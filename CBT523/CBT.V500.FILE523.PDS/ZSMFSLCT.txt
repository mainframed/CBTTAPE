         TITLE 'Assembly Variables'
         LCLC  &VERSION
&VERSION SETC  'V1.5'

         LCLC  &ASMDT
&ASMDT   SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)
SMFSLCT  TITLE 'Introduction'
*********************************************************************
*                                                                   *
*                 S  M  F  S  L  C  T                               *
*                                                                   *
*   This program will read SMF data (from the MAN datasets or output*
*  from IFASMFDP), and will select records according to user        *
*  specified criteria. Records can be selected by date and time,    *
*  by record type (and /or subtype), by Jobname, or by data at an   *
*  offset within the record. Records must meet date/time and        *
*  record type criteria before being eligible for selection, as     *
*  determined by Jobname and/or data specifications.                *
*                                                                   *
*   By default, any records selected from the input will be printed *
*  to SYSPRINT, unless 'PRINT=NO' is specified in the SYSIN control *
*  cards. If SYSUT2 is present, the selected input records will     *
*  also be written to it.                                           *
*                                                                   *
*   Multiple output files with different selection criteria can be  *
*  produced in one run of SMFSLCT. The output DDNames and selection *
*  criteria are specified in the control cards in SYSIN.            *
*                                                                   *
*   Two user-written exits can be used with SMFSLCT - the first     *
*  is given control after an SMF record is read, and the second     *
*  after an SMF record has been selected.                           *
*                                                                   *
*  Input:                                                           *
*      SYSUT1   - SMF dataset - either the output from IFASMFDP or  *
*                 one of the SYS1.MAN datasets. If this DDName is   *
*                 not allocated, it will be dynamically allocated to*
*                 the active SMF dataset.                           *
*      SYSIN    - Control cards (see below).                        *
*                                                                   *
*  Output:                                                          *
*      SYSPRINT - Error messages, selected SMF records.             *
*      SYSUT2   - optional, selected SMF records.                   *
*                                                                   *
*  Attributes:                                                      *
*      Re-entrant, Reuseable, Refreshable, Not Authorized,          *
*      AMODE(31), RMODE(ANY)                                        *
*                                                                   *
*  Coding    : All data areas in Dynamic Storage have names starting*
*   Notes       with '@'. One area of Dynamic Storage is acquired   *
*               during initialization, and is used as a LIFO stack  *
*               for dynamic storage.                                *
*              Conversely, data areas within the program (and thus  *
*               are read-only) have names that do not start with    *
*               an '@'.                                             *
*                                                                   *
*              The names of the Routines (and non-data labels within*
*               the routines) follow the pattern:                   *
*                 xnnnn                                             *
*               where x    is 1 or more alphabetic characters       *
*                     nnnn is a numeric sequence number             *
*                                                                   *
*              Data in dynamic storage that are globally accessible *
*               have names of the form:                             *
*                @_anyname                                          *
*              Data associated with a routine typically have names: *
*                 x_anyname or @x_anyname                           *
*               where 'x' is the alphabetic character associated    *
*                         with the routine                          *
*              Addressability to globally-accessible dynamic data is*
*               via R12; local dynamic data is addressable via R13. *
*                                                                   *
*              Each routine establishes it's own base register(s),  *
*               and has access only to it's own read-only variables.*
*               Base registers are typically R11.                   *
*                                                                   *
*  Sample Installation JCL:                                         *
*                                                                   *
*  //SMFSLCTA JOB blah,blah                                         *
*  //*                                                              *
*  //ASM     EXEC PGM=ASMA90,REGION=4M,                             *
*  //             PARM='NODECK,OBJECT,RENT,XREF(SHORT),NOALIGN'     *
*  //SYSPRINT  DD SYSOUT=*                                          *
*  //SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB                          *
*  //          DD DISP=SHR,DSN=SYS1.MODGEN                          *
*  //SYSUT1    DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),      *
*  //             UNIT=SYSALLDA                                     *
*  //SYSLIN    DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),           *
*  //             UNIT=SYSALLDA,DISP=(MOD,PASS),                    *
*  //             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB)              *
*  //SYSIN     DD DISP=SHR,DSN=source-program                       *
*  //*                                                              *
*  //LKED    EXEC PGM=HEWL,REGION=4M,COND=(0,LT),                   *
*  //             PARM='LIST,MAP,RENT,REUS,REFR'                    *
*  //SYSPRINT  DD SYSOUT=*                                          *
*  //SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)                       *
*  //          DD DDNAME=SYSIN                                      *
*  //SYSUT1    DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND)       *
*  //             UNIT=SYSALLDA                                     *
*  //SYSLMOD   DD DISP=SHR,DSN=loadlib                              *
*  //                                                               *
*                                                                   *
*  Change Log:                                                      *
*      1999/04/24 SDDA030 V1.1                                      *
*                 Added code to ignore records invalidly spanned    *
*                 in non-VSAM VBS input.                            *
*                 Calculated DCB=NCP (BSAM), DCB=BUFNO (QSAM), or   *
*                 AMP=BUFSP (VSAM) so we can read a cylinder of     *
*                 input at a time (if input on DASD).               *
*                 Used MACRF=PM on output file(s), so VBS datasets  *
*                 can be created.                                   *
*                 Lives and executes in 31-bit mode.                *
*                 Used internal LIFO stack for dynamic storage      *
*                 Made Y2K compliant!                               *
*      1999/07/22 SDDA030 V1.2                                      *
*                 Added Date conversion routines.                   *
*                 Added new START=/END= date keywords.              *
*                 Added 24-bit EODAD for SYSIN, if required         *
*      1999/11/18 SDDA030 V1.3                                      *
*                 Moved SYSUT1 OPEN logic(?) to its own subroutine  *
*                 (I0010)                                           *
*                 Added comments                                    *
*                                                                   *
*      2002/02/07 SDDA030 V1.4                                      *
*                 Added stack below the line.                       *
*                 Added new parms for exits as suggested by Dave    *
*                 Alcock.                                           *
*                 Added parms to INEXIT=/OUTEXIT= statements.       *
*                 Defaulted 2-digit years on START=/END= to the     *
*                 current century.                                  *
*                 Corrected S0C4 Abends when lots of record types   *
*                 or jobnames selected (Thanks to Paul              *
*                 Luttenberger).                                    *
*                 Changed RDJFCBs to SWAREQs.                       *
*                 Corrected logic when setting DCB characteristics  *
*                 for new output datasets with no DCB spacified.    *
*                 Printed **VIO** for volser when appropriate.      *
*      2006/10/26 SDDA030 V1.5                                      *
*                 Fixed bug when printing record subtypes to be     *
*                 selected (thanks to BBordonaro).                  *
*                 Corrected calculation of SYSPRINT LRECL (fixed    *
*                 check for CC) (thanks to Martin Samson).          *
*                 Corrected non-re-entrancy error with SYSUT1 EXLST *
*                 (thanks to Martin Samson - again!).               *
*                                                                   *
*  Author:                                                          *
*   All comments, criticisms and suggestions gratefully received.   *
*     Paul Dion  (pdion@canada.com)                                 *
*                                                                   *
*********************************************************************
         TITLE 'Control Cards'
*********************************************************************
*                                                                   *
*                 C o n t r o l   C a r d s                         *
*                                                                   *
*   Control cards are entered via SYSIN. Only columns 1-72 are      *
*  scanned, and the scan terminates with the first blank. Cont-     *
*  inuations are not allowed, but keywords can be specified more    *
*  than once. If a keyword that has a single value (ie, START=)     *
*  is specified more than once within an output group, or globally, *
*  the last value specified is used.                                *
*                                                                   *
*   OUTPUT=DDName                                                   *
*      specifies the DDName of an output dataset. All subsequent    *
*                control statements, until the next "OUTPUT="       *
*                statement or end-of-file, determine which input    *
*                records will be selected to this DDName. All       *
*                control statements appearing before an "OUTPUT="   *
*                statement apply to all output DDNames, unless      *
*                specifically overridden by control statements      *
*                entered after the "OUTPUT=" statement.             *
*                                                                   *
*   START=yyddd-hhmmss                                              *
*         yyyyddd-hhmmss                                            *
*         TODAY-hhmmss                                              *
*         (TODAY-n)-hhmmss                                          *
*         YESTERDAY-hhmmss                                          *
*         THISWEEK-hhmmss                                           *
*         LASTWEEK-hhmmss                                           *
*         THISMONTH-hhmmss                                          *
*         LASTMONTH-hhmmss                                          *
*      specifies the date and time at which selection of input      *
*                records is to start. Defaults to 00000-000000 (ie  *
*                the start of the input file). The specification of *
*                time (-hhmmss) is optional - if omitted, it def-   *
*                aults to 00:00:00.00.                              *
*                Dates using the 2-digit year format will default   *
*                to dates in the current century.                   *
*                YESTERDAY is equivalent to specifying (TODAY-1).   *
*                Note that a week starts on Monday, and ends on     *
*                Sunday. Thus, specifying START=LASTWEEK will start *
*                selecting records from the Monday of the previous  *
*                week.                                              *
*                                                                   *
*   END=yyddd-hhmmss                                                *
*       yyyyddd-hhmmss                                              *
*       TODAY-hhmmss                                                *
*       (TODAY-n)-hhmmss                                            *
*       YESTERDAY-hhmmss                                            *
*       THISWEEK-hhmmss                                             *
*       LASTWEEK-hhmmss                                             *
*       THISMONTH-hhmmss                                            *
*       LASTMONTH-hhmmss                                            *
*      specifies the date and time at which selection if input      *
*                records is to stop. Defaults to 2699999-235959 (ie *
*                the end of the input file). The specification of   *
*                time (-hhmmss) is optional - if omitted, it def-   *
*                aults to 23:59:59.99.                              *
*                Dates using the 2-digit year format will default   *
*                to dates in the current century.                   *
*                YESTERDAY is equivalent to specifying (TODAY-1).   *
*                Note that a week starts on Monday, and ends on     *
*                Sunday. Thus, specifying END=LASTWEEK will stop    *
*                selecting records on the Sunday of the previous    *
*                week.                                              *
*                                                                   *
*   PERIOD=hhmmss-hhmmss                                            *
*      specifies the start and stop time-of-day between which input *
*                records will be eligible for selection. Records for*
*                each day, as specified by start/end or defaulted,  *
*                falling outside these times will be ignored.       *
*                 The time can be specified as hh, hhmm or hhmmss;  *
*                the missing digits will default to 0.              *
*                 Defaults to "PERIOD=000000-240000".               *
*                                                                   *
*   WEEKENDS=IGNORE                                                 *
*      specifies that SMF data generated on Saturday and Sunday will*
*                be ignored.                                        *
*                                                                   *
*   INCLUDE=nn<(ss)>                                                *
*      specifies that record type nn should be selected. A subtype  *
*                ss can also be optionally included, in parentheses.*
*                If more that one record type is coded on the       *
*                control card, the record types (and subtypes)      *
*                must be enclosed in parentheses.                   *
*                SMF Record Type 30 is used as a model to determine *
*                the SubType location.                              *
*                Note that 'INCLUDE' is mutually exclusive with the *
*                'EXCLUDE' keyword within an "OUTPUT=" definition,  *
*                or globally, if no "OUTPUT=" statement is present. *
*                                                                   *
*   EXCLUDE=nn<(ss)>                                                *
*      specifies that record type nn should not be selected. A      *
*                subtype ss can optionally be included, in paren-   *
*                theses. If more than one record type is coded,     *
*                the record types (and subtypes) and subtypes must  *
*                be enclosed in parentheses.                        *
*                Note that 'EXCLUDE' is mutually exclusive with the *
*                'INCLUDE' keyword within an "OUTPUT=" definition,  *
*                or globally, if no "OUTPUT=" statement is present. *
*                                                                   *
*   PRINT=NO                                                        *
*   PRINT=EBCDIC                                                    *
*         NO     specifies that selected records are not to be      *
*                printed on SYSPRINT. If an output ddname is        *
*                present, selected records will be written to it.   *
*         EBCDIC specifies that selected records are to be printed  *
*                on SYSPRINT in EBCDIC only (the default is dump    *
*                format). If an output ddname is present, the       *
*                selected records will be written to it.            *
*                                                                   *
*   SEQUENCE=YES                                                    *
*                specifies that the input records are in date/time  *
*                sequence. If 'SEQUENCE=YES' is specified, SMFSLCT  *
*                will terminate as soon as a record with a date     *
*                stamp past the 'END=' date/time is encountered.    *
*                Normal SMFSLCT processing assumes that the input   *
*                records are not in sequence, and invokes           *
*                termination at end-of-file.                        *
*                                                                   *
*   CHECKVBS=NO                                                     *
*                specifies that no checking should be performed for *
*                variable spanned segmentation errors. If this      *
*                is specified, QSAM will be used to read SYSUT1,    *
*                and invalid segment sequences will cause an S002   *
*                (or potentially other system) abend. The default   *
*                is that BSAM will be used to read VS or VBS files, *
*                and invalid segments discarded.                    *
*                Note that using BSAM requires more CPU time; where *
*                the input file is known to be 'clean', specifying  *
*                CHECKVBS=NO will reduce the CPU time used by this  *
*                program.                                           *
*                                                                   *
*   JOBNAME=jjjjjjjj                                                *
*      specifies that all records (subject to "INCLUDE"/"EXCLUDE",  *
*                above), Job (or TSU or STC) jjjjjjjj should be     *
*                selected.                                          *
*                If more that one jobname is coded, the jobnames    *
*                should be enclosed in parentheses.                 *
*                 If the last character in the jobname is an        *
*                asterisk, the characters preceeding the asterisk   *
*                considered a prefix, and all jobnames that match   *
*                the prefix will be selected.                       *
*                SMF Record Type 5 is used as a model to determine  *
*                the location of the Jobname field.                 *
*                                                                   *
*   DATA=xxx<,nn>                                                   *
*      specifies the character string that must be present in the   *
*                input record before it will be selected.           *
*                DATA= indicates that the string xxx (specified     *
*                      either as a data(xxx...x), a character string*
*                      (C'xxx...x) or a hex string(X'xxx...x)) must *
*                      start at offset position nn (nn=0-32767,     *
*                      default=0), for the input record to be       *
*                      selected. Note that the offset must include  *
*                      the length of the RDW.                       *
*                                                                   *
*   JOB/DATA=OR                                                     *
*      specifies that the selection algorithm should select an      *
*                      input record if either the Jobname or data   *
*                      specifications are met. The default is that  *
*                      both Jobname and data criteria must be       *
*                      satisfied before a record will be selected.  *
*                                                                   *
*   STOPAFT=nnn                                                     *
*      specifies that SMFSLCT is to terminate after selecting nnn   *
*                      records (nnn = 1 to 999999999). The default  *
*                      is to terminate when end-of-file is reached  *
*                      on input.                                    *
*                                                                   *
*   INEXIT=(member-name<,parm>)                                     *
*      specifies that SMFSLCT is to invoke member-name after        *
*                      each SMF record is read from the input, and  *
*                      after checking the date/time against "START="*
*                      and "END=", but before checking any other    *
*                      selection criteria.                          *
*                      "parm" is an optional string that will be    *
*                      passed to the exit each time it is invoked.  *
*                      If present, the operands of INEXIT= must     *
*                      be enclosed in parentheses. Further, if parm *
*                      contains a close parenthesis, it must be     *
*                      enclosed in quotes (as per IBM, if parm also *
*                      contains a quote, it must be coded as two    *
*                      two consecutive quotes).                     *
*                                                                   *
*   OUTEXIT=(member-name<,parm>)                                    *
*      specifies that SMFSLCT is to invoke member-name after        *
*                      an SMF record has been selected, but before  *
*                      the record is printed and/or written to the  *
*                      output file(s).                              *
*                      "parm" is an optional string that will be    *
*                      passed to the exit each time it is invoked.  *
*                      If present, the operands of OUTEXIT= must    *
*                      be enclosed in parentheses. Further, if parm *
*                      contains a close parenthesis, it must be     *
*                      enclosed in quotes (as per IBM, if parm also *
*                      contains a quote, it must be coded as two    *
*                      two consecutive quotes).                     *
*                                                                   *
*  Example:                                                         *
*  //SMFSLCT  JOB blah,blah                                         *
*  //STEP1   EXEC PGM=SMFSLCT,REGION=6M                             *
*  //STEPLIB   DD DISP=SHR,DSN=if-required                          *
*  //SYSPRINT  DD SYSOUT=*                                          *
*  //SYSUT1    DD DISP=unloaded-man-file,DISP=SHR                   *
*  //OUT1      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *
*  //             DSN=output-file1,SPACE=(blah,blah),               *
*  //             DCB=(blah,blah)                                   *
*  //OUT2      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *
*  //             DSN=output-file1,SPACE=(blah,blah),               *
*  //             DCB=(blah,blah)                                   *
*  //OUT3      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *
*  //             DSN=output-file1,SPACE=(blah,blah),               *
*  //             DCB=(blah,blah)                                   *
*  //SYSIN     DD *                                                 *
*  START=87015,END=87017-170000                                     *
*  OUTPUT=OUT1                                                      *
*   INCLUDE=(30(2),20,5)                                            *
*   JOBNAME=JOBONE                                                  *
*   PRINT=NO                                                        *
*  OUTPUT=OUT2                                                      *
*   START=87013-081500,END=87013-170000                             *
*   INCLUDE=34                                                      *
*   JOBNAME=(TSO1,TSO2)                                             *
*  OUTPUT=OUT3                                                      *
*   DATA=C'A B C',257                                               *
*   OUTEXIT=EXIT5                                                   *
*  /*                                                               *
*                                                                   *
*       SMFSLCT will read the unloaded MAN file specified by SYSUT1.*
*       Note that if SYSUT1 were not specified, the active MAN      *
*       file would be read.                                         *
*       SMFSLCT will ignore any input records produced before       *
*       00:00:00 on 87.015, and terminate after finding a record    *
*       produced after 17:00:00 on 87.017.                          *
*       For the output file specified by DDName OUT1:               *
*        Record types 5, 20, and 30 subtype 2, for Jobs with the    *
*        name "JOBONE" will be selected, but not printed.           *
*       For the output file specified by DDName OUT2:               *
*        Record type 34 for Jobs (TSO users) with the names "TSO1"  *
*        or "TSO2" will be selected, and printed.                   *
*        The global date specification is overridden for this       *
*        output file only.                                          *
*       For the output file specified by DDName OUT3:               *
*        All records containing the character string "A B C" in     *
*        positions 257-261 (relative to 0, including the RDW) will  *
*        be selected and printed. The exit "EXIT5" will be invoked  *
*        for each record selected for "OUT3"                        *
*                                                                   *
*       Note that the selection criteria for the different output   *
*       files are indented: this is for readability only - SMFSLCT  *
*       ignores leading blanks.                                     *
*                                                                   *
*********************************************************************
         TITLE 'Processing Overview'
*********************************************************************
*                                                                   *
*          P r o c e s s i n g   O v e r v i e w                    *
*                                                                   *
*  Initialization.                                                  *
*     SMFSLCT first opens SYSPRINT - if this file cannot be OPENed  *
*    SMFSLCT terminates immediately. SYSIN statements (if present)  *
*    are then read and interpreted. Assuming there were             *
*    no control card errors, an OPEN is attempted for SYSUT1.       *
*    If this fails, SYSUT1 is dynamically allocated to the active   *
*    SMF file, and OPENed. Next, the JFCB for each output DDName is *
*    read. If the output file is NEW, and DCB characteristics are   *
*    not present in the JFCB, SMFSLCT assigns the RECFM, LRECL and  *
*    BLKSIZE from SYSUT1 (if SYSUT1 is a VSAM dataset, RECFM=VBS,   *
*    LRECL=32767, BLKSIZE=4096 are assigned as a default). If the   *
*    output dataset is OLD or SHR, no DCB changes are made.         *
*     If exits were specified, SMFSLCT 'LOAD's them, and saves      *
*    their EP addresses.                                            *
*                                                                   *
*  Processing.                                                      *
*     A record is read from SYSUT1, and, as long as it is not a dump*
*    header or trailer (record type 2 or 3), it is checked against  *
*    the start and stop times. If it is before the start time, the  *
*    record is ignored, and the next record is read. If it is after *
*    the stop time, termination is initiated.                       *
*     After the start and stop time checks, the INEXIT (if present) *
*    is invoked. If the exit indicates that this record should be   *
*    selected (RC=4), all further checks are bypassed. If the exit  *
*    indicates the record should be skipped (RC=8), the record is   *
*    ignored. If the exit indicates that SMFSLCT should terminate,  *
*    the stop date and time is set to 0, so that the next input     *
*    record will cause termination to be invoked. If the exit is    *
*    not present, or indicates that normal processing should cont-  *
*    inue (RC=0), the selection criteria are checked.               *
*     The first selection check is record type (INCLUDE=/EXCLUDE=). *
*    If the record passes this check, the job name criteria         *
*    (JOBNAME=) is checked. If the SMF record does not 'belong' to  *
*    one of the Jobnames specified in the control cards (assuming   *
*    that at least one Jobname was entered), the record is skipped, *
*    unless JOB/DATA=OR was specified. If it was, or the SMF record *
*    passed the Jobname check, the data criteria (DATA=) are exam-  *
*    ined. If the data specified are present in the SMF record, the *
*    record will be selected.                                       *
*     Once an input record is selected, the output exit (OUTEXIT=), *
*    if present, is invoked. This exit can indicate that the record *
*    should be ignored (RC=8), that processing should terminate     *
*    after this record (RC=12), or that normal processing should    *
*    continue (RC=0).                                               *
*     A selected record is first printed (unless PRINT=NO was       *
*    specified in the control cards), either in the default dump    *
*    format, or in EBCDIC only (PRINT=EBCDIC). Then, if output files*
*    are open, the selected record is written to them. The output   *
*    record length is checked against the input, and the input rec- *
*    ord truncated or padded with blanks as appropriate. If the     *
*    output RECFM is fixed, the SMF record is written without the   *
*    RDW.                                                           *
*                                                                   *
*  Termination.                                                     *
*     Termination is invoked either because an input SMF record's   *
*    date and time is greater than the stop date and time, or       *
*    because EOF was reached on the input file. The counters are    *
*    printed, and all open files are closed. The exits are invoked  *
*    one last time, and then deleted. All getmained storage is      *
*    freed, and standard exit code is executed to return to OS.     *
*                                                                   *
*********************************************************************
         TITLE 'User Exits'
*********************************************************************
*                                                                   *
*     SMFSLCT has provision for two exits that will be invoked      *
*    after a record is read, or a record is about to be written.    *
*    Each exit receives the address of the SMF record as a parm.    *
*    The exits can cause the SMF record to be selected or ignored   *
*    (via the return codes), or can modify (or replace) the SMF     *
*    record. The only restriction is that the record returned to    *
*    SMFSLCT must remain a valid variable-length record.            *
*                                                                   *
*     SMFSLCT also provides to each exit a word of storage that the *
*    exit can use in any manner whatsoever - SMFSLCT will not alter *
*    the contents of this word (other than to initialize it to 0    *
*    before the first invocation of the exit).                      *
*                                                                   *
*     The exits are LOADed at initialization, invoked via a BASR    *
*    instruction at various points in the processing, and then      *
*    DELETEd during termination. 'Global' exits (those that are     *
*    named by INEXIT=/OUTEXIT= statements before any OUT= statement)*
*    are LOADED only once; 'local' exits (those named after an      *
*    OUT= statement, even if they are the same as the 'global'      *
*    exits) are LOADed for each output statement. Thus, if an exit  *
*    is not reusable, there may be multiple versions LOADed and     *
*    invoked.                                                       *
*                                                                   *
*     The names of the exits are specified with the "INEXIT=" and   *
*    "OUTEXIT=" control statement keywords (see above). The exits   *
*    are invoked once for each output file, at 3 different points:  *
*      Initialization: A(SMF Record) = 0                            *
*                      Input count = -1                             *
*      Processing    : A(SMF Record) > 0                            *
*      Termination   : A(SMF Record) = 0                            *
*                      Input Count >= 0                             *
*                                                                   *
*     The parms passed to the exits are the same for both INEXIT    *
*    and OUTEXIT (all parameters reside below-the-line):            *
*        R1 ---> A(SMF record) or 0                                 *
*                                                                   *
*                A(A word for the user)                             *
*                  This word is 'output-file specific'; that is,    *
*                  the same word will be passed to the INEXIT and   *
*                  the OUTEXIT for the same output file (ie, when   *
*                  the 6th parm, the address of the DDName, is      *
*                  pointing to the same value). For different output*
*                  files, a different word is passed.               *
*                                                                   *
*                A(HL2'length', parm as coded on the xxxEXIT=       *
*                  statement. Note that the length is the length of *
*                  the parm, and that any quotes surrounding the    *
*                  parm have been removed)                          *
*                                                                   *
*                A(Fullword containing input count)                 *
*                                                                   *
*                A(Fullword containing output count)                *
*                                                                   *
*                A(DDName of output file)                           *
*                                                                   *
*                A(SYSPRINT routine. This routine can be invoked to *
*                  cause SMFSLCT to write a record to SYSPRINT. If  *
*                  this routine is invoked,                         *
*                   R1 : A(2-word parmlist):                        *
*                          A(Data to be printed)                    *
*                          Length of data to be printed             *
*                   R13: A(Standard 72-byte O/S save area)          *
*                   R14: Return Address                             *
*                   R15: EPA                                        *
*                  This routine is also IDENTIFYed as SMFSLCTP, and *
*                 so can be CALLed, LINKed, etc.                    *
*                                                                   *
*  INEXIT.                                                          *
*     The input exit is specified using the "INEXIT=" control       *
*    statement keyword, and is invoked after each SMF record is     *
*    read and determined to be within the start and end times       *
*    specified in the control cards ("START=", "END="). The exit    *
*    receives the address of the SMF record as a parm, and can      *
*    modify the contents of the record, if required. If the exit    *
*    wishes to replace the SMF record with another, the exit can    *
*    change the address in the pointer to the SMF record so that it *
*    points to a different area of storage, containing the new SMF  *
*    record.                                                        *
*     Note that the input exit is invoked (perhaps non-intuitively) *
*    for each output file.                                          *
*                                                                   *
*     On Exit,                                                      *
*        R15  =  0, Continue normal processing                      *
*                4, Unconditionally select this record              *
*                8, Ignore this record                              *
*               12, Terminate SMFSLCT after this record             *
*                                                                   *
*  OUTEXIT.                                                         *
*     The output exit is specified using the "OUTEXIT=" control     *
*    statement keyword, and is invoked after an SMF record has been *
*    selected (because it satisfied selection criteria, or it was   *
*    unconditionally selected by the input exit). The exit          *
*    receives the address of the SMF record as a parm, and can      *
*    modify the contents of the record, if required. If the exit    *
*    wishes to replace the SMF record with another, the exit can    *
*    change the address in the pointer to the SMF record so that it *
*    points to a different area of storage, containing the new SMF  *
*    record.                                                        *
*     On Exit,                                                      *
*        R15  =  0, Continue normal processing                      *
*                4, Unused                                          *
*                8, Ignore this record                              *
*               12, Terminate SMFSLCT after this record             *
*                                                                   *
*********************************************************************
         TITLE 'STACK Macro'
         MACRO
&NAME    STACK &TYPE,&LOC=,&LEN=,&STACK=,&ADDR=
         LCLC  &LENREG,&STKREG,&ADDREG,&LOCTN
         AIF   ('&TYPE(1)' EQ 'PUSH').PUSH01
         AIF   ('&TYPE(1)' EQ 'POP').POP01
         AIF   ('&TYPE(1)' EQ 'INIT').INIT01
         AIF   ('&TYPE(1)' EQ 'TERM').TERM01
         MNOTE 8,'TYPE must be INIT, PUSH, POP, or TERM'
         AGO   .MEND
.*
.INIT01  ANOP
         AIF   ('&LEN' EQ '').INITE01
         AIF   ('&LEN'(1,1) NE '(').INIT02
&LENREG  SETC  '&LEN(1)'
         AIF   ('&LENREG' NE  '1').INIT03
         MNOTE 8,'LEN= register must be 0 or 2-15'
         AGO   .MEND
         AGO   .INIT03
.INIT02  ANOP
&LENREG  SETC  'R0'
         LA    &LENREG,&LEN Length of Stack
.INIT03  ANOP
&LOCTN   SETC  '&LOC'
         AIF   ('&LOC' NE '').INIT04
&LOCTN   SETC  'ANY'
.INIT04  ANOP
         LA    R1,StackHdr_Length       Length of header
         AR    &LENREG,R1               Bump length
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(&LENREG),         this long                     +
               LOC=&LOCTN                anywhere
         ST    R0,StackHdr_StackLen-StackHdr(0,R1) Save length
         LA    R0,StackHdr_Length(0,R1) A(Current top of stack)
         ST    R0,StackHdr_NAB-StackHdr(0,R1) Save A(Next Avail Byte)
         AIF   ('&STACK' EQ '').INIT99
         AIF   ('&STACK'(1,1) EQ '(').INIT92
         ST    R1,&STACK                Save Stack origin
         AGO   .INIT99
.INIT92  ANOP
         LR    &STACK(1),R1             Load return register
         AGO   .INIT99
.INIT99  ANOP
         AIF   (D'Stack).MEND
Stack               DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   This is a LIFO stack that is used by various procedures in the  *
*  program to acquire storage. The Stack is GETMAINed at the beg-   *
*  inning of the program, and is typically used by procedures to    *
*  acquire storage for local variables (i.e., variables that are    *
*  used only within the procedures), although the main procedure    *
*  also uses a stack area to store Global variables (i.e., those    *
*  that are available throughout the program).                      *
*                                                                   *
*-------------------------------------------------------------------*

StackHdr            EQU   *           Start of Header
StackHdr_StackLen   DS    FL4          Length of Stack
StackHdr_NAB        DS    AL4          A(Next Available Byte in Stack)
StackHdr_Length     EQU   *-StackHdr  Length of Header

&SYSECT  &SYSSTYP
         AGO   .MEND
.INITE01 ANOP
         MNOTE 8,'LEN must be specified for STACK INIT'
         AGO   .MEND
.*
.PUSH01  ANOP
         AIF   ('&STACK' EQ '').PUSM02
         AIF   ('&STACK'(1,1) NE '(').PUSH01A
&STKREG  SETC  '&STACK(1)'
         AGO   .PUSH02
.PUSH01A ANOP
&STKREG  SETC  'R15'
         L     &STKREG,&STACK           A(Stack Origin)
.PUSH02  ANOP
         AIF   ('&LEN' EQ '').PUSHE01
         AIF   ('&LEN'(1,1) NE '(').PUSH03
&LENREG  SETC  '&LEN(1)'
         AGO   .PUSH04
.PUSH03  ANOP
&LENREG  SETC  'R0'
.PUSH04  ANOP
         LA    &LENREG,&LEN
         LA    R1,7                     Make
         AR    &LENREG,R1                a
         SRL   &LENREG,3                 doubleword
         SLL   &LENREG,3                 multiple
         L     R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)
         AR    R1,&LENREG               Bump by length requested
         SLR   R1,&STKREG               Get Stack used
         C     R1,StackHdr_StackLen-StacKHdr(0,&STKREG) Too much?
         BL    *+8                      No, OK
         BAL   R14,0                    ABEND
         ALR   R1,&STKREG               No, offset to address
         ST    R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)
         SLR   R1,&LENREG               A(Start of storage area)
         AIF   ('&ADDR' EQ '').MEND
         AIF   ('&ADDR'(1,1) NE '(').PUSH92
         LR    &ADDR(1),R1             Load return register
         AGO   .MEND
.PUSH92  ANOP
         ST    R1,&ADDR                 Save Stack origin
         AGO   .MEND
.PUSHE01 ANOP
         MNOTE 8,'LEN must be specified for STACK PUSH'
         AGO   .MEND
.PUSHE02 ANOP
         MNOTE 8,'STACK must be specified for STACK PUSH'
         AGO   .MEND
.*
.POP01   ANOP
         AIF   ('&ADDR' EQ '').POPE01
         AIF   ('&ADDR'(1,1) NE '(').POP02
&ADDREG  SETC  '&ADDR(1)'
         AGO   .POP02A
.POP02   ANOP
&ADDREG  SETC  'R0'
         L     &ADDREG,&ADDR
.POP02A  ANOP
         AIF   ('&STACK' EQ '').POPE02
         AIF   ('&STACK'(1,1) NE '(').POP03
&STKREG  SETC  '&STACK(1)'
         AGO   .POP04
.POP03   ANOP
&STKREG  SETC  'R15'
         L     &STKREG,&STACK           A(Stack Origin)
.POP04   ANOP
         ST    &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)
         AGO   .MEND
.POPE01  ANOP
         MNOTE 8,'ADDR must be specified for STACK POP'
         AGO   .MEND
.POPE02  ANOP
         MNOTE 8,'STACK must be specified for STACK POP'
         AGO   .MEND
.*
.TERM01  ANOP
         AIF   ('&STACK' EQ '').TERME02
         AIF   ('&STACK'(1,1) NE '(').TERM03
&STKREG  SETC  '&STACK(1)'
         AGO   .TERM04
.TERM03  ANOP
&STKREG  SETC  'R15'
         L     &STKREG,&STACK           A(Stack Origin)
.TERM04  ANOP
         L     R0,StackHdr_StackLen-StackHdr(0,&STKREG) Length
         STORAGE RELEASE,               Free our storage               +
               ADDR=(&STKREG),           starting here                 +
               LENGTH=(0)                for this long
         AGO   .MEND
.TERME02 ANOP
         MNOTE 8,'STACK must be specified for STACK TERM'
         AGO   .MEND
.*
.MEND    ANOP
         MEND
         TITLE 'IBM DSECTs'
         PUSH  PRINT
         PRINT NOGEN
         CVT   DSECT=YES
         IKJTCB
         IEFTIOT1
         IEESMCA
         IEFJFCBN
         DCBD  DSORG=PS
         IHADCBE
         IHADVA
         IEFUCBOB DEVCLAS=DA,LIST=NO
         IEFZB505 LOCEPAX=YES
         IEFJESCT
         IEFQMIDS
         IFASMFR (0,5,30)
         IFGACB
SYSUT1_ACB_Length EQU   *-IFGACB      Length of ACB
         IFGRPL
SYSUT1_RPL_Length EQU   *-IFGRPL      Length of RPL
         IEFZB4D0
         IEFZB4D2
         POP   PRINT
         TITLE 'Local DSECTs'
OutDesc_Tbl         DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   The Output Descriptor Table contains one entry for each output  *
*  file specified (in the "OUTPUT=" control card). Each entry is    *
*  initialized with the default parameters, and then modified with  *
*  the parameters entered via control cards. The first entry con-   *
*  tains the default parms, and is used as the "global" entry.      *
*                                                                   *
*-------------------------------------------------------------------*

ODT_SubPool_Nbr     EQU   0           Subpool for this table
ODT_Subp_Len        DS    0F          Length and Subpool of table
ODT_SubPool         DS    X            SubPool
ODT_Length          DS    FL3          Length
ODT_Entry_Count     DS    HL2         Nbr entries in the table
ODT_Entry           EQU   *           Table Entry

*-------------------------------------------------------------------*
*                                                                   *
*    Output Descriptor Entry. There is one entry for each output    *
*   file (defined using the "OUTPUT=" statement), plus one entry    *
*   (the first) used as a default entry.                            *
*                                                                   *
*-------------------------------------------------------------------*

ODTE_DCB_Ptr        DS    AL4          A(Output DCB)
ODTE_DDName         DS    CL8          Associated DDName
ODTE_RTT_Ptr        DS    AL4          A(Record Type Table)
ODTE_JNT_Ptr        DS    AL4          A(JobName Table)
ODTE_DT_Ptr         DS    AL4          A(Data Table)
ODTE_Selected       DS    FL4          Nbr Records Selected
ODTE_StopAft        DS    FL4          Stop after selecting this many
ODTE_InExit         DS    CL8          Input Exit Name
ODTE_InExit_Ptr     DS    AL4          A(Input Exit)
ODTE_InExit_Data    DS    FL4          Input Exit Data Area
ODTE_InExit_Parm_Ptr DS   AL4          A(Parm data for InExit)
ODTE_OutExit        DS    CL8          Output Exit Name
ODTE_OutExit_Ptr    DS    AL4          A(Output Exit)
ODTE_OutExit_Data   DS    FL4          Output Exit Data Area
ODTE_OutExit_Parm_Ptr DS  AL4          A(Parm data for OutExit)
ODTE_LRECL          DS    HL2          Max Output Record Length
ODTE_StartDate      DS    PL4          Start Date
ODTE_StartTime      DS    FL4            and Time
ODTE_EndDate        DS    PL4          End Date
ODTE_EndTime        DS    FL4            and Time
ODTE_PeriodStart    DS    FL4          Period Start Time
ODTE_PeriodEnd      DS    FL4          Period End Time
                    DS    X            Flag Byte
ODTE_Print_NO       EQU   *-1,X'80'     1... .... PRINT=NO Specified
ODTE_Print_EB       EQU   *-1,X'40'     .1.. .... PRINT=EBCDIC Spec
ODTE_JobData_OR     EQU   *-1,X'20'     ..1. .... JOB/DATA=OR
ODTE_Trunc          EQU   *-1,X'10'     ...1 .... Output Rec Truncated
ODTE_CopyOnly       EQU   *-1,X'08'     .... 1... No selection criteria
ODTE_Inactive       EQU   *-1,X'04'     .... .1.. Inactive Entry
ODTE_Ignore_Weekend EQU   *-1,X'02'     .... ..1. WEEKEND=IGNORE
                    DS    X            Flag Byte
ODTE_No_Dflt_InExit EQU   *-1,X'80'     1... .... Do not use default
ODTE_No_Dflt_OutExit EQU  *-1,X'40'     .1.. .... Do not use default

ODTE_Output_Count_Table DS  256FL4     Selected count by record type

ODTE_Length         EQU   *-ODT_Entry  Entry Length



JobName_Tbl         DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   The JobName Table is built when it is determined that the user  *
*  wishes to select input records by jobname. The table             *
*  consists of a header portion (describing the table as a whole),  *
*  and then one entry for each valid jobname control card found.    *
*                                                                   *
*-------------------------------------------------------------------*

JNT_Subp_Len        DS    0F          LENGTH AND SUBPOOL OF TABLE
JNT_Subpool         DS    X            SUBPOOL
JNT_Length          DS    FL3          LENGTH
JNT_Entry_Count     DS    HL2          NBR ENTRIES IN THE TABLE
JNT_Entry           EQU   *            DATA ENTRY
JNTE_JobName_Len    DS    X             EXECUTE LENGTH OF JOBNAME/PFX
JNTE_JobName        DS    CL8           JOBNAME, PADDED WITH BLANKS
JNTE_Length         EQU   *-JNT_Entry



RecType_Tbl         DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   THE RECORD TABLE IS BUILT WHEN IT IS DETERMINED THAT THE USER   *
*  WISHES TO INCLUDE OR EXCLUDE RECORDS BY RECORD TYPE. EACH ENTRY  *
*  CONSISTS OF TWO BYTES, A RECORD TYPE AND A SUBTYPE. All entries  *
*  are either 'INCLUDE's or 'EXCLUDE's, as indicated by a flag in   *
*  the header of the table.                                         *
*                                                                   *
*-------------------------------------------------------------------*

RTT_Subp_Len        DS    0F          LENGTH AND SUBPOOL OF TABLE
RTT_Subpool         DS    X            SUBPOOL
RTT_Length          DS    FL3          LENGTH
RTT_Entry_Count     DS    HL2         NBR ENTRIES IN TABLE
                    DS    X           Flag byte
RTT_Entry_Include   EQU   *-1,X'80'    1... .... INCLUDE=
RTT_Entry_Exclude   EQU   *-1,X'40'    .1.. .... EXCLUDE=
                    DS    X           Reserved
RTT_Entry           EQU   *           RECORD TABLE ENTRY
RTTE_RecType        DS    X            RECORD TYPE
                    DS    X            Flag Byte
RTTE_SubType_Present EQU  *-1,X'80'     1... .... Subtype present
RTTE_SubType        DS    XL2          SUBTYPE
RTTE_Length         EQU   *-RTT_Entry Entry length



Data_Tbl            DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   The Data Table is built when it is determined that the user     *
*  wishes to select input records by data in the record. The table  *
*  consists of a header portion (describing the table as a whole),  *
*  and then one entry for each valid 'data' control statement       *
*  found, containing:                                               *
*                     - the offset at which the data must be found  *
*                       before the record will be selected,         *
*                     - the execute length of the data, and         *
*                     - the data.                                   *
*                                                                   *
*-------------------------------------------------------------------*

DT_Subp_Len         DS    0F          LENGTH AND SUBPOOL OF TABLE
DT_Subpool          DS    X            SUBPOOL
DT_Length           DS    FL3          LENGTH
DT_Entry_Count      DS    HL2         NBR ENTRIES IN THE TABLE
DT_Entry            EQU   *           DATA ENTRY
DTE_Offset          DS    HL2          OFFSET OF DATA
DTE_Length          DS    X            EXECUTE LENGTH OF DATA
DTE_Data            EQU   *            DATA


BuffArea            DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   The Buffer Area is used only when SYSUT1 is VS or VBS, and      *
*  non-VSAM. Under these circumstances, we use BSAM to read blocks  *
*  of SYSUT1, and assemble the records ourselves, so we can discard *
*  any invalidly-spanned segments.                                  *
*                                                                   *
*-------------------------------------------------------------------*

BuffArea_Next_Ptr   DS    AL4         A(Next Buffer Area)
BuffArea_DECB_Ptr   DS    AL4         A(DECB - Below-the-Line)
BuffArea_Offset     DS    FL4         Offset within BuffArea_IOArea
BuffArea_Seg_Count  DS    FL4         Segment nbr in curr block
BuffArea_IOArea     EQU   *           I/O Area for Read
BuffArea_Hdr_Length EQU   *-BuffArea  Length of Header info



DateConv_Area       DSECT

*-------------------------------------------------------------------*
*                                                                   *
*   This DSECT describes the Date Conversion parameters used to     *
*  make SMF Dates and Times useable                                 *
*                                                                   *
*-------------------------------------------------------------------*

                    DS    X           Input Descriptor Flag
DConv_Input_Julian  EQU   *-1,X'80'    1... .... Input in YYYY and DDD
DConv_Input_Base    EQU   *-1,X'40'    .1.. .... Input in Base date
DConv_Input_YYMMDD  EQU   *-1,X'20'    ..1. .... Input in YYYY,MM,DD
DConv_Input_YYMonDD EQU   *-1,X'10'    ...1 .... Input in YYYY,Month,DD
DConv_Input_SMFDate EQU   *-1,X'08'    .... 1... Input in SMFDate
DConv_Input_Time    EQU   *-1,X'02'    .... ..1. Input in Time
DConv_Input_hhmmss  EQU   *-1,X'01'    .... ...1 Input in hh, mm, ss

DConv_Date_SMFDate  DS    PL4         SMF Date Stamp
DConv_Date_YYYY     DS    HL2         Year (including century)
DConv_Date_DDD      DS    HL2         Day-of-year
DConv_Date_Base     DS    FL4         Days since Jan1,0001 (a la REXX)
DConv_Date_MM       DS    XL1         Month number (1-12)
DConv_Date_DD       DS    XL1         Day-of-month (1-31)
DConv_Date_Month    DS    CL9         Month name (January, February ..)
DConv_Date_Day      DS    CL9         Day Name (Monday, Tuesday, etc.)
DConv_Date_DOW      DS    XL1         Day-of-week (Mon=0, Tue=1, etc.)

DConv_Time          DS    FL4         Time (secs*100 since midnight)
DConv_Time_hh       DS    XL1         Hours       (0-23)
DConv_Time_mm       DS    XL1         Minutes     (0-59)
DConv_Time_ss       DS    XL1         Seconds     (0-59)
DConv_Time_tt       DS    XL1         Seconds/100 (0-99)
DConv_Area_Length   EQU   *-DateConv_Area  Length of area

         TITLE 'Global Dynamic Storage'
@_Dynam  DSECT

@_31Bit_Stack_Ptr   DS    AL4         A(Stack storage above-the-line)
@_31Bit_Stack_Len   EQU   4096-StackHdr_Length  4K Stack

@_24Bit_Stack_Ptr   DS    AL4         A(Stack storage below-the-line)
@_24Bit_Stack_Len   EQU   2048-StackHdr_Length  2K Stack

*-------------------------------------------------------------------*
*                                                                   *
*    SYSPRINT-related info                                          *
*                                                                   *
*-------------------------------------------------------------------*

@_SYSPRINT_DCB_Ptr  DS    AL4         A(SYSPRINT DCB)
@_SYSPRINT_Rec_Ptr  DS    AL4         A(SYSPRINT RECORD)
@_SYSPRINT_Rec_Len  DS    HL2         SYSPRINT RECORD LENGTH (LESS ASA)
@_SYSPRINT_Y0010_Ptr DS   AL4         A(Copy of Y0010)

*-------------------------------------------------------------------*
*                                                                   *
*    SYSUT1-related info                                            *
*                                                                   *
*-------------------------------------------------------------------*

                    DS    0F
@_SYSUT1_DCB_Ptr    DS    AL4         A(SYSUT1 DCB)
                    ORG   @_SYSUT1_DCB_Ptr
@_SYSUT1_ACB_Ptr    DS    AL4         A(SYSUT1 ACB)
                    ORG   ,
@_SYSUT1_Rec_Ptr    DS    AL4         A(Input record)
@_SYSUT1_AtL_Ptr    DS    AL4         A(Above-the-line storage)
@_SYSUT1_BtL_Ptr    DS    AL4         A(Below-the-line storage)
@_SYSUT1_Rec_Length DS    FL4         Input record length
@_SYSUT1_BuffArea_Ptr DS  AL4         A(Current buffer area - BSAM)
@_SYSUT1_PBlock_Count DS  FL4         Physical Block Count - BSAM
                    ORG   @_SYSUT1_BuffArea_Ptr
@_SYSUT1_RPL_Ptr    DS    AL4         A(SYSUT1 RPL - VSAM)
                    ORG   ,

                    DS    X           Flag byte
@_SYSUT1_VSAM       EQU   *-1,X'80'    1... .... SYSUT1:  VSAM
@_SYSUT1_QSAM       EQU   *-1,X'40'    .1.. .... SYSUT1:  QSAM
@_SYSUT1_BSAM       EQU   *-1,X'20'    ..1. .... SYSUT1:  BSAM
@_SYSUT1_Sequence   EQU   *-1,X'10'    ...1 .... Input is in sequence
@_SYSUT1_NoVBSChk   EQU   *-1,X'08'    .... 1... No VBS checking
@_SYSUT1_Seg_Error  EQU   *-1,X'01'    .... ...1 Segments dropped

*-------------------------------------------------------------------*
*                                                                   *
*    Output-related fields                                          *
*                                                                   *
*-------------------------------------------------------------------*

                    DS    0F
@_ODT_Ptr           DS    AL4         A(Output Descriptor Table)

*-------------------------------------------------------------------*
*                                                                   *
*    Counters and Date/Times                                        *
*                                                                   *
*-------------------------------------------------------------------*

                    DS    0F
@_Line_Count        DS    HL2         LINE COUNT
@_Page_Count        DS    PL2         PAGE COUNT
@_Input_Count       DS    FL4         INPUT COUNTER

@_Dump_Start_Date   DS    PL4         SMF Dump Start Date
@_Dump_Start_Time   DS    FL4                    and Time
@_Dump_End_Date     DS    PL4         SMF Dump End Date
@_Dump_End_Time     DS    FL4                  and Time
@_First_Rec_Date    DS    PL4         First Record Date
@_First_Rec_Time    DS    FL4                  and Time
@_Input_Rec_Date    DS    PL4         Current Record Date
@_Input_Rec_Time    DS    FL4                    and Time

@_Prev_Input_Rec_Date DS  PL4         Previous record date
@_Prev_Input_Rec_DOW DS   X           Previous record Day-of-Week

@_DateConv_Area     DS    CL(DConv_Area_Length)  Todays Date Info

@_Input_Count_Table DS    256FL4      Input count by SMF Record Type

         DS    0D                     ALIGNMENT
@_DynLen EQU   *-@_Dynam               LENGTH OF STORAGE
         TITLE 'Register Equates'
         YREGS
         TITLE 'A0010: Main Program Block'
SMFSLCT  RMODE ANY
SMFSLCT  AMODE 31

SMFSLCT  RSECT

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : A0010                                                  *
*                                                                     *
*  Abstract  : Main program loop:                                     *
*               Perform Initialization                                *
*               Do until SYSUT1 EOF, or all criteria satisfied        *
*                 Read SYSIN                                          *
*                 Do for each appropriate output                      *
*                   Write to output                                   *
*                 EndDo                                               *
*               Perform Termination                                   *
*                                                                     *
*                                                                     *
*  Inputs    : Files:                                                 *
*               SYSUT1  : Input SMF File (Dynamically allocated if    *
*                                         not present in JCL)         *
*               SYSIN   : Control Cards                               *
*               SYSPRINT: Listing                                     *
*              Parms: N/A                                             *
*                                                                     *
*                                                                     *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error encountered                             *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

A0010    DS    0H
         USING *,R15                  ASSIGN TEMPORARY BASE
         SAVE  (14,12),T,'SMFSLCT &VERSION  &ASMDT &SYSTIME'
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING A0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get some storage for our LIFO stack ...                        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R0,=AL4(@_31Bit_Stack_Len) Get length of storage we need
         STACK INIT,                    Go get our storage             +
               LEN=(R0),                 this long                     +
               LOC=ANY                   anywhere
         LR    R2,R1                    Save its address

*-------------------------------------------------------------------*
*                                                                   *
*    ... and get some room on it for the globally addressable       *
*     variables ...                                                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@_DynLen,             this long                     +
               STACK=(R2)                using this stack
         LR    R12,R1                   Point to our storage

         USING @_Dynam,R12              Assign a base

         LA    R0,@_Dynam               A(Our storage)
         LA    R1,@_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage

         ST    R2,@_31Bit_Stack_Ptr     Save A(Stack)

*-------------------------------------------------------------------*
*                                                                   *
*    ... and finally get an area on it for our local storage        *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@A_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@A_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @A_DYNAM,R13             Assign a base
         L     R15,@A_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Get the 24-bit stack                                           *
*                                                                   *
*-------------------------------------------------------------------*

         L     R0,=AL4(@_24Bit_Stack_Len) Get length of storage we need
         STACK INIT,                    Go get our storage             +
               LEN=(R0),                 this long                     +
               LOC=BELOW                 below-the-line
         ST    R1,@_24Bit_Stack_Ptr     Save its address

         L     R15,@A_Dynam+4           Get A(HSA)
         LM    R0,R1,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Perform our Initialization Routines                            *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(B0010)        A(Initialization Routine)
         BASR  R14,R15                Go do it
         LTR   R15,R15                How did it go?
         BNZ   A9000                  Not so well, exit

A1000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Start of main program loop:                                    *
*      Get an input record                                          *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(C0010)        A(SYSUT1 Read routine)
         BASR  R14,R15                Go do it
         LTR   R15,R15                How did it go?
         BNZ   A9000                  Not so well, exit
         L     R1,@_SYSUT1_Rec_Ptr    OK, get A(Input Record)

*-------------------------------------------------------------------*
*                                                                   *
*    Indicate that we haven't printed the record yet, in case it    *
*   is selected more than once.                                     *
*                                                                   *
*-------------------------------------------------------------------*

         NI    @A_Rec_Printed,X'FF'-L'@A_Rec_Printed OFF Printed Flag

*-------------------------------------------------------------------*
*                                                                   *
*    Go through the Output Descriptor Table, seeing if this record  *
*   will satisfy any of the criteria.                               *
*                                                                   *
*-------------------------------------------------------------------*

         L     R10,@_ODT_Ptr          A(ENVIRONMENT TABLE)
         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) NBR ENTRIES
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST
         USING ODT_Entry,R10           and assign a base
         OI    @A_All_Done,L'@A_All_Done Assume all ODTEs inactive
A1010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    If this is an active entry ...                                 *
*                                                                   *
*-------------------------------------------------------------------*

         TM    ODTE_Inactive,L'ODTE_Inactive ACTIVE ENTRY?
         BO    A1250                   NO, SKIP
         NI    @A_All_Done,X'FF'-L'@A_All_Done Reset flag

*-------------------------------------------------------------------*
*                                                                   *
*    ... check the date and time of the input record against the    *
*   start and end date/time criteria.                               *
*                                                                   *
*-------------------------------------------------------------------*

         TM    ODTE_CopyOnly,L'ODTE_CopyOnly Any selection criteria?
         BO    A1200                  No, select the record
         CLI   SMF0RTY-SMFRCD0(R1),X'02' DUMP HEADER?
         BE    A1040                  YES, SKIP DATE/TIME CHECK
         CLI   SMF0RTY-SMFRCD0(R1),X'03' NO, DUMP TRAILER?
         BE    A1040                  YES, SKIP DATE/TIME CHECK
         CP    SMF0DTE-SMFRCD0(L'SMF0DTE,R1),ODTE_StartDate CHECK DATE
         BL    A1250                  DON'T WANT THIS ONE, SKIP
         BH    A1020                  AFTER START DATE, SKIP TIME CHK
         L     R15,SMF0TME-SMFRCD0(R1) GET INPUT TIME
         C     R15,ODTE_StartTime     DO WE WANT THIS ONE?
         BL    A1250                  NO, GET ANOTHER ONE
A1020    DS    0H
         CP    SMF0DTE-SMFRCD0(L'SMF0DTE,R1),ODTE_EndDate PAST END?
         BH    A1030                  YES, CHECK SEQUENCE
         BL    A1040                  BEFORE END DATE, SKIP TIME CHK
         L     R15,SMF0TME-SMFRCD0(R1) GET INPUT TIME
         C     R15,ODTE_EndTime       BEFORE END TIME?
         BNH   A1040                  YES, CONTINUE
A1030    DS    0H
         TM    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Input in sequence?
         BO    A1240                  YES, INACTIVATE THIS ENTRY
         B     A1250                  NO, IGNORE THIS RECORD
A1040    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    If we are ignoring weekends, check it out                      *
*                                                                   *
*-------------------------------------------------------------------*

         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend
         BZ    A1060                  No, continue
         CP    @_Prev_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)
         BE    A1050                  Same date as prev, skip
         XC    @A_DateConv_Area,@A_DateConv_Area No, clear Date area
         MVC   @A_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),SMF0DTE-SMFRCD0(R1) Move SMF Date
         OI    @A_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate      Indicate SMF Date
         LA    R1,@A_DateConv_Area   Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get Day-of-Week
         L     R1,@_SYSUT1_Rec_Ptr   Restore A(Input Record)
         ZAP   @_Prev_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)
         MVC   @_Prev_Input_Rec_DOW,@A_DateConv_Area+DConv_Date_DOW-Dat+
               eConv_Area            Save Day-of-week
A1050    DS    0H
         CLI   @_Prev_Input_Rec_DOW,X'04' Is DOW greater than Friday?
         BH    A1250                 Yes, ignore this record
A1060    DS    0H
*-------------------------------------------------------------------*
*                                                                   *
*    Start and End Date/Times are OK, check against the Period      *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,SMF0TME-SMFRCD0(R1) GET THE TIME OF THE SMF REC
         C     R15,ODTE_PeriodStart   BEFORE PERIOD START?
         BL    A1250                  YES, IGNORE IT
         C     R15,ODTE_PeriodEnd     NO, AFTER PERIOD END?
         BH    A1250                  YES, SKIP IT

*-------------------------------------------------------------------*
*                                                                   *
*    Invoke the User Exit INEXIT, if there is one.                  *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_InExit_Ptr Get A(Input Exit)
         BZ    A1070                  None, skip
         SLR   R0,R0                  Yes, flag as an Inexit
         L     R15,=AL4(X0010)        A(Exit invocation routine)
         BASR  R14,R15                Go do it
         LTR   R15,R15                Check return code
         BZ    A1070                  OK, continue normally
         CH    R15,=H'8'              Something else, check it out
         BL    A1200                  Select this record
         BE    A1250                  Ignore it
         ZAP   ODTE_EndDate,=P'0'     Clear End Date and Time so we
         XC    ODTE_EndTime,ODTE_EndTime finish after this record
A1070    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Check this record against any record types specified ...       *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_RTT_Ptr Get A(Record Table)
         BZ    A1130                  None, don't check it
         LH    R14,RTT_Entry_Count-RecType_Tbl(R15) Get nbr entries
         LA    R15,RTT_Entry-RecType_Tbl(R15) and point to the first
         SLR   R4,R4                  Clear R4
         SLR   R5,R5                  R5 too
A1080    DS    0H
         CLC   SMF0RTY-SMFRCD0(L'SMF0RTY,R1),RTTE_RecType-RTT_Entry(R15+
               ) Is this our record?
         BE    A1100                  Yes, skip
A1090    DS    0H
         LA    R15,RTTE_Length(R15)   No, A(Next entry in table)
         BCT   R14,A1080              and try again
         B     A1120                  Not our record, skip
A1100    DS    0H
         TM    RTTE_SubType_Present-RTT_Entry(R15),L'RTTE_SubType_Prese+
               nt                     SubType present?
         BNO   A1110                  No, found our record
         CLC   SMF30STP-SMFRCD30(L'SMF30STP,R1),RTTE_SubType-RTT_Entry(+
               R15)                   Yes, our subtype?
         BNE   A1090                  No, try again
A1110    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    ... and include or exclude it as required                      *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,ODTE_RTT_Ptr       Get A(Record Table)
         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude
         BO    A1250                  EXCLUDEing, skip
         B     A1130                  No, continue
A1120    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    This record is not in the Record Type Table - we must check the*
*    exclude indicator to see what we should do with it.            *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,ODTE_RTT_Ptr       Get A(Record Table)
         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude
         BO    A1130                  Yes, include this record
         B     A1250                  No, skip it
A1130    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Check this record for JobName selection.                       *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_JNT_Ptr A(JobName Table)
         BZ    A1170                  None, skip
*        CLI   SMF30RTY-SMFRCD30(R1),70 RMF record?
*        BL    A1140                  No, skip
*        CLI   SMF30RTY-SMFRCD30(R1),79 Really?
*        BNH   A1170                  Yes, skip jobname check
A1140    DS    0H
         LH    R14,JNT_Entry_Count-JobName_Tbl(R15) Nbr entries
         LA    R15,JNT_Entry-JobName_Tbl(R15) And point to first
         LA    R2,SMF5JBN-SMFRCD5(R1) A(JobName in SMF record)
         CLI   SMF30RTY-SMFRCD30(R1),30 Type 30 record?
         BNE   A1150                  No, skip
         L     R2,SMF30IOF-SMFRCD30(R1) Yes, offset to ID section
         AR    R2,R1                  and point to JobName
A1150    DS    0H
         SLR   R3,R3                   Clear EX register
         IC    R3,JNTE_JobName_Len-JNT_Entry(R15) Len of JobName Mask
         EX    R3,A9999               Check JobNameE
         BNE   A1160                  Not us, skip
         TM    ODTE_JobData_OR,L'ODTE_JobData_OR JOB/DATA=OR?
         BO    A1200                  Yes, Select this record
         B     A1170                  No, go check Data Table
A1160    DS    0H
         LA    R15,JNTE_Length(R15)   A(Next Entry)
         BCT   R14,A1150              and try again
         TM    ODTE_JobData_OR,L'ODTE_JobData_OR JOB/DATA=OR?
         BNO   A1250                  No, skip this record
         ICM   R15,B'1111',ODTE_DT_Ptr Yes, get A(Data Table)
         BZ    A1250                  None, skip this record
A1170    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Check for Data selection                                       *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_DT_Ptr Get A(Data Table)
         BZ    A1200                  None, select this record
         LH    R14,DT_Entry_Count-Data_Tbl(R15) Yes, get nbr entries
         LA    R15,DT_Entry-Data_Tbl(R15) and point to the first
         SLR   R3,R3                  Clear work register
A1180    DS    0H
         LH    R2,DTE_Offset-DT_Entry(R15) Offset of data
         IC    R3,DTE_Length-DT_Entry(R15) EX length if data
         LA    R4,0(R2,R3)            Offset of last char
         CH    R4,SMF0LEN-SMFRCD0(R1) Is the record long enough?
         BH    A1190                  No, data does not match
         AR    R2,R1                  Yes, A(Offset)
         EX    R3,A9998               Check the data
         BE    A1200                  Found it, skip
A1190    DS    0H
         LA    R15,1+DTE_Data-DT_Entry(R3,R15) A(Next Entry)
         BCT   R14,A1180              and check it
         B     A1250                  Not found, skip this record
A1200    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    This record has satisfied all the selection criteria for this  *
*   output file, so invoke the user exit                            *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_OutExit_Ptr Get A(Output Exit)
         BZ    A1210                  None, skip
         LA    R0,1                   Yes, flag as an Outexit
         L     R15,=AL4(X0010)        A(Exit invocation routine)
         BASR  R14,R15                Go do it
         CH    R15,=H'8'              Check return code
         BH    A1240                  Inactivate this ODT entry
         BE    A1250                  Ignore the record

A1210    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Invoke D0010 to write to the output file ...                   *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R1,@A_D0010_Parm       Save A(SMF record)
         ST    R10,@A_D0010_Parm+4    Save A(ODT Entry)

         LA    R1,@A_D0010_Parm       A(Parm list)
         L     R15,=AL4(D0010)        A(Selection routine)
         BASR  R14,R15                Go select the record

         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)

         LTR   R15,R15                How did it go?
         BNZ   A1250                  Not great, try next ODT

         ICM   R15,B'1111',ODTE_StopAft Get Select Limit
         BZ    A1220                  None, keep going
         C     R15,ODTE_Selected      Yes, have we reached it?
         BH    A1220                  Not yet, keep going
         OI    ODTE_Inactive,L'ODTE_Inactive Inactive entry
A1220    DS    0H


*-------------------------------------------------------------------*
*                                                                   *
*    ... and E0010 to print it, if required                         *
*                                                                   *
*-------------------------------------------------------------------*

         TM    ODTE_Print_NO,L'ODTE_Print_NO Should we print?
         BO    A1250                  No, skip
         TM    @A_Rec_Printed,L'@A_Rec_Printed Yes, already printed?
         BO    A1250                  Yes, skip

         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                Skip a line (Print blanks)

         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)
         MVC   0(7,R2),=X'4020206B202120'  Move mask
         L     R15,@_Input_Count      Get input record count
         CVD   R15,@A_DBLWD           Pack it
         ED    0(7,R2),@A_DBLWD+5     Edit it
         MVC   7(7,R2),=X'4020206B202120'  Move mask
         L     R15,ODTE_Selected      Get selected count
         CVD   R15,@A_DBLWD           Pack it
         ED    7(7,R2),@A_DBLWD+5     Edit it
         MVC   15(8,R2),=C'RecType:'  Move Record Type title
         MVC   23(4,R2),=X'40202120'  Move mask
         SLR   R15,R15                Clear work register
         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type
         CVD   R15,@A_DBLWD           Pack it
         ED    23(4,R2),@A_DBLWD+6     and put it in SYSPRINT rec
         MVC   30(11,R2),=C'Date-Time: ' Move Date/Time heading

         XC    @A_DateConv_Area,@A_DateConv_Area Clear Date area
         ZAP   @A_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),SMF0DTE-SMFRCD0(L'SMF0DTE,R1)  Date
         MVC   @A_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               SMF0TME-SMFRCD0(R1)            Time too
         OI    @A_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @A_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@A_DateConv_Area     Point to Date Conversion area
         ST    R15,@A_F0010_Parm     Save as 1st parm
         LA    R15,41(0,R2)          A(Output area)
         ST    R15,@A_F0010_Parm+4   Save as 2nd parm
         LA    R15,@A_Return_Ptr     A(Return area)
         ST    R15,@A_F0010_Parm+8   Save as 2nd parm
         LA    R1,@A_F0010_Parm      A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)
         L     R15,@_ODT_Ptr          A(OUTPUT ENVIRONMENT TABLE)
         LH    R15,ODT_Entry_Count-OutDesc_Tbl(R15) GET NBR ENTRIES
         CH    R15,=H'1'              MORE THAN 1?
         BNH   A1230                  NO, SKIP 'SELECTED BY' MSG
         L     R2,@A_Return_Ptr       Point to end of Date/Time
         MVC   1(13,R2),=C', selected to'  MOVE SELECTION HDG
         MVC   15(L'ODTE_DDName,R2),ODTE_DDName MOVE DDNAME
A1230    DS    0H
         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                PRINT THIS LINE

         ST    R1,@A_E0010_Parm       Save A(SMF record)
         ST    R10,@A_E0010_Parm+4    Save A(ODT Entry)

         LA    R1,@A_E0010_Parm       A(Parm list)
         L     R15,=AL4(E0010)        A(Print routine)
         BASR  R14,R15                Go print the record

         OI    @A_Rec_Printed,L'@A_Rec_Printed Printed now

         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)

         B     A1250                  And continue

A1240    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Flag this ODT Entry as Inactive                                *
*                                                                   *
*-------------------------------------------------------------------*

         OI    ODTE_Inactive,L'ODTE_Inactive Inactive entry
A1250    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Point to the next ODT Entry, and check it out                  *
*                                                                   *
*-------------------------------------------------------------------*

         AL    R10,=AL4(ODTE_Length)  Bump entry pointer
         BCT   R9,A1010               and keep going

*-------------------------------------------------------------------*
*                                                                   *
*    We have finished processing all ODT Entries - if they are all  *
*   inactive, we will terminate.                                    *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @A_All_Done,L'@A_All_Done All ODTs inactive?
         BZ    A1000                  No, go get more input

         DROP  R10                    Free ODTE Base register

         SLR   R15,R15                Yes, all done
         B     A9000                  and exit
A9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Perform our Termination routines ...                           *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(Z0010)        A(Termination Routine)
         BASR  R14,R15                Go do it

         LR    R3,R15                 Save the return code

*-------------------------------------------------------------------*
*                                                                   *
*    ... get rid of the 24-bit stack ...                            *
*                                                                   *
*-------------------------------------------------------------------*

         STACK TERM,                    Free the stack                 +
               STACK=@_24Bit_Stack_Ptr   starting here

*-------------------------------------------------------------------*
*                                                                   *
*    ... free up our local data area ...                            *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,@A_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... then the global data area ...                              *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,@_Dynam               A(Global storage)
         L     R2,@_31Bit_Stack_Ptr     Rescue Stack pointer

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=(R2)                on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and finally, the stack itself.                             *
*                                                                   *
*-------------------------------------------------------------------*

         STACK TERM,                    Free the stack                 +
               STACK=(2)                 starting here

*-------------------------------------------------------------------*
*                                                                   *
*    Restore callers registers, and return to caller.               *
*                                                                   *
*-------------------------------------------------------------------*


         L     R14,12(0,R13)            Restore Return address
         LR    R15,R3                   Restore return code
         LM    R0,R12,20(R13)           Restore remainder of registers
         BSM   0,R14                    and return to caller


         LTORG


A9998 CLC      0(0,R2),DTE_Data-DT_Entry(R15)  Check data
A9999 CLC      0(0,R2),JNTE_JobName-JNT_Entry(R15) Check JobName


         LTORG

@A_Dynam        DSECT               Local Variables
@A_Save         DS    18F            O/S Style Save Area
@A_DBLWD        DS    D
@A_ParmList     DS    0F
@A_D0010_Parm   DS    2AL4           Parms for D0010
                ORG   @A_ParmList
@A_E0010_Parm   DS    2AL4           Parms for E0010
                ORG   @A_ParmList
@A_F0010_Parm   DS    3AL4           Parms for F0010
@A_Return_Ptr   DS    AL4             Return pointer from F0010
                ORG
                DS    X              Flag Byte
@A_All_Done     EQU   *-1,X'80'       1... .... All ODTs inactive
@A_Rec_Printed  EQU   *-1,X'40'       .1.. .... Record printed
@A_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area
                DS    0D             Alignment
@A_DynLen       EQU   *-@A_Dynam    Length

         DROP  R11,R13

SMFSLCT  RSECT
         TITLE 'B0010: Initialization'

         PUSH  USING

B0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : B0010                                                  *
*                                                                     *
*  Abstract  : Initialization routine                                 *
*               Allocate and initialize various contol blocks         *
*               Interpret SYSIN Control Cards                         *
*               OPEN all output files                                 *
*               Print info about output files                         *
*                                                                     *
*                                                                     *
*  Inputs    : Parms: N/A                                             *
*                                                                     *
*                                                                     *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error encountered                             *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              1999/11/18 SDDA030 V1.3                                *
*                                 Added comments                      *
*              2002/02/07 SDDA030 V1.4                                *
*                                 Corrected SOC4s, etc., when we      *
*                                 overflowed SYSPRINT record when     *
*                                 listing rectypes/jobnames.          *
*                                 Invoked I0010 to OPEN SYSUT1.       *
*                                 Used W0010 to get A(JFCB), rather   *
*                                 that issue RDJFCB.                  *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING B0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@B_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@B_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @B_Dynam,R13             Assign a base
         L     R15,@B_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Create our Output Descriptor Table, ...                        *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,ODT_Entry-OutDesc_Tbl Header length
*        AL    R0,=AL4(ODTE_Length)    plus len of 1 entry
         AL    R0,=AL4(ODTE_Length*2)  plus len of 2 entries       JG
         ICM   R0,B'1000',=AL1(ODT_SubPool_Nbr) set up subpool
         STORAGE OBTAIN,              Go get our storage               +
               LENGTH=(0),             this long                       +
               LOC=ANY                 anywhere
         ST    R1,@_ODT_Ptr            Save A(Table)
         ST    R0,ODT_SubPool-OutDesc_Tbl(R1) Save subpool, length
         LA    R15,1                   Nbr entries
         STH   R15,ODT_Entry_Count-OutDesc_Tbl(R1) Init it
         LA    R0,ODT_Entry-OutDesc_Tbl(R1) Point to our entry
         L     R1,=AL4(ODTE_Length)    Get its length
         SLR   R14,R14                 no sending area
         SLR   R15,R15                 or length
         MVCL  R0,R14                  Clear our entry
         L     R10,@_ODT_Ptr           A(Output Descriptor Table)
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) Point to 1st entry

         USING ODT_Entry,R10           Assign a base

*-------------------------------------------------------------------*
*                                                                   *
*    ... and initialize the base (first) entry.                     *
*                                                                   *
*-------------------------------------------------------------------*

         ZAP   ODTE_StartDate,=P'0'   Start Date = 00000
         XC    ODTE_StartTime,ODTE_StartTime Start Time = 00:00:00
         ZAP   ODTE_EndDate,=P'999999' End Date = 00365
         MVC   ODTE_EndTime,=F'8640000' End Time = 24:00:00
         XC    ODTE_PeriodStart,ODTE_PeriodStart Period Start
         MVC   ODTE_PeriodEnd,=F'8640000' Period End
         MVI   ODTE_InExit,C' '       CLEAR
         MVC   ODTE_InExit+1(L'ODTE_InExit-1),ODTE_InExit Input and
         MVC   ODTE_OutExit,ODTE_InExit      Output Exit names
         SLR   R15,R15                   Clear work register
         ST    R15,ODTE_DCB_Ptr          No DCB yet

*-------------------------------------------------------------------*
*                                                                   *
*    Initialize our variables.                                      *
*                                                                   *
*-------------------------------------------------------------------*

         ZAP   @_First_Rec_Date,=P'0' First Date = 00000
         XC    @_First_Rec_Time,@_First_Rec_Time First Time = 00:00:00
         ZAP   @_Dump_Start_Date,=P'999999' Dump Start Date = 00.365
         MVC   @_Dump_Start_Time,=F'8640000' Dump Start Time = 24:00:00
         ZAP   @_Dump_End_Date,=P'0'  Dump End Date = 00.000
         XC    @_Dump_End_Time,@_Dump_End_Time Dump End Time = 00:00:00
         ZAP   @_Prev_Input_Rec_Date,=P'0'
         LA    R15,99                 Get High Line count
         STH   R15,@_Line_Count        and save it
         ZAP   @_Page_Count,=P'0'     Clear Page count

*-------------------------------------------------------------------*
*                                                                   *
*    Get the current date and time ...                              *
*                                                                   *
*-------------------------------------------------------------------*

         MVC   @B_Time,B_Time         Move L-Form of macro
         TIME  DEC,                   Get time                         C
               @B_TimeArea,            and return it here              C
               LINKAGE=SYSTEM,         don't use the SVC               C
               DATETYPE=YYYYDDD,       format of returned data         C
               MF=(E,@B_TIME)          addr of macro list
         XC    @_DateConv_Area,@_DateConv_Area Clear date conv area
         XC    @B_DBLWD,@B_DBLWD      Clear work area

*-------------------------------------------------------------------*
*                                                                   *
*    ... and some info about it.                                    *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R0,R0                  Clear work register
         IC    R0,@B_TimeArea         Get HH
         SLL   R0,4                   Make room for sign
         STH   R0,@B_DBLWD+6          Save it
         OI    @B_DBLWD+7,X'0F'       Add a sign
         CVB   R0,@B_DBLWD            Binarize it
         STC   R0,@_DateConv_Area+DConv_Time_HH-DateConv_Area
         IC    R0,@B_TimeArea+1       Get MM
         SLL   R0,4                   Make room for sign
         STH   R0,@B_DBLWD+6          Save it
         OI    @B_DBLWD+7,X'0F'       Add a sign
         CVB   R0,@B_DBLWD            Binarize it
         STC   R0,@_DateConv_Area+DConv_Time_MM-DateConv_Area
         IC    R0,@B_TimeArea+2       Get SS
         SLL   R0,4                   Make room for sign
         STH   R0,@B_DBLWD+6          Save it
         OI    @B_DBLWD+7,X'0F'       Add a sign
         CVB   R0,@B_DBLWD            Binarize it
         STC   R0,@_DateConv_Area+DConv_Time_SS-DateConv_Area
         IC    R0,@B_TimeArea+3       Get tt
         SLL   R0,4                   Make room for sign
         STH   R0,@B_DBLWD+6          Save it
         OI    @B_DBLWD+7,X'0F'       Add a sign
         CVB   R0,@B_DBLWD            Binarize it
         STC   R0,@_DateConv_Area+DConv_Time_tt-DateConv_Area
         OI    @_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DConv+
               _Input_hhmmss          Indicate time in hhmmss

         L     R15,@B_TimeArea+8      Get Date (0yyyyddd)
         SLR   R14,R14                Clear work register
         SLDL  R14,20                 R14 = yyyy
         SLL   R14,4                  Make room for sign
         ST    R14,@B_DBLWD+4         Save it
         OI    @B_DBLWD+7,X'0F'       Add a sign
         CVB   R14,@B_DBLWD           Binarize yyyy
         STH   R14,@_DateConv_Area+DConv_Date_YYYY-DateConv_Area
         SRL   R15,16                 R15 = ddd0
         ST    R15,@B_DBLWD+4         Save it
         OI    @B_DBLWD+7,X'0F'       Add a sign
         CVB   R15,@B_DBLWD           Binarize ddd
         STH   R15,@_DateConv_Area+DConv_Date_DDD-DateConv_Area
         OI    @_DateConv_Area+DConv_Input_Julian-DateConv_Area,L'DConv+
               _Input_Julian          Indicate date in YYYY and DDD

         LA    R1,@_DateConv_Area    Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get info about today

         NI    @_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,X'FF'-L+
               'DConv_Input_hhmmss    Off the flag
         NI    @_DateConv_Area+DConv_Input_Julian-DateConv_Area,X'FF'-L+
               'DConv_Input_Julian    Off the flag

*-------------------------------------------------------------------*
*                                                                   *
*    Initialize SYSPRINT stuff                                      *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R15,R15                  Clear work register
         ST    R15,@_SYSPRINT_DCB_Ptr   Clear A(SYSPRINT DCB)
         OI    ODTE_Print_NO,L'ODTE_Print_NO Suppress headings
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                Go get a record
         NI    ODTE_Print_NO,X'FF'-L'ODTE_Print_NO Reset no print flag
         LTR   R15,R15                  OK?
         BNZ   B8000                    No, exit with error

*-------------------------------------------------------------------*
*                                                                   *
*    Check out SYSIN control cards                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R10,@_ODT_Ptr          A(Output Desc Table)
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) A(default (1st) entry)
         L     R15,=AL4(H0010)        A(SYSIN processor)
         BASR  R14,R15                Go interpret SYSIN
         LTR   R15,R15                How did we do?
         BNZ   B8000                  Not great, exit

*-------------------------------------------------------------------*
*                                                                   *
*    Go allocate (if necessary) and OPEN SYSUT1                     *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(G0010)        A(SYSPRINT Routine)
         BASR  R14,R15                A blank line
         L     R15,=AL4(G0010)        A(SYSPRINT Routine)
         BASR  R14,R15                and another

         L     R15,=AL4(I0010)        A(SYSUT1 OPEN)
         BASR  R14,R15                Go OPEN SYSUT1
         LTR   R15,R15                How did we do?
         BNZ   B8000                  Not great, exit

*-------------------------------------------------------------------*
*                                                                   *
*    We seemed to interpret the SYSIN statements OK, and SYSUT1 is  *
*   OK, so go and fix up the Output Descriptor Table:               *
*        - if there is only one entry (ie, the default), make the   *
*          output ddname = SYSUT2,                                  *
*        - if there is more than one, propagate the default exit    *
*          names, record type, jobname and data table pointer addrs,*
*          and include and exclude flags from the default to the    *
*          other entries, unless they were specified in the other   *
*          entries. Additionally, inactivate the default entry.     *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,1                 Set Input count
         LNR   R15,R15                to -1 for any exits
         ST    R15,@_Input_Count      we may invoke

         L     R10,@_ODT_Ptr         A(Output Descriptor Table)
         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) NBR ENTRIES
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST
         CH    R9,=H'1'              ONLY ONE ENTRY?
         BH    B0020                 NO, SKIP
         MVC   ODTE_DDName,=CL8'SYSUT2' YES, DEFAULT TO SYSUT2
         SLR   R15,R15               Clear work register
         ST    R15,ODTE_DCB_Ptr      No DCB yet
         B     B0120                 AND SKIP
B0020    DS    0H
         LR    R1,R10                SAVE A(DEFAULT ENTRY)
         OI    ODTE_Inactive,L'ODTE_Inactive MAKE DEFAULT INACTIVE
         MVC   @B_Default_InExit_Name,ODTE_InExit Save default name
         MVC   @B_Default_InExit_Parm_Ptr,ODTE_InExit_Parm_Ptr
         MVC   @B_Default_OutExit_Name,ODTE_OutExit Save default name
         MVC   @B_Default_OutExit_Parm_Ptr,ODTE_OutExit_Parm_Ptr
         B     B0110
B0030    DS    0H
         CLI   ODTE_InExit,C' '      INPUT EXIT NAME BLANK?
         BNE   B0040                 NO, SKIP
         TM    ODTE_No_Dflt_InExit,L'ODTE_No_Dflt_Inexit Use default?
         BO    B0040                 No, skip
         MVC   ODTE_InExit,@B_Default_InExit_Name Yes, move default
         MVC   ODTE_InExit_Parm_Ptr,@B_Default_InExit_Parm_Ptr
B0040    DS    0H
         CLI   ODTE_OutExit,C' '     OUTPUT EXIT NAME BLANK?
         BNE   B0050                 NO, SKIP
         TM    ODTE_No_Dflt_OutExit,L'ODTE_No_Dflt_Outexit Use default?
         BO    B0050                 No, skip
         MVC   ODTE_OutExit,@B_Default_OutExit_Name    Yes, DEFAULT
         MVC   ODTE_OutExit_Parm_Ptr,@B_Default_OutExit_Parm_Ptr
B0050    DS    0H
         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TABLE) = 0?
         BNZ   B0060                 NO, SKIP
         MVC   ODTE_RTT_Ptr,ODTE_RTT_Ptr-ODT_Entry(R1) Yes, default
B0060    DS    0H
         ICM   R15,B'1111',ODTE_JNT_Ptr A(JOBNAME TABLE) = 0?
         BNZ   B0070                 NO, SKIP
         MVC   ODTE_JNT_Ptr,ODTE_JNT_Ptr-ODT_Entry(R1) Yes, default
B0070    DS    0H
         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE) = 0?
         BNZ   B0080                 NO, SKIP
         MVC   ODTE_DT_Ptr,ODTE_DT_Ptr-ODT_Entry(R1) Yes, default
B0080    DS    0H
         TM    ODTE_Print_NO-ODT_Entry(R1),L'ODTE_Print_NO
         BZ    B0090
         OI    ODTE_Print_NO,L'ODTE_Print_NO Set flag
B0090    DS    0H
         TM    ODTE_Print_EB-ODT_Entry(R1),L'ODTE_Print_EB
         BZ    B0100
         OI    ODTE_Print_EB,L'ODTE_Print_EB Set flag
B0100    DS    0H
         TM    ODTE_JobData_OR-ODT_Entry(R1),L'ODTE_JobData_OR
         BZ    B0110
         OI    ODTE_JobData_OR,L'ODTE_JobData_OR Set flag
B0110    DS    0H
         AL    R10,=AL4(ODTE_Length) A(Next entry)
         BCT   R9,B0030              AND DO IT
B0120    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    For each entry in the Output Descriptor Table ...              *
*                                                                   *
*-------------------------------------------------------------------*

         L     R10,@_ODT_Ptr          A(OUTPUT ENVIRONMENT TABLE)
         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST
B0130    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    ... get the attributes for the dataset                         *
*                                                                   *
*-------------------------------------------------------------------*

         TM    ODTE_Inactive,L'ODTE_Inactive INACTIVE ENTRY?
         BO    B0220                  YES, SKIP DCB STUFF

         LA    R0,B_SYSUT2_DCB_Length Length of DCB
         STORAGE OBTAIN,              Get storage                      +
               LENGTH=(0),             for the DCB                     +
               LOC=BELOW               Below-the-line
         MVC   0(B_SYSUT2_DCB_Length,R1),B_SYSUT2_DCB Move DCB
         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R1),ODTE_DDName IN DCB
         ST    R1,ODTE_DCB_Ptr        Save A(DCB)

         L     R15,=AL4(W0010)        A(Get JFCB address routine)
         BASR  R14,R15                Go get it
         LTR   R15,R15                How did we do?
         BNZ   B0200                  Not good, skip
         LR    R3,R1                  OK, point to JFCB

*-------------------------------------------------------------------*
*                                                                   *
*    If this is a new dataset ...                                   *
*                                                                   *
*-------------------------------------------------------------------*

         TM    JFCBIND2-INFMJFCB(R3),JFCNEW DISP=NEW or not specified?
         BM    B0180                  NO, USE EXISTING STUFF

*-------------------------------------------------------------------*
*                                                                   *
*    ... set up RECFM, LRECL and BLKSIZE if they were not           *
*   specified                                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R2,ODTE_DCB_Ptr        A(DCB)

         IC    R15,JFCRECFM-INFMJFCB(R3) GET JFCB RECFM
         TM    JFCRECFM-INFMJFCB(R3),JFCFMREC ANYTHING THERE?
         BNZ   B0140                  YES, OK
         L     R1,@_SYSUT1_DCB_Ptr    A(Input DCB)
         IC    R15,DCBRECFM-IHADCB(R1) NO, GET RECFM FROM SYSUT1
         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS THE INPUT VSAM?
         BZ    B0140                   NO, OK
         IC    R15,=AL1(DCBRECV+DCBRECBR+DCBRECSB) YES, DEFAULT TO VBS
B0140    DS    0H
         STC   R15,DCBRECFM-IHADCB(R2) SAVE RECFM
         TM    DCBRECFM-IHADCB(R2),DCBRECU RECFM=U?
         BO    B0170                   YES, SKIP LRECL CHECK
         BNZ   B0150                   NO, BUT SOME LRECL SPECIFIED
         TM    JFCRECFM-INFMJFCB(R3),JFCUND JFCB RECFM = U?
         BO    B0170                   YES, SKIP LRECL CHECK
B0150    DS    0H
         LH    R15,JFCLRECL-INFMJFCB(R3) GET JFCB LRECL
         LTR   R15,R15                 IS THERE ONE?
         BNZ   B0160                   YES, SKIP
         L     R1,@_SYSUT1_DCB_Ptr     No, A(SYSUT1 DCB)
         LH    R15,DCBLRECL-IHADCB(R1) NO, GET SYSUT1 LRECL
         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS THE INPUT VSAM?
         BZ    B0160                   NO, OK
         L     R15,=F'32760'           YES, DEFAULT LRECL=32760
B0160    DS    0H
         STH   R15,DCBLRECL-IHADCB(R2) Update OUTPUT LRECL
B0170    DS    0H
         LH    R15,JFCBLKSI-INFMJFCB(R3) GET JFCB BLKSIZE
         LTR   R15,R15                 IS THERE ONE?
         BNZ   B0180                   YES, SKIP
         MVC   DCBBLKSI-IHADCB(L'DCBBLKSI,R2),DCBBLKSI-IHADCB(R1)
         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS SYSUT1 VSAM?
         BZ    B0180                   NO, OK
         SLR   R15,R15                 YES, Use SDB
         STH   R15,DCBBLKSI-IHADCB(R2) UPDATE SYSUT2
B0180    DS    0H
         L     R2,ODTE_DCB_Ptr            A(DCB)
         MVC   @B_OPEN,B_OPEN             MOVE OPEN PARMS
         OPEN  ((2),OUTPUT),MODE=31,MF=(E,@B_OPEN) AND OPEN IT
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN IS IT OPEN?
         BZ    B0200                  NO, SKIP
         LH    R15,DCBLRECL-IHADCB(R2) YES, GET LRECL
         TM    DCBRECFM-IHADCB(R2),DCBRECU IS RECFM = U?
         BNO   B0190                  NO, OK
         LH    R15,DCBBLKSI-IHADCB(R2) YES, GET BLKSIZE INSTEAD
B0190    DS    0H
         STH   R15,ODTE_LRECL         SAVE MAX OUTPUT LRECL

*-------------------------------------------------------------------*
*                                                                   *
*    Go list some stuff about this file                             *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,ODTE_DCB_Ptr        A(DCB)
         L     R15,=A(J0010)          A(Info format routine)
         BASR  R14,R15                Go do it
         B     B0210                  and skip

B0200    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    THE OUTPUT DCB COULD NOT BE OPENED - SAY SO.                   *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT LINE)
         L     R15,ODTE_DCB_Ptr       A(DCB)
         MVC   1(8,R1),DCBDDNAM-IHADCB(R15) MOVE DDNAME
         MVC   9(23,R1),=C' DD statement not found'
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT OUR LINE

B0210    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*   Assume this entry has no selection criteria (i.e., a straight   *
*  copy). This flag will get reset each time we find (and print)    *
*  some selection criteria.                                         *
*                                                                   *
*-------------------------------------------------------------------*

         OI    ODTE_CopyOnly,L'ODTE_CopyOnly  Assume no selection crit

         LA    R1,ODT_Entry           Point to ODTE
         L     R15,=AL4(L0010)        A(List routine)
         BASR  R14,R15                Go do it

B0220    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    CHECK TO SEE IF WE HAVE TO LOAD THE EXITS - IF WE DO, WE DO.   *
*                                                                   *
*-------------------------------------------------------------------*

         CLI   ODTE_InExit,C' '       IS THERE AN INEXIT?
         BE    B0270                  NO, SKIP
         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria
         CLC   ODTE_InExit,@B_Default_InExit_Name  Default?
         BNE   B0230                  No, go load it
         ICM   R0,B'1111',@B_Default_InExit_Ptr Yes, get A(Exit)
         BNZ   B0240                  LOADed already, skip
B0230    DS    0H
         LA    R0,ODTE_InExit         NO, POINT TO IT
         LOAD  EPLOC=(0),ERRET=B0260 AND GO GET IT
         CLC   ODTE_InExit,@B_Default_InExit_Name  Default?
         BNE   B0240                  No, skip
         ST    R0,@B_Default_InExit_Ptr Yes, save its address
B0240    DS    0H
         ST    R0,ODTE_InExit_Ptr     SAVE EPA

         SLR   R1,R1                  Clear A(SMF Record)
         SLR   R0,R0                  An InExit
         L     R15,=AL4(X0010)        A(Exit invocation routine)
         BASR  R14,R15                Go do it
         C     R15,=FL4'12'           How did it go?
         BL    B0270                  OK, skip
         OI    ODTE_Inactive,L'ODTE_Inactive Not good, make inactive
         B     B0360                  AND SKIP

B0260    DS    0H
         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD
         MVC   20(35,R1),=C'Exit could not be LOADed - ignored.'
         MVC   10(L'ODTE_InExit,R1),ODTE_InExit MOVE EXIT NAME
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO PRINT
         MVI   ODTE_InExit,C' '       Clear 1st byte of name
B0270    DS    0H
         CLI   ODTE_OutExit,C' '      IS THERE AN OUTEXIT?
         BE    B0320                  NO, SKIP
         CLC   ODTE_OutExit,@B_Default_OutExit_Name  Default?
         BNE   B0280                  No, go load it
         ICM   R0,B'1111',@B_Default_OutExit_Ptr Yes, get A(Exit)
         BNZ   B0290                  LOADed already, skip
B0280    DS    0H
         LA    R0,ODTE_OutExit        NO, POINT TO IT
         LOAD  EPLOC=(0),ERRET=B0310 AND GO GET IT
         CLC   ODTE_OutExit,@B_Default_OutExit_Name  Default?
         BNE   B0290                  No, skip
         ST    R0,@B_Default_OutExit_Ptr Yes, save its address
B0290    DS    0H
         ST    R0,ODTE_OutExit_Ptr    SAVE EPA

         SLR   R1,R1                  Clear A(SMF Record)
         LA    R0,1                   An OutExit
         L     R15,=AL4(X0010)        A(Exit invocation routine)
         BASR  R14,R15                Go do it
         C     R15,=FL4'12'           How did it go?
         BL    B0320                  OK, skip
         OI    ODTE_Inactive,L'ODTE_Inactive Not good, make inactive
         B     B0360                  AND SKIP

B0310    DS    0H
         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD
         MVC   20(35,R1),=C'Exit could not be LOADed - ignored.'
         MVC   10(L'ODTE_OutExit,R1),ODTE_OutExit MOVE EXIT NAME
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO PRINT
         MVI   ODTE_OutExit,C' '      Clear 1st byte of name
B0320    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    If we are ignoring weekends, adjust the start/stop times (if   *
*   present), if they start or stop on weekends.                    *
*                                                                   *
*-------------------------------------------------------------------*

         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend No Sat or Sun?
         BNO   B0360                 No, OK
         NI    @B_Dates_Altered,X'FF'-L'@B_Dates_Altered Off our flag

         CP    ODTE_StartDate,=P'0'  Any start date?
         BE    B0330                 No, skip

         XC    @B_DateConv_Area,@B_DateConv_Area Clear Date area
         ZAP   @B_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),ODTE_StartDate
         OI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate        Indicate SMF Date
         LA    R1,@B_DateConv_Area   Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get info

         MVC   @B_StartDate_Base,@B_DateConv_Area+DConv_Date_Base-DateC+
               onv_Area              Save start Basedate
         MVC   @B_StartDate_DOW,@B_DateConv_Area+DConv_Date_DOW-DateCon+
               v_Area                Save start DOW
         CLI   @B_DateConv_Area+DConv_Date_DOW-DateConv_Area,X'04'
         BNH   B0330                 Not starting on a weekend, skip
         SLR   R0,R0                 Clear work register
         IC    R0,@B_DateConv_Area+DConv_Date_DOW-DateConv_Area
         LA    R15,7                 DOW of the next Monday
         SR    R15,R0                Number of days until Monday
         A     R15,@B_StartDate_Base Bump base date
         ST    R15,@B_StartDate_Base  and save it
         ST    R15,@B_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+
               Input_Base           Indicate Base Date
         NI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,X'FF'+
               -L'DConv_Input_SMFDate Off SMFDate flag
         LA    R1,@B_DateConv_Area   Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get info

         ZAP   ODTE_StartDate,@B_DateConv_Area+DConv_Date_SMFDate-DateC+
               onv_Area(L'DConv_Date_SMFDate)  Update Start Date
         OI    @B_Dates_Altered,L'@B_Dates_Altered Set our flag

         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD
         MVC   10(23,R1),=C'Start Date modified to '
         MVC   @B_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               ODTE_StartTime               Time too
         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+
               Input_Base           Indicate Base date
         OI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@B_DateConv_Area     Point to Date Conversion area
         ST    R15,@B_Parms          Save as 1st parm
         LA    R15,33(0,R1)          A(Output area)
         ST    R15,@B_Parms+4        Save as 2nd parm
         LA    R15,@B_Return_Ptr     A(Return area)
         ST    R15,@B_Parms+8        Save it
         LA    R1,@B_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time
         L     R15,=AL4(G0010)       A(SYSPRINT routine)
         BASR  R14,R15               GO PRINT

         NI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,X'FF'-L'+
               DConv_Input_Base      Off the flag
         NI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,X'FF'-L'+
               DConv_Input_Time      Off the flag
B0330    DS    0H
         CP    ODTE_EndDate,=P'999999' Any End Date?
         BE    B0340                 No, skip

         XC    @B_DateConv_Area,@B_DateConv_Area Clear Date area
         ZAP   @B_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),ODTE_EndDate
         OI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate        Indicate SMF Date
         LA    R1,@B_DateConv_Area   Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get info

         MVC   @B_EndDate_Base,@B_DateConv_Area+DConv_Date_Base-DateCon+
               v_Area                Save End Basedate
         CLI   @B_DateConv_Area+DConv_Date_DOW-DateConv_Area,X'04'
         BNH   B0340                 Not ending on a weekend, skip
         SLR   R0,R0                 Clear work register
         IC    R0,@B_DateConv_Area+DConv_Date_DOW-DateConv_Area
         LA    R15,4                 DOW of the previous Friday
         SR    R0,R15                Number of days after Friday
         L     R15,@B_EndDate_Base   Get Base date
         SR    R15,R0                Back up to Friday
         ST    R15,@B_EndDate_Base   and save it
         ST    R15,@B_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+
               Input_Base           Indicate Base Date
         NI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,X'FF'+
               -L'DConv_Input_SMFDate Off SMFDate flag
         LA    R1,@B_DateConv_Area   Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get info

         ZAP   ODTE_EndDate,@B_DateConv_Area+DConv_Date_SMFDate-DateCon+
               v_Area(L'DConv_Date_SMFDate) Update end date
         OI    @B_Dates_Altered,L'@B_Dates_Altered Set our flag

         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD
         MVC   10(21,R1),=C'End Date modified to '
         MVC   @B_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               ODTE_EndTime          Time too
         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+
               Input_Base            Indicate Base date
         OI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time            Indicate SMF Time
         LA    R15,@B_DateConv_Area  Point to Date Conversion area
         ST    R15,@B_Parms          Save as 1st parm
         LA    R15,31(0,R1)          A(Output area)
         ST    R15,@B_Parms+4        Save as 2nd parm
         LA    R15,@B_Return_Ptr     A(Return area)
         ST    R15,@B_Parms+8        Save it
         LA    R1,@B_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time
         L     R15,=AL4(G0010)       A(SYSPRINT routine)
         BASR  R14,R15               GO PRINT

         NI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,X'FF'-L'+
               DConv_Input_Base      Off the flag
         NI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,X'FF'-L'+
               DConv_Input_Time      Off the flag
B0340    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    If there is a StartDate and an EndDate, check the adjusted     *
*   dates ...                                                       *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @B_Dates_Altered,L'@B_Dates_Altered  Did we do anything?
         BNO   B0360                 No, skip
         CP    ODTE_StartDate,=P'0'  Any start date?
         BE    B0360                 No, skip
         CP    ODTE_EndDate,=P'999999' Any End Date?
         BE    B0360                 No, skip

*-------------------------------------------------------------------*
*                                                                   *
*    ... to see if we have to select anything. For instance, a      *
*   user may have specified:                                        *
*      START=Saturday,END=Sunday,WEEKENDS=IGNORE                    *
*   We will have adjusted the StartDate to Monday, and EndDate to   *
*   the previous Friday. In this case, we inactivate the entry      *
*   immediately.                                                    *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@B_EndDate_Base   Get base date for End date
         C     R15,@B_StartDate_Base Less than StartDate?
         BNL   B0350                 No, skip
         OI    ODTE_Inactive,L'ODTE_Inactive Yes, set inactive
         B     B0360                and skip
B0350    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    If we have adjusted the dates so that a weekend does not fall  *
*   within the Start and End dates, we can turn off the 'Ignore     *
*   Weekends' flag. This will save us some processing, since we     *
*   won't have to figure out the Day-of-Week for each day.          *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@B_EndDate_Base   Get base date for End date
         S     R15,@B_StartDate_Base Get nbr days
         SLR   R0,R0                 Clear work register
         IC    R0,@B_StartDate_DOW   Get starting day-of-week
         AR    R0,R15                Get DOW of last day
         C     R0,=FL4'5'            Saturday or greater?
         BNL   B0360                 Yes, skip
         NI    ODTE_Ignore_Weekend,X'FF'-L'ODTE_Ignore_Weekend

B0360    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    All done with this entry, check next                           *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                SKIP A LINE

         AL    R10,=AL4(ODTE_Length)  A(Next ODT entry)
         BCT   R9,B0130               GO PROCESS IT

         DROP  R10                    Free ODT Entry base reg

         SLR   R15,R15                Clear
         ST    R15,@_Input_Count       Input count

*-------------------------------------------------------------------*
*                                                                   *
*    We have finished going through the table, so print some        *
*   blank lines ...                                                 *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                SKIP A LINE
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                  AND ANOTHER

*-------------------------------------------------------------------*
*                                                                   *
*    ...  and exit.                                                 *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R15,R15                Clear return code
         B     B9000                  and exit



B8000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Either SYSPRINT could not be opened, or we found an error in   *
*   the SYSIN statements; set the return code, and exit             *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                  Error, set return code

B9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R3,R15                 Save return code

         LA    R1,@B_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return



         PUSH  PRINT
         PRINT NOGEN

B_Time   TIME  LINKAGE=SYSTEM,MF=L
B_Time_Length EQU *-B_Time

B_SYSUT2_DCB DCB DDNAME=SYSUT2,MACRF=PM,DSORG=PS
B_SYSUT2_DCB_Length EQU *-B_SYSUT2_DCB LENGTH OF SYSUT1 DCB

B_OPEN   OPEN  (0,INPUT),MODE=31,MF=L
B_OPEN_Length EQU  *-B_OPEN

         POP   PRINT

         LTORG

@B_Dynam        DSECT                 Dynamic area for B
@B_Save         DS    18F              O/S Style save area
@B_DBLWD        DS    D                Work area
@B_Parms        DS    3AL4             Parm area
@B_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)
@B_StartDate_Base DS  FL4              Start Date in REXX Base format
@B_StartDate_DOW DS   XL1              Start Date Day-of-Week
@B_EndDate_Base DS    FL4              End Date in REXX Base format

@B_Default_InExit_Name DS  CL8         Default Exit Name
@B_Default_InExit_Ptr  DS  AL4         A(EPA of default exit)
@B_Default_InExit_Parm_Ptr DS AL4      A(Parm Ptr for InExit)
@B_Default_OutExit_Name DS  CL8        Default Exit Name
@B_Default_OutExit_Ptr  DS  AL4        A(EPA of default exit)
@B_Default_OutExit_Parm_Ptr DS AL4     A(Parm Ptr for OutExit)

                DS    X                Flag Byte
@B_Dates_Altered EQU  *-1,X'80'         1... .... Start/End dates upd

@B_MACRO        DS    0F               Macro area
@B_OPEN         DS    CL(B_OPEN_Length) OPEN macro
                ORG   @B_MACRO
@B_Time         DS    CL(B_Time_Length) L-Form of Time
@B_TimeArea     DS    CL16             Return area for Time
                ORG   @B_MACRO
@B_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area
                ORG
                DS    0D               Alignment
@B_DynLen       EQU   *-@B_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         TITLE 'C0000: Read the Input File'

         PUSH  USING

C0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : C0010                                                  *
*                                                                     *
*  Abstract  : SYSUT1 Read Routine:                                   *
*               If SYSUT1 not OPEN                                    *
*                 OPEN SYSUT1                                         *
*               EndIf                                                 *
*               Do until valid SMF record found                       *
*                 Read SYSUT1                                         *
*                 Check VBS Segmentation, if required                 *
*               EndDo                                                 *
*                                                                     *
*  Inputs    : None                                                   *
*                                                                     *
*                                                                     *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error encountered                             *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              1999/11/18 SDDA030 V1.3                                *
*                                 Moved SYSUT1 OPEN logic(?) to its   *
*                                 own subroutine (I0010)              *
*                                 Added comments                      *
*              2002/02/07 SDDA030 V1.4                                *
*                                 Removed invocation of I0010 to OPEN *
*                                 SYSUT1 (now done in B0010).         *
*                                 Updated EODAD on 1st time through.  *
*                                 Cleaned up SYSUT1 resources at EOD. *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING C0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@C_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@C_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @C_Dynam,R13             Assign a base
         L     R15,@C_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers


*-------------------------------------------------------------------*
*                                                                   *
*    If this is the first time in (@_Input_Count = 0) ...           *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',@_Input_Count Get input counter
         BNZ   C0020                    Not 1st time in, skip

*-------------------------------------------------------------------*
*                                                                   *
*    ... go update the DCBE/ACB EODAD routine address               *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM It the input VSAM?
         BO    C0010E                 Yes, skip

         L     R15,@_SYSUT1_DCB_Ptr   Yes, A(Input DCB)
         L     R15,DCBDCBE-IHADCB(0,R15) A(DCBE)
         LA    R0,C7000               A(EOD Routine)
         ST    R0,DCBEEODA-DCBE(0,R15) Update DCBE EODAD
         B     C0010Z                  and skip
C0010E   DS    0H

         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)
         LA    R3,@C_SYSUT1_EXLST_Ptr  A(RECEIVING AREA)
         SHOWCB ACB=(2),              YES, FROM SYSUT1 ACB             +
               FIELDS=EXLST,            WE WANT THE LRECL              +
               AREA=(3),                MOVED TO THIS AREA             +
               LENGTH=L'@C_SYSUT1_EXLST_Ptr, for this long             +
               MF=(G,@C_SHOWCB,C_SHOWCB_Length)

         L     R2,@C_SYSUT1_EXLST_Ptr   A(EXLST area)
         LA    R3,C7000               Get A(EOD Routine)
         MODCB EXLST=(2),             Update SYSUT1 EXLST              +
               EODAD=(3),               for EOD address                +
               MF=(G,@C_MODCB,C_MODCB_Length)

C0010Z   DS    0H
         LA    R15,99                   Get High Line count
         STH   R15,@_Line_Count          and save it

C0020    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Read the Input File.                                           *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM It the input VSAM?
         BZ    C0030                  No, skip
         L     R1,@_SYSUT1_RPL_Ptr    Yes, A(RPL)
         GET   RPL=(1)                and issue GET

*-------------------------------------------------------------------*
*                                                                   *
*    We have just read a record from the active SMF file, in which  *
*  the end will be marked by a special record, so we had better     *
*  check for it. If this is it, we signal EOF.                      *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSUT1_Rec_Ptr    A(INPUT RECORD)
         LH    R15,SMF0LEN-SMFRCD0(R1) GET LENGTH
         CH    R15,=H'14'             IS IT THE RIGHT LENGTH?
         BNE   C0180                  NO, SKIP
         CLC   =C'SMFEOFMARK',SMF0FLG-SMFRCD0(R1) YES, IS THIS IT?
         BE    C7000                  YES, EOF
         B     C0180                  NO, CONTINUE
C0030    DS    0H

         TM    @_SYSUT1_QSAM,L'@_SYSUT1_QSAM Is the input QSAM?
         BNO   C0040                  No, skip

*-------------------------------------------------------------------*
*                                                                   *
*    The input file is QSAM - just read it normally                 *
*                                                                   *
*-------------------------------------------------------------------*

         L     R0,@_SYSUT1_Rec_Ptr    A(input record)
         L     R1,@_SYSUT1_DCB_Ptr    POINT TO INPUT DCB
         GET   (1),(0)                GO GET THE RECORD
         B     C0180                  and skip
C0040    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We are using BSAM to access the input file.                    *
*                                                                   *
*-------------------------------------------------------------------*

         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs Off our flag
         SLR   R15,R15                Clear work register
         ST    R15,@C_SegErr_Seg_Count Clear nbr error segments
C0050    DS    0H
         L     R15,@_SYSUT1_Rec_Ptr   A(Record area)
         SLR   R0,R0                  Clear work reg
         ST    R0,0(0,R15)            Clear record length
         STH   R0,@C_Seg_Count        Clear segment count
         NI    @C_Last_Segment,X'FF'-L'@C_Last_Segment Off our flag
C0060    DS    0H
         L     R1,@_SYSUT1_BuffArea_Ptr Point to our buffer area
         ICM   R15,B'1111',BuffArea_Offset-BuffArea(R1) Get offset
         BNZ   C0070                  OK, skip
         L     R1,BuffArea_DECB_Ptr-BuffArea(0,R1) None, A(DECB)
         CHECK (1)                    Wait for I/O completion
         L     R1,@_SYSUT1_BuffArea_Ptr Restore buffer pointer
         LA    R15,4                  Buffer offset
         ST    R15,BuffArea_Offset-BuffArea(0,R1) Update it
         L     R15,@_SYSUT1_PBlock_Count Get Phys Blk Count
         LA    R15,1(0,R15)           Bump it
         ST    R15,@_SYSUT1_PBlock_Count and save it
         LA    R15,1                  Initialize segment
         ST    R15,BuffArea_Seg_Count-BuffArea(0,R1)  count
C0070    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Check that the next segment is valid, based on the segments    *
*   that have come before. Segment Type bits:                       *
*          X'00'  00 - Complete segment                             *
*          X'01'  01 - 1st segment                                  *
*          X'02'  10 - Last segment                                 *
*          X'03'  11 - Intermediate segment                         *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,@_SYSUT1_Rec_Ptr   A(Input record area)
         LH    R0,0(0,R14)            Get current record length

         L     R1,@_SYSUT1_BuffArea_Ptr A(Buffer area)
         LA    R15,BuffArea_IOArea-BuffArea(0,R1) A(I/O Area)
         A     R15,BuffArea_Offset-BuffArea(0,R1) A(Next Segment)
         TM    2(R15),X'01'           Last or only segment?
         BNZ   C0080                  No, skip
         OI    @C_Last_Segment,L'@C_Last_Segment Yes, set flag
C0080    DS    0H
         TM    2(R15),X'02'           1st or complete segment?
         BZ    C0110                  Yes, skip
         LTR   R0,R0                  No, have we processed a 1st?
         BZ    C0090                  No, segment error
         LR    R14,R15                A(Start of segment)
         LH    R15,0(0,R14)           Segment length
         SH    R15,=H'4'              less length of SDW
         LA    R14,4(0,R14)           point past SDW
         B     C0140                  OK, skip
C0090    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Segment error - Intermediate or last segment without a 1st.       *
*  If we are not in the middle of dropping segments, save some info   *
*  about the start of the segmenting error.                           *
*                                                                     *
*---------------------------------------------------------------------*

         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Already in error?
         BO    C0100                  Yes, skip
         MVC   @C_SegErr_Init_PBlock,@_SYSUT1_PBlock_Count
         L     R15,@_SYSUT1_BuffArea_Ptr A(Buffarea)
         L     R15,BuffArea_Seg_Count-BuffArea(0,R15)
         ST    R15,@C_SegErr_Init_Seg  Save segment number
         ZAP   @C_SegErr_Init_Date,@_Input_Rec_Date
         MVC   @C_SegErr_Init_Time,@_Input_Rec_Time
         SLR   R15,R15                Number of segments
         ST    R15,@C_SegErr_Seg_Count Clear segment count
         OI    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error
         OI    @C_Skipping_Segs,L'@C_Skipping_Segs Segmenting error
C0100    DS    0H
         L     R15,@C_SegErr_Seg_Count Get segment count
         LA    R15,1(0,R15)           Bump it
         ST    R15,@C_SegErr_Seg_Count Save it

         L     R1,@_SYSUT1_BuffArea_Ptr A(Buffer area)
         L     R15,BuffArea_Offset-BuffArea(0,R1) Offset next segment
         LA    R15,BuffArea_IOArea-BuffArea(R15,R1) A(Next segment)
         LH    R14,0(0,R15)           Get length of Segment
         A     R14,8(0,R1)            Bump offset to next segment
         ST    R14,8(0,R1)            Save it
         NI    @C_Last_Segment,L'@C_Last_Segment Off our flag
         B     C0150                  and skip
C0110    DS    0H
         LTR   R0,R0                  Are we in the middle of a rec?
         BNZ   C0120                  Yes, error
         LR    R14,R15                OK, A(Start of segment)
         LH    R15,0(0,R14)           Segment length
         MVC   @C_Init_PBlock,@_SYSUT1_PBlock_Count Save init PBlock
         MVC   @C_Init_Seg,BuffArea_Seg_Count-BuffArea(R1) seg #
         B     C0140                  and skip
C0120    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Segment error - No ending segment                                 *
*  If we are not in the middle of dropping segments, save some info   *
*  about the start of the segmenting error.                           *
*                                                                     *
*---------------------------------------------------------------------*

         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Already in error?
         BO    C0130                  Yes, skip
         MVC   @C_SegErr_Init_PBlock,@C_Init_PBlock
         MVC   @C_SegErr_Init_Seg,@C_Init_Seg
         ZAP   @C_SegErr_Init_Date,@_Input_Rec_Date
         MVC   @C_SegErr_Init_Time,@_Input_Rec_Time
         OI    @C_Skipping_Segs,L'@C_Skipping_Segs Segmenting error
C0130    DS    0H
         LH    R15,@C_Seg_Count       Segments in partial record
         A     R15,@C_SegErr_Seg_Count Bump error count
         ST    R15,@C_SegErr_Seg_Count Set error count

         B     C0050                  Start again
C0140    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   At this point, R0  = Current length of input record               *
*                  R14 = A(Segment from SYSUT1)+4 (ie, past SDW)      *
*                  R15 = Length of Segment                            *
*                                                                     *
*---------------------------------------------------------------------*

         LR    R1,R0                  Get current length
         AR    R1,R15                 Get new total length
         C     R1,@_SYSUT1_Rec_Length Will it be too long?
         BH    C0120                  Yes, error
         A     R0,@_SYSUT1_Rec_Ptr    No, A(Next free area)
         LR    R1,R15                 Length to move
         MVCL  R0,R14                 Move data to input area
         L     R1,@_SYSUT1_Rec_Ptr    A(Start of input rec area)
         SR    R0,R1                  Current length of input
         STH   R0,0(0,R1)             Update RDW
         L     R1,@_SYSUT1_BuffArea_Ptr A(Input buffer area)
         LA    R15,BuffArea_IOArea-BuffArea(0,R1) A(Start of block)
         SR    R14,R15                Calculate new offset
         ST    R14,BuffArea_Offset-BuffArea(0,R1) Save it
         LH    R15,@C_Seg_Count       Get segments in curr rec
         LA    R15,1(0,R15)           Bump it
         STH   R15,@C_Seg_Count       Save it
C0150    DS    0H
         L     R15,@_SYSUT1_BuffArea_Ptr A(Buffer area)
         L     R14,BuffArea_Offset-BuffArea(0,R1) Get offset
         CH    R14,BuffArea_IOArea-BuffArea(0,R15) Done the block?
         BL    C0160                  No, skip
         L     R2,@_SYSUT1_DCB_Ptr    A(SYSUT1 DCB)
         L     R4,@_SYSUT1_BuffArea_Ptr A(buffer area)
         L     R5,BuffArea_DECB_Ptr-BuffArea(0,R4) A(DECB)
         MVC   0(C_READ_Length,R5),C_READ  Initialize DECB
         LA    R6,BuffArea_IOArea-BuffArea(0,R4) A(I/O Area)
         READ  (5),SF,(2),(6),'S',MF=E    Issue the read
         SLR   R15,R15                Clear work register
         ST    R15,BuffArea_Offset-Buffarea(0,R4) Clear offset
         L     R15,@_SYSUT1_BuffArea_Ptr A(Current buffer area)
         L     R15,BuffArea_Next_Ptr-BuffArea(0,R15) A(Next)
         ST    R15,@_SYSUT1_BuffArea_Ptr and save the address
C0160    DS    0H
         TM    @C_Last_Segment,L'@C_Last_Segment  All done?
         BZ    C0060                  No, keep going

         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Yes, segs skipped?
         BZ    C0180                  No, OK

         OI    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error Yes, set flag
         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)
         MVC   2(3,R2),=C'***'        Move flag
         MVC   5(7,R2),=X'4020206B202120' Segment count mask
         L     R15,@C_SegErr_Seg_Count Get segments dropped
         CVD   R15,@C_DBLWD           Pack it
         ED    5(7,R2),@C_DBLWD+5     Edit it in
         MVC   13(7,R2),=C'segment'   Start of literal
         LA    R2,20(0,R2)            point to next character
         C     R15,=FL4'1'            More than 1 segment?
         BNH   C0170                  No, skip
         MVI   0(R2),C's'             Yes, pluralize it
         LA    R2,1(0,R2)             and bump output pointer
C0170    DS    0H
         MVC   0(26,R2),=C' dropped, from (PBlk:Seg) '
         L     R15,@C_SegErr_Init_PBlock  Get starting phys block
         CVD   R15,@C_DBLWD          Pack it
         UNPK  26(7,R2),@C_DBLWD+4(4) Unpack it
         OI    32(R2),X'F0'          Make it readable
         MVI   33(R2),C':'           Move separator
         L     R15,@C_SegErr_Init_Seg   Get starting segment number
         CVD   R15,@C_DBLWD          Pack it
         UNPK  34(3,R2),@C_DBLWD+6(2) Unpack it
         OI    36(R2),X'F0'          Make it readable
         MVC   37(15,R2),=C' to (PBlk:Seg) '
         L     R15,@C_Init_PBlock    Get starting phys block
         CVD   R15,@C_DBLWD          Pack it
         UNPK  52(7,R2),@C_DBLWD+4(4) Unpack it
         OI    58(R2),X'F0'          Make it readable
         MVI   59(R2),C':'           Move separator
         L     R15,@C_SegErr_Init_Seg   Get starting segment number
         CVD   R15,@C_DBLWD          Pack it
         UNPK  60(3,R2),@C_DBLWD+6(2) Unpack it
         OI    62(R2),X'F0'          Make it readable
         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                PRINT THIS LINE
         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)
         MVC   6(10,R2),=C'Data after'

         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area
         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),@C_SegErr_Init_Date  Date
         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               @C_SegErr_Init_Time            Time too
         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@C_DateConv_Area     Point to Date Conversion area
         ST    R15,@C_FParms         Save as 1st parm
         LA    R15,17(0,R2)          A(Output area)
         ST    R15,@C_FParms+4       Save as 2nd parm
         LA    R15,@C_Return_Ptr     A(Return area)
         ST    R15,@C_FParms+8       Save it
         LA    R1,@C_FParms          A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                PRINT THIS LINE
         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)
         LA    R2,6(0,R2)             Bump pointer

         MVC   0(10,R2),=C'and before'
         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area
         L     R1,@_SYSUT1_Rec_Ptr   A(Input record)
         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),SMF0DTE-SMFRCD0(L'SMF0DTE,R1)
         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               SMF0TME-SMFRCD0(R1)          Time too
         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@C_DateConv_Area     Point to Date Conversion area
         ST    R15,@C_FParms         Save as 1st parm
         LA    R15,11(0,R2)          A(Output area)
         ST    R15,@C_FParms+4       Save as 2nd parm
         LA    R15,@C_Return_Ptr     A(Return area)
         ST    R15,@C_FParms+8       Save it
         LA    R1,@C_FParms          A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time
         L     R2,@C_Return_Ptr      A(Return area)
         MVC   1(17,R2),=C' are unavailable.'

         L     R15,=AL4(G0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs
         B     C0180                  and skip
C0180    DS    0H
         L     R1,@_SYSUT1_Rec_Ptr    AND POINT TO OUR RECORD

*-------------------------------------------------------------------*
*                                                                   *
*    Bump the input counters                                        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@_Input_Count      GET THE INPUT COUNTER
         LA    R15,1(0,R15)           BUMP IT
         ST    R15,@_Input_Count

         SLR   R15,R15                Clear work regiater
         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type
         SLL   R15,2                  times 4
         LA    R15,@_Input_Count_Table(R15) A(Our counter)
         L     R0,0(0,R15)            Get count
         AL    R0,=FL4'1'             Bump it
         ST    R0,0(0,R15)            Save it

*-------------------------------------------------------------------*
*                                                                   *
*    SAVE THE DATE/TIME OF THE FIRST RECORD.                        *
*                                                                   *
*-------------------------------------------------------------------*

         CLI   SMF0RTY-SMFRCD0(R1),X'02' DUMP HEADER?
         BNE   C0200                  NO, SKIP
         CP    @_Dump_Start_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) 1st?
         BL    C0230                  NO, SKIP IT
         BH    C0190                  YES, SAVE IT
         L     R15,@_Dump_Start_Time  SAME DAY, GET PREV TIME
         C     R15,SMF0TME-SMFRCD0(R1) COMPARE AGAINST THIS ONE
         BNH   C0230                  NOT EARLIEST, SKIP
C0190    DS    0H
         ZAP   @_Dump_Start_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) Save it
         MVC   @_Dump_Start_Time,SMF0TME-SMFRCD0(R1)
         B     C0230                  AND SKIP
C0200    DS    0H
         CLI   SMF0RTY-SMFRCD0(R1),X'03' DUMP TRAILER
         BNE   C0220                  NO, SKIP
         CP    @_Dump_End_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) LATEST?
         BH    C0230                  NO, SKIP IT
         BL    C0210                  YES, SAVE IT
         L     R15,@_Dump_End_Time    SAME DAY, GET PREV TIME
         C     R15,SMF0TME-SMFRCD0(R1) COMPARE AGAINST THIS ONE
         BNL   C0230                  NOT EARLIEST, SKIP
C0210    DS    0H
         ZAP   @_Dump_End_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)
         MVC   @_Dump_End_Time,SMF0TME-SMFRCD0(R1)
         B     C0230                  AND SKIP
C0220    DS    0H
         ZAP   @_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) SAVE DATE
         MVC   @_Input_Rec_Time,SMF0TME-SMFRCD0(R1) AND TIME
         CP    @_First_Rec_Date,=P'0' HAVE WE FOUND THE FIRST DATE?
         BNE   C0230                  YES,SKIP
         ZAP   @_First_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) SAVE DATE
         MVC   @_First_Rec_Time,SMF0TME-SMFRCD0(R1) AND TIME
C0230    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE'VE FINISHED WITH THIS RECORD, SO WE CLEAR THE RETURN CODE   *
*   AND EXIT.                                                       *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R15,R15                CLEAR THE RETURN CODE
         B     C9000                  AND EXIT
C7000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    END-OF-FILE EXIT FOR SYSUT1.                                   *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Are we using BSAM?
         BNO   C7010                  No, skip
         L     R15,@_SYSUT1_Rec_Ptr   Yes, A(SYSUT1 record)
         LH    R15,0(0,R15)           Get length of record
         LTR   R15,R15                Anything there?
         BZ    C7010                  No, OK

         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)
         MVC   2(3,R2),=C'***'        Move flag
         MVC   5(7,R2),=X'4020206B202120' Segment count mask
         LH    R15,@C_Seg_Count       Get segments dropped
         CVD   R15,@C_DBLWD           Pack it
         ED    5(7,R2),@C_DBLWD+5     Edit it in
         MVC   12(35,R2),=C' segments dropped, from (PBlk:Seg) '
         L     R15,@C_Init_PBlock  Get starting phys block
         CVD   R15,@C_DBLWD          Pack it
         UNPK  47(7,R2),@C_DBLWD+4(4) Unpack it
         OI    53(R2),X'F0'          Make it readable
         MVI   54(R2),C':'           Move separator
         L     R15,@C_Init_Seg   Get starting segment number
         CVD   R15,@C_DBLWD          Pack it
         UNPK  55(3,R2),@C_DBLWD+6(2) Unpack it
         OI    57(R2),X'F0'          Make it readable
         MVC   58(21,R2),=C' to the end of SYSUT1'
         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                PRINT THIS LINE
         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)
         MVC   6(11,R2),=C'Data after '

         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area
         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),@_Input_Rec_Date     Date
         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               @_Input_Rec_Time               Time too
         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@C_DateConv_Area     Point to Date Conversion area
         ST    R15,@C_FParms         Save as 1st parm
         LA    R15,17(0,R2)          A(Output area)
         ST    R15,@C_FParms+4       Save as 2nd parm
         LA    R15,@C_Return_Ptr     A(Return area)
         ST    R15,@C_FParms+8       Save it
         LA    R1,@C_FParms          A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

         L     R2,@C_Return_Ptr      A(Return area)
         MVC   1(17,R2),=C' are unavailable.'
         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                PRINT THIS LINE
         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs

C7010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    CLOSE SYSUT1 ...                                               *
*                                                                   *
*-------------------------------------------------------------------*

         L     R2,@_SYSUT1_DCB_Ptr     A(DCB or ACB)
         MVC   @C_CLOSE,C_CLOSE        Move CLOSE parms
         CLOSE ((2)),MODE=31,MF=(E,@C_CLOSE)   and CLOSE DCB/ACB

         ICM   R1,B'1111',@_SYSUT1_Rec_Ptr  GET A(INPUT RECORD AREA)
         BZ    C7020                  None, skip
         L     R0,@_SYSUT1_Rec_Length YES, GET ITS LEN
         LA    R15,7                  Make
         AR    R0,R15                  a
         SRL   R0,3                    doubleword
         SLL   R0,3                    multiple
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
         SLR   R15,R15                Clear work register
         ST    R15,@_SYSUT1_Rec_Ptr   No input record
C7020    DS    0H
         ICM   R1,B'1111',@_SYSUT1_AtL_Ptr A(Above-the-line storage)
         BZ    C7030                  None, skip
         L     R0,0(0,R1)             Get Subpool, length
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
         SLR   R15,R15                Clear work register
         ST    R15,@_SYSUT1_AtL_Ptr   No storage now
C7030    DS    0H
         ICM   R1,B'1111',@_SYSUT1_BtL_Ptr A(Below-the-line storage)
         BZ    C7040                  None, skip
         L     R0,0(0,R1)             Get Subpool, length
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
         SLR   R15,R15                Clear work register
         ST    R15,@_SYSUT1_BtL_Ptr   No storage now

C7040    DS    0H
         LA    R15,4                  SET THE RETURN CODE
         B     C9000                  AND EXIT

C9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R3,R15                 Save return code

         LA    R1,@C_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

         PUSH PRINT
         PRINT NOGEN

         READ  C_READ,SF,0,0,'S',MF=L
C_READ_Length EQU  *-C_READ

C_CLOSE    CLOSE (0),MODE=31,MF=L
C_CLOSE_Length EQU   *-C_CLOSE

         POP   PRINT

         LTORG

@C_Dynam              DSECT           Dynamic area for C
@C_Save               DS   18F         O/S Style save area
@C_DBLWD              DS   D           Work area
@C_Return_Ptr         DS   AL4         A(Last byte formatted by F0010)
@C_Seg_Count          DS   HL2         Nbr segs in curr record
@C_Init_PBlock        DS   FL4         Phys Block of start of record
@C_Init_Seg           DS   FL4         Seg # of start of record
@C_SegErr_Init_PBlock DS   FL4         Phys Blk of start of seg err
@C_SegErr_Init_Seg    DS   FL4         Segment# of start of seg err
@C_SegErr_Init_Date   DS   PL4         Date of valid rec pre seg err
@C_SegErr_Init_Time   DS   FL4         Time of valid rec pre seg err
@C_SegErr_Seg_Count   DS   FL4         Nbr segments dropped
                      DS   X           Flag byte
@C_Last_Segment       EQU  *-1,X'80'    1... .... Last segment
@C_Skipping_Segs      EQU  *-1,X'40'    .1.. .... Skipping Segments

@C_Macro              DS   0F          Temp area for Macro L-Forms
@C_EParms             EQU  *            Parms for E0010
@C_EP_Input_Ptr       DS   AL4           A(INPUT AREA)
@C_EP_Input_Len       DS   FL4           LEN OF INPUT AREA
@C_EP_Input_Off       DS   FL4           CURRENT OFFSET
@C_EP_Output_Ptr      DS   AL4           A(OUTPUT AREA)
@C_EP_Output_Len      DS   FL4           OUTPUT AREA LENGTH
@C_EP_Pr_Flag_Ptr     DS   AL4           A(Print flag)
                      ORG  @C_Macro
@C_DateConv_Area      DS   CL(DConv_Area_Length)  Date conversion area
@C_FParms             DS   3AL4          Parms for F0010
                      ORG  @C_Macro
@C_SHOWCB             DS   CL(C_SHOWCB_Length) SHOWCB Macro
@C_SYSUT1_EXLST_Ptr   DS   AL4           A(SYSUT1 EXLST)
                      ORG  @C_Macro
@C_MODCB              DS   CL(C_MODCB_Length) MODCB Macro
                      ORG  @C_Macro
@C_Close              DS   CL(C_CLOSE_Length)  Close macro

                      ORG  ,
                      DS   0D          Alignment
@C_DynLen             EQU  *-@C_Dynam Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         TITLE 'D0000: Process selected record'

         PUSH  USING

D0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : D0010                                                  *
*                                                                     *
*  Abstract  : Write the selected input record to the output file(s). *
*                                                                     *
*  Inputs    : R1 ----> A(Input SMF record)                           *
*                       A(ODTE entry)                                 *
*                                                                     *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error encountered                             *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING D0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@D_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@D_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @D_Dynam,R13             Assign a base
         L     R15,@D_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         NI    @D_RDW_Updated,X'FF'-L'@D_RDW_Updated  Off our flag

*-------------------------------------------------------------------*
*                                                                   *
*    Get the address of the SMF record, and the ODT Entry that      *
*   selected it                                                     *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,0(0,R1)              A(SMF record)

         L     R10,4(0,R1)              A(ODT Entry)
         USING ODT_Entry,R10            Tell the assembler

         LR    R1,R15                   Set up A(SMF record)

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE SELECTED A RECORD. WE BUMP THE SELECTED COUNT, PRINT   *
*   IT (IF REQUIRED) AND WRITE IT (IF REQUIRED) TO SYSUT2.          *
*                                                                   *
*   ON ENTRY, R1 = A(SELECTED RECORD)                               *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,ODTE_Selected      GET SELECTED COUNT
         LA    R15,1(0,R15)           BUMP IT
         ST    R15,ODTE_Selected      AND SAVE IT

         SLR   R15,R15                Clear work regiater
         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type
         SLL   R15,2                  times 4
         LA    R15,ODTE_Output_Count_Table(R15) A(Our counter)
         L     R0,0(0,R15)            Get count
         AL    R0,=FL4'1'             Bump it
         ST    R0,0(0,R15)            Save it

         ICM   R15,B'1111',ODTE_DCB_Ptr A(Output DCB)
         BZ    D0110                  None, exit
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS DCB OPEN?
         BZ    D0110                  NO, exit quick smart

*-------------------------------------------------------------------*
*                                                                   *
*    AND WRITE IT TO THE OUTPUT, IF POSSIBLE.                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R2,@_SYSUT1_Rec_Ptr    SAVE A(INPUT RECORD)
         ICM   R1,B'1111',ODTE_DCB_Ptr  A(Output DCB)
         BZ    D9000                  None, skip
         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN IS OUTPUT OPEN?
         BZ    D9000                  NO, SKIP
         LH    R3,SMF0LEN-SMFRCD0(R2) GET INPUT RECORD LEN
         LH    R0,ODTE_LRECL          GET MAX OUTPUT RECORD LEN
         TM    DCBRECFM-IHADCB(R1),DCBRECV OUTPUT RECFM=F?
         BO    D0080                  NO, SKIP
         LA    R2,4(0,R2)             YES, POINT PAST RDW
         SH    R3,=H'4'                DECREMENT THE LENGTH
         B     D0100                   and skip
D0080    DS    0H
         CR    R3,R0                  INPUT GREATER THAN MAX OUTPUT?
         BNH   D0090                  NO, OK
         TM    DCBRECFM-IHADCB(R1),DCBRECV+DCBRECSB RECFM=VS?
         BO    D0090                  YES, SKIP
         OI    ODTE_Trunc,L'ODTE_Trunc INDICATE TRUNCATION
         STH   R0,SMF0LEN-SMFRCD0(R2) Update RDW temporarily
         OI    @D_RDW_Updated,L'@D_RDW_Updated  and set our flag
D0090    DS    0H
         TM    DCBRECFM-IHADCB(R1),DCBRECU OUT RECFM = U?
         BNO   D0100                  NO, SKIP
         STH   R3,DCBLRECL-IHADCB(R1) YES, UPDATE LRECL
D0100    DS    0H
         LR    R0,R2                  A(Output record)
         PUT   (1),(0)                Write output

         TM    @D_RDW_Updated,L'@D_RDW_Updated  Did we change RDW?
         BNO   D0110                  No, skip
         STH   R3,SMF0LEN-SMFRCD0(R2) Yes, restore it
         NI    @D_RDW_Updated,X'FF'-L'@D_RDW_Updated  and off our flag

D0110    DS    0H
         SLR   R15,R15                Clear return code
         B     D9000                  and exit

D9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R3,R15                 Save return code

         LA    R1,@D_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return


         LTORG

@D_Dynam        DSECT                 Dynamic area for D
@D_Save         DS    18F              O/S Style save area
                DS    X                Flag Byte
@D_RDW_Updated  EQU   *-1,X'80'         1... .... Record length updated
                DS    0D               Alignment
@D_DynLen       EQU   *-@D_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R10                    Free ODT Entry base
         DROP  R11,R13
         POP   USING
         TITLE 'E0000: FORMAT RECORD FOR PRINT'

         PUSH  USING

E0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : E0010                                                  *
*                                                                     *
*  Abstract  : Print selected input record                            *
*                                                                     *
*  Inputs    : R1 ----> A(Input SMF record)                           *
*                       A(ODTE entry)                                 *
*                                                                     *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error encountered                             *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING E0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@E_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@E_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @E_Dynam,R13             Assign a base
         L     R15,@E_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Save the addresses of the input record, and of our ODT entry   *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,0(0,R1)            Get A(Input record)
         ST    R15,@E_Record_Ptr      Save it
         L     R15,4(0,R1)            Get A(ODT Entry)
         ST    R15,@E_ODTE_Ptr        Save it

         L     R2,@E_Record_Ptr       A(Start of record)
E0015    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Format the offset into the output record ...                   *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R2                 Get current posn in input rec
         S     R15,@E_Record_Ptr      Convert to an offset
         STH   R15,@E_DBLWD           Save it
         MVI   @E_DBLWD+2,X'FE'       MAKE IT "PACKED"
         L     R15,@_SYSPRINT_Rec_Ptr Get A(Output
         LA    R15,18(0,R15)            area)
         UNPK  0(5,R15),@E_DBLWD(3)   UNPACK IT
         TR    0(5,R15),E_Hexnum      TRANSLATE TO HEX

*-------------------------------------------------------------------*
*                                                                   *
*    ... and set up some of our addresses                           *
*                                                                   *
*-------------------------------------------------------------------*

         L     R3,@_SYSPRINT_Rec_Ptr  A(Output
         LA    R3,18(0,R3)              area)
         L     R4,@E_Record_Ptr       Get length
         AH    R4,SMF0LEN-SMFRCD0(R4)  of input record
         SR    R4,R2                   remaining

*-------------------------------------------------------------------*
*                                                                   *
*    Check to see if we are printing EBCDIC                         *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@E_ODTE_Ptr        A(Print flag)
         TM    ODTE_Print_EB-ODT_Entry(R15),L'ODTE_Print_EB  EBCDIC?
         BO    E0080                  Yes, go do it

*-------------------------------------------------------------------*
*                                                                   *
*    We are printing in Dump format (32 bytes per line) ...         *
*                                                                   *
*-------------------------------------------------------------------*

         C     R4,=F'32'              MORE THAN OUR MAX?
         BNH   E0020                  NO, SKIP
         L     R4,=F'32'              YES, ONLY PRINT 32
E0020    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    ... with EBCDIC translation on the right-hand side             *
*                                                                   *
*-------------------------------------------------------------------*

         MVI   80(R3),C'*'            OPENING ASTERISK
         SH    R4,=H'1'               EXECUTE LENGTH OF DATA
         LA    R14,81(0,R3)           A(OUTPUT AREA)
         EX    R4,E9996               MOVE TO EBCDIC AREA
         EX    R4,E9997               TRANSLATE UNPRNTBL TO .
         MVI   113(R3),C'*'           CLOSING ASTERISK
         LA    R4,1(0,R4)             RESTORE LENGTH

*-------------------------------------------------------------------*
*                                                                   *
*    ... and hex data in groups of 4 bytes                          *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R3,6(0,R3)             A(START OF HEX DATA)
         LA    R5,4                   GROUPS OF 4 BYTES EACH
E0030    DS    0H
         LA    R6,4                   DO 4 GROUPS
E0040    DS    0H
         CR    R4,R5                  CAN WE DO 4 BYTES?
         BH    E0050                  YES, SKIP
         LR    R5,R4                  NO, DO AS MANY AS WE CAN
E0050    DS    0H
         SH    R5,=H'1'               EXEC LEN OF DATA
         LA    R14,@E_DBLWD           A(TARGET AREA)
         EX    R5,E9996               MOVE TO DBLWD
         LA    R15,@E_DBLWD(R5)       POINT TO LAST BYTE
         MVI   1(R15),X'FE'           PUT IN SIGN
         LA    R5,1(0,R5)             RESET LEN OF DATA
         LR    R0,R5                  CALCULATE UNPACKED LEN =
         SLL   R0,1                     = (R5 * 2)
         LR    R15,R0                 PUT IN EXEC REGISTER
         SLL   R15,4                  MAKE ROOM FOR PACKED LEN
         OR    R15,R5                 GET PACKED LEN
         EX    R15,E9999              UNPACK IT
         LR    R14,R3                 A(OUTPUT AREA)
         SRL   R15,4                  LENGTH OF OUTPUT ONLY
         EX    R15,E9998              AND TRANSLATE IT
         AR    R3,R0                  A(NEXT
         LA    R3,1(0,R3)                    OUTPUT BYTE)
         AR    R2,R5                  A(NEXT INPUT BYTE
         SR    R4,R5                  NBR BYTES LEFT TO DO
         BNP   E0100                  None, were finished this line
         BCT   R6,E0040               DO NEXT GROUP OF 4
         LA    R3,1(0,R3)             EXTRA BLANK IN THE MIDDLE
         B     E0030                  AND DO ANOTHER GROUP OF 4

E0080    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    PRINT THE SELECTED RECORD IN EBCDIC ONLY.                      *
*                                                                   *
*-------------------------------------------------------------------*

         LH    R15,@_SYSPRINT_Rec_Len GET MAX LRECL
         SH    R15,=H'24'             LESS STUFF WE HAVE USED
         CR    R4,R15                 IS INPUT TOO LONG?
         BNH   E0090                  NO, OK
         LR    R4,R15                 YES, PRINT AS MUCH AS WE CAN
E0090    DS    0H
         LA    R14,6(0,R3)            A(OUTPUT AREA)
         SH    R4,=H'1'               EXECUTE LENGTH OF DATA
         EX    R4,E9996               MOVE TO EBCDIC AREA
         EX    R4,E9997               TRANSLATE UNPRNTBL TO .
         LA    R4,1(0,R4)             Restore length printed
         AR    R2,R4                  Bump input pointer
E0100    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    The print line has been formatted, so print it ...             *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                Print our line

*-------------------------------------------------------------------*
*                                                                   *
*    ... and if there is more input record to format, do it.        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,@E_Record_Ptr      Get A(Input record)
         LR    R15,R2                 Calculate current
         SR    R15,R14                 offset
         CH    R15,SMF0LEN-SMFRCD0(R14)  Compare against record length
         BNL   E9000                  All done, exit
         B     E0015                  Keep going
E9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,@E_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         SLR   R15,R15                  Clear return code
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

E9996    MVC   0(0,R14),0(R2)
E9997    TR    0(0,R14),E_PrtTbl
E9998    TR    0(0,R14),E_Hexnum
E9999    UNPK  0(0,R3),@E_DBLWD(0)

E_Hexnum EQU   *-239
         DC    C' 0123456789ABCDEF'

E_PrtTbl DC    C'................'        00-0F
         DC    C'................'        10-1F
         DC    C'................'        20-2F
         DC    C'................'        30-3F
         DC    C' ...........<(+]'        40-4F
         DC    C'&&.........|$*);'       50-5F
         DC    C'-/.........,%_>?'        60-6F
         DC    C'..........:#@''="'       70-7F
         DC    C'.abcdefghi......'        80-8F
         DC    C'.jklmnopqr......'        90-9F
         DC    C'..stuvwxyz......'        A0-AF
         DC    C'................'        B0-BF
         DC    C'.ABCDEFGHI......'        C0-CF
         DC    C'.JKLMNOPQR......'        DO-DF
         DC    C'..STUVWXYZ......'        E0-EF
         DC    C'0123456789......'        F0-FF

         LTORG

@E_Dynam        DSECT                 Dynamic area for E
@E_Save         DS    18F              O/S Style save area
@E_DBLWD        DS    D                Work area
@E_Record_Ptr   DS    AL4              A(Input record)
@E_ODTE_Ptr     DS    AL4              A(ODT Entry)
                DS    0D               Alignment
@E_DynLen       EQU   *-@E_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         TITLE 'F0000 - Format Date/Times for output'
         PUSH  USING

F0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : F0010                                                  *
*                                                                     *
*  Abstract  : Format Date/Time from DateConv area to printable       *
*                                                                     *
*  Inputs    : R1 ----> A(DateConv_Area)                              *
*                       A(Start of output area)                       *
*                       A(Word in which to return the address of      *
*                         the last byte of formatted data)            *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error in conversion routine                   *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING F0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@F_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@F_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @F_Dynam,R13             Assign a base
         L     R15,@F_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         L     R9,0(0,R1)               A(Date conv area)
         L     R8,4(0,R1)               A(Output area)
         L     R15,8(0,R1)              Get A(return area)
         ST    R15,@F_Return_Ptr        Save it

         LR    R1,R9                    Point to DateConv area
         L     R15,=A(K0010)            A(Date conversion routine)
         BASR  R14,R15                  Go do it
         LTR   R15,R15                  Did it work?
         BNZ   F8010                    No, exit doing nothing

         MVI   0(R8),C' '               OK, blank out
         MVC   1(29,R8),0(R8)             our receiving area
         USING DateConv_Area,R9         and assign a DateConv base

         MVC   0(L'DConv_Date_Day,R8),DConv_Date_Day
         LA    R8,L'DConv_Date_Day-1(0,R8) A(Last char)
F0020    DS    0H
         CLI   0(R8),C' '            End of Day name?
         BNE   F0030                 Yes, skip
         BCT   R8,F0020              No, try again
F0030    DS    0H
         MVI   1(R8),C','            Insert separator
         MVC   3(L'DConv_Date_Month,R8),DConv_Date_Month  Month name
         LA    R8,3+L'DConv_Date_Month-1(0,R8) A(Last char)
F0040    DS    0H
         CLI   0(R8),C' '            End of Month name?
         BNE   F0050                 Yes, skip
         BCT   R8,F0040              No, try again
F0050    DS    0H
         SLR   R0,R0                 Clear work reg
         IC    R0,DConv_Date_DD      Get Day of month
         CVD   R0,@F_DBLWD           Pack it
         UNPK  1(3,R8),@F_DBLWD+6(2)  unpack it
         MVI   1(R8),C' '            Clear spurious digit
         LA    R8,2(0,R8)            point to 1st char
         CLI   0(R8),C'0'            Leading 0?
         BNE   F0060                 No, skip
         MVC   0(1,R8),1(R8)         Yes, left align day
         SH    R8,=H'1'              and adjust pointer
F0060    DS    0H
         OI    1(R8),X'F0'           Make it readable
         MVI   2(R8),C','            Insert separator
         LH    R0,DConv_Date_YYYY    Get year
         CVD   R0,@F_DBLWD           Pack it
         UNPK  3(5,R8),@F_DBLWD+5(3) Unpack it
         MVI   3(R8),C' '            Clear spurious character
         OI    7(R8),X'F0'           Make it readable
         MVI   9(R8),C'('            Move separator
         MVC   10(4,R8),4(R8)        Move YYYY
         MVI   14(R8),C'.'           Move separator
         LH    R0,DConv_Date_DDD     Get day of year
         CVD   R0,@F_DBLWD           Pack it
         UNPK  15(3,R8),@F_DBLWD+6(2) Unpack it
         OI    17(R8),X'F0'          Make it readable
         MVI   18(R8),C')'           Move close paren
         SLR   R0,R0                 Clear work register
         IC    R0,DConv_Time_hh      Get hours
         CVD   R0,@F_DBLWD           Pack it
         UNPK  19(3,R8),@F_DBLWD+6(2) Unpack it
         MVI   19(R8),C' '           Clear spurious char
         OI    21(R8),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,DConv_Time_mm      Get minutes
         CVD   R0,@F_DBLWD           Pack it
         UNPK  22(3,R8),@F_DBLWD+6(2) Unpack it
         MVI   22(R8),C':'           Clear spurious char
         OI    24(R8),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,DConv_Time_ss      Get seconds
         CVD   R0,@F_DBLWD           Pack it
         UNPK  25(3,R8),@F_DBLWD+6(2) Unpack it
         MVI   25(R8),C':'           Clear spurious char
         OI    27(R8),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,DConv_Time_tt      Get hundredths of seconds
         CVD   R0,@F_DBLWD           Pack it
         UNPK  28(3,R8),@F_DBLWD+6(2) Unpack it
         MVI   28(R8),C'.'           Clear spurious char
         OI    30(R8),X'F0'          Make it readable

         LA    R8,30(0,R8)           A(Last byte of data)
         L     R15,@F_Return_Ptr     A(Caller's area)
         ST    R8,0(0,R15)           Save it for the caller

         SLR   R15,R15               Clear return code
         B     F9010                  and exit
F8010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Error from Date conversion routine                                *
*                                                                     *
*---------------------------------------------------------------------*

         LA    R15,4           Set return code
         B     F9010           and exit

F9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R2,R15                   Save return code
         LA    R1,@F_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

         LR    R15,R2                   Restore return code

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return



         LTORG

@F_Dynam        DSECT                 Dynamic area for F
@F_Save         DS    18F              O/S Style save area
@F_DBLWD        DS    D                Work area
@F_Return_Ptr   DS    AL4              A(Return area)
                DS    0D               Alignment
@F_DynLen       EQU   *-@F_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R9                     Free DateConv_Area base
         DROP  R11,R13
         POP   USING
         TITLE 'G0000: WRITE SYSPRINT'

         PUSH  USING

G0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : G0010                                                  *
*                                                                     *
*  Abstract  : Write SYSPRINT record, producing page titles if        *
*              required                                               *
*                                                                     *
*  Inputs    : N/A                                                    *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - SYSPRINT not usable                           *
*                                                                     *
*  Notes     : If SYSPRINT is not OPEN, an attempt is made to OPEN it.*
*              On exit, @SYSPRINT_Rec_Ptr is updated with the         *
*                       address of the next SYSPRINT record area.     *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING G0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@G_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@G_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @G_Dynam,R13             Assign a base
         L     R15,@G_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    If we havent opened our DCB yet, do so                         *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R1,B'1111',@_SYSPRINT_DCB_Ptr A(SYSPRINT DCB)
         BNZ   G0030                    OK, skip

         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=G_SYSPRINT_DCB_Length, this long                 +
               LOC=BELOW                 below-the-line

         ST    R1,@_SYSPRINT_DCB_Ptr    Save it
         MVC   0(G_SYSPRINT_DCB_Length,R1),G_SYSPRINT_DCB

         MVC   @G_Open,G_Open         Move OPEN parms
         L     R2,@_SYSPRINT_DCB_Ptr  Point to the DCB
         MVC   0(G_SYSPRINT_DCB_Length,R2),G_SYSPRINT_DCB
         OPEN  ((2),OUTPUT),MODE=31,MF=(E,@G_Open) and open it
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Is it open?
         BZ    G8000                  No, exit quick smart
         LH    R15,DCBLRECL-IHADCB(R2) Yes, get record length
         TM    DCBRECFM-IHADCB(R2),DCBRECCC CC present?
         BZ    G0020                  No, skip
         SH    R15,=H'1'              Yes, decrement length
G0020    DS    0H
         STH   R15,@_SYSPRINT_Rec_Len Save data length of SYSPRINT
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)

G0030    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    PRINT THE CURRENT SYSPRINT RECORD, CLEAR THE NEW RECORD AREA,  *
*   AND BUMP THE LINE COUNT.                                        *
*                                                                   *
*-------------------------------------------------------------------*

         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN  IS SYSPRINT OPEN?
         BNO   G8000                  NO, EXIT
         PUT   (1)                    WRITE IT
         ST    R1,@_SYSPRINT_Rec_Ptr  Save A(SYSPRINT Record)
         LH    R15,@_Line_Count       Get current Line Count
         LA    R15,1(0,R15)           Bump it
         STH   R15,@_Line_Count       Save it
         CH    R15,=H'60'             End of a page?
         BL    G0050                  Not yet, exit

*-------------------------------------------------------------------*
*                                                                   *
*    SKIP TO A NEW PAGE, AND PRINT THE HEADING.                     *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R0,R1                  Clear
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)
         LH    R1,DCBLRECL-IHADCB(R1)  Get output length
         SLR   R14,R14                 output
         LA    R15,X'40'               record
         SLL   R15,24                  area to
         MVCL  R0,R14                  blanks
         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer
         MVI   0(R1),C'1'             START A NEW PAGE
         LA    R15,@_DateConv_Area    A(Info about today)
         ST    R15,@G_Parms           Save it
         LA    R15,1(0,R1)            A(Output area)
         ST    R15,@G_Parms+4         Save it
         LA    R15,@G_LastChar        A(Return area)
         ST    R15,@G_Parms+8         Save it
         LA    R1,@G_Parms            Point to parms
         L     R15,=A(F0010)          A(Format routine)
         BASR  R14,R15                Go do it
         LH    R15,@_SYSPRINT_Rec_Len GET SYSPRINT RECORD LENGTH
         A     R15,@_SYSPRINT_Rec_Ptr POINT PAST END OF RECORD
         LA    R14,L'G_Hdg1PP+L'G_Hdg1P+1 LEN OF PAGE NUMBER STUFF
         SR    R15,R14                OFFSET OF PAGE NBR STUFF
         MVC   0(L'G_Hdg1PP+L'G_Hdg1P,R15),G_Hdg1PP MOVE IT
         AP    @_Page_Count,=P'1'     BUMP PAGE COUNT
         ED    G_Hdg1P-G_Hdg1PP(L'G_Hdg1P,R15),@_Page_Count EDIT IT IN
         L     R14,@G_LastChar        A(Last char of Date/Time)
         SR    R15,R14                Len of white space
         LA    R14,L'G_Hdg1TITL       LEN OF TITLE
         SR    R15,R14                GET DIFFERENCE
         SRL   R15,1                  HALVE IT (IE, CENTRE TITLE)
         A     R15,@G_LastChar        A(output area)
         MVC   0(L'G_Hdg1TITL,R15),G_Hdg1TITL MOVE TITLE
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)
         PUT   (1)                    WRITE IT
         ST    R1,@_SYSPRINT_Rec_Ptr  Save A(SYSPRINT Record)
         LA    R15,1                  SET RECORD COUNT
         STH   R15,@_Line_Count       AND SAVE IT
         TM    ODTE_Print_NO-ODT_Entry(R10),L'ODTE_Print_NO
         BO    G0040                  NO, SKIP THESE HEADINGS
         LR    R0,R1
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)
         LH    R1,DCBLRECL-IHADCB(R1)  Get output length
         LA    R15,X'40'
         SLL   R15,24
         LA    R14,L'G_Hdg2A
         OR    R15,R14
         LA    R14,G_Hdg2A
         MVCL  R0,R14
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)
         PUT   (1)                    WRITE IT
         LR    R0,R1
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)
         LH    R1,DCBLRECL-IHADCB(R1)  Get output length
         LA    R15,X'40'
         SLL   R15,24
         LA    R14,L'G_Hdg2B
         OR    R15,R14
         LA    R14,G_Hdg2B
         MVCL  R0,R14
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)
         PUT   (1)                    WRITE IT
         ST    R1,@_SYSPRINT_Rec_Ptr  Save record pointer
         LR    R0,R1                  Clear
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)
         LH    R1,DCBLRECL-IHADCB(R1)  Get output length
         SLR   R14,R14                 output
         LA    R15,X'40'               record
         SLL   R15,24                  area to
         MVCL  R0,R14                  blanks
         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)
         PUT   (1)                    WRITE IT
         ST    R1,@_SYSPRINT_Rec_Ptr  Save record pointer
         LA    R15,3                  SET RECORD COUNT
         AH    R15,@_Line_Count       INCREMENT LINT COUNT
         STH   R15,@_Line_Count       AND SAVE IT
G0040    DS    0H
G0050    DS    0H
         L     R0,@_SYSPRINT_Rec_Ptr  Clear
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)
         LH    R1,DCBLRECL-IHADCB(R1)  Get output length
         SLR   R14,R14                 output
         LA    R15,X'40'               record
         SLL   R15,24                  area to
         MVCL  R0,R14                  blanks
         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer
         L     R15,@_SYSPRINT_DCB_Ptr A(SYSPRINT)
         TM    DCBRECFM-IHADCB(R15),DCBRECCC  ANY CONTROL CHAR?
         BZ    G0060                  NO, SKIP
         LA    R1,1(0,R1)             YES, POINT PAST IT
G0060    DS    0H
         ST    R1,@_SYSPRINT_Rec_Ptr  SAVE A(OUTPUT AREA)
         SLR   R15,R15                Clear return code
         B     G9000                  AND EXIT
G8000    DS    0H
         LA    R15,4                  Error opening SYSPRINT
         B     G9000                  AND EXIT
G9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R3,R15                   Save the return code

         LA    R1,@G_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

G_SYSPRINT_DCB DCB DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,LRECL=133,        +
               RECFM=FBA
G_SYSPRINT_DCB_Length EQU *-G_SYSPRINT_DCB

G_Open   OPEN  (0,INPUT),MODE=31,MF=L
G_Open_Length EQU *-G_Open

G_Hdg1TITL DC  C'SMFSLCT &VERSION'
G_Hdg1PP DC    C'PAGE'
G_Hdg1P  DC    X'40202120'            PAGE NUMBER MASK

G_Hdg2A  DC    C'0  Input    Sel    Off-'
G_Hdg2B  DC    C'   Count  Count     set  Data'

         LTORG

@G_Dynam        DSECT                 Dynamic area for G
@G_Save         DS    18F              O/S Style save area
                DS    0F               Alignment
@G_Open         DS    CL(G_Open_Length)  Open parms
@G_Parms        DS    3AL4             Parm area for F0010
@G_LastChar     DS    AL4              Return area from F0010
                DS    0D               Alignment
@G_DynLen       EQU   *-@G_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         TITLE 'H0000: INTERPRET CONTROL CARDS'

         PUSH  USING

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : H0010                                                  *
*                                                                     *
*  Abstract  : READ SYSIN control cards, and branch to interpretation *
*              routines (Hx0010)                                      *
*                                                                     *
*  Inputs    : N/A                                                    *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - Error in SYSIN Control Cards                  *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

H0010    DS    0H

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING H0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@H_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@H_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @H_Dynam,R13             Assign a base
         L     R15,@H_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         SLR   R15,R15                  Clear work register
         ST    R15,@H_rc                and clear return code

*-------------------------------------------------------------------*
*                                                                   *
*    OPEN SYSIN.                                                    *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)
         MVC   5(20,R1),=C'Input Control Cards:' MOVE HEADING
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO PRINT IT
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO PRINT blank line
         L     R1,@_SYSPRINT_Rec_Ptr  A(NEW SYSPRINT RECORD)
         MVC   1(30,R1),=C'--- No Control Cards found ---'

         STACK PUSH,                    Get Stack area                 +
               LEN=H_SYSIN_DCB_Length,   this long                     +
               STACK=@_24Bit_Stack_Ptr   using this stack

         ST    R1,@H_SYSIN_DCB_Ptr    Save A(SYSIN DCB area)
         MVC   @H_OPEN,H_OPEN         Move OPEN parms
         L     R2,@H_SYSIN_DCB_Ptr      POINT TO THE DCB
         MVC   0(H_SYSIN_DCB_Length,R2),H_SYSIN_DCB Move DCB
         MVC   @H_SYSIN_DCBE,H_SYSIN_DCBE Move SYSIN DCBE
         LA    R15,@H_SYSIN_DCBE      Point to it
         ST    R15,DCBDCBE-IHADCB(R2) Update address in DCB
         OPEN  ((2),INPUT),MODE=31,MF=(E,@H_OPEN) AND OPEN IT
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN  IS IT OPEN?
         BZ    H9000                  NO, SKIP
         TM    @H_SYSIN_DCBE+DCBEFLG1-DCBE,DCBEMD31 31-bit SAM OK?
         BO    H0020                  Yes, skip

*---------------------------------------------------------------------*
*                                                                     *
*   31-bit SAM is not supported for SYSIN. This typically happens     *
*  when it is allocated to the terminal in a TSO session (the I/O     *
*  seems to be OK, but the EOD handling gets in trouble). So ...      *
*                                                                     *
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
*                                                                     *
*  ... close the current DCB ...                                      *
*                                                                     *
*---------------------------------------------------------------------*

         MVC   @H_CLOSE,H_CLOSE       Move close parms
         L     R2,@H_SYSIN_DCB_Ptr    Point to the DCB
         CLOSE ((2)),MODE=31,MF=(E,@H_CLOSE)  and close it

*---------------------------------------------------------------------*
*                                                                     *
*  ... move a normal DCB (without the DCBE) to the 24-bit area ...    *
*                                                                     *
*---------------------------------------------------------------------*

         MVC   0(H_SYSIN24_DCB_Length,R2),H_SYSIN24_DCB Move DCB

*---------------------------------------------------------------------*
*                                                                     *
*  ... and move the 24-bit EOD to below-the-line storage              *
*                                                                     *
*---------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=H800024_Length,       this long                     +
               STACK=@_24Bit_Stack_Ptr   using this stack

         MVC   0(H800024_Length,R1),H800024_Start Move 24-bit EOD
         O     R1,DCBEODAD-IHADCB(R2)     Set up
         ST    R1,DCBEODAD-IHADCB(R2)      EODAD

*---------------------------------------------------------------------*
*                                                                     *
*  Open SYSIN                                                         *
*                                                                     *
*---------------------------------------------------------------------*

         MVC   @H_OPEN,H_OPEN           Move OPEN parms
         L     R2,@H_SYSIN_DCB_Ptr      POINT TO THE DCB
         OPEN  ((2),INPUT),MODE=31,MF=(E,@H_OPEN) AND OPEN IT
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN  IS IT OPEN?
         BZ    H9000                  NO, SKIP

H0020    DS    0H
         L     R10,@_ODT_Ptr          A(ODT Table)
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST

H0030    DS    0H

*------------------------------------------------------------------*
*                                                                  *
*    Read a control card from SYSIN, and print it.                 *
*                                                                  *
*------------------------------------------------------------------*

         L     R1,@H_SYSIN_DCB_Ptr    A(SYSIN DCB)
         GET   (1)                    READ A SYSIN RECORD
         LR    R2,R1                  SAVE A(INPUT RECORD)
         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)
         LH    R3,DCBLRECL-IHADCB(R15) GET SYSIN RECORD LENGTH
         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)
         CH    R3,@_SYSPRINT_Rec_Len  CAN WE FIT SYSIN ON SYSPRINT?
         BNH   H0040                  YES, SKIP
         LH    R3,@_SYSPRINT_Rec_Len  NO, PUT AS MUCH AS WE CAN
H0040    DS    0H
         SH    R3,=H'1'               GET EXECUTE LENGTH
         EX    R3,H9998               MOVE TO SYSPRINT RECORD
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                AND WRITE IT
         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)
         LH    R3,DCBLRECL-IHADCB(R15) INPUT RECORD LENGTH

*------------------------------------------------------------------*
*                                                                  *
*    If it is a comment ('*' in Col 1), ignore it.                 *
*                                                                  *
*------------------------------------------------------------------*

         CLI   0(R2),C'*'             Is this a comment?
         BE    H0030                  Yes, get another record

*------------------------------------------------------------------*
*                                                                  *
*    Otherwise, skip leading blanks.                               *
*                                                                  *
*------------------------------------------------------------------*

H0050    DS    0H
         CLI   0(R2),C' '             IS THIS A LEADING BLANK?
         BNE   H0060                  NO, SKIP
         LA    R2,1(0,R2)             YES, BUMP INPUT POINTER
         BCT   R3,H0050               AND CHECK NEXT CHARACTER
         B     H0030                  ALL BLANK, IGNORE IT
H0060    DS    0H


*------------------------------------------------------------------*
*                                                                  *
*    At this point, R2 --> first non-blank character               *
*                   R3 = nbr characters left on input record       *
*                                                                  *
*------------------------------------------------------------------*

         LA    R4,H_Keyword_Table     A(Keyword Table)
         LA    R5,H_Keyword_Table_End A(End of Keyword Table)
H0070    DS    0H
         LA    R15,8                  Set return code, just in case
         CR    R4,R5                  End of Table?
         BNL   H0100                  Yes, skip
         SLR   R15,R15                No, clear R15
         IC    R15,H_Keyword_Len-H_Keyword_Table(R4) Get len of Keyword
         CR    R15,R3                 Could this be it?
         BNL   H0080                  No, check next keyword
         EX    R15,H9999              Yes, is this it?
         BE    H0090                  Yes, skip
H0080    DS    0H
         LA    R4,1+L'H_Keyword_Rtn+L'H_Keyword_Len(R15,R4)
         B     H0070                  Check out next entry
H0090    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We have identified the keyword - point R2 to the start of the  *
*   operand field, adjust the length remaining, and go process the  *
*   keyword stuff.                                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,1(R15,R2)           A(START OF OPERANDS)
         ST    R2,@H_Parms            Save it
         SR    R3,R15                 ADJUST LENGTH REMAINING
         SH    R3,=H'1'               SET IT UP PROPERLY
         BNP   H0100                  INVALID, SKIP
         ST    R3,@H_Parms+4          Save it
         ST    R10,@H_Parms+8         Save A(ODT Entry)
         LA    R1,@H_Parms            A(Parameters)
         L     R15,H_Keyword_Rtn-H_Keyword_Table(R4) A(Proc Rtn)
         BASR  R14,R15                Go process keyword operands
         LTR   R15,R15                OK?
         BNZ   H0100                  No, error message

         LM    R2,R3,@H_Parms         Reload our registers
         L     R10,@H_Parms+8         A(Current ODT Entry)

*-------------------------------------------------------------------*
*                                                                   *
*    We are back: R2 --> next byte after operands, and              *
*                 R3 = length remaining                             *
*    If r2 is not pointing to a space, we have more keywords to     *
*   look for; if not, we are finished with this record.             *
*                                                                   *
*-------------------------------------------------------------------*

         LTR   R3,R3                  Anything left?
         BNP   H0030                  No, go get next record
         CLI   0(R2),C' '             Yes, are we done?
         BE    H0030                  Yes, get next record
         CLI   0(R2),C','             No, is it a separator?
         LA    R15,4                  Set return code, just in case
         BNE   H0100                  Not a separator, error
         LA    R2,1(0,R2)             Yes, skip separator
         BCT   R3,H0060               and check next keyword
         LA    R15,4                  Non-blank last char, error
H0100    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We have found an error in the control cards - tell the user.   *
*                                                                   *
*-------------------------------------------------------------------*

         C     R15,@H_rc              Is this the highest return code?
         BNH   H0110                  No, skip
         ST    R15,@H_rc              Yes, save it
H0110    DS    0H
         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)
         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)
         S     R2,DCBRECAD-IHADCB(R15) R2=Offset of error
         LA    R2,1(R1,R2)            R2 = A(Column of error)
         MVI   0(R2),C'?'             Move a flag
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                Go print it
         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)
         MVC   5(55,R1),=C'Error detected above ''?'' - remainder of re*
               cord ignored.'
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                Go print it
         B     H0030                  Read another record

*-------------------------------------------------------------------*
*                                                                   *
*    The following is the EOD exit when 31-bit SAM is not supported *
*   for SYSIN. This code is moved to 24-bit storage, and is invoked *
*   by SYSIN EOD. All it does is branch to out 'real' EOD routine,  *
*   in 31-bit mode.                                                 *
*                                                                   *
*-------------------------------------------------------------------*

H800024_Start DS 0H                  Start of 24-bit EOD Routine
         PUSH  USING                  Save current USINGs
         DROP  ,                      No USINGs now
         BALR  R15,0                  Load up our base
         USING *,R15                  Tell the Assembler
         L     R15,H800024_EOD        Get real EODAD
         BSM   0,R15                  and go do it (in 31-bit mode)
H800024_EOD DC AL4(X'80000000'+H8000) Real EODAD
         DROP  R15                    Free up our base reg
H800024_Length EQU *-H800024_Start   Length of 24-bit EOD Routine
         POP   USING                  Restore USING environment


H8000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'Real' End-Of-File exit for SYSIN: Close SYSIN                 *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',@H_SYSIN_DCB_Ptr A(SYSIN DCB)
         BZ    H8020                  None, skip
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN SYSIN OPEN?
         BZ    H8010                  No, better not close it
         MVC   @H_CLOSE,H_CLOSE       Yes, move close parms
         L     R2,@H_SYSIN_DCB_Ptr    Point to the DCB
         CLOSE ((2)),MODE=31,MF=(E,@H_CLOSE)  and close it
H8010    DS    0H
         L     R1,@H_SYSIN_DCB_Ptr    A(Below-the-line storage)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_24Bit_Stack_Ptr   on this stack

H8020    DS    0H
         B     H9000                  Exit


H9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R3,@H_rc                 Rescue the return code

         LA    R1,@H_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

H9998 MVC      0(0,R1),0(R2)          Move SYSIN record to SYSPRINT
H9999 CLC      0(0,R2),H_Keyword-H_Keyword_Table(R4) Check keyword

*-------------------------------------------------------------------*
*                                                                   *
*    Table of command card Keywords, and A(Processing Routines).    *
*                                                                   *
*-------------------------------------------------------------------*

H_Keyword_Table EQU  *
*
H_Keyword_Rtn   DC    AL4(HA0010)            A(PROCESSING ROUTINE)
H_Keyword_Len   DC    AL1(5)                 EXECUTE LEN OF KEYWORD
H_Keyword       DC    C'START='              KEYWORD
*
                DC    AL4(HA0010)            A(PROCESSING ROUTINE)
                DC    AL1(3)                 EXECUTE LEN OF KEYWORD
                DC    C'END='                KEYWORD

                DC    AL4(HB0010)            A(PROCESSING ROUTINE)
                DC    AL1(5)                 EXECUTE LEN OF KEYWORD
                DC    C'PRINT='              KEYWORD

                DC    AL4(HC0010)            A(PROCESSING ROUTINE)
                DC    AL1(7)                 EXECUTE LEN OF KEYWORD
                DC    C'INCLUDE='            KEYWORD

                DC    AL4(HC0010)            A(PROCESSING ROUTINE)
                DC    AL1(7)                 EXECUTE LEN OF KEYWORD
                DC    C'EXCLUDE='            KEYWORD

                DC    AL4(HD0010)            A(PROCESSING ROUTINE)
                DC    AL1(7)                 EXECUTE LEN OF KEYWORD
                DC    C'JOBNAME='            KEYWORD

                DC    AL4(HE0010)            A(PROCESSING ROUTINE)
                DC    AL1(4)                 EXECUTE LEN OF KEYWORD
                DC    C'DATA='               KEYWORD

                DC    AL4(HF0010)            A(PROCESSING ROUTINE)
                DC    AL1(8)                 EXECUTE LEN OF KEYWORD
                DC    C'JOB/DATA='           KEYWORD

                DC    AL4(HG0010)            A(PROCESSING ROUTINE)
                DC    AL1(7)                 EXECUTE LEN OF KEYWORD
                DC    C'STOPAFT='            KEYWORD

                DC    AL4(HH0010)            A(PROCESSING ROUTINE)
                DC    AL1(6)                 EXECUTE LEN OF KEYWORD
                DC    C'INEXIT='             KEYWORD

                DC    AL4(HH0010)            A(PROCESSING ROUTINE)
                DC    AL1(7)                 EXECUTE LEN OF KEYWORD
                DC    C'OUTEXIT='            KEYWORD

                DC    AL4(HI0010)            A(PROCESSING ROUTINE)
                DC    AL1(6)                 EXECUTE LEN OF KEYWORD
                DC    C'OUTPUT='             KEYWORD

                DC    AL4(HJ0010)            A(PROCESSING ROUTINE)
                DC    AL1(6)                 EXECUTE LEN OF KEYWORD
                DC    C'PERIOD='             KEYWORD

                DC    AL4(HK0010)            A(PROCESSING ROUTINE)
                DC    AL1(8)                 EXECUTE LEN OF KEYWORD
                DC    C'SEQUENCE='           KEYWORD

                DC    AL4(HL0010)            A(PROCESSING ROUTINE)
                DC    AL1(8)                 EXECUTE LEN OF KEYWORD
                DC    C'CHECKVBS='           KEYWORD

                DC    AL4(HM0010)            A(PROCESSING ROUTINE)
                DC    AL1(8)                 EXECUTE LEN OF KEYWORD
                DC    C'WEEKENDS='           KEYWORD

H_Keyword_Table_End EQU *                END OF KEYWORD TABLE

         PUSH  PRINT
         PRINT NOGEN
H_SYSIN_DCB DCB  DDNAME=SYSIN,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,     +
               DCBE=H_SYSIN_DCBE
H_SYSIN_DCB_Length EQU *-H_SYSIN_DCB

H_SYSIN_DCBE DCBE RMODE31=BUFF,EODAD=H8000
H_SYSIN_DCBE_Length EQU  *-H_SYSIN_DCBE

H_SYSIN24_DCB DCB  DDNAME=SYSIN,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,   +
               EODAD=0
H_SYSIN24_DCB_Length EQU *-H_SYSIN24_DCB

H_OPEN   OPEN  (0,INPUT),MODE=31,MF=L
H_OPEN_Length  EQU   *-H_OPEN
H_CLOSE  CLOSE (0),MODE=31,MF=L
H_CLOSE_Length EQU   *-H_CLOSE
         POP   PRINT

         LTORG

@H_Dynam        DSECT                 Dynamic area for H
@H_Save         DS    18F              O/S Style save area
@H_Parms        DS    3AL4             Parm area
@H_rc           DS    FL4              Return code
@H_SYSIN_DCB_Ptr DS   AL4              A(SYSIN DCB)
@H_SYSIN_DCBE   DS    CL(H_SYSIN_DCBE_Length) Dynamic DCBE
@H_Macros       DS    0F               Macro area
@H_OPEN         DS    CL(H_OPEN_Length)
                ORG   @H_Macros
@H_CLOSE        DS    CL(H_CLOSE_Length)
                ORG
                DS    0D               Alignment
@H_DynLen       EQU   *-@H_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         EJECT
HA0010   DS    0H

         PUSH  USING

*-------------------------------------------------------------------*
*                                                                   *
*    'START='/'END=' Keyword Processor                              *
*             Validate Date and Times specified                     *
*    ON ENTRY, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    ON EXIT,  R15 =   0 - ALL OK, ODTE_Start/EndDate set           *
*                      4 - ERROR FOUND                              *
*                                                                   *
*-------------------------------------------------------------------*


         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HA0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HA_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HA_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HA_Dynam,R13            Assign a base
         L     R15,@HA_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of START=/END= keyword                    *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms
         L     R10,8(0,R1)              A(ODT Entry)

         LR    R15,R2                   Point to chars
         SH    R15,=HL2'2'               before operand
         CLC   =C'T=',0(R15)            START=
         BNE   HA0020                   No, must be END=
         OI    @HA_Start_Proc,L'@HA_Start_Proc Yes, set flag
         B     HA0030                   and skip
HA0020   DS    0H
         NI    @HA_Start_Proc,X'FF'-L'@HA_Start_Proc Off flag
         B     HA0030                   and skip
HA0030   DS    0H
         OI    @HA_Date_Proc,L'@HA_Date_Proc SAY WE ARE DOING DATE

*-------------------------------------------------------------------*
*                                                                   *
*    Check for our Date keywords                                    *
*                                                                   *
*-------------------------------------------------------------------*


         LA    R14,HA_Keyword_Table    A(Keyword Table)
         LA    R15,HA_Keyword_Table_End A(End of Keyword Table)
HA0040   DS    0H
         CR    R14,R15                End of Table?
         BNL   HA0070                 Yes, skip
         SLR   R1,R1                  No, clear work register
         IC    R1,HA_Keyword_Len-HA_Keyword_Table(R14) Get len of Kwd
         CR    R1,R3                  Could this be it?
         BNL   HA0050                 No, check next keyword
         EX    R1,HA9999              Yes, is this it?
         BE    HA0060                 Yes, skip
HA0050   DS    0H
         LA    R14,1+L'HA_Keyword_Rtn+L'HA_Keyword_Len(R1,R14)
         B     HA0040                 Check out next entry
HA0060   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We have identified the keyword - initialize our DateConv area  *
*   with the info we retrieved when we initialized (ie, Today) ...  *
*                                                                   *
*-------------------------------------------------------------------*

         MVC   @HA_DateConv_Area,@_DateConv_Area

*-------------------------------------------------------------------*
*                                                                   *
*    ... and go process it.                                         *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,HA_Keyword_Rtn-HA_Keyword_Table(R14) A(Proc Rtn)
         BR    R15                    Go process keyword operands

HA0070   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    COMMON 'START='/'END=' KEYWORD PROCESSING                      *
*                                                                   *
*-------------------------------------------------------------------*

HA0080   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SET UP THE TEMPORARY AREA WITH 0, AND POINT TO IT.             *
*                                                                   *
*-------------------------------------------------------------------*

         MVC   @HA_TEMP(7),=C'0000000' PRIME RECEIVING AREA
         LA    R4,@HA_TEMP            POINT TO IT
HA0090   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    AND COUNT THE NUMERIC CHARACTERS IN THE OPERAND.               *
*                                                                   *
*-------------------------------------------------------------------*

         CLI   0(R2),C'0'             IS THIS NUMERIC?
         BL    HA0100                 NO, SKIP
         CLI   0(R2),C'9'             SO FAR, REALLY NUMERIC?
         BH    HA0100                 NO, SKIP
         MVC   0(1,R4),0(R2)          YES, MOVE THE CHARACTER
         LA    R4,1(0,R4)             BUMP RECEIVING PTR
         LA    R2,1(0,R2)             POINT TO NEXT CHAR
         BCT   R3,HA0090              AND CHECK IT OUT
HA0100   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE EITHER FOUND A NON-NUMERIC CHARACTER (IE, A SEPARATOR),*
*   OR WE HAVE RUN OUT OF INPUT.                                    *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,@HA_TEMP            A(TEMP AREA)
         SR    R4,R0                  GET CHARS IN INPUT
         BNP   HA0140                 NO DATA, SKIP

*-------------------------------------------------------------------*
*                                                                   *
*    THE DATA SEEMS OK, SO WE WILL PACK IT.                         *
*              R1   = A(START OF TARGET FIELDS)                     *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @HA_Time_Proc,L'@HA_Time_Proc ARE WE DOING TIME?
         BO    HA0150                 YES, GO SET IT UP
         CH    R4,=H'5'               NO, IS DATE 5 CHARS?
         BNE   HA0110                 No, skip
         PACK  @HA_DBLWD,@HA_TEMP(5)  YES, PACK IT
         MVC   @HA_DBLWD+4(1),@_DateConv_Area+DConv_Date_SMFDate-DateCo+
               nv_Area                Move current century
         B     HA0120                 and skip
HA0110   DS    0H
         CH    R4,=H'7'               IS DATE 7 CHARS?
         BNE   HA8000                 NO, ERROR
         PACK  @HA_DBLWD,@HA_TEMP(7)  Yes, pack it
         SP    @HA_DBLWD,=P'1900000'  Adjust for SMF Date convention
HA0120   DS    0H
         TM    @HA_Start_Proc,L'@HA_Start_Proc Processing START=?
         BNO   HA0130                 No, must be END=
         ZAP   ODTE_StartDate-ODT_Entry(L'ODTE_StartDate,R10),@HA_DBLWD+
               +4(4)                  Save Start Date
         B     HA0140                 And skip
HA0130   DS    0H
         ZAP   ODTE_EndDate-ODT_Entry(L'ODTE_EndDate,R10),@HA_DBLWD+4(4+
               )                      Save End date
         B     HA0140                 And skip
HA0140   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    NOW SEE IF WE HAVE ANY MORE TO DO.                             *
*                                                                   *
*-------------------------------------------------------------------*

         LTR   R3,R3                  ANY INPUT LEFT?
         BZ    HA0180                 NO, WE'RE FINISHED
         CLI   0(R2),C'-'             IS THIS THE DATE SEPARATOR?
         BNE   HA0170                 NO, SKIP
         TM    @HA_Date_Proc,L'@HA_Date_Proc WERE WE DOING THE DATE?
         BNO   HA8000                 NO, ERROR

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE FOUND THE DATE/TIME SEPARATOR, SO WE WILL GO DO THE    *
*   TIME                                                            *
*                                                                   *
*-------------------------------------------------------------------*

         NI    @HA_Date_Proc,X'FF'-L'@HA_Date_Proc  Yes, Off Date flag
         OI    @HA_Time_Proc,L'@HA_Time_Proc Now we are doing time
         LA    R2,1(0,R2)             POINT OVER THE SEPARATOR
         BCT   R3,HA0080              AND DO THE TIME
         B     HA8000                 SEPARATOR BUT NO TIME, ERROR
HA0150   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE FOUND THE TIME, SPECIFIED AS HHMMSS - WE MUST          *
*   CONVERT IT TO SECONDS*100 SINCE MIDNIGHT                        *
*                                                                   *
*-------------------------------------------------------------------*

         XC    @HA_DateConv_Area,@HA_DateConv_Area Clear Date area
         PACK  @HA_DBLWD,@HA_TEMP(2)  PACK HH
         CVB   R15,@HA_DBLWD          BINARIZE IT
         STC   R15,@HA_DateConv_Area+DConv_Time_hh-DateConv_Area
         PACK  @HA_DBLWD,@HA_TEMP+2(2) GET NBR MINUTES
         CVB   R15,@HA_DBLWD          BINARIZE THEM
         STC   R15,@HA_DateConv_Area+DConv_Time_mm-DateConv_Area
         PACK  @HA_DBLWD,@HA_TEMP+4(2) PACK SECONDS
         CVB   R15,@HA_DBLWD          BINARIZE THEM
         STC   R15,@HA_DateConv_Area+DConv_Time_ss-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DCo+
               nv_Input_hhmmss       Indicate Time conversion
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get seconds since midnight
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         L     R15,@HA_DateConv_Area+DConv_Time-DateConv_Area
         TM    @HA_Start_Proc,L'@HA_Start_Proc Processing START=?
         BNO   HA0160                 No, must be END=
         ST    R15,ODTE_StartTime-ODT_Entry(R10) Save Start Time
         B     HA0170                 And skip
HA0160   DS    0H
         ST    R15,ODTE_EndTime-ODT_Entry(R10) Save End Time
         B     HA0170                 And skip
HA0170   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE FOUND A NON-NUMERIC CHARACTER - WE WILL EXIT, WITH     *
*   THE RETURN CODE 0 IF IT IS A VALID SEPARATOR, 4 IF IT IS NOT.   *
*                                                                   *
*-------------------------------------------------------------------*

         CLI   0(R2),C','             IS THIS A VALID SPEARATOR?
         BE    HA0180                 YES, SKIP
         CLI   0(R2),C' '             NO, TRY AGAIN
         BNE   HA8000                 INVALID CHARACTER, ERROR
HA0180   DS    0H
         SLR   R15,R15                CLEAR RETURN CODE
         B     HA9000                 AND EXIT

HA1000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    START/END=TODAY                                                *
*     On Entry, R2 = A("TODAY")                                     *
*               R3 = Nbr chars left                                 *
*     On Exit,  R2 ---> Byte after "TODAY"                          *
*               R3 = Nbr Chars left                                 *
*               @HA_DBLWD contains SMF Date                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,5(0,R2)             Adjust pointer
         SH    R3,=HL2'5'             Adjust chars remaining
         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+
               Area(L'DConv_Date_SMFDate) Set up Date
         B     HA0120                 and exit

HA2000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    START/END=(TODAY-n)                                            *
*     On Entry, R2 = A("(TODAY-")                                   *
*               R3 = Nbr chars left                                 *
*     On Exit,  R2 ---> Byte after "(TODAY-n)"                      *
*               R3 = Nbr Chars left                                 *
*               @HA_DBLWD contains SMF Date                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,7(0,R2)             Adjust pointer
         SH    R3,=HL2'7'             Adjust chars remaining
         BNP   HA8000                 Error, exit
         LR    R14,R2                 Save A(start)
HA2010   DS    0H
         CLI   0(R2),C')'             Closing paren?
         BE    HA2020                 Yes, skip
         CLI   0(R2),C'0'             No, is it numeric?
         BL    HA8000                 No, error
         CLI   0(R2),C'9'             So far, is it really?
         BH    HA8000                 No, error
         LA    R2,1(0,R2)             Yes, bump pointer
         BCT   R3,HA2010              and try again
         B     HA8000                 No closing paren, error
HA2020   DS    0H
         LR    R15,R2                 A(closing paren)
         SR    R15,R14                Length of numerics
         BNP   HA8000                 Nothing, error
         S     R15,=FL4'1'            EX length
         EX    R15,HA2999             Pack it
         CVB   R15,@HA_DBLWD          Binarize it
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         SR    R14,R15                Adjust Base date
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+
               Area(L'DConv_Date_SMFDate) Set up Date
         LA    R2,1(0,R2)            Point past closing paren
         S     R3,=FL4'1'            Adjust length remaining
         B     HA0120                 and exit

HA2999   PACK  @HA_DBLWD,0(0,R14)     Pack offset from today

HA3000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    START/END=YESTERDAY                                            *
*     On Entry, R2 = A("YESTERDAY"                                  *
*               R3 = Nbr chars left                                 *
*     On Exit,  R2 ---> Byte after "YESTERDAY"                      *
*               R3 = Nbr Chars left                                 *
*               @HA_DBLWD contains SMF Date                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,9(0,R2)             Adjust pointer
         SH    R3,=HL2'9'             Adjust chars remaining
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         S     R14,=FL4'1'            Adjust Base date
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+
               Area(L'DConv_Date_SMFDate) Set up Date
         B     HA0120                 and exit

HA4000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    START/END=THISWEEK                                             *
*     On Entry, R2 = A("THISWEEK")                                  *
*               R3 = Nbr chars left                                 *
*     On Exit,  R2 ---> Byte after "THISWEEK"                       *
*               R3 = Nbr Chars left                                 *
*               @HA_DBLWD contains SMF Date                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,8(0,R2)             Adjust pointer
         SH    R3,=HL2'8'             Adjust chars remaining
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         SLR   R15,R15                Clear work register
         IC    R15,@HA_DateConv_Area+DConv_Date_DOW-DateConv_Area
         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=
         BNO   HA4010                 No, skip
         SR    R14,R15                Yes, back up to Monday
         B     HA4020                 and skip
HA4010   DS    0H
         LA    R0,6                   Day-of-week for Sunday
         SR    R0,R15                 Nbr days until Sunday
         AR    R14,R0                 Adjust base date
HA4020   DS    0H
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+
               Area(L'DConv_Date_SMFDate) Set up Date
         B     HA0120                 and exit

HA5000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    START/END=LASTWEEK                                             *
*     On Entry, R2 = A("LASTWEEK")                                  *
*               R3 = Nbr chars left                                 *
*     On Exit,  R2 ---> Byte after "LASTWEEK"                       *
*               R3 = Nbr Chars left                                 *
*               @HA_DBLWD contains SMF Date                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,8(0,R2)             Adjust pointer
         SH    R3,=HL2'8'             Adjust chars remaining
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         S     R14,=FL4'7'            Back up a week
         SLR   R15,R15                Clear work register
         IC    R15,@HA_DateConv_Area+DConv_Date_DOW-DateConv_Area
         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=
         BNO   HA5010                 No, skip
         SR    R14,R15                Yes, back up to Monday
         B     HA5020                 and skip
HA5010   DS    0H
         LA    R0,6                   Day-of-week for Sunday
         SR    R0,R15                 Nbr days until Sunday
         AR    R14,R0                 Adjust base date
HA5020   DS    0H
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+
               Area(L'DConv_Date_SMFDate) Set up Date
         B     HA0120                 and exit

HA6000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    START/END=THISMONTH                                            *
*     On Entry, R2 = A("THISMONTH")                                 *
*               R3 = Nbr chars left                                 *
*     On Exit,  R2 ---> Byte after "THISMONTH"                      *
*               R3 = Nbr Chars left                                 *
*               @HA_DBLWD contains SMF Date                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,9(0,R2)             Adjust pointer
         SH    R3,=HL2'9'             Adjust chars remaining
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         SLR   R15,R15
         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area
         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=
         BNO   HA6010                 No, skip
         S     R15,=FL4'1'            Yes, nbr days past the 1st
         SR    R14,R15                Back up to the 1st
         B     HA6020                 and skip
HA6010   DS    0H
         LA    R0,27                  Minimum days-per-month-1
         SR    R0,R15                 Nbr days until the 27th
         AR    R14,R0                 Adjust base date
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         SLR   R0,R0                  Clear work register
         IC    R0,@HA_DateConv_Area+DConv_Date_MM-DateConv_Area Get mon
HA6012   DS    0H
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         A     R14,=FL4'1'            Bump a day
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         SLR   R15,R15               Clear work register
         IC    R15,@HA_DateConv_Area+DConv_Date_MM-DateConv_Area
         CR    R15,R0                Same month?
         BE    HA6012                Yes, bump again
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         S     R14,=FL4'1'           Back up a day
HA6020   DS    0H
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+
               Area(L'DConv_Date_SMFDate) Set up Date
         B     HA0120                 and exit

HA7000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    START/END=LASTMONTH                                            *
*     On Entry, R2 = A("LASTMONTH")                                 *
*               R3 = Nbr chars left                                 *
*     On Exit,  R2 ---> Byte after "LASTMONTH"                      *
*               R3 = Nbr Chars left                                 *
*               @HA_DBLWD contains SMF Date                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R2,9(0,R2)             Adjust pointer
         SH    R3,=HL2'9'             Adjust chars remaining
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         SLR   R15,R15
         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area
         SR    R14,R15                Last day of prev month
         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=
         BNO   HA7020                 No, all done

         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         SLR   R15,R15               Clear work register
         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area
         S     R15,=FL4'1'           Nbr days until the 1st
         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         SR    R14,R15               Back up to the 1st
HA7020   DS    0H
         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area
         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+
               _Input_Base           Indicate Base Date
         LA    R1,@HA_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go new SMFDate
         LTR   R15,R15               Everything OK?
         BNZ   HA8000

         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+
               Area(L'DConv_Date_SMFDate) Set up Date
         B     HA0120                 and exit

HA8000   DS    0H
         LA    R15,4                  SET RETURN CODE
         B     HA9000                 AND EXIT
HA9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HA_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

HA9999 CLC     0(0,R2),HA_Keyword-HA_Keyword_Table(R14) Check keyword

HA_Time   TIME  LINKAGE=SYSTEM,MF=L
HA_Time_Length EQU *-HA_Time

HA_Keyword_Table EQU *

HA_Keyword_Rtn  DC    AL4(HA1000)            A(PROCESSING ROUTINE)
HA_Keyword_Len  DC    AL1(4)                 EXECUTE LEN OF KEYWORD
HA_Keyword      DC    C'TODAY'               KEYWORD

                DC    AL4(HA2000)            A(PROCESSING ROUTINE)
                DC    AL1(6)                 EXECUTE LEN OF KEYWORD
                DC    C'(TODAY-'             KEYWORD

                DC    AL4(HA3000)            A(PROCESSING ROUTINE)
                DC    AL1(8)                 EXECUTE LEN OF KEYWORD
                DC    C'YESTERDAY'           KEYWORD

                DC    AL4(HA4000)            A(PROCESSING ROUTINE)
                DC    AL1(7)                 EXECUTE LEN OF KEYWORD
                DC    C'THISWEEK'            KEYWORD

                DC    AL4(HA5000)            A(PROCESSING ROUTINE)
                DC    AL1(7)                 EXECUTE LEN OF KEYWORD
                DC    C'LASTWEEK'            KEYWORD

                DC    AL4(HA6000)            A(PROCESSING ROUTINE)
                DC    AL1(8)                 EXECUTE LEN OF KEYWORD
                DC    C'THISMONTH'           KEYWORD

                DC    AL4(HA7000)            A(PROCESSING ROUTINE)
                DC    AL1(8)                 EXECUTE LEN OF KEYWORD
                DC    C'LASTMONTH'           KEYWORD

HA_Keyword_Table_End EQU *                END OF KEYWORD TABLE

         LTORG

@HA_Dynam       DSECT                 Dynamic area for HA
@HA_Save        DS    18F              O/S Style save area
@HA_DBLWD       DS    D                Work area
@HA_TEMP        DS    CL7              Work area
                DS    X                Flag Byte
@HA_Start_Proc  EQU   *-1,X'80'         1... .... Processing START=
@HA_Date_Proc   EQU   *-1,X'02'         .... ..1. Processing Date
@HA_Time_Proc   EQU   *-1,X'01'         .... ...1 Processing Time
@HA_Macros      DS    0F
@HA_Time        DS    CL(HA_Time_Length) L-Form of Time
@HA_TimeArea    DS    CL16             Return area for Time
                ORG   @HA_Macros
@HA_DateConv_Area DS  CL(DConv_Area_Length)
                ORG
                DS    0D               Alignment
@HA_DynLen      EQU   *-@HA_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         EJECT
HB0010   DS    0H

         PUSH  USING

*-------------------------------------------------------------------*
*                                                                   *
*    'PRINT=' Keyword PROCESSOR.                                    *
*             VALID VALUES ARE:                                     *
*                     "NO"     - DO NOT PRINT SELECTED RECORDS      *
*                     "EBCDIC" - PRINT SELECTED RECORDS IN EBCDIC   *
*                                ONLY                               *
*    ON ENTRY, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    ON EXIT,  R15 =   0 - ALL OK, ODTE_Print_NO flag set           *
*                      4 - ERROR FOUND                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HB0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HB_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HB_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HB_Dynam,R13            Assign a base
         L     R15,@HB_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of PRINT= keyword                         *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms
         L     R10,8(0,R1)              A(ODT Entry)

*-------------------------------------------------------------------*
*                                                                   *
*    CHECK FOR "NO" KEYWORD.                                        *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?
         BNH   HB8000                 NO, ERROR
         CLC   0(2,R2),=C'NO'         YES, IS THIS IT?
         BNE   HB0020                 NO, skip
         OI    ODTE_Print_NO-ODT_Entry(R10),L'ODTE_Print_NO YES, SET
         LA    R2,2(0,R2)             POINT PAST LITERAL
         SH    R3,=H'2'               RESET LENGTH REMAINING
         SLR   R15,R15                ASSUME EVERYTHING IS OK
         CLI   0(R2),C' '             VALID SEPARATOR?
         BE    HB9000                 YES, OK
         CLI   0(R2),C','             NO, TRY AGAIN
         BE    HB9000                 YES, SKIP
         B     HB8000                 NO, ERROR
HB0020   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    CHECK FOR "EBCDIC" KEYWORD.                                    *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R3,=H'6'               ENOUGH ROOM LEFT FOR LITERAL?
         BNH   HB8000                 NO, ERROR
         CLC   0(6,R2),=C'EBCDIC'     YES, IS THIS IT?
         BNE   HB8000                 NO, ERROR
         OI    ODTE_Print_EB-ODT_Entry(R10),L'ODTE_Print_EB YES, SET
         LA    R2,6(0,R2)             POINT PAST LITERAL
         SH    R3,=H'6'               RESET LENGTH REMAINING
         SLR   R15,R15                ASSUME EVERYTHING IS OK
         CLI   0(R2),C' '             VALID SEPARATOR?
         BE    HB9000                 YES, OK
         CLI   0(R2),C','             NO, TRY AGAIN
         BE    HB9000                 YES, SKIP
         B     HB8000                 NO, ERROR
HB8000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                  FLAG AN ERROR
         B     HB9000                 AND EXIT
HB9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HB_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return


         LTORG

@HB_Dynam       DSECT                 Dynamic area for J
@HB_Save        DS    18F              O/S Style save area
                DS    0D               Alignment
@HB_DynLen      EQU   *-@HB_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         EJECT

HC0010   DS    0H

         PUSH  USING

*-------------------------------------------------------------------*
*                                                                   *
*    'INCLUDE=/EXCLUDE=' Keyword Processor                          *
*    ON ENTRY, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    ON EXIT,  R15 =   0 - All OK, ODTE_RTT_Ptr set                 *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HC0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HC_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HC_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HC_Dynam,R13            Assign a base
         L     R15,@HC_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of INCLUDE=/EXCLUDE= keyword              *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

         L     R10,8(0,R1)              A(ODT Entry)

         USING ODT_Entry,R10            Tell the assembler

         LR    R15,R2                   Back up to start of
         SH    R15,=HL2'8'               keyword
         CLI   0(R15),C'I'              Include?
         BNE   HC0020                   No, must be Exclude
         NI    @HC_Exclude,X'FF'-L'@HC_Exclude OFF 'EXCLUDE' FLAG
         B     HC0030                   and skip
HC0020   DS    0H
         OI    @HC_Exclude,L'@HC_Exclude Turn on Exclude flag
         B     HC0030                   and skip
HC0030   DS    0H


*-------------------------------------------------------------------*
*                                                                   *
*    CHECK THAT BOTH INCLUDE AND EXCLUDE HAVE NOT BEEN SPECIFIED.   *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)
         BZ    HC0050                None, skip
         TM    @HC_Exclude,L'@HC_Exclude Is this Exclude
         BO    HC0040                 YES, SKIP
         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude
         BO    HC8000                 Error, both INCLUDE= and EXCLUDE=
         B     HC0050                 AND CONTINUE
HC0040   DS    0H
         TM    RTT_Entry_Include-RecType_Tbl(R15),L'RTT_Entry_Include
         BO    HC8000                 Error, both INCLUDE= and EXCLUDE=
HC0050   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SET UP OUR TRANSLATE TABLE TO LOOK FOR NUMERICS AND SEPARATORS.*
*                                                                   *
*-------------------------------------------------------------------*

         MVI   @HC_RecType,X'00'       Init Record type
         XC    @HC_SubType,@HC_SubType   and sub-type
         NI    @HC_Paren,X'FF'-L'@HC_Paren Off flag
         NI    @HC_RecTyp,X'FF'-L'@HC_Rectyp Off flag
         NI    @HC_SubType_Present,X'FF'-L'@HC_SubType_Present

         MVI   @HC_TRTab,X'FE'        SET WHOLE TABLE TO
         MVC   @HC_TRTab+1(L'@HC_TRTab-1),@HC_TRTab INVALID VALUES
         MVI   @HC_TRTab+C'0',X'00'   NUMERICS ARE
         MVC   @HC_TRTab+C'1'(9),@HC_TRTab+C'0' VALID
         MVI   @HC_TRTab+C' ',X'01'   STOP ON A BLANK
         MVI   @HC_TRTab+C',',X'01'        AND A COMMA
         MVI   @HC_TRTab+C'(',X'01'        AND OPEN PARENS
         MVI   @HC_TRTab+C')',X'01'        AND CLOSE PARENS
         NI    @HC_RecTyp,X'FF'-L'@HC_RecTyp No rectype yet
         NI    @HC_Paren,X'FF'-L'@HC_Paren No parens either
         CLI   0(R2),C'('             PAREN AROUND WHOLE STRING?
         BNE   HC0060                 NO, SKIP
         OI    @HC_Paren,L'@HC_Paren  Yes, set our flag
         LA    R2,1(0,R2)             POINT PAST IT
         SH    R3,=H'1'               AND REDUCE LENGTH
HC0060   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    FIND NEXT SEPARATOR.                                           *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R4,R2                 SAVE R2
         LR    R5,R2                 AND AGAIN
         SLR   R2,R2                 AND CLEAR FUNCTION BYTE
         SH    R3,=H'1'              EXECUTE LENGTH
         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE
         EX    R3,HC9998             TRANSLATE
         LR    R0,R2                 SAVE FUNCTION BYTE
         LR    R2,R5                 RESTORE A(START)
         LR    R4,R1                 A(SEPARATOR)
         SR    R4,R2                 R4 = LEN OF DATA

*-------------------------------------------------------------------*
*                                                                   *
*    AT THIS POINT, R2 = A(START OF DATA)                           *
*                   R3 = LENGTH OF DATA LEFT IN SYSIN RECORD        *
*                   R4 = LEN OF STRING (IE, R2+R4 = A(SEPARATOR)).  *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R0,=H'240'            ILLEGAL CHARACTER?
         BNL   HC8000                YES, SKIP
         LTR   R4,R4                 ANY DATA THERE?
         BNP   HC8000                NONE, ERROR
         CH    R4,=H'3'              YES, IS IT TOO LONG?
         BH    HC8000                YES, ERROR
         LR    R15,R4                NO, GET LEN OF STRING
         SH    R15,=H'1'             EXECUTE LENGTH
         EX    R15,HC9999            PACK IT
         CVB   R1,@HC_DBLWD          AND BINARIZE IT
         LA    R15,0(R2,R4)          POINT TO SEPARATOR
         TM    @HC_RecTyp,L'@HC_RecTyp HAVE WE ALREADY GOT RECTYPE?
         BZ    HC0070                NO, SKIP
         CLI   0(R15),C')'           YES, IS THIS END OF SUBTYPE?
         BNE   HC8000                NO, ERROR
         LA    R4,1(0,R4)            YES, BUMP PAST IT
         STH   R1,@HC_SubType        SAVE SUBTYPE
         OI    @HC_SubType_Present,L'@HC_SubType_Present Set flag
         B     HC0080                AND SKIP
HC0070   DS    0H
         STC   R1,@HC_RecType        SAVE RECORD TYPE
         CLI   0(R15),C'('           START OF SUBTYPE?
         BNE   HC0080                NO, SKIP
         OI    @HC_RecTyp,L'@HC_RecTyp YES, SAY WE HAVE RECORD TYPE
         LA    R2,1(R2,R4)           POINT PAST OPEN PAREN
         SR    R3,R4                 ADJUST LENGTH REMAINING
         SH    R3,=H'1'                PROPERLY
         B     HC0060                AND KEEP GOING
HC0080   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WHEN WE GET HERE, @HC_RecType CONTAINS THE RECORD TYPE,        *
*                      @HC_SubType CONTAINS THE SUBTYPE             *
*    AND WE GO TO FIND A FREE ENTRY IN THE RECTYPE TABLE            *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,10                 INITIAL NBR ENTRIES IN TBL
         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)
         BZ    HC0090                NONE, SKIP
         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) YES, GET NBR ENTRIES
         LA    R1,1(0,R1)            ADD ONE FOR OUR NEW ENTRY
         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY
         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES
         LA    R1,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN
         L     R0,RTT_Subp_Len-RecType_Tbl(R15) GET LEN
         SLL   R0,8                  GET RID OF
         SRL   R0,8                    SUBPOOL
         CR    R0,R1                 IS THE TABLE BIG ENOUGH?
         BNL   HC0110                YES, GO INSERT ENTRY
         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) NO, GET NBR ENTRIES
         SLL   R1,1                  DOUBLE THEM
HC0090   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    EITHER THE RECORD TYPE TABLE DOESN'T EXIST, OR IT IS TOO       *
*    SMALL TO HOLD OUR ENTRY, SO WE HAVE TO GO AND GET A NEW TABLE. *
*    R1 CONTAINS THE NUMBER OF ENTRIES THAT SHOULD BE IN THE TABLE. *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY
         MR    R0,R0                 GET LENGTH OF ENTRIES
         LA    R0,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(0),               this long                     +
               LOC=ANY                   anywhere
         ST    R0,@HC_DBLWD          SAVE SUBPOOL AND LENGTH
         ST    R1,@HC_DBLWD+4        SAVE A(TABLE)

*-------------------------------------------------------------------*
*                                                                   *
*    Move the old table to the new, or just clear the table if      *
*   there is no old table                                           *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R0,R1                 A(New TABLE) IN R0
         L     R1,@HC_DBLWD          LEN IN R1
         SLR   R15,R15               Assume no old table
         ICM   R14,B'1111',ODTE_RTT_Ptr GET A(OLD TABLE)
         BZ    HC0095                NONE, SKIP
         L     R15,RTT_Subp_Len-RecType_Tbl(R14) YES, GET CURR LEN
         SLL   R15,8                 CLEAR OUT
         SRL   R15,8                  SUBPOOL
HC0095   DS    0H
         MVCL  R0,R14                MOVE OLD TABLE TO NEW

         ICM   R1,B'1111',ODTE_RTT_Ptr  GET A(OLD TABLE)
         BZ    HC0100                   None, skip
         L     R0,RTT_Subp_Len-RecType_Tbl(R1) GET ITS LENGTH
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
HC0100   DS    0H
         L     R15,@HC_DBLWD+4       A(NEW TABLE)
         ST    R15,ODTE_RTT_Ptr      SAVE IT
         MVC   RTT_Subp_Len-RecType_Tbl(L'RTT_Subp_Len,R15),@HC_DBLWD
         LH    R0,RTT_Entry_Count-RecType_Tbl(R15)
         LTR   R0,R0                 Are we creating table?
         BNZ   HC0110                No, skip
         TM    @HC_Exclude,L'@HC_Exclude Yes, are we EXCLUDEing?
         BO    HC0105                Yes, skip
         OI    RTT_Entry_Include-RecType_Tbl(R15),L'RTT_Entry_Include
         B     HC0110                and skip
HC0105   DS    0H
         OI    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude
HC0110   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    AND NOW INSERT THE RECORD TYPE AND SUBTYPE IN THE TABLE.       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,ODTE_RTT_Ptr      A(RECORD TYPE TABLE)
         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) GET NBR ENTRIES
         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY
         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES
         LA    R1,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN
         AR    R1,R15                A(FREE ENTRY)
         MVC   RTTE_RecType-RTT_Entry(L'RTTE_RecType,R1),@HC_RecType
         NI    RTTE_SubType_Present-RTT_Entry(R1),X'FF'-L'RTTE_SubType_+
               Present
         TM    @HC_SubType_Present,L'@HC_SubType_Present SubType?
         BNO   HC0120                No, skip
         MVC   RTTE_SubType-RTT_Entry(L'RTTE_SubType,R1),@HC_SubType
         OI    RTTE_SubType_Present-RTT_Entry(R1),L'RTTE_SubType_Presen+
               t
HC0120   DS    0H

         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) GET NBR ENTRIES
         LA    R1,1(0,R1)            BUMP IT
         STH   R1,RTT_Entry_Count-RecType_Tbl(R15) SAVE IT

*-------------------------------------------------------------------*
*                                                                   *
*    SET UP TO FIND THE NEXT SUBENTRY.                              *
*                                                                   *
*-------------------------------------------------------------------*

         AR    R2,R4                 A(SEPARATOR)
         SR    R3,R4                 ADJUST LEN LEFT IN RECORD
         SLR   R15,R15               CLEAR RETURN CODE
         TM    @HC_Paren,L'@HC_Paren IS THE WHOLE MESS IN PARENS?
         BZ    HC9000                NO, EXIT
         NI    @HC_RecTyp,X'FF'-L'@HC_RecTyp YES, OFF FOUND FLAG
         MVI   @HC_RecType,X'00'     CLEAR RECORD TYPE
         XC    @HC_SubType,@HC_SubType AND SUBTYPE
         NI    @HC_SubType_Present,X'FF'-L'@HC_SubType_Present
         CLI   0(R2),C','            MORE RECORD TYPES?
         BNE   HC0130                NO, SKIP
         LA    R2,1(0,R2)            YES, BUMP PAST COMMA
         SH    R3,=H'1'              ADJUST LENGTH
         B     HC0060                AND TRY AGAIN
HC0130   DS    0H
         CLI   0(R2),C')'            IS THIS THE END?
         BNE   HC8000                NO, ERROR
         LA    R2,1(0,R2)            YES, POINT PAST CLOSING PAREN
         SH    R3,=H'1'              ADJUST LENGTH REMAINING
         NI    @HC_Paren,X'FF'-L'@HC_Paren AND OFF PAREN FLAG
         SLR   R15,R15               CLEAR RETURN CODE
         B     HC9000                AND EXIT
HC8000   DS    0H
         LA    R15,4                 SET RETURN CODE
         B     HC9000                AND EXIT
HC9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HC_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

HC9998 TRT     0(0,R5),@HC_TRTab     FIND ENDING CHARACTER
HC9999 PACK    @HC_DBLWD,0(0,R2)     PACK RECORD TYPE/SUBTYPE

         LTORG

@HC_Dynam       DSECT                 Dynamic area for J
@HC_Save        DS    18F              O/S Style save area
@HC_DBLWD       DS    D                Work area
@HC_RecType     DS    X                Record Type
@HC_SubType     DS    HL2              Record Type 30 Subtype
                DS    X                Flag Byte
@HC_Paren       EQU   *-1,X'80'         1... ....  IN PARENTHESES
@HC_RecTyp      EQU   *-1,X'40'         .1.. ....  RECTYPE FOUND
@HC_Exclude     EQU   *-1,X'20'         ..1. ....  EXCLUDE SPECIFIED
@HC_SubType_Present EQU *-1,X'10'       ...1 ....  SubType found
@HC_TRTab       DS    XL256            Translate table
                DS    0D               Alignment
@HC_DynLen      EQU   *-@HC_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R10                    ODT Entry base
         DROP  R11,R13
         POP   USING
         EJECT
HD0010   DS    0H

         PUSH  USING

*-------------------------------------------------------------------*
*                                                                   *
*    'JOBNAME=' Keyword Processor                                   *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, ODTE_JNT_Ptr updated             *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HD0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HD_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HD_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HD_Dynam,R13            Assign a base
         L     R15,@HD_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

         L     R10,8(0,R1)              A(ODT Entry)

         USING ODT_Entry,R10            Tell the assembler


*-------------------------------------------------------------------*
*                                                                   *
*    SET UP OUR TRANSLATE TABLE TO STOP ON SEPARATORS.              *
*                                                                   *
*-------------------------------------------------------------------*

         NI    @HD_Paren,X'FF'-L'@HD_Paren OFF PARENTHESES FLAG
         MVI   @HD_TRTab,X'00'        ANYTHING GOES IN A JOB NAME
         MVC   @HD_TRTab+1(L'@HD_TRTab-1),@HD_TRTab
         MVI   @HD_TRTab+C' ',X'01'   STOP ON A BLANK
         MVI   @HD_TRTab+C',',X'01'        AND A COMMA
         CLI   0(R2),C'('             PAREN AROUND WHOLE STRING?
         BNE   HD0020                 NO, SKIP
         OI    @HD_Paren,L'@HD_Paren  YES, SAY SO
         LA    R2,1(0,R2)             POINT PAST IT
         SH    R3,=H'1'               AND REDUCE LENGTH
         MVI   @HD_TRTab+C')',X'01'   STOP ON CLOSE PAREN TOO
HD0020   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    FIND NEXT SEPARATOR.                                           *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R4,R2                 SAVE R2
         LR    R5,R2                 AND AGAIN
         SLR   R2,R2                 AND CLEAR FUNCTION BYTE
         SH    R3,=H'1'              EXECUTE LENGTH
         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE
         EX    R3,HD9999             TRANSLATE
         LR    R0,R2                 SAVE FUNCTION BYTE
         LR    R2,R5                 RESTORE A(START)
         LR    R4,R1                 A(SEPARATOR)
         SR    R4,R2                 R4 = LEN OF DATA

*-------------------------------------------------------------------*
*                                                                   *
*    AT THIS POINT, R2 = A(START OF DATA)                           *
*                   R3 = LENGTH OF DATA LEFT IN SYSIN RECORD        *
*                   R4 = LEN OF STRING (IE, R2+R4 = A(SEPARATOR)).  *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R0,=H'240'            ILLEGAL CHARACTER?
         BNL   HD8000                YES, SKIP
         LTR   R4,R4                 ANY DATA THERE?
         BNP   HD8000                NONE, ERROR
         CH    R4,=H'8'              YES, IS IT TOO LONG?
         BH    HD8000                YES, ERROR

*-------------------------------------------------------------------*
*                                                                   *
*    WHEN WE GET HERE, R2 POINTS TO START OF JOBNAME,               *
*                      R4 CONTAINS ITS LENGTH                       *
*    AND WE GO TO FIND A FREE ENTRY IN THE JOBNAME TABLE            *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,10                 INITIAL NBR ENTRIES IN TBL
         ICM   R15,B'1111',ODTE_JNT_Ptr A(JOB NAME TABLE)
         BZ    HD0030                None, SKIP
         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) YES, GET NBR ENTRIES
         LA    R1,1(0,R1)            ADD ONE FOR OUR NEW ENTRY
         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY
         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES
         LA    R1,JNT_Entry-JobName_Tbl(0,R1) ADD TBL HEADER LEN
         L     R0,JNT_Subp_Len-JobName_Tbl(R15) GET CURR LEN
         SLL   R0,8                  GET RID OF
         SRL   R0,8                    SUBPOOL
         CR    R0,R1                 IS THE TABLE BIG ENOUGH?
         BNL   HD0050                YES, GO INSERT ENTRY
         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) NO, NBR ENTRIES
         SLL   R1,1                  DOUBLE THEM
HD0030   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    EITHER THE JOB NAME TABLE DOESN'T EXIST, OR IT IS TOO          *
*    SMALL TO HOLD OUR ENTRY, SO WE HAVE TO GO AND GET A NEW TABLE. *
*    R1 CONTAINS TRHE NUMBER OF ENTRIES THAT SHOULD BE IN THE TABLE.*
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY
         MR    R0,R0                 GET LENGTH OF ENTRIES
         LA    R0,JNT_Entry-JobName_Tbl+7(0,R1) ADD TBL HEADER LEN
         SRL   R0,3                  Make it a doubleword
         SLL   R0,3                   multiple
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(0),               this long                     +
               LOC=ANY                   anywhere
         ST    R0,@HD_JNT_Subp_Len   SAVE SUBPOOL AND LENGTH
         ST    R1,@HD_JNT_Pointer    SAVE A(TABLE)
         LR    R0,R1                 A(TABLE) IN R0
         L     R1,@HD_JNT_Subp_Len   LEN IN R1
         SLR   R14,R14               NOTHING IN R14
         SLR   R15,R15               AND IN 15
         MVCL  R0,R14                CLEAR THE TABLE
         ICM   R14,B'1111',ODTE_JNT_Ptr GET A(OLD TABLE)
         BZ    HD0040                None, SKIP

*-------------------------------------------------------------------*
*                                                                   *
*    THERE WAS AN OLD TABLE, SO WE HAVE TO COPY IT TO THE NEW TABLE *
*    AREA, AND THEN FREE UP THE OLD ONE.                            *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,JNT_Subp_Len-JobName_Tbl(R14) YES, GET CURR LENGTH
         SLL   R15,8                 CLEAR OUT
         SRL   R15,8                  SUBPOOL
         L     R0,@HD_JNT_Pointer    GET A(NEW TABLE)
         LR    R1,R15                SAME LENGTH
         MVCL  R0,R14                MOVE OLD TABLE TO NEW
         L     R1,ODTE_JNT_Ptr       GET A(OLD TABLE)
         L     R0,JNT_Subp_Len-JobName_Tbl(R1) GET ITS LENGTH
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
HD0040   DS    0H
         L     R15,@HD_JNT_Pointer   A(NEW TABLE)
         ST    R15,ODTE_JNT_Ptr      SAVE IT
         MVC   JNT_Subp_Len-JobName_Tbl(L'JNT_Subp_Len,R15),@HD_JNT_Sub+
               p_Len
HD0050   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    AND NOW INSERT THE JOB NAME IN THE TABLE.                      *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,ODTE_JNT_Ptr      A(JOB NAME TABLE)
         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) GET NBR ENTRIES
         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY
         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES
         LA    R1,JNT_Entry-JobName_Tbl(0,R1) ADD TBL HEADER LEN
         AR    R1,R15                A(FREE ENTRY)

*-------------------------------------------------------------------*
*                                                                   *
*    WE ARE NOW POINTING AT A FREE ENTRY IN THE JOBNAME TABLE -     *
*   IF THIS IS A PREFIX (IE, LAST CHAR IS AN '*'), CALCULATE THE    *
*   EXECUTE LEN AND SAVE IT; OTHERWISE, USE 7 AS THE EXECUTE LEN.   *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R14,L'JNTE_JobName-1  DEFAULT EXECUTE LENGTH
         LA    R15,0(R2,R4)          POINT PAST JOBNAME
         SH    R15,=H'1'             BACK UP A CHARACTER
         CLI   0(R15),C'*'           IS THIS JOBNAME A PREFIX?
         BNE   HD0060                NO, SKIP
         SH    R4,=H'1'              YES, DON'T INCLUDE THE ASTERISK
         LR    R14,R4                GET
         SH    R14,=H'1'              EXECUTE LENGTH
HD0060   DS    0H
         STC   R14,JNTE_JobName_Len-JNT_Entry(R1) SAVE IT

*-------------------------------------------------------------------*
*                                                                   *
*    MOVE THE JOBNAME/PREFIX TO THE TABLE.                          *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,JNTE_JobName-JNT_Entry(R1) A(JOBNAME FIELD)
         LA    R1,L'JNTE_JobName     LEN OF JOBNAME FIELD
         LR    R14,R2                A(JOBNAME)
         LA    R15,C' '              PAD CHARACTER
         SLL   R15,24                IN THE PROPER PLACE
         OR    R15,R4                INSERT LENGTH
         MVCL  R0,R14                MOVE JOBNAME
         L     R15,ODTE_JNT_Ptr      A(JOB NAME TABLE)
         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) GET NBR ENTRIES
         LA    R1,1(0,R1)            BUMP IT
         STH   R1,JNT_Entry_Count-JobName_Tbl(R15) SAVE IT

*-------------------------------------------------------------------*
*                                                                   *
*    SET UP TO FIND THE NEXT SUBENTRY.                              *
*                                                                   *
*-------------------------------------------------------------------*

         AR    R2,R4                 A(SEPARATOR)
         CLI   0(R2),C'*'            WAS THIS A PREFIX?
         BNE   HD0070                NO, SKIP
         LA    R2,1(0,R2)            YES, SKIP PAST THE ASTERISK
HD0070   DS    0H
         SR    R3,R4                 ADJUST LEN LEFT IN RECORD
         SLR   R15,R15               CLEAR RETURN CODE
         TM    @HD_Paren,L'@HD_Paren DO WE HAVE PARENS AROUND NAMES?
         BZ    HD9000                NO, EXIT
         CLI   0(R2),C','            YES, MORE JOBNAMES?
         BNE   HD0080                NO, ERROR
         LA    R2,1(0,R2)            YES, BUMP PAST COMMA
         SH    R3,=H'1'              ADJUST LENGTH
         B     HD0020                AND TRY AGAIN
HD0080   DS    0H
         CLI   0(R2),C')'            CLOSING PAREN?
         BNE   HD8000                NO, ERROR
         LA    R2,1(0,R2)            YES, POINT PAST IT
         SH    R3,=H'1'              ADJUST LENGTH REMAINING
         NI    @HD_Paren,X'FF'-L'@HD_Paren OFF PAREN FLAG
         B     HD9000                AND EXIT
HD8000   DS    0H
         LA    R15,4                 SET RETURN CODE
         B     HD9000                AND EXIT
HD9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HD_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

HD9999 TRT     0(0,R5),@HD_TRTab     FIND ENDING CHARACTER

         LTORG

@HD_Dynam       DSECT                 Dynamic area for HD
@HD_Save        DS    18F              O/S Style save area
@HD_JNT_Pointer DS    AL4              A(JobName Table)
@HD_JNT_Subp_Len DS   FL4              Subpool, length of JNT
@HD_TRTab       DS    XL256            Translate table
                DS    X                Flag byte
@HD_Paren       EQU   *-1,X'80'         1... .... In parentheses
                DS    0D               Alignment
@HD_DynLen      EQU   *-@HD_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R10
         DROP  R11,R13
         POP   USING
         EJECT
HE0010   DS    0H

         PUSH  USING

*-------------------------------------------------------------------*
*                                                                   *
*    'DATA=' Keyword Processor                                      *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, ODTE_DT_Ptr updated              *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HE0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HE_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HE_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HE_Dynam,R13            Assign a base
         L     R15,@HE_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

         L     R10,8(0,R1)              A(ODT Entry)

         USING ODT_Entry,R10            Tell the assembler

*-------------------------------------------------------------------*
*                                                                   *
*    Set up our translate table.                                    *
*                                                                   *
*-------------------------------------------------------------------*

         NI    @HE_Quote,X'FF'-L'@HE_Quote Off Quote flag
         NI    @HE_Hex,X'FF'-L'@HE_Hex    and hex flag
         MVC   @HE_TRTab,HE_EBCDIC_TRTab MOVE EBCDIC TRAN TABLE

         CH    R3,=H'1'               MORE THAN 1 CHARACTER LEFT?
         BNH   HE0070                 NO, NOT A QUOTED STRING
         CLI   0(R2),C''''            YES, START WITH A QUOTE?
         BE    HE0020                 YES, SKIP
         CLI   0(R2),C'"'             NO, DOUBLE QUOTE?
         BNE   HE0030                 NO, SKIP
HE0020   DS    0H
         SH    R2,=H'1'               BACK UP A BYTE
         AH    R3,=H'1'               SET UP LENGTH
         B     HE0040                 AND SKIP
HE0030   DS    0H
         CLI   1(R2),C''''            YES, SINGLE QUOTE?
         BE    HE0040                 YES, SKIP
         CLI   1(R2),C'"'             NO, DOUBLE QUOTE?
         BNE   HE0070                 NO, NO QUOTED STRING
HE0040   DS    0H
         OI    @HE_Quote,L'@HE_Quote    SAY WE'RE DOING A QUOTED STRING
         CLI   0(R2),C'C'             CHARACTER STRING?
         BE    HE0050                 YES, SKIP
         CLI   0(R2),C'='             QUOTES WITH NO C OR H?
         BE    HE0050                 YES, ASSUME CHARACTER DATA
         CLI   0(R2),C'X'             NO, HEX STRING?
         BNE   HE8000                 NO, ERROR
         OI    @HE_Hex,L'@HE_Hex      YES, SAY SO
         MVC   @HE_TRTab,HE_Hex_TRTab AND MOVE HEX CHARS TO TRANS TBL
         B     HE0060                 SKIP
HE0050   DS    0H
         MVI   @HE_TRTab,X'00'        ANYTHING GOES
         MVC   @HE_TRTab+1(L'@HE_TRTab-1),@HE_TRTab BETWEEN QUOTES
HE0060   DS    0H
         SLR   R0,R0                  CLEAR WORK REGISTER
         IC    R0,1(0,R2)             GET SEPARATOR CHARACTER
         LA    R15,@HE_TRTab          A(TRANSLATE TABLE)
         AR    R15,R0                 A(CHARACTER IN TRAN TBL
         MVI   0(R15),X'01'           STOP TRANSLATION THERE
         LA    R2,2(0,R2)             POINT PAST FIRST SEPARATOR
         SH    R3,=H'2'               AND ADJUST LENGTH
         BNP   HE8000                 NOTHING LEFT, ERROR
HE0070   DS    0H
         LR    R4,R2                 SAVE R2
         LR    R5,R2                 AND AGAIN
         SLR   R2,R2                 AND CLEAR FUNCTION BYTE
         SH    R3,=H'1'              EXECUTE LENGTH
         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE
         EX    R3,HE9997             TRANSLATE
         LR    R0,R2                 SAVE FUNCTION BYTE
         LR    R2,R1                 A(LAST CHARACTER)
         SR    R1,R4                 GET LENGTH OF DATA
         SR    R3,R1                 ADJUST LENGTH REMAINING
         AH    R3,=H'1'               PROPERLY
         CH    R0,=H'240'            ILLEGAL CHARACTER?
         BNL   HE8000                YES, SKIP
         LR    R4,R2                 NO, GET STARTING ADDRESS
         SR    R4,R5                 GET LEN OF DATA
         TM    @HE_Quote,L'@HE_Quote ARE WE DOING A QUOTED STRING?
         BNO   HE0110                NO, SKIP
         CH    R0,=H'1'              YES, DID WE GET A FINAL SEP?
         BNE   HE8000                NO, ERROR
         LA    R2,1(0,R2)            YES, POINT PAST IT
         SH    R3,=H'1'              AND ADJUST LENGTH REMAINING
         TM    @HE_Hex,L'@HE_Hex     ARE WE DOING HEX?
         BZ    HE0110                NO, SKIP
         STC   R4,@HE_DBLWD          YES, SAVE LENGTH
         TM    @HE_DBLWD,X'01'       IS LENGTH AN EVEN NUMBER
         BO    HE8000                NO, ERROR
         SRL   R4,1                  GET LENGTH OF CONVERTED HEX
         LR    R15,R5                A(START OF SOURCE)
         LR    R14,R5                A(START OF TARGET DATA
HE0080   DS    0H
         LA    R0,X'FF'              WHEN R0 GOES NEGATIVE, WE HAVE
         SLL   R0,16                   GOT ONE PACKED BYTE
HE0090   DS    0H
         CR    R15,R2                HAVE WE GONE FAR ENOUGH?
         BNL   HE0110                YES, SKIP
         IC    R1,0(0,R15)           GET BYTE OF SOURCE DATA
         CLI   0(R15),C'0'           IS IT X'C1' - X'C6'?
         BNL   HE0100                NO, OK
         LA    R1,9(0,R1)            YES, CONVERT TO X'CA' - X'CF'
HE0100   DS    0H
         SLL   R1,28                 GET LOW NIBBLE AT TOP OF R1
         SLDL  R0,4                  AND INTO R0
         LA    R15,1(0,R15)          BUMP SOURCE PTR
         LTR   R0,R0                 NO, HAVE WE DONE 2 SOURCE BYTES?
         BNL   HE0090                NOT YET, CONTINUE
         STC   R0,0(0,R14)           YES, SAVE HEX BYTE
         LA    R14,1(0,R14)          BUMP DEST PTR
         B     HE0080                AND CONTINUE
HE0110   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WHEN WE GET HERE, R2 = A(NEXT CHARACTER AFTER DATA)            *
*                      R4 = LENGTH OF DATA,                         *
*                      R5 = A(START OF DATA)                        *
*    IF THE DATA WAS IN HEX (ENTERED AS X'123456'), IT HAS BEEN     *
*   CONVERTED, AND R4 REFLECTS THE NEW LENGTH.                      *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE)
         BZ    HE0140                None, GO GET ONE
         LH    R14,DT_Entry_Count-Data_Tbl(R15) YES, GET NBR ENTRIES
         LA    R15,DT_Entry-Data_Tbl(R15) AND POINT TO THE FIRST ONE
         LTR   R14,R14               ARE THERE ANY ENTRIES?
         BZ    HE0130                NO, SKIP
HE0120   DS    0H
         SLR   R1,R1                 CLEAR WORK REGISTER
         IC    R1,DTE_Length-DT_Entry(R15) GET LEN OF DATA
         LA    R15,DTE_Data-DT_Entry+1(R1,R15) A(NEXT ENTRY
         BCT   R14,HE0120            AND GO TILL THE END
HE0130   DS    0H
         LA    R14,DTE_Data-DT_Entry(R4,R15) A(END OF OUR NEW ENT)
         S     R14,ODTE_DT_Ptr       LENGTH OF UPDATED TABLE
         L     R1,ODTE_DT_Ptr        A(TABLE)
         L     R1,DT_Subp_Len-Data_Tbl(R1) GET CURRENT LENGTH
         SLL   R1,8                  GET RID OF
         SRL   R1,8                    SUBPOOL
         CR    R1,R14                WILL OUR ENTRY FIT?
         BNL   HE0170                YES, GO DO IT
HE0140   DS    0H
         LA    R0,128                DEFAULT SUBPOOL AND LENGTH
         ICM   R1,B'1111',ODTE_DT_Ptr GET A(CURRENT TABLE)
         BZ    HE0150                None, SKIP
         L     R1,DT_Subp_Len-Data_Tbl(R1) YES, GET SUBPOOL, LEN
         SLDL  R0,8                  PUT SUBPOOL IN R0
         SLL   R1,1                  DOUBLE CURRENT LENGTH
         SLDL  R0,24                 AND PUT IT IN R0 TOO
HE0150   DS    0H
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(0),               this long                     +
               LOC=ANY                   anywhere
         ST    R0,@HE_DT_Subp_Len    SAVE SUBPOOL, LENGTH
         ST    R1,@HE_DT_Pointer     AND A(NEW TABLE)
         LR    R0,R1                 A(OUR TABLE)
         L     R1,@HE_DT_Subp_Len    SUBPOOL, LENGTH OF IT
         SLL   R1,8                  GET RID OF
         SRL   R1,8                    SUBPOOL
         SLR   R14,R14               NO SENDING ADDRESS
         SLR   R15,R15                 OR LENGTH
         MVCL  R0,R14                CLEAR OUR TABLE
         ICM   R14,B'1111',ODTE_DT_Ptr GET A(OLD TABLE)
         BZ    HE0160                None, SKIP
         L     R15,DT_Subp_Len-Data_Tbl(R14) YES, GET SUBPOOL, LENGTH
         SLL   R15,8                 CLEAR SUBPOOL SO THAT
         SRL   R15,8                   PAD CHAR IS X'00'
         L     R0,@HE_DT_Pointer     A(NEW TABLE AREA)
         L     R1,@HE_DT_Subp_Len    LENGTH OF NEW TABLE
         MVCL  R0,R14                MOVE OLD TABLE TO NEW
         L     R1,ODTE_DT_Ptr        A(OLD DATA TABLE)
         L     R0,DT_Subp_Len-Data_Tbl(R1) SUBPOOL, LENGTH OF TBL
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
HE0160   DS    0H
         L     R15,@HE_DT_Pointer    A(NEW TABLE AREA)
         ST    R15,ODTE_DT_Ptr       SAVE IT
         L     R0,@HE_DT_Subp_Len    SUBPOOL, LENGTH
         ST    R0,DT_Subp_Len-Data_Tbl(R15) AND SAVE IN TABLE
         B     HE0110                and try again
HE0170   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    AT THIS POINT, WE ARE READY TO INSERT THE ENTRY IN THE TABLE   *
*                   R4 =  LENGTH OF DATA                            *
*                   R5 =  A(DATA)                                   *
*                   R15 = A(ENTRY IN TABLE)                         *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R14,R4                GET THE LENGTH OF DATA
         SH    R14,=H'1'             EXECUTE LENGTH
         EX    R14,HE9998            MOVE IT
         STC   R14,DTE_Length-DT_Entry(R15) AND SAVE EXEC LENGTH

*-------------------------------------------------------------------*
*                                                                   *
*    NOW DECODE THE REST OF THE STUFF IN THE RECORD                 *
*                  R2  = A(NEXT CHAR IN INPUT)                      *
*                  R3  = LEN REMAINING IN INPUT                     *
*                  R15 = A(ENTRY IN TABLE)                          *
*    NOTE THAT WE HAVE NOT YET UPDATED THE NUMBER OF ENTRIES IN     *
*   THE TABLE (DT_Entry_Count), SO THAT IF WE FIND AN ERROR IN THE  *
*   REMAINDER OF THE INPUT CARD, WE CAN JUST EXIT.                  *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R0,R0                 CLEAR OFFSET
         LTR   R3,R3                 ANY DATA REMAINING IN THE INPUT?
         BZ    HE0180                NO, WE'RE FINISHED
         CLI   0(R2),C' '            YES, HAVE WE FINISHED?
         BE    HE0180                YES, GO UPDATE TABLE
         CLI   0(R2),C','            NO, IS THIS A VALID SEPARATOR?
         BNE   HE8000                NO, ERROR
         CLI   1(R2),C'0'            IS THE NEXT CHAR NUMERIC?
         BL    HE0180                NO, SKIP
         CLI   1(R2),C'9'            SO FAR, CHECK AGAIN
         BH    HE0180                NOT NUMERIC, SKIP
         LA    R2,1(0,R2)            YES, POINT PAST IT
         SH    R3,=H'1'              ADJUST LENGTH REMAINING
         BNP   HE8000                TRAILING COMMA, ERROR
         MVI   @HE_TRTab,X'FF'       SET UP TRANSLATE TABLE
         MVC   @HE_TRTab+1(255),@HE_TRTab SO THAT ALL
         MVI   @HE_TRTab+C'0',X'00'      CHARACTERS EXCEPT
         MVC   @HE_TRTab+C'1'(9),@HE_TRTab+C'0' NUMERICS ARE INVALID
         MVI   @HE_TRTab+C' ',X'01'  FLAG SPACE AS SPECIAL
         MVI   @HE_TRTab+C',',X'01'    COMMA TOO
         LR    R5,R2                 SAVE A(DATA)
         LA    R1,0(R2,R3)           A(PAST LAST CHAR)
         LA    R2,1                  SIMULATE A SPACE
         EX    R3,HE9997             CHECK OUR CHARACTERS
         LR    R0,R2                 SAVE R2
         LR    R2,R5                 RESTORE R2
         CH    R0,=H'254'            DID WE FIND AN INVALID CHAR?
         BNL   HE8000                YES, INVALID
         SR    R1,R2                 R1 = LENGTH OF DATA
         SH    R1,=H'1'              EXEC LEN
         BM    HE8000                NOTHING, INVALID
         EX    R1,HE9999             PACK THE DATA
         CVB   R0,@HE_DBLWD          AND PUT IT R0
         C     R0,=F'32767'          IS IT TOO BIG?
         BH    HE8000                YES, ERROR
         LA    R1,1(0,R1)            RESTORE REAL OPERAND LEN
         AR    R2,R1                 ADJUST NEXT PTR
         SR    R3,R1                 AND LENGTH REMAINING
HE0180   DS    0H
         STH   R0,DTE_Offset-DT_Entry(R15) SAVE IT
         SLR   R0,R0                 CLEAR REGISTER
         L     R15,ODTE_DT_Ptr       A(DATA TABLE)
         LH    R14,DT_Entry_Count-Data_Tbl(R15) GET NBR ENTRIES
         LA    R14,1(0,R14)          BUMP IT
         STH   R14,DT_Entry_Count-Data_Tbl(R15) AND SAVE IT
         SLR   R15,R15               CLEAR R15
         B     HE9000                AND EXIT
HE8000   DS    0H
         LA    R15,4                 SET RETURN CODE
         B     HE9000                AND EXIT
HE9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HE_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

HE9997 TRT     0(0,R5),@HE_TRTab     FIND ENDING CHARACTER
HE9998 MVC     DTE_Data-DT_Entry(0,R15),0(R5)
HE9999 PACK    @HE_DBLWD,0(0,R2)     PACK OFFSET/MSG CNT

*-------------------------------------------------------------------*
*                                                                   *
*    TRANSLATE TABLES FOR HE0000, USED TO INTERPRET DATA= OPERANDS. *
*                                                                   *
*-------------------------------------------------------------------*

HE_EBCDIC_TRTab DS XL256           EBCDIC TRANSLATE TABLE
         ORG   HE_EBCDIC_TRTab
         DC    256X'FE'
         ORG   HE_EBCDIC_TRTab+C' '
         DC    X'02'                 SEPARATOR (BLANK)
         ORG   HE_EBCDIC_TRTab+C','
         DC    X'02'                 SEPARATOR (,)
         ORG   HE_EBCDIC_TRTab+C''
         DC    XL7'00'                . < ( + ] &
         ORG   HE_EBCDIC_TRTab+C'|'
         DC    XL8'00'               | $ * ) ;  - /
         ORG   HE_EBCDIC_TRTab+C'%'
         DC    XL4'00'               % _ > ?
         ORG   HE_EBCDIC_TRTab+C':'
         DC    XL6'00'               : # @ ' = "
         ORG   HE_EBCDIC_TRTab+C'A'
         DC    XL9'00'               A-I
         ORG   HE_EBCDIC_TRTab+C'J'
         DC    XL9'00'               J-R
         ORG   HE_EBCDIC_TRTab+C'S'
         DC    XL8'00'               S-Z
         ORG   HE_EBCDIC_TRTab+C'0'
         DC    XL10'00'              0-9
         ORG

HE_Hex_TRTab DS XL256              HEX TRANSLATE TABLE
         ORG   HE_Hex_TRTab
         DC    256X'FE'
         ORG   HE_Hex_TRTab+C'A'
         DC    XL6'00'               A-F
         ORG   HE_Hex_TRTab+C'0'
         DC    XL10'00'              0-9
         ORG

         LTORG

@HE_Dynam       DSECT                 Dynamic area for HE
@HE_Save        DS    18F              O/S Style save area
@HE_DBLWD       DS    D                Work area
@HE_DT_Pointer  DS    AL4              A(Data Table)
@HE_DT_Subp_Len DS    FL4              Subpool, length of Dat Table
                DS    X                Flag Byte
@HE_Quote       EQU   *-1,X'80'         1... ....  QUOTED STRING
@HE_Hex         EQU   *-1,X'40'         .1.. ....  HEX STRING
@HE_TRTab       DS    XL256            Translate table
                DS    0D               Alignment
@HE_DynLen      EQU   *-@HE_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R10
         DROP  R11,R13
         POP   USING
         EJECT

         PUSH  USING

HF0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'JOB/DATA=' Keyword Processor                                  *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, ODTE_JobData_OR flag set         *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HF0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HF_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HF_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HF_Dynam,R13            Assign a base
         L     R15,@HF_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

         L     R10,8(0,R1)              A(ODT Entry)


*-------------------------------------------------------------------*
*                                                                   *
*    CHECK FOR "OR" KEYWORD.                                        *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?
         BNH   HF8000                 NO, ERROR
         CLC   0(2,R2),=C'OR'         YES, IS THIS IT?
         BNE   HF8000                 NO, ERROR
         OI    ODTE_JobData_OR-ODT_Entry(R10),L'ODTE_JobData_OR Yes, OK
         LA    R2,2(0,R2)             POINT PAST LITERAL
         SH    R3,=H'2'               RESET LENGTH REMAINING
         SLR   R15,R15                ASSUME EVERYTHING IS OK
         B     HF9000                 AND EXIT
HF8000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                  FLAG AN ERROR
         B     HF9000                 AND EXIT
HF9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HF_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return


         LTORG

@HF_Dynam       DSECT                 Dynamic area for HF
@HF_Save        DS    18F              O/S Style save area
                DS    0D               Alignment
@HF_DynLen      EQU   *-@HF_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         EJECT

         PUSH  USING

HG0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'STOPAFT=' Keyword Processor                                   *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, ODTE_StopAft updated             *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HG0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HG_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HG_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HG_Dynam,R13            Assign a base
         L     R15,@HG_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

         L     R10,8(0,R1)              A(ODT Entry)

*-------------------------------------------------------------------*
*                                                                   *
*    LOOK FOR THE FIRST NON-NUMERIC                                 *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R4,R2                  A(START OF OPERAND
HG0020   DS    0H
         CLI   0(R2),C'0'             IS THIS NUMERIC?
         BL    HG0030                 NO, SKIP
         CLI   0(R2),C'9'             SO FAR, CHECK AGAIN
         BH    HG0020                 NO, NOT NUMERIC
         LA    R2,1(0,R2)             OK, BUMP POINTER
         BCT   R3,HG0020              AND TRY AGAIN
         B     HG0040                 OK, SKIP
HG0030   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE A NON-NUMERIC CHARACTER - CHECK TO MAKE SURE IT'S A    *
*    VALID SEPARATOR (BLANK OR COMMA).                              *
*                                                                   *
*-------------------------------------------------------------------*

         CLI   0(R2),C','             IS THIS A COMMA?
         BE    HG0040                 YES, SKIP
         CLI   0(R2),C' '             NO, HOW ABOUT A BLANK
         BNE   HG8000                 NO, WE HAVE AN ERROR
HG0040   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    CHECK TO SEE IF THE NUMBER IS TOO LONG (MAX = 9 CHARACTERS)    *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R2                GET A(SEPARATOR)
         SR    R15,R4                LESS THE START
         CH    R15,=H'9'             IS IT TOO LONG?
         BH    HG8000                YES, ERROR

*-------------------------------------------------------------------*
*                                                                   *
*    IT SEEMS TO BE OK, SO BINARIZE IT AND SAVE IN ODTE_StopAft.    *
*                                                                   *
*-------------------------------------------------------------------*

         SH    R15,=H'1'             EXECUTE LEN
         EX    R15,HG9999            PACK IT
         CVB   R15,@HG_DBLWD         BINARIZE IT
         LTR   R15,R15               IS THE NUMBER 0?
         BE    HG8000                YES, THAT'S AN ERROR
         ST    R15,ODTE_StopAft-ODT_Entry(R10) No, save it
         SLR   R15,R15               CLEAR THE RETURN CODE
         B     HG9000                AND EXIT
HG8000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE AN ERROR, SET THE RETURN CODE AND EXIT.                *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                  FLAG AN ERROR
         B     HG9000                 AND EXIT
HG9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HG_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

HG9999 PACK    @HG_DBLWD,0(0,R4)        PACK STOPAFT COUNT

         LTORG

@HG_Dynam       DSECT                 Dynamic area for O
@HG_Save        DS    18F              O/S Style save area
@HG_DBLWD       DS    D                Work area
                DS    0D               Alignment
@HG_DynLen      EQU   *-@HG_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         EJECT

         PUSH  USING

HH0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'INEXIT=/OUTEXIT=' Keyword Processor                           *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, ODTE_InExit or ODTE_OutExit      *
*                          updated                                  *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HH0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HH_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HH_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HH_Dynam,R13            Assign a base
         L     R15,@HH_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

         L     R10,8(0,R1)              A(ODT Entry)
         USING ODT_Entry,R10            Assign a base

*-------------------------------------------------------------------*
*                                                                   *
*    Figure out if we are INEXIT or OUTEXIT, and set our flag       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R2                 A(Start of operands)
         S     R15,=FL4'5'            Back up to keyword
         CLI   0(R15),C'N'            INEXIT=?
         BNE   HH0020                 No, must be OUTEXIT=
         OI    @HH_InExit,L'@HH_InExit Yes, set our flag
HH0020   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Figure out what we have here. We can be:                       *
*      INEXIT=exitname                                              *
*      INEXIT=(exitname)                                            *
*      INEXIT=(exitname,parm)                                       *
*      INEXIT=(exitname,'parm')                                     *
*                                                                   *
*-------------------------------------------------------------------*

         CLI   0(R2),C'('             Open paren?
         BNE   HH0020C                No, skip
         OI    @HH_Paren,L'@HH_Paren  Yes, set our flag
         LA    R2,1(0,R2)             Point past it
         S     R3,=FL4'1'             and decrement length
HH0020C  DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Find the end of the exit name, by looking for a blank, comma,  *
*   or, optionally, a close paren.                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R14,R2                 A(Start)
         LR    R15,R3                 Length
HH0030   DS    0H
         CLI   0(R14),C' '            END OF NAME?
         BE    HH0050                 YES, SKIP
         CLI   0(R14),C','            NO, TRY AGAIN
         BE    HH0050                 FOUND END, SKIP
         TM    @HH_Paren,L'@HH_Paren  Are we in parentheses?
         BNO   HH0040                 No, skip
         CLI   0(R14),C')'            Yes, end of name?
         BE    HH0050                 Yes, skip
HH0040   DS    0H
         LA    R14,1(0,R14)           Point to next char
         BCT   R15,HH0030             and keep checking
HH0050   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We have the end of the name - move it to our ODT entry         *
*                                                                   *
*-------------------------------------------------------------------*

         SR    R14,R2                 Get length of name
         C     R14,=FL4'8'            Too long?
         BH    HH8000                 Yes, error

         LR    R1,R2                  Start of data to be moved
         LR    R3,R15                 Save length remaining
         AR    R2,R14                 and reset input pointer

         S     R14,=FL4'1'            EX Length to be moved

         TM    @HH_InExit,L'@HH_InExit Is this INEXIT
         BZ    HH0060                 No, skip
         LA    R15,ODTE_InExit        Yes, A(InExit name)
         MVC   ODTE_InExit,=CL(L'ODTE_InExit)' '  Clear it
         LTR   R14,R14                Anything?
         BNM   HH0070                 Yes, OK
         OI    ODTE_No_Dflt_InExit,l'ODTE_No_Dflt_InExit Don't use dflt
         B     HH0070C                and skip
HH0060   DS    0H
         LA    R15,ODTE_OutExit       A(OutExit Name)
         MVC   ODTE_OutExit,=CL(L'ODTE_OutExit)' '  Clear it
         LTR   R14,R14                Anything?
         BNM   HH0070                 Yes, OK
         OI    ODTE_No_Dflt_OutExit,l'ODTE_No_Dflt_OutExit No dflt
         B     HH0070C                and skip

HH0070   DS    0H
         EX    R14,HH_OC              OC    0(0,R15),0(R1)

HH0070C  DS    0H
         TM    @HH_Paren,L'@HH_Paren  Are we in paren?
         BNO   HH0180                 No, exit
         CLI   0(R2),C')'             Yes, at the end?
         BNE   HH0080                 No, skip
         LA    R2,1(0,R2)             Yes, point past it
         S     R3,=FL4'1'             decrement the length
         B     HH0180                 and exit
HH0080   DS    0H
         CLI   0(R2),C','             Separator?
         BNE   HH8000                 No, exit with error
         LA    R2,1(0,R2)             Yes, point past it
         S     R3,=FL4'1'             decrement the length
         SLR   R0,R0                  Clear work register
         LA    R0,C')'                Ending character

         CLI   0(R2),C''''            Open quote?
         BNE   HH0090                 No, skip
         OI    @HH_Quotes,L'@HH_Quotes Yes, set our flag
         LA    R2,1(0,R2)             Point past it
         S     R3,=FL4'1'             Decrement length remaining
         BNP   HH8000                 Nothing left, error
         LA    R0,C''''               Ending character
HH0090   DS    0H

         LA    R14,0(R2,R3)           A(Byte after string)
         LR    R15,R2                 A(1st byte of string)
HH0100   DS    0H
         SRST  R14,R15                Find it
         BO    HH0100                 Keep trying (CC=3)
         BNL   HH8000                 Not found, exit with error

         SR    R14,R2                 Length of data
         BZ    HH0110                 None, skip

         LR    R0,R2                  Start of data to be moved
         SR    R3,R14                 Update length remaining
         AR    R2,R14                 Bump pointer

         LR    R1,R14                 Length of data to be moved
         LA    R14,@HH_ParmArea       Temp save area
         AH    R14,@HH_ParmLen        A(Next byte)
         LH    R15,@HH_ParmLen        Bump
         AR    R15,R1                  current
         STH   R15,@HH_ParmLen         length
         LR    R15,R1                 Len to be moved
         MVCL  R14,R0                 Move parm data
HH0110   DS    0H
         TM    @HH_Quotes,L'@HH_Quotes Are we in quotes?
         BNO   HH0130                No, skip
         LA    R2,1(0,R2)            Point past quote
         S     R3,=FL4'1'            Decrement length remaining
         CLI   0(R2),C''''           Is this two quotes?
         BNE   HH0130                No, found the end

         LA    R15,@HH_ParmArea      Yes, A(Parmarea)
         AH    R15,@HH_ParmLen       Point past current data
         MVI   0(R15),C''''          Add a quote
         LH    R15,@HH_ParmLen       Bump the
         A     R15,=FL4'1'            current
         STH   R15,@HH_ParmLen        length
         LA    R2,1(0,R2)            Point past quote
         S     R3,=FL4'1'            Decrement length remaining
         LA    R0,C''''              Look for a quote
         B     HH0090                and keep checking

HH0130   DS    0H
         LA    R2,1(0,R2)            Bump past close paren
         S     R3,=FL4'1'            and decrement length
         B     HH0150                exit

HH0150   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We have assembled the parm in @HH_ParmArea. If a parm already  *
*   exists, free it up ...                                          *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @HH_InExit,L'@HH_InExit Is this INEXIT=?
         BNO   HH0150C                No, skip
         L     R1,ODTE_InExit_Parm_Ptr Yes, get A(Parm)
         B     HH0150E                and skip
HH0150C  DS    0H
         L     R1,ODTE_InExit_Parm_Ptr Get A(Parm)
HH0150E  DS    0H
         LTR   R1,R1                  Any parm?
         BZ    HH0150I                No, skip
         LH    R0,0(0,R1)             Yes, get its length
         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field
         STORAGE RELEASE,             Free the storage                 +
               ADDR=(1),               starting here                   +
               LENGTH=(0)              for this long

         SLR   R15,R15                Clear work register
         TM    @HH_Inexit,L'@HH_InExit Is this INEXIT=?
         BNO   HH0150G                No, skip
         ST    R15,ODTE_InExit_Parm_Ptr Yes, clear it
         B     HH0150I                and skip
HH0150G  DS    0H
         ST    R15,ODTE_OutExit_Parm_Ptr Clear parm pointer
HH0150I  DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    ... and copy it to 24-bit storage                              *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,L'@HH_ParmLen       Length of Parm length
         AH    R0,@HH_ParmLen         plus length of parm

         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(0),               this long                     +
               LOC=BELOW                 below-the-line

         TM    @HH_InExit,L'@HH_InExit Is this INEXIT=?
         BNO   HH0160                 No, skip
         ST    R1,ODTE_InExit_Parm_Ptr Yes, save A(Parm)
         B     HH0170                 and skip
HH0160   DS    0H
         ST    R1,ODTE_OutExit_Parm_Ptr Save A(Parm)
         B     HH0170                 and skip
HH0170   DS    0H

         MVC   0(L'@HH_ParmLen,R1),@HH_ParmLen Save parm length
         LA    R0,L'@HH_ParmLen(0,R1) Point past it
         LH    R1,@HH_ParmLen         Get its length
         LA    R14,@HH_ParmArea       Point to assenbled parm
         LR    R15,R1                 Same length
         MVCL  R0,R14                 Move parm

HH0180   DS    0H
         SLR   R15,R15                CLEAR RETURN CODE
         B     HH9000                 AND EXIT

HH8000   DS    0H
         LA    R15,4                  Bad stuff
         B     HH9000                 AND EXIT

HH9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HH_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

HH_OC    OC    0(0,R15),0(R1)           Move exit name

         LTORG

@HH_Dynam       DSECT                 Dynamic area for HH
@HH_Save        DS    18F              O/S Style save area
                DS    X                Flag Byte
@HH_InExit      EQU   *-1,X'80'         1... .... INEXIT= statement
@HH_Paren       EQU   *-1,X'40'         .1.. .... Parentheses
@HH_Quotes      EQU   *-1,X'20'         ..1. .... Parm in quotes
@HH_ParmArea    DS    CL256            Parm area
@HH_ParmLen     DS    HL2              Length of parm
                DS    0D               Alignment
@HH_DynLen      EQU   *-@HH_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R10
         DROP  R11,R13
         POP   USING
         EJECT

         PUSH  USING

HI0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'OUTPUT=' Keyword Processor                                    *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, 3rd parm updated with A(new ODT  *
*                          entry)                                   *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HI0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HI_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HI_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HI_Dynam,R13            Assign a base
         L     R15,@HI_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms
         L     R10,8(0,R1)              A(ODT Entry)


*-------------------------------------------------------------------*
*                                                                   *
*    AND MOVE THE NAME, CHARACTER BY CHARACTER.                     *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,@HI_DDName         A(HOLDING AREA)
         MVC   @HI_DDName,=CL8' '     CLEAR IT OUT
         LA    R14,9                  MAX LENGTH OF NAME + 1
         CR    R14,R3                 ARE THERE THAT MANY LEFT?
         BNH   HI0020                 YES, SKIP
         LR    R14,R3                 NO, USE ONLY WHATS LEFT
HI0020   DS    0H
         CLI   0(R2),C' '             END OF NAME?
         BE    HI0030                 YES, SKIP
         CLI   0(R2),C','             NO, TRY AGAIN
         BE    HI0030                 FOUND END, SKIP
         OC    0(1,R15),0(R2)         MOVE CHAR TO NAME FIELD
         LA    R15,1(0,R15)           BUMP RECEIVING POINTER
         LA    R2,1(0,R2)             BUMP SENDING POINTER
         SH    R3,=H'1'               DECREASE CHARS REMAINING
         BCT   R14,HI0020             AND KEEP GOING
         LA    R15,4                  TOO MANY CHARACTERS (>8)
         B     HI9000                 SO EXIT
HI0030   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE GOT THE NAME, SO FIND AN ENTRY IN THE OUTPUT ENV TBL.  *
*   NOTE THAT AN ENTRY MAY ALREADY EXIST - IF SO, WE USE IT. IF NOT,*
*   WE CREATE ONE,                                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R10,@_ODT_Ptr         POINT TO OUR TABLE
         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST

         USING ODT_Entry,R10            Tell the assembler

HI0040   DS    0H
         CLC   ODTE_DDName,@HI_DDName OUR ENTRY?
         BE    HI0060                 YES, SKIP
         AL    R10,=AL4(ODTE_Length)  No, point to next entry
         BCT   R9,HI0040              and check it out

*-------------------------------------------------------------------*
*                                                                   *
*    WE DIDN'T FIND OUR ENTRY IN THE TABLE, SO WE WILL CREATE ONE.  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_ODT_Ptr           A(OUR TABLE)
         L     R15,=AL4(ODTE_Length)  LENGTH OF ONE ENTRY
         LH    R14,ODT_Entry_Count-OutDesc_Tbl(R1) Nbr entries
         LA    R14,1(0,R14)           PLUS ONE FOR THE NEW ONE
         MR    R14,R14                LENGTH OF ENTRIES
         LA    R15,ODT_Entry-OutDesc_Tbl(0,R15) PLUS LEN OF HEADER
         L     R1,ODT_Subp_Len-OutDesc_Tbl(R1) Get Tbl Len, Subpool
         SLL   R1,8                   GET RID OF
         SRL   R1,8                    SUBPOOL
         CR    R1,R15                 DO WE HAVE ROOM?
         BNL   HI0050                 YES, ADD AN ENTRY

*-------------------------------------------------------------------*
*                                                                   *
*    WE DON'T HAVE ROOM IN THE TABLE TO INSERT THE NEW ENTRY, SO    *
*   WE GETMAIN A NEW TABLE TWICE THE SIZE, AND USE IT INSTEAD.      *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@_ODT_Ptr          GET A(CURRENT TABLE)
         L     R1,ODT_Subp_Len-OutDesc_Tbl(R15) GET SUBPOOL, LENGTH
         SLDL  R0,8                   SUBPOOL IN R0
         SLL   R0,24                  HIGH-ORDER BYTE OF R0
         SRL   R1,7                   DOUBLE PREVIOUS SIZE
         OR    R0,R1                  SET UP GETMAIN REGISTER
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(0),               this long                     +
               LOC=ANY                   anywhere
         ST    R0,@HI_ODT_Subp_Len    SAVE SUBPOOL, LENGTH
         ST    R1,@HI_ODT_Pointer      AND ADDRESS
         LR    R0,R1                  R0 = A(NEW TABLE)
         L     R1,@HI_ODT_Subp_Len    R1 = NEW TABLE LENGTH
         L     R14,@_ODT_Ptr          R14 = A(OLD TABLE)
         L     R15,ODT_Subp_Len-OutDesc_Tbl(R14) R15 = LENGTH
         SLL   R15,8                  FILL CHAR
         SRL   R15,8                   OF X'00'
         MVCL  R0,R14                 MOVE OLD TABLE TO NEW
         L     R1,@_ODT_Ptr           A(OLD TABLE)
         L     R0,ODT_Subp_Len-OutDesc_Tbl(R1) IT'S SUBPOOL, LENGTH
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
         L     R1,@HI_ODT_Pointer     A(NEW TABLE)
         ST    R1,@_ODT_Ptr           SAVE IT
         L     R0,@HI_ODT_Subp_Len    NEW TABLE LENGTH, SUBPOOL
         ST    R0,ODT_Subp_Len-OutDesc_Tbl(R1) SAVE IT IN THE TABLE
         L     R15,=AL4(ODTE_Length)   LENGTH OF ONE ENTRY
         MH    R15,ODT_Entry_Count-OutDesc_Tbl(R1) Len of entries
         LA    R10,ODT_Entry-OutDesc_Tbl(0,R15) PLUS LEN OF HEADER
         A     R10,@_ODT_Ptr         R10 = A(NEW ENTRY AREA)
HI0050   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    INITIALIZE OUR NEW ENTRY WITH THE DEFAULT (FIRST) ENTRY.       *
*       R10 --> NEW ENTRY AREA.                                     *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R10                SAVE A(NEW ENTRY)
         L     R1,@_ODT_Ptr           A(ENV TABLE)
         LA    R0,ODT_Entry-OutDesc_Tbl(R1) A(FIRST ENTRY)
         L     R1,=AL4(ODTE_Length)   ENTRY LENGTH
         LR    R14,R15                A(NEW ENTRY)
         LR    R15,R1                 SAME LENGTH
         MVCL  R14,R0                 MOVE THE DEFAULT ENTRY

*-------------------------------------------------------------------*
*                                                                   *
*    NOW SET UP OUR STUFF WITHIN OUR ENTRY.                         *
*                                                                   *
*-------------------------------------------------------------------*

         MVC   ODTE_DDName,@HI_DDName SAVE OUR DDNAME
         MVI   ODTE_InExit,C' '       CLEAR
         MVC   ODTE_InExit+1(L'ODTE_InExit-1),ODTE_InExit INPUT AND
         MVC   ODTE_OutExit,ODTE_InExit      OUTPUT EXIT NAMES
         SLR   R15,R15                CLEAR WORK REG
         ST    R15,ODTE_RTT_Ptr       NO RECORD TYPE TABLE
         ST    R15,ODTE_JNT_Ptr       NOR JOBNAME TABLE
         ST    R15,ODTE_DT_Ptr        NO DATA TABLE EITHER
         L     R15,@_ODT_Ptr          A(ENVIRONMENT TABLE)
         LH    R14,ODT_Entry_Count-OutDesc_Tbl(R15) Nbr entries
         LA    R14,1(0,R14)           BUMP IT
         STH   R14,ODT_Entry_Count-OutDesc_Tbl(R15) AND SAVE IT
HI0060   DS    0H
         L     R1,@HI_Save+4         A(HSA)
         L     R1,24(0,R1)           A(Original Parm list)
         ST    R10,8(0,R1)           Update A(ODT Entry)
         SLR   R15,R15                CLEAR THE RETURN CODE
         B     HI9000                 AND EXIT
HI9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HI_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

         LTORG

@HI_Dynam       DSECT                 Dynamic area for Q
@HI_Save        DS    18F              O/S Style save area
@HI_DDName      DS    CL8              DDName for this ODTE
@HI_ODT_Pointer DS    AL4              A(Output Desc Tbl)
@HI_ODT_Subp_Len DS   FL4              Subpool, length of ODT
                DS    0D               Alignment
@HI_DynLen      EQU   *-@HI_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R10
         DROP  R11,R13
         POP   USING
         EJECT

         PUSH  USING

HJ0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'PERIOD=' Keyword Processor                                    *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, ODTE_PeriodStart and             *
*                          ODTE_PeriodEnd updated.                  *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HJ0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HJ_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HJ_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HJ_Dynam,R13            Assign a base
         L     R15,@HJ_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

         L     R10,8(0,R1)              A(ODT Entry)

         USING ODT_Entry,R10            Tell the assembler

*-------------------------------------------------------------------*
*                                                                   *
*    BEGIN WITH PERIOD START TIME.                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,ODTE_PeriodStart    A(PERIOD START)
HJ0020   DS    0H
         MVC   @HJ_Time(6),=C'000000' INIT TEMP AREA
         LA    R4,@HJ_Time            AND POINT TO IT
HJ0030   DS    0H
         CLI   0(R2),C'0'             IS THIS NUMERIC?
         BL    HJ0040                 NO, SKIP
         CLI   0(R2),C'9'             SO FAR, MAKE SURE
         BH    HJ0040                 NOT NUMERIC, SKIP
         MVC   0(1,R4),0(R2)          ITS NUMERIC, MOVE IT
         LA    R4,1(0,R4)             BUMP OUTPUT POINTER
         LA    R2,1(0,R2)             BUMP INPUT POINTER
         BCT   R3,HJ0030              AND TRY AGAIN
HJ0040   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE REACHED THE END OF THE TIME FIELD.                     *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,@HJ_Time          A(Start of Time)
         SR    R4,R15                LENGTH OF DATA
         BZ    HJ0050                NOTHING THERE, CHECK IT OUT
         CH    R4,=H'6'              TOO LONG?
         BH    HJ8000                YES, ERROR

         LR    R4,R1                 Save A(Target field)
         XC    @HJ_DateConv_Area,@HJ_DateConv_Area Clear Date area
         PACK  @HJ_DBLWD,@HJ_Time(2)  PACK HH
         CVB   R15,@HJ_DBLWD          BINARIZE IT
         STC   R15,@HJ_DateConv_Area+DConv_Time_hh-DateConv_Area
         PACK  @HJ_DBLWD,@HJ_Time+2(2) GET NBR MINUTES
         CVB   R15,@HJ_DBLWD          BINARIZE THEM
         STC   R15,@HJ_DateConv_Area+DConv_Time_mm-DateConv_Area
         PACK  @HJ_DBLWD,@HJ_Time+4(2) PACK SECONDS
         CVB   R15,@HJ_DBLWD          BINARIZE THEM
         STC   R15,@HJ_DateConv_Area+DConv_Time_ss-DateConv_Area
         OI    @HJ_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DCo+
               nv_Input_hhmmss       Indicate Time conversion
         LA    R1,@HJ_DateConv_Area  Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get seconds since midnight
         LTR   R15,R15               Everything OK?
         BNZ   HJ8000                No, invalid time

         LR    R1,R4                 Restore A(Target field)
         L     R15,@HJ_DateConv_Area+DConv_Time-DateConv_Area
         ST    R15,0(0,R1)           OK, SAVE IT
         LA    R15,ODTE_PeriodEnd    A(PERIOD END TIME)
         CR    R1,R15                IS THAT WHAT WE JUST DID?
         BE    HJ0050                YES, SKIP
         CLI   0(R2),C'-'            IS THIS THE TIME SEPARATOR?
         BNE   HJ0050                NO, SKIP
         LA    R1,ODTE_PeriodEnd     YES, A(PERIOD END TIME)
         LA    R2,1(0,R2)            POINT PAST SEPARATOR
         BCT   R3,HJ0020             AND PROCESS IT
HJ0050   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE THE END OF THE PARAMETERS - CHECK THAT WE TERMINATE    *
*   WITH A SPACE OR COMMA, AND THAT PERIOD START IS LESS THAN       *
*   PERIOD END.                                                     *
*                                                                   *
*-------------------------------------------------------------------*

         CLI   0(R2),C' '            TERMINATING SPACE?
         BE    HJ0060                YES, SKIP
         CLI   0(R2),C','            NO, HOW ABOUT COMMA?
         BNE   HJ8000                NO, ERROR
HJ0060   DS    0H
         L     R15,ODTE_PeriodStart  GET PERIOD START TIME
         C     R15,ODTE_PeriodEnd    COMPARE TO PERIOD END
         BH    HJ8000                START > END, ERROR
         SLR   R15,R15               OK, CLEAR THE RETURN CODE
         B     HJ9000                AND EXIT
HJ8000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    WE HAVE AN ERROR, SET THE RETURN CODE.                         *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                 SET THE RETURN CODE
         B     HJ9000                AND EXIT
HJ9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HJ_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

         LTORG

@HJ_Dynam       DSECT                 Dynamic area for HJ
@HJ_Save        DS    18F              O/S Style save area
@HJ_DBLWD       DS    D                Work area
@HJ_Time        DS    XL6              Work area
@HJ_DateConv_Area DS   CL(DConv_Area_Length)     Our area
                DS    0D               Alignment
@HJ_DynLen      EQU   *-@HJ_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R10
         DROP  R11,R13
         POP   USING
         EJECT

         PUSH  USING

HK0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'SEQUENCE=' Keyword Processor                                  *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, @_SYSUT1_Sequence flag updated.  *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HK0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HK_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HK_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HK_Dynam,R13            Assign a base
         L     R15,@HK_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

*-------------------------------------------------------------------*
*                                                                   *
*    CHECK FOR "YES" KEYWORD.                                       *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R3,=H'3'               ENOUGH ROOM LEFT FOR LITERAL?
         BNH   HK8000                 NO, ERROR
         CLC   0(3,R2),=C'YES'        YES, IS THIS IT?
         BNE   HK8000                 NO, ERROR
         OI    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence YES, SET FLAG
         LA    R2,3(0,R2)             POINT PAST LITERAL
         SH    R3,=H'3'               RESET LENGTH REMAINING
         SLR   R15,R15                ASSUME EVERYTHING IS OK
         CLI   0(R2),C' '             VALID SEPARATOR?
         BE    HK9000                 YES, OK
         CLI   0(R2),C','             NO, TRY AGAIN
         BE    HK9000                 YES, SKIP
         B     HK8000                 NO, ERROR
HK8000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                  FLAG AN ERROR
         B     HK9000                 AND EXIT
HK9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HK_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

         LTORG

@HK_Dynam       DSECT                 Dynamic area for S
@HK_Save        DS    18F              O/S Style save area
                DS    0D               Alignment
@HK_DynLen      EQU   *-@HK_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         EJECT

         PUSH  USING

HL0010   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    'CHECKVBS=' Keyword Processor                                  *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, @_SYSUT1_NoVBSChk flag set       *
*                      4 - Error found                              *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HL0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HL_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HL_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HL_Dynam,R13            Assign a base
         L     R15,@HL_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of keyword                                *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms

*-------------------------------------------------------------------*
*                                                                   *
*    CHECK FOR "NO" KEYWORD.                                        *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?
         BNH   HL8000                 NO, ERROR
         CLC   0(2,R2),=C'NO'         YES, IS THIS IT?
         BNE   HL8000                 NO, ERROR
         OI    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk YES, SET FLAG
         LA    R2,2(0,R2)             POINT PAST LITERAL
         SH    R3,=H'2'               RESET LENGTH REMAINING
         SLR   R15,R15                ASSUME EVERYTHING IS OK
         CLI   0(R2),C' '             VALID SEPARATOR?
         BE    HL9000                 YES, OK
         CLI   0(R2),C','             NO, TRY AGAIN
         BE    HL9000                 YES, SKIP
         B     HL8000                 NO, ERROR
HL8000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                  FLAG AN ERROR
         B     HL9000                 AND EXIT
HL9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HL_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

         LTORG

@HL_Dynam       DSECT                 Dynamic area for U
@HL_Save        DS    18F              O/S Style save area
                DS    0D               Alignment
@HL_DynLen      EQU   *-@HL_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         EJECT
HM0010   DS    0H

         PUSH  USING

*-------------------------------------------------------------------*
*                                                                   *
*    'WEEKENDS=' Keyword Processor                                  *
*             Valid values are:                                     *
*                     "IGNORE" - Do not process Saturday or Sunday  *
*    On Entry, R1 --->  A(Operand)                                  *
*                       Fullword containing # characters left in    *
*                        the input record                           *
*                       A(ODT Entry)                                *
*    On Exit,  R15 =   0 - All OK, ODTE_Ignore_Weekend flag set     *
*                      4 - Invalid Parameter                        *
*                                                                   *
*-------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING HM0010,R11               Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@HM_DynLen,           this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@HM_DynLen             Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @HM_Dynam,R13            Assign a base
         L     R15,@HM_Dynam+4          Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Load our parm registers:                                       *
*         R2 ---> Operand of PRINT= keyword                         *
*         R3    = Nbr chars left in the input record                *
*                                                                   *
*-------------------------------------------------------------------*

         LM    R2,R3,0(R1)              Get parms
         L     R10,8(0,R1)              A(ODT Entry)

*-------------------------------------------------------------------*
*                                                                   *
*    CHECK FOR "NO" KEYWORD.                                        *
*                                                                   *
*-------------------------------------------------------------------*

         CH    R3,=HL2'6'             ENOUGH ROOM LEFT FOR LITERAL?
         BNH   HM8000                 NO, ERROR
         CLC   0(6,R2),=C'IGNORE'     YES, IS THIS IT?
         BNE   HM8000                 NO, ERROR
         OI    ODTE_Ignore_Weekend-ODT_Entry(R10),L'ODTE_Ignore_Weekend
         LA    R2,6(0,R2)             POINT PAST LITERAL
         SH    R3,=HL2'6'             RESET LENGTH REMAINING
         SLR   R15,R15                ASSUME EVERYTHING IS OK
         CLI   0(R2),C' '             VALID SEPARATOR?
         BE    HM9000                 YES, OK
         CLI   0(R2),C','             NO, TRY AGAIN
         BE    HM9000                 YES, SKIP
         B     HM8000                 NO, ERROR
HM8000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,4                  FLAG AN ERROR
         B     HM9000                 AND EXIT
HM9000   DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,4(0,R13)              A(HSA)
         L     R1,24(0,R1)              Get original R1
         STM   R2,R3,0(R1)              Update parms

         LR    R3,R15                   Rescue the return code

         LA    R1,@HM_Dynam             A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return


         LTORG

@HM_Dynam       DSECT                 Dynamic area for HM
@HM_Save        DS    18F              O/S Style save area
                DS    0D               Alignment
@HM_DynLen      EQU   *-@HM_Dynam     Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         TITLE 'I0000: OPEN SYSUT1'

         PUSH  USING

I0010    DS    0H


*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : I0010                                                  *
*                                                                     *
*  Abstract  : OPEN SYSUT1, allocating it to the active SMF dataset   *
*              if required. Print some interesting(?) info about it.  *
*                                                                     *
*  Inputs    : N/A                                                    *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - SYSUT1 not useable.                           *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              2002/02/07 SDDA030 V1.4                                *
*                                 Removed EODAD stuff.                *
*                                 Used W0010 to get A(JFCB).          *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING I0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@I_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@I_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @I_Dynam,R13             Assign a base
         L     R15,@I_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*     Get the storage for our DCB and DCBE                          *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,4                     Length field
         LA    R1,I_SYSUT1_BSAM_DCB_Length(0,R1) Plus length of DCB
         LA    R0,I_SYSUT1_DCBE_Length(0,R1) Plus length of DCBE
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(0),               this long                     +
               LOC=BELOW                 below-the-line
         ST    R1,@_SYSUT1_BtL_Ptr      Save A(Storage)
         ST    R0,0(0,R1)               Save length
         LA    R2,4(0,R1)               Point to DCB area
         MVC   0(I_SYSUT1_BSAM_DCB_Length,R2),I_SYSUT1_BSAM_DCB Move it
         LA    R14,I_SYSUT1_BSAM_DCB_Length(0,R2) Point past DCB
         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE
         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB

*-------------------------------------------------------------------*
*                                                                   *
*    And go get the JFCB - if this fails, we assume that SYSUT1     *
*   has not been allocated                                          *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSUT1_BtL_Ptr      A(Storage)
         LA    R1,4(0,R1)               Point to DCB area
         L     R15,=AL4(W0010)          A(Get JFCB routine)
         BASR  R14,R15                  Go do it
         LTR   R15,R15                  How did it go?
         BZ    I0060                    OK, skip

*-------------------------------------------------------------------*
*                                                                   *
*    No SYSUT1 DDName found, so dynamically allocate it to the      *
*   active SMF file, if there is one.                               *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,CVTPTR(0,0)          Get A(CVT)
         L     R15,CVTSMCA-CVT(R15)     And then the SMCA
         TM    SMCAMISC-SMCABASE(R15),SMCAUSER  SMF recording?
         BZ    I8000                    No, no active SMF file
         L     R14,SMCAFRDS-SMCABASE(R15) Yes, get A(1st RDS)
         L     R15,SMCALRDS-SMCABASE(R15) and A(last RDS)
I0040    DS    0H
         TM    12(R14),X'04'            Active SMF dataset?
         BZ    I0050                    Yes, skip
         L     R14,4(0,R14)             No, get A(Next)
         CR    R14,R15                  End of chain?
         BNE   I0040                    No, keep checking
         B     I8000                    Yes, no active SMF file
I0050    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We have found the active SMF file (R14 points to the RDS),     *
*   so build the SVC99 control blocks ...                           *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,@I_SVC99_RB          A(S99 RB)
         ST    R15,@I_SVC99_RB_Ptr+S99RBPTR-S99RBP SAVE IT
         OI    @I_SVC99_RB_Ptr+S99RBPTR-S99RBP,S99RBPND

         MVI   @I_SVC99_RB+S99RBLN-S99RB,S99RBEND-S99RB LENGTH
         MVI   @I_SVC99_RB+S99VERB-S99RB,S99VRBAL ALLOCATE
         SLR   R15,R15                CLEAR WORK REGISTER
         STH   R15,@I_SVC99_RB+S99FLAG1-S99RB CLEAR FLAG1
         STH   R15,@I_SVC99_RB+S99ERROR-S99RB CLEAR ERROR CODE
         STH   R15,@I_SVC99_RB+S99INFO-S99RB CLEAR INFO CODE
         LA    R15,@I_SVC99_TU_List   A(TEXT UNIT POINTERS)
         ST    R15,@I_SVC99_RB+S99TXTPP-S99RB SAVE IT
         SLR   R15,R15                CLEAR WORK REGISTER
         ST    R15,@I_SVC99_RB+S99TXTPP+4-S99RB CLEAR RESERVED FIELD
         ST    R15,@I_SVC99_RB+S99FLAG2-S99RB CLEAR FLAG 2

         LA    R15,@I_SVC99_DDName_TU A(DDNAME)
         ST    R15,@I_SVC99_TU_List   SAVE IT
         LA    R15,@I_SVC99_DSName_TU A(DSNAME)
         ST    R15,@I_SVC99_TU_List+4 SAVE IT
         LA    R15,@I_SVC99_Status_TU A(STATUS)
         ST    R15,@I_SVC99_TU_List+8 SAVE IT
         LA    R15,@I_SVC99_NDisp_TU  A(NDISP)
         ST    R15,@I_SVC99_TU_List+12 SAVE IT
         LA    R15,@I_SVC99_CDisp_TU  A(CDISP)
         ST    R15,@I_SVC99_TU_List+16 SAVE IT
         LA    R15,@I_SVC99_Free_TU   A(FREE)
         ST    R15,@I_SVC99_TU_List+20 SAVE IT
         OI    @I_SVC99_TU_List+20,S99TUPLN END OF LIST

         LA    R15,DALDDNAM           DDNAME TEXT KEY
         STH   R15,@I_SVC99_DDName_TU+S99TUKEY-S99TUNIT SAVE IT
         LA    R15,1                  NBR PARMS
         STH   R15,@I_SVC99_DDName_TU+S99TUNUM-S99TUNIT SAVE IT
         LA    R15,8                  LEN OF PARMS
         STH   R15,@I_SVC99_DDName_TU+S99TULNG-S99TUNIT SAVE IT
         MVC   @I_SVC99_DDName_TU+S99TUPAR-S99TUNIT(8),=CL8'SYSUT1'

         LA    R15,DALDSNAM           DSNAME TEXT KEY
         STH   R15,@I_SVC99_DSName_TU+S99TUKEY-S99TUNIT SAVE IT
         LA    R15,1                  NBR PARMS
         STH   R15,@I_SVC99_DSName_TU+S99TUNUM-S99TUNIT SAVE IT
         LA    R15,44                 LEN OF PARMS
         STH   R15,@I_SVC99_DSName_TU+S99TULNG-S99TUNIT SAVE IT
         MVC   @I_SVC99_DSName_TU+S99TUPAR-S99TUNIT(44),16(R14) SMF DSN

         LA    R15,DALSTATS           STATUS TEXT KEY
         STH   R15,@I_SVC99_Status_TU+S99TUKEY-S99TUNIT SAVE IT
         LA    R15,1                  NBR PARMS
         STH   R15,@I_SVC99_Status_TU+S99TUNUM-S99TUNIT SAVE IT
         STH   R15,@I_SVC99_Status_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO
         MVI   @I_SVC99_Status_TU+S99TUPAR-S99TUNIT,X'08' SHR

         LA    R15,DALNDISP           NORMAL DISP
         STH   R15,@I_SVC99_NDisp_TU+S99TUKEY-S99TUNIT SAVE IT
         LA    R15,1                  NBR PARMS
         STH   R15,@I_SVC99_NDisp_TU+S99TUNUM-S99TUNIT SAVE IT
         STH   R15,@I_SVC99_NDisp_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO
         MVI   @I_SVC99_NDisp_TU+S99TUPAR-S99TUNIT,X'08' KEEP

         LA    R15,DALCDISP           CONDITIONAL DISP
         STH   R15,@I_SVC99_CDisp_TU+S99TUKEY-S99TUNIT SAVE IT
         LA    R15,1                  NBR PARMS
         STH   R15,@I_SVC99_CDisp_TU+S99TUNUM-S99TUNIT SAVE IT
         STH   R15,@I_SVC99_CDisp_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO
         MVI   @I_SVC99_CDisp_TU+S99TUPAR-S99TUNIT,X'08' KEEP

         LA    R15,DALCLOSE           FREE=CLOSE
         STH   R15,@I_SVC99_Free_TU+S99TUKEY-S99TUNIT SAVE IT
         SLR   R15,R15                NBR PARMS
         STH   R15,@I_SVC99_Free_TU+S99TUNUM-S99TUNIT SAVE IT

*-------------------------------------------------------------------*
*                                                                   *
*    ... and invoke Dynamic Allocation                              *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,@I_SVC99_RB_Ptr     A(SVC99 RB Pointer)
         SVC   99                     Go do it
         LTR   R15,R15                Did it work?
         BNZ   I8010                  No, error

         OI    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Yes, in sequence

*-------------------------------------------------------------------*
*                                                                   *
*    And go get the JFCB (again)                                    *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSUT1_BtL_Ptr      A(Storage)
         LA    R1,4(0,R1)               Point to DCB area
         L     R15,=AL4(W0010)          A(Get JFCB routine)
         BASR  R14,R15                  Go do it
         LTR   R15,R15                  How did it go?
         BNZ   I8020                    Not good, exit with error

I0060    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Save some info from the JFCB                                   *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R1,@I_JFCB_Ptr           Save A(JFCB)

         MVC   @I_JFCBUFNO,JFCBUFNO-INFMJFCB(R1) Save DCB=BUFNO=
         MVC   @I_JFCNCP,JFCNCP-INFMJFCB(R1) Save DCB=NCP=

*-------------------------------------------------------------------*
*                                                                   *
*    Get some info about the device on which SYSUT1 lives           *
*                                                                   *
*-------------------------------------------------------------------*

         XC    @I_DVACLASS,@I_DVACLASS            Device Class
         XC    @I_DVATRK,@I_DVATRK                Trks/Cyl
         XC    @I_DVATRKLN,@I_DVATRKLN            Bytes/Trk

         LA    R1,I_SYSUT1_BSAM_DCB+DCBDDNAM-IHADCB A(DDName)
         LA    R0,@I_DEVAREA          A(Return area)
         DEVTYPE (1),(0),DEVTAB       Get SYSUT1 device info
         LTR   R15,R15                Did it work?
         BNZ   I0070                  No, skip
         MVC   @I_DVACLASS,@I_DEVAREA+DVACLASS-DVAREA Device Class
         MVC   @I_DVATRK,@I_DEVAREA+DVATRK-DVAREA Trks/Cyl
         MVC   @I_DVATRKLN,@I_DEVAREA+DVATRKLN-DVAREA Bytes/Trk
I0070    DS    0H

         L     R15,@I_JFCB_Ptr        A(JFCB)
         TM    JFCDSRG2-INFMJFCB(R15),JFCORGAM VSAM?
         BNZ   I0170                  Yes, skip

*-------------------------------------------------------------------*
*                                                                   *
*    SYSUT1 is non-VSAM; OPEN the BSAM DCB ...                      *
*                                                                   *
*-------------------------------------------------------------------*

         L     R2,@_SYSUT1_BtL_Ptr    A(Below-the-line storage)
         LA    R2,4(0,R2)             A(DCB)

         MVC   @I_OPEN,I_OPEN         MOVE OPEN PARMS
         OPEN  ((2),INPUT),MODE=31,MF=(E,@I_OPEN) AND OPEN BSAM DCB
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Is it open?
         BNO   I8020                  No, error

*-------------------------------------------------------------------*
*                                                                   *
*    ... save some info from the DCB ...                            *
*                                                                   *
*-------------------------------------------------------------------*

         MVC   @I_RECFM,DCBRECFM-IHADCB(R2) Save RECFM
         MVC   @I_NCP,DCBNCP-IHADCB(R2)      Save NCP (Calc by OPEN)
         LH    R15,DCBLRECL-IHADCB(R2)       Get LRECL
         ST    R15,@_SYSUT1_Rec_Length       and save it
         MVC   @I_BLKSI,DCBBLKSI-IHADCB(R2)   and BLKSIZE

*-------------------------------------------------------------------*
*                                                                   *
*    ... and close it.                                              *
*                                                                   *
*-------------------------------------------------------------------*

         MVC   @I_CLOSE,I_CLOSE              Move CLOSE parms
         CLOSE ((2)),MODE=31,MF=(E,@I_CLOSE)  and close BSAM DCB

*-------------------------------------------------------------------*
*                                                                   *
*    Calculate the value of DCBNCP or DCBBUFNO that we will         *
*   use so we can read a cylinder at a time (assuming SYSUT1 lives  *
*   on DASD - if it doesn't, we use an arbitrary value of 30). OPEN *
*   has calculated the number of blocks on a track (DCBNCP).        *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,30                  Default number of buffers
         STH   R0,@I_Buffer_Count     Save it

         TM    @I_DVACLASS,UCB3DACC   DASD device?
         BZ    I0100                  No, use default
         SLR   R0,R0                  Yes, get
         IC    R0,@I_NCP               blocks/track
         MH    R0,@I_DVATRK           Times Trks/Cyl
         LTR   R0,R0                  Is it 0?
         BZ    I0080                  Yes, use blks/trk
         C     R0,=FL4'255'           No, too big?
         BNH   I0090                  No, use it
I0080    DS    0H
         SLR   R0,R0                  Yes, use
         IC    R0,@I_NCP               blocks/trk
I0090    DS    0H
         STH   R0,@I_Buffer_Count     Save it
I0100    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    We know we are non-VSAM. If the RECFM is not variable spanned, *
*   or we have been told not to check for spanning errors, we will  *
*   use QSAM as our access method. Otherwise ...                    *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk Should we check?
         BO    I0140                  No, skip
         TM    @I_RECFM,DCBRECV+DCBRECSB     VS or VBS?
         BNO   I0140                  No, skip

*-------------------------------------------------------------------*
*                                                                   *
*    ... we will use BSAM.                                          *
*                                                                   *
*-------------------------------------------------------------------*

         OI    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Set BSAM Input flag

*-------------------------------------------------------------------*
*                                                                   *
*    Calculate the number of buffers we will need. If this has not  *
*   been specified by the user (DCB=NCP= or DCB=BUFNO=), we use     *
*   the value we calculated earlier that will allow us to read a    *
*   cylinder at a time.                                             *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R0,R0                  Clear work register
         IC    R0,@I_JFCNCP           Get user specified DCB=NCP=
         LTR   R0,R0                  Anything?
         BNZ   I0110                  Yes, skip
         IC    R0,@I_JFCBUFNO         No, get DCB=BUFNO=
         LTR   R0,R0                  Anything?
         BZ    I0120                  No, use default
I0110    DS    0H
         STH   R0,@I_Buffer_Count     Yes, update our variable
I0120    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Get some storage above-the-line for our buffers and stuff:     *
*     +0     A(Next Buffer area)                                    *
*     +4     A(DECB)                                                *
*     +8     Offset within buffer of next segment                   *
*     +C     Buffer (length of DCBBLKSI)                            *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,BuffArea_Hdr_Length Header bytes
         AH    R1,@I_BLKSI            Plus buffer area
         LA    R1,7(0,R1)             Make it
         SRL   R1,3                    its a
         SLL   R1,3                    doubleword
         ST    R1,@I_Buffer_Length    Save Buffer length
         LA    R2,8(0,R1)             Minimum storage we need
         LH    R0,@I_Buffer_Count     Number of buffers we need
         MR    R0,R0                  Total length
         LA    R0,8(0,R1)             plus header length
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=((0),(2)),         this long                     +
               LOC=ANY                   anywhere
         ST    R1,@_SYSUT1_AtL_Ptr    Save the address
         ST    R0,0(0,R1)              and the length
         LR    R15,R0                 Get the length
         SH    R15,=H'8'               less the header length
         SLR   R14,R14                prepare for divide
         D     R14,@I_Buffer_Length   Calculate number of buffers
         STH   R15,@I_Buffer_Count    Save number of buffers

*-------------------------------------------------------------------*
*                                                                   *
*    If we do not have enough room below-the-line for the DCB and   *
*   associated DECBs, free it and go get enough                     *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,I_READ_Length       Length of 1 DECB
         MH    R1,@I_Buffer_Count     Length of all DECBs
         LA    R1,4+I_SYSUT1_BSAM_DCB_Length+I_SYSUT1_DCBE_Length(0,R1)
         L     R15,@_SYSUT1_BtL_Ptr   A(current storage)
         C     R1,0(0,R15)            Long enough?
         BNH   I0130                  Yes, skip
         ST    R1,@I_DBLWD            No, save length required
         L     R1,@_SYSUT1_BtL_Ptr    A(Our storage)
         L     R0,0(0,R1)             Get its length
         STORAGE RELEASE,             Free the storage                 +
               LENGTH=(0),             this long                       +
               ADDR=(1)                starting here
         L     R0,@I_DBLWD            Get the amount we need
         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=(0),               this long                     +
               LOC=BELOW                 below-the-line
         ST    R0,0(0,R1)             Save the length
         ST    R1,@_SYSUT1_BtL_Ptr    Save A(Storage)
I0130    DS    0H
         L     R2,@_SYSUT1_BtL_Ptr    A(Below-the-line storage)
         LA    R2,4(0,R2)             A(DCB area)
         MVC   0(I_SYSUT1_BSAM_DCB_Length,R2),I_SYSUT1_BSAM_DCB Move it

         LH    R15,@I_Buffer_Count    Nbr buffers
         STC   R15,DCBNCP-IHADCB(R2)  Update NCP

         LA    R14,I_SYSUT1_BSAM_DCB_Length(0,R2) Point past DCB
         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE
         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB

         ST    R2,@_SYSUT1_DCB_Ptr    Init DCB address

         B     I0190                  and skip

I0140    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SYSUT1 is non-VSAM and not RECFM=VS or VBS, so we will use     *
*   QSAM.                                                           *
*                                                                   *
*-------------------------------------------------------------------*

         OI    @_SYSUT1_QSAM,L'@_SYSUT1_QSAM Set QSAM Input flag

         SLR   R0,R0                  Clear work register
         IC    R0,@I_JFCBUFNO         Get user-specified DCB=BUFNO=
         LTR   R0,R0                  Anything?
         BNZ   I0150                  Yes, skip
         IC    R0,@I_JFCNCP           No, get DCB=NCP=
         LTR   R0,R0                  Anything?
         BZ    I0160                  No, skip
I0150    DS    0H
         STH   R0,@I_Buffer_Count     Yes, update our field
I0160    DS    0H
         MVC   0(I_SYSUT1_QSAM_DCB_Length,R2),I_SYSUT1_QSAM_DCB
         LH    R15,@I_Buffer_Count    Blocks per cyl
         STC   R15,DCBBUFNO-IHADCB(R2) Save it

         LA    R14,I_SYSUT1_QSAM_DCB_Length(0,R2) Point past DCB
         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE
         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB

         ST    R2,@_SYSUT1_DCB_Ptr    Init DCB address
         B     I0190                  and skip

I0170    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SYSUT1 is VSAM, so set our flag ...                            *
*                                                                   *
*-------------------------------------------------------------------*

         OI    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM  Set VSAM Input flag

*-------------------------------------------------------------------*
*                                                                   *
*    ... save some VSAM-related info from the JFCB ...              *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@I_JFCB_Ptr          A(JFCB)

         SLR   R0,R0                    Clear work register
         L     R0,JFCBABFS+1-INFMJFCB(R15) Get BUFSP
         SRL   R0,8                     Align it properly
         ST    R0,@I_JFCBABFS           Save it
         SLR   R0,R0                    Clear work register
         LH    R0,JFCBADBF-INFMJFCB(R15) Get BUFND
         STH   R0,@I_JFCBADBF           Save it

*-------------------------------------------------------------------*
*                                                                   *
*    ... free the below-the-line storage ...                        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSUT1_BtL_Ptr      A(Below-the-line storage)
         L     R0,0(0,R1)               Get its length
         STORAGE RELEASE,               Free the storage               +
               LENGTH=(0),               this long                     +
               ADDR=(1)                  starting here
         SLR   R15,R15                  Clear work register
         ST    R15,@_SYSUT1_BtL_Ptr     No more storage below

*-------------------------------------------------------------------*
*                                                                   *
*    ... and get some above-the-line for the ACB, EXLST and RPL     *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R0,4+I_SYSUT1_ACB_Length+I_SYSUT1_EXLST_Length+SYSUT1_RP+
               L_Length
         STORAGE OBTAIN,                Get some storage               +
               LENGTH=(0),               this long                     +
               LOC=ANY                   from above-the-line
         ST    R1,@_SYSUT1_AtL_Ptr      Save the address
         ST    R0,0(0,R1)               Save the length
         LA    R2,4(0,R1)               Point to ACB area
         MVC   0(I_SYSUT1_ACB_Length,R2),I_SYSUT1_ACB  Move ACB
         ST    R2,@_SYSUT1_ACB_Ptr      Save A(ACB)

         LA    R3,I_SYSUT1_ACB_Length(0,R2) A(Dynamic EXLST)
         MVC   0(I_SYSUT1_EXLST_Length,R3),I_SYSUT1_EXLST Move it
         MODCB ACB=(2),               Update SYSUT1 ACB                +
               EXLST=(3),              with EXLST                      +
               MF=(G,@I_MODCB1,I_MODCB1_Length)

         ICM   R0,B'1111',@I_JFCBABFS Get user-specified BUFSP=
         BNZ   I0180                  OK, skip
         LH    R0,@I_JFCBADBF         None, get user specified BUFND=
         LTR   R0,R0                  Any?
         BNZ   I0180                  Yes, skip
         SLR   R15,R15                No, clear work register
         ST    R15,@I_BUFSP           Clear Buffer space
         LH    R2,@I_DVATRK           Get Trks/Cyl
         LH    R3,@I_DVATRKLN         Get Bytes/Trk
         SLL   R3,16                  Make sure
         SRL   R3,16                   its positive
         MR    R2,R2                  Get Bytes/Cyl
         LTR   R3,R3                  Anything?
         BZ    I0180                  No, don't modify ACB
         A     R3,=FL4'4096'          Yes, bump by a page
         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)
         MODCB ACB=(2),               Update SYSUT1 ACB                +
               BUFSP=(3),               for bytes/cyl                  +
               MF=(G,@I_MODCB2,I_MODCB2_Length)

         ST    R3,@I_BUFSP            and save Buffer Space
I0180    DS    0H
         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)
         LA    R3,@_SYSUT1_Rec_Length A(RECEIVING AREA)
         SHOWCB ACB=(2),              YES, FROM SYSUT1 ACB             *
               FIELDS=LRECL,            WE WANT THE LRECL              *
               AREA=(3),                MOVED TO THIS AREA             *
               LENGTH=L'@_SYSUT1_Rec_Length, for this long             *
               MF=(G,@I_SHOWCB,I_SHOWCB_Length)
         LTR   R15,R15                Did it work?
         BZ    I0190                  Yes, skip
         LH    R15,=H'32767'          No, assume the biggest
         ST    R15,@_SYSUT1_Rec_Length and save it
I0190    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area in which the input record will be assembled        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSUT1_Rec_Length Get size of record
         LA    R1,7(0,R1)            Make it
         SRL   R1,3                   doubleword multiple
         SLDL  R0,35                  in R0
         STORAGE OBTAIN,             Get some storage                  +
               LENGTH=(0),            this long                        +
               LOC=BELOW              below the line

         ST    R1,@_SYSUT1_Rec_Ptr   Save it

*-------------------------------------------------------------------*
*                                                                   *
*    And open SYSUT1 (@_SYSUT1_DCB_Ptr contains the address of the  *
*   DCB or ACB)                                                     *
*                                                                   *
*-------------------------------------------------------------------*

         L     R2,@_SYSUT1_DCB_Ptr    Point to the DCB/ACB
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN DCB already open?
         BO    I0210                  Yes, skip the OPEN
         MVC   @I_OPEN,I_OPEN         MOVE OPEN PARMS
         OPEN  ((2),INPUT),MODE=31,MF=(E,@I_OPEN) AND OPEN DCB/ACB
         LTR   R15,R15                DID IT OPEN?
         BNZ   I8020                  NO, ERROR
I0210    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    SYSUT1 is open, so go list some interesting(?) info            *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSUT1_DCB_Ptr    A(DCB or ACB)
         L     R15,=A(J0010)          A(DCB info routine)
         BASR  R14,R15                Go do it

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                SKIP A LINE
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                  AND ANOTHER

*-------------------------------------------------------------------*
*                                                                   *
*    SYSUT1 has been opened successfully - if we are using BSAM     *
*   to read it ...                                                  *
*                                                                   *
*-------------------------------------------------------------------*

         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Are we using BSAM?
         BNO   I0410                  No, skip

*-------------------------------------------------------------------*
*                                                                   *
*    ... initialize the DECBs and buffer areas, and prime the areas *
*   with initial READs                                              *
*                                                                   *
*-------------------------------------------------------------------*

         L     R4,@_SYSUT1_AtL_Ptr    A(Above-the-line storage)
         LA    R4,8(0,R4)             A(1st buffer area)
         L     R2,@_SYSUT1_DCB_Ptr    A(DCB)
         LA    R5,I_SYSUT1_BSAM_DCB_Length+I_SYSUT1_DCBE_Length(0,R2)
         LH    R6,@I_Buffer_Count     Nbr buffers
I0400    DS    0H
         ST    R5,BuffArea_DECB_Ptr-BuffArea(0,R4) Save A(DECB)
         MVC   0(I_READ_Length,R5),I_READ  Initialize DECB
         LA    R3,BuffArea_IOArea-BuffArea(0,R4) A(I/O Area)
         READ  (5),SF,(2),(3),'S',MF=E    Issue the read
         SLR   R15,R15                Clear work register
         ST    R15,BuffArea_Offset-BuffArea(0,R4) Clear Offset
         L     R15,@I_Buffer_Length   Get buffer size
         AR    R15,R4                 Point to next area
         ST    R15,BuffArea_Next_Ptr-BuffArea(0,R4) Chain BuffAreas
         LR    R4,R15                 Point to next BuffArea
         LA    R5,I_READ_Length(0,R5) A(next DECB)
         BCT   R6,I0400               and do it too

         S     R4,@I_Buffer_Length    Back up to last buffer area
         L     R15,@_SYSUT1_AtL_Ptr   Point to
         LA    R15,8(0,R15)             1st buffer area
         ST    R15,BuffArea_Next_Ptr-BuffArea(0,R4) Chain last to 1st
         ST    R15,@_SYSUT1_BuffArea_Ptr And init our pointer

I0410    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    If the input is VSAM, generate an RPL in the area after the    *
*   ACB                                                             *
*                                                                   *
*-------------------------------------------------------------------*


         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM Is SYSUT1 VSAM?
         BNO   I0420                    No, skip

         L     R2,@_SYSUT1_ACB_Ptr      A(ACB)
         LA    R3,I_SYSUT1_ACB_Length+I_SYSUT1_EXLST_Length(0,R2)
         L     R4,@_SYSUT1_Rec_Ptr      A(Record area)
         L     R5,@_SYSUT1_Rec_Length   Length of a record
         GENCB BLK=RPL,               GENERATE RPL                     *
               AM=VSAM,                 FOR VSAM                       *
               ACB=(2),                 SYSUT1                         *
               AREA=(4),                A(INPUT RECORD ADDRESS)        *
               AREALEN=(5),             Len of the address             *
               OPTCD=(ADR,SEQ,MVE,SYN), MOVE MODE                      *
               WAREA=(3),               BUILD THE RPL HERE             *
               LENGTH=SYSUT1_RPL_Length,  its this long                +
               MF=(G,@I_GENCB,I_GENCB_Length)

         ST    R3,@_SYSUT1_RPL_Ptr      Save A(RPL)

I0420    DS    0H
         SLR   R15,R15                Clear return code
         B     I9000                  and exit

I8000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    No active SMF file                                             *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)
         MVC   1(16,R1),=C'No active SMF File found'
         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                GO PRINT IT
         LA    R15,4                  FLAG AN ERROR
         B     I9000                  AND EXIT

I8010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Dynalloc (SVC99) error                                         *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)
         MVC   1(16,R1),=C'Error allocating'
         MVC   18(10,R1),@I_SVC99_DSName_TU+S99TUPAR-S99TUNIT MOVE DSN
         MVC   28(30,R1),=C', RC=XX, Error=XXXX, Info=XXXX'
         SRL   R15,4                  MAKE ROOM FOR "SIGN"
         STH   R15,@I_DBLWD           SAVE IT
         OI    @I_DBLWD+1,X'0F'       INSERT A  SIGN
         UNPK  @I_DBLWD+2(3),@I_DBLWD(2) UNPACK IT
         TR    @I_DBLWD+3(2),I_HexNum MAKE IT READABLE
         MVC   33(2,R1),@I_DBLWD+3    MOVE TO MESSAGE
         LH    R15,@I_SVC99_RB+S99ERROR-S99RB GET ERROR CODE
         SRL   R15,4                  MAKE ROOM FOR SIGN
         ST    R15,@I_DBLWD+4         SAVE IT
         OI    @I_DBLWD+7,X'0F'       INSERT A SIGN
         UNPK  @I_DBLWD(5),@I_DBLWD+5(3) UNPACK IT
         TR    @I_DBLWD+1(4),I_HexNum MAKE IT READABLE
         MVC   43(4,R1),@I_DBLWD+1   MOVE TO MESSAGE
         LH    R15,@I_SVC99_RB+S99INFO-S99RB GET INFO CODE
         SRL   R15,4                  MAKE ROOM FOR SIGN
         ST    R15,@I_DBLWD+4         SAVE IT
         OI    @I_DBLWD+7,X'0F'       INSERT A SIGN
         UNPK  @I_DBLWD(5),@I_DBLWD+5(3) UNPACK IT
         TR    @I_DBLWD+1(4),I_HexNum MAKE IT READABLE
         MVC   54(4,R1),@I_DBLWD+1   MOVE TO MESSAGE
         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                GO PRINT IT
         LA    R15,4                  FLAG AN ERROR
         B     I9000                  AND EXIT
I8020    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Error opening SYSUT1                                           *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSPRINT_Rec_Ptr  NO, GET A(SYSPRINT RECORD)
         MVC   22(40,R1),=C'SYSUT1 could not be opened - terminating'
         LA    R15,12                 SET RETURN CODE
         B     I9000                  AND EXIT

I9000    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R3,R15                   Rescue the return code

         LA    R1,@I_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R15,R3                   Restore return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

I_HexNum EQU   *-239
         DC    C' 0123456789ABCDEF'

         LTORG


         PUSH PRINT
         PRINT NOGEN
I_SYSUT1_QSAM_DCB DCB DDNAME=SYSUT1,MACRF=GM,DSORG=PS,OPTCD=C,         +
               DCBE=1
I_SYSUT1_QSAM_DCB_Length EQU *-I_SYSUT1_QSAM_DCB LENGTH OF SYSUT1 DCB

I_SYSUT1_BSAM_DCB DCB DDNAME=SYSUT1,MACRF=RC,DSORG=PS,                 +
               DCBE=1
I_SYSUT1_BSAM_DCB_Length EQU *-I_SYSUT1_BSAM_DCB LENGTH OF SYSUT1 DCB

I_SYSUT1_DCBE DCBE RMODE31=BUFF,MULTSDN=1,EODAD=1
I_SYSUT1_DCBE_Length EQU *-I_SYSUT1_DCBE Length of SYSUT1 DCBE

I_SYSUT1_ACB ACB AM=VSAM,               FOR VSAM                       *
               DDNAME=SYSUT1,           SYSUT1                         *
               BUFND=3,                 DATA BUFFERS                   *
               BUFSP=131072,            128K FOR BUFFERS               *
               STRNO=1,                 NBR STRINGS                    *
               EXLST=I_SYSUT1_EXLST,    EODAD                          *
               MACRF=(ADR,NFX,DDN,NRM,NRS,SEQ,IN),                     *
               RMODE31=ALL              Everything above-the-line
             DS    0D
I_SYSUT1_ACB_Length EQU   *-I_SYSUT1_ACB

         PRINT GEN
I_SYSUT1_EXLST EXLST AM=VSAM,           For VSAM                       +
               EODAD=1                   End-of-Data
             DS    0D
I_SYSUT1_EXLST_Length EQU *-I_SYSUT1_EXLST
         PRINT NOGEN

I_OPEN   OPEN  (0,INPUT),MODE=31,MF=L
I_OPEN_Length EQU  *-I_OPEN

         READ  I_READ,SF,0,0,'S',MF=L
I_READ_Length EQU  *-I_READ

I_CLOSE  CLOSE (0),MODE=31,MF=L
I_CLOSE_Length EQU *-I_CLOSE

         POP    PRINT
@I_Dynam        DSECT                 Dynamic area for I
@I_Save         DS    18F              O/S Style save area
@I_DBLWD        DS    D                Workarea

@I_JFCB_Ptr     DS    AL4              A(JFCB)
@I_DVACLASS     DS    X                Device class from DEVTYPE
@I_DVATRK       DS    HL2              Trks/Cyl from DEVTYPE
@I_DVATRKLN     DS    HL2              Bytes/Trk from DEVTYPE
@I_RECFM        DS    X                DCB=RECFM

@I_DCBChar      EQU   *                Non-VSAM DCB Characteristics
@I_JFCBUFNO     DS    X                 DCB=BUFNO from JFCB
@I_JFCNCP       DS    X                 DCB=NCP= from JFCB
@I_BLKSI        DS    HL2               SYSUT1 BLKSIZE
@I_NCP          DS    X                 DCB=NCP (calculated by OPEN)
@I_Buffer_Count DS    HL2               Number of buffer areas
@I_Buffer_Length DS   FL4               Buffer area length
@I_ACBChar      ORG   @I_DCBChar       VSAM ACB Characteristics
@I_JFCBABFS     DS    FL4               AMP=BUFSP= from JFCB
@I_JFCBADBF     DS    HL2               AMP=BUFND= from JFCB
@I_BUFSP        DS    FL4               VSAM BUFFSP
                ORG

@I_MACRO        DS    0F               Macro area
                ORG   @I_MACRO
@I_OPEN         DS    CL(I_OPEN_Length) OPEN macro
                ORG   @I_MACRO
@I_CLOSE        DS    CL(I_CLOSE_Length) CLOSE macro
                ORG   @I_MACRO
@I_SHOWCB       DS    CL(I_SHOWCB_Length) SHOWCB Macro
                ORG   @I_MACRO
@I_MODCB1       DS    CL(I_MODCB1_Length) MODCB Macro
                ORG   @I_MACRO
@I_MODCB2       DS    CL(I_MODCB2_Length) MODCB Macro
                ORG   @I_MACRO
@I_GENCB        DS    CL(I_GENCB_Length) GENCB Macro
                ORG   @I_MACRO
@I_DEVAREA      DS    CL(L'DVAPREFX+L'DVATAB) DEVTAB return info
                ORG   @I_MACRO
*-------------------------------------------------------------------*
*                                                                   *
*    DYNAMIC ALLOCATION (SVC 99) CONTROL BLOCKS                     *
*                                                                   *
*-------------------------------------------------------------------*

@I_SVC99_RB_Ptr    DS  F
@I_SVC99_RB        DS  CL(S99RBEND-S99RB)
@I_SVC99_TU_List   DS  6A
@I_SVC99_DDName_TU DS  CL((S99TUPAR-S99TUNIT)+8)      DDNAME
@I_SVC99_DSName_TU DS  CL((S99TUPAR-S99TUNIT)+44)     DSNAME
@I_SVC99_Status_TU DS  CL((S99TUPAR-S99TUNIT)+1)      STATUS
@I_SVC99_NDisp_TU  DS  CL((S99TUPAR-S99TUNIT)+1)      NORMAL DISP
@I_SVC99_CDisp_TU  DS  CL((S99TUPAR-S99TUNIT)+1)      COND DISP
@I_SVC99_Free_TU   DS  CL(S99TUENT-S99TUNIT)          FREE=CLOSE
                   ORG ,

                DS    0D               Alignment
@I_DynLen       EQU   *-@I_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         TITLE 'J0000: Print info about DCB'

         PUSH  USING

J0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : J0010                                                  *
*                                                                     *
*  Abstract  : Print info about a DCB or ACB.                         *
*                                                                     *
*  Inputs    : R1 ----> A(Open DCB or ACB)                            *
*  Outputs   : R15: 0 - OK                                            *
*                   4 - SYSUT1 not useable.                           *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              2002/02/07 SDDA030 V1.4                                *
*                                 Invoked W0010 to get JFCB and TIOT  *
*                                 addresses.                          *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING J0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@J_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@J_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @J_Dynam,R13             Assign a base
         L     R15,@J_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         ST    R1,@J_DCB_Ptr            Save A(DCB)

*-------------------------------------------------------------------*
*                                                                   *
*    Get our JFCB ...                                               *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(W0010)          A(Get JFCB routine)
         BASR  R14,R15                  Go do it

         ST    R1,@J_JFCB_Ptr           Save A(JFCB)
         ST    R0,@J_TIOT_Entry_Ptr     Save A(TIOT Entry)

*-------------------------------------------------------------------*
*                                                                   *
*    Put out the DSN and volsers for this DDName                    *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSPRINT_Rec_Ptr    Get A(SYSPRINT Record)
         L     R15,@J_TIOT_Entry_Ptr    Get A(TIOT Entry)
         MVC   1(L'TIOEDDNM,R1),TIOEDDNM-TIOENTRY(R15) Move DDName
         MVC   2+L'TIOEDDNM(5,R1),=C'DSN: ' Move heading
         L     R15,@J_JFCB_Ptr          Get A(JFCB)
         MVC   2+L'TIOEDDNM+5(L'JFCBDSNM,R1),JFCBDSNM-INFMJFCB(R15)
         LA    R1,2+L'TIOEDDNM+5+L'JFCBDSNM-1(,R1)  A(End of DSN)
J0020    DS    0H
         CLI   0(R1),C' '               Is this the end?
         BNE   J0030                    Yes, skip
         BCT   R1,J0020                 No, back up and try again
J0030    DS    0H
         MVC   1(10,R1),=C', Volser: '  Move VOLSER heading
         LA    R1,11(0,R1)              Point past it
         L     R15,@J_JFCB_Ptr          Get A(JFCB Pointer)
         TM    JFCFLGS1-INFMJFCB(R15),JFCVRDS VIO?
         BNO   J0030C                   No, skip
         MVC   0(7,R1),=C'**VIO**'      Yes, dummy volser
         B     J0050                    and skip
J0030C   DS    0H

         SLR   R0,R0                    Clear work register
         IC    R0,JFCBNVOL-INFMJFCB(R15) Get nbr volsers
         LA    R15,JFCBVOLS-INFMJFCB(R15)  and point to first
         CH    R0,=H'5'                 More than 5?
         BNH   J0040                    No, skip
         LA    R0,5                     Yes, only the 1st 5
J0040    DS    0H
         MVC   0(6,R1),0(R15)           Move VOLSER
         SH    R0,=H'1'                 Reduce volser count
         BNP   J0050                    thats all, skip
         MVI   6(R1),C','               More, add a comma
         LA    R1,7(0,R1)               Point to next output area
         LA    R15,6(0,R15)             A(Next input volser)
         B     J0040                    and do it too
J0050    DS    0H
         L     R15,=AL4(G0010)          A(SYSPRINT routine)
         BASR  R14,R15                  Go print it

*-------------------------------------------------------------------*
*                                                                   *
*    Put out the DCB or ACB information                             *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@J_DCB_Ptr           A(DCB)
         TM    DCBDSRG2-IHADCB(R15),DCBACBM Is this VSAM?
         BO    J0140                    Yes, format VSAM stuff
         L     R1,@_SYSPRINT_Rec_Ptr    No, get A(SYSPRINT Record)
         MVC   10(11,R1),=C'DCB=(RECFM=' Move heading
         LA    R1,21(0,R1)              Point to next byte
         TM    DCBRECFM-IHADCB(R15),DCBRECF+DCBRECV  RECFM=U?
         BNO   J0060                    No, skip
         MVI   0(R1),C'U'               Yes, say so
         LA    R1,1(0,R1)               Bump pointer
         B     J0110                    and skip
J0060    DS    0H
         TM    DCBRECFM-IHADCB(R15),DCBRECF  RECFM=F?
         BZ    J0070                    No, skip
         MVI   0(R1),C'F'               Yes, say so
         B     J0080                    and skip
J0070    DS    0H
         MVI   0(R1),C'V'               RECFM=V
J0080    DS    0H
         LA    R1,1(0,R1)               Bump pointer
         TM    DCBRECFM-IHADCB(R15),DCBRECBR  Blocked?
         BZ    J0090                    No, skip
         MVI   0(R1),C'B'               Yes, say so
         LA    R1,1(0,R1)               Bump pointer
J0090    DS    0H
         TM    DCBRECFM-IHADCB(R15),DCBRECSB Spanned or Standard?
         BZ    J0100                    No, skip
         MVI   0(R1),C'S'               Yes, say so
         LA    R1,1(0,R1)               and bump pointer
J0100    DS    0H

         MVC   0(7,R1),=C',LRECL='      Move literal
         LA    R1,7(0,R1)               Point to next byte
         LH    R0,DCBLRECL-IHADCB(R15)  Get LRECL
         CVD   R0,@J_DBLWD              Pack it
         MVC   @J_Temp(5),=X'2020202120' Move mask
         LR    R2,R1                    Save A(Output Byte)
         LA    R1,@J_Temp+4             A(Significant digit)
         EDMK  @J_Temp(5),@J_DBLWD+5    Edit it
         LR    R0,R1                    A(Start digit)
         LA    R1,@J_Temp+5             Calculate
         SR    R1,R0                     length
         LR    R3,R1                    Destination length
         MVCL  R2,R0                    Move it
         LR    R1,R2                    A(Next byte)
J0110    DS    0H
         MVC   0(9,R1),=C',BLKSIZE='    Move literal
         LA    R1,9(0,R1)               Point to next byte
         LH    R0,DCBBLKSI-IHADCB(R15)  Get BLKSIZE
         CVD   R0,@J_DBLWD              Pack it
         MVC   @J_Temp(5),=X'2020202120' Move mask
         LR    R2,R1                    Save A(Output Byte)
         LA    R1,@J_Temp+4             A(Significant digit)
         EDMK  @J_Temp(5),@J_DBLWD+5    Edit it
         LR    R0,R1                    A(Start digit)
         LA    R1,@J_Temp+5             Calculate
         SR    R1,R0                     length
         LR    R3,R1                    Destination length
         MVCL  R2,R0                    Move it
         LR    R1,R2                    A(Next byte)

         TM    DCBCIND2-IHADCB(R15),DCBCNQSM  QSAM?
         BZ    J0120                    No, skip

         TM    DCBCIND1-IHADCB(R15),DCBCBNDF  Yes, BUFNO default?
         BO    J0130                    Yes, skip
         MVC   0(7,R1),=C',BUFNO='      No, move literal
         LA    R1,7(0,R1)               Point to next byte
         SLR   R0,R0                    Clear work register
         IC    R0,DCBBUFNO-IHADCB(R15)  Get BUFNO
         CVD   R0,@J_DBLWD              Pack it
         MVC   @J_Temp(3),=X'202120' Move mask
         LR    R2,R1                    Save A(Output Byte)
         LA    R1,@J_Temp+2             A(Significant digit)
         EDMK  @J_Temp(3),@J_DBLWD+6    Edit it
         LR    R0,R1                    A(Start digit)
         LA    R1,@J_Temp+3             Calculate
         SR    R1,R0                     length
         LR    R3,R1                    Destination length
         MVCL  R2,R0                    Move it
         LR    R1,R2                    A(Next byte)
         B     J0130                    and skip

J0120    DS    0H
         MVC   0(5,R1),=C',NCP='        No, move literal
         LA    R1,5(0,R1)               Point to next byte
         SLR   R0,R0                    Clear work register
         IC    R0,DCBNCP-IHADCB(R15)    Get NCP
         CVD   R0,@J_DBLWD              Pack it
         MVC   @J_Temp(3),=X'202120'    Move mask
         LR    R2,R1                    Save A(Output Byte)
         LA    R1,@J_Temp+2             A(Significant digit)
         EDMK  @J_Temp(3),@J_DBLWD+6    Edit it
         LR    R0,R1                    A(Start digit)
         LA    R1,@J_Temp+3             Calculate
         SR    R1,R0                     length
         LR    R3,R1                    Destination length
         MVCL  R2,R0                    Move it
         LR    R1,R2                    A(Next byte)
J0130    DS    0H

         MVI   0(R1),C')'               Close off DCB info

         L     R15,=AL4(G0010)          A(SYSPRINT routine)
         BASR  R14,R15                  Go print it

         B     J0170                    and skip

J0140    DS    0H

         SLR   R0,R0                  Clear work register
         ST    R0,@J_BUFND            Clear data space
         ST    R0,@J_BUFSP            and buffer space
         LR    R2,R15                 A(ACB)
         LA    R3,@J_BUFND            A(Receiving area)
         SHOWCB ACB=(2),              Get data from this ACB           +
               FIELDS=(BUFND,BUFSP),    this data                      +
               AREA=(3),                moved to here                  +
               LENGTH=8,                for this long                  +
               MF=(G,@J_SHOWCB,J_SHOWCB_Length)

         L     R0,@J_BUFND            Get Data space
         A     R0,@J_BUFSP            and buffer space
         LTR   R0,R0                  anything to say?
         BZ    J0170                  No, skip

         L     R1,@_SYSPRINT_Rec_Ptr    Yes, get A(SYSPRINT Record)
         MVC   10(7,R1),=C'AMP=BUF'     Move literal
         ICM   R0,B'1111',@J_BUFSP      Get buffer space
         BZ    J0150                    None, skip
         MVC   17(2,R1),=C'SP'          Yes, make it BUFSP
         B     J0160
J0150    DS    0H
         MVC   17(2,R1),=C'ND'          Make it BUFND
         L     R0,@J_BUFND              and load up the register
J0160    DS    0H
         MVI   19(R1),C'='              Move literal
         LA    R1,20(0,R1)              Point to next char
         CVD   R0,@J_DBLWD              Pack our value
         MVC   @J_Temp(9),=X'202020202020202120'
         LR    R2,R1                    Save A(Output Byte)
         LA    R1,@J_Temp+8             A(Significant digit)
         EDMK  @J_Temp(9),@J_DBLWD+3    Edit it
         LR    R0,R1                    A(Start digit)
         LA    R1,@J_Temp+9             Calculate
         SR    R1,R0                     length
         LR    R3,R1                    Destination length
         MVCL  R2,R0                    Move it

         L     R15,=AL4(G0010)          A(SYSPRINT routine)
         BASR  R14,R15                  Go print it

J0170    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    If this is the input file (SYSUT1) ...                         *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@J_TIOT_Entry_Ptr    A(TIOT entry)
         CLC   =CL8'SYSUT1',TIOEDDNM-TIOENTRY(R15)  Input file?
         BNE   J9010                    No, all done

*-------------------------------------------------------------------*
*                                                                   *
*    ... display some info about input processing                   *
*                                                                   *
*-------------------------------------------------------------------*


         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM Is this VSAM?
         BO    J0200                  Yes, skip VBS stuff
         L     R15,@J_DCB_Ptr         A(DCB)
         TM    DCBRECFM-IHADCB(R15),DCBRECV+DCBRECSB VS or VBS?
         BNO   J0200                  No, skip
         L     R2,@_SYSPRINT_Rec_Ptr  Yes, A(Print record)
         MVC   10(31,R2),=C'Variable Spanned segments will '
         LA    R2,41(0,R2)            Point to next byte
         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Is this BSAM?
         BNO   J0180                  No, skip
         TM    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk Yes, checking VBS?
         BNO   J0190                  Yes, skip
J0180    DS    0H
         MVC   0(4,R2),=C'not '       No VBS checking
         LA    R2,4(0,R2)             bump output pointer
J0190    DS    0H
         MVC   0(27,R2),=C'be checked for consistency.'

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO PRINT THE LINE
J0200    DS    0H
         L     R2,@_SYSPRINT_Rec_Ptr  A(Print record)
         MVC   10(11,R2),=C'Input data '
         TM    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Input in sequence?
         BNO   J0210                  No, skip
         MVC   21(14,R2),=C'assumed to be '
         LA    R2,35(0,R2)            bump output pointer
         B     J0220                  and skip
J0210    DS    0H
         MVC   21(16,R2),=C'not necessarily '
         LA    R2,37(0,R2)            bump output pointer
J0220    DS    0H
         MVC   0(12,R2),=C'in sequence.'

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO PRINT THE LINE

J9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,@J_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R15,R15                  Clear return code
         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

         LTORG


@J_Dynam        DSECT                 Dynamic area for J
@J_Save         DS    18F              O/S Style save area
@J_DBLWD        DS    D                Work area
@J_Temp         DS    CL10             Work area
@J_DCB_Ptr      DS    AL4              A(DCB)
@J_TIOT_Entry_Ptr DS  AL4              A(TIOT Entry for this DCB)
@J_JFCB_Ptr     DS    AL4              A(JFCB)

@J_Macro        DS    0F               Macro area
@J_SHOWCB       DS    CL(J_SHOWCB_Length) SHOWCB Macro
                DS    0F
@J_BUFND        DS    FL4              BUFND from ACB
@J_BUFSP        DS    FL4              BUFSP from ACB
                ORG
                DS    0D               Alignment
@J_DynLen       EQU   *-@J_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING

         TITLE 'K0000 - Date/Time Conversion Routine'
K0010    DS    0H

         PUSH  USING

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : K0010                                                  *
*                                                                     *
*  Abstract  : Populate DateConv_Area Dates and Times                 *
*                                                                     *
*  Inputs    : R1 ----> DateConv Area                                 *
*  Outputs   : R15 = 0, DateConv_Area contains converted              *
*                       Date/Time values.                             *
*              R15 = 4, DateConv_Area unchanged                       *
*                                                                     *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING K0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@K_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@K_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @K_Dynam,R13             Assign a base
         L     R15,@K_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         ST    R1,@K_DateConv_Area_Ptr  Save A(Callers DateConv_Area)
         MVC   @K_DateConv_Area,0(R1)   Copy callers DateConv_Area
         LA    R9,@K_DateConv_Area      Point to our DateConv_Area
         USING DateConv_Area,R9         Tell the assembler

         TM    DConv_Input_Base,L'DConv_Input_Base  Base Date?
         BO    K0020                    Yes, skip
         TM    DConv_Input_YYMMDD,L'DConv_Input_YYMMDD Std num date?
         BO    K0020                    Yes, skip
         TM    DConv_Input_YYMonDD,L'DConv_Input_YYMonDD Normal Date?
         BO    K0020                    Yes, skip
         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate SMF?
         BO    K0020                    Yes, skip
         TM    DConv_Input_Julian,L'DConv_Input_Julian Julian Date?
         BZ    K0180                    No, check time

K0020    DS    0H
         TM    DConv_Input_Base,L'DConv_Input_Base  Base Date?
         BO    K0110                    Yes, skip

         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate SMF?
         BNO   K0030                    No, skip
         ZAP   @K_DBLWD,=P'1900000'     Yes, set
         AP    @K_DBLWD,DConv_Date_SMFDate  up Y2K Date
         L     R15,@K_DBLWD+4           Save it
         XC    @K_DBLWD+4(2),@K_DBLWD+4 Clear out year
         CVB   R0,@K_DBLWD              Binarize Day-of-year
         STH   R0,DConv_Date_DDD        Save it
         SRL   R15,12                   Get rid of ddd
         ST    R15,@K_DBLWD+4           Save it
         OI    @K_DBLWD+7,X'0F'         Set up sign
         CVB   R0,@K_DBLWD              Binarize Year
         STH   R0,DConv_Date_YYYY       and save it too
K0030    DS    0H

         LH    R15,DConv_Date_YYYY      No, get Year
         LTR   R15,R15                  Is it 0
         BNP   K8010                    Yes, error

         TM    DConv_Input_YYMMDD,L'DConv_Input_YYMMDD Std num date?
         BZ    K0040                    No, skip

*---------------------------------------------------------------------*
*                                                                     *
*   Standard Date (yyyymmdd): dd, mm must be consistent               *
*                                                                     *
*---------------------------------------------------------------------*

         BAS   R14,K6000       Go validate dd, mm
         LTR   R15,R15         OK?
         BNZ   K8010           No, error
         STH   R0,DConv_Date_DDD Yes, save day-of-year
         B     K0100           and go calculate BDate

K0040    DS    0H
         TM    DConv_Input_YYMonDD,L'DConv_Input_YYMonDD Std num date?
         BZ    K0070                    No, skip

*---------------------------------------------------------------------*
*                                                                     *
*   Normal Date (yyyymondd): dd, mon must be consistent               *
*                                                                     *
*---------------------------------------------------------------------*

         OC    DConv_Date_Month,=CL(L'DConv_Date_Month)' ' Upper-case
         LA    R15,K_MONTHS    A(Month-name table)
         LA    R14,1           Set month number
K0050    DS    0H
         MVC   @K_DBLWD(3),2(R15) Move month name from table
         OC    @K_DBLWD(3),=C'   ' Uppercase it
         CLC   @K_DBLWD(3),DConv_Date_Month Is this us?
         BE    K0060           Yes, skip
         LA    R15,11(0,R15)   No, bump to next month
         LA    R14,1           Bump month number
         CH    R14,=H'12'      Too far?
         BNH   K0050           No, try again
         B     K8010           Unknown month, error
K0060    DS    0H
         STC   R14,DConv_Date_MM  Save month number
         BAL   R14,K6000       Go validate dd, mm, and yy
         LTR   R15,R15         OK?
         BNZ   K8010           No, error
         STH   R0,DConv_Date_DDD Yes, save day-of-year
         B     K0100           and go calculate BDate

K0070    DS    0H
         TM    DConv_Input_Julian,L'DConv_Input_Julian  JDate?
         BO    K0080                    Yes, do it
         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate No, SMF
         BZ    K0180                    No, skip
K0080    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Julian Date (yyyyddd): yyyy, ddd must be consistent               *
*                                                                     *
*---------------------------------------------------------------------*

         LH    R2,DConv_Date_DDD Get Day of year
         LTR   R2,R2           Is it 0
         BNP   K8010           Yes, error

         LA    R2,365          Days in a normal year
         BAS   R14,K7000       Go check leap year
         LTR   R15,R15         Is it a leap year?
         BZ    K0090           No, skip
         LA    R2,1(0,R2)      Yes, bump max days
K0090    DS    0H
         CH    R2,DConv_Date_DDD Day-of-year too big?
         BL    K8010           Yes, error

K0100    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Calculate Base Date using the Julian Date in DConv_Date_YYYY and  *
*    DConv_Date_DDD                                                   *
*   In REXX terms,                                                    *
*      YYYY = YYYY - 1             /*  Based on Year 0001          */ *
*      BDate = (YYYY * 365) +,     /*  Days per year        plus   */ *
*              (YYYY % 4)   -,     /*  Leap days            minus  */ *
*              (YYYY % 100) +,     /*  non-Leap Centuries   plus   */ *
*              (YYYY % 400) +,     /*  Leap centuries       plus   */ *
*              DDD          -,     /*  Days in year         minus  */ *
*              1                   /*  1 to get complete days      */ *
*                                                                     *
*---------------------------------------------------------------------*

         LH    R2,DConv_Date_YYYY Get year
         SH    R2,=H'1'         relative to year 0001
         LR    R15,R2          Year *
         MH    R15,=H'365'            365
         LR    R0,R15          Initialize accumulator
         LR    R15,R2          Year
         SLR   R14,R14              %
         D     R14,=F'4'              4
         AR    R0,R15          Bump accumulator
         LR    R15,R2          Year
         SLR   R14,R14              %
         D     R14,=F'100'            100
         SR    R0,R15          Reduce accumulator
         LR    R15,R2          Year
         SLR   R14,R14              %
         D     R14,=F'400'            400
         AR    R0,R15          Bump accumulator
         AH    R0,DConv_Date_DDD  Add days in current year
         SH    R0,=H'1'        Complete days
         ST    R0,DConv_Date_Base  Initialize Base Date
         B     K0110           And skip
K0110    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Calculate various bits from the base date:                        *
*     DConv_Date_YYYY                                                 *
*     DConv_Date_DDD                                                  *
*     DConv_Date_MM                                                   *
*     DConv_Date_DD                                                   *
*                                                                     *
*   First, calculate the Year, and Day-of-year ...                    *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE
         L     R15,DConv_Date_Base Get the base date
         SLR   R14,R14         set up for divide
         D     R14,=F'365'     Do it
         STH   R15,DConv_Date_YYYY Save Year
         SPACE
*---------------------------------------------------------------------*
*                                                                     *
*   ... and adjust the Day-of-year for leap years                     *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE
         LR    R0,R14          Get day-of-year
         LH    R15,DConv_Date_YYYY Get number
         SLR   R14,R14          of
         D     R14,=F'4'          leap-days
         SR    R0,R15          Reduce day-of-year
         LH    R15,DConv_Date_YYYY Get number
         SLR   R14,R14          of
         D     R14,=F'100'        centuries
         AR    R0,R15          Bump day-of-year
         LH    R15,DConv_Date_YYYY Get number
         SLR   R14,R14          of
         D     R14,=F'400'        leap centuries
         SR    R0,R15          Reduce day-of-year
         A     R0,=FL4'1'      Bump for incomplete day
         SPACE
*---------------------------------------------------------------------*
*                                                                     *
*   Day-of-year is almost certainly negative at this point, so we     *
*   will adjust it (and year) until it is greater than 1.             *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE
K0120    DS    0H
         C     R0,=FL4'1'      Is Day-of-year OK?
         BNL   K0140           Yes, skip
         A     R0,=F'365'      No, bump a year's worth
         BAS   R14,K7000       Check for leap year
         LTR   R15,R15         Is this a leap year?
         BZ    K0130           No, skip
         A     R0,=FL4'1'      Yes, bump Day-of-year
K0130    DS    0H
         LH    R15,DConv_Date_YYYY Get Year
         S     R15,=FL4'1'     Reduce it
         STH   R15,DConv_Date_YYYY and save it
         B     K0120           Keep checking
K0140    DS    0H
         STH   R0,DConv_Date_DDD Save adjusted Day-of-year
         SPACE
*---------------------------------------------------------------------*
*                                                                     *
*   Adjust Year, since it it relative to 0001                         *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE
         LH    R15,DConv_Date_YYYY Get Year
         A     R15,=FL4'1'     Bump it
         STH   R15,DConv_Date_YYYY and save it

*---------------------------------------------------------------------*
*                                                                     *
*   Create the SMFDate from YYYY and DDD                              *
*                                                                     *
*---------------------------------------------------------------------*

         LH    R0,DConv_Date_YYYY  Get YYYY
         CVD   R0,@K_DBLWD         Pack it
         L     R0,@K_DBLWD+4       Get packed year
         SRL   R0,4                Get rid of sign
         STH   R0,DConv_Date_SMFDate Move YYYY
         LH    R0,DConv_Date_DDD   Get DDD
         CVD   R0,@K_DBLWD         Pack it
         MVC   DConv_Date_SMFDate+2(2),@K_DBLWD+6 Move DDD
         SP    DConv_Date_SMFDate,=P'1900000' Convert to SMF Date

*---------------------------------------------------------------------*
*                                                                     *
*   Copy the Days-per-month table, and adjust the number of days in   *
*  February, if this a leap year.                                     *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE
         MVC   @K_Months,K_Months Copy the table
         BAS   R14,K7000       Check for leap year
         LTR   R15,R15         Is this a leap year?
         BZ    K0150           No, skip
         LH    R15,@K_Months+11 Yes, get days in Feb
         LA    R15,1(0,R15)    Bump it
         STH   R15,@K_Months+11 Save it
K0150    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Calculate the month number, and the day-of-month                  *
*                                                                     *
*---------------------------------------------------------------------*

         LH    R0,DConv_Date_DDD Get day-of-year
         LA    R14,1           January
         LA    R15,@K_Months   A(Days-per-month table)
K0160    DS    0H
         CH    R0,0(0,R15)     Is this our month
         BNH   K0170           Yes, skip
         SH    R0,0(0,R15)     No, reduce days
         LA    R14,1(0,R14)    Bump month number
         LA    R15,11(0,R15)   Bump month pointer
         B     K0160           and keep going
K0170    DS    0H
         STC   R0,DConv_Date_DD Save Day-of-month
         STC   R14,DConv_Date_MM and month number
         MVC   DConv_Date_Month,2(R15)  Move month name

         L     R1,DConv_Date_Base Get base date
         SLR   R0,R0           Clear for divide
         D     R0,=F'7'        Get weekday (0=Mon, 1=Tue ...)
         STC   R0,DConv_Date_DOW Save it
         LR    R15,R0          Put in R15
         SLL   R15,3           Weekday num * 8
         AR    R15,R0          Weekday num * 9
         LA    R15,K_DAYS(R15) Point to weekday name
         MVC   DConv_Date_Day,0(R15)  Move weekday name
K0180    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Do Time conversions                                               *
*                                                                     *
*---------------------------------------------------------------------*

         TM    DConv_Input_Time,L'DConv_Input_Time  To hh,mm,ss?
         BNO   K0190           No, skip

         L     R15,DConv_Time  Yes, get secs*100 since midnight
         C     R15,=FL4'8640000' Is it too big?
         BH    K8010           Yes, error
         SLR   R14,R14         Set up for divide
         D     R14,=FL4'360000' Get hours
         STC   R15,DConv_Time_hh Save it
         SRDL  R14,32          Set up for divide
         D     R14,=FL4'6000'  Get minutes
         STC   R15,DConv_Time_mm Save them
         SRDL  R14,32          Set up for divide
         D     R14,=FL4'100'   Get seconds
         STC   R15,DConv_Time_ss Save them
         STC   R14,DConv_Time_tt Save hundredths
         B     K0200           and exit

K0190    DS    0H
         TM    DConv_Input_hhmmss,L'DConv_Input_hhmmss  To secs*100?
         BNO   K0200           No, skip

         SLR   R0,R0           Clear accumulator
         SLR   R15,R15         Clear work register
         IC    R15,DConv_Time_hh Get hours
         L     R14,=FL4'360000' multiplier for secs*100
         MR    R14,R14         Convert it
         AR    R0,R15          Add to accumulator
         SLR   R15,R15         Clear work register
         IC    R15,DConv_Time_mm Get minutes
         L     R14,=FL4'6000'  multiplier for secs*100
         MR    R14,R14         Convert it
         AR    R0,R15          Add to accumulator
         SLR   R15,R15         Clear work register
         IC    R15,DConv_Time_ss Get seconds
         L     R14,=FL4'100' multiplier for secs*100
         MR    R14,R14         Convert it
         AR    R0,R15          Add to accumulator
         SLR   R15,R15         Clear work register
         IC    R15,DConv_Time_tt Get hundredths of seconds
         AR    R0,R15          Add to accumulator
         C     R0,=FL4'8640000' Is it too big?
         BH    K8010           Yes, error
         ST    R0,DConv_Time   Save it

K0200    DS    0H

         L     R15,@K_DateConv_Area_Ptr  A(Callers DateConv_Area)
         MVC   0(DConv_Area_Length,R15),@K_DateConv_Area Copy ours
         SLR   R15,R15         Clear return code
         B     K9010           and exit

K6000    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Validate DConv_Date_MM, DConv_Date_DD                             *
*   If valid, day-of-year is returned in R0                           *
*                                                                     *
*---------------------------------------------------------------------*

         ST    R14,@K_K6Save   Save return address
         ST    R1,@K_K6Save+4  and R1
         SLR   R15,R15         Clear work register
         IC    R15,DConv_Date_MM  Get month
         LTR   R15,R15         Is it 0?
         BZ    K6040           Yes, invalid
         CH    R15,=H'12'      No, is it too big?
         BH    K6040           Yes, invalid
         MVC   @K_Months,K_Months Move Days-per-month table
         BAS   R14,K7000       Check leap year
         LTR   R15,R15         Is it?
         BZ    K6010           No, skip
         LH    R15,@K_Months+11 Yes, get February days
         AH    R15,=H'1'       Bump it
         STH   R15,@K_Months+11 and save it
K6010    DS    0H
         SLR   R15,R15         Clear work register
         IC    R15,DConv_Date_MM Get month number
         MH    R15,=HL2'11'    Calculate offset
         LA    R15,@K_Months-11(R15) Point to days in our month
         SLR   R0,R0           Clear work register
         IC    R0,DConv_Date_DD Get day-of-month
         LTR   R0,R0           Is it 0?
         BZ    K6040           Yes, error
         CH    R0,0(R15)       Are Days too big?
         BH    K6040           Yes, error
         LA    R14,@K_Months   A(Our Days-per-month table)
K6020    DS    0H
         CR    R14,R15         Are we done?
         BNL   K6030           Yes, skip
         AH    R0,0(R14)       No, bump total days
         LA    R14,11(0,R14)   point to next month
         B     K6020           and try again
K6030    DS    0H
         SLR   R15,R15         Clear return code
         B     K6050           and exit
K6040    DS    0H
         LA    R15,4           Error in date
         SLR   R0,R0           Clear day-of-year
         B     K6050
K6050    DS    0H
         L     R14,@K_K6Save   Restore return address
         L     R1,@K_K6Save+4  Restore R1
         BSM   0,R14           and return


K7000    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Purpose   : This routine will determine if the year passed as a    *
*              parm is a leap year                                    *
*                                                                     *
*  Input     : DConv_Date_YYYY                                        *
*                                                                     *
*  Output    : R15 = 0: Non-Leap Year                                 *
*                    4: Leap Year                                     *
*                                                                     *
*---------------------------------------------------------------------*

         STM   R0,R1,@K_K7Save    Save our registers
         LH    R1,DConv_Date_YYYY Get the Year

*---------------------------------------------------------------------*
*                                                                     *
*   If it is not divisible by 4, it is not a leap year                *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE
         SLR   R0,R0           Clear for divide
         D     R0,=FL4'4'      Divide by 4
         LTR   R0,R0           Any remainder?
         BNZ   K7020           Yes, not a leap year

*---------------------------------------------------------------------*
*                                                                     *
*   If it also not divisible by 100, it is a leap year                *
*                                                                     *
*---------------------------------------------------------------------*

         LH    R1,DConv_Date_YYYY Get year
         SLR   R0,R0           Clear for divide
         D     R0,=FL4'100'    Divide by 100
         LTR   R0,R0           Any remainder?
         BNZ   K7030           Yes, a leap year

*---------------------------------------------------------------------*
*                                                                     *
*   If it also divisible by 400, it is a leap year                    *
*                                                                     *
*---------------------------------------------------------------------*

         LH    R1,DConv_Date_YYYY Get year
         SLR   R0,R0           Clear for divide
         D     R0,=FL4'400'    Divide by 400
         LTR   R0,R0           Any remainder?
         BNZ   K7020           Yes, not a leap year
         B     K7030           Must be a leap year
K7020    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Not a leap year, clear the return code                            *
*                                                                     *
*---------------------------------------------------------------------*

         SLR   R15,R15         Clear return code
         B     K7090           and exit
K7030    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   A leap year, set the return code                                  *
*                                                                     *
*---------------------------------------------------------------------*

         LA    R15,4           Set return code
         B     K7090           and exit
K7090    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   Exit (R15 contains the return code)                               *
*                                                                     *
*---------------------------------------------------------------------*

         LM    R0,R1,@K_K7Save Restore our registers
         BSM   0,R14           and return
K8010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*   DConv fields contain invalid data, exit with error                *
*                                                                     *
*---------------------------------------------------------------------*

         LA    R15,4           Set return code
         B     K9010           and exit

K9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R2,R15                   Save return code
         LA    R1,@K_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

         LR    R15,R2                   Restore return code

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return


K_Months DC    HL2'31',C'January  '
         DC    HL2'28',C'February '
         DC    HL2'31',C'March    '
         DC    HL2'30',C'April    '
         DC    HL2'31',C'May      '
         DC    HL2'30',C'June     '
         DC    HL2'31',C'July     '
         DC    HL2'31',C'August   '
         DC    HL2'30',C'September'
         DC    HL2'31',C'October  '
         DC    HL2'30',C'November '
         DC    HL2'31',C'December '
K_Months_Length EQU  *-K_Months

K_Days   DC    C'Monday   '
         DC    C'Tuesday  '
         DC    C'Wednesday'
         DC    C'Thursday '
         DC    C'Friday   '
         DC    C'Saturday '
         DC    C'Sunday   '

         LTORG

@K_Dynam        DSECT                 Dynamic area for K
@K_Save         DS    18F              O/S Style save area
@K_DateConv_Area_Ptr DS AL4            A(Callers DateConv_Area)
@K_DBLWD        DS    D                Work area
@K_DateConv_Area DS   CL(DConv_Area_Length)     Our area
@K_K6Save       DS    2AL4             K6000 save area
@K_K7Save       DS    2AL4             K7000 save area
@K_Months DS   CL(K_Months_Length) Month table
                DS    0D               Alignment
@K_DynLen       EQU   *-@K_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING

         TITLE 'L0000 - List Selection Ctiteria'
L0010    DS    0H

         PUSH  USING

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : L0010                                                  *
*                                                                     *
*  Abstract  : List selection criteria                                *
*                                                                     *
*  Inputs    : R1 ----> ODT entry                                     *
*  Outputs   : R15 = 0                                                *
*                                                                     *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              2002/02/07 SDDA030 V1.4                                *
*                                 New. This used to be part of B0010, *
*                                 but we ran out of base register.    *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING L0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@L_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@L_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @L_Dynam,R13             Assign a base
         L     R15,@L_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         LR    R10,R1                   Point to the ODT Entry
         USING ODT_Entry,R10            and tell the assembler

* - - - - - - - - - - -  D A T E / T I M E     - - - - - - - - - - -*

         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)
         CP    ODTE_StartDate,=P'0'   ANY START DATE SPECIFIED?
         BNE   L0020                  YES, SKIP
         CP    ODTE_EndDate,=P'999999' NO, ANY END DATE?
         BNE   L0020                  YES, SKIP
         MVC   10(L'L_Sum3,R2),L_Sum3 MOVE NO DATE/TIME MESSAGE
         B     L0070                  AND SKIP
L0020    DS    0H
         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria
         MVC   10(L'L_Sum2A,R2),L_Sum2A MOVE FIRST PART OF MESSAGE
         CP    ODTE_StartDate,=P'0'  ANY START DATE?
         BNE   L0030                 YES, SKIP
         MVC   10+L'L_Sum2A(20,R2),=C' the start of SYSUT1'
         LA    R2,10+L'L_Sum2A+20(0,R2) BUMP POINTER
         B     L0040                 AND SKIP
L0030    DS    0H
         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area
         ZAP   @L_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),ODTE_StartDate move in Date
         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               ODTE_StartTime                 Time too
         OI    @L_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_*
               Input_Time           Indicate SMF Time
         LA    R15,@L_DateConv_Area     Point to Date Conversion area
         ST    R15,@L_Parms          Save as 1st parm
         LA    R15,10+L'L_Sum2A+1(0,R2) A(Output area)
         ST    R15,@L_Parms+4        Save as 2nd parm
         LA    R15,@L_Return_Ptr     A(Return area)
         ST    R15,@L_Parms+8        Save it
         LA    R1,@L_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time
L0040    DS    0H
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT
         MVC   10+L'L_Sum2A-L'L_Sum2B(L'L_Sum2B,R2),L_Sum2B Next part
         LA    R2,10+L'L_Sum2A+1(0,R2) Point past it
         CP    ODTE_EndDate,=P'999999' ANY END DATE?
         BNE   L0050                 YES, SKIP
         MVC   0(19,R2),=C' the end of SYSUT1'
         LA    R2,19(0,R2)           BUMP POINTER
         B     L0060                 AND SKIP
L0050    DS    0H
         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area
         ZAP   @L_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),ODTE_EndDate move in Date
         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               ODTE_EndTime                 Time too
         OI    @L_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@L_DateConv_Area     Point to Date Conversion area
         ST    R15,@L_Parms          Save as 1st parm
         LA    R15,0(0,R2)           A(Output area)
         ST    R15,@L_Parms+4        Save as 2nd parm
         LA    R15,@L_Return_Ptr     A(Return area)
         ST    R15,@L_Parms+8        Save it
         LA    R1,@L_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time
         L     R2,@L_Return_Ptr      Point past
         LA    R2,1(0,R2)              Date/Time
L0060    DS    0H
         MVC   0(L'L_Sum2C,R2),L_Sum2C MOVE LAST PART OF MESSAGE
L0070    DS    0H
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD

* - - - - - - - - - -   P E R I O D            - - - - - - - - - - -*

         ICM   R15,B'1111',ODTE_PeriodStart PERIOD START TIME
         BNZ   L0080                  OK, PRINT PERIOD MESSAGE
         L     R15,ODTE_PeriodEnd     NO, GET PERIOD END
         C     R15,=F'8640000'        IS THERE ONE?
         BE    L0090                  NO, SKIP
L0080    DS    0H
         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria
         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT
         MVC   10(20,R2),=C'Only records between'
         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area
         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               ODTE_PeriodStart             Time too
         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R1,@L_DateConv_Area   Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get Time
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_hh-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  30(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   30(R2),C' '           Clear spurious char
         OI    32(R2),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_mm-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  33(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   33(R2),C':'           Clear spurious char
         OI    35(R2),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_ss-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  36(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   36(R2),C':'           Clear spurious char
         OI    38(R2),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_tt-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  39(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   39(R2),C'.'           Clear spurious char
         OI    41(R2),X'F0'          Make it readable

         MVC   42(4,R2),=C' and'

         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area
         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               ODTE_PeriodEnd               Time too
         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R1,@L_DateConv_Area   Point to Date Conversion area
         L     R15,=AL4(K0010)       A(Format routine)
         BASR  R14,R15               Go get Time
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_hh-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  46(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   46(R2),C' '           Clear spurious char
         OI    48(R2),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_mm-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  49(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   49(R2),C':'           Clear spurious char
         OI    51(R2),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_ss-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  52(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   52(R2),C':'           Clear spurious char
         OI    54(R2),X'F0'          Make it readable
         SLR   R0,R0                 Clear work register
         IC    R0,@L_DateConv_Area+DConv_Time_tt-DateConv_Area
         CVD   R0,@L_DBLWD           Pack it
         UNPK  55(3,R2),@L_DBLWD+6(2) Unpack it
         MVI   55(R2),C'.'           Clear spurious char
         OI    57(R2),X'F0'          Make it readable
         MVC   58(18,R2),=C' will be eligible.'

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
L0090    DS    0H

* - - - - - - - - - - W E E K E N D S  - - - - - - - - - - - - - - -*

         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend No Sat or Sun?
         BNO   L0100                  No, OK
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD
         MVC   10(77,R2),=C'SMF Data generated on Saturday and Sunday w+
               ill not be eligible for selection.'

         L     R15,=AL4(G0010)       A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
L0100    DS    0H

* - - - - - - - - - - R E C O R D   T Y P E S  - - - - - - - - - - -*

         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD
         ICM   R3,B'1111',ODTE_RTT_Ptr  A(RECORD TYPE TABLE)
         BNZ   L0110                  OK, SKIP
         MVC   10(L'L_Sum5,R2),L_Sum5 NO, MOVE NO RECORD TYPE MSG
         B     L0180                  AND SKIP
L0110    DS    0H
         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria
         MVC   10(L'L_Sum4A,R2),L_Sum4A Move 1st part of message
         LH    R4,RTT_Entry_Count-RecType_Tbl(R3) Get nbr entries
         CH    R4,=H'1'               More than 1?
         BNH   L0120                  No, skip
         MVI   10+L'L_Sum4A(R2),C's'  Yes, make msg plural
         LA    R2,1(0,R2)             and bump SYSPRINT pointer
L0120    DS    0H
         LA    R2,10+L'L_Sum4A+1(0,R2) A(NEXT AVAILABLE BYTE)
         LR    R15,R2                 Calculate offset
         S     R15,@_SYSPRINT_Rec_Ptr   into SYSPRINT record
         STH   R15,@L_SYSPRINT_Rec_Offset  and save it
         LA    R3,RTT_Entry-RecType_Tbl(R3) A(FIRST ENTRY IN TABLE)
L0130    DS    0H
         LA    R15,9(0,R2)            A(last byte we might write)
         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write
         CH    R15,@_SYSPRINT_Rec_Len Too long?
         BL    L0140                  No, OK
         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)
         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte
L0140    DS    0H
         SLR   R0,R0                  CLEAR WORK REGISTER
         IC    R0,RTTE_RecType-RTT_Entry(R3) GET RECORD TYPE
         CVD   R0,@L_DBLWD            PACK IT
         MVC   @L_DBLWD(4),=X'40202120' MOVE MASK
         LA    R1,@L_DBLWD+3          A(LAST POSSIBLE POSITION)
         EDMK  @L_DBLWD(4),@L_DBLWD+6 EDIT IT
         LA    R15,@L_DBLWD+3         A(LAST POSSIBLE POSITION)
         SR    R15,R1                 R3 = EXEC LEN OF EDITED RECTYPE
         EX    R15,L_MVC              MOVE IT
         LA    R2,1(R15,R2)           A(NEXT BYTE)
         TM    RTTE_SubType_Present-RTT_Entry(R3),L'RTTE_SubType_Presen+
               t                      Any subtype?
         BNO   L0150                  No, skip subtype stuff
         LH    R0,RTTE_SubType-RTT_Entry(R3) YES, GET SUBTYPE
         CVD   R0,@L_DBLWD            PACK IT
         MVC   @L_DBLWD(4),=X'40202120' MOVE MASK
         LA    R1,@L_DBLWD+3          A(LAST POSSIBLE POSITION)
         EDMK  @L_DBLWD(4),@L_DBLWD+6 EDIT IT
         LA    R15,@L_DBLWD+3         A(LAST POSSIBLE POSITION)
         SR    R15,R1                 R15 = EXEC LEN OF SUBTYPE
         MVI   0(R2),C'('             OPENING PAREN
         LA    R2,1(0,R2)             POINT PAST IT
         EX    R15,L_MVC              MOVE SUBTYPE
         LA    R2,1(R15,R2)           POINT TO NEXT BYTE
         MVI   0(R2),C')'             CLOSE PAREN
         LA    R2,1(0,R2)             AND BUMP POINTER
L0150    DS    0H
         MVI   0(R2),C','             MOVE SEPARATOR
         LA    R2,2(0,R2)             POINT PAST IT
         LA    R3,RTTE_Length(0,R3)   A(NEXT ENTRY
         BCT   R4,L0130               and do it

         SH    R2,=H'2'               BACK UP TO LAST COMMA
         MVI   0(R2),C' '             CLEAR IT
         LA    R15,1+L'L_Sum4B+2+L'L_Sum4C(0,R2) A(last byte)
         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write
         CH    R15,@_SYSPRINT_Rec_Len Too long?
         BL    L0160                  No, OK
         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)
         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte
L0160    DS    0H
         MVC   1(L'L_Sum4B,R2),L_Sum4B MOVE NEXT PART OF MSG
         LA    R2,1+L'L_Sum4B(0,R2)   POINT PAST IT
         L     R15,ODTE_RTT_Ptr       A(RECORD TYPE TABLE)
         TM    RTT_Entry_Exclude-RecType_TBL(R15),L'RTT_Entry_Exclude
         BZ    L0170                  INCLUDEing, skip
         MVC   0(2,R2),=C'in'         EXCLUDEing, IN of INELIGIBLE
         LA    R2,2(0,R2)             AND POINT PAST IT
L0170    DS    0H
         MVC   0(L'L_Sum4C,R2),L_Sum4C MOVE LAST PART OF MESSAGE
L0180    DS    0H

         L     R15,=AL4(G0010)       A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD

* - - - - - - - - - -      J O B N A M E S     - - - - - - - - - - -*

         L     R2,@_SYSPRINT_Rec_Ptr  A(NEW PRINT RECORD)
         ICM   R3,B'1111',ODTE_JNT_Ptr A(JOBNAME TABLE)
         BNZ   L0190                  OK, SKIP
         MVC   10(L'L_Sum6,R2),L_Sum6 NO, SAY SO
         B     L0270                  AND SKIP
L0190    DS    0H
         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria
         MVC   10(L'L_Sum7A,R2),L_Sum7A MOVE FIRST PART OF MESSAGE
         LH    R4,JNT_Entry_Count-JobName_Tbl(R3) GET NBR JOBNAMES
         CH    R4,=H'1'               MORE THAN 1?
         BNH   L0200                  NO, SKIP
         MVI   10+L'L_Sum7A(R2),C's'  YES, MAKE IT PLURAL
         LA    R2,1(0,R2)             BUMP IT
L0200    DS    0H
         LA    R2,10+L'L_Sum7A+1(0,R2) A(NEXT AVAILABLE BYTE)
         LR    R15,R2                 Calculate offset
         S     R15,@_SYSPRINT_Rec_Ptr   into SYSPRINT record
         STH   R15,@L_SYSPRINT_Rec_Offset  and save it
         LA    R3,JNT_Entry-JobName_Tbl(R3) A(FIRST JOBNAME
L0210    DS    0H
         LA    R15,L'JNTE_JobName+2(0,R2) A(Last possible byte)
         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write
         CH    R15,@_SYSPRINT_Rec_Len Too long?
         BL    L0220                  No, OK
         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)
         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte
L0220    DS    0H
         MVC   0(L'JNTE_JobName,R2),JNTE_JobName-JNT_Entry(R3)
         CLI   JNTE_JobName_Len-JNT_Entry(R3),L'JNTE_JobName-1 PREFIX?
         BE    L0230                  NO, SKIP
         SLR   R0,R0                  YES, CLEAR WORK REG
         IC    R0,JNTE_JobName_Len-JNT_Entry(R3) GET PREFIX EXEC LEN
         AR    R2,R0                  BUMP OUTPUT POINTER
         MVI   1(R2),C'*'             ADD IN THE ASTERISK
         LA    R2,1(0,R2)             INCREMENT POINTER
         B     L0250                  AND SKIP
L0230    DS    0H
         LA    R2,L'JNTE_JobName-1(0,R2) BUMP POINTER
L0240    DS    0H
         CLI   0(R2),C' '             END OF JOBNAME?
         BNE   L0250                  YES, SKIP
         BCT   R2,L0240               NO, KEEP CHECKING
L0250    DS    0H
         MVI   1(R2),C','             ADD A COMMA
         LA    R2,3(0,R2)             A(NEXT JOBNAME AREA)
         LA    R3,JNTE_Length(0,R3)   A(NEXT JOBNAME)
         BCT   R4,L0210               AND KEEP GOING

         SH    R2,=H'2'               BACK UP OVER LAST COMMA
         LA    R15,L'L_Sum7B(0,R2)    A(Last possible byte)
         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write
         CH    R15,@_SYSPRINT_Rec_Len Too long?
         BL    L0260                  No, OK
         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)
         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte
L0260    DS    0H
         MVC   0(L'L_Sum7B,R2),L_Sum7B MOVE REST OF MESSAGE
L0270    DS    0H

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GET A SYSPRINT RECORD

* - - - - - - - - - -          D A T A         - - - - - - - - - - -*

         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)
         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE)
         BNZ   L0280                  OK, SKIP
         MVC   10(L'L_Sum8,R2),L_Sum8 NO, SAY SO
         B     L0300                  AND SKIP
L0280    DS    0H
         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria
         MVC   10(L'L_Sum9A,R2),L_Sum9A MOVE FIRST PART OF MESSAGE
         LA    R2,L'L_Sum9A+10(0,R2) POINT PAST IT
         LH    R14,DT_Entry_Count-Data_Tbl(R15) GET NBR ENTRIES
         LA    R15,DT_Entry-Data_Tbl(R15) A(FIRST ENTRY)
L0290    DS    0H
         LR    R0,R14                 SAVE BCT COUNT
         SLR   R14,R14                CLEAR REG
         IC    R14,DTE_Length-DT_Entry(R15) GET EXEC LEN OF DATA
         LA    R1,DTE_Data-DT_Entry(0,R15) A(DATA)
         EX    R14,L_MVC              MOVE IT
         LA    R2,1(R14,R2)           A(NEXT BYTE)
         MVC   0(L'L_Sum9B,R2),L_Sum9B MOVE NEXT PART OF MSG
         LA    R2,L'L_Sum9B(0,R2)     POINT PAST IT
         LH    R14,DTE_Offset-DT_Entry(R15) GET OFFSET
         CVD   R14,@L_DBLWD           PACK IT
         MVC   @L_Offset,=X'4020206B202120' MOVE MASK
         LA    R1,@L_Offset+6         A(LAST POSSIBLE POSITION)
         EDMK  @L_Offset,@L_DBLWD+5   EDIT IT
         LA    R14,@L_Offset+6        A(LAST POSSIBLE POSITION)
         SR    R14,R1                 R14 = EXEC LEN
         EX    R14,L_MVC              MOVE IT
         SLR   R14,R14                CLEAR REGISTER
         IC    R14,DTE_Length-DT_Entry(R15) GET EXEC LEN OF DATA
         LA    R1,1+DTE_Data-DT_Entry(R14,R15) A(NEXT ENTRY)
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT IT
         L     R2,@_SYSPRINT_Rec_Ptr  A(PRINT RECORD)
         MVC   28(2,R2),=C'or'        MOVE LITERAL
         LA    R2,31(0,R2)            POINT TO FREE POSITION
         LR    R14,R0                 RESTORE BCT REGISTER
         LR    R15,R1                 RESTORE A(TABLE ENTRY)
         BCT   R14,L0290              KEEP GOING
         L     R2,@_SYSPRINT_Rec_Ptr  A(OUTPUT RECORD)
         MVC   15(L'L_Sum9C,R2),L_Sum9C MOVE LAST PART
L0300    DS    0H

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                YES, GET A NEW SYSPRINT REC

* - - - - - - - - - -   S T O P A F T          - - - - - - - - - - -*

         ICM   R15,B'1111',ODTE_StopAft GET STOPAFT COUNT
         BZ    L0310                  None, SKIP
         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT
         MVC   10(58,R2),=C'A maximum of XX,XXX records will be selecte*
               d to this file.'
         MVC   22(7,R2),=X'4020206B202120' MOVE MASK
         L     R15,ODTE_StopAft       GET STOPAFT
         CVD   R15,@L_DBLWD           PACK IT
         ED    22(7,R2),@L_DBLWD+5    AND EDIT IT

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO PRINT IT
L0310    DS    0H

         DROP  R10                    Free ODT Entry addressability

         B     L9010                  and exit

L9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,@L_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         SLR   R15,R15                  Clear return code
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

L_MVC MVC      0(0,R2),0(R1)          EXECUTED INSTRUCTION


L_Sum2A  DC    C'Records between'
L_Sum2B  DC    C' and'
L_Sum2C  DC    C' will be eligible'

L_Sum3   DC    C'No Date-Time criteria; all records will be eligible'

L_Sum4A  DC    C'Record Type'
L_Sum4B  DC    C'will be '
L_Sum4C  DC    C'eligible'

L_Sum5   DC    C'No Record Type criteria; all records will be eligible'

L_Sum6   DC    C'No Jobname criteria; all records will be eligible'

L_Sum7A  DC    C'Records for Jobname'
L_Sum7B  DC    C' will be eligible'

L_Sum8   DC    C'No Data criteria; all records will be eligible'

L_Sum9A DC     C'Records must contain '
L_Sum9B DC     C' in position '
L_Sum9C DC     C' to be eligible'


         LTORG

@L_Dynam        DSECT                 Dynamic area for L
@L_Save         DS    18F              O/S Style save area
@L_DBLWD        DS    D                Work area
@L_Parms        DS    3AL4             Parm area
@L_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)
@L_SYSPRINT_Rec_Offset DS  HL2         Offset into SYSPRINT record
@L_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area
@L_Offset       DS    CL7              DATA= offset
                DS    0D               Alignment
@L_DynLen       EQU   *-@L_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING

         TITLE 'W0000 - Return JFCB pointer'
W0010    DS    0H

         PUSH  USING

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : W0010                                                  *
*                                                                     *
*  Abstract  : Return A(JFCB) as returned by SWAREQ                   *
*                                                                     *
*  Inputs    : R1 : A(DCB)                                            *
*                                                                     *
*  Outputs   : R1 : A(JFCB) or 0                                      *
*              R0 : A(TIOT Entry) or 0                                *
*              R15: 0:OK, 4: No JFCB                                  *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              2002/02/07 SDDA030 V1.4                                *
*                                 New                                 *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING W0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@W_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@W_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @W_Dynam,R13             Assign a base
         L     R15,@W_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    Find our TIOT entry ...                                        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,CVTPTR(0,0)          A(CVT)
         L     R15,CVTTCBP-CVT(R15)     A(Current TCB pointer)
         L     R15,0(0,R15)             A(Current TCB)
         L     R15,TCBTIO-TCB(R15)      A(TIOT)

*-------------------------------------------------------------------*
*                                                                   *
*    If the DCB is OPEN, we can use DCBTIOT to find our entry ...   *
*                                                                   *
*-------------------------------------------------------------------*

         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN DCB OPen?
         BNO   W0020                    No, skip

         AH    R15,DCBTIOT-IHADCB(R1)   Offset in TIOT
         B     W0040                    and skip

W0020    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    The DCB is not OPEN, chain through the TIOT looking for our    *
*   DDName                                                          *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R15,TIOENTRY-TIOT1(R15)  A(1st entry in TIOT)
W0030    DS    0H
         CLI   TIOELNGH-TIOENTRY(R15),0 Last Entry?
         BE    W8010                    Yes, DDName not found
         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R15),DCBDDNAM-IHADCB(R1)
         BE    W0040                    Found our entry, skip

         SLR   R0,R0                    Clear work reg
         IC    R0,TIOELNGH-TIOENTRY(R15) Get entry length
         AR    R15,R0                   Point to next entry
         B     W0030                    and check it out
W0040    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    ... and then get the JFCB address from the SVA                 *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R15,@W_TIOT_Ptr          Save A(TIOT Entry)

         XC    @W_SWAEPAX,@W_SWAEPAX    Clear SWAEPA
         MVC   @W_SWAEPAX+SWVA-ZB505(L'SWVA),TIOEJFCB-TIOENTRY(R15)
         LA    R15,@W_SWAEPAX           A(EPA)
         ST    R15,@W_EPA_Ptr           Save the address

         MVC   @W_SWAREQ,W_SWAREQ       Move L-Form of macro
         SWAREQ FCODE=RL,               Read Locate                    +
               EPA=@W_EPA_Ptr,           using the EPA at this addr    +
               UNAUTH=YES,               not being authorized          +
               MF=(E,@W_SWAREQ)          keep ourselves re-entrant

         L     R1,@W_SWAEPAX+SWBLKPTR-ZB505 Get A(JFCB)
         L     R0,@W_TIOT_Ptr           A(TIOT Entry)
         SLR   R15,R15                  Clear return code
         B     W9010                    and exit

W8010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    TIOT entry not found                                           *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R1,R1                    Clear A(JFCB)
         SLR   R0,R0                    Clear A(TIOT)
         LA    R15,4                    Set return code
         B     W9010                    and exit


W9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R2,R15                   Save return code
         LR    R3,R0                    Save A(TIOT)
         LR    R4,R1                    Save A(JFCB)
         LA    R1,@W_Dynam              A(Local storage)

         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

         LR    R15,R2                   Restore return code
         LR    R0,R3                    Restore A(TIOT)
         LR    R1,R4                    Restore A(JFCB)

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         LM    R2,R12,28(R13)           Restore other registers
         BSM   0,R14                    and return



W_SWAREQ SWAREQ MF=L                    Read Locate
W_SWAREQ_Length EQU *-W_SWAREQ          Length of SWAREQ Macro

         LTORG

@W_Dynam        DSECT                 Dynamic area for W
@W_Save         DS    18F              O/S Style save area
@W_EPA_Ptr      DS    AL4              A(EPA for SWAREQ)
@W_TIOT_Ptr     DS    AL4              A(TIOT Entry for DDName)
@W_SWAREQ       DS    CL(W_SWAREQ_Length)
                DS    0F
@W_SWAEPAX      DS    CL(L'SWAEPAX)

                DS    0D               Alignment
@W_DynLen       EQU   *-@W_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING

         TITLE 'X0000 - Exit Invocation Routine'
X0010    DS    0H

         PUSH  USING

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : X0010                                                  *
*                                                                     *
*  Abstract  : Invoke user exits                                      *
*                                                                     *
*  Inputs    : R0 : 0:Inexit, 1:OutExit                               *
*              R1 : A(SMF Record)                                     *
*              R10: A(ODT Entry)                                      *
*                                                                     *
*  Outputs   : R1 : A(SMF Record as returned by exit)                 *
*              R15: As received from the user exit                    *
*                                                                     *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              2002/02/07 SDDA030 V1.4                                *
*                                 New                                 *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING X0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@X_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@X_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @X_Dynam,R13             Assign a base
         L     R15,@X_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         USING ODT_Entry,R10            Assign ODTE base

*-------------------------------------------------------------------*
*                                                                   *
*    If the SYSPRINT User Exit Interface (Y0010) has not been       *
*   copied to 24-bit storage, do it now ...                         *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',@_SYSPRINT_Y0010_Ptr A(Interface routine)
         BNZ   X0020                    Already moved, OK

         STORAGE OBTAIN,                Go get our storage             +
               LENGTH=Y_Code_End-Y0010,  this long                     +
               LOC=BELOW                 below-the-line

         ST    R1,@_SYSPRINT_Y0010_Ptr  Save the address
         LR    R0,R1                    Point to it
         LA    R1,Y_Code_End-Y0010      Length of code
         L     R14,=AL4(Y0010)          Point to start of code
         LR    R15,R1                   Same length
         MVCL  R0,R14                   Move code to 24-bit storage

         L     R15,@_SYSPRINT_Y0010_Ptr A(Moved code)
         ST    R12,Y_@_Dynam_Ptr-Y0010(R15) Update A(@_Dynam)

*-------------------------------------------------------------------*
*                                                                   *
*    ... and IDENTIFY it as SMFSLCTP, in case the exit is written   *
*   in a HLL.                                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R1,@_SYSPRINT_Y0010_Ptr Point to our routine
         IDENTIFY EP=SMFSLCTP,         and let MVS know                +
               ENTRY=(1)                about it

X0020    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Update the pointer to the ODT in the Y0010 copy                *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@_SYSPRINT_Y0010_Ptr A(Moved code)
         ST    R10,Y_@_ODT_Entry_Ptr-Y0010(R15) Update A(ODT Entry)

*-------------------------------------------------------------------*
*                                                                   *
*    Get some 24-bit storage, and build our parm list               *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@X_24_DynLen,         this long                     +
               STACK=@_24Bit_Stack_Ptr   using this stack

         ST    R1,@X_ParmList_Ptr       Save it
         USING @X_24_Dynam,R1           Assign a base

         L     R15,@X_Dynam+4           Get A(HSA)
         L     R0,24(0,R15)             A(SMF record) Original R1
         ST    R0,@X_24_Exit_Parmlist   Save A(SMF Record)

         ICM   R0,B'1111',20(R15)       Get Original R0
         BNZ   X0030                    OutExit, skip

         L     R0,ODTE_InExit_Data      Yes, A(Word for the user)
         ST    R0,@X_24_Exit_Word       Save it
         LA    R0,@X_24_Exit_Word       Point to it
         ST    R0,@X_24_Exit_Parmlist+4 Save the pointer
         L     R0,ODTE_InExit_Parm_Ptr  A(Parm for InExit)
         ST    R0,@X_24_Exit_Parmlist+8 Save it
         L     R15,ODTE_InExit_Ptr      A(InExit EP)
         B     X0040                    Skip

X0030    DS    0H

         L     R0,ODTE_OutExit_Data     Yes, A(Word for the user)
         ST    R0,@X_24_Exit_Word       Save it
         LA    R0,@X_24_Exit_Word       Point to it
         ST    R0,@X_24_Exit_Parmlist+4 Save it
         L     R0,ODTE_OutExit_Parm_Ptr A(Parm for OutExit)
         ST    R0,@X_24_Exit_Parmlist+8 Save it
         L     R15,ODTE_OutExit_Ptr     A(OutExit EP)
         B     X0040                    Skip

X0040    DS    0H

         L     R0,@_Input_Count         Input count
         ST    R0,@X_24_Input_Count     Save it
         LA    R0,@X_24_Input_Count     Point to it
         ST    R0,@X_24_Exit_Parmlist+12 Save it

         L     R0,ODTE_Selected         A(Selected count)
         ST    R0,@X_24_Selected        Save it
         LA    R0,@X_24_Selected        Point to it
         ST    R0,@X_24_Exit_Parmlist+16 Save it
         MVC   @X_24_DDName,ODTE_DDName Move DDName
         LA    R0,@X_24_DDName          A(DDName)
         ST    R0,@X_24_Exit_Parmlist+20 Save it
         L     R0,@_SYSPRINT_Y0010_Ptr  A(SYSPRINT routine)
         ST    R0,@X_24_Exit_Parmlist+24 Save it

         OI    @X_24_Exit_Parmlist+24,X'80' Flag as last parm

         LA    R14,@X_24_Save           Point to 24-bit savearea
         ST    R14,8(0,R13)             Chain
         ST    R13,4(0,R14)              saveareas
         LR    R13,R14                  Point to 24-bit savearea

         LA    R1,@X_24_Exit_Parmlist   Point to the parmlist
         BASR  R14,R15                  Go do the exit

         LR    R2,R15                   Save return code

         L     R13,4(0,R13)             Restore A(Our 31-bit savearea)

         L     R1,@X_ParmList_Ptr       Restore A(24-bit storage)
         L     R15,@X_Dynam+4           Get A(HSA)
         ICM   R0,B'1111',20(R15)       InExit?
         BNZ   X0050                    No, skip
         MVC   ODTE_InExit_Data,@X_24_Exit_Word Yes, save user stuff
         B     X0060                    and skip
X0050    DS    0H
         MVC   ODTE_OutExit_Data,@X_24_Exit_Word Yes, save user stuff
X0060    DS    0H

         L     R1,@X_ParmList_Ptr       A(Parmlist)
         L     R3,@X_24_Exit_Parmlist   Get A(SMF record)
         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_24Bit_Stack_Ptr   on this stack

         DROP  R1                       Free 24-bit storage base

         LR    R15,R2                   Restore return code
         B     X9010                    and exit

X9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R2,R15                   Save return code
         LA    R1,@X_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

         LR    R15,R2                   Restore return code

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         LR    R15,R2                   Set return code
         L     R0,20(0,R13)             Restore R0
         LR    R1,R3                    A(SMF record returned by exit)
         LM    R2,R12,28(R13)           Restore other registers
         BSM   0,R14                    and return



         LTORG

@X_Dynam        DSECT                 Dynamic area for X
@X_Save         DS    18F              O/S Style save area
@X_ParmList_Ptr DS    AL4              A(Parmlist)
                DS    0D               Alignment
@X_DynLen       EQU   *-@X_Dynam      Length of storage required

@X_24_Dynam     DSECT                 24-bit Dynamic area for X
@X_24_Save      DS    18F              O/S Style save area
@X_24_Exit_Parmlist DS 7FL4            Parmlist
@X_24_Exit_Word DS    FL4              A Word for the user
@X_24_Input_Count DS  FL4              Input count
@X_24_Selected  DS    FL4              Selected count
@X_24_DDName    DS    CL8              DDName
                DS    0D               Alignment
@X_24_DynLen    EQU   *-@X_24_Dynam   Length of 24-bit storage required



SMFSLCT  RSECT

         DROP  R10
         DROP  R11,R13
         POP   USING
         TITLE 'Y0000: SYSPRINT routine for User Exits'

         PUSH  USING

Y0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : Y0010                                                  *
*                                                                     *
*  Abstract  : SYSPRINT routine for User Exits:                       *
*               Load @_Dynam base                                     *
*               Move user data to SYSPRINT record                     *
*               Invoke G0010                                          *
*                                                                     *
*                                                                     *
*  Inputs    : R1 --> A(Data to be printed)                           *
*                     Fullword containing length of data              *
*  Outputs   : R15 = 0                                                *
*                                                                     *
*  Notes     : This routine is moved to 24-bit storage, and the       *
*              address of @_Dynam inserted into the copy.             *
*              Before each invocation of the exit, the address of the *
*              active ODT is also stored in Y_ODT_Entry_Ptr.          *
*                                                                     *
*                                                                     *
*  History:                                                           *
*              2002/02/07 SDDA030 V1.4                                *
*                                 New                                 *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*

         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING Y0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Make sure we are in AMODE(31)                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R14,Y0020                A(Dummy label)
         ICM   R14,B'1000',=XL1'80'     in 31-bit mode
         BSM   0,R14                    Gen into 31-bit mode
Y0020    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         L     R12,Y_@_Dynam_Ptr        A(@_Dynam)

         STACK PUSH,                    Get Stack area                 +
               LEN=@Y_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@Y_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @Y_Dynam,R13             Assign a base
         L     R15,@Y_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

*-------------------------------------------------------------------*
*                                                                   *
*    If SYSPRINT is OPEN ...                                        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@_SYSPRINT_DCB_Ptr A(SYSPRINT DCB)
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Is it open?
         BZ    Y9010                  No, skip printing

*-------------------------------------------------------------------*
*                                                                   *
*    ... load the address of the ODT we are using ...               *
*                                                                   *
*-------------------------------------------------------------------*

         L     R10,Y_@_ODT_Entry_Ptr  A(ODT Entry)

*-------------------------------------------------------------------*
*                                                                   *
*    ... move the data to the SYSPRINT record ...                   *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,@_SYSPRINT_Rec_Ptr Get A(SYSPRINT record)
         LH    R15,@_SYSPRINT_Rec_Len Get its length
         LM    R0,R1,0(R1)            Get ptr, length of user data
         ICM   R1,B'1000',=CL1' '     Pad character of blank
         MVCL  R14,R0                 Move user data

*-------------------------------------------------------------------*
*                                                                   *
*    ... and print it                                               *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,=AL4(G0010)        A(Print routine)
         BASR  R14,R15                Go do it

Y9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LA    R1,@Y_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller                                       *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         SLR   R15,R15                  Clear return code
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

Y_@_Dynam_Ptr     DC AL4(0)           A(@_Dynam)
Y_@_ODT_Entry_Ptr DC AL4(0)           A(ODT Entry for User exit)

         LTORG

Y_Code_End  EQU   *                   End of code to be moved

@Y_Dynam        DSECT                 Dynamic area for Y
@Y_Save         DS    18F              O/S Style save area
                DS    0D               Alignment
@Y_DynLen       EQU   *-@Y_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
SMFSLCT  RSECT

         TITLE 'Z0000: Termination'

         PUSH  USING

Z0010    DS    0H

*---------------------------------------------------------------------*
*                                                                     *
*  Routine   : Z0010                                                  *
*                                                                     *
*  Abstract  : Termination routine:                                   *
*               Print counters                                        *
*               Close DCBs                                            *
*               Free Storage areas                                    *
*                                                                     *
*                                                                     *
*  Inputs    : N/A                                                    *
*  Outputs   : R15 = 0, at least 1 record selected to an output file  *
*                    4, no records selected to any output file.       *
*                                                                     *
*  Notes     :                                                        *
*                                                                     *
*  History:                                                           *
*              1999/04/24 SDDA030 V1.1                                *
*                                 Used LIFO Stack for our dynamic     *
*                                 areas.                              *
*              ____/__/__ _______                                     *
*                                                                     *
*---------------------------------------------------------------------*



         USING *,R15
         SAVE  (14,12),T
         LR    R11,R15                  Load permanent base reg
         DROP  R15                      Free up temp base
         USING Z0010,R11                Assign permanent base

*-------------------------------------------------------------------*
*                                                                   *
*    Get an area on the stack for our local storage                 *
*                                                                   *
*-------------------------------------------------------------------*

         STACK PUSH,                    Get Stack area                 +
               LEN=@Z_DynLen,            this long                     +
               STACK=@_31Bit_Stack_Ptr   using this stack

         LR    R2,R1                    Save its address
         LR    R0,R1                    A(Our storage)
         LA    R1,@Z_DynLen              Its length
         SLR   R14,R14                  Clear source address
         SLR   R15,R15                   and length
         MVCL  R0,R14                   Clear our storage
         LR    R1,R2                    Restore A(Our storage)

*-------------------------------------------------------------------*
*                                                                   *
*    Chain our save areas, and restore the important registers      *
*   that we have destroyed                                          *
*                                                                   *
*-------------------------------------------------------------------*

         ST    R13,4(0,R1)              Chain
         ST    R1,8(0,R13)               saveareas
         LR    R13,R1                   Load dynam base
         USING @Z_Dynam,R13             Assign a base
         L     R15,@Z_Dynam+4           Get A(HSA)
         LM    R0,R3,20(R15)            Restore callers registers

         NI    @Z_Select_OK,X'FF'-L'@Z_Select_OK Nothing selected

*-------------------------------------------------------------------*
*                                                                   *
*    PRINT THE RECORD COUNTERS, IF POSSIBLE.                        *
*                                                                   *
*-------------------------------------------------------------------*

         L     R15,@_SYSPRINT_DCB_Ptr A(Sysprint DCB)
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS SYPRINT OPEN?
         BZ    Z0060                  NO, SKIP PRINTING
         LA    R15,99                 GET HIGH LINE COUNT
         STH   R15,@_Line_Count       SAVE IT
         L     R10,@_ODT_Ptr          POINT TO OUTPUT ENV TABLE
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST

         USING ODT_Entry,R10          Tell the assembler

         OI    ODTE_Print_NO,L'ODTE_Print_NO SUPPRESS HEADINGS
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GO GET A NEW PAGE
         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)
         ICM   R15,B'1111',@_Input_Count Nbr input records read
         BZ    Z0050                  None, skip
         CP    @_Dump_Start_Date,=P'999999' DID WE GET A TYPE 2?
         BE    Z0040                  NO, SKIP
         MVC   20(27,R2),=C'First Dump Header (Type 2):'

         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area
         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),@_Dump_Start_Date    Date
         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               @_Dump_Start_Time              Time too
         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@Z_DateConv_Area     Point to Date Conversion area
         ST    R15,@Z_Parms          Save as 1st parm
         LA    R15,51(0,R2)          A(Output area)
         ST    R15,@Z_Parms+4        Save as 2nd parm
         LA    R15,@Z_Return_Ptr     A(Return area)
         ST    R15,@Z_Parms+8        Save as 2nd parm
         LA    R1,@Z_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT THE RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)
         MVC   20(27,R2),=C'Last Dump Trailer (Type 3):'
         CP    @_Dump_End_Date,=P'0'  DID WE GET A TYPE 3?
         BNE   Z0020                  YES, SKIP
         MVI   51(R2),C'?'            NO, SAY SO
         B     Z0030                  AND SKIP
Z0020    DS    0H

         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area
         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),@_Dump_End_Date    Date
         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               @_Dump_End_Time              Time too
         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@Z_DateConv_Area     Point to Date Conversion area
         ST    R15,@Z_Parms          Save as 1st parm
         LA    R15,51(0,R2)          A(Output area)
         ST    R15,@Z_Parms+4        Save as 2nd parm
         LA    R15,@Z_Return_Ptr     A(Return area)
         ST    R15,@Z_Parms+8        Save as 2nd parm
         LA    R1,@Z_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

Z0030    DS    0H
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT THE RECORD
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT THE RECORD
         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)
Z0040    DS    0H
         MVC   20(26,R2),=C'Date/Time of first record:'

         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area
         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),@_First_Rec_Date   Date
         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               @_First_Rec_Time             Time too
         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@Z_DateConv_Area     Point to Date Conversion area
         ST    R15,@Z_Parms          Save as 1st parm
         LA    R15,51(0,R2)          A(Output area)
         ST    R15,@Z_Parms+4        Save as 2nd parm
         LA    R15,@Z_Return_Ptr     A(Return area)
         ST    R15,@Z_Parms+8        Save as 2nd parm
         LA    R1,@Z_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT IT
         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)
         MVC   20(25,R2),=C'Date/Time of last record:'

         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area
         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+
               v_Date_SMFDate),@_Input_Rec_Date   Date
         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+
               @_Input_Rec_Time             Time too
         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+
               nv_Input_SMFDate     Indicate SMF Date
         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+
               Input_Time           Indicate SMF Time
         LA    R15,@Z_DateConv_Area     Point to Date Conversion area
         ST    R15,@Z_Parms          Save as 1st parm
         LA    R15,51(0,R2)          A(Output area)
         ST    R15,@Z_Parms+4        Save as 2nd parm
         LA    R15,@Z_Return_Ptr     A(Output area)
         ST    R15,@Z_Parms+8        Save as 3nd parm
         LA    R1,@Z_Parms           A(Parm pointers)
         L     R15,=AL4(F0010)       A(Format routine)
         BASR  R14,R15               Go convert date and time

         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT IT
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                A COUPLE OF
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                  BLANK LINES
Z0050    DS    0H
         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)
         MVC   20(23,R1),=C'Number of records read:'
         MVC   50(12,R1),=X'402020206B2020206B202120'
         L     R15,@_Input_Count      GET INPUT COUNTER
         CVD   R15,@Z_DBLWD           PACK IT
         ED    50(12,R1),@Z_DBLWD+3   AND EDIT IT
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                PRINT THE INPUT COUNT
         TM    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error Segment errors?
         BZ    Z0060                  No, skip
         L     R1,@_SYSPRINT_Rec_Ptr  Yes, A(SYSPRINT record)
         MVC   17(39,R1),=C'** Segment errors discarded from SYSUT1'
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                Print warning message
Z0060    DS    0H
         L     R10,@_ODT_Ptr          POINT TO OUTPUT ENV TABLE
         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST
         CH    R9,=H'1'               MORE THAN 1 ENTRY?
         BNH   Z0070                  No, continue
         ST    R10,@Z_Default_ODTE_Ptr Yes, save its address
         B     Z0160                  and skip it until last
Z0070    DS    0H
         ICM   R15,B'1111',@_SYSPRINT_DCB_Ptr A(Sysprint DCB)
         BZ    Z0090                  None, skip
         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Yes, is it open?
         BNO   Z0090                  NO, SKIP
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                GET A NEW SYSPRINT RECORD
         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO IT
         MVC   20(27,R1),=C'Number of          records:'
         MVC   30(8,R1),ODTE_DDName   MOVE OUTPUT DDNAME
         MVC   50(12,R1),=X'402020206B2020206B202120'
         ICM   R15,B'1111',ODTE_Selected Get selected counter
         BZ    Z0080                  None, skip
         OI    @Z_Select_OK,L'@Z_Select_OK Yes, set our flag
Z0080    DS    0H
         CVD   R15,@Z_DBLWD           PACK IT
         ED    50(12,R1),@Z_DBLWD+3   AND EDIT IT
         TM    ODTE_Trunc,L'ODTE_Trunc  ANY RECORDS TRUNCATED?
         BZ    Z0090                  NO, SKIP
         L     R15,=AL4(G0010)        A(SYSPRINT routine)
         BASR  R14,R15                YES, SKIP A LINE
         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT)
         MVC   10(73,R1),=C'*****  WARNING - At least 1 record truncate*
               d on XXXXXXXX - WARNING  *****'
         MVC   58(8,R1),ODTE_DDName   MOVE OUTPUT DDNAME
Z0090    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    LAST CALL TO INPUT EXIT, AND DELETE, IF PRESENT                *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_InExit_Ptr A(INPUT EXIT
         BZ    Z0100                 None, SKIP
         SLR   R1,R1                 Yes, clear A(SMF record)
         SLR   R0,R0                 Flag as an InExit
         L     R15,=AL4(X0010)       A(Exit interface)
         BASR  R14,R15               Go do it
         L     R15,@Z_Default_ODTE_Ptr A(Default entry)
         CR    R10,R15               Are we doing default?
         BE    Z0095                 Yes, skip
         CLC   ODTE_InExit,ODTE_InExit-ODT_Entry(R15) No, default exit?
         BE    Z0100                 YES, DON'T DELETE IT
Z0095    DS    0H
         LA    R0,ODTE_InExit        A(EXIT NAME)
         DELETE EPLOC=(0)            AND DELETE IT

         ICM   R1,B'1111',ODTE_InExit_Parm_Ptr Get A(Parm)
         BZ    Z0100                  None, skip
         LH    R0,0(0,R1)             Yes, get its length
         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field
         STORAGE RELEASE,             Free the storage                 +
               ADDR=(1),               starting here                   +
               LENGTH=(0)              for this long

         SLR   R15,R15                Clear work register
         ST    R15,ODTE_InExit_Parm_Ptr and clear parm pointer
Z0100    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    LAST CALL TO OUTPUT EXIT, AND DELETE, IF PRESENT               *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R15,B'1111',ODTE_OutExit_Ptr  A(OUTPUT EXIT)
         BZ    Z0110                 None, SKIP
         SLR   R1,R1                 Yes, clear A(SMF record)
         LA    R0,1                  Flag as an OutExit
         L     R15,=AL4(X0010)       A(Exit interface)
         BASR  R14,R15               Go do it
         L     R15,@Z_Default_ODTE_Ptr A(Default entry)
         CR    R10,R15               Are we doing default?
         BE    Z0105                 Yes, skip
         CLC   ODTE_OutExit,ODTE_OutExit-ODT_Entry(R15) No, default?
         BE    Z0110                 YES, DON'T DELETE IT
Z0105    DS    0H
         LA    R0,ODTE_OutExit       A(EXIT NAME)
         DELETE EPLOC=(0)            AND DELETE IT

         ICM   R1,B'1111',ODTE_OutExit_Parm_Ptr Get A(Parm)
         BZ    Z0110                  None, skip
         LH    R0,0(0,R1)             Yes, get its length
         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field
         STORAGE RELEASE,             Free the storage                 +
               ADDR=(1),               starting here                   +
               LENGTH=(0)              for this long

         SLR   R15,R15                Clear work register
         ST    R15,ODTE_OutExit_Parm_Ptr and clear parm pointer
Z0110    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    CLOSE THE OUTPUT DCB, IF OPEN.                                 *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R2,B'1111',ODTE_DCB_Ptr A(Output DCB)
         BZ    Z0130                  None, skip
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Yes, is it open?
         BZ    Z0120                  NO, BETTER NOT CLOSE IT
         MVC   @Z_CLOSE,Z_CLOSE           YES, MOVE CLOSE PARMS
         CLOSE ((2)),MODE=31,MF=(E,@Z_CLOSE)    AND CLOSE IT
Z0120    DS    0H
         LA    R0,B_SYSUT2_DCB_Length Length of DCB
         LR    R1,R2                  A(DCB storage)
         STORAGE RELEASE,             Get storage                      +
               LENGTH=(0),             for the DCB                     +
               ADDR=(1)                which is here
         SLR   R15,R15                Clear work register
         ST    R15,ODTE_DCB_Ptr       No more DCB
Z0130    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    FREE UP RECORD TYPE TABLE, IF IT EXISTS.                       *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R1,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)
         BZ    Z0140                  None, BETTER NOT FREE IT
         L     R15,@Z_Default_ODTE_Ptr A(Default entry)
         CR    R10,R15               Are we doing default?
         BE    Z0135                 Yes, skip
         CLC   ODTE_RTT_Ptr,ODTE_RTT_Ptr-ODT_Entry(R15) No, default?
         BE    Z0140                 YES, DON'T DELETE IT
Z0135    DS    0H
         L     R0,0(0,R1)             NO, GET SUBPOOL AND LENGTH
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z0140    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    FREE UP JOBNAME TABLE, IF IT EXISTS.                           *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R1,B'1111',ODTE_JNT_Ptr A(JOBN TABLE)
         BZ    Z0150                  None, BETTER NOT FREE IT
         L     R15,@Z_Default_ODTE_Ptr A(Default entry)
         CR    R10,R15               Are we doing default?
         BE    Z0145                 Yes, skip
         CLC   ODTE_JNT_Ptr,ODTE_JNT_Ptr-ODT_Entry(R15) No, default?
         BE    Z0150                 YES, DON'T DELETE IT
Z0145    DS    0H
         L     R0,0(0,R1)             YES, GET SUBPOOL AND LENGTH
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z0150    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    FREE UP DATA TABLE, IF PRESENT.                                *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R1,B'1111',ODTE_DT_Ptr A(DATA TABLE
         BZ    Z0160                 None SKIP
         L     R15,@Z_Default_ODTE_Ptr A(Default entry)
         CR    R10,R15               Are we doing default?
         BE    Z0155                 Yes, skip
         CLC   ODTE_DT_Ptr,ODTE_DT_Ptr-ODT_Entry(R15) No, default?
         BE    Z0160                 YES, DON'T DELETE IT
Z0155    DS    0H
         L     R0,0(0,R1)            YES, GET SUBPOOL AND LENGTH
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
Z0160    DS    0H
         AL    R10,=AL4(ODTE_Length)  A(NEXT ENTRY)
         BCT   R9,Z0070               GO DO IT TOO
         L     R10,@_ODT_Ptr          A(ENVIRONMENT TABLE)
         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES
         CH    R9,=H'1'               MORE THAN 1 ENTRY?
         BNH   Z0190                  NO, SKIP
         LA    R10,ODT_Entry-OutDesc_Tbl(R10) YES, POINT TO DEFAULT
         ICM   R15,B'0010',ODTE_InExit_Ptr GET A(INEXIT)
         BZ    Z0170                  None, SKIP
         LA    R0,ODTE_InExit         YES, POINT TO IT'S NAME
         DELETE EPLOC=(0)             AND DELETE IT
         XC    ODTE_InExit_Ptr,ODTE_InExit_Ptr CLEAR EXIT ADDRESS

         ICM   R1,B'1111',ODTE_InExit_Parm_Ptr Get A(Parm)
         BZ    Z0170                  None, skip
         LH    R0,0(0,R1)             Yes, get its length
         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field
         STORAGE RELEASE,             Free the storage                 +
               ADDR=(1),               starting here                   +
               LENGTH=(0)              for this long

         SLR   R15,R15                Clear work register
         ST    R15,ODTE_InExit_Parm_Ptr and clear parm pointer
Z0170    DS    0H
         ICM   R15,B'1111',ODTE_OutExit_Ptr GET A(OUTEXIT)
         BZ    Z0180                  None, SKIP
         LA    R0,ODTE_OutExit        YES, POINT TO IT'S NAME
         DELETE EPLOC=(0)             AND DELETE IT
         XC    ODTE_OutExit_Ptr,ODTE_OutExit_Ptr CLEAR EXIT ADDRESS

         ICM   R1,B'1111',ODTE_OutExit_Parm_Ptr Get A(Parm)
         BZ    Z0180                  None, skip
         LH    R0,0(0,R1)             Yes, get its length
         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field
         STORAGE RELEASE,             Free the storage                 +
               ADDR=(1),               starting here                   +
               LENGTH=(0)              for this long

         SLR   R15,R15                Clear work register
         ST    R15,ODTE_OutExit_Parm_Ptr and clear parm pointer
Z0180    DS    0H
         L     R15,@_ODT_Ptr          A(OUR TABLE)
         LA    R9,1                   DO A SINGLE ENTRY
         STH   R9,ODT_Entry_Count-OutDesc_Tbl(R15) PRETEND ONLY 1 ENTRY
         B     Z0090                  AND FREE UP DEFAULT TABLES
Z0190    DS    0H

         DROP  R10

*-------------------------------------------------------------------*
*                                                                   *
*    Print the counters by record type                              *
*                                                                   *
*-------------------------------------------------------------------*


*-------------------------------------------------------------------*
*                                                                   *
*    CLOSE SYSPRINT, IF REQUIRED.                                   *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R2,B'1111',@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)
         BZ    Z0270                  None, skip
         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN SYSPRINT OPEN?
         BZ    Z0260                  NO, BETTER NOT CLOSE IT
         MVC   @Z_CLOSE,Z_CLOSE       YES, MOVE CLOSE PARMS
         CLOSE ((2)),MODE=31,MF=(E,@Z_CLOSE)    AND CLOSE IT
Z0260    DS    0H
         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)
         STORAGE RELEASE,               Free the storage               +
               ADDR=(R1),                starting here                 +
               LENGTH=G_SYSPRINT_DCB_Length this long

         SLR   R15,R15                  Clear work register
         ST    R15,@_SYSPRINT_DCB_Ptr   No more DCB

         ICM   R1,B'1111',@_SYSPRINT_Y0010_Ptr
         BZ    Z0270
         STORAGE RELEASE,               Free the storage               +
               ADDR=(R1),                starting here                 +
               LENGTH=Y_Code_End-Y0010   this long

         SLR   R15,R15                  Clear work register
         ST    R15,@_SYSPRINT_Y0010_Ptr No more print interface

         DELETE EP=SMFSLCTP             Un-IDENTIFY it

Z0270    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free the Output Descriptor Table                               *
*                                                                   *
*-------------------------------------------------------------------*

         ICM   R1,B'1111',@_ODT_Ptr   A(ENVIRONMENT TABLE)
         BZ    Z0280                  None, dont free it
         L     R0,ODT_Subp_Len-OutDesc_Tbl(R1) GET SUBPOOL, LENGTH
         STORAGE RELEASE,               Free our storage               +
               ADDR=(1),                 starting here                 +
               LENGTH=(0)                for this long
         SLR   R15,R15                Clear work register
         ST    R15,@_ODT_Ptr          No more ODT
Z0280    DS    0H
         B     Z9010                  and exit
Z9010    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Set the return code, if anything has been selected or not      *
*                                                                   *
*-------------------------------------------------------------------*

         SLR   R15,R15                  Assume all is OK
         TM    @Z_Select_OK,L'@Z_Select_OK Anything selected?
         BO    Z9020                    Yes, OK
         LA    R15,4                    No, set return code
Z9020    DS    0H

*-------------------------------------------------------------------*
*                                                                   *
*    Free up our local storage ...                                  *
*                                                                   *
*-------------------------------------------------------------------*

         LR    R3,R15                   Save return code
         LA    R1,@Z_Dynam              A(Local storage)
         L     R13,4(0,R13)             Rescue A(HSA)

         STACK POP,                     Free the stack area            +
               ADDR=(R1),                starting here                 +
               STACK=@_31Bit_Stack_Ptr   on this stack
         LR    R15,R3                   Restore return code

*-------------------------------------------------------------------*
*                                                                   *
*    ... and return to caller (return code in R15)                  *
*                                                                   *
*-------------------------------------------------------------------*

         L     R14,12(0,R13)            Restore return address
         LM    R0,R12,20(R13)           Restore other registers
         BSM   0,R14                    and return

Z_CLOSE    CLOSE (0),MODE=31,MF=L
Z_CLOSE_Length EQU   *-Z_CLOSE
         LTORG

@Z_Dynam        DSECT                 Dynamic area for Z
@Z_Save         DS    18F              O/S Style save area
@Z_DBLWD        DS    D                Work area
@Z_Default_ODTE_Ptr DS AL4             A(Defalt ODT Entry)
@Z_Parms        DS    3AL4             Parms for F0010
@Z_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)
@Z_InExit_Parm  DS    2AL4             Parms for InExit
@Z_OutExit_Parm DS    2AL4             Parm list for OutExit
                DS    X                Flag Byte
@Z_Select_OK    EQU   *-1,X'80'         1... .... At least 1 rec sel
@Z_Macros       DS    0F               Macro area
@Z_Close        DS    CL(Z_CLOSE_Length)  Close macro
                ORG   @Z_Macros
@Z_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area
                ORG
                DS    0D               Alignment
@Z_DynLen       EQU   *-@Z_Dynam      Length of storage required

SMFSLCT  RSECT

         DROP  R11,R13
         POP   USING
         END
