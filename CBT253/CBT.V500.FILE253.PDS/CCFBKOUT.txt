/*  REXX EXEC : ( CCFBKOUT ).
    FUNCTION  :  FACILITATES THE LIB/CCF BACKOUT OF A CHANGE REQUEST
                 WORKORDER (CR/WO) IN SELECTIVE MEMBER MODE OR GROUP
                 MODE FOR THE THE ENTIRE CR/WO.
                 THE CR/WO "MUST' HAVE ALREADY BEEN PROMOTED INTO THE
                 PRODUCTION LIBRARIAN MASTERS AND LOAD LIBRARIES.
    AUTHOR    :  DAN BOWEN, TECH SERVICES.
                                                                      */

TRACE O
/*     */
HOUSE_KEEPING:
ADDRESS TSO
X = MSG("OFF")
C = 0
J = 0
P = 0
R = 0
S = 0
I = 0
H = 0
DB = 0
DC = 0
DR = 0
EC = 0
EJ = 0
EP = 0
ER = 0
ES = 0
EI = 0
LB = 0
LC = 0
AST = '********'
MODCNT = 0
TSOID = SYSVAR(SYSUID)
CDAY = DATE(W)
CDATE = DATE(U)
MVS = 'SYSA'
CLASS = 'P'
COMPMSG = 'DB2 BACKOUT COMPILE'
ACCTCDE = '5302010530000000'
CICSLANG = 'BMSMAP CICSCOB CICSCOB2 DMSMAP'
MEMBER_TYPES = 'COPYBOOK JCL PROC RAMIS SOURCE SYSIN'
SYSMAST = 'SYS1.SYSTEM.CONTROL.MASTER'
HISTMAST = 'SYS1.HISTSRCE.MASTER'
MASTER = 'SYS1.PRODSRCE.MASTER'
PARMLIB = 'SYSS.TECH.COMMON.PARMLIB'
CNTLLIB = 'SYSS.QA.CCF.BACKOUT.CNTLLIB'
QACCF = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'
"FREE FILE(CCFDD)"
"FREE FILE(PARMDD)"
WDSN = SYSDSN("'"CNTLLIB"'")
IF WDSN = 'DATASET NOT FOUND' THEN SIGNAL STAGING_PDS_ERROR
FROMLIB.1 = 'SYS1.PRODCOPY.MASTER'
FROMLIB.2 = 'SYS1.PRODJCL.MASTER'
FROMLIB.3 = 'SYS1.PRODPROC.MASTER'
FROMLIB.4 = 'SYS1.PRODRAMI.MASTER'
FROMLIB.5 = 'SYS1.PRODSRCE.MASTER'
FROMLIB.6 = 'SYS1.PRODSYSI.MASTER'
DESTLIB.1 = 'SYS1.BACKCOPY.MASTER'
DESTLIB.2 = 'SYS1.BACKJCL.MASTER'
DESTLIB.3 = 'SYS1.BACKPROC.MASTER'
DESTLIB.4 = 'SYS1.BACKRAMI.MASTER'
DESTLIB.5 = 'SYS1.BACKSRCE.MASTER'
DESTLIB.6 = 'SYS1.BACKSYSI.MASTER'
CALL CHECK_USER_AUTHORIZATION
IF AUTHSW = 'NO' THEN SIGNAL AUTHORIZATION_ERROR
/*
        M A I N   R O U T I N E   S E C T I O N      */
/*     */
DISPLAY_RUN_OPTION_PANEL:
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"DISPLAY PANEL(CCFBKPNL)"
SRC = RC
IF SRC = 0 & BKOPT = 1 THEN SIGNAL BACKOUT_ALL
IF SRC = 0 & BKOPT = 2 THEN SIGNAL BACKOUT_SELECTIVE
IF SRC = 8 & WORKORDR = '' THEN EXIT 0
ADDRESS TSO
"FREE F(CCFDD)"
SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNL ). ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
BACKOUT_ALL:
SAY
SAY 'B A C K O U T   J O B S T R E A M   B U I L D   I N   P R O G R E S S'
SAY
SAY 'PLEASE WAIT ...'
SAY
CALL CHECK_CRWO_SYSMAST_MEMBER
CALL GET_CRWO_MODULE_NAMES
CALL BUILD_LIBRCOPY_JOBSTREAM
CALL BUILD_GPO_ARCHIVE_RESTORE_JOBSTREAM
CALL BUILD_GPO_DELETE_MODULE_JOBSTREAM
IF SCNT = 0 THEN DO
   E = 1
   JCL.1 = "//"
   CALL WRITE_LBACKOUT_JCL2
   CALL SUBMIT_BACKOUT_JOB
   EXIT 0
END
B = 0
C = 0
DB2SW = 'NO'
DO S = 1 TO SCNT
   CALL BUILD_IEBCOPY_LOAD_MODULE_NAMES
   IF DYLSW = 'YES' THEN CALL BUILD_DYL280_LOAD_MODULE_NAMES
END
CALL BUILD_IEBCOPY_LOADLIB_JOBSTREAM
CALL BUILD_DELETE_LOADLIB_JOBSTREAM
CALL SUBMIT_BACKOUT_JOB
IF DB2SW = 'YES' THEN DO
   CALL CHECK_DB2_PARMS_MEMBER
   SAY
   SAY '===>  DB2 MEMBER(S) BACKOUT IN PROGRESS ...'
   SAY '+++ COMPILE/BIND JOB(S) WILL BE SUBMITTED AS SOURCE MEMBER NAME. +++'
   IF DB > 0 THEN DO D = 1 TO DB
      MEMBER = DB2BAT.D
      SKELJCL = 'CCFDB2P1'
      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL
   END
   IF DC > 0 THEN DO D = 1 TO DC
      MEMBER = DB2CICS.D
      SKELJCL = 'CCFDB2P2'
      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL
   END
END
SAY
SAY 'B A C K O U T   J O B S T R E A M   B U I L D   C O M P L E T E'
SAY
EXIT 0
/*     */
BACKOUT_SELECTIVE:
CALL CHECK_CRWO_SYSMAST_MEMBER
CALL GET_CRWO_MODULE_NAMES
CALL INIT_SCREEN_MEMBER_PARM
MODCNT = 0
DO Y = 1 TO 6
   MEMTYPE = WORD(MEMBER_TYPES,Y)
   LABEL = 'DISPLAY_MEMBER_SELECTION_PANEL'Y
   INTERPRET CALL LABEL
END
IF MODCNT = 0 THEN DO
   SAY
   SAY '*** NO MEMBER(S) SELECTED FOR BACKOUT. ***'
   SAY '*** LIB/CCF BACKOUT TASK TERMINATED FOR 'WORKORDR' - RC = (024). ***'
   EXIT 024
END
CALL BUILD_LIBRCOPY_JOBSTREAM
CALL BUILD_GPO_ARCHIVE_RESTORE_JOBSTREAM
CALL BUILD_GPO_DELETE_MODULE_JOBSTREAM
IF SCNT = 0 THEN DO
   E = 1
   JCL.1 = "//"
   CALL WRITE_LBACKOUT_JCL2
   CALL SUBMIT_BACKOUT_JOB
   EXIT 0
END
B = 0
C = 0
DB2SW = 'NO'
DO S = 1 TO SCNT
   CALL BUILD_IEBCOPY_LOAD_MODULE_NAMES
   IF DYLSW = 'YES' THEN CALL BUILD_DYL280_LOAD_MODULE_NAMES
END
CALL BUILD_IEBCOPY_LOADLIB_JOBSTREAM
CALL BUILD_DELETE_LOADLIB_JOBSTREAM
CALL SUBMIT_BACKOUT_JOB
IF DB2SW = 'YES' THEN DO
   CALL CHECK_DB2_PARMS_MEMBER
   SAY
   SAY '===>  DB2 MEMBER(S) BACKOUT IN PROGRESS ...'
   SAY '+++ COMPILE/BIND JOB(S) WILL BE SUBMITTED AS SOURCE MEMBER NAME. +++'
   IF DB > 0 THEN DO D = 1 TO DB
      MEMBER = DB2BAT.D
      SKELJCL = 'CCFDB2P1'
      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL
   END
   IF DC > 0 THEN DO D = 1 TO DC
      MEMBER = DB2CICS.D
      SKELJCL = 'CCFDB2P2'
      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL
   END
END
SAY
SAY 'B A C K O U T   J O B S T R E A M   B U I L D   C O M P L E T E'
SAY
EXIT 0
/*
        S U B R O U T I N E S   S E C T I O N       */
/*     */
CHECK_CRWO_SYSMAST_MEMBER:
ADDRESS TSO
WOLEN = LENGTH(WORKORDR)
IF WOLEN ¬= 8 THEN SIGNAL INVALID_WORKORDR_NUMBER
WOKEY = SUBSTR(WORKORDR,1,2)
IF WOKEY ¬= 'WO' THEN SIGNAL INVALID_WORKORDR_NUMBER
WONUM = SUBSTR(WORKORDR,3,6)
WOTYP = DATATYPE(WONUM)
IF WOTYP ¬= 'NUM' THEN SIGNAL INVALID_WORKORDR_NUMBER
WO = WORKORDR
ZRMEMB = 'ZR'||WONUM
DO F = 1 TO 2
   IF F = 1 THEN MEMBER = ZRMEMB
   IF F = 2 THEN MEMBER = WORKORDR
   LIBDSN = "'"SYSMAST"("MEMBER")'"
   LIBDD = LIBALLOC(LIBDSN)
   IF LIBDD = "ERROR" THEN SIGNAL SYSMAST_ALLOC_ERROR
   MASTDD = LIBALLOC("'"SYSMAST"'")
   IF MASTDD = "ERROR" THEN SIGNAL SYSMAST_ALLOC_ERROR
   MASTMEM = XLIBEMEM(MASTDD,MEMBER)
   IF MASTMEM = ""  THEN DO
      "EXECIO 0 DISKR" LIBDD "(FINIS"
      "EXECIO 0 DISKR" MASTDD "(FINIS"
      "FREE F("LIBDD")"
      "FREE F("MASTDD")"
      ITERATE
   END
   LEAVE
END
"EXECIO 0 DISKR" MASTDD "(FINIS"
"FREE F("MASTDD")"
IF MASTMEM = ""  THEN SIGNAL CRWO_MODULE_NOT_FOUND
RETURN
/*     */
GET_CRWO_MODULE_NAMES:
ADDRESS TSO
"EXECIO * DISKR" LIBDD "(STEM WODATA. FINIS"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL SYSMAST_MODULE_READ_ERROR
DO L = 1 TO 6
   DO D = 1 TO WODATA.0
      PRODKEY = POS('TO: PROD',WODATA.D)
      IF PRODKEY ¬= 0 THEN DO
         MODNAME = WORD(WODATA.D,1)
         EXCLMOD = 'XXXXXXXX'
         CRWO = WORD(WODATA.D,3)
         IF CRWO ¬= WORKORDR THEN ITERATE
      END
      FROMMAST = POS('FROM MASTER:',WODATA.D)
      IF FROMMAST ¬= 0 THEN DO
         EMRGLIB = POS('EMRG',WODATA.D)
         IF EMRGLIB ¬= 0 THEN DO
            LIBRMAST = WORD(WODATA.D,3)
            CALL INVALID_BACKOUT_LIBRARY
            LABEL = 'BUILD_MODULE_EXCLUDE_LIST'L
            INTERPRET CALL LABEL
            ITERATE
         END
      END
      TOMAST = POS('TO   MASTER:',WODATA.D)
      IF TOMAST ¬= 0 THEN DO
         MASTDSN = WORD(WODATA.D,3)
         IF MASTDSN = FROMLIB.L THEN DO
            LABEL = 'BUILD_MODULE_LIST'L
            LABELSW = 'YES'
         END
      END
      VERSION = POS('VERS=',WODATA.D)
      IF VERSION ¬= 0 THEN DO
         DELETESW = 'NO'
         NEWVERS = POS('VERS= *NEW*',WODATA.D)
         IF NEWVERS ¬= 0 THEN DELETESW = 'YES'
         IF LABELSW = 'YES' THEN DO
            INTERPRET CALL LABEL
            LABELSW = 'NO'
         END
      END
   END
END
EMRGCNT = H
RETURN
/*     */
INVALID_BACKOUT_LIBRARY:
EXCLMOD = MODNAME
SAY
SAY '*** INVALID BACKOUT LIBRARY: ('LIBRMAST'). ***'
SAY '+++ MODULE: ('MODNAME') WILL NOT BE INCLUDED IN BACKOUT. +++'
SAY '+++ MODULES LAST TURNED OVER FROM AN EMERGENCY ID ARE EXCLUDED. +++'
SAY '+++ PLEASE NOTE AND TAKE APPROPRIATE ACTION, IF ANY. +++'
SAY '===> TO CONTINUE, HIT ENTER ...'
PULL OK
RETURN
/*     */
BUILD_MODULE_LIST1:
IF MODNAME = EXCLMOD THEN RETURN
C = C + 1
MODCNT = MODCNT + 1
COPYMEM.C = MODNAME
COPYSW.C = DELETESW
RETURN
/*     */
BUILD_MODULE_LIST2:
IF MODNAME = EXCLMOD THEN RETURN
J = J + 1
MODCNT = MODCNT + 1
JCLMEM.J = MODNAME
JCLSW.J = DELETESW
RETURN
/*     */
BUILD_MODULE_LIST3:
IF MODNAME = EXCLMOD THEN RETURN
P = P + 1
MODCNT = MODCNT + 1
PROCMEM.P = MODNAME
PROCSW.P = DELETESW
RETURN
/*     */
BUILD_MODULE_LIST4:
IF MODNAME = EXCLMOD THEN RETURN
R = R + 1
MODCNT = MODCNT + 1
RAMIMEM.R = MODNAME
RAMISW.R = DELETESW
RETURN
/*     */
BUILD_MODULE_LIST5:
IF MODNAME = EXCLMOD THEN RETURN
S = S + 1
MODCNT = MODCNT + 1
SRCEMEM.S = MODNAME
SRCESW.S = DELETESW
RETURN
/*     */
BUILD_MODULE_LIST6:
IF MODNAME = EXCLMOD THEN RETURN
I = I + 1
MODCNT = MODCNT + 1
SYSIMEM.I = MODNAME
SYSISW.I = DELETESW
RETURN
/*     */
BUILD_MODULE_EXCLUDE_LIST1:
EC = EC + 1
ECOPY.EC = MODNAME
RETURN
/*     */
BUILD_MODULE_EXCLUDE_LIST2:
EJ = EJ + 1
EJCL.EJ = MODNAME
RETURN
/*     */
BUILD_MODULE_EXCLUDE_LIST3:
EP = EP + 1
EPROC.EP = MODNAME
RETURN
/*     */
BUILD_MODULE_EXCLUDE_LIST4:
ER = ER + 1
ERAMI.ER = MODNAME
RETURN
/*     */
BUILD_MODULE_EXCLUDE_LIST5:
ES = ES + 1
ESRCE.ES = MODNAME
RETURN
/*     */
BUILD_MODULE_EXCLUDE_LIST6:
EI = EI + 1
ESYSI.EI = MODNAME
RETURN
/*     */
BUILD_LIBRCOPY_JOBSTREAM:
ADDRESS TSO
IF MODCNT = 0 THEN SIGNAL BACKOUT_QUALIFY_ERROR
"ALLOC DA('"CNTLLIB"("WORKORDR")') F(CCFDD) SHR"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL STAGING_PDS_ALLOC_ERROR
MEM = WORKORDR
WO = WORKORDR
CCNT = C
JCNT = J
PCNT = P
RCNT = R
SCNT = S
ICNT = I
RCD.1 = "//"WO" JOB "ACCTCDE",'LIBCCF.BACKOUT.CRWO',NOTIFY="TSOID","
RCD.2 = "//     CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M"
W = 2
CALL WRITE_LBACKOUT_JCL1
RCD.2 = "//SYSPRINT DD SYSOUT=*"
RCD.3 = "//LIST     DD SYSOUT=*"
RCD.4 = "//INDEX    DD SYSOUT=*"
RCD.7 = "//OSJOB    DD DSN=&&CPYMEMB,UNIT=SYSDA,"
RCD.8 = "//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),"
RCD.9 = "//         SPACE=(CYL,(9,1)),DISP=(NEW,PASS)"
RCD.10 = "//SYSIN    DD *"
RCD.11 = "-OPT UTILITY"
JCL.1 = "-EMOD"
JCL.2 = "-END"
JCL.3 = "/*"
JCL.5 = "/*"
JCL.7 = "//SYSPRINT DD SYSOUT=*"
JCL.8 = "//SYSUDUMP DD SYSOUT=Y"
JCL.9 = "//SYSABEND DD SYSOUT=Y"
JCL.10 = "//LIST DD SYSOUT=*"
JCL.11 = "//INDEX DD SYSOUT=*"
JCL.12 = "//OSJOB DD DUMMY"
JCL.14 = "//SYSIN    DD DSN=&&CPYMEMB,DISP=(OLD,DELETE)"
JCL.15 = "/*"
JCL.17 = "/*"
DO L = 1 TO 6
   W = 11
   LABEL = 'GET_LIBRCOPY_MODNAME'||L
   INTERPRET CALL LABEL
   IF MODSW = 'NO' THEN ITERATE
   CPYSTEP1 = WORD('SELCOPY SELJCL SELPROC SELRAMI SELSRCE SELSYSI',L)
   ABEND1 = WORD('ABCOPY1 ABJCL1 ABPROC1 ABRAMI1 ABSRCE1 ABSYSI1',L)
   RCD.1 = "//"CPYSTEP1" EXEC PGM=LIBRCOPY"
   RCD.5 = "//MASTER   DD DSN="FROMLIB.L",DISP=SHR"
   RCD.6 = "//DESTMAST DD DSN="DESTLIB.L",DISP=SHR"
   CALL WRITE_LBACKOUT_JCL1
   E = 17
   JCL.4 = "//"ABEND1" EXEC PGM=ABENDWTO,COND=(0,GE,"CPYSTEP1")"
   CPYSTEP2 = WORD('CPYCOPY CPYJCL CPYPROC CPYRAMI CPYSRCE CPYSYSI',L)
   ABEND2 = WORD('ABCOPY2 ABJCL2 ABPROC2 ABRAMI2 ABSRCE2 ABSYSI2',L)
   JCL.6 = "//"CPYSTEP2" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'"
   JCL.13 = "//MASTER   DD DSN="DESTLIB.L",DISP=SHR"
   JCL.16 = "//"ABEND2" EXEC PGM=ABENDWTO,COND=(0,GE,"CPYSTEP2")"
   CALL WRITE_LBACKOUT_JCL2
END
RETURN
/*     */
GET_LIBRCOPY_MODNAME1:
MODSW = 'NO'
IF CCNT = 0 THEN RETURN
DO C = 1 TO CCNT
   EXCLSW = 'NO'
   IF EC  > 0 THEN DO H = 1 TO EC
      IF ECOPY.H = COPYMEM.C THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCD.W = '-COPY' COPYMEM.C
END
RETURN
/*     */
GET_LIBRCOPY_MODNAME2:
MODSW = 'NO'
IF JCNT = 0 THEN RETURN
DO J = 1 TO JCNT
   EXCLSW = 'NO'
   IF EJ > 0 THEN DO H = 1 TO EJ
      IF EJCL.H = JCLMEM.J THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCD.W = '-COPY' JCLMEM.J
END
RETURN
/*     */
GET_LIBRCOPY_MODNAME3:
MODSW = 'NO'
IF PCNT = 0 THEN RETURN
DO P = 1 TO PCNT
   EXCLSW = 'NO'
   IF EP > 0 THEN DO H = 1 TO EP
      IF EPROC.H = PROCMEM.P THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCD.W = '-COPY' PROCMEM.P
END
RETURN
/*     */
GET_LIBRCOPY_MODNAME4:
MODSW = 'NO'
IF RCNT = 0 THEN RETURN
DO R = 1 TO RCNT
   EXCLSW = 'NO'
   IF ER > 0 THEN DO H = 1 TO ER
      IF ERAMI.H = RAMIMEM.R THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCD.W = '-COPY' RAMIMEM.R
END
RETURN
/*     */
GET_LIBRCOPY_MODNAME5:
MODSW = 'NO'
IF SCNT = 0 THEN RETURN
DO S = 1 TO SCNT
   EXCLSW = 'NO'
   IF ES > 0 THEN DO H = 1 TO ES
      IF ESRCE.H = SRCEMEM.S THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCD.W = '-COPY' SRCEMEM.S
END
RETURN
/*     */
GET_LIBRCOPY_MODNAME6:
MODSW = 'NO'
IF ICNT = 0 THEN RETURN
DO I = 1 TO ICNT
   EXCLSW = 'NO'
   IF EI > 0 THEN DO H = 1 TO EI
      IF ESYSI.H = SYSIMEM.I THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCD.W = '-COPY' SYSIMEM.I
END
RETURN
/*     */
BUILD_GPO_ARCHIVE_RESTORE_JOBSTREAM:
RCD.2 = "//SYSPRINT DD SYSOUT=*"
RCD.3 = "//LIST     DD SYSOUT=*"
RCD.4 = "//INDEX    DD SYSOUT=*"
RCD.5 = "//SYSAF01  DD UNIT=SYSDA,SPACE=(TRK,(30,30))"
RCD.6 = "//SYSAF02  DD UNIT=SYSDA,SPACE=(TRK,(30,30))"
RCD.8 = "//OSJOB    DD DSN=&&ARCMEMB,UNIT=SYSDA,"
RCD.9 = "//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),"
RCD.10 = "//         SPACE=(CYL,(9,1)),DISP=(NEW,PASS)"
RCD.11 = "//SYSIN    DD *"
RCD.12 = "-OPT GPO"
JCL.1 = "-EMOD"
JCL.2 = "-END"
JCL.3 = "/*"
JCL.5 = "/*"
JCL.7 = "//SYSPRINT DD SYSOUT=*"
JCL.8 = "//SYSUDUMP DD SYSOUT=Y"
JCL.9 = "//SYSABEND DD SYSOUT=Y"
JCL.10 = "//LIST DD SYSOUT=*"
JCL.11 = "//INDEX DD SYSOUT=*"
JCL.12 = "//OSJOB DD DUMMY"
JCL.14 = "//SYSIN    DD DSN=&&ARCMEMB,DISP=(OLD,DELETE)"
JCL.15 = "/*"
JCL.17 = "/*"
DO L = 1 TO 6
   W = 12
   LABEL = 'GET_GPOARCH_MODNAME'||L
   INTERPRET CALL LABEL
   IF MODSW = 'NO' THEN ITERATE
   ARCSTEP1 = WORD('ARCCOPY ARCJCL ARCPROC ARCRAMI ARCSRCE ARCSYSI',L)
   ABEND3 = WORD('ABCOPY3 ABJCL3 ABPROC3 ABRAMI3 ABSRCE3 ABSYSI3',L)
   RCD.1 = "//"ARCSTEP1" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'"
   RCD.7 = "//MASTER   DD DSN="FROMLIB.L",DISP=SHR"
   W = W + 1
   RCD.W = "-HST" WO "TURNOVER BACKOUT BY:" TSOID "ON:" CDAY CDATE
   CALL WRITE_LBACKOUT_JCL1
   E = 17
   JCL.4 = "//"ABEND3" EXEC PGM=ABENDWTO,COND=(0,GE,"ARCSTEP1")"
   ARCSTEP2 = WORD('REPCOPY REPJCL REPPROC REPRAMI REPSRCE REPSYSI',L)
   ABEND4 = WORD('ABCOPY4 ABJCL4 ABPROC4 ABRAMI4 ABSRCE4 ABSYSI4',L)
   JCL.6 = "//"ARCSTEP2" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'"
   JCL.13 = "//MASTER   DD DSN="FROMLIB.L",DISP=SHR"
   JCL.16 = "//"ABEND4" EXEC PGM=ABENDWTO,COND=(0,GE,"ARCSTEP2")"
   CALL WRITE_LBACKOUT_JCL2
END
RETURN
/*     */
GET_GPOARCH_MODNAME1:
MODSW = 'NO'
IF CCNT = 0 THEN RETURN
RCDSW = 'NO'
DO C = 1 TO CCNT
   IF COPYSW.C = 'YES' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"COPYMEM.C"/"
      ITERATE
   END
   EXCLSW = 'NO'
   IF EC > 0 THEN DO H = 1 TO EC
      IF ECOPY.H = COPYMEM.C THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-SEL NAME=/"COPYMEM.C"/"
END
IF RCDSW = 'NO' THEN RETURN
RCD.W = RCD.W||",VERS,ARC=-1"
RETURN
/*     */
GET_GPOARCH_MODNAME2:
MODSW = 'NO'
IF JCNT = 0 THEN RETURN
RCDSW = 'NO'
DO J = 1 TO JCNT
   IF JCLSW.J = 'YES' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"JCLMEM.J"/"
      ITERATE
   END
   EXCLSW = 'NO'
   IF EJ > 0 THEN DO H = 1 TO EJ
      IF EJCL.H = JCLMEM.J THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-SEL NAME=/"JCLMEM.J"/"
END
IF RCDSW = 'NO' THEN RETURN
RCD.W = RCD.W||",VERS,ARC=-1"
RETURN
/*     */
GET_GPOARCH_MODNAME3:
MODSW = 'NO'
IF PCNT = 0 THEN RETURN
RCDSW = 'NO'
DO P = 1 TO PCNT
   IF PROCSW.P = 'YES' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"PROCMEM.P"/"
      ITERATE
   END
   EXCLSW = 'NO'
   IF EP > 0 THEN DO H = 1 TO EP
      IF EPROC.H = PROCMEM.P THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-SEL NAME=/"PROCMEM.P"/"
END
IF RCDSW = 'NO' THEN RETURN
RCD.W = RCD.W||",VERS,ARC=-1"
RETURN
/*     */
GET_GPOARCH_MODNAME4:
MODSW = 'NO'
IF RCNT = 0 THEN RETURN
RCDSW = 'NO'
DO R = 1 TO RCNT
   IF RAMISW.R = 'YES' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"RAMIMEM.R"/"
      ITERATE
   END
   EXCLSW = 'NO'
   IF ER > 0 THEN DO H = 1 TO ER
      IF ERAMI.H = RAMIMEM.R THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-SEL NAME=/"RAMIMEM.R"/"
END
IF RCDSW = 'NO' THEN RETURN
RCD.W = RCD.W||",VERS,ARC=-1"
RETURN
/*     */
GET_GPOARCH_MODNAME5:
MODSW = 'NO'
IF SCNT = 0 THEN RETURN
RCDSW = 'NO'
DO S = 1 TO SCNT
   IF SRCESW.S = 'YES' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"SRCEMEM.S"/"
      ITERATE
   END
   EXCLSW = 'NO'
   IF ES > 0 THEN DO H = 1 TO ES
      IF ESRCE.H = SRCEMEM.S THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-SEL NAME=/"SRCEMEM.S"/"
END
IF RCDSW = 'NO' THEN RETURN
RCD.W = RCD.W||",VERS,ARC=-1"
RETURN
/*     */
GET_GPOARCH_MODNAME6:
MODSW = 'NO'
IF ICNT = 0 THEN RETURN
RCDSW = 'NO'
DO I = 1 TO ICNT
   IF SYSISW.I = 'YES' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"SYSIMEM.I"/"
      ITERATE
   END
   EXCLSW = 'NO'
   IF EI > 0 THEN DO H = 1 TO EI
      IF ESYSI.H = SYSIMEM.I THEN EXCLSW = 'YES'
   END
   IF EXCLSW = 'YES' THEN ITERATE
   MODSW = 'YES'
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-SEL NAME=/"SYSIMEM.I"/"
END
IF RCDSW = 'NO' THEN RETURN
RCD.W = RCD.W||",VERS,ARC=-1"
RETURN
/*     */
BUILD_GPO_DELETE_MODULE_JOBSTREAM:
C = 0
J = 0
P = 0
R = 0
S = 0
I = 0
RCD.2 = "//SYSPRINT DD SYSOUT=*"
RCD.3 = "//LIST     DD SYSOUT=*"
RCD.4 = "//INDEX    DD SYSOUT=*"
RCD.5 = "//SYSAF01  DD UNIT=SYSDA,SPACE=(TRK,(30,30))"
RCD.6 = "//SYSAF02  DD UNIT=SYSDA,SPACE=(TRK,(30,30))"
RCD.8 = "//OSJOB    DD DSN=&&DELMEMB,UNIT=SYSDA,"
RCD.9 = "//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),"
RCD.10 = "//         SPACE=(CYL,(9,1)),DISP=(NEW,PASS)"
RCD.11 = "//SYSIN    DD *"
RCD.12 = "-OPT GPO"
JCL.1 = "-END"
JCL.2 = "/*"
JCL.4 = "/*"
JCL.6 = "//SYSPRINT DD SYSOUT=*"
JCL.7 = "//SYSUDUMP DD SYSOUT=Y"
JCL.8 = "//SYSABEND DD SYSOUT=Y"
JCL.9 = "//LIST DD SYSOUT=*"
JCL.10 = "//INDEX DD SYSOUT=*"
JCL.11 = "//OSJOB DD DUMMY"
JCL.13 = "//SYSIN    DD DSN=&&DELMEMB,DISP=(OLD,DELETE)"
JCL.14 = "/*"
JCL.16 = "/*"
DO L = 1 TO 6
   W = 12
   LABEL = 'GET_GPODELET_MODNAME'||L
   INTERPRET CALL LABEL
   IF MODSW = 'NO' THEN ITERATE
   DELSTEP1 = WORD('DELCOPY DELJCL DELPROC DELRAMI DELSRCE DELSYSI',L)
   ABEND5 = WORD('ABCOPY5 ABJCL5 ABPROC5 ABRAMI5 ABSRCE5 ABSYSI5',L)
   RCD.1 = "//"DELSTEP1" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'"
   RCD.7 = "//MASTER   DD DSN="FROMLIB.L",DISP=SHR"
   CALL WRITE_LBACKOUT_JCL1
   E = 16
   JCL.3 = "//"ABEND5" EXEC PGM=ABENDWTO,COND=(0,GE,"DELSTEP1")"
   DELSTEP2 = WORD('REMCOPY REMJCL REMPROC REMRAMI REMSRCE REMSYSI',L)
   ABEND6 = WORD('ABCOPY6 ABJCL6 ABPROC6 ABRAMI6 ABSRCE6 ABSYSI6',L)
   JCL.5 = "//"DELSTEP2" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'"
   JCL.12 = "//MASTER   DD DSN="FROMLIB.L",DISP=SHR"
   JCL.15 = "//"ABEND6" EXEC PGM=ABENDWTO,COND=(0,GE,"DELSTEP2")"
   CALL WRITE_LBACKOUT_JCL2
END
RETURN
/*     */
GET_GPODELET_MODNAME1:
MODSW = 'NO'
IF CCNT = 0 THEN RETURN
RCDSW = 'NO'
DO C = 1 TO CCNT
   IF COPYSW.C = 'NO' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"COPYMEM.C"/"
      ITERATE
   END
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-DLM NAME=/"COPYMEM.C"/"
END
IF RCDSW = 'NO' THEN RETURN
MODSW = 'YES'
RETURN
/*     */
GET_GPODELET_MODNAME2:
MODSW = 'NO'
IF JCNT = 0 THEN RETURN
RCDSW = 'NO'
DO J = 1 TO JCNT
   IF JCLSW.J = 'NO' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"JCLMEM.J"/"
      ITERATE
   END
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-DLM NAME=/"JCLMEM.J"/"
END
IF RCDSW = 'NO' THEN RETURN
MODSW = 'YES'
RETURN
/*     */
GET_GPODELET_MODNAME3:
MODSW = 'NO'
IF PCNT = 0 THEN RETURN
RCDSW = 'NO'
DO P = 1 TO PCNT
   IF PROCSW.P = 'NO' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"PROCMEM.P"/"
      ITERATE
   END
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-DLM NAME=/"PROCMEM.P"/"
END
IF RCDSW = 'NO' THEN RETURN
MODSW = 'YES'
RETURN
/*     */
GET_GPODELET_MODNAME4:
MODSW = 'NO'
IF RCNT = 0 THEN RETURN
RCDSW = 'NO'
DO R = 1 TO RCNT
   IF RAMISW.R = 'NO' THEN ITERATE
   IF RCDSW = 'NO' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"RAMIMEM.R"/"
      ITERATE
   END
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-DLM NAME=/"RAMIMEM.R"/"
END
IF RCDSW = 'NO' THEN RETURN
MODSW = 'YES'
RETURN
/*     */
GET_GPODELET_MODNAME5:
MODSW = 'NO'
IF SCNT = 0 THEN RETURN
RCDSW = 'NO'
DO S = 1 TO SCNT
   IF SRCESW.S = 'NO' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"SRCEMEM.S"/"
      ITERATE
   END
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-DLM NAME=/"SRCEMEM.S"/"
END
IF RCDSW = 'NO' THEN RETURN
MODSW = 'YES'
RETURN
/*     */
GET_GPODELET_MODNAME6:
MODSW = 'NO'
IF ICNT = 0 THEN RETURN
RCDSW = 'NO'
DO I = 1 TO ICNT
   IF SYSISW.I = 'NO' THEN ITERATE
   IF RCDSW = 'YES' THEN DO
      RCD.W = RCD.W||"|"
      W = W + 1
      RCD.W = "-CON NAME=/"SYSIMEM.I"/"
      ITERATE
   END
   W = W + 1
   RCDSW = 'YES'
   RCD.W = "-DLM NAME=/"SYSIMEM.I"/"
END
IF RCDSW = 'NO' THEN RETURN
MODSW = 'YES'
RETURN
/*     */
BUILD_IEBCOPY_LOAD_MODULE_NAMES:
ADDRESS TSO
LANGCODE = ''
DYLSW = 'NO'
LIBHST = "'"HISTMAST"("SRCEMEM.S")'"
HISTDD = LIBALLOC(LIBHST)
IF HISTDD = "ERROR" THEN SIGNAL HISTMAST_ALLOC_ERROR
"DELSTACK"
"EXECIO 1 DISKR" HISTDD "4 (FINIS"
SRC = RC
"FREE FILE("HISTDD")"
IF SRC ¬= 0 THEN SIGNAL HISTMAST_EXECIO_ERROR
PULL LANGCODE .
IF (LANGCODE = 'CICSCOPY') | (LANGCODE = 'CICS2CPY') THEN RETURN
IF LANGCODE = 'CICSDB2' THEN DO
   IF SRCESW.S = 'YES' THEN DO
      LC = LC + 1
      DELCICS.LC = SRCEMEM.S
      RETURN
   END
   DB2SW = 'YES'
   DC = DC + 1
   DB2CICS.DC = SRCEMEM.S
   RETURN
END
IF LANGCODE = 'COBDB2' THEN DO
   IF SRCESW.S = 'YES' THEN DO
      LB = LB + 1
      DELBAT.LB = SRCEMEM.S
      RETURN
   END
   DB2SW = 'YES'
   DB = DB + 1
   DB2BAT.DB = SRCEMEM.S
   RETURN
END
LANG = WORDPOS(LANGCODE,CICSLANG)
IF LANG ¬= 0 THEN DO
   IF SRCESW.S = 'YES' THEN DO
      LC = LC + 1
      DELCICS.LC = SRCEMEM.S
      RETURN
   END
   C = C + 1
   CICS.C = SRCEMEM.S
   RETURN
END
IF LANGCODE = 'DYL280' THEN DO
   DYLSW = 'YES'
   RETURN
END
IF SRCESW.S = 'YES' THEN DO
   LB = LB + 1
   DELBAT.LB = SRCEMEM.S
   RETURN
END
B = B + 1
BATCH.B = SRCEMEM.S
RETURN
/*     */
BUILD_DYL280_LOAD_MODULE_NAMES:
IF SRCESW.S = 'YES' THEN DO
   LB = LB + 1
   DELBAT.LB = SRCEMEM.S
   CALL CHECK_DYL280_NUMBER_REPORTS
   IF REPTSW = 'NO' THEN RETURN
   DO M = 1 TO NUMREPTS
      IF M = 1 THEN ITERATE
      MLEN = LENGTH(M)
      IF MLEN = 1 THEN DYLMOD = PREFIX||'0'M
      IF MLEN = 2 THEN DYLMOD = PREFIX||M
      LB = LB + 1
      DELBAT.LB = DYLMOD
   END
   RETURN
END
B = B + 1
BATCH.B = SRCEMEM.S
CALL CHECK_DYL280_NUMBER_REPORTS
IF REPTSW = 'NO' THEN RETURN
DO M = 1 TO NUMREPTS
   IF M = 1 THEN ITERATE
   MLEN = LENGTH(M)
   IF MLEN = 1 THEN DYLMOD = PREFIX||'0'M
   IF MLEN = 2 THEN DYLMOD = PREFIX||M
   B = B + 1
   BATCH.B = DYLMOD
END
RETURN
/*     */
CHECK_DYL280_NUMBER_REPORTS:
ADDRESS TSO
REPTSW = 'NO'
MLEN = LENGTH(SRCEMEM.S)
PREFIX = SUBSTR(SRCEMEM.S,1,MLEN)
IF MLEN >= 6 THEN PREFIX = SUBSTR(SRCEMEM.S,1,6)
LIBDSN = "'"MASTER"("SRCEMEM.S")'"
LIBDD = LIBALLOC(LIBDSN)
IF LIBDD = "ERROR" THEN RETURN
"EXECIO 1 DISKR" LIBDD "(FINIS STEM REPORT."
SRC = RC
"FREE F("LIBDD")"
IF SRC ¬= 0 THEN RETURN
REPTFLG = POS('* REPORTS = ',REPORT.1)
IF REPTFLG = 0 THEN RETURN
NUMREPTS = WORD(REPORT.1,4)
IF NUMREPTS = '' THEN RETURN
RTYP = DATATYPE(NUMREPTS)
IF RTYP ¬= 'NUM' THEN RETURN
IF NUMREPTS < 2 THEN RETURN
REPTSW = 'YES'
RETURN
/*     */
BUILD_IEBCOPY_LOADLIB_JOBSTREAM:
BCNT = B
CCNT = C
B = 0
C = 0
COPYM.1 = 'LOADCPYB'
FDD.1 = 'INDDB  '
TDD.1 = 'OUTDDB '
FLOAD.1 = 'SYS1.BACKUP.BATCH.LOADLIB'
TLOAD.1 = 'SYS1.PROD.BATCH.LOADLIB'
COPYM.2 = 'LOADCPYC'
FDD.2 = 'INDDC  '
TDD.2 = 'OUTDDC '
FLOAD.2 = 'SYS1.BACKUP.CICS.LOADLIB'
TLOAD.2 = 'SYS1.PROD.CICS.LOADLIB'
DO L = 1 TO 2
   LABEL = 'BUILD_IEBCOPY_SYSIN'||L
   INTERPRET CALL LABEL
END
RETURN
/*     */
BUILD_IEBCOPY_SYSIN1:
IF BCNT = 0 THEN RETURN
I = 0
W = 0
LOADSW = 'NO'
CNTL = "       SELECT MEMBER=("
DO B = 1 TO BCNT
   LOADMOD = SYSDSN("'"FLOAD.1"("BATCH.B")'")
   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE
   LOADSW = 'YES'
   I = I + 1
   IF I = 1 THEN SYSIN = CNTL||BATCH.B
   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||","||BATCH.B
   IF (I = 5) THEN DO
      W = W + 1
      SYSIN = SYSIN||","||BATCH.B||")"
      RCD.W = SYSIN
      I = 0
   END
END
IF LOADSW = 'NO' THEN RETURN
CALL WRITE_IEBCOPY_JCL
CALL WRITE_LBACKOUT_JCL2
IF I > 0 THEN DO
   W = W + 1
   SYSIN = SYSIN||")"
   RCD.W = SYSIN
END
W = W + 1
RCD.W = "/*"
W = W + 1
RCD.W = "//ABEND7  EXEC PGM=ABENDWTO,COND=(0,GE,"COPYM.L")"
W = W + 1
RCD.W = "/*"
CALL WRITE_LBACKOUT_JCL1
RETURN
/*     */
BUILD_IEBCOPY_SYSIN2:
IF CCNT = 0 THEN RETURN
I = 0
W = 0
LOADSW = 'NO'
CNTL = "       SELECT MEMBER=("
DO C = 1 TO CCNT
   LOADMOD = SYSDSN("'"FLOAD.2"("CICS.C")'")
   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE
   LOADSW = 'YES'
   I = I + 1
   IF I = 1 THEN SYSIN = CNTL||CICS.C
   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||","||CICS.C
   IF (I = 5) THEN DO
      W = W + 1
      SYSIN = SYSIN||","||CICS.C||")"
      RCD.W = SYSIN
      I = 0
   END
END
IF LOADSW = 'NO' THEN RETURN
CALL WRITE_IEBCOPY_JCL
CALL WRITE_LBACKOUT_JCL2
IF I > 0 THEN DO
   W = W + 1
   SYSIN = SYSIN||")"
   RCD.W = SYSIN
END
W = W + 1
RCD.W = "/*"
W = W + 1
RCD.W = "//ABEND8  EXEC PGM=ABENDWTO,COND=(0,GE,"COPYM.L")"
W = W + 1
RCD.W = "/*"
CALL WRITE_LBACKOUT_JCL1
RETURN
/*     */
WRITE_IEBCOPY_JCL:
E = 11
FROMDD = STRIP(FDD.L)
JCL.1 = "//"COPYM.L" EXEC PGM=IEBCOPY"
JCL.2 = "//"FDD.L"  DD    DSN="FLOAD.L",DISP=SHR"
JCL.3 = "//"TDD.L"  DD    DSN="TLOAD.L",DISP=SHR"
JCL.4 = "//SYSPRINT DD    SYSOUT=*"
JCL.5 = "//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))"
JCL.6 = "//SYSUT2   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))"
JCL.7 = "//SYSUT3   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))"
JCL.8 = "//SYSUT4   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))"
JCL.9 = "//SYSIN    DD  *"
JCL.10 = "  COPY OUTDD="TDD.L
JCL.11 = "       INDD=(("FROMDD",R))"
RETURN
/*     */
BUILD_DELETE_LOADLIB_JOBSTREAM:
BCNT = LB
CCNT = LC
B = 0
C = 0
W = 0
LOADSW = 'NO'
LIBDEF = 'BATCHDD CICSDD'
LOADLIB.1 = 'SYS1.PROD.BATCH.LOADLIB'
LOADLIB.2 = 'SYS1.PROD.CICS.LOADLIB'
DO L = 1 TO 2
   LABEL = 'BUILD_DELETE_SYSIN'||L
   LIBDD = WORD(LIBDEF,L)
   INTERPRET CALL LABEL
END
IF LOADSW = 'NO' THEN RETURN
CALL WRITE_IDCAMS_DELMOD_JCL
CALL WRITE_LBACKOUT_JCL2
W = W + 1
RCD.W = "/*"
W = W + 1
RCD.W = "//ABEND9  EXEC PGM=ABENDWTO,COND=(0,GE,DLOADMOD)"
W = W + 1
RCD.W = "/*"
CALL WRITE_LBACKOUT_JCL1
RETURN
/*     */
BUILD_DELETE_SYSIN1:
IF BCNT = 0 THEN RETURN
DO B = 1 TO BCNT
   LOADMOD = SYSDSN("'"LOADLIB.1"("DELBAT.B")'")
   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE
   LOADSW = 'YES'
   W = W + 1
   RCD.W = "  DELETE   "LOADLIB.1"("DELBAT.B") FILE("LIBDD")"
END
RETURN
/*     */
BUILD_DELETE_SYSIN2:
IF CCNT = 0 THEN RETURN
DO C = 1 TO CCNT
   LOADMOD = SYSDSN("'"LOADLIB.2"("DELCICS.C")'")
   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE
   LOADSW = 'YES'
   W = W + 1
   RCD.W = "  DELETE   "LOADLIB.2"("DELCICS.C") FILE("LIBDD")"
END
RETURN
/*     */
WRITE_IDCAMS_DELMOD_JCL:
E = 5
JCL.1 = "//DLOADMOD EXEC PGM=IDCAMS"
JCL.2 = "//BATCHDD  DD   DSN="LOADLIB.1",DISP=SHR"
JCL.3 = "//CICSDD   DD   DSN="LOADLIB.2",DISP=SHR"
JCL.4 = "//SYSPRINT DD   SYSOUT=*"
JCL.5 = "//SYSIN    DD  *"
RETURN
/*     */
CHECK_DB2_PARMS_MEMBER:
SRC = 028
DB2PARM = SYSDSN("'"QACCF"("WORKORDR")'")
IF DB2PARM = 'MEMBER NOT FOUND' THEN SIGNAL DB2PARM_MEMBER_ERROR
RETURN
/*     */
SUBMIT_DB2_SKELETON_COMPILE_JCL:
ADDRESS ISPEXEC
"FTOPEN TEMP"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR
"FTINCL $CCFJOBD"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR
"FTINCL" SKELJCL
SRC = RC
IF SRC ¬= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR
"FTCLOSE"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR
"VGET ZTEMPF"
ADDRESS TSO "SUBMIT '"ZTEMPF"'"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR
RETURN
/*     */
WRITE_LBACKOUT_JCL1:
ADDRESS TSO
"DELSTACK"
RCDCNT = W
DO W = 1 TO RCDCNT
   QUEUE RCD.W
END
"EXECIO" RCDCNT "DISKW CCFDD"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL PDS_WRITE_ERROR
RETURN
/*     */
WRITE_LBACKOUT_JCL2:
ADDRESS TSO
"DELSTACK"
RCDCNT = E
DO E = 1 TO RCDCNT
   QUEUE JCL.E
END
"EXECIO" RCDCNT "DISKW CCFDD"
SRC = RC
IF SRC ¬= 0 THEN SIGNAL PDS_WRITE_ERROR
RETURN
/*     */
INIT_SCREEN_MEMBER_PARM:
DO A = 1 TO 56
   INTERPRET 'MEM'A '= AST'
END
RETURN
/*     */
DISPLAY_MEMBER_SELECTION_PANEL1:
CCNT = C
IF CCNT = 0 THEN RETURN
IF C > 56 THEN CCNT = 56
C = 0
EC = 0
DO A = 1 TO CCNT
   INTERPRET 'MEM'A '= COPYMEM.'A
END
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"DISPLAY PANEL(CCFBKPNM)"
SRC = RC
IF SRC = 0 THEN DO A = 1 TO CCNT
   SELMEMB = VALUE('SM'A)
   IF SELMEMB = 'S' THEN DO
      C = C + 1
      MODCNT = MODCNT + 1
      COPYMEM.C = COPYMEM.A
      COPYSW.C = COPYSW.A
      ITERATE
   END
   EC = EC + 1
   ECOPY.EC = COPYMEM.A
END
IF SRC = 0 THEN RETURN
IF SRC = 8 THEN EXIT 8
SAY
SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
DISPLAY_MEMBER_SELECTION_PANEL2:
JCNT = J
IF JCNT = 0 THEN RETURN
IF J > 56 THEN JCNT = 56
J = 0
EJ = 0
DO A = 1 TO JCNT
   INTERPRET 'MEM'A '= JCLMEM.'A
END
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"DISPLAY PANEL(CCFBKPNM)"
SRC = RC
IF SRC = 0 THEN DO A = 1 TO JCNT
   SELMEMB = VALUE('SM'A)
   IF SELMEMB = 'S' THEN DO
      J = J + 1
      MODCNT = MODCNT + 1
      JCLMEM.J = JCLMEM.A
      JCLSW.J = JCLSW.A
      ITERATE
   END
   EJ = EJ + 1
   EJCL.EJ = JCLMEM.A
END
IF SRC = 0 THEN RETURN
IF SRC = 8 THEN EXIT 8
SAY
SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
DISPLAY_MEMBER_SELECTION_PANEL3:
PCNT = P
IF PCNT = 0 THEN RETURN
IF P > 56 THEN PCNT = 56
P = 0
EP = 0
DO A = 1 TO PCNT
   INTERPRET 'MEM'A '= PROCMEM.'A
END
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"DISPLAY PANEL(CCFBKPNM)"
SRC = RC
IF SRC = 0 THEN DO A = 1 TO PCNT
   SELMEMB = VALUE('SM'A)
   IF SELMEMB = 'S' THEN DO
      P = P + 1
      MODCNT = MODCNT + 1
      PROCMEM.P = PROCMEM.A
      PROCSW.C = PROCSW.A
      ITERATE
   END
   EP = EP + 1
   EPROC.EP = PROCMEM.A
END
IF SRC = 0 THEN RETURN
IF SRC = 8 THEN EXIT 8
SAY
SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
DISPLAY_MEMBER_SELECTION_PANEL4:
RCNT = R
IF RCNT = 0 THEN RETURN
IF R > 56 THEN RCNT = 56
R = 0
ER = 0
DO A = 1 TO RCNT
   INTERPRET 'MEM'A '= RAMIMEM.'A
END
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"DISPLAY PANEL(CCFBKPNM)"
SRC = RC
IF SRC = 0 THEN DO A = 1 TO RCNT
   SELMEMB = VALUE('SM'A)
   IF SELMEMB = 'S' THEN DO
      R = R + 1
      MODCNT = MODCNT + 1
      RAMIMEM.R = RAMIMEM.A
      RAMISW.C = RAMISW.A
      ITERATE
   END
   ER = ER + 1
   ERAMI.ER = RAMIMEM.A
END
IF SRC = 0 THEN RETURN
IF SRC = 8 THEN EXIT 8
SAY
SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
DISPLAY_MEMBER_SELECTION_PANEL5:
SCNT = S
IF SCNT = 0 THEN RETURN
IF S > 56 THEN SCNT = 56
S = 0
ES = 0
DO A = 1 TO SCNT
   INTERPRET 'MEM'A '= SRCEMEM.'A
END
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"DISPLAY PANEL(CCFBKPNM)"
SRC = RC
IF SRC = 0 THEN DO A = 1 TO SCNT
   SELMEMB = VALUE('SM'A)
   IF SELMEMB = 'S' THEN DO
      S = S + 1
      MODCNT = MODCNT + 1
      SRCEMEM.S = SRCEMEM.A
      SRCESW.S = SRCESW.A
      ITERATE
   END
   ES = ES + 1
   ESRCE.ES = SRCEMEM.A
END
IF SRC = 0 THEN RETURN
IF SRC = 8 THEN EXIT 8
SAY
SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
DISPLAY_MEMBER_SELECTION_PANEL6:
ICNT = I
IF ICNT = 0 THEN RETURN
IF I > 56 THEN ICNT = 56
I = 0
EI = 0
DO A = 1 TO ICNT
   INTERPRET 'MEM'A '= SYSIMEM.'A
END
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"DISPLAY PANEL(CCFBKPNM)"
SRC = RC
IF SRC = 0 THEN DO A = 1 TO ICNT
   SELMEMB = VALUE('SM'A)
   IF SELMEMB = 'S' THEN DO
      I = I + 1
      MODCNT = MODCNT + 1
      SYSIMEM.I = SYSIMEM.A
      SYSISW.I = SYSISW.A
      ITERATE
   END
   EI = EI + 1
   ESYSI.EI = SYSIMEM.A
END
IF SRC = 0 THEN RETURN
IF SRC = 8 THEN EXIT 8
SAY
SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
SUBMIT_BACKOUT_JOB:
ADDRESS TSO
"EXECIO 0 DISKW CCFDD (FINIS"
"SUBMIT '"CNTLLIB"("WORKORDR")'"
SRC = RC
"FREE F(CCFDD)"
IF SRC ¬= 0 THEN SIGNAL SUBMIT_ERROR
RETURN
/*     */
CHECK_USER_AUTHORIZATION:
AUTHSW = 'NO'
"ALLOC DA('"PARMLIB"(ELIPSAUS)') F(PARMDD) SHR"
"EXECIO * DISKR PARMDD (STEM AUTHUSR. FINIS"
"FREE FILE(PARMDD)"
DO V = 1 TO AUTHUSR.0
   IF AUTHUSR.V = TSOID THEN DO
      AUTHSW = 'YES'
      LEAVE
   END
END
RETURN
/*
         E R R O R   R O U T I N E S   S E C T I O N      */
/*     */
STAGING_PDS_ERROR:
SAY
SAY '*** DATASET ERROR: ('CNTLLIB') - DATASET NOT FOUND. ***'
SAY '*** UNABLE TO ALLOCATE THE STAGING SKELETON JCL PDS. ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'
EXIT 028
/*     */
AUTHORIZATION_ERROR:
SAY
SAY '*** AUTHORIZATION ERROR: USER ('TSOID') NOT AUTHORIZED. ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'
EXIT 913
/*     */
INVALID_WORKORDR_NUMBER:
SAY
SAY '*** INVALID CR/WO NUMBER: (' WORKORDR ') NOT FOUND IN SYSTEM MASTER. ***'
SAY '+++ VALID CR/WO NUMBER MUST BE 8 BYTE FORMAT: ( WONNNNNN ). +++'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'
EXIT 024
/*     */
SYSMAST_ALLOC_ERROR:
SAY
SAY '*** ALLOCATION ERROR: ('SYSMAST') - RETRY TASK. ***'
SAY '*** DYNAMIC ALLOCATION FAILED FOR THE CONTROL LIBRARIAN MASTER. ***'
SAY '*** CCF BACKOUT SUBTASK CANCELLED. ***'
EXIT 100
/*     */
CRWO_MODULE_NOT_FOUND:
SAY
SAY '*** CRWO MODULE ERROR: MODULE NOT FOUND FOR (' ZRMEMB 'OR' MEMBER '). ***'
SAY '*** MEMBERS NOT FOUND IN ('SYSMAST') DATASET. ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: (028). ***'
"FREE F("LIBDD")"
EXIT 028
/*     */
SYSMAST_MODULE_READ_ERROR:
SAY
SAY '*** EXECIO READ ERROR: ('SYSMAST'('MEMBER'). ***'
SAY '*** CANNOT READ CR/WO SYSTEM MASTER MODULE TO EXTRACT MEMBER NAMES. ***'
SAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'
EXIT SRC
/*     */
BACKOUT_QUALIFY_ERROR:
SAY
SAY '*** BACKOUT ERROR: NO TO-PRODUCTION MODULE RECORD ENTRIES FOUND. ***'
SAY 'MEMBERS ('ZRMEMB 'OR' WORKORDR') DO NOT CONTAIN VALID MOVEMEMT RECORDS.'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'
EXIT 028
/*     */
STAGING_PDS_ALLOC_ERROR:
SAY
SAY '*** ALLOCATION ERROR: ('CNTLLIB'('WORKORDR') SKELETON JCL PDS. ***'
SAY '*** DATASET UNAVAILABLE FOR JOBSTREAM BUILD/WRITE. ***'
SAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'
"FREE F(CCFDD)"
EXIT SRC
/*     */
PDS_WRITE_ERROR:
SAY
SAY '*** PDS WRITE ERROR: ('CNTLLIB'('WORKORDR'). ***'
SAY '*** SKELETON JCL JOBSTREAM BUILD ERROR. ***'
SAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'
"FREE F(CCFDD)"
EXIT SRC
/*     */
HISTMAST_ALLOC_ERROR:
SAY
SAY '*** ALLOCATION ERROR: ('HISTMAST'('SRCEMEM.S') - RETRY TASK. ***'
SAY '*** DYNAMIC ALLOCATION FAILED FOR THE SOURCE HISTORY MASTER. ***'
SAY '*** CCF BACKOUT SUBTASK CANCELLED. ***'
EXIT 100
/*     */
HISTMAST_EXECIO_ERROR:
SAY
SAY '*** EXECIO READ ERROR: ('HISTMAST'('SRCEMEM.S'). ***'
SAY '*** UNABLE TO RETRIEVE LANG CODE FOR LOAD MODULE BACKOUT. ***'
SAY '*** CCF BACKOUT EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'
EXIT SRC
/*     */
DB2PARM_MEMBER_ERROR:
SAY
SAY '*** PARMLIB MEMBER ERROR: ('QACCF'('WORKORDR'). ***'
SAY '*** UNABLE TO RETRIEVE DB2 PACKAGE/BIND PARAMETER DATA. ***'
SAY '*** CCF BACKOUT EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'
EXIT SRC
/*     */
SUBMIT_ERROR:
SAY
SAY '*** SUBMIT ERROR: ('CNTLLIB'('WORKORDR'). ***'
SAY '*** EXECIO DISKW SKELETON JCL JOBSTREAM BUILD ERROR. ***'
SAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'
"FREE F(CCFDD)"
EXIT SRC
/*     */
SKELETON_JCL_BUILD_ERROR:
SAY
SAY '*** SUBMIT ERROR: ('SKELJCL'('MEMBER'). ***'
SAY '*** DIALOG SKELETON JCL JOBSTREAM BUILD ERROR. ***'
SAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'
"FREE F(CCFDD)"
EXIT SRC
