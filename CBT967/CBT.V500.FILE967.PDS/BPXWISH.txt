/*REXX*/
/**********************************************************************/
/* $MAC(BPXWISH) COMP(SCPX1) PROD(BPX):                               */
/* EXEC:      BPXWISH                                                 */
/* PROPRIETARY STATEMENT:                                             */
/*            LICENSED MATERIALS - PROGRAM PROPERTY OF IBM            */
/*            5650-ZOS COPYRIGHT IBM CORPORATION, 1993,2015           */
/* STATUS:    HBB77A0                                                 */
/* FUNCTION:  ISPF shell (dialog) for OpenMVS file system access      */
/*            and various administrative functions.                   */
/* CHANGE ACTIVITY:  (recent only)                                    */
/*   $P1=PPF0035  HOM1130, 940601, PDND: fix fsattr after name cmd    */
/*                                       makevpath/path->tpath        */
/*   $P2=PPF0080  HOM1130, 940804, PDND: showobj support for delete   */
/*   $01=OY08318  HOM1120, 940920, PDND: libdef/altlib, user setup    */
/*   $P4=PPF0477  HOM1130, 950613, PDND: adds for root setup          */
/*   $02=OW16240  HOM1130, 950926, PDND: add mode popup for copy      */
/*                                       user setup and automount     */
/*   $03=OW19471  HOM1130, 960325, PDND: handle tso noprefix          */
/*   $04=OW20797  HOM1130, 960604, PDND: allow 10 digit uids          */
/*   $P5=PQC1428  HOM1150, 960611, PDND: do not prime fields on mount */
/*                                       add diag for ispf select err */
/*   $05=OW19596  HOM1130, 960801, PDND: sh/ex pathname, set HOME env */
/*   $D3=DSYA188  JBB6604, 961011, PDND: trusted tree                 */
/*   $D4=DSYA199  JBB6604, 961030, PDND: cee runopts  A199.03         */
/*   $D6=DWAA297  JBB6607, 980507, PDJP: mount nosecurity             */
/*   $P6=PWA0164  JBB6607, 980520, PDJP: 10 digit uid/gid FIN OW33117 */
/*                                       fall back to CWD of /        */
/*   $06=OW35469  HBB6606, 980826, PDND: default uid/gid, env vars    */
/*   $D7=DWYA309  JBB6609, 990321, PDND: sysplex support              */
/*   $07=OW36923  HBB6605, 990323, PDJP: 10 digit uid for panel P06   */
/*   $08=OW42612  JBB6609, 000130, PDND: fsattr misses fs name        */
/*                                       add dyn fs list              */
/*   $09=OW43422  JBB6609, 000229, PDND: fix changing automove attr   */
/*   $D8=DXVA412  HBB7705, 000515, PDMX: Native Ascii - file tag      */
/*   $D9=DYMA...  HBB7706, 001204, PDND: autounmount                  */
/*   $DA=DYMA525  HBB7706, 001218, PDND: ACLs A525.02                 */
/*   $0A=OW47337  HBB7706, 010130, PDND: change seteuid to setreuid   */
/*   $0B=OW47860  HBB7706, 010130, PDND: improve symlink handling     */
/*   $DB=DYMA557  HBB7707, 010611, PDND: ish enhancements: local time */
/*                                       sort, color, X via sh,       */
/*                                       fixed len edit               */
/*   $P7=PYM0293  HBB7707, 010628, PDND: call mpc and misc fixes      */
/*   $P8=PYM....  HBB7707, 010711, PDND: sort fix                     */
/*   $P9=PYM0396  HBB7707, 010809, PDND: execute fix                  */
/*   $PA=PYM0365  HBB7707, 010809, PDND: reorder color attrs          */
/*   $DC=DYVA579  HBB7707, 011012, PDND: zfs, syslist                 */
/*   $PB=PYV0168  HBB7707, 011201, PDND: add syslist to mount         */
/*   $PC=PYV0188  HBB7707, 011206, PDND: syslist fix                  */
/*   $PD=PYV0159  HBB7707, 011220, PDND: syslist fix2                 */
/*   $Px=PYV0276  HBB7707, 020103, PDND: rewrite dirlist nonrecursive */
/*   $0C=OW.....  HBB7708, 020210, PDND: user setup with automount    */
/*   $DD=DYNA604  HBB7708, 020210, PDND: zfs aggregates               */
/*   $PE=xxxxxxx  HBB7708, 020601, PDMX: filetag update               */
/*   $0E=PYN0516  HBB7708, 021001, PDND: dirlist nonrecursive OW56603 */
/*   $0A=OW53406  JBB6609, 021201, PDMX: peg csr to cmdline on ps     */
/*   $0D=OW52333  HBB7703, 020823, PDND: user setup with automount    */
/*                                        (also PYN0207)              */
/*   $PF=PYN0699  HBB7708, 021021, PDND: fix shortcuts on dirlist($0E)*/
/*   $DE=DYNA597  HBB7708, 021104, PDND: add r/o seclabel to fs       */
/*   $0F=OW55686  HBB7706, 021101, PDMX: incorrect HOME during spawn  */
/*   $0G=OA01945  HBB7708, 020131, PDND: get init uid from user seg   */
/*   $0H=OW57339  HBB7706, 030227, PDKG: do stat if readdir2 fails    */
/*   $0I=OAxxxxx  HBB7708, 030227, PDKG: Allow no options on dir list */
/*   $DF=DJKA663  HBB7709, 030418, PDND: ish enhancements: filter,    */
/*                                       rwx, old way options,        */
/*                                                                    */
/*   $DG=DJKA612  HBB7709, 030522, PDND: superkill                    */
/*   $PG=PJK0588  HBB7709, 030622, PDND: change fchattr to chattr     */
/*   $PH=PJK0622  HBB7709, 030713, PDMX: init prc for setfilter       */
/*   $0J=OA04911  HBB7720, 040313, PDMX: panel not found loop (FIN)   */
/*   $0K=OA06789  HBB7720, 040313, PDMX: symlink 'L' cmd improvement  */
/*   $DH=DDEA780  HBB7720, 040127, PDND: reflist, grplst, ...         */
/*                         040622, PDND: add filesys type to mnt tab  */
/*   $PI=ME01222  HBB7720, 040813, PDND: misc fixes                   */
/*   $PJ=ME01786  HBB7720, 040927, PDND: fix for using old copy source*/
/*   $0M=OA09148  HBB7720, 041010, PDMX: user setup tso error (fin)   */
/*   $PK=ME03811  HBB7730, 050809, PDND: add crnl to data type display*/
/*   $0N=OA13504  HBB7707, 051110, PDKG: check stat of getpwnam       */
/*   $0O=OA13287  HBB7708, 051111, PDMX: allow long TZ env            */
/*   $DI=DCRB241  HBB7750, 070413, PDGY: add mount status string      */
/*   $PL=ME10435  HBB7750, 070618, PDGY: rename mount status string   */
/*                                       variables                    */
/*   $DJ=ME12185  HBB7750, 071217, PDND: remove blank copyright msg   */
/*                                       reset quiesce for zfs        */
/*                                       BPXWISHISPF envar            */
/*   $DK=DCRB495  HBB7760, 080508, PDGY: Remount samemode support     */
/*   $DL=ME14677  HBB7760, 080826, PDND: default to use ispf ed/br    */
/*   $DM=DCRB763  HBB7770, 081215, PD2R: Add Record file format Supp. */
/*   $DN=DCRB685  HBB7770, 090309  PDGY: Remove multi-file system supp*/
/*   $0P=OA29228  HBB7760, 090618  PDFV: Screen size on compare option*/
/*   $0Q=OA30104  HBB7760, 090831  PDGY: ISPF edit fails w/ rc>4      */
/*   $0R=OA31564  HBB7760, 100119  PDGY: ISHELL edit fails            */
/*   $0S=OA31876  HBB7760, 100210  PDGY: run edit macro               */
/*   $DO=DCRC028  HBB7780, 100609  PDGY: add non-priv mounts  C028.04 */
/*   $DP=ME20000  HBB7780, 100917  PDGY: Display user ID instead uid  */
/*   $0T=OA33768  HBB7750, 101212, PDMX: bpxwunix for export -p       */
/*   $0U=OA36218  HBB7780, 110418, PDGY: change var for mtabf         */
/*   $DQ=ME23809  HBB7790, 120612, PDX8: detect MENU PENU TENU libs   */
/*   $0V=OA41249  HBB7770, 130131, PDX8: filelist sorted by size w/ M */
/*   $PM=OA42869  HBB77A0, 130724, PDGY: handle errno > 999   (FIN)   */
/**********************************************************************/
signal on syntax
parse source . . who . execdsn .    /* get name of this macro   10@02C*/
if sysvar(sysispf)<>'ACTIVE' then   /* if ispf not active             */
   do                               /* start it and exec this command */
   if execdsn<>'?' then
      "ispstart cmd(ex '"execdsn"("who arg(1)")') newappl(isr)"
    else
      'ispstart cmd('who arg(1)') newappl(isr)'
   return
   end

enopref='BPXW'
ejrcomp='BPXWC'
pan.p_main='BPXWP99'
pan.p_sdir='BPXWP01'
pan.p_scsp='BPXWP02'
pan.p_sreg='BPXWP03'
pan.p_sfifo='BPXWP04'
pan.p_ssym='BPXWP05'
pan.p_dir='BPXWP06'
pan.p_dirshort='BPXWP06'
pan.p_dirlong='BPXWP06a'
pan.p_creat='BPXWP07'
pan.p_fields='BPXWP08'
pan.p_edopt='BPXWP09'
pan.p_mtopts='BPXWP61' /* @08A*/
pan.p_obj='BPXWP10'
pan.p_settings='BPXWP11'
pan.p_cngmode='BPXWP12'
pan.p_cnguser='BPXWP13'
pan.p_cnggroup='BPXWP14'
pan.p_cnguaud='BPXWP15'
pan.p_cngaaud='BPXWP16'
pan.p_confd='BPXWP17'
pan.p_confr='BPXWP18'
pan.p_getpath='BPXWP19'
pan.p_mt='BPXWP20'
pan.p_smt='BPXWP21'
pan.p_mtstat='BPXWP22'
                                                               /*@DND*/
pan.p_mtunmt='BPXWP23'
pan.p_dev='BPXWP24'
pan.p_root='BPXWP25'
pan.p_mount='BPXWP26'
pan.p_usere='BPXWP27'
pan.p_alluser='BPXWP28'
pan.p_grp='BPXWP29'
pan.p_usrlst='BPXWP30'
pan.p_usrlstm='BPXWP31'
pan.p_cpydst='BPXWP32'
pan.p_cpysrc='BPXWP33'
pan.p_getdsn='BPXWP34'
pan.p_symset='BPXWP35'
pan.p_mkfs='BPXWP36'
pan.p_cpyspds='BPXWP37'
pan.p_cpydpds='BPXWP38'
pan.p_cpyconv='BPXWP39'
pan.p_cpyerr='BPXWP40'
pan.p_segauth='BPXWP41'
pan.p_getrecl='BPXWP42'
pan.p_srchstr='BPXWP43'
pan.p_run='BPXWP44'
pan.p_memlist='BPXWP45'
pan.p_memlisthr='BPXWH45'
pan.p_memlisthc='BPXWH56'
pan.p_unquiesce='BPXWP46'
pan.p_perm='BPXWP47'
pan.p_dflts='BPXWP48'
pan.p_exconf='BPXWP49'
pan.p_symsel='BPXWP50'
pan.p_ps='BPXWP51'
pan.p_pssig='BPXWP52'
pan.p_psatt='BPXWP53'
pan.p_shcmd='BPXWP54'
pan.p_excmd='BPXWP55'
pan.p_rdel='BPXWP56'
pan.p_remount='BPXWP57'
pan.p_cngffmt='BPXWP58'
pan.p_cngexat='BPXWP59'
pan.p_cngfsat='BPXWP60'
pan.p_acltab='BPXWP62'   /*  @DAA*/
pan.p_aclnew='BPXWP63'   /*  @DAA*/
pan.p_aclconf='BPXWP64'   /*  @DAA*/
pan.p_acltype='BPXWP65'   /*  @DAA*/
pan.p_dircolor='BPXWP66'
pan.p_dirsort='BPXWP67'
pan.p_arights='BPXWP68'
pan.p_selamt='BPXWP70'    /* @DCA*/
pan.p_adops='BPXWP71'     /* @DFA*/
pan.p_filter='BPXWP72'    /* @DFA*/
pan.p_multi='BPXWP73'     /* @DFA*/
pan.p_multe='BPXWP74'     /* @DFA*/
pan.p_attrack='BPXWP75'   /* @DFA*/
pan.p_autoid='BPXWP76'    /* @DFA*/
pan.p_refltb='BPXWP77'    /* @DHA*/
pan.p_grplst='BPXWP79'    /* @DHA*/
pan.p_samemode='BPXWP80'  /* @DKA*/

pan.p_hlphelp='BPXWH90'
pan.p_hlpnews='BPXWH98'
pan.p_about='BPXWH00'
pan.p_acthelp='BPXWF13'
msg.m_blank='BPXWM999'       /* @DFA*/
msg.m_start='BPXWM001'
msg.m_invcmd='BPXWM002'
msg.m_scerr='BPXWM003'
msg.m_scerr2='BPXWM005'
msg.m_printed='BPXWM004'
msg.m_baduid='BPXWM006'
msg.m_defusr='BPXWM007'
msg.m_nouids='BPXWM008'
msg.m_unavail='BPXWM009'
unavail='BPXWM009'
msg.m_grsetup='BPXWM010'
msg.m_gentxt='BPXWM011'
msg.m_nodsn='BPXWM012'
msg.m_dupfs='BPXWM013'
msg.m_alloc='BPXWM014'
msg.m_nopgm='BPXWM015'
msg.m_notfound='BPXWM016'
msg.m_noacc='BPXWM017'
msg.m_nodiff='BPXWM018'
msg.m_noarg='BPXWM019'
msg.m_timeout='BPXWM020'
msg.m_sigexit='BPXWM021'
msg.m_sigterm='BPXWM022'
msg.m_sigstop='BPXWM023'
msg.m_priv='BPXWM024'
mnotpriv='BPXWM024'
msg.m_noaccw='BPXWM025'
msg.m_nospaces='BPXWM026'
/* M027 used by oputx/ogetx */
msg.m_nocopy='BPXWM028'
msg.m_diff='BPXWM029'
msg.m_found='BPXWM030'
msg.m_nontext='BPXWM031'
msg.m_nocopy='BPXWM032'
msg.m_dupid='BPXWM034'
msg.m_badid='BPXWM035'
msg.m_noacl='BPXWM036'
msg.m_badname='BPXWM037'
msg.m_rmfilt='BPXWM038'     /* 2@PIA */
msg.m_badnum='BPXWM039'
lit='BPXWL'
pgmedit='BPXWEDIT'
pgmbrws='BPXWBRWS'
address ispexec
"CONTROL ERRORS RETURN"
"VGET (ZAPPLID ZSCROLLD ZPLACE)"
if zapplid<>"BPXW" then
   do
   if execdsn<>'?' then                                        /* @02A*/
      do
      address tso "altlib activate appl(exec) da('"execdsn"')" /* @02A*/
      didalt=1
      end
   "SELECT CMD("who arg(1)") NEWAPPL(BPXW) NEWPOOL PASSLIB"  /* @02C*/
   if rc>8 then              /* @P5A*/
      say zerrmsg zerrlm     /* @P5A*/
   "VPUT (ZPLACE) PROFILE"
   if didalt=1 then                            /* @wjs*/
      address tso "altlib deact appl(exec)"
   return
   end
call libdefs
"VGET (IPLACE TPLACE) PROFILE"
if tplace='' then
   tplace='BOTTOM'
if iplace='' then
   iplace='ASIS'
zscrolld='DATA'
if tplace<>'INHERIT' then   /*  6@DFA*/
   do
   zplace=tplace
   "VPUT (ZPLACE) PROFILE"
   end
"VPUT (IPLACE TPLACE ZSCROLLD) PROFILE"
msgloc='MSGLOC(ZCMD)'

"GETMSG MSG("lit"000) LONGMSG(L#MT0)"
"GETMSG MSG("lit"001) LONGMSG(L#MT1)"
"GETMSG MSG("lit"002) LONGMSG(L#MT2)"
"GETMSG MSG("lit"003) LONGMSG(L#MT4)"
"GETMSG MSG("lit"004) LONGMSG(L#MT8)"
"GETMSG MSG("lit"005) LONGMSG(L#MT16)"
"GETMSG MSG("lit"006) LONGMSG(L#MT32)"
"GETMSG MSG("lit"007) LONGMSG(L#MT64)"
"GETMSG MSG("lit"018) LONGMSG(L#MT130)"
"GETMSG MSG("lit"010) LONGMSG(L#USERL)"
"GETMSG MSG("lit"011) LONGMSG(L#USER)"
"GETMSG MSG("lit"012) LONGMSG(L#UID)"
"GETMSG MSG("lit"013) LONGMSG(L#GID)"
"GETMSG MSG("lit"014) LONGMSG(L#HD)"
"GETMSG MSG("lit"015) LONGMSG(L#IP)"
"GETMSG MSG("lit"016) LONGMSG(L#FTYPES)"
"VGET (ZLSTLPP ZLSTTRUN)"
jrnodir='003D'

parse arg pathmain
if translate(substr(pathmain,1,2))='-D' then
   do
   if translate(substr(pathmain,1,3))='-DT' then
      debug=2
    else
      debug=1
   parse var pathmain . pathmain
   end
 else
   debug=0
pathmain$=strip(pathmain)    /* @DHA*/

/* In R13 a new column was added in the mount table. The mount table
   headers get saved in variable mtabf. If one was to log onto R13 and
   display the column and then log onto an R12 system, then the column
   would show up and not have initialized data since R12 does not know
   about it which caused bad output. To get around this, bpxinit was
   incremented so that mtabf was initialized to the default headers.
   This had the side effect of clearing all ISHELL display settings
   and became a problem if a user were to switch back and forth between
   releases. To get around this, bpxinit was changed back to its
   previous version and the mtabf variable changed to mtabf2 for R13.
   This way R13 could inherit the settings from R12 and if going back
   to R12, ISHELL would use the old variable name which has not been
   used in R13. */                                             /*@0UC*/
"VGET (BPXINIT DIRH NOCONF NOEXCONF FLSORT FLSORTS",
      "VDIRFP VDIRFT VDIRFC VDIRFR VDIRFU VDIRFS VDIRVB VDIRENT",
      "MTABF VFSLSN VFSLAM VFSLRO VFSLS1 VFSLS2 VFSLBC VFSLM1 VFSLM2",
      "VFSFST ADDIR ADREG ADCSP ADFIFO ADSYML TPERM VFSUSR",   /*@DOC*/
      "PROF IMAC EDPRF PATHMAIN NOAUTOSK NOPTHMEM VDIRNOM",
      "REFLOFF VDIRPL MTABF2",   /*@0UC@DHC*/
     ") PROFILE"                                          /* @DFC*/
if mtabf2='' then                                              /*@0UA*/
   mtabf2=mtabf                                                /*@0UA*/
if pathmain$<>'' then    /* 2@DHA*/
   pathmain=pathmain$
call setcolors 0
if bpxinit<>2 then                                         /*@0UC@DOA*/
   do
   bpxinit=2                                               /*@0UC@DOA*/
   mtabf2='fsname l 44 <File system name>',                    /*@0UC*/
         'status l 30 <Status>'
   mtfmt='O'
   vdirft='/'
   vdirvb='/'
   flsort='C'
   flsorts='0'
   addir='L'
   adreg='B'
   adcsp='A'
   adfifo='A'
   adsyml='A'
   tperm=600
   dirh=''
   "VPUT (DIRH VDIRFT FLSORT FLSORTS MTFMT MTABF2",            /*@0UC*/
         "ADDIR ADREG ADCSP ADFIFO ADSYML TPERM",
         "PATHMAIN VDIRVB) PROFILE"
   "VPUT (BPXINIT) PROFILE"
   end
if vdirvb='/' then
   pan.p_dir=pan.p_dirlong
fsn=''
stdout=''
stderr=''
vpath01=''
greppath='/bin/grep'
diffpath='/bin/diff'
findpath='/bin/find'
autouid=''    /* 2@DFA*/
autogid=''
if syscalls(on)>4 then
   do
   eno='?'
   rsn=''
   call syscallm 'sysconf 1'
   return
   end
call syscalls 'SIGOFF'
call syscallm 'getuid'
myuid=retval
call syscallm 'geteuid'
myeuid=retval
pw.=''                                        /* 4@0GA*/
call syscallm 'getpwnam' userid() 'pw.'

/*************************************************************** @0NA*/
/* Check return value from getpwnam.  getpwnam returns UID/GID/CWD.  */
/* If no entry exists in the security product data base for the      */
/* passed in userid, getpwnam returns a 0 in RETVAL.                 */
/* If a installation is using secondary USERIDs, the secondary ID    */
/* is not defined to TSO or to the security product; it is           */
/* associated with a primary userid (which is defined to TSO and has */
/* OMVS segment information defined).  In this case, the USERID()    */
/* function returns the secondary userid which is not defined to the */
/* security product.  We must then issue getlogin to get the real    */
/* USERID associated with the secondary userid.  We then pass this   */
/* userid to getpwnam to get the UID information.                    */
/*********************************************************************/
if retval=-1 | retval=0 Then                                  /* @0NA*/
 do                                                           /* @0NA*/
  call syscallm 'getlogin myid'                               /* @0NA*/
  call syscallm 'getpwnam' myid 'pw.'                         /* @0NA*/
 end                                                          /* @0NA*/

inituid=pw.pw_uid
initeuid=pw.pw_uid
userhome=pw.pw_dir      /* 9@DHA*/
reffile=userhome'/.ishell-reflist-'userid()
if refloff<>0 & refloff<>1 then
   refloff=1
if refloff=0 then         /* if ref list is not off in profile */
   do
   refloff=1
   call reflistproc 'on'  /* turn on ref list */
   end
notpriv=1
if myuid=0 then
   do
   call bpxwirac 'special'
   if result=1 then
      notpriv=0
   end
prod.=''
address syscall 'uname prod.'
prodinf=prod.u_sysname prod.u_version'.'prod.u_release
address ispexec "VPUT (PRODINF)"
drop prod.
dfltuser='00'x         /* @06A*/
dfltgroup='00'x        /* @06A*/
pattern.=''  /* @DFA*/
pattern.0=0  /* @DFA*/

/* *** start local time co-process ***/
cmdline='export -p'
pgm=''
ltime.4='*'
call runshcmd
parse var ltimebf 'TZ=' gmt
if gmt='' then
   gmt='GMT'
 else
   do
   gmt=strip(gmt)                /* @0OC*/
   call runcoprocess             /* @DFA*/
   end
ltime.4=''
parse value '' with cmdl1 cmdl2 cmdl3 cmdl4
if pathmain<>'' & nopthmem<>'/' then   /* @DFC*/
   call makevpath pathmain
 else
   pathmain=''

/**********************************************************************/
/* main panel loop                                                    */
/**********************************************************************/
do forever
   sellev=0
   if vpath01='' then
      do
      call syscallm 'getcwd path'
      if retval=-1 then path='/'                                /*@D6C*/
      call makevpath path
      end
   address syscall 'geteuid'
   uidline='EUID='retval
   if debug=1 then
      "CONTROL ERRORS RETURN"
   "REMPOP ALL"
   if debug=1 then
      "CONTROL ERRORS"
   "DISPLAY PANEL("pan.p_main")"
   if rc<>0 then
      if rc>8 | noexconf='/' then
         leave
       else
         do
         "VGET (ZVERB)"
         if ZVERB='RETURN' then
            leave
         "ADDPOP"
         "DISPLAY PANEL("pan.p_exconf")"
         src=rc
         "REMPOP"
         if src=0 then leave
         "VGET (ZVERB)"
         if ZVERB='CANCEL' then
            iterate
         leave
         end
   pathmain=makepath()
   if length(zcmd)>1 & word(zcmd,1)<>'SEL' then
      call main_cmd
    else
      do
      if word(zcmd,1)='SEL' then
         zcmd=word(zcmd,2)
         call main_path
      end
   call makevpath pathmain
end
address ispexec "VPUT (PATHMAIN) PROFILE"  /* @DHM*/
call reflistproc 'save'    /* @DHA*/
if datatype(ltime.0,'W')=1 then
   do
   trace o
   address syscall
   'close' ltime.0
   'close' ltime.1
   'waitpid (ltime.3) st. 0'
   p1='0000000000000000'x
   p2=p1
   p3=p1
   p4=p1
   address linkpgm 'bpx1mpc p1 p2 p3 p4'
   end
return

/**********************************************************************/
/* main panel: runcoprocess                                           */
/************************************************************** 20@DFM*/
runcoprocess:
   address syscall 'pipe pi.'
   address syscall 'pipe po.'
   fd.0=pi.1
   ltime.0=pi.2
   fd.1=po.2
   ltime.1=po.1
   env.0=2
   env.1='TZ='gmt
   env.2='_BPX_SHAREAS=YES'
   prm.0=1
   prm.1='/bin/fomfuish'
   call runopts 'env.'
   address syscall 'spawn (prm.1) 2 fd. prm. env.'
   ltime.3=retval
   if retval=-1 then
      do       /* cannot create coprocess, no time conv 4@DFA*/
      address syscall 'close' ltime.0
      address syscall 'close' ltime.1
      ltime.0=''
      gmt='GMT'
      end
   address syscall 'close' fd.0
   address syscall 'close' fd.1
   return

/**********************************************************************/
/* main panel: command entered                                        */
/**********************************************************************/
main_cmd:
   parse var zcmd zcmd cmdline
   cmd=translate(zcmd)
   zcmd=''
   select
      when cmd='PS' then
         call pscmd

      when cmd='SH' then
         call shcmd cmdline

      when cmd='EX' then
         call shcmd cmdline,1

 /*   when cmd='ABOUT' then
         do
         "SELECT PGM(ISPTUTOR) PARM("pan.p_about")"
         end                                            @DFD*/

      when cmd='ACTHELP' then
         do
         "SELECT PGM(ISPTUTOR) PARM("pan.p_acthelp")"
         end

      when cmd='HLPHELP' then
         do
         "SELECT PGM(ISPTUTOR) PARM("pan.p_hlphelp")"
         end

 /*   when cmd='NEWINFO' then
         do
         "SELECT PGM(ISPTUTOR) PARM("pan.p_hlpnews")"
         end                                           @DFD*/

      when cmd='FLFIELD' then
         do
         "ADDPOP"
         if flsorts='' then     /* 4@P8A*/
            flsortf=flsort
          else
            flsortf='X'
         vdircl=''
         vdirso=''
         "DISPLAY PANEL("pan.p_fields")"
         if rc=0 then
            do
            dirh=''
            if vdirft='/' then
               dirh=dirh 'filetp l 4 <Type>'
            if vdirfp='/' then
               dirh=dirh 'filemd r 4 <Perm>'
            if vdirfr='/' then                        /* @DFA*/
               dirh=dirh 'filemd p 10 <Permission>'   /* @DFA*/
            if vdirfc='/' then
               dirh=dirh 'filecd l 16 <Changed(GMT)>'   /* @P7C*/
            if vdirfu='/' then
               dirh=dirh 'fileusr l 9 <Owner>'
            if vdirfs='/' then
               dirh=dirh 'filesz r 10 <------Size>'
            dirh=dirh 'filenm l 255 <Filename>'
            if vdirso='/' then
               do
               "DISPLAY PANEL("pan.p_dirsort")"
               if rc<>0 then
                  "VGET (FLSORT FLSORTS) PROFILE"
               end
            if vdircl='/' then
               call setcolors 1
            if vdirvb='/' then
               pan.p_dir=pan.p_dirlong
             else
               pan.p_dir=pan.p_dirshort
            "VPUT (DIRH FLSORT FLSORTS VDIRFP VDIRFR VDIRENT VDIRNOM",
                   "VDIRPL", /* @DHM*/
                "VDIRFT VDIRFC VDIRFU VDIRFS VDIRVB) PROFILE"  /* @DFC*/
            end
          else
            "VGET (DIRH FLSORT FLSORTS VDIRFP VDIRFR VDIRENT VDIRNOM",
                   "VDIRPL", /* @DHM*/
                  "VDIRFT VDIRFC VDIRFU VDIRFS) PROFILE"       /* @DFC*/
         "REMPOP"
         end

      when cmd='BPXISHMT' then  /* xx@08A*/
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_mtopts")"
         if rc<>0 then        /* If user canceled out of panel (PF3) */
                                                               /*@0UC*/
            "VGET (MTABF2 VFSLSN VFSLAM VFSLRO VFSLS1 VFSLS2 VFSLBC",
                "VFSLM1 VFSLM2 VFSFST VFSUSR) PROFILE" /*@DPC@DOC@DHC*/
          else
            do
            if mtfmt='O' then                /* Using default display */
               mtabf2='fsname l 44 <File system name>',        /*@0UC*/
                     'status l 30 <Status>'
             else                        /* Using selectable display */
               do
               mtabf2=''                                       /*@0UC*/
               if vfsfst='/' then                     /* 2@DHC*/
                  mtabf2=mtabf2 'type l 4 <Type>'              /*@0UC*/
               if vfslsn='/' then
                  mtabf2=mtabf2 'sysname l 8 <Owner>'          /*@0UC*/
               if vfslam='/' then
                  mtabf2=mtabf2 'am     l 3  <A/M>'            /*@0UC*/
               if vfslro='/' then
                  mtabf2=mtabf2 'ro     l 3  <R/O>'            /*@0UC*/
               if vfslbc='/' then
                  mtabf2=mtabf2 'blkcnt r 9 <I/O Count>'       /*@0UC*/
               if vfsusr='/' then
                  mtabf2=mtabf2 'usercol l 8 <User>'   /*@0UC@DPC@DOC*/
               if vfsls1='/' & vfsls2<>'/' then
                  mtabf2=mtabf2 'status l 12 <Status>'         /*@0UC*/
               if vfsls2='/' then
                  mtabf2=mtabf2 'status l 30 <Status>'         /*@0UC*/
               if vfslm1='/' then
                  mtabf2=mtabf2 'path l 20 <Mount Point>'      /*@0UC*/
               if vfslm2='/' then
                  mtabf2=mtabf2 'path l 60 <Mount Point>'      /*@0UC*/
               mtabf2=mtabf2 'fsname l 44 <File system name>'
               end
                                                               /*@0UC*/
            "VPUT (MTABF2 VFSLSN VFSLAM VFSLRO VFSLS1 VFSLS2 VFSLBC",
                 "VFSUSR VFSLM1 VFSLM2 VFSFST) PROFILE" /*@DPC@DOA@DHC*/
            end
         "REMPOP"
         end

      when cmd='EDOPTS' then
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_edopt")"
         if rc=0 then
            "VPUT (IPLACE PROF IMAC EDPRF) PROFILE"
          else
            "VGET (IPLACE PROF IMAC EDPRF) PROFILE"
         "REMPOP"
         end

      when cmd='MT' then
         call main_filesys

      when cmd='MKFS' then
         call main_mkfs

      when cmd='MKZFS' then
         do
         address tso 'bpxwizfs - newzfs' ltime.0 ltime.1
         end

      when cmd='ZFS' then
         do
         address tso 'bpxwizfs - -' ltime.0 ltime.1
         end

      when cmd='USER' then
         call main_user

      when cmd='ALLUSER' then
         call main_alluser

      when cmd='LSTUSER' then
         call main_lstuser

      when cmd='LSTGROUP' then    /* 2@DHA*/
         call main_lstgrps

      when cmd='GROUP' then
         call main_group

      when cmd='DEV' then
         call main_devsetup makepath()

      when cmd='ROOT' then
         call main_rootsetup makepath()

      when cmd='OMVSSEG' then
         call main_omvsseg

      when cmd='NEWF' then
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_perm")"
         src=rc
         "REMPOP"
         if src=0 then
            do
            "VPUT (TPERM) PROFILE"
            pathname=makepath()
            call syscallm 'open (pathname)',
                          O_WRONLY+O_EXCL+O_CREAT vperm
            if retval<>-1 then
               address syscall 'close' retval
            end
         end

      when cmd='NEWD' then
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_perm")"
         src=rc
         "REMPOP"
         if src=0 then
            do
           "VPUT (TPERM) PROFILE"
            pathname=makepath()
            call syscallm 'mkdir (pathname)' vperm
            end
         end

      when cmd='NEWP' then
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_perm")"
         src=rc
         "REMPOP"
         if src=0 then
            do
           "VPUT (TPERM) PROFILE"
            pathname=makepath()
            call syscallm 'mkfifo (pathname)' vperm
            end
         end

      when cmd='NEWS' then
         do
         pathnm=makepath()
         call makesym
         end

      when cmd='NEWL' then
         do
         pathname=makepath()
         "ADDPOP"
         vtext='L'
         "DISPLAY PANEL("pan.p_getpath")"
         src=rc
         "REMPOP"
         if src=0 then
            do
            lnknm=makepath()
            call syscallm 'link (lnknm) (pathname)'
            end
         end

      when cmd='DEFAULT' then
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_dflts")"
         src=rc
         "REMPOP"
         if src=0 then
            "VPUT (ADDIR ADREG ADCSP ADFIFO ADSYML) PROFILE"
          else
            "VGET (ADDIR ADREG ADCSP ADFIFO ADSYML) PROFILE"
         end

      when cmd='SU' then
         do
         if cmdline<>'' then
            if datatype(cmdline,'W') then
               call syscallm 'setreuid' cmdline cmdline
             else
               do
               pw.=''
               call syscallm 'getpwnam (cmdline) pw.'
               if pw.pw_uid<>'' then
                  call syscallm 'setreuid' pw.pw_uid pw.pw_uid
               end
         else
         if myeuid<>initeuid then
            call syscallm 'setreuid' inituid initeuid
         else
         if myeuid<>0 then
            call syscallm 'setreuid 0 0'
         call syscallm 'getuid'
         myuid=retval
         call syscallm 'geteuid'
         myeuid=retval
         notpriv=1
         if myeuid=0 then
            do
            call bpxwirac 'special'
            if result=1 then
               notpriv=0
            end
         end

      when cmd='BPXACLA' then               /* 2@DAA*/
         call editacl 'acl',makepath()

      when cmd='BPXACLD' then               /* 2@DAA*/
         call editacl 'dir',makepath()

      when cmd='BPXACLF' then               /* 2@DAA*/
         call editacl 'file',makepath()

      when cmd='BPXISHOP' then              /* 2@DFA*/
         call advancedopts

      when cmd='FILTER' then                /* 2@DFA*/
         call setfilter cmdline

      when cmd='REF' then                   /* 6@DHA*/
         do
         call reflistproc cmdline
         if cmdline='' & length(result)>0 then
            pathmain=result
         end

      when cmd='BPXWISHISPF' then                   /* 10@DJA*/
         do
         cmdline=translate(cmdline)
         if cmdline='YES' then
            isp=1
         else
         if cmdline='ALL' then
            isp=2
         else
            isp=0
         end

      otherwise
         "SETMSG MSG("msg.m_invcmd")" msgloc
   end
   return

/**********************************************************************/
/* reflistadd  20@DHA                                                 */
/**********************************************************************/
reflistadd:
procedure expose refloff reffile reflist.
   parse arg path
   if refloff=1 then return
   refix=reflist.0
   do i=1 to refix
      if reflist.i==path then
         leave
   end
   if i>refix then
      i=refix        /* i is entry to delete */
   do j=i to 2 by -1
      k=j-1
      reflist.j=reflist.k
   end
   reflist.1=path
   return

/**********************************************************************/
/* reflistproc  130@DHA                                               */
/**********************************************************************/
reflistproc:
procedure expose refloff reffile o_rdonly reflist. pan. p_usrlst msg.,
                 reflcntl
   arg refopt refparm .
   if refopt='' then
      do
      if refloff=1 then
         do                               /* 4@PIA*/
         "SETMSG MSG("msg.m_invcmd")"
         return ''
         end
      do forever
         s=''
         "TBCREATE REF NOWRITE REPLACE NAMES(S,PATH,FULLPATH,I)"
         do i=1 to reflist.0
            fullpath=reflist.i
            path=fullpath
            "TBADD REF"
         end
         rtnpath=''
         "TBTOP REF"
         "TBDISPL REF CSRROW(1) AUTOSEL(NO) PANEL("pan.p_refltb")"
         svrc=rc
         "TBEND REF"
         if svrc>4 then leave
         if zcmd<>'' then
            do
            "SETMSG MSG("msg.m_invcmd")"
            iterate
            end
         if ztdsels=0 then iterate
         if translate(s)='D' then
            do
            do i=i to reflist.0-1
               j=i+1
               reflist.i=reflist.j
               reflist.j=''
            end
            iterate
            end
         if translate(s)='S' | s='/' then
            do
            rtnpath=fullpath
            leave
            end
         "SETMSG MSG("msg.m_invcmd")"
      end
      return rtnpath
      end

   if refopt='ON' then
      do
      if refparm='' then
         refparm=0
      if datatype(refparm,'W')<>1 then
         do
         "SETMSG MSG("msg.m_badnum")"       /* @PIC*/
         return
         end
      if refparm>64 then
         do                                 /* 4@PIA*/
         "SETMSG MSG("msg.m_badnum")"
         return
         end
      if refloff=0 then
         call reflistproc 'off'
      reflist.=''
      address syscall 'open (reffile)' o_rdonly
      fd=retval
      refix=0
      if fd<>-1 then
         do forever
            reflistarea=''
            address syscall 'read (fd) reflistarea' 1024
            if retval<>1024 then
               do                /* 5@PIA*/
               if refix>0 then
                  refix=refix-1
               leave
               end
            parse var reflistarea reflist.refix '00'x
            if refparm>0 & refix=refparm then  /* max entries hit */
               leave
            refix=refix+1
         end
      if fd<>-1 then
         address syscall 'close (fd)'
      if refix=0 then
         do
         refix=16     /* set default number of entries if no list */
         reflcntl=''
         end
       else
         reflcntl=reflist.0
      if refparm=0 then
         reflist.0=refix
       else
         reflist.0=refparm
      refloff=0
      "VPUT (REFLOFF) PROFILE"
      end
   else
   if refopt='OFF' then
      do
      call reflistproc 'save'
      drop reflist.
      refloff=1
      "VPUT (REFLOFF) PROFILE"
      end
   else
   if refopt='SAVE' then
      do
      if refloff=1 then return
      address syscall 'unlink (reffile)'
      call syscallm 'creat (reffile) 400'
      fd=retval
      if fd<>-1 then
         do
         refix=reflist.0
         reflist.0=reflcntl
         do i=0 to refix
            refbuf=reflist.i || copies('00'x,1024)
            call syscallm 'write (fd) refbuf 1024'
            if retval=-1 then leave
         end
         reflist.0=refix
         address syscall 'close (fd)'
         end
      end
   else
   if refopt='CLEAR' then
      do
      if refloff=1 then return
      do i=1 to reflist.0
         reflist.i=''
      end
      end
   else
      do
      "SETMSG MSG("msg.m_invcmd")"
      end
   return

/**********************************************************************/
/* advancedops                                                        */
/**********************************************************************/
advancedopts:

   if refloff=1 then   /* 4@DHA*/
      reflset=''
    else
      reflset='/'
   "ADDPOP"
   "DISPLAY PANEL("pan.p_adops")"
   prc=rc
   "REMPOP"
   if prc<>0 then
      do
      "VGET (TPLACE NOCONF NOEXCONF NOAUTOSK NOPTHMEM) PROFILE"
      return
      end

   "VPUT (NOCONF NOEXCONF NOAUTOSK NOPTHMEM) PROFILE"
   if tplace='INHERIT' then
      do
      'VERASE (ZPLACE) PROFILE'
      'VERASE (ZPLACE) SHARED'
      "VPUT (TPLACE) PROFILE"
      end
   else
     do
     zplace=tplace
     "VPUT (TPLACE ZPLACE) PROFILE"
     end
   if reflset='/' & refloff=1 then       /* 5@DHA*/
      call reflistproc 'on'
   else
   if reflset<>'/' & refloff=0 then
      call reflistproc 'off'
   return

/**********************************************************************/
/* main panel: path specified                                         */
/**********************************************************************/
main_path:
   path=pathmain
   if path='' then
      do
      call syscallm 'getcwd path'
      if retval=-1 then return
      call makevpath path
      pathmain=path
      xcmd=zcmd
      "CONTROL DISPLAY LOCK"
      "DISPLAY PANEL("pan.p_main")"
      zcmd=xcmd
      end
   call syscalle ENOENT 'lstat (path) st.'
   if retval=-1 then
      do
      parse upper var errnojr +8 -4 errnojr
      if errno=ENOENT then
         if errnojr<>jrnodir & (zcmd='' | zcmd='N' | zcmd='n') then
            call main_create
          else
            call syscallm 'lstat (path) st.'
      end
    else
      select
         when st.st_type=s_isdir then
            if zcmd='' then
               call path_dir addir
             else
               call path_dir zcmd
         when st.st_type=s_ischr then
            if zcmd='' then
               call path_chr adcsp
             else
               call path_chr zcmd
         when st.st_type=s_isreg then
            if zcmd='' then
               call path_reg adreg
             else
               call path_reg zcmd
         when st.st_type=s_isfifo then
            if zcmd='' then
               call path_fifo adfifo
             else
               call path_fifo zcmd
         when st.st_type=s_issym then
            if zcmd='' then
               call path_sym adsyml
             else
               call path_sym zcmd
         otherwise
   end
   return

/**********************************************************************/
/* main panel: mkfs specified                                         */
/**********************************************************************/
main_mkfs:
   "ADDPOP"
   do forever
      "DISPLAY PANEL("pan.p_mkfs")"
      if rc<>0 then leave
      fsn=strip(fsn,'B',"'")
      if sysdsn("'"fsn"'")='OK' then
         do
         "SETMSG MSG("msg.m_dupfs")" msgloc
         iterate
         end
      clas=''
      if storclas<>'' then
         clas=clas 'storclas('storclas')'
      if dataclas<>'' then
         clas=clas 'dataclas('dataclas')'
      if mgmtclas<>'' then
         clas=clas 'mgmtclas('mgmtclas')'
      if volser<>'' then
         clas=clas 'vol('volser')'
      if unit<>'' then
         clas=clas 'unit('unit')'
      cmd="alloc da('"fsn"') dsntype(hfs)",
          "space("fspri","fssec") dir(1) cyl new" clas
      xx=outtrap(off)
      address tso cmd
      if rc<>0 then
         do
         say translate(cmd)
         "SETMSG MSG("msg.m_alloc")" msgloc
         iterate
         end
       else
         address tso "free da('"fsn"')"
      leave
   end
   "REMPOP"
   return

/* mkzfs moved to bpxwizfs xx@DDD*/

/**********************************************************************/
/* main panel: file system specified                                  */
/**********************************************************************/
main_filesys:
   first=1
   selrow=1
   sellev=1
   if mtabf2='' then                                      /*@0UC3@08A*/
      mtabf2='fsname l 44 <File system name>',                 /*@0UC*/
             'status l 30 <Status>'
   alcurcmd=1
   do forever
      call filesystable
      x=actionlist('MTAB',first,selrow,pan.p_mt,mtabf2)        /*@0UC*/
      if x=0 & zverb<>'' then
         leave
      first=selrow.sel_top
      selrow=selrow.sellev.x
      "TBTOP MTAB"
      do forever
         "TBSKIP MTAB"
         if rc<>0 then leave
         if s='' | s='_' then iterate
         call filesys_cmd s
      end
   end
   "TBEND MTAB"
   return

/**********************************************************************/
/* main panel: create character special files                         */
/**********************************************************************/
main_devsetup:
   parse arg path
   if path='' then
      path='/dev'
   "ADDPOP"
   devtty='/'
   devnull='/'
   devcons='/'
   ptys=100
   call syscallm 'sysconf' sc_open_max
   if retval=-1 | retval>9999 then
      fds=9999
    else
      fds=retval
   "DISPLAY PANEL("pan.p_dev")"
   src=rc
   "REMPOP"
   if src<>0 then return
   do i=0 to ptys-1
      ix=right(i,4,'0')
      call devsysc 'ptyp'ix 1 i
      if retval<0 then return
      call devsysc 'ttyp'ix 2 i
      if retval<0 then return
   end
   if devtty='/' then
      call devsysc 'tty' 3 0
   if retval<0 then return
   if devnull='/' then
      call devsysc 'null' 4 0
   if retval<0 then return
   if devcons='/' then
      do
      call devsysc 'console' 9 0
      call syscallm 'chmod (pathnm) 222'
      end
   if retval<0 then return
   do i=0 to fds-1
      call devsysc 'fd'i 5 i
      if retval<0 then return
   end
   return

devsysc:
   parse arg nm mjr mnr
   pathnm=path'/'nm
   call syscalle EEXIST 'mknod (pathnm)' 666 mjr mnr
   if retval=-1 & errno=EEXIST then
      retval=0
   return

/**********************************************************************/
/* main panel: root - build dirs found in root                        */
/**********************************************************************/
main_rootsetup:
   parse arg path
   if path='' then
      path='/'
   "ADDPOP"
   dir1='/'
   dir2='/'
   dir3='/'
   dir4='/'
   dir5='/'
   dir6='/'
   dir7='/'
   dodev='/'
   "DISPLAY PANEL("pan.p_root")"
   src=rc
   "REMPOP"
   if src<>0 then return
   call syscallm 'chmod (path) 755'
   if retval=-1 then return
   call syscallm 'getgid'
   gid=retval
   call syscallm 'getuid'
   uid=retval
   call syscallm 'chown (path)' uid gid
   if retval=-1 then return
   if dir1='/' then
      do
      call mdsysc 'dev'
      if retval=-1 then return
      end
   if dir2='/' then
      do
      call mdsysc 'bin'
      if retval=-1 then return
      call mdsysc 'bin/IBM'
      if retval=-1 then return
      end
   if dir3='/' then
      do
      call mdsysc 'usr'
      if retval=-1 then return
      call mdsysc 'usr/mail'
      if retval=-1 then return
      address syscall 'chmod (pathnm) 777' /* mailx seems to need this*/
      call mdsysc 'usr/man'
      if retval=-1 then return
      call mdsysc 'usr/man/C'
      if retval=-1 then return
      call mdsysc 'usr/man/C/cat1'
      if retval=-1 then return
      call mdsysc 'usr/man/C/cat1/IBM'
      if retval=-1 then return
      call mdsysc 'usr/man/C/IBM'
      if retval=-1 then return
      call mdsysc 'usr/man/Ja_JP'
      if retval=-1 then return
      call mdsysc 'usr/man/Ja_JP/cat1'
      if retval=-1 then return
      call mdsysc 'usr/man/Ja_JP/cat1/IBM'
      if retval=-1 then return
      call mdsysc 'usr/man/Ja_JP/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lib'
      if retval=-1 then return
      call mdsysc 'usr/lib/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/charmap'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/charmap/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/locale'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/locale/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/localedef'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/localedef/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/msg'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/msg/C'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/msg/C/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/msg/Ja_JP'
      if retval=-1 then return
      call mdsysc 'usr/lib/nls/msg/Ja_JP/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lib/cron'
      if retval=-1 then return
      call mdsysc 'usr/lib/cron/IBM'
      if retval=-1 then return
      call mdsysc 'usr/include'
      if retval=-1 then return
      call mdsysc 'usr/include/IBM'
      if retval=-1 then return
      call mdsysc 'usr/include/sys'
      if retval=-1 then return
      call mdsysc 'usr/include/sys/IBM'
      if retval=-1 then return
      call mdsysc 'usr/include/net'
      if retval=-1 then return
      call mdsysc 'usr/include/net/IBM'
      if retval=-1 then return
      call mdsysc 'usr/include/netinet'
      if retval=-1 then return
      call mdsysc 'usr/include/netinet/IBM'
      if retval=-1 then return
      call mdsysc 'usr/include/arpa'
      if retval=-1 then return
      call mdsysc 'usr/include/arpa/IBM'
      if retval=-1 then return
      call mdsysc 'usr/lpp'
      if retval=-1 then return
      call mdsysc 'usr/sbin'
      if retval=-1 then return
      call mdsysc 'usr/sbin/IBM'
      if retval=-1 then return
      call mdsysc 'usr/share'
      if retval=-1 then return
      call mdsysc 'usr/share/lib'
      if retval=-1 then return
      call mdsysc 'usr/share/lib/terminfo'
      if retval=-1 then return
      call mdsysc 'usr/share/lib/terminfo/IBM'
      if retval=-1 then return
      call mdsysc 'usr/spool'
      if retval=-1 then return
      call mdsysc 'usr/spool/cron'
      if retval=-1 then return
      call mdsysc 'usr/spool/cron/atjobs'
      if retval=-1 then return
      call mdsysc 'usr/spool/cron/crontabs'
      if retval=-1 then return
      address syscall 'unlink usr/lib/terminfo'
      pathnm=path'/usr/lib/terminfo'
      call syscallm 'symlink ../share/lib/terminfo (pathnm)'
      end
   if dir4='/' then
      do
      call mdsysc 'etc'
      if retval=-1 then return
      call mdsysc 'samples'        /* samples is in root */
      if retval=-1 then return
      call mdsysc 'samples/IBM'
      if retval=-1 then return
      end
   if dir5='/' then
      do
      call mdsysc 'tmp'
      if retval=-1 then return
      end
   if dir6='/' then
      do
      call mdsysc 'u'
      if retval=-1 then return
      end
   if dir7='/' then
      do
      call mdsysc 'lib'
      if retval=-1 then return
      end
   if dodev='/' then
      call main_devsetup strip(path,'T','/')'/dev'
   return

mdsysc:
   parse arg nm
   pathnm=path'/'nm
   call syscalle EEXIST 'mkdir (pathnm)' 755
   if retval=-1 & errno=EEXIST then
      retval=0
   return

/**********************************************************************/
/* main panel: implicit create                                        */
/**********************************************************************/
main_create:
   call dir_create
   return

/**********************************************************************/
/* main panel: omvsseg specified                                      */
/**********************************************************************/
main_omvsseg:
   "ADDPOP"
   "DISPLAY PANEL("pan.p_segauth")"
   src=rc
   "REMPOP"
   if src<>0 then return
   call bpxwirac 'omvsseg'
   return

/**********************************************************************/
/* main panel: user specifed                                          */
/**********************************************************************/
getdfltuser:                   /* 15@06A*/
   numeric digits 12
   dfltuser.=''
   dfltgroup.=''
   tcb=c2d(storage('21c',4))
   stcb=c2d(storage(d2x(tcb+x2d(138)),4))
   otcb=c2d(storage(d2x(stcb+x2d('d8')),4))
   oapb=c2d(storage(d2x(otcb+x2d('64')),4))
   oapblen=c2d(storage(d2x(oapb+5),3))
   if oapblen<256 then return
   dfltuser=storage(d2x(oapb+x2d(101)),8)
   dfltgroup=storage(d2x(oapb+x2d('10a')),8)
   if substr(dfltuser,1,1)<>'00'x then
      address syscall 'getpwnam (dfltuser) dfltuser.'
   if substr(dfltgroup,1,1)<>'00'x then
      address syscall 'getgrnam (dfltgroup) dfltgroup.'
   return

main_user:
   "ADDPOP"
   user=userid()
   group=''
   home=''
   program=''
   fsn=''
   do forever
      mkfsok=0
      "DISPLAY PANEL("pan.p_usere")"
      if rc<>0 then leave
      lcuser=translate(user,'abcdefghijklmnopqrstuvwxyz',,
                            'ABCDEFGHIJKLMNOPQRSTUVWXYZ')
      if fsn='' then
         mode=700
       else
         mode=500
      address syscall 'getpwnam (user) pw.'                    /* @02M*/
      retval2 = retval                                         /* @M0A*/
      if substr(dfltuser,1,1)='00'x then      /* @06A*/
         call getdfltuser                     /* @06A*/
      if retval2>0 &                   ,                       /* @0MC*/
         pw.pw_uid<>dfltuser.pw_uid &  ,                       /* @06C*/
         datatype(pw.pw_uid,W) then                            /* @0MA*/
         call usersetup mode
      else                                                     /* @02A*/
      if retval=-1 | errno=emvssaf2err then                    /* @02A*/
         msgid=msg.m_baduid                                    /* @02A*/
       else
         do
         uid=nextuid()
         if uid<0 then
            msgid=msg.m_nouids
          else
            call usersetup mode uid
         end
         if sfstype=1 then pfs='HFS'
         else
         if sfstype=2 then pfs='ZFS'
         else
            pfs=''
         if msgid=msg.m_defusr & pfs<>'' then
            do
            pw.=''
            address syscall 'getpwnam (user) pw.'
            group=pw.pw_gid
            "SETMSG MSG("msgid")" msgloc
            if pfs='HFS' then call main_mkfs
            else
            if pfs='ZFS' then
               address tso 'bpxwizfs - newzfs' ltime.0 ltime.1 /* @PIC*/
            end
         if msgid=msg.m_defusr & pfs<>'' & mkfsok<>-1 then
            do
            call syscallm 'mount (pwdir) (fsn)' pfs '(mtm_rdwr)'
            if pfs='HFS' then
            if retval=-1 then
               do
               address syscall 'stat (pwdir) st.'
               drop mt.
               if retval<>-1 then
                  address syscall 'getmntent mt.' x2d(st.st_dev)
               if fsn=mt.mnte_fsname.1 then
                  address syscall 'chown (pwdir)' pwuid pwgid
                else
                  iterate
               end
             else
               address syscall 'chown (pwdir)' pwuid pwgid
            end
      if mkfs<>-1 then
         "SETMSG MSG("msgid")" msgloc
   end
   "REMPOP"
   return

/**********************************************************************/
/* main panel: alluser specified                                      */
/**********************************************************************/
main_alluser:
   nxuid=nextuid()-1
   if nxuid<0 then
      do
      "SETMSG MSG("msg.m_nouids")" msgloc
      return
      end
   call bpxwirac 'users'
   do ix=1 by 1 while queued()>0
      pull cmdusr.ix .
   end
   cmdusr.0=ix-1
   group=''
   hpref='/u'
   program='/bin/sh'
   dogroups=1
   "ADDPOP"
   do forever
      "DISPLAY PANEL("pan.p_alluser")"
      if rc<>0 then leave
      temp=hpref'/'
      call syscallm 'access (temp)' x_ok   /* @0DC*/
      if retval=-1 then iterate
      if dogroups then
         if main_group() then
            do
            dogroups=0
            "VGET (ZVERB)"
            if zverb<>'CANCEL' then
               leave
             else
               iterate
            end
      do ix=1 to cmdusr.0
         user=cmdusr.ix
         lcuser=translate(user,'abcdefghijklmnopqrstuvwxyz',,
                               'ABCDEFGHIJKLMNOPQRSTUVWXYZ')
         home=hpref'/'lcuser
         pw.=''
         address syscall 'getpwnam (user) pw.'
         if pw.pw_uid<>'' then
            iterate
         nxuid=nxuid+1
         call usersetup 700 nxuid
         "SETMSG MSG("msgid")" msgloc
         if msgid<>msg.m_baduid then
            "CONTROL DISPLAY LOCK"
         "DISPLAY PANEL("pan.p_alluser")"
         if rc<>0 then
            leave
      end
      leave
   end
   "REMPOP"
   return

/**********************************************************************/
/* main panel: lstuser specified                                      */
/**********************************************************************/
main_lstuser:
   numeric digits 10
   "ADDPOP ROW(5) COLUMN(20)"
   "CONTROL DISPLAY LOCK"
   "DISPLAY PANEL("pan.p_usrlstm")"
   "REMPOP"
   call bpxwirac 'users'
   do ix=1 by 1 while queued()>0
      pull cmdout.ix .
   end
   cmdout.0=ix-1
   gid.gr_members=0
   gid.0=1
   j=gr_mem
   do i=1 to cmdout.0
      gid.gr_members=gid.gr_members+1
      gid.j=cmdout.i
      j=j+1
   end
   "TBCREATE USR NOWRITE REPLACE",
      "NAMES(S,USER,UID,GID,HDIR,IPGM,LOCATE)"
   "TBSORT USR FIELDS(USER,C,A)"
   s=''
   locate=''
   grps.=''
   do j=gr_mem to gr_mem + gid.gr_members -1
      pw.=''
      address syscall 'getpwnam (gid.j) pw.'
      user=gid.j
      hdir=pw.pw_dir
      ipgm=pw.pw_shell
      uid=pw.pw_uid
      gid=pw.pw_gid
      if datatype(uid,'W')<>1 then
         uid=-1
      if datatype(gid,'W')<>1 then
         gid=-1
      if gid>-1 then
         if grps.gid='' then
            do
            gr.=''
            address syscall 'getgrgid' gid 'gr.'
            grps.gid=gr.gr_name
            gid=gr.gr_name
            end
          else
            gid=grps.gid
       else
         gid=''
      "TBADD USR ORDER"
   end
   table.0=ix
   usrsortv="USER,C,A"
   do forever
      "TBTOP USR"
      zcmd=''
      "TBDISPL USR PANEL("pan.p_usrlst")"
      if rc<>0 then leave
      select
        when zcmd='' then
           nop
        when zcmd='SORTN' then
          "TBSORT USR FIELDS(USER,C,A)"
        when zcmd='SORTU' then
          "TBSORT USR FIELDS(UID,N,A)"
        when zcmd='SORTG' then
          "TBSORT USR FIELDS(GID,C,A)"
        when zcmd='PRNT' then
           do
           hdr1=''
           hdr2=time() date() L#userl
           hdr3=''
           hdr4=left(L#user,8),
                right(L#uid,9),
                ' 'left(L#gid,8),
                left(L#hd,40),
                left(L#ip,40)
           hdr0=4
           'TBTOP USR'
           call print_hdr 1
           do forever
              'TBSKIP USR'
              if rc<>0 then
                 leave
              "VGET (ZLSTNUML)"
              if zlstlpp=zlstnuml then
                 call print_hdr pg+1
              ln=left(user,8),
                 right(uid,9),
                 right(gid,9),
                 left(hdir,40),
                 left(ipgm,40)
              'LIST BUFNAME(LN) LINELEN('length(ln)')'
           end
           'SETMSG MSG('msg.m_printed')'
           end
        otherwise
           "SETMSG MSG("msg.m_invcmd")" msgloc
      end
   end
   return

/**********************************************************************/
/* main panel: lstgrps specified                                      */
/************************************************************** 60@DHA*/
main_lstgrps:
   numeric digits 10
   call bpxwirac 'omvsgroup'
   do ix=1 by 1 while queued()>0
      pull cmdout.ix cmdout.ix.1 .
   end
   cmdout.0=ix-1
   "TBCREATE GRP NOWRITE REPLACE",
      "NAMES(S,GROUP,GID,LOCATE)"
   "TBSORT GRP FIELDS(GROUP,C,A)"
   s=''
   locate=''
   do i=1 to cmdout.0
      group=cmdout.i
      gid=cmdout.i.1
      locate=group
      "TBADD GRP ORDER"
   end
   do forever
      "TBTOP GRP"
      zcmd=''
      "TBDISPL GRP PANEL("pan.p_grplst")"
      if rc<>0 then leave
      select
        when zcmd='' then
           nop
        when zcmd='SORTN' then
          "TBSORT GRP FIELDS(GROUP,C,A)"
        when zcmd='SORTG' then
          "TBSORT GRP FIELDS(GID,N,A)"
        when zcmd='PRNT' then
           do
           hdr1=''
           hdr2=time() date() 'Group list'
           hdr3=''
           hdr4=left('Group',8),
                right('GID',10)
           hdr0=4
           'TBTOP GRP'
           call print_hdr 1
           do forever
              'TBSKIP GRP'
              if rc<>0 then
                 leave
              "VGET (ZLSTNUML)"
              if zlstlpp=zlstnuml then
                 call print_hdr pg+1
              ln=left(group,8),
                 right(gid,10)
              'LIST BUFNAME(LN) LINELEN('length(ln)')'
           end
           'SETMSG MSG('msg.m_printed')'
           end
        otherwise
           "SETMSG MSG("msg.m_invcmd")" msgloc
      end
   end
   return

/**********************************************************************/
/* main panel: group specifed                                         */
/**********************************************************************/
main_group:
   grp.0=0
   highgid=0
   "ADDPOP"
   "DISPLAY PANEL("pan.p_grp")"
   if rc<>0 then
      do
      "REMPOP"
      return 1
      end
   if autogid='' then         /* 3@DFA*/
      if checkautoid() then
         return 1
   call bpxwirac 'omvsgroup'
   do ix=1 by 1 while queued()>0
      pull cmdout.ix
   end
   cmdout.0=ix-1
   do i=1 to cmdout.0
      parse var cmdout.i grp.i gid .
      if datatype(gid,'W') then
         if gid>highgid then
            highgid=gid
   end
   grp.0=cmdout.0
   do i=1 to grp.0
      address syscall 'getgrnam (grp.i) gr.'
      if retval=0 then
         do
         grname=grp.i
         if autogid=1 then      /* 3@DFA*/
            gid='AUTOGID'
          else
            gid=highgid+1
         "SETMSG MSG("msg.m_grsetup")" msgloc
         "CONTROL DISPLAY LOCK"
         "DISPLAY PANEL("pan.p_grp")"
         if autogid=1 then                                   /* 3@DFA*/
            call bpxwirac 'altgroup' grp.i 'omvs(autogid)'
          else
            call bpxwirac 'altgroup' grp.i 'omvs(gid('highgid+1'))'
         if result=0 & autogid=0 then                        /* @DFC*/
            highgid=highgid+1
         end
   end
   "REMPOP"
   return 0

/**********************************************************************/
/* path selection: file selected is directory                         */
/**********************************************************************/
path_dir:
arg selcode,fromsl
   if selcode<>'' then
      vactc=selcode
    else
      do
      "ADDPOP COLUMN(20) ROW(1)"
      src=popobj(pan.p_sdir)
      "REMPOP"
      if src<>0 then return 0
      end
   select
      when vactc='L' then call dir_list
      when vactc='N' then call dir_create
      when vactc='A' then call dir_settings
      when vactc='D' then call dir_delete
      when vactc='R' then call dir_rename
      when vactc='C' then call dir_copy
      when vactc='I' then call dir_replace
      when vactc='P' then call dir_print
      when vactc='M' then call dir_compare
      when vactc='F' then call dir_find
      when vactc='W' then call dir_cwd
      when vactc='O' then call dir_mount
      when vactc='U' then call fsattr
      when vactc='X' then call linecmd
      otherwise
        if fromsl<>'' then return 1   /* @0BA*/
        if selcode<>'' then call path_dir
   end
   return 0

/**********************************************************************/
/* path selection: file selected is char special                      */
/**********************************************************************/
path_chr:
arg selcode,fromsl
   if selcode<>'' then
      vactc=selcode
    else
      do
      "ADDPOP COLUMN(20) ROW(1)"
      src=popobj(pan.p_scsp)
      "REMPOP"
      if src<>0 then return 0
      end
   select
      when vactc='A' then call chr_settings
      when vactc='D' then call chr_delete
      when vactc='R' then call chr_rename
      otherwise
        if fromsl<>'' then return 1   /* @0BA*/
        if selcode<>'' then call path_chr
   end
   return 0

/**********************************************************************/
/* path selection: file selected is regular file                      */
/**********************************************************************/
path_reg:
arg selcode,fromsl
   if selcode<>'' then
      vactc=selcode
    else
      do
      "ADDPOP COLUMN(20) ROW(1)"
      src=popobj(pan.p_sreg)
      "REMPOP"
      if src<>0 then return 0
      end
   select
      when vactc='B' then call reg_brtext
      when vactc='V' then call reg_brrecs
      when vactc='E' then call reg_edit
      when vactc='G' then call reg_edit
      when vactc='A' then call reg_settings
      when vactc='D' then call reg_delete
      when vactc='R' then call reg_rename
      when vactc='C' then call reg_copy
      when vactc='I' then call reg_replace
      when vactc='P' then call reg_print
      when vactc='M' then call reg_compare
      when vactc='F' then call reg_find
  /*  when vactc='X' then call reg_run */
      when vactc='U' then call fsattr
      when vactc='X' then call linecmd
      otherwise
        if fromsl<>'' then return 1   /* @0BA*/
        if selcode<>'' then call path_reg
   end
   return 0

/**********************************************************************/
/* path selection: file selected is fifo                              */
/**********************************************************************/
path_fifo:
arg selcode,fromsl
   if selcode<>'' then
      vactc=selcode
    else
      do
      "ADDPOP COLUMN(20) ROW(1)"
      src=popobj(pan.p_sfifo)
      "REMPOP"
      if src<>0 then return 0
      end
   select
      when vactc='A' then call fifo_settings
      when vactc='D' then call fifo_delete
      when vactc='R' then call fifo_rename
      otherwise
        if fromsl<>'' then return 1   /* @0BA*/
        if selcode<>'' then call path_fifo
   end
   return 0

/**********************************************************************/
/* path selection: file selected is symlink                           */
/**********************************************************************/
path_sym:
arg selcode
   if selcode<>'' then
      vactc=selcode
    else
      do
      "ADDPOP COLUMN(20) ROW(1)"
      src=popobj(pan.p_ssym)
      "REMPOP"
      if src<>0 then return
      end
   select
      when vactc='A' then call sym_settings
      when vactc='D' then call sym_delete
      when vactc='R' then call sym_rename
      otherwise
        call syscallm 'stat (path) st.'
        result=0
        select
           when st.st_type=s_isdir then
              call path_dir selcode,1
           when st.st_type=s_ischr then
              call path_chr selcode,1
           when st.st_type=s_isreg then
              call path_reg selcode,1
           when st.st_type=s_isfifo then
              call path_fifo selcode,1
           otherwise
        end
        if result=1 then call path_sym   /* @0BA*/
   end
   return

/**********************************************************************/
/* directory panel: file list selected                                */
/**********************************************************************/
dir_list:
   if vdirpl<>'/' then        /* 2@DHA*/
   do
   address syscall 'realpath (path) dlpath'
   if rc>=0 & retval<>-1 then
      path=dlpath
   end
   if substr(path,length(path))<>'/' then
      path=path'/'
   /* if native ispf selected just call ispf dirlist and return 8@DJA*/
   if isp>1 then
      do
      'dirlist path(path)'
      if rc>8 then
        'SETMSG MSG('zerrmsg')'
      return
      end

   selrow=1
   first=1
   sellev=1
   level=0
   alcurcmd=1
   row.=''
   if substr(path,length(path))='/' then
      path.level=path
    else
      path.level=path'/'
   first.level=selrow
   row.level=first
   if dirh='' then
      dirh='filetp l 4 <Type>',
           'filenm l 255 <Filename>'

   /* direxit:   loop control */
   do direxit=1
      if debug=2 then
         do
         say 'direxit loop level='level
         trace ?i
         end
      if level<0 then leave direxit
      path=path.level
      call reflistadd path        /* @DHA */
      nxlevel=level+1
      row.nxlevel=''
      if dir_mktable() then        /* build/rebuild the dir list */
         do
         level=level-1  /* backup one level on error */
         iterate
         end
      "TBTOP DIR"

      /* dirloop:   loop control */
      do dirloop=1
         first=first.level
         selrow=row.level
         row=row.level
         path=path.level
         sellev=level
         x=actionlist('DIR',first,selrow,pan.p_dir,dirh,path,1)
         if debug=2 then trace ?i
         if x=0 then
            if zverb='EXIT' | zverb='RETURN' then
               leave direxit
            else
            if zverb='CANCEL' then  /* @DFC*/
               do
               level=level-1  /* backup one level on cancel */
               iterate direxit
               end
            else
            if word(zverb,1)='REFRESH' then      /* 3@DHA*/
               iterate direxit
            else
            if word(zverb,1)='FILTER' then      /* 6@DFA*/
               do
               call setfilter substr(zverb,8)
               iterate direxit
               end
            else
            if word(zverb,1)='EMPTY' then      /* 10@DFA*/
               do
               if pattern.0=0 then
                  level=level-1       /* treat as cancel if no filter */
                else
                  do
                  call setfilter '*'  /* remove filter and refresh */
                  'SETMSG MSG('msg.m_rmfilt')'    /* @PIA*/
                  end
               iterate direxit
               end
            else
            if selrow.sellev.0=0 & word(zverb,1)='SELECT' then
               do
               call dir_cursel
               if row.nxlevel<>'' then
                  do
                  level=level+1
                  first.level=1                /* @0EA*/
                  iterate direxit
                  end
               end
         first=selrow.sel_top
         first.level=first
         row.level=selrow
         do selix=1 to selrow.sellev.0
            "TBTOP DIR"
            selnum=selrow.sellev.selix
            selrow=selnum
            row.level=selrow
            "TBSKIP DIR NUMBER("selnum")"
            if s='' | s='_' then iterate
            else
            if absel<>'' & s='/' then
               s=absel
            selval=s
            s='_'
            "TBPUT DIR"
            selval=translate(selval)
            if filetpn=1 then
               if selval='S' | selval='/' then
                  selval=addir
            if filenm\=='.' | selval<>'L' then
               do
               path=pathnm
               call makevpath pathnm
               end
            select
               when filetpn=1 then
                  do
                  if selval='S' | selval='/' then
                     selval=addir
                  src=0                          /* 10@0EA*/
                  /* if selval not a valid dir command then prompt */
                  if pos(selval,'LNADRCIPMFWOUX')=0 then
                     do
                     "ADDPOP COLUMN(20) ROW(1)"
                     vactc=''
                     src=popobj(pan.p_sdir)
                     "REMPOP"
                     selval=vactc
                     end
                  if src=0 then
                   if selval<>'L' then
                     call path_dir selval
                   else
                     if row.nxlevel='' then
                        do
                        if vdirpl<>'/' then        /* 2@DHA*/
                        do
                        address syscall 'realpath (pathnm) dlpath'
                        if rc>=0 & retval<>-1 then
                           pathnm=dlpath
                        end
                        if substr(pathnm,length(pathnm))<>'/' then
                           pathnm=pathnm'/'
                        path=pathnm
                        path.nxlevel=pathnm
                        row.nxlevel=0
                        alcurcmd=1
                        first.nxlevel=first.level
                        end
                  end
               when filetpn=2 then
                  do
                  if selval='S' | selval='/' then
                     selval=adcsp
                  call path_chr selval
                  end
               when filetpn=3 then
                  do
                  if selval='S' | selval='/' then
                     selval=adreg
                  call path_reg selval
                  end
               when filetpn=4 then
                  do
                  if selval='S' | selval='/' then
                     selval=adfifo
                  call path_fifo selval
                  end
               when filetpn=5 then
                  do
                  if selval='S' | selval='/' then
                     selval=adsyml
                  if selval<>'L' then
                     call path_sym selval
                  else
                     do                                      /* 9@0KA*/
                     address syscall 'realpath (pathnm) dlpath'
                     rprc = rc
                     rpretval = retval
                     drop tmpst.
                     address syscall 'lstat (dlpath) tmpst.'
                     if tmpst.st_type<>s_isdir then
                       call path_sym
                     else
                       if row.nxlevel='' then
                          do
                          if vdirpl<>'/' then      /* 2@DHA*/
                          do
                          if rprc>=0 & rpretval<>-1 then
                             pathnm=dlpath
                          end
                          if substr(pathnm,length(pathnm))<>'/' then
                             pathnm=pathnm'/'
                          path=pathnm
                          path.nxlevel=pathnm
                          row.nxlevel=0
                          alcurcmd=1
                          first.nxlevel=first.level
                          end
                     end                                      /* @0KA*/
                  end
               otherwise
                  call syscallm 'stat (path) st.'
            end
            /* the following will show progress on multiple selections
               if the no continue option is selected.  In general the
               progress message will not show.  This is done so that
               a blank message can conditionally be displayed to
               detect if the selected function did issue a message.
               In that case this will stop the multiselection
               processing and show the path in error */
            if vdirnom='/' & selrow.sellev.0>1 then   /* 25@DFA*/
               do
               'SETMSG MSG('msg.m_blank') COND'
               if rc=4 then
                  do
                  if length(filenm)>70 then
                     do
                     tempnm=filenm
                     filenm='<<' substr(filenm,length(filenm)-67)
                     end
                   else
                     tempnm=''
                  'ADDPOP'
                  'DISPLAY PANEL('pan.p_multe')'
                  'REMPOP'
                  if length(tempnm)>0 then
                     filenm=tempnm
                  leave selix
                  end
               'ADDPOP'
               'CONTROL DISPLAY LOCK'
               'DISPLAY PANEL('pan.p_multi')'
               'REMPOP'
               end
         end     /* end selix */
         /* if staying on this level and
             null enter does not refresh then iterate dirloop  @DFC*/
         if selrow.sellev.0=0 & row.nxlevel='' & vdirent<>'/' then
            iterate dirloop
         if row.nxlevel<>'' then
            do
            level=level+1
            first.level=1               /* @0EA*/
            end
         iterate direxit
      end
      if level>=0 then
         call makevpath path
   end
   return

dir_mktable:
         st.=''
         s='_'
         parse value '' with filetpn filesz filemt filect,
                             filecd filemd fileuid fileusr pathnm
         if substr(path,length(path))<>'/' then
            path=path'/'

         /*----------------------------------------------------------*/
         /* Call readdir2.  Any stat failure will cause the syscall  */
         /* to fail and no information will be returned.             */
         /*----------------------------------------------------------*/
         Call syscalle EIO 'readdir (path) dir. st.'          /* @0HC*/

         if retval=-1 then
          do                  /* Call readdir and then lstat   21@0HA*/
           /*--------------------------------------------------------*/
           /* readdir2 failed.  Call readdir to get the directory    */
           /* list entries.  Then call lstat for each entry.  This   */
           /* way, we will be able to get to the root directory      */
           /* This is slower than readdir2, but will not trip over   */
           /* a black hole file on the stat call.                    */
           /*--------------------------------------------------------*/

           Call syscallm 'readdir (path) dir.'
           If Retval = -1 Then
            return 1

           /*--------------------------------------------------------*/
           /* Loop through directory entries and get stat info       */
           /*--------------------------------------------------------*/
           st. = ''
           Do i = 1 to DIR.0     /* Loop through directory entries   */
            Pathnm = path || dir.i
            address syscall  'lstat (pathnm) st.'i'.'
           End                 /* End Loop through directory entries */
          end                 /* End Call readdir and then lstat @0HA*/

         "TBCREATE DIR NOWRITE REPLACE",
            "NAMES(S,FILENM,LOCATE,FILETP,FILETPN,FILESZ,",
                  "FILEMT,FILECT,FILECD,FILEXA,FILESID,FILESTK,",
                  "FILEMD,FILEUID,FILEUSR,PATHNM)"
         sortx=pos(flsort,'NCTPSOM')     /* 10@P8C*/
         if sortx=0 then sortx=1
         sortkey=word("FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A",
                      "FILESZ,C,D FILEUSR,C,A FILECT,C,D",sortx)
         sortx=pos(flsorts,'NCTPSOM')
         if sortx>0 then
            sortkey=sortkey',' ||,
               word("FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A",
                    "FILESZ,C,D FILEUSR,C,A FILECT,C,D",sortx)
         do i=1 to dir.0
            filenm=dir.i
            if pattern.0>0 then                 /* 3@DFC */
               if matchpat(1,filenm)=0 then
                  iterate
            pathnm=path || filenm
            locate=translate(filenm)
            filetp='?'
            filecd=''
            call dirstat i
            "TBADD DIR"
         end
         "TBSORT DIR FIELDS("sortkey")"
   return 0

dir_cursel:
               parse var zverb . csrcode csrline
               if csrcode='P' then
                  do
                  'TBTOP DIR'
                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'
                  panpath=path
                  path=path || filenm
                  pathnm=path
                  if filetpn=s_isdir then
                     parse value 1 1 with faclch daclch
                   else
                     parse value 0 0 with faclch daclch
                  cmd=path
                  'SETMSG MSG('msg.m_gentxt')'
                  "ADDPOP"
                  "DISPLAY PANEL("pan.p_arights")"
                  if rc<>0 then chacc=''
                  "REMPOP"
                  if chacc='M' then
                     do
                     call info filetpn
                     zcmd='MODE'
                     call changeatt
                     end
                  else
                  if chacc='A' then
                     call editacl 'acl',path
                  else
                  if chacc='F' then
                     call editacl 'file',path
                  else
                  if chacc='D' then
                     call editacl 'dir',path
                  path=panpath
                  end
               else
               if csrcode='O' then
                  do
                  'TBTOP DIR'
                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'
                  panpath=path
                  path=path || filenm
                  pathnm=path
                  cmd=path
                  'SETMSG MSG('msg.m_gentxt')'
                  call info filetpn
                  zcmd='USER'
                  call changeatt
                  path=panpath
                  end
               else
               if pos(csrcode,'CS-')>0 then
                  do
                  'TBTOP DIR'
                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'
                  panpath=path
                  path=path || filenm
                  pathnm=path
                  select
                    when filetpn=s_isdir then call dir_settings
                    when filetpn=s_isreg then call reg_settings
                    when filetpn=s_ischr then call chr_settings
                    when filetpn=s_issym then call sym_settings
                    when filetpn=s_isfifo then call fifo_settings
                    otherwise
                       nop
                  end
                  path=panpath
                  end
               else
               if csrcode='T' then
                  do
                  'TBTOP DIR'
                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'
                  panpath=path
                  path=path || filenm
                  pathnm=path
                  select
                    when filetpn=s_isdir then
                       if addir<>'L' then
                          call path_dir addir,1
                        else
                          do
                          if row.nxlevel='' then
                             do
                             if vdirpl<>'/' then        /* 2@DHA*/
                             do
                             address syscall 'realpath (pathnm) dlpath'
                             if rc>=0 & retval<>-1 then
                                pathnm=dlpath
                             end
                             if substr(pathnm,length(pathnm))<>'/' then
                                pathnm=pathnm'/'
                             path=pathnm
                             path.nxlevel=pathnm
                             row.nxlevel=0
                             alcurcmd=1
                             first.nxlevel=first.level
                             end
                          end
                    when filetpn=s_isreg then call path_reg adreg,1
                    when filetpn=s_ischr then call path_chr adcsp,1
                    when filetpn=s_isfifo then call path_fifo adfifo,1
                    when filetpn=s_issym then
                       if adsyml<>'L' then
                          call path_sym adsyml,1
                        else
                          do
                          if row.nxlevel='' then
                             do
                             if vdirpl<>'/' then        /* 2@DHA*/
                             do
                             address syscall 'realpath (pathnm) dlpath'
                             if rc>=0 & retval<>-1 then
                                pathnm=dlpath
                             end
                             if substr(pathnm,length(pathnm))<>'/' then
                                pathnm=pathnm'/'
                             path=pathnm
                             path.nxlevel=pathnm
                             row.nxlevel=0
                             alcurcmd=1
                             first.nxlevel=first.level
                             end
                          end
                    otherwise
                       nop
                  end
                  path=panpath
                  end
               else
               if csrcode='3e'x then
                  do
                  end
               else
                  do
                  'TBTOP DIR'
                  'TBSKIP DIR NUMBER('selrow.sel_top+csrline-1')'
                  panpath=path
                  path=path || filenm
                  pathnm=path
                  call showobj
                  path=panpath
                  end
   return

/* pattern build and match routines  75@DFA*/

setfilter:
   parse arg pat
   prc = 0                          /* @PHA*/
   if pat='' then
      do
      pat=pattern.1
      "ADDPOP"
      "DISPLAY PANEL("pan.p_filter")"
      prc=rc
      "REMPOP"
      end
   if prc>0 then
      return
   pattern.0=0
   if pat='*' then
      pat=''
   if pat<>'' then
      do
      pattern.1=pat
      call parsepat 1,pat
      pattern.0=1
      end
   return

parsepat: procedure expose pattern.
   parse arg patix,pat
   pattern.patix.0=0
   j=0
   /* break each pattern segment into a var using last level index.
      if var is * it means match to next segment
      if var is ** it means match next sement at end of string
      else var is an absolute string match                       */
   do while pat<>''
      j=j+1
      if pos('*',pat)=0 then
         do
         pattern.patix.j=pat
         pat=''
         if j>1 then
            do
            i=j-1
            if pattern.patix.i='*' then
               pattern.patix.i='**'
            end
         leave
         end
      parse var pat pattern.patix.j '*' pat
      if length(pattern.patix.j)=0 then
         do
         pattern.patix.j='*'
         i=j-1
         if pattern.patix.i='*' then   /* eliminate dup * */
            j=j-1
         end
        else
         do
         j=j+1
         pattern.patix.j='*'
         end
   end
   pattern.patix.0=j
   return

matchpat: procedure expose pattern.
parse arg patix,str
do j=1 to pattern.patix.0
   if substr(pattern.patix.j,1,1)='*' then
      do
      jj=j
      j=j+1
      if j>pattern.patix.0 then
         do
         str=''
         leave
         end
      if pattern.patix.jj='**' then
         p=lastpos(pattern.patix.j,str)
       else
         p=pos(pattern.patix.j,str)
      end
     else
      p= substr(str,1,length(pattern.patix.j))=pattern.patix.j
   if p=0 then return 0
   str=substr(str,p+length(pattern.patix.j))
end
if str='' then
   return 1
return 0

/**********************************************************************/
/* directory panel: create selected                                   */
/**********************************************************************/
dir_create:
   crpath=path
   tattrs='N'               /* @DHA*/
   do forever
      call makevpath crpath
      "ADDPOP"
      zcmd=''
      "DISPLAY PANEL("pan.p_creat")"
      prc=rc
      "REMPOP"
      if prc<>0 then return
      if zcmd<>'' then
         if zcmd<>'SHOWOBJ' then
            return
          else
            do
            crpath=makepath()
            call showobj
            iterate
            end
      leave
   end
   "VPUT (TPERM) PROFILE"
   pathnm=makepath()
   tattrs=translate(tattrs)
   if tattrs='/' then tattrs='Y'
   select
     when vtype='D' then
       do
       call syscallm 'mkdir (pathnm)' vperm
       if tattrs='Y' then              /* @DHA*/
          call dir_settings /* @DHA*/
       end

     when vtype='C' then
       do
       call syscallm 'mknod (pathnm)' vperm vmajor vminor
       if tattrs='Y' then               /* @DHA*/
          call chr_settings /* @DHA*/
       end

     when vtype='L' then
       do
       "ADDPOP"
       vtext='L'
       "DISPLAY PANEL("pan.p_getpath")"
       prc=rc
       "REMPOP"
       if prc=0 then
          do
          lnknm=makepath()
          call syscallm 'link (lnknm) (pathnm)'
          if tattrs='Y' then   /* @DHA */
             call sym_settings /* @DHA*/
          end
       end

     when vtype='R' then
       do
       call syscallm 'open (pathnm)',
          O_WRONLY+O_EXCL+O_CREAT vperm
       if retval>=0 then
          do
          address syscall 'close' retval
          if tattrs='Y' then               /* @DHA*/
             call reg_settings /* @DHA*/
          if vsrcs='' then vsrce=''        /* @PJA*/
          select
             when vsrce='E' then
                call oedit pathnm
             when vsrce='C' then
                do
                path=pathnm
                call reg_replace 'F'
                end
             when vsrce='D' then
                do
                path=pathnm
                call reg_replace 'D'
                end
             otherwise
          end
          end
       end

     when vtype='F' then
       do
       call syscallm 'mkfifo (pathnm)' vperm
       end

     when vtype='S' then
       call makesym

     otherwise
   end

   return

/**********************************************************************/
/* directory panel: settings selected                                 */
/**********************************************************************/
dir_settings:
   call settings pan.p_settings s_isdir 'Directory'
   return

/**********************************************************************/
/* directory panel: delete selected                                   */
/**********************************************************************/
dir_delete:
   call delete 'rmdir'
   if result<>enotempty then
      return
   if noconf='/' then
      rdelopt='D'
    else
      rdelopt='A'
   rdeldone=0
   call rdelete path
   if rdeldone>0 then
      return
   address syscall 'lstat (path) st.'
   if retval=-1 then
      return
   call syscallm 'rmdir (path)'
   return

/**********************************************************************/
/* directory panel: rename selected                                   */
/**********************************************************************/
dir_rename:
   call rename
   return

/**********************************************************************/
/* directory panel: copy selected                                     */
/**********************************************************************/
dir_copy:
   call syscallm "readdir (path) dir. st."
   if retval=-1 then return
   "ADDPOP"
   optcb=''
   optcl='/'
   optcc=''
   optcs='/'
   optcm='/'
   alcurcmd=1
   do forever
      zcmd=''
      "DISPLAY PANEL("pan.p_cpydpds")"
      if rc<>0 then leave
      if zcmd='SHOWOBJ' then
         do
         call showobj
         iterate
         end
      pan=pan.p_cpydpds
      if substr(dsn,1,1)="'" then
         cdsn=strip(dsn,,"'")
       else
         cdsn=strip(sysvar(syspref)'.'dsn,,'.')
      util='OGET'
      if optcb='/' then
         utilopt='BINARY'
       else
         utilopt='TEXT'
      if optcc='/' then
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_cpyconv")"
         src=rc
         "REMPOP"
         if src<>0 then
            do
            "VGET (ZVERB)"
            if ZVERB='CANCEL' then
               iterate
             else
               leave
            end
         if tabdsn='' then
            utilopt=utilopt 'convert(yes)'
          else
            utilopt=utilopt 'convert('tabdsn')'
         end
      suf='.'strip(suffix,'L','.')
      copied=0
      "TBCREATE ML NAMES(S,MEM,FNAME,CPATH,LOCATE,UPDATE) NOWRITE",
             "REPLACE"
      "TBSORT ML FIELDS(FNAME)"
      if optcm='/' then
         s='_'
       else
         s='/'
      update=''
      do i=1 to dir.0
         if st.i.st_type<>s_isreg then
            iterate
         if optcs='/' then
            do
            parse var dir.i mem '.' tsuf
            if suf<>'.' & suf<>'.'tsuf then
               iterate
            end
          else
            mem=dir.i
         if optcl='/' then
            mem=translate(mem)
         if length(mem)>8 then
            iterate
         valchr='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$1234567890'
         if verify(mem,valchr)>0 then
            iterate
         valchr='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$'
         if verify(substr(mem,1,1),valchr)>0 then
            iterate
         fname=dir.i
         locate=fname
         cpath="'"quotes(path"/"fname)"'"
         "TBADD ML ORDER"
      end
      if optcm='/' then
         do
         "ADDPOP"
         dlf='mem $ 8 <  Member> fname l 50 <  Filename>'
         althelp=pan.p_memlisthc
         x=actionlist('ML',1,1,pan.p_memlist,dlf)
         "REMPOP"
         if x=0 then
            if zverb='EXIT' | zverb='RETURN' then
               leave
            else
            if zverb='CANCEL' then
               iterate
         end
      done=1
      "TBTOP ML"
      do forever
         "TBSKIP ML"
         if rc<>0 then leave
         if s='' | s='_' then iterate
         if update<>'' then
            mem=update
         cdsnm="'"cdsn"("mem")'"
         src=tsocmd(util,pan,cpath cdsnm utilopt)
         if src=0 then
            copied=1
          else
            do
            "ADDPOP"
            "DISPLAY PANEL("pan.p_cpyerr")"
            src=rc
            "REMPOP"
            if src=0 then
               iterate
            "VGET (ZVERB)"
            if ZVERB='CANCEL' then
               done=0
            leave
            end
      end
      if copied=0 then
         'SETMSG MSG('msg.m_nocopy')' msgloc
      if done then leave
   end
   "REMPOP"
   return

/**********************************************************************/
/* directory panel: replace selected                                  */
/**********************************************************************/
dir_replace:
   "ADDPOP"
   done=0
   optcb=''
   optcc=''
   optcl='/'
   optcm='/'
   do until done
      zcmd=''
      "DISPLAY PANEL("pan.p_cpyspds")"
      if rc<>0 then leave
      if zcmd='SHOWOBJ' then
         do
         call showobj
         iterate
         end
      "VPUT (TPERM) PROFILE"
      pan=pan.p_cpyspds
      if substr(dsn,1,1)="'" then
         cdsn=strip(dsn,,"'")
       else
         cdsn=strip(sysvar(syspref)'.'dsn,,'.')
      "LMINIT DATAID(PDSID) DATASET("dsn") ORG(DSORG)"
      if rc<>0 then
         do
         'LMFREE DATAID('pdsid')'
         'SETMSG MSG('msg.m_nodsn')' msgloc
         iterate
         end
      util='OPUT'
      if optcb='/' then
         utilopt='BINARY'
       else
         utilopt='TEXT'
      if optcc='/' then
         do
         "ADDPOP"
         "DISPLAY PANEL("pan.p_cpyconv")"
         src=rc
         "REMPOP"
         if src<>0 then
            do
            "VGET (ZVERB)"
            if ZVERB='CANCEL' then
               iterate
             else
               leave
            end
         if tabdsn='' then
            utilopt=utilopt 'convert(yes)'
          else
            utilopt=utilopt 'convert('tabdsn')'
         end
      'LMOPEN DATAID('pdsid') LRECL(LRECL)'
      'TBCREATE ML NOWRITE REPLACE',
                'NAMES(S,MEM,OMEM,CPATH,CDSNM,LOCATE,UPDATE)'
      mem=''
      update=''
      if optcm='/' then
         s='_'
       else
         s='/'
      do forever
         'LMMLIST DATAID('pdsid') MEMBER(MEM)'
         if rc>0 then
            leave
         mem=strip(mem)
         if optcl='/' then
            omem=translate(mem,'abcdefghijklmnopqrstuvwxyz',,
                               'ABCDEFGHIJKLMNOPQRSTUVWXYZ')
          else
            omem=mem
         if suffix<>'' then
            omem=omem'.'strip(suffix,'L','.')
         cpath=strip(path,"T","/")"/"omem
         cdsnm="'"cdsn"("mem")'"
         locate=mem
         "TBADD ML"
      end
      if optcm='/' then
         do
         "ADDPOP"
         dlf='mem l 8 < Member> omem $ 50 <  Filename>'
         althelp=pan.p_memlisthr
         x=actionlist('ML',1,1,pan.p_memlist,dlf)
         "REMPOP"
         if x=0 then
            if zverb='EXIT' | zverb='RETURN' then
               done=1
            else
            if zverb='CANCEL' then
               iterate
         end
      if done then leave
      done=1
      "TBTOP ML"
      cpcount=0
      do forever
         "TBSKIP ML"
         if rc<>0 then leave
         if s='' | s='_' then iterate
         if update<>'' then
            cpath=strip(path,"T","/")"/"update
         cpcount=cpcount+1
         address syscall 'access (cpath)' f_ok
         cprepl= rc=0 & retval<>-1                  /* @DFA*/
         src=tsocmd(util,pan,cdsnm "'"quotes(cpath)"'" utilopt)
         if src=0 then
            do                                      /* @DFA*/
            /* if new or replaced and reset perms opt */
            if cprepl=0 | (cprepl=1 & optcp<>'/') then  /* @DFA*/
               do
               call syscallm 'chmod (cpath)' vperm
               /* this will now stop on permission errors */
               if retval=-1 then leave              /* @DFA*/
               end                                  /* @DFA*/
            end                                     /* @DFA*/
           else
            do
            "ADDPOP"
            "DISPLAY PANEL("pan.p_cpyerr")"
            src=rc
            "REMPOP"
            if src=0 then
               iterate
            "VGET (ZVERB)"
            if ZVERB='CANCEL' then
               done=0
            leave
            end
      end
      if cpcount=0 then
         do
         done=0
         "SETMSG MSG("msg.m_nocopy")" msgloc
         end
      "TBEND ML"
      "LMMLIST DATAID("pdsid") OPTION(FREE)"
      "LMFREE DATAID("pdsid")"
   end
   "REMPOP"
   return

/**********************************************************************/
/* directory panel: print selected                                    */
/**********************************************************************/
dir_print:
   call syscallm 'readdir (path) ln.'
   if retval=-1 then return
   hdr1=''
   hdr2=time() date() 'Files:' ln.0 'Directory:' path
   hdr3=''
   hdr0=3
   'TBCREATE DL NOWRITE REPLACE NAMES(LN)'
   do i=1 to ln.0
      ln=ln.i
      'TBADD DL'
   end
   'TBSORT DL FIELDS(LN)'
   'TBTOP DL'
   call print_hdr 1
   do forever
      'TBSKIP DL'
      if rc<>0 then
         leave
      "VGET (ZLSTNUML)"
      if zlstlpp=zlstnuml then
         call print_hdr pg+1
      'LIST BUFNAME(LN) LINELEN('length(ln)')'
   end
   'TBEND DL'
   'SETMSG MSG('msg.m_printed')' msgloc
   return

/**********************************************************************/
/* directory panel: compare selected                                  */
/**********************************************************************/
dir_compare:
   call run_diff 'CD' '-fr'
   return

/**********************************************************************/
/* directory panel: find selected                                     */
/**********************************************************************/
dir_find:
   pgmpath=greppath
   call syscallm "access (pgmpath)" x_ok
   if retval=-1 then
      do
      "SETMSG MSG("msg.m_nopgm")" msgloc
      return
      end
   pgmpath=findpath
   call syscallm "access (pgmpath)" x_ok
   if retval=-1 then
      do
      "SETMSG MSG("msg.m_nopgm")" msgloc
      return
      end
   if find_opts('SO') then return
   srch=''
   if str1<>'' then
      srch=srch || str1 ||esc_n
   if str2<>'' then
      srch=srch || str2 ||esc_n
   if str3<>'' then
      srch=srch || str3 ||esc_n
   if str4<>'' then
      srch=srch || str4 ||esc_n
   srch=strip(srch,,esc_n)
   "REMPOP"                   /* @0PM*/
   "REMPOP"                   /* @0PM*/
   env.0=0
   call syscallm "creat (stdout)" 600
   if retval=-1 then return
   fd0=-1
   fd1=retval
   fd2=retval
   found=0
   parm.1=pgmpath
   parm.2=path
   parm.3='-print'
   parm.4='-type'
   parm.5='f'
   parm.6='-exec'
   parm.7=greppath
   parm.8='-Fni'
   parm.9='-e'
   parm.10=srch
   parm.11='{}'  /* open/close braces */
   parm.12=';'
   parm.0=12
   cmd=pgmpath '-exec' greppath'...'
   call spawnpgm pan.p_srchstr
   if retcode=0 then
      do
      call syscallm 'stat (stdout) st.'
      if st.st_size>0 & st.st_type=s_isreg then
         call obrowse stdout,0
       else
         "SETMSG MSG("msg.m_found")"
      end
    else
      "SETMSG MSG("msg.m_notfound")" msgloc
   address syscall 'close' fd1
   address syscall 'close' fd2
   if tempname=1 then
      do
      address syscall 'unlink (stdout)'
      stdout=''
      end
   return

/**********************************************************************/
/* directory panel: set cwd selected                                  */
/**********************************************************************/
dir_cwd:
   call syscallm 'chdir (path)'
   return

/**********************************************************************/
/* directory panel: mount                                             */
/**********************************************************************/
dir_mount:
   "ADDPOP"
   opt='RDWR'
   fsparm1=''
   fsparm2=''
   fsowner=''
   dsn=''        /* @P5C*/
   filesys=''    /* @P5C*/
   fssystem=''   /* @D7A*/
   fsccsid=''    /* @D8A*/
   mpath=path
   do forever
      call makevpath mpath
      zcmd=''
      "DISPLAY PANEL("pan.p_mount")"
      if rc<>0 then leave
      mpath=makepath()
      if zcmd='SHOWOBJ' then
         do
         call showobj
         iterate
         end
      if length(dsn)>2 & substr(dsn,1,1)="'" &,       /* 5@DCA*/
           substr(dsn,length(dsn),1)="'" then
         fsn=substr(dsn,2,length(dsn)-2)
       else
         fsn=translate(dsn)
      fsparm=fsparm1 || fsparm2

      /* 17@D7A - converted to mnte interface */
      m.=''
      if optro='' then
         m.mnte_mode=mnt_mode_rdwr
       else
         m.mnte_mode=mnt_mode_rdonly
      if optsetam<>'' then             /* 25@PBA*/
         do
         do sli=1 to 32                  /* 3@PCA*/
            call value 'SYSNM'sli,''
         end
         "ADDPOP"
         "DISPLAY PANEL("pan.p_selamt")"
         rrc=rc
         "REMPOP"
         if rrc<>0 then leave
         if vactc='Y' | vactc='N' | vactc='U' then
            do
            if vactc='N' then
               m.mnte_mode=mnt_mode_noautomove+m.mnte_mode
            else
            if vactc='U' then
               m.mnte_mode=mnt_mode_aunmount+m.mnte_mode
            end
          else
            if vactc='I' | vactc='E' then
               do
               if vactc='I' then
                  m.mnte_syslist='0000'x
               else
                  m.mnte_syslist='0001'x
               slc=0
               do sli=1 to 32
                  sysnm=value('SYSNM'sli)
                  if sysnm<>'' then
                     do
                     slc=slc+1
                     m.mnte_syslist=m.mnte_syslist ||,
                                     translate(left(sysnm,8))
                     end
               end
               m.mnte_syslist=d2c(slc,2) || m.mnte_syslist
               end
         end

      if optsec<>'' then
         m.mnte_mode=m.mnte_mode+mnt_mode_nosec
      if optid<>'' then
         m.mnte_mode=m.mnte_mode+mnt_mode_nosetid
      numeric digits 10                                     /* 8@D8A*/
      if fsccsid='' then fsccsid=0
      if opttext='' then
        filetag = fsccsid * 65536
      else
        filetag = fsccsid * 65536 + 32768
      if filetag=0 then fsccsid=''
      m.mnte_filetag=d2c(filetag)
      m.mnte_fsname=fsn
      m.mnte_fstype=filesys
      m.mnte_parm=fsparm
      m.mnte_path=mpath
      m.mnte_sysname=fssystem
      call syscallm 'mount m.'

      if retval=-1 then iterate
      if fsowner<>'' then
         do
         call syscallm 'getpwnam (fsowner) pw.'
         if retval>0 then
            call syscallm 'chown (mpath)' pw.pw_uid pw.pw_gid
          else
            if retval=0 then
               do
               retval=-1
               rsn=getjr(errnojr)
               eno=geterr(errno)
               "SETMSG MSG("msg.m_scerr")" msgloc
               end
         end
      leave
   end
   "REMPOP"
   return

/**********************************************************************/
/* chr special panel: settings selected                               */
/**********************************************************************/
chr_settings:
   call settings pan.p_settings s_ischr 'Character special'
   return

/**********************************************************************/
/* chr special panel: delete selected                                 */
/**********************************************************************/
chr_delete:
   call delete 'unlink'
   return

/**********************************************************************/
/* chr special panel: rename selected                                 */
/**********************************************************************/
chr_rename:
   call rename
   return

/**********************************************************************/
/* reg file panel: text browse selected                               */
/**********************************************************************/
reg_brtext:
   xx=obrowse(path,0)
   return

/**********************************************************************/
/* reg file panel: record browse selected                             */
/**********************************************************************/
reg_brrecs:
   "ADDPOP"
   "DISPLAY PANEL("pan.p_getrecl")"
   src=rc
   "REMPOP"
   if src<>0 then return
   xx=obrowse(path,hfsrl)
   return

/**********************************************************************/
/* reg file panel: edit selected                                      */
/**********************************************************************/
reg_edit:
   call oedit path
   return

/**********************************************************************/
/* reg file panel: settings selected                                  */
/**********************************************************************/
reg_settings:
   call settings pan.p_settings s_isreg 'Regular file'
   return

/**********************************************************************/
/* reg file panel: delete selected                                    */
/**********************************************************************/
reg_delete:
   call delete 'unlink'
   return

/**********************************************************************/
/* reg file panel: rename selected                                    */
/**********************************************************************/
reg_rename:
   call rename
   return

/**********************************************************************/
/* reg file panel: copy selected                                      */
/**********************************************************************/
reg_copy:
   "ADDPOP"
   sel=''
   optcc=''
   optcb=''
   do forever
      "DISPLAY PANEL("pan.p_cpydst")"
      if rc=0 then
         select
            when selc='F' then
               do
               "ADDPOP"
               vtext='CP'
               "DISPLAY PANEL("pan.p_getpath")"
               src=rc
               "REMPOP"
               if src<>0 then
                  do
                  "VGET (ZVERB)"
                  if ZVERB='CANCEL' then
                     iterate
                   else
                     leave
                  end
               xx=copy(pan.p_getpath,path,makepath())
               end

            when selc='D' then
               do
               "ADDPOP"
               util='OGET'
               if optcb='/' then
                  utilopt='BINARY'
                else
                  utilopt='TEXT'
               "DISPLAY PANEL("pan.p_getdsn")"
               if rc<>0 then
                  do
                  "REMPOP"
                  "VGET (ZVERB)"
                  if ZVERB='CANCEL' then
                     iterate
                   else
                     leave
                  end
               if optcc='/' then
                  do
                  "DISPLAY PANEL("pan.p_cpyconv")"
                  if rc<>0 then
                     do
                     "REMPOP"
                     "VGET (ZVERB)"
                     if ZVERB='CANCEL' then
                        iterate
                      else
                        leave
                     end
                  if tabdsn='' then
                     utilopt=utilopt 'convert(yes)'
                   else
                     utilopt=utilopt 'convert('tabdsn')'
                  end
               src=tsocmd(util,pan.p_getdsn,,
                          "'"quotes(path)"'" dsn utilopt)
               "REMPOP"
               if src=0 then leave
               iterate
               end

            otherwise
         end
      leave
   end
   "REMPOP"
   return

/**********************************************************************/
/* reg file panel: replace selected                                   */
/**********************************************************************/
reg_replace:
   "ADDPOP"
   arg selc
   optcc=''
   optcb=''
   do forever
      "DISPLAY PANEL("pan.p_cpysrc")"
      if rc=0 then
         select
            when selc='F' then
               do
               vtext='RP'
               "ADDPOP"
               "DISPLAY PANEL("pan.p_getpath")"
               src=rc
               "REMPOP"
               if src<>0 then iterate
               xx=copy(pan.p_getpath,makepath(),path)
               end

            when selc='D' then
               do
               "ADDPOP"
               util='OPUT'
               if optcb='/' then
                  utilopt='BINARY'
                else
                  utilopt='TEXT'
               "DISPLAY PANEL("pan.p_getdsn")"
               if rc<>0 then
                  do
                  "REMPOP"
                  "VGET (ZVERB)"
                  if ZVERB='CANCEL' then
                     iterate
                   else
                     leave
                  end
               if sysdsn(dsn)<>'OK' then
                  do
                  "SETMSG MSG("msg.m_nodsn")" msgloc
                  "REMPOP"
                  iterate
                  end
               if optcc='/' then
                  do
                  "DISPLAY PANEL("pan.p_cpyconv")"
                  if rc<>0 then
                     do
                     "REMPOP"
                     "VGET (ZVERB)"
                     if ZVERB='CANCEL' then
                        iterate
                      else
                        leave
                     end
                  if tabdsn='' then
                     utilopt=utilopt 'convert(yes)'
                   else
                     utilopt=utilopt 'convert('tabdsn')'
                  end
               src=tsocmd(util,pan.p_getdsn,,
                          dsn "'"quotes(path)"'" utilopt)
               "REMPOP"
               if src=0 then leave
               iterate
               end

            otherwise
         end
      leave
   end
   "REMPOP"
   return

/**********************************************************************/
/* reg file panel: print selected                                     */
/**********************************************************************/
reg_print:
   call syscallm 'readfile (path) ln'
   if rc<>0 then
      do
      "SETMSG MSG("msg.m_nontext")"
      return
      end
   if retval=-1 then return
   hdr1=''
   "GETMSG MSG("lit"017) LONGMSG(HDR2)"
   hdr2=time() date() hdr2
   hdr3=''
   hdr0=3
   call print_hdr 1
   do i=1 to ln0
      "VGET (ZLSTNUML)"
      if zlstlpp=zlstnuml then
         call print_hdr pg+1
      'LIST BUFNAME(LN'i') LINELEN('length(value('ln'i))')'
   end
   'SETMSG MSG('msg.m_printed')'
   return

/**********************************************************************/
/* reg file panel: compare selected                                   */
/**********************************************************************/
reg_compare:
   call run_diff 'CF' '-f'
   return

/**********************************************************************/
/* reg file panel: find selected                                      */
/**********************************************************************/
reg_find:
   pgmpath=greppath
   call syscallm "access (pgmpath)" x_ok
   if retval=-1 then
      do
      "SETMSG MSG("msg.m_nopgm")" msgloc
      return
      end
   if find_opts('SO') then return
   parm.0=4
   parm.1=pgmpath
   parm.2='-Fni'
   parm.3='-e'
   parm.4=''
   if str1<>'' then
      parm.4=parm.4 || str1 ||esc_n
   if str2<>'' then
      parm.4=parm.4 || str2 ||esc_n
   if str3<>'' then
      parm.4=parm.4 || str3 ||esc_n
   if str4<>'' then
      parm.4=parm.4 || str4 ||esc_n
   parm.4=strip(parm.4,,esc_n)
   env.0=0
   call syscallm "creat (stdout)" 600
   if retval=-1 then
      do
      "REMPOP"
      "REMPOP"
      return
      end
   fd1=retval
   fd2=retval
   found=0
   call syscallm "open (path)" o_rdonly+o_nonblock 000
   if retval=-1 then
      do
      "REMPOP"
      "REMPOP"
      address syscall "close" fd1
      return
      end
   fd0=retval
   buf="Searching" path "for:"esc_n || parm.4 || esc_n || esc_n
   address syscall "write" fd1 "buf"
   cmd=pgmpath'...'
   call spawnpgm pan.p_srchstr
   if retcode=0 then
      do
      found=1
      buf=esc_n || esc_n
      address syscall "write" fd1 "buf"
      end
   "REMPOP"
   "REMPOP"
   if found then
      do
      call syscallm 'stat (stdout) st.'
      if st.st_size>0 & st.st_type=s_isreg then
         call obrowse stdout,0
       else
         "SETMSG MSG("msg.m_found")"
      end
    else
      "SETMSG MSG("msg.m_notfound")" msgloc
   address syscall 'close' fd1
   address syscall 'close' fd0
   if tempname=1 then
      do
      address syscall 'unlink (stdout)'
      stdout=''
      end
   return

/**********************************************************************/
/* fifo panel: settings selected                                      */
/**********************************************************************/
fifo_settings:
   call settings pan.p_settings s_isfifo 'FIFO'
   return

/**********************************************************************/
/* fifo panel: delete selected                                        */
/**********************************************************************/
fifo_delete:
   call delete 'unlink'
   return

/**********************************************************************/
/* fifo panel: rename selected                                        */
/**********************************************************************/
fifo_rename:
   call rename
   return

/**********************************************************************/
/* symlink panel: settings selected                                   */
/**********************************************************************/
sym_settings:
   call settings pan.p_symset s_issym 'Symbolic link'
   return

/**********************************************************************/
/* symlink panel: delete selected                                     */
/**********************************************************************/
sym_delete:
   call delete 'unlink'
   return

/**********************************************************************/
/* symlink panel: rename selected                                     */
/**********************************************************************/
sym_rename:
   call rename
   return

/**********************************************************************/
/* make a symlink                                                     */
/**********************************************************************/
makesym:
   doingsl=1
   "ADDPOP"
   do while doingsl>0
      "DISPLAY PANEL("pan.p_symsel")"
      if rc<>0 then
         do
         "REMPOP"
         return
         end
      vtext=vsymc
      doingsl=2
      "ADDPOP"
      do while doingsl>1
         call getlinkname
         if lnknm='' then
            leave
         if vsymc='S' then
            call syscallm 'symlink (lnknm) (pathnm)'
          else
            call syscallm 'extlink (lnknm) (pathnm)'
         if retval<>-1 then
            doingsl=0
      end
      "REMPOP"
   end
   "REMPOP"
   return

/**********************************************************************/
/* getlinkname                                                        */
/**********************************************************************/
getlinkname:
   select
     when vsymc='S' then
        do
        "DISPLAY PANEL("pan.p_getpath")"
        src=rc
        lnknm=makepath()
        end
     when vsymc='E' then
        do
        "DISPLAY PANEL("pan.p_getpath")"
        src=rc
        lnknm=makepath()
        end
     otherwise
        "DISPLAY PANEL("pan.p_getdsn")"
        src=rc
        lnknm=dsn
   end
   if src>0 then
      do
      lnknm=''
      "VGET (ZVERB)"
      if zverb<>'CANCEL' then
         doingsl=0
       else
         doingsl=1
      end
   return

/**********************************************************************/
/* delete: delete a file or directory                                 */
/**********************************************************************/
delete:
   arg op
   prc=0
   errno=0
   if noconf<>'/' then
      do forever
         "ADDPOP"
         zcmd=''
         "DISPLAY PANEL("pan.p_confd")"
         prc=rc
         "REMPOP"
         if prc<>0 then
            leave
         "VPUT (NOCONF) PROFILE"
         if zcmd='' then
            leave
         if translate(zcmd)='SHOWOBJ' then
            call showobj
      end
   if prc=0 then
      call syscallm op '(path)'
   return errno

/**********************************************************************/
/* shcmd:  issue shell command or run program                         */
/**********************************************************************/
shcmd:
   parse arg cmdline,pgm
   path=''
   if cmdline='' then
      do
         if pgm<>'' then
            do
            runmeth='D'
            call linecmd 1
            return
            end
         do forever                      /* @DHA*/
         "ADDPOP"
         "DISPLAY PANEL("pan.p_shcmd")"
         src=rc
         "REMPOP"
         if src<>0 then return
         cmdline=strip(left(shcmd1,64) || left(shcmd2,64) ||,
                       left(shcmd3,64) || left(shcmd4,64))
         call runshcmd pgm              /* @DHA*/
         end                            /* @DHA*/
      end
   call runshcmd pgm
   return

/**********************************************************************/
/* runshcmd:  run the shell command                                   */
/**********************************************************************/
runshcmd:

   arg pgm
   pw.=''
   address syscall 'getpwnam' sysvar('SYSUID') 'pw.'
   ev.1='PATH=/bin:.'                                  /* @06C*/
   ev.2='_BPX_SHAREAS=YES'
   ev.3='HOME='pw.pw_dir                               /* @05A*/
   ev.4='LOGNAME='userid()                             /* @06A*/
   ev.0=4                                              /* @06C*/
   if pgm<>'' then
      do
      i=0
      prm=cmdline
      do while prm<>''
         i=i+1
         if substr(prm,1,1)='"' then
            dlm='"'
         else
         if substr(prm,1,1)="'" then
            dlm="'"
         else
            dlm=' '
         if dlm<>'' then
            prm=substr(prm,2)
         j=pos(dlm,prm)
         if j=0 then
            j=length(prm)+1
         p.i=substr(prm,1,j-1)
         prm=strip(substr(prm,j+1))
      end
      p.0=i
      end
    else
      do
      p.1='/bin/sh'
      p.2='-Lc'
      p.3=cmdline
      p.0=3
      end
   call runopts 'ev.'
   if ltime.4<>'*' then       /* no speical init processing     @0TC*/
      do                                                    /*  @0TA*/
      call syscallm 'open /dev/null 2 000'
      fd.0=retval
      shout='/tmp/'sysvar('SYSUID')'.'time('L')'.ishell'
      call syscallm 'open (shout) 147 700' /* rdwr+create+trunc */
      fd.1=retval
      fd.2=retval
      if retval<>-1 then
         call syscallm 'spawnp (p.1) 3 fd. p. ev.'
      pid=retval
      if pid>0 then
         do
         address syscall 'waitpid (pid) st. 0'
         end
      if retval<>-1 then
         do
         call syscallm 'fstat (fd.1) stat.'
         if stat.8>0 then                                   /* @0TC*/
            call obrowse shout,0
         end
      trace o
      address syscall 'close' fd.0
      address syscall 'close' fd.1
      address syscall 'close' fd.2
      address syscall 'unlink (shout)'
      trace
      end                                                   /*  @0TA*/
   if ltime.4='*' then         /* special processing for init 20@0TC*/
      do
      itz=''
      ltz=''
      /* Use bpxwunix to retrieve env vars - avoid using tmp space. */
      /* Echo env vars to stderr and parse the output.              */
      cmd='/bin/sh -Lc "echo',
          'IS=\$BPXWISHISPF\IZ=\$BPXWISHTZ\TZ=\$TZ >/dev/fd2"'
      if bpxwunix(cmd,,,stderr.,ev.)=0 then
         do
         i=stderr.0
         parse var stderr.i 'IS=' isp 'IZ=' itz 'TZ=' ltz
         end
      if isp='NO' then
         isp=0                                          /* 2@DLC*/
      else
      if isp='ALL' then
         isp=2
      else                                              /* 3@DLA*/
         isp=1
      if itz<>'' then ltz=itz
      if ltz='GMT' then ltz=''
      ltimebf='TZ='ltz
      end
   return

/**********************************************************************/
/* spawn a command                                                    */
/**********************************************************************/
spawncmd:
   arg excmd

   pw.=''                                            /* @0FA 8@DFM*/
   address syscall 'getpwnam' sysvar('SYSUID') 'pw.' /* @0FA*/
   env.1='PATH=/bin:.'                         /* @06C*/
   env.2='_BPX_SHAREAS=YES'
   env.3='HOME='pw.pw_dir       /* 2@wjs*/
   env.4='LOGNAME='userid()
   env.0=4
   call runopts 'env.'

   if runmeth='I' then             /* 12@DFA*/
      do
      /* this run method does not show the completion value nor does it
         support a time limit */
      spnin.0=0
      address tso 'alloc fi(bpxwidd1) da(*) reuse'
      address tso 'alloc fi(bpxwidd2) da(*) reuse'
      rv=bpxwunix(pgmpath parm,spnin.,'DD:bpxwidd1','DD:bpxwidd2',env.)
      address tso 'free fi(bpxwidd1 bpxwidd2)'
      return
      end

   stdin='/dev/null'
   call syscallm "open (stdin)" o_rdonly+o_nonblock 000
   fd0=retval
   if retval=-1 then
      do
      msgpath=stdin
      "SETMSG MSG("msg.m_noacc")" msgloc
      return
      end
   stdout='/tmp/'sysvar('SYSUID')'.'time('L')'.stdout.ishell'
   call syscallm "creat (stdout)" 600
   fd1=retval
   if retval=-1 then
      do
      address syscall 'close' fd0
      msgpath=stdout
      "SETMSG MSG("msg.m_noaccw")" msgloc
      return
      end
   stderr='/tmp/'sysvar('SYSUID')'.'time('L')'.stderr.ishell'
   call syscallm "creat (stderr)" 600
   fd2=retval
   if retval=-1 then
      do
      address syscall 'close' fd0
      address syscall 'close' fd1
      address syscall 'unlink (stdout)'
      msgpath=stderr
      "SETMSG MSG("msg.m_noaccw")" msgloc
      return
      end
   fd.0=fd0
   fd.1=fd1
   fd.2=fd2
   pw.=''                                            /* @0FA*/
   address syscall 'getpwnam' sysvar('SYSUID') 'pw.' /* @0FA*/
   env.1='PATH=/bin:.'                         /* @06C*/
   env.2='_BPX_SHAREAS=YES'
   env.3='HOME='pw.pw_dir       /* 2@wjs*/
   env.4='LOGNAME='userid()
   env.0=4
   call runopts 'env.'
   if excmd='' & runmeth='L' then       /* 10@DBA*/
      do
      parm.1='/bin/sh'
      parm.2='-Lc'
      parm.3=pgmpath parm
      parm.0=3
      end
    else
      do
      i=1
      prm=parm
      parm.i=pgmpath
      do while prm<>''
         i=i+1
         if substr(prm,1,1)='"' then
            dlm='"'
         else
         if substr(prm,1,1)="'" then
            dlm="'"
         else
            dlm=' '
         if dlm<>'' then
            prm=substr(prm,2)
         j=pos(dlm,prm)
         if j=0 then
            j=length(prm)+1
         parm.i=substr(prm,1,j-1)
         prm=strip(substr(prm,j+1))
      end
      parm.0=i
      end
   cmd=pgmpath parm
   cmd=''
   do j=1 to parm.0
      cmd=cmd||parm.j||'!'
   end
   spcmd=cmd
   "ADDPOP"
   "CONTROL DISPLAY LOCK"
   "SETMSG MSG("msg.m_gentxt")" msgloc
   "DISPLAY PANEL("panel")"
   call syscallm 'spawnp (parm.1) 3 fd. parm. env.'
   if retval=-1 then
      do
      "REMPOP"
      return
      end
   pid=retval
   cmd=spcmd 'PID='pid
   "CONTROL DISPLAY LOCK"
   "SETMSG MSG("msg.m_gentxt")" msgloc
   "DISPLAY PANEL("panel")"
   call syscalls 'SIGON'
   address syscall 'sigaction' sigalrm sig_cat 0 'ohdl oflg'
   address syscall 'sigprocmask' sig_unblock,
      sigaddset(sigsetempty(),sigalrm) 'mask'
   if tout<>'' then
      address syscall 'alarm' tout
   address syscall 'waitpid (pid) st. 0'
   srv=retval
   address syscall 'alarm 0'
   if srv=-1 then
      do
      "CONTROL DISPLAY LOCK"
      "SETMSG MSG("msg.m_timeout")" msgloc
      "DISPLAY PANEL("panel")"
      address syscall 'kill' pid sigkill
      address syscall 'alarm 10'
      address syscall 'waitpid (pid) st. 0'
      srv=retval
      address syscall 'alarm 0'
      if srv=-1 then
         st.=-1
      end
   address syscall 'sigaction' sigalrm ohdl oflg 'x y'
   call syscalls 'SIGOFF'
   select
      when st.w_ifexited=1 then
         parse value msg.m_sigexit st.w_exitstatus with msgid code
      when st.w_ifsignaled=1 then
         parse value msg.m_sigterm st.w_termsig with msgid code
      when st.w_ifstopped=1 then
         parse value msg.m_sigstop st.w_stopsig with msgid code
      otherwise
         msgid=''
   end
   if msgid<>'' then
      "SETMSG MSG("msgid")" msgloc
   "REMPOP"
   st.=0
   address syscall 'fstat' fd1 'st.'
   if st.st_size>0 & st.st_type=s_isreg then
      xx=obrowse(stdout,0)
   address syscall 'fstat' fd2 'st.'
   if st.st_size>0 & st.st_type=s_isreg & fd1<>fd2 &,
       stdout<>stderr then
      xx=obrowse(stderr,0)
   address syscall 'unlink (stdout)'
   address syscall 'unlink (stderr)'
   address syscall 'close' fd0
   address syscall 'close' fd1
   address syscall 'close' fd2
   return 0

/**********************************************************************/
/* linecmd: enter a line command                                      */
/**********************************************************************/
linecmd:
   arg excmd
   linecmdbrc=pos('{}',path)
   excmdsv=excmd                                    /* 3@DHA*/
   do forever           /* keep dialog active until pf3  */
   excmd=excmdsv
   "ADDPOP"
   if excmd<>'' then
      panel=pan.p_excmd
    else
      panel=pan.p_run
   "DISPLAY PANEL("panel")"
   lcrc=rc
   "REMPOP"
   if lcrc<>0 then
      return
   cmdline=cmdl1 || cmdl2 || cmdl3 || cmdl4
   if excmd='' then
      do
      do i=1 by 1
         if pos('{}',cmdline)=0 then leave
         if linecmdbrc>0 then
            do
            /* path cannot contain {} */
            "SETMSG MSG("msg.m_badname")" msgloc
            return
            end
         parse var cmdline p1 '{}' p2
         cmdline=p1 || path || p2
      end
      if i=1 then cmdline=cmdline path
      end
   cmdline=strip(cmdline)
   parse var cmdline pgmpath parm
   zcmd=''    /* @DHA*/
   if runmeth='T' then
      address tso cmdline
   else
   if runmeth='L' then
      call spawncmd
   else
   if runmeth='I' then   /* 3@DFA*/
      call spawncmd
   else
   if runmeth='D' then
      call spawncmd 1
   else
      "SETMSG MSG("msg.m_invcmd")" msgloc
   end             /* @DHA*/
   return

/**********************************************************************/
/* rename: rename a file or directory                                 */
/**********************************************************************/
rename:
   "ADDPOP"
   vtext='R'
   "DISPLAY PANEL("pan.p_getpath")"
   if rc<>0 then
      do
      "REMPOP"
      return
      end
   newpath=makepath()
   address syscall 'access (newpath)' f_ok
   if retval=0 & noconf<>'/' then
      do
      "ADDPOP"
      "DISPLAY PANEL("pan.p_confr")"
      prc=rc
      "REMPOP"
      if prc<>0 then
         do
         "REMPOP"
         "VGET (ZVERB)"
         if zverb="CANCEL" then
            call rename
         return
         end
      end
   call syscallm 'rename (path) (newpath)'
   "REMPOP"
   return

/**********************************************************************/
/* settings:  common settings logic                                   */
/**********************************************************************/
settings:
   parse arg pan sttype type
   "ADDPOP"
   do forever
      call info sttype type
      if result then leave
      "DISPLAY PANEL("pan")"
      if rc<>0 then leave
      if zcmd='SHOWOBJ' then
         call showobj
      else
      if zcmd<>'' then
         call changeatt
   end
   "REMPOP"
   return

/**********************************************************************/
/* info:  Get the stat structure and set dialog variables             */
/**********************************************************************/
info:
   parse arg sttype type
   st.='?'
   call syscallm 'lstat (path) st.'
   if retval=-1 then return 1
   if datatype(st.st_type,'W')=0 |,
        st.st_type<>sttype then
      return 1
   /*******************************************************************/
   /* set dialog vars from stat structure                             */
   /*******************************************************************/
   extlink=st.st_extlink
   filesz=st.st_size
   dev=st.st_dev
   inode=st.st_ino
   links=st.st_nlink
   uid=st.st_uid
   gid=st.st_gid
   id.=''
   address syscall 'getgrgid' gid 'id.'
   gname=id.gr_name
   group=strip(gname)'('gid')'
   id.=''
   address syscall 'getpwuid' uid 'id.'
   uname=id.pw_name
   user=strip(uname)'('uid')'
   access=ltime(st.st_atime)
   modify=ltime(st.st_mtime)
   change=ltime(st.st_ctime)
   fmajor=st.st_major
   fminor=st.st_minor
   key='RWE'
   i=translate(d2c(st.st_aaudit,4),' SFB','00010203'x)
   aaudit=''
   do j=1 to 3
      if substr(i,j,1)='B' then
         aaudit=aaudit||substr(key,j,1)'= FS  '
       else
         aaudit=aaudit||substr(key,j,1)'= 'substr(i,j,1)'   '
   end
   i=translate(d2c(st.st_uaudit,4),' SFB','00010203'x)
   uaudit=''
   do j=1 to 3
      if substr(i,j,1)='B' then
         uaudit=uaudit||substr(key,j,1)'= FS  '
       else
         uaudit=uaudit||substr(key,j,1)'= 'substr(i,j,1)'   '
   end
   auditid=st.st_auditid
   crtime=ltime(st.st_crtime)
   fformat=word('NA BINARY NL CR LF CRLF LFCR CRNL RECORD',
                ,st.st_filefmt+1)        /* add crnl and REC @DMC @PKC*/
   if fformat='' then
      fformat=st.st_filefmt
   if st.st_type=s_isreg then
      do
      genval=substr(st.st_genvalue,4)
      extattrs= bitand(genval,'08'x)='00'x /* reverse bit */
      extattra= bitand(genval,'04'x)='04'x
      extattrp= bitand(genval,'02'x)='02'x
      extattrl= bitand(genval,'10'x)='10'x  /* @D7A*/
      end
   else
      parse value '- - - -' with extattrs extattra extattrp extattrl
   /*******************************************************************/
   /* set mode flags                                                  */
   /*******************************************************************/
   setuid=st.st_setuid
   setgid=st.st_setgid
   fmode=st.st_mode
   fmode=fmode,
         o2rwx(substr(fmode,1,1)) ||,
         o2rwx(substr(fmode,2,1)) ||,
         o2rwx(substr(fmode,3,1))                /* @DFA*/
   sticky=st.st_sticky
   /*******************************************************************/
   /* if file is a symlink, read the link contents                    */
   /*******************************************************************/
   if st.st_type=s_issym then
      do
      call syscallm 'readlink (path) sympath'
      if retval=-1 then sympath=''
      call makevpath sympath
      end
   /*******************************************************************/
   /* get the real CCSID and text flag from the beginning of st_ccsid */
   /*******************************************************************/
   filetag=c2d(substr(st.st_ccsid,1,2))                        /* 5@D8*/
   if substr(st.st_ccsid,3,1)>='80'x then
     filetag= right(filetag,5,'0') 'ON'                        /* @PEC*/
   else
     filetag= right(filetag,5,'0') 'OFF'                       /* @PEC*/

   aclacc=st.st_accessacl        /* 4@DAA*/
   aclfile=st.st_fmodelacl
   acldir=st.st_dmodelacl
   seclabel=st.st_seclabel
   return 0

/**********************************************************************/
/* changeatt:  change attributes                                      */
/**********************************************************************/
changeatt:
   numeric digits 10                                     /*@P6A*/
   "ADDPOP POPLOC(PATH)"
   select
      when zcmd='MODE' then
         do forever
            fmode=word(fmode,1)     /* @DFA*/
            fmodec=fmode
            setuidc=setuid
            setgidc=setgid
            stickyc=sticky
            "DISPLAY PANEL("pan.p_cngmode")"
            if rc<>0 then leave
            if fmode<>fmodec | setuid<>setuidc |,
                 setgid<>setgidc | sticky<>stickyc then
               do
               call syscallm 'chmod (path)',
                  fmodec setuidc setgidc stickyc
               fmode=fmodec,
                     o2rwx(substr(fmode,1,1)) ||,
                     o2rwx(substr(fmode,2,1)) ||,
                     o2rwx(substr(fmode,3,1))              /* @DFA*/
               if retval<>-1 then leave
               end
         end

      when zcmd='USER' then
         do forever
            uidc=uid
            unamec=uname
            "DISPLAY PANEL("pan.p_cnguser")"
            if rc<>0 then leave
            if uid<>uidc & uidc<>'' then
               do
               call syscallm 'chown (path)' uidc gid
               if retval<>-1 then leave
               end
            else
            if uname<>unamec & unamec<>'' then
               do
               call syscallm 'getpwnam (unamec) pw.'
               if retval=0 then
                  do
                  retval=-1
                  rsn=getjr(errnojr)
                  eno=geterr(errno)
                  "SETMSG MSG("msg.m_scerr")" msgloc
                  iterate
                  end
               if retval>0 then
                  do
                  call syscallm 'chown (path)' pw.pw_uid gid
                  if retval<>-1 then leave
                  end
               end
         end

      when zcmd='GROUP' then
         do forever
            gidc=gid
            gnamec=gname
            "DISPLAY PANEL("pan.p_cnggroup")"
            if rc<>0 then leave
            if gid<>gidc & gidc<>'' then
               do
               call syscallm 'chown (path)' uid gidc
               if retval<>-1 then leave
               end
            else
            if gname<>gnamec &gnamec<>'' then
               do
               call syscallm 'getgrnam (gnamec) gr.'
               if retval=0 then
                  do
                  retval=-1
                  rsn=getjr(errnojr)
                  eno=geterr(errno)
                  "SETMSG MSG("msg.m_scerr")" msgloc
                  iterate
                  end
               if retval>0 then
                  do
                  call syscallm 'chown (path)' uid gr.gr_gid
                  if retval<>-1 then leave
                  end
               end
         end

      when zcmd='UAUDIT' then
         do forever
            zero='00000000'x
            aud=d2c(st.st_uaudit,4)
            ar= bitand(aud,d2c(aud_fread,4))<>zero
            ar= ar + (bitand(aud,d2c(aud_sread,4))<>zero)*2
            aw= bitand(aud,d2c(aud_fwrite,4))<>zero
            aw= aw + (bitand(aud,d2c(aud_swrite,4))<>zero)*2
            ax= bitand(aud,d2c(aud_fexec,4))<>zero
            ax= ax + (bitand(aud,d2c(aud_sexec,4))<>zero)*2
            arc=ar
            awc=aw
            axc=ax
            "DISPLAY PANEL("pan.p_cnguaud")"
            if rc<>0 then leave
            if ar<>arc | aw<>awc | ax<>axc then
               do
               aud=0
               select
                 when arc=1 then aud=aud+aud_fread
                 when arc=2 then aud=aud+aud_sread
                 when arc=3 then aud=aud+aud_fread+aud_sread
                 otherwise
               end
               select
                 when awc=1 then aud=aud+aud_fwrite
                 when awc=2 then aud=aud+aud_swrite
                 when awc=3 then aud=aud+aud_fwrite+aud_swrite
                 otherwise
               end
               select
                 when axc=1 then aud=aud+aud_fexec
                 when axc=2 then aud=aud+aud_sexec
                 when axc=3 then aud=aud+aud_fexec+aud_sexec
                 otherwise
               end
               call syscallm 'chaudit (path)' aud 0
               if retval<>-1 then leave
               end
         end

      when zcmd='AAUDIT' then
         do forever
            zero='00000000'x
            aud=d2c(st.st_aaudit,4)
            ar= bitand(aud,d2c(aud_fread,4))<>zero
            ar= ar + (bitand(aud,d2c(aud_sread,4))<>zero)*2
            aw= bitand(aud,d2c(aud_fwrite,4))<>zero
            aw= aw + (bitand(aud,d2c(aud_swrite,4))<>zero)*2
            ax= bitand(aud,d2c(aud_fexec,4))<>zero
            ax= ax + (bitand(aud,d2c(aud_sexec,4))<>zero)*2
            arc=ar
            awc=aw
            axc=ax
            "DISPLAY PANEL("pan.p_cngaaud")"
            if rc<>0 then leave
            if ar<>arc | aw<>awc | ax<>axc then
               do
               aud=0
               select
                 when arc=1 then aud=aud+aud_fread
                 when arc=2 then aud=aud+aud_sread
                 when arc=3 then aud=aud+aud_fread+aud_sread
                 otherwise
               end
               select
                 when awc=1 then aud=aud+aud_fwrite
                 when awc=2 then aud=aud+aud_swrite
                 when awc=3 then aud=aud+aud_fwrite+aud_swrite
                 otherwise
               end
               select
                 when axc=1 then aud=aud+aud_fexec
                 when axc=2 then aud=aud+aud_sexec
                 when axc=3 then aud=aud+aud_fexec+aud_sexec
                 otherwise
               end
               call syscallm 'chaudit (path)' aud 1
               if retval<>-1 then leave
               end
         end

      when zcmd='FFMT' then
         do forever
            ffmt=st.st_filefmt
            "DISPLAY PANEL("pan.p_cngffmt")"
            if rc<>0 then leave
            call syscallm 'chattr (path)' st_filefmt ffmt
            if retval<>-1 then leave
         end

      when zcmd='EXTATTR' then
         do forever
            if st.st_type<>s_isreg then
               leave
            genval=substr(st.st_genvalue,4)
            extattrs= bitand(genval,'08'x)='00'x /* reverse bit */
            extattra= bitand(genval,'04'x)='04'x
            extattrp= bitand(genval,'02'x)='02'x
            extattrl= bitand(genval,'10'x)='10'x  /* @D7A*/
            oldeas=extattrs
            oldeaa=extattra
            oldeap=extattrp
            oldeal=extattrl  /* @D7A*/
            "DISPLAY PANEL("pan.p_cngexat")"
            if rc<>0 then leave
            genm='00'x
            if oldeas<>extattrs then
               genm=bitor(genm,'08'x)
            if oldeaa<>extattra then
               genm=bitor(genm,'04'x)
            if oldeap<>extattrp then
               genm=bitor(genm,'02'x)
            if oldeal<>extattrl then    /* 2@D7A*/
               genm=bitor(genm,'10'x)
            genval='00'x
            if extattrs=0 then
               genval=bitor(genval,'08'x)
            if extattra=1 then
               genval=bitor(genval,'04'x)
            if extattrp=1 then
               genval=bitor(genval,'02'x)
            if extattrl=1 then            /* 2@D7A*/
               genval=bitor(genval,'10'x)
            genval='000000'x || genval
            genm='000000'x || genm
            call syscallm 'chattr (path)' st_genvalue '(genm) (genval)'
            if retval<>-1 then leave
         end

      when zcmd='BPXWACLS' then     /* access acl  2@DAA */
         call editacl 'acl',path

      when zcmd='BPXWACLD' then     /* dir dflt acl  2@DAA */
         call editacl 'dir',path

      when zcmd='BPXWACLF' then     /* file dflt acl 2@DAA */
         call editacl 'file',path

      otherwise
   end
   zcmd=''
   "REMPOP"
   return

/**********************************************************************/
/* decodemtab:  copy mtab fields to panel variables                   */
/**********************************************************************/
decodemtab:
   arg mtix
   type=mtab.mnte_type.mtix
   cmode=d2c(mtab.mnte_mode.mtix,4)
   z4='00000000'x
   if bitand(cmode,'00000001'x)=z4 then mode='R/W'; else mode='R/O'
   if bitand(cmode,'00000002'x)=z4 then md=md'-'; else md=md'S'
   if bitand(cmode,'00000004'x)=z4 then md=md'-'; else md=md'E'
   if bitand(cmode,'00000008'x)=z4 then md=md'-'; else md=md'U'
   if bitand(cmode,'00000010'x)=z4 then amv='Yes'; else amv='No'
   if bitand(cmode,'00000020'x)=z4 then md=md'-'; else md=md'C'
   if bitand(cmode,'00000040'x)<>z4 then amv='Unmount'   /* @D9A*/
   sysname=mtab.mnte_sysname.mtix
   dirblio=mtab.mnte_diribc.mtix
   datablrd=mtab.mnte_readibc.mtix
   datablwr=mtab.mnte_writeibc.mtix
   dev=mtab.mnte_dev.mtix
   dd=mtab.mnte_dd.mtix
   fstype=mtab.mnte_fstype.mtix
   path=mtab.mnte_path.mtix
                                                               /*@DND*/
   roseclab=mtab.mnte_roseclabel.mtix             /* @DEA*/
   if mtab.mnte_syslist.mtix<>'' then             /* 13@DCA*/
      do
      /* syslist: 2 byte count, 2 byte type, 8 byte names */
      if bitand('0001'x,substr(mtab.mnte_syslist.mtix,3,2))='0000'x then
         amv='I'
       else
         amv='E'
      syslist=substr(mtab.mnte_syslist.mtix,5)
      do syslistc=c2d(substr(mtab.mnte_syslist.mtix,1,2)) by -1 to 1
         amv=amv','strip(substr(syslist,1,8))
         syslist=substr(syslist,9)
      end
      end
   do ix=1 to 21
      call value 'fsparm'ix,,
                 substr(mtab.mnte_parm.mtix,(ix-1)*50+1,50,'_')
   end

   pfsstnor=substr(mtab.mnte_pfsstatusnormal.mtix,1,50,'_')/*@PLC@DIA*/
   pfsstexc=substr(mtab.mnte_pfsstatusexcp.mtix,1,50,'_')  /*@PLC@DIA*/

           /* Get the user ID from the uid and display them both @DOA*/
           /* If uid=0 then privileged mount so clear out info   @DOA*/
   uid=mtab.mnte_fsusrmntuid.mtix                              /*@DOA*/
   if uid <>0 Then                                             /*@DOA*/
   do                                                          /*@DOA*/
     id.=''                                                    /*@DOA*/
     address syscall 'getpwuid' uid 'id.'                      /*@DOA*/
     uname=id.pw_name                                          /*@DOA*/
     user=strip(uname)'('uid')'                                /*@DOA*/
   end                                                         /*@DOA*/
   else                                                        /*@DOA*/
     user=''                                                   /*@DOA*/

   return

/**********************************************************************/
/* filesys_cmd:  process command from filesys display                 */
/**********************************************************************/
filesys_cmd:
   arg selcode
   if selcode<>'' then
      vactc=selcode
    else
      do
      "ADDPOP COLUMN(20) ROW(1)"
      src=popobj(pan.p_smt)
      "REMPOP"
      if src<>0 then return
      end
   "ADDPOP"
   fsix=i
   select
      when vactc='A' then
         do
         call decodemtab fsix
         do forever
            st.=
            if mtab.mnte_status.fsix=0 then
               do
               call syscallm "statfs (fsname) st."
               end
            blksz=st.stfs_blocksize
            total=st.stfs_total
            avail=st.stfs_avail
            inuse=st.stfs_inuse
            nosuid=st.stfs_nosuid
            nosec=st.stfs_nosec                                 /*@D6A*/
            "DISPLAY PANEL("pan.p_mtstat")"
                                                              /*3@DND*/
            if rc<>0 then leave
            if zcmd='SHOWOBJ' then
               do
               call showobj
               iterate
               end
         end
         end

      when vactc='U' then
         do
         opt=''
         "DISPLAY PANEL("pan.p_mtunmt")"
         if rc=0 then
            do
            if opt='' then
               mode=mtm_normal
             else
               mode=value('mtm_'opt)
            if wtm<>'' then
               do
               call syscalls 'SIGON'
               address syscall 'sigaction' sigalrm sig_cat 0 'ohdl oflg'
               address syscall 'sigprocmask' sig_unblock,
                  sigaddset(sigsetempty(),sigalrm) 'mask'
               address syscall "alarm" wtm
               end
            call syscallm "unmount (fsname)" mode
            srv=retval
            if wtm<>'' then
               do
               address syscall "alarm 0"
               address syscall 'sigaction' sigalrm ohdl oflg 'x y'
               call syscalls 'SIGOFF'
               end
            if srv=-1 then
               do
               "REMPOP"
               call filesys_cmd vactc
               end
            end
         end

      when vactc='R' then
         if statnum=4 then      /* draining   @DJC*/
            do
            opt=''
            call syscallm "unmount (fsname)" mtm_reset
            end
          else
            do
            opt=''
            "DISPLAY PANEL("pan.p_unquiesce")"
            if rc=0 then
             if type='ZFS' then                         /* 3@DJA*/
               call zfsunquiesce
              else
               call syscallm "unquiesce (fsname) 1"
            end

      when vactc='M' then       /* 60@D7A*/
         do
         opt=''
         call decodemtab fsix
         if mode='R/W' then
            newmode='R/O'
          else
            newmode='R/W'
         if amv='No' then               /* 3@D9D  16@D9A */
            do
            newamv='Yes'
            newamv2='Unmount'
            end
         else
         if amv='Yes' then
            do
            newamv='No'
            newamv2='Unmount'
            end
         else
            do
            newamv='No'
            newamv2='Unmount'
            end
         oldsys=sysname
         fssystem=''
         "DISPLAY PANEL("pan.p_cngfsat")"
         if rc=0 then
            select

               when vactc='C' then
                  do
                  "DISPLAY PANEL("pan.p_remount")"
                  if rc=0 then
                     do
                     call syscallm "unmount (fsname)" mtm_remount
                     srv=retval
                     if srv=-1 then
                        do
                        "REMPOP"
                        call filesys_cmd 'M'
                        end
                     end
                  end

               when vactc='M' then         /* xx@DCA*/
                  do
                  vactc=substr(amv,1,1)
                  do sli=1 to 32                        /* 3@PCA*/
                     call value 'SYSNM'sli,''
                  end
                  if vactc='I' | vactc='E' then
                     do
                     amvsl=translate(substr(amv,3),' ',',')
                     do sli=1 to words(amvsl)
                        call value 'SYSNM'sli,word(amvsl,sli)
                     end
                     end
                  "ADDPOP"
                  "DISPLAY PANEL("pan.p_selamt")"
                  rrc=rc
                  "REMPOP"
                  if rrc=0 then

                     if vactc='Y' | vactc='N' | vactc='U' then
                           do
                           mt.=''
                           mt.mnte_rflags=3
                           mt.mnte_fsname=fsname
                           if vactc='N' then
                              mt.mnte_mode=mnt_mode_noautomove
                           else
                           if vactc='Y' then
                              mt.mnte_mode=0
                           else
                              mt.mnte_mode=mnt_mode_aunmount
                           call syscallm 'mount mt.'
                           end
                     else
                     if vactc='I' | vactc='E' then
                        do
                        mt.=''
                        mt.mnte_rflags=3
                        mt.mnte_mode=0              /* @PDA*/
                        mt.mnte_fsname=fsname
                        if vactc='I' then
                           mt.mnte_syslist='0000'x
                        else
                           mt.mnte_syslist='0001'x
                        slc=0
                        do sli=1 to 32
                           sysnm=value('SYSNM'sli)
                           if sysnm<>'' then
                              do
                              slc=slc+1
                              mt.mnte_syslist=mt.mnte_syslist ||,
                                              translate(left(sysnm,8))
                              end
                        end
                        mt.mnte_syslist=d2c(slc,2) || mt.mnte_syslist
                        call syscallm 'mount mt.'
                        end

                  end

               when vactc='O' then
                  do
                  mt.=''
                  mt.mnte_rflags=1
                  mt.mnte_fsname=fsname
                  mt.mnte_sysname=fssystem
                  call syscallm 'mount mt.'
                  end

               when vactc='S' then                           /*14@DKA*/
                  do
                  "DISPLAY PANEL("pan.p_samemode")"
                  if rc=0 then
                     do
                     call syscallm "unmount (fsname)" mtm_samemode
                     srv=retval
                     if srv=-1 then
                        do
                        "REMPOP"
                        call filesys_cmd 'M'
                        end
                     end
                  end

               otherwise
                  nop
            end
         end

      otherwise
         "REMPOP"
         call filesys_cmd
   end
   "REMPOP"
   return

/**********************************************************************/
/* zfsunquiesce                                                       */
/************************************************************** 12@DJA*/
zfsunquiesce:
   z4='00000000'x
   agid='AGID' || '5401'x || left(strip(fsname),45,'00'x) ||,
        copies('00'x,33)
   pctbf=d2c(133,4) ||,                     /* unquiesce     */
         d2c(32,4)  ||,                     /* p0: ofs agrid */
         'ffffffff'x ||,                    /* p1: force unq */
         z4||z4||z4||z4||z4||,              /* p2-p6     */
         agid
   call syscallm 'pfsctl ZFS 1073741829 pctbf'
   return

/**********************************************************************/
/* filesystable:  build file system table                             */
/**********************************************************************/
filesystable:
   call syscallm 'getmntent mtab.'
   if retval=-1 then return
   "TBCREATE MTAB NAMES" ||,
    "(S,FSNAME,STATUS,SYSNAME,AM,RO,BLKCNT,PATH,TYPE,I,LOCATE," ||,
    "STATNUM,USERCOL) NOWRITE REPLACE"             /*@DPC@DOC@08C@DHC*/
   if pos('sysname',mtabf2)>0 then                        /*@0UC3@08A*/
      "TBSORT MTAB FIELDS(SYSNAME,C,A,FSNAME,C,A)"
    else
      "TBSORT MTAB FIELDS(FSNAME)"
   s=''
   do i=1 to mtab.0
      call setmntent
      "TBADD MTAB ORDER"
   end
   return

/**********************************************************************/
/* setmntent:  set vars for a mount entry                             */
/**********************************************************************/
setmntent:
   fsname=mtab.mnte_fsname.i
   type=mtab.mnte_fstype.i              /* @DHA*/
   locate=translate(fsname)
   sysname=mtab.mnte_sysname.i          /* 8@08A*/
   sysname=mtab.mnte_sysname.i
   blkcnt=mtab.mnte_diribc.i+mtab.mnte_readibc.i+mtab.mnte_writeibc.i
   path=mtab.mnte_path.i
   cmode=d2c(mtab.mnte_mode.i,4)
   z4='00000000'x
   if bitand(cmode,'00000010'x)=z4 then am='Yes'; else am='No'
   if bitand(cmode,'00000040'x)<>z4 then am='U'   /* @DFA*/
   if mtab.mnte_syslist.i<>'' then                /* 8@DFA*/
      do
      /* syslist: 2 byte count, 2 byte type, 8 byte names */
      if bitand('0001'x,substr(mtab.mnte_syslist.i,3,2))='0000'x then
         am='I'
       else
         am='E'
      end
   if bitand(cmode,'00000001'x)=z4 then ro='No'; else ro='Yes'

    /* Get user ID from uid to display in User ID column of mount table.
       If uid=0 then column will be blank. If user ID is blank for
       whatever reason, then show UID instead.                   @DOA*/
   uid=mtab.mnte_fsusrmntuid.i                                 /*@DOA*/
   if uid = 0 then                                             /*@DOA*/
     usercol=''                                            /*@DPC@DOA*/
   else                                                        /*@DOA*/
   do                                                          /*@DPA*/
     id.=''                                                    /*@DPA*/
     address syscall 'getpwuid' uid 'id.'                      /*@DPA*/
     if id.pw_name='' then                                     /*@DPA*/
       usercol=uid                                             /*@DPA*/
     else                                                      /*@DPA*/
       usercol=strip(id.pw_name)                               /*@DPA*/
   end                                                         /*@DPA*/

   statnum=mtab.mnte_status.i
   statnum2=mtab.mnte_status2.i                                /*@DIA*/
   j=statnum
   k=statnum2                                                  /*@DIA*/
   select                                                     /*5@DIA*/
     when k=1  then "GETMSG MSG("lit"022) LONGMSG(STATUS)"
     when k=2  then "GETMSG MSG("lit"023) LONGMSG(STATUS)"
     when k=4  then "GETMSG MSG("lit"024) LONGMSG(STATUS)"
     when k=8  then "GETMSG MSG("lit"019) LONGMSG(STATUS)"
     when k=16 then "GETMSG MSG("lit"020) LONGMSG(STATUS)"
     when k=32 then "GETMSG MSG("lit"021) LONGMSG(STATUS)"
     otherwise
      do                                                       /*@DIA*/
       select
        when j=0 then status=L#mt0
        when j=1 then status=L#mt1
        when j=2 then status=L#mt2
        when j=4 then status=L#mt4
        when j=8 then status=L#mt8
        when j=16 then status=L#mt16
        when j=32 then status=L#mt32
        when j=64 then status=L#mt64
        when j=128 then
         do
           quiesr=strip(mtab.mnte_qjobname.i),
                  '('mtab.mnte_qpid.i')'
           "GETMSG MSG("lit"008) LONGMSG(STATUS)"
         end
        when j=130 then status=L#mt130
        otherwise
               "GETMSG MSG("lit"009) LONGMSG(STATUS)"
       end                                                   /*@DIA*/
      end                                                    /*@DIA*/
   end
   return

/**********************************************************************/
/* fsattr: show fs attributes using pathname                    44@D5A*/
/**********************************************************************/
fsattr:
   "ADDPOP"
   do forever
      st.=
      call syscallm "statvfs (path) st."
      if retval=-1 then
         return
      if st.stfs_fsid<>0 & datatype(st.stfs_fsid,'W') then
         do
         address syscall 'getmntent mtab.' st.stfs_fsid
         if retval<>-1 then
            do                      /* @08A*/
            i=1                     /* @08A*/
            call setmntent          /* @08A*/
            call decodemtab 1
            end                     /* @08A*/
         end
      blksz=st.stfs_blocksize
      total=st.stfs_total
      avail=st.stfs_avail
      inuse=st.stfs_inuse
      nosuid=st.stfs_nosuid
      nosec=st.stfs_nosec                                       /*@D6A*/
      "DISPLAY PANEL("pan.p_mtstat")"
                                                              /*3@DND*/
      if rc<>0 then leave
      if zcmd='SHOWOBJ' then
         do
         call showobj
         iterate
         end
   end
   "REMPOP"
   return

/**********************************************************************/
/* run_diff:  get args for diff and run it                            */
/**********************************************************************/
run_diff:
   parse arg vpathflg opt
   pgmpath=diffpath
   call syscallm "access (pgmpath)" x_ok
   if retval=-1 then
      do
      "SETMSG MSG("msg.m_nopgm")" msgloc
      return
      end
   call syscallm "access (path)" r_ok
   if retval=-1 then
      do
      msgpath=path
      "SETMSG MSG("msg.m_noacc")" msgloc
      return
      end
   parm.0=5
   parm.1=pgmpath
   parm.2=opt
   parm.3='-c'
   parm.4=path
   parm.5=path
   "ADDPOP"
   done=0
   do until done
      call makevpath parm.5
      vtext=vpathflg
      "DISPLAY PANEL("pan.p_getpath")"
      if rc<>0 then
         do
         "REMPOP"
         return
         end
      parm.5=makepath()
      call syscallm "access (parm.5)" r_ok
      if retval=-1 then
         do
         msgpath=parm.5
         "SETMSG MSG("msg.m_noacc")" msgloc
         iterate
         end
      vtext='CO'
      "ADDPOP"
      stdout=''
      temppath=''
      do until done
         call makevpath stdout
         "DISPLAY PANEL("pan.p_getpath")"
         if rc<>0 then
            do
            "REMPOP"
            "VGET (ZVERB)"
            if zverb<>"CANCEL" then
               do
               "REMPOP"
               return
               end
            leave
            end
         stdout=makepath()
         if length(stdout)=0 |temppath==stdout then
            do
            tempname=1
            stdout='/tmp/'sysvar('SYSUID')'.'time('L')'.ishell'
            temppath=stdout
            end
          else
            tempname=0
         call syscallm "creat (stdout)" 600
         if retval=-1 then
            iterate
         fd1=retval
         fd2=retval
         done=1
      end
   end
   "REMPOP"                   /* @0PM*/
   "REMPOP"                   /* @0PM*/
   env.0=0
   fd0=-1
   cmd=diffpath'...'
   call spawnpgm pan.p_getpath
   select
      when retcode=0 then
         "SETMSG MSG("msg.m_nodiff")"
      when retcode=1 then
         do
         call syscallm 'stat (stdout) st.'
         if st.st_size>0 & st.st_type=s_isreg then
            call obrowse stdout,0
          else
            "SETMSG MSG("msg.m_diff")"
         end
      otherwise
   end
   address syscall 'close' fd1
   if tempname=1 then
      do
      address syscall 'unlink (stdout)'
      stdout=''
      end
   return

/**********************************************************************/
/* find_opts:  get opts for search                                    */
/**********************************************************************/
find_opts:
   optrc=1
   "ADDPOP"
   stdout=''
   done=0
   temppath=''
   do until done
      vtext=arg(1)
      call makevpath stdout
      "DISPLAY PANEL("pan.p_getpath")"
      if rc<>0 then
         do
         "REMPOP"
         leave
         end
      stdout=makepath()
      if length(stdout)=0 | temppath==stdout then
         do
         tempname=1
         stdout='/tmp/'sysvar('SYSUID')'.'time('L')'.ishell'
         temppath=stdout
         end
       else
         tempname=0
      "ADDPOP"
      do until done
         "DISPLAY PANEL("pan.p_srchstr")"
         if rc<>0 then
            do
            "REMPOP"
            "VGET (ZVERB)"
            if zverb<>'CANCEL' then
               done=1
            if zverb='EXIT' then
               "REMPOP"
            leave
            end
         optrc=0
         done=1
      end
   end
   if done=0 then
      "REMPOP"
   return optrc

/**********************************************************************/
/* spawnpgm:  spawn a program                                         */
/**********************************************************************/
spawnpgm:
   arg pan
   retcode=-1
   fd.0=fd0
   fd.1=fd1
   fd.2=fd2
   "CONTROL DISPLAY LOCK"
   "SETMSG MSG("msg.m_gentxt")" msgloc
   "DISPLAY PANEL("pan")"
   call runopts 'env.'
   call syscallm 'spawn (pgmpath) 3 fd. parm. env.'
   pid=retval
   address syscall 'waitpid (pid) st. 0'
   if st.w_ifexited=0 then
      "SETMSG MSG("msg.m_nopgm")" msgloc
   else
      retcode=st.w_exitstatus
   return retcode

/**********************************************************************/
/* print_hdr:  print top of page heading                              */
/**********************************************************************/
print_hdr:
   arg pg
   if pg>0 then
      hdr1=right('Page:' pg,zlsttrun)
   page='PAGE'
   do hdri=1 to hdr0
      'LIST BUFNAME(HDR'hdri') LINELEN('length(value('hdr'hdri))')' page
      page=''
   end
   return

/**********************************************************************/
/* makepath: return pathname made from vpath01-vpath20 vars           */
/**********************************************************************/
makepath:
   retpath=''
   quote="'"
   do i=1 to 20
      tpath=value('vpath' || right(i,2,0))
      if tpath='' then
         leave
      if substr(tpath,1,1)=quote then
         tpath=substr(tpath,2)
      if length(tpath)=0 then
         iterate
      if substr(tpath,length(tpath),1)=quote then
         tpath=substr(tpath,1,length(tpath)-1)
      retpath=retpath || tpath
   end
   return retpath

/**********************************************************************/
/* makevpath: set vpath01-vpath20 vars from a pathname                */
/**********************************************************************/
makevpath:
   parse arg fullpath
   quote="'"
   do i=1 to 20
      parse var fullpath tpath 63 fullpath
      if length(tpath)=0 then
         leave
      if substr(tpath,1,1)=quote | substr(tpath,1,1)==' ' |, /* @0GC*/
         substr(tpath,1,1)='_' then                          /* @0GA*/
         tpath=quote || tpath
      if substr(tpath,length(tpath),1)=quote |,
           substr(tpath,length(tpath),1)='_' |,              /* @0GA*/
           substr(tpath,length(tpath),1)==' ' then
         tpath=tpath || quote
      xx=value('vpath' || right(i,2,0),tpath)
   end
   do i=i to 20
      xx=value('vpath' || right(i,2,0),'')
   end
   return

/**********************************************************************/
/* showobj:  show selected object                                     */
/**********************************************************************/
showobj:
   call makevpath path
   "ADDPOP"
   "DISPLAY PANEL("pan.p_obj")"
   "REMPOP"
   return

/**********************************************************************/
/* setcolors: setup colors                                            */
/*                                                                    */
/* cltd  directory       clsa  ext attr           clst  trunc name    */
/* cltr  reg file        clsu  setuid/gid                             */
/* cltf  fifo            clss  sticky                                 */
/* cltc  char spec       clsx  exec perm                              */
/* clts  symlink         clso  not yours                              */
/*                                                                    */
/* 33  white     36  green       39  turq                             */
/* 34  red       37  pin                                              */
/* 35  blue      38  yellow      32  default                          */
/*                                                                    */
/**********************************************************************/
setcolors:
   parse arg coloropt
   clvars='CLNO CLTD CLTR CLTF CLTC CLTS CLSA CLSU CLSS CLSX CLSO CLST'
   if coloropt=0 then
      do
      "VGET ("clvars") PROFILE"
      return
      end
   "DISPLAY PANEL("pan.p_dircolor")"
   if rc<>0 then
      "VGET ("clvars") PROFILE"
    else
      "VPUT ("clvars") PROFILE"
   return

/**********************************************************************/
/* color: determine color attribute byte                              */
/**********************************************************************/
color:
   colorchoice=xrange('33'x,'39'x) || '3f3e'x
   if gotcolors<>1 then
      call setcolors 0
   coloratt='32'x
   if clno='/' then return coloratt
   if filetpn=1 & datatype(cltd,'W') then
      coloratt=substr(colorchoice,cltd,1)
   else
   if filetpn=2 & datatype(cltc,'W') then
      coloratt=substr(colorchoice,cltc,1)
   else
   if filetpn=3 & datatype(cltr,'W') then
      coloratt=substr(colorchoice,cltr,1)
   else
   if filetpn=4 & datatype(cltf,'W') then
      coloratt=substr(colorchoice,cltf,1)
   else
   if filetpn=5 & datatype(clts,'W') then
      coloratt=substr(colorchoice,clts,1)

   if datatype(clso,'W') & fileuid<>myuid then
      coloratt=substr(colorchoice,clso,1)
   if datatype(clsx,'W') & filetpn=3 &,
        bitand(strip(filemd,'B','+'),'010101'x)<> '000000'x then
      coloratt=substr(colorchoice,clsx,1)
   if datatype(clst,'W') & filenmtrunc=1 then
      coloratt=substr(colorchoice,clst,1)
   if datatype(clsu,'W') & filesid=1 then
      coloratt=substr(colorchoice,clsu,1)
   if datatype(clss,'W') & filestk=1 then
      coloratt=substr(colorchoice,clss,1)
   if datatype(clsa,'W') & filexa=1 then
      coloratt=substr(colorchoice,clsa,1)

   return coloratt

/**********************************************************************/
/* actionlist: display a table as an action list                      */
/*                                                                    */
/*   the panel must contain a scrollable dynamic area called DYN      */
/*   and the table must contain the name S                            */
/*   On return,                                                       */
/*     SELROW.SELLEV. contains the row numbers for all selected rows  */
/*     SELROW.SELLEV.0 contains the number of selected rows           */
/*     SELROW.SELLEV.SEL_TOP contains the top row number              */
/*   The table is updated for each selected row with S containing     */
/*   the action code.                                                 */
/**********************************************************************/

actionlist:
   procedure expose selrow. sellev zverb vpath01 vpath02 msg. pan. path,
     st_type L#ftypes st_size vdirfc st_mtime st_uid pw_name st_mode,
     st_setuid st_setgid st_sticky st_gid st_genvalue,
     f_ok noconf m_scerr pw_uid gmt,
     enopref ejrcomp tm_mon tm_mday tm_year tm_hour tm_min vdirfu,
     pgmbrws iplace tplace althelp pw_dir st_accessacl,
     st_fmodelacl st_dmodelacl ltime. flsort flsorts myuid,
     absel vdirvb alcurcmd pattern. noautosk                  /* @DFC*/
   true=1
   parse arg id,first,selrow,panel,format,name,dirlst
   selrow.sellev.0=0
   sel=0
   selrow.sel_top=first
   "TBSTATS" id "ROWCURR(TOTAL)"
   if rc<>0 | datatype(total,'W')=0 then return 0
   if total=0 then
      do
      zverb='EMPTY'
      return 0
      end
   "VGET (ZSCREENW ZSCREEND)"
   "PQUERY PANEL("panel") AREANAME(DYN)",
      "WIDTH(WIDTH) DEPTH(DEPTH)"
   if rc>8 then                                              /* 5@0JA*/
      do
      say zerrmsg zerrlm
      zverb = 'RETURN'
      end
   if rc<>0 then
      return 0
   total=strip(total,'L','0')
   if first>total then
      first=1
   if selrow>total | datatype(selrow,'W')=0 then  /* @DHC*/
      selrow=1
   ddi=(selrow-first)*width+2
   if ddi<2 then ddi=2
   hexdata=xrange('00'x,'0d'x) || xrange('10'x,'3f'x)
   do forever

      dynhdr='3e4040'x
      map=format
      modify=0
      do while map<>''
         parse var map . v j '<' t '>' map
         parse var t pref '(' subvar ')'
         if subvar<>'' then
            t=pref'-'value(subvar)
         if length(t)<>j then
            t=left(t,j)
         dynhdr=dynhdr || t || '  '
         if v='$' then
            modify=1
      end
      if first>total then
         first=total
      rowsh='Row' first 'of' total
      dynhdr=substr(dynhdr,1,width-length(rowsh)-4) ' 'rowsh
      dyn=''
      linenum=0
      "TBTOP" id
      "TBSKIP" id "NUMBER("first-1") NOREAD"
      do cnt=1 to depth
         "TBSKIP" id
         if rc>0 then leave
         if dirlst=1 & filecd='' then
            filecd=substr(ltime(filect),1,16)
         map=format
         linenum=linenum+1
         if s='' then s='_'
         ln=''
         do while map<>''
            parse var map v j t '<' . '>' map
            if j='r' then
               ln=ln || right(value(v),t)'  '
            else
            if j='c' then
               ln=ln || center(value(v),t)'  '
            else
            if j='$' then        /* modify allowed */
               do
               ln=ln || '31'x || left(value(v),t) '32'x
               updname=v
               end
            else                                      /* 8@DFA*/
            if j='p' then        /* perms in rwxrwxrwx format */
               do
               perm=value(v)
               if length(perm)=3 then
                  perm=' ' || perm
               else
               if length(perm)=4 then
                  nop
               else
                  perm=' 000'
               perms=substr(perm,1,1) ||,
                     o2rwx(substr(perm,2,1)) ||,
                     o2rwx(substr(perm,3,1)) ||,
                     o2rwx(substr(perm,4,1))
               ln=ln || left(perms,t)'  '
               end
             else
              if id<>'DIR' then
               ln=ln || left(value(v),t)'  '
              else
               do
               if map='' then
                  do
                  filenmtrunc=(length(ln)+length(value(v))+3)>width
                 if ln <> '' then                            /* @0IA*/
                  ln=substr(ln,1,length(ln)-1) || color()
                 else                                        /* @0IA*/
                  ln = color()                               /* @0IA*/
                  end
               ln=ln || left(translate(value(v),,hexdata,' '),t)'  '
               end
         end
         if noautosk='/' then                          /* @DFA*/
            s#attr='30'x                               /* @DFA*/
          else
            s#attr='32'x                               /* @DFA*/
         if modify then
            dyn=dyn || '31'x || s || s#attr substr(ln,1,width-4)
          else
            dyn=dyn || '31'x || s || s#attr || substr(ln,1,width-3)
      end

      do cnt=cnt to depth
         dyn=dyn || copies(' ',width)
      end
      zcmd=''
      if id='DIR' then
         do
         address syscall 'geteuid'
         uidline='EUID='retval
         patix=pattern.0          /* 7@DFC*/
         if patix>0 then    /* if filter short and on show it in red */
            if length(pattern.patix)>10 then
               uidline=uidline '34'x || 'FILTER=ON' || '32'x
             else
               uidline=uidline '34'x || pattern.patix || '32'x
         end
      if id='DIR' then panpath='32'x || uidline ' ' path
      if alcurcmd=1 then                        /* 5@DBA*/
         curfield='CURSOR(ZCMD)'
       else
         curfield="CURSOR(DYN) CSRPOS("ddi")"
      alcurcmd=0
      "DISPLAY PANEL("panel")" curfield         /* @DBC*/
      src=rc
      "VGET (ZSCROLLA ZSCROLLN ZVERB)"
      if src<>0 then
         return 0
       dynwrk=dyn
       cmd=translate(zcmd)
       if id='DIR' & word(cmd,1)='FILTER' then          /* 6@DFC*/
          do
          parse var zcmd . cmd
          zverb='FILTER' cmd
          return 0
          end
       if word(cmd,1)='SEL' then
          do
          absel=word(cmd,2)
          cmd=''
          end
        else
          absel=''
       do selrow=1 by 1 while dynwrk<>''
          dynln=substr(dynwrk,1,width)
          tag=substr(dynln,1,1)
          dynwrk=substr(dynwrk,width+1)
          if tag='3f'x then
             do
             sel=sel+1
             selrow.sellev.sel=first+selrow-1
             "TBTOP" id
             "TBSKIP" id "NUMBER("selrow.sellev.sel")"
             s=substr(dynln,2,1)
             if s='' then s='_'
             if modify then
                do
                upd=substr(dynln,4)
                parse var upd '3f'x upd '32'x
                if upd<>'' then
                   do
                   update=strip(upd)
                   call value updname,update
                   end
                end
             "TBPUT" id
             end
       end
       if zverb='UP' | zverb='DOWN' then
          do
          ddi=2
          alcurcmd=1
          if lvline>0 then
             select
               when zscrolla='PAGE' then
                 if zverb='UP' then
                    first=first-lvline
                  else
                    first=first+lvline

               when zscrolla='MAX' then
                 if zverb='UP' then
                    first=1
                  else
                    first=total-lvline+2

               otherwise
                  if zverb='UP' then
                     first=first-zscrolln
                   else
                     first=first+zscrolln
             end
          if first>total-lvline+1 then
             first=total-lvline+2
          if first<1 then
             first=1
          selrow.sel_top=first
          end
       else
       select
         when cmd='' & csrfld='DYNHDR' & id='DIR' & sel=0 then
            do
            dynstr=reverse(substr(dynhdr,1,csrpos))
            parse var dynstr dyncol .
            csrcode=substr(dyncol,length(dyncol),1)
            sortx=pos(csrcode,'FTP-OC')
            if sortx>0 then
               do
               flsort=substr('NTPSOM',sortx,1)    /* @P8C*/
               sortkey=word("FILENM,C,A FILETP,C,A FILEMD,C,A",
                            "FILESZ,C,D FILEUSR,C,A FILECT,C,D",sortx)
               "VPUT (FLSORT) PROFILE"
               sortx=pos(flsorts,'NCTPSOM')
               if sortx>0 then
                  sortkey=sortkey',' ||,
                    word("FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A",
                         "FILESZ,C,D FILEUSR,C,A FILECT,C,D",sortx)
              "TBSORT DIR FIELDS("sortkey")"
               end
             else
               done=1
            end
         when cmd='' & csrfld='DYN' & id='DIR' then
            do
            csrcol=csrpos//width
            dynstr=reverse(substr(dynhdr,1,csrcol))
            parse var dynstr dyncol .
            csrcode=''
            if length(dyncol)>0 then
               do
               csrcode=substr(dyncol,length(dyncol),1)
               csrline=(width+csrpos-1)%width
               end
            zverb='SELECT' csrcode csrline
            if csrcode<>'' | sel<>0 then
               done=1
            end
         when cmd='' then
            done=1
         when cmd='REFRESH' | cmd='REFR' then  /* 5@DHA*/
            do
            done=1
            zverb='REFRESH'
            end
         when abbrev('LOCATE',word(cmd,1)) then
           do
           oldfirst=0
           find=word(cmd,2)
           if find='' then
              "SETMSG MSG("msg.m_noarg")" msgloc
            else
              do 2
              "TBTOP" id
              "TBSKIP" id "NUMBER("first")"
              do newfirst=first by 1
                 "TBSKIP" id
                 if rc<>0 then leave
                 if substr(locate,1,length(find))=find then
                    leave
              end
              if rc=0 then
                 do
                 first=newfirst+1
                 selrow.sel_top=first
                 leave
                 end
               else
                 if first<2 then
                    do
                    if oldfirst<>0 then
                       first=oldfirst
                    leave
                    end
                  else
                    do
                    oldfirst=first
                    first=1
                    end
              end
           end
         when cmd='NOAB' & id='DIR' then
           do
           pan.p_dir=pan.p_dirshort
           vdirvb=''
           "VPUT (VDIRVB) PROFILE"
           done=1
           end
         when cmd='AB' & id='DIR' then
           do
           pan.p_dir=pan.p_dirlong
           done=1
           vdirvb='/'
           "VPUT (VDIRVB) PROFILE"
           end
         when cmd='SHOWOBJ' then
           do
           call makevpath name
           "ADDPOP"
           "DISPLAY PANEL("pan.p_obj")"
           "REMPOP"
           end
         when word(cmd,1)='SH' & words(zcmd)>1 then
           do                                          /*start @05A*/
           svpath=path
           call shcmd delword(zcmd,1,1)
           path=svpath
           end
         when word(cmd,1)='EX' & words(zcmd)>1 then
           do
           svpath=path
           call shcmd delword(zcmd,1,1),1
           path=svpath
           end                                        /*end @05A*/
         when word(cmd,1)='SORT' & id='DIR' &,
              flsorts<>'' then                       /* 20@DBC*/
           do
           "ADDPOP"
           "DISPLAY PANEL("pan.p_dirsort")"
           src=rc
           "REMPOP"
           if src=0 then
             do
             sortx=pos(flsort,'NCTPSOM')
             if sortx=0 then sortx=1
             sortkey=word("FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A",
                          "FILESZ,C,D FILEUSR,C,A FILECT,C,D",sortx)
             sortx=pos(flsorts,'NCTPSOM')
             if sortx>0 then
                sortkey=sortkey',' ||,
                   word("FILENM,C,A LOCATE,C,A FILETP,C,A FILEMD,C,A",
                        "FILESZ,C,D FILEUSR,C,A FILECT,C,D",sortx)
             "TBSORT DIR FIELDS("sortkey")"
             "VPUT (FLSORT FLSORTS) PROFILE"
            end
           end
         when word(cmd,1)='COLORS' & id='DIR' then   /* 20@DBC*/
           do
           "ADDPOP"
           call setcolors 1
           "REMPOP"
           end
         otherwise
            "SETMSG MSG("msg.m_invcmd")"
       end
       if done=1 then leave
       if cmd<>'' then alcurcmd=1
   end
   selrow.sellev.0=sel
   return sel
/**********************************************************************/
/* o2rwx: convert octal permissions to rwf format                     */
/***************************************************************  @DFA*/
o2rwx: procedure
   parse arg perm
   if bitand(perm,'04'x)<>'00'x then
      rwx='r'
    else
      rwx='-'
   if bitand(perm,'02'x)<>'00'x then
      rwx=rwx || 'w'
    else
      rwx=rwx || '-'
   if bitand(perm,'01'x)<>'00'x then
      rwx=rwx || 'x'
    else
      rwx=rwx || '-'
   return rwx

/**********************************************************************/
/* dirstat:  get stat for an item in the directory list               */
/**********************************************************************/
dirstat:
   arg stix
   numeric digits 10                                     /*@07A*/
   if datatype(st.stix.st_type,'W'),
       & st.stix.st_type>0 & st.stix.st_type<6 then
      filetp=substr('   'L#ftypes,st.stix.st_type*4,4)
   filetpn=st.stix.st_type
   if pos('M',st.stix.st_size)<>0 Then                   /*@0VA*/
      filesz='*' || right(st.stix.st_size,10)            /*@0VA*/
   else                                                  /*@0VA*/
      filesz=right(st.stix.st_size,11)                   /*@0VC*/
   fileuid=st.stix.st_uid
   filect=right(st.stix.st_mtime,10)
   if datatype(fileuid,'W') then
    if cachediruid.fileuid=fileuid then
       fileusr=cachediruid.fileuid.1
     else
      do
      pw.=''
      address syscall 'getpwuid' fileuid 'pw.'
      fileusr=pw.pw_name
      cachediruid.fileuid=fileuid
      cachediruid.fileuid.1=fileusr
      end
    else
      fileusr=''
   filemd=st.stix.st_mode
   filexa=(bitand(substr(st.stix.st_genvalue,4),'16'x)<>'00'x) /*LAP--*/
   filesid=(st.stix.st_setuid=1 | st.stix.st_setgid=1)
   filestk=st.stix.st_sticky
   if st.stix.st_accessacl=1 | st.stix.st_fmodelacl=1 |, /* 2@DAA*/
        st.stix.st_dmodelacl=1 then
      filemd='+'filemd
   return

/**********************************************************************/
/* popobj:  display popup and handle showobj command                  */
/**********************************************************************/
popobj:
   arg panel
   /* 4@0ED*/
   do forever
      "DISPLAY PANEL("panel")"
      src=rc
      if src<>0 | zcmd='' then
         leave
      if zcmd='SHOWOBJ' then
         call showobj
       else
         "SETMSG MSG("msg.m_invcmd")" msgloc
   end
   return src

/**********************************************************************/
/* Name:    ltime                                                     */
/* Purpose: get gm time from epoch time                               */
/**********************************************************************/
ltime:
   arg tm
   numeric digits 10
   if datatype(tm,'W')<>1 | datatype(ltime.0,'W')<>1 then
      return gtime(tm)
   if tm=-1 then return ''   /* @DHA */
   writetm='L'tm
   address syscall 'write' ltime.0 'writetm'
   if retval=-1 then   /* if error clean up coprocess and retry 20@DFA*/
      do
      address syscall 'close' ltime.0
      address syscall 'close' ltime.1
      address syscall 'waitpid (ltime.3) st. 0'
      call runcoprocess
      if datatype(tm,'W')<>1 | datatype(ltime.0,'W')<>1 then
         return gtime(tm)
      address syscall 'write' ltime.0 'writetm'
      if retval=-1 then /* 2 errors in a row, turn off time conv */
         do
         address syscall 'close' ltime.0
         ltime.0=''
         gmt='GMT'
         address syscall 'close' ltime.1
         address syscall 'waitpid (ltime.3) st. 0'
         return gtime(tm)
         end
      end
   address syscall 'read' ltime.1 'ltimebf' 20
   if retval=-1 then return gtime(tm)
   return ltimebf

   address syscall 'close' ltime.0
   address syscall 'close' ltime.1
   address syscall 'waitpid (ltime.3) st. 0'

/**********************************************************************/
/* Name:    gtime                                                     */
/* Purpose: get gm time from epoch time                               */
/**********************************************************************/
gtime:
   arg tm
   numeric digits 10
   if tm=0 | datatype(tm,'W')<>1 then
      return ''
   if tm=-1 then return ''   /* @DHA */
   numeric digits
   call syscallm 'gmtime' tm 'tm.'
   if retval=-1 then return ''
   return right(tm.tm_year,4,0)'-' ||,
          right(tm.tm_mon,2,0)'-'right(tm.tm_mday,2,0),
          right(tm.tm_hour,2,0)':'right(tm.tm_min,2,0) 'GMT'

/**********************************************************************/
/* usersetup: setup a user                                            */
/**********************************************************************/
usersetup:
   arg mode uid
   cmd='altuser ('user')'
   ocmd=''
   address syscall 'getpwnam (user) pw.'
   if retval<1 | pw.pw_uid=dfltuser.pw_uid |  ,        /* @06C*/
      datatype(pw.pw_uid,W)=0 then                     /* @0MA*/
      if autouid=1 then                           /* 3@DFA*/
         ocmd=ocmd 'AUTOUID'
       else
         ocmd=ocmd 'uid('uid')'
    else
      uid=pw.pw_uid
   if home<>'' then
      ocmd=ocmd "home('"home"')"
   if program<>'' then
      ocmd=ocmd "program('"program"')"
   if ocmd<>'' then
      do
      cmd=cmd 'omvs('ocmd')'
      call bpxwirac cmd
      end
   pw.=''
   address syscall 'getpwnam (user) pw.'
   if pw.pw_uid='' then
      msgid=msg.m_baduid
    else
      do
      pwuid=pw.pw_uid
      pwgid=pw.pw_gid
      pwdir=pw.pw_dir
      pwpgm=pw.pw_shell
      msgid=msg.m_defusr
      if home<>'' then
         do
         address syscall 'access (home)' f_ok
         if retval=-1 then
            do
            address syscall 'mkdir (home)' mode
            end
         address syscall 'chown (home)' pw.pw_uid pw.pw_gid  /* @0DM*/
         end
      /* setup other files/dirs for user which do not already exist */
      end
   return

/**********************************************************************/
/* nextuid:  find the next highest unused uid                         */
/**********************************************************************/
nextuid:
   if autouid='' then                         /* 5@DFA*/
      if checkautoid() then
         return -1
   if autouid=1 then
      return 999999999   /* this number will not really be used */
   call bpxwirac 'highuid'
   if result<0 then
      return result
    else
      return result+1

/**********************************************************************/
/* checkautoid: ask user if autouid/gid is to be used                 */
/************************************************************** @15DFA*/
checkautoid:
   'ADDPOP'
   'DISPLAY PANEL('pan.p_autoid')'
   src=rc
   'REMPOP'
   if src>0 then return 1
   if autouid='/' then
      autouid=1
    else
      autouid=0
   if autogid='/' then
      autogid=1
    else
      autogid=0
   return 0

/**********************************************************************/
/* copy:  copy file1 to file2                                         */
/**********************************************************************/
copy:
   parse arg panel,file1,file2
   call syscallm 'open (file1)' O_RDONLY+O_NONBLOCK 000
   if retval=-1 then return 1
   fd1=retval
   address syscall 'fstat' fd1 'cp.'
   cpino=cp.st_ino
   cpdev=cp.st_dev
   cpperm=tperm
   tperm=cp.st_mode
   cpgenval=cp.st_genvalue  /* @DFA*/
   cpgenatt=''              /* @DFA*/
   cpccsid=substr(cp.st_ccsid,1,4)            /* 2@DHA*/
   cpfilefmt=cp.st_filefmt
   cp.=''
   address syscall 'stat (file2) cp.'
   if retval<>-1 then
      tperm=cp.st_mode
   if cpino=cp.st_ino & cpdev=cp.st_dev then
      do
      address syscall 'close' fd1
      return 0
      end
   "ADDPOP"
   "DISPLAY PANEL("pan.p_perm")"
   src=rc
   "REMPOP"
   tperm=cpperm
   if src<>0 then
      return 1

   if cpgenval<>'00000000'x then   /* 12@DFA*/
      do                           /* ask if extattrs should be set */
      cmd=file1
      "SETMSG MSG("msg.m_gentxt")"
      "ADDPOP"
      "DISPLAY PANEL("pan.p_attrack")"
      src=rc
      "REMPOP"
      if src<>0 then
         return 1
      end

   call syscallm 'creat (file2)' vperm
   fd2=retval
   if retval=-1 then
      do
      address syscall 'close' fd1
      return 1
      end
   address syscall 'fchmod' fd2 vperm
   address syscall 'fchattr' fd2 st_ccsid '(cpccsid)',
                                 st_filefmt '(cpfilefmt)'   /* @DHA*/
   cmd='copy' file1 file2
   "CONTROL DISPLAY LOCK"
   "SETMSG MSG("msg.m_gentxt")"
   "DISPLAY PANEL("panel")"
   /* note: can and may eventually need to turn off translation
            (w/ fcntl) to avoid problems with non-reversible tables */
   do until retval<0
      call syscallm 'read' fd1 'buf 16384'
      if retval<1 then leave
      szread=retval
      do forever
         call syscallm 'write' fd2 'buf' szread
         if retval=szread | retval=-1 then
            leave
         buf=substr(buf,retval+1)
         szread=szread-retval
      end
   end
   address syscall 'close' fd1
   address syscall 'close' fd2    /* @PGM*/
   if cpgenatt='/' then   /* user wants extattrs set 10@DFA*/
      do
      cpgenm=cpgenval
      call syscallm 'chattr (file2)' st_genvalue,
                    '(cpgenm) (cpgenval)'  /* @PGC*/
      if retval=-1 then
         return 1
      end

   return 0

/**********************************************************************/
/* quotes: double-up all quotes                                       */
/**********************************************************************/
quotes: procedure
   qpath=translate(arg(1),'00'x,"'")
   do forever
      i=pos('00'x,qpath)
      if i=0 then leave
      qpath=substr(qpath,1,i-1) || "''" || substr(qpath,i+1)
   end
   return qpath

/**********************************************************************/
/* tsocmd:  run tso command (oget/oput)                               */
/**********************************************************************/
tsocmd:
   parse arg util,pan,cmdline
   cmd=util cmdline
   "CONTROL DISPLAY LOCK"
   "SETMSG MSG("msg.m_gentxt")"
   "DISPLAY PANEL("pan")"
   xx=outtrap('M.')
   address tso cmd
   src=rc
   xx=outtrap(off)
   if src<>0 then
      do ci=1 to m.0
         say m.ci
      end
   return src

/**********************************************************************/
/* oedit:  call edit service                                          */
/**********************************************************************/
oedit: procedure expose iplace tplace prof imac edprf pan. pgmedit msg.,
         vactc isp
   parse arg path
   if edprf<>'/' then
      do
      "ADDPOP"
      "DISPLAY PANEL("pan.p_edopt")"
      src=rc
      "REMPOP"
      if src<>0 then
         do
         "VGET (IPLACE PROF IMAC EDPRF) PROFILE"
         return 20
         end
      "VPUT (IPLACE PROF IMAC EDPRF) PROFILE"
      end
   if vactc='G' then
      do /* fixed length recs */
      "ADDPOP"
      "DISPLAY PANEL("pan.p_getrecl")"
      src=rc
      "REMPOP"
      if src<>0 then return 20
      end
    else
      hfsrl=0
   'VPUT (HFSRL)'
   xx=lastpos('/',path)
   if xx=0 then
      do
      path='./'path
      xx=2
      end
   hfscwd=substr(path,1,xx)
   hfsname=substr(path,xx+1)
   if substr(hfscwd,length(hfscwd))='' |,
       substr(hfsname,length(hfsname))='' then
      do
      "SETMSG MSG("msg.m_nospaces")"
      return 20
      end
   "CONTROL DISPLAY SAVE"
   zplace=iplace
   "VPUT (HFSCWD HFSNAME PROF IMAC ZPLACE)"
   if isp>0 then                  /* using ispf services  14@DJA*/
      do
      if hfsrl<>0 then            /* 4@DLA*/
         reclen='RECLEN('hfsrl')'
       else
         reclen=''
      if imac = '' Then                                        /*@0SC*/
        initmac=''                                             /*@0SC*/
      else                                                     /*@0SC*/
        initmac = 'MACRO('imac')'                              /*@0SC*/
      if substr(path,1,1) <> '/' & substr(path,1,2) <> './' Then
         path = './' || path                                   /*@0RA*/
      "VPUT (PATH)"
      "EDIT FILE(PATH)" reclen initmac                         /*@0SC*/
      src=rc
      /* ISPF edit only sets zerrsm if return code > 4           @0QA*/
      if src>4 then                                            /*@0QC*/
         do
         zedsmsg=zerrsm        /* put out just the short msg if error */
         zedlmsg=zerrsm
         "SETMSG MSG(ISRZ000)"
         end
      end
   else
      do
      "SELECT CMD("pgmedit") SUSPEND"
      src=rc
      end                                               /* @DJA*/
   zplace=tplace
   "VPUT (ZPLACE)"
   "CONTROL DISPLAY RESTORE"
   return src

/**********************************************************************/
/* obrowse:  call browse service                                      */
/**********************************************************************/
obrowse: procedure expose iplace tplace pgmbrws msg. isp
   parse arg path,hfsrl
   xx=lastpos('/',path)
   if xx=0 then
      do
      path='./'path
      xx=2
      end
   hfscwd=substr(path,1,xx)
   hfsname=substr(path,xx+1)
   if substr(hfscwd,length(hfscwd))='' |,
       substr(hfsname,length(hfsname))='' then
      do
      "SETMSG MSG("msg.m_nospaces")"
      return 20
      end
   "CONTROL DISPLAY SAVE"
   zplace=iplace
   "VPUT (HFSCWD HFSNAME HFSRL ZPLACE)"
   if isp>0 then                  /* using ispf services  14@DJA*/
      do
      if hfsrl<>0 then            /* 4@DLA*/
         reclen='RECLEN('hfsrl')'
       else
         reclen=''
      if substr(path,1,1) <> '/' & substr(path,1,2) <> './' Then
         path = './' || path                                   /*@0RA*/
      "VPUT (PATH)"
      "BROWSE FILE(PATH)" reclen
      src=rc
      if src<>0 then
         do
         zedsmsg=zerrsm        /* put out just the short msg if error */
         zedlmsg=zerrsm
         "SETMSG MSG(ISRZ000)"
         end
      end
   else
      do
      "SELECT CMD("pgmbrws") SUSPEND"
      src=rc
      end                                               /* @DJA*/
   zplace=tplace
   "VPUT (ZPLACE)"
   "CONTROL DISPLAY RESTORE"
   return src

/**********************************************************************/
/* pscmd:  show process table                                         */
/**********************************************************************/
pscmd:
   pstabf='pid r 10 <Process_ID>',
          'state l 6 <State>',
          'cttyfn l 8 <  TTY>',
          'usertmd r 7 <   Time>',
          'pscmd l 1024 <Command>'
   first=1
   selrow=1
   sellev=1
   do forever
      call syscallm 'getpsent ps.'
      if retval=-1 then return
      "TBCREATE PSTAB NAMES(S,PID,STATE,PSCMD,LOCATE," ||,
           "PSPATH,CTTY,CTTYFN,STARTTM,USERTM,USERTMD,SYSTM,PPID," ||,
           "EUID,RUID,SUID,EGID,RGID,SGID,SID,PGPID,FGPID,SIZE," ||,
           "SRVTYPE,SRVNAME,MAXPIDS,PIDCNT,MAXVN,VNCNT,SRVFLAGS" ||,
                          ") NOWRITE REPLACE"
      "TBSORT PSTAB FIELDS(RUID,N,A,PID,N,A)"
      s=''
      do i=1 to ps.0
         pid=ps.i.ps_pid
         locate=pid
         state=ps.i.ps_state
         select
           when state=ps_run then state='RUN'
           when state=ps_waito then state='K-WAIT'
           when state=ps_child then state='CHILD'
           when state=ps_zombie then state='ZOMBIE'
           when state=ps_fork then state='FORK'
           when state=ps_sleep then state='SLEEP'
           when state=ps_waitc then state='C-WAIT'
           when state=ps_waitf then state='F-WAIT'
           when state=ps_msgrcv then state='MSGRCV'
           when state=ps_msgsnd then state='MSGSND'
           when state=ps_semwt then state='SEM-WT'
           when state=ps_freeze then state='FREEZE'
           when state=ps_quiesce then state='QUIESCE'
           when state=ps_zombie2 then state='ZOMBIE2'
           when state=ps_pause then state='PAUSE'
           otherwise
         end
         pscmd=ps.i.ps_cmd
         pspath    = ps.i.ps_path
         ctty      = ps.i.ps_contty
         parse value reverse(ctty) with cttyfn '/'
         cttyfn=reverse(cttyfn)
         starttm   = ltime(ps.i.ps_starttime)
         usertm    = ps.i.ps_usertime/100
         if length(usertm)>7 then
            usertmd='*******'
          else
            usertmd=usertm
         systm     = ps.i.ps_systime/100
         ppid      = ps.i.ps_ppid
         euid      = ps.i.ps_euid
         ruid      = ps.i.ps_ruid
         suid      = ps.i.ps_suid
         egid      = ps.i.ps_egid
         rgid      = ps.i.ps_rgid
         sgid      = ps.i.ps_sgid
         sid       = ps.i.ps_sid
         pgpid     = ps.i.ps_pgpid
         fgpid     = ps.i.ps_fgpid
         size      = ps.i.ps_size
         srvtype   = ps.i.ps_servertype
         if srvtype=0 then
            parse value '' with,
                  srvtype srvname maxpids pidcnt maxvn vncnt srvflags
          else
            do
            select
              when srvtype=1 then srvtype='FILE'
              when srvtype=2 then srvtype='LOCK'
              otherwise
              end
            srvname   = ps.i.ps_servername
            maxpids   = ps.i.ps_maxbrlmpids
            pidcnt    = ps.i.ps_brlmpids
            maxvn     = ps.i.ps_maxvnodes
            vncnt     = ps.i.ps_vnodecount
            srvflags  = c2x(ps.i.ps_serverflags)
            end
         "TBADD PSTAB ORDER"
      end
      alcurcmd=1        /* @0AA keep csr on cmd line */
      x=actionlist('PSTAB',first,selrow,pan.p_ps,pstabf)
      if x=0 & zverb<>'' then
         leave
      first=selrow.sel_top
      selrow=selrow.sellev.x
      "TBTOP PSTAB"
      do forever
         "TBSKIP PSTAB"
         if rc<>0 then leave
         if s='' | s='_' then iterate
         s=translate(s)
         select
            when s='A' then
               do
               "ADDPOP"
               do forever
                  "DISPLAY PANEL("pan.p_psatt")"
                  if rc<>0 then leave
               end
               "REMPOP"
               end
            when s='S' then
               do
               signum=''
               "ADDPOP"
               do forever
                  "DISPLAY PANEL("pan.p_pssig")"
                  if rc<>0 | datatype(signum,'W')=0 then
                     leave
                  if signum=99 then     /* 7@DGA*/
                     do
                     sigdata='00000800'x
                     signbr=9
                     end
                   else
                     do
                     sigdata='00000000'x
                     signbr=signum
                     end
                  call syscallm 'kill (pid)' signbr 'sigdata'   /*@DGC*/
                  if retval=0 then leave
               end
               "REMPOP"
               end
            when s='K' then
               call syscallm 'kill (pid)' sigkill
            otherwise
               /* ignore */
         end
      end
   end
   "TBEND PSTAB"
   return

/**********************************************************************/
/* rdelete: delete a directory and everything below it            @D2A*/
/**********************************************************************/
rdelete: procedure expose enotempty msg. pan. rdelopt rdeldone
   inrdel=1
   noconf=''
   parse arg path
   /* rdelopt = N,no confirm, A,all, D,non-empty dirs */
   if rdelopt<>'N' then
      do
      address ispexec
      do forever
         "ADDPOP"
         cmd=''                       /* delete pndg msg */
         'SETMSG MSG('msg.m_gentxt')'
         zcmd=''
         "DISPLAY PANEL("pan.p_rdel")"
         src=rc
         "REMPOP"
         if src<>0 then
            do
            "VGET (ZVERB)"
            if ZVERB='CANCEL' then
               do
               rdeldone=1
               return
               end
            rdeldone=2
            return
            end
         if zcmd='' then leave
         if translate(zcmd)='SHOWOBJ' then
            call showobj
      end
      end
   address syscall
   d.0=0
   'readdir (path) d.'
   do i=1 to d.0
      dpath=path'/'d.i
      if d.i<>'.' & d.i<>'..' then
         do
         if rdelopt='A' then
            do forever
               address ispexec
               "ADDPOP"
               svpath=path
               path=dpath
               "DISPLAY PANEL("pan.p_confd")"
               src=rc
               path=svpath
               "REMPOP"
               if src<>0 then
                  do
                  "VGET (ZVERB)"
                  if ZVERB='CANCEL' then
                     do
                     rdeldone=1
                     return
                     end
                  rdeldone=2
                  return
                  end
               if noconf='/' then
                  rdelopt='D'
               if zcmd='' then leave
               if translate(zcmd)='SHOWOBJ' then
                  do
                  path=dpath
                  call showobj
                  path=svpath
                  end
            end
         address syscall
         'unlink (dpath)'
         if retval=-1 then
            do
            'rmdir (dpath)'
            if retval=-1 & errno=enotempty then
               do
               call rdelete dpath
               if rdeldone>1 then return
               end
            end
         end
   end
   'rmdir (path)'
   return

/**********************************************************************/
/* runopts: add default runopts to environment before spawn       @DxA*/
/**********************************************************************/
runopts:
   arg optenv
   numeric digits 12
   cvt=c2x(storage(10,4))
   ecvt=c2x(storage(d2x(x2d(cvt)+140),4))
   ocvt=c2x(storage(d2x(x2d(ecvt)+240),4))
   if ocvt=0 then return
   oext=c2x(storage(d2x(x2d(ocvt)+12),4))
   if oext=0 then return
   optstr=c2x(storage(d2x(x2d(oext)+36),4))
   if optstr=0 then return
   optlen=c2d(storage(d2x(x2d(oext)+40),4))
   if optlen<2 then return
   opti=value(optenv'0')
   opti=opti+1
   call value optenv||opti,'_CEE_RUNOPTS='storage(optstr,optlen-1)
   call value optenv'0',opti
   return

/**********************************************************************/
/* getjr:  get message text for an errnojr                            */
/**********************************************************************/
getjr: procedure expose ejrcomp msg.
   arg jr
   jr=right(jr,8,'0')
   id=x2d(substr(jr,5,4))
   if id>999 then
      return jr
   comp=x2d(substr(jr,1,2))
   mod=x2d(substr(jr,3,2))
   "GETMSG MSG("ejrcomp || right(comp,3,'0')") LONGMSG(PREF)"
   if rc>8 then
      return jr
   "GETMSG MSG("pref || right(id,3,'0')") LONGMSG(TXT)"
   if rc>8 then
      return jr
   return jr txt

/**********************************************************************/
/* geterr: get message text for an errno                              */
/*                                                                    */
/* The errno is converted to decimal and right justified to three     */
/* characters to create a message ID when concatenated with enopref.  */
/* A message such as BPXW129 will be created and GETMSG is used to    */
/* retrieve the message text. Message text is only available for      */
/* IDs with less than four digits.                                    */
/**********************************************************************/
geterr: procedure expose enopref msg.
   arg eno
   enod=x2d(eno)                           /* Convert to decimal @PMC*/
   id= right(enod,3,'0')                /* make decimal 3 digits @PMC*/
   msg=enopref || id                                           /*@PMC*/
   "GETMSG MSG("msg") LONGMSG(TXT)"
   /* If GETMSG succeeded and enod is less than 4 digits */
   if rc<12 & enod<1000 then                                   /*@PMC*/
      txt=eno'x' txt
    else
      do
      "GETMSG MSG("msg.m_scerr2") LONGMSG(TXT)"
      if rc<12 then
         txt=eno'x' txt
       else
         txt=eno'x  '
      end
   return txt

/**********************************************************************/
/* syscallm:  issue syscall and put up a message on error             */
/**********************************************************************/
syscallm:
   parse arg cmd
   address syscall cmd
   if rc<0 then
      signal retry
   if retval=-1 then
      return
   rsn=getjr(errnojr)
   eno=geterr(errno)
   "SETMSG MSG("msg.m_scerr")" msgloc
   return

/**********************************************************************/
/* syscalle:  like syscallm but a parm specifies an ok error          */
/**********************************************************************/
syscalle:
   parse arg err cmd
   address syscall cmd
   if rc<0 then
      signal retry
   if retval=-1 then
      return
   if errno=err then
      return
   rsn=getjr(errnojr)
   eno=geterr(errno)
   "SETMSG MSG("msg.m_scerr")" msgloc
   return

/**********************************************************************/
/* signal functions                                                   */
/**********************************************************************/
sigsetempty: return copies(0,64)
sigfillset: return copies(1,64)
sigaddset: return overlay(1,arg(1),arg(2))
sigismember return substr(arg(1),arg(2),1)

/**********************************************************************/
/* error exits                                                        */
/**********************************************************************/
retry:
say 'Invalid syscall command syntax'
say 'address syscall' cmd
if datatype(ltime.0,'W')=1 then
   do
   address syscall
   'close' ltime.0
   'close' ltime.1
   end
trace ?r
nop
exit

syntax:
say 'Internal error encountered'
say sigl sourceline(sigl)
say errortext(rc)
if datatype(ltime.0,'W')=1 then
   do
   address syscall
   'close' ltime.0
   'close' ltime.1
   end
trace ?r
nop
exit

/**********************************************************************/
/* LIBDEFs                                                            */
/**********************************************************************/
libdefs:
   "CONTROL ERRORS RETURN"
   "CONTROL NONDISPL END"              /* next panel not displayed    */
   "GETMSG MSG("lit"000) LONGMSG(L#MT0)"  /* detect msg lib       @DQA*/
   rcm=rc
/*********************************************************************/
/********************* BEGIN CUCI MODIFICATIONS **********************/
/*********************************************************************/
   usrlibdf = 'YES'               /* CUCI change to bypass uid reset  */
                                  /* on PANEL display where CONTROL   */
                                  /* NONDISPL END is specified        */
                                  /* instead of user issuing END      */
/*********************************************************************/
/********************** END CUCI MODIFICATIONS ***********************/
/*********************************************************************/
   "DISPLAY PANEL("pan.p_main")"       /* detect panel and table libs */
   rcp=rc
/*********************************************************************/
/********************* BEGIN CUCI MODIFICATIONS **********************/
/*********************************************************************/
   usrlibdf = 'NO'                /* CUCI change to allow uid reset   */
                                  /* for user-entered 'END' cmd       */
/*********************************************************************/
/********************** END CUCI MODIFICATIONS ***********************/
/*********************************************************************/
   if rcm<12 & rcp<12 then
      return
   "LIBDEF ISPPLIB DATASET ID('SYS1.SBPXPENU')"
   "LIBDEF ISPMLIB DATASET ID('SYS1.SBPXMENU')"
   "LIBDEF ISPTLIB DATASET ID('SYS1.SBPXTENU')"
   "CONTROL ERRORS"
   if rcp >= 12 then      /* only if prev. main panel disp failed @DQA*/
      "DISPLAY PANEL("pan.p_main")"
   "CONTROL ERRORS RETURN"
   return

/**********************************************************************/
/* editacl                                                            */
/**********************************************************************/
editacl:
   parse arg aclcmd,aclpath
   if aclcmd='acl' then
      do
      call listacl acl_type_access,"Access"
      end
   else
   if aclcmd='dir' then
      do
      call listacl acl_type_dirdefault,"Directory Default"
      end
   else
   if aclcmd='file' then
      do
      call listacl acl_type_filedefault,"File Default"
      end
   return

listacl:
   parse arg typeofacl,acllabel
   address ispexec
   call makeacltable
   call syscallm 'aclinit acltok'
   call getacl typeofacl,aclpath
   zcmd=''
   aclmod=0
   do forever
      "TBTOP ACL"
      aclopt=''
      d=''
      "TBDISPL ACL PANEL("pan.p_acltab")"
      if rc>4 then
         do
         'VGET (ZVERB)'
         if ZVERB='CANCEL' & aclmod<>0 then
            do
            "ADDPOP"
            'DISPLAY PANEL('pan.p_aclconf')'
            crc=rc
            "REMPOP"
            if crc=0 then
               aclmod=0
             else
               iterate
            end
         leave
         end
      do i=ztdsels by -1 to 1
         if d='D' then
            do
            acl.acl_id=aclid
            if acltp='User' then
               acl.acl_entry_type=acl_entry_user
             else
               acl.acl_entry_type=acl_entry_group
            address syscall 'acldeleteentry acltok acl.'
            'TBDELETE ACL'
            aclmod=1
            end
          else
            do
            d=''
            newid=strip(aclid)
            newname=strip(aclname)
            call makeaclperm
            call updateacl
            'TBPUT ACL'
            aclmod=1
            end
         if i>1 then
            'TBDISPL ACL'
      end
      if zcmd<>'' then
         do
         parse upper var zcmd zcmd1 zcmd2
         if zcmd1='SORT' & zcmd2='ID' then
            "TBSORT ACL FIELDS(ACLTP,C,A,ACLID,N,A)"
         else
         if zcmd1='SORT' & zcmd2='NAME' then
            "TBSORT ACL FIELDS(ACLTP,C,A,ACLNAME,C,A)"
         else
         if zcmd1='SHOWOBJ' & zcmd2='' then
            call showobj
         else
         if zcmd1='SAVE' & zcmd2='' then
            do
            call syscallm 'aclset acltok (aclpath)' typeofacl
            "TBEND ACL"
            call makeacltable
            call getacl typeofacl,aclpath
            aclmod=0
            aclopt=0
            end
         else
         if zcmd1='D' & zcmd2='*' then
            do
            "TBTOP ACL"
            do forever
               "TBSKIP ACL"
               if rc<>0 then leave
               "TBDELETE ACL"
               call updateacl 1
               aclmod=1
            end
            end
         else
            "SETMSG MSG("msg.m_invcmd")" msgloc
         zcmd=''
         end
      'ADDPOP'
      parse value '' with pr pw px d
      aclname=''
      select
        when aclopt=2 then
         do
         acltp='User'
         'DISPLAY PANEL('pan.p_aclnew')'
         if rc=0 then
            do
            call makeaclperm
            pw.=''
            if datatype(aclname,'W') then
               address syscall 'getpwuid' aclname 'pw.'
             else
               address syscall 'getpwnam' aclname 'pw.'
            aclname=strip(pw.pw_name)
            aclid=pw.pw_uid
            if aclname<>'' then
               do
               "TBADD ACL ORDER"
               if rc=8 then
                  do
                  'SETMSG MSG('msg.m_dupid')' msgloc
                  end
                else
                  do
                  call updateacl
                  aclmod=1
                  end
               end
             else
               do
               'SETMSG MSG('msg.m_badid')' msgloc
               end
            end
         end
        when aclopt=1 then
         do
         acltp='Group'
         'DISPLAY PANEL('pan.p_aclnew')'
         if rc=0 then
            do
            call makeaclperm
            gr.=''
            if datatype(aclname,'W') then
               address syscall 'getgrgid' aclname 'gr.'
             else
               address syscall 'getgrnam' aclname 'gr.'
            aclname=strip(gr.gr_name)
            aclid=gr.gr_gid
            if aclname<>'' then
               do
               "TBADD ACL ORDER"
               if rc=8 then
                  do
                  'SETMSG MSG('msg.m_dupid')' msgloc
                  end
                else
                  do
                  call updateacl
                  aclmod=1
                  end
               end
             else
               do
               'SETMSG MSG('msg.m_badid')' msgloc
               end
            end
         end

        when aclopt=3 then
         do
         vtext='Add ACL entries from the ACL from path:'
         'DISPLAY PANEL('pan.p_getpath')'
         if rc=0 then
            do
            cpaclpath=makepath()
            cpacltp=selectacl()
            if cpacltp<>'' then
               do
               svtok=acltok
               drop acltok
               call syscallm 'aclinit acltok'
               call getacl cpacltp,cpaclpath,svtok
               call syscallm 'aclfree acltok'
               acltok=svtok
               drop svtok
               aclmod=1
               end
            end
         end

        when aclopt=4 then
         do
         vtext='Replace this ACL with the ACL from path:'
         'DISPLAY PANEL('pan.p_getpath')'
         if rc=0 then
            do
            cpaclpath=makepath()
            cpacltp=selectacl()
            if cpacltp<>'' then
               do
               "TBEND ACL"
               call makeacltable
               call getacl cpacltp,cpaclpath
               aclmod=1
               end
            end
         end
        otherwise
         nop
      end
      'REMPOP'
   end
   "TBEND ACL"
   if aclmod then
      call syscallm 'aclset acltok (aclpath)' typeofacl
   call syscallm 'aclfree acltok'
   return

selectacl:
   call syscallm 'stat (cpaclpath) aclst.'
   if retval=-1 then
      return ''
   ac=aclst.st_accessacl + aclst.st_fmodelacl + aclst.st_dmodelacl
   if ac=0 then
      do
      'SETMSG MSG('msg.m_noacl')' msgloc
      return ''
      end
   aaclch=aclst.st_accessacl
   faclch=aclst.st_fmodelacl
   daclch=aclst.st_dmodelacl
   if ac=1 then
      do
      if aaclch then return 1
      if faclch then return 2
      if daclch then return 3
      return ''
      end
   'ADDPOP'
   'DISPLAY PANEL('pan.p_acltype')'
   arc=rc
   'REMPOP'
   if arc>0 then
      return ''
   return saclch

makeacltable:
   "TBCREATE ACL NOWRITE REPLACE",
            "KEYS(ACLTP,ACLID)",
            "NAMES(PR,PW,PX,D,ACLTP1,ACLID1,ACLNAME)"
   "TBSORT ACL FIELDS(ACLTP,C,A,ACLNAME,C,A)"
   return

getacl:
   parse arg getacltype,getaclpath,cpacltok
   d='_'
   call syscalle enoent 'aclget acltok (getaclpath) (getacltype)'
   if retval=-1 then return
   do i=1 by 1
      call syscalle enoent 'aclgetentry acltok acl.' i
      if retval=-1 then
         leave
      if acl.acl_delete=1 then
         iterate
      parse value '' with pr pw px
      if acl.acl_read=1 then
         pr='R'
      if acl.acl_write=1 then
         pw='W'
      if acl.acl_execute=1 then
         px='X'
      aclid=acl.acl_id
      if acl.acl_entry_type=acl_entry_user then
         do
         acltp='User'
         pw.=''
         address syscall 'getpwuid' aclid 'pw.'
         aclname=strip(pw.pw_name)
         if aclname='' then iterate
         end
      else
      if acl.acl_entry_type=acl_entry_group then
         do
         acltp='Group'
         gr.=''
         address syscall 'getgrgid' aclid 'gr.'
         aclname=strip(gr.gr_name)
         if aclname='' then iterate
         end
      else
         iterate
      "TBADD ACL ORDER"
      if rc<8 & cpacltok<>'' then
         address syscall 'aclupdateentry cpacltok acl.'
   end
   return

makeaclperm:
   if pr<>'' then pr='R'
   if pw<>'' then pw='W'
   if px<>'' then px='X'
   return

updateacl:
   parse arg delacl
   acl.=''
   acl.acl_id=aclid
   if acltp='User' then
      acl.acl_entry_type=acl_entry_user
    else
      acl.acl_entry_type=acl_entry_group
   if pr='R' then
      acl.acl_read=1
   if pw='W' then
      acl.acl_write=1
   if px='X' then
      acl.acl_execute=1
   acl.acl_delete=delacl
   address syscall 'aclupdateentry acltok acl.'
   return
