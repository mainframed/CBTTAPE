IEBUPDTX TITLE 'CORNELL EXTENDED UPDATE PROGRAM'                 80308
*  WRITTEN SEPTEMBER, 1971
*  LARRY BRENNER, CORNELL U. (OCS - LANGMUIR LABS).
         SPACE 1                                                 80294
*              MODIFICATIONS BY:                                 80294
*              SEYMOUR JEROME METZ                               80294
*              PINKERTON COMPUTER CONSULTANTS, INC.              83014
*              5881 LEESBURG PIKE                                83014
*              BAILEY'S CROSSROADS                               83014
*              FALLS CHURCH, VIRGINIA   22041                    83014
*              (703)820-5571 AT PCCI                             83014
*              (202)632-2545 AT ISO/FADPC                        83014
         SPACE 1                                                 80294
*              CHANGES FLAGGED WITH 80002                        80294
*        1     SYMBOLIC REGISTER NAMES                           80294
*        2     EXTENDED BCR MNEMONICS                            80294
*        3     REGEQU MACRO USED                                 80294
*        4     370 INSTRUCTION SET USED                          80308
*        5     JOBCAT AND STEPCAT DDNAMES RECOGNIZED             80294
*        6     NAMES FROM DCBD AND IEFJFCBN MAPPING MACROS USED  80294
*              TO TEST AND ALTER DCB AND JFCB FLAGS              80294
*        7     CODE TIGHTENED UP                                 80294
*        8     ABEND 0CX FOR MISSING SYSIN CORRECTED.            80294
*        9     013 ON SYSIN CORRECTED BY TURNING OFF POINT BIT   80308
*              IF DSORG¬=PO.                                     80308
         SPACE 1                                                 80294
*              CHANGES FLAGGED WITH 80294                        80294
*        1     CHANGE LOG (THESE COMMENTS)                       80294
*        2     USE L R15,=V(EP) INSTEAD OF THE INLINE DC         80308
*              GENERATED BY CALL IN ORDER TO AVOID EXTRANEOUS    80294
*              CNOP 0,4 AND B *+8                                80294
*        3     MORE 370 OPCODE USE                               80294
*        4     MORE CODE TIGHTENING                              80294
*        5     CHANGES IN LISTING FORMAT AFTER JRE0036           80294
*        6     DEFAULT BLOCKSIZE FOR RECFM=VB TO 3165            80294
*        7     FIX BUG IN CHAIN PROCESSING, WHEREBY DIRECTORY    80301
*              ENTRY FOR ANY VERSION BUT 0 SHOWS 001 AS          80301
*              HIGHEST VERSION. NOTE THAT THE DIRECTORY ENTRY    80301
*              FOR THE PRODUCTION ALIAS WAS CORRECT.             80301
         SPACE 1                                                 80301
*              CHANGES FLAGGED WITH 80301                        80301
*        1     LOAD WILL SET THE CURRENT VERSION OF              80301
*              EACH CHANGE TO THE HIGHEST VERSION LOADED.        80301
*        2     MORE CODE TIGHTENED.                              80301
*        3     TTR INCLUDED IN STOW MESSAGE.                     80301
*        4     FIX BUG IN WYLBUR CODE WHICH SET THE WRONG        80301
*              FLAG FOR ANY OUTPUT DDNAME EXCEPT SYSUT2.         80301
         SPACE 1                                                 83014
*              CHANGES FLAGGED WITH 83012:                       83014
*        1     CORRECT 0C4 DUE TO UNINITIALIZED BACKLEV WHEN     83014
*              PS LEVEL IS HELD.                                 83014
         SPACE 1                                                 83014
*              CHANGES FLAGGED WITH 83013:                       83014
*        1     MOVE TABLES TO INCREASE ADDRESSABILITY            83014
*        2     REINSTATE 3 LETTER ALIAS FOR "D", "I", AND "R".   83014
*              "DEL", "INS", AND "REP" HAD PREVIOUSLY BEEN       83014
*              COMMENTED OUT AT THE JRE0036 LEVEL.               83014
         SPACE 1                                                 83014
*              CHANGES FLAGGED WITH 83014:                       83014
*        1     ADD LINECNT= KEYWORD TO PARM                      83014
*        2     UPDATE ADDRESS AND TELEPHONE #                    83014
         SPACE 2                                                 80294
*              MODIFICATIONS BY:                                 80294
*              JOHN R. EHRMAN                                    80294
*              SLAC                                              80294
*              MAIL BIN 97                                       80294
*              P.O. BOX 4349                                     80294
*              STANFORD, CALIFORNIA   94305                      80294
*              (415)854-3300 EXTENSION 2631                      80294
         SPACE 1                                                 80294
*              CHANGES FLAGGED WITH JRE0036                      80294
*        1     WYLBUR SUPPORT                                    80294
*        2     MODIFIED LISTING FORMAT                           80294
*        3     NEW PARM OPTIONS: WYLBUR AND INTEGER              80294
*        4     MAPPING MACROS FOR BUFDSECT, LOCAL, AND NMDSECT   80294
         SPACE 2                                                 80294
*              MODIFICATIONS BY GERHARD POSTPISCHIL              82060
*              EXPERT SYSTEM PROGRAMMING, INC.                   82060
*              347 ORCHARD STREET                                82060
*              VIENNA, VA.   22180                               82060
*              (202) 872-7703                                    82060
         SPACE 1                                                 82060
*        1     CORRECTIONS TO ERROR AND PARM PROCESSING. CHAIN=  82060
*              NO LONGER NEEDS TO BE LAST KEYWORD ON PARM.       82060
*              SOME IMPROVEMENTS TO CONTENTS OF ERROR MESSAGES.  82060
*              EXTRA VALIDITY CHECKING ADDED (FIX, OPEN)         82060
*        2     PARM CHANGES: KEYWORD=NO ALLOWED; SSI= ADDED      82060
*              CTL=./ REPLACEMENT OPTION. LIST FOR ADD ONLY;     82060
*              GLOBAL GANG OPTION, ASM OPTION FOR GANG.          82060
*              WYLRUN - SUPPRESSION OF RUN EDIT LINE NUMBERS     82060
*              INTEGER DEFINITION HAS BEEN REVERSED TO MATCH     82060
*                THE DEFINITION OF THE WYLBUR RUN COMMAND.       82060
*              PARM=NEW AND =MOD HONORED, BUT =NEW DEFAULTED     82060
*        3     GANG=SSI ADDED; CFIX AND CSCAN ADDED.             82060
*        4     DIRECTORY ENTRY PRINTOUT ADDED                    82060
*        5     CODE RE-ARRANGED (ADDRESSING) AND CLEANED UP.     82060
*                                                                82067
*        1     ERROR IN TIOT CODE FIXED (MVS)                    82067
*        2     GANG/ASM NOW OVERLAYS OLD FIELD IF 5 NUMERICS     82067
*        3     COPY/MACRO/LIST NOW USE SYSUT1 IF SYSLIB IS       82067
*              OMITTED AND SYSUT1 IS A PDS                       82067
*        4     LOCATE REWRITTEN TO FUNCTION AS INSERT OF 0 CARDS 82067
*        5     LIST NOW SUPPORTS FROM/TO SEQ OPERANDS            82067
         SPACE 2                                                 82060
*  THE ERROR MACRO CONSTRUCTS A VARYING LENGTH STRING FROM ITS ARGUMENT
*  WITH THE LENGTH OF THE ERROR TEXT IN THE FIRST BYTE.
*  THE ERROR'S SEVERITY CODE IS STORED IN THE SECOND BYTE.
*  THE NEXT  SIX BYTES ARE RESERVED FOR THE LEVEL'S ID NUMBER.
*  THE STRING IS PLACED IN CSECT IEBUPDTZ TO CONSERVE ADDRESSABILITY.
*  THE OFFSET TO THE ERROR MESSAGE IS PASSED AS AN IN-LINE ARGUMENT.
*
         MACRO
&N       ERROR &TEXT,&FILL,&RC=8,&ID=                            82060
         GBLA  &OFFSET
         LCLA  &L,&LT,&NF,&I,&J                                  82060
         LCLB  &IDFG                                             82060
         LCLC  &LQ                                               82060
.*       EXTENSIONS :                                            82060
.*       RC=0 - NO ERROR (ABEND NOW =14)                         82060
.*       ID=NO - ID PREFIX NEITHER MOVED NOR EXPANDED            82060
.*       FILL - SUBLIST(N) WHERE (N,1) TEXT OFFSET (NOT COUNTING ID)
.*             (N,2) ADDRESS OF FILL TEXT (ACCEPTABLE IN S CONSTANT)
.*             (N,3) OPTIONAL LENGTH OF FILL (DEFAULT IS L'FILL(N,2))
.*       EXPANSION : AL1(TEXTLEN,16*FILLCOUNT+CODE+0/1(ID)       82060
.*             CL6' ' (IF ID), C'TEXT'                           82060
.*             AL1(FILL OFFSET,FILL LENGTH),SL2(FILL ADDRESS) ...
.*                                                               82060
&IDFG    SETB  ('&ID' EQ 'NO')                                   82060
&LQ      SETC  'L'''                                             82060
&I       SETA  N'&SYSLIST    NUMBER OF POSITIONAL PARAMETERS     82060
&J       SETA  1             TEXT PARAMETER                      82060
.FILLLP  AIF   (&J GE &I).FILLND                                 82060
&J       SETA  &J+1                                              82060
         AIF   (N'&SYSLIST(&J) LT 2 OR N'&SYSLIST(&J) GT 3).FILLBD
&NF      SETA  &NF+1                                             82060
         AGO   .FILLLP                                           82060
.FILLBD  MNOTE 8,'POSITIONAL PARAMETER #&J IS INVALID'           82060
         AGO   .FILLLP                                           82060
.FILLND  ANOP  ,                                                 82060
&LT      SETA  K'&TEXT-2     (INCLUDES DOUBLED QUOTES, AMPERSANDS)
&L       SETA  &LT+6*(1-&IDFG)                                   82060
&N       BAL   R1,ERROR
         DC    H'&OFFSET'
IEBUPDTZ CSECT ,                                                 82060
         DC    AL1(&L,16*&NF+&RC+&IDFG),(1-&IDFG)CL6' ',CL(&LT)&TEXT
&J       SETA  1             TEXT PARAMETER                      82060
.FEXPLP  AIF   (&J GE &I).FEXPND                                 82060
&J       SETA  &J+1                                              82060
         AIF   (N'&SYSLIST(&J) LT 2 OR N'&SYSLIST(&J) GT 3).FEXPND
         AIF   (N'&SYSLIST(&J) EQ 3).FEXPLN                      82060
         DC   AL1(&SYSLIST(&J,1),&LQ&SYSLIST(&J,2)),SL2(&SYSLIST(&J,2))
         AGO   .FEXPLP                                           82060
.FEXPLN  DC    AL1(&SYSLIST(&J,1),&SYSLIST(&J,3)),SL2(&SYSLIST(&J,2))
         AGO   .FEXPLP                                           82060
.FEXPND  ANOP  ,                                                 82060
&SYSECT  CSECT ,
&OFFSET  SETA  &OFFSET+&L+2+4*&NF                                82060
         MEND  ,
*
*  THE SETEXIT MACRO STORES THE ADDRESS OF AN ERROR INTERCEPT         A
*  ROUTINE, OR RESETS IT TO ZERO.                                     A
*  DURING ERROR HANDLING FOR ERRORS OF SEVERITY GREATER THAN 4,       A
*  IF AN EXIT IS ACTIVE, THE ERROR ROUTINE WILL PURGE I/O AND SET     A
*  THE NO-WRITE SWITCH BEFORE BRANCHING TO THE ERROR EXIT ROUTINE.    A
*                                                                     A
         MACRO                                                        A
&N       SETEXIT &ADR                                                 A
         AIF   ('&ADR' EQ '0').RESET                                  A
&N       LA    R0,&ADR                                                A
         AGO   .ST                                                    A
.RESET   ANOP                                                         A
&N       XR    R0,R0                                                  A
.ST      ST    R0,EREXIT                                              A
         MEND                                                         A
*                                                                     A
*
*  THE BGNSB MACRO IS USED TO BEGIN A SUBROUTINE.
*  R10 IS RESERVED FOR SUBROUTINE LINKAGE.
*  THE SAVE AREA FOR REG.S 2-10 IS RESERVED HERE
*  OPTIONALLY, THE CALLER MAY (VIA EQU=) HAVE HIS SAVE AREA NAME EQU'ED
*  TO A PREVIOUSLY DEFINED SAVE AREA TO SAVE SPACE.
*
         MACRO
&N       BGNSB &SA,&EQU=
         AIF   (T'&EQU NE 'O').NOSA
&SA      DC    9F'0'
&N       STM   R2,R10,&SA
         MEXIT
.NOSA    ANOP
&SA      EQU   &EQU
&N       STM   R2,R10,&EQU
         MEND
*
*  THE ENDSB MACRO IS USED TO EXIT FROM INTERNAL SUBROUTINES.
*
         MACRO
&N       ENDSB &SA,&RC=
&N       LM    R2,R10,&SA
         AIF   (T'&RC EQ 'O').EXIT
         AIF   ('&RC' EQ '0').SR
         LA    R15,&RC
.EXIT    BR    R10
         MEXIT
.SR      XR    R15,R15
         BR    R10
         MEND
*
*  THE GOSUB MACRO IS USED TO CALL A SUBROUTINE, AND OPTIONALLY TEST
*  THE RETURN CODE.
*  TEST= SHOULD BE SET TO THE HIGHEST POSSIBLE RETURN CODE.
*
         MACRO
&N       GOSUB &SUB,&TEST=,&BXH=,&BXLE=                          82060
&N       BAL   R10,&SUB
         AIF   (T'&TEST EQ 'O').BX                               82060
         AIF   ('&TEST' EQ '4').FOUR
         B     *+4(R15)
         B     *+4+&TEST
         MEXIT
.FOUR    LTR   R15,R15
         BZ    *+8
         MEXIT ,                                                 82060
.BX      AIF   (T'&BXH EQ 'O').BXT                               82060
         BXH   R15,R15,&BXH                                      82060
.BXT     AIF   (T'&BXLE EQ 'O').EXIT                             82060
         BXLE  R15,R15,&BXLE                                     82060
.EXIT    MEND
         SPACE 1                                                 82060
*        SPECIAL ENTRY CODE FOR OTHERWISE NOT ADDRESSABLE        82060
*        SUBROUTINES - DOES NOT GENERATE A SAVE AREA             82060
*                                                                82060
         MACRO ,                                                 82060
&NM      ENTSB &SA                                               82060
         USING &NM,R15                                           82060
&NM      STM   R2,R10,&SA                                        82060
         LR    R10,R15                                           82060
         DROP  R15                                               82060
         USING &NM,R10       LOCAL BASE                          82060
         MEND  ,                                                 82060
         SPACE 1                                                 82060
*        CALL TO UNADDRESSABLE SUBROUTINE                        82060
*        POS1 - ROUTINE NAME  POS2 - OPTION R1 VALUE             82060
         MACRO ,                                                 82060
&NM      CALLSUB &SUB,&PARM,&TEST=,&BXH=,&BXLE=                  82060
&NM      L     R15,=A(&SUB)                                      82060
         AIF   (T'&PARM EQ 'O').NOPM                             82060
         AIF   ('&PARM'(1,1) NE '(').LAPM                        82060
         AIF   ('&PARM'(2,1) EQ '(').LAPM                        82060
         LR    R1,&PARM(1)                                       82060
         AGO   .NOPM                                             82060
.LAPM    LA    R1,&PARM                                          82060
.NOPM    BALR  R10,R15                                           82060
         AIF   (T'&TEST EQ 'O').BX                               82060
         AIF   ('&TEST' EQ '4').FOUR                             82060
         B     *+4(R15)                                          82060
         B     *+4+&TEST                                         82060
         MEXIT ,                                                 82060
.FOUR    LTR   R15,R15                                           82060
         BZ    *+8                                               82060
         MEXIT ,                                                 82060
.BX      AIF   (T'&BXH EQ 'O').BXT                               82060
         BXH   R15,R15,&BXH                                      82060
.BXT     AIF   (T'&BXLE EQ 'O').EXIT                             82060
         BXLE  R15,R15,&BXLE                                     82060
.EXIT    MEND  ,                                                 82060
*
*  THE LOG MACRO JUST BRANCHES TO THE LOG ROUTINE.
*
         MACRO
&N       LOG   &OP
&N       LA    R0,&OP             LOAD FUNCTION TO BE LOGGED INDICATOR
         BAL   R10,LOGRTN         AND GO DO IT
         MEND
         SPACE 1                                                 82060
*        SHORT PRINT EXPANSION FOR CTLAREA                       82060
*                                                                82060
         MACRO ,                                                 82060
&NM      XPRADR &PWA,&TEXT=CTLAREA,&MF=(E,PRCTL)                 82060
         AIF   ('&MF(1)' NE 'E').ERR                             82060
         AIF   (T'&TEXT EQ 'O').ERR                              82060
         AIF   (T'&PWA EQ 'O').ERR                               82060
&NM      LA    R1,&MF(2)                                         82060
         AIF   ('&TEXT'(1,1) NE '(').LA                          82060
         AIF   ('&TEXT'(2,1) EQ '(').LA                          82060
         ST    &TEXT(1),4(,R1)                                   82060
         AGO   .COM                                              82060
.LA      LA    R15,&TEXT                                         82060
         ST    R15,4(,R1)                                        82060
.COM     LA    R0,&PWA                                           82060
         L     R15,=V(XPRNTSUB)                                  82060
         BAL   R14,32(,R15)                                      82060
         MEXIT ,                                                 82060
.ERR     MNOTE 8,'MISSING OR INVALID PARAMETER'                  82060
         MEND  ,                                                 82060
         SPACE 1                                                 82060
         MACRO ,                                                 82060
&NM      POPS  &P1,&P2,&P3,&P4   POSITIONAL PARAMETER DEFINITION 82060
         AIF   (N'&SYSLIST EQ 4).MAKE4                           82060
         AIF   (N'&SYSLIST EQ 3).MAKE3                           82060
         AIF   (N'&SYSLIST EQ 2).MAKE2                           82060
         AIF   (N'&SYSLIST EQ 1).MAKE1                           82060
         AIF   (N'&SYSLIST EQ 0).MAKE0                           82060
         MNOTE 8,'*** EXCESSIVE POSITIONAL OPERANDS ***'         82060
.MAKE4   ANOP  ,                                                 82060
&NM      DC    AL1(VK&P1,VK&P2,VK&P3,VK&P4)                      82060
         MEXIT ,                                                 82060
.MAKE3   ANOP  ,                                                 82060
&NM      DC    AL1(VK&P1,VK&P2,VK&P3,VKNONE)                     82060
         MEXIT ,                                                 82060
.MAKE2   AIF   (K'&SYSLIST(2) EQ 0).MAKE1                        82060
&NM      DC    AL1(VK&P1,VK&P2,VKNONE,VKNONE)                    82060
         MEXIT ,                                                 82060
.MAKE1   AIF   (K'&SYSLIST(1) EQ 0).MAKE0  *ALLOW , FOR COMMENTS*
&NM      DC    AL1(VK&P1,VKNONE,VKNONE,VKNONE)                   82060
         MEXIT ,                                                 82060
.MAKE0   ANOP  ,                                                 82060
&NM      DC    AL1(VKNONE,VKNONE,VKNONE,VKNONE)                  82060
         MEND  ,                                                 82060
         SPACE 1                                                 82060
         MACRO ,                                                 82060
         SEQU  &PFX=         ASSIGN SEQUENTIAL EQU SYMBOLS       82060
         GBLA  &GLOB#                                            82060
         GBLC  &GLOB@                                            82060
         LCLC  &V                                                82060
         LCLA  &I,&J                                             82060
         AIF   (T'&PFX EQ 'O').NOTNEW                            82060
&GLOB#   SETA  0             RESET COUNTER                       82060
&GLOB@   SETC  '&PFX'        SET NEW PREFIX                      82060
.NOTNEW  ANOP  ,                                                 82060
&J       SETA  N'&SYSLIST                                        82060
.LOOP    AIF   (&I GE &J).MEND                                   82060
&I       SETA  &I+1                                              82060
&V       SETC  '&GLOB@'.'&SYSLIST(&I)'                           82060
&V       EQU   &GLOB#                                            82060
&GLOB#   SETA  &GLOB#+1                                          82060
         AGO   .LOOP                                             82060
.MEND    MEND  ,                                                 82060
         SPACE 2                                                 82060
         GBLA  &GLOB#                                            82060
         SPACE 2                                                 82060
         COPY  OPTIONGB      DEFINE LOCAL ASSEMBLY OPTIONS       82060
         SPACE 1                                                 82060
         SYSPARM LIST=YES    DEFINE LOCAL ASSEMBLY OPTIONS       82060
         TITLE 'IEBUPDTX - MAIN CONTROL ROUTINE'
IEBUPDTX START 0
         PRINT &PRTSOR                                           82060
         ENTRY PWA                 DCB ADDR                     JRE0036
         WYBLKSIZ                                               JRE0036
         REGEQU                                                  80002
         USING *,R15
         SAVE  (14,12),,*
         LR    R2,R13
         LM    R11,R13,BASES
         LM    R7,R8,BASES2       MORE BASE REGISTERS
         ST    R13,8(,R2)
         ST    R2,4(,R13)
         DROP  R15
         USING SAVEAREA,R13,R12,R11,R7,R8
         B     SAVEAREA+72
*
BASES    DC    A(SAVEAREA+8192,SAVEAREA+4096,SAVEAREA)
BASES2   DC    A(SAVEAREA+X'3000',SAVEAREA+X'4000')
BBAS     DS    0F            BASE ADDRESS FOR BRANCH BY OFFSET   82060
SAVEAREA DS    18F
*
*  GENERAL PATTERNS OF REGISTER USAGE.
*
*        R7,R8          BASE REGISTERS.
*        R11-R13        BASE REGISTERS.
*
*        R14-R1         SHORT TERM WORK REGISTERS, SUBJECT TO CHANGE
*                       BY MACROS AND SUBROUTINES.
*
*        R2-R6          LONG TERM WORK REGISTERS.  SAVED AND RESTORED
*                       BY MACROS AND SUBROUTINES.
*                       R6 FREQUENTLY POINTS TO THE 'NM' DSECT, WHICH
*                       DESCRIBES SYSUT2/SYSPUNCH FILES.
*
*        R9             DSECT POINTER.  BASE ADDRESSING FOR DATA STORED
*                       IN THE LOCAL DSECT FOR EACH INPUT FILE.
*
*
         CALLSUB RUNINIT     PERFORM BASIC INITIALIZATION        82060
*
*  ALLOCATE SYSLIB WORK AREA.  NEEDED NOW FOR PARM ROUTINE TO USE.  SMP
*                                                                   SMP
         L     R15,=A(LCLINIT)    WORK AREAS FOR COPY LIBRARY    82060
         BALR  R14,R15            CALL                           80294
         LR    R9,R2              DSECT ADDRESSING                  SMP
         USING LOCAL,R9                                             SMP
         SET   (SYSLIB,REALEOF)   SOME INITIALIZATION               SMP
         ST    R2,LIBADR          SAVE SYSLIB AREA POINTER          SMP
*                                                                   SMP
*  BRANCH TO PARM ROUTINE FOR EXEC PARMS.                           SMP
*  BECAUSE PARM ROUTINE IS REALLY FOR ./ PARM CARD,                 SMP
*  SOME SPECIAL HANDLING IS REQUIRED.                               SMP
*                                                                   SMP
         SETEXIT PARMDONE         IN CASE ERROR IN PARM FIELD       SMP
         SET   XPARMS             INDICATE SPECIAL CALL (FOR IN/OUT SMP
         B     EXPARM             GO TO PARM ROUTINE                SMP
XPARMRET RESET XPARMS             RETURN FROM PARM RTN, R6->NMDATA  SMP
         MVC   CTLAREA(10),BLANKS  CLEAR 'EXEC PARMS'            82060
         SETEXIT 0                                                  SMP
*                                                                   SMP
         USING NMDSECT,R6
         MVC   DCBDDNAM-IHADCB+SYSUT2,DDUT2  SET SYSUT2 DDNAME      SMP
         GOSUB NMOPEN             OPEN SYSUT2 - NEW MASTER
         B     *+4(R15)
         SET UT2AVAIL             INDICATE THAT SYSUT2 IS OPEN
*                                                                   SMP
         IF    ¬CHAINING,UT2NOCHN SKIP IF SYSUT2 NOT CHAINED        SMP
*  SET UP FOR CHAINED OUTPUT LIBRARY SPECIFIED VIA EXEC PARMS.      SMP
         BAL   R3,PSOUTDDC        SNEAK INTO PARM SUBROUTINE        SMP
UT2NOCHN EQU   *                                                    SMP
*
*  SYSUT1 - OLD MASTER - OPTIONAL.
*
         XR    R2,R2
         DEVTYPE DDUT1,OBWORK+8                                     SMP
         BXH   R15,R15,SU1X   SKIP IF DDNAME NOT FOUND           82060
*
         L     R15,=A(LCLINIT)                                   82060
         BALR  R14,R15            CALL                           80294
         LR    R9,R2
         MVC   LEVNAME,DDUT1                                        SMP
         SET   SYSUT1
         GOSUB CTLOPEN
SU1X     ST    R2,WORKC           SAVE FOR CHAINING UPDATES
*
*
*  SCAN TIOT.  ANY NON-'SYS' DDNAME WILL BE USED AS AN UPDATE FILE.
*
         L     R3,TIOTLOC         TIOT DSECT REGISTER
         USING TIOT,R3
         XR    R4,R4              WORK REG.
*
TIOTLOOP ICM   R4,1,TIOELNGH      LENGTH OF THIS TIOT ENTRY      80002
         BZ    TIOTDONE           EXIT AT END OF TIOT
         CLC   TIOEDDNM(3),=C'SYS'
         BE    TIOTSKIP           IGNORE SYS... DDNAMES
         CLC   TIOEDDNM(8),=C'STEPLIB '
         BE    TIOTSKIP
         CLC   TIOEDDNM(8),=C'JOBLIB  '
         BE    TIOTSKIP
         CLC   =C'JOBCAT  ',TIOEDDNM                             80002
         BE    TIOTSKIP                                          80002
         CLC   =C'STEPCAT ',TIOEDDNM                             80002
         BE    TIOTSKIP                                          80002
         CLC   TIOEDDNM(8),=C'PGM=*.DD'
         BE    TIOTSKIP
         CLI   TIOEDDNM,C' '      ALSO WANT TO IGNORE CONCATENATIONS
         BE    TIOTSKIP
*
*  USE DD CARDS ONLY IF THEIR DDNAMES START WITH THE PREFIX         SMP
*  SPECIFIED VIA PARM='UPDATES=PREFIX'                              SMP
*                                                                   SMP
         ICM   R15,3,PRELEN       PREFIX LENGTH-1                80002
         BM    TIOTUSEA           IF LENGTH <= 0, USE ANY DD     82060
         EX    R15,PRECLC         TEST DDNAME AGAINST PREFIX        SMP
         BNE   TIOTSKIP           DON'T USE UNLESS PREFIX MATCHED   SMP
         B     TIOTUSE       ERROR OR ABEND IF BAD               82060
*                                                                82060
*        'ANY' ENTRY SHOULD BE CHECKED FOR OBVIOUS PROBLEMS      82060
*                                                                82060
TIOTUSEA ICM   R15,7,TIOEFSRT  GET UCB ADDRESS                   82060
         AIF   (NOT &MVS).NMVSJES                                82067
         BNZ   TIOTUSEB      NOT ZERO; CONTINUE                  82067
         TM    TIOELINK,TIOESSDS  SUBSYSTEM DATASET ?            82067
         BZ    TIOTSKIP      SKIP DUMMY                          82102
         ICM   R15,7,TIOEJFCB  GET JFCB IN SWA                   82102
         BZ    TIOTSKIP      HUH ?                               82102
         CLC   =C'.JOB',4(R15)  POSS. SUBSYSTEM NAME ?           82102
         BNE   TIOTSKIP      NO                                  82102
         CLC   =C'.SI',13(R15)  SYSIN ?                          82102
         BNE   TIOTSKIP      NO; SKIP                            82102
         B     TIOTUSE       TRY TO USE IT                       82102
         AGO   .DMVSJES                                          82102
.NMVSJES BZ    TIOTSKIP      SKIP IF DUMMY                       82067
.DMVSJES SPACE 1                                                 82102
TIOTUSEB TM    UCBTBYT3-UCBOB(R15),UCB3DACC+UCB3TAPE+UCB3UREC    82067
         BNM   TIOTSKIP      SKIP IF NOT USABLE FOR SAM          82060
         TM    UCBTBYT3-UCBOB(R15),UCB3UREC  UNIT RECORD ?       82060
         BZ    TIOTUSE       NO; TRY IT                          82060
         CLI   UCBTBYT4-UCBOB(R15),X'08'  OBVIOUS OUTPUT DEVICE ?
         BNL   TIOTSKIP      MAYBE; SKIP ANYWAY                  82060
         CLI   UCBTBYT4-UCBOB(R15),X'02'  PUNCH ?                82060
         BE    TIOTSKIP      YES; SKIP                           82060
*                                                                   SMP
TIOTUSE  EQU   *                                                    SMP
         L     R15,=A(LCLINIT)    GET DCB ETC. VIA R2            82060
         BALR  R14,R15            CALL                           80294
         LR    R9,R2
         MVC   LEVNAME,TIOEDDNM   PUT IN DDNAME
         GOSUB CTLOPEN            INITIALIZE THE FILE
         MVC   NEXTLEV,WORKC      CHAIN TO PREVIOUS UPDATES
         ST    R9,WORKC
*
TIOTSKIP AR    R3,R4              POINT TO NEXT TIOT ENTRY
         B     TIOTLOOP
*
PRECLC   CLC   TIOEDDNM(0),PRENAME          EXECUTED INSTRUCTION    SMP
*                                                                   SMP
TIOTDONE EQU   *
         DROP  R3
*
*  LINK SYSIN TO THE ABOVE TO COMPLETE INITIALIZATION
*  IF SYSIN IS NOT PRESENT, USE LAST INTERMEDIATE UPDATE DECK INSTEAD.
*
         DEVTYPE DDIN,OBWORK+8    TEST SYSIN PRESENT OR NOT         SMP
         BXH   R15,R15,NOSYSIN   SKIP IF SYSIN OMITTED           82060
*
         L     R15,=A(LCLINIT)                                   82060
         BALR  R14,R15            CALL                           80294
         LR    R9,R2
         MVC   LEVNAME,DDIN                                         SMP
         MVC   NEXTLEV,WORKC
         GOSUB CTLOPEN
         B     GOTSYSIN
*
NOSYSIN  ICM   R9,15,WORKC        ADDRESS OF LATEST UPDATE       80294
         BZ    NOCTL              ERROR - NO CONTROL FILE
         IF    SYSUT1,NOCTL                                           H
*
GOTSYSIN SET   SYSIN
         ST    R9,SYSINADR
         IF    ¬CTLPS,NOCTL       CONTROL FILE MUST BE SEQUENTIAL
         B     MAINL              JUMP AROUND PARM ROUTINE          SMP
EXPARM   EQU   *                  ENTRY FOR DOING EXEC PARMS        SMP
*
*  IF PARM=... WAS SPECIFIED ON THE EXEC CARD, WE DUMMY UP A ./ PARM
*  CONTROL CARD.
*  PARM INFORMATION MAY BE RESPECIFIED AT ANY TIME USING THE ./ PARM
*  MAJOR COMMAND.
*
         AIF   ('&LOCAL' NE 'CCSI').NOSSID                       82060
*        SET DEFAULT OPTIONS FOR DIAL-TYME                       82060
         BAL   R3,PSSSIDAT   SET SSI=DATE (WYLBUR COMPATIBILITY) 82060
         SET   (LISTADD,WYLRUN,PARMMOD)  SET OTHER DEFAULTS      82060
.NOSSID  SET   INTEGER       SET DEFAULT - NO WYLBUR LINE NUMBERS
         L     R1,PARMADR
         LH    R2,0(,R1)           GET LENGTH OF EXEC PARMS
         SH    R2,=H'1'            LENGTH FOR MOVE
         BM    PARMDONE            SKIP IF NO EXEC PARM SPECIFIED   SMP
         CH    R2,=H'70'     CHECK THAT PARM STUFF FITS ONE CARD 82060
         BH    PARMLEN
         MVC   CTLAREA(10),=C'EXEC PARMS'                        82060
         MVI   CMDNUM+3,VCPARM    FAKE ./PARM FOUND BY CCLOOK    82060
         LA    R3,CTLBUF     USE WHOLE CARD                      82060
         ST    R3,KSCANPTR         SET FOR KEYSCAN
         EX    R2,PARMMOVE         MOVE FROM PARM FIELD TO INPUT AREA
*
*
*
*  SCAN KEYWORD OPERANDS OF THE ./ PARM COMMAND (OR EXEC PARMS).
*
*  SCANNING PROCEEDS FROM LEFT TO RIGHT, HALTING AT FIRST ERROR
*  WITH A NON-DESCRIPTIVE SYNTAX ERROR MESSAGE.
*  IF TWO PARMS BEING SPECIFIED SIMULTANEOUSLY ARE INTERDEPENDENT,
*  IT MAY BE NECESSARY TO SPECIFY THEM IN A CERTAIN ORDER, FOR EXAMPLE
*  "PARM='OUTDD=SYSOUT,CHAIN=ZZ'"
*
*  NOTE - PARM COMMANDS MAY NOT BE CONTINUED, AND THE PARM COMMAND,
*  IF IMPLIED BY BEING SPECIFIED THROUGH THE EXEC PARM FIELD,
*  IS LIMITED TO 50 CHARACTERS.
*
*  THE FOLLOWING ARE POSSIBLE PARM OPTIONS -
*
*    (NO)NAMES     SPECIFIES IF CONTROL STATEMENTS WILL HAVE STANDARD
*                  (IEBUPDTE) NAME FIELDS OR NOT.
*
*    (NO)INSERT    SPECIFIES THAT COLUMNS 73-80 OF CHANGE DATA RECORDS
*                  ARE TO BE IGNORED (TREATED AS BLANK) FOLLOWING
*                  INSERT OR REPLACE OPERATIONS.
*
*    (NO)CHAIN     .....
*        CHAIN=XX  SPECIFY IF THE OUTPUT FILE (SYSUT2) IS TO BE TREATED
*                  AS A CHAINED LIBRARY OR NOT.  IF THIS IS THE FIRST
*                  TIME THAT IEBUPDTX WILL OPEN THE NEW MASTER DATA SET
*                  AS A CHAINED LIBRARY, THEN A TWO LETTER OR NUMBER
*                  LIBRARY ID MUST BE SPECIFIED.  OTHERWISE, THE
*                  LIBRARY ID IS OPTIONAL, BEING PROVIDED IN THE
*                  NEW MASTER PARTITIONED DIRECTORY (@LLOCATR).
*
*    (NO)LISTLEV   SPECIFIES IF CONTROL CARDS AND INSERTED (DELETED)
*                  DATA ARE TO BE PRINTED FOR ALL UPDATE CONTROL FILES,
*                  OR NOT (THEN ONLY SYSIN WILL CAUSE PRINTING).
*
*    (NO)LISTDEL   SPECIFIES WHETHER CARDS DELETED FROM THE OLD MASTER
*                  ARE TO BE LISTED OR NOT.
*
*    (NO)LISTRN    SPECIFIES WHETHER CARDS WHICH HAVE BEEN RENUMBERED
*                  FROM THE OLD MASTER BY SYSIN ARE TO BE PRINTED
*                  OR NOT.
*
*    (NO)DECK      SPECIFIES WHETHER OR NOT AN IEBUPDTE COMPATIBLE
*                  UPDATE DECK EQUIVALENT (EXCEPT FOR SEQUENCING)
*                  TO THE FOLLOWING CHANGE OPERATIONS IS TO BE PUNCHED
*                  OR WRITTEN TO SYSPUNCH (MAY BE PARTITIONED).
*                  NOTE THAT IF THE NEW MASTER IS BASED IN ANY WAY ON
*                  DATA PROVIDED BY AN ADD COMMAND, NO DECK IS MADE.
*
*    (NO)INTEGER   SPECIFIES THAT FOR INPUT DATA SETS IN        JRE0036
*                  WYLBUR EDIT FORMAT, THE WYLBUR LINE # WILL   JRE0036
*                  NOT BE USED AS THE CARD SEQUENCE #; FOR       82060
*                  OUTPUT DATA SETS IN WYLBUR FORMAT, THE SEQUENCE
*                  NUMBER WILL NOT BE PUT IN THE WYLBUR LINE # FIELD.
*                                                               JRE0036
*    (NO)WYLBUR    SPECIFIES THAT COL 73-80 ON SYSIN ARE        JRE0036
*                  LINE NUMBERS AND SHOULD BE PRINTED ON THE    JRE0036
*                  IEBUPDTX UPDATE LISTING AS SUCH. ALL UPDATES JRE0036
*                  COMING FROM SYSIN WILL HAVE THEIR COL 73-80  JRE0036
*                  TREATED AS BLANKS FOR PURPOSES OF UPDATING.  JRE0036
*                                                                82060
*    (NO)WYLRUN    SPECIFIES THAT COLUMNS 73-80 MAY HAVE BEEN    82060
*                  SET BY A WYLBUR RUN COMMAND TO EDIT FORMAT    82060
*                  (NNNN.NNN) LINE NUMBERS. THE FIELD IS BLANKED 82060
*                  IF AT LEAST THE 'N.' IN COL 77/78 ARE PRESENT,
*                  ELSE IT IS LEFT UNCHANGED. THIS PERMITS DATA  82060
*                  CARDS (TRUE SEQUENCE NUMBERS IN 73/80).       82060
*                                                               JRE0036
*                                                               JRE0036
*    (NO)TIMES     SPECIFIES WHETHER OR NOT A 4-BYTE TIME STAMP IS TO
*                  BE STOWED AS USER DATA IN THE NEW MASTER PDS.
*                  TIME STAMP = 'YYDDDHHF'  (F IS A HEX 'F').
*
*    (NO)CHAINUPD  SPECIFIES WHETHER OR NOT CHAINED MEMBERS FOUND AS
*                  INTERMEDIATE UPDATE DECKS ARE TO BE APPLIED AS A
*                  SET OF RECURSIVE UPDATES (OTHERWISE, THE PRODUCTION
*                  ALIAS IS SIMPLY USED).
*
*    (NO)LISTING   SPECIFIES IF LISTING OF UPDATE COMMANDS AND DATA
*                  IS TO BE PROVIDED (DEFAULT IS LISTING).
*                  NOTE - THIS PARAMETER OVERRIDES 'LIST=ALL'
*
*    (NO)SEQFIX    SPECIFIES THAT LEADING DIGITS MAY BE OMITTED FROM  A
*                  SEQ2 AND WILL BE DEFAULTED FROM SEQ1.              A
*                                                                     A
*    (NO)IMPLSEQ   REQUESTS IMPLICIT SEQUENCING OF SYSUT1 IN STEPS OF A
*                  ONE.  ORIGINAL SEQUENCE FIELD IS RESTORED AS EACH  A
*                  OLD MASTER CARD IS WRITTEN OUT.                    A
*                  NOTE - USE DECK OPTION WITH CARE.                  A
*                                                                     A
*    (NO)LISTALL   FORCES LIST=ALL TO BE ASSUMED ON CHANGE/ADD CARDS  A
*                                                                     A
*        INCR=     OVER RIDES THE BUILT-IN DEFAULT NUMBERING INCREMENT
*                  WHICH IS USED BY REPLACE INSERT AND NUMBER COMMANDS
*                  WHEN THE USER OMITS THE INCR PARAMETER.
*
*    (NO)DECKQ     SPECIFIES THAT ./Q AND ./N COMMANDS MAY BE         A
*                  PRODUCED AS PART OF THE DECK OPTION.  THESE        A
*                  EXTRA CARDS WILL CORRECT FOR CHANGES IN THE        A
*                  SEQUENCING, AND ARE NOT IEBUPDTE COMPATIBLE.       A
*                  DECKQ RESET IF ANY TOTAL RESEQUENCING REQUESTED.   A
*                  DO NOT USE WITH IMPLSEQ OPTION.                    A
*
*        COND=     SETS THE HIGHEST SEVERITY OF INTERNAL ERROR WHICH
*                  WILL NOT TERMINATE IEBUPDTX PROCESSING.
*                  SHOULD ONLY SPECIFY 0, 4, 8 OR 12 (RISK IS YOURS).
*                  COND=4 IS USEFUL IF SYSUT2 IS SEQUENTIAL.
*
*        OUTDD=    SPECIFIES THE DDNAME OF A NEW OUTPUT FILE.
*                  CURRENT NEW MASTER DATA SET IS CLOSED, AND THE NEW
*                  ONE IS OPENED IN ITS PLACE.
*                  THE NEW DDNAME MUST BEGIN WITH THE LETTERS 'SYS'.
*                  THE CHAINING OPTION IS AUTOMATICALLY RESET WHEN
*                  OUTDD IS SPECIFIED.
*
*        INDD=     SAME AS ABOVE, BUT RESPECIFIES OLD MASTER FILE NAME
*
*        LIBDD=    SAME AS ABOVE, BUT RESPECIFIES THE COPY LIBRARY    C
*                  DDNAME (USED BY COPY, MACRO, AND LIST COMMANDS).   C
*        NOUSER    .....                                              #
*        USER=     SPECIFY NAME OF GLOBAL EXIT ROUTINE, OR CANCEL IT. #
*                                                                     #
*    (NO)UPDATES   .....                                            SMP
*        UPDATES=  SPECIFY A PREFIX WHICH DDNAMES FOR INTERMEDIATE  SMP
*                  UPDATE FILES MUST HAVE.                          SMP
*                                                                   SMP
*                                                                82060
*    (NO)SSI   RESET GLOBAL SSI OPTION; SSI SETS SSI=000YYDDD    82060
*        SSI=HEX  SETS DEFAULT GLOBAL SSI FOR SYSUT1 ADD/CHANGE  82060
*                                                                82060
*    (NO)GANG  SETS GLOBAL GANG OPTION                           82060
*                                                                82060
*    (NO)ASM   CAUSES GANG TO SKIP OVERLAY AND CONTINUED CARDS   82060
*        CTL=??  SPECIFIES TWO CHARACTERS WHICH IDENTIFY CONTROL 82060
*              CARDS IN LIEU OF './'. AT LEAST ONE MUST BE LOWER 82060
*              THAN C'A'; NEITHER MAY BE BLANK OR COMMA.         82060
*
*  THE FOLLOWING REPRESENT THE DEFAULT PARM VALUES --
*
*        NONAMES,NOINSERT,NOCHAIN,NOLISTLEV,NOLISTDEL,NOLISTRN,       V
*        NODECK,NOTIMES,INCR=1,NODECKQ,COND=8,OUTDD=SYSUT2,           A
*        NOCHAINUPD,INDD=SYSUT1,LISTING,LIBDD=SYSLIB                  C
*        NOSEQFIX,NOIMPLSEQ,NOLISTALL                                 V
*        UPDATES                                                    SMP
*        AT DIAL-TYME:  LISTADD, SSI=000YYDDD, WYLRUN, INTEGER   82060
*
*
PARM     LA    R2,CTLAREA         POINTER TO PRINT WITH
         XPRADR PWA,TEXT=(R2)   PRINT CTLAREA                    82060
         L     R2,KSCANPTR        POINTER SAVED BY 'CCLOOK' ROUTINE
         LA    R4,1               INCREMENT
         LA    R5,CTLBUF+70       LIMIT
*
PPB1     CLI   0(R2),C' '         LOOP SKIPS BLANKS TO FIND KEYWORDS
         BNE   PPKEY
         BXLE  R2,R4,PPB1
         B     PARMDONE           NO KEYWORD FOUND
*
*  NOW R2 -> FIRST LETTER OF KEYWORD.  WE SPAN TO NEXT DELIMITER
*  (SPECIAL CHARACTER).
*
PPKEY    LR    R1,R2              SAVE ADDRESS FIRST LETTER OF KEYWORD
         RESET (PPVALUE,PPNO)     INITIALIZE FLAGS
PPKL1    CLI   0(R2),C'A'
         BL    PPKEQ
         BXLE  R2,R4,PPKL1
*
PPKEQ    CLC   0(2,R1),=C'NO'     TEST FOR NEGATION KEYWORD
         BNE   PPYES
         SET   PPNO               SO WE REMEMBER TO INVERT THE BIT
         LA    R1,2(,R1)          ADVANCE POINTER PAST THE 'NO'
*
*  FETCH THE KEYWORD (WITH POSSIBLE 'NO' PREFIX REMOVED) AND LOOK IT
*  UP IN 'PARMTBL'
*
PPYES    LR    R3,R2              ADDRESS+1 OF LAST LETTER OF KEYWORD
         SR    R3,R1              NO. OF LETTERS IN KEYWORD
         SR    R3,R4              -1 FOR MOVE
         BM    PARME1             ERROR - NULL KEYWORD
         CH    R3,=H'8'
         BNL   PARME1             ERROR IF MORE THAN 8 CHARACTERS
         MVC   WORKA,BLANKS       CLEAR WORK AREA TO RECEIVE KEYWORD
         EX    R3,CMDMOVE         HERE IT COMES
*
         L     R3,PRMTBLA          GET PARM TABLE ADDR          JRE0036
         LA    R14,11             INCREMENT
         L     R15,PRMTBLXA        END OF TABLE                 JRE0036
PPLKUP   CLC   WORKA,0(R3)
         BE    PPGOTIT            BRANCH WHEN KEYWORD FOUND IN TABLE
         BXLE  R3,R14,PPLKUP
         B     PARME1             ERROR - UNKNOWN KEYWORD
*
*  R3 -> ENTRY IN 'PARMTBL' FOR THIS KEYWORD.
*  FETCH KEYWORD VALUE IF ONE IS ALLOWED (BRANCH TABLE BYTE NON-ZERO),
*  OR SET/RESET GLOBAL FLAG REPRESENTING THIS KEYWORD (FLAG BIT OFFSET
*  BYTE NON-ZERO).
*
PPGOTIT  XR    R14,R14            WORK REGISTER
         CLI   10(R3),0           TEST IF SHOULD SET A GLOBAL BIT
         BE    PPKEYW             NO - IT'S A "VALUE" KEYWORD.
         CLC   =C'=NO',0(R2)  SPECIAL FORM ?                     82060
         BNE   PPGOTITY                                          82060
         LA    R2,3(,R2)     SKIP OVER                           82060
         IF    PPNO,PARME1   NO...=NO IS INVALID                 82060
         SET   PPNO          SET NEGATION                        82060
PPGOTITY IC    R14,9(,R3)         BYTE OFFSET TO FLAG WRT 'GFLAGS'
         LA    R14,GFLAGS(R14)    POINT TO BYTE CONTAINING THE FLAG
         OC    0(1,R14),10(R3)    SET THE FLAG ON.
         IF    ¬PPNO,PPSET        WAS KEYWORD PREFIXED BY 'NO'
         XC    0(1,R14),10(R3)    YES - INVERT FLAG TO SET IT OFF
PPSET    CLI   0(R2),C' '         TEST IF WAS LAST KEYWORD
         BE    PARMDONE           YES - LEAVE
         CLI   0(R2),C','         NO - MUST FIND COMMA
         BNE   PARME1             * OR IS AN ERROR
         BXLE  R2,R4,PPKEY        GO DO NEXT KEYWORD
         B     PARME1             NO CONTINUATIONS YET
*
PPKEYW   CLI   0(R2),C'='         TEST IF USER SPECIFIED A "VALUE"
         BNE   PPKEYNV            BRANCH IF NOT.
*
*  R2 -> '=' BECAUSE KEYWORD VALUE WAS SPECIFIED.
*  FETCH THIS VALUE FROM THE ./ PARM CARD IMAGE TO 'WNAME' RIGHT
*  JUSTIFIED FOR EASY ACCESS TO IT LATER.
*
         IF    PPNO,PARME1        CAN'T SAY, EG. "NOINCR=50"
         SET   PPVALUE
         LA    R6,WNAME           ADDRESS OF RECEIVING FIELD
         MVC   0(8,R6),BLANKS     CLEAR FIELD TO RECEIVE VALUE
         LR    R1,R2              ADDRESS OF THE '='
*
PPKEY2   CLI   1(R2),C'A'         SCAN FOR DELIMITER (COMMA OR BLANK)
         BL    PPVALEND           BRANCH OUT WHEN HAVE IT.
PPKEY22  BXLE  R2,R4,PPKEY2                                         SMP
*
PPVALEND EQU   *                                                    SMP
         CLI   1(R2),C'$'         TREAT NATIONALS LIKE A-Z          SMP
         BE    PPKEY22                                              SMP
         CLI   1(R2),C'#'                                           SMP
         BE    PPKEY22                                              SMP
         CLI   1(R2),C'@'                                           SMP
         BE    PPKEY22                                              SMP
         CLI   8(R3),12      CTL= VERB ?                         82060
         BNE   PPVALENT      NO; HAVE END                        82060
         CLI   1(R2),C' '    TRAILING BLANK ?                    82060
         BE    PPVALENT      YES; QUIT                           82060
         CLI   1(R2),C','    TRAILING COMMA ?                    82060
         BNE   PPKEY22       NO; ALLOW SPECIAL FOR CONTROL       82060
PPVALENT LR    R15,R2             ADDRESS OF THE LAST CHARACTER  82060
         SR    R15,R1             LENGTH OF VALUE STRING
         SR    R15,R4             -1 GIVES LENGTH FOR MOVE
         BM    PARME1             ERROR IF NULL
         CH    R15,=H'8'
         BNL   PARME1             ERROR IF MORE THAN 8 CHARACTERS
         SR    R6,R15             OFFSET (-7) TO RIGHT JUSTIFY
         EX    R15,KEYMOVER       FETCH KEYWORD "VALUE"
         AR    R2,R4              POINT TO DELIMITER FOR LATER
         CLC   =C' NO',WNAME+5  KEYWORD=NO ?                     82060
         BNE   PPKEYNV       NO                                  82060
         RESET PPVALUE       SHOW NO VALUE SUPPLIED              82060
         SET   PPNO          SET NEGATION                        82060
*
*  GET OFFSET IN BRANCH TABLE FROM 'PARMTBL' ENTRY.
*  LINK TO SPECIALIZED ROUTINE FOR THIS KEYWORD.
*
PPKEYNV  IC    R14,8(,R3)         INDEX TO BRANCH TABLE
         SLL   R14,1                                             82060
         LH    R14,PPKEYNVT(R14)  GET BRANCH OFFSET              82060
         LA    R3,PPSET      SET RETURN ADDRESS                  82060
         B     BBAS(R14)     CALL ROUTINE FOR THIS KEYWORD       82060
PPKEYNVT DC    Y(PPSET-BBAS)     00 GO DO NEXT KEYWORD.          82060
         DC    Y(PSINCR-BBAS)    01 INCR=...                     82060
         DC    Y(PARME1-BBAS)    02 DECKINCR - OPTION REMOVED -  82060
         DC    Y(PSCHAIN-BBAS)   03 CHAIN=... | CHAIN | NOCHAIN  82060
         DC    Y(PSCOND-BBAS)    04 COND=...                     82060
         DC    Y(PSDECK-BBAS)    05 DECK | NODECK                82060
         DC    Y(PSOUTDD-BBAS)   06 OUTDD=...                    82060
         DC    Y(PSINDD-BBAS)    07 INDD=                        82060
         DC    Y(PSUSER-BBAS)    08 USER=... | NOUSER            82060
         DC    Y(PSLIBDD-BBAS)   09 LIBDD=...                    82060
         DC    Y(PSUPDATE-BBAS)  10 UPDATES=... | UPDATES | NOUPDATES
         DC    Y(PSGBLSSI-BBAS)  11 SSI<=DATE> | SSI=... | NOSSI 82060
         DC    Y(PSCTLCOD-BBAS)  12 CTL=./ REPLACEMENT           82060
         DC    Y(PSLINECT-BBAS)  13 LINECNT=                     83014
*
*
*  ROUTINES FOR SPECIAL KEYWORDS WHICH NEED SPECIFIC ATTENTION.
*
*
PSINCR   LA    R1,WNAME           -- SET DEFAULT INSERT/REPLACE INCR --
         IF    ¬PPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED
         GOSUB DECCHK             TEST FOR VALID DECIMAL DIGITS
         PACK  PINCR,WNAME
         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE
*
PSCOND   LA    R1,WNAME           -- SET ERROR SEVERITY LIMIT --
         IF    ¬PPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED
         GOSUB DECCHK              TEST VALID NUMERICS
         PACK  WORKA,WNAME
         CVB   R1,WORKA
         STH   R1,COND             STORE FOR USE BY ERROR HANDLER LATER
         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE
*
*                                 -- HANDLE PARM 'DECK' OPTION --
PSDECK   IF    PPVALUE,PARME1     VALUE MUST NOT HAVE BEEN SPECIFIED
         RESET DECK
         IF    PPNO,PSNODECK      BRANCH IF SPECIFIED 'NODECK'
         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN                 80002
         BO    PSDECK1            BRANCH IF SYSPUNCH ALREADY OPEN
         MVC   DCBDDNAM-IHADCB+SYSPUNCH,DDPUNCH SET SYSPUNCH DDNAME SMP
         LA    R6,PUDATA          DSECT POINTER TO SYSPUNCH WORK AREA
         GOSUB NMOPEN             * AND OPEN IT.
         B     *+4(R15)           SKIP SETTING FLAG IF NO SYSPUNCH DD
PSDECK1  SET   DECK               TELLS LOGRTN TO PUNCH A DECK.
PSNODECK BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE
*
PSOUTDD  SET   FNAME              -- RESPECIFY NEW MASTER DDNAME --
         IF    ¬PPVALUE,PARME1                                        #
         LA    R6,NMDATA          SYSUT2 DSECT POINTER
         GOSUB LJNAME             LEFT JUSTIFY IT
         CLC   NAME,NMNAME        TEST IF NEW DDNAME REALLY IS NEW
         BER   R3                 NO - IGNORE IT.                80002
         IF    ¬UT2AVAIL,PSKPCLS  TEST IF NEED TO CLOSE PREVIOUS NM
         GOSUB NMTRUNC            WRITE OUT THE LAST BUFFER
         GOSUB NMCLOSE            CLOSE PREVIOUS NEW MASTER DD
         RESET UT2AVAIL
         RESET NMWNOT1       RESET WYLBUR FIRST TIME FLAG        82060
         XC    NMCOUNT(5*4),NMCOUNT  CLEAR EVERYTHING            82060
PSKPCLS  MVC   DCBDDNAM-IHADCB+SYSUT2,NAME  CHANGE DDNAME IN NM DCB
         MVC   NMNAME,NAME        SAVE NEW MASTER DDNAME
         IF    XPARMS,(R3)        DONE IF EXEC PARM                 SMP
         RESET CHAINING                                             SMP
         GOSUB NMOPEN             CALL TO OPEN NEW OUTPUT FILE
         B     *+4(R15)           TEST IF OPEN FAILED
         SET   UT2AVAIL           YES - DON'T SET THIS FLAG
         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE
*
PSINDD   SET   FNAME              -- RESPECIFY OLD MASTER DDNAME ---
         IF    ¬PPVALUE,PARME1                                        #
         GOSUB LJNAME             LEFT  JUSTIFY DDNAME                #
         CLC   NAME,OMNAME        TEST THAT INDD DDNAME REALLY IS NEW
         BER   R3                 NO - RETURN (JOB WELL DONE)    80002
         MVC   OMNAME,NAME        SET NEW (OLD MASTER) DDNAME
         IF    XPARMS,(R3)        DONE IF EXEC PARMS                SMP
*  CHAIN DOWN CONTROL STRUCTURE TO SYSUT1.  IF THERE IS NO SYSUT1
*  LEVEL, CREATE IT AT THE END.
*  THIS MAY APPEAR UNNECESSARY (IE. WHY NOT HAVE AN END OF CHAIN
*  POINTER TO LEVEL BEFORE SYSUT1), BUT ALLOWS FOR UPWARD
*  COMPATIBILITY WITH SOME FAR OUT IDEAS WHICH MAY COME LATER
INDDLOOP LR    R6,R9              SAVE POINTER
         ICM   R9,15,NEXTLEV      NEXT LEVEL DOWN CONTROL CHAIN  80002
         BZ    INDDGL             NONE - GET NEW LEVEL FOR SYSUT180002
         IF    ¬SYSUT1,INDDLOOP   NO - KEEP LOOKING FOR SYSUT1
         GOSUB CTLCLOSE           CLOSE OLD SYSUT1 FILE
         IF    REALEOF+¬CTLPS,INDDHL
         ERROR '*** DDNAMEOM - UNPROCESSED OLD MASTER RECORDS EXIST ****
               ',(5,OMNAME),RC=4                                 82060
         B     INDDHL             GO TO OPEN NEW INDD
*
INDDGL   ST    R2,WORKA
         L     R15,=A(LCLINIT)    GET NEW CONTROL LEVEL STORAGE  82060
         BALR  R14,R15            CALL                           80294
         ST    R2,NEXTLEV-LOCAL(,R6)   PUT ON END OF CHAIN
         LR    R9,R2              ADDRESSIBILITY FOR NEW LEVEL
         L     R2,WORKA
         SET   SYSUT1             FLAG AS SOURCE LEVEL
INDDHL   MVC   OBWORK(8),OMNAME   NEW DDNAME FOR SYSUT1
         DEVTYPE OBWORK,OBWORK+8  CHECK FOR DD PRESENT, GET DEVTYPE
         BXH   R15,R15,INDDE1   BIG ERROR IF NONE                82060
         MVC   LEVNAME,OMNAME     SET DDNAME FOR OPEN
         GOSUB CTLOPEN            OPEN NEW O.M. FILE
         RESET (REALEOF,CTLEOF)
         ICM   R9,15,SYSINADR     RESET R9 BEFORE LEAVING        80002
         BNZR  R3                                                80002
         L     R9,LIBADR          USE SYSLIB DURING INIT.        80002
         BR    R3                 RETURN TO PARM LOOP
*
*                                 -- HANDLE 'CHAIN' PARM OPTION --
PSCHAIN  IF    PPNO,PNOCHAIN      BRANCH IF SPECIFIED 'NOCHAIN'
         SET   CHAINING           INDICATE PARM=CHAIN SPECIFIED     SMP
         IF    ¬XPARMS,PSOUTDDD   SKIP IF NOT PARM= PROCESSING   82060
         IF    ¬PPVALUE,(R3)      RETURN IF NO ID SUPPLIED       82060
         MVC   LIBID,WNAME+6      SAVE LIBRARY ID                82060
         SET   PRMLIBID      SHOW LIBRARY ID SUPPLIED            82060
         BR    R3            RETURN TO PARM PROCESSING           82060
*  ENTER HERE DURING IEBUPDTX INITIALIZATION TO COMPLETE PARM=CHAIN SMP
*  PROCESSING NOW THAT NEW MASTER LIBRARY IS READY.                 SMP
PSOUTDDC IF    ¬PRMLIBID,PSOUTDDD  SKIP IF NOT CHAIN= PARM       82060
         SET   PPVALUE       FAKE PARM PROCESSING                82060
         MVC   WNAME+6(2),LIBID    RESTORE LIBRARY ID            82060
PSOUTDDD LA    R6,NMDATA                                         82060
         IF    ¬UT2AVAIL+NMPS,PCHNBAD  CAN'T CHAIN WITHOUT SYSUT2 (PO)
*  PARM CALLED FOR CHAINING.  TRY TO READ IN THE ALLOCATOR.
*  IF THERE IS NONE, CREATE ONE.
         BLDL  NM,BLDALLOC        TRY READ IN ALLOCATOR
         BXH   R15,R15,ALLOC1     IF FAILED, CREATE IT           82060
         CLI   BATTR+2,0
         BE    ALLOC1
*
         MVC   STWATTR,BATTR      SET UP FOR FUTURE STOW-ING
         MVC   STWAC(5),BAC       LIBRARY INFO.
         IF    ¬PPVALUE,PSCHAINX  NO ID SUPPLIED BY USER         82060
         CLC   LIBID,WNAME+6   MATCHES ALLOCATOR ID ?            82060
         BE    PSCHAINX      YES                                 82060
         ERROR '*** CHAIN ID XX DOES NOT MATCH LIBRARY ID YY ***',     *
               (13,WNAME+6,2),(42,LIBID),RC=4                    82060
         B     PSCHAINX
*  CREATE ALLOCATOR IN SYSUT2 DIRECTORY
ALLOC1   IF    ¬PPVALUE,CHNE1     MUST SPECIFY LIBRARY ID IF NEW
         MVC   LIBID,WNAME+6       MOVE LIBRARY I.D.
         STOW  NM,STWALLOC,A
         BXH   R15,R15,STWABOMB   BOMB IF COULDN'T CREATE        82060
*
PSCHAINX UNPK  WORKA(3),AMEMBID   GET ALLOCATOR MEMBER NUMBER    82060
         OI    WORKA+2,C'0'  MAKE NUMERIC                        82060
         ERROR '*** CHAIN LIBRARY ID = ''XX'', ALLOCATION NUMBER = NNN'*
               ,(24,LIBID),(49,WORKA,3),RC=0,ID=NO               82060
         OI    STWAC,X'80'        ALWAYS STOW AS AN ALIAS AFTER THIS
         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE
*
*                                 -- SPECIFY GLOBAL USER EXIT --      #
PSUSER   IF    PPNO,PNOUSER       BRANCH TO CANCEL GLOBAL EXIT        #
         IF    ¬PPVALUE,PARME1    ERROR IF DIDN'T SPECIFY A NAME      #
         SET   FNAME                                                  #
         GOSUB LJNAME             GO LEFT-JUSTIFY ROUTINE NAME        #
         SET   GUSER              GLOBAL FLAG                         #
         CLC   NAME,GUNAME        BE SURE NAME REALLY NEW             #
         BER   R3                 IF NOT, ALREADY DONE.          80002#
*                                                                     #
         CLI   GUNAME,C' '        TEST IF PREVIOUS ONE TO DELETE      #
         BE    PSUSD              NO - SKIP THE DELETE                #
         DELETE  EPLOC=GUNAME     DITCH UNWANTED EXIT ROUTINE         #
PSUSD    MVC   GUNAME,NAME        SAVE NEW GLOBAL USER NAME           #
         LOAD  EPLOC=GUNAME       LOAD NEW GLOBAL USER EXIT ROUTINE   #
         ST    R0,GUADR           SAVE ITS ADDRESS                    #
         BR    R3                 RETURN TO PARM DRIVER               #
*                                                                     #
PNOUSER  RESET GUSER              CANCEL GLOBAL EXIT                  #
         CLI   GUNAME,C' '        TEST IF PREV. MOD. TO DELETE        #
         BER   R3                 NO - BACK TO PARM ROUTINE      80002#
         DELETE  EPLOC=GUNAME                                         #
         MVI   GUNAME,C' '                                            #
         BR    R3                 RETURN TO PARM ROUTINE              #
*                                                                     #
PSLIBDD  IF    ¬PPVALUE,PARME1    -- SPECIFY LIBRARY DDNAME --        C
         SET   FNAME                                                  C
         GOSUB LJNAME                                                 C
         MVC   LIBDD,NAME                                             C
         BR    R3                                                     C
*                                                                     C
PSUPDATE IF    PPNO,PNOUPD        BRANCH FOR 'NOUPDATES'            SMP
         IF    ¬PPVALUE,PUPD      BRANCH FOR 'UPDATES'              SMP
*  HANDLE PARM='UPDATES=PREFIX'                                     SMP
         CLC   =C' SYS',WNAME+4   UPDATES=SYS ?                  82060
         BE    PARME1        YES; AVOID BIG PROBLEMS             82060
         SET   FNAME              SO LJNAME WILL WORK               SMP
         GOSUB LJNAME             LEFT JUSTIFY PREFIX STRING        SMP
         STH   R15,PRELEN         SAVE LENGTH-1 OF PREFIX           SMP
         MVC   PRENAME,NAME       AND PREFIX STRING                 SMP
         BR    R3                                                   SMP
*  HANDLE PARM='NOUPDATES'                                          SMP
PNOUPD   MVC   PRELEN(3),=X'0000FF'         SET IMPOSSIBLE PREFIX   SMP
         BR    R3                                                   SMP
*  HANDLE PARM='UPDATES'                                            SMP
PUPD     MVI   PRELEN,X'FF'       SET LENGTH NEGATIVE               SMP
         BR    R3                                                   SMP
         SPACE 1                                                 82060
PSGBLSSI IF    PPNO,PSSSINO  BRANCH IF NOSSI                     82060
         IF    ¬PPVALUE,PSSSIDAT  IF NO PARM, USE DATE           82060
         CLC   =C' DATE',WNAME+3  SSI=DATE OPTION ?              82060
         BNE   PSSSIHEX      NO; SEE IF HEX                      82060
PSSSIDAT MVC   DEFSSI,DATEWORD  COPY THE DATE IN 000YYDDD FORM   82060
PSSSICOM UNPK  SSIWORK(9),DEFSSI(5)  UNPACK                      82060
         MVC   DEFSSU,SSIWORK  SET UNPACKED SSI                  82060
         SET   GBLSSI        SHOW GLOBAL SSI PRESENT             82060
         BR    R3            DO MORE                             82060
PSSSIHEX LA    R14,WNAME     GET USER AREA                       82060
         LA    R0,8          SET MAXIMUM LENGTH                  82060
PSSSILB  CLI   0(R14),C' '   LEADING BLANK ?                     82060
         BNE   PSSSILNB      NO; CHECK                           82060
*        MVI   0(R14),C'0'   REPLACE BY LEADING ZERO             82060
         LA    R14,1(,R14)                                       82060
         BCT   R0,PSSSILB    TRY FOR MORE                        82060
         B     PSSSINO       SSI= TREATED AS NOSSI               82060
PSSSILNB CLI   0(R14),C'A'   VALID ?                             82060
         BL    PARME1        NO                                  82060
         CLI   0(R14),C'F'                                       82060
         BNH   PSSSILLP      OK                                  82060
         CLI   0(R14),C'0'   NUMERIC ?                           82060
         BL    PARME1        NO; FAIL                            82060
         CLI   0(R14),C'9'   MULTI-PUNCHED ?                     82060
         BH    PARME1        YES; TSK, TSK                       82060
PSSSILLP LA    R14,1(,R14)                                       82060
         BCT   R0,PSSSILNB   TRY ALL                             82060
         NC    WNAME(8),=8X'1F'  CHEAT                           82060
         TR    WNAME(8),PSSSIHTR  TRANSLATE                      82060
         PACK  SSIWORK(5),WNAME(9)  PACK                         82060
         MVC   DEFSSI,SSIWORK  PLACE IN DEFAULT                  82060
         B     PSSSICOM      GO TO COMMON                        82060
PSSSIHTR DC    AL1(0,10,11,12,13,14,15),10X'0',AL1(1,2,3,4,5,6,7,8,9)
PSSSINO  RESET GBLSSI        RESET, BUT DON'T CHANGE DEFSSI      82060
         BR    R3            DO MORE                             82060
         SPACE 1                                                 82060
PSCTLCOD IF    PPNO,PARME1   NOCTL IS INVALID                    82060
         IF    ¬PPVALUE,PARME1  CTL= ALSO BAD                    82060
         CLI   WNAME+5,C' '  NO MORE THAN TWO BYTES ?            82060
         BNE   PARME1        TOO LONG, TOO BAD                   82060
         CLI   WNAME+6,C' '  TWO BYTES ?                         82060
         BNH   PARME1        NO; ERROR                           82060
         CLI   WNAME+6,C'A'  NON-ALPHAMERIC FIRST BYTE ?         82060
         BL    PSCTLCOM      YES; ACCEPT                         82060
         CLI   WNAME+7,C'A'  OR NON-ALPHA SECOND BYTE ?          82060
         BNL   PARME1        TOO BAD                             82060
PSCTLCOM MVC   DOTSLASH,WNAME+6  REPLACE CONTROL CARD CODE       82060
         BR    R3                                                82060
         SPACE 1                                                 83014
PSLINECT LA    R1,WNAME           -- SET LINES/PAGE        --    83014
         IF    ¬PPVALUE,PARME1    VALUE MUST HAVE BEEN SPECIFIED 83014
         GOSUB DECCHK                   MUST BE DECIMAL          83014
         PACK  WORKA,WNAME                                       83014
         CVB   R1,WORKA                                          83014
         CH    R1,=H'24'          PAGE TOO SHORT ?               83014
         BL    CMDE28              YES - SHORTEN RUN             83014
         CH    R1,=H'132'         PAGE TOO LONG ?                83014
         BH    CMDE28              YES - MAKE USER'S FACE LONG   83014
        XPRMOD PWA,MAXLINE=(R1)                                  83014
         BR    R3                                                83014
*                                                                   SMP
PCHNBAD  ERROR '*** CHAINING IGNORED - IMPROPER DDNAMENM ***',         *
               (32,NMNAME),RC=4                                  82060
PNOCHAIN RESET CHAINING           PARM = 'NOCHAIN'
         BR    R3                 RETURN FOR NEXT KEYWORD TO BE DONE
*
*
CHNE1    ERROR '*** LIBRARY ID REQUIRED FOR NEW ALLOCATOR ***',RC=12
STWABOMB ERROR '*** ERROR CREATING ALLOCATOR ***',RC=ABEND
PARME1   ERROR '*** ERROR IN PARM FIELD ***',RC=12  FAIL BAD PARM
PARMLEN  ERROR '*** PARM FIELD LENGTH EXCESSIVE ***',RC=12
INDDE1   ERROR '*** INDD - DDNAMEOM DD STATEMENT MISSING ***',         *
               (11,OBWORK,8),RC=12     ADD DDNAME                82060
*
*
PARMDONE RESET CTLEOF
         IF    ¬PARMNEW,PRMNMOD   SKIP IF PARM=NEW NOT USED      82060
         RESET (PARMNEW,PARMMOD)  TURN BOTH OFF                  82060
PRMNMOD  LA    R6,NMDATA          RESTORE R6 TO SYSUT2 WORK AREA 82060
         IF    XPARMS,XPARMRET    SPECIAL EXIT FOR EXEC PARMS       SMP
         EJECT
*
*  LOOP HERE UPDATES MEMBERS UNTIL SYSIN END OF FILE
*
*
MAINL    EQU   *
MAINLOOP IF    ¬ANYFCB,SKPFREE3   SKIP IF NO FCB'S ALLOCATED
         FREEMAIN R,SP=3          FREE ALL FCB'S USED THIS UPDATE
         RESET ANYFCB
SKPFREE3 ICM   R0,15,SYSINADR   ENTERED FROM PARM/SETUP ERROR ?  82060
         BZ    STOP          YES; QUIT                           82060
         IF    REALEOF,STOP
         XC    CMDFLGS,CMDFLGS
         XC    OMSEQ,OMSEQ
         RESET NOWRITE            CLEAR NO-WRITE SWITCH               A
         USING IHADCB,R1
         XR    R0,R0                                             82060
         LA    R6,PUDATA          POINT TO SYSPUNCH WORK AREA
         LA    R1,NM              SYSPUNCH DCB ADDRESS
         MVC   FDAD,DCBFDAD       SAVE DISK ADDRESS IN CASE OF ERROR
         MVC   NMRELAD,DCBRELAD   SAVE TTR OF RELAD              82060
         MVC   TRBAL,DCBTRBAL
         ST    R0,NMCOUNT    RESET COUNT                         82060
         IF    NMPS,MAININUT   SKIP WYLBUR INIT IF SEQ.          82060
         RESET NMWNOT1       RESET WYLBUR FIRST TIME FLAG        82060
         XC    NMWYL#(4*4),NMWYL#   CLEAR WYLBUR INFO            82060
MAININUT LA    R6,NMDATA     POINT TO SYSUT2 WORK AREA FOR OUTPUT
         LA    R1,NM
         MVC   FDAD,DCBFDAD       SAVE IN CASE MEMBER BLOWS
         MVC   NMRELAD,DCBRELAD   SAVE FOR RESTORE AND ERROR     82060
         MVC   TRBAL,DCBTRBAL
         ST    R0,NMCOUNT    RESET COUNT                         82060
         IF    NMPS,MAININGO   SKIP WYLBUR INIT IF SEQ.          82060
         RESET NMWNOT1       RESET WYLBUR FIRST TIME FLAG        82060
         XC    NMWYL#(4*4),NMWYL#   CLEAR WYLBUR INFO            82060
         DROP  R1
*
MAININGO IF    CTLEOF,MAINSR      SKIP READ IF CTL. CARD WAITING 82060
MAINREAD GOSUB CTLREAD,BXH=STOP   QUIT IF READ PROBLEM OR EOF    82060
         GOSUB CCLOOK             TEST FOR MAIN CONTROL CARD
         CH    R15,=H'4'
         BNH   MAINERR            FLUSH FOR MAIN CONTROL CARD
MAINSR   RESET CTLEOF
         IF    ¬LISTING,MAINAC0   NO EJECT IF LISTING SUPPRESSED 82060
         CLI   CMDNUM+3,VCCHANGE  IS OPCODE ADD OR CHANGE ?      82060
         BNH   MAINAC1             YES - DON'T PRINT UNDERSCORES 80294
MAINAC0  XPRNTLIN PWA,TEXT=UNDERS,LENGTH=PWIDTH,SPB=1,SPA=2      82060
         SET   PRVEJECT      FAKE PREVIOUS PAGE EJECT            82060
         CLI   CMDNUM+3,VCPARM    TEST IF 'PARM' COMMAND         82060
         BE    PARM               YES - ESCAPE TO SPECIAL ROUTINE
MAINAC1  SET   OMFIRST             SET FOR AUTO-ID-SEQ STUFF     80294
         RESET (IDSEQ,REMID)
         RESET FIXFAIL       RESET FAILED FIX CARD               82060
         ZAP   INCR,PINCR         FOR POSSIBLE ./ SEQUENCE            #
         ZAP   NEW1,PINCR         FOR POSSIBLE ./ SEQUENCE            #
         GOSUB KEYSCAN
         MVC   GMEMB,NAME         SYSIN NAME CONTROLS ALL
         MVC   HNAME,GMEMB        PUT NAME IN HEADING LINE
MAINACH  CLI   CMDNUM+3,VCCHANGE  IS OPCODE ADD OR CHANGE ?      82144
         BH    MAINAC2             NO  - DON'T EJECT             80294
         IF    PRVEJECT,MAINAC2  DON'T EJECT TWICE               82060
         IF    ¬LISTING,MAINAC2  PREVENT PAGE EJECT IF TERSE     82150
      XPREJECT PWA                 YES - NEW PAGE                80294
*
*  BRANCH ACCORDING TO MAJOR FUNCTION
*
MAINAC2  L     R1,CMDNUM          GET COMMAND'S SEQUENCE NUMBER  80294
         SLL   R1,1          MAKE TABLE OFFSET                   82060
         LH    R1,MAINFTAB(R1)   GET OFFSET TO COMMAND CODE      82060
         B     BBAS(R1)      BRANCH TO HANDLE SPECIFIED COMMAND  82060
*                                                                     A
MAINFTAB DC    2Y(POSFIN-BBAS)      ADD, REPLACE                 82060
         DC    Y(POSLOOP-BBAS)      CHANGE                       82060
         DC    Y(STOP-BBAS)         ENDUP                        82060
         DC    Y(DROP-BBAS)         DROP                         82060
         DC    Y(CURRENT-BBAS)      CURRENT                      82060
         DC    Y(PARM-BBAS)         PARM      (CAN'T HAPPEN)     82060
         DC    Y(LIST-BBAS)         LIST                         82060
         DC    Y(LOAD-BBAS)         LOAD                         82060
         DC    Y(RENAME-BBAS)       RENAME                       82060
         DC    Y(GENALIAS-BBAS)     GENALIAS                     82060
         DC    Y(RESTORE-BBAS)      RESTORE                      82060
*
*  POSITION ALL UPDATE FILES TO CURRENT MEMBER
*
POSLOOP  LR    R2,R9              PREVIOUS LEVEL IN R2 FOR SUBROUTINE
         ICM   R9,15,NEXTLEV      NEXT LEVEL TO BE POSITIONED    80002
         BZ    POSBOMB            BRANCH WHEN ALL FILES TRIED
         GOSUB POSITION
         IF    CHANGE+CTLEOF,POSLOOP
*
POSFIN   CLI   CMDNUM+3,VCADD    ADD SPECIFIED ?                 82060
         BNE   POSFINA       NO                                  82060
         IF    NMPS,POSFINA  SKIP IF NOT PO OUT                  82060
         IF    ¬PARMMOD,POSFINA   IF PARM=MOD, CONTINUE          82060
         IF    CHAINING,POSFINA   SKIP IF CHAINING               82060
         IF    LOADING,POSFINA    SKIP IF LOADING                82060
         CALLSUB PRESTOW,GMEMB    SEE IF MEMBER EXISTS           82060
         L     R1,=A(PSTBLDL)                                    82060
         USING PSTBLDL,R1                                        82060
         IF    ¬PSTFLAG,POSFINA  OK IF DOES NOT EXIST            82060
         CALLSUB POSTSTOW    PRINT DATA                          82060
         B     RNDUPL        WRITE ERROR - EXISTS ALREADY        82060
POSFINA  RESET FLUSHING                                          82060
         LOG   STRT               LOG START OF NEW MEMBER (FOR DECK)
         L     R9,SYSINADR        POINT TO SYSIN
         XC    LCLFCBAD,LCLFCBAD  ZERO SCAN CHAIN POINTER IN DSECT
         XC    USERWORK,USERWORK  ZERO WORK FIELD FOR USER ROUTINES
         MVC   OMSQ,=8C'0'        CURRENT O.M. SEQ. NO. SET LOW
         ZAP   IMPLNUM,=P'0'      SET FOR POSSIBLE PARM=IMPLSEQ       A
         LR    R2,R9
         LA    R3,NMAREA
         IF    FSSI,POSGANG  NO ACTION IF USER SSI               82060
         IF    ¬GBLSSI,POSGANG  ALSO IF NO GLOBAL SSI            82060
         SET   SSISPEC       SET SSI AVAILABLE                   82060
         MVC   SSI,DEFSSU                                        82060
         XC    SSICOUNT,SSICOUNT  CLEAR LEADING BLANK COUNT      82060
POSGANG  IF    ¬GBLGANG,POSLISAD  SKIP GLOBAL GANG IF OFF        82060
         CALLSUB DEFGANG     SEE IF CAN AND NEED TO SET GANG     82060
POSLISAD IF    ¬LISTADD,GOLOOP  CHECK IF ./ ADD GLOBAL LIST SET  82060
         IF    ¬ADD,GOLOOP   SKIP IF NOT ADD                     82060
         SET   LISTALL       LIST ALL ADDED CARDS                82060
GOLOOP   BAL   R10,UPDATE         CALL RECURSIVE UPDATE FOR NEXT CARD
         BXH   R15,R15,MEMBEND   BRANCH AT END OF UPDATE         82060
*                                                                     #
         IF    ¬GUSER,NOGUSER     SKIP IF NO GLOBAL USER EXIT         #
         L     R15,GUADR          ADDRESS OF ENTRY POINT              #
         LR    R2,R3              RECORD AREA (-6) POINTER            #
         BALR  R14,R15            CALL USER EXIT ROUTINE              #
         B     *+4(R15)           TEST RETURN CODE                    #
         B     GUOK               OK - NO CHANGE MADE                 #
         B     GUNG               ERROR - DELETE NOT ALLOWED          #
         B     GUOK               OK - RECORD MODIFIED                #
         NOP   0                  ERROR - INSERT NOT ALLOWED          #
GUNG     ERROR '*** GLOBAL USER EXIT ERROR ***'                       #
GUOK     LR    R2,R9              RESTORE R2                          #
NOGUSER  EQU   *                                                      #
*                                                                     #
         LOG   NEWM               LOG NEW MASTER RECORD WRITTEN
         LA    R1,NMREC           ADDRESS OF RECORD                   A
         GOSUB NMWRITE            WRITE A NEW MASTER RECORD
         B     GOLOOP
*
*  MEMBER UPDATE COMPLETE - GO ON TO THE NEXT.
*
MEMBEND  XPRSPACE PWA
         IF    ¬FIXFAIL,MEMBENDF  OK IF FIXES APPLIED            82060
         ERROR '*** SCAN/FIX CARD HAD NO EFFECT ***',ID=NO       82060
MEMBENDF LOG   MEMX               LOG END OF UPDATE OPERATION    82060
         IF    NMPS,MAINLOOP      SKIP STOW FOR SEQUENTIAL OUTPUT
         GOSUB NMTRUNC            WRITE LAST BLOCK SHORT
         GOSUB NMSTOW             AND UPDATE DIRECTORY
         B     MAINLOOP           ON TO NEXT MEMBER
*
*  SYSIN END OF FILE
*
STOP     IF    ¬UT2AVAIL,UT2NC    IF SYSUT2 NOT OPEN, DON'T CLOSE IT.
         GOSUB NMTRUNC            FINISH ANY PENDING OUTPUT
         GOSUB NMCLOSE            CLOSE SYSUT2
UT2NC    EQU   *
*
         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN                 80002
         BZ    CLSLOOPT      IF SYSPUNCH CLOSED, TEST SYSIN      82060
         LA    R6,PUDATA          YES - CLOSE IT
         GOSUB NMTRUNC
         GOSUB NMCLOSE            CLOSE SYSPUNCH
*
CLSLOOP  GOSUB CTLCLOSE           CLOSE ALL CONTROL FILES
         L     R9,NEXTLEV
CLSLOOPT LTR   R9,R9         ALLOCATED FILE ?                    82060
         BNZ   CLSLOOP
*
         L     R9,LIBADR          POINT TO SYSLIB DSECT
         CLI   LEVNAME,C' '       TEST IF NEED TO CLOSE COPY LIBRARY
         BE    NOLIBC
         GOSUB CTLCLOSE
NOLIBC   EQU   *
*
         CLI   USERNAME,C' '      TEST ANY USER ROUTINE LOADED
         BE    NOUDLT             NO - THEN CAN'T DELETE IT
         DELETE  EPLOC=USERNAME
NOUDLT   EQU   *
         IF    ¬GUSER,NOGUDLT                                         #
         DELETE EPLOC=GUNAME      DELETE POSSIBLE GLOBAL USER EXIT    #
NOGUDLT  EQU   *                                                      #
         TM    DCBOFLGS-IHADCB+SNAPDCB,DCBOFOPN                  80002
         BZ    NOSNAPC
         CLOSE SNAPDCB            CLOSE SNAPDCB ONLY IF DD CARD OK
*
NOSNAPC  FREEMAIN R,SP=2          FREE ALL THE 'LOCAL' AREAS
*
         L     R2,STEPRC          LOAD STEP RETURN CODE
         CVD   R2,WORKD
         UNPK  STOPMSGA,WORKD+6(2)
         OI    STOPMSGA+1,C'0'
         XPRNTLIN PWA,TEXT=STOPMSG,LENGTH=STOPMSGL,SPB=(1,NOEJ)       A
         XPRCLOSE PWA
         LR    R15,R2
         L     R13,4(,R13)
         RETURN (14,12),T,RC=(15)
*
*
*  DROP - DELETE A MEMBER FROM SYSUT2'S DIRECTORY.
*
DROP     CALLSUB PRESTOW,RNAME   GET OLD DATA                    82060
         STOW  NM,RNAME,D    AND DELETE IT                       82060
         BXH   R15,R15,DROP1    BRANCH ON ERROR                  82060
         MVC   DROPMSG+11(8),RNAME
         XPRNTLIN PWA,TEXT=DROPMSG,LENGTH=L'DROPMSG,SPB=1
         CALLSUB POSTSTOW    PRINT THE OLD DATA                  82060
         B     MAINLOOP
*
DROP1    ERROR '*** MEMBER NOT DELETED ***',RC=4
         B     MAINLOOP
DROPMSG  DC    C'*** MEMBER XXXXXXXX HAS BEEN DELETED'
*
*
*  RENAME - CHANGE NAME OF A SYSUT2 MEMBER.
*
RENAME   STOW  NM,STOWRN,C        STOW-RENAME
         B     *+4(R15)           TEST RETURN CODE
         B     RNOK               SUCCESSFUL RENAME
         B     RNDUPL             DUPLICATE NEWNAME
         B     CMDE12             NAME NOT FOUND
         DC    XL4'0'
         B     NMSTE              I/O ERROR
         B     NMSTE              DCB BAD                        82060
         B     NMSTG         OUT OF STORAGE                      82060
*
RNOK     XPRNTLIN PWA,TEXT=RNMSG,LENGTH=L'RNMSG,SPB=1
         CALLSUB POSTSTAD,STOWRN+8  PRINT NEW DATA               82060
         B     MAINLOOP
*
RNMSG    DC    C'*** MEMBER SUCCESSFULLY RENAMED ***'
RNDUPL   ERROR '*** NEW NAME ALREADY EXISTS ***'
NMSTG    ERROR '*** REGION TOO SMALL TO PROCEED ***',RC=ABEND    82060
*
*                                                                     A
*  GENALIAS - CREATE AN ALIAS ENTRY IN SYSUT2 DIRECTORY.              A
*  OLD AND NEW NAMES SUPPLIED AS FOR RENAME.                          A
*                                                                     A
GENALIAS MVC   BLDLNAME,STOWRN    NAME OF EXISTING MEMBER             A
         BLDL  NM,BLDLIST         GET ITS TTR                         A
         BXH   R15,R15,CUR1       BRANCH IF MEMBER NOT FOUND     82060
         CLI   BLDLTTR+2,0                                            A
         BE    CUR1                                                   A
         MVC   STOWNAME,STOWRN+8  PLUG NEW NAME FOR STOW              A
         MVC   STOWTTR,BLDLTTR    PLUG TTR OF MEMBER                  A
         MVI   STOWC,X'80'        SET ALIAS, NO USER DATA             A
         STOW  NM,STOWLIST,A                                          A
         B     *+4(R15)                                               A
         B     GENAOK             STOW SUCCEEDED                      A
         B     RNDUPL             NEW NAME WAS ALREADY THERE          A
         DC    XL4'0'             IMPOSSIBLE                          A
         B     NMSTF              DIRECTORY FULL                      A
         B     NMSTE              DIRECTORY I/O ERROR                 A
         B     NMSTE              INVALID DCB ?                  82060
         B     NMSTG         OUT OF STORAGE                      82060
*                                                                     A
GENAOK   XPRNTLIN PWA,TEXT=GAMSG,LENGTH=L'GAMSG,SPB=1                 A
         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DIRECTORY INFO     82060
         B     MAINLOOP                                               A
GAMSG    DC    C'*** ALIAS CREATED ***'                               A
         SPACE 1                                                 82060
RESTORE  CALLSUB PRESTOW,STOWNAME  SEE IF IT ALREADY EXISTS      82060
         L     R1,=A(PSTBLDL)  GET PSTFLAG ADDRESSABILITY        82060
         USING PSTBLDL,R1                                        82060
         IF    PSTFLAG,RNDUPL  'NEW NAME ALREADY EXISTS'         82060
         DROP  R1                                                82060
         MVC   NM+DCBRELAD-IHADCB(3),STOWTTR  SET DESIRED TTR    82060
         MVI   NM+DCBRELAD+3-IHADCB,0  ZERO CONCATENATION BYTE   82060
         NI    NM+DCBOFLGS-IHADCB,255-DCBOFLWR  SET READ MODE    82060
         B     CUR0STOW      USE COMMON STOW CODE                82060
*                                                                     A
*
*  CURRENT - MAKE SPECIFIED VERSION CURRENT (PRODUCTION).
*  NOTE - AS A SPECIAL OPTION, THE USER MAY HAVE PROVIDED A 'FAKE'
*  MEMBER NAME DIRECTLY (INSTEAD OF THE PRODUCTION NAME AND A VERSION
*  NUMBER), PROBABLY BECAUSE SOMEONE DELETED THE PRODUCTION ALIAS.
*  IN SUCH A CASE, A NEW PRODUCTION ALIAS IS CREATED (AND THE HIGH
*  VERSION NUMBER 'MEMVER' CAN OBVIOUSLY NOT BE RETAINED FROM THE
*  PREVIOUS PRODUCTION DIRECTORY ENTRY).
*
CURRENT  MVC   BLDLNAME,RNAME     SET NAME OF NEW CURRENT MEMBER
         MVC   WORKA(3),BLDLTTR   SAVE TTR OF OLD CURRENT MEMBER
         MVC   WORKA+3(2),MEMVER-SSSI+BLDLUD  SAVE PRODUCTION HIGH VER.
         BLDL  NM,BLDLIST         TRY TO FIND NEW CURRENT MEMBER
         BXH   R15,R15,CUR1       ERROR - COULD NOT FIND IT.     82060
         CLI   BLDLTTR+2,0
         BE    CUR1
*
         CLC   BLDLTTR,WORKA      COMPARE NEW TO OLD CURRENT'S TTR
         BE    CUR3               BRANCH IF THEY ARE EQUAL
         TM    BLDLC,8            TEST THAT HAVE BIG ENOUGH DIRECTORY
         BZ    CUR4               * ENTRY.  ELSE IS ERROR.
*
         MVC   STOWNAME,REALNAME-SSSI+BLDLUD  MOVE REAL NAME FOR STOWIN
         MVC   STOWTTR,BLDLTTR    TTR OF NEW CURRENT MEMBER
         MVC   STOWC(DRECSIZE+5),BLDLC MOVE COUNT AND USER DATA
         OI    STOWC,X'80'        SET ALIAS BIT
         IF    ¬FVERSION,CUR0     SKIP IF VERSION UNSPECIFIED (RECOVER)
         ZAP   MEMVER-SSSI+STOWUD,WORKA+3(2)  RETAIN HIGH VERSION NO.
CUR0     CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060
CUR0STOW STOW  NM,STOWLIST,R                                     82060
         CH    R15,=H'12'         TEST IF STOW OK
         BH    NMSTE              I/O ERROR
         BE    NMSTF              DIRECTORY FULL
         CALLSUB POSTSTOW                                        82060
CUR0PRNT CALLSUB POSTSTAD,STOWLIST  FORMAT NEW DATA              82060
         CLI   CMDNUM+3,VCRESTR  RESTORE ?                       82060
         BNE   MAINLOOP      NO; LEAVE DCB AS IS                 82060
         BAL   R2,NMPUNTAD   RESTORE NEW MASTER FDAD             82060
         B     MAINLOOP
*
CUR1     ERROR '*** MEMBER DOES NOT EXIST ***'                        A
CUR3     ERROR '*** MEMBER ALREADY IS CURRENT ***',RC=4
         B     MAINLOOP
CUR4     ERROR '*** MEMBER DOES NOT SUPPORT VERSION ***'
*
*
*  LIST - PRINT OUT A MEMBER FROM SYSLIB
*  NOTE THAT THE FIND HAS ALREADY BEEN ISSUED BY KEYSCAN (SCOPY-SLIST)
*
LIST     XPRSPACE  PWA,LINES=2
         L     R9,LIBADR          POINT TO SYSLIB DSECT
         LA    R3,CTLBUF          BUFFER ADDRESS FOR XPRNTSUB
         MVC   HNAME,BLDLNAME     MOVE NAME TO HEADING LINE.
*
LISTL1   GOSUB CTLREAD
         BXH   R15,R15,LISTL2     BRANCH FOR END OF FILE         82060
         CLC   FROMSEQ,CTLSQ-CTLBUF(R3)                          82067
         BH    LISTL1             CARD BELOW RANGE - IGNORE IT   82067
         RESET XFROMSEQ      NOTE WHEN START RANGE HIT           82067
         CLC   TOSEQ,CTLSQ-CTLBUF(R3)                            82067
         BL    LISTL2             CARD ABOVE RANGE - TERMINATE.  82067
         RESET XTOSEQ        NOTE WHEN END RANGE HIT             82067
         XPRNTLIN PWA,TEXT=(R3),LENGTH=80,OFFSET=20
         B     LISTL1             CONTINUE
*
LISTL2   IF    ¬XFROMSEQ.¬XTOSEQ,LISTL3   OK IF LISTED           82067
         ERROR '*** INCORRECT LIST RANGE ***',RC=4               82067
LISTL3   RESET (XFROMSEQ,XTOSEQ)                                 82067
         L     R9,SYSINADR        POINT BACK TO SYSIN DSECT      82067
         XPRSPACE PWA,LINES=1
         RESET COPYING            RELEASE SYSLIB DCB
         B     MAINLOOP
*
*
*  LOAD - CREATE A PDS FROM A SERIES OF UPDATE DECKS.
*  WARNING - CAN NOT HANDLE CONTINUED CHANGE/ADD CARDS.
*
LOAD     SET   LOADING
         LA    R3,CTLBUF          PLACE WE WILL PRINT DATA CARDS FROM
         GOSUB CTLREAD            READ CARD FROM SYSIN
         BXH   R15,R15,MAINERR    BOMB QUICK IF NOTHING TO LOAD  82060
         GOSUB CCLOOK             TEST FOR CONTROL CARD AND TYPE
         CLI   CMDNUM+3,VCCHANGE  FIRST CARD MUST BE CHANGE/ADD  82060
         BNH   LOAD0                                             82060
         ERROR '*** REQUIRES CHANGE/ADD CARD ***',RC=12
LOAD0    CLI   CMDNUM+3,VCCHANGE    ADD/CHANGE CARD ?            82060
         BH    LOADDONE           TERMINATE IF NOT CHANGE/ADD    82060
         GOSUB KEYSCAN            GET MEMBER NAME FROM CHANGE/ADD CARD
         MVC   HNAME,NAME         PUT MEMBER NAME IN PAGE TITLE
LOAD1    LR    R1,R3              POINT TO RECORD                     A
         GOSUB NMWRITE            WRITE TO SYSUT2
         GOSUB CTLREAD            READ MORE CARDS
         BXH   R15,R15,LOADSTOW   BRANCH IF EOF                  82060
         GOSUB CCLOOK             TEST FOR CONTROL CARD
         CH    R15,=H'4'
         BH    LOADSTOW           STOP COPYING IF MAJOR CONTROL RECORD
         IF    ¬LISTING,LOAD1                                         #
         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'CTLBUF,OFFSET=10
         B     LOAD1              CONTINUE COPYING
*
LOADSTOW GOSUB NMTRUNC            WRITE LAST BLOCK SHORT
*              ENSURE THAT HIGHEST VERSION FOR LOAD              80301
*              IS MAINTAINED AS CURRENT (PRODUCTION) VERSION     80301
         CLC   NAME,RNAME         USING VERSION NAME ?           80301
         BE    LOADST1             NO  - VERSION 0               80301
         SET   ALIAS               YES - FORCE EXTRA STOW        80301
         MVC   ANAME,NAME         SPECIFY PRODUCTION ALIAS       80301
         LA    R0,ANAME           TRUE NAME IS ONLY ALIAS        80301
         ST    R0,ALIASPTR                                       80301
LOADST1  GOSUB NMSTOW             STOW NEW MEMBER                80301
         IF    ¬REALEOF,LOAD0     CONTINUE WITH NEXT UPDATE DECK
         B     STOP               OR STOP (EOF)
*
LOADDONE RESET LOADING
         B     MAINSR
*
*
STOPMSG  DC    C'*** END OF JOB IEBUPDTX.  STEP RETURN CODE = '
STOPMSGA DC    CL2' '
         DC    C'.'
STOPMSGL EQU   *-STOPMSG
MAINERR  ERROR '*** SYSIN REQUIRES MAJOR FUNCTION COMMAND ***'
POSBOMB  ICM   R9,15,SYSINADR     RESET R9 FOR ERROR             80002
         BNZ   *+8                                               80002
         L     R9,LIBADR          USE SYSLIB DURING INIT.        80002
         ERROR '*** NO OLD MASTER FOUND ***'
NOCTL    ERROR '*** NO CONTROL FILE FOUND ***',RC=ABEND               A
         DROP  R6
         TITLE 'GLOBAL UPDATE OPERATION MONITOR AND LIST ROUTINE'
*  THIS ROUTINE KEEPS AN EYE ON THE PROGRESS OF THE OVERALL UPDATING
*  PROCESS IN THE GLOBAL SENSE, SO THAT WE CAN PRINT A NICE LISTING.
*  THE IEBDECK IS PRODUCED HERE.
*
LOGRTN   BGNSB LOGSAVE
         LR    R2,R0
         LA    R6,PUDATA          OUTPUT (NM-) FROM LOG = SYSPUNCH
         USING NMDSECT,R6
         B     *+4(R2)            BRANCH ACCORDING TO LOGGING FUNCTION
         B     LOGDLTE
         B     LOGNEWM
         B     LOGMEMX
*
*  LOG  STRT  --  BEGINNING A NEW MEMBER.
*  IF WE ARE PUNCHING AN 'IEB'-DECK, SHOOT OUT THE CHANGE CARD.
*
LOGSTRT  MVI   DECKFLGS,0         INITIALIZE DECK AND LISTING FLAGS
         IF    ¬DECK,LOGEXIT      LEAVE IF NOT PUNCHING A DECK
         ZAP   DINCR,=P'0'                                            A
         ZAP   DNEW1,=P'0'                                            A
         IF    ADD,SADECK         NO DECK IF SOURCE FROM ./ADD DECK
         RESET ADDDECK
         MVI   LASTOM,0           SO CAN DETECT ./I 0 TYPE THINGS
         MVC   NMREC(10),=C'./ CHANGE '                               A
         MVC   NMREC+10(70),NMREC+9                                   A
         CLI   GMEMB,C' '         TEST NAME OMITTED                   A
         BE    LOGDPS                                                 H
         MVC   NMREC+10(5),=C'NAME='                                  A
         MVC   NMREC+15(8),GMEMB
         B     LOGDPO             MEMBER NAME SPECIFIED               H
LOGDPS   IF    NMPS,LOGDPO        NAME OMITTED, OK IF SEQUENTIAL      H
         ERROR '*** SYSPUNCH DD DDNAMEPU NOT SEQUENTIAL ***',          *
               (16,DDPUNCH),RC=4                                 82060
         RESET DECK               CAN'T PRODUCE DECK                  H
         B     LOGEXIT                                                H
LOGDPO   EQU   *                                                      H
*                                                                     H
         LA    R1,NMREC                                               A
         GOSUB NMWRITE            PUNCH CHANGE CARD TO SYSPUNCH
         B     LOGEXIT
SADECK   SET   ADDDECK            SET SWITCH TO PREVENT DECK FOR MEMBER
         B     LOGEXIT
*
*  LOG  DLTE  --  KEEP TRACK OF DELETIONS
*
LOGDLTE  IF    ¬DECK,LDSKIP       SKIP IF NOT PRODUCING DECK
         CLI   OMID,C' '          ONLY SYSUT1 CARDS BEING DELETED RATE
         BNE   LDSKIP
         IF    LDLT,LD2           BRANCH IF CONTINUING A PREV. DELETE
         SET   LDLT               ESTABLISH A NEW DELETE IN PROGRESS
         BAL   R3,LOGNSUB         STOP POSSIBLE ./N                   A
         MVC   DECKD1,OMOSQ       SET SEQ1
LD2      MVC   DECKD2,OMOSQ       SET SEQ2
*
LDSKIP   IF    ¬LISTDEL,LOGEXIT   LEAVE IF NOT LISTING DELETIONS
         IF    ¬SYSIN.¬LISTLEV,LOGEXIT LEAVE IF NOT LISTING THIS LEVEL
         IF    ¬LISTING,LOGEXIT   IF ./PARM NOLISTING, WRITE NOTHING
         MVI   OMID+5,C'|'
         IF    DTP,LDSKIP2        BR. IF DELETE TITLE ALREADY PRINTED
      XPRNTLIN PWA,TEXT=DTITLE,LENGTH=DTITLEL,                   80294 *
               OFFSET=DLTOFST+NMREC-NMAREA                       80294
         SET   DTP                FLAG INDICATES DELETE TITLE PRINTED
LDSKIP2  EQU   *
         LA    R3,OMAREA
         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'OMAREA,OFFSET=DLTOFST
         B     LOGEXIT
*
*  LOG  NEWM  --  INFORM OF NEW MASTER RECORD WRITTEN
*
LOGNEWM  IF    ¬DECK,LISKIP       SKIP TO LISTING STUFF IF NO DECK
         IF    ADDDECK,LISKIP     TEST IF DECK OMITTED FOR THIS MEMBER
         CLI   NMID,C' '          TEST IF CARD FROM SYSUT1, OR INSERTED
         BE    LI1                BRANCH IF FROM SYSUT1
*  THIS IS AN INSERTED RECORD.
         IF    LINS,LI2           BRANCH IF INSERTION ALREADY GOING
         CLI   LASTOM,C' '        TEST IF EXISTS CARD TO INSERT AFTER
         BH    LOGBIX             YES - SKIP ERROR MESSAGE
         MVC   LASTOM,=8C'0'      INITIALIZE PREVIOUS O.M. SEQUENCE   A
         IF    DECKQ,LOGBIX       PARM=DECKQ => DON'T CARE            A
         ERROR '*** DECK WILL NOT RUN ON IEBUPDTE ***',RC=4
LOGBIX   MVC   DECKI1,LASTOM      SET SEQ1=(PREV. OM SOURCE NO).
         MVC   DECKI2,NMSQ        SET NEW1 IN DECK OUTPUT CARD        #
         BAL   R3,LOGNSUB         PUNCH POSSIBLE ./N CARD             A
         BAL   R3,LOGISUB         GET BEST GUESS FOR INCR             A
         MVC   DINCR,DWORK        SAVE                                A
         UNPK  DECKI3,DINCR       PLACE INCR ON CARD                  A
         OI    DECKI3+L'DECKI3-1,C'0'                                 A
         PACK  DNEW1,NMSQ         SAVE PACKED NEW1                    A
*                                                                     A
         IF    ¬SEQALL,JUSTINS                                        #
         PACK  WORKA(5),DECKI1
         AP    WORKA(5),=P'1'                                         A
         UNPK  DECKI2,WORKA(5)    SET NEW1 = SEQ1+1
         OI    DECKI2+7,C'0'
*
         IF    ¬LDLT,JUSTINS      SKIP IF NO DELETE IN PROGRESS.
*  CARD INSERTED WHILE DELETE IN PROGRESS.  USE DELETE SEQ1 = NEW1.
         MVC   DECKI2,DECKD1
JUSTINS  EQU   *
*
         LA    R1,DECKCD2                                             A
         GOSUB NMWRITE            PUNCH ./ NUMBER INSERT=YES CARD
         SET   LINS               INDICATE INSERT IN PROGRESS
         B     LI2NQ              NO ./Q FOR FIRST CARD INSERTED      A
*  INSERT IN PROGRESS.  MONITOR SEQUENCING IF PARM=DECKQ.             A
LI2      IF    ¬DECKQ,LI2NQ       SKIP IF ./Q NOT WANTED              A
         BAL   R3,LOGISUB         GET PREFERED INCR IN DWORK          A
         CP    DINCR,DWORK        SEE IF INCR CHANGING                A
         MVC   DINCR,DWORK        SAVE JUST IN CASE IT HAS            A
         BNE   LI2Q               INCR CHANGED.  NEED ./Q             A
         AP    DNEW1,DINCR        PREDICT CURRENT SEQ FROM PREV.      A
         PACK  DWORK,NMSQ         CURRENT SEQ.                        A
         CP    DWORK,DNEW1        SEE IF NEW1 CHANGED                 A
         BE    LI2NQ              NO - DON'T NEED ./Q                 A
*                                                                     A
LI2Q     PACK  DNEW1,NMSQ         CURRENT SEQUENCE NUMBER             A
         L     R1,JFCBA           PLACE TO BUILD ./Q CARD             V
         MVC   0(5,R1),=C'./ Q '                                      A
         MVC   5(75,R1),4(R1)     CLEAR CARD IMAGE AREA               A
         UNPK  6(8,R1),DINCR      PLACE INCR ON CARD                  A
         OI    13(R1),C'0'                                            A
         MVI   14(R1),C','                                            A
         MVC   15(L'NMSQ,R1),NMSQ PLACE NEW1 ON CARD                  A
         GOSUB NMWRITE            PUNCH ./Q CARD.                     A
*                                                                     A
LI2NQ    LA    R1,NMREC           ADDRESS OF CARD TO PUNCH            A
         MVC   OBWORK(L'NMSQ),NMSQ  SAVE SEQUENCE NUMBER              A
         MVC   NMSQ,BLANKS        CLEAR SEQFLD                        A
         GOSUB NMWRITE            PUNCH INSERTED CARD (WITHOUT SEQFLD)
         MVC   NMSQ,OBWORK        PUT SEQFLD BACK                     A
         B     LISKIP
*  AN OLD MASTER SOURCE CARD MADE IT THROUGH.
LI1      CLI   NMID+1,C'M'        TEST IF CARD FROM ./MACRO
         BE    NMSQMOD            YES - THEN NOT O.M., DECK IGNORES.
*  MONITOR SEQUENCING OF UNDELETED O.M. CARDS, IF PARM=DECKQ.         A
         IF    ¬DECKQ,LOGN5       TEST IF ./N CARDS WANTED IN DECK    A
         CLC   NMSQ,NMOSQ         TEST IF RENUMBERED                  A
         BE    LOGN3              NO - DON'T HAVE TO CHECK INCR       A
         IF    LNUM1,LOGN1        BRANCH IF SECOND CARD OF RENUMBERINGA
         PACK  DWORK,NMSQ         CURRENT SEQ.                        A
         AP    DNEW1,DINCR        PREDICTED SEQ.                      A
         CP    DWORK,DNEW1        SEE IF PREDICTED RIGHT              A
         BE    LOGN5              YES - NO PROBLEM.                   A
*                                                                     A
         BAL   R3,LOGNSUB         PUNCH POSSIBLE PENDING ./N          A
         SET   (LNUM1,LNUM2)      INDICATE NEW ./N                    A
         MVC   DECKN1,NMOSQ       SEQ1                                A
         MVC   DECKN3,NMSQ        NEW1                                A
         MVC   DECKN4,=C'00000001'  TEMPORARY INCR                    A
         ZAP   DNEW1,DWORK        SAVE CURRENT SEQ                    A
         B     LOGN5                                                  A
*                                                                     A
LOGN1    PACK  DINCR,NMSQ         CURRENT SEQ.                        A
         SP    DINCR,DNEW1        - PREV. SEQ = CURRENT INCR.         A
         UNPK  DECKN4,DINCR       PLACE INCR ON ./N CARD              A
         OI    DECKN4+L'DECKN4-1,C'0'                                 A
         AP    DNEW1,DINCR        CURRENT SEQ. NO.                    A
         RESET LNUM1              NOW BACK IN GENERAL MODE            A
         B     LOGN5                                                  A
*                                                                     A
LOGN3    BAL   R3,LOGNSUB         PUNCH ANY PENDING ./N CARD          A
         ZAP   DINCR,=P'0'        DESTRUCT CURRENT RENUMBERING        A
LOGN5    EQU   *                                                      A
*                                                                     A
         RESET LINS               THIS BREAKS ANY INSERT STREAM
         MVC   LASTOM,NMOSQ       KEEP LAST O.M. SEQ. NO. (FOR INSERTS)
         IF    ¬LDLT,LISKIP       TEST IF IT ALSO BROKE A DELETE
         LA    R1,DECKCD1         ADDRESS OF ./ DELETE CARD           A
         GOSUB NMWRITE
         RESET LDLT
*
*  PUT ALPHABETICS INTO SEQUENCE FIELD IF WERE THERE IN SYSUT1
*                                                                     A
LISKIP   IF    ¬IMPLSEQ+ADDDECK,LI3  SKIP FOR NORMAL SEQUENCING       A
         MVC   NMPSQ,NMSQ         FOR LISTING                         A
         MVC   NMSQ,NMOSQ         PARM=IMPLSEQ; REPLACE ORIG SEQ.     A
LI3      EQU   *                                                      A
         IF    ¬IDSEQ,NMSQMOD     SKIP IF WERE NONE                   A
         IF    REMID,NMSQMOD      BRANCH IF REMOVING OLD SEQID.
         CLI   NMID+1,C'M'        NO SEQID-ING ON MACRO CARDS
         BE    NMSQMOD
         L     R1,SEQIDLEN        LENGTH-1 OF LEADING ALPHABETICS
         EX    R1,SEQIDCHK        BE SURE NOT OVERLAYING NON-ZEROS
         BNZ   SEQIDERR
         EX    R1,SEQIDMV         MOVE THEM BACK INTO THE SEQFLD.
NMSQMOD  IF    ¬LISTING,LOGEXIT   IF ./PARM NOLISTING, WRITE NOTHING
         IF    LISTALL,LOGNMW     IF LIST=ALL, WRITE OUT EVERYTHING
         IF    ADD,LOGEXIT        SKIP LISTING THE ADDED CARDS
         CLC   CTLID(4),NMID      TEST IF ORIGINATED VIA SYSIN        #
         BE    LOGNMW             YES - LIST IT
         IF    ¬LISTRN,SKIPRN     TEST IF PRINTING RENUMBERED CARDS
         CLI   NMPSQ,C' '
         BNE   LOGNMW
SKIPRN   EQU   *
         IF    ¬LISTLEV,LOGEXIT
         CLI   NMID,C' '          TEST IF ORIGINAL O.M. CARD
         BE    LOGEXIT            YES - DON'T LIST
LOGNMW   RESET DTP                SO NEW DELETE WILL PRINT ITS TITLE
         IF    NMTP,PRINTNM       SKIP IF DON'T NEED NM TITLE LINE
      XPRNTLIN PWA,TEXT=NMTITLE,LENGTH=NMTITLEL,                 80294 *
               OFFSET=NMOFST+NMREC-NMAREA                        80294
         SET   NMTP               INDICATE NM TITLE PRINTED
PRINTNM  XPRNTLIN PWA,TEXT=NMAREA,LENGTH=L'NMAREA,OFFSET=NMOFST
         B     LOGEXIT
*
*  LOGMEMX  --  LOG END OF MEMBER UPDATE (WAITING FOR DECK STUFF)
*
LOGMEMX  IF    ¬LDLT,LOGMEM2      LEAVE UNLESS PENDING DELETE
         LA    R1,DECKCD1         ADDRESS OF ./ DELETE CARD           A
         GOSUB NMWRITE
LOGMEM2  BAL   R3,LOGNSUB         PUNCH ANY PENDING ./N               A
         IF    NMPS,LOGEXIT       LEAVE IF SYSPUNCH SEQUENTIAL        A
         IF    ¬DECK,LOGEXIT
         IF    ADDDECK,LOGEXIT    NO DECK, NO STOW
         GOSUB NMTRUNC            OTHERWISE, FINISH PARTITIONED MEMBER
         MVC   STOWNAME,GMEMB
         MVI   STOWC,0
         IF    ¬TIMES,DECKSTOW    SKIP TIME STAMPING IF NOT REQUESTED
         MVI   STOWC,4            WILL HAVE 4 HALFWORDS USER DATA
         XC    STOWUD(4),STOWUD   FIRST TWO ARE THE SSI
         MVC   STOWUD+4(4),TIMEWORD  LAST TWO ARE THE TIME STAMP
DECKSTOW CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060
         STOW  NM,STOWLIST,R                                     82060
         CH    R15,=H'8'
         BNH   DECKSTOD                                          82060
         ERROR '*** SYSPUNCH DD DDNAMEPU - STOW ERROR ***',            *
               (16,DDPUNCH),RC=ABEND                             82060
*
DECKSTOD CALLSUB POSTSTOW    PRINT OLD DATA                      82060
         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060
LOGEXIT  ENDSB LOGSAVE
*                                                                     A
*  ROUTINE GETS INCR FROM BEST LOCAL DSECT AREA TO BE USED FOR        A
*  INSERTIONS.  RESULT PACKED IN DWORK.                               A
*                                                                     A
LOGISUB  IF    INSERTX,LOGI1      STOP AT FIRST INSERT AFTERMATH      A
         CLC   NMID(4),CTLID      OR THE RESPONSIBLE INSERT LEVEL     A
         BE    LOGI2                                                  A
         L     R9,NEXTLEV         CHAIN ON DOWN                       A
         B     LOGISUB                                                A
LOGI1    ZAP   DWORK,XINCR        AFTERMATH INCR                      A
         B     LOGI3                                                  A
LOGI2    ZAP   DWORK,INCR         INSERT INCR                         A
LOGI3    L     R9,SYSINADR        RESTORE R9                          A
         BR    R3                 RETURN                              A
*                                                                     A
*  SUBROUTINE TO PUNCH ./N CARD.                                      A
*                                                                     A
LOGNSUB  IF    ¬LNUM2,0(R3)       RETURN IF NO ./N PENDING            A
         MVC   DECKN2,LASTOM      FILL IN SEQ2                        A
         LA    R1,DECKCD3         POINT TO ./N CARD                   A
         GOSUB NMWRITE            PUNCH TO THE DECK                   A
         RESET (LNUM1,LNUM2)                                          A
         BR    R3                 RETURN                              A
*                                                                     A
*
*  EQU'S FOR THE VARIOUS LOG FUNCTIONS
*
DLTE     EQU   0
NEWM     EQU   4
MEMX     EQU   8
STRT     EQU   12
DECKFLGS DS    0X
         FLAG  (LDLT,LINS,DTP,NMTP,LNUM1,LNUM2)                       A
*
         DROP  R6
*
SEQIDERR ERROR '*** SEQUENCE TRUNCATION ***'
LASTOM   DC    CL8' '             LAST OLD MASTER SEQUENCE NUMBER
         TITLE 'WRITE A NEW MASTER RECORD FROM NMREC'
*  THIS ROUTINE SETS NO RETURN CODE.
         SPACE 2
NMWRITE  BGNSB NMSAV
         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA
         IF    NOWRITE,NMWX       SKIP I/O IF NO-WRITE SET            A
         LA    R0,1                                              82060
         A     R0,NMCOUNT                                        82060
         ST    R0,NMCOUNT    SET OUTPUT RECORD COUNT             82060
         L     R3,NMCURREC        ADDRESS OF CURRENT RECORD POSITION
         IF    ¬NMWYLFMT,NMNOTWYL  CHK IF WYLBUR FLAG ON        JRE0036
         LR    R10,R1              YES, PT TO NM BUFFER         JRE0036
         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS         80294
         CALL  (15),(INTEGER,0,RNAME)                            80294
         B     NMWX                EXIT                         JRE0036
NMNOTWYL DS    0H                                               JRE0036
         TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V
         BZ    NMWF               NO - EASY FIXED LENGTH RECORD       V
*                                                                     V
*  CONSTRUCT FORMAT V RECORD (SEQFLD FIRST, NO TRAILING BLANKS).      V
*                                                                     V
         MVC   VBUF(L'NMSQ),NMSQ-NMREC(R1)  SEQUENCE FIELD FIRST      V
         MVC   VBUF+L'NMSQ(L'NMDATAF),NMDATAF-NMREC(R1) THEN DATA     V
         LA    R5,L'VBUFFER       MAXIMUM RECORD LENGTH (WITH RDW)    V
NMVLOOP  LA    R1,VBUFFER-1(R5)   -> NEXT POSSIBLE TRAILING BLANK     V
         CLI   0(R1),C' '         SEE IF IT IS ONE                    V
         BNE   NMVDONE            NO - NOW WE KNOW RECORD LENGTH      V
         BCT   R5,NMVLOOP         YES - BACK TO SCAN FURTHER BLANKS   V
*                                                                     V
NMVDONE  LA    R1,0(R5,R3)        PREDICT NEXT RECORD'S ADDRESS       V
         C     R1,NMBUFLIM        SEE IF CURRENT RECORD FITS IN BUFFERV
         BNH   NMFILLV            YES - GO MOVE IT.                   V
*                                                                     V
*  BUFFER FULL.  WRITE IT, (POSSIBLY) WAIT FOR NEXT BUFFER TO BECOME  V
*  AVAILABLE, AND PUT CURRENT RECORD IN IT.                           V
*                                                                     V
NMFULL   BAL   R10,NMPUTB         WRITE BUFFER (NOTE REGS ALTERED)    V
         USING BUFDSECT,R3                                            V
         L     R4,BUFCHAIN        ADDRESS OF NEXT BUFFER              C
         DROP  R3                                                     C
         USING BUFDSECT,R4                                            C
         ST    R4,NMBUFADR        SET POINTER TO NEW CURRENT BUFFER   C
         LA    R3,BUFDATA         START OF DATA AREA IN BUFFER        C
         AR    R2,R3              ADD TO BLKSIZE                      V
         ST    R2,NMBUFLIM        SAVE ADR END OF BUFFER + 1          V
         AH    R3,NMBDW           LEAVE ROOM FOR POSSIBLE BDW         V
*                                                                     V
         CLI   BUFSTAT,0          TEST STATUS OF BUFFER               C
         BE    NMBUFOK            NOT USED YET - SO GO FILL IT.       V
         MVI   BUFSTAT,0          RESET FLAG                          C
         CHECK BUFDECB            PREVIOUSLY USED - WAIT FOR I/O      C
         DROP  R4                                                     C
*
NMBUFOK  TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V
         BZ    NMFILLF            NO - GO MOVE FIXED LENGTH RECORD    V
*                                                                     V
*  MOVE VARYING LENGTH RECORD TO OUTPUT BUFFER.                       V
*                                                                     V
NMFILLV  STH   R5,VBUFRDW         PLUG LRECL INTO RDW                 V
         BCTR  R5,0               RECORD LENGTH - 1                   V
         EX    R5,NMMVC           MOVE DATA TO BUFFER                 V
         LA    R3,1(R5,R3)        -> SLOT FOR NEXT RECORD IN BUFFER   V
         B     NMDONE             AND LEAVE                           V
*                                                                     V
*  MOVE AN EASY FIXED LENGTH RECORD.                                  V
*                                                                     V
NMWF     LR    R5,R1              SAVE INPUT CARD POINTER             V
         C     R3,NMBUFLIM        TEST BUFFER FULL                    V
         BNL   NMFULL             YES - GO WRITE IT.                  V
*  FLOW RETURNS HERE WITH NEW BUFFER READY FOR RECORD.                V
NMFILLF  MVC   0(L'NMREC,R3),0(R5)     MOVE RECORD TO BUFFER          V
         LA    R3,L'NMREC(,R3)    ADVANCE RECORD POINTER              V
NMDONE   ST    R3,NMCURREC        SAVE RECORD POINTER                 V
NMWX     ENDSB NMSAV                                                  A
         DROP  R6
*                                                                     V
NMMVC    MVC   0(0,R3),VBUFFER    EXECUTED INSTRUCTION                V
         TITLE 'WRITE A TRUNCATED NEW MASTER BLOCK'
*  THIS ROUTINE DOES NOT SET A RETURN CODE.
         SPACE 1
         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA
NMTRUNC  BGNSB NMTSAV,EQU=NMSAV
         IF    ¬NMWYLFMT,NMTRUNCW  CHK IF WYLBUR EDIT FORMAT    JRE0036
         L     R15,=V(PRESS)      CALL WYLBUR EDIT PRESS         80294
         CALL  (15),(INTEGER,1,RNAME)                            80294
         B NMT1                    BR TO CHK I/O PENDING BUF    JRE0036
NMTRUNCW DS    0H                                               JRE0036
         BAL   R10,NMPUTB         WRITE CURRENT BUFFER                V
         USING BUFDSECT,R3                                            V
         LA    R4,BUFDATA         -> BEGINNING OF DATA AREA IN BUFFER V
         AH    R4,NMBDW           LEAVE POSSIBLE 4 BYTES FOR BDW      V
         ST    R4,NMCURREC        RESET RECORD POINTER                C
*                                                                     C
*  LOOP THROUGH BUFFER POOL TO 'CHECK' ALL PENDING I/O.               C
*                                                                     C
NMT1     OI    BUFSTAT,X'80'      FLAG THIS AS LAST BUFFER            C
NMT2     L     R3,BUFCHAIN        CHAIN TO NEXT BUFFER IN THE POOL    C
         TM    BUFSTAT,1          TEST IF I/O PENDING                 C
         BZ    NMT4               NO - SKIP THE CHECK                 C
         CHECK BUFDECB            WAIT FOR I/O TO FINISH              C
         NI    BUFSTAT,255-1      RESET I/O ACTIVE                    C
NMT4     CLI   BUFSTAT,X'80'      WAS THIS THE LAST BUFFER            C
         BNE   NMT2               NO - DO NEXT                        C
         MVI   BUFSTAT,0          YES - WE'RE FINISHED                C
         DROP  R3                                                     C
         ENDSB NMTSAV
*                                                                     V
*  SUBROUTINE DOES PHYSICAL WRITE OF CURRENT NM BUFFER.               V
*                                                                     V
*  INPUT:  R6 -> NMDSECT                                              V
*  OUTPUT: R2 =  DCB BLKSIZE                                          V
*          R3 -> BUFFER (POSSIBLY) JUST WRITTEN                       V
*                                                                     V
NMPUTB   L     R3,NMBUFADR        -> CURRENT BUFFER                   V
         USING BUFDSECT,R3                                            V
         LH    R2,DCBBLKSI-IHADCB+NM   MAXIMUM BLOCK SIZE             V
         LA    R0,BUFDATA         -> START OF DATA AREA IN BUFFER     V
         L     R1,NMCURREC        -> NEXT RECORD ADDRESS IN BUFFER    V
         SR    R1,R0              NUMBER OF DATA BYTES IN BUFFER      V
         TM    DCBRECFM-IHADCB+NM,DCBRECV   TEST RECFM=V         80002V
         BZ    NMPUTBNV           NO                             82060
         STH   R1,BUFDATA         YES - SET BLOCK LENGTH IN BDW       V
         STCM  R1,12,BUFDATA+2   ZERO REST OF BDW                82060
NMPUTBNV CH    R1,NMBDW           TEST BUFFER EMPTY (0 F; 4 V)   82060
         BER   R10                YES - RETURN WITHOUT ANY I/O.  80002V
*                                                                     V
         MVI   BUFSTAT,1          INDICATE I/O ACTIVE THIS BUFFER     V
         STH   R1,DCBBLKSI-IHADCB+NM   SET PHYSICAL BLOCK LENGTH      V
         WRITE BUFDECB,SF,NM,BUFDATA,MF=E   START THE WRITE           V
         STH   R2,DCBBLKSI-IHADCB+NM   RESTORE DCB BLKSIZE            V
         BR    R10                RETURN                              V
*                                                                     V
         DROP  R3,R6                                                  V
         TITLE 'OPEN NEW MASTER DATA SET'
*  NOTE - REGISTER R6 IS ASSUMED BY ALL OF THE NM- ROUTINES (NMOPEN,
*  NMCLOSE, NMWRITE, NMTRUNC, NMSTOW) TO BE LOADED WITH THE ADDRESS OF
*  EITHER SYSUT2'S OR SYSPUNCH'S WORK AREA (TO CONTAIN BUFFER POINTERS,
*  FLAGS, THE DCB, AND THE DECB).
*  ALSO NOTE THAT NMREC IS SHARED BY BOTH FILES.
*  THIS ROUTINE SETS RETURN CODE 4 IF REQUIRED DD CARD MISSING.
         SPACE 2
         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA
NMOPEN   BGNSB NMSAVE,EQU=NMSAV
         LA    R4,NM              NEW MASTER DCB ADDRESS
         USING IHADCB,R4
         L     R5,JFCBA           ADDRESS OF JFCB IN STORAGE          V
         USING JFCBD,R5
         RESET NMPS                                                   C
         LR    R2,R4         COPY DCB ADDRESS FOR OPEN CHECK     82060
         MVC   OBWORK(8),DCBDDNAM
         MVC   CMOIO,=C'OUT'   PRESET FOR OUTPUT DATASET         82060
         CALLSUB COMOPEN     PERFORM PRE-OPEN CHECKS             82060
         B     *+4(R15)      BRANCH ON RETURN CODE               82060
         B     NMISPO        PARTITIONED; NO MEMBER SPECIFIED    82060
         B     NMISPS        PARTITIONED; MEMBER SPECIFIED       82060
         B     NMISPS        SEQUENTIAL                          82060
         B     NMOPENX       DD CARD NOT SUPPLIED                82060
         SPACE 1                                                 82060
*  NEW MASTER IS SEQUENTIAL
NMISPS   SET   NMPS
*
NMISPO   OPEN  ((R4),(OUTPUT)),TYPE=J
         TM    DCBOFLGS,DCBOFOPN  TEST FOR SUCCESSFUL OPEN       80002
         BO    NMOPENED
*
OBERROR2 ERROR '*** COULD NOT OPEN DDNAMENM ***',(19,CMODDN),RC=ABEND
*
*
*  SET UP BUFFERS AND BUFFER POINTERS FOR NEW MASTER
*
NMOPENED BAL   R10,BUFGET         CALL TO PREPARE SIZE FOR GETMAIN    C
         ST    R0,NMBPL           SAVE LENGTH AND SUBPOOL FOR FREEMAINC
         GETMAIN R,LV=(0)         GET STORAGE FOR BUFFER POOL         C
         ST    R1,NMBPA           SAVE ADDRESS FOR FREEMAIN           C
         ST    R1,NMBUFADR        SET CURRENT BUFFER ADDRESS          C
         USING BUFDSECT,R1                                            C
         LA    R0,BUFDATA                                             C
         XR    R15,R15            ASSUME RECFM=F (NO BDW)             V
         TM    DCBRECFM,DCBRECU    RECFM=U?                     JRE0036
         BO    NMOPENRU            BRANCH IF YES, MAYBE WYLBUR  JRE0036
         TM    DCBRECFM,DCBRECV   TEST RECFM=V                   80002V
         BZ    *+8                NO                                  V
         LA    R15,4              YES - 4 BYTE BLOCK DESCRIPTOR WORD  V
NMOPENRU DS    0H                                               JRE0036
         STH   R15,NMBDW          SAVE SPACE TO RESERVE FOR BDW       V
         AR    R15,R0             COMPUTE ADR FIRST RECORD IN BUFFER  V
         ST    R15,NMCURREC       SAVE IT                             V
         AH    R0,DCBBLKSI        END OF BUFFER + 1                   V
         ST    R0,NMBUFLIM        SAVE AS BUFFER LIMIT                V
         BAL   R10,BUFINIT        GO PREPARE BUFFER POOL              C
         BAL   R10,MEMPUT         PUT POSSIBLE MEMBER NAME IN MESSAGE
         XPRNTLIN PWA,TEXT=CMOMSG,LENGTH=CMOMSGL                 82060
         MVC   FDAD,DCBFDAD       SET DISK ADDRESS JUST IN CASE
         MVC   NMRELAD,DCBRELAD   SAVE MEMBER TTR                82060
         MVC   TRBAL,DCBTRBAL     * THIS A ./PARM WITH ERROR COMING
         XR    R15,R15            SUCCESSFUL RETURN CODE
NMOPENX  ENDSB NMSAVE
*
*
NMCLOSE  BGNSB NMCSV,EQU=NMSAV
         LA    R4,NM              DCB ADDRESS
         LM    R0,R1,NMBPL        GET LENGTH, SP, ADDRESS OF BUFFERS  C
         FREEMAIN R,LV=(0),A=(1)  RETURN BUFFER STORAGE
         CLOSE ((R4))
         ENDSB NMCSV
*                                                                     C
*                                                                     C
*  SUBROUTINE TO INITIALIZE A BUFFER POOL                             C
*  ENTER WITH R1->FIRST BUFFER, R2=BUFL, R3=BUFNO, R10=RETURN         C
*                                                                     C
BUFINIT  LR    R15,R1             SAVE ADR FIRST BUFFER               C
NMBINIT  LA    R0,0(R2,R1)        ADDRESS OF NEXT BUFFER              C
         ST    R0,BUFCHAIN        SET IN CHAIN ADDRESS OF CURRENT BUF C
         MVC   BUFDECB(DECBLEN),MDECB  INITIALIZE DECB FROM MODEL     C
         AR    R1,R2              ADVANCE POINTER                     C
         BCT   R3,NMBINIT         CONTINUE                            C
         SR    R1,R2              BACK OFF TO LAST BUFFER             C
         ST    R15,BUFCHAIN       CHAIN IT TO FIRST BUFFER            C
         BR    R10                RETURN                              C
         DROP  R1                                                     C
*                                                                     C
*                                                                     C
*  SUBROUTINE TO COMPUTE SIZE OF BUFFER POOL REQUIRED THIS DCB        C
*  ENTER WITH R4->DCB, R10=RETURN                                     C
*  EXITS WITH R0=LENGTH(AND SP), R2=LENGTH, R3=BUFNO                  C
*                                                                     C
BUFGET   XR    R1,R1                                                  C
         IC    R1,DCBBUFNO        GET NUMBER OF BUFFERS REQUIRED      C
         LA    R0,BUFLEN+3        BUFFER SIZE (+3 FOR ROUNDING)       V
         AH    R0,DCBBLKSI        ADD BLKSIZE                         C
         N     R0,=X'FFFFFFFC'    FORCE BUFL DIV. BY 4                V
         LR    R2,R0              SAVE BUFL                           C
         LR    R3,R1              SAVE BUFNO                          C
         MR    R0,R0              GET BUFFER POOL SIZE                C
         LR    R0,R1              PUT IN R0 FOR GETMAIN               C
         ICM   R0,8,=X'01'   SET SUBPOOL=1 FOR GETMAIN           82060
         BR    R10                RETURN                              C
*                                                                     C
         DROP  R4,R5,R6
         TITLE 'PRINT ERROR MESSAGE ROUTINE'
*  THE ERROR MESSAGE WRITER IS CALLED VIA THE 'ERROR' MACRO.
*  ON ENTRY TO THIS ROUTINE, R1 POINTS TO A HALFWORD CONTAINING THE
*  OFFSET IN THE IEBUPDTZ CSECT TO THE ERROR MESSAGE STRING.     82060
*  (R1)+2 IS THE RETURN ADDRESS TO BE USED FOR WARNINGS (RC=4).
*  THE MESSAGE TEXT ITSELF IS PRECEDED BY THE LENGTH AND RETURN
*  CODE FOR THE MESSAGE.
*
ERROR    STM   R0,R15,ERSAVE  SAVE ALL REGISTERS FOR S-CON       82060
         LH    R1,0(,R1)          GET OFFSET TO ERROR MESSAGE STRING
         A     R1,=V(IEBUPDTZ)    BASE OF ERRORS DATA AREA       82060
         XR    R2,R2
         IC    R2,0(,R1)          PICK UP LENGTH OF MESSAGE
         LA    R3,2(,R1)          AND ADDRESS OF TEXT
         LR    R4,R3         ADDRESS OF TEXT LESS PREFIX         82060
         TM    1(R1),1       SKIP ID ?                           82060
         BNZ   ERRNID        YES                                 82060
         MVC   0(L'CTLID,R3),CTLID     PUT LEVEL NO. IN MESSAGE
         LA    R4,6(,R3)     SET INSERTIONS AFTER LEVEL          82060
ERRNID   XR    R6,R6                                             82060
         IC    R6,1(,R1)     GET FILL COUNT                      82060
         SRA   R6,4          ISOLATE NUMBER OF FILLS             82060
         BZ    ERRNFILL      NONE                                82060
         LR    R0,R4         SAVE MESSAGE TEXT ADDRESS           82060
         LA    R4,0(R2,R3)   POINT AFTER TEXT                    82060
ERRYFILL XR    R15,R15                                           82060
         ICM   R15,1,1(R4)   GET LENGTH OF INSERTION             82060
         BZ    ERRYFILB      BUMP IF ZERO                        82060
         BCTR  R15,0         EXECUTE LENGTH FOR MOVE             82060
         XR    R14,R14                                           82060
         ICM   R14,3,2(R4)   GET S-CONSTANT FOR SOURCE TEXT      82060
         LR    R5,R14        COPY                                82060
         SRA   R5,12         ISOLATE REGISTER NUMBER             82060
         BZ    ERRYFIL0      REGISTER 0; TREAT AS ZERO           82060
         SLL   R5,2          *4 FOR OFFSET                       82060
         L     R5,ERSAVE(R5)  GET CALLER'S VALUE                 82060
ERRYFIL0 N     R14,=X'00000FFF'  ISOLATE OFFSET                  82060
         ALR   R5,R14        MAKE SOURCE TEXT ADDRESS            82060
         XR    R14,R14                                           82060
         IC    R14,0(,R4)    GET OFFSET                          82060
         AR    R14,R0        GET OUTPUT ADDRESS                  82060
         EX    R15,ERFILMVC  MOVE OVERLAY TEXT                   82060
ERRYFILB LA    R4,4(,R4)     POINT TO NEXT FILL WORD             82060
         BCT   R6,ERRYFILL   PROCESS IT                          82060
ERRNFILL IC    R4,1(,R1)     LOAD RETURN CODE AND FLAGS          82060
         XPRNTLIN PWA,TEXT=(R3),LENGTH=(R2) PRINT ERROR MESSAGE
*
         LA    R15,X'0E'     MAKE RETURN CODE MASK               82060
         NR    R4,R15        MASK IT                             82060
         BZ    ERRZERO            ZERO - NOT AN ERROR            82060
         CH    R4,=Y(ABEND)  ABEND CODE ?                        82060
         BE    ERBOMB        YES; QUIT                           82060
*
*  IF SYSUBEND DD CARD IS PRESENT, TAKE A SNAP FOR EACH ERROR MESSAGE
*  (EXCEPT THOSE WHICH ARE ON THEIR WAY TO ERBOMB).
*
         TM    DCBOFLGS-IHADCB+SNAPDCB,DCBOFOPN                  80002
         BZ    NOSNAP
         ST    R4,WORKA                                               #
         LM    R0,R15,ERSAVE                                     82060
         SNAP  DCB=SNAPDCB,SDATA=CB,PDATA=(PSW,REGS,SAH,SPLS)
         L     R4,WORKA                                               #
NOSNAP   EQU   *
*
         C     R4,STEPRC          SET STEP RETURN CODE TO THE
         BNH   *+8                * MAXIMUM OF THE PREVIOUS STEP
         ST    R4,STEPRC          * RETURN CODE AND THE CURRENT ONE.
         IF    LOADING,ENDJOBL    NO RECOVERY POSSIBLE DURING ./LOAD
         CH    R4,COND            TEST IF USER WANTS US TO STOP RUN
         BH    ENDJOB
         CH    R4,=H'8'
         BNL   RESTART            CURRENT RC TOO HIGH, TERMINATE MEMBER
ERRZERO  LM    R0,R15,ERSAVE      RC=4  RETURN TO CALLER         82060
         B     2(,R1)
ERFILMVC MVC   0(0,R14),0(R5)  MOVE FILL TEXT TO MESSAGE         82060
*
*
*  CALLER REQUESTS ABEND
*
ERBOMB   XPRCLOSE PWA             SQUEEZE OUT SYSPRINT
         LM    R0,R15,ERSAVE                                     82060
         ABEND 1,DUMP              AND GIVE IT TO HIM.
*
*  ERROR OF SEVERITY 8 OR ABOVE REQUIRES RESTART WITH NEXT SYSIN FUNCT.
*  ALSO REQUIRES CLEAN-UP FOR PARTITIONED OUTPUT FILE(S).
*
RESTART  IF    POSING,PSFLOOP     BIG JUMP BACK TO POSITION ROUTINE
         IF    FLUSHING,EPLP      SKIP RESTART MESSAGE IF ALREADY GIVEA
         RESET COPYING
         ICM   R0,15,SYSINADR   ENTERED DURING SETUP ?           82060
         BZ    ERSKPMSG      YES; SKIP MESSAGE                   82060
         IF    CTLEOF+NOWRITE,ERSKPMSG                                A
         XPRNTLIN PWA,TEXT=ERMSG1,LENGTH=L'ERMSG1,SPA=2
ERSKPMSG EQU   *
         IF    ¬DECK,SRDECK       SKIP IF SYSPUNCH NOT BEING USED
         LA    R6,PUDATA          POINT TO SYSPUNCH INFO.
         BAL   R10,NMPUNT         GO CLEAN UP I/O ON SYSPUNCH
SRDECK   EQU   *
         IF    ¬UT2AVAIL,SRNM     SKIP IF SYSUT2 NOT BEING USED       H
         LA    R6,NMDATA          POINT TO SYSUT2 INFO
         BAL   R10,NMPUNT         GO CLEAN UP I/O ON SYSUT2
SRNM     EQU   *                                                      H
*                                                                     A
*  TEST FOR SPECIAL EXIT SET                                          A
*                                                                     A
         ICM   R1,15,EREXIT       GET EXIT ADDRESS OR ZERO       82060
         BZ    NOERX              ZERO => NO EXIT REQUIRED            A
         LM    R2,R15,ERSAVE+8   NOTE - IF BRANCH IS NOT TO SAME 82060
*                                 ROUTINE AS ERROR, REGS WRONG.       A
         SETEXIT 0                                                    A
         SET   NOWRITE            CANCEL ALL OUTPUT                   A
         BR    R1                 BRANCH TO EXIT (NO RETURN EXPECTED) A
NOERX    EQU   *                                                      A
*                                                                     A
         SET   FLUSHING           INDICATE FLUSHING THIS MEMBER       A
EPLP     ICM   R9,15,SYSINADR  GET SYSIN                         82060
         BZ    ENDJOB        OR OUT                              82060
         XC    CMDFLGS,CMDFLGS    RESET FLAGS (ESP. GANG, NOINSERT)   A
         IF    REALEOF,ENDJOB
         IF    CTLEOF,ERSDONE     ALREADY AT MAJOR CONTROL CARD.
*
EPLOOP   GOSUB CTLREAD,BXH=ENDJOB   FLUSH TO NEXT MAJOR FUNCTION 82060
         GOSUB CCLOOK
         CH    R15,=H'4'
         BNH   EPLOOP
*
ERSDONE  B     MAINL              LEAP BACK INTO CONTROL ROUTINE
*
*  RETURN CODE FOR THE ERROR WAS GREATER THAN 8.  TERMINATE RUN.
*
ENDJOBL  MVI   STEPRC+L'STEPRC-1,12    RC=12 FOR ANY ERROR ON ./LOAD
ENDJOB   IF    XPARMS,ERBOMB      MUST PUNT IF LEVEL 12 EXEC PARM  SMP1
         LA    R6,NMDATA     MAIN ROUTINE EXPECTS R6 -> SYSUT2   82060
         ICM   R9,15,SYSINADR  GET SYSIN POINTER                 82060
         BZ    MAINLOOP      OR OUT                              82060
         SET   REALEOF            SO MAIN ROUTINE WILL STOP
         B     MAINLOOP
*
ERMSG1   DC    C'*** IEBUPDTX WILL SKIP TO NEXT SYSIN FUNCTION ***'
ERSAVE   DC    16F'0'                                            82060
         SPACE 3
*  NMPUNT - CLEAN UP I/O ON (PARTITIONED) SYSUT2/SYSPUNCH FILES SINCE
*  MEMBER UPDATE WAS INTERRUPTED.
*  R2 ALTERED
*
         USING NMDSECT,R6
NMPUNT   LR    R2,R10             SAVE RETURN ADDRESS
         L     R1,NMBUFADR        CURRENT BUFFER ADDRESS              C
         USING BUFDSECT,R1                                            C
         LA    R1,BUFDATA         ADDRESS OF FIRST RECORD             C
         AH    R1,NMBDW           SKIP POSSIBLE 4 BYTE BDW            V
         ST    R1,NMCURREC        SET BUFFER EMPTY TO SAVE I/O        C
         IF    NMPS,NMNOF         DON'T FOOL WITH SEQUENTIAL FILE
         GOSUB NMTRUNC            TERMINATE OUTPUT ACTIVITY ON THE FILE
NMPUNTAD LA    R1,NM              DCB ADDRESS                    82060
         USING IHADCB,R1
         MVC   DCBFDAD,FDAD
         MVC   DCBRELAD(L'NMRELAD),NMRELAD  RESTORE MEMBER TTR   82060
         MVC   DCBTRBAL,TRBAL
NMNOF    BR    R2                 RETURN
         DROP  R1,R6
         TITLE 'OPEN A CONTROL DATA SET'
*  THIS ROUTINE SETS NO RETURN CODES.
*
CTLOPEN  BGNSB CTLSV
         LA    R2,LEVDCB
         USING IHADCB,R2          DCB SYMBOLIC ADDRESSING
         L     R5,JFCBA           ADDRESS OF JFCB IN STORAGE          V
         USING JFCBD,R5
         MVC   DCBDDNAM,LEVNAME
         RESET CTLPS                                                  C
*
         MVC   OBWORK(8),LEVNAME
         MVC   CMOIO,=C' IN'   PRESET FOR INPUT DATASET          82060
         CALLSUB COMOPEN     PERFORM PRE-OPEN CHECKS             82060
         B     *+4(R15)      BRANCH ON RETURN CODE               82060
         B     CTLISPO       PARTITIONED; NO MEMBER NAME         82060
         B     CTLISPS       PARTITIONED; WITH MEMBER NAME       82060
         B     CTLISPS       SEQUENTIAL                          82060
*        B     *+4           NO DD (DEVTYPE FAILED)              82060
*
*  ERROR - REQUIRED DD NOT FOUND                                 82060
*
         ERROR '*** DDNAMEIN INPUT UNDEFINED OR INVALID ***',          *
               (4,LEVNAME),RC=ABEND                              82060
         SPACE 1                                                 82060
CTLISPS  SET   CTLPS
*
CTLISPO  OPEN  ((R2),INPUT),TYPE=J
         TM    DCBOFLGS,DCBOFOPN                                 80002
         BO    CTLOK
*
CTLNODD  ERROR '*** DDNAMEIN - UNABLE TO OPEN DATA SET ***',           *
               (4,LEVNAME),RC=ABEND                              82060
*
*  SET UP BUFFERS AND POINTERS FOR THIS LEVEL
*
CTLOK    LR    R4,R2              DCB ADDRESS FOR SUBROUTINE          C
         BAL   R10,BUFGET         GET SIZE OF BUFFER POOL             C
         ST    R0,CTLBPL          SAVE FOR FREEMAIN                   C
         GETMAIN R,LV=(0)
         ST    R1,CTLBPA          SAVE FOR FREEMAIN                   C
         ST    R1,BUFADR          SAVE CURRENT BUFFER ADDRESS         C
         BAL   R10,BUFINIT        INITIALIZE BUFFER POOL              C
         SET   BUFEMPTY           INDICATE BUFFER HUNGRY
         BAL   R10,MEMPUT         PUT POSSIBLE MEMBER NAME IN MESSAGE
*
*  SET UP LEVEL ID NUMBER FOR THIS FILE, AND PUT IN OPEN MESSAGE
*
         IF    SYSUT1+SYSLIB,CTLOPRT   DOESN'T APPLY TO THESE FILES
         AP    LEVCTR,=P'1'
         UNPK  CMOLVL+1(2),LEVCTR                                82060
         OI    CMOLVL+2,C'0'                                     82060
         MVI   CMOLVL,C'<'                                       82060
         MVI   CMOLVL+3,C'>'                                     82060
         MVC   CTLID(4),CMOLVL    ALSO PUT IN RELEVANT DSECT     82060
CTLOPRT  EQU   *
*
         XPRNTLIN PWA,TEXT=CMOMSG,LENGTH=CMOMSGL                 82060
*
*  CHECK FOR CONCATENATIONS WITH THIS DATA SET, SO CAN PRINT MORE
*  DSNAMES.
*  THE JFCB'S OF CONCATENATIONS ARE READ BY THE FOLLOWING TRICK:
*  AFTER THE DCB IS OPEN, RDJFCB MUST USE THE OFFSET (FROM THE
*  ORIGIN OF THE TIOT) WHICH REPLACES THE DDNAME FIELD IN THE DCB.
*  THIS VALUE IS EASILY MODIFIED TO SELECT ANY DESIRED TIOT DD ENTRY.
*
*
*  JUST SO NOBODY FORGETS, HERE ARE THE REGISTERS:
*
*        R2    DCB ADDRESS
*        R3    POINTER TO DD ENTRY IN TIOT
*        R4    OFFSET FROM TIOT TO THE TIOT DD ENTRY
*        R5    POINTER TO THE JFCB
*        R6    SAVES DCBTIOT FOR LATER RESTORING
*
         LA    R2,LEVDCB          R2 -> DCB AGAIN
         LH    R4,DCBTIOT         OFFSET IN TIOT
         L     R3,TIOTLOC
         AR    R3,R4              POINTER IN TIOT
         LR    R6,R4              SAVE DCB'S ORIGINAL VALUE
         USING TIOENTRY,R3
*
CATLIST  XR    R1,R1              WORK REG.
         IC    R1,TIOELNGH        LENGTH OF THIS DD ENTRY
         AR    R4,R1              OFFSET FOR NEXT DD ENTRY
         AR    R3,R1              * CORRESPONDING POINTER
         CLI   TIOELNGH,0
         BZ    CTLCLEND           STOP IF END OF TIOT
         CLI   TIOEDDNM,C' '
         BNE   CTLCLEND           STOP IF NO (MORE) CONCATENATIONS
         STH   R4,DCBTIOT         ** THE BIG FUDGE **
         RDJFCB  ((R2))
         MVC   CMODSN,JFCBDSNM   PUT DSNAME IN MESSAGE AREA      82060
         BAL   R10,MEMPUT
         XPRNTLIN PWA,TEXT=CMODSNC,LENGTH=CMOMSGL-(CMODSNC-CMOMSG),    *
               OFFSET=CMODSNC-CMOMSG+4                           82060
         B     CATLIST            GO TRY FOR MORE CONCATENATIONS.
         DROP  R3
*
CTLCLEND STH   R6,DCBTIOT         PUT DCB BACK LIKE WE FOUND IT.
         ENDSB CTLSV
         SPACE 3
*  IF DATA SET IS PDS MEMBER, SAY SO IN OPEN MESSAGE.
*  IF AVAILABLE, TACK ON THE VOLSER                              82060
*
MEMPUT   MVC   CMOBLK(CMOBLKL),BLANKS  CLEAR MEMBER AND VOLSER   82060
         LA    R1,CMODSN+L'CMODSN-1                              82060
         LA    R0,L'CMODSN                                       82060
MEMPUTL  CLI   0(R1),C' '    TRAILING BLANK ?                    82060
         BNE   MEMPUTB       NO; START ADDING                    82060
         BCTR  R1,0          BACKSPACE                           82060
         BCT   R0,MEMPUTL                                        82060
MEMPUTB  TM    JFCBIND1,JFCPDS                                   82060
         BZ    MEMPUTV       IF NO MEMBER, CHECK FOR VOLUME      82060
         MVI   1(R1),C'('    MAKE MEMBER NAME START              82060
         MVC   2(8,R1),JFCBELNM   ADD MEMBER NAME                82060
         LA    R1,9(,R1)     SPACE TO LAST BYTE OF MEMBER NAME   82060
         LA    R0,7          MAX TO CHECK                        82060
MEMPUTM  CLI   0(R1),C' '    TRAILING BLANK ?                    82060
         BNE   MEMPUTP       NO                                  82060
         BCTR  R1,0                                              82060
         BCT   R0,MEMPUTM    BACKSPACE                           82060
MEMPUTP  MVI   1(R1),C')'    MAKE ENDING PARENTHESIS             82060
         LA    R1,1(,R1)     MAKE ROOM FOR VOLUME                82060
MEMPUTV  CLI   JFCBVOLS,C'9'   SCRATCH VOLSER ?                  82060
         BHR   R10           YES; RETURN                         82060
         CLI   JFCBVOLS,C'$'   NON-ALPHA ?                       82060
         BLR   R10           YES; QUIT                           82060
         MVC   2(2,R1),=C'ON'                                    82060
         MVC   5(6,R1),JFCBVOLS  SHOW FIRST VOLSER               82060
         BR    R10                RETURN
         SPACE 3
CTLCLOSE BGNSB CTLCSV,EQU=CTLSV
         TM    DCBOFLGS-IHADCB+LEVDCB,DCBOFOPN TEST DCB OPEN     80301
         BZ    CTLCX              NO - CAN'T CLOSE THEN             SMP
         BAL   R10,BUFCLN         WAIT ANY PENDING I/O                A
         LM    R0,R1,CTLBPL                                           C
         FREEMAIN R,LV=(0),A=(1)  RETURN BUFFER STORAGE
         IF    TEMPUPD,CTLCX      NO DCB TO CLOSE IF TEMP. LEVEL
         LA    R2,LEVDCB
         CLOSE ((R2))
CTLCX    ENDSB CTLCSV
         SPACE 1                                                 82060
CMOMSG   DC    C'*** DDNAME='                                    82060
CMODDN   DC    CL8' ',CL3' '                                     82060
CMOLVL   DC    C'<00>',C' OPEN FOR '                             82060
CMOIO    DC    CL3'OUT',C'PUT, DSORG='                           82060
CMODSO   DC    C'PO',C', '                                       82060
CMODSNC  DC    C'DSNAME='                                        82060
CMODSN   DC    CL44' '                                           82060
CMOBLK   EQU   *             START OF PRE-BLANKED AREA           82060
         DC    C'(',CL8'MEMBER',C')'                             82060
         DC    C' ON ',CL6'VOLSER'                               82060
CMOBLKL  EQU   *-CMOBLK                                          82060
CMOMSGL  EQU   *-CMOMSG                                          82060
         DROP  R2,R5
         TITLE 'READ A RECORD FROM A CONTROL FILE TO CTLBUF'
*  ROUTINE SETS RETURN CODE OF 4 ON END OF FILE.
*
*  THIS ROUTINE IS CAPABLE OF SINGLE OR DOUBLE BUFFERED OPERATION FOR
*  THE INPUT CONTROL FILE POINTED TO BY R9 (LOCAL DSECT).
*  THIS CODE REPLACES THE SINGLE BUFFERED INPUT ROUTINE CTLREAD, AND
*  ALSO IMPLIES CHANGES IN CTLOPEN, CTLCLOSE, LOCAL, AND LCLINIT.
*
CTLREAD  BGNSB CTLSAVE,EQU=CTLSV
         IF    REALEOF,CTLEOD     IF PREVIOUS EOF, GET OUT QUICK.
         MVC   CTLWYL(8),BLANKS   CLEAR POSSIBLE WYLBUR SEQUENCE 82067
         IF    BUFEMPTY,CTLREAD1  PERFORM INITIAL READ FOR FIRST CALL
*
         L     R3,CURREC          ADDRESS OF CURRENT RECORD
         C     R3,MAXREC          TEST IF STILL VALID
         BNL   CTLREAD2           NO - GO START ANOTHER READ.
         IF    ¬WYLFORMT,CTLMVNWY  CHK IF WYLBUR EDIT FORMAT    JRE0036
         L     R15,=V(UNPRESS)    YES, CALL WYLBUR EDIT UNPRESS  80294
         CALL  (15),(INTEGER)                                    80294
         B     CTLRDX0             RETURN                       JRE0036
CTLMVNWY DS    0H                                               JRE0036
         TM    DCBRECFM-IHADCB+LEVDCB,DCBRECV    TEST RECFM=V    80002V
         BZ    CTLMF              NO - JUST MOVE FIXED LENGTH RECORD  V
*                                                                     V
*  DEBLOCK AND RE-ARRANGE FORMAT V RECORDS (SEQFLD IS FIRST).         V
*                                                                     V
CTLMV    MVI   VBUF,C' '          CLEAR AREA TO RECEIVE RECORD        V
         MVC   VBUF+1(L'VBUF-1),VBUF                                  V
         MVC   VBUFRDW,0(R3)      RECORD LENGTH + 4 FROM RDW          V
         LH    R4,VBUFRDW         * INTO R4 VIA ALIGNED FIELD.        V
         CH    R4,DCBLRECL-IHADCB+LEVDCB    BE SURE WILL FIT MY BUFFERV
         BH    CTLBADV            NO - QUITTING TIME.                 V
         BCTR  R4,0               RECORD LENGTH-1 FOR MVC             V
         EX    R4,CTLMVC          MOVE THE RECORD                     V
         LA    R3,1(R4,R3)        POINT TO NEXT RECORD FOR NEXT TIME  V
*                                                                     V
         MVC   CTLDATA,VBUF+L'CTLSQ    COPY DATA FIELD                V
         MVC   CTLSQ,VBUF         COPY SEQUENCE FIELD                 V
         B     CTLRNEXT                                               V
*                                                                     V
*  SIMPLE MOVE FOR FIXED LENGTH RECORD.                               V
*                                                                     V
CTLMF    MVC   CTLBUF,0(R3)       MOVE THE RECORD                     V
         LA    R3,80(,R3)         AND POINT TO NEXT RECORD            V
CTLRNEXT ST    R3,CURREC          SAVE IT                        82060
CTLRDX0  MVI   CTLID+4,C' '       CLEAR GANG OVERLAY INDICATION  82060
         IF    ¬WYLRUN,CTLNWRUN   NOT WYLBUR RUN COMMAND         82060
         CLI   CTLBUF+76,C'.'   EDIT FORMAT NUMBERING ?          82060
         BNE   CTLNWRUN      DEFINITELY NOT                      82060
         CLI   CTLBUF+75,C'0'   MAYBE ?                          82060
         BL    CTLNWRUN      DEFINITELY NOT                      82060
         MVC   CTLWYL,CTLSQ  MOVE TO WYLBUR NUMBER FIELD         82060
         MVC   CTLSQ,BLANKS  CLEAR SEQUENCE                      82060
CTLNWRUN XR    R15,R15            SET ZERO RETURN CODE           82060
CTLRDX   ENDSB CTLSAVE            RETURN
*
*  INITIAL READ (START UP READING OF NEW MEMBER).
*
CTLREAD1 RESET BUFEMPTY
         IF    CHAINED,CTLREAD2   CHAINED UPDATE LIB SINGLE BUFFERED  C
         L     R3,BUFADR          BUFFER POOL POINTER                 C
         USING BUFDSECT,R3                                            C
CTLRD1   READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036
         MVI   BUFSTAT,1          SET I/O PENDING IN THIS BUFFER      C
         L     R3,BUFCHAIN        ON TO NEXT BUFFER                   C
         CLI   BUFSTAT,0          TEST BUFFER AVAILABLE               C
         BE    CTLRD1             YES - START FILLING IT TOO          C
         B     CTLRD2                                                 C
*
*  NORMAL INPUT PROCESSING - START NEXT READ, CHECK CURRENT ONE.      C
*
CTLREAD2 L     R3,BUFADR          BUFFER POINTER                      C
         IF    CHAINED,CHAINRD    SPECIAL READ FOR CHAINED UPDATE
         READ  BUFDECB,SF,LEVDCB,BUFDATA,'S',MF=E               JRE0036
         MVI   BUFSTAT,1          SHOW I/O ACTIVE                     C
         L     R3,BUFCHAIN                                            C
         ST    R3,BUFADR          SET NEW CURRENT BUFFER POINTER      C
CTLRD2   MVI   BUFSTAT,0          SHOW I/O COMPLETED                  C
         CHECK BUFDECB                                                C
CHAINRD1 EQU   *                  MERGE BACK FROM SPECIAL READ
         IF    WYLFORMT,WYLREAD    CHK IF WYLBUR EDIT FORMAT    JRE0036
         L     R1,BUFDECB+16      IOB POINTER                         C
         LH    R5,14(,R1)         GET I/O RESIDUAL COUNT.
         LH    R1,DCBBLKSI-IHADCB+LEVDCB    MAXIMUM BLOCK SIZE        C
         SR    R1,R5              NUMBER OF BYTES IN CURRENT BLOCK.
         LA    R3,BUFDATA         ADDRESS FIRST RECORD IN BUFFER      C
         TM    DCBRECFM-IHADCB+LEVDCB,DCBRECV    TEST RECFM=V    80002V
         BNZ   CTLV               YES - HANDLE DIFFERENTLY            V
         AR    R1,R3              FIRST INVALID RECORD ADDRESS
         ST    R1,MAXREC          SAVE IT
         B     CTLMF              GO MOVE FIXED LENGTH RECORD         V
*                                                                     V
CTLV     CH    R1,0(,R3)          VALIDATE BLOCK DESCRIPTOR WORD      V
         BL    CTLBADV            MUST NOT SAY BLOCK LONGER THAN IS   V
         LH    R1,0(,R3)          NUMBER OF GOOD BYTES IN BLOCK       V
         AR    R1,R3              FIRST INVALID RECORD ADDRESS        V
         ST    R1,MAXREC          SAVE IT                             V
         DROP  R3                                                     V
         LA    R3,4(,R3)          MEANWHILE SKIP BLOCK DESCRIPTOR     V
         B     CTLMV              AND GO GET THE RECORD               V
*                                                                     V
CTLBADV  ERROR '*** DDNAMEIN IMPROPER FORMAT V DATA ***',              *
               (4,LEVNAME),RC=ABEND                              82060
*                                                                     V
CTLMVC   MVC   VBUFFER(0),0(R3)   EXECUTED INSTRUCTION                V
*
*  END OF FILE
*
CTLEOD   SET   (CTLEOF,REALEOF)   JUST SO NOBODY FORGETS
         LA    R15,4              SET END OF FILE RETURN CODE
         B     CTLRDX             AND RETURN
*                                                               JRE0036
WYLREAD  L     R15,=V(UNPRESS)    WYLBUR EDIT UNPRESS FOR READ   80294
         CALL  (15),(INTEGER)                                    80294
         B     CTLRDX0             RETURN                       JRE0036
*
*  SYNAD EXIT
*
CTLSYNAD SYNADAF ACSMETH=BSAM
         MVC   SYNMSG2,50(R1)
         SYNADRLS
         XPRNTLIN PWA,TEXT=SYNADMSG,LENGTH=SYNLEN
         ERROR '*** ABENDING - USER 1 ***',RC=ABEND                   #
*
SYNADMSG DC    C'*** I/O ERROR *** '
SYNMSG2  DC    CL78' '
SYNLEN   EQU   *-SYNADMSG
*
*  DCB EXIT LIST
*
CTLEXIT  DS    0F                                                     #
NMEXIT   DC    X'05',AL3(DCBEXIT) SO CAN DEFAULT NM BLKSIZE TO 80
JFCBA    DC    X'87',AL3(JFCB)                                        V
         SPACE 1                                                 82060
*
*  SPECIAL READ ROUTINE FOR MEMBER OF A CHAIN OF RECURSIVE UPDATES.
*
*  IN THIS CASE, THE DCB FOR ALL LEVELS IS IN THE CREATING LEVEL
*  FOR THE CHAIN (THE PERMANENT LEVEL HAS THE ONLY OPEN DCB).
*  EACH LEVEL OF THE RECURSIVE UPDATE CHAIN SHARES THE ONE DCB,
*  MAINTAINING THE CURRENT TTR IN THE BLDL AREA FOR ITSELF.
*
CHAINRD  L     R2,REALDCB         GET ADDRESS OF SHARED DCB
         POINT (R2),BLDLTTR       POSITION TO READ NEXT BLOCK
         USING BUFDSECT,R3                                            C
         READ  BUFDECB,SF,(R2),BUFDATA,'S',MF=E                 JRE0036
         CHECK BUFDECB                                                C
         DROP  R3                                                     C
         NOTE  (R2)               WHERE HAVE YOU BEEN ALL AFTERNOON
         ST    R1,BLDLTTR         SAVE TTR FOR FUTURE READS
         MVI   BLDLTTR+3,1        FOR FUTURE POINT (TTR + 1).
         B     CHAINRD1           MERGE BACK WITH NORMAL READ.
         TITLE 'NEW MASTER STOW AND SSI MAINTENANCE ROUTINES'
NMSTOW   BGNSB NMSTSV,EQU=NMSAV
         IF    NOWRITE,NMSTX      BYPASS STOW IF NO-WRITE SET         A
         USING NMDSECT,R6         POINTER FOR SYSUT2/SYSPUNCH AREA
         MVC   SSIWORK,DEFSSU  USE DEFAULT SSI                   82060
         MVC   STOWNAME,RNAME     MEMBER NAME
         MVI   STOWC,0            COUNT OF USER DATA TO BE STORED / 2
         MVC   NMSTMSG+4(6),=C'MEMBER'
         IF    LOADING,NMST4                                          #
*
*  FOLLOW CHAIN OF LEVEL DSECTS DOWN TO ORIGINAL SOURCE
*
         L     R9,SYSINADR        SYSIN DSECT IS BEGINNING OF CHAIN
NMST1    IF    SYSUT1,NMST3
         CLC   NAME,GMEMB         BE SURE CURRENT UPDATE APPLIES NOW
         BNE   NMST1A             SKIP OVER IT IF IT DOESN'T
         IF    ADD,NMST2
NMST1A   L     R9,NEXTLEV         POINT TO NEXT UPDATE LEVEL DSECT
         B     NMST1              KEEP LOOKING
*
*  ORIGINAL SOURCE IS CARDS VIA THE ADD FUNCTION
*
NMST2    IF    ¬SSISPEC,NMST4     BRANCH IF SSI WAS NOT SPECIFIED
         MVI   STOWC,2            INDICATE 2 HALF-WORDS USER DATA (SSI)
         BAL   R10,SSIMOVE        GET USER SSI INFO.
         B     NMST4
*
*  ORIGINAL SOURCE IS SYSUT1 (ONLY SSI SOURCE IS PDS DIRECTORY)
*
NMST3    IF    CTLPS,NMST4        BRANCH IF DSORG=PS (NO SSI POSSIBLE)
         MVC   STOWC(63),BLDLC    FETCH ALL POSSIBLE USER DATA
         NI    STOWC,X'7F'        RESET ALIAS BIT
         CLI   STOWC,2            TEST IF MORE U.D. THAN JUST SSI     A
         BNH   *+8                NO - O.K.                           A
         MVI   STOWC,2            YES - TRUNCATE (IN CASE CHAINED)    A
         UNPK  SSIWORK(9),BLDLUD(5)    FETCH SSI OUT FOR ANY MODS
*
*  WORK BACK UP THE CHAIN TO SYSIN, UPDATING THE UNPACKED SSI IN
*  SSIWORK AS WE GO.
*
*  IF WE ARE STOW-ING A VERSION OF A MEMBER, WE MUST PUT THE EXTRA
*  USER DATA (FROM SYSUT2 - IN SYSIN'S "BLDLIST" WORK AREA) INTO THE
*  DIRECTORY ENTRY.
*
NMST4    IF    ¬VSTOW,NMST4B      BRANCH IF NOT STOWING A "VERSION"
         L     R2,SYSINADR
         MVC   STOWUD+4(DRECSIZE-4),BLDLUD+4-LOCAL(R2)
         CLI   STOWC,0            TEST IF ANY SSI FROM SYSUT1
         BNE   NMST4A             YES - BRANCH
         UNPK  SSIWORK(9),BLDLUD-LOCAL(5,R2)    NO - PUT SOME IN
NMST4A   MVI   STOWC,DRECSIZE/2   EXPAND DIRECTORY
*
NMST4B   IF    SYSIN,NMST5        BRANCH IF SOURCE FROM SYSIN
         L     R9,BACKLEV         POINT TO PREVIOUS DSECT
         IF    ¬SSISPEC,NMST4B    SKIP THIS LEVEL IF SSI NOT SPECIFIEDH
         CLC   NAME,GMEMB
         BNE   NMST4B             ALSO SKIP IF REFERS TO WRONG MEMBER H
*  CURRENT LEVEL CHANGE DECK WILL MODIFY THE SSI.
         BAL   R10,SSIMOVE        UPDATE PREVIOUS SSI
         CLI   STOWC,2
         BNL   NMST4B             DIRECTORY ALREADY HAS SSI SPACE     H
         MVI   STOWC,2            SET 2 HALF-WORDS OF SPACE FOR SSI
         B     NMST4B                                                 H
*
*  SSI UPDATING COMPLETE - JUST STOW THE THING.
*
NMST5    PACK  WORKS,SSIWORK(9)
         MVC   STOWUD(4),WORKS    PUT FINAL SSI INTO USER DATA FIELD
*
         LA    R3,ANAME-L'ANAME   POINTER TO ANY ALIASES TO BE STOWED A
         LA    R4,L'ANAME         INCREMENT                           A
         L     R5,ALIASPTR        LIMIT                               A
*                                                                     A
         IF    ¬TIMES,NMSTOWA     BRANCH IF NOT STOWING TIME-STAMP
         XR    R1,R1
         ICM   R1,1,STOWC         NO. HALFWORDS USER DATA        82060
         BNZ   *+8                NOT ZERO; OK
         LA    R1,2               YES - MUST PUT IN DUMMY SSI
         CLI   STOWC,4            TEST FOR PREVIOUS TIME STAMP
         BE    DETIME             IF IS, BRANCH TO REMOVE IT
         CLI   STOWC,DRECSIZE/2   TEST FOR PREV. STAMP (IN CHAIN ENTRY)
         BNH   DETIME+4           NO, SKIP
DETIME   SH    R1,=H'2'           DROP PREV. STAMP BY SHRINKING U.D.
         LA    R2,0(R1,R1)        BYTES U.D. WITHOUT TIME STAMP
         LA    R2,STOWUD(R2)      PLACE IN U.D. TO PUT STAMP
         MVC   0(4,R2),TIMEWORD   MOVE TIME STAMP TO USER DATA AREA
         LA    R1,2(,R1)          INCREASE USER DATA HALFWORDS COUNT
         STC   R1,STOWC
*
NMSTOWA  MVC   NMSTMSG+11(8),STOWNAME  PUT INTO PRINT MESSAGE
         CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060
         STOW  NM,STOWLIST,R
         B     *+4(R15)           TEST RETURN CODE
         B     NMSTR              MEMBER REPLACED
         DC    XL4'0'             ARMAGEDDON
         B     NMSTA              MEMBER ADDED TO DIRECTORY
         B     NMSTF              DIRECTORY FULL
         B     NMSTE         PERMANENT I/O ERROR                 82060
         B     NMSTE         DCB INVALID                         82060
         B     NMSTG         OUT OF STORAGE                      82060
NMSTE    ERROR '*** NEW MASTER STOW ERROR ***',RC=ABEND
*
NMSTR    MVC   NMSTMSGA,=C'REPLACED'
         B     NMST6
*
NMSTA    MVC   NMSTMSGA,=C'ADDED   '
NMST6    LA    R10,NMSTMSGA-NMSTMSG  SET ALIAS LENGTH OF MESSAGE 82060
         CLI   NMSTMSG+4,C'M'  MEMBER ?                          82060
         BNE   NMST6Z        NO; DO ALIAS                        82060
         LA    R10,NMSTMSGZ-NMSTMSG  SET FULL LENGTH             82060
         MVC   NMSTMSGN,=X'4020202020202120'   MOVE EDIT PATTERN 82060
         L     R0,UT2COUNT   GET OUTPUT COUNT                    82060
         CVD   R0,WORKA      MAKE PACKED                         82060
         ED    NMSTMSGN,WORKA+4   MAKE EBCDIC COUNT              82060
NMST6Z   XPRNTLIN PWA,TEXT=NMSTMSG,LENGTH=(R10)                  82060
         CALLSUB POSTSTOW    PRINT OLD DATA                      82060
         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060
         IF    ALIAS,STOWA        BRANCH IF AN ALIAS TO STOW
NMSTX    ENDSB NMSTSV             RETURN                              A
*
NMSTMSG  DC    C'*** MEMBER ........ HAS BEEN '
NMSTMSGA DC    CL8' '        ADDED/REPLACED                      82060
NMSTMSGS DC    CL4' '        END OF ALIAS (SHORT) MESSAGE        82060
NMSTMSGN DC    CL8' ',C' RECORDS WRITTEN'                        82060
NMSTMSGZ EQU   *             END OF MEMBER (LONG) MESSAGE        82060
STOWA    BXH   R3,R4,NMSTX        LOOP TO STOW ALL THE ALIASES        A
         OI    STOWC,X'80'        INDICATE ALIAS
         MVC   NMSTMSG+4(6),=C' ALIAS'
         MVC   STOWNAME,0(R3)                                         A
         B     NMSTOWA
*
NMSTF    ERROR '*** NEW MASTER DIRECTORY FULL ***',RC=12              #
         DROP  R6
         SPACE 3
*  THIS ROUTINE FETCHES SSI INFORMATION FROM THE SSI FIELD OF THE
*  CURRENT DSECT (WHICH CONTAINS THE SSI IN UNPACKED HEX),
*  TO SSIWORK, OVERLAYING (FROM THE RIGHT) ONLY THE NUMBER OF DIGITS
*  THE USER ACTUALLY SPECIFIED ON HIS CONTROL CARD.
*  NOTE THAT SSIWORK IS FOLLOWED BY A FIELD OF PADDING TO SAVE ME THE
*  TROUBLE OF COMPUTING A MVC LENGTH FIELD.
*
SSIMOVE  L     R1,SSICOUNT        NUMBER OF DIGITS NOT TO OVERLAY
         LA    R14,SSIWORK(R1)     TO ADDRESS
         LA    R15,SSI(R1)         FROM ADDRESS
         MVC   0(8,R14),0(R15)    FETCH (PARTIAL) SSI
         BR    R10                RETURN
         SPACE 2                                                 82060
*        CONVERT FROM INTERNAL HEX TO EBCDIC                     82060
*                                                                82060
HEXCNVT  CH    R1,H7                                             82060
         BL    HEXCNVT1                                          82060
         UNPK  0(15,R3),0(8,R4)                                  82060
         TR    0(14,R3),HEXTAB-C'0'                              82060
         LA    R3,14(,R3)                                        82060
         LA    R4,7(R4,0)                                        82060
H7       EQU   *-2                                               82060
         SH    R1,H7                                             82060
         BP    HEXCNVT                                           82060
         B     HEXCNVT2                                          82060
HEXCNVT1 LA    R2,0(R1,R1)                                       82060
         SLL   R2,4                                              82060
         AR    R2,R1                                             82060
         EX    R2,HEXUNPK                                        82060
         LA    R2,0(R1,R1)                                       82060
         BCTR  R2,0                                              82060
         EX    R2,HEXTRT                                         82060
         LA    R3,1(R2,R3)                                       82060
         LA    R4,0(R1,R4)                                       82060
HEXCNVT2 MVI   0(R3),C' '                                        82060
         BR    R5                                                82060
HEXUNPK  UNPK  0(0,R3),0(0,R4)                                   82060
HEXTRT   TR    0(0,R3),HEXTAB-C'0'                               82060
         TITLE 'GETNAME - FETCH NAME AND ADJUST FOR VERSION'
*  THIS ROUTINE GETS THE NAME= FIELD (IN WNAME FROM KEYSCAN) AND
*  MOVES IT, LEFT JUSTIFIED, TO 'NAME' IN THE DSECT.
*  IT IS ALSO PLACED IN 'RNAME' (GLOBAL) SO THAT IF VERSION= IS
*  SPECIFIED AND CAUSES A NEW NAME TO BE CREATED (IN RNAME) THE
*  ORIGINAL NAME AS SPECIFIED IS NOT LOST (IT IS NEEDED FOR THE
*  POSITION ROUTINE).
*
*  THIS ROUTINE IS ALSO RESPONSIBLE FOR THE CREATION OF THE INITIAL
*  EXPANDED PRODUCTION ALIAS AND VERSION ZERO ALIASES IN THE NEW
*  MASTER DIRECTORY.
*  THE DIRECTORY MUST BE EXPANDED UNDER THE FOLLOWING CONDITIONS:
*  1.  THE FUNCTION IS CHANGE/ADD (I.E. LATER STOW WILL OCCUR)
*  2.  THE VERSION NUMBER IS NOT ZERO (WHILE ONLY ONE VERSION OF
*      A MEMBER EXISTS, WE LIKE TO KEEP THE DIRECTORY STANDARD)
*  3.  THE PRODUCTION DIRECTORY ENTRY IS 'SHORT' (THAT IS, THIS
*      ROUTINE HAS NOT PREVIOUSLY EXPANDED IT TO INCLUDE THE MEMBER'S
*      UNIQUE I.D. NUMBER, LIBRARY I.D., OR HIGHEST VERSION NUMBER).
*
*  NOTE THAT WHEN THE DIRECTORY IS EXPANDED, IT IS NO LONGER ASSUMED
*  TO REPRESENT VERSION ZERO OF THE MEMBER, SO ANOTHER DIRECTORY ALIAS
*  MUST BE CREATED WITH THE PROPER NAME TO BE RECOGNIZED AS VERSION 0.
*
*  THE (EXPANDED) PRODUCTION DIRECTORY ALIAS INCLUDES (IN 'MEMVER')
*  THE HIGHEST VERSION NUMBER WHICH IT KNOWS ABOUT (OTHER DIRECTORY
*  ENTRIES SIMPLY REPEAT THEIR OWN VERSION NUMBER IN THIS FIELD).
*  THIS IS DONE SO THAT A USER MAY, WHEN BEGINNING WORK ON A MEMBER
*  WHICH HE WANTS BACKED UP UNDER THE 'CHAIN LIBRARY' SYSTEM,
*  SPECIFY 'VERSION=NEXT' ON HIS CHANGE/ADD CARD.
*  THIS ROUTINE THEN ASSIGNS HIM VERSION NUMBER MEMVER+1 FROM THE
*  PRODUCTION ALIAS.  THE ALIAS IS WRITTEN BACK TO THE DIRECTORY
*  BY THIS ROUTINE SO THAT EVEN IF HIS UPDATE FAILS, HIS ASSIGNED
*  VERSION NUMBER IS NOT AVAILABLE IN THE FUTURE.
*  THIS ROUTINE WILL ALSO RE-WRITE THE PRODUCTION ALIAS IF THE USER IS
*  DROPPING A VERSION EQUAL TO THE MEMVER FIELD IN THE PRODUCTION
*  ALIAS WITH MEMVER=MEMVER-1.  HENCE THE DROPPED VERSION NUMBER IS
*  MADE AVAILABLE AGAIN (IF SEVERAL PEOPLE ARE WORKING ON ONE MEMBER,
*  IT MAY BE DESIREABLE TO DROP THE EXTRA VERSION AT THE SAME TIME, TO
*  ENSURE PROPER REDUCTION OF MEMVER.  NOTE THAT MEMVER IS DECREMENTED
*  BY THIS ROUTINE EVEN IF THE SPECIFIED VERSION IS FOUND NOT TO EXIST
*  BY THE DROP ROUTINE.
*
*
         USING NMDSECT,R6
GETNAME  BGNSB GNSAVE,EQU=LOGSAVE
         GOSUB LJNAME             GET NAME LEFT JUSTIFIED (OR ERROR)
         IF    ¬SYSIN,GNEXIT      IGNORE VERSION= UNLESS IN SYSIN
         IF    ¬UT2AVAIL,CMDE24   STOP IF SYSUT2 NOT AVAILABLE
         MVC   RNAME,NAME         SAVE NAME FOR STOW
         RESET VSTOW
         LA    R3,BLDLUD          DSECT POINTER FOR USER DATA
         USING DREC,R3
         IF    LOADING,GNLOAD     SPECIAL TREATMENT UNDER ./LOAD
         IF    FVERSION,GNVSP     BRANCH IF VERSION= SPECIFIED
         IF    FNEWNAME,GN6       BRANCH IF NEWNAME= SPECIFIED
         IF    ¬CHAINING,GNEXIT   NO CHAINING, NO VERSION.   EXIT.
*
         CLI   CMDNUM+3,VCCURNT   IF OPERATION IS 'CURRENT'      82060
         BE    GN3                * ALLOW OMITTED VERSION (RECOVER)
GNE1     ERROR '*** VERSION MUST BE SPECIFIED WHEN CHAINING ***'
*
GNVSP    IF    CHAINING,GN1
         IF    NMPS,GNEXIT        COULDN'T HAVE HAD CHAINING ANYWAY
         ERROR '*** ILLEGAL TO SPECIFY VERSION WHEN NOT CHAINING ***'
*
GNLOAD   IF    ¬CHAINING,GNEXIT
         MVI   WVERSION,C' '      FAKE VERSION=NEXT FOR ./LOAD
         MVI   WVERSION+4,C'N'                                   82060
GN1      MVC   BLDLNAME,NAME      PREPARE TO SEARCH DIRECTORY FOR NAME
         MVC   BLDLUD(4),DEFSSI  SET DEFAULT SSI IF NONE READ    82060
         BLDL  NM,BLDLIST
         BXH   R15,R15,GNCT       BRANCH TO CREATE (UNCHAINED, V=0)
         CLI   BLDLTTR+2,0
         BE    GNCT
         CLI   WVERSION,C' '      WILL BE '    NEXT' IF VERSION=NEXT
         BE    GN4
*
*  CHAINING IS ON, VERSION WAS SPECIFIED, AND THE NAMED PRODUCTION
*  MEMBER ALREADY EXISTS IN SYSUT2.
*  CREATE OR ADD TO CHAIN.
*
GN1A     TM    BLDLC,8            BIT WILL BE ON ONLY IF SO MUCH USER
         BO    GN2                 DATA EXISTS THAT WE KNOW THIS IS
*                                  ALREADY AN EXPANDED ENTRY.
*
*  DIRECTORY ENTRY FOR PRODUCTION NAME WAS SHORT (NORMAL).
*  WE WILL DETERMINE A MEMBER ID FOR ALL UPDATES TO BE CHAINED TO
*  THIS MEMBER (FROM ALLOCATOR ENTRY) AND THIS DIRECTORY ENTRY
*  (WHICH IS THE PRODUCTION ENTRY) WILL BE EXPANDED TO INCLUDE ALL OUR
*  STUFF.  IT WILL ALSO BE CHANGED INTO AN ALIAS.
*
GN1B     CLC   WVERSION+5(3),=C'000'   TEST IF SPECIFIED V=0
         BE    GNEXIT             YES - DO NOT EXPAND DIRECTORY
         CLI   CMDNUM+3,VCCHANGE  MUST BE CHANGE/ADD TO EXPAND   82060
         BH    GNE3
*
*  IF SHORT ENTRY HAD A TIME STAMP, MUST PRESERVE IT.
         TM    BLDLC,4
         MVI   BLDLC,DRECSIZE/2+X'80'  ENLARGE USER DATA AREA    82060
         BZ    GN1C               BRANCH OUT IF NO OLD TIME STAMP
         MVI   BLDLC,DRECSIZE/2+X'82'  MAKE COUNT OF USER DATA BIGGER
         MVC   STOWUD+DRECSIZE(4),BLDLUD+4  SAVE OLD TIME STAMP  82060
         MVC   BLDLUD+DRECSIZE(4),BLDLUD+4    FOR GNRESTOW ALSO  82060
GN1C     EQU   *
*  CREATE INTERNAL NAME.
         AP    AMEMBID,=P'1'      INCREMENT IN ALLOCATOR
         MVC   REALNAME,NAME      SET UP IN BLDL AREA JUST LIKE IT
         MVC   LIBNAME,LIBID      * WAS READ IN BY BLDL.
         ZAP   MEMBID,AMEMBID
         PACK  MEMVER,WVERSION+5(3)    SET AS HIGH VERSION NUMBER
*  AND CHECKPOINT THE ALLOCATOR
         STOW  NM,STWALLOC,R
         BXH   R15,R15,STWACHBL                                  82060
*  NOW STOW THE EXPANDED PRODUCTION ALIAS
         MVC   STOWNAME,NAME
         MVC   STOWTTR,BLDLTTR
         MVC   STOWC(DRECSIZE+1),BLDLC
         CALLSUB PRESTOW,STOWLIST                                82060
         STOW  NM,STOWLIST,R
         LTR   R15,R15
         BNZ   STWE1              BAD NEWS IF DIDN'T STOW OK
         CALLSUB POSTSTOW    PRINT OLD DATA                      82060
         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060
*  AND WRITE A VERSION ZERO DIRECTORY ALIAS FOR THE SHORT ENTRY
         MVC   STOWNAME(2),LIBNAME
         UNPK  STOWNAME+2(3),MEMBID
         OI    STOWNAME+4,C'0'
         MVC   STOWNAME+5(3),=C'000'   VERSION ZERO
         ZAP   MEMVER-SSSI+STOWUD,=P'0'
         STOW  NM,STOWLIST,A      ADD TO DIRECTORY
         BXLE  R15,R15,GN1Z       BRANCH IF STOW WORKED OK       82060
         ERROR '*** VERSION ZERO ALIAS NOT STORED ***',RC=4
         B     GN2                                               82060
GN1Z     CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060
         SPACE 3                                                 80294
*              CREATE NEW NAME FOR STOW-ING AT END OF            80294
*              MEMBER UPDATE.                                    80294
         SPACE 1                                                 80294
*              MAY HAVE BEEN ENTERED FOR VERSION=NEXT OR FOR     80294
*                                        VERSION=EXPLICIT.       80294
*              IF VERSION    THEN WVERSION IS     MEMVER IS      80294
*                 EXPLICIT        EXP. VER        HIGH VER       80294
*                 NEXT            HIGH + 1        HIGH + 1       80294
         SPACE 1                                                 80294
GN2      MVC   RNAME(2),LIBNAME
         UNPK  RNAME+2(3),MEMBID
         OI    RNAME+4,C'0'
         MVC   RNAME+5(3),WVERSION+5
         SET   VSTOW              INDICATE TO NMSTOW THIS A "VERSION"
         CLC   BLDLNAME,REALNAME  VERIFY USER DATA VALID              #
         BNE   BADDREC            NO - BOMB.                          #
*  MAY RE-STOW PRODUCTION ALIAS TO PRESERVE HIGH VERSION NUMBER.
         MVC   STOWNAME,NAME
         MVC   STOWTTR,BLDLTTR
         MVC   STOWC(DRECSIZE+5),BLDLC
         OI    STOWC,X'80'        BE SURE STILL ALIAS (IEBCOPY ETC)
         PACK  MEMVER-SSSI+STOWUD,WVERSION+5(3)  NEW VERSION NUMBER
         CLI   CMDNUM+3,VCDROP    TEST FOR DROP/CURRENT          82060
         BH    GNEXIT             CURRENT (HE'LL PROBABLY BOMB LATER)
         BE    GN5                DROP - MAY BE ABLE TO LOWER MEMVER
*                                 OLD HIGH + 1 :: NEW VERSION    80294
*              OR                 OLD HIGH     :: NEW VERSION    80294
         CP    MEMVER,MEMVER+STOWUD-SSSI                         80294
         BH    GNEXIT             LEAVE IF NEW VERSION LOWER     80294
GNRESTOW CALLSUB PRESTOW,STOWLIST   SAVE OLD DATA                82060
         L     R1,=A(PSTBLDL)   GET PRESTOW WORK AREA            82060
         TM    PSTFLAG-PSTBLDL(R1),L'PSTFLAG  GOOD BLDL ?        82060
         BZ    GNRESTOX      NO; STOW                            82060
         CLC   PSTNAME-PSTBLDL(PSTTTR-PSTNAME+L'PSTTTR,R1),STOWLIST
         BNE   GNRESTOX      DIFFERENT ?  RESTOW                 82060
         CLC   PSTINDC-PSTBLDL(DRECSIZE+1,R1),STOWC  SAME DATA ? 82060
         BNE   GNRESTOX      NO; RESTOW                          82060
         TM    STOWC,X'0B'   TIME STAMP PRESENT ?                82060
         BNO   GNEXIT        NO; DON'T RESTOW SAME ENTRY         82060
         CLC   PSTSSI+DRECSIZE-PSTBLDL(4,R1),STOWUD+DRECSIZE     82060
         BE    GNEXIT        SKIP IF TIME STAMP MATCHES ALSO     82060
GNRESTOX STOW  NM,STOWLIST,R                                     82060
         BXH   R15,R15,STWE2                                     82060
         CALLSUB POSTSTOW                                        82060
         CALLSUB POSTSTAD,STOWLIST  PRINT NEW DATA               82060
*
GNEXIT   ENDSB GNSAVE
*
*  USER SPECIFIED VERSION= FOR NEW MEMBER.  IF HE DOESN'T HAVE
*  VERSION=0, HE SOON WILL.
*
GNCT     CLI   CMDNUM+3,VCDROP    TEST FOR DROP/CURRENT          82060
         BNL   GNNCT              BRANCH IF IT IS FOR ERROR MESSAGE
         CLC   WVERSION+5(3),=C'000'
         BE    GNEXIT
         CLI   WVERSION,C' '      DID USER SPECIFY VERSION=NEXT
         BE    GNEXIT             YES - DON'T ANNOY HIM ABOUT V=0
         ERROR '*** VERSION SET TO ZERO FOR NEW MEMBER ***',RC=4
         B     GNEXIT
*
*  HAVE NO VERSION SPECIFIED FOR ./CURRENT - USER MUST BE TRYING TO
*  RECOVER A LOST PRODUCTION ALIAS.
*
GN3      CLC   LIBID,NAME         TO RECOVER, HE MUST PROVIDE A
         BNE   GNE2                REASONABLE NAME
         MVI   BLDLTTR+2,0        PREVENT IT FROM LOOKING CURRENT BY TT
         MVZ   WORKD(6),NAME+2
         CLC   WORKD(6),=8C'0'
         BE    GNEXIT
*
GNE2     ERROR '*** BAD NAME FOR RECOVERY OPERATION ***'
         SPACE 1                                                 80308
*              USER SPECIFIED VERSION=NEXT | VERSION=LAST        80308
*              GIVE HIM 1+MEMVER (FROM PRODUCTION) | MEMVER      80308
         SPACE 1                                                 80308
GN4      TM    BLDLC,8            TEST IF SHORT DIRECTORY ENTRY
         BZ    GN4S               YES - BRANCH TO SET VERSION=1
         CLI   WVERSION+4,C'L'         VERSION=LAST ?            80308
         BE    *+10                     YES - SKIP INCREMENT     80308
         AP    MEMVER,=P'1'       COMPUTE NEXT VERSION NUMBER    80294
*                                        =HIGHEST + 1            80294
         UNPK  WVERSION,MEMVER    SETUP IN VERSION WORK AREA     80294
         OI    WVERSION+7,C'0'
         B     GN4S+6             JUMP NEXT INSTRUCTION
GN4S     MVC   WVERSION+5(3),=C'001'  SET NEW VERSION=1
         IF    LOADING,SKIPVNM    DON'T PRINT VERSION MSG FOR ./LOAD
         ERROR '*** YOU HAVE BEEN ASSIGNED VERSION NUMBER NNN',        *
               (42,WVERSION+5,3),ID=NO,RC=0                      82060
         ERROR '*** PLEASE USE THIS VERSION FOR YOUR CURRENT WORK ON TH*
               IS MEMBER',ID=NO,RC=0                             82060
SKIPVNM  EQU   *
         TM    BLDLC,8            TEST IF MUST EXPAND
         BZ    GN1B
         B     GN2
*
*  USER SPECIFIES NEWNAME=... ON A SYSIN CHANGE CARD.  SET FOR NMSTOW.
*
GN6      IF    CHAINING,GNE1      TRYING TO USE NEWNAME WITH CHAINING?
         MVC   WORKA,NAME         SAVE OLD MASTER MEMBER NAME
         MVC   WNAME,WNEWNAME     TRICK 'LJNAME' SUBROUTINE
         GOSUB LJNAME             * INTO CONVERTING NEWNAME FOR US.
         MVC   RNAME,NAME         SET NEWNAME AS NAME TO STOW LATER
         MVC   NAME,WORKA         RESTORE OLD MASTER MEMBER NAME
         B     GNEXIT
*
*  FOR 'DROP' - IF DROPPING HIGHEST VERSION, DECREMENT MEMVER AND
*  RE-WRITE PRODUCTION ALIAS.
*
GN5      CP    MEMVER,MEMVER-SSSI+STOWUD
         BNE   GNEXIT
         SP    MEMVER-SSSI+STOWUD,=P'1'
         B     GNRESTOW           GO TO RE-WRITE IT.
*
STWACHBL ERROR '*** ERROR UPDATING ALLOCATOR ***',RC=ABEND
STWE1    CH    R15,=H'12'         TEST IF PROBLEM WAS FULL DIRECTORY
         BE    NMSTF              YES - BRANCH
         ERROR '*** ERROR EXPANDING DIRECTORY ENTRY ***',RC=ABEND
STWE2    ERROR '*** ERROR UPDATING PRODUCTION ALIAS ***',RC=ABEND
GNE3     ERROR '*** NO VERSIONS EXIST (EXCEPT SHORT ZERO) ***'
GNNCT    ERROR '*** BASE MEMBER DOES NOT EXIST ***'
BADDREC  ERROR '*** INVALID PRODUCTION DIRECTORY ***',RC=ABEND        #
         DROP  R3
*
*
*  ROUTINE TO LEFT JUSTIFY A NAME, MOVING IT FROM WNAME TO NAME
*  (IN THE DSECT).
*  IF NAME= WAS NOT SPECIFIED, (NAME) IS SET TO BLANKS.
*  THE MEMBER NAME IS ALSO CHECKED FOR VALIDITY (WRT OS CONVENTIONS)
*  LENGTH-1 IS RETURNED IN R15 (UNLESS NAME OMITTED).               SMP
*
LJNAME   MVC   NAME,BLANKS        CLEAR RECEIVING AREA
         IF    FNAME,LJOK         BRANCH IF NAME= WAS SPECIFIED
         IF    NMPS,LJEND         OMITTED NAME IS OK FOR DSORG=PS (NM)
         B     CMDE8              BUT NOT FOR PARTITIONED OUTPUT
LJOK     LA    R1,WNAME           ADDRESS OF SOURCE
         LA    R14,1              INCREMENT
         LA    R15,WNAME+7        BXLE LIMIT
LJLOOP1  CLI   0(R1),C' '
         BNE   LJ1                BRANCH AFTER SCANNING LEADING BLANKS
         BXLE  R1,R14,LJLOOP1
LJ1      CLI   0(R1),C'Z'         FIRST LETTER MAY NOT BE NUMERIC
         BH    BADNAME
         SR    R15,R1             LENGTH FOR MOVE
         EX    R15,LJMOVE         MOVE MEMBER NAME
LJEND    BR    R10                RETURN
         DROP  R6
*
LJMOVE   MVC   NAME(0),0(R1)
BADNAME  ERROR '*** IMPROPER NAME ***'
         TITLE 'CHECK FOR ./ CONTROL CARD AND ANALYZE CONTROL WORD'
*  THIS ROUTINE SETS RETURN CODE 4 FOR EXPLICIT CONTROL CARDS.
*  AND 8 FOR THOSE WHICH REPRESENT CTLEOF (ADD, CHANGE)
         SPACE 2
CCLOOK   BGNSB CMDSAV,EQU=CTLSV
         LA    R6,CTLAREA         PLACE TO PRINT FROM
*
         CLC   DOTSLASH,CTLBUF    TEST IF CONTROL CARD
         BE    CCCTL              BRANCH FOR EXPLICIT CONTROL CARD
*
*  IF 'GANG' IS ON, WE PLACE THE USER'S 'CODE' ON ALL HIS DATA CARDS.
*
         LA    R0,C'G'            ERROR CODE IF GANG OVERLAY
         LA    R1,CTLBUF          ADDRESS OF THE CARD IMAGE
         BAL   R10,DOGANG
         ENDSB CMDSAV,RC=0
*
*
*  FOR ./ CONTROL CARDS, WE ANALYZE THE OPERATION TYPE HERE.
*  THE RETURN CODE IS SET TO 4, BUT THE COMMAND IS NEITHER PRINTED
*  NOR IMPLEMENTED AT THIS POINT, UNLESS IN ERROR.
*
CCCTL    LA    R2,CTLBUF+L'DOTSLASH  PLACE TO START SCAN FROM
         LA    R4,1               INCREMENT
         MVC   CTLPSQ,BLANKS
         IF    ¬WYLBUR,CCCTLWYL                                 JRE0036
         MVC   CTLWYL,CTLSQ        LIST WYL SEQ #               JRE0036
         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036
CCCTLWYL DS    0H                                               JRE0036
         IF    ¬NAMES,CCB0A       BRANCH IF NO NAMES ON ./ CARDS
         LA    R5,7(,R2)          ARBITRARY LIMIT
*
CCB0     CLI   0(R2),C' '
         BE    CCB0A              BRANCH OUT WHEN DONE WITH NAME FIELD
         BXLE  R2,R4,CCB0
*
         XPRADR PWA,TEXT=(R6)   PRINT CTLAREA                    82060
         ERROR '*** NAME FIELD - EXCESSIVE LENGTH ***'
*
CCB0A    LA    R5,CTLBUF+50       ANOTHER ARBITRARY LIMIT
*
*  SCAN LEADING BLANKS TO LOCATE THE OPERATION CONTROL WORD.
*
CCB1     CLI   0(R2),C' '
         BNE   CCB2
         BXLE  R2,R4,CCB1
*
         XPRADR PWA,TEXT=(R6)   PRINT CTLAREA                    82060
         ERROR '*** NO OPERATION SPECIFIED ***'
*
CCB2     LR    R1,R2              SAVE POINTER TO CONTROL WORD
         LA    R5,7(,R2)          LIMIT
CCB3     CLI   1(R2),C' '
         BE    CCB4               BRANCH WHEN FOUND END OF WORD
         BXLE  R2,R4,CCB3
         B     CMDBAD
*
CCB4     LR    R3,R2
         SR    R3,R1              LENGTH FIELD FOR MOVING CONTROL WORD
         MVC   WORKA,BLANKS
         EX    R3,CMDMOVE
         LA    R2,2(,R2)          SET TO SCAN POST-BLANKS LATER
         ST    R2,KSCANPTR        SAVE FOR KEYWORD ROUTINE
*
*  LOOK UP OPERATION IN COMMAND TABLE, AND STORE ITS SEQUENCE NUMBER.
*
         L     R3,CMDTABA          GET CMD TABLE ADDR           JRE0036
         LA    R14,10             INCREMENT
         L     R15,CMTENDA         END OF TABLE                 JRE0036
CMDLOOP  CLC   WORKA,0(R3)
         BE    CMDOK              BRANCH WHEN COMMAND FOUND
         BXLE  R3,R14,CMDLOOP
*
CMDBAD   XPRADR PWA,TEXT=(R6)   PRINT CTLAREA                    82060
         ERROR '*** INVALID COMMAND ***'
*
CMDOK    LH    R1,8(,R3)          GET CODE NUMBER THIS COMMAND
         ST    R1,CMDNUM          HIDE IT AWAY
         CH    R1,=Y(VCMAJOR)     TEST IF MAJOR CONTROL FUNCTION 82060
         BNH   CMDEOF             BRANCH IF SO TO SET RC=8
         IF    ¬INSERT,CMDNI      TEST IF TERMINATING AN INSERT
         CLI   CMDNUM+3,VCCOPY    TEST IF NEXT COMMAND IS COPY   82060
         BE    CMDNI              YES - LEAVE INSERT ALONE
         CLI   CMDNUM+3,VCGANG    TEST FOR ./ GANG COMMAND       82060
         BE    CMDNI              YES - LEAVE INSERT ALONE
         CLI   CMDNUM+3,VCSEQ     TEST IF  ./ SEQUENCE           82060
         BE    CMDNI              YES - LEAVE INSERT ALONE
         CLI   CMDNUM+3,VCMACRO    TEST IF  ./ MACRO             82060
         BE    CMDNI              YES - LEAVE INSERT ALONE
         BAL   R10,INSTERM
CMDNI    EQU   *
         ENDSB CMDSAV,RC=4
CMDEOF   SET   CTLEOF
         ENDSB CMDSAV,RC=8
         TITLE 'CONTROL CARD - KEYWORD ANALYSIS'
*  THIS ROUTINE PRINTS THE CONTROL CARD IN CTLBUF, AND SCANS IT
*  (AND ANY CONTINUATIONS) FOR RECOGNIZED KEYWORDS.
*  THIS ROUTINE SETS NO RETURN CODE.
*
KEYSCAN  BGNSB KEYSAV,EQU=NMSAV
         XC    FKEYFLGS,FKEYFLGS  CLEAR KEYWORD WORK FLAGS
         RESET (PRVEJECT,PRVEJTST)  RESET EJECT FLAGS            82060
KSCONT   LA    R2,CTLAREA         PLACE TO PRINT CONTROL CARD FROM
*  IF COMMAND'S SEQUENCE IS BETWEEN VCENDUP AND VCMAJOR, THEN THE
*  FUNCTION IS VALID ONLY IN SYSIN (EG.  SCRATCH, RENAME, CURRENT, LOAD
         L     R6,CMDNUM          GET COMMAND'S SEQUENCE NUMBER       A
         IF    SYSIN,KSPR         FILE IS SYSIN - PRINT ALL
         CLI   CMDNUM+3,VCENDUP   IF NOT, VERIFY COMMAND ALLOWED.
         BNH   KSTEST             CHANGE|ENDUP|ADD ARE OK.       82060
         CH    R6,=Y(VCMAJOR)     TEST IF A DETAIL COMMAND       82060
         BH    KSTEST             DETAIL COMMANDS OK.
*
         XPRADR PWA,TEXT=(R2)   PRINT CTLAREA                    82060
         ERROR '*** ABOVE COMMAND IGNORED (NOT SYSIN) ***',RC=4
         B     SNOTE              GO TREAT LIKE A COMMENT
*
KSTEST   IF    ¬LISTLEV,KSNOPR    LIST NON-SYSIN CARD ONLY IF 'LISTLEV'
KSPR     IF    LISTING,KSPR1      IF PARM=LISTING, WE CAN PRINT IT
         IF    ¬SYSIN,KSNOPR      PARM=NOLISTING.  PRINT ONLY SYSIN
         CH    R6,=Y(VCMAJOR)     * MAJOR FUNCTION COMMANDS      82060
         BH    KSNOPR                                                 A
KSPR1    IF    ¬SYSIN,KSPR2  SKIP NON-SYSIN                      82060
         IF    ¬LISTING,KSPR2  SKIP IF LISTING ONLY MAJOR CMDS   82060
         IF    PRVEJTST,KSPR2   SKIP IF CONTINUATION CARD        82060
         SET   PRVEJTST      SET ATTEMPTED                       82060
         CH    R6,=Y(VCCHANGE)  ADD/CHANGE ?                     82060
         BH    KSPR2         NO                                  82060
         L     R15,KSCANPTR  GET SCAN POINTER                    82060
         LA    R0,1          INCREMENT                           82060
         LA    R1,CTLBUF+70  END                                 82060
KSPR1A   CLI   0(R15),C' '   BLANK ?                             82060
         BNE   KSPR1B        NO                                  82060
         BXLE  R15,R0,KSPR1A  TRY AGAIN                          82060
         B     KSPR2                                             82060
KSPR1B   CLC   =C'NAME=',0(R15)  NAME KEYWORD ?                  82060
         BNE   KSPR1BL       NO                                  82144
         LA    R15,5(,R15)   SKIP OVER                           82060
         B     KSPR1C                                            82144
KSPR1BL  CLC   =C'LIST=ALL,NAME=',0(R15) NIH WYLBUR/PUNK CARD ?  82144
         BNE   KSPR1C        NO; TREAT AS POSITIONAL             82144
         LA    R15,14(,R15)  SKIP OVER IT                        82144
KSPR1C   LR    R14,R15       SAVE FIRST POSITION                 82060
         BCTR  R15,0         ALLOW FOR NEXT BXH                  82060
KSPR1D   BXH   R15,R0,KSPR1E  LAST COLUMN FOUND, CHECK LENGTH    82060
         CLI   0(R15),C' '   END OF PARAMETER ?                  82060
         BE    KSPR1E        YES                                 82060
         CLI   0(R15),C','   ALTERNATE END ?                     82060
         BE    KSPR1E        YES                                 82060
         CLI   0(R15),C'$'   NATIONAL ?                          82060
         BE    KSPR1D        YES                                 82060
         CLI   0(R15),C'#'                                       82060
         BE    KSPR1D                                            82060
         CLI   0(R15),C'@'                                       82060
         BE    KSPR1D                                            82060
         CLI   0(R15),C'-'                                       82060
         BE    KSPR1E                                            82060
         CLI   0(R15),C'A'   VALID CHARACTER ?                   82060
         BNL   KSPR1D        HOPE SO                             82060
         B     KSPR2         GIVE UP                             82060
KSPR1E   SR    R15,R14       GET PARAMETER LENGTH                82060
         BNP   KSPR2         NOT VALID                           82130
         LA    R0,L'HNAME    SET MAX LENGTH (8)                  82130
         CR    R15,R0        TOO LONG ?                          82060
         BNH   *+6           NO                                  82060
         LR    R15,R0        TRUNCATE IT                         82060
         MVC   HNAME,BLANKS  BLANK BEFORE MOVE                   82060
         BCTR  R15,0         SET EXECUTE LENGTH                  82060
         EX    R15,KSPR1M    MOVE                                82060
         SET   PRVEJECT      SET EJECT                           82060
         XPREJECT PWA        EJECT                               82060
         B     KSPR2         PROCESS ./ CARD                     82060
KSPR1M   MVC   HNAME(0),0(R14)  MOVE PRESUMED NAME               82060
KSPR2    XPRADR PWA,TEXT=(R2)   PRINT CARD                       82060
*
KSNOPR   CLI   CMDNUM+3,VCNOTE    TEST IF COMMAND IS JUST 'NOTE' 82060
         BE    SNOTE              YES - DON'T HAVE ANYTHING TO DO
         L     R2,KSCANPTR        POINTER
         LA    R4,1               INCREMENT
         LA    R5,CTLBUF+70       LIMIT
*
CCB5     CLI   0(R2),C' '
         BNE   POSRTN             BRANCH AFTER SPANNING BLANKS
         BXLE  R2,R4,CCB5
         B     KEYEXIT            NO KEYWORDS FOUND
*
*  AT THIS POINT, R2 -> THE FIRST LETTER OF EITHER A KEYWORD (IN
*  WHICH DELIMITER WILL BE '=') OR A POSITIONAL OPERAND.
*  ATTEMPT TO ANALYZE AS POSITIONAL BEFORE GOING ON INTO THE KEYWORD
*  ROUTINE.
*
POSRTN   SLL   R6,2               * 4 (SIZE OF POSTAB ENTRIES)        A
POSL1    LR    R1,R2              SAVE ADDRESS OF FIRST LETTER
POSL1A   CLI   0(R2),C'A'         SCAN FOWARDS TO DELIMITER
         BL    POSL2
POSL1B   BXLE  R2,R4,POSL1A
         B     KEYSYN             ERROR WORD SO LONG, HIT COL. 72
*
POSL2    CLI   0(R2),C'='         TEST IF THIS WAS JUST A KEYWORD
         BE    KEYEQ              YES - JOIN KEYWORD ROUTINE
         CLI   0(R2),C','         TEST FOR VALID DELIMITER
         BE    POSL3              COMMA IS OK
         CLI   0(R2),C' '
         BE    POSL3              BLANK IS OK
         CLI   0(R2),C'$'         TREAT LIKE A-Z
         BE    POSL1B
         CLI   0(R2),C'#'         TREAT LIKE A-Z
         BE    POSL1B
         CLI   0(R2),C'@'         TREAT LIKE A-Z
         BE    POSL1B
         CLI   0(R2),C'-'         TREAT DASH LIKE COMMA
         BNE   KEYSYN
*
*  HAVE POSITIONAL PARAMETER BETWEEN (R1) AND (R2)-1.
*
POSL3    LR    R3,R2              ADDRESS OF DELIMITER
         SR    R3,R1              NO. OF LETTERS IN PARAM.
         SR    R3,R4              -1 FOR MOVE LENGTH FIELD
         BM    POSNEXT            BRANCH IF WAS OMITTED OPERAND
         CH    R3,=H'8'
         BNL   KEYSYN             ERROR IF TOO LONG
         L     R15,=A(KEYFLAG)    MAKE ADDRESSABLE               83013
         USING KEYFLAG,R15                                       83013
         XR    R14,R14
         IC    R14,POSTAB(R6)     GET I.D. NO. OF CORRESPONDING KEYWORD
         CH    R14,=X'00FF'       TEST FOR INHIBIT INDICATION
         BE    KEYEQ1             BRANCH IF POSITIONAL OP. NOT ALLOWED
         SLL   R14,2              * 4
         EX    0,KEYFLAG(R14)     SET F-FLAG FOR CORRESPONDING KEYWORD
         AR    R14,R14
         LA    R14,WTABLE(R14)    PLACE TO PUT OPERAND VALUE
         DROP  R15                                               83013
         MVC   0(8,R14),BLANKS
         SR    R14,R3             OFFSET TO RIGHT JUSTIFY
         EX    R3,POSMOVER        (MVC  7(0,R14),0(R1))
*
*  GO ON WITH NEXT PARAMETER OR EXIT
*
POSNEXT  CLI   0(R2),C' '         TEST IF END OF ALL PARAMS
         BE    KEYEXIT            YES, GET OUT
         BXH   R2,R4,KEYSYN       ERROR - COL. 72 ON POSITIONALS.
         AR    R6,R4              ADVANCE POSTAB POINTER
         STC   R6,WORKA           TEST (R6) < 4
         TM    WORKA,3
         BNZ   POSL1              GO FOR NEXT PARAM IF STILL SMALL
*                                 * ELSE ASSUME IS A KEYWORD.
*
CCB6     LR    R1,R2              SAVE ADDRESS OF FIRST LETTER
KEYL1    CLI   0(R2),C'A'
         BL    KEYEQ              BRANCH WHEN HAVE DELIMITER
         BXLE  R2,R4,KEYL1
         B     KEYSYN             ERROR - HIT COLUMN 72
*
KEYEQ    LR    R3,R2              ADDRESS OF THE '='
         SR    R3,R1              NO. OF LETTERS IN KEYWORD
         SR    R3,R4              -1 FOR MOVE
         BM    KEYSYN             ERROR IF NULL
         CH    R3,=H'8'
         BNL   KEYSYN             ERROR IF TOO LONG
KEYEQ1   MVC   WORKA,BLANKS
         EX    R3,CMDMOVE         FETCH THE KEYWORD
         L     R3,KEYTABA          GET KEYWORD TABLE            JRE0036
         LA    R14,10             INCREMENT
         L     R15,KEYTENDA        END OF KEYWORD TABLE         JRE0036
*
KEYLOOP  CLC   WORKA,0(R3)
         BE    KEYGOT             BRANCH WHEN KEYWORD VERIFIED
         BXLE  R3,R14,KEYLOOP
*
KEYSYN   ERROR '*** INVALID KEYWORD OR KEYWORD SYNTAX ***'
*
KEYGOT   L     R15,=A(KEYFLAG)    MAKE ADDRESSABLE               83013
         USING KEYFLAG,R15                                       83013
         LH    R1,8(,R3)          GET KEYWORD'S SEQUENCE NUMBER  83013
         SLL   R1,2
         EX    0,KEYFLAG(R1)      SET FLAG FOR THIS KEYWORD
         AR    R1,R1
         LA    R6,WTABLE(R1)      PLACE TO STORE KEYWORD 'VALUE'
         MVC   0(8,R6),BLANKS
         DROP  R15                                               83013
*
         CLI   0(R2),C'='         MUST HAVE PROPER DELIMITER
         BNE   KEYSYN
*
*  SCAN OVER KEYWORD VALUE AND FETCH IT TO WORK TABLE
*
         LR    R1,R2              SAVE ADDRESS OF '='
KEYLOOP2 CLI   1(R2),C'A'
         BL    K2END              BRANCH AT DELIMETER
KL2B     BXLE  R2,R4,KEYLOOP2
         B     KEYSYN             ERROR - REACHED COL. 72
*
K2END    CLI   1(R2),C'$'         TREAT LIKE A-Z
         BE    KL2B
         CLI   1(R2),C'#'         TREAT LIKE A-Z
         BE    KL2B
         CLI   1(R2),C'@'         TREAT LIKE A-Z
         BE    KL2B
         LR    R3,R2              ADDRESS OF LAST CHARACTER
         SR    R3,R1
         SR    R3,R4              LENGTH-1 FOR MOVE
         BM    KEYSYN
         CH    R3,=H'8'
         BNL   KEYSYN             VALUE TOO MANY CHARACTERS
         SR    R6,R3              OFFSET TO RIGHT JUSTIFY
         EX    R3,KEYMOVER
         AR    R2,R4              POINT TO DELIMITER
         B     KEYNEXT
*
*
*  THIS KEYWORD COMPLETE, GO ON TO NEXT OR EXIT.
*
KEYNEXT  CLI   0(R2),C' '
         BE    KEYEXIT            WE'RE DONE
         CLI   0(R2),C','
         BNE   KEYSYN             INVALID DELIMITER
         BXH   R2,R4,KEYCONT      COMMA IN 71.  IGNORE 72.
         CLI   0(R2),C' '
         BNE   CCB6               LOOP BACK FOR NEXT KEYWORD
*
*  CONTINUATION CARD SHOULD FOLLOW.  PRINT AND ANALYZE IT TOO.
*
KEYCONT  IF    LOADING,CMDE13     NO CONTINUATIONS WHILE LOADING      #
         GOSUB CTLREAD,BXH=KEY2NC  GET NEXT CARD; B ON EOF       82060
*
         LA    R2,CTLBUF+L'DOTSLASH
         ST    R2,KSCANPTR        SET ADDRESS FROM WHICH TO LOOK
         CLC   DOTSLASH,CTLBUF    TEST IF CONTROL CARD
         BE    KSCONT             GO DO CONTINUATION
*
KEY2NC   ERROR '*** EXPECTED CONTINUATION NOT RECEIVED ***',RC=4
*
KEYEXIT  EQU   *
*
*  NOW HAVE SCANNED ALL THE KEYWORDS, AND CAN PERFORM INDIVIDUAL
*  OPERATIONS BASED ON SPECIFIC SITUATIONS.
*  WE IMMEDIATELY SET UP THE FOLLOWING DEFAULTS, IF NECESSARY
*    1.  SEQ2 FROM SEQ1
*    2.  INCR BECOMES 1 (DEFAULT FROM 'PINCR' WHICH IS INITIALLY 1,
*        BUT IS MODIFIABLE VIA THE PARM COMMAND).
*    3.  NEW1 FROM SEQ1+INCR
*
*  TESTS ON THE VALIDITY OF USER SPECIFIED SEQ1 AND NEW1 FIELDS ARE
*  PERFORMED HERE.  EXTRA CHECKING (IN CASES OF EXACT EQUALITY) MUST
*  BE DEFERRED TO THE INDIVIDUAL COMMANDS WHICH DON'T ALLOW THIS CASE.
*  FOR EXAMPLE, SEQ1 = TO PREVIOUS OLD MASTER CARD NUMBER IS ALLOWED
*  FOR INSERTIONS, BUT NOT FOR DELETIONS.
*
*  TEST IF ANY SEQUENCE NUMBER TYPE KEYWORD ALLOWED WITH THIS COMMAND.
*  IF NONE IS, SKIP VERIFYING THEM.
*
         L     R1,CMDNUM          COMMAND NUMBER
         SLL   R1,2               *L'FKEYFLGS
         AL    R1,=A(FVALID)      TEST KEYWORD VALIDATION TABLE  83013
         CLI   FSEQ1-FKEYFLGS(R1),0                              83013
*                                 SEQ1, SEQ2, INCR, NEW1, OR     83013
*                                 INSERT ALLOWED ?               83013
         BE    NEW1GOT             NO  - NONE OF THEM ALLOWED    83013
*
         IF    ¬OMEOF,OMSOK       TEST IF OLD MASTER AT EOF
         ERROR '*** OLD MASTER AT END OF FILE ***',RC=4
OMSOK    EQU   *
         IF    FSEQ1,SEQ1SPEC
SEQ1SPCA MVC   SEQ1,=8C'0'        INITIALIZE SEQ1 IF OMITTED OR 'ALL'
         B     SEQ2FF
SEQ1SPEC LA    R1,WSEQ1           TEST SEQ1 VALID
         CLC   WSEQ1,=C'     ALL'
         BE    SEQ1SPCA
         GOSUB DECCHK
         MVC   SEQ1,WSEQ1
SEQ1GOT  EQU   *
*
         IF    FSEQ2,SEQ2SPEC
         MVC   SEQ2,SEQ1
         B     SEQ2GOT
SEQ2SPEC CLC   WSEQ2,=C'     END' IF SEQ2=END, SET IT HIGH.
         BNE   SEQ2CHK
SEQ2FF   MVI   SEQ2,X'FF'
         B     SEQ2GOT
SEQ2CHK  LA    R1,WSEQ2           TEST SEQ2 VALID
         GOSUB DECCHK
         MVC   SEQ2,WSEQ2
         IF    ¬FSEQ1,SEQ2GOT     IF SEQ1 SPECIFIED, MUST BE < SEQ2
         CLC   SEQ1,SEQ2
         BNH   SEQ2GOT            SEQ2 IS OK                          A
*  SEQ2 LOOKS BAD (LESS THAN SEQ1).  IF THE USER HAS SPECIFIED THE    A
*  SEQFIX PARM OPTION, WE WILL TRY TO SAVE HIM BY SUBSTITUTING        A
*  LEADING DIGITS OF SEQ1 FOR CORRESPONDING LEADING ZEROES OF SEQ2.   A
*  THIS WILL ALLOW, FOR EXAMPLE:   ./ D 105-6                         A
         IF    ¬SEQFIX,CMDE2                                          A
         LA    R1,SEQ1            SEQ1 POINTER                        A
         LA    R3,SEQ2            SEQ2 POINTER                        A
         LR    R14,R4             BXLE INCREMENT (1)                  A
         LA    R15,SEQ1+6         LIMIT                               A
SEQFLOOP CLI   0(R3),C'0'         TEST SEQ2 FOR LEADING ZEROES        A
         BNE   SEQFDONE                                               A
         MVC   0(1,R3),0(R1)      MERGE HIGH ORDER SEQ1 ONTO SEQ2     A
         AR    R3,R14                                                 A
         BXLE  R1,R14,SEQFLOOP                                        A
SEQFDONE CLC   SEQ1,SEQ2          SEE IF THAT FIXED IT UP             A
         BH    CMDE2
SEQ2GOT  EQU   *
*
         SP    NEW1,INCR          FOR POSSIBLE ./SEQUENCE             #
         IF    FINCR,INCRSPEC
         ZAP   INCR,PINCR         DEFAULT INCR
         B     INCRGOT
INCRSPEC LA    R1,WINCR           TEST INCR VALID
         GOSUB DECCHK
         PACK  INCR,WINCR
         ZAP   INCR,INCR     VALID ?                             82144
         BNZ   INCRGOT       YES                                 82144
         ERROR '*** INCR = 0 ; FORCE TO 1 ***',RC=4              82144
         MVI   INCR+L'INCR-1,X'1C'  SET TO 1 (ADDED FOR NIH WYL) 82144
INCRGOT  ZAP   INCR,INCR
         BZ    CMDE5              EVEN HSW WOULDN'T DO THAT
*
         CLI   CMDNUM+3,VCSEQ     TEST IF  ./ SEQUENCE COMMAND   82060
         BNE   NEW1CHK            NO - PROCEED NORMALLY
         AP    NEW1,INCR                                              #
         IF    ¬FNEW1,NEW1GOT     NEW1 OMITTED, RETAIN PREVIOUS
         LA    R1,WNEW1
         GOSUB DECCHK             TEST NEW1 FOR VALID DIGITS
         PACK  WORKA(5),WNEW1     USER'S NEW NEW1
         AP    WORKA(5),INCR                                          #
         CP    WORKA(5),NEW1      TEST AGAINST PREVIOUS NEW1 VALUE
         BH    NEW1OK                                                 #
         ERROR '*** NEW1 < PREVIOUS; IGNORED ***',RC=4                #
         B     NEW1GOT
NEW1OK   PACK  NEW1,WNEW1         SET NEW NEW1                        #
         B     NEW1GOT
*
NEW1CHK  EQU   *
         IF    FNEW1,NEW1SPEC
         PACK  NEW1,SEQ1          DEFAULT NEW1
         AP    NEW1,INCR
         B     NEW1GOT
NEW1SPEC LA    R1,WNEW1           TEST NEW1 VALID
         GOSUB DECCHK
         PACK  NEW1,WNEW1
         CLC   WNEW1,SEQ1         NEW1 MUST BE >= SEQ1
         BL    CMDE27
         CP    NEW1,=P'0'         NEW1 MUST BE GT ZERO                A
         BH    NEW1GOT                                                A
         ERROR '*** NEW1=0 NOT ALLOWED ***',RC=4                      A
         RESET FNEW1              PRETEND NEW1 NOT SPECIFIED          A
         B     NEW1CHK            AND GO TRY AGAIN                    A
NEW1GOT  EQU   *
*
         IF    ¬FVERSION,NOVERS   SKIP DECIMAL-CHECK IF UNSPECIFIED
         CLC   WVERSION,=C'    NEXT'
         BE    NOVERS             SKIP DECIMAL VALIDITY CHECK
         CLC   WVERSION,=C'    LAST'                             80308
         BE    NOVERS                                            80308
         LA    R1,WVERSION
         GOSUB DECCHK
NOVERS   IF    ¬FSSI,NOSSI                                       82060
         CLC   =C' DATE',WSSI+3  SSI=DATE ?                      82060
         BNE   NOSSI         NO                                  82060
         UNPK  WORKA(8),DATEWORD+1(4)  UNPACK DATE               82060
         TR    WORKA(7),HEXTAB-C'0'  LEAVE LEADING ZEROES        82060
         MVC   WSSI+1(7),WORKA   MAKE B00YYDDD                   82060
         MVI   WSSI,C'0'     MAKE LEADING ZERO                   82060
NOSSI    EQU   *                                                 82060
*
         IF    ¬FSEQ1,SEQ1NC
         CLC   SEQ1,OMSEQ         IF SEQ1 SPECIFIED, CHECK IT
         BL    CMDE3
SEQ1NC   EQU   *
*
*  HERE WE TEST THAT NO EXTRANEOUS KEYWORDS WERE FOUND ON THE
*  CONTROL CARD (E.G.   ./ INSERT SEQ1=10,NAME=HAHA)
*
*  THIS IS DONE BY FORMING A BIT STRING OF LENGTH EQUAL TO 'FKEYFLGS'
*  (WHICH IS THE STORAGE AREA CONTAINING THE 'KEYWORDS FOUND' FLAGS,
*  OR THE 'F-FLAGS,' AS THEY ARE OFTEN CALLED) CONTAINING ONE BITS NOT
*  ONLY FOR EACH KEYWORD FOUND, BUT SIMULTANEOUSLY FOR EACH KEYWORD
*  WHICH IS ALLOWED (FROM THE TABLE 'FVALID').
*  THIS RESULT WILL ONLY EQUAL THE STRING FOR ALLOWED KEYWORDS IF
*  NO ILLEGAL KEYWORDS WERE FOUND.
*
         L     R3,CMDNUM          SEQUENCE NUM. FOR THIS COMMAND 83013
         MH    R3,=AL2(L'FKEYFLGS)     COMPUTE OFFSET IN TABLE   83013
         AL    R3,=A(FVALID)      POINT TO MASK OF VALID KEYS    83013
         MVC   WORKF(L'FKEYFLGS),FKEYFLGS   KEYWORDS ACTUALLY FOUND
         OC    WORKF(L'FKEYFLGS),0(R3)      + KEYWORDS ALLOWED
         CLC   WORKF(L'FKEYFLGS),0(R3)      SHOULD = KEYWORDS ALLOWED
         BE    CMDBRAN
         ERROR '*** EXCESSIVE OPERAND(S) WILL BE IGNORED ***',RC=4
         NC    FKEYFLGS,0(R3)     ZERO INVALID F-FLAG BITS.
*
*  BRANCH TO SET UP FOR VARIOUS COMMANDS
*
CMDBRAN  L     R1,CMDNUM          GET COMMAND'S SEQUENCE NUMBER
         LA    R6,NMDATA          GETNAME/LJNAME REFERENCE SYSUT2 AREA
         SLL   R1,1          MAKE OFFSET TO OFFSET               82060
         LH    R1,CMDBTAB(R1)   GET OFFSET                       82060
         B     BBAS(R1)      BRANCH TO COMMAND HANDLING ROUTINES 82060
*                                                                     A
CMDBTAB  DC    2Y(SADD-BBAS)        ADD, REPLACE                 82060
         DC    Y(SCHANGE-BBAS)      CHANGE                       82060
         DC    Y(SENDUP-BBAS)       ENDUP                        82060
         DC    Y(SDROP-BBAS)        DROP                         82060
         DC    Y(SCURRENT-BBAS)     CURRENT                      82060
         DC    Y(SPARM-BBAS)        PARM                         82060
         DC    Y(SLIST-BBAS)        LIST                         82060
         DC    Y(SLOAD-BBAS)        LOAD                         82060
         DC    Y(SRENAME-BBAS)      RENAME                       82060
         DC    Y(SGENA-BBAS)        GENALIAS                     82060
         DC    Y(SRESTR-BBAS)       RESTORE                      82060
         DC    Y(SDELETE-BBAS)      DELETE                       82060
         DC    Y(SNUMBER-BBAS)      NUMBER                       82060
         DC    Y(SINSERT-BBAS)      INSERT                       82060
         DC    Y(SREPLACE-BBAS)     REPLACE                      82060
         DC    Y(SETSEQ-BBAS)       SEQUENCE                     82060
         DC    Y(SCOPY-BBAS)        COPY                         82060
         DC    Y(SALIAS-BBAS)       ALIAS                        82060
         DC    Y(SGANG-BBAS)        GANG                         82060
         DC    Y(SSCAN-BBAS)        SCAN                         82060
         DC    Y(SNOTE-BBAS)        NOTE    WILL NEVER HAPPEN    82060
         DC    Y(SMACRO-BBAS)       MACRO                        82060
         DC    Y(SFIX-BBAS)         FIX                          82060
         DC    Y(SUSER-BBAS)        USER                         82060
         DC    Y(SLOCATE-BBAS)      LOCATE                       82060
         DC    Y(SSCAN-BBAS)        COND. SCAN                   82060
         DC    Y(SFIX-BBAS)         COND. FIX                    82060
*
*
*  SET UP FOR ADD FUNCTION.
*
SADD     GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION
         SET   ADD                                               82060
         B     SCH1                                              82060
*
*  SET UP FOR CHANGE FUNCTION.
*
SCHANGE  GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION
         SET   CHANGE                                            82060
*        ADD/CHANGE COMMON CODE                                  82060
SCH1     IF    ¬FSSI,SCH2         SKIP IF SSI NOT SPECIFIED      82060
         CALLSUB SSIFETCH                                        82060
SCH2     IF    ¬SYSIN,SCH3        LIST OPTION ONLY VALID IN SYSIN
         IF    GLISTALL,SCHLA     TEST FOR PARM=LISTALL               A
         IF    ¬FLIST,SCH3        SKIP IF LIST= NOT SPECIFIED         A
         CLC   WLIST,=C'     ALL' TEST FOR LIST=ALL
         BE    SCHLA
         ERROR '*** INVALID LIST OPTION.  LIST=ALL ASSUMED ***',RC=4
SCHLA    SET   LISTALL
*  IF NEW1/INCR SPECIFIED ON CHANGE/ADD CARD, GIVE SEQUENCE ALL.
SCH3     IF    ¬FNEW1.¬FINCR,SCH4
         MVI   OMSEQ,C' '         PREVENT SUBSEQUENT SEQUENCE/NUMBER AL
         SET   SEQALL
         IF    ADD,SCH4                                               #
         RESET DECKQ              PARM=DECKQ NOT ALLOWED WITH SEQALL  A
         ZAP   INCRA,INCR         SET SPECIAL COUNTERS FOR ./CHANGE   #
         ZAP   NEW1A,NEW1         * RESEQUENCE OPERATION.             #
SCH4     IF    ¬FSEQID,SCH5       SKIP IF SEQID= NOT SPECIFIED
         IF    IDSEQ+REMID,SCH5   BLOCK BACKWARDS OVERLAY
         CLC   WSEQID+6(2),=C' 0' TEST FOR USER'S DESIRE TO REMOVE SEQ.
         BE    SCH43              * ID
         LA    R4,WSEQID          POINT TO SEQID WORK AREA
SCH41    CLI   0(R4),C' '         COUNT LEADING BLANKS (IS RIGHT JUST.)
         BNE   SCH42
         LA    R4,1(,R4)
         B     SCH41
*
SCH42    LA    R3,WSEQID+7
         SR    R3,R4              LENGTH-1 OF SEQID CHARS
         ST    R3,SEQIDLEN        SAVE IT
         EX    R3,SEQIDMV2        SAVE SEQID CHARS IN SEQIDA
         SET   IDSEQ              SO WON'T CHECK SYSUT1 AUTOMATICALLY
         RESET OMFIRST
         B     SCH5
SCH43    SET   REMID              PREVENT SYSUT1 SEQID FROM -> SYSUT2
SCH5     XPRSPACE PWA        MAKE LISTING PRETTIER               82060
         B     CMDSET                                            82060
*
*  SET UP FOR DELETE FUNCTION.
*
SDELETE  EQU   *                                                      A
         IF    ¬CHANGE,CMDE4
         IF    ¬FSEQ1,CMDE1
         CLC   SEQ1,OMSEQ         TEST SEQ1 NOT ALREADY WRITTEN OUT
         BNH   CMDE3
         SET   (DELETE,CTLWAIT)                                       A
         SET   XSEQ1              SET UNTIL SEQ1 FOUND IN OM
         CLI   SEQ2,X'FF'         TEST IF SEQ2=END
         BE    CMDSET             YES - WE'RE DONE
         SET   XSEQ2              NO - MUST VERIFY SEQ2 IN OM ALSO
         B     CMDSET
*
*
*  SET UP FOR NUMBER AND INSERT FUNCTIONS.
*
SINSERT  SET   FINSERT            FAKE INSERT=YES FOR ./ INSERT       A
SNUMBER  RESET LOCATE        CLEAR POSSIBLE PRIOR LOCATE FLAG    82102
SINSCOM  IF    ADD,SETSEQA        UNDER ADD, ALL NUMBERS ARE SEQ1=ALL
         IF    ¬FSEQ1,CMDE1
         IF    ¬CHANGE,CMDE4
         CLC   WSEQ1,=C'     ALL'
         BE    SETSEQ             FULL SEQUENCING                     #
         IF    FINSERT,XINSERT    INSERT=YES OPTION
         SET   (NUMBER,CTLWAIT)
         SET   (XSEQ1,XSEQ2)      WILL BE RESET WHEN LIMIT OM CARDS FND
         IF    FNEW1,CMDSET       DONE IF NEW1 SPECIFIED              H
         SP    NEW1,INCR          OTHERWISE, SET DEFAULT              H
         B     CMDSET
XINSERT  IF    ¬FNEW1,NEW1SKP     CHECK NEW1 VALID, IF WAS SPECIFIED.
         CLC   WNEW1,SEQ1         FOR INSERTIONS, NEW1 MUST BE > SEQ1
         BNH   CMDE27             IF WAS EQUAL, THIS BRANCHES TO ERROR
NEW1SKP  SET   (INSERT,NOINSERT,INSERT1)
         CLC   SEQ1,OMSQ          TEST AGAINST CURRENT O.M. CARD
         BNL   CMDSET             INSERTING AFTER IT - NO TROUBLE.
         CLC   SEQ1,OMSEQ         INSERTING AFTER PREVIOUS O.M. CARD -
         BE    CMDSET             * MUST GET SEQ1 RIGHT.
         ERROR '*** INCORRECTLY SPECIFIED SEQ1 VALUE ***',RC=4
         IF    FNEW1,CMDSET       SKIP IF NEW1 SPECIFIED DIRECTLY
         PACK  NEW1,SEQ1          ELSE GIVE BETTER DEFAULT
         B     CMDSET
*                                                                     A
*  THE 'LOCATE' COMMAND POSITIONS THE OLD MASTER, SOMEWHAT LIKE       A
*  AN INSERT OF ZERO CARDS.  IT IS IMPLEMENTED AS AN INSERT      82067
*  WITH THE 'NO CARDS INSERTED' MESSAGE SUPPRESSED               82067
*                                                                     A
SLOCATE  IF    ¬CHANGE,CMDE4                                          A
         SET   LOCATE        SET LOCATE IN ADDITION              82067
         SET   FINSERT       SET INSERT                          82102
         B     SINSCOM       TREAT AS AN INSERT OPERATION        82102
*
*  SET UP FOR REPLACE FUNCTION.
*
SREPLACE SET   (INSERT,NOINSERT)
         IF    FNEW1,SDELETE
         SP    NEW1,INCR
         B     SDELETE
*
*  SET UP FOR SEQUENCE FUNCTION (OR SEQUENCE OPTION FOUND ELSEWHERE).
*
SETSEQ   IF    INSERT,SETSEQI
         IF    ADD,SETSEQA
         CLI   OMSEQ,0            TEST IF ANY CARDS OUT TO N.M YET
         BNE   CMDE4              YES - ERROR
         ZAP   NEW1A,NEW1         SET TOTAL RESEQUENCE COUNTERS       #
         ZAP   INCRA,INCR                                             #
         RESET DECKQ              PARM=DECKQ NOT ALLOWED WITH SEQALL  A
SETSEQA  SET   SEQALL
SETSEQI  SET   INSERT1
         B     CMDSET
*
*  SET UP FOR 'CURRENT' AND 'DROP' COMMANDS.
*
SCURRENT IF    ¬CHAINING,CMDE16   DUMP HIM IF NOT CHAINING
SDROP    IF    ¬FVERSION,SDROP1
         CLI   WVERSION,C' '      TEST IF VERSION=NEXT
         BE    CMDE18             YES - ERROR
         USING NMDSECT,R6
SDROP1   IF    NMPS,CMDE17        ERROR IF SYSUT2 SEQUENTIAL
         GOSUB GETNAME            LEFT JUSTIFY NAME; CHECK FOR VERSION
         B     CMDSET
*
*  SETUP FOR 'RENAME' COMMAND.
*  ALSO SETUP FOR 'GENALIAS' COMMAND.                                 A
*
SGENA    EQU   *                                                      A
SRENAME  IF    ¬FNEWNAME,CMDE8    ERROR IF NEWNAME NOT SPECIFIED
         IF    NMPS+¬UT2AVAIL,CMDE24   SYSUT2 MUST BE OPEN PDS
         IF    CHAINING,CMDE26
         GOSUB LJNAME             GET 'NAME' TO BE CHANGED
         MVC   STOWRN,NAME        MOVE TO STOW AREA
         MVC   WNAME,WNEWNAME     SET UP NEWNAME FOR LJNAME ROUTINE
         GOSUB LJNAME
         MVC   STOWRN+8,NAME      MOVE NEW NAME TO STOW AREA
         B     CMDSET             THAT'S IT.
         SPACE 2                                                 82060
*        RESTORE COMMAND - (RE)CREATE A DIRECTORY ENTRY          82060
*        ./ RESTORE NAME TTR,INDC,SSI(DATA)                      82060
*          BLANK BETWEEN NAME AND TTR REQUIRED                   82060
*                                                                82060
SRESTR   IF    NMPS+¬UT2AVAIL,CMDE24  NEED OPEN PO SYSUT2        82060
         XC    STOWLIST,STOWLIST  CLEAR NEW DIRECTORY ENTRY      82060
         GOSUB LJNAME        FIX AND CHECK NAME                  82060
         MVC   STOWNAME,NAME  COPY NAME                          82060
         LA    R3,STOWTTR    POINT TO INTENDED OUTPUT AREA       82060
         BCTR  R2,0          BACKSPACE FOR END COLUMN CHECK      82060
SRESTRW  XR    R0,R0         CLEAR ACCUMULATOR                   82060
         LA    R1,8          SET NUMBER OF CHARACTERS IN WORD    82060
SRESTRL  BXH   R2,R4,SRESTRN  GET NEXT COLUMN OR OUT             82060
         CLI   0(R2),C' '    BLANK ?                             82060
         BE    SRESTRL       YES; IGNORE                         82060
         CLI   0(R2),C','    COMMA ?                             82060
         BE    SRESTRL       YES; IGNORE                         82060
         LA    R14,HEXTAB    POINT TO VALID HEX CHARACTERS       82060
         LA    R15,L'HEXTAB  AND NUMBER                          82060
SRESTRH  CLC   0(1,R2),0(R14)  MATCHING CHARACTER ?              82060
         BE    SRESTRF       YES; TACK IT IN                     82060
         LA    R14,1(,R14)   TRY AGAIN                           82060
         BCT   R15,SRESTRH                                       82060
SRESTE   ERROR '*** INVALID HEX TEXT SUPPLIED ***',RC=8          82060
SRESTRF  LA    R14,L'HEXTAB                                      82060
         SR    R14,R15       GET VALUE OF BYTE                   82060
         SLL   R0,4          MAKE ROOM FOR IT                    82060
         OR    R0,R14        ADD IT IN                           82060
         BCT   R1,SRESTRL    GET ANOTHER                         82060
         STCM  R0,15,0(R3)   STASH ONE WORD                      82060
         LA    R3,4(,R3)     POINT TO NEXT ONE                   82060
         B     SRESTRW       PREPARE FOR NEXT WORD               82060
SRESTRN  SLL   R1,2          CONVERT UNPROCESSED BYTES TO SHIFT COUNT
         SLL   R0,0(R1)      LEFT-ADJUST PARTIAL WORD            82060
         STCM  R0,15,0(R3)   STASH LAST WORD OR FRACTION         82060
         CLI   STOWTTR+2,0   ANY R IN TTR ?                      82060
         BE    SRESTRIV      NO; FAIL IT                         82060
         TM    STOWC,255-X'80'-X'1F'  NOTELIST FLAGS ON ?        82060
         BZ    CMDSET        NO; PROCESS                         82060
SRESTRIV ERROR '*** MEMBER TTR/INDC/DATA NOT VALID ***'          82060
         DROP  R6
*
*  SET UP FOR ALIAS COMMAND.
*
SALIAS   SET   INSERT1            IF RC=4 ERROR NEXT, WILL READ AGAIN
         IF    ¬CHANGE.¬ADD,CMDE4
         IF    ¬SYSIN,CMDE14      IGNORE ALIAS IF NOT IN SYSIN FILE
         MVC   WDUM2,NAME         SAVE MEMBER NAME                    A
         GOSUB LJNAME             LEFT JUSTIFY NAME
         IF    ¬CHAINING,SALIASN   OK IF NOT CHAINING            82060
         CLC   WDUM2,NAME    NAME MATCHES PRODUCTION ALIAS ?     82060
         BNE   CMDE15        NO; NOT PERMITTED                   82060
*        ALIAS OF PRODUCTION NAME PERMITTED WITH GRAVE DOUBTS    82060
SALIASN  IF    ALIAS,SALIASM      BRANCH IF NOT FIRST ./ALIAS    82060
         LA    R1,ANAME-L'ANAME   INITIALIZE ALIAS NAME LIST POINTER  A
         ST    R1,ALIASPTR                                            A
         SET   ALIAS              INDICATE ALIASES FOUND              A
SALIASM  L     R1,ALIASPTR                                            A
         LA    R1,L'ANAME(,R1)    PLACE TO SAVE ALIAS                 A
         LA    R0,ANAME+L'ANAME*MAXALIAS                              A
         CR    R1,R0              BE SURE NOT TOO MANY ALIASES        A
         BNL   SALIASE1                                               A
         MVC   0(L'ANAME,R1),NAME SAVE ALIAS NAME                     A
         ST    R1,ALIASPTR        AND CURRENT LIST ADDRESS            A
SALIASX  MVC   NAME,WDUM2         RESTORE MEMBER NAME                 A
         B     CMDSET
*                                                                     A
SALIASE1 ERROR '*** EXCESSIVE ALIAS CARDS ***',RC=4                   A
         B     SALIASX                                                A
*
*  SET UP FOR 'COPY' COMMAND.
*  ALSO USED FOR LIST AND MACRO COMMANDS BELOW.
*
SCOPY    IF    ADD,CPY1
         IF    ¬CHANGE,CMDE4
         IF    ¬INSERT,CMDE10
CPY1     IF    COPYING,CMDE11     USE OF SYSLIB MUST BE SERIAL
SLIST    EQU   *                  SETUP FOR ./LIST SAME AS FOR ./COPY
*  SET SEQUENCE LIMITS IF PARTIAL COPY REQUESTED
         XC    FROMSEQ,FROMSEQ    DEFAULT - COPY FROM BEGINNING
         MVI   TOSEQ,X'FF'        DEFAULT - COPY TO END OF FILE.
         IF    ¬FFROMSEQ,FSNS     SKIP IF FROMSEQ= NOT SPECIFIED
         SET   COPY1              INDICATE NEED TO CHECK SEQID
         LA    R1,WFROMSEQ
         GOSUB DECCHK             CHECK FROMSEQ FOR VALID DIGITS
         MVC   FROMSEQ,WFROMSEQ
         MVC   TOSEQ,FROMSEQ      DEFAULT TOSEQ TO FROMSEQ
         SET   XFROMSEQ           USED TO VERIFY THAT FROMSEQ EXISTS
FSNS     IF    ¬FTOSEQ,TSNS       SKIP IF TOSEQ= NOT SPECIFIED
         MVI   TOSEQ,X'FF'        IN CASE SEQ2=END                    #
         CLC   WTOSEQ,=C'     END'
         BE    TSNS
         SET   COPY1              INDICATE NEED TO CHECK SEQID
         LA    R1,WTOSEQ
         GOSUB DECCHK             CHECK TOSEQ FOR VALID DIGITS
         MVC   TOSEQ,WTOSEQ
         SET   XTOSEQ             VERIFY THAT TOSEQ EXISTS IN INPUT
TSNS     EQU   *
*
         IF    ¬FNAME,CMDE8       ERROR IF NO NAME SPECIFIED
         LR    R2,R9              SAVE CURRENT DSECT POINTER
         L     R9,LIBADR          SET DSECT REG TO SYSLIB
         MVC   FKEYFLGS,FKEYFLGS-LOCAL(R2)  BRING ALONG SOME FLAGS
         GOSUB LJNAME             FETCH NAME, LEFT JUSTIFIED
         MVC   BLDLNAME,NAME
*
*  IF USER'S DDNAME CHOICE HAS CHANGED (DEFAULT IS SYSLIB), WE CLOSE
*  THE LIBRARY DCB (IF NECESSARY) AND RE-OPEN IT WITH THE NEW DDNAME.
*
         IF    FDDNAME,DDNSPEC    BRANCH IF DDNAME= SPECIFIED
         MVC   NAME,LIBDD         DEFAULT DDNAME                      C
         B     DDNDEF
DDNSPEC  MVC   WNAME,WDDNAME
         GOSUB LJNAME             DDNAME MOVED LEFT JUSTIFIED TO (NAME)
DDNDEF   CLI   LEVNAME,C' '       TEST IF DCB PREVIOUSLY USED
         BE    CPYNCL             NO - SKIP CLOSING IT.
         BAL   R10,BUFCLN           WAIT ON ANY PENDING I/O           C
         CLC   LEVNAME,NAME       TEST IF DDNAME CHANGED
         BE    CPYBLDL            NO - LEAVE DCB OPEN AS IS.
         GOSUB CTLCLOSE           CLOSE FOR PREVIOUS DDNAME
CPYNCL   MVC   LEVNAME,NAME       STICK IN NEW DDNAME
         MVC   OBWORK(8),NAME
         DEVTYPE OBWORK,OBWORK+8  GET DEVICE TYPE; CHECK IF DD PRESENT
         BXH   R15,R15,CMDE25     BRANCH IF DD CARD NOT PRESENT  82060
         GOSUB CTLOPEN            IF CAN'T OPEN, WILL ABEND
*                                                                     H
CPYBLDL  IF    CTLPS,CMDE6        LIST/COPY LIB MUST BE PARTITIONED   H
         BLDL  LEVDCB,BLDLIST                                         H
         BXH   R15,R15,CMDE12     BE SURE NAMED MEMBER EXISTS    82060
         CLI   BLDLTTR+2,0
         BE    CMDE12
*  NOW HAVE PRODUCTION VERSION LOCATED.  TEST IF VERSION REQUESTED.
         IF    ¬FVERSION,CPY3     SKIP IF NO VERSION REQUEST
         NI    BLDLC,X'7F'        IGNORE ALIAS BIT IN DIRECTORY
         CLI   BLDLC,8            TEST IF MEMBER SUPPORTS VERSION
         BNL   CPY2
         CLC   WVERSION+5(3),=C'000'
         BE    CPY3               ACCEPT V=0 ONLY
         B     CMDE12
*
CPY2     LA    R3,BLDLUD          POINTER TO USER DATA
         USING DREC,R3
         CLC   BLDLNAME,REALNAME  VERIFY USER DATA VALID              #
         BNE   BADDREC            NO - BOMB.                          #
         MVC   BLDLNAME(2),LIBNAME     CONSTRUCT DESIRED VERSION'S NAME
         UNPK  BLDLNAME+2(3),MEMBID
         OI    BLDLNAME+4,C'0'
         MVC   BLDLNAME+5(3),WVERSION+5
         RESET FVERSION
         B     CPYBLDL            GO LOOK FOR FUNNY MEMBER
         DROP  R3
*
CPY3     FIND  LEVDCB,BLDLTTR,C
         RESET REALEOF            BECAUSE PREVIOUS COPY WILL HAVE SET
         LR    R9,R2              BACK TO ORIGINATING DSECT
         SET   (COPY,COPYING)
         B     CMDSET
*
*  SET UP FOR 'GANG' FUNCTION.
*
SGANG    IF    ¬CHANGE.¬ADD,CMDE4
         SET   INSERT1            SO CAN RECOVER FROM SEVERITY 4 ERRORS
         IF    ¬FCODE,SNOGANG     BRANCH IF CODE= OMITTED
         CLC   =C' DATE',WCODE+3  GANG=DATE REQUESTED ?          82060
         BNE   SGLS          NO; CHECK FOR SSI                   82060
         UNPK  WORKA(7),DATEWORD+1(4)  GET DATE                  82060
         TR    WORKA+1(5),HEXTAB-C'0'  MAKE EBCDIC               82060
         MVC   WCODE+3(5),WORKA+1  MOVE IT                       82060
         B     SGL0          AND PROCESS IT                      82060
SGLS     CLC   =C' SSI',WCODE+4   GANG=SSI REQUEST ?             82060
         BNE   SGL0          NO                                  82060
         CALLSUB DEFGANG     SET GANG FROM SSI                   82060
         IF    ¬GANG,CMDE21  ERROR IF SSI NOT AVAILABLE          82060
         IF    ¬FCOL,CMDSET  DONE IF COL NOT SPECIFIED           82060
         RESET GANG          ELSE MUST RESET FOR COL ERROR       82060
         L     R3,GANGLEN    RETRIEVE LENGTH                     82060
         B     SGCS          PROCESS COLUMN                      82060
SGL0     MVC   CODE,BLANKS                                       82060
*
         LA    R4,WCODE           POINT TO CODE DATA SPECIFIED
SGL1     CLI   0(R4),C' '         COUNT UP NUMBER OF BLANKS
         BNE   SGL2
         LA    R4,1(,R4)
         B     SGL1
*
SGL2     LA    R3,WCODE+7
         SR    R3,R4              LENGTH-1 OF USER'S CODE FIELD
         ST    R3,GANGLEN         SAVE FOR CCLOOK ROUTINE LATER
         LA    R2,7
         SR    R2,R3              NUMBER OF LEADING BLANKS IN WCODE
         EX    R3,CODEMOVE        MOVE CODE TO DSECT, LEFT ADJUSTED
         IF    FCOL,SGCS          BRANCH IF USER SPECIFIED COL=
*  DEFAULT TO COL=72-LENGTH(CODE)
         LA    R1,63(,R2)
         B     SGDONE
*  USER SPECIFIED COL=, SO CHECK IT OUT
SGCS     LA    R1,WCOL
         GOSUB DECCHK             VERIFY COL= GOOD DECIMAL DIGITS
         PACK  WORKA,WCOL
         CVB   R1,WORKA
         AR    R1,R3              ADD LENGTH(CODE)-1 TO COL.
         CH    R1,=H'80'          BE SURE IT FALLS ON THE CARD
         BH    CMDE20
         SR    R1,R3              RESTORE R1 TO 'COL'
         BCTR  R1,0               OFFSET IN A CARD BUFFER TO PUNCH TO
SGDONE   ST    R1,GANGCOL
         SET   GANG
         B     CMDSET
*  WE ARE HERE IF USER OMITTED CODE= TO RESET THE GANG FUNCTION
SNOGANG  RESET GANG
         IF    ¬GBLGANG,CMDSET  SKIP IF GLOBAL GANG OFF          82060
         IF    ¬SYSIN,CMDSET   SKIP IF NOT SYSIN LEVEL           82060
         CALLSUB DEFGANG     CHECK FOR GLOBAL GANG REQUEST       82060
         B     CMDSET
*
*  SET UP USER UPDATING EXIT ROUTINE.
*
SUSER    IF    ¬FNAME,CMDE8       MUST SPECIFY NAME OF USER ROUTINE
         IF    ¬CHANGE,CMDE4      MAIN FUNCTION MUST BE CHANGE
         IF    ¬FSEQ1,CMDE1       MUST SPECIFY SEQ1 (SEQ2 OPTIONAL)
         CLC   SEQ1,OMSEQ         BE SURE DESIRED CARD NOT ALREADY OUT
         BNH   CMDE3
         MVC   WORKA,NAME         SAVE MEMBER NAME FROM SUBROUTINE
         GOSUB LJNAME             GET USER ROUTINE NAME
         MVC   UNAME,NAME         STORE NAME OF USER ROUTINE IN DSECT
         MVC   NAME,WORKA         RESTORE MEMBER NAME
         SET   (USER,CTLWAIT)
         CLC   SEQ1,=8C'0'
         BE    *+8                SKIP CHECKING FOR SEQ1=0 OR ALL
         SET   XSEQ1
         CLI   SEQ2,X'FF'
         BE    *+8                SKIP CHECKING FOR SEQ2=END
         SET   XSEQ2
         XC    USERWORK(4),USERWORK  ZERO FIRST WORD OF WORK AREA
         MVC   USERCODE,BLANKS    SET OPTIONAL CODE= INFORMATION.
         IF    ¬FCODE,CMDSET
         MVC   USERCODE,WCODE
         B     CMDSET
*
*  SET UP FOR 'LOAD' COMMAND.
*
         USING NMDSECT,R6
SLOAD    IF    ¬UT2AVAIL+NMPS,CMDE24
         B     CMDSET
         DROP  R6
*
*
*  SET UP FOR 'SCAN' AND 'FIX' COMMANDS.
*
*   ROUTINE TO CHECK A ./ FIX OR ./ SCAN CARD AND BUILD AN FCB
*   (FIX CONTROL BLOCK) FOR IT
*  AT THIS POINT, R2 POINTS TO THE BLANK FOLLOWING THE SEQ1-SEQ2 INFO
*  ON THE CONTROL CARD, R4 CONTAINS A ONE, AND R5 CONTAINS THE ADDRESS
*  OF THE END OF THE USABLE PART OF THE CONTROL CARD (FOR BXLE).
*
         USING FCB,R6
SFIX     EQU   *
SSCAN    IF    ¬FSEQ1,CMDE1       MUST SPECIFY SEQ1
         IF    ¬CHANGE,CMDE4      FUNCTION MUST BE CHANGE
         CLC   SEQ1,OMSQ          TEST SEQ1 AGAINST CURRENT OM CARD
         BNL   SSCANOK            IF .GE. CAN'T POSSIBLY BE WRONG
         CLI   OMSEQ,0            IF NO OM CARDS TO SYSUT2 YET, STILL
         BNE   CMDE3              * OK
         CLC   SEQ1,=8C'0'        * PROVIDED THAT SEQ1=0 OR SEQ1=ALL
         BNE   CMDE3
SSCANOK  SET   INSERT1            SO ./SCAN CARD IS READ OVER NEXT
*
*  CHECK FOR COL1= AND COL2= SPECIFIED ON THE CONTROL CARD.
*
         XR    R3,R3              DEFAULT COL1=1
         IF    ¬FCOL1,COL1NS      STICK WITH DEFAULT IF NO COL1 SPEC.
         LA    R1,WCOL1           POINT TO COL1 SPECIFIED VALUE
         GOSUB DECCHK             BE SURE IS VALID DECIMAL NUMBER
         PACK  WORKA,WCOL1
         CVB   R3,WORKA           COL1 CONVERTED TO BINARY
         CH    R3,=H'72'          BE SURE IS NOT OFF THE CARD
         BH    CMDE23
         SR    R3,R4              SUBTRACT 1 FOR LATER
COL1NS   STH   R3,COL1            SAVE COL1 VALUE
*
         LA    R3,70              DEFAULT COL2=71
         IF    ¬FCOL2,COL2NS      STICK WITH DEFAULT IF NO COL2 SPEC.
         LA    R1,WCOL2           POINT TO COL2 SPECIFIED VALUE
         GOSUB DECCHK             BE SURE IS VALID DECIMAL NUMBER
         PACK  WORKA,WCOL2
         CVB   R3,WORKA           COL2 CONVERTED TO BINARY
         CH    R3,=H'72'          BE SURE IS NOT OFF THE CARD
         BH    CMDE23
         SR    R3,R4              SUBTRACT 1 FOR LATER
COL2NS   STH   R3,COL2            SAVE COL2 VALUE
*
SSLOOP   CLI   0(R2),C' '         GOOD CHARACTER ?
         BNE   SSGOOD             YES -- GO DO EVALUATION
         BXLE  R2,R4,SSLOOP       NO -- GO BACK FOR ANOTHER
         B     CMDE22             PAST CARD BOUNDRY -- ERROR
SSGOOD   MVC   SSCTL(1),0(R2)     MOVE IN THE CONTROL CHARACTER
         GETMAIN   R,LV=FCBLEN,SP=3    GET STORAGE FOR THE FCB
         SET   ANYFCB             FOR OUTSIDE FREEMAIN LOGIC
*
*   CHAIN THE FCB'S
         SPACE 1                                                 80301
         ICM   R3,15,LCLFCBAD     ADDRESS OF THE FIRST FCB ?     80301
         BNZ   SSSTORE            NOT FIRST - CHAIN              80301
         ST    R1,LCLFCBAD        FIRST ONE -- STORE ADDRESS
         B     SSMORE             LEAVE TO DO BETTER THINGS
SSSTORE  LR    R6,R3
         L     R3,FCBNADR         ADDRESS OF NEXT FCB OR ZERO (NO NEXT)
         LA    R0,0(,R3)          STRIP AWAY HIGH-ORDER BYTE (FLAGS)
         LTR   R0,R0
         BNZ   SSSTORE            YES -- REPEAT
         OR    R1,R3              SAVE THE FLAG BYTE (FIX)
         ST    R1,FCBNADR         NO NEXT -- NOW THERE IS
SSMORE   LR    R6,R1              ADDRESSABILITY
         XC    FCB(FCBLEN),FCB    INITIALIZE                          A
         CLI   CMDNUM+3,VCFIX     TEST FOR SCAN (INSTEAD OF FIX) 82060
         BE    SSMOREF       SET FOR FIX                         82060
         CLI   CMDNUM+3,VCCFIX    CFIX ?                         82060
         BNE   *+8                IT IS SCAN OR CSCAN; BRANCH    82060
SSMOREF  SET   FIX                FIX OR CFIX - SET BIT IN THE FCB
*        SET FIX USED TO PREVENT 'NOT APPLIED' ERRORS IF REQUEST 82060
         SET   FIXUSED       * CONTAINS INVALID PARAMETERS       82060
         LA    R15,FCBLENB        GET SET FOR SUBROUTINE
         LA    R14,FCBBAD         ADDRESS OF WHERE BAD GOES
         BAL   R10,SSPUT          GO GET BAD STUFF
         BM    CMDE22             ERROR IF STRING WAS NULL
         LA    R15,FCBLENG        LENGTH OF GOOD STUFF
         LA    R14,FCBGOOD        WHERE TO PUT GOOD STUFF
         BAL   R10,SSPUT          GO GET GOOD
         BXH   R2,R4,SSNMORE   SKIP IF LAST CARD COLUMN          82060
         CLI   0(R2),C' '    TRAILING BLANK AFTER ?              82060
         BNE   CMDE22        NO; BAD SPECIFICATION               82060
SSNMORE  MVC   FCBCOL1,COL1       PUT COL1 VALUE INTO FCB        82060
         LH    R1,COL2
         STH   R1,FCBCOL2         PUT COL2 VALUE INTO THE FCB
         SH    R1,FCBLENB         COL2-LENGTH(BAD_STRING)
         CH    R1,FCBCOL1         * MUST BE .GE. COL1
         BL    CMDE23
         MVC   FCBSEQ1,SEQ1       MOVE SEQ1 INTO THE FCB              A
         MVC   FCBSEQ2,SEQ2       MOVE SEQ2 INTO THE FCB              A
         RESET FIXUSED       PAST ERROR EXITS; RESET FLAG        82060
         CLI   CMDNUM+3,VCCSCAN  CONDITIONAL SCAN/FIX ?          82060
         BL    CMDSET        NO                                  82060
         SET   FIXCOND       PREVENT ERROR IF NOT MATCHED        82060
         B     CMDSET             NORMAL RETURN
*
SSCTL    DS    C                  CONTROL CHARACTER FOR BAD/GOOD SCAN
*
*   ROUTINE TO PUT TEXT INTO FCB
*   CALLED BY
*        R14 -> PLACE TO PUT TEXT  (32 CHARACTERS MAX)
*        R15 -> PLACE TO PUT LENGTH OF TEXT  (HALFWORD ON HW BOUNDRY)
*
SSPUT    XR    R1,R1              CLEAR FOR ACTION
         AR    R2,R4              MOVE PAST CONTROL CHARACTER
SSLUP    CLC   0(1,R2),SSCTL      CHECK FOR END OF TEXT
         BE    SSDONE             GOT IT -- WE'RE FINISHED
         CH    R1,=AL2(L'FCBBAD)  ARE WE PAST MAX LENGTH (32) ?
         BNL   CMDE22             YES -- ERROR RETURN
         MVC   0(1,R14),0(R2)     MOVE IN ONE CHARACTER OF TEXT
         AR    R1,R4              INCR.
         AR    R14,R4             DITTO
         BXLE  R2,R4,SSLUP        BACK FOR MORE
         B     CMDE22             ERROR -- PAST CARD BOUNDRY
*
SSDONE   SR    R1,R4              WILL BE NEGATIVE IF TEXT WAS NULL
         STH   R1,0(,R15)         STORE LENGTH IN FCB
         BR    R10                RETURN
*
         DROP  R6
*
*  SET UP FOR 'MACRO' COMMAND.
*
SMACRO   IF    ¬SYSIN,NOMACS      MACRO COMMAND IS A NO-OP UNLESS SYSIN
         SET   MACRO
         B     CPY1               LET COPY SETUP DO THE BLDL ETC.
NOMACS   SET   INSERT1            SO ./MACRO CARD IS BURIED
         B     CMDSET
*
*  SET UP FOR 'NOTE' COMMAND.
*
SNOTE    SET   INSERT1            SO CARD IS OVERLAID IMMEDIATELY
         B     CMDSET
*
*  SET UP FOR 'ENDUP' COMMAND.
*
SENDUP   SET   (CTLEOF,REALEOF)
*
*  LEAVE AFTER COMMAND HAS BEEN SET UP.
*
SPARM    EQU   *
CMDSET   ENDSB KEYSAV,RC=0
*
*  COMMAND ERROR MESSAGES
*
CMDE1    ERROR '*** SEQ1 NOT SPECIFIED ***'
CMDE2    ERROR '*** SEQ1 > SEQ2 ***'
CMDE3    ERROR '*** SEQ1 < CURRENT OLD MASTER ***'
CMDE4    ERROR '*** DETAIL FUNCTION NOT ALLOWED HERE ***'
CMDE5    ERROR '*** INCR = 0 ***',RC=12
CMDE6    ERROR '*** LIBRARY NOT PARTITIONED ***'
CMDE7    ERROR '*** INVALID DECIMAL FIELD ***'
CMDE8    ERROR '*** NAME REQUIRED ***'
CMDE10   ERROR '*** COPY UNDER CHANGE REQUIRES INSERT ***'
CMDE11   ERROR '*** COPY INTERLOCK ***'
CMDE12   ERROR '*** NAME NOT FOUND IN LIBRARY ***'
CMDE13   ERROR '*** NO CONTINUATIONS WHILE LOADING***'                #
CMDE14   ERROR '*** ALIAS IGNORED (NOT SYSIN) ***',RC=4
         B     CMDSET
CMDE15   ERROR '*** ALIAS INHIBITED WHILE CHAINING ***',RC=4
         B     CMDSET
CMDE16   ERROR '*** VALID ONLY WHEN CHAINING ***'
CMDE17   ERROR '*** NEW MASTER NOT PARTITIONED ***'
CMDE18   ERROR '*** VERSION=NEXT ALLOWED ONLY FOR ADD/CHANGE ***'
CMDE19   ERROR '*** CODE NOT SPECIFIED ***',RC=4
         B     CMDSET
CMDE20   ERROR '*** COL IS TOO LARGE ***',RC=4
         B     CMDSET
CMDE21   ERROR '*** SSI NOT AVAILABLE ***',RC=4                  82060
         B     CMDSET                                            82060
CMDE22   ERROR '*** IMPROPER SCAN DATA ***'
CMDE23   ERROR '*** INVALID COLUMN RANGE ***'
CMDE24   ERROR '*** IMPROPER OR MISSING SYSUT2 ***',RC=12
CMDE25   MVI   LEVNAME,C' '       INDICATE DD NOT OPEN                H
    ERROR '*** NECESSARY SYSLIBDD DD CARD NOT FOUND ***',(14,OBWORK,8)
CMDE26   ERROR '*** NOT ALLOWED WITH CHAINING ***'
CMDE27   ERROR '*** NEW1 <= SEQ1 ***',RC=4                            #
         RESET FNEW1              ARRANGE TO USE DEFAULT INSTEAD      #
         B     NEW1CHK                                                #
CMDE28   ERROR '*** LINECNT OUT OF RANGE'                        83014
         SPACE 1
*  SUBROUTINE TO SET UP 'INSERT AFTERMATH'
*
INSTERM  RESET INSERT
         IF    ¬NOINSERT,CCIA2    BRANCH IF INSERT DID SOME WORK
         IF    LOCATE,INSTERML   NO MESSAGE IF LOCATE            82067
         ERROR '*** NO RECORDS INSERTED ***',RC=4
INSTERML RESET (NOINSERT,LOCATE)                                 82067
         BR    R10                NO AFTERMATH, SINCE NO INSERTIONS
CCIA2    RESET LOCATE        RESET POSSIBLE LOCATE FLAG          82067
         IF    INSERTX,CCIA1      IF PREVIOUS 'AFTERMATH' LEAVE  82067
         SET   INSERTX            INSERT AFTERMATH
         ZAP   XINCR,INCR         SAVE FOR INSERT AFTERMATH
         ZAP   XNEW1,NEW1
         SP    XNEW1,XINCR        BACK OFF XNEW1 FOR AFTERMATH CHECK  A
CCIA1    BR    R10                RETURN
*
*  THE DECCHK ROUTINE EXAMINES THE 8 BYTE FIELD POINTED TO BY R1
*  TO ENSURE THAT ONLY LEADING BLANKS AND VALID DECIMAL DIGITS ARE
*  PRESENT.  THE LEADING BLANKS, IF ANY, ARE REPLACED BY ZEROS.
*  ALSO, A TRAILING 'K' IS CHECKED FOR AND REPLACED BY 3 ZEROS.
*
DECCHK   BGNSB DCSV,EQU=LOGSAVE
         CLI   7(R1),C'K'         TEST FOR K (THOUSANDS) ABBREVIATION
         BNE   DECNOK             SKIP IF JUST NORMAL DECIMAL NUMBER
         CLC   0(2,R1),BLANKS     BE SURE LOTS OF LEADING SPACES
         BNE   DECERR             IF NOT, COMPLAIN.
         CLI   6(R1),C' '         BE SURE NOT JUST 'INCR=K'
         BE    DECERR
         MVC   0(5,R1),2(R1)      SHIFT IT LEFT
         MVC   5(3,R1),=C'000'    ATTACH TRAILING ZEROS
DECNOK   EQU   *
         LR    R2,R1              POINTER
         LA    R4,1               INCREMENT
         LA    R5,7(,R1)          LIMIT
*
DCLOOP   CLI   0(R2),C' '         SCAN LEADING BLANKS
         BNE   DC1
         MVI   0(R2),C'0'         REPLACE THEM WITH ZEROS
         BXLE  R2,R4,DCLOOP
         MVC   0(8,R1),BLANKS     RESTORE FOR ERROR PRINT
         B     DECERR
*
DC1      MVZ   WORKD,0(R1)        FETCH ZONES OF SUBJECT FIELD
         CLC   WORKD,=8C'0'       ALL MUST BE 'F'
         BNE   DECERR             ERROR IF NOT
         ENDSB DCSV
*
DECERR   LA    R2,CTLSQ           ERROR - INVALID DECIMAL FIELD
         CR    R1,R2              TEST IF WAS CHANGE DATA RECORD
         BNE   CMDE7              NO - GO GIVE MESSAGE
         LA    R6,CTLAREA
         XPRADR PWA,TEXT=(R6)   YES - PRINT BAD CARD             82060
         B     CMDE7              * AND THEN GIVE ERROR MESSAGE
*
         TITLE 'POSITION A CONTROL DATA SET'
*  THIS ROUTINE POSITIONS THE CURRENT CONTROL DATA SET TO THE MEMBER
*  NAME IN (GMEMB) (MEMBER NAMES COME FROM SYSIN), AND ANALYZES THE
*  FIRST CONTROL FUNCTION (SHOULD BE ADD OR CHANGE TYPE)
*  NOTE - IF THE MEMBER (OR SDS) DOESN'T BEGIN WITH A CONTROL CARD,
*  IT IS FLUSHED UNTIL IT FINDS SOMETHING IT LIKES (UNLESS IS SYSUT1)
*  NO RETURN CODE SET.
*
POSITION BGNSB POSSAVE
POSTC    IF    ¬TEMPUPD,NOFREETU  SKIP IF NORMAL UPDATE LEVEL
*
*  HAVE ENCOUNTERED A TEMPORARY UPDATE LEVEL.  THESE ARE CREATED
*  TO ALLOW AN AUTOMATIC CHAINED MEMBER UPDATE (I.E. SEVERAL
*  INTERMEDIATE UPDATES FROM A SINGLE PDS AUTOMATICALLY), AND MUST
*  BE DELETED FROM THE UPDATE CONTROL STRUCTURE BEFORE STARTING
*  THE NEXT UPDATE.
*  NOTE:  R9 -> LEVEL BEING FREED, R2 -> PREVIOUS LEVEL.
*
         L     R3,NEXTLEV        GET LEVEL FOLLOWING THE TEMP.
         ST    R3,NEXTLEV-LOCAL(,R2)   FIX PREV'S CHAIN POINTER
         GOSUB CTLCLOSE           TERMINATE THE TEMP (FREE BUFFER)
         LR    R1,R9              ADDRESS OF TEMP. LEVEL
         FREEMAIN R,A=(1),LV=LOCALSZ,SP=2
         LR    R9,R3              RESTART NOW THAT TEMP. REMOVED
         B     POSTC
NOFREETU EQU   *
*
         IF    ¬CHAINED,SKIPUC    SKIP UNLESS WAS MAIN CHAINED UPDATE
*
*  HERE WE HAVE THE PERMANENT ENTRY WHICH CREATED TEMPORARIES
*  LAST TIME AROUND.
*
         RESET CHAINED
         ST    R9,POSSAVE+28      *** FIX CALLER'S R9 ***            LB
SKIPUC   EQU   *
*
         IF    CTLPS,PSFIND       BRANCH FOR SEQUENTIAL ORG.
*
*  DSORG=PO.  USE BLDL-FIND TO LOCATE THE MEMBER.
*  IF THE MEMBER WAS INTERRUPTED BY AN ERROR, AND THIS LEVEL IS BEING
*  DOUBLE BUFFERED, WE MUST ISSUE A CHECK HERE TO CLEAN UP THE I/O.
*
         BAL   R10,BUFCLN                                             C
*
         CLC   GMEMB,BLANKS       TEST IF ANY MEMBER NAME
         BE    POSE1              ERROR OF SORTS.  JUST CANCEL THIS FIL
*
         RESET (CTLEOF,REALEOF)
         MVC   BLDLNAME,GMEMB     SET UP FOR BLDL
         BLDL  LEVDCB,BLDLIST     SEARCH DIRECTORY FOR MEMBER
         BXH   R15,R15,POSE1      COULD NOT BLDL                 82060
         CLI   BLDLTTR+2,0        CHECK IF MEMBER FOUND
         BNE   POSOK1             YES - BRANCH
*
*  MEMBER NOT FOUND - SET THIS LEVEL ON 'EOF' TO DISABLE IT.
*
POSE1    XC    CMDFLGS,CMDFLGS    KILL ALL FUNCTIONS OF PREVIOUS UPD.
         XC    LCLFCBAD,LCLFCBAD
         XC    OMSEQ,OMSEQ
         SET   (CTLEOF,CHANGE)
         B     POSDONEX           RETURN
*
POSOK1   FIND  LEVDCB,BLDLTTR,C
         RESET CHANGE             IN CASE SYSUT1 WAS 'HELD' BEFORE
*
*  DSORG=PS. SCAN FOR REQUIRED UPDATE DECK.
*
PSFIND   IF    SYSUT1,POSDONEX    DON'T LOOK FOR CHANGE/ADD IN SYSUT1 V
         IF    REALEOF,POSE1      DISABLE COMPLETED INTERMEDIATE FILE
         IF    CHAINUPD,POSBUILD  BRANCH IF USER MAY HAVE CHAINED UPD
         IF    CTLEOF,POSCHK      SKIP INITIAL READ IF ON CTL CARD NOW
         SET   POSING             SET FLAG FOR ERROR ROUTINE
*
*  NOTE - PSFLOOP IS BRANCHED TO DIRECTLY FROM THE ERROR ROUTINE IF
*  THE 'POSING' FLAG IS ON (MEANS ERROR WHILE POSITIONING, WHICH WE
*  WILL JUST CONTINUE TO DO).
*
PSFLOOP  GOSUB CTLREAD,BXH=POSE1  READ A CARD; EXIT ON EOF       82060
         GOSUB CCLOOK             GO CHECK FOR CONTROL CARD
         CH    R15,=H'4'
         BNH   PSFLOOP
         CLI   CMDNUM+3,VCCHANGE  STOP ONLY FOR CHANGE/ADD       82060
         BH    PSFLOOP
*
POSCHND  EQU   *                  MERGE HERE FROM BUILDING TEMP UPDS
POSCHK   XC    USERWORK,USERWORK  ZERO WORK FIELD FOR USER ROUTINES
         MVC   OMSQ,=8C'0'        CURRENT O.M. SEQ. NO. SET LOW
         IF    HELD,SKIPKS        IF WAS PREVIOUSLY SCANNED, SKIP
         XC    CMDFLGS,CMDFLGS    RESET ALL COMMAND FLAGS
         XC    LCLFCBAD,LCLFCBAD  ZERO SCAN CHAIN POINTER IN DSECT
         ZAP   INCR,PINCR         FOR POSSIBLE ./ SEQUENCE            #
         ZAP   NEW1,PINCR         FOR POSSIBLE ./ SEQUENCE            #
         GOSUB KEYSCAN            GET KEYWORDS FOR IT
SKIPKS   EQU   *
         CLC   GMEMB,NAME
         BNE   PSFE2              BRANCH IF NAMES DIDN'T MATCH
         RESET (CTLEOF,HELD)
         RESET (OMEOF,CTLWAIT)    IN CASE WAS 'HELD' UPDATE DECK
         XC    OMSEQ,OMSEQ        RESET PREVIOUS OM SEQUENCE NO.
POSDONE  RESET POSING
         IF    REALEOF.(¬CTLPS),POSPDSE1  LOOK FOR ERROR              A
         B     POSDONEX           RETURN
*
*  CONTROL CARD DIDN'T SPECIFY NAME WE WANTED
*
PSFE2    ERROR '*** MOD FOR "XXXXXXXX" ON DDNAMEIN IS BEING HELD ***', *
               (13,NAME,8),(26,LEVNAME),ID=NO,RC=0               82060
         SET   (CTLEOF,HELD)
POSDONEX ENDSB POSSAVE
*
*  POSITIONING ERROR - EITHER
*   1.  OLD MASTER IS AT END OF FILE AND CAN NOT BE FURTHER UPDATED
*   2.  WE FLUSHED AN INTERMEDIATE UPDATE IN A PDS LOOKING FOR
*       A ./ CHANGE OR ./ ADD COMMAND.
*
POSPDSE1 ERROR '*** NO DATA (OR NO CHANGE/ADD CARD) FOUND ***',RC=12
*                                                                     C
*                                                                     C
*  CLEAN UP ANY PENDING I/O ON AN INPUT PDS                           C
*                                                                     C
BUFCLN   STM   R2,R3,WORKA                                            C
         LA    R2,BUFC3           SET EODAD DURING THIS ROUTINE       C
         ST    R2,DCBEODAD-IHADCB+LEVDCB                              C
         L     R3,BUFADR          ADDRESS CURRENT INPUT BUFFER        C
*                                                                     C
         USING BUFDSECT,R3                                            C
BUFC1    L     R3,BUFCHAIN        CHAIN FOWARDS                       C
         CLI   BUFSTAT,0          TEST IF CHECK REQUIRED              C
         BE    BUFC2              NO - EXIT                           C
         MVI   BUFSTAT,0          YES - RESET I/O ACTIVE FLAG         C
         IF    REALEOF,BUFC1      SKIP CHECK AFTER EOF                C
         CHECK BUFDECB                                                C
         B     BUFC1              GO FOR NEXT BUFFER                  C
*                                                                     C
BUFC2    LA    R2,CTLEOD          RESET EODAD                         C
         ST    R2,DCBEODAD-IHADCB+LEVDCB                              C
         SET   BUFEMPTY                                               C
         LM    R2,R3,WORKA                                            C
         BR    R10                RETURN                              C
*                                                                     C
BUFC3    SET   REALEOF            INDICATE PHYSICAL EOF REACHED       C
         B     BUFC1              CONTINUE RESETING BUFSTAT           C
         DROP  R3                                                     C
         TITLE 'POSITION A CONTROL DATA SET - CHAINED UPDATING'
*  HERE IF USER ALLOWS CHAINED UPDATE DECKS IN A PDS.
*
*  THIS ROUTINE CONSTRUCTS AS MANY TEMPORARY LEVELS AS NESESSARY
*  AND CHAINS THEM INTO THE EXISTING UPDATE CONTROL STRUCTURE.
*  THE PREVIOUS LEVEL IN THE STRUCTURE IS POINTED TO BY R2 AT ENTRY.
*  NEW LEVELS ARE INSERTED AT THIS POINT IN THE CHAIN, WITH VERSION
*  NUMBERS DECREASING TO THE LOWEST EXISTING, WHICH WILL USE THE
*  PERMANENT LEVEL.
*  THE CHAIN POINTER IN THE PERMANENT LEVEL ABOVE US IS SET TO POINT
*  TO THE FIRST TEMPORARY (HIGHEST VERSION).
*
POSBUILD NI    BLDLC,X'7F'        CLEAR ALIAS BIT
         CLI   BLDLC,DRECSIZE/2   LOTS OF USER DATA?
         BL    PSFLOOP            NO - CAN'T BE CHAINED MEMBER
*
         MVC   PRODTTR,BLDLTTR    SAVE TTR OF PRODUCTION VERSION
         ST    R2,WORKP1          SAVE ADDRESS OF LEVEL ABOVE US
         LA    R6,BLDLUD          TO ADDRESS USER DATA (PDS DIRECTORY)
         USING DREC,R6
         ZAP   WORKA,MEMVER       GET HIGH VERSION NUMBER
         CVB   R3,WORKA           *  INTO R3
         MVC   WORKA(2),LIBNAME   CONSTRUCT PATTERN MEMBER NAME
         UNPK  WORKA+2(3),MEMBID
         OI    WORKA+4,C'0'
         DROP  R6
*
*  GET STORAGE TO CONSTRUCT BLDL LIST.
*
         LA    R2,14              BLDL ENTRY SIZE
         LA    R3,1(,R3)          NUMBER OF ENTRIES TO BLDL FOR
         LR    R5,R3              COPY FOR MULTIPLY
         MR    R4,R2              SPACE REQUIRED FOR BLDL ENTRIES
         LA    R0,4(,R5)          PLUS 4 BYTES FOR BLDL HEADER
         ST    R0,BLDLFA          SAVE FOR SUBSEQUENT FREEMAIN
         GETMAIN R,LV=(0)         GET STORAGE FOR BLDL LIST
         ST    R1,BLDLFA+4        SAVE FOR SUBSEQUENT FREEMAIN
         STH   R3,0(,R1)          SET NUMBER OF ENTRIES
         STH   R2,2(,R1)          SET LENGTH OF EACH
         LR    R6,R1              SAVE ADDRESS OF BLDL LIST IN R6
*
*  LOOP TO FILL IN BLDL LIST WITH MEMBER NAMES FOR ALL POSSIBLE
*  VERSIONS, AND ISSUE THE BLDL.
*
         LA    R3,4(R5,R1)        LIMIT ADDRESS FOR BXLE
         SR    R3,R2
         ZAP   LEVCTR,=P'0'       VERSION NUMBER TO START FROM
POSFILL  UNPK  WORKA+5(3),LEVCTR SET VERSION NUMBER IN MEMBER NAME
         OI    WORKA+7,C'0'
         MVC   4(8,R1),WORKA MOVE MEMBER NAME INTO LIST
         AP    LEVCTR,=P'1'       STEP VERSION NUMBER
         BXLE  R1,R2,POSFILL      CONTINUE UNTIL LIST COMPLETED
*
         BLDL  LEVDCB,(R6)        O.S. SEARCHES DIRECTORY FOR US
*
*  SCAN BLDL LIST UP FROM VERSION ZERO TO FIND FIRST EXISTING
*  MEMBER (REALLY SHOULD ALWAYS BE THE FIRST ONE IN LIST).
*  ALLOCATE THE PERMANENT LEVEL TO THIS UPDATE.
*
         SETEXIT POSCHNE                                              A
         LA    R4,4(,R6)          SET LIST POINTER
POSCHNL  CLI   10(R4),0           TEST IF BLDL FOUND THIS MEMBER
         BNE   POSCHNL0           YES - BRANCH
         BXLE  R4,R2,POSCHNL      NO - TRY NEXT
         ERROR '*** BLDL FAILED ***'                                  A
*
POSCHNL0 MVC   BLDLNAME(11),0(R4) SET TTR FOR READ ROUTINE
         MVI   BLDLTTR+3,0        SET FOR READ ROUTINE
         CLC   PRODTTR,BLDLTTR    THIS MUST BE PRODUCTION VERSION
         BE    POSCHNE            YES - NEED NOT PLAY CHAIN GAME
         BXLE  R4,R2,POSCHNM      BRANCH IF THIS NOT LAST ENTRY
         ERROR '*** 1 MEMBER, NOT P ***'                              A
*
POSCHNM  LA    R5,LEVDCB          ADDRESS OF DCB TO BE SHARED
         ST    R5,REALDCB
         XR    R10,R10             CLEAR R10 FOR FLAG           JRE0036
         IF    ¬WYLFORMT,POSNWYL   CHK IF WYLBUR FORMAT         JRE0036
         LA    R10,1               ELSE SET FLAG                JRE0036
POSNWYL  DS    0H                                               JRE0036
         LR    R6,R9              ADDRESS OF LEVEL TO CHAIN TO BELOW
         SET   (CHAINED)          FLAG FOR READ ROUTINE               C
*
*  CONSTRUCT TEMPORARY UPDATE LEVELS FOR REST OF UPDATES IN CHAIN.
*
POSCHNB  CLI   10(R4),0           TEST IF BLDL FOUND THIS ENTRY
         BE    POSCHNX            NO - SKIP TO TRY NEXT
         L     R15,=A(LCLINIT)    GET STORAGE FOR TEMP. LEVEL    82060
         BALR  R14,R15            CALL                           80294
         LR    R9,R2              ADDRESSABILITY FOR NEW LEVEL
         SET   (TEMPUPD,CHAINED)  FLAGS GALORE                        C
         LTR   R10,R10             CHK IF WYLBUR FLAG ON        JRE0036
         BZ    POSNOFLG            NO, BRANCH                   JRE0036
         SET   (WYLFORMT)          SET FLAG FOR THIS LEVEL      JRE0036
POSNOFLG DS    0H                                               JRE0036
         ST    R6,NEXTLEV         CHAIN NEW LEVEL TO THOSE BELOW
         LR    R6,R9              ADVANCE POINTER
*
         LA    R0,BUFLEN          SIZE OF BUFFER PREFIX               C
         AH    R0,DCBBLKSI-IHADCB(,R5)  GET SIZE NEEDED FOR BUFFER    C
         ICM   R0,8,=X'01'   SET SUBPOOL=1 FOR GETMAIN           82060
         ST    R0,CTLBPL          SAVE LENGTH FOR FREEMAIN            C
         GETMAIN R,LV=(0)         STORAGE FOR I/O BUFFER
         ST    R1,BUFADR          SET BUFFER POINTER FOR READ RTN     C
         USING BUFDSECT,R1                                            C
         ST    R1,BUFCHAIN        CHAIN SINGLE BUFFER TO ITSELF       C
         MVC   BUFDECB(DECBLEN),MDECB  COPY MODEL DECB                C
         DROP  R1                                                     C
         ST    R1,CTLBPA          SAVE ADDRESS OF POOL FOR FREEMAIN   C
         MVC   BLDLNAME(11),0(R4) SET TTR FOR READ ROUTINE
         MVI   CTLID,C'.'
         MVC   CTLID+1(3),BLDLNAME+5  SET VERSION NO. AS ID IN LISTING
         ST    R5,REALDCB         SHARED DCB ADDRESS FOR READ ROUTINE
         MVC   DCBBLKSI-IHADCB+LEVDCB,DCBBLKSI-IHADCB(R5)             A
         CLC   PRODTTR,BLDLTTR    CHECK IF THIS IS PRODUCTION VERSION
         BE    POSCHNE            YES - WE'RE ALL DONE
         LA    R2,14              RESET INCREMENT
POSCHNX  BXLE  R4,R2,POSCHNB      ONWARD TO NEXT MEMBER
         ERROR '*** P NOT FOUND ***'                                  A
*
*  WE'VE FOUND THE PRODUCTION VERSION - OUR SEARCH IS ENDED.
*
POSCHNE  L     R2,WORKP1          ADDRESS OF PERMENANT LEVEL ABOVE US
         ST    R9,NEXTLEV-LOCAL(,R2)   LINK TEMPORARIES INTO STRUCTURE
         LM    R0,R1,BLDLFA       LENGTH/ADDRESS OF BLDL LIST
         FREEMAIN R,LV=(0),A=(1)  KISS IT GOOD-BYE.
         SETEXIT 0                                                    A
*
*  LOOP THROUGH NEWLY CREATED TEMPORARIES TO CHECK THEIR CHANGE/ADD
*  CARDS.  (THIS STEP DEFERED BECAUSE WANTED TO FREE BLDL LIST FIRST.
*  OTHERWISE
*  AN ERROR IN THIS LOOP WILL GO FROM THE ERROR ROUTINE BACK TO
*  MAINLOOP DIRECTLY, LEAVING US WITH LESS STORAGE FOR THE FUTURE).
*
POSCHNP  L     R9,NEXTLEV-LOCAL(,R2)   POINT TO NEXT TEMPORARY
         GOSUB CTLREAD,BXH=POSPDSE1  READ FIRST CARD; B ON EOF   82060
         GOSUB CCLOOK             CHECK FOR CONTROL CARD
         CH    R15,=H'4'
         BNH   POSPDSE1
         CLI   CMDNUM+3,VCCHANGE  MUST BE CHANGE/ADD             82060
         BH    POSPDSE1           COMPLAIN IF NOT
         IF    ¬TEMPUPD,POSCHND   MERGE WITH NORMAL ROUTINE FOR LAST
         GOSUB KEYSCAN            SCAN THE CHANGE/ADD COMMAND
         CLC   GMEMB,NAME         MUST APPLY TO CURRENT MEMBER UPDATE
         BNE   PSFE2              CONFUSE HIM IF IT DOESN'T
         RESET CTLEOF
         ZAP   NEW1,PINCR
         LR    R2,R9              ADVANCE POINTER
         B     POSCHNP            CONTINUE POSITIONING TEMPORARIES
         TITLE 'UPDATE - RECURSIVE UPDATING ROUTINE'
*  CALL WITH R3 POINTING TO RESULT BUFFER AREA,
*  R2 SET TO THE DESIRED LEVEL DSECT,
*  AND R10 WITH THE RETURN ADDRESS.
*  THIS ROUTINE SETS RETURN CODE 4 ON END OF FILE.
*
UPDATE   STM   R2,R10,LEVSAVE-LOCAL(R2)
         SPACE 1                                                 83012
         PUSH  USING                                             83012
         DROP  R9                                                83012
         USING LOCAL,R2                                          83012
         IF    ¬(CTLEOF.HELD),UPDATNOH                           83012
         L     R2,NEXTLEV                                        83012
         B     UPDATE                                            83012
         POP   USING                                             83012
UPDATNOH EQU   *                                                 83012
         SPACE 1                                                 83012
         LR    R9,R2              SET UP NORMAL DSECT POINTER
         IF    CHANGE,UPC         BRANCH FOR CHANGE FUNCTION
         IF    ADD,UPA            BRANCH FOR ADD FUNCTION
*
*  THIS IS SYSUT1 (OLD MASTER SUPREME).  JUST COPY IT.
*
         GOSUB CTLREAD,BXH=UPEXIT4  READ CARD; B ON EOF          82060
         IF    IMPLSEQ,UT1IMPL    BRANCH FOR PARM=IMPLSEQ             A
*        <<< AUTO-ID-SEQFLD >>>
*  EXAMINE FIRST O.M. RECORD FOR LEADING SEQFLD ALPHABETICS
         IF    ¬OMFIRST,UT1MOD    ONLY DO IT FOR FIRST O.M. CARD
         CLI   CTLSQ+7,C'0'       BE SURE AT LEAST 1 GOOD COLUMN      A
         BNL   IDL0               YES - OK                            A
IDL3     L     R2,BACKLEV         IF PREV. LEVEL HAS SEQ1=ALL,        A
         TM    SEQALL-LOCAL(R2),L'SEQALL   IS OK IF SEQFLD BAD        A
         BNZ   IDL5                                                   A
         ERROR '*** INVALID O.M. SEQUENCE FIELD ***'                  A
IDL0     LA    R1,CTLSQ+6         SEQFLD POINTER                      A
         LH    R4,=H'-1'          INCREMENT                           A
         LA    R5,CTLSQ-1         LIMIT                               A
IDL1     CLI   0(R1),C'0'         CHECK FOR LEADING ALPHABETICS       A
         BL    IDL2               HAVE LAST SEQID, STOP SCANNING      A
         BXH   R1,R4,IDL1                                             A
         B     IDL5               WEREN'T ANY - WE'RE DONE            A
IDL2     SR    R1,R5              LENGTH OF SEQID                     A
         AR    R1,R4                                                  A
         ST    R1,SEQIDLEN        SAVE IT
         EX    R1,SEQIDMV1        SAVE LEADING ALPHABETICS
         SET   IDSEQ              INDICATE THEY EXISTED AND WERE SAVED
IDL5     RESET OMFIRST
*  REMOVE LEADING ALPHABETICS FROM SYSUT1 SEQFLD, IF WERE ANY.
UT1MOD   IF    ¬IDSEQ,UT1NOMOD    SKIP IF THERE WEREN'T
         L     R1,SEQIDLEN        LENGTH-1 OF LEADING ALPHABETICS
         EX    R1,SEQIDZ          ZERO WHILE UPDATING
UT1NOMOD EQU   *
         MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQUENCE NUMBER
UT1MB    MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA  SEND CALLER A RECORD A
         B     UPEXIT             AND RETURN
*
UT1IMPL  MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQFLD FOR IMPLSEQ    A
         AP    IMPLNUM,=P'1'      GENERATE IMPLICIT SEQUENCE NUMBER   A
         UNPK  CTLSQ,IMPLNUM      PLACE INTO SEQUENCE FIELD           A
         OI    CTLSQ+L'CTLSQ-1,C'0'                                   A
         B     UT1MB                                                  A
*                                                                     A
*  MAIN FUNCTION IS ADD-REPL
*
UPA      IF    HELD,UPEXITX       BYPASS SEQ1=ALL IN HELD DECK        H
         GOSUB READCARD,BXH=UPEXIT4  READ/CHECK CONTROL FILE CARD
         IF    ¬SEQALL,CCLANS     TEST IF NEED TO SEQUENCE
         UNPK  CTLSQ,NEW1
         OI    CTLSQ+L'CTLSQ-1,C'0'
         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A
         BNL   SEQOVFL                                                A
         AP    NEW1,INCR
CCLANS   MVC   CTLOSQ,CTLSQ       SAVE ORIGINAL SEQUENCE NUMBER
         MVC   CTLPSQ,BLANKS      NO PREVIOUS SEQUENCE NO.
         MVC   0(L'CTLAREA,R3),CTLAREA  RETURN SIMPLE DATA CARD
         B     UPEXITX                                                #
*
*
*  FUNCTION IS CHANGE-REPRO
*
UPC      EQU   *
*
*  READ A RECORD FROM THE CONTROL FILE, IF NECESSARY
*
RDCTL    IF    CTLWAIT+CTLEOF,UPC2
         SETEXIT CTLERROR         PROVIDE SPECIAL ERROR RECOVERY      A
         GOSUB READCARD           GET AND ANALYZE CONTROL RECORD
         IF    MACRO,UPMVMAC      JUST FLUSH MACRO CARD THROUGH
UPC2     EQU   *
*
*  READ AN OLD MASTER RECORD, IF NECESSARY
*
READOM   IF    OMWAIT+OMEOF,UPC1  CONDITIONS FOR BYPASSING READ
         LR    R4,R3
         L     R2,NEXTLEV         DSECT POINTER FOR NEXT UPDATE LEVEL
         LA    R3,OMAREA          PLACE TO PUT CARD INTO
         MVC   OMWYL(8),BLANKS                                  JRE0036
         BAL   R10,UPDATE         GO GET NEXT OLD MASTER RECORD
         LR    R3,R4
         BXLE  R15,R15,UPC1   IF NOT EOF, SKIP SETTING THE FLAG  82060
         SET   OMEOF
         MVC   OMSQ,=8X'FF'       SET SEQ. NO. HIGH                   A
         GOSUB SCAN               * SO SCAN RTN. WILL PURGE           A
UPC1     EQU   *
*
         IF    CTLEOF.OMEOF,UPEXIT4    RETURN IF ALL RIVERS ARE DRY
*
*  TEST FOR AND HANDLE DELETE IN PROGRESS
*
         IF    ¬DELETE,UPC3       SKIP IF DELETE NOT IN PROGRESS
         IF    OMEOF,DLTX         OLD MASTER EOF TERMINATES FUNCTION
         CLC   SEQ2,OMSQ          TEST OLD MASTER CARD AGAINST RANGE
         BL    DLTX               CARD ABOVE DELETE RANGE, TERMINATE
         BH    *+8
         RESET XSEQ2              OM SEQUENCE = SEQ2, RESET FLAG.
         RESET OMWAIT
         CLC   SEQ1,OMSQ
         BH    UPMVOLD            CARD BELOW RANGE, RETURN IT.
         BL    DLTNX
         RESET XSEQ1              SEQ1 FOUND IN O.M.  RESET FLAG.
*  IF INSERT AFTERMATH IS ON, WE CHECK IF THE O.M. CARD HAS A HIGH
*  ENOUGH SEQUENCE NUMBER TO RESET IT.  THIS IS DONE TO PREVENT THE
*  PROGRAM FROM MERGING SUCCESSIVE 'REPLACE' OPERATIONS, AND THEREBY
*  YIELDING UNEXPECTED (THOUGH PERFECTLY REASONABLE) SEQUENCING ON THE
*  SECOND SET OF INSERTED CARDS.
*  E.G. ./ R 10  ...  ./ R 11  WOULD HAVE BEEN EQUIVALENT TO ./ R 10-11
*  THIS IS DONE ONLY FOR THE FIRST DELETED CARD (SINCE SEQUENCE LOWEST)
         IF    ¬INSERTX,DLTNX     SKIP IF PREVIOUS FUNCTION NOT INSERT
         IF    ¬INSERT,DLTNX      DO ONLY FOR REPLACE, NEVER FOR DELETE
         PACK  WORKA(5),OMSQ
         CP    WORKA(5),XNEW1     TEST IF CAN KILL INSERT-AFTERMATH
         BNH   DLTNX              NO                                  A
         RESET INSERTX            YES
DLTNX    EQU   *
         LOG   DLTE               LOG THAT RECORD DELETED
         B     READOM
*  THE DELETE RANGE HAS BEEN EXCEEDED.  TERMINATE THE FUNCTION.
DLTX     RESET (DELETE,CTLWAIT)
         SET   OMWAIT
         IF    ¬XSEQ1.¬XSEQ2,DLTOK  BRANCH IF SEQ1, SEQ2 BOTH VERIFIED
         RESET (XSEQ1,XSEQ2)                                         LB
         SETEXIT RDCTL            HANDLE ERROR HERE                 SMP
         ERROR '*** DELETE RANGE WAS INCORRECT ***'                  LB
DLTOK    B     RDCTL              GET NEXT CONTROL RECORD
UPC3     EQU   *
*
*  TEST FOR SIMPLE RENUMBER IN PROGRESS (./NUMBER SEQ1=,SEQ2=)
*
         IF    ¬NUMBER,UPC4       SKIP IT ALL IF NUMBER NOT ACTIVE
         IF    OMEOF,NUMX         OLD MASTER EOF TERMINATES FUNCTION
         CLC   SEQ2,OMSQ
         BL    NUMX               CARD ABOVE RANGE.  TERMINATE FUNCTION
         BH    *+8
         RESET XSEQ2              UPPER LIMIT O.M. CARD VERIFIED.
         RESET OMWAIT
         CLC   SEQ1,OMSQ          TEST IF IN RANGE
         BH    UPMVOLD            NO - JUST RETURN IT.
         BL    NUM2
         RESET XSEQ1              THIS IS FIRST CARD IN RANGE
         IF    ¬INSERTX,NUM2      IF NO INSERT AFTERMATH, WE'RE OK.
         CP    NEW1,XNEW1         TEST IF CAN USE NEW SEQUENCE NUMBERS
         BH    NUM1               * AS DIRECTED WITHOUT CAUSING ERROR.A
         ERROR '*** CAN NOT RENUMBER AS DIRECTED ***',RC=4
         B     NUMX               IGNORE THE NUMBER OPERATION
NUM1     RESET INSERTX
NUM2     MVC   OMPSQ,OMSQ         SAVE ORIG. SEQ, (FOR LISTRN)
         MVC   OMSEQ,OMSQ         FOR SEQUENCE ERROR CHECKS LATER
         GOSUB SCAN               'FIX' BEFORE LOSE SEQ. NO.
         UNPK  OMSQ,NEW1          RESEQUENCE THE CARD
         OI    OMSQ+L'OMSQ-1,C'0'
         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A
         BNL   SEQOVFL                                                A
         AP    NEW1,INCR
         MVC   0(L'OMAREA+L'OMOSQ,R3),OMAREA
         B     UPEXIT
NUMX     RESET (NUMBER,CTLWAIT)
         SET   OMWAIT
         BAL   R10,INSTERM        WILL ALLOW SUBSEQUENT RENUMBERING
         IF    ¬XSEQ1.¬XSEQ2,RDCTL
         ERROR '*** NUMBER RANGE WAS INCORRECT ***',RC=4
         RESET (XSEQ1,XSEQ2)
         B     RDCTL
*                                                                     A
UPC4     EQU   *
*
*  TEST FOR INSERT OPERATION ACTIVE.
*
         IF    ¬INSERT,UPC5       SKIP IF NOT INSERTING
         IF    CTLEOF,UPC6        TERMINATE INSERTING ON CTL EOF
         IF    GINSERT,UPCI1      SKIP IF PARM SET TO IGNORE C.D.R.'S
         CLC   CTLSQ,BLANKS       TEST IF BLANK SEQFLD
         BNE   UPC6               NO - INSERT TERMINATED BY C.D.R.
UPCI1    EQU   *
*
         IF    OMEOF,UPCI2        JUST RETURN CTL. RCD. IF OM EOF.
         CLC   SEQ1,OMSQ          TEST IF HAVE REACHED INSERT POINT
         BH    UPMVOLD1           NO - MOVE OM RECORD, SET XSEQ1.
         BL    UPCI2              YES - MOVE INSERTED CARD.
         RESET XSEQ1              SEQ1 FOUND IN O.M.  RESET FLAG.
         B     UPMVOLD            MOVE FINAL O.M. CARD BEFORE INSERTION
UPCI2    IF    ¬XSEQ1,UPCI3       SKIP ERROR IF SEQ1 FOUND IN OM
         ERROR '*** SEQ1 NOT FOUND IN OLD MASTER ***',RC=4
         RESET XSEQ1
         IF    FNEW1,UPCI3        SKIP IF NEW1= WAS SPECIFIED
*  SINCE SEQ1 DOESN'T EXIST, IT MAKES A FINE DEFAULT FOR NEW1.
*  (OTHERWISE, WILL HAVE DEFAULTED TO SEQ1+INCR).
*  NOTE THAT IF THE USER INTERRUPTED HIS INSERT TO SPECIFY, SAY,
*  A GANG, FNEW1 WILL HAVE RESET, AND HIS SPECIFICATION WILL BE
*  LOST.  THATS THE PRICE OF MAKING AN ERROR (CAN ALWAYS PRECEDE
*  THE INSERT WITH THE GANG, ANYWAY.)
         PACK  NEW1,SEQ1          RESET NEW1 BETTER
UPCI3    SET   OMWAIT
         RESET CTLWAIT
*  OVER-RIDE A PREVIOUS INSERT AFTERMATH, IF POSSIBLE.
*  THIS SECTION (TO UPCNAT) MAY BE DELETED FOR STRICT IEBUPDTE
*  COMPATIBILITY.  (BUT WE'RE STILL SAME IF OMITS NEW1, INCR).
         IF    ¬NOINSERT,UPCNAT   ONLY DO THIS FOR FIRST CARD
         IF    ¬INSERTX,UPCNAT    NO AFTERMATH - SKIP
         IF    ¬FNEW1.¬FINCR,UPCNAT SKIP IF USING DEFAULTS
         CP    XNEW1,NEW1         COMPARE TO NUMBER WE WANT           A
         BNL   UPCNAT             SORRY - CAN'T STOP AFTERMATH
         RESET INSERTX            STOP INSERT RENUMBERING AFTERMATH
UPCNAT   EQU   *
         MVC   CTLOSQ,CTLSQ       SAVE ORIG SEQFLD FOR IMPLSEQ        A
         UNPK  CTLSQ,NEW1         PUT SEQUENCE NO. ON INSERTED CARD
         OI    CTLSQ+L'CTLSQ-1,C'0'
         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A
         BNL   SEQOVFL                                                A
         AP    NEW1,INCR          SET NEW1 UP FOR NEXT CARD
         RESET NOINSERT           INDICATE THAT SOMETHING INSERTED
         MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA                       A
         B     UPCINX
UPC6     BAL   R10,INSTERM        TERMINATE INSERT FUNCTION
UPC5     EQU   *
*
*
*  TEST FOR ACTIVE 'USER' UPDATING EXIT ROUTINE.
*
         IF    ¬USER,UPNUX1       SKIP IF NO USER EXIT
         IF    OMEOF,UPNUX        TERMINATE IF NO MORE DATA
         CLC   OMSQ,SEQ1          TEST O.M. CARD IN RANGE
         BL    UPMVOLD            O.M. BELOW RANGE - JUST PASS IT BACK
         BH    *+8
         RESET XSEQ1              NOTE IF SEQ1 SPECIFIED PROPERLY
         CLC   OMSQ,SEQ2
         BH    UPNUX              CARD ABOVE RANGE - TERMINATE.
         BL    *+8
         RESET XSEQ2              NOTE IF SEQ2 SPECIFIED CORRECTLY
*  CALL USER ROUTINE TO POSSIBLY UPDATE CURRENT OLD MASTER RECORD.
         IF    UINSERT,USKPSCAN   DON'T SCAN/FIX SAME OM CARD TWICE
         GOSUB SCAN               SCAN APPLIES BEFORE USER
USKPSCAN EQU   *
         CLC   USERNAME,UNAME     TEST IF REQUIRED ROUTINE IS LOADED
         BE    USERCALL           BRANCH IF IT IS.
         CLI   USERNAME,C' '      TEST IF ANY PREVIOUS ROUTINE LOADED
         BE    USERLOAD           NO - CAN'T DELETE IT THEN.
         DELETE  EPLOC=USERNAME
USERLOAD MVC   USERNAME,UNAME     SAVE NAME OF ACTIVE USER ROUTINE
         LOAD    EPLOC=USERNAME   LOAD REQUIRED USER ROUTINE
         ST    R0,USERADR         SAVE ITS ENTRY POINT ADDRESS
USERCALL L     R15,USERADR        ADDRESS OF USER'S ROUTINE
         LA    R1,USERCODE        ADDRESS OF CODE= PARAMETER
         LA    R2,OMAREA          ADDRESS (-6) OF OLD MASTER RECORD
         LA    R4,PWA             SO USER CAN PRINT IF HE WANTS
         BALR  R14,R15            BRANCH TO USER ROUTINE
         B     *+4(R15)           BRANCH ON USER'S RETURN CODE
         B     USERNC             USER ROUTINE DESIRES NO CHANGES
         B     USERDLTE           USER ROUTINE DELETES OM RECORD
         B     USERMOD            USER ROUTINE REPLACES OM RECORD
         B     USERINS            USER ROUTINE INSERTS (WE'LL CALL BACK
         ERROR '*** USER ROUTINE SIGNALS ERROR ***'
*
USERNC   BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT
         B     UPMVOLD2           USER ROUTINE MAKES NO CHANGE
*
USERDLTE LOG   DLTE               LOG RECORD HAS BEEN DELETED
         BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT
         B     READOM             AND GO GET ANOTHER
*
USERMOD  LOG   DLTE               LOG THAT OM RECORD IS DELETED
         MVC   OMID-OMAREA(,R3),CTLID
         MVC   OMSQ-OMAREA(26,R3),OMSQ
         BAL   R10,INSTERMU       TERMINATE POSSIBLE USER INSERT
         B     UPCEXIT
*
USERINS  MVC   OMID-OMAREA(,R3),CTLID
         MVC   OMPSQ-OMAREA(,R3),BLANKS
         IF    UINSERT,UI1        SKIP IF CONTINUED INSERT
         SET   (UINSERT,OMWAIT)
         PACK  NEW1,OMSQ
         ZAP   INCR,PINCR
UI1      UNPK  OMSQ-OMAREA(,R3),NEW1  ASSIGN SEQUENCE NUMBER TO INSERT
         OI    OMSQ+L'OMSQ-1-OMAREA(R3),C'0'
         CLI   NEW1,X'10'         TEST IF SEQUENCE NUMBER TOO BIG     A
         BNL   SEQOVFL                                                A
         AP    NEW1,INCR
         B     UPCINX
*
*  SUBROUTINE TERMINATES USER INSERT.
INSTERMU IF    ¬UINSERT,NUINS     LEAVE IF WAS NO USER INSERT
         RESET (UINSERT,OMWAIT)
         IF    INSERTX,NUINS      LEAVE IF AFTERMATH ALREADY SET UP
         SET   INSERTX
         ZAP   XINCR,INCR
         ZAP   XNEW1,NEW1
         SP    XNEW1,XINCR        BACK OFF XNEW1 FOR AFTERMATH CHECK  A
NUINS    BR    R10                RETURN
*
*
*  USER RANGE EXCEEDED, TERMINATE THE FUNCTION.
*
UPNUX    RESET (USER,CTLWAIT)
         SET   OMWAIT
         IF    ¬XSEQ1.¬XSEQ2,RDCTL
         ERROR '*** SEQ1/SEQ2 DOES NOT EXIST IN OLD MASTER ***',RC=4
         RESET (XSEQ1,XSEQ2)
         B     RDCTL              GO GET NEXT COMMAND
UPNUX1   EQU   *
*
*
*  WE ARE DOWN TO SIMPLE CHANGE DATA RECORDS HERE.
*
         IF    CTLEOF,UPMVOLD     UPDATE AT EOF, JUST COPY REST OF OM
         IF    CTLWAIT,SKPSEQCK   ONLY CHECK SEQFLD ONCE PER CARD
         IF    ¬IDSEQ,SKPSEQID    IS THERE A SEQID                    A
         L     R1,SEQIDLEN        YES - MOVE APPROPRIATE NUMBER OF    A
         EX    R1,SEQIDZ          ZEROES TO CDR'S SEQFLD.             A
SKPSEQID EQU   *                                                      A
         LA    R1,CTLSQ           CHECK SEQUENCE FIELD
         GOSUB DECCHK
         MVC   CTLOSQ,BLANKS      FOR IMPLSEQ ONLY                    A
SKPSEQCK EQU   *
         IF    OMEOF,UPMVNEW      JUST RETURN CTL. RCD. IF OM EOF.
         CLC   CTLSQ,OMSQ         COMPARE SEQUENCE NUMBERS
         BH    UPMVOLD            MOVE OLD MASTER
         BL    UPMVNEW            MOVE CTL. RCD. BEING MERGED
*  CONTROL RECORD WILL OVERLAY (REPLACE) OLD MASTER RECORD.
         RESET (OMWAIT,CTLWAIT)
         LOG   DLTE               LOG THAT RECORD DELETED
         B     CCLNS
*  MOVE OUT AN INSERTED CHANGE DATA RECORD
UPMVNEW  SET   OMWAIT
         RESET CTLWAIT
CCLNS    MVC   0(L'CTLAREA+L'CTLOSQ,R3),CTLAREA                       A
         B     UPCEXIT
*  MOVE OUT AN OLD MASTER RECORD (SINCE ITS SEQUENCE WAS LOW)
UPMVOLD1 SET   XSEQ1              SO INSERT FLAGS BAD SEQ1 LATER MAYBE
UPMVOLD  SET   CTLWAIT
         RESET OMWAIT
         ICM   R1,15,LCLFCBAD     AVOID CALL TO SCAN ROUTINE IF THERE
         BZ    *+8                * ARE NO FIX CONTROL BLOCKS OUT.
         GOSUB SCAN               FOR ANY POSSIBLE SCAN ACTION NEEDED
UPMVOLD2 MVC   0(L'OMAREA+L'OMOSQ,R3),OMAREA
*
*  CHECK SEQUENCING OF OUTPUT RECORDS AS THEY ARE PRODUCED
*
UPCEXIT  CLC   OMSQ-OMAREA(,R3),OMSEQ COMPARE AGAINST PREVIOUS OMSQ
         BNH   UPSEQERR
         MVC   OMSEQ,OMSQ-OMAREA(R3)   SET FOR NEXT TIME
*
*  TEST FOR "INSERT AFTERMATH" (WHEN AN INSERT OPERATION TERMINATES,
*  RENUMBERING OF SUBSEQUENT DATA MAY BE REQUIRED).
*
UPCINX   IF    ¬INSERTX,UPC7
         PACK  WORKA(5),OMSQ-OMAREA(,R3)   O.M. SEQUENCE NUMBER       A
         CP    WORKA(5),XNEW1     COMPARE TO PREV. ASSIGNED NO.       A
         BH    DONERN             HIGH - CAN STOP RENUMBERING         A
         AP    XNEW1,XINCR        ELSE, COMPUTE NEW SEQUENCE NUMBER   A
         MVC   OMPSQ-OMAREA(,R3),OMSQ-OMAREA(R3) PREVIOUS SEQ. NO.
         UNPK  OMSQ-OMAREA(,R3),XNEW1
         OI    OMSQ-OMAREA+L'OMSQ-1(R3),C'0'
         CLI   XNEW1,X'10'        TEST IF SEQUENCE NUMBER TOO BIG     A
         BL    UPEXIT                                                 A
         B     SEQOVFL                                                A
DONERN   RESET INSERTX            SET INSERT AFTERMATH DONE           A
UPC7     EQU   *                                                      A
*
*  THAT'S IT.
*
UPEXIT   XR    R15,R15
*  CHECK FOR TOTAL RESEQUENCE OPTION.                                 #
         IF    ¬SEQALL,UPEXITX    SKIP IF NOT 'SEQ1=ALL' SEQUENCING   #
         CLI   OMPSQ-OMAREA(R3),C' '  TEST CARD PREVIOUSLY RENUMBERED #
         BNE   UPC1A              IF SO, LEAVE 'PREV' FIELD ALONE     #
         MVC   OMPSQ-OMAREA(,R3),OMSQ-OMAREA(R3)                      #
UPC1A    UNPK  OMSQ-OMAREA(,R3),NEW1A                                 #
         OI    OMSQ+L'OMSQ-1-OMAREA(R3),C'0'                          #
         CLI   NEW1A,X'10'        TEST IF SEQUENCE NUMBER TOO BIG     A
         BNL   SEQOVFL                                                A
         AP    NEW1A,INCRA                                            #
UPEXITX  LM    R2,R10,LEVSAVE     RESTORE SOME REGISTERS
         BR    R10                RETURN
UPEXIT4  LA    R15,4
         B     UPEXITX
*
UPMVMAC  MVC   0(L'CTLAREA,R3),CTLAREA  MOVE UP A MACRO CARD
         MVC   0(4,R3),=C' MAC'   IDENTIFY IT (SO WON'T BE INSERTION)
         B     UPEXIT
*
UPSEQERR IF    SEQALL,UPCINX      NOT A PROBLEM IF RESEQUENCING       #
         XPRNTLIN PWA,TEXT=(R3),LENGTH=L'CTLAREA,SPB=1                #
         ERROR '*** SEQUENCE ERROR ***'
SEQOVFL  ERROR '*** SEQUENCE NUMBER OVERFLOW ***'                     A
         SPACE 3
*  SUBROUTINE FOR UPDATE - READ AND IMPLEMENT CONTROL RECORDS
*  RC=4 FOR EOF, AND FLAGS FOR EOF SET.
*  CARDS MAY ALSO BE READ FROM SYSLIB (ANY THAT ARE CONTROL CARDS
*  ARE TREATED AS DATA).                                              A
*
READCARD BGNSB RCSAVE
         IF    COPY,RDCOPY        BRANCH IF COPY IN PROGRESS
RDCTL1   GOSUB CTLREAD,BXH=RCEOF  READ; BRANCH ON EOF            82060
         GOSUB CCLOOK             TEST FOR CONTROL CARD
         B     *+4(R15)           TEST RETURN CODE
         B     RDCPYX             SIMPLE DATA/CHANGE-DATA RECORD.
         B     RCDTL              BRANCH FOR DETAIL FUNCTION
         B     RCSEOF             BRANCH FOR MAJOR FUNCTION
*
RCEOF    SET   REALEOF
RCSEOF   SET   CTLEOF
         LA    R15,4
         B     RDCPYX             RETURN
*
*  HAVE DETAIL CONTROL RECORD.  CALL KEYSCAN TO IMPLEMENT IT.
*
RCDTL    GOSUB KEYSCAN            GO ANALYZE AND PRINT IT.
         IF    COPY,RDCOPY        BRANCH IF COPY JUST STARTED
         IF    INSERT1,RERDC      TEST IF SHOULD IMMEDIATELY READ AGAIN
         XR    R15,R15
         B     RDCPYX             RETURN
*
*  READ A CARD FROM THE COPY LIBRARY
*
RDCOPY   LR    R2,R9              SAVE CURRENT DSECT POINTER
         L     R9,LIBADR          POINT TO SYSLIB'S DSECT
         GOSUB CTLREAD            CALL FOR NEXT COPY RECORD
         LR    R3,R9              SAVE COPY LIBRARY DSECT ADDRESS
         LR    R9,R2              POINT BACK TO CURRENT ONE
         LTR   R15,R15            TEST FOR END OF FILE
         BNZ   RDCPYEOF           IF EOF, BRANCH
         IF    ¬COPY1,COPY1D      SKIP IF SEQID DONE OR NOT NEEDED
*
*  ADJUST FOR POSSIBLE SEQID IN COPY DATA
*
         RESET COPY1              ONLY DO IT ONCE                     A
         CLI   CTLSQ+7-LOCAL(R3),C'0'  BE SURE AT LEAST ONE GOOD COL  A
         BNL   IDC0               YES - OK                            A
         SETEXIT RDCPYEOF         AFTER ERROR, TREAT LIKE NULL COPY   A
         ERROR '*** INVALID SEQFLD IN COPY DATA ***'                  A
IDC0     LA    R5,CTLSQ-1-LOCAL(,R3)   LIMIT                          A
         LA    R1,CTLSQ+6-LOCAL(,R3)   SEQFLD POINTER                 A
         LH    R4,=H'-1'          INCREMENT                           A
IDC1     CLI   0(R1),C'0'         CHECK IF LEADING ALPHABETIC         A
         BL    IDC2               YES - STOP SCAN                     A
         BXH   R1,R4,IDC1                                             H
         B     COPY1D             NULL - WE'RE DONE                   A
IDC2     SR    R1,R5              LENGTH OF SEQID                     A
         AR    R1,R4                                                  A
         EX    R1,COPYM1          FUDGE FROMSEQ COMPARAND
         EX    R1,COPYM2          FUDGE TOSEQ COMPARAND
COPY1D   EQU   *
*
*  REJECT CARDS WHICH ARE NOT IN THE USER SPECIFIED COPY RANGE.
*
         CLC   FROMSEQ,CTLSQ-LOCAL(R3)
         BH    RDCOPY             CARD BELOW RANGE - IGNORE IT
         BL    *+8
         RESET XFROMSEQ           NOTE IF MATCH FOR FROMSEQ EXISTS
         CLC   TOSEQ,CTLSQ-LOCAL(R3)
         BL    RDCPYEOF           CARD ABOVE RANGE - TERMINATE.
         BH    *+8
         RESET XTOSEQ             NOTE THAT XTOSEQ MATCHED INPUT CARD
*
         MVC   CTLBUF(90),CTLBUF-LOCAL(R3)                            A
         IF    ADD,RDCPYA         UNDER ADD, RETAIN SEQUENCING
         IF    MACRO,RDCPYA       ALSO FOR MACROS, KEEP SEQUENCING
         MVC   CTLSQ,BLANKS
RDCPYA   EQU   *
RDCPYX   DS    0H                                               JRE0036
         SETEXIT 0                                              JRE0036
         CLC   CTLSQ(8),BLANKS                                  JRE0036
         BE    RDCPYXWL                                         JRE0036
*DEL*?   MVC   CTLWYL(8),BLANKS    BLANK WYL NUM FIELD          JRE0036
         IF    ¬WYLBUR,RDCPYXWL                                 JRE0036
         MVC   CTLWYL,CTLSQ        LIST WYL SEQ#                JRE0036
         MVC   CTLSQ(8),BLANKS     BLANK REAL SEQ FIELD         JRE0036
RDCPYXWL DS    0H                                               JRE0036
         ENDSB RCSAVE             RETURN                              A
*
RDCPYEOF RESET (COPY,COPYING,MACRO)
         IF    ¬XFROMSEQ.¬XTOSEQ,RDCTL1
         ERROR '*** INCORRECT COPY RANGE ***',RC=4
         RESET (XFROMSEQ,XTOSEQ)
         B     RDCTL1
*
RERDC    RESET INSERT1            CONTROL CARD MUST IMMEDIATELY BE
         B     RDCTL1             * READ OVER. (INSERT OR ALIAS)
*                                                                     A
*  ERROR FOUND ON DETAIL CONTROL CARD.  FLUSH TO NEXT AND             A
*  CONTINUE THE UPDATE.  THE ERROR ROUTINE HAS SET NO-WRITE.          A
*                                                                     A
CTLERROR RESET (INSERT1,COPY1,XFROMSEQ,XTOSEQ)                        A
         SETEXIT CTLERROR         IN CASE HIT MORE TROUBLE            A
CTLER1   GOSUB CTLREAD            READ NEXT CONTROL CARD              A
         BXH   R15,R15,RCEOF      EOF - LEAVE                    82060
         GOSUB CCLOOK,TEST=8      SEE IF A COMMAND                    A
         B     RCDTL              BRANCH IF DETAIL COMMAND            A
         B     RCSEOF             LEAVE ON MAJOR FUNCTION             A
         CLC   CTLSQ,BLANKS       SKIP INSERT DATA                    A
         BE    CTLER1                                                 A
         IF    GINSERT,CTLER1                                         A
         B     RDCPYX                                                 A
*                                                                     A
         TITLE 'ROUTINE TO APPLY FIX/SCAN OPERATION TO AN OLD MASTER CAX
               RD'
*
*  THE FOLLOWING REGISTERS ARE USED IN THE FOLLOWING ROUTINE
*
*   R1  ->  POSITION IN OLD MASTER CARD
*   R3  ->  END OF OLD MASTER CARD
*   R4  =   LENGTH-1 OF "BAD" STUFF TO BE REMOVED
*
*   R14 ->  POSITION IN "FIXED" CARD
*   R15 ->  END OF "FIXED" CARD
*   R5  =   LENGTH-1 OF "GOOD" STUFF TO BE PLACED ON CARD
*
         USING FCB,R6
SCAN     BGNSB QSAVE,EQU=CTLSV    ENTER AND SAVE REGS
         RESET SCANFIX
         LA    R5,LCLFCBAD        ADDRESS OF FIRST FCB (IS DUMMY)
         XR    R6,R6         JUST IN CASE ...                    82060
QAGAIN   ICM   R6,7,1(R5)    GET NEXT FCB TO LOOK AT             82060
         BZ    QEND          QUIT IF NO MORE
         CLC   OMSQ,FCBSEQ2       CHECK UPPER RANGE OF THE SCAN/FIX
         BH    QFCBDEQ            BRANCH TO DE-QUEUE DEAD FCB
         CLC   OMSQ,FCBSEQ1       CHECK O.M. SEQ. NO. AGAINST RANGE
         BL    QNEXT              TOO LOW
         SET   FIXSEQ        SHOW AT LEAST ONE CARD IN RANGE     82060
*
         MVI   SCANWORK,C' '      TO FILL THE BUFFER
         MVC   SCANWORK+1(L'SCANWORK-2+L'FCBGOOD),SCANWORK
*
*   SET UP REGS FOR THE ADDRESSING OF THE WORK AREAS
*
         LA    R1,OMDATA          POINTS TO OLD MASTER CARD
         LA    R2,1               INCREMENT FOR BXLE
         LA    R14,SCANWORK       POINTS TO POSITION IN NEW MASTER
         LH    R4,FCBLENB         LENGTH OF BADSTUFF FOR EX
         LH    R5,FCBLENG         LENGTH OF GOOD STUFF FOR EX
*
         LR    R3,R1
         AH    R1,FCBCOL1         START POSITION IN OLD MASTER CARD
         AH    R3,FCBCOL2         END POSITION IN OLD MASTER CARD
         LR    R15,R14
         SH    R15,FCBCOL1
         AH    R15,FCBCOL2        END POSITION IN "FIXED" CARD
         LR    R0,R3              OLD MASTER END POSITION
         SR    R0,R4              BACK LENGTH("BAD") IS WHERE CAN
*                                 * NO LONGER POSSIBLY MATCH "BAD"
QONWARD  CR    R1,R0              TEST IF CLC CAN NO LONGER FIT
         BH    QONWARD1
         EX    R4,BADCLC          CHECK SUBSTR FOR OCCURRENCE OF BAD
         BE    QREP               FOUND IT -- REPLACE WITH GOOD STUFF
QONWARD1 CR    R14,R15            END OF THE LINE ?
         BH    QDONE              YES -- FORCE END
         MVC   0(1,R14),0(R1)     NOT FOUND -- ADVANCE TO NEXT CHAR
         AR    R14,R2             INCREMENT TO NEXT POSITION
         BXLE  R1,R2,QONWARD      BACK FOR ANOTHER TRY
*
*   REPLACE THE OLD MASTER WITH THE FIXED NEW MASTER AND ADVANCE
*   TO THE NEXT FCB IF ANY.
*
QDONE    LH    R1,FCBCOL1
         LH    R2,FCBCOL2
         SR    R2,R1              LENGTH FIELD TO MOVE (AS FIXED)
         LA    R3,OMDATA(R1)      PLACE TO MOVE TO IN O.M. CARD
         EX    R2,QDONEMVC
*
QNEXT    LR    R5,R6              MOVE FCB ADDRESS TO R5
         B     QAGAIN             TEST FOR ANOTHER FCB
*
*   ROUTINE TO REPLACE BAD STUFF ON OLD MASTER CARD WITH GOOD STUFF
*   FROM FCB.  GOOD STUFF MAY BE NULL
*
QREP     IF    SCANFIX,QDID       ON FIRST REP -- PRINT OLD MASTER
         STM   R14,R1,QSAVE2      SAVE THE WORK REGS FROM LOG
         LOG   DLTE               CONSIDER ORIGINAL RECORD DELETED
         LM    R14,R1,QSAVE2      RESTORE WORK REGS.
         MVC   OMID,CTLID
         SET   SCANFIX            DON'T PRINT IT OUT AGAIN
QDID     SET   FIXUSED            NOTE FCB ACTUALLY DID SOMETHING     #
         LTR   R5,R5         IS FCBLENG NULL ?                   82060
         BM    QSKIP            YES -- SKIP MOVING IN GOOD STUFF 82060
         EX    R5,GOODMVC         MOVE IT IN
         AR    R14,R5             MOVE UP IN POSITION
         CR    R14,R15            END OF THE LINE ?
         BH    QDONE              YES -- PAST NEW CARD BOUNDRY
         AR    R14,R2             PLUS ONE FOR EX
QSKIP    AR    R1,R4              MOVE PAST BAD STUFF ON OLD
         IF    FIX,QFIX           ONLY CHANGE FIRST OCCURRENCE FOR FIX
         BXLE  R1,R2,QONWARD      PLUS ONE FOR EX AND GO ON
         B     QDONE              DONE THIS FCB
*
QEND     IF    ¬SCANFIX,QEXIT     IF NO FIXES MADE, LEAVE
         LA    R1,OMBUF           ELSE, MUST APPLY ANY GANGS
         LA    R0,C'S'            GANG OVERLAY BY SCAN CODE
         BAL   R10,DOGANG         SUBROUTINE DOES THIS FOR US
         MVC   OMWYL(8),DSCANFIX   FLAG SCAN/FIX LINE           JRE0036
         LA    R2,SCANWORK+1(R2)
         CLC   0(L'FCBBAD-1,R2),BLANKS    CHECK FOR SCAN OVER-RUN     #
         BE    QEXIT
         ERROR '*** REPLACEMENT TEXT TRUNCATED ***',RC=4
QEXIT    ENDSB QSAVE
DSCANFIX DC    CL8'SCAN/FIX'                                    JRE0036
*
*  IF OPERATION IS FIX (INSTEAD OF SCAN) ONLY THE FIRST OCCURRENCE OF
*  THE 'BAD' STRING IS REPLACED.  THE REST OF THE OLD MASTER RECORD
*  IS COPIED DIRECTLY TO THE FIXED RECORD IN SCANWORK (NOTE THAT THIS
*  RECORD AREA HAS ENOUGH PADDING TO SURVIVE ANY POSSIBLE INCREASE IN
*  SIZE FROM BAD TO GOOD STRINGS).
*
QFIX     AR    R1,R2              POINT TO REST OF OLD MASTER CARD
         SR    R3,R1              LENGTH-1 LEFT ON OLD MASTER CARD
         BM    QDONE
         EX    R3,FIXMVC          FINISH UP BY COPYING THE REST.
         B     QDONE
*
*  DE-QUEUE AND FREEMAIN THIS FCB (ITS RANGE EXCEEDED).
*
QFCBDEQ  MVC   1(3,R5),1(R6)      THIS FIXES THE CHAIN LINKS
         IF    FIXUSED,QFCBDEQ1                                       #
         CALLSUB FAILFIX     PRINT BAD FIX MESSAGE               82060
QFCBDEQ1 LR    R1,R6              SO CAN FREE DEAD FCB                #
         FREEMAIN R,LV=FCBLEN,A=(1),SP=3
         B     QAGAIN
*
*
*   THESE INSTRUCTIONS ARE USED VIA AN EX INSTRUCTION FOR VARIABLE
*   LENGTH MOVES AND COMPARES
*
BADCLC   CLC   0(0,R1),FCBBAD
GOODMVC  MVC   0(0,R14),FCBGOOD
QDONEMVC MVC   0(0,R3),SCANWORK
FIXMVC   MVC   0(0,R14),0(R1)
QSAVE2   DS    4F
*
         DROP  R6
         SPACE 3
*  DOGANG -- HANDLE USER SPECIFIED 'GANG' OPERATION.
*  R10 = RETURN ADDRESS,  R1 -> CARD BUFFER.
*  R0 CONTAINS 'G' OR 'S' FOR ERROR CONDITION (PREV. GANG OVERLAY).
*
DOGANG   IF    ¬GANG,NOGANG       SKIP IF NOT GANG-PUNCHING ANYTHING
         IF    ¬GANGASM,DOGANGCM  NO SPECIAL TESTING             82060
         CLI   71(R1),C' '   CONTINUATION CARD ?                 82060
         BNER  R10           YES; DON'T CLOBBER SPLIT STRINGS    82060
         LR    R14,R1        REMEMBER THE START ADDRESS          82060
         A     R1,GANGCOL    GET INSERTION ADDRESS               82060
         CR    R1,R14        START ON COLUMN 1 ?                 82060
         BNH   DOGANGCM      YES; USE NORMAL CODE                82060
         L     R15,GANGLEN   GET LENGTH TO CHECK                 82060
         BCTR  R1,0          BACKSPACE                           82060
         LA    R15,2(,R15)   CHECK BLANKS BEFORE AND AFTER       82060
         EX    R15,GANGCHK   ALL BLANK ?                         82060
         BE    DOGANGR1      YES; PROCESS                        82067
         CH    R15,=H'6'     5 BYTE GANG FIELD ?                 82067
         BNER  R10           NO; SKIP SPECIAL TEST               82067
         CLI   0(R1),C' '    STARTING BLANK ?                    82067
         BNER  R10           NO; DO NOT OVERLAY OLD DATA         82067
         CLI   6(R1),C' '    TRAILING BLANK ?                    82067
         BNER  R10           NO                                  82067
         MVZ   WORKD(5),1(R1)  5 NUMERICS ?                      82067
         CLC   WORKD(5),=8C'0'   CHECK FIVE NUMERIC ZONES        82067
         BNER  R10           NO; NO REPLACEMENT OF OLD DATE      82067
DOGANGR1 LR    R1,R14        RESTORE R1                          82067
DOGANGCM A     R1,GANGCOL         PLACE IN CARD TO MOVE STUFF TO 82060
         L     R15,GANGLEN        AMOUNT (-1) TO BE MOVED
         EX    R15,GANGCHK        BE SURE NOT OVERLAYING ANYTHING
         EX    R15,GANGMOVE
         BER   R10                RETURN IF DID NOT OVERLAY ANYTH80002
         S     R1,GANGCOL
         SH    R1,=H'2'
         STC   R0,0(,R1)          QUIETLY FLAG GANG OVERLAY
NOGANG   BR    R10                RETURN
         TITLE 'THINGS OF GLOBAL INTEREST'
*
*
*  WORK AREAS USED WHEN BREAKING DOWN KEYWORDS
*
WTABLE   DS    0D                                                     A
WNAME    DC    CL8' '
WLIST    DC    CL8' '
WSSI     DC    CL8' '
WNEWNAME DC    CL8' '
WVERSION DC    CL8' '
WSEQ1    DC    CL8' '
WSEQ2    DC    CL8' '
WINCR    DC    CL8' '
WNEW1    DC    CL8' '
WINSERT  DC    CL8' '
WDUM2    DC    CL8' '
WCODE    DC    CL8' '
WCOL     DC    CL8' '
WGANG    DC    CL8' '
WSEQID   DC    CL8' '
WCOL1    DC    CL8' '
WCOL2    DC    CL8' '
WFROMSEQ DC    CL8' '
WTOSEQ   DC    CL8' '
WDDNAME  DC    CL8' '
*
GMEMB    DC    CL8' '             CURRENT MEMBER
RNAME    DC    CL8' '             MEMBER FOR STOWING (=GMEMB UNLESS V=)
*                                                                     A
MAXALIAS EQU   16                 MAXIMUM NUMBER OF ./ALIAS ALLOWED   A
ANAME    DC    (MAXALIAS)CL8' '   TABLE TO STORE ALIASES              A
ALIASPTR DC    A(0)               ADDRESS OF LAST ALIAS NAME ABOVE    A
WORKF    DC    F'0'               *MUST BE AT LEAST AS LONG AS FKEYFLGS
PINCR    DC    PL5'1'             DEFAULT FOR 'INCR=' (CAN SET VIA PARM
DINCR    DC    PL5'1'
DNEW1    DC    PL5'1'                                                 A
DWORK    DC    PL5'0'                                                 A
*                                                                82060
         FLAG  (PRVEJECT,PRVEJTST,FIXFAIL)                       82060
*
GFLAGS   DS    XL6                                               82060
         FLAG  (FLUSHING,COPYING,CHAINING,NAMES,UT2AVAIL,GINSERT,     AX
               WYLRUN,SEQFIX)                                    82060
        FLAG (LISTLEV,LISTDEL,LISTADD,ANYFCB,LISTRN,DECK,ADDDECK,TIMES)
         FLAG  (IDSEQ,OMFIRST,REMID,XFROMSEQ,XTOSEQ,VSTOW,PPVALUE,PPNO)
         FLAG  (CHAINUPD,COPY1,LOADING,LISTING,GUSER,                 AX
               NOWRITE,IMPLSEQ,GLISTALL)                              A
         FLAG  (DECKQ,XPARMS,PRMLIBID,GBLGANG,GBLSSI,GANGASM,          *
               WYLBUR,INTEGER)   INTEGER MUST BE LAST            82060
* NOTE: PRESS/UNPRESS ROUTINES EXPECT INTEGER AS LAST BIT.      JRE0036
         FLAG  (PARMNEW,PARMMOD)  IEBUPDTE PARM OPTIONS          82060
*
*  GLOBAL FLAGS - WHAT DO THEY REPRESENT.
*        LISTADD   SETS LIST=ALL FOR SYSIN ./ ADD CARDS          82060
*
*        NMPS      NEW MASTER PHYSICAL SEQUENTIAL
*        FLUSHING  ERROR ROUTINE SETS BEFORE FLUSHING TO NEXT FUNCTION
*        COPYING   SET WHILE A COPY IS IN PROGRESS (SYSLIB NOT RECURSIV
*        UT2AVAIL  SET IF SYSUT2 SUCCESSFULLY OPENED.
*        CHAINING  SET IF USER SPECIFIED CHAIN= VIA PARM KEYWORD
*        NAMES     SET IF NAME FIELD EXPECTED ON CONTROL CARDS (PARM)
*        LISTLEV   SET IF OUTPUT LISTING INCLUDES ALL UPDATE LEVELS
*        LISTDEL   SET IF PROGRAM IS TO LIST DELETED RECORDS
*        LISTRN    SET IF PROGRAM IS TO LIST RENUMBERED RECORDS
*        ANYFCB    SET BY SCAN ROUTINE IF ANY FCB'S ALLOCATED (SP=3)
*        DECK      SET IF SYSPUNCH OPEN FOR IEBDECK OPTION.
*        IDSEQ     SET BY AUTO-ID-SEQFLD ROUTINE IF LEADING CHARS FOUND
*        OMFIRST   SET ONLY WHILE READING FIRST SYSUT1 CARD
*        ADDDECK   SET TO BLOCK PARM=DECK IF SOURCE NOT FROM SYSUT1
*        TIMES     SET IF TIME STAMP TO BE STOWED WITH USER DATA
*        REMID     INDICATES SEQID NOT TO GO INTO SYSUT2
*        XFROMSEQ  USED TO VERIFY (FOR COPY) THAT FROMSEQ EXISTED.
*        XTOSEQ    SIMILAR TO ABOVE, BUT FOR TOSEQ.
*        GINSERT   SET (VIA PARM=INSERT), INDICATES INSERT IGNORES CDR
*        VSTOW     CHANGE/UPDATE MEMBER IS A "VERSION"
*        PPVALUE   SET IF PARM KEYWORD FOLLOWED BY '=' ON ./ PARM CARD
*        PPNO      SET IF PARM KEYWORD PREFIXED BY 'NO'
*        CHAINUPD  SET BY PARM IF CHAINED UPDATES IN PDS'S OK
*        COPY1     SET FOR COPY READ ROUTINE TO CHECK FIRST SEQID
*        LISTING   PARM=NOLISTING => NO UPDATE LISTING GENERATED.
*        GUSER     SET VIA PARM FOR GLOBAL USER EXIT.                 #
*        NOWRITE   SET WHEN ERROR HANDLER TAKES EXIT TO STOP I/O      A
*        GANGASM   SET WHEN GANG MAY HIT ASSEMBLER LANGUAGE DECKS
*        GBLGANG   SETS DEFAULT GANG TO SSI                      82060
*        SEQFIX    PARM OPTION - CAN OMIT LEADING SEQ2 DIGITS.        A
*        IMPLSEQ   PARM OPTION - SYSUT1 IMPLICITLY SEQUENCED.         A
*        GLISTALL  SET BY PARM=LISTALL                                A
*        DECKQ     PARM OPTION - DECK TO INCLUDE SEQUENCE CONTROLS.   A
*        XPARMS    PARM ROUTINE IS DOING EXEC PARMS.                SMP
*        PRMLIBID  CHAIN=ID SPECIFIED ON PARM=; ID SAVED         82060
*        PRVEJECT  ADD/CHANGE EJECT DONE IN KEYSCAN              82060
*        PRVEJTST  ON AFTER PRVEJECT TESTS (CONTINUATION)        82060
*        GBLSSI    USE GLOBAL SSI WHEN OMITTED ON ADD/CHANGE     82060
*        WYLBUR    SET TO LIST WYLBUR NUMBERS ON OUTPUT         JRE0036
*        WYLRUN    WYLBUR RUN (EDIT) MAY BE USED; SUPPRESS SEQ.  82060
*        INTEGER   SET IF WYLBUR EDIT FORMAT IS NOT USED &       82060
*                  SEQUENCE # IS IN THE WYLBUR LINE # FIELD.    JRE0036
*        PARMNEW   RESETS PARM=MOD OPTION                        82060
*        PARMMOD   DEFAULT - TREATS ADD AS REPL IF NOT LOADING/CHAINING
*
COND     DC    H'8'               MAY CHANGE VIA PARM CARD
*  SINGLE CARD BUFFER AREA FOR NM FILES (SYSUT2/SYSPUNCH SHARE NMREC)
NMAREA   DS    0CL106              SPACE FOR WYLBUR NUMBERS     JRE0036
NMWYL    DC    CL8' '                                           JRE0036
         DC    CL2' '                                           JRE0036
NMID     DC    CL6' '
NMREC    DS    0CL80
NMDATAF  DS    CL72                                                   V
NMSQ     DS    CL8
         DS    CL2
NMPSQ    DS    CL8
NMOSQ    DS    CL8
*
         DS    0H                                                     V
VBUFFER  DS    0CL(4+L'NMREC)                                         V
VBUFRDW  DC    2H'0'                                                  V
VBUF     DS    CL(L'NMREC)        USED IN HANDLING OF FORMAT V RECORDSV
*                                                                     V
WORKA    DS    D
WORKD    DC    D'0'
*  BLDLFA, WORKP1, AND PRODTTR USED ONLY BY POSITION (CHAINED UPDATES)
BLDLFA   DS    D                  SAVES LENGTH/ADDRESS OF BLDL LIST
WORKP1   DS    F                  PREVIOUS LEVEL UPDATE
PRODTTR  DS    XL3                TTR OF PRODUCTION VERSION
         DS    0D
BLANKS   DC    CL32' '            SUPPLY OF BLANKS FOR ALL SORTS USES #
CMDMOVE  MVC   WORKA(0),0(R1)
KEYMOVER MVC   7(0,R6),1(R1)
POSMOVER MVC   7(0,R14),0(R1)
PARMMOVE MVC   0(0,R3),2(R1)
GANGMOVE MVC   0(0,R1),CODE
GANGCHK  CLC   0(0,R1),BLANKS
CODEMOVE MVC   CODE(0),0(R4)
DOTSLASH DC    C'./'              IEBUPDTX CONTROL CHARACTERS
COL1     DC    H'0'
COL2     DC    H'0'
FROMSEQ  DC    CL8' '             LOWER LIMIT - COPY RANGE
TOSEQ    DC    CL8' '             UPPER LIMIT - COPY RANGE
USERNAME DC    CL8' '             NAME OF CURRENTLY LOADED USER ROUTINE
USERADR  DC    A(0)               ADDRESS OF CURRENT USER ROUTINE
GUNAME   DC    CL8' '             NAME OF GLOBAL USER ROUTINE         #
GUADR    DC    A(0)               AND ITS ADDRESS                     #
*
PRELEN   DC    H'0'               LENGTH-1 OF PREFIX STRING         SMP
PRENAME  DC    CL8' '             PREFIX STRING                     SMP
*                                                                   SMP
ABEND    EQU   14                 FOR ERROR MESSAGE MACRO        82060
TIMEWORD DC    F'0'               TIME STAMP (FOR STOWING)
DATEWORD DC    F'0'          CURRENT DATE LESS SIGN (000YYDDD)   82060
DEFSSI   DC    X'FF200000'  DEFAULT SSI (HEX)                    82060
DEFSSU   DC    X'0F0F02F0F0F0F0F0'  UNPACKED DEFAULT SSI         82060
SYSINADR DC    F'0'               ADDRESS OF FIRST UPDATE LEVEL
LIBADR   DC    A(0)               ADDRESS OF DSECT FOR SYSLIB
PARMADR  DC    A(0)               ADDRESS OF EXEC PARM FIELD
STEPRC   DC    F'0'               STEP RETURN CODE
WORKC    DC    F'0'
TIOTLOC  DC    F'0'
EREXIT   DC    A(0)               SPECIAL ERROR EXIT ADDRESS OR ZERO  A
PWA      XPRDCB DDNAME=SYSPRINT                                       C
PRCTL    XPRNTLIN PWA,LENGTH=L'CTLAREA,MF=L  PRINT CTLAREA REMOTE
         ORG   PRCTL         MAKE CALLS SHORTER                  82060
         DC    X'80',AL3(PRCTL+4)  ADDRESS OF LIST               82060
         ORG   ,                                                 82060
HEADING  XPRLDEF TEXT=HNAME,LENGTH=HEADINGL,SPA=3
HNAME    DC    CL8' '
         DC    CL2' '
         DC    C'IEBUPDTX -- CORNELL EXTENDED UPDATE PROGRAM.  '
         DC    C'VERSION 1.12 (SLAC V.&SYSDATE)'                JRE0036
HEADINGL EQU   *-HNAME
*
SSIWORK  DC    XL8'0'
         DC    XL8'0'             PADDING FOR SSIWORK
WORKS    DC    XL5'0'             STOW WORK FIELD
LEVCTR   DC    PL2'0'
*                                                                     A
IMPLNUM  DC    PL5'0'             USED TO IMPLICITLY SEQUENCE OM      A
*
         DS    0H
STOWLIST DS    0XL74              STOW WORK AREA
STOWNAME DC    CL8' '             MEMBER NAME
STOWTTR  DC    XL3'0'             TTR
STOWC    DC    XL1'0'             COUNT
STOWRN   DS    0CL8               16 BYTES FOR RENAME FUNCTION
STOWUD   DC    XL62'0'            USER DATA (FIRST 4 BYTES = SSI)
*
*  AREAS FOR BLDL-ING AND STOW-ING THE ALLOCATOR DIRECTORY ENTRY.
*
BLDALLOC DC    H'1,18'
         DC    C'@LLOCATR'
BATTR    DC    XL3'0'
         DC    XL2'0'
BAC      DC    XL1'0'
BAUD     DC    XL4'0'
*
STWALLOC DC    C'@LLOCATR'
STWATTR  DC    XL3'0'
STWAC    DC    X'02'
LIBID    DC    CL2' '
AMEMBID  DC    PL2'0'
*
SNAPDCB  DCB   DDNAME=SYSUBEND,DSORG=PS,RECFM=VBA,MACRF=W,LRECL=125,   X
               BLKSIZE=882
HEXTAB   DC    C'0123456789ABCDEF'
SCANWORK DC    CL72' '            SCAN WORK AREA (OMDATA IMAGE)
         DC    CL31' '            PADDING                             #
         FLAG  SCANFIX            SET IF CHANGE MADE TO CURRENT RECORD
*
*  CONSTANTS AND EXECUTED INSTRUCTIONS USED BY AUTO-ID-SEQFLD.
*
SEQIDLEN DC    F'0'               LENGTH-1 OF LEADING CHARS IN SEQFLD
SEQIDA   DC    CL8' '             SAVE LEADING SEQFLD ALPHABETICS HERE
SEQIDMV1 MVC   SEQIDA(0),CTLSQ    MOVES LEADING CHARS TO SAVE AREA
SEQIDMV  MVC   NMREC+72(0),SEQIDA MOVE SEQ-ID INTO SEQFLD FOR N.M.
SEQIDZ   MVC   CTLSQ(0),=8C'0'    ZERO LEADING SEQFLD CHARS FROM SYSUT1
SEQIDCHK CLC   NMREC+72(0),=8C'0' CHECK SEQID ONLY OVERLAYS ZEROS
SEQIDMV2 MVC   SEQIDA(0),0(R4)    FETCH CHARS FOR SEQID= KEYWORD SETUP
COPYM1   MVC   FROMSEQ(0),1(R5)                                      LB
COPYM2   MVC   TOSEQ(0),1(R5)                                        LB
*
*  CARD IMAGES FOR THE 'DECK' OPTION.
*
DECKCD1  DC    C'./ DELETE SEQ1='
DECKD1   DC    CL8' '
         DC    C',SEQ2='
DECKD2   DC    CL8' '
         DC    CL43' '            PAD TO 80
*
DECKCD2  DC    C'./ NUMBER INSERT=YES,SEQ1='
DECKI1   DC    CL8' '
         DC    C',NEW1='
DECKI2   DC    CL8' '
         DC    C',INCR='
DECKI3   DC    CL8'00000001'
         DC    CL18' '            PAD TO 80
*                                                                     A
DECKCD3  DC    C'./ NUMBER SEQ1='                                     A
DECKN1   DC    CL8' ',C',SEQ2='                                       A
DECKN2   DC    CL8' ',C',NEW1='                                       A
DECKN3   DC    CL8' ',C',INCR='                                       A
DECKN4   DC    CL8' ',CL15' '                                         A
*                                                                     C
         WRITE MDECB,SF,MF=L      MODEL DECB                          C
DECBLEN  EQU   *-MDECB                                                C
*
*  DATA AREAS CORRESPONDING TO 'NMDSECT' USED BY THE NM- I/O ROUTINES.
*
NMDATA   DC    7F'0'              BUFFER POINTERS   ---   SYSUT2      C
SYSUT2   DCB   DDNAME=SYSUT2,DSORG=PO,MACRF=W,                  JRE0036X
               EXLST=NMEXIT,SYNAD=CTLSYNAD,BUFCB=0                    A
         DC    H'0'               TRBAL                               C
         DC    H'0'               NMBDW                               V
         DC    XL3'0',X'0'   DCBRELAD, FLAGS                     82060
UT2COUNT DC    5F'0'         O/P COUNT; WYLBUR STUFF             82060
*
*  TABLE OF STANDARD DEFAULT DDNAMES USED BY IEBUPDTX.              SMP
*  THIS TABLE IS INITIALIZED BY DDINIT SUBROUTINE.                  SMP
*                                                                   SMP
DDNAMES  DS    0D                                                   SMP
DDLIB    DC    C'SYSLIB  '                                          SMP
DDIN     DC    C'SYSIN   '                                          SMP
DDPRINT  DC    C'SYSPRINT'                                          SMP
DDPUNCH  DC    C'SYSPUNCH'                                          SMP
DDUT1    DC    C'SYSUT1  '                                          SMP
DDUT2    DC    C'SYSUT2  '                                          SMP
NMNAME   EQU   DDUT2              NEW MASTER CURRENT DDNAME         SMP
OMNAME   EQU   DDUT1              OLD MASTER CURRENT DDNAME         SMP
LIBDD    EQU   DDLIB              COPY LIBRARY CURRENT DDNAME       SMP
*
PUDATA   DC    7F'0'              BUFFER POINTERS   ---   SYSPUNCH    C
SYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PO,MACRF=W,                      VX
               EXLST=NMEXIT,SYNAD=CTLSYNAD,BUFCB=0                    A
         DC    H'0'               TRBAL                               C
         DC    H'0'               NMBDW                               V
         DC    XL3'0',X'0'   DCBRELAD, FLAGS                     82060
PUNCOUNT DC    5F'0'         O/P COUNT; WYLBUR STUFF             82060
*
         LTORG
*
PRMTBLA  DC    A(PARMTBL)                                       JRE0036
PRMTBLXA DC    A(PARMTBLX)                                      JRE0036
CMDTABA  DC    A(CMDTABLE)                                      JRE0036
CMTENDA  DC    A(CMTEND)                                        JRE0036
KEYTABA  DC    A(KEYTABLE)                                      JRE0036
KEYTENDA DC    A(KEYTEND)                                       JRE0036
*
OBLIST   CAMLST SEARCH,JFCBDSNM-JFCBD+JFCB,JFCBVOLS-JFCBD+JFCB,DS1FMTID
         DS    0D
OBWORK   DS    350C                                                   V
         ORG   OBWORK-44                                         82060
         IECSDSL1 1          EXPAND FORMAT 1 DSCB                82060
         ORG   ,                                                 82060
         DS    0F                                                     V
JFCB     DS    XL176
         SPACE 1                                                 82060
DTITLE   DC    30C'_',C'DELETED',35C'_'                          80294
         DC    C'___AS_______PREV__'
DTITLEL  EQU   *-DTITLE            TITLE LENGTH                 JRE0038
NMTITLE  DC    30C'_',C'NEW_MASTER',32C'_'                       80294
         DC    C'_NEWSEQ_____PREV__'
NMTITLEL EQU   *-NMTITLE           TITLE LENGTH                 JRE0038
UNDERS   DC    132C'_'            LINE OF UNDERSCORES                 H
         TITLE 'EQUATES FOR FUNCTIONS AND PARAMETERS'            83013
*        SYMBOLIC DEFINITIONS FOR FUNCTIONS                      83013
*                                                                82060
         SEQU  ADD,REPL,PFX=VC    ADD, REPLACE                   82060
         SEQU  CHANGE,ENDUP  CHANGE, ENDUP                       82060
         SEQU  DROP,CURNT    DROP, CURRENT                       82060
         SEQU  PARM,LIST     PARM, LIST                          82060
         SEQU  LOAD,RENAM    LOAD, RENAME                        82060
         SEQU  GENAL,RESTR   GENALIAS, RESTORE                   82060
&GLOB#   SETA  &GLOB#-1      RESET FOR DEFINITION OF LAST MAJOR  82060
         SEQU  MAJOR         HIGHEST MAJOR VERB CODE             82060
*                                                                82060
*        DETAIL FUNCTIONS                                        82060
*                                                                82060
         SEQU  DELET,NUMBER,INSERT,REPLA  DEL, NUM, INS, REPLACE 82060
         SEQU  SEQ,COPY,ALIAS,GANG  SEQUENCE, COPY, ALIAS, GANG  82060
         SEQU  SCAN,NOTE,MACRO,FIX                               82060
         SEQU  USER,LOCATE,CSCAN,CFIX                            82060
         SPACE 2                                                 82060
*        SYMBOLIC DEFINITIONS FOR KEYWORD AND POSIT. OPERANDS    83013
*                                                                82060
         SEQU  NAME,PFX=VK   NAME                                82060
         SEQU  LIST,SSI,NEWNAM,VERS                              82060
         SEQU  SEQ1,SEQ2,INCR,NEW1                               82060
         SEQU  INS,DUM       INSERT=YES, DUMMY ENTRY             82060
         SEQU  CODE,COL,GANG,SEQID                               82060
         SEQU  COL1,COL2,FSEQ,TSEQ                               82060
         SEQU  DDN           DDNAME=                             82060
VKNONE   EQU   255             INVALID POSITIONAL                82060
         TITLE 'TABLE OF OI INSTRUCTIONS FOR KEYWORD FLAGS'      83013
*  TABLE OF SET (OR IMMEDIATE) INSTRUCTIONS FOR EACH KEYWORD.
*
*  (ASSOCIATED WITH EACH KEYWORD IS A FLAG WHOSE NAME IS FORMED BY
*  CONCATENATING AN 'F' TO THE KEYWORD'S PRINT NAME, AND AN 8 BYTE
*  WORK AREA IN THE GLOBAL AREA WHOSE NAME IS FORMED BY CONCATENATING
*  A 'W' TO THE KEYWORD'S PRINT NAME).
*
*
KEYFLAG  SET   FNAME
         SET   FLIST
         SET   FSSI
         SET   FNEWNAME
         SET   FVERSION
         SET   FSEQ1
         SET   FSEQ2
         SET   FINCR
         SET   FNEW1
         SET   FINSERT
         NOP   0                  DUMMY                          83013
         SET   FCODE
         SET   FCOL
         SET   FGANG
         SET   FSEQID
         SET   FCOL1
         SET   FCOL2
         SET   FFROMSEQ
         SET   FTOSEQ
         SET   FDDNAME
         TITLE 'TABLE OF VALID POSIT. PARAMETERS, BY FUNCTION'   83013
*  THE FOLLOWING TABLE IS USED BY 'KEYSCAN' TO INTERPRET POSITIONAL
*  PARAMETERS.  THERE IS ONE 4 BYTE ENTRY IN POSTAB FOR EACH ./
*  TYPE CONTROL CARD, ORDERED BY THE COMMAND'S SEQUENCE NUMBER.
*  EACH OF THE BYTES OF EACH ENTRY CONTAINS THE SEQUENCE NUMBER
*  OF A KEYWORD.  HENCE THE POSITIONAL PARAMETER INTERPRETER CAN
*  GET THE KEYWORD'S SEQUENCE NUMBER FROM THE PROPER BYTE OF POSTAB,
*  WHILE THE KEYWORD INTERPRETER GETS THIS INFORMATION FROM KEYTABLE.
*  NOTE - THIS IMPOSES A LIMIT OF 4 POSITIONAL OPERANDS PER CONTROL
*  STATEMENT.  ALSO, A BYTE OF ALL ONES IS USED TO INDICATE THAT NO
*  POSITIONAL PARAMETER IS ACCEPTABLE IN THAT POSITION.
*
*              SEQ. NUMBERS       COMMAND   POSITIONAL INTERPRETATION
*
POSTAB   POPS  NAME,VERS,SSI        ADD     (NAME,VERSION,SSI)   82060
         POPS  NAME,VERS,SSI        REPL    (NAME,VERSION,SSI)   82060
         POPS  NAME,VERS,SSI        CHANGE  (NAME,VERSION,SSI)   82060
         POPS  ,                    ENDUP                        82060
         POPS  NAME,VERS            DROP    (NAME,VERSION)       82060
         POPS  NAME,VERS            CURRENT (NAME,VERSION)       82060
         POPS  ,                    PARM                         82060
         POPS  NAME,VERS,FSEQ,TSEQ  LIST    (NAME,VERSION,FROMSEQ,TOSEQ
         POPS  ,                    LOAD                         82060
         POPS  NAME,NEWNAM          RENAME  (NAME,NEWNAME)       82060
         POPS  NAME,NEWNAM          GENALIAS (NAME,NEWNAME)      82060
         POPS  NAME +TTR,INDC,DATA  RESTORE (NAME)               82060
*                                                                     A
         POPS  SEQ1,SEQ2            DELETE  (SEQ1,SEQ2)          82060
         POPS  SEQ1,SEQ2,INCR,NEW1  NUMBER  (SEQ1,SEQ2,INCR,NEW1)
         POPS  SEQ1,INCR,NEW1       INSERT  (SEQ1,INCR,NEW1)     82060
         POPS  SEQ1,SEQ2,INCR,NEW1  REPLACE (SEQ1,SEQ2,INCR,NEW1)
         POPS  INCR,NEW1            SEQUENCE (INCR,NEW1)         82060
         POPS  NAME,VERS,FSEQ,TSEQ  COPY    (NAME,VERSION,FROMSEQ,TOSEQ
         POPS  NAME                 ALIAS   (NAME)               82060
         POPS  CODE,COL             GANG    (CODE,COL)           82060
         POPS  SEQ1,SEQ2,COL1,COL2  SCAN    (SEQ1,SEQ2,COL1,COL2)
         POPS  ,                    NOTE                         82060
         POPS  NAME,VERS            MACRO   (NAME,VERSION)       82060
         POPS  SEQ1,SEQ2,COL1,COL2  FIX     (SEQ1,SEQ2,COL1,COL2)
         POPS  NAME,SEQ1,SEQ2,CODE  USER    (NAME,SEQ1,SEQ2,CODE)
         POPS  SEQ1,INCR,NEW1       LOCATE  (SEQ1,INCR,NEW1)     82067
         POPS  SEQ1,SEQ2,COL1,COL2  CSCAN   (SEQ1,SEQ2,COL1,COL2)
         POPS  SEQ1,SEQ2,COL1,COL2  CFIX    (SEQ1,SEQ2,COL1,COL2)
         TITLE 'TABLE OF VALID KEYWORD PARAMETERS, BY FUNCTION'  83013
*  THIS TABLE CONTAINS ENTRIES FOR EACH VALID IEBUPDTX COMMAND SHOWING
*  WHICH KEYWORDS ARE ALLOWED WITH EACH COMMAND.
*  EACH ENTRY IS PATTERNED AFTER 'FKEYFLGS' (IN THE DSECT - LOCAL).
*  IF THE ARRANGEMENT OR NUMBER OF F-FLAGS IS CHANGED, THIS TABLE WILL
*  ALSO HAVE TO BE CHANGED (AS WHEN ADDING A NEW KEYWORD).
*  BE SURE WHEN ADDING A NEW KEYWORD AND ITS F-FLAG (AND W-AREA) THAT
*  YOU REPRESENT IT IN THE SAME BYTE RELATIVE TO THE FIRST BYTE OF THE
*  TABLE ENTRY FOR A COMMAND AS WHEN YOU DEFINED IT IN FKEYFLGS.
*
FVALID   DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION,L'FINCR+L'FNEW1,0)
         DC    AL1(L'FSEQID)                               ADD
         DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION,L'FINCR+L'FNEW1,0)
         DC    AL1(L'FSEQID)                               REPL  82060
         DC    AL1(L'FNAME+L'FLIST+L'FSSI+L'FVERSION+L'FNEWNAME) CHANGE
         DC    AL1(L'FINCR+L'FNEW1,0,L'FSEQID)             CHANGE CTD.
         DC    AL1(0,0,0,0)                                ENDUP
         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               DROP
         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               CURRENT
         DC    AL1(0,0,0,0)                                PARM
         DC    AL1(L'FNAME+L'FVERSION,0,0)         1/2     LIST  82067
         DC    AL1(L'FDDNAME+L'FFROMSEQ+L'FTOSEQ)  2/2     LIST  82067
         DC    AL1(0,0,0,0)                                LOAD
         DC    AL1(L'FNAME+L'FNEWNAME,0,0,0)               RENAME
         DC    AL1(L'FNAME+L'FNEWNAME,0,0,0)               GENALIAS   A
         DC    AL1(L'FNAME,0,0,0)                          RESTORE
*                                                                     A
         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,0)                  DELETE
         DC    AL1(0,L'FSEQ1+L'FSEQ2+L'FINCR+L'FNEW1+L'FINSERT,0,0) N
         DC    AL1(0,L'FSEQ1+L'FINCR+L'FNEW1,0,0)          INSERT
         DC    AL1(0,L'FSEQ1+L'FSEQ2+L'FINCR+L'FNEW1,0,0)  REPLACE
         DC    AL1(0,L'FINCR+L'FNEW1,0,0)                  SEQUENCE
         DC    AL1(L'FNAME+L'FVERSION,0,0)                 COPY
         DC    AL1(L'FFROMSEQ+L'FTOSEQ+L'FDDNAME)          COPY CTD.
         DC    AL1(L'FNAME,0,0,0)                          ALIAS
         DC    AL1(0,0,L'FCODE+L'FCOL,0)                   GANG
         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    SCAN
         DC    AL1(0,0,0,0)                                NOTE
         DC    AL1(L'FNAME+L'FVERSION,0,0,0)               MACRO
         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    FIX
         DC    AL1(L'FNAME,L'FSEQ1+L'FSEQ2,L'FCODE,0)      USER
         DC    AL1(0,L'FSEQ1+L'FINCR+L'FNEW1,0,0)          LOCATE
         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    CSCAN 82060
         DC    AL1(0,L'FSEQ1+L'FSEQ2,0,L'FCOL1+L'FCOL2)    CFIX  82060
         TITLE 'TABLE OF VALID PARM OPTIONS'                     83013
*  THE FOLLOWING TABLE DRIVES THE ANALYSIS OF 'PARM' PARAMETERS.JRE0036
*  THE FORMAT IS -                                              JRE0036
*        8 BYTES   KEYWORD NAME                                 JRE0036
*        1 BYTE    INDEX TO BRANCH TABLE, FOR THOSE OPTIONS     JRE0036
*                  WHICH REQUIRE SPECIAL "VALUE" PROCESSING.    JRE0036
*                  EG.  "INCR=1K"                               JRE0036
*        2 BYTES   BYTE OFFSET & BIT MASK TO SET A GLOBAL FLAG.  83014
*                  (THE PARM ROUTINE SETS/RESETS AUTOMATICALLY).JRE0036
*                  EG.  "NAMES" OR "NONAMES"                    JRE0036
*                                                               JRE0036
PARMTBL  DC    C'INCR    ',X'1',AL1(0,0)                        JRE0036
         DC    C'CHAIN   ',X'3',AL1(0,0)                        JRE0036
         DC    C'COND    ',X'4',AL1(0,0)                        JRE0036
         DC    C'DECK    ',X'5',AL1(0,0)                        JRE0036
         DC    C'OUTDD   ',X'6',AL1(0,0)                        JRE0036
         DC    C'INDD    ',X'7',AL1(0,0)                        JRE0036
         DC    C'USER    ',X'8',AL1(0,0)                        JRE0036
         DC    C'LIBDD   ',X'9',AL1(0,0)                        JRE0036
         DC    C'UPDATES ',X'A',AL1(0,0)                        JRE0036
         DC    C'SSI     ',X'B',AL1(0,0)                         82060
         DC    C'CTL     ',X'C',AL1(0,0)                         82060
         DC    C'LISTLEV ',X'0',AL1(LISTLEV-GFLAGS,L'LISTLEV)   JRE0036
         DC    C'LISTADD ',X'0',AL1(LISTADD-GFLAGS,L'LISTADD)    82102
         DC    C'LISTDEL ',X'0',AL1(LISTDEL-GFLAGS,L'LISTDEL)   JRE0036
         DC    C'LISTRN  ',X'0',AL1(LISTRN-GFLAGS,L'LISTRN)     JRE0036
         DC    C'TIMES   ',X'0',AL1(TIMES-GFLAGS,L'TIMES)       JRE0036
         DC    C'NAMES   ',X'0',AL1(NAMES-GFLAGS,L'NAMES)       JRE0036
         DC    C'INSERT  ',X'0',AL1(GINSERT-GFLAGS,L'GINSERT)   JRE0036
         DC    C'CHAINUPD',X'0',AL1(CHAINUPD-GFLAGS,L'CHAINUPD) JRE0036
         DC    C'LISTING ',X'0',AL1(LISTING-GFLAGS,L'LISTING)   JRE0036
         DC    C'ASM     ',X'0',AL1(GANGASM-GFLAGS,L'GANGASM)    82060
         DC    C'GANG    ',X'0',AL1(GBLGANG-GFLAGS,L'GBLGANG)    82060
         DC    C'SEQFIX  ',X'0',AL1(SEQFIX-GFLAGS,L'SEQFIX)     JRE0036
         DC    C'IMPLSEQ ',X'0',AL1(IMPLSEQ-GFLAGS,L'IMPLSEQ)   JRE0036
         DC    C'LISTALL ',X'0',AL1(GLISTALL-GFLAGS,L'GLISTALL) JRE0036
         DC    C'DECKQ   ',X'0',AL1(DECKQ-GFLAGS,L'DECKQ)       JRE0036
         DC    C'NEW     ',X'0',AL1(PARMNEW-GFLAGS,L'PARMNEW)    82060
         DC    C'INTEGER ',X'0',AL1(INTEGER-GFLAGS,L'INTEGER)   JRE0036
         DC    C'INT     ',X'0',AL1(INTEGER-GFLAGS,L'INTEGER)    82060
         DC    C'WYLRUN  ',X'0',AL1(WYLRUN-GFLAGS,L'WYLRUN)      82060
         DC    C'RUN     ',X'0',AL1(WYLRUN-GFLAGS,L'WYLRUN)      82060
         DC    C'WYLBUR  ',X'0',AL1(WYLBUR-GFLAGS,L'WYLBUR)     JRE0036
PARMTBLX DC    C'MOD     ',X'0',AL1(PARMMOD-GFLAGS,L'PARMMOD)    82060
         TITLE 'TABLE OF VALID COMMAND WORDS'                    83013
*  NOTE THAT THE HALFWORD STORED WITHIN EACH TABLE ENTRY        JRE0036
*  DETERMINES WHAT THE PROGRAM TAKES ANY COMMAND TO MEAN.       JRE0036
*  BECAUSE OF THIS, THE ORDER OF THE TABLE ENTRIES IS LOGICALLY JRE0036
*  INSIGNIFICANT (BUT MAY ALTER EFFICIENCY).                    JRE0036
*  NOTE ALSO THAT ENTRIES WITH COMMAND NUMBERS LESS THAN VCMAJOR ARE
*  MAJOR FUNCTIONS, WHILE THE OTHERS ARE DETAIL STATEMENTS.     JRE0036
*                                                               JRE0036
*  NEW COMMANDS MAY BE DEFINED BY CODING A 'VC...' DEFINITION    82060
*  IN THE MAJOR OR MINOR PORTION OF THE TABLE, RENUMBERING THE   82060
*  VC'S SUBSEQUENT IN THE TABLE, ADJUSTING THE MAINFTAB, CMDBTAB 82060
*  BRANCH TABLES, INSERTING THE PARAMETER DEFINITIONS IN POSTAB  82060
*  AND FVALID.  DEPENDENCIES EXIST FOR VCADD<VCREPL<VCCHANGE<VCENDUP,
*        VCDROP<VCCURNT, VCSCAN<VCFIX<VCCSCAN<VCCFIX.            82060
*                                                               JRE0036
CMDTABLE DS    0H                                               JRE0036
         DC    C'ADD     ',Y(VCADD)                             JRE0036
         DC    C'A       ',Y(VCADD)                             JRE0036
         DC    C'REPL    ',Y(VCREPL)                            JRE0036
         DC    C'CHANGE  ',Y(VCCHANGE)                          JRE0036
         DC    C'C       ',Y(VCCHANGE)                          JRE0036
         DC    C'CHA     ',Y(VCCHANGE)                           83013
         DC    C'REPRO   ',Y(VCCHANGE)                          JRE0036
         DC    C'ENDUP   ',Y(VCENDUP)                           JRE0036
         DC    C'DROP    ',Y(VCDROP)                            JRE0036
         DC    C'SCRATCH ',Y(VCDROP)                            JRE0036
*        DC    C'SCR     ',Y(VCDROP)                            JRE0036
         DC    C'CURRENT ',Y(VCCURNT)                           JRE0036
         DC    C'PARM    ',Y(VCPARM)                            JRE0036
         DC    C'LIST    ',Y(VCLIST)                            JRE0036
*DEAD*   DC    C'L       ',Y(VCLIST)                            JRE0036
         DC    C'LOAD    ',Y(VCLOAD)                            JRE0036
         DC    C'RENAME  ',Y(VCRENAM)                           JRE0036
         DC    C'GENALIAS',Y(VCGENAL)                           JRE0036
         DC    C'RESTORE ',Y(VCRESTR)   RESTORE OLD DIRECTORY    82060
         DC    C'RECOVER ',Y(VCRESTR)     ENTRY                  82060
*                                                               JRE0036
         DC    C'DELETE  ',Y(VCDELET)                           JRE0036
         DC    C'D       ',Y(VCDELET)                           JRE0036
         DC    C'DEL     ',Y(VCDELET)                            83013
         DC    C'NUMBER  ',Y(VCNUMBER)                          JRE0036
         DC    C'N       ',Y(VCNUMBER)                          JRE0036
         DC    C'NUM     ',Y(VCNUMBER)                           83013
         DC    C'INSERT  ',Y(VCINSERT)                          JRE0036
         DC    C'I       ',Y(VCINSERT)                          JRE0036
         DC    C'INS     ',Y(VCINSERT)                           83013
         DC    C'REPLACE ',Y(VCREPLA)                           JRE0036
         DC    C'R       ',Y(VCREPLA)                           JRE0036
         DC    C'REP     ',Y(VCREPLA)                            83013
         DC    C'SEQUENCE',Y(VCSEQ)                             JRE0036
         DC    C'Q       ',Y(VCSEQ)                             JRE0036
         DC    C'COPY    ',Y(VCCOPY)                            JRE0036
         DC    C'ALIAS   ',Y(VCALIAS)                           JRE0036
         DC    C'GANG    ',Y(VCGANG)                            JRE0036
         DC    C'G       ',Y(VCGANG)                            JRE0036
         DC    C'SCAN    ',Y(VCSCAN)                            JRE0036
         DC    C'S       ',Y(VCSCAN)                            JRE0036
         DC    C'NOTE    ',Y(VCNOTE)                            JRE0036
         DC    C'*       ',Y(VCNOTE)                             82060
         DC    C'MACRO   ',Y(VCMACRO)                           JRE0036
         DC    C'FIX     ',Y(VCFIX)                             JRE0036
         DC    C'F       ',Y(VCFIX)                             JRE0036
         DC    C'USER    ',Y(VCUSER)                            JRE0036
         DC    C'LOCATE  ',Y(VCLOCATE)                          JRE0036
         DC    C'L       ',Y(VCLOCATE)                          JRE0036
         DC    C'CSCAN   ',Y(VCCSCAN)  CONDITIONAL SCAN (NO ERROR)
         DC    C'CS      ',Y(VCCSCAN)                            82060
         DC    C'CFIX    ',Y(VCCFIX)  CONDITIONAL FIX (NO ERROR) 82060
         DC    C'CF      ',Y(VCCFIX)                             82060
         DC    C'CHNGE   ',Y(VCCHANGE)                          JRE0036
         DC    C'DELET   ',Y(VCDELET)                           JRE0036
         DC    C'NUMBR   ',Y(VCNUMBER)                          JRE0036
CMTEND   EQU   *-10                                             JRE0036
         TITLE 'TABLE OF VALID KEYWORDS'                         83013
KEYTABLE DC    C'NAME    ',Y(VKNAME)                            JRE0036
         DC    C'MEMBER  ',Y(VKNAME)                            JRE0036
         DC    C'LIST    ',Y(VKLIST)                            JRE0036
         DC    C'SSI     ',Y(VKSSI)                             JRE0036
         DC    C'NEWNAME ',Y(VKNEWNAM)                          JRE0036
         DC    C'VERSION ',Y(VKVERS)                            JRE0036
         DC    C'V       ',Y(VKVERS)                            JRE0036
         DC    C'SEQ1    ',Y(VKSEQ1)                            JRE0036
         DC    C'SEQ2    ',Y(VKSEQ2)                            JRE0036
         DC    C'INCR    ',Y(VKINCR)                            JRE0036
         DC    C'NEW1    ',Y(VKNEW1)                            JRE0036
         DC    C'INSERT  ',Y(VKINS)                             JRE0036
         DC    C'CODE    ',Y(VKCODE)                            JRE0036
         DC    C'E       ',Y(VKCODE)  EDITION ALIAS FAVOR       JRE0036
         DC    C'COL     ',Y(VKCOL)                             JRE0036
         DC    C'GANG    ',Y(VKGANG)                            JRE0036
         DC    C'SEQID   ',Y(VKSEQID)                           JRE0036
         DC    C'COL1    ',Y(VKCOL1)                            JRE0036
         DC    C'COL2    ',Y(VKCOL2)                            JRE0036
         DC    C'FROMSEQ ',Y(VKFSEQ)                            JRE0036
         DC    C'TOSEQ   ',Y(VKTSEQ)                            JRE0036
         DC    C'DDNAME  ',Y(VKDDN)                             JRE0036
         DC    C'LEVEL   ',Y(VKDUM)  DUMMY ENTRIES              JRE0036
         DC    C'SOURCE  ',Y(VKDUM)  DUMMY ENTRIES              JRE0036
         DC    C'SEQFLD  ',Y(VKDUM)  DUMMY ENTRIES              JRE0036
KEYTEND  DC    C'NEW     ',Y(VKDUM)  DUMMY ENTRIES              JRE0036
         DS    0F                                               JRE0036
*                                                               JRE0036
         TITLE 'SMALL SUBROUTINES'                               82060
*
*  THIS ROUTINE FETCHES SSI INFORMATION FROM THE WORK TABLE (WSSI)
*  (THE SSI GETS THERE IN RESPONSE TO 'SSI=...' ON A CONTROL STATEMENT)
*  TO ITS RESERVED LOCATION IN THE LOCAL DSECT.
*  IT IS CHECKED FOR VALID HEX DIGITS, AND THE NUMBER OF OMITTED SSI
*  DIGITS IS SAVED IN SSICOUNT.
*
SSIFETCH ENTSB PSTSAVE                                           82060
         XC    SSI,SSI            INITIALIZE RECEIVING AREA
         XR    R2,R2              COUNT OF BLANKS, AND INDEX
         LA    R4,1               INCREMENT
         LA    R5,7               LIMIT
*
SSIFL1   LA    R3,WSSI(R2)        POINTER TO INPUT DIGIT
         CLI   0(R3),C' '         TEST FOR BLANKS
         BNE   SSIFGOT            BRANCH OUT AFTER SCANNING LEADING BLK
         BXLE  R2,R4,SSIFL1
         ABEND 8,DUMP
*
SSIFGOT  ST    R2,SSICOUNT        SAVE COUNT OF BLANKS
SSIFL2   LA    R3,WSSI(R2)        POINT TO INPUT HEX DIGIT
         CLI   0(R3),C'F'
         BNH   SSIFL              BRANCH FOR A-F
         CLI   0(R3),C'0'
         BL    SSIBAD             ERROR FOR G-Z
         CLI   0(R3),C'9'         JUST FOR SAFETY
         BH    SSIBAD             (BUT WHO WOULD MULTIPUNCH THOSE ???)
         LA    R6,SSI(R2)         PLACE TO STORE RESULT BYTE
         MVN   0(1,R6),0(R3)      FETCH RESULT DIGIT (0-9)
         B     SSIFNEXT
*
SSIFL    XR    R1,R1
         IC    R1,0(,R3)          PICK UP INPUT DIGIT (A-F)
         SH    R1,=H'183'         CONVER TO HEX (4 BITS)
         STC   R1,SSI(R2)         PLACE IN RESULT AREA
SSIFNEXT BXLE  R2,R4,SSIFL2
         SET   SSISPEC
         ENDSB PSTSAVE                                           82060
*
SSIBAD   ERROR '*** INVALID (NON-HEX) SSI DATA ***'
         SPACE 1                                                 82060
*        ROUTINE TO SET GANG FROM SSI                            82060
*                                                                82060
DEFGANG  ENTSB PSTSAVE                                           82060
         IF    ¬SSISPEC,DEFGANGX   EXIT IF SSI NOT AVAILABLE     82060
         MVC   CODE,BLANKS   CLEAR GANG CODE                     82060
         MVC   WORKA,SSI     COPY SSI                            82060
         MVZ   WORKA,=8C'0'  MAKE F ZONES                        82060
         TR    WORKA,HEXTAB-C'0'   MAKE PRINTABLE                82060
         LA    R1,8          SET NUMBER OF TIMES TO CHECK        82060
         LA    R4,WORKA      POINT TO FIRST DIGIT                82060
DEFGANGA CLI   0(R4),C'0'    LEADING ZERO ?                      82060
         BNE   DEFGANGB      NO                                  82060
         LA    R4,1(,R4)                                         82060
         BCT   R1,DEFGANGA   TRY AGAIN                           82060
         B     DEFGANGX      NONE - EXIT                         82060
DEFGANGB BCTR  R1,0          NUMBER TO MOVE                      82060
         EX    R1,CODEMOVE   MOVE TO GANG AREA                   82060
         ST    R1,GANGLEN    SAVE LENGTH                         82060
         LA    R2,70         SET FOR COLUMN 72-LENGTH            82060
         SR    R2,R1                                             82060
         AIF   ('&LOCAL' NE 'CCSI').NOGAN66                      82060
         CH    R1,=H'4'      LENGTH = 5 (STD SSI DATE) ?         82060
         BNE   *+6           NO                                  82060
         BCTR  R2,0          PUT INTO COLUMN 66                  82060
.NOGAN66 ST    R2,GANGCOL    SET GANG OFFSET                     82060
         SET   GANG          SHOW GANG AVAILABLE                 82060
DEFGANGX ENDSB PSTSAVE       RETURN                              82060
         TITLE 'REPLACE PROCESSING - GET AND PRINT OLD DATA'     82060
         DROP  R9                                                82060
PRESTOW  ENTSB PSTSAVE       ROUTINE TO TEST PRIOR TO STOW       82060
         MVC   PSTLINE(3),=C'OLD'   SET FOR OLD DATA             82060
         RESET PSTFLAG       RESET DATA AVAILABLE FLAG           82060
         USING NMDSECT,R6    PASSED BY CALLER                    82060
         IF    NMPS,PRESTOWX   SKIP IF SEQUENTIAL OUTPUT         82060
         MVC   PSTNAME,0(R1)  COPY MEMBER/ALIAS NAME             82060
         BLDL  NM,PSTBLDL    LOCATE OLD MEMBER                   82060
         BXH   R15,R15,PRESTOWX   NOT FOUND; RETURN              82060
         CLI   PSTTTR+2,0    ANY R IN TTR ?                      82060
         BE    PRESTOWX      NO; SKIP                            82060
         SET   PSTFLAG       SHOW DATA AVAILABLE                 82060
PRESTOWX ENDSB PSTSAVE       RETURN TO CALLER (NO RETURN CODE)   82060
         SPACE 2                                                 82060
*        ROUTINE TO FORMAT NEW DIRECTORY DATA FOR AN ADD         82060
POSTSTAD ENTSB PSTSAVE                                           82060
         RESET PSTFLAG                                           82060
         IF    NMPS,POSTSTAX   QUIT IF SEQUENTIAL                82060
         MVC   PSTNAME,0(R1)   COPY MODULE NAME                  82060
         BLDL  NM,PSTBLDL    SEE IF REALLY THERE                 82060
         BXH   R15,R15,POSTSTAX  NO                              82060
         CLI   PSTTTR+2,0    VALID R IN TTR ?                    82060
         BE    POSTSTAX      NO                                  82060
         SET   PSTFLAG       SET DATA AVAILABLE                  82060
         MVC   PSTLINE(3),=C'NEW'  SET FOR NEW DATA              82060
POSTSTAX LM    R2,R10,PSTSAVE  RESTORE REGISTERS                 82060
         BALR  R15,0         FAKE A CALL TO POSTSTOW             82060
         SPACE 1                                                 82060
*        ROUTINE TO FORMAT DATA GOTTEN BY PRESTOW                82060
POSTSTOW ENTSB PSTSAVE                                           82060
         IF    ¬PSTFLAG,POSTSTOX  RETURN IF NO DATA              82060
         MVC   PSTLSSID(PSTLLAST-PSTLSSID),PSTLSSID-1  CLEAR LINE
         MVC   PSTLNAME,PSTNAME  COPY MEMBER/ALIAS NAME          82060
         LA    R4,PSTTTR     POINT TO TTR I/P                    82060
         LA    R3,PSTLTTR    POINT TO TTR O/P                    82060
         LA    R1,L'PSTTTR   SET INPUT LENGTH                    82060
         BAL   R5,HEXCNVT    CONVERT TO HEX                      82060
         LA    R4,PSTINDC    POINT TO FLAGS/LENGTH               82060
         LA    R3,PSTLINDC   AND OUTPUT                          82060
         LA    R1,L'PSTINDC  SET INPUT LENGTH                    82060
         BAL   R5,HEXCNVT    FORMAT HEX                          82060
         LA    R4,PSTSSI     POINT TO USER DATA (SSI+ )          82060
         LA    R0,X'1F'      MAKE MASK FOR LENGTH                82060
         IC    R14,PSTINDC   GET FLAGS AND LENGTH                82060
         NR    R14,R0        ISOLATE LENGTH                      82060
         BZ    POSTSTOP      NOTHING TO ADD                      82060
         LA    R0,2          SET SSI LENGTH IN HALF-WORDS        82060
         CR    R14,R0        ANY SSI PRESENT ?                   82060
         BL    POSTSTOP      NO; JUST DO DATA                    82060
         LA    R1,4          SET SSI LENGTH IN BYTES             82060
         LA    R3,PSTLSSI    POINT TO SSI O/P                    82060
         MVC   PSTLSSID,=C'SSI='  IDENTIFY                       82060
         BAL   R5,HEXCNVT    FORMAT                              82060
         SR    R14,R0        GET LENGTH AFTER SSI                82060
         BNP   POSTSTOP      NOTHING ELSE                        82060
POSTSTOD LA    R3,PSTLDAT    POINT TO DATA OUTPUT                82060
         LA    R15,9         SET MAXIMUM THAT FITS               82060
         CR    R14,R15       MORE THAN MAX ?                     82060
         BNH   *+6           NO                                  82060
         LR    R14,R15       TRUNCATE                            82060
         MVC   PSTLDAD,=C'DATA='  IDENTIFY                       82060
POSTSTOL LA    R1,2          SET INPUT LENGTH - ONE HALFWORD     82060
         BAL   R5,HEXCNVT    CONVERT IT                          82060
         LA    R3,1(,R3)     SKIP EXTRA SPACE IN OUTPUT          82060
         BCT   R14,POSTSTOL  DO NEXT HALFWORD                    82060
POSTSTOP XPRNTLIN PWA,TEXT=PSTLINE,LENGTH=PSTLLAST-PSTLINE,            *
               OFFSET=7      LINE UP ?                           82060
POSTSTOX RESET PSTFLAG                                           82060
         ENDSB PSTSAVE       RETURN; NO CODE                     82060
         TITLE 'COMMON PRE-OPEN VALIDITY CHECKING'               82060
*        COMMON OPEN PROCESSING AND VALIDITY CHECKING FOR ALL FILES
*        CALLED WITH R2=>DCB, R5=> JFCB  DDNAME IN OBWORK(8)     82060
*              FIELD CMOIO IS PRESET TO ' IN' OR 'OUT'           82060
*        RC15= 0 - PO;  4 - PO AS PS; 8 - PS; 12 - NO DD         82060
*        OTHER ERRORS CAUSE LOCAL ABEND                          82060
*                                                                82060
COMOPEN  ENTSB  PSTSAVE                                          82060
         USING IHADCB,R2     DECLARE THE DCB                     82060
         USING JFCBD,R5      DECLARE THE JFCB                    82060
         MVI   DCBDSORG,DCBDSGPO  INITIALIZE REUSABLE DCB        80002
         MVI   CMODSO+1,C'O'   PRESET FOR DSORG=PO               82060
         MVC   CMOLVL,BLANKS   CLEAR THE LEVEL NUMBER            82060
         MVC   CMOBLK(CMOBLKL),BLANKS  CLEAR MEMBER AND VOLSER   82060
         MVC   CMODDN,OBWORK   COPY THE DDNAME                   82060
         DEVTYPE OBWORK,OBWORK+8  DD CARD PRESENT ?              82060
         BXH   R15,R15,COMOX12    NO; SET RETURN CODE 12         82060
         RDJFCB ((R2))       GET DSN, VOLSER, MEMBER, ETC.       82060
         BXH   R15,R15,COMOX12    NOT READ ?  SET RETURN CODE 12 82060
         MVC   CMODSN,JFCBDSNM  COPY THE DATASET NAME            82060
         CLI   OBWORK+10,UCB3DACC  DASD DATASET ?                82060
         BNE   COMOSEQ       NO; SET SEQUENTIAL                  82060
         TM    JFCBTSDM,JFCSDS    SYSIN/SYSOUT DATASET ?         82060
         BO    COMOSEQ       YES; DON'T MESS WITH IT             82060
         OBTAIN OBLIST       READ THE FORMAT 1 DSCB              82060
         BXLE  R15,R15,COMOBT   GOOD                             82060
         ERROR '*** OBTAIN FAILED FOR DD DDNAMECM ***',                *
               (25,CMODDN),RC=ABEND                              82060
COMOBT   CLI   DS1DSORG+1,0   ACCEPTABLE DSORG ?                 82060
         BNE   COMOBORG      NO                                  82060
         TM    DS1DSORG,255-JFCORGPO-JFCORGPS-JFCORGU            82060
         BZ    COMOBTO       NOT INVALID                         82060
COMOBORG ERROR '*** DDNAMECM DATASET ORGANIZATION INVALID OR INCONSISTE*
               NT',(4,CMODDN),RC=ABEND                           82060
COMOBTO  TM    DS1DSORG,JFCORGPO   EXISTING PARTITIONED DATASET ?
         BZ    COMOBSEQ      NO; CHECK JFCB                      82060
         TM    JFCBIND1,JFCPDS   MEMBER SPECIFIED ?              82060
         BNZ   COMOBSEM      YES; TREAT AS SEQUENTIAL            82060
         CLI   JFCDSORG+1,0    ANY FUNNIES ?                     82060
         BNE   COMOJORG      YES; FAIL                           82060
         TM    JFCDSORG,255-JFCORGPO-JFCORGU  FUNNY ?            82060
         BZ    COMODCB       NO; CHECK DCB                       82060
COMOJORG ERROR '*** DDNAMECM DSORG ON DD DOES NOT MATCH DATASET ***',  *
               (4,CMODDN),RC=ABEND                               82060
COMOBSEQ TM    JFCBIND1,JFCPDS  MEMBER ?                         82060
         BNZ   COMOJORG                                          82060
COMOBSEM CLI   JFCDSORG+1,0                                      82060
         BNE   COMOJORG                                          82060
         TM    JFCDSORG,255-JFCORGPS-JFCORGU                     82060
         BNZ   COMOJORG                                          82060
COMODCB  MVC   WORKA(1),DS1RECFM                                 82060
         MVC   WORKA+1(1),JFCRECFM                               82060
         NC    WORKA(2),=2AL1(JFCUND)                            82060
         TM    DS1RECFM,JFCUND     RECFM ON DSCB ?               82060
         BZ    COMODCBF      NO; NO TEST                         82060
         TM    JFCRECFM,JFCUND     RECFM ON JFCB ?               82060
         BZ    COMODCBF      NO                                  82060
         CLC   WORKA(1),WORKA+1    MATCH ?                       82060
         BE    COMODCBF      YES                                 82060
COMOBDCB TM    DS1DSORG,JFCORGPO   PARTITIONED ?                 82060
         BNZ   COMOCDCB      YES; NO RECOVERY                    82060
         CLI   CMOIO,C'O'    OUTPUT DATASET ?                    82060
         BE    COMODCBD      YES; PERMIT COMPLETE CHANGE         82060
COMOCDCB ERROR '*** DDNAMECM DCB PARAMETERS ON DD INCOMPATIBLE WITH DAT*
               ASET ***',(4,CMODDN),RC=ABEND                     82060
COMODCBF OC    WORKA(1),WORKA+1   COMBINE THE TWO                82060
         XR    R0,R0         FOR FAST ZERO TESTS                 82060
         TM    WORKA,JFCUND  RECFM=U OR UNSPECIFIED ?            82060
         BNM   COMODCBB      YES; DO NOT TEST LRECL              82060
         CH    R0,DS1LRECL   ANY LRECL ?                         82060
         BE    COMODCBB      NO; DON'T TEST                      82060
         CH    R0,JFCLRECL                                       82060
         BE    COMODCBB                                          82060
         CLC   JFCLRECL,DS1LRECL  SAME LRECL ?                   82060
         BNE   COMOBDCB      NO; FAIL                            82060
COMODCBB CH    R0,DS1BLKL    BLOCKSIZE SPECIFIED ?               82060
         BE    COMODCBD      NO                                  82060
         CH    R0,JFCBLKSI   JFCB BLOCKSIZE SPECIFIED ?          82060
         BE    COMODCBD      NO                                  82060
         CLC   JFCBLKSI,DS1BLKL  COMPATIBLE ?                    82060
         BL    COMOBDCB      NO                                  82060
*        IF HIGH, USER MAY BE TRYING TO RESTORE CLOBBERED VALUE  82060
*        DCBEXIT WILL CATCH IF NOT MULTIPLE OF LRECL FOR F/FB    82060
COMODCBD LA    R15,4         SET RETURN 4 FOR PO OPEN FOR PS     82060
         TM    JFCBIND1,JFCPDS   MEMBER SPECIFIED ?              82060
         BNZ   COMOSEQ2      YES; SET FOR SEQUENTIAL I/O         82060
         XR    R15,R15       SET FOR PO                          82060
         TM    DS1DSORG,JFCORGPO  PO ?                           82060
         BNZ   COMOX15       YES; GO TO COMMON EXIT              82060
COMOSEQ  LA    R15,8         SET RETURN CODE FOR PS              82060
         CLI   JFCDSORG+1,0                                      82060
         BNE   COMOBORG                                          82060
         TM    JFCDSORG,255-JFCORGPS-JFCORGU                     82060
         BNZ   COMOBORG                                          82060
         TM    JFCBIND1,JFCPDS                                   82060
         BNZ   COMOBORG                                          82060
COMOSEQ2 MVI   CMODSO+1,C'S'  LABEL WITH PS                      82060
         MVI   DCBDSORG,DCBDSGPS  SET DCB FOR SEQUENTIAL         82060
         NI    DCBMACR1,255-DCBMRPT1  RESET POINT                82060
         NI    DCBMACR2,255-DCBMRPT2                             82060
COMOX15  ENDSB PSTSAVE       RETURN TO CALLER                    82060
COMOX12  LA    R15,12        SET RETURN CODE 12 - NO DD          82060
         B     COMOX15       RETURN                              82060
         DROP  R2,R5
         TITLE 'FIX/SCAN ERROR MESSAGES'                         82060
*        ROUTINE TO PRINT FIX/SCAN CARDS NOT USED                82060
*                                                                82060
         USING FCB,R6        PASSED BY CALLER                    82060
FAILFIX  ENTSB PSTSAVE                                           82060
         IF    FIXUSED,FAILFIXX  SHOULD NOT HAVE GOTTEN HERE     82060
         MVC   FAFFS,=C' FIX'    SET MOST FREQUENT CONDITION     82060
         IF    FIX,FAILFIXA                                      82060
         MVC   FAFFS,=C'SCAN'   ELSE SET FOR SCAN                82060
FAILFIXA IF    ¬FIXSEQ,FAILFIXB  ANY CARDS IN RANGE ?            82060
         MVC   FAFEXP,FAFNMTCH  SHOW NO MATCH FOUND              82060
         B     FAILFIXC                                          82060
FAILFIXB MVC   FAFEXP,FAFNSEQ   SHOW NO CARDS IN RANGE           82060
FAILFIXC MVC   FAFSEQ1,FCBSEQ1  SHOW START SEQUENCE              82060
         CLI   FAFSEQ1,C'$'  INVALID SEQUENCE NUMBER ?           82060
         BNL   *+10          NO ?                                82060
         MVC   FAFSEQ1,=8C'0'  REPLACE BY ZEROES                 82060
         MVC   FAFSEQ2,FCBSEQ2     AND END                       82060
         CLI   FAFSEQ2,C'9'  END RANGE ?                         82060
         BH    FAILFIXD      YES; REPLACE IT                     82060
         CLI   FAFSEQ2,C'$'  INVALID ?                           82060
         BNL   FAILFIXE      NO; LEAVE IT                        82060
FAILFIXD MVC   FAFSEQ2,=8C'9'  MAKE END RANGE                    82060
FAILFIXE LH    R1,FCBCOL1       GET START OFFSET                 82060
         LA    R1,1(,R1)        MAKE COLUMN NUMBER               82060
         MH    R1,=H'1000'   FINAGLE TO GET END COLUMN IN        82060
         AH    R1,FCBCOL2        ADD END COLUMN OFFSET           82060
         LA    R1,1(,R1)         MAKE TRUE END COLUMN            82060
         CVD   R1,WORKA          PACK                            82060
         UNPK  FAFCOL1(5),WORKA+5(3)  UNPACK                     82060
         MVI   FAFCOL1+2,C'/'    MAKE SEPARATOR                  82060
         OI    FAFCOL2+L'FAFCOL2-1,C'0'  ENSURE GOOD ZONE        82060
         LA    R2,FAFVER     POINT TO FIRST OUTPUT FIELD         82060
         LA    R3,FCBBAD     POINT TO INPUT TEXT                 82060
         LA    R4,FCBLENB    POINT TO LENGTH                     82060
         LA    R5,2          DO ONCE FOR VER, ONCE FOR REP       82060
         MVI   FAFVER-FAFVER(R2),C' '   CLEAR OUTPUT FIELD + QUOTE
         MVC   FAFVER+1-FAFVER(FAFRQ+1-FAFVER,R2),FAFVER-FAFVER(R2)
         B     FAILFIXL      SKIP SECOND TIME CODE               82060
FAILFIXK MVC   2(5,R1),=C'REP='''  IDENTIFY REPLACEMENT TEXT     82060
         LA    R2,7(,R1)     POINT TO NEW OUTPUT LOCATION        82060
FAILFIXL XR    R1,R1         CLEAR FOR ICM                       82060
         ICM   R1,3,FCBLENB-FCBLENB(R4)  LOAD AND TEST LENGTH    82060
         BNM   FAILFIXM      NON-ZERO; MOVE USER DATA            82060
         XR    R1,R1         ENSURE VALUE IS -1, NOT JUST MINUS  82060
         BCT   R1,FAILFIXQ   SET -1                              82060
FAILFIXM EX    R1,FAFMVC     MOVE USER DATA TO LINE              82060
FAILFIXQ LA    R1,FAFVER+1-FAFVER(R1,R2)  POINT PAST LAST BYTE   82060
         MVI   0(R1),C''''   ADD TRAILING QUOTE                  82060
         LA    R3,FCBGOOD-FCBBAD(,R3) NEXT INPUT                 82060
         LA    R4,FCBLENG-FCBLENB(,R4)  NEXT LENGTH FIELD        82060
         BCT   R5,FAILFIXK   REPEAT FOR REPLACE DATA             82060
         XPRNTLIN PWA,TEXT=FAFLINE,LENGTH=FAFLINEL  PRINT ERROR MSG
         XPRNTLIN PWA,TEXT=FAFLINE2,LENGTH=FAFLIN2L,OFFSET=23 FCB
         XPRSPACE PWA        WHY DOESN'T SPA ON XPRNTLIN WORK ?  82060
         IF    FIXCOND,FAILFIXX  NO ERROR IF CONDITIONAL         82060
         SET   FIXFAIL       SET FOR END OF MEMBER MESSAGE       82060
FAILFIXX ENDSB PSTSAVE       RETURN TO CALLER                    82060
         SPACE 1                                                 82060
FAFMVC   MVC   FAFVER-FAFVER(0,R2),FCBBAD-FCBBAD(R3)             82060
         SPACE 1                                                 82060
PSTSAVE  DC    9F'0'         LOCAL SAVE AREA                     82060
PSTBLDL  DC    Y(1,PSTFLAG-PSTNAME)   BLDL PREFIX                82060
PSTNAME  DC    CL8' '        MODULE NAME                         82060
PSTTTR   DC    XL3'0'        TTR                                 82060
         DC    XL2'0'        BLDL CNCT/LIBF                      82060
PSTINDC  DC    X'00'         FLAGS/LENGTH                        82060
PSTSSI   DC    XL4'0'        SSI (OPTIONAL)                      82060
PSTDATA  DC    9XL2'0'       OTHER DATA                          82060
         SPACE 1                                                 82060
         FLAG  (PSTFLAG)     FLAG AND END OF BLDL AREA           82060
         SPACE 1                                                 82060
PSTLINE  DC    C'OLD '                                           82060
PSTLNAME DC    CL8' '        MEMBER NAME                         82060
         DC    C' ENTRY: TTR='                                   82060
PSTLTTR  DC    CL6' ',C' INDC='                                  82060
PSTLINDC DC    CL2' ',C' '                                       82060
PSTLSSID DC    C'SSI='                                           82060
PSTLSSI  DC    CL8' ',C' '                                       82060
PSTLDAD  DC    C'DATA='                                          82060
PSTLDAT  DC    9CL5' '                                           82060
PSTLLAST EQU   *-1                                               82060
         SPACE 1                                                 82060
FAFNSEQ  DC    C'NO CARDS IN RANGE ***'                          82060
FAFNMTCH DC    CL(L'FAFNSEQ)'NO MATCH FOUND ***'                 82060
FAFLINE  DC    C'*** '                                           82060
FAFFS    DC    C'SCAN',C' NOT APPLIED - '   SCAN OR FIX          82060
FAFEXP   DC    CL(L'FAFNSEQ)' '                                  82060
FAFLINEL EQU   *-FAFLINE                                         82060
         SPACE 1                                                 82060
FAFLINE2 DC    C'SEQ='                                           82060
FAFSEQ1  DC    CL8' ',C'/'                                       82060
FAFSEQ2  DC    CL8' ',C' COL='                                   82060
FAFCOL1  DC    CL2' ',C'/'                                       82060
FAFCOL2  DC    CL2' ',C' VER='''                                 82060
FAFVER   DC    CL32' '                                           82060
FAFVQ    DC    C' ',C' REP='''                                   82060
FAFREP   DC    CL32' '                                           82060
FAFRQ    DC    C' '          TRAILING QUOTE                      82060
FAFLIN2L EQU   *-FAFLINE2                                        82060
         SPACE 1                                                 82060
         DROP  R10                                               82060
         SPACE 1                                                 82060
         LTORG ,             EXPAND BEFORE 'LOCAL' DSECT         82060
         TITLE 'LOCAL DEFINITION AND INITIALIZER'                82060
IEBUPDTX CSECT ,                                                 82060
         USING LCLINIT,R12                                       82060
*
*  SUBROUTINE OF IEBUPDTX.
*  INITIALIZE STORAGE AREA AS A LOCAL DSECT TARGET.
*
LCLINIT  SAVE  (14,12),,*                                        82060
         LR    12,15
         LR    2,13
         LA    13,SA
         ST    2,4(,13)
         ST    13,8(,2)
*
         GETMAIN EU,LV=LOCALSZ,SP=2,A=GETPTR
         L     2,GETPTR
         MVC   0(256,2),NEXTLEV
         MVC   256(256,2),NEXTLEV+256
         MVC   512(LOCALSZ-512,2),NEXTLEV+512
*
         L     13,4(,13)
         L     14,12(,13)
         RETURN  12,T
*
SA       DS    18F
GETPTR   DC    F'0'
*
*  DSECT DESCRIBING THE DATA MAINTAINED INDIVIDUALLY FOR EACH
*  UPDATE FILE (FOR RECURSIVE UPDATE ABILITY) AS WELL AS SYSUT1, SYSLIB
*
*
         PRINT &PRTMAC                                           82060
         LOCAL TYPE=CODE                                        JRE0036
*
*  LOCAL FLAGS     USAGE
*
*        FXXXXX    ALL THE 'F' FLAGS ARE SET ON WHEN THE KEYSCAN
*                  ROUTINE FINDS THE CORRESPONDING KEYWORD.
*        ADD       SET IF MAJOR FUNCTION IS ADD-REPL
*        CHANGE    SET IF MAJOR FUNCTION IS CHANGE-REPRO
*        DELETE    SET IF DELETE OPERATION IN PROGRESS
*        INSERT    SET IF INSERT OPERATION IN PROGRESS
*        NUMBER    SET IF RENUMBER (SPECIFIC RANGE) IN PROGRESS
*        LOCATE    SET IF LOCATE OPERATION IN PROGRESS(AS IS NUMBER)  A
*        INSERTX   SET WHEN INSERT OPERATION IS TERMINATED TO INDICATE
*                  THAT RENUMBERING MAY BE REQUIRED.
*                  RESET WHEN THE OLD MASTER SEQUENCING IS OK AGAIN.
*        USER      SET WHEN USER UPDATE EXIT IS ACTIVE
*        UINSERT   SET IF USER ROUTINE MAKES AN INSERTION.
*        SEQALL    SET IF INPUT CARDS ARE TO BE ASSIGNED SEQUENCE NO.S
*        LISTALL   SET IF USER HAD LIST=ALL KEYWORD
*        SSISPEC   SET IF SSI=... WAS SPECIFIED
*        CTLWAIT   SET TO STOP CTL-READS TEMPORARILY
*        OMWAIT    SET TO STOP OLD MASTER READS TEMPORARILY
*        OMEOF     SET WHEN OLD MASTER INDICATES END OF FILE
*        NOINSERT  RESET AFTER FIRST CARD INSERTED (FLAGS NONE INSERTED
*        XSEQ1     USED TO NOTE IF SEQ1 EXISTED IN OLD MASTER
*        XSEQ2     SAME AS ABOVE, FOR SEQ2.
*        INSERT1   SET BY ALIAS/INSERT TO CAUSE IMMEDIATE RE-CTLREAD.
*        ALIAS     SET AFTER ALIAS CARD SCANNED
*        COPY      SET WHILE COPY OPERATION IN PROGRESS (THIS LEVEL)
*        GANG      SET WHEN THE 'GANG' INPUT OPTION IS REQUESTED.
*
*        CTLEOF    SET WHEN CONTROL FILE IS AT LOGICAL EOF
*        REALEOF   SET WHEN CONTOL FILE AT PHYSICAL EOF
*        CTLPS     SET IF THIS CONTROL FILE IS SEQUENTIAL
*        BUFEMPTY  USED BY CTL I/O ROUTINES WHEN BUFFER IS EMPTY
*        SYSUT1    SET ON IN SYSUT1'S DSECT ONLY
*        SYSIN     SAME AS ABOVE, BUT FOR SYSIN
*        POSING    SET WHILE POSITIONING A FILE (USED BY ERROR RTN)
*        HELD      SET IF AN UPDATE IS WAITING FOR SYSIN TO MATCH IT.
*        TEMPUPD   LEVEL CREATED FOR A CHAINED UPDATE
*        CHAINED   THIS LEVEL SUPPORTING ELEMENT OF A CHAINED UPDATE
*
*
*  IF THIS LEVEL IS A MEMBER OF AN UPDATE CHAIN, ITS DCB IS NOT
*  USED FOR I/O (FOR EFFICIENCY - IT'S NOT EVEN OPENED), UNLESS
*  THIS IS THE CHAIN'S CREATING LEVEL (THE ONE CREATED PERMANENTLY
*  BY THE TIOT SCAN AT INITIALIZATION).
*
*  THE FULLWORD 'REALDCB' WILL CONTAIN A POINTER TO THE MAIN
*  LEVEL'S DCB, WHICH IS USED AMOUNG ALL MEMBERS OF THE CHAINED
*  UPDATE (SINGLE BUFFERED WITH THE TTR SAVED IN BLDLAREA AT EACH
*  LEVEL FOR USE BY NOTE/POINT).
*
*  CHAINED LEVELS ARE CREATED/DESTROYED BY THE 'POSITION' SUBROUTINE.
         TITLE 'PROGRAM INITIALIZATION CODE'                     82060
         DROP  ,                                                 82060
*  R1 -> O.S. EXEC PARMS POINTER ADDRESS (AS O.S. PASSED).          SMP
*                                                                   SMP
         PRINT &PRTSOR                                           82060
RUNINIT  ENTSB RUNINSAV      ESTABLISH BASE                      82060
         USING SAVEAREA,R13,R12,R11,R7,R8  DECLARE COMMON BASES  82060
         LA    R2,DDNAMES-8       -> TABLE FOR DEFAULT DDNAMES - 8  SMP
         MVC   8(DDTSIZE,R2),DDDFLTS        SET DEFAULT DDNAMES     SMP
         LA    R1,0(,R1)     CLEAN PARM                          82060
         LTR   R9,R1         ANY ?                               82060
         BZ    NODDLIST      NO; ERROR.  SKIP DD INIT            82060
         ICM   R9,7,1(R1)    GET PARM ADDRESS                    82060
         TM    0(R1),X'80'        TEST EXEC PARMS LAST PARAMETER    SMP
         BO    NODDLIST           YES - NO DDNAME LIST.             SMP
*                                                                   SMP
*  SCAN O.S. STANDARD DDNAME LIST TO OVER-RIDE DEFAULT DDNAMES.     SMP
*                                                                   SMP
         L     R1,4(,R1)          -> DDNAME LIST                 82060
         LH    R6,0(,R1)          LENGTH                         82060
         LA    R3,18(,R1)         POINT ENTRY BEFORE 'SYSLIB'    82060
         LA    R4,8               INCREMENT                         SMP
         LA    R5,1(R6,R1)        BXH LIMIT ADDRESS              82060
*                                                                   SMP
DDNLOOP  BXH   R3,R4,NODDLIST     TO NEXT LIST ENTRY OR EXIT        SMP
         AR    R2,R4              ADVANCE TARGET TABLE POINTER      SMP
         CLI   0(R3),0            TEST DDNAME OMITTED               SMP
         BE    DDNLOOP            YES - LEAVE TABLE WITH DEFAULT    SMP
         MVC   0(8,R2),0(R3)      NO PLUG OVER-RIDING DDNAME        SMP
         B     DDNLOOP                                              SMP
*                                                                   SMP
NODDLIST ST    R9,PARMADR    SAVE PARM FIELD ADDRESS             82060
*                                                                82067
*        INSERTION FOR PEOPLE WHO DON'T READ OR ARE VERY LAZY.   82067
*        WHEN THE SYSLIB DD STATEMENT IS OMITTED, AND A SYSUT1 PDS
*        IS PRESENT, THEN COPY/LIST WILL DEFAULT TO SYSUT1/2     82102
         DEVTYPE DDLIB,OBWORK   DID USER SUPPLY SYSLIB DD ?      82067
         BXLE  R15,R15,LIBDFLT  YES; ACCEPT IT EVEN IF DUMMY     82067
         LA    R3,DDUT1      POINT TO SYSUT1                     82102
         LA    R4,2          TRY TWO (UT1 AND UT2)               82102
LIBDLOOP DEVTYPE 0(R3),OBWORK   ELSE DID USER SUPPLY A SYSUT1/2 ?
         BXH   R15,R15,LIBDBUMP NO; DEFAULT COPY/LIST WON'T      82102
         CLI   OBWORK+2,UCB3DACC  DIRECT ACCESS ?                82067
         BNE   LIBDBUMP      NO; CAN'T USE INSTEAD               82102
         MVC   DCBDDNAM-IHADCB+SYSPUNCH(8),0(R3)  CREAM AN INNOCUOUS
         RDJFCB (SYSPUNCH)   DCB FOR JFCB READ                   82067
         MVC   DCBDDNAM-IHADCB+SYSPUNCH(8),DDPUNCH  RESTORE DDNAME
         BXH   R15,R15,LIBDBUMP  DIDN'T WORK ?                   82102
         L     R15,JFCBA     GET JFCB ADDRESS                    82067
         TM    JFCBIND1-INFMJFCB(R15),JFCPDS  MEMBER SPECIFIED ? 82067
         BNZ   LIBDBUMP      YES; SKIP IT                        82102
         OBTAIN OBLIST       GET THE DSCB                        82067
         BXH   R15,R15,LIBDBUMP  TOO BAD                         82102
         TM    DS1DSORG,JFCORGPO  PARTITIONED DATASET ?          82067
         BZ    LIBDBUMP      NO                                  82102
         MVC   DDLIB,0(R3)   USE SYSUT1 DEFAULT INSTEAD OF SYSLIB
         B     LIBDFLT                                           82102
LIBDBUMP LA    R3,DDUT2      IF NO UT1, TRY UT2                  82102
         BCT   R4,LIBDLOOP                                       82102
LIBDFLT  XR    R1,R1                                             82067
         XC    GFLAGS,GFLAGS      RESET ALL GLOBAL FLAGS              A
         SET   LISTING
         ST    R1,STEPRC          RESET STEP RETURN CODE TO ZERO
         MVI   COND+1,8           RESET COND=8
         ZAP   PINCR,=P'1'        INITIALIZE DEFAULT INCR
         ZAP   LEVCTR,=P'0'
         MVC   HNAME,BLANKS       INITIALIZE PART OF PAGE TITLE
         MVI   USERNAME,C' '      NO PREVIOUSLY LOADED USER ROUTINE
         MVI   PRELEN,X'FF'       SET DEFAULT PARM=UPDATES          SMP
         MVI   GUNAME,C' '        NO PREV. GLOBAL USER ROUTINE LOADED #
         EXTRACT TIOTLOC,FIELDS=TIOT
*
*  SET UP TIME STAMP (IN TIMEWORD) TO BE USED (OPTIONALLY) AS PART
*  OF THE USER DATA FIELD IN STOW OPERATIONS.
*
         TIME  DEC                TIME AND DATE IN R0,R1
         SRL   R0,20              00 00 0H HM
         SRL   R1,4
         ST    R1,DATEWORD   SAVE DATE IN 000YYDDD FORM          82060
         SLL   R1,12              YY DD D0 00
         OR    R1,R0              YY DD DH HM
         ST    R1,TIMEWORD        THIS IS THE TIME STAMP
         OI    TIMEWORD+3,X'0F'   MAKES IT YY DD DH HF
*
*  INITIALIZATION - OPEN SYSPRINT
*
         LA    R2,DDPRINT         -> PRINTER DDNAME                 SMP
         XPROPEN PWA,PAGEWID=PWIDTH,DDNAME=(R2)                     SMP
         BXLE  R15,R15,PRTOK    BRANCH IF OPENED                 82060
*
         WTO   'IEBUPDTX - UNABLE TO OPEN SYSPRINT',ROUTCDE=11   82060
         L     R13,4(,R13)
         RETURN  (14,12),T,RC=16
*
PRTOK    XPRHEAD PWA,LIST=HEADING
         XPREJECT PWA
*
*  OPEN SNAP DATA SET (DDNAME=SYSUBEND).
*
*  IF USER SUPPLIES THE DD CARD, A DUMP IS PRODUCED WITH EACH
*  IEBUPDTX GENERATED ERROR MESSAGE (HELPFUL WHEN PROGRAM GENERATES
*  INCORRECT ERRORS).
*  THE DCB OPEN BIT (IN DCBOFLGS) IS TESTED IN THE ERROR ROUTINE TO
*  DETERMINE IF THE SNAP IS TO BE ISSUED.
*  THE DEVTYPE TEST FOR PRESENCE OF THE DD CARD IS LOGICALLY NOT
*  REQUIRED, BUT WAS ADDED TO PREVENT POSSIBLE WTO IN RELEASE 20.6.
*
         DEVTYPE DCBDDNAM-IHADCB+SNAPDCB,OBWORK+8
         BXH   R15,R15,NOSNAPO   SKIP IF NOT SUPPLIED            82060
         OPEN  (SNAPDCB,OUTPUT)
NOSNAPO  ENDSB RUNINSAV                                          82060
*                                                                   SMP
*  TABLE OF STANDARD DEFAULT DDNAMES USED BY IEBUPDTX.              SMP
*  THIS TABLE MUST CORRESPOND TO THE DDNAMES TABLE IN THE GLOBAL    SMP
*  AREA.  (AND TO ENTRIES 4-9 OF OS DDNAME LIST).                   SMP
*                                                                   SMP
DDDFLTS  DS    0D                                                   SMP
         DC    C'SYSLIB  '                                          SMP
         DC    C'SYSIN   '                                          SMP
         DC    C'SYSPRINT'                                          SMP
         DC    C'SYSPUNCH'                                          SMP
         DC    C'SYSUT1  '                                          SMP
         DC    C'SYSUT2  '                                          SMP
DDTSIZE  EQU   *-DDDFLTS          SIZE FOR MVC                      SMP
         SPACE 1                                                 82060
RUNINSAV DC    9F'0'                                             82060
         TITLE 'DCBEXIT'                                         82060
*              OLD(SYSUT1) AND NEW(SYSUT2) MASTER DCB EXIT       80301
*              BLOCKSIZE DEFAULTED BY DEVICE TYPE FOR DASD (SEE  82060
*              DEFBLKSI); 8000 FOR TAPE; 80/88 FOR OTHERS        82060
*              SET WYLBUR FLAGS FOR RECFM=U                      80301
         SPACE 2                                                 80301
         USING IHADCB,R1
         USING DCBEXIT,R15                                       82060
         USING SAVEAREA+4096,R12,R11,R7,R8                       82060
DCBEXIT  LH    R3,DCBBLKSI        PICK UP BLOCK SIZE                  #
         LA    R0,88         SET BLOCKSIZE FOR UNKNOWN           82060
         TM    DCBDEVT,UCB3DACC+UCB3TAPE  BIG BLOCKS ?           82060
         BNM   DCBEXGB       NO; USE SMALL DEFAULT               82060
         LA    R0,4000       SET DISK DEFAULT                    82060
         TM    DCBDEVT,UCB3DACC  DASD ?                          82060
         BNZ   DCBEXGDA      YES; DO TABLE LOOKUP                82060
         SLL   R0,1          USE 8K FOR TAPE                     82060
         B     DCBEXGB                                           82060
DCBEXGDA LA    R4,DEFBLKSI   GET DEFAULT BLOCKSIZE TABLE         82060
         LA    R5,(DEFBLKSX-DEFBLKSI)/3  NUMBER OF ENTRIES       82060
DCBEXGDL CLC   DCBDEVT,0(R4)  MATCHING TYPE ?                    82060
         BNE   DCBEXGDN      NO; TRY NEXT                        82060
         ICM   R0,3,1(R4)    GET DEFAULT FOR THIS DISK           82060
         B     DCBEXGB                                           82060
DCBEXGDN LA    R4,3(,R4)     TRY NEXT ENTRY                      82060
         BCT   R5,DCBEXGDL   IF ANY                              82060
DCBEXGB  LR    R5,R0         R0 = DEFAULT FOR RECFM=V,U          82060
         XR    R4,R4                                             82060
         LA    R2,80         SET CARD LENGTH                     82060
         DR    R4,R2         R5 = DEFAULT FOR RECFM=F            82060
         MR    R4,R2              TRUNCATED TO CARD MULTIPLE     82060
*                                                                     C
*  SET BUFNO AND NCP TO BUFNO (IF SPECIFIED) ELSE DEFAULT THEM.       C
         SPACE 1                                                 80301
         CLI   DCBBUFNO,0         BUFNO OMITTED ?                80301
         BH    *+8                 NO  - DON'T SET DEFAULT       80301
         MVI   DCBBUFNO,2          YES - BUFNO=2                 80301
         MVC   DCBNCP,DCBBUFNO    SET NCP TO MATCH BUFNO         80301
         SPACE 1                                                 80301
*  IF BUFNO=1, DON'T SET OPTCD=C.                                     A
*                                                                     A
         TM    DCBRECFM,DCBRECU    CHECK FOR RECFM=U            JRE0036
         BO    DCBEXITW            GO TEST FOR WYLBUR           JRE0036
         CLI   DCBBUFNO,1         TEST IF BUFNO=1                     A
         BE    *+8                YES - SKIP                          A
         OI    DCBOPTCD,DCBOPTC   NO - SET OPTCD=C               80002A
*                                                                     A
*  CHECK RECFM SPECIFIED.  DEFAULT TO FB.                             V
*                                                                     V
         OI    DCBRECFM,DCBRECBR  FORCE BLOCKED                  80002V
         TM    DCBRECFM,DCBRECV   TEST RECFM=V (OR U).           80002V
         BO    DCBSETV            YES                                 V
         OI    DCBRECFM,DCBRECF   FORCE POSSIBLE NO RECFM TO F   80002V
         ICM   R0,3,DCBLRECL      ANY RECORD LENGTH ?            82060
         BNZ   *+8                YES                            82060
         STH   R2,DCBLRECL        SET TO 80                      82060
         CH    R2,DCBLRECL        REALLY 80 ?                    82060
         BNE   DCBBLKX            NO; ERROR                      82060
         LTR   R3,R3              TEST IF USER SPECIFIED IT.          #
         BNZ   DCBEXIT1           YES - GO CHECK IS MULTIPLE OF 80.   #
         STH   R5,DCBBLKSI   NO; SET DEFAULT                     82060
         LR    R3,R5         SET FOR F VS. FB TEST               82060
         B     DCBEXIT1      SET BLOCKING PROPERLY               82060
DCBEXITW CLC   DCBBLKSI,=AL2(WYBLKSIZ)  CHK IF VALID WYLBUR     JRE0036
         BH    DCBBLKX             ELSE, ERROR                  JRE0036
         LTR   R3,R3         ANY SIZE SPECIFIED ?                82060
         BP    *+8           YES; USE IT                         82060
         STH   R0,DCBBLKSI   ELSE USE DEVICE DEFAULT             82060
         CLC   DCBBLKSI,=Y(106)  ROOM FOR MINIMUM BLOCK ?        82060
         BL    DCBBLKX       NO; ERROR                           82060
*              SYSIN/SYSUT1/SYSLIB WILL BE MACRF=R | MACRF=RP    80301
         TM    DCBMACR1,DCBMRRD   MACRF=R ?                      80301
         BO    SETWYL2             YES                           80301
*              SYSUT2/SYSPUNCH     WILL BE MACRF=W | MACRF=WP    80301
         USING NMDSECT,R6                                       JRE0036
         SET   NMWYLFMT            ELSE SET FLAG FOR SYSUT2     JRE0036
         DROP  R6                                               JRE0036
         BR    R14                 RETURN                       JRE0036
         USING LOCAL,R9                                          82060
SETWYL2  SET   WYLFORMT            SET WYLBUR FORMAT FLAG       JRE0036
         DROP  R9                                                82060
         BR    R14                                              JRE0036
*                                                                     #
DCBEXIT1 LR    R0,R2         SAVE CONSTANT OF 80                 82060
         XR    R2,R2         CLEAR FOR DIVIDE                    82060
         DR    R2,R0         DIVIDE USER'S BLKSIZE BY 80         82060
         LTR   R2,R2              REMAINDER BETTER BE ZERO            #
         BNZ   DCBBLKX       FAIL IF IT IS NOT                   82060
         CH    R3,=H'1'      TEST QUOTIENT                       82060
         BHR   R14           MORE THAN ONE                       82060
         BL    DCBBLKX       TOO SMALL FOR RECORD ?              82060
         NI    DCBRECFM,255-DCBRECBR  RESET BLOCKING             82060
         BR    R14                                               82060
DCBBLKX  ERROR '*** DDNAMEXX - BLKSIZE/LRECL/RECFM IN ERROR ***',      *
               (4,OBWORK,8),RC=ABEND   ADD CORRECT(?) DDNAME     82060
*                                                                     V
*  SET UP FOR VARYING LENGTH RECORDS                                  V
*                                                                     V
DCBSETV  LA    R5,84         SET MINIMUM LRECL                   82060
         XR    R4,R4         CLEAR FOR ICM                       82060
         ICM   R4,3,DCBLRECL   LRECL=X ?                         82060
         BM    DCBSETV1      YES; LEAVE IT                       82060
         CR    R4,R5         LARGE ENOUGH ?                      82060
         BNL   DCBSETV1      YES                                 82060
         STH   R5,DCBLRECL   FORCE OURS                          82060
DCBSETV1 LA    R5,88         SET MINIMUM BLOCKSIZE               82060
         LTR   R3,R3              TEST BLKSIZE SPECIFIED              V
         BNZ   DCBSETV2           YES                            82060
         STH   R0,DCBBLKSI   SET DEVICE DEFAULT                  82060
         BR    R14                                                    V
DCBSETV2 CR    R3,R5         BE SURE BLKSIZE ABOVE REQUIRED      82060
         BNLR  R14                BNL TO RETURN                  80002V
         B     DCBBLKX            ELSE COMPLAIN                       V
*                                                                     V
         DROP  R1,R15                                            82060
*        TABLE OF DEFAULT BLOCKSIZES FOR DISKS                   82060
DEFBLKSI DC    X'2D',AL2(3156)  DCBDEVT/BLKSI  ORDERED BY OUR MOST
         DC    X'28',AL2(3520)                 FREQUENT DISKS    82060
         DC    X'2B',AL2(3665)  3350                             82060
         DC    X'2A',AL2(4100)  3340                             82060
         DC    X'29',AL2(3156)  3330                             82060
         DC    X'21',AL2(3625)  2311 ?                           82060
DEFBLKSX EQU   *             DEFAULT IS 4000 FOR OTHERS          82060
         TITLE 'DSECTS'
*  DSECT FOR TASK INPUT/OUTPUT TABLE (TIOT).
*
TIOT     DSECT
         IEFTIOT1
*
*  DSECT FOR DATA CONTROL BLOCKS.
*
         DCBD  DSORG=PO,DEVD=DA
*
*  DSECT FOR JOB FILE CONTROL BLOCK
*
JFCBD    DSECT
         IEFJFCBN
*
         SPACE 1                                                 82060
         IEFUCBOB ,          UNIT CONTROL BLOCK                  82060
PWIDTH   EQU   132                PAGE WIDTH
NMOFST   EQU   PWIDTH-L'CTLAREA   OFFSET TO PRINT LIST=ALL NM CARDS
DLTOFST  EQU   NMOFST             PLACE TO PRINT DELETED LINES AT80294
         TITLE 'PDS DIRECTORY USER DATA FIELD WHEN CHAINING'
*  DSECT DESCRIBING USER DATA PORTION OF SYSLIB (CHAINED) DIRECTORIES
*
         PRINT &PRTMAC                                           82060
DREC     DSECT
SSSI     DS    XL4
REALNAME DS    XL8                REAL PRINT NAME OF THIS MEMBER
LIBNAME  DS    XL2                LIBRARY IDENTIFICATION LETTERS
MEMBID   DS    PL2                ID NUMBER FOR THIS MEMBER
MEMVER   DS    PL2                VERSION NO. (HIGH OR IDENT)
DRECSIZE EQU   *-SSSI             SIZE OF EXPANDED USER DATA FIELD
*
*
*HEX  DEC
*         *-----------------------------------------------------------*
*  0    0 |   SSSI                                                    |
*         |                 SPACE FOR SSI INFORMATION                 |
*         |                                                           |
*         *-----------------------------------------------------------*
*  4    4 |   REALNAME                                                |
*         |             EXTERNAL PRINT NAME OF THE MEMBER             |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         *-----------------------------*-----------------------------*
*  C   12 |   LIBNAME                   |   MEMBID                    |
*         |       2 BYTES LIBRARY       |   PACKED MEMBER ID NUMBER   |
*         |        IDENTIFICATION       |                             |
*         *-----------------------------*-----------------------------*
* 10   16 |   MEMVER                    |
*         |        PACKED VERSION       |
*         |     NUMBER (OR HIGHEST)     |
*         *-----------------------------*
         TITLE 'F I X   C O N T R O L   B L O C K'
*   FCB CONTAINS INFORMATION FOR THE SCAN ROUTINE
*   ONE FCB IS CONSTRUCTED FOR EACH FIX/SCAN CONTROL CARD FOUND
*
FCB      DSECT
FCBNADR  DS    0A                 ADDRESS OF NEXT FCB OR ZERO
         FLAG  (FIX,FIXUSED,FIXSEQ,FIXCOND)  FIX/SCAN FLAGS      82060
         DS    AL3                ADDRESS OF NEXT FCB OR ZERO
FCBSEQ1  DS    CL8                STARTING SEQUENCE NUMBER OF FIX
FCBSEQ2  DS    CL8                ENDING SEQUENCE NUMBER OF FIX
FCBBAD   DS    CL32               "BAD STUFF" TEXT                    #
FCBGOOD  DS    CL32               "GOOD STUFF" TEXT                   #
FCBLENB  DS    H                  LENGTH OF "BAD" TEXT
FCBLENG  DS    H                  LENGTH OF "GOOD" TEXT
FCBCOL1  DS    H                  START COLUMN
FCBCOL2  DS    H                  END COLUMN
FCBLEN   EQU   *-FCB              LENGTH FOR GETMAIN
*
*
*HEX  DEC
*         *-----------------------------------------------------------*
*  0    0 |   FCBNADR                                                 |
*         *--------------*          CHAIN TO NEXT FCB OR ZERO         |
*         |   FIX        |                                            |
*         *--------------*--------------------------------------------*
*  4    4 |   FCBSEQ1                                                 |
*         |                BEGIN SEQUENCE OF SCAN RANGE               |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         *-----------------------------------------------------------*
*  C   12 |   FCBSEQ2                                                 |
*         |                 END SEQUENCE OF SCAN RANGE                |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         |                                                           |
*         *-----------------------------------------------------------*
* 14   20 |   FCBBAD                                                  |
*         |                   STRING TO BE REPLACED                   |
*         |                                                           |
*         /                                                           /
*         /                                                           /
*         |                                                           |
*         |                                                           |
*         *-----------------------------------------------------------*
* 24   36 |   FCBGOOD                                                 |
*         |                     REPLACEMENT STRING                    |
*         |                                                           |
*         /                                                           /
*         /                                                           /
*         |                                                           |
*         |                                                           |
*         *-----------------------------*-----------------------------*
* 34   52 |   FCBLENB                   |   FCBLENG                   |
*         |      LENGTH-1 OF STRING     |         LENGTH-1 OF         |
*         |        BEING REPLACED       |      REPLACEMENT STRING     |
*         *-----------------------------*-----------------------------*
* 38   56 |   FCBCOL1                   |   FCBCOL2                   |
*         |     SCAN STARTING COLUMN    |      SCAN ENDING COLUMN     |
*         |                             |                             |
*         *-----------------------------*-----------------------------*
         TITLE 'OUTPUT FILE DSECT'
         NMDSECT                                                JRE0036
         TITLE 'BUFFER DSECT'                                         C
         BUFDSECT                                               JRE0036
         END   IEBUPDTX
