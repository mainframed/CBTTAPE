//T750KQ   JOB (317,04,E150AQ),'RAMSEIER',
//             MSGLEVEL=(1,1),
//             CLASS=X,
//             MSGCLASS=T,
//             NOTIFY=&SYSUID,
//             TIME=NOLIMIT
//*MAIN SYSTEM=SYT
//*
//ASM      EXEC PGM=ASMA90,REGION=2048K,
//          PARM='NODECK,OBJECT,USING(NOWARN)'
//SYSIN     DD *
***********************************************************************
*                                                                     *
*     AIACCTAB - RETURN A VALUE BASED ON A FILTERED INPUTSTRING       *
*                                                                     *
*  PARAMETER-HANDLING:                                                *
*  -------------------                                                *
*  AIACCTAB USES THE FOLLOWING LINKAGE-CONVENTIONS:                   *
*                                                                     *
*  R1  --> +--------+ --> +---------------+                           *
*          |PARMADDR|     | PARMFIELD     |                           *
*          +--------+     +---------------+                           *
*                                                                     *
*  PARMADDR: FULLWORD, CONTAINS THE STARTADDRESS OF THE PARMFIELD     *
*                                                                     *
*  THE PARMFIELD LOOKS THE FOLLOWING WAY:                             *
*                                                                     *
*  FLLDDDDDDDDDDDDDDDDD                                               *
*  | |        |                                                       *
*  +-|--------|------------> F: FUNCTIONCODE (LENGTH:1)               *
*    |        |                                                       *
*    +--------|------------> L: LENGTH OF THE DATAPORTION             *
*             |             (W/O FCODE + W/O ITS OWN LENGTH) LEN:2    *
*             |                                                       *
*             +------------> D: DATAPORTION, MAXIMUM LENGTH: 97 BYTES *
*                                                                     *
*  FUNCTIONCODE;  - I (INIT) FOR THE FIRST CALL, OPENS THE DDNAME RE- *
*                       FERENCED IN THE DATAPORTION (=FILTER-DS).     *
*                                                                     *
*                 - S (SEARCH) CONTAINS THE ARGUMENT TO BE COMPARED   *
*                       AGAINST THE FILTER-DD                         *
*                                                                     *
*                 - T (TERM) LAST CALL, CLOSES+RELEASES THE FILTER-DD.*
*                                                                     *
* RETURNED VALUES:                                                    *
*                                                                     *
* WITH FUNCTIONCODE I (INIT) NONE, WITH THE OTHER FUNCTIONCODES, THE  *
* FOLLOWING VALUES ARE RETURNED AT THE ADDRESS OF THE INPUT-PARAMETER:*
* GEGEBEN:                                                            *
*                                                                     *
*  MLLRRRRRRRRRRRRRRRRRR                                              *
*  | |        |                                                       *
*  +-|--------|------------> M: MATCHCODE, (LENGTH:1):                *
*    |        |              M=MATCH, N=NOMATCH                       *
*    |        |                                                       *
*    +--------|------------> L: LENGTH OF THE RETURNED VALUE          *
*             |             (W/O LEN(MATCHCODE + W/O ITS OWN 2 BYTES) *
*             |                                                       *
*             +------------> R: RESULT, LENGTH DETERMINED THROUGH THE *
*                            ARGLEN-KEYWORD IN THE FILTERDATASET.     *
*                                                                     *
* FILTERTABLE:                                                        *
*                                                                     *
* THE FILTERTABLE HAS TO LOOK THE FOLLOWING WAY:                      *
* - COMMENTLINES:              ';' ON POS. 1                          *
* - 1ST DATALINE (MANDATORY):  KEYLEN=NNN,ARGLEN=NNN                  *
*      KEYLEN AND ARGLEN HAVE BOTH TO BE 3 BYTES IN LENGTH, RIGHTJUS- *
*      TIFIED AND PADDED TO THE LEFT WITH ZEROES.                     *
*                                                                     *
* - DATALINES:   POS. 1-KEYLEN: FILTERSTRING                          *
*                POS. KEYLEN+1, LENGTH(ARGLEN): VALUE TO BE RETURNED  *
*                                                                     *
* - THE FILTERING ALGORITHMS ARE DESCRIBED AT THE LABELS MATCH40*.    *
*                                                                     *
* DEBUGGING AID:                                                      *
*                                                                     *
* - IF THE DDNAME ACTTRACE IS ALLOCATED, THE FUNCTION RUNS IN "TRACE"-*
*   MODE: THE INPUTSTRING, FILTERSTRIN AND THE RETURNED VALUE WILL BE *
*   LISTED.                                                           *
*                                                                     *
*                                                                     *
* LINKAGE-CONVENTIONS:  AMODE=24, RMODE=24, REUSABLE, NON-REENTRANT.  *
*                       AIACCTAB SHOULD RUN IN BATCHMODE.             *
*                                                                     *
*                                           27.12.96 $$TRA            *
*                                                                     *
***********************************************************************
***********************************************************************
*     EQUATES                                                         *
***********************************************************************
R0       EQU   0                      WORKREG
R1       EQU   1                      WORKREG
R2       EQU   2                      WORKREG
R3       EQU   3                      WORKREG
R4       EQU   4                      WORKREG
R5       EQU   5                      WORKREG
R6       EQU   6                      WORKREG
R7       EQU   7                      WORKREG
R8       EQU   8                      GETMAINED AREA #1
R9       EQU   9                      GETMAINED AREA #2
R10      EQU   10                     SUBROUTINE-LINKAGE
R11      EQU   11                     BASEREG. #1
R12      EQU   12                     BASEREG. #2
R13      EQU   13
R14      EQU   14
R15      EQU   15                     RETURNCODE
***********************************************************************
*     START                                                           *
***********************************************************************
AIACCTAB CSECT
AIACCTAB AMODE 24
AIACCTAB RMODE 24
         BAKR  14,0                   ESTABLISH LINKAGE-CONVENTIONS
         LR    R11,R15                LOAD TEMPORARY BASE TO MY BASE
         USING AIACCTAB,R11,R12       TELL ASSEMBLER
         LA    R12,2048               LOAD 2NDRY BASE  ..
         LA    R12,2048(R12,R11)      W. 2ND 4K
         LR    R3,R1                  SAVE PASSED PARAMETERS
*
MAIN0010 BAL   R10,GETPARMS           LOOK FOR PASSED PARAMETERS
         CLI   FUNCCODE,C'T'          IS THIS THE LAST CALL ?
         BE    MAIN0090               (BE=YES, FREEMAIN)
         LTR   R15,R15                ARE THERE ANY PARMS ?
         BNZ   ERRMSG                 (BNZ = NO PARMS)
MAIN0020 BAL   R10,GETDDNAM           LOOK WHETHER DDNAME ALLOCATED
         LTR   R15,R15                IS IT ?
         BNZ   ERRMSG                 (BNZ = LIBRARY NOT FOUND)
         CLI   FUNCCODE,C'I'          IS THIS THE FIRST RUN ?
         BNE   MAIN0080               (BNE=NO, SO LOOK FOR MATCH)
MAIN0030 BAL   R10,OPENSKEL           LOOK WHETHER OPEN WAS SUCCESSFUL
         LTR   R15,R15                WAS IT?
         BNZ   ERRMSG                 (BNZ = OPEN FAILED)
MAIN0040 BAL   R10,GETFIRST           GET THE FIRST DATARECORD
         LTR   R15,R15                FOUND ?
         BNZ   ERRMSG                 (BNZ = NO PARAMETER-RECORD FOUND)
MAIN0050 BAL   R10,GETWSTOR           OBTAIN WORKSTORAGE
         LTR   R15,R15                GOT ?
         BNZ   ERRMSG                 (BNZ = OBTAIN FAILED)
MAIN0060 BAL   R10,BUILDTAB           BUILD THE INSTORAGE TABLE
         LTR   R15,R15                DONE ?
         BNZ   ERRMSG                 (BNZ = BUILD FAILED)
MAIN0070 BAL   R10,SORTTAB            SORT THE TABLES (NO RC CHECKED)
         CLI   FUNCCODE,C'I'          IS THIS THE FIRST RUN ?
         BE    MAIN0100               (BE=YES, SO NO FURTHER PROCESS)
MAIN0080 BAL   R10,GETMATCH           CHECK FOR MATCH (NO RC CHECKED)
         B     MAIN0100
MAIN0090 BAL   R10,RELWSTOR           RELEASE WORKING STORAGE
         LTR   R15,R15                FREED ?
         BNZ   ERRMSG                 (BNZ = RELEASE FAILED)
         DELETE EP=AIACCTAB
MAIN0100 DS    0H                     END OF PROGRAM
         LTR   R15,R15                TEST FOR A SUBROUTINE-RC
         BZ    ALLDONE                (BZ=RC = ZERO)
ERRMSG   DS    0H                     ERRMSG: SET AN ERRORMESSAGE-WTO
         LR    R2,R15                 SAVE PASSED SUBROUTINE-RETURNCODE
         MVC   DLWTO(LEFWTO),EFWTO    CLEAR OUT WTO-WORKAREA
         MVC   DLWTO+4(L'ERRORMSG),ERRORMSG    MOVE ERRORMSG IN THERE
         WTO   MF=(E,DLWTO)           ISSUE TH WTO
         LR    R15,R2                 RELOAD PASSED RETURNCOD
ALLDONE  DS    0H                     ALL SUBROUTINES PASSED, BYEBYE
         L     R3,PARMFLD             LOAD PARMAREA-STARTADDRESS
         MVC   0(L'RETVALUE,R3),RETVALUE    MOVE RETURNVALUE THERE
         PR                           END AIACCTAB + CLEANUP
*
         LTORG
***********************************************************************
*     EXECUTE                                                         *
***********************************************************************
         USING IHADCB,R2
MOVEDDN1 MVC   DCBDDNAM(0),2(R3)
MOVESRA1 MVC   SRCHARG(0),2(R3)
MOVEKEY1 MVC   CURRKEY(0),IREC
MOVEKEY2 MVC   0(0,R2),CURRKEY
MOVEARG1 MVC   0(0,R2),0(R5)
COMPSRT1 CLC   0(0,R2),0(R5)
MOVESRT2 MVC   0(0,R9),0(R2)
SAVESRT1 MVC   SAVEREC(0),0(R2)
SAVESRT2 MVC   0(0,R2),0(R5)
SAVESRT3 MVC   0(0,R5),SAVEREC
TRANSRT1 TR    0(0,R2),TRTTAB02
TRANMAT1 TRT   0(0,R5),TRTTAB03
MOVEMAT1 MVC   0(0,R4),0(R5)
MOVEMAT2 MVC   RETVALUE+3(0),0(R2)
MOVEACT1 MVC   0(0,R5),0(R2)
***********************************************************************
*     SUBROUTINES                                                     *
***********************************************************************
GETPARMS ST    R10,SAVE10
         XR    R15,R15                ASSUME WE HAVE PARMS
         L     R3,0(,R3)              LOAD PARM START ADDRESS INTO R3
         ST    R3,PARMFLD             STORE PARAMETER START ADDRESS
         MVC   FUNCCODE(1),0(R3)      FIRST BYTE IS THE FUNCTIONCODE
         LA    R3,1(,R3)              BUMP BEHIND IT
         LH    R4,0(R3)               LOAD LENGTH OF PARM INTO R4
         LTR   R4,R4                  IS THE PARM-LENGTH ZERO ?
         BNZ   PARMS010               (BNZ = PARMS FOUND)
         LA    R15,8                  NO, LOAD RC=8
         MVC   ERRORMSG(80),ERROR010
PARMS010 L     R10,SAVE10             RELOAD ENTRYPOINT
         BR    R10                    BRANCH THERE
*********************************************************************
* GETDDNAM:  OBTAIN VARIABLE DDNAME. CALLED 1ST TIME, (FUNCCODE=I), *
* THIS SUBROUTINE OBTAINS THE DDNAME PASSED BY  CALLER. CALLED ANY  *
* OTHER TIME, LABEL GETSRCHA IS JUMPED AT AND THE SEARCH-ARGUMENT   *
* IS WRITTEN INTO A WORKAREA.                                       *
* THE TIOT IS WALKED THROUGH TO EVALUATE PARAMETER DDNAME. IF NO    *
* APPROPRIATE DDNAME IS ATTACHED, GETDDNAM TERMINATES W. RC=8.      *
*********************************************************************
*
GETDDNAM ST    R10,SAVE10
         XR    R15,R15
         CLI   FUNCCODE,C'I'          IS THIS THE FIRST RUN ?
         BNE   GETSRCHA               (BNE = NO, GET SEARCHARGUMENT)
         LOAD  EP=AIACCTAB            LOAD MYSELF TO SAVE WORKFIELDS
         LA    R2,DCBSKEL             POINT TO SKELETON-DCB
         USING IHADCB,R2              TELL ASSEMBLER
         BCTR  R4,0                   R4: PARMLENGTH -1 FOR EXECUTE
         EX    R4,MOVEDDN1            MOVE THE PASSED DDNAME IN THERE
TIOTSCAN DS    0H                     CHECK FOR VALID DDNAME
         MVI   TRACFLAG,C'N'          ASSUME NO TRACE DESIRED
         MVI   DDNFLAG,C'N'           ASSUME DDNAME NOT FOUND
         L     R6,PSATOLD-PSA(0)      GET CURRENT TCB
         L     R6,TCBTIO-TCB(R6)      POINT AT TIOT
         USING TIOT1,R6               TELL ASSEMBLER
         LA    R7,TIOENTRY            POINT AT FIRST DDNAME
         USING TIOENTRY,R7            TELL ASSEMBLER
TIOT0010 DS    0H
         XR    R1,R1                  CLEAR WORKREG
         ICM   R1,1,TIOELNGH          GET LENGTH OF TIOT-ENTRY
         BZ    TIOT0020               (BZ = LIBRARY NOT FOUND)
         CLC   TIOEDDNM(8),=CL8'ACTTRACE' IS THE TRACE-DD ALLOCATED ?
         BNE   TIOT0015               (BNE = NO, TRY NEXT)
         MVI   TRACFLAG,C'Y'
TIOT0015 CLC   TIOEDDNM,DCBDDNAM      SEARCH LIBRARY ENTRY
         BNE   TIOT0016               (BNE = LIBRARY NOT FOUND)
         MVI   DDNFLAG,C'Y'           INDICATE DDNAME WAS FOUND
TIOT0016 AR    R7,R1                  STEP TO NEXT ENTRY
         B     TIOT0010
TIOT0020 DS    0H
         CLI   TRACFLAG,C'Y'          IS THE TRACE-DATASET ALLOCATED?
         BNE   TIOT0025               (BNE = NO, SO DON'T OPEN)
         OPEN  (ACTTRACE,(OUTPUT))
TIOT0025 CLI   DDNFLAG,C'Y'           WAS DDNAME FOUND ?
         BE    ENDPARMS               (BE = YES, CONTINUE)
         LA    R15,8                  INDICATE LIBRARY NOT FOUND
         MVC   ERROR020+7(8),DCBDDNAM
         MVC   ERRORMSG(80),ERROR020
         B     ENDPARMS
GETSRCHA DS    0H                    GET THE SEARCH-ARGUMENT
         XC    SRCHARG(L'SRCHARG),SRCHARG  CLEAR WORKAREA
         BCTR  R4,0                  SUBTRACT 1 FOR EXECUTE
         ST    R4,LSRCHARG           STORE EX'ED LENGTH
         EX    R4,MOVESRA1           DO THE EXECUTE
ENDPARMS DS    0H                    RETURN
         L     R10,SAVE10
         BR    R10
*
*********************************************************************
* OPENSKEL:    OPENS THE DDNAME VERIFIED BY ROUTINE GETPARMS        *
*              IF THE OPEN FAILS, AN ERRORMSG IS GENERATED, RC=8    *
*********************************************************************
*
OPENSKEL ST    R10,SAVE10
         XR    R15,R15                ASSUME OPEN WILL WORK
         OPEN  DCBSKEL                OPEN PASSED DDNAME
         LTR   R15,R15                OPEN SUCCESSFULL ?
         BZ    OPEN010                (BZ = OPEN SUCCESSFULL)
         MVC   ERROR030+12(8),DCBDDNAM
         MVC   ERRORMSG(80),ERROR030  NO,SET AN ERRORMSG
OPEN010  L     R10,SAVE10             RETURN TO MAIN-PGM
         BR    R10
*
*********************************************************************
* GETFIRST: GET THE FIRST DATARECORD. THIS ROUTINE STRIPS THE 1ST   *
* DATARECORD OF THE DDNAME EVALUATED BY GETPARMS. 1ST DATARECORD    *
* MUST START WITH KEYWORDS 'KEYLEN=XXX,ARGLEN=XXX'. DO NOT CHANGE   *
* THE LENGTH OF THIS DATAFIELDS, RESULTS MAY BE INPREDICTABLE.      *
* THE LENGTHS OF THE FILTERSTRING (KEYLEN) AND RETURNVALUE (ARGLEN) *
* IF RECORD DOES NOT START WITH KEYLEN=, ERROR + RC=8 IS SET.       *
*********************************************************************
*                                                                   *
GETFIRST ST    R10,SAVE10
GET0010  GET   DCBSKEL,IREC           GET FIRST RECORD
         CLI   IREC,C';'              IS IT A COMMENT ?
         BE    GET0010                (BE = YES, IT'S COMMENT)
         CLC   IREC(7),=CL7'KEYLEN='  DOES DATARECORD START W. KEYLEN=?
         BNE   GET0030                (BNE = NO, ERROR FOUND)
         MVC   KEYLEN(L'KEYLEN),IREC+7      KEYLEN=...
         MVC   ARGLEN(L'ARGLEN),IREC+18     ARGLEN=...
         PACK  PACKPARM(2),KEYLEN(3)  MAKE DEC. INPUT PACKED
         ZAP   KEYDW,PACKPARM         ... AND ADD IT TO A FULLWORD
         CVB   R2,KEYDW               MAKE IT COMPUTABLE
         ST    R2,WKEYLEN             STORE FOR LATER USE
         PACK  PACKPARM(2),ARGLEN(3)  MAKE DEC. INPUT PACKED
         ZAP   ARGDW,PACKPARM         ... AND ADD IT TO A FULLWORD
         CVB   R2,ARGDW               MAKE IT COMPUTABLE
         ST    R2,WARGLEN             STORE FOR LATER USE
         XR    R15,R15
         B     GET0040
GET0030  MVC   ERRORMSG(80),ERROR040
         CLOSE DCBSKEL
         LA    R15,8
GET0040  L     R10,SAVE10
         BR    R10
         LTORG
*********************************************************************
* CLOSFILE: UNUSED AT THE MOMENT                                    *
*********************************************************************
*                                                                   *
CLOSFILE ST    R10,SAVE10
         XR    R2,R2
         LR    R2,R15               SAVE PASSED RETURN.-CODE
         CLOSE DCBSKEL
         LTR   R2,R2                IS THIS A REGULAR CLOSE ?
         BE    CLOS010              (BE = YES, R15 WAS ZERO)
CLOS010  LR    R15,R2               NO, SAVE GENUINE RC
         L     R10,SAVE10
         BR    R10
*
*********************************************************************
* GETWSTOR: OBTAIN WORKING STORAGE FOR FILTER-TABLE.                *
* THIS ROUTINE OBTAINS 100 PAGES (400K) OF PRIVATE AREA STORAGE.    *
* ROUTINE BUILDTAB WILL USE THESE 100 PAGES.                        *
*********************************************************************
*                                                                   *
GETWSTOR ST    R10,SAVE10
         XR    R15,R15
         STORAGE OBTAIN,LENGTH=HUNPAGES,ADDR=(8),LOC=BELOW,            X
               BNDRY=PAGE           OBTAIN 100 PAGES OF WORKING-STOR.
         ST    R8,SAVE8
         LTR   R15,R15              ALL OK ?
         BZ    GWST010              (BZ = STORAGE OBTAINED)
         LA    R15,8
         MVC   ERRORMSG(80),ERROR050  SET ERROR-MSG
GWST010  L     R10,SAVE10
         BR    R10
*
*********************************************************************
* BUILDTAB - BUILD AN INSTORAGE TABLE OF ALL FILTERRECORDS.         *
*            FREE THE INPUT-DDNAME AFTER SUCCESSFULL BUILD.         *
* EVERY DATARECORD IS READ IN AND TESTET AGAINST SPECIAL-CHARACTERS *
* '*' (GENERIC) '%' (WILDCARD) OR '?' (NUMERIC). TO MAKE THE TABLE  *
* SORTEABLE, THE SPECIALS ARE TRANSLATED: '*' -> X'FF'              *
*                                         '%' -> X'FE'              *
*                                         '?' -> X'FD'              *
*                                         ' ' -> X'FC'              *
* THE TRANSLATED ENTRIES ARE THEN WRITTEN INTO GETMAINED AREA AND   *
* THE INPUT-DDNAME IS FREED THEREAFTER.                             *
*                                                                   *
*********************************************************************
*                                                                   *
BUILDTAB ST    R10,SAVE10
         L     R3,WKEYLEN             LOAD LENGTH OF KEY
         L     R4,WARGLEN             LOAD LENGTH OF RETURNVALUE
         BCTR  R4,0                   SUBTR. 1 FOR EXECUTE
         BCTR  R3,0                   SUBTRACT 1 FOR EXECUTE
         LR    R2,R8                  POINT TO TOP OF GETM'D AREA
         XR    R6,R6                  ENTRIES-COUNTER
TAB0010  XC    IREC,IREC              GET RECORD
         GET   DCBSKEL,IREC           GET RECORD
         CLI   IREC,C';'              IS IT COMMENT ?
         BE    TAB0010                (BE = YES, COMMENTLINE)
         LA    R6,1(,R6)              ADD 1 TO REC-COUNTER
         ST    R2,SAVE2               SAVE R2 BEC. OF TRT ||
         EX    R3,MOVEKEY1            MOVE IN DATA-PORTION
         TRT   CURRKEY,TRTTAB00       ARE THERE ANY SPECIAL-CHARACTERS?
         BZ    TAB0020                (BZ = NO SPECIAL CHARS)
         TR    CURRKEY,TRTTAB01       TRANSLATE THE SPECIAL-CHARS
TAB0020  L     R2,SAVE2               RESTORE R2 AFTER TRT||
         EX    R3,MOVEKEY2            WRITE TRANSLATED KEY INTO WSTOR
         A     R2,WKEYLEN             BUMP BEHIND IT
         LA    R5,IREC                POINT TO INPUT RECORD
         A     R5,WKEYLEN             BUMP BEHIND KEY
         LA    R5,1(R5)               ADD 1 (BUMP OVER ',')
         EX    R4,MOVEARG1            WRITE INTO GETMAINED AREA
         A     R2,WARGLEN             BUMP BEHIND IT
         B     TAB0010                GET NEXT RECORD
EOF      CLOSE DCBSKEL                CLOSE LIBRARY
         XR    R15,R15                ASSUME EVERYTHING WENT OK
         CR    R8,R2                  NO DATARECORDS ?
         BNE   TAB0030                (BNE = YES, WE HAVE RECORDS)
         MVC   ERRORMSG(80),ERROR060  SET ERROR-MSG
         STORAGE RELEASE,LENGTH=HUNPAGES,ADDR=(8)
         LA    R15,8
TAB0030  L     R10,SAVE10
         BR    R10
*
*********************************************************************
* SORTTAB - THIS SUBROUTINE SORTS THE INPUTFILE:                    *
* LOGIC: R2 POINTS TO THE 1ST RECORD                                *
*        R5 POINTS TO THE 2ND RECORD                                *
*        IS THE 1ST RECORD "SMALLER" THAN THE 2ND?                  *
*        YES: GET NEXT RECORD INTO R5                               *
*        NO: EXCHANGE R2 RECORD W. R5 RECORD                        *
*        R6:INNER-LOOPCOUNTER (NR.OF RECORDS-NR. OF RECORDS SORTED) *
*        IF R6 IS ZERO, R2 POINTS TO THE "LOWEST" RECORD. THIS ONE  *
*        IS WRITTEN INTO THE 2ND TABLE (POINTED TO BY R9) .         *
*        R6 IS THEN DECREASED BY ONE, R2 POINTS TO 2ND ENTRY,       *
*        R5 POINTS TO THE THIRD. THE WHOLE THING CONTINUES WHILE    *
*        R7 IS STILL > 0.                                           *
*        R7: OUTER-LOOPCOUNTER (NR. OF TIMES TO WALK THROUGH TABLE) *
*        R7: IS R6-1 AT FISRST WALKTHROUGH                          *
*********************************************************************
*
SORTTAB  ST    R10,SAVE10
         ST    R6,SAVE6               # OF RECORDS
         SR    R2,R8                  R2-R8 = EFF. LENGTH OF W-STOR
         L     R4,WKEYLEN             R4 ...
         A     R4,WARGLEN                ... IS THE CURRENT LINELENGTH
         ST    R4,LINELEN             STORE IT FOR LATER USE
         STORAGE OBTAIN,LENGTH=(2),ADDR=(9),LOC=BELOW,BNDRY=PAGE
         ST    R9,SAVE9               STORE ENTRYPOINT AND ....
         ST    R2,SAVE2               .... STORAGESIZE
SORT010  DS    0H                     MOVE 1ST KEY INTO G'MND AREA
         L     R3,WKEYLEN             LOAD LENGTH OF KEY
         BCTR  R3,0                   SUBTRACT 1 FOR EXECUTE
         LR    R2,R8                  POINT TO 1ST GETMAINED AREA WREG1
         LR    R5,R8                  POINT TO 1ST GETMAINED AREA WREG2
         L     R6,SAVE6               LOAD NUMBER OF ENTRIES IN TABLE
         LR    R7,R6                  SAME FOR OUTER-LOOP
         BCTR  R7,0                   SUBTR. 1 FOR OUTER LOOP
         LTR   R7,R7                  DO WE HAVE JUST ONE ENTRY ?
         BZ    SORT040                (BZ = YES, QUITE EASY TO SORT)
*LOOP                                 START OF OUTER LOOP
SORT015  DS    0H
         BCTR  R6,0                   DECREASE INNER LOOP-COUNT AND ..
         ST    R6,CURRCNT             SAVE THE NEW VALUE
*--LOOP
SORT020  DS    0H                     START OF INNER LOOP
         AR    R5,R4                  POINT TO NEXT BUT ONE-ENTRY
         EX    R3,COMPSRT1            COMP. WHETHER CURRENT IS LOW
         BL    SORT030                (BL=R2-> IS LOW, GET NEXT)
         BCTR  R4,0                   NO, NEXT RECORD IS LOW, SO
         EX    R4,SAVESRT1            SAVE CURRENT LOWEST RECORD,
         EX    R4,SAVESRT2            MOVE NEW LOWEST RECORD,
         EX    R4,SAVESRT3            RELOAD NEXT REC. W. GENUINE LOW-
         LA    R4,1(,R4)              EST RECORD. RE-INCREASE LENGTH
SORT030  DS    0H                     GET NEXT INPUTLINE
         BCT   R6,SORT020             RETRY W. NEXT RECORD.
*--ENDLOOP                            END OF INNER LOOP
         EX    R3,TRANSRT1            TRANSLATE THE INPUT BACK
         BCTR  R4,0                   DECREASE FOR EXECUTE AND ...
         EX    R4,MOVESRT2            ... WRITE THE LOWEST VALUE INTO
         LA    R4,1(,R4)              ... GETMAINED AREA. RE-INCREASE
         AR    R9,R4                  PREPARE FOR NEXT LOWEST ENTRY
         AR    R2,R4                  BUMP OVER WRITTEN LOWEST ENTRY
         LR    R5,R2                  SAME W. POINTER 1
         L     R6,CURRCNT             LOAD NEW DECREASED INNERLOOP-CNT
         BCT   R7,SORT015             AND RESTART
*ENDLOOP                              END OF OUTER LOOP.
SORT040  DS    0H                     WRITE LAST RECORD
         EX    R3,TRANSRT1            TRANSLATE THE INPUT BACK
         BCTR  R4,0                   WRITE THE LAST LINE ...
         EX    R4,MOVESRT2            ... INTO GETMAINED TABLE #2
         LA    R4,1(,R4)              SAVE OR. LENGTH FOR FURTHER USE
         L     R10,SAVE10
         BR    R10
*********************************************************************
* GETMATCH: THE MAIN SUBROUTINE OF THIS PROGRAM. GETMATCH PERFORMS  *
* THE FOLLOWING FUNCTIONS: THE INPUTPARM IS SEPARATED INTO A MAX. OF*
* 16 QUALIFIERS OF 20 BYTES (16 DATA + 4 LENGTH-BYTES). SEPARATION- *
* CHARACTER IS '.'. THIS IS DONE FOR THE FILTERSTRING, TOO.         *
* THEN, THE QUALIFIERS ARE TESTED AGAINST EACH OTHERS. IF THERE     *
* IS A GENERIC-CHAR (* IN QUALIFIER, ** IN WHOLE ENTRY), THE REMAIN-*
* ING PART OF THE QUALIFIER OR ENTRY IS REVERSED TO FULLFILL ISPF-  *
* MATCH CRITERIA.(ATITRA.**.CNTL MATCHES ATITRA.SYS9.CNTL.CNTL ONLY,*
* IF ALL QUALIFIERS ARE REVERSED).                                  *
* THE LOGIC OF THE QUALIFIER-MATCHES IS DESCRIBED BELOW (MATCH040)  *
* IF THE PARAMETERSTRING MATCHES THE FILTERSTRING, A RETURNVALUE IS *
* PLACED INTO FIELD RETVALUE, PRECEEDED BY A 1-BYTE MATCH-FIELD,    *
* (M = MATCH OCCURRED, N=NOMATCH), THEN BY A 2-BYTE LENGTH-FIELD.   *
* IF NO MATCH OCCURS, X'00' IS RETURNED.                            *
*********************************************************************
*                                                                   *
GETMATCH ST    R10,SAVE10
         L     R3,LSRCHARG            LOAD LENGTH OF SEARCHARGUMENT
         LA    R5,SRCHARG             POINT TO PASSED SEARCH-ARGUMENT
         LA    R4,QUALIVAL            POINT TO TOP OF QUALIFIERTABLE
         LR    R1,R3                  LOAD LENGTH OF ARGUMENT INTO R1
         LA    R6,1                   R6 = NUMBER OF QUALIFIERS
*                                     IF 1 THEN INPUT=FILTERSTRING
MATCH010 EX    R1,TRANMAT1            SEARCH FOR THE NEXT '.'
         BZ    MATCH015               (BZ = NO (MORE) '.')
         XC    0(LTABDATA-4,R4),0(R4) BLANK OUT ENTRY
         SR    R1,R5                  R5=EP, R1= 1ST '.' R5-R1=LENGTH
         BCTR  R1,0                   SUBTRACT 1 FOR EXECUTE
         EX    R1,MOVEMAT1            MOVE QUALIFIER INTO TABLE
         STCM  R1,15,LTABDATA-4(R4)   STORE THE LENGTH OF ENTRY
         LA    R1,2(,R1)              RE-INCR. + BUMP BEHIND '.'
         AR    R5,R1                  ADD NEW ENTRY TO OLD ENTRY
         LA    R6,1(,R6)              # OF QUALIFIERS
         SR    R3,R1                  SUBTRACT EX'ED LN. FROM TOTAL
         LR    R1,R3                  RELOAD RESULT (NEW LENGTH F.TRT)
         LA    R4,LTABDATA(,R4)       POINT TO NEXT-ENTRY
         B     MATCH010               RE-TRANSLATE-AND TEST
MATCH015 DS    0H                     END OF TRT-LOOP
         LR    R2,R5                  POINT TO START OF PASSED PARMS
         AR    R2,R3                  ADD REMAINING BYTES
MATCH15A CLI   0(R2),C' '             IS THERE A BLANK AT THE END ?
         BNE   MATCH016               (BNE = NOT BLANK, ALL DATA NOW
         BCTR  R2,0                   YES, DECREASE
         BCT   R3,MATCH15A            RETRY
MATCH016 DS    0H                     SUBTR. 1 TO EXECUTE LAST QUALI.
         XC    0(LTABDATA-4,R4),0(R4)
         EX    R3,MOVEMAT1            MOVE QUALIFIER INTO TABLE
         STCM  R3,15,LTABDATA-4(R4)   STORE LENGTH OF LAST QUALIFIER
         ST    R6,PARMQUAL            # OF QUALIFIERS INPUT-PARMM
*
MATCH017 DS    0H                     NOW START WORK FOR FILTERLIST
         L     R5,SAVE9               POINT TO PASSED SEARCH-ARGUMENT
         L     R7,SAVE6               POINT TO PASSED SEARCH-ARGUMENT
MATCH020 L     R3,WKEYLEN             LOAD KEY-LENGTH IN TABLE
         BCTR  R3,0                   SUBTRACT 1 (POINT TO LAST POS)
         AR    R3,R5                  ADD CURRENT TABLE-ENTRY
MATCH018 CLI   0(R3),C' '             BLANK AT THE END ?
         BNE   MATCH019               (BNE=NO, ALL DATA FROM HEREON)
         BCT   R3,MATCH018            YES, ITS BLANK. DECREASE + RETRY
         L     R3,WKEYLEN             ALL BLANKS, LOAD ENTRY-LENGTH
MATCH019 SR    R3,R5                  SUBTRACT ENTRYPOINT(R3=EFF. L')
         LA    R4,FILTRVAL            POINT TO TOP OF QUALIFIERTABLE
         LA    R6,1                   R6 = NUMBER OF QUALIFIERS
         MVI   GENRFLAG,C'N'          ASSUME NOT GENERIC
         ST    R5,CURRFILT            SEARCH FOR THE NEXT '.'
         LR    R1,R3                  LOAD LENGTH OF ARGUMENT INTO R1
MATCH021 EX    R1,TRANMAT1            SEARCH FOR THE NEXT '.'
         BZ    MATCH025               (BZ = NO (MORE) '.')
         XC    0(LTABDATA,R4),0(R4)   BLANK OUT ENTRY TO WRITE IN
         SR    R1,R5                  R5=EP, R1= 1ST '.' R1-R5=LENGTH
         BCTR  R1,0                   SUBTRACT 1 FOR EXECUTE
         EX    R1,MOVEMAT1            MOVE QUALIFIER INTO TABLE
         STCM  R1,15,LTABDATA-4(R4)   STORE LENGTH AT END OF TABLE-ENT.
MATCH022 LA    R1,2(,R1)              RE-INCR. + BUMP BEHIND '.'
         AR    R5,R1                  ADD NEW ENTRY TO OLD ENTRY
         LA    R6,1(,R6)              # OF QUALIFIERS
         SR    R3,R1                  SUBTRACT EX'ED LN. FROM TOTAL
         LR    R1,R3                  RELOAD RESULT (NEW LENGTH F.TRT)
         LA    R4,LTABDATA(,R4)       POINT TO NEXT ENTRY
         B     MATCH021               RE-TRANSLATE
MATCH025 DS    0H                     NOW WRITE IN THE LAST QUALIFIER
         XC    0(LTABDATA,R4),0(R4)   BLANK OUT THE ENTRY
         EX    R3,MOVEMAT1            MOVE QUALIFIER INTO TABLE
         STCM  R3,15,LTABDATA-4(R4)   STORE THE LENGTH AT TABLEEND
         ST    R6,FILTQUAL            # OF QUALIFIERS INPUT-PARMM
         STM   R2,R7,SAVE2TO7         STORE SUBROUTINES REGISTERS
         B     MATCH040               BRANCH TO CHECK FOR A MATCH
MATCH035 DS    0H                     NO MATCH FOUND, TRY NEXT
         LM    R2,R7,SAVE2TO7         RESTORE "DAMAGED" REGISTERS
         L     R5,CURRFILT            LOAD CURRENT FILTER-DATASET
         A     R5,LINELEN             ADD ONE LINE
         BCT   R7,MATCH020            # OF ATTEMPTS TO MADE
         XC    RETVALUE,RETVALUE      NO MATCH OCCURRED, RETURN X'00'
         MVI   RETVALUE,C'N'          INDICATE NOMATCH
         B     MATCH037               NO FILTERVALUE FOUND
MATCH036 DS    0H                     MATCH036: FILTER MATCHED
         L     R2,CURRFILT            POINT TO CURRENT FILTERENTRY
         A     R2,WKEYLEN             ADD LENGTH OF KEY
         LR    R3,R2                  SAVE IT INTO R3
         L     R4,WARGLEN             LOAD LENGTH OF RETURNVALUE
         BCTR  R4,0                   SUBTRACT ONE (-> LAST DATAFIELD)
         AR    R3,R4                  ADD IT TO R3 (R3=END OF LINE)
MATCH36A CLI   0(R3),C' '             IS THERE A BLANK AT THE END ?
         BNE   MATCH36B               (BNE=NO, DATA IS FOUND)
         BCTR  R3,0                   STILL BLANK, TRY NEXT
         BCT   R4,MATCH36A            RETRY
MATCH36B XC    RETVALUE,RETVALUE      CLEAR-OUT RETURNVALUE
         MVI   RETVALUE,C'M'          INDICATE MATCH
         LTR   R4,R4                  IS THERE ANY DATA ?
         BZ    MATCH037               (BZ=NO MATCH, BUT ONLY BLANKS)
         LA    R4,1(,R4)              ADD 1 TO STORE EFFECTIVE LENGTH
         STCM  R4,3,RETVALUE+1        AT THE TOP OF RETVALUE
         BCTR  R4,0                   SUBTRACT 1 FOR EXECUTE
         EX    R4,MOVEMAT2            MOVE DATAPORTION THERE
MATCH037 DS    0H                     END OF SUBROUTINE
         CLI   TRACFLAG,C'Y'          DO WE HAVE TO TRACE ?
         BNE   MATCH038               (BNE = NO, JUST RETURN)
         XC    OREC,OREC
         MVC   OREC(1),RETVALUE
         LA    R5,OREC+2
         LA    R2,RETVALUE+3          POINT TO RETURN-VALUE
         L     R3,WARGLEN
         EX    R3,MOVEACT1            DO THE EXECUTE
         AR    R5,R3                  BUMP BEHIND INPUT-PARM
         MVI   0(R5),C' '
         LA    R5,1(,R5)              SPARE-ENTRY
         L     R2,PARMFLD             LOAD PARAMETER ADDRESS
         LA    R2,3(,R2)              BUMP BEHIND HEADER
         L     R3,LSRCHARG            LOAD EX'ED LENGTH
         EX    R3,MOVEACT1            DO THE EXECUTE
         AR    R5,R3                  BUMP BEHIND IT
         LA    R5,1(,R5)              EXECUTED LENGTH+1
         MVI   0(R5),C' '
         LA    R5,1(,R5)              SPARE-ENTRY
         CLI   RETVALUE,C'N'          IS IT A NOMATCH ?
         BE    MATCH37P               (BE = YES, WRITE NO FILTER)
         L     R2,CURRFILT            LOAD CURRENT FILTER ADDRESS
         L     R3,WKEYLEN             LOAD LENGTH OF FILTER-ENTRY
         BCTR  R3,0
         EX    R3,MOVEACT1            DO THE EXECUTE
MATCH37P PUT   ACTTRACE,OREC
MATCH038 L     R9,SAVE9               LOAD GETMAINED-AREA POINTER
         L     R10,SAVE10             RETURN TO CALLER
         XR    R15,R15
         BR    R10
**********************************************************************
* MATCH040: A SUBROUTINE THAT CHECKS FOR A MATCH AGAINST FILTERLIST  *
* THE LOGIC OF THIS SUBROUTINE IS AS FOLLOWS:                        *
* '**' IS AN OVERALL-WILDCARD, INDICATING THAT 0-NN QUALIFIERS MAY   *
*      BE JUMPED OVER. SO IF '**' IS THE LAST QUALIFIER, WE HAVE A   *
*      MATCH. IF NOT, THE NEXT BUT ONE QUALIFIER OF THE FILTERPARM   *
*      IS LOADED AND TESTING RE-EXECUTES WITH NEW QUALIFIER.         *
*                                                                    *
* '*'  IS A GENERIC-CHARACTER, INDICATING THAT 0-NN CHARACTERS IN A  *
*      QUALIFIER MAY BE JUMPED OVER. IF * IS THE LAST CHARACTER      *
*      WHITHIN THE QUALIFIER, THERE'S A QUALIFIER-MATCH. OTHERWISE   *
*      THE NEXT BUT ONE CHARACTER IS LOADED AND FURTHER TESTING      *
*      OCCURS.                                                       *
*                                                                    *
* '%'  IS A WILDCARD, INDICATING THAT THE NEXT CHARACTER MAY BE JUM- *
*      PED. THERE  M U S T  BE A VALID SIGN (Â¬= X'00') TO FULLFILL   *
*      THE REQUIREMENT. BLANK (X'40') IS A VALID CHARACTER, TOO.     *
*                                                                    *
* '?'  IS A NUMERIC WILDCARD (NUMBERS 0-9).                          *
*                                                                    *
* SAMPLE:   PARM: SLAESIN.ISS.CNTL72                                 *
*           FILTER: **.ISS.CNT*      -->  MATCH                      *
*           FILTER: **.IS%.CNTL      -->  NOMATCH                    *
*           FILTER: SLAE*.IS%.CNTL?* -->  MATCH                      *
*           FILTER: %*AE*.ISS.CNTL?? -->  MATCH                      *
*           FILTER: %*AE*.ISS.CNTL??? --> NOMATCH                    *
*                                                                    *
**********************************************************************
*                                                                    *
MATCH040 DS    0H                     CHECK FOR A MATCH
         L     R6,PARMQUAL            R6: # OF INPUTPARM-QUALIFIERS
         L     R7,FILTQUAL            R7: # OF FILTERVALUE-QUALIFIERS
         LA    R4,QUALIVAL            R4: POINTS TO 1ST INPUT-QUALI
         LA    R5,FILTRVAL            R5: POINTS TO 1ST FILTER-QUALI
         MVI   GENRFLAG,C'N'          '**' - INDICATOR
         MVI   REVAFLAG,C'N'          REVERSEMODE-INDICATOR
MATCHQ40 DS    0H
         STM   R4,R5,SAVE4TO5        STORE GENUINE PARAMETER-POINTERS
         ICM   R3,15,LTABDATA-4(R4)  LENGTH OF ARGUMENT QUALIFIER
         LA    R3,1(,R3)             INC. 1, VALUE IS EXECUTED LENGTH
         ICM   R2,15,LTABDATA-4(R5)  LENGTH OF FILTER QUALIFIER
         LA    R2,1(,R2)             INC. 1, VALUE IS EXECUTED LENGTH
         MVI   GENQFLAG,C'N'         ASSUME NOT IN GENERIC QUALI-MODE
         MVI   SAVEFLAG,C'N'         ASSUME NOT IN GENERIC QUALI-MODE
         MVI   REVDONE,C'N'          ASSUME NOT IN GENERIC QUALI-MODE
         CLC   0(2,R5),=CL2'**'      IS THIS AN OVERALL-WILDCARD ?
         BE    MATCH40X
MATCH40A DS    0H
         CLC   0(1,R5),0(R4)         DO THE ACTUAL CHARACTERS MATCH?
         BE    MATCH40W              (BE = YES, TRY NEXT CHAR)
         CLI   0(R5),C'%'            DO WE HAVE A WILDCARD ?
         BE    MATCH40W              (BE = YES, TRY NEXT CHAR)
         CLI   0(R5),C'?'            DO WE HAVE A NUMERIC ?
         BNE   MATCH40B              (BE = YES, TRY NEXT CHAR)
         CLI   0(R4),C'0'            IS INPUT-CHAR >= F0 ?
         BL    MATCH40B              (BL = NO, LOOK FOR GENERIC-FLAG)
         CLI   0(R4),C'9'            IS INPUT-CHAR <= F9 ?
         BNH   MATCH40W              YES, IT IS| TRY NEXT CHAR
MATCH40B CLI   GENQFLAG,C'Y'         ARE WE IN GENERIC-'MODE'
         BE    MATCH40V              (BE=YES, TRY NEXT INPUT-CHAR)
         CLI   0(R5),C'*'            IS THIS A GENERIC ?
         BNE   MATCH4XA              (BNE=NO, SO IT IS A MISHIT)
         MVI   GENQFLAG,C'Y'         YES, INDICATE GENERIC-'MODE'
         BCTR  R2,0                  DECREASE FILTER-LENGTH BY 1
         LTR   R2,R2                 IS THIS THE LAST FILTERCHAR ?
         BZ    MATCH40Y              (BZ = YES, WE HAVE A MATCH)
         LA    R5,1(,R5)             POINT TO NEXT FILTER-CHAR
         MVI   SAVEFLAG,C'Y'
         B     MATCH40A              RETRY IN GENERIC-MODE
*
MATCH40V LA    R4,1(,R4)             POINT TO NEXT CHAR OF PARAMETER
         BCT   R3,MATCH40A           RETRY NEXT CHARACTER
         B     MATCH4XA              NO MORE MATCH FOUND, MISHIT
*
MATCH40W CLI   SAVEFLAG,C'Y'         IS THE REVERSEMODE NEEDED ?
         BNE   MATCH4WA              (BNE=NO, JUMP TO NEXT CHAR)
         CLI   REVDONE,C'Y'          IS THE REVERSE-STUFF DONE ALREADY?
         BE    MATCH4WA              (BE = YES, JUMP TO NEXT CHAR)
         STM   R2,R5,SAVEQUAL        STORE THE USED REGISTERS
         BCTR  R3,0                  COUNTER HAS NOT YET BEEN DECR.
         XC    REVQUAL,REVQUAL       CLEAR OUT WORKAREA
         LA    R2,REVQUAL            POINT THERE
         AR    R4,R3                 POINT AT END OF QUALIFIER
         LA    R3,1(,R3)             RE-INCREASE COUNTER
MATCHRE1 MVC   0(1,R2),0(R4)         MOVE LAST CHARACTER INTO 1ST POS.
         BCTR  R4,0                  DECREASE QUALIFIERPOINTER
         LA    R2,1(,R2)             INCREASE WORKAREAPOINTER
         BCT   R3,MATCHRE1           REDO THE REVERSE-LOOP
         LM    R2,R5,SAVEQUAL        SAME ...
         XC    REVFILT,REVFILT       ... PROCEDURE ...
         LA    R3,REVFILT            ... WITH THE ...
         BCTR  R2,0                  ... CURRENT ...
         AR    R5,R2                 ... FILTER ...
         LA    R2,1(,R2)             ... QUALIFIER .
MATCHRE2 MVC   0(1,R3),0(R5)         START OF REVERSE ...
         BCTR  R5,0                  FILTERQUALIFIER-LOOP.
         LA    R3,1(,R3)             THE FILTERQUALIFIER IS NOW
         BCT   R2,MATCHRE2           REVERSED, TOO.
         LM    R2,R5,SAVEQUAL        RESTORE USED REGISTERS.
         LA    R4,REVQUAL            POINT TO THE REVERSED FIELDS
         LA    R5,REVFILT            AND SAVE THE NEW POINTERS
         STM   R2,R5,SAVEQUAL        IN THE WORKAREA
         MVI   REVDONE,C'Y'          IND. REVERSEMODE IS DONE ALREADY
         MVI   SAVEFLAG,C'N'         IND. SAVE IS DONE
         MVI   GENQFLAG,C'N'         INDICATE NO LONGER GENERIC-MODE
         B     MATCH40A              BRANCH TO COMPARE-LABEL AGAIN
*                                    USING THE REVERSED STRINGS
MATCH4WA MVI   SAVEFLAG,C'N'         IND. SAVE IS DONE
         MVI   GENQFLAG,C'N'         INDICATE NO LONGER GENERIC-MODE
         LA    R5,1(,R5)             POINT TO NEXT CHAR OF FILTER
         LA    R4,1(,R4)             POINT TO NEXT CHAR OF PARAMETER
         BCTR  R2,0                  DEC. FILTER-COUNTER
         BCT   R3,MATCH40A           RETRY NEXT CHARACTER
         LTR   R2,R2                 IS FILTER-LENGTH ZERO, TOO
         BZ    MATCH40Y              (BZ = MATCH, NO MORE FILTERCHARS)
         BCTR  R2,0                  LAST CHANCE: IS THERE A '*' AT
         LTR   R2,R2                 THE END OF QUALIFIER ?
         BNZ   MATCH4XA              (BNZ=STILL > THAN 1 CHAR, MISHIT)
         CLI   0(R5),C'*'            IS IT A '*' ?
         BE    MATCH40Y              (BE = YES, SO WE HAVE A MATCH)
MATCH4XA DS    0H                    MATCH4XA: QUALIFIER MISHIT
         LM    R4,R5,SAVE4TO5        LOAD START OF TABLE-ENTRIES
         CLI   GENRFLAG,C'Y'         ARE WE IN A **-LOOP, LAST CHANCE?
         BNE   MATCH035              (BNE=NO, DEFINITE MISHIT)
         L     R4,SAVE4TO5           YES, WE ARE, TRY THE LAST CHANCE
         LA    R4,LTABDATA(,R4)      POINT TO NEXT PARAMETER-QUALIFIER
         ST    R4,SAVE4TO5           STORE THE NEW POINTER
         BCT   R6,MATCHQ40           TRY NEXT QUALIFIER
         B     MATCH035              (NO MORE QUALIES, DEFINITE MISHIT)
MATCH40X DS    0H                    '**'-ENTRY, BUMP BEHIND AND RETRY
         MVI   GENRFLAG,C'Y'         INDICATE WE'RE IN GENERIC-MODE
         STM   R2,R7,SAVEREGS        SAVE ALL BLOODY REGS I NEED |
         BCTR  R7,0                  SUBTRACT 1
         LTR   R7,R7                 IS THIS THE LAST QUALIFIER ?
         BZ    MATCH40Z              HOORRAY, WE HAVE A MATCH |
         L     R5,SAVE4TO5+4         NO, LOAD GENUINE POINTER
         LA    R5,LTABDATA(,R5)      LOAD NEXT FILTER-QUALIFIER
         ST    R5,SAVE4TO5+4         SAVE NEW FILTERPOINTER
         CLI   REVAFLAG,C'Y'         REVERSE ALREADY DONE ?
         BE    MATCH4XG              (BE = YES, SO NOP)
*                                    SPECIAL CASE, REVERSE THE QUALS.
         MVI   REVAFLAG,C'Y'
         LM    R2,R7,SAVEREGS        LOAD ALL BLOODY REGS I NEED |
         LA    R4,WORKREVQ           POINT TO FILTER-QUALIFIER-EXCHANGE
         XR    R2,R2                 WORK-AREA (UFF|).
         XR    R3,R3                 CLEAR MULTIPLY-REGS
         LA    R3,LTABDATA           LOAD MULTIPLICAND (QUALILENGTH)
         MR    R2,R7                 MULTIPLY W. # OF QUALIES
         LA    R2,LTABDATA           LOAD ENTRYLENGTH
         SR    R3,R2                 SUBTRACT FROM RESULT OF MULTIPL.
         BZ    MATCH4XD              BZ=JUST 1 QUALIFIER LEFT, PROCEED
         AR    R5,R3                 ADD RESULT TO FILTERPOINTER
**********************************************************************
*SPECIAL CASE: LOGIC PROBLEM IN REVERSING QUALIFIERS: IF THE LAST
*FILTERQUALIFIER IS A SINGLE '*', IT MAY NOT BE REVERSED ||
*   '**' DOES NOT MATTER BECAUSE IT MAY BE 0 QUALIFIERS, BUT '*' MAY
*JUST BE A 0-QUALIFIER AT THE END.
**********************************************************************
         MVI   LASTSTAR,C'N'         ASSUME NOT A '*' AT THE END
         CLI   0(R5),C'*'            IS THERE A '*' AT THE LAST QUALI?
         BNE   MATCH4XB              (BNE=NO, PROCEED)
         ICM   R1,15,LTABDATA-4(R5)  INSERT LENGTH OF LAST FILTERQUAL
         LTR   R1,R1                 IS LENGTH(EXECUTED) = 0 ?
         BNZ   MATCH4XB              (BNZ=NO, MORE THAN JUST A '*')
         MVI   LASTSTAR,C'Y'         YES, INDICATE NOT TO REVERSE
         ST    R5,SAVE5              STORE POINTER TO LAST FILTERQUAL
         BCTR  R7,0                  SUBTRACT 1 FOR LOOP BELOW
         SR    R5,R2                 (THE LAST '*' WILL BE RE-WRITTEN
*LOOP                                AT THE END, WHERE IT BELOWS)
*********************************************************************
* START OF ORDINARY LOOP
*********************************************************************
MATCH4XB XC    0(LTABDATA,R4),0(R4)  CLEAR OUT WORKAREA-FIELD
         MVC   0(LTABDATA,R4),0(R5)  MOVE THERE THE CURRENT ENTRY
         AR    R4,R2                 ADD ENTRYLENGTH TO WORKAREA
         SR    R5,R2                 SUBTR. QUALILENGTH FROM FILTER
         BCT   R7,MATCH4XB           RE-DO W. NEXT QUALIFIER
*ENDLOOP
*********************************************************************
* SPECIAL CASE OF A '*' AT THE END
*********************************************************************
         CLI   LASTSTAR,C'Y'         IS THE LAST FILTERQUALI A '*' ?
         BNE   MATCHXB1              (BNE=NO, ALL IS REVERSED,PROCEED)
         L     R5,SAVE5              LOAD POINTER TO '*'
         LA    R7,1                  SET LOOPCOUNTER TO 1
         MVI   LASTSTAR,C'N'         RESET REVERSE-FLAG
         B     MATCH4XB              RE-CALL PREVIOUS LOOP
*********************************************************************
* END OF SPECIAL CASE
*********************************************************************
MATCHXB1 LA    R4,WORKREVQ           TABLE. LOAD WA-POINTER INTO Q-PTR.
         L     R5,SAVEREGS+12        POINT TO 1ST QUALIFIER OF FILTER
         L     R7,SAVEREGS+20        RELOAD # OF QUALIFIERS
MATCH4XC XC    0(LTABDATA,R5),0(R5)  CLEAR OUT WORKAREA-FIELD
         MVC   0(LTABDATA,R5),0(R4)  MOVE THERE THE CURRENT ENTRY
         AR    R4,R2                 ADD ENTRYLENGTH TO WORKAREA
         AR    R5,R2                 SUBTR. QUALILENGTH FROM FILTER
         BCT   R7,MATCH4XC           RE-WRITE FILTERQUALIFIERTABLE
*ENDLOOP
MATCH4XD DS    0H                    REVERSE DONE (OR NOT NEEDED)
         LM    R2,R7,SAVEREGS        LOAD THE GENUINE REG-VALUES
         LA    R5,WORKREVQ           POINT TO TOP OF WORKING-TABLE
         XR    R2,R2                 CLEAR OUT R2 AND PREPARE IT FOR
         LA    R3,LTABDATA           THE COMING MULTIPLICATION
         MR    R2,R6                 MULTIPLY THE ENTRY LENGTH W.
         LA    R2,LTABDATA           # OF ENTRIES. (R3 = RESULT)
         SR    R4,R2                 POINT TO START OF CURRENT PARM
         AR    R4,R3                 ADD RESULT TO PARM-POINTER
MATCH4XE XC    0(LTABDATA,R5),0(R5)  CLEAR OUT WORKAREA-FIELD
         MVC   0(LTABDATA,R5),0(R4)  MOVE THERE THE CURRENT ENTRY
         SR    R4,R2                 (R4=END OF QUALTAB, POINT TO NEXT
         AR    R5,R2                 PREVIOUS ENTRY)
         BCT   R6,MATCH4XE           WRITE NEXT ENTRIES
         L     R5,SAVEREGS+8         POINT TO CURRENT PARAMETERENTRY
         LA    R4,WORKREVQ           POINT TO TOP OF REVERSE-WORKAREA
         L     R6,SAVEREGS+16        LOAD # OF QUALIFIERS
MATCH4XF XC    0(LTABDATA,R5),0(R5)  CLEAR OUT PARAMETER-QUALIFIER
         MVC   0(LTABDATA,R5),0(R4)  MOVE THE REVERSED ENTRY THERE
         AR    R4,R2                 INCREASE PARAMETER-QUALIFIER
         AR    R5,R2                 INCREASE WORKAREA-POINTER
         BCT   R6,MATCH4XF           REDO WITH NEXT ENTRY
         LM    R2,R7,SAVEREGS        RELOAD DAMAGED REGISTERS
MATCH4XG DS    0H                    END OF REVERSE-ACTION
         B     MATCHQ40              RETRY |
*
MATCH40Y DS    0H                    MATCH40Y: QUALIFIER MATCHES |
         LM    R4,R5,SAVE4TO5        LOAD START OF TABLE-ENTRIES
         LA    R4,LTABDATA(,R4)      LOAD NEXT PARAMETER-QUALIFIER
         LA    R5,LTABDATA(,R5)      LOAD NEXT FILTER-QUALIFIER
         STM   R4,R5,SAVE4TO5        STORE NEW ENTRY-POINTS
         MVI   GENRFLAG,C'N'         GENERIC REQUEST IS SATISFIED NOW
         BCTR  R7,0                  SUBTRACT 1
         BCT   R6,MATCHQ40           R6=0: ALL QUALIFIERS MATCH |
         LTR   R7,R7                 IS THIS THE LAST FILTERQUAL?
         BZ    MATCH40Z              NO, IT IS A MISHIT
         BCTR  R7,0                  LOOK WHETHER LAST QUAL IS * OR **
         LTR   R7,R7                 IS THIS NOW THE LAST FILTERQUAL?
         BNZ   MATCH035              (BNZ=NO,DEFINITE MISHIT)
         L     R5,SAVE4TO5+4         POINT TO LAST ENTRY
         ICM   R4,15,LTABDATA-4(R5)  LOAD EXECUTED LENGTH OF LAST QUAL
         LA    R4,1(,R4)             ADD 1 FOR LOOPCOUNTER
MATCH4Y1 CLI   0(R5),C'*'            IS THERE A WILDCARD SET ?
         BNE   MATCH035              (BNE = NO, DEFINITE MISHIT)
         LA    R5,1(,R5)             YES, TRY NEXT CHARACTER
         BCT   R4,MATCH4Y1           REDO LOOP
MATCH40Z DS    0H
         B     MATCH036
         LTORG
*                                                                    *
**********************************************************************
* RELWSTOR: RELEASE OBTAINED WORKAREAS                               *
**********************************************************************
*                                                                    *
RELWSTOR ST    R10,SAVE10
         XR    R15,R15
         L     R8,SAVE8
         STORAGE RELEASE,LENGTH=HUNPAGES,ADDR=(8)
         LTR   R15,R15              ALL OK ?
         BZ    RWST010              (BZ = STORAGE RELEASED)
         LA    R15,8
         MVC   ERRORMSG(80),ERROR070  SET ERROR-MSG
RWST010  L     R9,SAVE9               RELOAD ORIGINAL POINTER THERE
         L     R2,SAVE2               RELOAD LENGTH OF 2ND TABLE
         STORAGE RELEASE,LENGTH=(2),ADDR=(9)
         CLI   TRACFLAG,C'Y'
         BNE   RWST015
         CLOSE ACTTRACE
RWST015  L     R10,SAVE10
         BR    R10
         LTORG
*                                                                    *
**********************************************************************
*     CONSTANTS                                                      *
**********************************************************************
*                                                                    *
TRTTAB00 DC    XL256'00'
         ORG   TRTTAB00+C'*'
         DC    X'FF'
         ORG   TRTTAB00+C'%'
         DC    X'FE'
         ORG   TRTTAB00+C'?'
         DC    X'FD'
         ORG   TRTTAB00+C' '
         DC    X'FC'
         ORG
*
TRTTAB01 DC    XL256'00'
         ORG   TRTTAB01
         DC    X'000102030405060708090A0B0C0D0E0F'
         DC    X'101112131415161718191A1B1C1D1E1F'
         DC    X'202122232425262728292A2B2C2D2E2F'
         DC    X'303132333435363738393A3B3C3D3E3F'
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
         ORG   TRTTAB01+C'*'
         DC    X'FF'
         ORG   TRTTAB01+C'%'
         DC    X'FE'
         ORG   TRTTAB01+C'?'
         DC    X'FD'
         ORG   TRTTAB01+C' '
         DC    X'FC'
         ORG
*
TRTTAB02 DC    XL256'00'
         ORG   TRTTAB02
         DC    X'000102030405060708090A0B0C0D0E0F'
         DC    X'101112131415161718191A1B1C1D1E1F'
         DC    X'202122232425262728292A2B2C2D2E2F'
         DC    X'303132333435363738393A3B3C3D3E3F'
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
         ORG   TRTTAB02+X'FF'
         DC    C'*'
         ORG   TRTTAB02+X'FE'
         DC    C'%'
         ORG   TRTTAB02+X'FD'
         DC    C'?'
         ORG   TRTTAB02+X'FC'
         DC    C' '
         ORG
*
TRTTAB03 DC    XL256'00'
         ORG   TRTTAB03+C'.'
         DC    C'.'
         ORG
*
HUNPAGES EQU   100*4096
*
ERROR010 DC    CL80'NO PARAMETER PASSED. PROGRAM TERMINATES'
ERROR015 DC    CL80'FIRST CALL NEEDS DDNAME + SEARCHARG. PLEASE RETRY'
ERROR020 DC    CL80'DDNAME XXXXXXXX NOT ALLOCATED. PROGRAM TERMINATES'
ERROR030 DC    CL80'OPEN DDNAME XXXXXXXX FAILED. PROGRAM TERMINATES'
ERROR040 DC    CL80'FIRST DATARECORD DOES NOT START W. KEYLEN=. PROGRAMX
                TERMINATES.'
ERROR050 DC    CL80'STORAGE OBTAIN FAILED. PROGRAM TERMINATES.'
ERROR060 DC    CL80'NO VALID TABLE RECORDS FOUND. PROGRAM TERMINATES.'
ERROR070 DC    CL80'STORAGE RELEASE FAILED. PROGRAM TERMINATES.'
***********************************************************************
*     LIST-FORMS                                                      *
***********************************************************************
EFWTO    WTO   '                                                       C
                                ',MF=L
LEFWTO   EQU   *-EFWTO
***********************************************************************
*     DCB'S                                                           *
***********************************************************************
DCBSKEL  DCB   DDNAME=XXXXXX,MACRF=GM,EODAD=EOF,DSORG=PS,LRECL=80
ACTTRACE DCB   DDNAME=ACTTRACE,MACRF=PM,DSORG=PS,LRECL=133
***********************************************************************
*     WORKING SECTION                                                 *
***********************************************************************
*
GENRFLAG DS    CL1              INDICATES '**' - MODE
GENQFLAG DS    CL1              INDICATES '*' - FLAG
SAVEFLAG DS    CL1              INDICATES REG.-SAVE FOR REVERSE-MODE
REVDONE  DS    CL1              INDICATES REVERSE IS DONE OR NOT
REVAFLAG DS    CL1              INDICATES ALL QUALIFIERS ARE REVERSED
LASTSTAR DS    CL1              INDICATES LAST QUALIFIER IS A '*'
TRACFLAG DS    CL1              INDICATES TRACE-DD ALLOCATED
DDNFLAG  DS    CL1              INDICATES DDNAME FOUND
*
FUNCCODE DS    CL1              PASSED FUNCTION-CODE
IREC     DS    CL80             INPUT-RECORD
SRCHARG  DS    CL80             PASSED SEARCH-ARGUMENT
LSRCHARG DS    F                LENGTH OF SEARCH-ARGUMENT
CURRKEY  DS    CL80             KEY-VALUE WORKFIELD
CURRARG  DS    CL80             ARGUMENT-VALUE WORKFIELD
KEYLEN   DS    CL3              KEYLENGTH DECIMAL
ARGLEN   DS    CL3              ARGUMENTLENGTH DECIMAL
KEYDW    DS    D                KEYLENGTH PACK-WORKFIELD
ARGDW    DS    D                ARGUMENTLENGTH PACK-WORKFIELD
PACKPARM DS    PL2'0'           WORKFIELD
WKEYLEN  DS    F                KEY-LENGTH AS A FULLWORD
WARGLEN  DS    F                ARGUMENT-LENGTH AS A FULLWORD
*
OREC     DS    CL133            TRACE-RECORD
*
SAVE2    DS    F                REGISTER SAVEAREA
SAVE5    DS    F                REGISTER SAVEAREA
SAVE6    DS    F                REGISTER SAVEAREA
SAVE8    DS    F                REGISTER SAVEAREA
SAVE9    DS    F                REGISTER SAVEAREA
SAVE10   DS    F                REGISTER SAVEAREA
SAVE4TO5 DS    2F               REGISTER SAVEAREA
SAVE2TO7 DS    6F               REGISTER SAVEAREA
SAVEQUAL DS    4F               REGISTER SAVEAREA
SAVEREGS DS    6F               REGISTER SAVEAREA
CURRCNT  DS    F                REGISTER SAVEAREA
CURRFILT DS    F                REGISTER SAVEAREA
CURENTRY DS    F                REGISTER SAVEAREA
PARMQUAL DS    F                REGISTER SAVEAREA
FILTQUAL DS    F                REGISTER SAVEAREA
LINELEN  DS    F                REGISTER SAVEAREA
EFFKLEN  DS    F                REGISTER SAVEAREA
PARMFLD  DS    F                RETURN-ADDRESS
*
RETVALUE DS    CL80             RETURN-VALUE
SAVEREC  DS    CL80             SORT-ENTRY WORKFIELD
ERRORMSG DS    CL80             ERROR-MSG
DLWTO    DS    CL(LEFWTO)       WTO-WORKAREA
*
LTABDATA EQU   20               LENGTH OF EACH QUALIFIER-ENTRY
*
REVQUAL  DS    CL(LTABDATA)     REVERSED PARAMETER QUALIFIER
REVFILT  DS    CL(LTABDATA)     REVERSED FILTER QUALIFIER
QUALIVAL DS    16CL(LTABDATA)   PARAMETER QUALIFIER-TABLE
FILTRVAL DS    16CL(LTABDATA)   FILTER-QUALIFIER-TABLE
WORKREVQ DS    16CL(LTABDATA)   WORK-TABLE FOR REVERSE OF WHOLE ENTRY
         PRINT NOGEN
         DCBD  DSORG=PS
         IHAPSA
         IKJTCB DSECT=YES
         IEFTIOT1
         END   AIACCTAB
/*
//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB
//          DD DISP=SHR,DSN=SYS1.MODGEN
//SYSLIN    DD DSN=&&OBJ,UNIT=SYSDA,DISP=(NEW,PASS),
//          SPACE=(3200,(200,50)),DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80)
//SYSPRINT  DD SYSOUT=*,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3990)
//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,3))
//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(5,3))
//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(5,3))
//*
//* =====================================================
//* ===== L I N K A G E   E D I T O R ===================
//* =====================================================
//LKED      EXEC PGM=HEWL,REGION=1024K,COND=(0,NE),
//          PARM='XREF,LIST,REUS'
//SYSLMOD   DD DISP=SHR,DSN=SA1T.T750K.CBTFILE.LOAD
//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(10,3))
//SYSPRINT  DD SYSOUT=*
//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)
//          DD *
  NAME    AIACCTAB(R)
/*
