/*--------------------------ooo00 REXX 00ooo--------------------------*/
/* LOGR: LOGstReam processor.                                         */
/*                                                                    */
/* Generate listings or summarise and/or create define/delete         */
/* logstream JCL from output from a LOGR listing.                     */
/*                                                                    */
/* Parameters:                                                        */
/* -----------                                                        */
/* /A  - All fields defined. Even those in exclusion list.            */
/* /B  - Build define logstream.  Same as '/F'.                       */
/* /D  - build Delete logstream statements.                           */
/* /DEF- build deFine logstream from output. (Same as '/F'.)          */
/* /DEL- build Delete logstream statements. (Same as '/D'.)           */
/* /DESC(){O}                                                         */
/*     - Supplied description for logstream.                          */
/* /DF - build Delete/deFine logstream statements.                    */
/* /F  - build deFine logstream from output of option '/L'.           */
/* /H  - Hard copy into Userid.LOGSTRM.LIST.Dyymmdd (option '/L')     */
/*     - Hard copy into Userid.LOGSTRM.DEFINE.Dyymmdd                 */
/*       (options '/DF' or '/F')                                      */
/*     - Hard copy into Userid.LOGSTRM.DELETE.Dyymmdd                 */
/*       (options '/D')                                               */
/* /HA - Hard copy (append) into Userid.LOGSTRM.DEFINE.Dyymmdd.       */
/*       (options '/DF' or '/F')                                      */
/*     - Hard copy (append) into Userid.LOGSTRM.DELETE.Dyymmdd.       */
/*       (options '/D')                                               */
/* /HLQ()                                                             */
/*     - HLQ to match for Delete/deFine.                              */
/* /L  - List logstreams - default.                                   */
/* /NP - No Popup (for debugging).                                    */
/* /S  - Sumarise logstream from output of option '/L'.               */
/* /SET()                                                             */
/*     - Site's LPAR to generate logstreams for.                      */
/* /SS - Seperate Steps (for Delete/deFine option).                   */
/* /T  - deTailed list. (Sets '/L' option.)                           */
/* /TR - TRace (for debugging).                                       */
/* /X  - eXecute command extracted from cursor placed line from part  */
/*       of the tutorial. Save cut and paste (because I can).        */
/*  ?  - Tutorial.                                                    */
/*                                                                    */
/* Use parameter of '?' for tutorial or go to bottom of this member.  */
/*                                                                    */
/*--------------------------------------------------------------------*/
LOGR:logr_ver='1.22'
    f_s=mark(+5)
/*--------------------------------------------------------------------*/
/* Fields to generate define statements for, 1(Yes) 0(No).            */
/* Parameter of '/A' will turn all on for the run.                    */
/*--------------------------------------------------------------------*/
    f_ad=1  /* AUTODELETE                                             */
    f_do=1  /* DASDONLY                                               */
    f_de=0  /* DESCRIPTION                                            */
    f_di=1  /* DIAG                          - Enabled for Kmart      */
    f_du=1  /* DUPLEXMODE                                             */
    f_eh=1  /* EHLQ                          - Enabled for Kmart      */
    f_ho=1  /* HIGHOFFLOAD                                            */
    f_hl=1  /* HLQ                                                    */
    f_lx=0  /* LOGGERDUPLEX                                           */
    f_lo=1  /* LOWOFFLOAD                                             */
    f_ld=0  /* LS_DATACLAS                                            */
    f_lm=0  /* LS_MGMTCLAS                                            */
    f_lz=1  /* LS_SIZE                                                */
    f_ls=0  /* LS_STORCLAS                                            */
    f_mb=1  /* MAXBUFSIZE                                             */
    f_mo=1  /* MODEL                                                  */
    f_or=1  /* OFFLOADRECALL                                          */
    f_rt=1  /* RETPD                                                  */
    f_rm=0  /* RMNAME                                                 */
    f_sd=0  /* STG_DATACLAS                                           */
    f_sx=1  /* STG_DUPLEX                                             */
    f_sm=0  /* STG_MGMTCLAS                                           */
    f_sz=1  /* STG_SIZE                                               */
    f_ss=0  /* STG_STORCLAS                                           */
    f_st=1  /* STRUCTNAME                                             */
/*--------------------------------------------------------------------*/
    f_e=mark(-2)
    Parse Upper ARG parm#
    Address ISPEXEC;"CONTROL ERRORS RETURN";ima_macro=0
    If parm#/='' Then Signal byp1
    "ISREDIT MACRO (parm#) NOPROCESS"
    If rc=0 Then ima_macro=1

byp1:
    "CONTROL ERRORS CANCEL"

ini1:
    userid=Userid();Parse Value Date('E') With dd '/' mm '/' yy
    sysid=Strip(storage(d2x(x2d(c2x(storage(10,4)))+x2d(154)),8))
    dater=yy||mm||dd
    Parse Value '' With hardcopy_l hardcopy_f site_parm desc_supplied,
                        hlq_rep
    Parse Upper VAR parm# parm#;Parse SOURCE . xenv xcmd xdd xdsn .
    If Index(parm#,'/SET(')>0 Then Do
        Parse VAR parm# p1 '/SET(' site_parm ')' p2
        logr_set=Logr$(site_parm)
        If logr_set='' Then Do
            zedsmsg=;zedlmsg='Set "'site_parm'" not defined in',
                             "'LOGR$' customisation member. Enter a",
                             "valid value or omit this parameter and",
                             "enter long hand. Use tutorial to list",
                             "valid SET values."
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
            Exit
        End
        parm#=Space(p1 p2) logr_set
    End
    If Wordpos(Word(parm#,1),'? ?? /HELP')>0 Then Signal Help_me
    If Wordpos('/TR',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/TR',parm#),1)
        Trace r
    End
    If Wordpos('/X',parm#)>0 Then Signal exec_ext_cmd
    If Index(parm#,'/DESC(')>0 Then Do
        Parse VAR parm# p1 '/DESC(' desc_supplied ')' p2
        If desc_supplied='/SET' Then desc_supplied=site_parm
        If Substr(p2,1,1)='O' Then Do
            p2=subword(p2,2);desc_over=1
        End
        Else desc_over=0
        desc_supplied=Space(Translate(desc_supplied,'_',' '))
        x=Verify(desc_supplied,'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$_.','N')
        If x>0 Then Do
            desc_supplied=;desc_over=0
        End
        Else Do
            f_de=1
            desc_supplied=Left(desc_supplied,16)
        End
        parm#=Space(p1 p2) Logr$(site_parm)
    End;Else desc_over=0
    If Wordpos('/L',parm#)>0 | parm#='' Then Do
        If Wordpos('/L',parm#)>0 Then,
            parm#=Delword(parm#,Wordpos('/L',parm#),1)
        list=1
    End;Else list=0
    If Wordpos('/NP',parm#)>0 | parm#='' Then Do
        If Wordpos('/NP',parm#)>0 Then,
            parm#=Delword(parm#,Wordpos('/NP',parm#),1)
        addpop=0;dont_say='Y'
    End;Else addpop=1
    If Wordpos('/T',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/T',parm#),1)
        detail=1;list=1
    End;Else detail=0
    Signal on Syntax Name error_off_$ALKUVOL
/*  unitvol_b='UNIT=SYSALLDA';unitvol_b=$alkuvol('SMS',,'J',)         */
/*  unitvol_o='UNIT(SYSALLDA)';unitvol_o=$alkuvol('SMS',,,)           */
    unitvol_b='UNIT=SYSALLDA';unitvol_o='UNIT(SYSALLDA)'
    unitvol_b=$alkuvol('SMS',,'J',)
    unitvol_o=$alkuvol('SMS',,,)
error_off_$ALKUVOL:Signal off Syntax
    If Wordpos('/D',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/D',parm#),1)
        delete_def=1
    End;Else delete_def=0
    If \delete_def Then,
        If Wordpos('/DEL',parm#)>0 Then Do
            parm#=Delword(parm#,Wordpos('/DEL',parm#),1)
            delete_def=1
        End
    If Wordpos('/F',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/F',parm#),1)
        build_def=1
    End;Else,
        If Wordpos('/B',parm#)>0 Then Do
            parm#=Delword(parm#,Wordpos('/B',parm#),1)
            build_def=1
        End;Else build_def=0
    If \build_def Then,
        If Wordpos('/DEF',parm#)>0 Then Do
            parm#=Delword(parm#,Wordpos('/DEF',parm#),1)
            build_def=1
        End
    If Wordpos('/DF',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/DF',parm#),1)
        delete_def=1;build_def=1
    End
    If Wordpos('/S',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/S',parm#),1)
        summarise=1
    End;Else summarise=0
    If Wordpos('/A',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/A',parm#),1)
        If build_def Then Do i=f_s To f_e
            Parse Value Sourceline(i) With field_var '=' .
            Interpret field_var'=1'
        End
    End
    If Wordpos('/SS',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/SS',parm#),1)
        sep_step=1
    End;Else sep_step=0
    If Index(parm#,'/HLQ(')>0 Then Do
        Parse VAR parm# p1 '/HLQ(' hlq_rep ')' p2
        parm#=Space(p1 p2)
        hlq_rep=Translate(hlq_rep,' ',',')
    End
    If Wordpos('/RH',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/RH',parm#),1)
        delete_def=1;build_def=0;
        rep_hlq=1
    End;Else rep_hlq=0
    If Wordpos('/H',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/H',parm#),1)
        hardcopy_l=userid'.LOGSTRM.LIST.D'dater;list=1
        If delete_def Then hardcopy_f="'"userid'.LOGSTRM.DELETE.D'dater"'"
        Else hardcopy_f="'"userid'.LOGSTRM.DEFINE.D'dater"'"
        hc_disp='NEW'
    End
    If Wordpos('/HA',parm#)>0 Then Do
        parm#=Delword(parm#,Wordpos('/HA',parm#),1)
        If delete_def Then hardcopy_f="'"userid'.LOGSTRM.DELETE.D'dater"'"
        Else hardcopy_f="'"userid'.LOGSTRM.DEFINE.D'dater"'"
        list=1;hc_disp='MOD'
    End
    If \ima_macro & \list Then Do
        zedlmsg="You should be edit/viewing the output of the output",
                "of your report ('/L') run.  Do as you're told and",
                "try again ."
        "SETMSG MSG(ISRZ001)"
        Exit
    End

    Parse VAR parm# namep rep
    If Datatype(namep,'w') Then Parse VAR parm# rep namep
    If \Datatype(rep,'w') Then rep='*'
    Signal on Syntax Name error_off_$VERNAME
    wild1=0;st#=0
    If build_def | delete_def Then list=0
    namep=ver_wild(namep)
    If Verify(hlq_rep,'%*','m')>0 Then x=ver_wild(hlq_rep)
    If list Then x=Report_JCL()
    Address ISREDIT;"(status)=USER_STATE";
    "(dl1,dl2)=DISPLAY_LINES";If dl1>1 Then dl1=dl1+1
    "PROCESS RANGE C";"(cmd)=RANGE_CMD"
    If cmd='C' Then Do
        "(zfrange)=LINENUM .ZFRANGE";"(zlrange)=LINENUM .ZLRANGE"
    End
    Else Do
       zfrange=1
       "F 'LOG STREAM ATTRIBUTES:' LAST"
       If rc=0 Then "(zlrange)=LINENUM .ZCSR";Else "(zlrange)=LINENUM .ZLAST"
    End
    "F 'LOGSTREAM NAME(' FIRST"
    If rc=0 Then Do
        "(lin#)=LINENUM .ZCSR";If lin#>zfrange Then zfrange=lin#+1
    End;Else lin#=zfrange
    "CURSOR="lin# 0;"SCAN=OFF";"(dataset)=DATASET";"CAPS=OFF"
/*  "RESET"                                                           */

analyse:
    If build_def | delete_def Then Do
        "(dataset)=DATASET"
        If Strip(hardcopy_f,,"'")=dataset Then Do
            zedsmsg=;zedlmsg='You are in the output dataset. End out',
                             'of it and execute "LOGR" out of the',
                             'listing.'
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
            Signal get_out
        End
        hardcopy_l=
        If hc_disp/='MOD' Then Do
            x=Report_JCL('Q')
            If hardcopy_f='' Then Do Queued()
                Parse PULL line
                xx=nl(line)
            End
        End
        If \sep_step Then Do
            sep1=' /*'Copies('-',60)'*/';sep2=' /*'Copies(' ',60)'*/'
            xx=nl(sep1)
            If namep/='' Then xtra=' matching "'namep'"';Else xtra=
            If hlq_rep/='' Then Do
                If xtra='' Then xtra=' matching HLQ('hlq_rep')'
                Else xtra=xtra 'and HLQ('hlq_rep')'
            End
            xx=nl(' /*'Left(' Define statements'xtra':',60)'*/')
            xx=nl(sep1)
        End
    End
    Else Do
        xx=nl(Substr('LOG name',1,30) 'HLQ      Ls-Sz  Stg-Sz LowO High MaxBuf')
        xx=nl(Copies('-',30) '-------- ------ ------ ---- ---- ------')
    End
    k=0;panelp='POP#55#2';#popr=10;#popc=25            /* Where popup */
    zwinttl='Hear Ye! Hear Ye!';Address ISPEXEC "VPUT (ZWINTTL)"
    "LABEL" zfrange"=.LINEF";"LABEL" zlrange"=.LINET"
    #rep=rep ;#namep=namep;If #namep='' Then #namep='*'
    Do While #namep/=''
      rep=#rep
      Parse VAR #namep namep ',' #namep
      If \wild1 Then Do
          Parse VAR namep namep '*' .
          find_string='LOGSTREAM NAME('namep
      End
      Else find_string='LOGSTREAM NAME('
      "F '"find_string"' ALL .LINEF .LINET"
      "(lin#)=LINENUM .ZCSR";lin#=lin#-1
      "(hits)=FIND_COUNTS";hits=hits+0;ll=Length(hits)
      da0=Substr('Processing:',1,55)
      sh1=Copies('g',Length(da0))Copies('g',ll)'b'Copies('g',ll)Copies('y',46)

      Do While rc=0
          line=;If lin#+1>zlrange Then Leave
          "CURSOR="lin#+1 0
          "F '"find_string"' NEXT";If rc/=0 Then Iterate
          "(lin#)=LINENUM .ZCSR";If lin#>zlrange Then Do;rc=1;Iterate;End
          "(linei)=LINE .ZCSR";linei=Strip(linei)
          If Index(linei,'LOGSTREAM NAME(')=0 Then Iterate
          lin@=lin#
          Do Forever
              If lin@+1>zlrange Then Leave
              lin@=lin@+1;"(linen)=LINE" lin@;Parse VAR linen 2 linen
              If Index(linen,'LOG STREAM ATTRIBUTES:')>0 Then Leave
              If Index(linen,'LOGSTREAM NAME(')>0 Then Leave
              If Substr(linen,1,1)/='' Then Iterate
              linei=linei linen
          End
          Parse VAR linei  'NAME(' lname ')' .,
                           'STRUCTNAME(' struct ')' .,
                           'LS_DATACLAS(' ls_data ')' .,
                           'LS_MGMTCLAS(' ls_mgmt ')' .,
                           'LS_STORCLAS(' ls_stor ')' .,
                           'HLQ(' hlq ')' .,
                           'MODEL(' model ')' .,
                           'LS_SIZE(' ls_size ')' .,
                           'STG_MGMTCLAS(' st_mgmt ')' .,
                           'STG_STORCLAS(' st_stor ')' .,
                           'STG_DATACLAS(' st_data ')' .,
                           'STG_SIZE(' st_size ')' .,
                           'LOWOFFLOAD(' lo ')' .,
                           'HIGHOFFLOAD(' ho ')'.,
                           'STG_DUPLEX(' st_dup ')' .,
                           'DUPLEXMODE(' dupm ')' .,
                           'RMNAME(' rmname ')' .,
                           'DESCRIPTION(' desc ')' .,
                           'RETPD(' retpd ')' .,
                           'AUTODELETE(' auto_d ')' .,
                           'OFFLOADRECALL(' offldr ')' .,
                           'DASDONLY(' d_o ')' .,
                           'DIAG('disag ')' .,
                           'LOGGERDUPLEX(' logdupx ')' .,
                           'EHLQ(' ehlq ')' .,
                           'MAXBUFSIZE(' mb ')' .
          k=k+1;xxx=Right(k,ll)'/'hits lname;x=$addpop();o_hlq=hlq
          If wild1 & $wild(namep,lname)='NO-MATCH' Then Iterate
          If hlq_rep/='' Then Do
              hlq_comp=hlq_rep
              If Verify(hlq_rep,'%*','m')>0 | Words(hlq_rep)>1 Then Do
                  xxx=hlq_rep
                  Do While xxx/=''
                      Parse VAR xxx xx xxx
                      If Verify(hlq_rep,'%*','m')>0 & wild1 Then Do
                          If $Wild(xx' ',hlq' ')='OK' Then Do
                              hlq=hlq_comp;Leave
                          End
                      End
                      Else Do
                          If xx=hlq Then Do
                              hlq=hlq_comp;Leave
                          End
                      End
                  End
              End
          End;Else hlq_comp=hlq
          Select
              When delete_def | build_def Then Do
               If hlq_comp=hlq Then Do
                If sep_step Then x=step_build()
                If delete_def Then Do
                  If Length(lname)>33 Then lname=Substr(lname,1,32)'+'
                  If rep_hlq Then lname=Substr(lname')',1,34) 'HLQ('o_hlq
                  xx=nl('  DELETE LOGSTREAM NAME('lname')')
                End
                If build_def Then Do
                  xx=nl('  DEFINE LOGSTREAM NAME('lname')')
                  If f_ad Then xx=nl('         AUTODELETE('auto_d')')
                  If f_do Then xx=nl('         DASDONLY('d_o')')
                  If f_de Then Do
                      If desc_supplied/='' Then Do
                          If desc='' Then desc=desc_supplied
                          Else If desc_over Then desc=desc_supplied
                      End
                      xx=nl('         DESCRIPTION('desc')')
                  End
                  If f_di Then xx=nl('         DIAG('disag')')
                  If f_du & d_o/='YES' Then,
                               xx=nl('         DUPLEXMODE('dupm')')
                  If f_eh & \f_hl Then,
                               xx=nl('         EHLQ('ehlq')')
                  If f_ho Then xx=nl('         HIGHOFFLOAD('ho')')
                  If f_hl Then xx=nl('         HLQ('o_hlq')')

                  If f_lx & d_o/='YES' Then,
                               xx=nl('         LOGGERDUPLEX('logdupx')')
                  If f_lo Then xx=nl('         LOWOFFLOAD('lo')')
                  If f_ld Then xx=nl('         LS_DATACLAS('ls_data')')
                  If f_lm Then xx=nl('         LS_MGMTCLAS('ls_mgmt')')
                  If f_lz Then xx=nl('         LS_SIZE('ls_size')')
                  If f_ls Then xx=nl('         LS_STORCLAS('ls_stor')')
                  If f_mb Then xx=nl('         MAXBUFSIZE('mb')')
                  If f_mo Then xx=nl('         MODEL('model')')
                  If f_or Then xx=nl('         OFFLOADRECALL('offldr')')
                  If f_rt Then xx=nl('         RETPD('retpd')')
                  If f_rm Then xx=nl('         RMNAME('rmname')')
                  If f_sd Then xx=nl('         STG_DATACLAS('st_data')')

                  If f_sx & d_o/='YES' Then,
                               xx=nl('         STG_DUPLEX('st_dup')')
                  If f_sm Then xx=nl('         STG_MGMTCLAS('st_mgmt')')
                  If f_sz Then xx=nl('         STG_SIZE('st_size')')
                  If f_ss Then xx=nl('         STG_STORCLAS('st_stor')')
                  If f_st & struct/='' Then,
                               xx=nl('         STRUCTNAME('struct')')
                  If \sep_step Then xx=nl(' ')
                End
                If sep_step Then xx=nl('/*')
               End
              End
              Otherwise Do
               If hlq_comp=hlq Then Do
                  lineo=Substr(lname,1,30) Substr(o_hlq,1,8) Right(ls_size,6),
                  Right(st_size,6) Right(lo,4) Right(ho,4) Right(mb,6)
                  xx=nl(lineo)
                  "F 'DATA SET NAMES IN USE' NEXT"
                  If rc=0 Then Do
                      "(linei)=LINE .ZCSR";Parse VAR linei ':' dsnu .
                      xx=nl('  ->' dsnu)
                  End;Else rc=0
               End
              End
          End
          If rep/='*' Then Do
              rep=rep-1;If rep<1 Then Leave
          End
      End
    End
    If build_def | delete_def Then Do
        If \sep_step Then xx=nl('/*')
        xx=nl('//')
        dd='LF'Time('s')
        If hardcopy_f/='' Then Do
            If hc_disp='MOD' & Sysdsn(hardcopy_f)='OK' Then Do
                Address TSO "ALLOC F("dd") DSN("hardcopy_f") OLD"
                Address TSO "EXECIO * DISKR "dd" (STEM linei. FINIS)"
                Address TSO "FREE F("dd")"
                x=linei.0
                If linei.x='//' Then Do
                    x=x-1;linei.x=' /*'
                    x=x+1;linei.x=' /* Appending.......'
                    x=x+1;linei.x=' /*'
                    linei.0=x
                End
            End;Else linei.0=0
            x=Msg('Off')
            Address TSO "DELETE" hardcopy_f
            x=Msg(x)
            Address TSO "ALLOC F("dd") DSN("hardcopy_f") REU NEW",
                        "SPACE(60 60) TRACKS RECFM(F B) LRECL(80)",
                        "BLKSIZE(0)" unitvol_o
            If linei.0>0 Then,
                Address TSO "EXECIO * DISKW "dd" (STEM linei."
            Queue ''
            Address TSO "EXECIO * DISKW "dd" (FINIS"
            Address ISPEXEC "CONTROL ERRORS RETURN"
            zedsmsg=;zedlmsg='LOGR: Logstream statements generated (or/and',
                             'appended) to a "staging" dataset.',
                             'Suggest you record the name or copy',
                             'into a more generically usable dataset/member.'
            Address ISPEXEC "SETMSG MSG(ISRZ001)"
            Address ISPEXEC "LMINIT DATAID(DATAID) DDNAME("dd")"
            Address ISPEXEC "VIEW DATAID(&DATAID)"
            Address ISPEXEC "LMFREE DATAID(&DATAID)"
            Address TSO "FREE F("dd")"
        End
    End
    Signal get_out

Get_out:
    "USER_STATE=(status)"
    Exit

$addpop:
    If k//10 /=1 then Return 0
    If \addpop then Do
        If dont_say/='Y' Then Say xxx
        Return 4
    End
    da1=da0 || xxx
    Address ISPEXEC;#rc=rc
    "CONTROL ERRORS RETURN"
    "ADDPOP ROW(&#POPR) COLUMN(&#POPC)";"CONTROL DISPLAY LOCK"
    "DISPLAY PANEL(&PANELP)"
    If rc>8 Then addpop=0 ;Else "REMPOP"
    Address;rc=#rc
    Return 0

Report_JCL:
    j_s=mark(+5)
    Address TSO 'NEWSTACK'
    Signal on Syntax Name error_on_JC
    x=JC('L /Q /9');Signal error_off_JC
error_on_JC:
    Queue "//"userid"L JOB (SU1ZIBMS),'"xcmd"',"
    Queue '//             CLASS=A,COND=(4,LT),'
    Queue '//             MSGCLASS=X,TIME=120,REGION=0M,'
    Queue '//             NOTIFY=&SYSUID,LINES=9999'
error_off_JC:Signal off Syntax
    j_e=mark(-2)
    If Arg(1)='4HELP' Then Return 0
    Queue '//*'
    Queue "//*  Gen'd by: 'AKOS.$$("xcmd")'"
    Queue '//*'
    Queue '//*'
    If hardcopy_l/='' Then Do
        Queue '//HOUSEKP  EXEC PGM=IEFBR14'
        Queue '//SYSPRINT DD DISP=(MOD,DELETE),DSN='hardcopy_l','
        Queue '//            UNIT=SYSALLDA,'
        Queue '//            SPACE=(TRK,(0,0))'
        Queue '//*'
    End
    If \sep_step Then xx=step_build()
    If Arg(1)/='' Then Return 0
    If detail Then Queue '  LIST LOGSTREAM NAME('namep') DETAIL(YES)'
    Else           Queue '  LIST LOGSTREAM NAME('namep')'
    Queue ' '
    Queue '/*'
    Queue '//'
    Queue ' '
    Queue '  LIST LOGSTREAM NAME('namep') DETAIL(YES)'
    Queue ' '
    Queue '  /* SYSTEM LOGS                      */'
    Queue '  DEFINE LOGSTREAM NAME(SRPMVS.TESTTOR.DFHSHUNT) MODEL(NO)'
    Queue '   HLQ(DNTCICS)'
    Queue '   STRUCTNAME()'
    Queue '   STG_DUPLEX(YES) DUPLEXMODE(UNCOND)'
    Queue '   LOWOFFLOAD(40) HIGHOFFLOAD(80)'
    Queue ' '
    Queue '  /* SECONDARY SYSTEM LOGS            */'
    Queue '  DEFINE LOGSTREAM NAME(SYSE.DFHSHUNT.MODEL) MODEL(YES)'
    Queue '   STRUCTNAME(LOG_DFHSHUNT_001)'
    Queue '   STG_DUPLEX(YES) DUPLEXMODE(COND)'
    Queue ''
    dd='LG'Time('s')
    Signal on Syntax Name error_on_$ZTEMPF1
    ztempf=$ztempf();Signal error_off_$ZTEMPF1
error_on_$ZTEMPF1:
    Address ISPEXEC "VGET ZTEMPF"
error_off_$ZTEMPF1:Signal off Syntax
    zedlmsg='You will have to manually submit this JCL or forever',
            'loose it to the bit bucket.'
    Address ISPEXEC "SETMSG MSG(ISRZ001)"
    Address TSO "ALLOC F("dd") DSN('"ztempf"') SHR REU"
    Address TSO "EXECIO * DISKW "dd" (FINIS"
    Address ISPEXEC "LMINIT DATAID(DATAID) DDNAME("dd")"
    Address ISPEXEC "EDIT DATAID(&DATAID)"
    Address ISPEXEC "LMFREE DATAID(&DATAID)"
    Signal on Syntax Name error_on_$ZTEMPF2
    Address TSO "FREE F("dd")";xx=$ztempf(ztempf,'/D')
error_on_$ZTEMPF2:Signal off Syntax
    Exit

step_build:
    st#=Right(st#+1,4,0)
    Queue '//STEP'st#'  EXEC PGM=IXCMIAPU'
    If namep='' Then namep='*'
    Queue '//******************************************************************'
    Queue '//*' $Dateman('VER')':'
    Queue '//*'
    Queue '//*   Define logstream models for system log streams.               '
    If hlq_rep/='' Then Do
        Queue '//*   Using selection template "NAME('namep')" and'
        Queue '//*                            "HLQ('hlq_rep')".'
    End
    Else Queue '//*   Using selection template "NAME('namep')".'
    Queue '//*                                                                 '
    Queue '//******************************************************************'
    If hardcopy_l/='' Then Do
        If st#=1 Then Do
            Queue '//SYSPRINT DD DISP=(NEW,CATLG),DSN='hardcopy_l','
/*          Queue '//            UNIT=SYSALLDA,'                      */
            Queue '//            'unitvol_b','
            Queue '//            SPACE=(TRK,(60,60),RLSE)'
        End
        Else Queue '//SYSPRINT DD DISP=MOD,DSN='hardcopy_l
    End
    Else,
        Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
/*  Queue '  DATA TYPE(LOGR) REPORT(YES)'                             */
    Queue '  DATA TYPE(LOGR) REPORT(NO)'
    If sep_step Then Do Queued()
        Parse Pull linex;xx=nl(linex)
    End
    Return 0

ver_wild:Parse Arg wild_P
    If wild_P/='' Then Do
        If Verify(wild_P,'*%','M')>0 & \list Then Do
            x=$Vername(wild_P,,'*')
            If x/='OK' Then Do
                zedlmsg=Subword(x,2)
                "SETMSG MSG(ISRZ001)"
                Exit
            End
            Signal on Syntax Name error_on_$WILD
            x=$Wild('a','a');Signal error_off_$WILD
error_on_$WILD:Signal off Syntax
            zedlmsg='Function "$WILD" not available. You cannot use',
                    'the explicit wildcard feature. Remove your "*"',
                    'and/or "%" and try again.'
            "SETMSG MSG(ISRZ001)"
            Exit
error_off_$WILD:Signal off Syntax
            wild1=1
            Signal error_off_$VERNAME
        End
        xxx=Translate(wild_P,' ',',');wild_P=
        Do While xxx/=''
            Parse VAR xxx xx xxx
            x=$Vername(xx)
            If x/='OK' Then Do
                zedlmsg=Subword(x,2)
                "SETMSG MSG(ISRZ001)"
                Exit
            End
            wild_P=wild_P xx'*'
            If list Then Leave
        End
        wild_P=Space(wild_P,1,',')
    End
error_off_$VERNAME:Signal off Syntax
    Return wild_P

exec_ext_cmd:
    If \ima_macro Then Do
        zedlmsg='Not a view/edit session to execute the "LOGR /X"',
                'command.'
        Address ISPEXEC "SETMSG MSG(ISRZ001)"
        Exit
    End
    Address ISPEXEC "VGET (zscreeni,zscreenc)"
    screeni=zscreeni;screenc=zscreenc
    line=Translate(Substr(screeni,80*(screenc%80)+1,80),' ','00'x)
    line=Strip(Translate(line))
    Parse VAR line 'LOGR' parms '<' rubbish
    "ISREDIT (status)=USER_STATE"
    "ISREDIT LOGR" parms
    "ISREDIT USER_STATE=(status)"
    Exit

Help_me:
    If Word(parm#,2)='SAY' Then rc=4
    Else "ISREDIT (#member#)=MEMBER"
    If rc=0 Then Do;Address ISREDIT;ima_macro=1;End;Else ima_macro=0
    If site_parm/='' Then xx=site_parm;Else xx=sysid
    site_cics=Logr$(xx)
    Parse VAR site_cics string1 ',' 1 site_cics +59 site_cics2
    If site_cics2/='' Then site_cics=site_cics'+'
    string2=Logr$(string1)
    If site_cics='' Then site_cics='Not Defined in LOGR$'
    n_st=mark(2)                            /* Mark Start             */
/*

   Good &TOD. &CNAME..

   LOGR: LOGR processor [ Ver: &LOGR_VER. ].

   LOGR is a z/OS system logger definitions processor in a plex.
   You can use this function to report, summarise or generate
   "cloning" define statements.

   Suggestion: If you don't have access to the '$BR' routine, issue
               'LOGR ?' in a view/edit session to place help in
               notelines rather than the uncontollable dreaded
               screen-of-red.
   Sets:
   -----
   The following are acceptable site "SET()" parameters for '&SYSID.',
     &SITE_CICS.
     &SITE_CICS2.
   (For further details, see the "SET()" parameter below.)

   Instant parameters (use "LOGR /X" command on lines below):
   -------------------
     logr /l /h                                           <- Report them
     logr /d /h /set(&SITE_CICS.)                         <- delete JCL
     logr /f /h /set(&SITE_CICS.) /desc(/set)             <- define JCL

   Parameter Quick Ref (keyword):
   -------------------------------
   /A  - All fields defined. Even those in exclusion list.
   /B  - Build define logstream.  Same as '/F'.
   /D  - build Delete logstream statements.
   /DEF- build deFine logstream from output. (Same as '/F'.)
   /DEL- build Delete logstream statements. (Same as '/D'.)
   /DESC(){O}
       - Supplied description for logstream.
   /DF - build Delete/deFine logstream statements.
   /F  - build deFine logstream from output of option '/L'.
   /H  - Hard copy into '&USERID..LOGSTRM.LIST.D&DATER.' (option '/L')
       - Hard copy into '&USERID..LOGSTRM.DEFINE.D&DATER.'
         (options '/DF' or '/F')
       - Hard copy into '&USERID..LOGSTRM.DELETE.D&DATER.'
         (options '/D')
   /HA - Hard copy (append) into '&USERID..LOGSTRM.DEFINE.D&DATER.'
         (options '/DF' or '/F')
       - Hard copy (append) into '&USERID..LOGSTRM.DELETE.D&DATER.'
         (options '/D')
   /HLQ()
       - HLQ to match for Delete/deFine.
   /L  - List logstreams.
   /NP - No Popup (for debugging).
   /S  - Sumarise logstream from output of option '/L'.
   /SET()
       - Site's LPAR to generate logstreams for.
   /SS - Seperate Steps (for Delete/deFine option).
   /T  - deTailed list. (Sets '/L' option.)
   /TR - TRace (for debugging).
   /X  - eXecute command extracted from cursor placed line from part
         of the tutorial. Save cut and paste (because I can).
    ?  - Tutorial.

   Once the above keywords have been extracted from the parameter stream
   the ramaining is/are used as positional as follows,

   1.  'list-of-names' (comma seperated) names to generate statements 4.
            - Or -
       'masked.string' (only 1 string permitted per pass, use the append
                        option and re-run if you want multiple masks)
   2.  nn   - Numeric counter of qualifier matches to return.

   Examples of use:
     LOGR { /L }                  - list all the logs in the plex (while
                                    editing/viewing logstream list
                                    output). (This is the default.)
     LOGR /L CICSA                - list all the CICSA* logs
     LOGR /T CICSA                - detailed list of all the CICSA* logs
     LOGR /S CICSA,CPSM           - Summarise all the CICSA* and CPSM*
                                    logs
     LOGR /F AT,CICSA,CPSM 2      - Build the first 2 logstream defines
                                    for each of AT, CICSA* and CPSM*.
     LOGR /F **.DFH*              - Build the DFHLOG and DFHSHUNT logs
                                    for all the CICS regions. (May pick
                                    up a few stragglers that fit the
                                    mask and will have to be manually
                                    deleted.)
     LOGR /F ETS.CICS,ETS.ATR     - Build the DFHLOG and DFHSHUNT logs
                                    for all the CICS regions.
                                    May include 'user'
                                    journals eg., DFHJ01 etc. which you
                                    probably want anyway.
                                    Also include the ETS.ATR* logstreams
                                    at ETS.  All other logstreams are
                                    ignored.
     LOGR /D SRPMVS.**.DFH*       - Get what you ask for at Standard
                                    Register site (hopefully no
                                    drift-wood due to more discreet
                                    filtering). May include 'user'
                                    journals eg., DFHJ01 etc. which you
                                    probably want anyway.
                                    Alternatively pass parameter of
                                    '/SET(SRC_CICS)'
     LOGR /F   /SET(ETS_CICSD)  - or -
     LOGR /DEF /SET(ETS_CICSD)    - Generate logstreams as setup in
                                    LOGR$ against "ETS_CICSD".
     LOGR /F **.DFH* /HLQ(DNPCICS) /DESC(ETS PRODUCTION CICS)O
                                  - Generate logstreams for hlq DNPCICS
                                    matching the mask and overwrites
                                    any description with "ETS PRODUCTION
                                    CICS".
     LOGR ? /SET(sysid)           - Include the sets for 'sysid' in the
                                    tutorial.  Why?  Because I can....

     logr /d /h /set(kmart_cics)
     logr /f /h /set(kmart_cics) /desc(/set)
                                  - Two commands to use to generate the
                                    delete and define JCL respectively
                                    in seperate datasets at a KMART DR
                                    site.

   The following parameters will be processed:
   Keywords:
   ---------
   /A  - All fields.  Use in conjunction with the '/F' parameter and
         generate define statemants that include all fields regardless
         of site's field flag settings. (It's easier to delete
         unnecessary lines than build manually.)
         Note: Not all field combinations are valid.  Some are mutually
               exclusive and I havent ironed out ALL combinations.
   /B  - Build define logstream. (Same as '/F' and included for
         historic purposes.)
   /D  - build Delete logstream statements from output of option '/L'.
         You may restrict the define statements by passing a prefix
         'string'.
   /DEF- Same as '/F'.
   /DEL- Same as '/D'.
   /DESC(){O}
       - Any free format string (between() unquoted) to be plugged into
         a description. Only applicable for defines, otherwise ignored.
         Is ignored if there is already a description unless an Override
         paremeter 'O' is appended after the closing ) without any
         spaces.  Description must be 16 alphanumeric or national
         ($,#,@) characters, underscore (_) or period (.), padded on the
         right with blanks if necessary. Imbedded blanks will be
         converted to underscore(s).
         Supply of this parameter will automatically turn variable
         f_de=1 (on).
         You may use literal value of '/SET' to use the same value
         you supplied with the "/SET" parameter. Minimises typos.
   /DF - build Delete/deFine logstream statements. (Combination of
         '/D' and '/F' commands.
   /F  - build deFine logstream from output of option '/L'. You may
         restrict the define statements by passing a prefix 'string'.
         (See build fields below.)
   /H  - Hardcopy into dataset '&USERID..LOGSTRM.LIST.D&DATER.' as
         opposed to SDSF held output.
         Will force the '/L' option and without a define or delete
         parameter WILL force listing operation.
         With either a '/D' or '/F' parameter, will output statements
         into dataset '&USERID..LOGSTRM.DEFINE.D&DATER.' rather than
         NOTElines in the logstrem list dataset.
   /HA - Hardcopy append define or delete statements onto dataset
         '&USERID..LOGSTRM.DEFINE.D&DATER.'.
         The routine will convert the '/*' and '//' last two lines of        */
         the original JCL into IXCMIAPU comments with an "Appending...."
         eyecatcher in it to provide contiguous instream SYSIN data.
         Without a delete or define parameter this will be treated as
         the '/H /L' options, however, no appending will be done as
         you can only generate 1 unique listing per plex regardless
         of LPAR, so accumulation is senseless.
   /HLQ(hlq1{,hlq2,..hlqn})
       - Only generate log stream delete/define statemsts for matching
         hlq's. This can be a list of hlq's awhich can be wildcarded
         using the '%' character placeholder or the '*' string place
         holder.  (Only applicable to '/D', '/DF' and '/F' options.)
         Use the "/S" summarise option to identify HLQ's associated
         with each log streams.
         If wildcarding, only 1 hlq will be accepted. For multiple hlq's
         they must be the full value any truncation will either fail a
         full word compare or only returned the truncated qualifier.
   /L  - List logstreams.  (Will be forced with the '/H' hardcopy
         feature.)
         This is the default if invoked as a TSO command..
   /NP - No Popup (for debugging) or to remove the progress indicator
         (if it anoys you). However, without this parameter and no
         pop-up panel availability, you will get a progress "Say"
         statement.
   /S  - Sumarise logstreams from output of option '/L'. One summary
         lines for each logstream.  You may restrict the define
         statements by passing a prefix 'string'.  The following fields
         will be displayed,
           LOG name             HLQ      Ls-Sz  Stg-Sz LowO High MaxBuf
           -------------------- -------- ------ ------ ---- ---- ------
           AP1CIP01.DFHLOG      SYDCICS    4579   4579   10   95  64000
           .......
         This is the default when invoking LOGR as an edit macro.
   /SET()
       - Site's LPAR to generate logstreams for. Either enter the LPAR
         name (will default to currenmt LPAR) or enter a site
         identifier.  Any walid entry used as object of this parameter
         must be defined in REXX routine 'LOGR$'.
         The following are acceptable site parameters for '&SYSID.',
            &SITE_CICS.
            &SITE_CICS2.
         If you invoke LOGR using the following command,
            LOGR /D /SET(&STRING1.)
         it would generate and execute,
            LOGR /D /SET(&STRING2.)
   /SS - Seperate steps. Use this feature if there is potential for an
         error which would stop subsequent processing.  If in seperate
         steps only the sole log stream in that step would not be
         be executed and condition codes will permit all other valid
         steps to be executed.
   /T  - deTailed listing. Uses list parameter of 'DETAIL(YES)'.
         (Sets '/L' option.)

   Positional:
   -----------
   First:
   ------
   ccc{,cc2,cc3,Q1.Q2.Q3}
       - A nonblank string of dataset naming qualifiers.  This is a
         prefix and no wildcarding is permitted.   DO NOT use trailing
         '*' as a trailing '*' is the implied wildcarding and an exact
         match will be made on the log name using the prefix(s).
         Validation is attempted using $VERNAME if available, otherwise,
         wear what you input.  You may seperate multiple 'prefixes' by
         commas or spaces.  The prefix(s) may be single or multi
         qualified.  You can only use one prefix for the '/L' (list)
         option.
     - Or -
   cc%cc.*.SYS*
       - You may enter only one wildcarded prefix which may include
         imbedded '%' (single character) or '*' (string) wildcard
         characters. With this parameter a full listing will be
         processed and each logstream will be tested using the "$WILD"
         function for a match. This may be a timely process for large
         log listings.  This feature cannot be used for the '/L' (list)
         option.
   Second:
   -------
   nn | *
       - You may enter the number of matches (per qualifier set) to
         process or '*' for all hits.  Default is '*'. (This option was
         created to limit tracing loops during testing and I decided
         to leave it in.)

   Build fields:
   -------------
   The following variables can be found at the top of this REXX program
   and can be changed to 1 (include) or 0 (exclude) that field in the
   generated define statements.  This routine has the following flag
   setings (on code lines &F_S.-&F_E. sotrted alphabetically):
     f_ad=&F_AD.  /* AUTODELETE     */
     f_do=&F_DO.  /* DASDONLY       */
     f_de=&F_DE.  /* DESCRIPTION    */
     f_di=&F_DI.  /* DIAG           */
     f_du=&F_DU.  /* DUPLEXMODE     */
     f_eh=&F_EH.  /* EHLQ           */
     f_ho=&F_HO.  /* HIGHOFFLOAD    */
     f_hl=&F_HL.  /* HLQ            */
     f_lx=&F_LX.  /* LOGGERDUPLEX   */
     f_lo=&F_LO.  /* LOWOFFLOAD     */
     f_ld=&F_LD.  /* LS_DATACLAS    */
     f_lm=&F_LM.  /* LS_MGMTCLAS    */
     f_lz=&F_LZ.  /* LS_SIZE        */
     f_ls=&F_LS.  /* LS_STORCLAS    */
     f_mb=&F_MB.  /* MAXBUFSIZE     */
     f_mo=&F_MO.  /* MODEL          */
     f_or=&F_OR.  /* OFFLOADRECALL  */
     f_rt=&F_RT.  /* RETPD          */
     f_rm=&F_RM.  /* RMNAME         */
     f_sd=&F_SD.  /* STG_DATACLAS   */
     f_sx=&F_SX.  /* STG_DUPLEX     */
     f_sm=&F_SM.  /* STG_MGMTCLAS   */
     f_sz=&F_SZ.  /* STG_SIZE       */
     f_ss=&F_SS.  /* STG_STORCLAS   */
     f_st=&F_ST.  /* STRUCTNAME     */
   Parameter of '/A' will turn all field generations on for the run.


   Packaging:
   ----------
   The following members are required to fully package this function.
   Note:- Members marked with an 'o' seperator are 'optional', however,
          full functionality of this routine will not be achieved
          without them.

   $VERNAME -  Verify format of 'ccc' string positional parameter.
               Without this routine you won't be advised of an error
               and no define or summary statements will be generated
               without warning.
               (This has been imported into this REXX program.)
   $WHOAMI  o  You don't want to be called "there". Do you???
   $WILD    -  Permit entering wildcarded prefixes (using '*' and '%'
               placeholders).
               (This has been imported into this REXX program.)
   $ZTEMPF  o  Allocate a temporary file (ZTEMPF).  Without this
               routine. ISPF's "VGET ZTEMPF" facility will be used.  If
               your site limits the number of ISPF temporary files and
               you have reached that limit, the routine will, in the
               words of IBM, produce "unpredictable results".  Also I'm
               getting sick and tired of having to cater for sites that
               create uncatalogued temporary ISPF datasets.
   JC       o  Generate site customised JCL jobcard.  Without this
               routine you may need to customise this routine at lines
               &J_S.-&J_E. to site standards.
   LOGR     - This driver.
   LOGR$    - Site customisation member. Use this member to customise
              a combination of names/name patterns and hlq(s) to define
              a particular functional set for each site.
              Eg.  set "ETS_CICS" would be all the CICS logstreams used
                   at site "ETS".

                                 *****

   Modifications:
   --------------
   28/08/09 ALK - Provided hard copy facilities for delete/defines (as
                  an alternative to notelines).
   25/08/09 ALK - Imported $WILD, $CSTRING and $VERNAME to make LOGR
                  stand alone.
                  Added '/DESC()' option.
   28/07/08 ALK - Added the site customiser module LOGR$ and the
                  '/SET()' parameter.
   12/02/07 ALK - Added the '/SS' seperate steps option.
   04/12/06 ALK - Added the '/HLQ()' option.

   GOTCHAs:
   ----------
   1. Without parameters the listing will be put to spool.
   2. On very large plexes, you may need to split (however you can)
      your listing for statement generation purposes.  You have to be
      in either view/edit session.  If you get view size errors, suggest
      you up your TSO size limit to the max first.
   3. If you use the append option, watch out for imbedded '//'
      terminator cards.
   4. If you use the append option with the '/SS' (seperate steps)
      option, stepnames will be duplicated.
   5. When generating delete/define statements, they will be placed as
      notelines in your session without the '/H{A}' options.
      Either rerun with the '/H' option or use the MD (make data) line
      commands and copy the lines out of the dataset. DO NOT forget to
      CANCEL out if in an edit session. LOGR execution without the
      hardcopy option will reset the session and replace any existing
      notelines with new ones, so you can't build/accumulate lists.
   6. Only 1 masked string is permitted per command. For multiple
      wildcarding, use the append feature. However, name string are
      actually prefix masks (without the trailing '*') and can be
      supplied in a comma seperated list.
      Short prefix strings could return more data then desired.
   7. Only single HLQ can be wildcarded. Multiple hlqs must be consist
      of full qualifiers comma seperated.
   8. Ensure that your sites LPARS are listed above all similar named
      LPARS in the generic site customisation member LOGR$.
   9. The /DESC() description update feature will apply to all defines.
      So don't wildard or use lists that may cross "description"
      boundaries.
  10. Depending on storage settings for site, hard copies may finish up
      on temporay storage.  Please don't blame me if your datasets get
      creamed by SMS after a few days or so. You have been warned...


                                 *****

*/
    n_en=mark(-2)                           /* Mark End               */

    chgchar='&';cname='there'
    Signal on Syntax Name error_off_$WHOAMI
    Parse Value $Whoami() With cname sname  /* Toggle as per format   */
error_off_$WHOAMI: Signal Off Syntax
    Parse Value Time() With hh ':' 1 time +5
    Select
        When hh<12 Then tod='morning'
        When hh<18 Then tod='afternoon'
        Otherwise tod='evening'
    End
    x=Report_JCL('4HELP');Address TSO "DELSTACK"     /* Jobcard lines */
    If ima_macro Then Do
        Address ISREDIT;"(caps)=CAPS";"CAPS=OFF"
        "(dl1,dl2)=DISPLAY_LINES";If dl1>1 Then dl1=dl1+1
    End
    Do i=n_st To n_en
        line=Sourceline(i)
        Do While Index(line,chgchar)>0
            Interpret "Parse VAR line p1 '"chgchar"' var '.' p2"
            If Index(var,'(')>0 Then Do
                Parse VAR var var '(' vl ')'
                If Â¬Datatype(vl,'W') Then vl=Length(var)
                Interpret 'line=p1||Substr('var',1,vl)||p2'
            End
            Else Interpret 'line=p1||'var'||p2'
        End
        x=nl(Substr(line,1,72))
    End
    If ima_macro Then Do;"CAPS=(caps)";Address;End
    Exit

nl:Parse Arg n#
    If hardcopy_f/='' Then Queue n#
    Else If ima_macro Then "LINE_BEFORE" dl1"=NOTELINE (n#)"
         Else Say n#
    Return 0
Mark:Arg diff;If \Datatype(diff,'W') Then diff=1;Return sigl+diff

/*--------------------------ooo00 REXX 00ooo--------------------------*/
$Wild:$wild_ver='1.04'
/*--------------------------ooo000OOOO000ooo--------------------------*/
/*  $WILD:                                                            */
/*                                                                    */
/*  Function to check each word in a list against a mask. The list    */
/*  can be:                                                           */
/*    - List of dataset names                                         */
/*    - List of member names                                          */
/*    - String of text/code etc.                                      */
/*                                                                    */
/*  Parameters (positional):                                          */
/*  1. mask   - Dataset mask wildcarded by interspacings of '*' for   */
/*              any string mask or '%' for any single character mask. */
/*              Note: Mask is not validated but parsed into matching  */
/*                    components based on the locations of '%' and    */
/*                    '*'.                                            */
/*  2. list   - List of dataset names. Should be unquoted and space   */
/*              seperated, however, any quotes (no                    */
/*              prefix added) and comma seperators will be removed.   */
/*              If no list is provided 'NO-DATA' is returned.         */
/*              The returnde data will be en entry for each dataset   */
/*              with one of the following values:                     */
/*                NO-MATCH                                            */
/*                OK                                                  */
/*  3. 1 | ASIS                                                       */
/*            - Numeric "1" to indicate that the list is 1 record     */
/*              containing embeded blanks (eg. text or code) rather   */
/*              than space seperated entities.                        */
/*              If using this feature you must perform upper case     */
/*              translation if required before invoking the function. */
/*                          - or -                                    */
/*            - Any (other than 1) non blank character (eg. 'ASIS')   */
/*              To prevent upper case translation to both the mask    */
/*              and list.                                             */
/*                                                                    */
/*  Examples:                                                         */
/*                                                                    */
/*  1.Check a list of datasets against a mask:-                       */
/*      list='dataset1 dataset 2 .... datasetn'                       */
/*      mask='hlq%.ISP%LIST.*.TEMP*'                                  */
/*      match=$wild(mask,list)                                        */
/*      Do WHile match/=''                                            */
/*          Parse VAR list dsn list;Parse VAR match rcm match         */
/*          Say Left(dsn,44) rcm                                      */
/*      End                                                           */
/*                                                                    */
/*  2.Check line(s) against a tring mask:-                            */
/*      mask='*STR%NG% #%%% *'                                        */
/*      Do i=first to last                                            */
/*          "(line)=LINE" i;lineu=Tranlate(line)                      */
/*          If $wild(mask,lineu,1)='OK' Then Say 'line' i 'matched'   */
/*      End                                                           */
/*                                                                    */
/*  Gotcha(s):                                                        */
/*  1. Each time the function is called, the mask is parsed. If you   */
/*     are execution cycle constrained and your need is to check for  */
/*     many single 'texts' at a time using complex masks, copy        */
/*     "$WILD" into your routine and invoke the 'De_Mask' option once */
/*     and then the '$Wild_Match' for each dataset, eg. (assuming     */
/*     this resides snugly at to end of your REXX),                   */
/*        x=De_Mask(mask)                                             */
/*        Do While dsn_list/=''                                       */
/*            ....                                                    */
/*            rcm=$wild_match(dsn)                                    */
/*            ....                                                    */
/*        End                                                         */
/*  2. Needs acces to routine '$CSTRING'.                             */
/*  3. '*' and '**' are treated the same. A single '*' will cross     */
/*     qualifier boundaries (dots) like '**'.                         */
/*                                                                    */
/*--------------------------------------------------------------------*/
     Parse Arg mask,dsn_list,asis
     If asis='' Then Do;mask=Translate(mask);dsn_list=Translate(dsn_list);End
     If dsn_list='' Then Do
         Parse VAR mask mask ',' dsn_list
         If dsn_list='' Then Parse VAR mask mask dsn_list
         dsn_list=Translate(dsn_list,' ',',')
     End
     x=De_Mask(mask);If dsn_list='' Then Return 'NO-DATA'
     If asis=1 Then Return $wild_match(dsn_list)
     hit_list=
     Do While dsn_list/=''
         Parse VAR dsn_list dsn dsn_list;dsn=Strip(dsn,,"'")
         hit_list=hit_list $wild_match(dsn)
     End
     Return Space(hit_list)

/*--------------------------------------------------------------------*/
/* Break the mask up into each of its 'components' for later use.     */
/*--------------------------------------------------------------------*/
De_Mask: Parse Arg mask
    pmask=$cstring(mask,'.*','*',1,'*');optr=1;j=0
    Do Forever
        nptr=Verify(pmask,'*%','M',optr);If nptr=0 Then Leave
        j=j+1
        If optr/=nptr Then,
            Interpret "Parse VAR pmask" optr "mv.j +"nptr-optr" mc.j +1 rest"
        Else Do
            Interpret "Parse VAR pmask" optr ". +"nptr-optr" mc.j +1 rest"
            mv.j=
        End
        optr=nptr+1
        If mv.j||mc.j='.*' Then j=j-1
    End
    mv.0=j
    Return pmask

$wild_match: Parse Arg line
        optr=1;match=1;prevc='%'
        If mv.0=0 Then Do
            Interpret "Parse VAR line p1 +"Length(pmask)
            If pmask/=p1 Then Return 'NO-MATCH'
            Else Return 'OK'
            Iterate
        End
        Do j=1 To mv.0
            If mv.j/='' Then Do
                ll=Length(mv.j)
                If prevc='%' Then Do
                    Interpret "Parse VAR line" optr "p1 +"ll
                    If mv.j/=p1 Then Do;match=0;Leave;End
                    optr=optr+ll
                End
                Else Do
                    nptr=Index(line,mv.j,optr)
                    If nptr=0 Then Do;match=0;Leave;End
                    optr=nptr+ll
                End
            End
            prevc=mc.j;If prevc='%' Then optr=optr+1
        End
        If \match Then Return 'NO-MATCH'
        If rest/='' Then Do
            If prevc='%' Then Do
                Interpret "Parse VAR line" optr "p1 +"Length(rest)
                If rest/=p1 Then Return 'NO-MATCH'
            End
            Else Do
                nptr=Index(line,rest,optr)
                If nptr=0 Then Return 'NO-MATCH'
            End
        End
        Return 'OK'

$Wild_End:
/*--------------------------ooo00 REXX 00ooo--------------------------*/
$cstring:Version='1.04';If Arg(1)='?' Then Return Version
    Parse ARG string,fstrg,tstrg,start,rep,f_n
    Numeric Digits 10
    If tstrg='' & Length(tstrg)=0 Then change=0;Else change=1
    If f_n/='' Then change=1                /* Force change no matter */
    If Datatype(rep)='NUM' & change=0 Then rpos=1;Else rpos=0
    If rep='*' Then rep=9999999999
    If \Datatype(rep,'W') Then rep=1
    If \Datatype(start,'W') Then start=1
    fl=Length(fstrg);tl=Length(tstrg);ct=0
    Do i=1 To rep
        start=Index(string,fstrg,start);r_pos=start;If start=0 Then Leave
        If change Then Do
            string=Delstr(string,start,fl)
            string=Insert(tstrg,string,start-1,tl)
            rep=rep-1;start=start+tl
        End
        Else Do;ct=ct+1;start=start+fl;End
    End
    If rpos Then Return r_pos;Else If change Then Return string;Else Return ct

/*--------------------------ooo000OOOO000ooo--------------------------*/
/* $CSTRING:                                                          */
/* Function to change occurances of a string in a string to another   */
/* string.                                                            */
/*    - or -                                                          */
/* Return the number of occurrances of a string in another string.    */
/*    - or -                                                          */
/* Return the pointer to the nth. occurance of a string within a      */
/* string starting from a particular position (if not found 0)        */
/*                                                                    */
/* Format:                                                            */
/*  $CSTRING(string,fr_string,to_string,start_col,repetition,f_nulls) */
/*                                                                    */
/*     where (positional) parameters are:-                            */
/*       1. string      - Original string                             */
/*       2. fr_string   - Character(string) in original string to     */
/*                        change from.                                */
/*       3. to_string   - New value, character(string). If this       */
/*                        parameter is omitted (NULLS) then a count   */
/*                        of the occurrances of the from_string is    */
/*                        returned. Note, space(s) is NOT 'NULL'.     */
/*       4. start_col   - Starting column. Default is 1.              */
/*       5. Repetition  - Occurances to change. Default is 1. '*'     */
/*                        changes all occurances or acts as a tally   */
/*                        indicator if 'to_string' is missing.        */
/*                      - If the to_string is missing and this value  */
/*                        is numeric, the pointer to the valued       */
/*                        occurance after the start is returned (acts */
/*                        as an Index of occurance command).          */
/*                      - If both the to_string and this value is     */
/*                        missing, it will be set to '*' to make it   */
/*                        act like a 'tally' and return the number of */
/*                        occurances (after the start column).        */
/*       6. f_nulls     - In case to_string is nulls, any non blank   */
/*                        value will indicate that the 'to_string' is */
/*                        literally NULLs and not missing to control  */
/*                        a tally function. Leave this and to_string  */
/*                        as blanks to perform a tally.               */
/*                        eg. tally=$CSTRING(string,find_chars,,,,)   */
/* Use command "$RU $CSTRING" ($Routine Upgrade) to update with the   */
/* latest infrastructure copy of $CSTRING.  Use command               */
/* "$RU $CSTRING ?" to display latest infrastructure version.         */
/*--------------------------------------------------------------------*/
$cstring_End:
/*-----------------------------< REXX >-------------------------------*/
/* $VERNAME: [V1.03]                                                  */
/* -----------------                                                  */
/* Parses the passed string to verify each qualifier to be a valid    */
/* name format (will handle member names).                            */
/*                                                                    */
/* Parameters:                                                        */
/*   Input (positional):                                              */
/*   1. String to be parsed.                                          */
/*   2. Member only indicator:                                        */
/*       'M' - Member name (wildard indicators "*" and "%" accepted). */
/*       'N' - Member name (National/numeric characters only)         */
/*       Anything else will be treated as dsn(member).                */
/*   3. Wildcarding on dataset indicator. Any non-blank value will    */
/*      accept wildard indicators "*" and "%".                        */
/*   Return:                                                          */
/*   1. If valid returns 'OK' else returns an error message.          */
/*--------------------------------------------------------------------*/
$Vername:Arg xx,act,wild
    If xx='' Then Return "Missing dataset name."
    If Substr(xx,1,1)="'" Then Parse VAR xx "'" xx "'"
    If wild/='' Then wild='*%'
    If Wordpos(act,'M N')>0 Then Parse VAR xx member yyy
    Else Parse VAR xx yyy '(' member ')' .
    Do While yyy /= ''
        Parse VAR yyy yy '.' yyy
        If Length(yy) > 8 Then Return 'Error: Qualifier "'yy'" > 8 bytes.'
        x=Verify(Substr(yy,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$'wild)
        If x>0 Then Return 'Error: Qualifier "'yy'" must start with a',
                           'national character.'
        x=Verify(Substr(yy,2),'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$0123456789'wild)
        If x>0 Then Return 'Error: Qualifier "'yy'" must only contain',
                           'national and numeric characters.'
    End
    If member /= '' Then Do
        If act='N' Then wild=;Else wild='*%'
        yy=member
        x=Verify(Substr(yy,1,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$'wild)
        If x>0 Then Return 'Error: Member name "'yy'" must start with a',
                           'national character.'
        x=Verify(Substr(yy,2),'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$0123456789'wild)
        If x>0 Then Return 'Error: Member name "'yy'" must only contain',
                           'national and numeric characters.'
    End
    Return 'OK'
$Vername_End:
/******************************** REXX ********************************/
/*                                                                    */
/* $WHOAMI:                                                           */
/*                                                                    */
/* This routine will check the ACEE control block to get persons name.*/
/* Change variable "cname1st=" to name format according to site:      */
/*    1 -Christian name first.                                        */
/*    0 -Surname followed by christian name.                          */
/*                                                                    */
/* This routine wil convert names to lower case (starting with        */
/* capital) and return what asked for, either Christian, surname or   */
/* both.                                                              */
/* It is also used by $WHOAMIC to return "CNAME1ST" setting.          */
/*                                                                    */
/* This routine can be automatically configured using $WHOAMIC.       */
/*                                                                    */
/* DO NOT CHANGE THE 1ST. LINE AFTER THESE COMMENTS AS IT IS USED FOR */
/* CUSTOMISATION by "$WHOAMIC" (automatically invoked by "$CUSTOM").  */
/*--------------------------------------------------------------------*/
$Whoami:
    cname1st=0                           /* 1=ChrisSurn, 0=SurnChris  */
    Parse Upper ARG type .;Parse Source . op_mode .
    If type='CNAME1ST' Then Return cname1st
    name=getname()
    name=Translate(name,'  ','.,') /* Cater for '.' or ',' seperator */
    If cname1st Then Parse var name cname sname .
    Else Parse var name sname cname .
    Return $U2Lower(name,2,'*')

/*--------------------------------------------------------------------*/
/* Get name from ACEE control block (imported from REXX '$getname' for*/
/* self containment).                                                 */
/*--------------------------------------------------------------------*/
getname:
    ascb=Storage('224',4)
    asxb=Storage(d2x(c2d(ascb)+x2d('6c')),4)
    acee=Storage(d2x(c2d(asxb)+x2d('c8')),4)
    nam@=Storage(d2x(c2d(acee)+x2d('64')),4)
    name=Storage(c2x(nam@),30)
    len =c2d(Substr(name,1,1))
    name=Substr(name,2,len-1)
    Return name

/*--------------------------------------------------------------------*/
/* Convert upper to lower (imported from REXX routine '$lower' for    */
/* self containment).                                                 */
/*--------------------------------------------------------------------*/
$U2Lower:
    ARG text,pos,rep
    lc='abcdefghijklmnopqrstuvwxyz';uc='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    If Datatype(rep,'W') Then Nop;Else rep=99999
    If Datatype(pos,'W') Then Nop;Else pos=2
    rname=
    Do i=rep by -1 To 1
        Parse VAR text name text
        If pos>1 Then Do
            pref=Substr(name,1,pos-1);suff=Substr(name,pos);End
        Else Do;pref=;suff=name;End
        rname=rname pref||Translate(suff,lc,uc)
        If text='' Then Leave
    End
    Return Strip(rname text)
$Whoami_End:
