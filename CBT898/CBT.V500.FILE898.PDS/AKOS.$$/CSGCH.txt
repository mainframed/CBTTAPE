/******************************** REXX ********************************/
    csgchver='V3.11'
/*--------------------------ooo000OOOO000ooo--------------------------*/
/*                                                                    */
/*  CSGCH:                                                            */
/*  Routine to create JCL for CICS change processing.                 */
/*                                                                    */
/*  Members required to package this routine. Those marked with 'o'   */
/*  are optional:                                                     */
/*  REXX:                                                             */
/*    $ALKJCPG o Routine to return non standard 'program name' for    */
/*               use on JOBCARD for applicable sites.                 */
/*    $WHOAMI  o Identify user.                                       */
/*    $WORDAT  - Return word a character position. Required by CSGCH$ */
/*               at some sites.                                       */
/*    CSGCH    - Driver                                               */
/*    CSGCH$   - Configuration file. Must be tailored for each site.  */
/*    CSGCHELP o Dynamic tutorial text.                               */
/*    CSGCH*   - Miscellaneous samples and routines.                  */
/*    $CSTRING - String change maipulation routine.                   */
/*    $DATEMAN - Date manipulation routine used to calculate Mondays. */
/*    FTPANY1  o Routine to FTP datasets between systems. Alternative */
/*               to XMIT and eliminates the 'RECEIVE' process.        */
/*    HELPDRVR o Dynamic tutorial driver.                             */
/*    HELPTN   o Dynamic tutorial navigation text.                    */
/*                                                                    */
/*  Panels:                                                           */
/*    CSGCHPCO - Copy member selection panel                          */
/*    CSGCHPDY - Table display panel for datasets used as generated   */
/*               by CSGCH$ routine.                                   */
/*    CSGCHPD1 - Table display panel (with sequence numbers for debug)*/
/*    CSGCHP   - Main data entry panel                                */
/*    CSGCHPR  - Regions data entry panel                             */
/*    HELPDRVP o Dynamic tutorial panel                               */
/*                                                                    */
/*  Skeleton:                                                         */
/*    HELPDRVS o Dynamic tutorial skeleton for tutorial print.        */
/*                                                                    */
/*  Messages:                                                         */
/*    GC00     - Generic messages member.                             */
/*                                                                    */
/*  Programs:                                                         */
/*    BATCHSIN - Vehicle for making variable susbstitutions in SYSIN  */
/*               data.                                                */
/*    DFH0CBDC o CSD extract program for file compares.               */
/*                                                                    */
/*  Note.                                                             */
/*  -----                                                             */
/*  Members should reside in permanent ISPF allocated datasets and    */
/*  should NOT be ALTLIBd and LIBDEFd.                                */
/*                                                                    */
/*--------------------------------------------------------------------*/
    Parse Upper Arg parm#;Address ISPEXEC;"CONTROL ERRORS RETURN"
    im_a_macro=0
    If parm#/='' Then Signal byp1
    "ISREDIT MACRO (parm#) NOPROCESS"
    If rc=0 Then im_a_macro=1

byp1:
/*  "CONTROL ERRORS CANCEL"                                           */

ini1:
    userid=Userid()
    zedsmsg=
    Parse SOURCE . . xcmd .

    If cname/='CNAME' Then Signal error_off_$WHOAMI
    cname='there'
    Signal on Syntax Name error_off_$WHOAMI
    cname=$whoami('C')
error_off_$WHOAMI:Sinal Off Syntax
    If im_a_macro  Then Do
        "VGET (csgchmac) SHARED"
        xx=csgchmac;csgchmac=;"VPUT (csgchmac) SHARED"
        If xx/='' Then Interpret "Signal" xx
    End

    "VGET (ZAPPLID) ASIS"
    tapplid='CSG'
    If zapplid/=tapplid Then Do
        "SELECT CMD(%"xcmd parm#") NEWAPPL("tapplid")"
        Return 0
    End

    jcltyp='JOBL PROC PARM TAB UTIL AUTH'   /* CSD LOAD seperate      */
    string1=' ',
            '$CSD C:CSD:',
            '$PAR P:Parmlib:',
            '$JOB J:JOBlib:',
            '$PRO R:Proclib:',
            '$TAB T:CICS tables:',
            '$UTI U:In-house UTILLIB:',
            '$AUT A:AUTHLIB:',
            '$CTR M:Control-M:',
            '$LOA L:Region loadlib:',
            ' '
    string2=' ',
            'BU U:backup:',
            'ST S:staging:',
            'IM I:implement:',
            'BO B:backout:',
            'UP P:update:',
            'OC O:oper command:',
            'RS R:Review staging with backup:',
            'RU R:Review original with backup:',
            ' '
    chgmanc=Csgch$('chgmanc')
    valcmd="entered. Valid commands are:",
           "                         Edit, View, Browse, ?, *,",
           "$$$INDEX, ALTER nn, APPEND=Y/N, APPLY, CONFIG [SAVE]",
           "CONFIG=ccc, COPYANY, CREATE,",
           "CSD#, DEL nn, DSName, LEFT/RIGHT, REgions, SET cc ON/OFF,",
           "SIP=Y/N, SYSID=cccc, TASK#, TEST ON/OFF, TRACE, TRIGGER,",
           "LOCK, UNLOCK and" chgmanc"."

    panel  = 'CSGCHP'                       /* Primary display panel  */
    tbpand = 'CSGCHPDY'                     /* Table display          */
    test = ',TYPRUN=SCAN'                   /* SCAN on (comma)        */
    test = ' TYPRUN=SCAN'                   /* SCAN off (no comma)    */
/*  subit  = 'Y'  */                        /* Permit direct submit   */

    Parse VAR parm# parm1 .

    vars='CHGNO,CHGACCT,CHGJOBC,CHGGENR,CHGENVT,CHGMSGC,CHGDATE',
         'CHGXMST,CHGXMOR,CHGSTCN,CHGREGS,CHGJREG'
    "VGET ("vars") PROFILE"
    If rc/=0 Then Do
        If chgregs='CHGREGS' Then chgregs=
        If chggenr='' Then chggenr='0'
        If chgstcn='' Then chgstcn='stcname'
    End
    If Index(parm#,'CONFIG=')>0 Then Do
        Parse VAR parm# 'CONFIG=' #config .;#config_parm=1
    End
    Else Do;#config='CSGCH$';#config_parm=0;End
    Interpret "Parse Value '"#config"(siteenvt)' With xxx ',' ."
    If chgenvt='' Then Do
        chgenvt=xxx
        "VPUT (chgenvt) PROFILE"
    End
    If Datatype(chgdate)/='NUM' Then,
        chgdate=$DATEMAN('REV',Date('e'),2,'S')

    If Index(parm#,'SYSID=') > 0 Then Parse VAR parm# 'SYSID=' sid .
    Else sid=Strip(storage(d2x(x2d(c2x(storage(10,4)))+x2d(154)),8))

    If Wordpos('*',parm#)>0 Then Do
        v1='chgjclw chghlqA'
        Interpret "v2="#config"(v1)"
        Interpret "Parse var v2" v1
        Parse VAR chgjclw '.' rlq;dsl=chghlqa'.'rlq
        "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
        Exit
    End
    #envt=chgenvt                           /* Environment type D or P*/
    #chgstcn=chgstcn                        /* Backup stc name        */

    x=set_vars_0()
    zedlmsg=
    x=set_vars_1();
    If x/=0 Then Do;Address TSO "FREE F("helpdd")";Exit;End

/*--------------------------------------------------------------------*/
/*  JCL name is derived from the Monday of start of week or may be    */
/*  backdated by passing a '-n' 1st. parameter.                       */
/*  Parameter of 'CREATE' is required to delete/redefine the JCL.     */
/*  The first time through, if the JCL dataset does not exist, the    */
/*  routine to delete obsolete versions is processed. The flay is set */
/*  to eliminate deletion in case of 'CREATE'd recursion.             */
/*--------------------------------------------------------------------*/
Test_4_create:
    xx=Listdsi("'"chgjcl"' NORECALL")
Test_4_create_bp1:
    If xx<5 | sysreason=9 | sysreason=25 Then Do
        If Sysreason=9 | sysreason=25 Then xx='MIGRATED - ';Else xx=
        If zedlmsg/='' Then xx=zedlmsg xx
        zedlmsg=xx ||,
              "Dataset '"chgjcl"' already exists."
        If Sysdsn("'"chgjcl"($$$LOCKD)'")='OK' Then zedlmsg=zedlmsg,
           'and is "locked".'
/*      Else zedlmsg=zedlmsg"'"                                       */
/*            "Dataset '"chgjcl"' already exists. Enter ""CREATE""",  */
/*            "on the command line to force deletion/re-creation."    */
/*            "(GOTCHA - existing members will be overwritten.)"      */
    End
    Else Do
        zedlmsg="Note - Dataset '"chgjcl"' does not exist."
        If create_new=1 Then Do
            If frstime/='N' Then Do
                zcmd=;zwinttl='Change System'
                "ADDPOP ROW(6) COLUMN(30)";"DISPLAY PANEL(CSGCHPOP)"
                rc1=rc;"REMPOP"
                If rc1/=0 Then create_new=0
            End
            If create_new=1 Then Do
                Address TSO "ALLOC DA('"chgjcl"')",
                   "SPACE(30,15) DSORG(PO) DIR(30)",
                   "UNIT(SYSALLDA) RECFM(F B) LRECL(80) BLKSIZE(0)",
                   "TRACKS NEW CATALOG"
                Address TSO "FREE  DA('"chgjcl"')"
                If frstime/='N' Then Do
                    delr='+';@ver='-'#ver;zcmd='.' autodel
                    Call del_old_datasets
                End
                zedlmsg="Dataset '"chgjcl"' created."
            End
        End
    End
    x=process_config('READ')
    create_new=0;frstime='N';"SETMSG MSG(ISRZ001)"
    If Length(regions)>159 Then zedlmsg=zedlmsg,
          "Use LEFT/RIGHT PF keys to access the full region list data."
    #tr=Trace('o')

/*--------------------------------------------------------------------*/
/*  Display screen for changed parameters.                            */
/*--------------------------------------------------------------------*/
    csr1='ZCMD';csrp1=
scr1:
    zcmd=;#regions=regions
scr1a:
    If Sysdsn("'"chgjcl"($$$LOCKD)'")='OK' Then Do
        locked=1;autoindx='N'
    End
    Else locked=0
    #gener=gener;itype1='INPUT'
    "DISPLAY PANEL(&PANEL) CURSOR(&CSR1) CSRPOS(&CSRP1)"
    If rc/=0 Then Do
        chggenr=gener;"VPUT ("vars") PROFILE"
        If table/='' Then "TBEND &TABLE"
        If helpused='Y' Then x=helpdrvr(helpdrvr '/CLOSE')
        If help$used='Y' Then x=helpdrvr(#config '/CLOSE')
        xx=MSG('Off')
        If helpaloc/='N' Then Do
            If helpaloc='' Then Address TSO "FREE F("helpdd")"
            Else If helpaloc/=helpdsn Then,
                 Address TSO "ALLOC F("helpdd") DSN('"helpaloc"') SHR REU"
        End
        Exit
    End

    csr1='ZCMD';csrp1=;zedlmsg=;"VGET (zverb)"

    Parse VAR zcmd #zcmd1 #zcmd2 #zcmd3
    If #zcmd1='TRACE' Then Do
        Select
            When #zcmd2='OFF' Then #tr='O'
            When #zcmd2='ON' Then #tr='R'
            Otherwise If #tr='R' Then #tr='O';Else #tr='R'
            x=Trace(#tr)
        End
        Signal scr1
    End
    If chgacct='' Then Do
        Interpret "chgacct="#config"('chgacct')"
        zedlmsg='Account reset to default.'
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If #zcmd1='LOCK' Then Do
        Address TSO "NEWSTACK"
        Queue 'This member prevents this dataset from being edited through the',
              'change'
        Queue 'system and creation and submission of JCL.'
        Queue 'Either manually delete this member or issue the "UNLOCK"',
              'command to'
        Queue 'permit changes through the change system.'
        Queue ' '
        Queue Right(cname 'at' Substr(time(),1,5) 'on' Date('e'),71)
        Queue ''
        dd='LO'Time('s')
        Address TSO "ALLOC DD("dd") DA('"chgjcl"($$$LOCKD)') SHR REU"
        Address TSO "EXECIO * DISKW "dd" (FINIS"
        Address TSO "FREE F("dd")"
        x=process_config('WRITE')
        zedlmsg='Dataset locked and configuration saved.'
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If #zcmd1='UNLOCK' Then Do
        #msg=Msg('Off');Address TSO "DELETE '"chgjcl"($$$LOCKD)'";x=Msg(#msg)
        If rc=0 Then zedlmsg='Dataset unlocked.'
        Else zedlmsg='Unlock failed RC='rc'.'
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If #zcmd1='?' Then Do
        If #zcmd2/='' Then xx=#zcmd2;Else xx='/OPEN'
        x=helpdrvr(helpdrvr xx);helpused='Y';Signal scr1
    End

    If Length(chgno)>6 Then chgnot=Substr(chgno,(Length(chgno)-6+1))
    Else chgnot=chgno

    ch1=Substr(zcmd,1,1)
    If ch1='E' | ch1='V' | ch1='B' Then Do
        x=action_dataset(ch1,chgjcl);Signal scr1
    End
/*--------------------------------------------------------------------*/
/*  Display of datasets generated requested.                          */
/*--------------------------------------------------------------------*/
    If Substr(#zcmd1,1,3)='DSN' | zcmd='CONFIG' |,
       Substr(zcmd,1,4)='PARM' Then Do
        Call display_datasets;Signal scr1
    End
/*--------------------------------------------------------------------*/
/*  Scroll region street.                                             */
/*--------------------------------------------------------------------*/
    If zverb='LEFT' | zverb='RIGHT' Then Do
        Select
            When regionp='' Then err=1
            When Substr(regionp,Length(regionp),1)/='+' Then err=1
            Otherwise Do
                If panel='CSGCHP' Then panel='CSGCHPR';Else panel='CSGCHP'
                err=0
            End
        End
        If err Then zedlmsg='Region continuation indicator missing.',
                          'Region screen NOT toggled.'
        Else zedlmsg='Region screen has been toggled.'
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
/*--------------------------------------------------------------------*/
/*  If in extended region display, truncate regions if required and   */
/*  redisplay normal panel.                                           */
/*--------------------------------------------------------------------*/
    If panel='CSGCHPR' Then Do
        regionp=regions
        If Length(regions)>159 Then Do
            regionp=Translate(regionp,' ',',')
            regionp=Space($wordat(regionp,158,'L'),1,',')'+'
        End
        panel='CSGCHP'
        zedlmsg='Returning to original panel.'
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    Else Do
        If regionp/='' Then,
          If Substr(regionp,Length(regionp),1)/='+' Then regions=regionp
    End
    If regnveri='Y' & #regions/=regions Then Do
        xx=Validate_regions(regions)
        If xx>0 Then Do
            If Length(regions)>159 Then Do
                panel='CSGCHPR';csr1='REGIONS'
            End
            Else csr1='REGIONP'
            csrp1=xx
            zedlmsg="Region startup JCL not found in '"proc_o"'. Please" ,
                  "correct and try again."
            "SETMSG MSG(ISRZ001)";Signal scr1
        End
    End
    If regionp/='' Then,
        If Substr(regionp,Length(regionp),1)/='+' Then regions=regionp
    chgregs=regions
    If regionp='' Then Do
        x=get_cics_regions(chgjcl)
        If regionp/='' Then Do
            zedlmsg="Regions list built from executing regions."
            "SETMSG MSG(ISRZ001)"
            Signal scr1
        End
    End

    retscr1='N'
    If Index(','siteenvt',',','chgenvt',')=0 Then Do
        zedlmsg='Valid Environments are: 'siteenvt'.'
        "SETMSG MSG(ISRZ001)";csr1='chgenvt';Signal scr1
    End

    If #zcmd1='CONFIG' & #zcmd2='SAVE' Then Do
        x=process_config('WRITE')
        zedlmsg='Configuration saved.'
        "SETMSG MSG(ISRZ001)";Signal scr1
        Signal scr1
    End
    If Substr(zcmd,1,7)='CONFIG=' Then Do
        Parse VAR zcmd . 'CONFIG=' xx .
        x=ver_and_process_config(xx);"SETMSG MSG(ISRZ001)"
        If x=0 Then Call display_datasets
        Signal scr1
    End
    If Substr(zcmd,1,7)='APPEND=' Then Do
        Parse VAR zcmd . 'APPEND=' yy .
        If Wordpos(yy,'Y ON')>0 Then appndstc='Y';Else appndstc='N'
        If appndstc='Y' Then chgjcl=chgjcl'.'chgstcn
        zedlmsg="Appendix changed. "
        If Sysdsn("'"chgjcl"'")/='OK' Then zedlmsg=zedlmsg,
            "Note - dataset '"chgjcl"' does not exist. "
        "SETMSG MSG(ISRZ001)";Signal scr1
    End

    ##gener=
    If #chgdate/=chgdate Then Do            /* Date changed           */
        retscr1='Y'
        If chgdate='=' Then $DATEMAN('REV',Date('e'),2,'S')
        xx=Abs(Substr(#chgdate,1,2)-Substr(chgdate,1,2))
        If xx>1 Then Do
            zedlmsg="> 1 year difference with new date. If valid",
                  "re-execute '"xcmd"' with new date as parameter."
            "SETMSG MSG(ISRZ001)";csr1='CHGDATE';Signal scr1
        End
        parm1=Substr(chgdate,5,2)'/' ||,
              Substr(chgdate,3,2)'/' ||,
              Substr(chgdate,1,2)
        If gener='*' Then chggenr='*'
        @gener=gener;@envt=chgenvt
        x=set_vars_1()
        ##gener=gener                       /* Generation changed ?   */
        gener=@gener;envt=@chgenvt
        If x/=0 Then Do
            csr1='chgdate';Signal scr1
        End
        zedlmsg="Change week changed. "
        If Sysdsn("'"chgjcl"'")/='OK' Then zedlmsg=zedlmsg,
            "Note - dataset '"chgjcl"' does not exist. "
        "SETMSG MSG(ISRZ001)"
    End
    If #gener/=gener Then Do                /* Generation changed     */
        retscr1='Y';parm1=gener
        If Datatype(parm1)='NUM' | parm1='*' Then chggenr=parm1
        @envt=chgenvt;x=set_vars_1();envt=@chgenvt
        If x/=0 Then Do
            csr1='GENER';Signal scr1
        End
        zedlmsg="Generation changed. "
        If Sysdsn("'"chgjcl"'")/='OK' Then zedlmsg=zedlmsg,
            "Note - dataset '"chgjcl"' does not exist. "
        "SETMSG MSG(ISRZ001)"
    End
    Else If ##gener/='' Then gener=##gener
    If #envt/=chgenvt Then Do               /* Environment changed    */
        retscr1='Y';#envt=chgenvt
        x=set_vars_1();If x/=0 Then Signal scr1
        "VPUT (chgenvt) PROFILE";"VPUT (chgenvt) SHARED"
        zedlmsg=zedlmsg"Environment type changed to '"chgenvt"'."
        "SETMSG MSG(ISRZ001)"
    End
    If #chgstcn/=chgstcn Then Do            /* Started task changed   */
        retscr1='Y';#chgstcn=chgstcn
        x=set_vars_1();If x/=0 Then Signal scr1
        "VPUT (chgstcn) PROFILE"
        zedlmsg=zedlmsg"Started task name changed to '"chgstcn"'."
        "SETMSG MSG(ISRZ001)"
    End

    If zcmd='CREATE' Then Do                    /* def dataset        */
        create_new=1
        If Sysdsn("'"chgjcl"'")='OK' Then Do
            zedlmsg="You are about to irreversably delete version",
                  "'"gener"'. Confirm by pressing [ENTER] or"           ,
                  "END PF key to cancel."
            itype1='OUTPUT'
            "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(ZCMD)"
            If rc/=0 Then Do
                zedlmsg="Delete of old generations abandoned."
                "SETMSG MSG(ISRZ001)";Signal scr1
            End
        End
        xmsg=Msg('Off')
        Address TSO "DELETE '"chgjcl"'"
        xmsg=Msg(xmsg)
        Signal Test_4_create
    End
    If Substr(zcmd,1,3)='DEL' Then Do       /* Delete obsolete gens   */
        @ver=#zcmd2
        If @ver='' Then Do
            zedlmsg="You must supply a valid DELETE parametre of -n,0 or +n."
            "SETMSG MSG(ISRZ001)";Signal scr1
        End
        delr=Substr(@ver,Length(@ver),1)
        If delr='+' Then Do
            @ver=Substr(@ver,1,Length(@ver)-1);xtra=' and before'
        End
        Else Do;xtra=;delr=;End
        If Datatype(@ver)='NUM' Then Do
            If @ver/=0 Then Do
                If Substr(@ver,1,1)='+' | Substr(@ver,1,1)='-' Then Nop
                Else Do
                    zedlmsg="You need a '-/+' sign indicator to qualify" ,
                          "a non zero generation.'"
                    "SETMSG MSG(ISRZ001)";Signal scr1a
                End
            End
            zedlmsg="You are about to irreversably delete version",
                  "'"@ver"'" || xtra". Confirm by pressing [ENTER] or"  ,
                  "END PF key to cancel."
            itype1='OUTPUT'
            "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(ZCMD)"
            If rc/=0 Then Do
                zedlmsg="Delete of old generations abandoned."
                "SETMSG MSG(ISRZ001)";Signal scr1
            End
        End
        Else Do
            zedlmsg="You need a valid generation parameter for the",
                  "DELete command.'"
            "SETMSG MSG(ISRZ001)";Signal scr1a
        End
        Call del_old_datasets
        Signal scr1
    End

    If #zcmd1='SET' Then Do                 /* Mass change gen parms  */
        If Substr(#zcmd2,1,3)='DEF' Then Do
            acty='J';actn=;Call set_vars_2;Signal scr1
        End
        If Substr(#zcmd2,1,2)=Substr('AUDIT',1,2) Then Do
            oper='MISS';Call set_JCL_gen_requests
            oper='FLIP';acty='A';Call set_JCL_gen_requests
            zedlmsg="The fields colored" cola "have JCL."
            "SETMSG MSG(ISRZ001)";Signal scr1
        End
        If Substr(#zcmd2,1,2)=Substr('FLIP',1,2) Then Do
            oper='FLIP';acty='J';Call set_JCL_gen_requests
            zedlmsg="The fields have been Flipped."
            "SETMSG MSG(ISRZ001)";Signal scr1
        End
        If #zcmd3='OFF' Then act=;Else act='J'
        oper=#zcmd2
        If #zcmd3='SUB' Then Do
            If oper='IM' | oper='BO' Then Do
                zedlmsg="Cannot mass 'SUB' implement or backup jobs."
                "SETMSG MSG(ISRZ001)";Signal scr1
            End
            act='S'
        End
        Call set_JCL_gen_requests;Signal scr1
    End
    If Substr(#zcmd1,1,2)='RE' Then Do
        x=get_cics_regions()
        zedlmsg="Regions list built from executing regions."
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If Substr(zcmd,1,6)='SYSID=' Then Do
        Parse VAR zcmd . 'SYSID=' sid .
        x=set_vars_1();If x/=0 Then Signal scr1
        zedlmsg="SYSID changed to '"sid"'."
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If Substr(zcmd,1,4)='SIP=' Then Do
        Parse VAR zcmd . 'SIP=' xx .
        If xx/='?' Then csdsip=xx
        zedlmsg='SIP overide set to "'csdsip'".'
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If #zcmd1='TASK#' Then Do
        m_list=;task#=;task#_l=
        x=member_list_select(chgjcl,'CONCAT')
        Do While m_list/=''
            Parse VAR m_list memb m_list
            If Substr(memb,1,1)/='I' Then Iterate
            If Substr(memb,1,2)='I#' Then Iterate
            xx=Substr(memb,3)
            If Index(task#_l,','xx)=0 Then task#_l=task#_l','xx
            If #zcmd2/='HIGH' Then Do;task#=xx;Leave;End
            If xx>task# Then task#=xx
        End
        If task#/='' Then Do
            chgno=task#
            zedlmsg="Task # '"task#"' interpreted from",
                  Substr(task#_l,2) "task(s) found."
        End
        Else zedlmsg="No task # interpreted."
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If #zcmd1='CSD#' Then Do
        m_list=;csd#=;csd#_l=
        x=member_list_select(chgjcl,'CONCAT')
        Do While m_list/=''
            Parse VAR m_list memb m_list
            If Substr(memb,1,2)/='$C' Then Iterate
            Parse VAR memb '@' xx
            If Index(csd#_l,','xx)=0 Then csd#_l=csd#_l','xx
            If #zcmd2/='HIGH' Then Do;csd#=xx;Leave;End
            If xx>csd# Then csd#=xx
        End
        If csd#/='' Then Do
            Interpret "chgstcn="#config"('CSD' csd# 'X')"
            zedlmsg="CSD '"chgstcn"' interpreted from",
                  '"'Substr(csd#_l,2)'" CSD suffixed jobs found.'
        End
        Else zedlmsg="No CSD interpreted."
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
    If #zcmd1='ALTER' Then Do
        altr_#=#zcmd2
        If Datatype(altr_#,'W') Then Do
            Parse VAR chgdate yy +2 mm +2 dd
            If Length(altr_#)>2 Then Do
                Parse VAR altr_# y1 +2 m1 +2 d1
                If m1='' Then m1=mm;If d1='' Then d1=dd
                newdate=y1||m1||d1
            End
            Else newdate=,
               $DATEMAN('REV',$DATEMAN('E-N',dd'/'mm'/'yy,7*altr_#,2),2,'S')
            Call build_ALTER_jcl
            Call build_index
            zedlmsg="Member $ALTER created. Peruse and submit manually."
            errlm=
        End
        Else zedlmsg="Invalid ALTER parameter. Must be numeric."
        "SETMSG MSG(ISRZ001)"
        x=action_dataset('E',chgjcl'($ALTER)');Signal scr1
    End
    If #zcmd1='$$$INDEX' Then Do
        autoindx='Y';Call build_index
        zedlmsg='Index auto build active for session. Exit and',
                're-enter to turn it off.'
        "SETMSG MSG(ISRZ001)"
        x=action_dataset('E',chgjcl'($$$INDEX)');Signal scr1
    End
    If zcmd='*' Then Do
        dsl=chgjclw
        "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
        Signal scr1
    End
    If zcmd=chgmanc Then Do
        Address TSO "ISPEXEC VPUT (chgmanc,chgmano,chgnot) SHARED"
        Address TSO "%CSGCHSLV" chgjcl CSDbreq
        Signal scr1
    End
    If zcmd='TRIGGER' Then Do
        Address TSO "%CSGCHTRG" chgjcl chgenvt sid
        Signal scr1
    End
/*--------------------------------------------------------------------*/
/*  Turn TEST mode on/off. In testmode jobcard has TYPRUN=SCAN.       */
/*--------------------------------------------------------------------*/
    If #zcmd1='TEST' Then Do
        If #zcmd2='OFF' Then Do
            test=' TYPRUN=SCAN';tmode='"OFF"'
        End
        Else Do
            test=',TYPRUN=SCAN';tmode='"ON"'
        End
        zedlmsg="Test mode set" tmode"."
        "SETMSG MSG(ISRZ001)";Signal scr1
    End
/*--------------------------------------------------------------------*/
/*  Only permit copy of CICS members in joblib or proclib. Normally   */
/*  only permit members matching variable "regnmask".                 */
/*--------------------------------------------------------------------*/
    If zcmd='COPYANY' Then Do
        copyany='Y'
        zedlmsg='Copy permited for all datasets/members.',
        "SETMSG MSG(ISRZ001)";Signal scr1
    End

    If zcmd/='' Then Do
        zedlmsg='Invalid command "'zcmd'"' valcmd'.';zcmd=
        "SETMSG MSG(ISRZ001)";Signal scr1a
    End

/*--------------------------------------------------------------------*/
/*  End of command processing.                                        */
/*--------------------------------------------------------------------*/
    Interpret "csdr#="#config"('CSD' chgstcn 'T')"
    If csdr#=8 Then Do
        zedlmsg="Invalid CSD qualifier entered. Please correct and re-execute."
        "SETMSG MSG(ISRZ001)";csr1='CHGSTCN'
        Signal scr1a
    End

    Call process_HK_flags
    If retscr1='Y' Then Signal scr1
    If Sysdsn("'"chgjcl"'")/='OK' Then Do
        zedlmsg="'"chgjcl"' was not found in catalog."
        "SETMSG MSG(ISRZ001)";Signal scr1a
    End

    If locked Then Signal show_result_and_return

/*--------------------------------------------------------------------*/
/*  Here we go with the CSD processing.                               */
/*--------------------------------------------------------------------*/
process_CSD:
    member='$CSD';bo_csdsip='N'
    If csdbu csdst csdim csdbo csdup csdoc/='' Then Do
        xx=Listdsi("'"csd_o"' NORECALL")
        If xx<5 | sysreason=9 | sysreason=25 Then NOP
        Else Do
            zedlmsg="Dataset '"csd_o"' does not exist.",
                  'If the job is submitted',
                  'without updating with a valid OLD CSD name it will',
                  'either JCL or give an unacceptable RC.',
                  'Press [ENTER] to continue processing or',
                  'END PF key to process next non-CSD selection.'
            "SETMSG MSG(ISRZ001)"
            csr2='ZCMD'
            xxx='csdbu csdst csdim csdbo csdup csdoc'
            Do While xxx/=''
                Parse VAR xxx xx xxx
                Interpret 'If' xx'/="" Then Do;csr2="'xx'";xxx="";End'
            End
            itype1='INPUT'
            "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
            If rc/=0 Then Do
                Parse Value '' With csdbu csdst csdim csdbo csdup csdoc
                Signal process_Rest
            End
        End
    End
    If csdsip='N' Then Do
        csdst=csdbu
        #csd_s=csd_s;#csd_u=csd_u;#csd_o=csd_o
        csd_s=csd_u
        Call build_csd_backup
        csd_s=csd_o
        csdup=csdim
        Call build_csd_update
/*      Call build_csd_implement                                      */
        Call build_csd_opercmd
        bo_csdsip='Y'
        Call build_csd_backout
        csd_s=#csd_s
        bo_csdsip='N'
        csdst=;csdbu=
        Signal process_Rest
    End
    Call build_csd_backup
    Call build_csd_update
    Call build_csd_implement
    Call build_csd_opercmd
    Call build_csd_backout

/*--------------------------------------------------------------------*/
/*  The rest (excluding region specific load libraries).              */
/*--------------------------------------------------------------------*/
process_Rest:
    string=jcltyp
    Do While string/=''
        Parse VAR string type string
        member='$'type
        Call build_PDS
    End

/*--------------------------------------------------------------------*/
/*  Region specific load libraries.                                   */
/*--------------------------------------------------------------------*/
process_Load:
    Parse VAR regions regn .
    reg#=;type='LOAD'
    #tr=Trace('o')
    Do While regn/=''
        Parse VAR regn reg ',' regn
        Interpret "reg#="#config"('REGION' reg 'T')"
        If reg#='' Then Iterate
        If reg#=8 Then Do
            zedlmsg="Invalid region '"reg"' entered. Please correct",
                  "and re-execute."
            "SETMSG MSG(ISRZ001)"
            Leave
        End
        member='$L'reg#
        Call build_PDS
    End
    x=Trace(#tr)
    If reg#=8 Then Signal scr1

/*--------------------------------------------------------------------*/
/*  Control-M jobs.                                                   */
/*--------------------------------------------------------------------*/
    If chgno/='' Then Do
        member='$CTRLM'
        Call build_controlM_process
        Call build_controlM_implement
        Call build_controlM_backout
    End
    If chgmana/='N' & \locked Then,
        Address TSO "%CSGCHSLV" chgjcl CSDbreq chgmano chgmanc 'EXIT'
    Call build_index
show_result_and_return:
    x=action_dataset('E',chgjcl)
    act=;oper='ALL';Call set_JCL_gen_requests
    Signal scr1

/*--------------------------------------------------------------------*/
/*  Edit dataset.                                                     */
/*    Parameters:                                                     */
/*      1. Action.                                                    */
/*      2. Dataset.                                                   */
/*      3. Macro invocation value.                                    */
/*--------------------------------------------------------------------*/
action_dataset: Arg e_a,e_f,e_m
    Select
        When e_a='E' Then e_a='EDIT'
        When e_a='V' Then e_a='VIEW'
        Otherwise e_a='BROWSE'
    End
    If e_a='EDIT' & locked Then Do
        e_a='VIEW'
        zedlmsg='Dataset locked. VIEW substituted for EDIT.'
        "SETMSG MSG(ISRZ001)"
    End
    If e_m='' Then e_a "DATASET('"e_f"')"
    Else Do
        csgchmac=e_m;"VPUT (csgchmac) SHARED"
        e_a "DATASET('"e_f"') MACRO("xcmd")"
    End
    If rc>4 Then "SETMSG MSG(&ZERRMSG)"
    Return 0

/*--------------------------------------------------------------------*/
/*  Self executed macro (used to insert notelines for user).          */
/*--------------------------------------------------------------------*/
Macro_1:
    Call greet_me;Call put_message
    Call build_message_1;Call put_message
    Call confucius;Call put_message
    x=nl_h('*'Copies('-',70)'*')
    "ISREDIT MEND"
    Exit

Macro_2:
    "VGET (chghlqC) SHARED"
    Call greet_me;Call put_message
    Call build_message_2;Call put_message
    Call confucius;Call put_message
    x=nl_h('*'Copies('-',70)'*')
    "ISREDIT MEND"
    Exit

Macro_3:
    Call greet_me;Call put_message
    Call build_message_3;Call put_message
    Call confucius;Call put_message
    x=nl_h('*'Copies('-',70)'*')
    "ISREDIT MEND"
    Exit

/*--------------------------------------------------------------------*/
/*  Self extracting NOTELINE processor.                               */
/*--------------------------------------------------------------------*/
build_message_1:
n_st=mark(2)                                /* Mark next line         */
/*
   JCL generated to compare datasets in batch. Submit job now or do
   it at your own leisure later on.

*/
n_en=mark(-2);Return 0                      /* Mark prev 2 line       */

/*--------------------------------------------------------------------*/
build_message_2:
n_st=mark(2)                                /* Mark next line         */
/*
   The clone and CSD update jobs have been tailored for output to
   '&CHGHLQC..&USERID..*' for a trial run. Submit at your leisure.

*/
n_en=mark(-2);Return 0                      /* Mark prev 2 line       */

/*--------------------------------------------------------------------*/
build_message_3:
n_st=mark(2)                                /* Mark next line         */
/*
   This JCL will generate extracts from both the changed and original
   CSD based on the lists and groups that are being changed in the
   update/implement job. Submit at your leisure.

*/
n_en=mark(-2);Return 0                      /* Mark prev 2 line       */

/*--------------------------------------------------------------------*/
/* Greeting message                                                   */
/*--------------------------------------------------------------------*/
greet_me:
    "ISREDIT RESET"
n_st=mark(2)                                /* Mark next line         */
/*

   Hello &CNAME..

*/
n_en=mark(-2);Return 0                      /* Mark prev 2 line       */

/*--------------------------------------------------------------------*/
/* Sign-off message                                                   */
/*--------------------------------------------------------------------*/
confucius:
n_st=mark(2)                                /* Mark next line         */
/*
                            -****-

   Remember, a wise man will always check his JCL before submitting
   the job.
   -Confucius

*/
n_en=mark(-2);Return 0                      /* Mark prev 2 line       */

/*--------------------------------------------------------------------*/
/*  Process self-extracted data. Tries to identify user using routine */
/*  '$WHOAMI'. If routine not available will just say 'Hello there..' */
/*--------------------------------------------------------------------*/
put_message:
    chgchar='&'

    "ISREDIT (caps)=CAPS";"ISREDIT CAPS = OFF"
    Do i=n_st To n_en
        line=Sourceline(i)
        Do While Index(line,chgchar)>0
            Interpret "Parse VAR line p1 '"chgchar"' var '.' p2"
            Interpret 'line=p1||'var'||p2'
        End
        x=nl_h('*'Substr(line,1,70)'*')
    End
    "ISREDIT CAPS=(caps)"
    Return 0

qc:Parse Arg n#;Queue Substr(n#,1,70)'*';Return 0
nl_h:Parse Arg n#;"ISREDIT LINE_BEFORE .ZFIRST=NOTELINE (n#)";Return 0

Mark: Arg diff;If Datatype(diff)/='NUM' Then diff=1;Return sigl+diff
syntaxerr:Interpret syntaxact;Signal Value retlab

/*--------------------------------------------------------------------*/
/*  Backup the CSD. Actually clones the staging dataset as the rename */
/*  of the current dataset at implementation will become the backup/  */
/*  recovery CSD.                                                     */
/*--------------------------------------------------------------------*/
build_csd_backup:
    If csdst='' Then Return 0
    If bustexst='Y' Then Do
        x=Listdsi("'"csd_s"' NORECALL")
        If Sysreason/=5 Then Do
            zedlmsg='Dataset already exist. If the job is submitted,',
                  'you may delete work already done.  Press [ENTER]',
                  'to continue with the JCL generation/submission or',
                  'END PF key to process next selection.'
            "SETMSG MSG(ISRZ001)"
            If csdsip='Y' Then csr2='CSDST';Else csr2='CSDBU'
            itype1='INPUT'
            "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
            If rc/=0 Then Do
                If csdsip='Y' Then csdst=;Else csdbu=
                Return 0
            End
            If csdst='' Then Return 0
        End
    End
    act=csdst
    If csdsip='N' Then Do
        jid=Strip(Substr('$CU@'csdr#,1,8))
        x=Build_job_card('BU','CSD BACKUP')
    End
    Else Do
        jid=Strip(Substr('$CU@'csdr#,1,8))
        x=Build_job_card('ST','CSD STAGING')
    End
csd_backup_JCL_Body:
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* This job will delete if exists, defines and populates the')
    x=qc('//* CSD dataset.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//*'
    Queue '//DELFILES EXEC PGM=IDCAMS'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue '     DELETE ('csd_s') -'
    Queue '           PURGE NOERASE CLUSTER'
    Queue ' '
    Queue '     IF MAXCC < 9 THEN SET MAXCC = 0'
    Queue ' '
    Queue '//DEFVSAM  EXEC PGM=IDCAMS'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue '     DEFINE  CLUSTER( -'
    Queue '             NAME('csd_s') -'
    Queue '             MODEL('csd_o') -'
    Queue '                )'
    Queue '/*'
    Queue '//*'
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//*   This step will repro the current CSD into the staging CSD.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//*'
    Queue '//REPVSAM EXEC PGM=IDCAMS,REGION=5120K'
    Queue '//INPUT    DD DISP=SHR,DSN='csd_o','
    Queue "//            AMP=('BUFNI=30','BUFND=90')"
    Queue '//OUTPUT   DD DISP=OLD,DSN='csd_s','
    Queue "//            AMP=('BUFNI=30','BUFND=90')"
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSUDUMP DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue ' REPRO INFILE(INPUT) OUTFILE(OUTPUT) REPLACE'
    Queue '/*'
    If Arg(1)='INC-BU' Then Do;Queue '//*';Return 0;End
    Queue '//'
    Queue ''
    If csdsip='N' Then x=output_jcl('BU');Else x=output_jcl('ST')
    csdst=;csdbu=

    Return 0

/*--------------------------------------------------------------------*/
/*  Build a CSD update template. This will need to be customised  for */
/*  appropriate update.                                               */
/*--------------------------------------------------------------------*/
build_csd_update:
    If csdup='' Then Return 0
    If csdsip='N' Then xx='I';Else xx='P'
    If Sysdsn("'"chgjcl"("xx"C"chgnot")'")='OK' Then Do
        zedlmsg='Member to process the CSD already exists,',
                'you may delete work already done.  Press [ENTER]',
                'to continue with the JCL generation or',
                'END PF key to process next selection.'
        "SETMSG MSG(ISRZ001)"
        If csdsip='Y' Then csr2='CSDUP';Else csr2='CSDIM'
        itype1='INPUT'
        "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
        If rc/=0 Then Do
            Interpret csr2"=''"
            Return 0
        End
        Interpret "If "csr2"='' Then Return 0"
    End
    act=csdup
    If csdsip='N' Then x=Build_job_card('IM','CSD IMPLEMENT')
    Else               x=Build_job_card('UP','CSD UPDATE')
    csd4use='UPDATE'
    If excsdupd/='N' Then Signal build_csd_update_for_backout
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Use this as a template for generation the CSD housekeeping jobs.')
    x=qc('//* Delete lines not appropriate for your operation.')
    x=qc('//*')
    x=qc('//* Use program CSGCSDX  to generate define statements from existing')
    x=qc('//* definitions.')
    x=qc('//*')
build_csd_update_for_backout:
    If excsdupd/='N' Then Do
        Interpret 'x='excsdupd ||,
          '(csd_s,csd_u,chgjcl,cicstl1,cicstl2,csd4use,bo_csdsip)'
        If x=0 Then Signal build_csd_update_JCL_out
    End
    y_y=csd_s;If csd_s=csd_# Then csd_s=csd_u
    x=csd_backup_JCL_Body('INC-BU')
    csd_s=y_y
    If batchsin/='N' Then Do
        Queue '//*'Copies('-',67)'*'
        x=qc('//*')
        x=qc('//* This step will generate a temporary file containing the CSD')
        x=qc('//* dataset name for inclusion into the SYSIN data to readily')
        x=qc('//* identify the dataset in the output listing.')
        x=qc('//*')
        Queue '//*'Copies('-',67)'*'
        Queue '//         EXEC PGM='batchsin','
        Queue "// PARM="Substr("'* CSD file: ''"csd_s"''.",1,61)"*'"
        Queue '//STEPLIB  DD DISP=SHR,DSN='batchdsn
        Queue '//SYSOUT   DD DISP=(NEW,PASS),DSN=&&SYSGCD1,'
        Queue '//    UNIT=SYSDA,SPACE=(TRK,(1,1)),'
        Queue '//    DCB=(LRECL=80,BLKSIZE=0,RECFM=FB)'
        If csdsip='N' Then Do
            Queue '//*'
            Queue '//ENQDD    DD DISP=(MOD,CATLG),DSN='chgjcl'.ENQ,'
            Queue '//            SPACE=(0,(0,0)),UNIT=SYSALLDA'
        End
        Queue '//*'
    End
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* CSD process/update')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue "//UPDATE   EXEC PGM=DFHCSDUP,PARM='CSD(READWRITE)'"
    Queue '//STEPLIB  DD DISP=SHR,DSN='cicstl1
    Queue '//         DD DISP=SHR,DSN='cicstl2
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//DFHCSD   DD DISP=SHR,DSN='csd_s','
    Queue "//            AMP=('BUFNI=30','BUFND=90')"
    If bo_csdsip/='Y' Then Do
        Queue '//*FRMCSD   DD DISP=SHR,DSN='csd_u','
        Queue "//*            AMP=('BUFNI=30','BUFND=90')"
        Queue '//*'
        Queue '//*CBDOUT   DD DISP=SHR,DSN='chgjcl'(extract)'
        Queue '//*'
    End
    Else,
        Queue '//FRMCSD   DD DISP=SHR,DSN='csd_u','
    If csdsip='N' Then Do
        Queue '//*'
        Queue '//ENQDD    DD DISP=(MOD,CATLG),DSN='chgjcl'.ENQ,'
        Queue '//            SPACE=(0,(0,0)),UNIT=SYSALLDA'
        Queue '//*'
    End
    Queue '//SYSIN    DD *'
    If batchsin/='N' Then Do
        Queue Copies('*',59)
        Queue '//         DD DISP=(OLD,DELETE),DSN=&&SYSGCD1'
        Queue '//         DD *'
        Queue Copies('*',59)
    End
    If bo_csdsip='Y' Then,
        Queue 'DEL GROUP(        )'
    Queue '//*        DD DISP=SHR,DSN='chgjcl'(CSD_data)'
    Queue '//         DD *'
    If bo_csdsip='Y' Then,
        Queue 'COPY GROUP(        ) TO(        ) FROM(FRMCSD) REPLACE'
    Queue 'LIST'
    Queue '/*'
    If csdsip='N' Then x=build_wto('IM','UPDATE','0')
    Else               x=build_wto('UP','UPDATE','0')
    Queue '//'
    Queue ' '
    Queue 'Boys and Girls,'
    Queue 'If you wish to run diagnostics and install using console commands,'
    Queue 'please use the appropriate formats (keyword sequences) from below:'
    Queue ' '
    Queue 'LIST ALL OBJECTS'
    Queue 'COPY GROUP(        ) TO(        ) FROM(FRMCSD) REPLACE'
    Queue 'ADD  GROUP(        ) LIST(        )'
    Queue 'REM  GROUP(        ) LIST(        )'
    Queue 'APP  LIST(        )  TO(        )'
    Queue 'ALTER  FILE(        ) GROUP(        )'
    Queue 'DEFINE FILE(        ) GROUP(        )'
    Queue 'EXTRACT GROUP(        ) USERPROGRAM(CSGCSDX)  OBJECTS'
build_csd_update_JCL_out:
    If bo_csdsip='Y' Then Return 0
    Queue ''
    If csdsip='N' Then Do;csdim=;x=output_jcl('IM');End
    Else x=output_jcl('UP')
    csdup=

    Return 0

/*--------------------------------------------------------------------*/
/*  Build the CSD implementation job which will rename all the        */
/*  components.                                                       */
/*--------------------------------------------------------------------*/
build_csd_implement:
    If csdim='' Then Return 0
    act=csdim
    x=Build_job_card('IM','CSD IMPLEMENT')
    If csd_u_d= 'Missing_component' | csd_s_d = 'Missing_component' Then
        Signal long_data_index_names
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* This job will implement the CSD by:')
    x=qc('//*    Renaming all current components to backup names.')
    x=qc('//*    Renaming all staging components to current names.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//*'
    Queue '//RENAME   EXEC PGM=IDCAMS'
    Queue '//SYSPRINT DD SYSOUT=*'
    If csdsip='N' Then Do
        Queue '//*'
        Queue '//ENQDD    DD DISP=(MOD,DELETE),DSN='chgjcl'.ENQ,'
        Queue '//            SPACE=(0,(0,0)),UNIT=SYSALLDA'
        Queue '//*'
    End
    Queue '//SYSIN    DD *'
    Queue '     ALTER   ' csd_o '-'
    Queue '     NEWNAME(' csd_u ')'
    Queue ' '
    Queue '     ALTER   ' csd_o_i '-'
    Queue '     NEWNAME(' csd_u_i ')'
    Queue ' '
    Queue '     ALTER   ' csd_o_d '-'
    Queue '     NEWNAME(' csd_u_d ')'
    Queue ' '
    Queue '     ALTER   ' csd_s '-'
    Queue '     NEWNAME(' csd_o ')'
    Queue ' '
    Queue '     ALTER   ' csd_s_i '-'
    Queue '     NEWNAME(' csd_o_i ')'
    Queue ' '
    Queue '     ALTER   ' csd_s_d '-'
    Queue '     NEWNAME(' csd_o_d ')'
    Queue '/*'
    Queue '//*'
    x=build_wto('IM','RENAME','0')
    Queue ''
    x=output_jcl('IM')
    csdim=

    Return 0

build_csd_opercmd:
    If csdoc='' Then Return 0
    If csdbreq='Y' & csdsip='N' Then Do
         zedlmsg='Cannot select operator command JCL with "Bounce CICS"',
               'set to "Y".'
         "SETMSG MSG(ISRZ001)";csr2='CSDOC';itype1='INPUT'
         "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
         Signal build_csd_opercmd
    End
OC_test_region:
    If regions='' Then Do
         zedlmsg='Cannot select operator command JCL without a region',
               'list to generate CEDA implement statements for.'
         "SETMSG MSG(ISRZ001)";csr2='REGIONP';itype1='INPUT'
         "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
         If rc/=0 Then Return 0
         regions=regionp
         Signal OC_test_region
    End
    If regnveri='Y' Then Do
        csrp2=Validate_regions(regionp)
        If csrp2>0 Then Do
             zedlmsg="Region startup JCL not found in '"proc_o"'. Please",
                   "correct and try again."
             "SETMSG MSG(ISRZ001)";csr2='REGIONP';itype1='INPUT'
             "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2) CSRPOS(&CSRP2)"
             If rc/=0 Then Return 0
             regions=regionp
             Signal OC_test_region
        End
    End
    x=get_csd_updates()
    If x/=0 Then Signal scr1
    x=Build_job_card('OCI','OPERCMD IMPLEMENT')
    cedaimp='$O'chgnot;CSDbreq='N'
    If excsdopc/='N' Then Do
        Interpret 'x='excsdopc ||,
          '('IM',chgjcl,cedaimp,regions,group1)'
        If x=0 Then Signal build_csd_opercmd_IM_JCL_out
    End
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* This job will use an operator command to install the CSD')
    x=qc('//* changes.')
    x=qc('//* Delete any inapplicable regions.')
    x=qc('//*')
    x=qc('//* Note - This job should follow "IC'chgnot'".')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//OPERCMDI EXEC PGM='conscmd
    If Translate(conslib)/='LINKLIST' & Sysdsn("'"conslib"'")='OK' Then
        Queue '//STEPLIB  DD DISP=SHR,DSN='conslib
    Queue '//*'
    If csdsip='N' Then Do
        Queue '//*'
        Queue '//ENQDD    DD DISP=(MOD,DELETE),DSN='chgjcl'.ENQ,'
        Queue '//            SPACE=(0,(0,0)),UNIT=SYSALLDA'
    End
    Queue '//*'
    Queue '//SYSIN    DD *'
    Queue '//         DD DISP=SHR,DSN='chgjcl'('cedaimp')'
    Queue '//         DD *'
    Queue '/*'
build_csd_opercmd_IM_JCL_out:
    x=build_wto('OCI','OPERCMDI','0')
    Queue ''
    x=output_jcl('OCI')

    x=Build_job_card('OCB','OPERCMD BACKOUT')
    If excsdopc/='N' Then Do
        Interpret 'x='excsdopc ||,
          '('BO',chgjcl,cedaimp,regions,group1)'
        If x=0 Then Signal build_csd_opercmd_BO_JCL_out
    End
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* This job will use an operator command to backout the CSD')
    x=qc('//* changes.')
    x=qc('//* Delete any inapplicable regions.')
    x=qc('//*')
    x=qc('//* Note - This job should follow "OC'chgnot'".')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//OPERCMDO EXEC PGM='conscmd
    If Translate(conslib)/='LINKLIST' & Sysdsn("'"conslib"'")='OK' Then
        Queue '//STEPLIB  DD DISP=SHR,DSN='conslib
    Queue '//*'
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Place any discard commands between the SYSIN DDs below in')
    x=qc('//* the format of')
    x=qc('//*   "F regnname,CEMT DISCARD opt(..)"')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    If csdsip='N' Then Do
        Queue '//*'
        Queue '//ENQDD    DD DISP=(MOD,DELETE),DSN='chgjcl'.ENQ,'
        Queue '//            SPACE=(0,(0,0)),UNIT=SYSALLDA'
    End
    Queue '//*'
    Queue '//SYSIN    DD *'
    Queue '//         DD DISP=SHR,DSN='chgjcl'('cedaimp')'
    Queue '//         DD *'
    Queue '/*'
    x=build_wto('OCB','OPERCMDO','0')
build_csd_opercmd_BO_JCL_out:
    Queue ''
    x=output_jcl('OCB')
    csdoc='N'
    Address TSO "NEWSTACK"
    If excsdopc/='N' Then Do
        Interpret 'x='excsdopc ||,
          '('SI',chgjcl,cedaimp,regions,group1)'
        If x=0 Then Signal build_csd_opercmd_SI_JCL_out
    End
    Parse VAR regions regn .
    Do While regn/=''
        Parse VAR regn reg ',' regn
        grp=group1
        If grp='' Then Queue ' F 'reg',CEDA I G(........)'
        Else Do While grp/=''
            Parse VAR grp gr ',' grp
            Queue ' F 'reg',CEDA I G('gr')'
        End
    End
build_csd_opercmd_SI_JCL_out:
    Queue ''
    @jid=jid;jid=cedaimp
    x=output_jcl()
    jid=@jid

    Return 0

/*--------------------------------------------------------------------*/
/*  Build the CSD backout job.                                        */
/*--------------------------------------------------------------------*/
build_csd_backout:
    If csdbo='' Then Return 0
    act=csdbo
    x=Build_job_card('BO','CSD BACKOUT')
    If csd_u_d='Missing_component' | csd_s_d='Missing_component' Then,
        Signal long_data_index_names
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* This job will backout the CSD changes by:')
    x=qc('//*    Renaming all current components to staging names.')
    x=qc('//*    Renaming all backup components to current names.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    If bo_csdsip='Y' Then Do
        x=qc('//*')
        x=qc('//* Note: A template has been added below for backouts')
        x=qc('//*       without a CICS bounce.')
        x=qc('//*')
        x=qc('//* Please delete the IDCAMS step..')
        x=qc('//*')
        Queue '//*'Copies('-',67)'*'
    End
    Queue '//*'
    Queue '//DELFILES EXEC PGM=IDCAMS'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue '     ALTER   ' csd_o '-'
    Queue '     NEWNAME(' csd_s ')'
    Queue ' '
    Queue '     ALTER   ' csd_o_i '-'
    Queue '     NEWNAME(' csd_s_i ')'
    Queue ' '
    Queue '     ALTER   ' csd_o_d '-'
    Queue '     NEWNAME(' csd_s_d ')'
    Queue ' '
    Queue '     ALTER   ' csd_u '-'
    Queue '     NEWNAME(' csd_o ')'
    Queue ' '
    Queue '     ALTER   ' csd_u_i '-'
    Queue '     NEWNAME(' csd_o_i ')'
    Queue ' '
    Queue '     ALTER   ' csd_u_d '-'
    Queue '     NEWNAME(' csd_o_d ')'
    Queue '/*'
    Queue '//'
    If csdsip='N' Then Do
        Queue ' '
        Queue ' '
        Queue '//*'Copies('-',67)'*'
        x=qc('//*')
        x=qc('//* This template is designed for backing out CSD changes')
        x=qc('//* without bouncing CICS.')
        x=qc('//* This step should be customised to delete any groups tha have')
        x=qc('//* been changed and copy them from the backup CSD.')
        x=qc('//* The backout console commands job should then be submitted')
        x=qc('//* to re-install the replaced groups.')
        x=qc('//*')
        x=qc('//* For 100% accuracy suggest console commands for discarding')
        x=qc('//* mebers be created and executed before this job:')
        x=qc('//*   "F regnname,CEMT DISCARD opt(..)"')
        x=qc('//*')
        Queue '//*'Copies('-',67)'*'
        csd4use='BACKOUT'
        x=build_csd_update_for_backout()
    End
    Queue ''
    x=output_jcl('BO')
    csdbo='N'

    Return 0

/*--------------------------------------------------------------------*/
/*  Build CSD compare job.                                            */
/*--------------------------------------------------------------------*/
build_csd_compare:
    If userhlq=userid Then hlq=userid'.CSD.EXTRACT'
    Else                   hlq=userhlq'.'userid'.CSD.EXTRACT'
    restart='EXTRACT1 EXTRACT2 CLONE1 CLONE2 ISPFBTCH'
    x=Build_job_card('*','CSD COMPARE',member,restart)
    If chgxmst/='' | chgxmor/='' Then Do
        If chgxmst='' Then chgxmst=chgxmor
        If chgxmor='' Then chgxmor=chgxmst
        v1='ispplib ispmlib ispslib isptlib';Interpret "v2="#config"(v1)"
        Interpret "Parse var v2" v1
    End
    x=build_csd_extract(csd_s,'STAGING',chgxmst,1)
    x=build_csd_extract(csd_o,'ORIGINAL',chgxmor,2)
    If chgxmst/='' | chgxmor/='' Then Do
        If chgxmst/='' Then,
            x=build_csd_ext_clone('STAGING',chgxmst,1)
        If chgxmor/='' Then,
            x=build_csd_ext_clone('ORIGINAL',chgxmor,2)
        x=build_csd_ext_macro_env()
        If chgxmst/='' Then,
            x=build_csd_ext_macro_cmd('STAGING',chgxmst)
        If chgxmor/='' Then,
            x=build_csd_ext_macro_cmd('ORIGINAL',chgxmor)
        Queue '/*'
        Queue '//*'
    End
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Run ISPF file compare utility in batch.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//SUPERC  EXEC PGM=ISRSUPC,'
    Queue "//   PARM=(DELTAL,LINECMP,'','')"
    If chgxmst='' Then Queue '//NEWDD  DD DISP=SHR,DSN='hlq'.STAGING'
    Else               Queue '//NEWDD  DD DISP=SHR,DSN='hlq'.STAG'
    If chgxmor='' Then Queue '//OLDDD  DD DISP=SHR,DSN='hlq'.ORIGINAL'
    Else               Queue '//OLDDD  DD DISP=SHR,DSN='hlq'.ORIG'
    Queue '//OUTDD  DD SYSOUT=(*)'
    Queue "//"
    Queue ''

    Return 0

build_csd_extract: Arg ifile,llq,macros,seq#
    cbdout=hlq'.'llq
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//*                   'llq 'extract.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Use this as a template for generating CSD extracts from both')
    x=qc('//* the current and backup CSDs.')
    x=qc('//*')
    x=qc('//* Last step will compare the two extracts.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    If batchsin/='N' Then Do
        Queue '//         EXEC PGM='batchsin','
        Queue "// PARM="Substr("'* CSD file: ''"ifile"''.",1,61)"*'"
        Queue '//STEPLIB  DD DISP=SHR,DSN='batchdsn
        Queue '//SYSOUT   DD DISP=(NEW,PASS),DSN=&&SYSGCD1,'
        Queue '//    UNIT=SYSDA,SPACE=(TRK,(1,1)),'
        Queue '//    DCB=(LRECL=80,BLKSIZE=0,RECFM=FB)'
        Queue '//         EXEC PGM='batchsin','
        Queue "// PARM="Substr("'* Into    : ''"cbdout"''.",1,61)"*'"
        Queue '//STEPLIB  DD DISP=SHR,DSN='batchdsn
        Queue '//SYSOUT   DD DISP=MOD,DSN=&&SYSGCD1'
        Queue '//*'
        Queue '//*'Copies('-',67)'*'
        x=qc('//*')
    End
    x=qc('//* CSD process/update')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//EXTRACT'seq#' EXEC PGM=IEFBR14'
    Queue '//CBDOUT   DD DSN='hlq'.'llq','
    Queue '//            DISP=(MOD,DELETE),UNIT=SYSALLDA,'
    Queue '//            SPACE=(TRK,(0,0))'
    Queue '//*'
    Queue "//         EXEC PGM=DFHCSDUP,PARM='CSD(READWRITE)'"
    Queue '//STEPLIB  DD DISP=SHR,DSN='cicstl1
    Queue '//         DD DISP=SHR,DSN='cicstl2
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//DFHCSD   DD DISP=SHR,DSN='ifile','
    Queue "//            AMP=('BUFNI=30','BUFND=90')"
    Queue '//*'
    Queue '//CBDOUT   DD DSN='cbdout','
    Queue '//            DISP=(MOD,CATLG),UNIT=SYSALLDA,'
    Queue '//            SPACE=(TRK,(50,50),RLSE)'
    Queue '//*'
    Queue '//SYSIN    DD *'
    If batchsin/='N' Then Do
        Queue Copies('*',59)
        Queue '//         DD DISP=(OLD,DELETE),DSN=&&SYSGCD1'
        Queue '//         DD *'
        Queue Copies('*',59)
    End
    xxx=list1
    Do While xxx/=''
        Parse VAR xxx yyy ',' xxx
        Queue 'EXTRACT L('yyy') USERPROGRAM('csdext')  OBJECTS'
    End
    xxx=group1
    Do While xxx/=''
        Parse VAR xxx yyy ',' xxx
        Queue 'EXTRACT G('yyy') USERPROGRAM('csdext')  OBJECTS'
    End
    Queue '/*'
    Queue '//*'
    Return 0

build_csd_ext_clone: Arg llq,macros,seq#
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//*                   'llq 'clone.')
    x=qc('//*')
    x=qc('//* This step will take a copy of the original extract')
    x=qc('//* to a truncated name.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//CLONE'seq#'   EXEC PGM=IEFBR14'
    Queue '//SYSUT2   DD DSN='hlq'.'Substr(llq,1,4)','
    Queue '//            DISP=(MOD,DELETE),UNIT=SYSALLDA,'
    Queue '//            SPACE=(TRK,(0,0))'
    Queue '//*'
    Queue '//         EXEC PGM=IEBGENER'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD DUMMY'
    Queue '//SYSUT1   DD DISP=SHR,DSN='hlq'.'llq
    Queue '//SYSUT2   DD DSN='hlq'.'Substr(llq,1,4)','
    Queue '//            DISP=(NEW,CATLG),UNIT=SYSALLDA,'
    Queue '//            SPACE=(TRK,(60,30),RLSE)'
    Queue '//*'
    Return 0

build_csd_ext_macro_env:
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* This step will hit the extract with an edit macro to')
    x=qc('//* rationalise file compares in a batch ISP environment.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//ISPFBTCH EXEC PGM=IKJEFT01,DYNAMNBR=65,REGION=4096K'
    Queue '//SYSPROC  DD DISP=SHR,DSN='sysexec
    Queue '//ISPPLIB  DD DISP=SHR,DSN='ispplib
    Queue '//ISPSLIB  DD DISP=SHR,DSN='ispslib
    Queue '//ISPMLIB  DD DISP=SHR,DSN='ispmlib
    Queue '//ISPTLIB  DD DISP=SHR,DSN='isptlib
    Queue '//ISPPROF  DD DSN=&&ISPPROF,SPACE=(TRK,(10,,10)),UNIT=SYSDA,'
    Queue '//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)'
    Queue '//SYSTSPRT DD SYSOUT=X'
    Queue '//SYSOUT   DD SYSOUT=*'
    Queue '//SYSTERM  DD SYSOUT=*'
    Queue '//SYSTSIN  DD *'
    Return 0

build_csd_ext_macro_cmd: Arg llq,macros
    Do While macros/=''
        Parse VAR macros mac ',' macros
        Queue ' ISPSTART CMD(%'mac  hlq'.'Substr(llq,1,4)')'
    End
    Return 0

/*--------------------------------------------------------------------*/
/*  Build the PDS jobs as required.                                   */
/*  This section will determine which job is to be generated and will */
/*  execute the appropriate section.                                  */
/*--------------------------------------------------------------------*/
build_PDS:
    If Substr(member,1,2)='$L' Then Do
        "VPUT (reg) SHARED"
        Interpret "fileo="#config"('load_r')"
        files=fileo'.ST'chgdate
        fileu=fileo'.BU'chgdate
        #type=type
        If loadbu='J' Then Do
            delr='+';@ver='-'#ver
            x=get_all_versions(fileo,'NONVSAM','.BU')
        End
        If loadst='J' Then Do
            delr='+';@ver='-'#ver
            x=get_all_versions(fileo,'NONVSAM','.ST')
        End
        If Queued()>0 Then Do
            If disaudit='Y' Then Do
                Queue ''
                "VGET ZTEMPF"
                dd='CH'Time('s')
                Address TSO "ALLOC F("dd") DA('"ztempf"') SHR REU"
                Address TSO "EXECIO * DISKW "dd" (FINIS"
                Address TSO "DELSTACK"
                zedlmsg='The following is a list of files eligible for',
                        'deletion.'
                "SETMSG MSG(ISRZ001)"
                "LMINIT DATAID(DATAID) DDNAME("dd")"
                "BROWSE DATAID(&DATAID)"
                "LMFREE DATAID(&DATAID)"
                Address TSO "FREE  F("dd")"
            End
            Else Address TSO "DELSTACK"
        End
        Interpret 'L'reg"BU=loadbu"
        Interpret 'L'reg"ST=loadst"
        Interpret 'L'reg"IM=loadim"
        Interpret 'L'reg"BO=loadbo"
        type=#type
    End
    Else Do
        Interpret "fileo="Substr(member,2)"_o"
        Interpret "files="Substr(member,2)"_s"
        Interpret "fileu="Substr(member,2)"_u"
    End
    Call build_PDS_backup
    Call build_PDS_stage
    Call build_iebcopy_implement
/*  Call build_iebcopy_delete                                         */
    Call build_iebcopy_backout
    Call build_PDS_batch_review_bu
    Call build_PDS_batch_review_st

    Return 0

/*--------------------------------------------------------------------*/
/*  PDS backup using DFDSS to do a COPY rename.                       */
/*--------------------------------------------------------------------*/
build_PDS_backup:
    Interpret "If "type"BU='' Then Return"
    If bustexst='Y' Then Do
        x=Listdsi("'"fileu"' NORECALL")
        If Sysreason/=5 Then Do
            zedlmsg='Dataset already exist. If the job is submitted,',
                  'you may delete work already done.  Press [ENTER]',
                  'to continue with the JCL generation/submission or',
                  'END PF key to process next selection.'

            "SETMSG MSG(ISRZ001)"
            csr2=type'BU';itype1='INPUT'
            "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
            If rc/=0 Then Do
                Interpret type"BU="
                Return 0
            End
            Interpret "If "type"BU='' Then Return"
        End
    End
    x=Listdsi("'"fileo"' NORECALL SMSINFO")
    If Sysreason=5 Then Do
        zedlmsg="Dataset '"fileo"' does not exist. Please review",
                "your dataset name generation processing in the",
                'configuration member "CSGCH$" and try again.',
                'Pess [ENTER] or END PF key to process next selection.'
        "ISPEXEC SETMSG MSG(ISRZ001)"
        csr2=type'BU';itype1='INPUT'
        "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
         Return 0
    End
    Interpret "act =" Substr(member,2)"BU"
    x=Build_job_card('BU',type '- BACKUP')
    If sysreason=30 & smsmangd='N' Then Do
        Queue '//*'Copies('-',67)'*'
        x=qc('//*')
        x=qc("//* Note - It appears that '"fileo"' is not SMS")
        x=qc("//*        managed.",
                        'Backup is to it''s home volume "'sysvolume'". If this')
        x=qc('//*        is not acceptable, please change the references to',
                        'the')
        x=qc('//*        correct value.')
        x=qc('//*')
        Queue '//*'Copies('-',67)'*'
    End
    Queue '//DELETE   EXEC PGM=IDCAMS,REGION=1024K'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue "  DELETE '"fileu"'"
    Queue ' '
    Queue '  IF MAXCC < 9 THEN SET MAXCC = 0'
    Queue ' '
    Queue '/*'
    Queue "//CLONEDSN EXEC PGM=ADRDSSU PARM='TYPRUN=NORUN'"
    If sysreason=30 & smsmangd='N' Then,
        Queue '//OUTVOL   DD UNIT=SYSALLDA,DISP=OLD,VOL=SER='sysvolume
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue ' COPY -'
    If sysreason=30 & smsmangd='N' Then Do
        Queue '  OUTDD(OUTVOL) -'
        Queue '  NSC NMC  -'
    End
    Queue '  DATASET(INC( -'
    Queue '              'fileo' -'
    Queue '              ) -'
    Queue '          ) -'
    Queue '   RENUNC ( -'
    Queue '          ('fileo', -'
    Queue '           'fileu'), -'
    Queue '          ), -'
    Queue '   CATALOG ALLDATA(*) -'
    Queue '   TOL(ENQF)'
    Queue '/*'
    Queue '//*'
    Queue '//'
    Queue ''
    x=output_jcl('BU')

    Return 0

/*--------------------------------------------------------------------*/
/*  Create the staging dataset. The dataset is defined with no        */
/*  members. It is up to the change co-ordinator to copy accross the  */
/*  appropriate members that will be changed manually.                */
/*--------------------------------------------------------------------*/
build_PDS_stage:
    Interpret "If "type"ST = '' Then Return"
    x=Listdsi("'"fileo"' NORECALL SMSINFO")
    If Sysreason=5 Then Do
        zedlmsg="Dataset '"fileo"' does not exist. Please review",
                "your dataset name generation processing in the",
                'configuration member "CSGCH$" and try again.',
                'Pess [ENTER] or END PF key to process next selection.'
        "SETMSG MSG(ISRZ001)"
        csr2=type'ST';itype1='INPUT'
        "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
        If rc/=0 Then Do
            Interpret type"ST="
            Return 0
        End
        Interpret "If "type"ST='' Then Return"
    End
    If bustexst='Y' Then Do
        x=Listdsi("'"files"' NORECALL")
        If Sysreason/=5 Then Do
            zedlmsg='Dataset already exist. If the job is submitted,',
                    'you may delete work already done.  Press [ENTER]',
                    'to continue with the JCL generation/submission or',
                    'END PF key to process next selection.'

            "SETMSG MSG(ISRZ001)"
            csr2=type'ST';itype1='INPUT'
            "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
            If rc/=0 Then Do
                Interpret type"ST="
                Return 0
            End
            Interpret "If "type"ST='' Then Return"
        End
    End
    Interpret "act =" Substr(member,2)"ST"
    x=Build_job_card('ST',type '- STAGE')
    Queue '//DELETE   EXEC PGM=IDCAMS,REGION=1024K'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue "  DELETE '"files"'"
    Queue ' '
    Queue '  IF MAXCC < 9 THEN SET MAXCC = 0'
    Queue ' '
    Queue '/*'
    Queue "//DEFINEDS EXEC PGM=IEFBR14"
    Queue '//STAGEDS DD DSN='files','
    Queue '//           DISP=(NEW,CATLG),SPACE=(TRK,(15,5,10)),'
    Queue '//           DCB='fileo','
    Queue '//           UNIT=SYSALLDA'
    Queue '//*'
    Queue '//'
    Queue ''
    x=output_jcl('ST')

    Return 0

/*--------------------------------------------------------------------*/
/*  Create the implementation job. This job will copy the entire      */
/*  stagin PDS into the current PDS. However, before the copy, it will*/
/*  execute a 'COMPRESS' to ensure sufficient space.                  */
/*  Will not cater for insufficient directory blocks for new members. */
/*--------------------------------------------------------------------*/
build_iebcopy_implement:
    Interpret "If "type"IM='' Then Return"
    x=Listdsi("'"files"' DIRECTORY NORECALL SMSINFO")
    If sysreason=30 Then x=0
    If x/=0 | Datatype(sysmembers)/='NUM' | sysmembers=0 Then Do
         zedlmsg='Cannot select implement JCL until staging dataset',
                 'is built and populated. Hit [ENTER] or END PF key',
                 'to continue to next selection.'
         "SETMSG MSG(ISRZ001)"
         csr2=type'IM';itype1='INPUT'
         "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
         Interpret type"IM="
         Return 0
    End

    Interpret "act =" Substr(member,2)"IM"
    x=Build_job_card('IM',type '- IMPLEM')
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Note - This implement job has two templates:')
    x=qc('//*    1. IEBCOPY  - Compresses output dataset and copies the')
    x=qc('//*       staging members to the original dataset.')
    x=qc('//*    2. IEBPROGM - Uses the members in the staging dataset to')
    x=qc('//*       build delete statements from the original dataset.')
    x=qc('//* Use the appropriate template or combination to achieve desired')
    x=qc('//* results.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Copy template.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue "//*"
    Queue "//IMPMENT  EXEC PGM=IEBCOPY,PARM='SIZE=200K'"
    Queue "//*"
    Queue "//IN1      DD  DISP=SHR,DSN="files
    Queue "//*"
    Queue "//OUT1     DD  DISP=SHR,DSN="fileo
    Queue "//*"
    Queue "//SYSUT3   DD  UNIT=VIO,SPACE=(80,(6000,2000))"
    Queue "//SYSUT4   DD  UNIT=VIO,SPACE=(80,(6000,2000))"
    Queue "//SYSPRINT DD  SYSOUT=*"
    Queue "//SYSIN    DD  *"
    x=member_list_select(files,'SELECT')
    Queue "/*"
    x=build_wto('IM','COPY1','0')
    Queue "//"
    Queue ''
    x=output_jcl('IM')

    x=build_iebcopy_delete('IM')

    Return 0

build_iebcopy_delete:
    Queue ' '
    Queue ' '
    Queue '  *'Copies('-',67)'*'
    x=qc('  *')
    x=qc('  * Statements after the previous "//" will not be executed unless')
    x=qc('  * the JCL structure is explicitly modified to do so.')
    x=qc('  *')
    Queue '  *'Copies('-',67)'*'
    Queue ' '
    Queue ' '
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Delete template.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue "//*"
    Queue '//DELETES  EXEC PGM=IEHPROGM'
    Queue "//SYSPRINT DD SYSOUT=*"
    x=Listdsi("'"fileo"' DIRECTORY NORECALL")
    scrvol=Substr('               VOL='sysunit'='sysvolume',',1,71)'+'
    Queue '//DD1      DD UNIT='sysunit',VOL=SER='sysvolume',DISP=SHR'
    Queue '//SYSIN    DD *'
    m_list=
    x=member_list_select(files,'CONCAT')
    If m_list='' Then m_list='Missing'
    Do While m_list/=''
        Parse VAR m_list xx m_list
        Queue Substr('      SCRATCH DSNAME='fileo',',1,71)'+'
        Queue scrvol
        Queue        '               MEMBER='xx
    End
    Queue "/*"
    x=build_wto('IM','DELETES','0')
    Queue "//"
    Queue ''
    x=output_jcl(Arg(1),'MOD')

    Return 0

/*--------------------------------------------------------------------*/
/*  Create the backout job. This option should be exercised AFTER     */
/*  the proposed changed members have been copied into the staging    */
/*  dataset. During execution of this process, it will genearte a     */
/*  member list from the staging dataset to use in 'SELECT MEMBER'    */
/*  statements from the backup dataset for recovery purposes.         */
/*--------------------------------------------------------------------*/
build_iebcopy_backout:
    Interpret "If "type"BO = '' Then Return"
    x=Listdsi("'"files"' DIRECTORY NORECALL SMSINFO")
    If sysreason=30 Then x=0
    If x/=0 | Datatype(sysmembers)/='NUM' | sysmembers=0 Then Do
         zedlmsg='Cannot select backout JCL until staging dataset',
                 'is built and populated. Hit [ENTER] or END PF key',
                 'to continue to next selection.'
         "SETMSG MSG(ISRZ001)"
         csr2=type'BO';itype1='INPUT'
         "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
         Interpret type"BO="
         Return 0
    End

    Interpret "act =" Substr(member,2)"BO"
    x=Build_job_card('BO',type '- BACKOUT')
    Queue "//BACKOUT  EXEC PGM=IEBCOPY,PARM='SIZE=200K'"
    Queue "//*"
    Queue "//IN1      DD  DISP=SHR,DSN="fileu
    Queue "//*"
    Queue "//OUT1     DD  DISP=SHR,DSN="fileo
    Queue "//*"
    Queue "//SYSUT3   DD  UNIT=VIO,SPACE=(80,(6000,2000))"
    Queue "//SYSUT4   DD  UNIT=VIO,SPACE=(80,(6000,2000))"
    Queue "//SYSPRINT DD  SYSOUT=*"
    Queue "//SYSIN    DD  *"
    x=member_list_select(files,'SELECT')
    Queue "/*"
    Queue "//"
    Queue ''
    x=output_jcl('BO')

    x=build_iebcopy_delete('BO')

    Return 0

/*--------------------------------------------------------------------*/
/*  Create the review (compare) job. Should be exercised AFTER        */
/*  the proposed changed members have been copied into the staging    */
/*  dataset and modified.                                             */
/*--------------------------------------------------------------------*/
build_PDS_batch_review_bu:
    Interpret "If "type"BU/='B' Then Return"
/*  If Listdsi("'"fileu"'")>0 Then Return                             */
    x=Build_job_card('RU',type '- REV BU')
    Queue '//SUPERC  EXEC PGM=ISRSUPC,'
    Queue "//   PARM=(DELTAL,LINECMP,'','')"
    Queue '//NEWDD  DD DISP=SHR,DSN='fileo
    Queue '//OLDDD  DD DISP=SHR,DSN='fileu
    Queue '//OUTDD  DD SYSOUT=(*)'
    Queue "//"
    Queue ''
    x=output_jcl('RU')
    x=action_dataset('E',chgjcl'('jid')','macro_1')

    Return 0

build_PDS_batch_review_st:
    Interpret "If "type"ST/='B' Then Return"
/*  If Listdsi("'"files"'")>0 Then Return                             */
    x=Build_job_card('RS',type '- REV STAG')
    Queue '//SUPERC  EXEC PGM=ISRSUPC,'
    Queue "//   PARM=(DELTAL,LINECMP,'','')"
    Queue '//NEWDD  DD DISP=SHR,DSN='files
    Queue '//OLDDD  DD DISP=SHR,DSN='fileu
    Queue '//OUTDD  DD SYSOUT=(*)'
    Queue "//"
    Queue ''
    x=output_jcl('RS')
    x=action_dataset('E',chgjcl'('jid')','macro_1')

    Return 0

/*--------------------------------------------------------------------*/
/*  Build controlM process job to execute all process jobs.           */
/*--------------------------------------------------------------------*/
build_controlM_process:
    x=Build_job_card('PR','PROCESS-ALL')
    Queue '//VARS     SET CLASS='chgjobc',DSNAME='chgjcl
    Queue '//*'
    Queue '//SUBJOB   PROC MEMBER=MISSING'
    Queue '//*'
    Queue '//STEP1    EXEC PGM=IEBGENER'
    Queue '//SYSPRINT DD  SYSOUT=*'
    Queue '//SYSIN    DD  DUMMY'
    Queue '//SYSUT2   DD  SYSOUT=(&CLASS,INTRDR),DCB=BLKSIZE=80'
    Queue '//SYSUT1   DD  DISP=SHR,DSN=&DSNAME(&MEMBER)'
    Queue '// PEND'
    x=member_list_select(chgjcl,'CTRLM','P')
    Queue "//"
    Queue ''
    x=output_jcl('PR')

    Return 0

/*--------------------------------------------------------------------*/
/*  Build controlM implement job to execute all implement jobs.       */
/*--------------------------------------------------------------------*/
build_controlM_implement:
    x=Build_job_card('IM','IMPLEMENT-ALL')
    Queue '//VARS     SET CLASS='chgjobc',DSNAME='chgjcl
    Queue '//*'
    Queue '//SUBJOB   PROC MEMBER=MISSING'
    Queue '//*'
    Queue '//STEP1    EXEC PGM=IEBGENER'
    Queue '//SYSPRINT DD  SYSOUT=*'
    Queue '//SYSIN    DD  DUMMY'
    Queue '//SYSUT2   DD  SYSOUT=(&CLASS,INTRDR),DCB=BLKSIZE=80'
    Queue '//SYSUT1   DD  DISP=SHR,DSN=&DSNAME(&MEMBER)'
    Queue '// PEND'
    x=member_list_select(chgjcl,'CTRLM','I')
    Queue "//"
    Queue ''
    x=output_jcl('IM')

    Return 0

/*--------------------------------------------------------------------*/
/*  Build controlM backout job to execute all implement jobs.         */
/*--------------------------------------------------------------------*/
build_controlM_backout:
    x=Build_job_card('BO','BACKOUT-ALL')
    Queue '//VARS     SET CLASS='chgjobc',DSNAME='chgjcl
    Queue '//*'
    Queue '//SUBJOB   PROC MEMBER=MISSING'
    Queue '//*'
    Queue '//STEP1    EXEC PGM=IEBGENER'
    Queue '//SYSPRINT DD  SYSOUT=*'
    Queue '//SYSIN    DD  DUMMY'
    Queue '//SYSUT2   DD  SYSOUT=(&CLASS,INTRDR),DCB=BLKSIZE=80'
    Queue '//SYSUT1   DD  DISP=SHR,DSN=&DSNAME(&MEMBER)'
    Queue '// PEND'
    x=member_list_select(chgjcl,'CTRLM','B')
    Queue "//"
    Queue ''
    x=output_jcl('BO')

    Return 0

/*--------------------------------------------------------------------*/
/*  This generates JCL to rename a set of CSGCH managed datasets to   */
/*  a new set using a later date.                                     */
/*--------------------------------------------------------------------*/
build_ALTER_jcl:
    jid='$ALTER';member='$ALTER'
    x=Build_job_card('AL','ALTER' altr_#)
    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* This job will rename all the change management datasets')
    x=qc('//* 'altr_# 'week(s) from current change date.')
    x=qc('//*')
    x=qc('//* Note the ENQ on the "RENBASE" step. After submitting')
    x=qc('//* this JCL exit the dataset entirely to permit rename.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//*'
    Queue '//RENAME   EXEC PGM=IDCAMS'
    Queue '//SYSPRINT DD SYSOUT=*'
    Queue '//SYSIN    DD *'
    Queue " /* NOTE - OTHER CSDS MAY BE SUBJECT TO NAME CHANGES.      */"
    Queue " /*        THESE COMMANDS WERE GENERATED FROM THE ACTIVE   */"
    Queue " /*        CSD ON THE CONTROL PANEL. IF MORE CSDS ARE      */"
    Queue " /*        INVOLVED IN THIS CHANGE, USE THE ALTER          */"
    Queue " /*        STATEMENTS BELOW TO MODEL THE REST ON, CHANGING */"
    Queue " /*        THE APPROPRIATE MIDDLE QUALIFIER ACCORDINGLY.   */"
    Queue ' '
    Queue '     ALTER   ' csd_u '-'
    Queue '     NEWNAME(' $cstring(csd_u,chgdate,newdate) ')'
    Queue ' '
    Queue '     ALTER   ' csd_u_i '-'
    Queue '     NEWNAME(' $cstring(csd_u_i,chgdate,newdate) ')'
    Queue ' '
    Queue '     ALTER   ' csd_u_d '-'
    Queue '     NEWNAME(' $cstring(csd_u_d,chgdate,newdate) ')'
    Queue ' '
    Queue '     ALTER   ' csd_s '-'
    Queue '     NEWNAME(' $cstring(csd_s,chgdate,newdate) ')'
    Queue ' '
    Queue '     ALTER   ' csd_s_i '-'
    Queue '     NEWNAME(' $cstring(csd_s_i,chgdate,newdate) ')'
    Queue ' '
    Queue '     ALTER   ' csd_s_d '-'
    Queue '     NEWNAME(' $cstring(csd_s_d,chgdate,newdate) ')'
    Queue ' '
    Queue '/*'
    Queue '//*'

    Queue '//*'Copies('-',67)'*'
    Queue '//*'
    Queue '//RENCSD EXEC PGM=IKJEFT01 COND=(0,LT)'
    Queue '//SYSOUT   DD SYSOUT=*'
    Queue '//SYSTSPRT DD SYSOUT=*'
    Queue '//SYSTSIN  DD *'
    Queue "  RENAME '"jobl_u"' +"
    Queue "         '"$cstring(jobl_u,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"jobl_s"' +"
    Queue "         '"$cstring(jobl_s,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"proc_u"' +"
    Queue "         '"$cstring(proc_u,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"proc_s"' +"
    Queue "         '"$cstring(proc_s,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"tab_u"' +"
    Queue "         '"$cstring(tab_u,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"tab_s"' +"
    Queue "         '"$cstring(tab_s,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"util_u"' +"
    Queue "         '"$cstring(util_u,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"util_s"' +"
    Queue "         '"$cstring(util_s,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"auth_u"' +"
    Queue "         '"$cstring(auth_u,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"auth_s"' +"
    Queue "         '"$cstring(auth_s,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"parm_u"' +"
    Queue "         '"$cstring(parm_u,chgdate,newdate)"'"
    Queue " "
    Queue "  RENAME '"parm_s"' +"
    Queue "         '"$cstring(parm_s,chgdate,newdate)"'"
    Queue " "
    Queue '/*'
    Queue '//*'

    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Change all occurances.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//RENBUST EXEC PGM=PDSEDIT,REGION=2048K'
    Queue '//STEPLIB  DD DISP=SHR,DSN='pdsedld
    Queue '//SYSPRINT DD SYSOUT=H'
    Queue '//SYSOUT   DD SYSOUT=H'
    Queue '//SYSUT1   DD DISP=SHR,DSN='chgjcl
    Queue '//SYSIN    DD DATA,DLM=$$'
    Queue 'PDS IN(SYSUT1)'
    Queue 'EXCLUDE($ALTER)'
    Queue 'CHANGE \.BU'chgdate'\.BU'newdate'\'
    Queue 'CHANGE \.ST'chgdate'\.ST'newdate'\'
    Queue '$$'
    Queue '/*'
    Queue '//*'

    Queue '//*'Copies('-',67)'*'
    x=qc('//*')
    x=qc('//* Rename base change JCL. Note the ENQ. After submitting')
    x=qc('//* this JCL exit the dataset entirely.')
    x=qc('//*')
    Queue '//*'Copies('-',67)'*'
    Queue '//*'
    Queue '//RENBASE EXEC PGM=IKJEFT01 COND=(0,LT)'
    Queue '//SYSOUT   DD SYSOUT=*'
    Queue '//SYSTSPRT DD SYSOUT=*'
    Queue '//ENQDD    DD DISP=OLD,DSN='chgjcl
    Queue '//SYSTSIN  DD *'
    Queue "  RENAME '"chgjcl"' +"
    Queue "         '"$cstring(chgjcl,chgdate,newdate)"'"
    Queue " "
    Queue '/*'
    Queue ''
    x=output_jcl('TE')

    Return 0

/*--------------------------------------------------------------------*/
/*  Comon jobcard build section.                                      */
/*--------------------------------------------------------------------*/
Build_job_card: Arg jsuf,desc,memasis,restart
    Address TSO "NEWSTACK"
    If jsuf='ST' | jsuf='BU' Then Nop
    Else,
        If Length(desc chgno)>20 Then desc=,
            chgno Substr(desc,1,20-(Length(chgno)+1))
        Else desc=chgno desc
    Signal on Syntax Name error_off_$ALKJCPG

    x=$Alkjcpg(desc);If x/='' Then desc=x
error_off_$ALKJCPG:Signal off Syntax
    jsuf=eval_member_name(jsuf,memasis)
    If Wordpos(Substr(member,1,2),'$C $A')>0 Then NOP
    Else jid=member||jsuf
    member=#memb
    If exjobcrd/='N' Then Do
        Interpret 'x='exjobcrd ||,
          '(member,#suff,jid,desc,chgno,chgacct,chgjobc,chgmsgc,chgjreg,' ||,
          'restart,test)'
        If x=0 Then Return 0
    End
    If jidasmem='N' Then,
        Queue "//CSGCH"mt||#suff "JOB ("chgacct"),"
    Else,
        Queue "//"jid "JOB ("chgacct"),"
    Queue "//        '"desc"',MSGLEVEL=1,"chgjreg
    If Arg(4)/='' Then Queue '//*'Copies('-',67)'*'
    Do While restart/=''
        Parse Var restart xx restart
        Queue '//*       RESTART='Substr(xx',',1,9),
              '<--- uncomment if applicable'
    End
    If Arg(4)/='' Then Queue '//*'Copies('-',67)'*'
    Queue '//        MSGCLASS='chgmsgc',CLASS='chgjobc',NOTIFY=&SYSUID'test
    Queue '//*'

    Return 0

/*--------------------------------------------------------------------*/
/*  Comon WTO build step.                                             */
/*--------------------------------------------------------------------*/
build_wto: Arg jsuf,step,cc
    If exwtomsg/='N' Then Do
        Interpret 'x='exwtomsg ||,
          '(jid,step,cc)'
        If x=0 Then Signal build_WTO_JCL_out
    End
    If ctrl_M/='Y' Then Do
        Queue '//'
        Queue ' '
        Queue ' '
    End
    Queue '//*'
    Queue '// IF ('step'.RC GT 'cc') THEN'
    Queue '//WTO  EXEC PGM=WTO'
    Queue '//SYSPRINT DD  SYSOUT=*,DCB=(LRECL=133,RECFM=FBA)'
    Queue '//SYSIN    DD  *'
    Queue "Implementation job '"jid"' failed."
    Queue 'Please contact/page CICS Support quoting above message.'
    Queue '/*'
    Queue '//*'
    Queue '// ENDIF'
    Queue '//*'
build_WTO_JCL_out:

    Return 0

/*--------------------------------------------------------------------*/
/*  Output generated JCL members into to change dataset               */
/*--------------------------------------------------------------------*/
output_jcl: Arg jsuf,disp
    zedlmsg='Processing member "'jid'".'
    If #tr='N' Then Do
        "CONTROL DISPLAY LOCK";"DISPLAY MSG(ISRZ001)"
    End
    y=Msg('Off')
    Address TSO "ALLOC DD("ddj") DS('"chgjcl"("jid")') SHR REU"
Say Address TSO "ALLOC DD("ddj") DS('"chgjcl"("jid")') SHR REU"
    y=Msg(y)
    If rc=0 Then Do
        If disp='MOD' Then Do
            modline.=
            Address TSO "EXECIO * DISKR" ddj "(STEM modline. FINIS"
            Address TSO "EXECIO * DISKW" ddj "(STEM modline.)"
        End
        Address TSO "EXECIO * DISKW" ddj "(FINIS"
        Address TSO "FREE DD("ddj")"
        If act='S' Then Do
            If jsuf='BU' | jsuf='ST' Then Do
                x=Outtrap('line.',10,'NOCONCAT')
                If subit='Y' Then Address TSO "SUBMIT '"chgjcl"("jid")'"
                x=Outtrap('Off')
                zedlmsg=line.1
                If #tr='N' Then Do
                    "CONTROL DISPLAY LOCK";"DISPLAY MSG(ISRZ001)"
                End
            End
        End
    End
    Address TSO "DELSTACK"
    Return 0

/*--------------------------------------------------------------------*/
/*  Evaluate member name. Changes member name if a change number is   */
/*  supplied except for the load libraries.                           */
/*--------------------------------------------------------------------*/
eval_member_name: Arg suff,memasis
    #memb=member
/*  If chgno/='' Then Do                                              */
        #suff=suff
        suff=
        xx=Index(string1,Substr(member,1,4)' ')
        Select
            When xx>0 Then Do
                Parse Value Substr(string1,xx) With . mt ':' .
            End
            When Substr(member,1,2)='$L'  Then mt='L'
            Otherwise mt='@'
        End
        Select
            When #suff='BO' & member='$CTRLM' Then member='B#CSG'
            When #suff='IM' & member='$CTRLM' Then member='I#CTRLM'
            When #suff='PR' & member='$CTRLM' Then member='P#CSG'
            When #suff='BO'  Then member='B'mt ||chgnot
            When #suff='IM'  Then member='I'mt ||chgnot
            When #suff='UP'  Then member='P'mt ||chgnot
            When #suff='OCI' Then member='IO'  ||chgnot
            When #suff='OCB' Then member='BO'  ||chgnot
            When #suff='RU'  Then member=member||'RU'
            When #suff='RS'  Then member=member||'RS'
            When #suff='*'   Then Do
                member=memasis
                #suff=Substr(member,Length(member),1)
                mt=Substr(member,Length(member)-2,2)
            End
/*          When Substr(member,1,2)='$L' Then Do                      */
/*          End                                                       */
            Otherwise suff=#suff
        End
        If suff='' & Substr(#memb,1,2)='$L' Then,
            member=Substr(member,1,1)Substr(#memb,2,5)
/*  End                                                               */
    Return suff

/*--------------------------------------------------------------------*/
/*  Build the index from members in dataset                           */
/*--------------------------------------------------------------------*/
build_index:
    If autoindx='N' Then Return 4
    x_memb='$$$INDEX $$$LOCKD $$$CONFG $ALTER'
    "LMINIT DATAID(DATA1) DATASET('&CHGJCL') "
    "LMOPEN DATAID(&DATA1) OPTION(INPUT)"
    Address TSO "NEWSTACK"
    Queue ' Member   Description'
    Queue '+---------+'Copies('-',68)
    Queue '$$$INDEX  Index....(gen''d' Time() 'on' Date('e')') by' cname'.'
    Queue '$$$CONFG  Configuration/parameter settings member.'
    Queue '$$$LOCKD  Prev accidental changes. UNLOCK/LOCK for last',
          'minute change.'
    Queue '$ALTER    JCL to alter all to a new change-date-set'
    memb=
    #tr=Trace('o')
    Do While rc=0
        "LMMLIST DATAID(&DATA1) OPTION(LIST) MEMBER(MEMB) STATS(NO)"
        If rc/=0 Then Leave

        memb=Strip(memb);line=''Substr(memb,1,9)''
        mpre=Substr(memb,1,4);msuf=Substr(memb,Length(memb)-1)
        Interpret "Parse VAR string1 . ' "mpre" ' i1 ':' t1 ':'."
        Interpret "Parse VAR string2 . ' "msuf" ' i2 ':' t2 ':'."
        Select
            When Wordpos(memb,x_memb)>0 Then Iterate
            When Substr(memb,1,2)='$C' Then Do
                ch3=Substr(memb,3,1)
                If ch3='S' Then xx='staging'
                Else If ch3='U' Then xx='backup'
                     Else xx='?????'
                Interpret "yy="#config"('CSD' Substr(memb,5) 'X')"
                line=line 'CSD' yy xx
            End
            When Substr(memb,1,2)='$G' Then line=line,
                 chgmanc 'change #.'Substr(memb,3) 'instructions'
            When Substr(memb,1,2)='B#' Then line=line,
                 'CSG backout job to submit all dedicated backouts.'
            When Substr(memb,1,2)='I#' Then line=line,
                 'Control-M implement job to submit all dedicated implements.'
            When Substr(memb,1,2)='P#' Then line=line,
                 'Manual process job to submit all dedicated processes.'
            When Substr(memb,1,2)='IO' Then line=line,
                 'Implement using operator commands.'
            When Substr(memb,1,2)='BO' Then line=line,
                 'Backout using operator commands.'
            When Substr(memb,1,2)='$L' Then line=line,
                 'Region_loadlib' t2'.'
            When Substr(memb,1,2)='$O' Then line=line,
                 'CEDA install commands for task #.'Substr(memb,3)'.'
            When Substr(memb,1,1)='#'  Then line=line,
                 'Miscellaneous process/doco/work member.'
            When Substr(memb,1,1)='$' Then Do
                line=line t1 t2'.'
            End
            Otherwise Do
                ch1=Substr(memb,1,1);ch2=Substr(memb,2,1)
                Interpret "Parse VAR string1 . ' "ch2":' t1 ':' ."
                Interpret "Parse VAR string2 . ' "ch1":' t2 ':' ."
                If t1='' Then t1='User_created'
                If Substr(memb,2,1)='L' Then,
                     line=line t1 t2 'for task #.????.'
                Else line=line t1 t2 'for task #.'Substr(memb,3)'.'
            End
        End
        Queue line
        If Verify(Trace(),'NO')>0 Then Say line
    End
    x=Trace(#tr)

    "LMMLIST DATAID(&DATA1) OPTION(FREE)"
    "LMCLOSE DATAID(&DATA1)";"LMFREE  DATAID(&DATA1)"
    Queue ''
    jid='$$$INDEX'
    x=output_jcl()

    Return 0

/*--------------------------------------------------------------------*/
/*  Set up variables.                                                 */
/*--------------------------------------------------------------------*/
set_vars_0:
    table=
    Return 0

set_vars_1:
    ddj='CH'Time('s')
    If chgjobc='' | chgjreg='CHGJREG' Then Do
        v1='chgjobc chgmsgc chgacct chgjreg';Interpret "v2="#config"(v1)"
        Interpret "Parse var v2" v1
    End
    If chgjreg='N/A' Then chgjreg=
    cols    = 'YELLOW'                      /* Submit color           */
    colj    = 'BLUE'                        /* JCL color              */
    coln    = 'RED'                         /* No color               */
/*  cola    = 'YELLOW'                    *//* Audit color            */
    asubs   =                               /* Audit 'A' flag subs    */
    create_new=0

/*--------------------------------------------------------------------*/
/*  The following bit of code determines if any parameters were passed*/
/*  that may alter the change date.                                   */
/*--------------------------------------------------------------------*/
    llq=
    If Index(parm1,'/')>0 Then Do
        xx=$DATEMAN('VER',parm1)
        If Word(xx,1)='Error' Then Do
            zedlmsg="Invalid date '"parm1"'." xx
            "SETMSG MSG(ISRZ001)"
            Return 4
        End
        parm1=xx
    End
    "VPUT (sid,chgenvt,chgstcn) SHARED"

/*--------------------------------------------------------------------*/
/* Export the contents if the next variable into CSGCHELP for variable*/
/* list cobvered by the "CONFIG=" command:                            */
/*--------------------------------------------------------------------*/
    v#='#ver auth_# auth_a auth_o autodel autoindx batchdsn batchsin',
       'bustexst chghlq chghlqC chgjclc chgsid#',
       'chgjclw chgmana chgmanc',
       'chgmano cicshlq cicshlqv cicstl1 cicstl2 cola comp_PDS conscmd',
       'conscmdi conslib copyany copyfbu csd_# csd_o csd_w CSDbreq',
       'csdext csdsip ctrl_M day# disaudit excsdopc excsdupd exjobcrd',
       'exoprcmd extmacs exwtomsg helpdrvr helpdsn jidasmem jobl_#',
       'jobl_o load_# load_a load_r loadlib parm_# parm_o pdsedld',
       'proc_# proc_o regnveri siteenvt smsmangd subit sysexec tab_#',
       'tab_a tab_o userhlq util_# util_a util_o',
       ''
set_vars_1a:
    v1=v#
    "VPUT (#config) SHARED"
    Interpret "v2="#config"(v1)";Interpret "Parse var v2" v1
    Interpret "regnignr="#config"('regnignr')"
    Interpret "regnmask="#config"('regnmask')"
    "VGET (chgenvt,chgstcn) SHARED"

    If Index(helpdrvr,'=')>0 Then Do
        Parse VAR helpdrvr helpdd '=' .
        x=Listdsi(helpdd "FILE")
        If sysdsname='' | sysdsname/=helpdsn Then Do
            xx=MSG('Off')
            Address TSO "ALLOC F("helpdd") DSN('"helpdsn"') SHR REU"
            xx=MSG(xx)
        End
        helpaloc=sysdsname
    End
    Else helpaloc='N'
/*--------------------------------------------------------------------*/
/*  Test if parameter 1 is a valid change JCL dataset. If it is, use  */
/*  it and work out it's generation.                                  */
/*  Note: passed dataset may force a change in sysid.                 */
/*--------------------------------------------------------------------*/
    If parm1/='' Then Do
        qe=Words(Translate(chgjclc,' ','.')) /* # quals w/o STC appnd */
        xxx=Strip(parm1,,"'")
        qa=Translate(xxx,' ','.')            /* Actual # of quals     */
        If Words(qa)=qe Then appndstc='N';Else appndstc='Y'
        Parse Value Word(qa,qe) With p1 +2 p2
        If p1='CH' & Datatype(p2)='NUM' Then Do
            x=Listdsi("'"xxx"' NORECALL")
            If xx<5 | sysreason=9 | sysreason=25 Then Do
                chgdate=p2;llq=p2
                If Datatype(chgsid#,'w') Then,
                    If chgsid#>0 Then sid=Word(qa,chgsid#)
                chgjclc=Strip(Substr(xxx,1,Lastpos('.',xxx)+2))
                Interpret "xx="#config"('ENV' parm1)"
                If xx/='' Then Do;chgenvt=xx;#envt=chgenvt;End
                "SETMSG MSG(ISRZ001)"
            End
        End
    End
    If chggenr='*' | day#='*' Then Do
        Select
            When Index(parm1,'/')>0 Then,
                Parse VAR parm1 dd '/' mm '/' +3 yy .
            When chgdate/='' Then
                Parse VAR chgdate yy +2 mm +2 dd .
            Otherwise Parse Value Date('e') With dd '/' mm '/' yy
        End
        xx=dd'/'mm'/'Right(yy,4,'0');gener='*'
        Signal have_base_date
    End

    xx=$DATEMAN('E-N',,,day#-$DATEMAN('E2N',Date('e')))

    If llq/='' Then Do
        Parse VAR llq yy +2 mm +2 dd
        zz=$DATEMAN('VER',dd'/'mm'/'yy)
        If Word(zz,1)/='Error' Then Do
            gener=$DATEMAN('E-E',zz,xx)%7;xx=zz
            Signal have_base_date
        End
    End

    gener=parm1
    Select
        When Index(parm1,'/')>0 Then Do
            zz=xx
            xx=$DATEMAN('E-N',parm1,,day#-$DATEMAN('E2N',parm1))
            gener=$DATEMAN('E-E',xx,zz) % 7
            If frstime/='N' & gener>0 Then create_new=1
        End
        When Datatype(parm1)='NUM' Then Do
            dif=Sign(parm1)*7
            Do i=1 To Abs(parm1);xx=$DATEMAN('E-N',xx,,dif);End
            If frstime/='N' & gener>0 Then create_new=1
        End
        Otherwise Do
            zz=xx
            xx=Substr(chgdate,5,2)'/' ||,
               Substr(chgdate,3,2)'/' ||,
               Substr(chgdate,1,2)
            xx=$DATEMAN('VER',xx)
            If Word(xx,1)='Error' Then Do
                zedlmsg="Invalid date '"parm1"'." xx
                "SETMSG MSG(ISRZ001)"
                Return 4
            End
            xx=$DATEMAN('E-N',xx,,day#-$DATEMAN('E2N',xx))
            gener=$DATEMAN('E-E',xx,zz) % 7
        End
    End
    parm1=xx

have_base_date:
    Parse VAR xx dd '/' mm '/' +3 yy .
    chgdate=yy||mm||dd;#chgdate=chgdate
    "VPUT (chgdate) PROFILE"

    gen0date=
        $DATEMAN('REV',$DATEMAN('E-N',,,day#-$DATEMAN('E2N',Date('e'))),2,'S')
/*--------------------------------------------------------------------*/
    stsuf='ST'chgdate
    Do i=1 To 4
        xx=$DATEMAN('E-N',xx,,-7)
        Parse VAR xx dd '/' mm '/' +3 yy .
        mon.i=yy||mm||dd
        Interpret "chgjc"i"= '"chgjclc"'mon.i"
    End

build_dsnames:
/*--------------------------------------------------------------------*/
/*  Work out CSD (and respective components') names.                  */
/*--------------------------------------------------------------------*/
    If parm1='' Then Do
        chgjcl=chgjclc||chgdate
        If appndstc='Y' Then chgjcl=chgjcl'.'chgstcn
    End
    Else Do
        If Index(parm1,'/')=0 Then Do;chgjcl=Strip(parm1,,"'");parm1=;End
        Else chgjcl=chgjclc||chgdate
    End

    csd_o_i=csd_o'.INDEX'
    If Length(csd_o_i)>44 Then Do
        If Length(csd_o_i)>48 Then Do
            x=get_vsam_components(csd_o)
            csd_o_i=index;csd_o_d=data
        End
        Else Do
            csd_o_i=csd_o'.I';csd_o_d=csd_o'.D'
        End
    End
    Else csd_o_d=csd_o'.DATA'

    csd_s=csd_#'.ST'chgdate;csd_u=csd_#'.BU'chgdate
    csd_u_i=csd_u'.INDEX'
    If Length(csd_u_i)>44 Then Do
        If Length(csd_u_i)>48 Then Call long_data_index_names
        Else Do
            csd_u_i=csd_u'.I';csd_u_d=csd_u'.D'
            csd_s_i=csd_s'.I';csd_s_d=csd_s'.D'
        End
    End
    Else Do
        csd_u_d=csd_u'.DATA'
        csd_s_i=csd_s'.INDEX';csd_s_d=csd_s'.DATA'
    End
/*--------------------------------------------------------------------*/
/*  Remove JCL/PROC/both out of process controling variables if the   */
/*  respective dataet is not applicable.                              */
/*--------------------------------------------------------------------*/
    If jobl_#/='N/A' Then Do
        jobl_u=jobl_#'.BU'chgdate;jobl_s=jobl_#'.ST'chgdate
    End
    Else Do
        jobl_u=jobl_#;jobl_s=jobl_#;jobl_o=jobl_#
        jcltyp=Delword(jcltyp,Wordpos('JOBL',jcltyp),1)
        string1=Delword(string1,Wordpos('$JCL',string1),2)
    End
    If proc_#/='N/A' Then Do
        proc_u=proc_#'.BU'chgdate;proc_s=proc_#'.ST'chgdate
    End
    Else Do
        proc_u=proc_#;proc_s=proc_#;;proc_o=proc_#
        jcltyp=Delword(jcltyp,Wordpos('PROC',jcltyp),1)
        string1=Delword(string1,Wordpos('$PRO',string1),2)
    End
/*--------------------------------------------------------------------*/
    tab_u=tab_#'.BU'chgdate;tab_s=tab_#'.ST'chgdate
    util_u=util_#'.BU'chgdate;util_s=util_#'.ST'chgdate
    auth_u=auth_#'.BU'chgdate;auth_s=auth_#'.ST'chgdate
    load_u=load_#'.BU*';load_s=load_#'.ST*'
    parm_u=parm_#'.BU'chgdate;parm_s=parm_#'.ST'chgdate
build_dsnames_end:
    acty=;actn=

/*--------------------------------------------------------------------*/
/*  Setup and prepare for tutorial's variable substitution.           */
/*--------------------------------------------------------------------*/
    If userhlq=userid Then csdexts=userid;Else csdexts=userhlq'.'userid
    csdexts=csdexts'.CSD.EXTRACT.*'
    If chgmanc='' Then cmc='GCARS';Else cmc=chgmanc
    helpvars='sid #ver chghlq chgjcl chgjc2 stsuf csgchver chgdate',
             'chgjcl csgchver cmc sysexec csdexts userid tod'
    "VPUT (helpvars) SHARED";"VPUT ("helpvars") SHARED"

/*--------------------------------------------------------------------*/
/*  Work out which components to generate.                            */
/*  If the update dataset does not exist it will set the staging and  */
/*  backup flags.                                                     */
/*  If the update exists it will set up the implement and backout     */
/*  flags.                                                            */
/*--------------------------------------------------------------------*/
set_vars_2:
    string='CSD' jcltyp
    #tr1=Trace('o')
    Do While string/=''
        Parse VAR string type string
        Interpret "dsn="type"_u"
        If Sysdsn("'"dsn"'")/='OK' Then x=set_value1(type,'BU',acty)
        Else x=set_value1(type,'BU',actn)
        Interpret "dsn="type"_s"
        If Sysdsn("'"dsn"'")/='OK' Then Do
            x=set_value1(type,'ST',acty)
            x=set_value1(type,'IM',acty)
            x=set_value1(type,'BO',actn)
        End
        Else Do
            x=set_value1(type,'ST',actn)
            x=set_value1(type,'IM',actn)
            x=set_value1(type,'BO',acty)
        End
    End
    x=Trace(#tr1)

    If csdsip='N' Then csdup=actn
    csdoc=actn;loadbu=actn;loadst=actn;loadim=actn;loadbo=actn
    #tr=Trace('o')
    If chgregs='' Then x=get_cics_regions(chgjcl)
    Else Do
        regions=chgregs
        If Length(regions)>159 Then regionp=Substr(Regions,1,154)'+'
        Else regionp=regions
    End
    Return 0

/*--------------------------------------------------------------------*/
/* This section will try to uestablish the .DATA and .INDEX component */
/* names of a VSAM dataset if it is > 44 bytes.                       */
/*--------------------------------------------------------------------*/
long_data_index_names: Arg
    If Sysdsn("'"csd_u"'")/='OK' Then Do
        csd_u_i='Missing_component';csd_u_d='Missing_component'
    End
    Else Do
        x=get_vsam_components(csd_u)
        csd_u_i=index;csd_u_d=data
    End
    If Sysdsn("'"csd_s"'")/='OK' Then Do
        csd_s_i='Missing_component';csd_s_d='Missing_component'
    End
    Else Do
        x=get_vsam_components(csd_s)
        csd_s_i=index;csd_s_d=data
    End
    Return 0

get_vsam_components: Arg filei
    index='Missing_component';data='Missing_component'
    x=Outtrap('linei.',500,'NOCONCAT')
    Address TSO "LISTC ENT('"filei"')"
    x=Outtrap('Off')
    Do i=1 To linei.0
        If word(linei.i,1)='INDEX' Then Do
            index=Word(linei.i,3);Iterate
        End
        If word(linei.i,1)='DATA' Then Do
            data=Word(linei.i,3);Iterate
        End
    End
    Return 0

/*--------------------------------------------------------------------*/
/* This section will build a dynamic variable to display the dataset  */
/* names that will be used in this procedure.                         */
/* If you modify the code to display parameters shown, update variable*/
/* 'canotchg' to ensure it stays in sync with staqtic values.         */
/*--------------------------------------------------------------------*/
display_datasets:
    type#='OUTPUT'
/*  canotchg='11 12 13 14 15 16 18 23 64 92'                          */
    canotchg=
    Interpret "tab_slm="#config"('tab_slm')"
    Interpret "util_slm="#config"('util_slm')"
    Interpret "auth_slm="#config"('auth_slm')"
    v1='ispplib ispslib ispmlib isptlib';Interpret "v2="#config"(v1)"
    Interpret "Parse var v2" v1
    table='TB'Time('s');"TBEND &TABLE"
    "TBCREATE &TABLE KEYS(SEQ) NAMES(DESC,DSN,FNAME,INCSGCH$) REPLACE NOWRITE"
    grd='----+----1----+----2----+----3----+----4---|+----5'
    sep=Copies('*-',31)'*'
    ztdmark=Substr(' ',1,15)Centre(' R-Send ',63,'*')
    seq=10
    w=Substr(#config,1,40)'<- Use CONFIG=to_change'
    x=tb_mod('Config.....:',w,'#config','N');canotchg=canotchg seq
    x=tb_mod(,Centre(' Top ',62,'*'))
    w=Substr(chghlq,1,40)'<- Not Changeable'
    x=tb_mod('HLQ Change.:',w,'chghlq'     );canotchg=canotchg seq
    w=Substr(chghlqC,1,40)'<- Not Changeable'
    x=tb_mod('    HLQC...:',w,'chghlqC'    );canotchg=canotchg seq
    w=Substr(cicshlq,1,40)'<- Not Changeable'
    x=tb_mod('    CICS...:',w,'cicshlq'    );canotchg=canotchg seq
    w=Substr(cicshlqv,1,40)'<- Not Changeable'
    x=tb_mod('    CICSver:',w,'cicshlqv'   );canotchg=canotchg seq
    w=Substr(userhlq,1,40)'<- Not Changeable'
    x=tb_mod('    USER...:',w,'userhlq'    );canotchg=canotchg seq
    w=Substr(chgjclc,1,40)'<- Not Changeable'
    x=tb_mod('Change JCL.:',w,'chgjclc'    );canotchg=canotchg seq
    x=tb_mod('       Wild:',chgjclw,'chgjclw')
    w=Substr(appndstc,1,40)'<- Use APPEND=to_change'
    x=tb_mod('Append STC.:',w,'appndstc'   );canotchg=canotchg seq
    w='<- SIP Override =' csdsip
    If Length(csd_o)<39 Then w=Substr(' ',1,39-Length(csd_o))w
    x=tb_mod('CSD Active.:',csd_o w,'csd_o')
    x=tb_mod('    Data...:',csd_o_d,'csd_o_d','N')
    x=tb_mod('    Index..:',csd_o_i,'csd_o_i','N')
    If csdsip='N' Then Do
      If Length(csd_o)<39 Then w=Substr(' ',1,39-Length(csd_o))'(Active)'
      Else w='(Active)'
      x=tb_mod('CSD Updated:',csd_o,w,'csd_o')
    End
    Else Do
      If Length(csd_s)<39 Then w=Substr(' ',1,39-Length(csd_s))'(Staging)'
      Else w='(Staging)'
      x=tb_mod('CSD Updated:',csd_s,w,'csd_s','N')
    End
    x=tb_mod('CSD wild...:',csd_w,'csd_w')
    x=tb_mod('           :',grd,'grd')
    w=Substr(csd_#,1,40)'<- Not Changeable'
    x=tb_mod('CSD Templat:',w,'csd_#');canotchg=canotchg seq
    x=tb_mod('CSD Backup.:',csd_u,'csd_u','N')
    x=tb_mod('    Data...:',csd_u_d,'csd_u_d','N')
    x=tb_mod('    Index..:',csd_u_i,'csd_u_i','N')
    x=tb_mod('CSD Staging:',csd_s,'csd_s','N')
    x=tb_mod('    Data...:',csd_s_d,'csd_s_d','N')
    x=tb_mod('    Index..:',csd_s_i,'csd_s_i','N')
    If jobl_#/='N/A' Then Do
        x=tb_mod('JOBlib Act :',jobl_o,'jobl_o')
        w=Substr(jobl_#,1,40)'<- Not Changeable'
        x=tb_mod('   Template:',w);canotchg=canotchg seq
        x=tb_mod('   Backup..:',jobl_u,'jobl_u','N')
        x=tb_mod('   Staging.:',jobl_s,'jobl_s','N')
    End
    If proc_#/='N/A' Then Do
        x=tb_mod('Proclib Act:',proc_o,'proc_o')
        w=Substr(proc_#,1,40)'<- Not Changeable'
        x=tb_mod('   Template:',w);canotchg=canotchg seq
        x=tb_mod('   Backup..:',proc_u,'proc_u','N')
        x=tb_mod('   Staging.:',proc_s,'proc_s','N')
    End
    x=tb_mod('Parmlib Act:',parm_o,'parm_o')
    w=Substr(parm_#,1,40)'<- Not Changeable'
    x=tb_mod('   Template:',w);canotchg=canotchg seq
    x=tb_mod('   Backup..:',parm_u,'parm_u','N')
    x=tb_mod('   Staging.:',parm_s,'parm_s','N')
    x=tb_mod('Tables Act.:',tab_o,'tab_o')
    x=tb_mod('   Backup..:',tab_u,'tab_u','N')
    x=tb_mod('   Staging.:',tab_s,'tab_s','N')
    x=tb_mod('   Source..:',tab_a,'tab_a')
    x=tb_mod('   SYSLMOD.:',tab_slm,'tab_slm')
    x=tb_mod('Utils. Act.:',util_o,'util_o')
    x=tb_mod('   Backup..:',util_u,'util_u','N')
    x=tb_mod('   Staging.:',util_s,'util_s','N')
    x=tb_mod('   Source..:',util_a,'util_a')
    x=tb_mod('   SYSLMOD.:',util_slm,'util_slm')
    x=tb_mod('Auth. Act..:',auth_o,'auth_o')
    x=tb_mod('   Backup..:',auth_u,'auth_u','N')
    x=tb_mod('   Staging.:',auth_s,'auth_s','N')
    x=tb_mod('   Source..:',auth_a,'auth_a')
    x=tb_mod('   SYSLMOD.:',auth_slm,'auth_slm')
    x=tb_mod('Loadlib....:',loadlib,'loadlib')
    x=tb_mod('   Backup..:',load_u,'load_u','N')
    x=tb_mod('   Staging.:',load_s,'load_s','N')
    x=tb_mod('Load region:',load_r,'load_r')
    x=tb_mod('   Source..:',load_a,'load_a')
    x=tb_mod('Steplib #1.:',cicstl1,'cicstl1')
    x=tb_mod('Steplib #2.:',cicstl2,'cicstl2')
    x=tb_mod('Misc........',sep,)
    x=tb_mod('Region mask:',regnmask,'regnmask')
    x=tb_mod('Region ignr:',regnignr,'regnignr')
    x=tb_mod('Copy any...:',copyany,'copyany')
    x=tb_mod('Copy backup:',copyfbu,'copyfbu')
    x=tb_mod('ChgMan Cmd.:',chgmanc,'chgmanc')
    x=tb_mod('ChgMan Opts:',chgmano,'chgmano')
    x=tb_mod('ChgMan Auto:',chgmana,'chgmana')
    x=tb_mod('Day of week:',day#,'day#')
    x=tb_mod('No.of vers.:',#ver,'#ver')
    x=tb_mod('Help DSN...:',helpdsn,'helpdsn')
    x=tb_mod('    DD=tute:',helpdrvr,'helpdrvr')
    x=tb_mod('ISPF Panels:',ispplib,'ispplib')
    x=tb_mod('     Skels.:',ispslib,'ispslib')
    x=tb_mod('     Msgs..:',ispmlib,'ispmlib')
    x=tb_mod('     Tables:',isptlib,'isptlib')
    x=tb_mod('Macro DSN..:',sysexec,'sysexec')
    If extmacs='' Then extmacs='N'
    x=tb_mod('    Macros :',extmacs,'extmacs')
    x=tb_mod('Conscmd DSN:',conslib,'conslib')
    x=tb_mod('    Conscmd:',conscmd,'conscmd')
    x=tb_mod("    Implm't:",conscmdi,'conscmdi')
    x=tb_mod('Job as memb:',jidasmem,'jidasmem')
    x=tb_mod('Comp. PDSs.:',comp_pds,'comp_pds')
    x=tb_mod('Verify CICS:',regnveri,'regnveri')
    x=tb_mod('Auto index.:',autoindx,'autoindx')
    x=tb_mod('Auto delete:',autodel,'autodel')
    x=tb_mod('Audit dels.:',disaudit,'disaudit')
    x=tb_mod('SMS managed:',smsmangd,'smsmangd')
    x=tb_mod('Let opt."S":',subit,'subit')
    x=tb_mod('Account....:',chgacct,'chgacct')
    x=tb_mod('Exec class.:',chgjobc,'chgjobc')
    x=tb_mod('Msg class..:',chgmsgc,'chgmsgc')
    x=tb_mod('JOB region.:',chgjreg,'chgjreg')
    x=tb_mod('Exits.......',sep,)
    x=tb_mod(' Jobcard...:',exjobcrd,'exjobcrd')
    x=tb_mod(' CSD update:',excsdupd,'excsdupd')
    x=tb_mod(' Cons. cmd.:',excsdopc,'excsdopc')
    x=tb_mod(' WTO msg...:',exwtomsg,'exwtomsg')
    "TBTOP &TABLE"

dis0:
    zcmd=;sel=
    "TBDISPL &TABLE PANEL(&TBPAND)"
    If rc>4 Then Do;"TBEND &TABLE";Return 0;End
    If zcmd='SEQ' Then Do
        If tbpand='CSGCHPDY' Then Do
            zedlmsg='Cannot change lines:' Strip(canotchg)'.'
            tbpand='CSGCHPD1'
        End
        Else Do
            zedlmsg='Line number mode off.'
            tbpand='CSGCHPDY'
        End
        "SETMSG MSG(ISRZ001)";Signal dis0
    End
    If zcmd='?' Then Do
        x=helpdrvr(helpdrvr '/OPEN 10');helpused='Y'
        Signal dis0
    End
    If Substr(Word(zcmd,1),1,2)='UP' Then Do
        type#='INPUT'
        zedlmsg='You can now make temporary changes to the description.'
        "SETMSG MSG(ISRZ001)";Signal dis0
    End
    msub=ztdsels
    Signal con0
mus0:
    "TBDISPL &TABLE"
con0:
    If Index(dsn,'* Top *')>0 Then Signal gnx0
    If Index(dsn,'----')>0 Then Signal gnx0
    Select
        When sel='S' Then Do
            "CONTROL DISPLAY SAVE"
            "SELECT PGM(ISRDSLST) PARM(DSL '&DSN')"
            "CONTROL DISPLAY RESTORE"
        End
        When sel='?' Then Do
            If incsgch$='N' Then Do
              zedlmsg='"'fname'" variable derived from above name(s).',
                      'Not defined by "CSGCH$".'
              "SETMSG MSG(ISRZ001)"
            End
            Else Do
              zedlmsg='"'fname'" variable.  Issue command "/F',
                      fname'" to describe this field.'
              "SETMSG MSG(ISRZ001)"
              If help$used='Y' Then xx=
              Else Do;xx='/OPEN';help$used='Y';End
              x=helpdrvr(#config xx "F(/F '"Substr(fname,1,8)"=')")
            End
            Signal dis0
        End
        Otherwise Do
            If type#='INPUT' Then Do
                If Wordpos(seq,cnotchg)=0 Then Do
                    dsn=Translate(dsn);Interpret fname'=dsn'
                    "TBMOD &TABLE"
                End
            End
        End
    End
gnx0: msub=msub-1;If msub<1 Then Signal dis0;Else Signal mus0
tb_mod: Parse ARG desc,dsn,fname,incsgch$
    seq=seq+1;"TBMOD &TABLE";Return 0

/*--------------------------------------------------------------------*/
/* Check for old versions of dataset. Delete anything more than the   */
/* setting of variable '#ver' which should be set at total -1 to allow*/
/* for new version being created.                                     */
/*--------------------------------------------------------------------*/
del_old_datasets:
    Address TSO "NEWSTACK"
    Queue '*---------------------------------------------------------*'
    If create_new=1 Then Do
    Queue '*                                                         *'
    Queue '* The following house-keeping process has been instigated *'
    Queue '* by the creation of a new changes dataset and the auto   *'
    Queue '* cleanup of past generations.                            *'
    Queue '*                                                         *'
    Queue '*                   ****                                  *'
    Queue '*                                                         *'
    End
    If #zcmd2='APPLY' | #zcmd3='APPLY' Then Nop
    Else Do
    Queue '*                                                         *'
    Queue '* Simulated run.....                                      *'
    Queue '*                                                         *'
    x='* Use comand "DEL '@ver||delr' APPLY" to affect deletion or to'
    Queue Substr(x,1,58)'*'
    Queue '* bypass simulation during housekeeping change the        *'
    Queue '* "autodel" variable setting from "SIMULATE" to "APPLY"   *'
    Queue '* in the CSGCH$ site default member.                      *'
    Queue '*                                                         *'
    Queue '*                   ****                                  *'
    Queue '*                                                         *'
    End
    Queue '* The following datasets have been deleted as they have   *'
    Queue '* passed the system defined generation limit of' #ver'.        *'
    Queue '*---------------------------------------------------------*'
    xx=$DATEMAN('E-N',,,day#-$DATEMAN('E2N',Date('e')))
    Queue 'Target Day(0) =' gen0date
    w=Substr(chgjclc,1,Length(chgjclc)-3)
    x=get_all_versions(w,'NONVSAM','.CH')
    x=get_all_versions(csd_o,'CLUSTER','.BU')
    If jobl_#/='N/A' Then Do
        x=get_all_versions(jobl_#,'NONVSAM','.BU')
        x=get_all_versions(jobl_#,'NONVSAM','.ST')
    End
    If proc_#/='N/A' Then Do
        x=get_all_versions(proc_#,'NONVSAM','.BU')
        x=get_all_versions(proc_#,'NONVSAM','.ST')
    End
    x=get_all_versions(tab_o,'NONVSAM','.BU')
    x=get_all_versions(tab_o,'NONVSAM','.ST')
    x=get_all_versions(util_o,'NONVSAM','.BU')
    x=get_all_versions(util_o,'NONVSAM','.ST')
    x=get_all_versions(auth_o,'NONVSAM','.BU')
    x=get_all_versions(auth_o,'NONVSAM','.ST')
    x=get_all_versions(parm_o,'NONVSAM','.BU')
    x=get_all_versions(parm_o,'NONVSAM','.ST')
    If disaudit='Y' Then Do
        Queue ''
        "VGET ZTEMPF"
        dd='CH'Time('s')
        Address TSO "ALLOC F("dd") DA('"ztempf"') SHR REU"
        Address TSO "EXECIO * DISKW "dd" (FINIS"
        Address TSO "DELSTACK"
        zedlmsg='The following is a list of files eligible for deletion.'
        "SETMSG MSG(ISRZ001)";"LMINIT DATAID(DATAID) DDNAME("dd")"
        "BROWSE DATAID(&DATAID)";"LMFREE DATAID(&DATAID)"
        Address TSO "FREE  F("dd")"
    End
    Else Address TSO "DELSTACK"
    Return 0

/*--------------------------------------------------------------------*/
/* Issue a LISTCAT and parse the datasets to ensure they fit pattern  */
/* and then build a list of eligible datasets for deletion. Then      */
/* delete all but the last 3.                                         */
/* Parameters:                                                        */
/*  1. File prefix.                                                   */
/*  2. File type (NONVSAM or CLUSTER).                                */
/*  3. File suffix (.BU or .ST). Rest must be numeric for validation. */
/*--------------------------------------------------------------------*/
get_all_versions: Arg filei,type,sufx
    Queue " "
    Queue "Processing '"filei||sufx"*'-"
    x=Outtrap('linei.',500,'NOCONCAT')
    Address TSO "LISTC LEV('"filei"')"
    x=Outtrap('Off')
    j=0;cj=0
    Do i=linei.0 By -1 To 1
        If word(linei.i,1)/=type Then Iterate
        dsn=Word(linei.i,3);ll=Length(filei||sufx)
        If Substr(dsn,1,ll)/=filei||sufx Then Iterate
        llq=Substr(dsn,ll+1);If Datatype(llq)/='NUM' Then Iterate
        j=j+1;If llq<=gen0date & cj=0 Then cj=j;lineo.j=dsn;llq.j=llq
    End
    If j>0 & cj=0 Then cj=1
    If delr='+' Then lim=-9999;Else lim=@ver
    If @ver>cj | cj+@ver*(-1)>j Then del_msg=;Else del_msg='Delete'
    k=0
    Do i=j By -1 To 1
        gen=cj-i
        If gen<=@ver & gen>=lim Then Do
            xtra=del_msg;k=k+1;lined.k=lineo.i
        End
        Else xtra=
        Queue Right(j-i+1,3)')' lineo.i Substr('Gen('gen')',1,9) xtra
    End
    If del_msg='' Then Do
        Queue "Generation '"@ver"' does not exist. Nothing to delete."
        Return 0
    End
    If k=0 Then Do
        Queue "Generation '"@ver"' does not exist. Nothing to delete."
        Return 0
    End
    Queue 'Deleting from' @ver 'to' @ver-k+1'.'
    msgx=Msg('Off')
    Do i=1 To k
        If #zcmd2='APPLY' | #zcmd3='APPLY' Then,
        Address TSO "DELETE '"lined.i"'"
    End
    x=Msg(msgx)
    Return 0

/*--------------------------------------------------------------------*/
/* On first creation of the change dataset:                           */
/*  This section will do an 'ASVT/ESVTE' MVS control block navigation */
/*  to check which CICS region is executing. It will identify         */
/*  production and development regions using 'CPRD' and 'CDEV' prefix */
/*  respectively. It then sorts them numerically and present them     */
/*  in one field in the format of Pnnn,Pnnn,....                      */
/*  Any valid non executing CICS names will have to be manually       */
/*  entered.                                                          */
/* On subsequent entry:                                               */
/*  The region list will be built from any $LP* members for the first */
/*  region only.                                                      */
/*--------------------------------------------------------------------*/
get_cics_regions: Arg file
    If file/='' Then x=Listdsi("'"file"' DIRECTORY NORECALL SMSINFO")
    Else x=8
    If sysreason=30 Then x=0
    If x=0 Then Do
        "LMINIT DATAID(DATA1) DATASET('&file') "
        "LMOPEN DATAID(&DATA1) OPTION(INPUT)"
        memb='$L';prd=
        Do While rc=0
            "LMMLIST DATAID(&DATA1) OPTION(LIST) MEMBER(MEMB) STATS(NO)"
            If rc/=0 Then Leave
            If Substr(memb,1,2)>'$L' Then Leave
            reg=Substr(memb,3,Length(memb)-4)
            Interpret "reg="#config"('REGION' reg 'E')','"
            If reg/='' Then If Index(prd,reg)=0 Then prd=prd||reg
        End
        "LMMLIST DATAID(&DATA1) OPTION(FREE)"
        "LMCLOSE DATAID(&DATA1)";"LMFREE  DATAID(&DATA1)"
        If prd/='' Then Do
            regions=Substr(prd,1,Length(prd)-1)
            If Length(regions)>159 Then regionp=Substr(Regions,1,154)'+'
            Else regionp=regions
            chgregs=regions
            Return 0
        End
    End

    cvt=Storage(10,4);asvt=Storage(d2x(c2d(cvt)+x2d(22c)),4)
    ascbmax=c2d(Storage(d2x(c2d(asvt)+x2d(204)),4))
    xf7='7F'X                               /* Active @ mask          */
    x_r_x=regnmask;regn=
    #tr=Trace('o')
    Do While x_r_x/=''
        asve@=d2x(c2d(asvt)+x2d(210));asve=Storage(asve@,4)
        r_list=
        Parse VAR x_r_x mask x_r_x
        aster1=Index(mask,'*')
        If aster1>0 Then aster2=Index(mask,'*',aster1+1);Else aster2=0
        Select
            When aster1=0 Then m_type=4
            When aster2=0 Then Do
                If aster1=1 Then Do
                    m_type=3;mask=Substr(mask,2)
                End
                Else Do
                    m_type=1;mask=Substr(mask,1,Length(mask)-1)
                End
            End
            Otherwise Do
                m_type=2;Parse VAR mask '*' mask '*' .
            End
        End
        maskl=Length(mask)
        Do i=1 To ascbmax
            If Bitor(Substr(asve,1,1),xf7)=xf7 Then Do
                jbn=c2x(Storage(d2x(c2d(asve)+x2d(0AC)),4))
                If jbn=0 Then
                    jbn=c2x(Storage(d2x(c2d(asve) + x2d(0B0)),4))
                jbnm=Storage(jbn,8)
                If jbnm='INIT    ' | jbn=0 | jbnm='ASCHINT ' Then Do
                    asve@=d2x(x2d(asve@)+(4));asve=Storage(asve@,4)
                    Iterate
                End
                xx=match_reg_mask()
                If xx/='' Then r_list=r_list xx
            End
            asve@=d2x(x2d(asve@)+(4));asve=Storage(asve@,4)
        End
        If r_list/='' Then x=Sort_regions(r_list)
    End
    x=Trace(#tr)
    If regn/='' Then regions=Substr(regn,1,Length(regn)-1);Else regions=
    regionp=regions
    If Length(regions)>159 Then Do
        regionp=Translate(regionp,' ',',')
        regionp=Space($Wordat(regionp,158,'L'),1,',')'+'
    End
    chgregs=regions
    Return 0

match_reg_mask:
    rjn=;jbnm=Strip(jbnm)
    Select
        When m_type=1 Then,                 /* Pattern CICS*          */
            If Substr(Strip(jbnm),1,maskl)=mask Then rjn=jbnm
        When m_type=2 Then,                 /* Pattern *CICS*         */
            If Index(jbnm,mask)>0 Then rjn=jbnm
        When m_type=3 Then,                 /* Pattern *CICS          */
            If Substr(Strip(jbnm),Length(jbnm)-maskl+1)=mask Then rjn=jbnm
        Otherwise,                          /* Pattern CICS           */
            If Strip(jbnm)=mask Then rjn=jbnm
    End
    If rjn/='' & Wordpos(rjn,regnignr)>0 Then rjn=
    Return Strip(rjn)

/*--------------------------------------------------------------------*/
/*  Sort regions using a simple bubble sort process.                  */
/*--------------------------------------------------------------------*/
Sort_REGIONS: Arg xxx
    Do i=1 To 9999
        Parse VAR xxx v.i xxx;If xxx='' Then Leave
    End
    Do l=1 to i-1
        swap=0
        Do j=1 to i-l
            k=j+1
            If v.j>v.k Then Do
                swap=1;x=v.j;v.j=v.k;v.k=x
            End
        End
        If swap=0 Then Leave
    End
    Do l=1 to i;regn=regn||v.l',';End
    Return yyy

/*--------------------------------------------------------------------*/
/*  Member selections for:                                            */
/*    Backout processing. Built from members in the staging dataset.  */
/*    Control-M processing. Built from *IM members in the changes     */
/*      dataset.                                                      */
/*--------------------------------------------------------------------*/
member_list_select: Arg files,process,ptype
    x=Listdsi("'"files"' DIRECTORY NORECALL SMSINFO")
    If sysreason=30 Then x=0
    If x/=0 | Datatype(sysmembers)/='NUM' | sysmembers=0 Then Do
        Select
            When process='SELECT' Then Do
                If Datatype(sysusedpages)/='NUM' &,
                   Index(comp_PDS,Substr(member,2))>0 Then,
                    Queue "  COPY INDD=((OUT1,R)),OUTDD=OUT1"
                Queue "* COPY INDD=((IN1,R)),OUTDD=OUT1"
                Queue "* No members in dataset '"files"'."
                Queue "*    Cannot generate members selection list."
                Queue "* SELECT MEMBER=........"
            End
            When process='CTRLM' Then Do
                Queue "* No members in dataset '"files"'."
                Queue "*    Cannot generate members selection list."
                Queue '//*S1       EXEC SUBJOB,MEMBER=....'
            End
            Otherwise NOP
        End
        Return 0
    End

    Select
        When process='SELECT' Then Do
            If Datatype(sysusedpages)='CHAR' &,
               Index(comp_PDS,Substr(member,2))>0 Then,
                Queue "  COPY INDD=((OUT1,R)),OUTDD=OUT1"
            Queue "  COPY INDD=((IN1,R)),OUTDD=OUT1"
            intdata='Queue "  SELECT MEMBER="memb';meml='*'
        End
        When process='CTRLM' Then Do
            intdata='Queue "//S"st#"     EXEC SUBJOB,MEMBER="memb'
            If chgno='' Then meml='*IM';Else meml=ptype'*'
        End
        When process='CONCAT' Then Do
            intdata='m_list=m_list memb'
            meml='*'
        End
        Otherwise NOP
    End

    "LMINIT DATAID(DATA1) DATASET('&FILES') "
    "LMOPEN DATAID(&DATA1) OPTION(INPUT)"
    memb=;st#=0
    Do While rc=0
        "LMMLIST DATAID(&DATA1) OPTION(LIST) MEMBER(MEMB) STATS(NO)"
        If rc/=0 Then Leave
        If conscmdi/='Y' & Substr(memb,2,1)='O' Then Iterate
        Select
            When meml='*' Then use=1
            When Substr(meml,1,1)='*' Then Do
                mask=Substr(meml,2);maskl=Length(mask)
                If Substr(memb,Length(memb)-(maskl))=mask Then use=1
                Else use=0
            End
            When Substr(meml,2,1)='*' Then Do
                If Substr(memb,1,1)=ptype Then use=1;Else use=0
                If Substr(memb,2,1)='#'   Then use=0
            End
            Otherwise use=0
        End
        If use Then Do
            st#=st#+1;Interpret intdata
        End
    End
/*  If process='CTRLM' Then Do                                        */
/*      memb='$CSDOC'ptype                                            */
/*      If Sysdsn("'"files"($CSDOC"ptype")'")='OK' Then Do            */
/*          st#=st#+1;Interpret intdata                               */
/*      End                                                           */
/*  End                                                               */
    "LMMLIST DATAID(&DATA1) OPTION(FREE)"
    "LMCLOSE DATAID(&DATA1)"
    "LMFREE  DATAID(&DATA1)"
    Return 0

/*--------------------------------------------------------------------*/
/*  Process each flag to see if any specifid requirement              */
/*--------------------------------------------------------------------*/
process_HK_flags:
    p_l=1
    Select
        When csdbu='O' Then dsl=csd_o
        When csdbu='E' Then dsl=csd_u
        When csdbu='L' Then dsl=csd_o
        When csdbu='*' Then dsl=csd_w
        When csdst='O' Then dsl=csd_o
        When csdst='E' Then dsl=csd_s
        When csdst='L' Then dsl=csd_o
        When csdst='*' Then dsl=csd_w
        Otherwise p_l=0
    End
    If p_l Then Do
        "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
        retscr1='Y';csdst=actn;csdbu=actn
    End
/*--------------------------------------------------------------------*/
/* Generate JCL to k of code when SIT overide for DFHCSD is active &  */
/* You do not wish to emulate CSD updates.                            */
/* With SIP use emulation may be redundant as update is to the        */
/* staging and not active.                                            */
/* However, you may wish to keep emulation for peer review re-runs.   */
/*--------------------------------------------------------------------*/
    If csdim='T' Then Do
        csdim=;retscr1='Y'
/*If csdsip='N' Then xxx='$CSDBU';Else xxx='$CSDST'                   */
If csdsip='N' Then xxx='$CU@'csdr#;Else xxx='$CS@'csdr#
        If Sysdsn("'"chgjcl"("xxx")'")/='OK' Then Do
            zedlmsg='Cannot "T" until member 'xxx'* has been created.'
            "SETMSG MSG(ISRZ001)";csr1='CSDIM'
            Return 0
        End
If csdsip='N' Then member='IC'||chgnot;Else member='PC'||chgnot
        If Sysdsn("'"chgjcl"("member")'")/='OK' Then Do
            zedlmsg='Cannot "T" until member' member 'has been created.'
            "SETMSG MSG(ISRZ001)";csr1='CSDIM'
            Return 0
        End
        Address TSO "ALLOC DD("ddj") DS('"chgjcl"("xxx")') SHR REU"
        Address TSO "EXECIO * DISKR" ddj "(STEM linei. FINIS"
If csdsip='N' Then Do
    #csd_s=csd_s;#csd_u=csd_u;#csd_o=csd_o;csd_s=csd_u;#csd_#=csd_#
End
        Parse VAR csd_s . '.' . '.' p2
        my_csd=chghlqC'.'userid'.'p2
        Parse VAR linei.1 . linei.1
        linei.1='$CSDTSTI' linei.1
        j=0
        Do i=1 To linei.0
            If Strip(linei.i)='//' Then Leave
            j=j+1
            If Index(linei.i,csd_s)>0 &,
               Substr(linei.i,1,3)/='//*' Then lineo.j=,
                $cstring(linei.i,csd_s,my_csd)
            Else lineo.j=linei.i
        End
        linei.=
        Address TSO "ALLOC DD("ddj") DS('"chgjcl"("member")') SHR REU"
        Address TSO "EXECIO * DISKR" ddj "(STEM linei. FINIS"
If csdsip='N' Then csd_s=csd_o
        Do i=3 To linei.0
            j=j+1
            If Index(linei.i,csd_s)>0 &,
               Substr(linei.i,1,3)/='//*' Then lineo.j=,
                $cstring(linei.i,csd_s,my_csd,,,'TRACE')
            Else lineo.j=linei.i
        End
If csdsip='N' Then csd_s=#csd_s
        Address TSO "ALLOC DD("ddj") DS('"chgjcl"($CSDTSTI)') SHR REU"
        Address TSO "EXECIO * DISKW" ddj "(STEM lineo. FINIS"
        Address TSO "FREE DD("ddj")"
        "ISPEXEC VPUT (chghlqC) SHARED"
        Interpret "x=action_dataset('E',chgjcl'($CSDTSTI)','Macro_2')"
        csdup=actn
    End

/*--------------------------------------------------------------------*/
/* Generate CSD compare JCL.                                          */
/*--------------------------------------------------------------------*/
    If csdup='B' | csdim='B' Then Do
        retscr1='Y'
get_csd_updates:
        If csdup='B' | csdim='B' Then Do
            xx='B';csr1='CSDUP'
        End
        Else Do
            xx='J';csr1='CSDOC'
        End
        If chgno='' Then Do
            zedlmsg='Cannot "'xx'" without a task no. Enter "TASK#" on',
                    'the command line.'
            "SETMSG MSG(ISRZ001)"
            Return 4
        End
/*      If csdsip='N' Then xxx='$CSDBU';Else xxx='$CSDST'             */
        If csdsip='N' Then xxx='$CU@'csdr#;Else xxx='$CS@'csdr#
        If Sysdsn("'"chgjcl"("xxx")'")/='OK' Then Do
            zedlmsg='Cannot "'xx'" until member 'xxx'* has been created.'
            "SETMSG MSG(ISRZ001)"
            Return 4
        End
        If csdsip='N' Then xxx='IC'||chgnot;Else xxx='PC'||chgnot
        yyy='update'
        If csdsip='N' Then Do
            #csd_s=csd_s;#csd_u=csd_u;#csd_o=csd_o;csd_s=csd_u
            xxx='IC'||chgnot;yyy='implement'
        End
        csdupmem=chgjcl"("xxx")"
        If Sysdsn("'"csdupmem"'")/='OK' Then Do
            zedlmsg='Cannot "'xx'" until 'yyy' member' xxx,
                    'has been created.'
            "SETMSG MSG(ISRZ001)"
            Return 4
        End
/*--------------------------------------------------------------------*/
/* Process the CSD update job and extract the SYSIN data and          */
/* identify any SYSIN DD and extarct the data from them.              */
/*--------------------------------------------------------------------*/
        list1=;group1=
        x=get_sysin_csd_update(chgjcl"("xxx")")
        sindsn=1
        Do i=1 To linei.0
            If Substr(linei.i,1,1)/='/' Then Iterate
            If Substr(linei.i,3,1)='*' Then Iterate
            If Index(linei.i,'PGM=DFHCSDUP')>0 Then Do
                sindsn=2;Iterate
            End
            If sindsn='1' Then Iterate
            If sindsn='2' Then Do
                If Word(linei.i,1)='//SYSIN' Then sindsn=;Else Iterate
            End
            Parse VAR linei.i 'DSN=' dsn
            If dsn='' | Substr(dsn,1,1)='&' Then Iterate
            Parse VAR dsn dsn ','
            sindsn=sindsn dsn
        End
        Do While sindsn/=''
            Parse VAR sindsn yyy sindsn
            If Sysdsn("'"yyy"'")/='OK' Then Do
                Parse VAR csdupmem '(' xxx ')'
                zedlmsg="SYSIN reference '"yyy"' in job" xxx,
                        "not found. Please remove or comment out and",
                        "re-request operation."
                "SETMSG MSG(ISRZ001)"
                Return 4
            End
            x=get_sysin_csd_update(yyy)
        End
        If group1/='' Then group1=Substr(group1,1,Length(group1)-1)
        If csdup/='B' Then Return 0
        If list1/='' Then list1=Substr(list1,1,Length(list1)-1)
/*--------------------------------------------------------------------*/
        #csdst="'"csd_s"'";#csdor="'"csd_o"'"
        #list1=list1;#group1=group1
        zedlmsg="Change the list/group to desired values."
        "SETMSG MSG(ISRZ001)"
        If extmacs='N' Then extmacs=
        rc=4;csr1=
        Do While rc=4
            zcmd=
            "DISPLAY PANEL(CSGCHPLG) CURSOR(&CSR1)"
            If rc=8 Then Leave
            If zcmd='?' Then Do
                x=helpdrvr(helpdrvr '/OPEN CC');helpused='Y'
                rc=4
            End
            If upview='Y' Then Do
                Interpret "x=action_dataset('V',csdupmem)"
                rc=4
            End
            If chgxmst/='' |   chgxmor/='' Then,
            If chgxmor/='' Then Do
                xxx=chgxmor
                Do while xxx/=''
                    Parse var xxx xx ',' xxx
                    If Sysdsn("'"sysexec"("xx")'")/='OK' Then Do
                        zedlmsg='Macro "'xx'" not found in' "'"sysexec"'.",
                                "Please correct."
                        "SETMSG MSG(ISRZ001)"
                        xxx=;rc=4;csr1='chgxmor'
                    End
                End
            End
            If chgxmst/='' Then Do
                xxx=chgxmst
                Do while xxx/=''
                    Parse var xxx xx ',' xxx
                    If Sysdsn("'"sysexec"("xx")'")/='OK' Then Do
                        zedlmsg='Macro "'xx'" not found in' "'"sysexec"'.",
                                "Please correct."
                        "SETMSG MSG(ISRZ001)"
                        xxx=;rc=4;csr1='chgxmst'
                    End
                End
            End
        End
        If rc=0 Then Do
            member='$CSDCOMP'
            Call build_csd_compare
            Call output_jcl
            Interpret "x=action_dataset('E',chgjcl'($CSDCOMP)','Macro_3')"
        End
        csdup=actn
    End

/*--------------------------------------------------------------------*/
/* Delete this block of code when SIT overide for DFHCSD is active &  */
/* You do not wish to emulate CSD updates.                            */
/* With SIP use emulation may be redundant as update is to the        */
/* staging and not active.                                            */
/* However, you may wish to keep emulation for peer review re-runs.   */
/*--------------------------------------------------------------------*/
    If csdbo='T' Then Do
        retscr1='Y'
        member='BC'||chgnot
        If Sysdsn("'"chgjcl"("member")'")/='OK' Then Do
            zedlmsg='Cannot "T" until member' member 'has been created.'
            "SETMSG MSG(ISRZ001)";csr1='CSDBO'
            Return 0
        End
        Parse VAR csd_u . '.' . '.' p2
        my_csd=chghlqC'.'userid'.'p2
        If Sysdsn("'"my_csd"'")/='OK' Then Do
End                                         /* To bypass veryfying    */
If 'OK'/='OK' Then Do                       /* "my_csd"               */
            zedlmsg='You need to run the "$CSDTSTI" job before this',
                    "one to create and update '"my_csd"' dataset."
            "SETMSG MSG(ISRZ001)";csr1='CSDBO'
            Return 0
        End
        Address TSO "ALLOC DD("ddj") DS('"chgjcl"("member")') SHR REU"
        Address TSO "EXECIO * DISKR" ddj "(STEM linei. FINIS"
        Parse VAR linei.1 . linei.1
        linei.1='$CSDTSTB' linei.1
        j=0
        Do i=1 To linei.0
            If Strip(linei.i)='//' Then Leave
            If Strip(linei.i,'T')='     ALTER   ' csd_o '-' Then Do
                zedlmsg='Cannot test rename backout procedures.'
                "SETMSG MSG(ISRZ001)";csr1='CSDUP'
                Return 0
            End
            j=j+1
            If Index(linei.i,csd_o)>0 &,
               Substr(linei.i,1,3)/='//*' Then Do
                If Index(linei.i,csd_o"'")>0 Then,
                    lineo.j="// PARM="Substr("'* CSD file: ''" ||,
                            my_csd"''.",1,61)"*'"
                Else lineo.j=$cstring(linei.i,csd_o",",my_csd",")
            End
            Else lineo.j=linei.i
        End
        Address TSO "ALLOC DD("ddj") DS('"chgjcl"($CSDTSTB)') SHR REU"
        Address TSO "EXECIO * DISKW" ddj "(STEM lineo. FINIS"
        Address TSO "FREE DD("ddj")"
        "ISPEXEC VPUT (chghlqC) SHARED"
        Interpret "x=action_dataset('E',chgjcl'($CSDTSTB)','Macro_2')"
        csdup=actn
    End

/*--------------------------------------------------------------------*/
    string=jcltyp 'LOAD'
    Do While string/=''
        Parse VAR string type string
        x=process_value1(type)
    End

    p_l='Y';dsl=loadlib
    Select
        When loadbu='O' Then NOP
        When loadbu='E' | loadbu='D' Then Do
            If loadbu='D' Then Do
                zedlmsg='Enter "D" against dataset(s) to be deleted.'
                "SETMSG MSG(ISRZ001)"
            End
            dsl=dsl'.BU'chgdate
        End
        Otherwise p_l='N'
    End
    If p_l='Y' Then Do
        "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
        retscr1='Y';loadbu=actn
    End
    If loadst='E' | loadst='D' Then Do
        If loadst='D' Then Do
            zedlmsg='Enter "D" against dataset(s) to be deleted.'
            "SETMSG MSG(ISRZ001)"
        End
        dsl=dsl'.ST'chgdate
        "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
        retscr1='Y';loadst=actn
    End
    If loadst='O' Then Do
        dsl=load_a
        "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
        retscr1='Y';loadst=actn
    End
    Return 0

process_value1: Arg type
    Select
/*      When Value(type'bu')='?' Then Do                              */
/*          x=helpdrvr(helpdrvr '/OPEN' type'BU');helpused='Y'        */
/*          Interpret type"bu=actn"                                   */
/*      End                                                           */
        When Value(type'bu')='O' Then Do
            Interpret "x=action_dataset('V',"type"_o)"
            retscr1='Y';Interpret type"bu=actn"
        End
        When Value(type'bu')='E' Then Do
            Interpret "x=action_dataset('V',"type"_u)"
            retscr1='Y';Interpret type"bu=actn"
        End
        When Value(type'bu')='D' Then Do
            csr2=type'BU'
            Interpret "x=delete_dataset("type"_u)"
            retscr1='Y';Interpret type"bu=actn"
        End
        When Value(type'bu')='C' Then Do
            If copyfbu/='N' Then s_f='u';Else s_f='o'
            Interpret "x=copy_members("type"_"s_f","type"_s)"
            retscr1='Y'
            If x/=0 Then Signal scr1
            Interpret type"bu=actn"
        End
        When Value(type'bu')='R' Then Do
            Interpret "x=review_dataset("type"_o,"type"_u,'"type'BU'"')"
            retscr1='Y';Interpret type"bu=actn"
        End
        When Value(type'bu')='L' | Value(type'bu')='*' Then Do
            Interpret "dsl="type"_u";Parse VAR dsl v1 '.' . '.' v2
            v2=Substr(v2,1,Length(v2)-6);dsl=v1'.*.'v2'*'
            "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
            retscr1='Y';Interpret type"bu=actn"
        End
        Otherwise NOP
    End
    Select
        When Value(type'st')='E' Then Do
            Interpret "x=action_dataset('E',"type"_s)"
            retscr1='Y';Interpret type"st=actn"
        End
        When Value(type'st')='D' Then Do
            csr2=type'ST'
            Interpret "x=delete_dataset("type"_s)"
            retscr1='Y';Interpret type"st=actn"
        End
        When Value(type'st')='R' Then Do
            Interpret "x=review_dataset("type"_s,"type"_u,'"type'ST'"')"
            retscr1='Y';Interpret type"st=actn"
        End
        When Value(type'st')='L' | Value(type'st')='*' Then Do
            Interpret "dsl="type"_s";Parse VAR dsl v1 '.' . '.' v2
            v2=Substr(v2,1,Length(v2)-6);dsl=v1'.*.'v2'*'
            "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
            retscr1='Y';Interpret type"st=actn"
        End
        When Value(type'st')='O' Then Do
            Interpret "dsl="type"_a"
            "SELECT PGM(ISRDSLST) PARM(DSL '&DSL')"
            retscr1='Y';Interpret type"st=actn"
        End
        Otherwise NOP
    End

    Return 0

/*--------------------------------------------------------------------*/
/*  Promp for reply prior to deleting dataset.                        */
/*--------------------------------------------------------------------*/
delete_dataset: Arg file
    If Sysdsn("'"file"'")/='OK' Then,
        zedlmsg="Dataset '"file"' not found. Use END PF key to bypass",
                "attempt to delete."
    Else Do
        zedlmsg="You are about to delete dataset '"file"'. Confirm by",
                "pressing [ENTER] or END to cancel."
        csr2=
    End
    itype1='OUTPUT'
    "DISPLAY PANEL(&PANEL) MSG(ISRZ001) CURSOR(&CSR2)"
    If rc=0 Then Do
        y=Msg('Off');Address TSO "DELETE '"file"'";x=Msg(y)
    End
    Return 0

/*--------------------------------------------------------------------*/
/*  Invoke Super-CE under the guise of 'Review'.                      */
/*--------------------------------------------------------------------*/
review_dataset: Arg file1,file2,v3
    If Sysdsn("'"file1"'")/='OK' Then Do
        zedlmsg="Dataset '"file1"' not found. Cannot review."
        "SETMSG MSG(ISRZ001)";csr1=v3
        Signal scr1a
    End
    super_ce='*(ISRSUPC)'
    Address TSO "ALLOC F(NEWDD) DSN('"file1"') SHR REU"
    Address TSO "ALLOC F(OLDDD) DSN('"file2"') SHR REU"
    "VGET ZTEMPF"
    If Sysdsn("'"ztempf"'")/='OK' Then Do
        ztempf=Sysvar(Syspref)'.'userid'.CHANGE.TEMP.OUTLIST'
        If Sysdsn(ztempf)/='OK' Then,
            Address TSO "ALLOC DA('"ztempf"') NEW CATALOG TRACKS",
                        "UNIT(SYSALLDA) SPACE(15,15)"
    End
    Address TSO "ALLOC F(OUTDD) DSN('"ztempf"') SHR REU"
    sysin=Sysvar(Syspref)'.'userid'.CHANGE.TEMP.SYSIN'
    Address TSO "ALLOC F(SYSIN) DSN('"sysin"') NEW CATALOG TRACKS",
                        "UNIT(SYSALLDA) SPACE(1,0) REU"
/*  Address TSO "NEWSTACK";Queue 'DELTAL,LINECMP';Queue ''            */
/*  Address TSO "EXECIO * DISKW SYSIN (FINIS";"DELSTACK"              */
/*  "ISRSUPC DELTAL,LINECMP"                                          */
    Address TSO "CALL "super_ce" 'DELTAL,LINECMP'"   /* Call Supre-CE */
    "LMINIT DATAID(DATAID) DDNAME(OUTDD)"
    "VIEW DATAID(&DATAID)"
    "LMFREE DATAID(&DATAID)"
    Address TSO "FREE F(NEWDD,OLDDD,OUTDD,SYSIN)"
    xx=Msg('Off')
    Address TSO "DELETE '"ZTEMPF"'";Address TSO "DELETE '"sysin"'"
    xx=Msg(xx)
    Return 0

/*--------------------------------------------------------------------*/
/*  Copy members selection panel.                                     */
/*  Build a member list ISPF table and present under table display    */
/*  panel CSGCHPCO to copy members from the backup to staging         */
/*  datasets.                                                         */
/*  Member selection panel permits browsing of members prior to copy. */
/*--------------------------------------------------------------------*/
copy_members: Arg ifile,ofile
    If Sysdsn("'"ifile"'")/='OK' Then Do
        zedlmsg="Dataset '"ifile"' not found. Cannot copy."
        "SETMSG MSG(ISRZ001)"
        csr1=type'BU';Interpret type"BU=''"
        Return 4
    End
    table="CH"Time('s')

/*  llq=Substr(ifile,Lastpos('.',ifile)+1)                            */
/*  hlq=Substr(ifile,1,Lastpos('.',ifile)-1)                          */
/*  ofile=hlq'.ST'Substr(llq,3)                                       */
    If Sysdsn("'"ofile"'")/='OK' Then Do
        zedlmsg="Dataset '"ofile"' not found. Cannot copy."
        "SETMSG MSG(ISRZ001)"
        csr1=type'BU';Interpret type"BU=''"
        Return 4
    End

    #tr2=Trace('o')
    "TBCREATE &TABLE KEYS(MEMBER,ZLMDATE) NAMES(",
         "ZLCDATE ZLMTIME SELCTD VERSMOD",
         "ZLCNORC ZLINORC ZLMNORC ZLUSER )",
         "REPLACE NOWRITE"

    "LMINIT DATAID(DATA1) DATASET('&IFILE') ENQ(SHR)"
    "LMOPEN DATAID(&DATA1) OPTION(INPUT)"
    member=
    Do While rc=0
        "LMMLIST DATAID(&DATA1) OPTION(LIST) MEMBER(MEMBER) STATS(YES)"
        If rc/=0 Then Leave
        If zlvers/='' Then versmod=zlvers'.'zlmod;Else versmod=
        "TBADD &TABLE"
    End
    "LMMLIST DATAID(&DATA1) OPTION(FREE)"
    "TBTOP &TABLE"
    "LMINIT DATAID(DATA2) DATASET('&OFILE') ENQ(SHR)"
    zedlmsg="Valid selections are B(rowse), V(iew) or C/S to copy."
    "SETMSG MSG(ISRZ001)"
    x=Trace(#tr2)

dis1:
    sel=
    "TBDISPL &TABLE PANEL(CSGCHPCO)"
    If rc> 4 Then Do
        "TBEND &TABLE"
        "LMCLOSE DATAID(&DATA1)";"LMFREE  DATAID(&DATA1)"
        "LMFREE  DATAID(&DATA2)"
        Return 0
    End
    Parse var zcmd cmd parm1 .
    If cmd='L' Then Do
        If parm1='' Then Do
            zedlmsg='Missing Locate parameter.'
            "SETMSG MSG(ISRZ001)";Signal dis1
        End
        "TBTOP &TABLE"
        If Index(parm1,'*')>0 Then
             member=Substr(parm1,1,Index(parm1,'*')-1)
        member=parm1'*'
        If sp='ZLMDATE,CY1,D,ZLMTIME,C,D,MEMBER,C,A' Then Do
            zlmdate=member;member='*'
            "TBSCAN &TABLE ARGLIST(ZLMDATE) CONDLIST(GE)"
        End
        Else "TBSCAN &TABLE ARGLIST(MEMBER) CONDLIST(GE)"
        Signal dis1
    End
    If cmd='SORT' | cmd='/SORT' Then Do
        Select
           When parm1='CHANGED' Then sp='ZLMDATE,CY1,D,ZLMTIME,C,D,MEMBER,C,A'
           Otherwise sp='MEMBER,C,A'
        End
        "TBSORT &TABLE FIELDS(&SP)";Signal dis1
    End
    If zcmd='COPYANY' Then Do
        copyany='Y'
        zedlmsg='Copy permited for all datasets/members.',
        "SETMSG MSG(ISRZ001)";Signal dis1
    End
    If sel='' Then Signal dis1
    msub=ztdsels
    Signal con1
mus1:
    "TBDISPL &TABLE"
con1:
    Select
        When (sel='C' | sel='S') Then Do
            If test_can_copy(member) Then Do
                "LMCOPY FROMID("data1") TODATAID("data2")",
                    "FROMMEM("member") TOMEM("member") REPLACE"
                selctd='Copied'
            End
            Else selctd='Non-CICS'
            "TBMOD &TABLE"
        End
        When (sel='B') Then Do
            "CONTROL DISPLAY SAVE"
            "BROWSE DATASET('&IFILE(&MEMBER)')"
            "CONTROL DISPLAY RESTORE"
        End
        When (sel='V') Then Do
            "CONTROL DISPLAY SAVE"
            "VIEW DATASET('&IFILE(&MEMBER)')"
            "CONTROL DISPLAY RESTORE"
        End
        Otherwise NOP
    End

gnx1:
    msub=msub-1
    If msub<1 Then Signal dis1;Else Signal mus1

/*--------------------------------------------------------------------*/
/*  Test if you can copy member.                                      */
/*--------------------------------------------------------------------*/
test_can_copy: Arg jbnm
    If copyany='Y' Then Return 1
    x_r_x=regnmask
    Do While x_r_x/=''
        Parse VAR x_r_x mask x_r_x
        aster1=Index(mask,'*')
        If aster1>0 Then aster2=Index(mask,'*',aster1+1);Else aster2=0
        Select
            When aster1=0 Then m_type=4
            When aster2=0 Then Do
                If aster1=1 Then Do
                    m_type=3;mask=Substr(mask,2)
                End
                Else Do
                    m_type=1;mask=Substr(mask,1,Length(mask)-1)
                End
            End
            Otherwise Do
                m_type=2;Parse VAR mask '*' mask '*' .
            End
        End
        maskl=Length(mask)
        If match_reg_mask()/='' Then Return 1
    End
    Return 0

/*--------------------------------------------------------------------*/
/*  Mass JCL gen flag change processing section.                      */
/*--------------------------------------------------------------------*/
set_JCL_gen_requests:
    string='CSD' jcltyp 'LOAD OPER'
#tr1=Trace('o')
    Do While string/=''
        Parse VAR string type string
        Select
            When oper='ALL' Then Do
                x=set_value1(type,'BU',act)
                x=set_value1(type,'ST',act)
                If act/='S' Then Do
                    x=set_value1(type,'IM',act)
                    x=set_value1(type,'BO',act)
                    If type='CSD' Then Do
                         csdup=act
                         csdoc=act
                    End
                End
            End
            When Substr(oper,1,2)='MI' Then Do
                acty='J'
                If type='LOAD' Then Do
                    If regions='' Then Iterate
                    Parse VAR regions xxx ',' .
                    Interpret "xxx="#config"('REGION' xxx 'T')"
                    x=set_value2('L'xxx,'BU')
                    x=set_value2('L'xxx,'ST')
                    x=set_value2('L'xxx,'IM')
                    x=set_value2('L'xxx,'BO')
                End
                x=set_value2(type,'BU')
                x=set_value2(type,'ST')
                x=set_value2(type,'IM')
                x=set_value2(type,'BO')
                x=set_value2(type,'UP')
                x=set_value2(type,'OC')
            End
            When oper='FLIP' Then Do
                x=set_value3(type,'BU',acty)
                x=set_value3(type,'ST',acty)
                x=set_value3(type,'IM',acty)
                x=set_value3(type,'BO',acty)
                x=set_value3(type,'UP',acty)
                x=set_value3(type,'OC',acty)
            End
            Otherwise x=set_value1(type,oper,act)
        End
    End
    x=Trace(#tr1)                           /* Restore trace setting  */
    If csdsip='N' Then Do
        csdst=;csdup=
    End
    Else csdbu=
    x=Trace(#tr)
    Return 0

set_value1:Arg v1,v2,v3;Interpret v1 || v2 "= '"v3"'";Return 0
set_value2:Arg v1,v2
    If v1='CSD' & (v2='ST' | v2= 'BU') Then Do
        Interpret "csdr#="#config"('CSD' chgstcn 'T')"
        If csdsip='N' Then v2='BU';Else v2='ST'
        If v2='ST' Then member='$CS@'csdr#;Else member='$CU@'csdr#;jsuf=
    End
    Else Do
        member='$'v1
        jsuf=Strip(eval_member_name(v2))
    End
    If Sysdsn("'"chgjcl"("Strip(member) || jsuf")'")/='OK' Then,
         x=set_value1(v1,v2,acty)
    Else x=set_value1(v1,v2,actn)
    member=#memb
    Return 0
set_value3:Arg v1,v2,v3
    Interpret "xx =" v1 || v2
    If xx='' Then act=v3;Else act=''
    x=set_value1(v1,v2,act)
    Return 0

/*--------------------------------------------------------------------*/
/*  Mass JCL gen flag change processing section.                      */
/*--------------------------------------------------------------------*/
get_sysin_csd_update: Arg ifile
    Address TSO "ALLOC DD("ddj") DS('"ifile"') SHR REU"
    Address TSO "EXECIO * DISKR" ddj "(STEM linei. FINIS"

    #tr=Trace('o')
    Do i=1 To linei.0
        linei.i=Strip(linei.i)
        If linei.i='//' Then Leave
        If Substr(linei.i,1,1)='/' Then Iterate
        list=;group=
        Select
            When Substr(Word(linei.i,1),1,2)='AL' |,
               Substr(Word(linei.i,1),1,3)='DEF' Then,
                Parse Value Word(linei.i,3) With '(' group ')'
/*          When Substr(Word(linei.i,1),1,3)='DEL' Then Do            */
/*              Parse VAR linei.i ' LIST(' list ')'                   */
/*              If list='' Then Parse VAR linei.i ' L(' list ')'      */
/*              Parse VAR linei.i ' GROUP(' group ')'                 */
/*              If group='' Then Parse VAR linei.i ' G(' group ')'    */
/*          End                                                       */
            When Substr(Word(linei.i,1),1,2)='AD' Then Do
                If Substr(Word(linei.i,2),1,1)='L' Then Do
                    Parse Value Word(linei.i,2) With '(' list ')'
                    Parse Value Word(linei.i,3) With '(' xxx  ')'
                End
                Else Do
                    Parse Value Word(linei.i,3) With '(' list ')'
                    Parse Value Word(linei.i,2) With '(' xxx  ')'
                End
                If csdoc='J' Then group=xxx
            End
            When Substr(Word(linei.i,1),1,2)='AP' Then Do
                Parse VAR linei.i ' T' xxx
                Parse VAR xxx '(' list ')'
            End
            When Substr(Word(linei.i,1),1,1)='R' Then Do
                Parse VAR linei.i ' L' xxx
                Parse VAR xxx '(' list ')'
            End
            When Substr(Word(linei.i,1),1,1)='C' Then Do
                Parse VAR linei.i ' T' xxx
                Parse VAR xxx '(' group ')'
            End
            Otherwise Do;list=;group=;End
        End
        list=Strip(list);group=Strip(group)
        If list/='' & Index(','list1,','list',')=0 Then,
            list1=list1 || list','
        If group/='' & Index(','group1,','group',')=0 Then,
            group1=group1||group','
    End
    x=Trace(#tr)

    Return 0

Validate_regions: Arg xxx xx
    Do While xxx/=''
        Parse VAR xxx xx ',' xxx
        If Sysdsn("'"jobl_o"("xx")'")/='OK' Then,
            Return Index(regionp',',xx',')
        If Sysdsn("'"proc_o"("xx")'")/='OK' Then,
            Return Index(regionp',',xx',')
    End
    Return 0

process_config:
    dd='EI'Time('s');c_memb="'"chgjcl"($$$CONFG)'";#msg=Msg('Off')
    Address TSO "ALLOC F("dd") DSN("c_memb") SHR REU"
    If rc=0 Then Do
        If Arg(1)='WRITE' Then Do
            Address TSO "NEWSTACK"
            Queue 'STCname:' chgstcn '     Task#.:' chgno "     Gener'n.:" gener
            Queue 'Config.:' #config
            Queue ' '
            Queue 'Regions identified in this change:'
            xxx=Space(Translate(regions,' ',','))
            Do While xxx/=''
                xx=Translate(Space($Wordat(xxx,73,'L')),',',' ')
                xxx=$Wordat(xxx,72,'T');If xxx/='' Then xx=xx','
                Queue ' 'xx
            End
            Queue ' '
            Queue ''
            Address TSO "EXECIO * DISKW "dd" (FINIS"
        End
        Else If Sysdsn("'"chgjcl"($$$CONFG)'")='OK' Then Do
            Address TSO "EXECIO * DISKR "dd" (STEM linei. FINIS)"
            If linei.0>3 Then Do
                Parse VAR linei.1 . chgstcn . chgno . chggenr .
                Parse VAR linei.2 . xx .
                If \#config_parm Then Do
                    #zedlmsg=zedlmsg
                    x=ver_and_process_config(xx)
                    zedlmsg=Strip(#zedlmsg zedlmsg)
                End
                #envt=chgenvt;#chgstcn=chgstcn;regions=
                Do i=5 To linei.0
                    regions=regions || Strip(linei.i)
                End
                If Length(regions)>159 Then regionp=Substr(Regions,1,154)'+'
                Else regionp=regions
                zedlmsg=Strip(zedlmsg "Parameters populated from '$$$CONFG'",
                        "member.")
            End
        End
        Address TSO "FREE F("dd")"
    End
    x=Msg(#msg)
    Return rc

ver_and_process_config:
        If xx/=#config Then Do
            Signal On Syntax Name inval_config
            Interpret "#x=" xx"(csd_#)"
            Signal Off Syntax
            #config=xx;x=set_vars_1a()
            zedlmsg='Config changed, now using "'#config'".'
        End
        Else zedlmsg='Using config "'#config'".'
        Return 0
inval_config:
        Signal Off Syntax
        zedlmsg='Invalid config member "'xx'" entered.'
        Return 8

