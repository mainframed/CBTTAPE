         MACRO
&NAME    ADYN  &ACTION=INFO,                                           +
               &BASE=,                                                 +
               &BLKSIZE=,                                              +
               &BUFNO=,                                                +
               &CCP=YES,                                               +
               &COPIES=,                                               +
               &DATA=,                                                 +
               &DD=,                                                   +
               &DDC=,                                                  +
               &DDR=NO,                                                +
               &DEST=,                                                 +
               &DISP=,                                                 +
               &DSN=,                                                  +
               &DSNR=NO,                                               +
               &DSORG=,                                                +
               &ERROR=,                                                +
               &FCB=,                                                  +
               &HELP=NO,                                               +
               &LIST=YES,                                              +
               &LRECL=,                                                +
               &MEMBER=,                                               +
               &MF=,                                                   +
               &PARMT=PARM,                                            +
               &PDUMP=NO,                                              +
               &PDUMPX=,                                               +
               &PERMA=YES,                                             +
               &RECFM=,                                                +
               &REGR=YES,                                              +
               &REUSE=NO,                                              +
               &RLSE=,                                                 +
               &R1=R1,                                                 +
               &R4=R4,                                                 +
               &R5=R5,                                                 +
               &R6=R6,                                                 +
               &R7=R7,                                                 +
               &SPACE=,                                                +
               &SYSOUT=,                                               +
               &UCLOSE=NO,                                             +
               &UNIT=,                                                 +
               &VOLR=NO,                                               +
               &VOLSER=
*--------------------------START OF ADYN------------------------------*
&NAME    DS    0H
         PUSH  PRINT
         AIF   ('&LIST' NE 'NO').A$XX
         PRINT NOGEN
.A$XX    ANOP
         AIF   ('&HELP' EQ 'YES').A$HELP
*---------------------------------------------------------------------*
* For a more comprehensive description of the 'ADYN' parameters and   *
* use pass parameter 'HELP=YES'.                                      *
*---------------------------------------------------------------------*
         AGO .A$HELPE
.A$HELP  ANOP
***********************************************************************
*                                                                     *
* DYNAMIC ALLOCATION MACRO.      Written by A. Kara.                  *
* -------------------------                                           *
*           N O T E - N O T E - N O T E - N O T E - N O T E           *
*                                                                     *
*   This routine saves and uses the following general registers:      *
*      R1, R4, R5, R6, R7, R14 and R15.                               *
*   If any of these registers are used as base registers or anchors   *
*   for the DSECT containing the DATA format of the macro (if used),  *
*   either substitute with an unused one (refer parameter 'Rn') or do *
*   not use this macro.                                               *
*                                                                     *
*   This macro is only applicable to DASD and cannot be used for      *
*   tapes.                                                            *
*                                                                     *
*---------------------------------------------------------------------*
* Macro to generate code to dynamically Allocate/Info/Delete/         *
*  Unallocate|Free/Deconcatenate/Concatenate/Reallocate               *
*                                                                     *
*   Parameters:                                                       *
*       1. ACTION  - valid actions are:                               *
*                    'Info'    - advise if dataset is allocated.      *
*                                Requires the following minimum       *
*                                parameters:                          *
*                                  DD and DSN.                        *
*                    'Alloc'   - allocate datest (basically pass jcl  *
*                                format parameters).                  *
*                                To reallocate, pass parameter of     *
*                                REUSE=YES.                           *
*                    'Unalloc'/'Free'/'DEConc'                        *
*                              - any one of these command will        *
*                                unallocate the dataset/concatenations*
*                    'DELete'  - delete allocates the DSN with        *
*                                'DISP=(OLD,DELETE,DELETE)' then frees*
*                                it.                                  *
*                    'Conc'    - concatenates the dd name defined on  *
*                                the 'DDC' parameter to the 'DD' parm.*
*                                                                     *
*       2. BASE    - Register to be used as a base register for the   *
*                    SVC 99 DSECT 'S99RBP'. This register must be     *
*                    loaded with the address of the area where the    *
*                    SVC 99 parameter list may be built. Also used to *
*                    invoke the 'DYNALLOC' routine automatically.     *
*                    (Do not enclose in brackets.)                    *
*                    If the base parameter is not passed, the         *
*                    following will need to be explicitly coded:      *
*                    1. Before the invocation of the 'ADYN' macro:    *
*                                                                     *
*                         USING S99RBP,Rn  establish addresability    *
*                                                                     *
*                    2. On return from the macro:                     *
*                                                                     *
*                         LR    R1,Rn  req blk ptr in R1 for dynalloc *
*                                      (both Rn must be same register)*
*                         DYNALLOC                                    *
*                                                                     *
*       3. BLKSIZE - Block size. (Same restrictions as 'LRECL').      *
*                                                                     *
*       4. CCP     - Wheteher to make concatenation permanent.        *
*                    Valid values are YES/NO with YES as default.     *
*                                                                     *
*       5. COPIES  - Number of copies to print (for SYSOUT DD's)      *
*                                                                     *
*       6. DATA    - Valid values are 'VARiable'/'CONstant'/'IBM'.    *
*                    Set up the data fields if you use the parameter  *
*                    'PARMT=DATA' in your program:                    *
*                    Set to 'VARiable' if you want a map of the data  *
*                    fields used for variable parameter passing. This *
*                    is required in your getmained DSECT for re-      *
*                    entrant programs.                                *
*                    You may initialise this area by coding a macro   *
*                    with 'DATA=CONstant' in your constant data area  *
*                    and on the macro pass all the parameters as      *
*                    though you were coding a macro with 'PARMT=PARM' *
*                    and moving it over the variable part. The max    *
*                    length of the data is 123 bytes.  If the program *
*                    is not re-entrant you only need to code the macro*
*                    with the parameter of 'DATA=VARiable'.           *
*                    In all cases supply a macro with 'DATA=IBM' to   *
*                    define the IBM required macros. If this is not   *
*                    defined in your program, you must explicitly     *
*                    define the following ibm macros in your program  *
*                          'IEFZB4D0'                                 *
*                          'IEFZB4D2'                                 *
*                    There should only be 1 macro with DATA=IBM/VAR   *
*                    however you may have as many DATA=CON as you     *
*                    like. DATA=IBM/VAR generate labels while 'CON'   *
*                    does not.                                        *
*                                                                     *
*       7. DD      - DD name to be allocated. In case of a 'Conc'     *
*                    action, concatenate the 'DDC' parm to this.      *
*                    If parameter 'DDR=YES' is used with 'PARMT=PARM' *
*                    this paramater must point to a variable name in  *
*                    the data area.                                   *
*                                    - or -                           *
*                    DD=(varname) if the DDname is to be taken from   *
*                    a variable.                                      *
*                    For DDR=Yes, allign the DD variable on a full-   *
*                    word boundary to eliminate allignament warning   *
*                    assembly messages.                               *
*                                                                     *
*       8. DDC     - DD name to concatenate to DD name with 'Conc'.   *
*                                                                     *
*       9. DDR     - DD name to be returned and placed in the variable*
*                    specified for the 'DD' parameter after an        *
*                    'Alloc' request without a DD parm. Set to either *
*                    YSE/NO ('NO' is the default).                    *
*                    If 'PARMT=DATA' is used, the DD name is returned *
*                    in the variable 'YDD' which would have been      *
*                    defined by the ADYN macro with 'PARMT=VAR'.      *
*      10. DEST    - Printer-id destination with 'SYSOUT'             *
*                                                                     *
*      11. DISP    - Standard JCL type DISP parameter, eg.            *
*                    'DISP=(NEW,CATLG,DELETE)'                        *
*                    (default of 'OLD' for 'Allocate' action.)        *
*                    For new dataset allocation without a 'DSN='      *
*                    but rather a 'DSNR=' parameter, the 2nd. and 3rd.*
*                    disposition parameter will be automatically      *
*                    changed to '(....,DELETE,DELETE)'.               *
*                                                                     *
*      12. DSN     - DSNAME (unquoted of course) or '*' for terminal. *
*                                    - or -                           *
*                    Variable name to return the DSN name in, after an*
*                    'Info' request. (If 'PARMT=DATA' is used the DSN *
*                    will be returned in the variable 'YDSN' which    *
*                    would have been defined by the ADYN macro with   *
*                    'PARMT=VAR'.)                                    *
*                                    - or -                           *
*                    If the action is ALLOC and the dataset name is   *
*                    stored in a variable and PARMT=PARM is required, *
*                    indicate the variable's name by specifying       *
*                    'DSN=(varname)'.                                 *
*                    NOTE - This variable must be specified if the    *
*                    'DSNR=Yes' parameter is used. Use 'DSN=YDSN' for *
*                    'PARMT=VAR'.                                     *
*                    For DSNR=Yes, allign the DSN variable on a full- *
*                    word boundary to eliminate allignament warning   *
*                    assembly messages.                               *
*                                                                     *
*      13. DSNR    - DSN name to be returned and placed in the        *
*                    variable specified for the 'DSN' parameter after *
*                    an 'Alloc' request without a DSN parm. Set to    *
*                    either YES/NO ('NO' is the default).             *
*                    If 'PARMT=DATA' is used, the DSN name is returned*
*                    in the variable 'YDSN' which would have been     *
*                    defined by the ADYN macro with 'PARMT=VAR'.      *
*                    >>>>>>>>>>>>>>>>>>>> NOTE <<<<<<<<<<<<<<<<<<<<<< *
*                    Will force 'DISP=(...,DELETE,DELETE)' to prevent *
*                    allocations of datasets with variable names all  *
*                    over the place........                           *
*                    >>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<< *
*                                                                     *
*      14. ERROR   - Label to branch to in case of error. If this     *
*                    parameter is not passed you will have to code    *
*                    your own return code test:                       *
*                          LTR  R15,R15                               *
*                          BNZ  ERROR01                               *
*                                                                     *
*      15. FCB     - Forms Control Buffer image id                    *
*                                                                     *
*      16. HELP    - Set to YES/NO to include these parameter comments*
*                    into the assembly listings. The default is 'NO'. *
*                                                                     *
*      17. LIST    - Set to YES/NO to generate macro expansion.       *
*                    Default is 'YES'.                                *
*                                                                     *
*      18. LRECL   - Logical record size. As a keyword, pass as an    *
*                    integer < 32760. As data pass as a halfword.     *
*                                                                     *
*      19. MEMBER  - Member name or GDG generation. The GDG generation*
*                    must be numeric an can take the format -n, 0, n  *
*                    or +n.                                           *
*                                    - or -                           *
*                    MEMBER=(member) if the member name is to be      *
*                    taken from a variable and PARMT=PARM.            *
*                                                                     *
*      20. MF      - Macro format. Must be coded as MF=E to generate  *
*                    code and MF=L either in a GETMAINed DSECT and/or *
*                    data area. MF=L defines 16 full words as a       *
*                    register save area (will not be defined if the   *
*                    area has already been defined by a prior macro). *
*                    These 16 full words are appended to both the     *
*                    DATA=VAR/CON areas if used.                      *
*                                                                     *
*      21. PARMT   - Parameter type.                                  *
*               'PARM'    - Keyword parameters passed (default) on    *
*                           the EXEC form of the macro.               *
*               'DATA'    - Parameters passed as data from the 'ADYN' *
*                           DSECT. If parameters are passed as        *
*                           variable data, a keyword entry of 'DATA'  *
*                           is required to tell the macro to process  *
*                           that parameter from the data area (in     *
*                           this case the data area must be set up as *
*                           required).                                *
*                           (Default is 'PARM'.)                      *
*                                                                     *
*      22. PERMA   - 'Permanent allocate' attribute. Prevents         *
*                    datasets from being automatically dealocated when*
*                    closed (in on-line environments).                *
*                    valid values are YES/NO with 'YES' as default.   *
*                                                                     *
*      23. PDUMP   - Invoke the PDUMP utility just prior to issuing   *
*                    the DYNALLOC SVC.                                *
*                                                                     *
*      24. PDUMPX  - This parameter is used with the PDUMP parameter  *
*                    and you may specify an exit point address to     *
*                    branch to by entering the 'QUIT' command in      *
*                    PDUMP thereby bypassing execution of DYNALLOC.   *
*                                                                     *
*      25. RECFM   - Record format.                                   *
*                                                                     *
*      26. REGR    - Set to YES/NO to restore registers on return     *
*                    from macro, default is 'YES'.                    *
*                    (Refer note "A" below.)                          *
*                                                                     *
*      27. REUSE   - Use this parameter if you wany to reallocate the *
*                    DD name without having to free it.  The macro    *
*                    will generate the Free statements prior to       *
*                    Allocation. Set to YES/NO ('NO' is the default). *
*                                                                     *
*      28. RLSE    - Release unused space indicator. Not required for *
*                    keyword parameters as would be passed on the     *
*                    SPACE= keyword. However, is required if data     *
*                    passed as there is no equivalent data area.      *
*                    Valid values are YES/NO with 'NO' as default.    *
*                                                                     *
*      29. Rn      - Substitute specified register for the nominated  *
*                    register in this routine. Registers that may be  *
*                    substituted are:                                 *
*                       R1, R4, R5, R6 and R7.                        *
*                    NOTE - You may use R14 and R15 as substitute     *
*                           registers.                                *
*                                                                     *
*      30. SPACE   - Standard JCL type space parameter, eg.           *
*                    'SPACE=(TRK,(2,2,1),RLSE)'                       *
*                    NOTE - In DATA format of the macro, RLSE is      *
*                           ignored and you must specify the RLSE=YES *
*                           paremeter.                                *
*                                                                     *
*      31. SYSOUT  - SYSOUT class and writer-name:                    *
*                    eg. SYSOUT=X, SYSOUT=(A,INTRDR),                 *
*                        SYSOUT=(A,FREDWRTR)                          *
*                                                                     *
*      32. UCLOSE  - Unalloc dataset on closing. If this option is to *
*                    be effective, it must be coded as UCLOSE=YES for *
*                    both types of parameter passing as there is no   *
*                    equivalent data area.                            *
*                    Valid values are YES/NO with 'NO' as default.    *
*                                                                     *
*      33. UNIT    - Device unit type. Any valid device unit as would *
*                    be accepted on JCL.                              *
*                                                                     *
*      34. VOLSER  - Volume serial.                                   *
*                                    - or -                           *
*                    VOLSER=(volser) if the member name is to be      *
*                    taken from a variable and PARMT=PARM.            *
*                    For VOLR=Yes, allign the VOLSER variable on a    *
*                    full-word boundary to eliminate allignament      *
*                    warning assembly messages.                       *
*                                                                     *
*      35. VOLR    - VOLSER name to be returned and placed in the     *
*                    variable specified for the 'VOLSER' parameter    *
*                    after an 'Alloc' request without a VOLSER value. *
*                    Set to either YES/NO ('NO' is the default).  If  *
*                    'PARMT=DATA' is used, the VOLSER name is returned*
*                    in the variable 'YVOLSER' which would have been  *
*                    defined by the ADYN macro with 'PARMT=VAR'.      *
*                                                                     *
*   NOTES -                                                           *
*      A) Macro format parameter of 'MF=.' Is mandatory.              *
*         A macro with 'MF=L' is required in your program to generate *
*         a register save area as registers R1,R4,R5,R6,R7,R14,R15 are*
*         used in the program. All registers except R15 will be       *
*         reset on return from the macro. R15 will contain the return *
*         code from the 'DYNALLOC' routine.                           *
*                                                                     *
*      B) If parameter 'PARMT=DATA' is used:                          *
*         Must issue an 'ADYN' macro with 'DATA=VARiable'. For re-    *
*         entrant programs, suggest you initialise the data area in   *
*         your DSECT by copying over it data initialised in your      *
*         constant area from an 'ADYN' macro using 'DATA=CONstant'.   *
*                                                                     *
*      C) Must have 'DATA=IBM' to include the IBM DSECTs needed for   *
*         SVC 99.                                                     *
*                                                                     *
*      D) Space requirements:                                         *
*         Allow 300 bytes for SVC 99 parameter list, (ie. data area   *
*         pointer to by the 'BASE' parameter).                        *
*         Allow 123 bytes for both constant and variable data area    *
*         created by the 'DATA=CON/VAR' parameter. Add 64 (16 x 4)    *
*         bytes if this expansion stores the register save areas      *
*         (refer to the MF parameter).                                *
*                                                                     *
*      E) On the EXEC form of the macro, R15 contains the return code *
*         from the 'DYNALLOC' routine.  R0 contains the error code in *
*         the high 2 order bytes and the information reason code in   *
*         the low 2 order bytes.  All the other registers wiil be     *
*         reset to their initial value on entering the macro.         *
*         NOTE - Note the comment about register usage in this macro  *
*                versus your program's register usage.                *
*                                                                     *
***********************************************************************
.A$HELPE ANOP
         LCLC  &#DISP,&#DISP1,&#DISP2,&#DISP3,&#ACTION,&#PRIM,&#SECOND
         LCLC  &#RLSE,&#DSORG,&#BUFNO,&#DIRB,&#SPACET,&#DDC
         LCLC  &#MEMBER,&#DD,&#DDR,&#DSN,&#RECFM,&#LRECL,&#BLKSZ
         LCLC  &#UNIT,&#VOLSER,&#CLASS,&#WRTR,&#DEST,&#FCB,&#COPIES
         LCLC  &@DSNR,&@DDR,&#DSNR,&#DSNV,&#REUSEF
         LCLC  &#1,&#4,&#5,&#6,&#7
         LCLC  &#PERMA,&#CHDISP
         LCLC  &#VOLR,&#VOLV,&@VOLR,&VARNM
         GBLC  &REGSMC1,&REGSMC2
.*
.*--------------------------------------------------------------------*
.*
         LCLC  &INDEX,&DELLAB
.*
         LCLA  &PL,&TUS
.*--------------------------------------------------------------------*
         GBLC  &REGSAVR,&REGSMCR
         GBLB  &REGSFLG,&REGDFLG,&ADYNFL0,&ADYNFL1
         AIF   (&REGSFLG).A$RS
&REGSAVR SETC  'GB'.'&SYSNDX'.'#'
&REGSMCR SETC  'ADYN'
&REGSMC1 SETC  'ADYN'
&REGSMC2 SETC  'ADYN'
&REGSFLG SETB  1
.A$RS    ANOP
&#CHDISP SETC  'NO'
         AIF   (&ADYNFL0).A$RT
&ADYNFL0 SETB  1
.*-------------- ADYN EQUATES FOR MEANINGFULL VALUES -----------------*
$SHR     EQU X'08'
$NEW     EQU X'04'
$MOD     EQU X'02'
$OLD     EQU X'01'
$UNCATLG EQU X'01'
$CATLG   EQU X'02'
$DELETE  EQU X'04'
$KEEP    EQU X'08'
$FBA     EQU X'94'
$VBA     EQU X'54'
$FB      EQU X'90'
$VB      EQU X'50'
$U       EQU X'C0'
$F       EQU X'80'
$V       EQU X'40'
$POU     EQU X'03'
$PSU     EQU X'41'
$DAU     EQU X'21'
$PO      EQU X'02'
$PS      EQU X'40'
$DA      EQU X'20'
.A$RT    ANOP
.*--------------------------------------------------------------------*
.*  INITIALISE SYSLIST TYPE VARIABLES                                 *
.*--------------------------------------------------------------------*
&#1      SETC  '&R1.'
&#4      SETC  '&R4.'
&#5      SETC  '&R5.'
&#6      SETC  '&R6.'
&#7      SETC  '&R7.'
&#ACTION SETC  '&ACTION'
&#DISP1  SETC  '&DISP(1)'
&#DISP2  SETC  '&DISP(2)'
&#DISP3  SETC  '&DISP(3)'
         AIF   (T'&DISP EQ 'O').BYPDP3        BYPASS IF DISP OMITTED
         AIF   ('&#DISP1'(1,1) NE 'N').BYPDP3 BYPASS IF DISP NOT 'NEW'
         AIF   (T'&#DISP2 NE 'O').BYPDP2      BYP IF DISP2 PRESENT
&#DISP2  SETC  'CATLG'
.BYPDP2  ANOP
         AIF   (T'&#DISP3 NE 'O').BYPDP3      BYP IF DISP3 PRESENT
&#DISP3  SETC  'DELETE'
.BYPDP3  ANOP
&#SPACET SETC  '&SPACE(1)'
&#PRIM   SETC  '&SPACE(2,1)'
&#SECOND SETC  '&SPACE(2,2)'
&#DIRB   SETC  '&SPACE(2,3)'
&#CLASS  SETC  '&SYSOUT(1)'
&#WRTR   SETC  '&SYSOUT(2)'
&#RLSE   SETC  '&SPACE(3)'
         AIF (T'&#RLSE EQ 'O').TPARMT1     BYPASS IF NO 'RLSE' PARM
&#RLSE   SETC '&#RLSE'(1,1)                EXTRACT 1ST. CHAR
.TPARMT1 ANOP
         AIF ('&PARMT'(1,1) EQ 'P').GRELSE IF NON-VAR RLSE IN SPACE
         AIF (T'&#RLSE NE 'YES').GRELSE    BYPASS IF 'RLSE=YES' NOT REQ
&#RLSE   SETC  'R'                         SET 'RLSE' PARM
.GRELSE  ANOP
&#DSORG  SETC  '&DSORG'                    SET 'DSORG' WORK PARM
         AIF (T'&#DSORG NE 'O').DSORGE     IF DSORG PARM SUPPLIED BYP
         AIF (T'&#SPACET EQ 'O').DSORGE    IF NO SPACE TYPE BYPASS
         AIF (T'&#DIRB EQ 'O').DSORGPS     IF DIRB NOT SUPPLIED PS ORG
&#DSORG  SETC  'PO'
         AGO .DSORGE
.DSORGPS ANOP
&#DSORG  SETC  'PS'
.DSORGE  ANOP
.*-------------------------------------------------------------------*
.*     INITIALISE VARIABLES SO THEY MAY BE MANIPULATED               *
.*-------------------------------------------------------------------*
&#DD     SETC '&DD'
&#DDC    SETC '&DDC'
&#DDR    SETC '&DDR'
&#DSNR   SETC '&DSNR'
&#DSN    SETC '&DSN'
&#MEMBER SETC '&MEMBER'
&#VOLSER SETC '&VOLSER'
&#VOLR   SETC '&VOLR'
&#UNIT   SETC '&UNIT'
&#DEST   SETC '&DEST'
&#FCB    SETC '&FCB'
&#COPIES SETC '&COPIES'
&#BUFNO  SETC '&BUFNO'
&#RECFM  SETC '&RECFM'
&#LRECL  SETC '&LRECL'
&#BLKSZ  SETC '&BLKSIZE'
.*--------------------------------------------------------------------*
         AIF  (T'&DATA NE 'O').DATAMAP   GO PROCESS DATA TYPE
         AIF  ('&MF' EQ 'L').MFELIST     GO PROCESS LIST FORM
.*--------------------------------------------------------------------*
.MFEEXEC ANOP
.*--------------------------------------------------------------------*
&#PERMA  SETC '&PERMA'
         AIF ('&#ACTION'(1,1) NE 'A').BPREAL1  NOT REALLOC BYPASS'
         AIF ('&REUSE'(1,1) NE 'Y').BPREAL1    REUSE NOT REQUIRED
         AIF ('&#REUSEF' EQ 'Y').BPREAL1       REUSE RESET BYPASS
&#ACTION SETC 'FREE'
         AGO .ISFREE1                          GO FREE IT
.*--------------------------------------------------------------------*
.BPREAL1 ANOP
         AIF ('&#ACTION'(1,1) EQ 'U').ISFREE1  PROCESS 'UNALLOC'
         AIF ('&#ACTION'(1,1) NE 'F').TSTINF1 BYPASS IF NOT 'FREE'
.ISFREE1 ANOP     ENSURE ALL APPROPRIATE FIELDS ARE BLANK FOR FREE
         AIF (T'&#DD EQ 'O').LVFREE  BYPASS IF DD NOT SUPPLIED
&#DSN    SETC ''
&#DSNR   SETC 'NO'
&#MEMBER SETC ''
.LVFREE  ANOP
.* &#DD     SETC ''
.* &#DDR    SETC 'NO'
.* &#DSNR   SETC 'NO'
.* &#DSN    SETC ''
.* &#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#VOLR   SETC 'NO'
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTINF1 ANOP
         AIF ('&#ACTION'(1,1) NE 'I').TSTCON1 BYPASS IF NOT 'INFO'
.* &#DD     SETC ''
.* &#DDR    SETC 'NO'
.* &#DSNR   SETC 'NO'
.* &#VOLR   SETC 'NO'
&#ACTION SETC 'INFO'
&#DSN    SETC '&DSN'
&#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTCON1 ANOP
         AIF ('&#ACTION'(1,1) NE 'C').TSTDEC1 BYPASS IF NOT 'CONCAT'
&#ACTION SETC 'CONCAT'
&#DDC    SETC '&DDC'
&#DSN    SETC ''
&#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTDEC1 ANOP
         AIF ('&#ACTION'(1,3) NE 'DEC').TSTDLT1 BYP IF NOT 'DECONCAT'
&#ACTION SETC 'DECONCAT'
&#DDC    SETC '&DDC'
&#DSN    SETC ''
&#MEMBER SETC ''
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#RLSE   SETC ''
&#UNIT   SETC ''
&#VOLSER SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#BUFNO  SETC ''
&#DSORG  SETC ''
&#CLASS  SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#WRTR   SETC ''
&#PERMA  SETC 'NO'
         AGO .NOTDELT
.*--------------------------------------------------------------------*
.TSTDLT1 ANOP
         AIF ('&#ACTION'(1,3) NE 'DEL').NOTDELT  BYP IF NOT 'DELETE'
*---------------------------------------------------------------------*
*  FOR 'DELETE', ALLOCATING DATASET WITH A STATUS OF:                 *
*     DISP=(OLD,DELETE,DELETE)                                        *
*---------------------------------------------------------------------*
&#ACTION SETC 'ALLOC'
&#DISP1  SETC 'OLD'
&#DISP2  SETC 'DELETE'
&#DISP3  SETC 'DELETE'
&#MEMBER SETC ''
&#VOLSER SETC ''
&#DEST   SETC ''
&#FCB    SETC ''
&#COPIES SETC ''
&#SPACET SETC ''
&#PRIM   SETC ''
&#SECOND SETC ''
&#DIRB   SETC ''
&#BUFNO  SETC ''
&#UNIT   SETC ''
&#RECFM  SETC ''
&#LRECL  SETC ''
&#BLKSZ  SETC ''
&#PERMA  SETC ''
&#PERMA  SETC 'NO'
.NOTDELT ANOP
.*--------------------------------------------------------------------*
.*--------------------------------------------------------------------*
.*    EXEC FORM OF MACRO
.*--------------------------------------------------------------------*
         AIF   ('&REGR' EQ 'NO').NORSAV1 BYPASS IF REGS NOT 2 BE REST'D
         STM   R0,R14,&REGSAVR      SAVE REGISTERS
.NORSAV1 ANOP
         AIF   (T'&BASE EQ 'O').NOBASE   BYPASS IF NO 'BASE' PASSED
         USING S99RBP,&BASE         ESTABLISH ADDRESABILITY
.NOBASE  ANOP
         LA    &#4,S99RBPTR+4       POINT PAST RBPTR
         USING S99RB,&#4            EST ADDRESABILITY FOR "RB" DSECT
         ST    &#4,S99RBPTR         MAKE "RBPTR" TO "RB"
         OI    S99RBPTR,S99RBPND    TURN ON HIGH ORDER BIT OF "RBPTR"
         XC    S99RB(S99RBEND-S99RB),S99RB INITIALISE "RB" ENTIRELY
         MVI   S99RBLN,S99RBEND-S99RB      PUT LEN OF "RB" IN ITS FLD
         LA    &#5,S99RB+(S99RBEND-S99RB)  POINT 20 BYTES PAST 'RB'
         USING S99TUPL,&#5          EST ADDRESABILITY TO TEXT UNIT PTRS
         ST    &#5,S99TXTPP         INIT TEXT POINTER IN 'RB'
.*--------------------------------------------------------------------*
.*    TEST ACTION AND SET VERB ACCORDINGLY                            *
.*--------------------------------------------------------------------*
&DELLAB  SETC  'AY'.'&SYSNDX'.'E'   SET LABEL FOR DELETE ERROR BYPASS
&TUS     SETA  0                    SET UNALLOCATE # TEXT UNITS
         AIF ('&#ACTION'(1,1) NE 'A').A1DD
         MVI   S99VERB,S99VRBAL     SET VERB FOR INFO ALLOCATION
         AIF ('&#DDR'(1,1) EQ 'Y').A1DDR
         LA    &#7,DALDDNAM         SET KEY FOR DDNAME SPECIFICATION
         AGO   .A1DD
.A1DDR   ANOP
         LA    &#7,DALRTDDN         SET KEY FOR DDNAME RETURN
         AIF ('&#ACTION'(1,1) EQ 'A').A1DDR1 BYPASS IF ACTION ADD
         MNOTE 12,'DD NAME RETURN ONLY APPLICABLE TO ALLOCATIONS.'
         AGO .MEXIT
.A1DDR1  ANOP
         AIF (T'&#DD NE 'O').A1DD   BYPASS IF DD SPECIFIED
         AIF ('&PARMT'(1,1) EQ 'D').A1DD
         MNOTE 12,'DD NAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'
         AGO .MEXIT
.A1DD    ANOP
         AIF ('&#DDR'(1,1) EQ 'Y').A1DDFC DD RETURN REQUESTED
         AIF (T'&#DD EQ 'O').A1DSNR1
.A1DDFC  ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR DDNAME                                             *
.A1DSNR1 ANOP
         AIF ('&#ACTION'(1,1) EQ 'C').CONC11
         AIF ('&#ACTION'(1,1) EQ 'F').A1DSN
         AIF ('&#ACTION'(1,1) EQ 'D').A1DSN
         AIF ('&#ACTION'(1,1) EQ 'U').A1DSN
         AIF (T'&#DSN NE 'O').A1DSN  BYPASS IF DSNAME SPECIFIED
         AIF (T'&SYSOUT NE 'O').A1DSN  BYPASS IF SYSOUT SPECIFIED
         AIF ('&PARMT'(1,1) EQ 'D').A1DSN
         MNOTE 12,'DSNAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'
         AGO .MEXIT
.A1DSN   ANOP
         AIF ('&#DSNR'(1,1) EQ 'Y').A1DSNFC DSN RETURN REQUESTED
         AIF (T'&#DSN EQ 'O').A1DISP1
.A1DSNFC ANOP
&TUS     SETA  &TUS+1
*  1 TEXT UNIT FOR DSNAME                                             *
         AIF ('&#ACTION'(1,1) EQ 'I').INFO11
.A1DISP1 ANOP
         AIF (T'&#DISP1 NE 'O').A1DIS11       PROCESS IF NOT OMITTED
         AIF ('&#ACTION'(1,1) NE 'A').A1MEMBR BYPASS IF NOT ALLOCATE
         AIF (T'&#CLASS NE 'O').A1MEMBR       BYPASS IF SYSOUT CLASS
&#DISP1  SETC 'OLD'                           SET STATUS AS OLD
*        DEFAULT STATUS OF 'OLD' ASSIGNED                             *
.A1DIS11 ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR STATUS                                             *
.A1MEMBR ANOP
         AIF (T'&#MEMBER EQ 'O').A1VOLS
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR MEMBER                                             *
.A1VOLS  ANOP
         AIF ('&#VOLR'(1,1) EQ 'Y').A1VOLSR
         AIF (T'&#VOLSER EQ 'O').A1DEST
.A1VOLSR ANOP
         AIF ('&PARMT'(1,1) EQ 'D').A1VOLS1
         AIF (T'&#VOLSER NE 'O').A1VOLS1
         MNOTE 12,'VOLSER RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'
         AGO .MEXIT
.A1VOLS1 ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR VOLSER                                             *
.A1DEST  ANOP
         AIF (T'&#DEST EQ 'O').A1FCB
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR SYSOUT DESTINATION                                 *
.A1FCB   ANOP
         AIF (T'&#FCB EQ 'O').A1COPYS
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR FCB                                                *
.A1COPYS ANOP
         AIF (T'&#COPIES EQ 'O').A1T1
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR COPIES                                             *
.A1T1    ANOP
         AIF (T'&#DISP2 EQ 'O').A1DISP3
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR NORMAL DISPOSITION                                 *
.A1DISP3 ANOP
         AIF (T'&#DISP3 EQ 'O').A1BLK
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR CONDITIONAL/ABNORMAL TERMINATION                   *
.A1BLK   ANOP
         AIF (T'&#BLKSZ EQ 'O').A1LREC
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR BLKSIZE                                            *
.A1LREC  ANOP
         AIF (T'&#LRECL EQ 'O').A1RECFM
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR LRECL                                              *
.A1RECFM ANOP
         AIF (T'&#RECFM EQ 'O').A1DSORG
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR RECFM                                              *
.A1DSORG ANOP
         AIF (T'&#DSORG EQ 'O').A1SPACE
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR DSORG                                              *
.A1SPACE ANOP
         AIF (T'&#SPACET EQ 'O').A1PRIM
&TUS     SETA  &TUS+2               SET UNALLOCATE # TEXT UNITS
*  2 TEXT UNIT FOR ALLOCATION UNITS (CYL, TRK or block size)          *
.A1PRIM  ANOP
         AIF (T'&#PRIM EQ 'O').A1SECON
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR PRIMARY ALLOCATION                                 *
.A1SECON ANOP
         AIF (T'&#SECOND EQ 'O').A1DIRB
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR SECONDARY ALLOCATION                               *
.A1DIRB  ANOP
         AIF ('&#PERMA'(1,1) NE 'Y').A1PERMA
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR PERMANENT ALLOCATE ATTRIBUTE                       *
.A1PERMA ANOP
         AIF (T'&#DIRB EQ 'O').A1BUFNO
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR DIRECTORY BLOCKS                                   *
.A1BUFNO ANOP
         AIF (T'&#BUFNO EQ 'O').A1UNIT
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR BUFFER COUNT/DCB                                   *
.A1UNIT  ANOP
         AIF (T'&#UNIT NE 'O').A1UNI11   PROCESS IF NOT OMITTED
         AIF ('&#DISP1' NE 'NEW').A1WRTR BYPASS IF OMMITED AND NOT NEW
&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'
*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *
.A1UNI11 ANOP
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR DEVICE UNIT                                        *
.A1WRTR  ANOP
         AIF (T'&#WRTR EQ 'O').A1CLASS
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR SYSOUT WRITER-NAME/INTERNAL-READER                 *
.A1CLASS ANOP
         AIF (T'&#CLASS EQ 'O').A1RLSE
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR SYSOUT CLASS                                       *
.A1RLSE  ANOP
         AIF (T'&#RLSE EQ 'O').A1UCLOS
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR RLSE
.A1UCLOS ANOP
         AIF ('&#ACTION'(1,1) NE 'A').A$OPTE  BYPASS IF NOT 'ALLOACTE'
         AIF ('&UCLOSE' NE 'YES').A$OPTE
&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS
*  1 TEXT UNIT FOR UCLOSE                                             *
.A$OPTE  ANOP
         AIF ('&#ACTION'(1,1) EQ 'A').CON#000
.UNAL1   ANOP
         AIF ('&#ACTION'(1,1) EQ 'U').UNAL11
         AIF ('&#ACTION'(1,1) NE 'F').INFO1
.UNAL11  ANOP
         MVI   S99VERB,S99VRBUN     SET VERB FOR UNALLOCATION
         LA    &#7,DUNDDNAM         GET THE KEY FOR DDNAME
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR REMOVE 'IN-USE' ATTRIBUTE (UNALLOCATE)             *
.*  1 TEXT UNIT FOR UNALLOCATE ATTRIBUTE
         AGO .CON#000
.INFO1   ANOP
         AIF ('&#ACTION'(1,1) NE 'I').CONC1
.INFO11  ANOP
         MVI   S99VERB,S99VRBIN     SET VERB FOR INFO RETRIEVAL
         LA    &#7,DINDDNAM         GET THE KEY FOR DDNAME
         AIF ('&PARMT'(1,1) EQ 'P').CON#000
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR DSNAME RETURN                                      *
         AGO .CON#000
.CONC1   ANOP
         AIF ('&#ACTION'(1,1) NE 'C').DEAL1
         AIF (T'&#DDC NE 'O').CONC11
         MNOTE 12,'CONCATENATION MUST HAVE A "DDC" PARAMETER.'
         AGO .MEXIT
.CONC11  ANOP
         MVI   S99VERB,S99VRBCC     SET VERB FOR INFO CONCATENATE
         LA    &#7,DCCDDNAM         GET THE KEY FOR DDNAME
         AIF ('&CCP'(1,1) EQ 'N').CON#000
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
*  1 TEXT UNIT FOR PERMANENT CONCATENATION
         AGO .CON#000
.DEAL1   ANOP
         AIF ('&#ACTION'(1,3) NE 'DEC').CON#000
         AIF (T'&#DDC NE 'O').DEAL11
         MNOTE 12,'DECONCATENATION MUST HAVE A "DDC" PARAMETER.'
         AGO .MEXIT
.DEAL11  ANOP
&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS
         MVI   S99VERB,S99VRBDC     SET VERB FOR INFO DECONCATENATE
         LA    &#7,DDCDDNAM         GET THE KEY FOR DDNAME
.CON#000 ANOP
         LA    &#6,S99TUPL+(&TUS*4) POINT JUST PAST THE TEXT UNIT PTRS
         USING S99TUNIT,&#6         ADDRESABILITY FOR 1ST TEXT UNIT
&TUS     SETA  0                    SET TEXT UNITS PTR INCREMENT
.*-------------------------------------------------------------------*
.A2DDC   ANOP
         AIF ('&#ACTION'(1,1) NE 'C').A2DEC
*--------------------------------------------------------------------*
*   ADYN-SET UP DDNAME TO CONCATENATE                                *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,2                BECAUSE THE DSNAME KEY REQUIRES 2
         STH   &#7,S99TUNUM           PARM, STORE 2 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DDC#
         LA    &#7,8                MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         STH   &#7,S99TULNG+10      STORE TEXT UNIT LENGTH TO CONCAT
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DDN          MOVE DDNAME
         EX    &#7,MV99DDCN         MOVE DDNAME TO CONCATENATE
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         AIF ('&CCP'(1,1) EQ 'N').A$END
         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)
         LA    &#7,3(&#7)           BACK TO NORMAL LENGTH + LENGTH FLD
         AR    &#6,&#7              POINT PAST DDNAME
         AR    &#6,&#7              POINT PAST DDNAME CONCATENATION
         AGO   .A2DDC#0             EXIT PROCESS
.A2DDC#  ANOP
&PL      SETA  K'&#DD
&PLC     SETA  K'&#DDC
         LA    &#7,&PL              LENGTH OF DDNAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME
         STH   &#7,S99TULNG+&PL+2   STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#DD' MOVE DDNAME
         MVC   S99TUPAR+&PL+2(&PLC),=C'&#DDC' MOVE DDNAME TO CONCAT
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         AIF ('&CCP'(1,1) EQ 'N').A$END
         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)
         LA    &#7,&PL+2            LENGTH OF DDNAME + LENGTH FIELD
         LA    &#7,&PLC+2(&#7)      LENGTH OF DDNAME + LENGTH FIELD
         AR    &#6,&#7              POINT PAST DSNAME
.A2DDC#0 ANOP
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DCCPERMC         GET THE KEY FOR PERMANENT CONCAT
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,0                BECAUSE THE PERMCON KEY REQUIRES 0
         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD
         AGO   .A$END
.*-------------------------------------------------------------------*
.A2DEC   ANOP
         AIF ('&#ACTION'(1,3) NE 'DEC').A2DD
*--------------------------------------------------------------------*
*   ADYN-SET UP DDNAME TO DECONCATENATE                              *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DEC#
         LA    &#7,8                MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DDCN         MOVE DDNAME TO DECONCATENATE
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         AGO   .A2DEC#0             EXIT PROCESS
.A2DEC#  ANOP
&PLC     SETA  K'&#DDC
         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PLC),=C'&#DDC' MOVE DDNAME TO DECONCATENATE
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
.A2DEC#0 ANOP
         AGO   .A$END
.*-------------------------------------------------------------------*
.A2DD    ANOP
&@DDR    SETC  ''
         AIF ('&#DDR'(1,1) EQ 'Y').A2DDRIY
         AIF (T'&#DD  EQ 'O').A2DSN
         AGO   .A2DDACT
.A2DDRIY ANOP
         AIF ('&PARMT'(1,1) EQ 'P').A2DDRIP
&@DDR    SETC  'YDD'
         AGO   .A2DDACT
.A2DDRIP ANOP
&@DDR    SETC  '&#DD'
.A2DDACT ANOP
*--------------------------------------------------------------------*
*   ADYN-SET UP DDNAME                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,8                MAXIMUM LENGTH OF DATASET
         AIF ('&#DDR'(1,1) EQ 'Y').A2DDR0 IF DD RETURN REQ'D BYPASS
         AIF ('&PARMT'(1,1) EQ 'P').A2DD#
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DDN          MOVE DDNAME
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AGO   .A2DDR1
.A2DDR0  ANOP
         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS
&VARNM   SETC  '&#DD'               SET VARIABLE NAME
         AIF ('&#DD'(1,1) NE '(').NDDVAR1
&PL      SETA  K'&#DD
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
.NDDVAR1 ANOP
         ST    &#1,&VARNM           SAVE FOR LATER USE
.A2DDR1  ANOP
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2DD#0              EXIT PROCESS
.A2DD#   ANOP
&PL      SETA  K'&#DD
         AIF ('&#DD'(1,1) NE '(').NDDVAR2
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM  MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2DD#0  ANOP
.NDDVAR2 ANOP
         LA    &#7,&PL              MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#DD'
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DDNAME
.A2DD#0  ANOP
*--------------------------------------------------------------------*
*   ADYN-SET UP DSNAME                                               *
*--------------------------------------------------------------------*
.*--------------------------------------------------------------------*
.A2DSN   ANOP
         AIF ('&#ACTION'(1,1) EQ 'I').INFO2
         AIF ('&#DSN' EQ 'DUMMY').A2DUMMY
         AIF ('&#DSN' EQ '*').A2TERML
&@DSNR   SETC  ''
&#DSNV   SETC  'DALDSNAM'
         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSRIY
         AIF (T'&#DSN EQ 'O').A2MEMBR
         AGO  .A2DSACT
.A2DSRIY ANOP
&#DSNV   SETC  'DALRTDSN'
&#DISP2  SETC  'DELETE'
&#DISP3  SETC  'DELETE'
         AIF ('&PARMT'(1,1) EQ 'P').A2DSRIP
&@DSNR   SETC  'YDSN'
         AGO   .A2DSACT
.A2DSRIP ANOP
&@DSNR   SETC  '&#DSN'
.A2DSACT ANOP
.*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,&#DSNV           GET THE KEY FOR DSNAME
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,44               MAXIMUM LENGTH OF DATASET NAME
         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSNR0 IF DSN RETURN REQ'D BYPASS
         AIF ('&PARMT'(1,1) EQ 'P').A2DSN#
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DSN          MOVE DSNAME
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AGO   .A2DSNR1
.A2DSNR0 ANOP
         LA    &#1,S99TUPAR         LOAD DSNAME VARIABLE ADDRESS
&VARNM   SETC  '&#DSN'              SET VARIABLE NAME
         AIF (T'&#DSN EQ 'O').NDSNVA1
         AIF ('&#DSN'(1,1) NE '(').NDSNVA1
&PL      SETA  K'&#DSN
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
.NDSNVA1 ANOP
.*       ST    &#1,&VARNM           SAVE FOR LATER USE
         ST    &#1,&@DSNR           SAVE FOR LATER USE
.A2DSNR1 ANOP
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2DSN#0             EXIT PROCESS
.A2DSN#  ANOP
&PL      SETA  K'&#DSN
         AIF ('&#DSN'(1,1) NE '(').NDSNVA2
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2DSN#0             EXIT PROCESS
.NDSNVA2 ANOP
         MVC   S99TUPAR(&PL),=C'&#DSN'
         LA    &#7,&PL              LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2DSN#0 ANOP
         AGO   .A2MEMBR
.*--------------------------------------------------------------------*
.A2DUMMY ANOP
*--------------------------------------------------------------------*
*   ADYN-SET UP DUMMY DSNAME                                         *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALDUMMY         GET THE KEY FOR DUMMY DSNAME
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
         AGO   .A2MEMBR
.A2TERML ANOP
*--------------------------------------------------------------------*
*   ADYN-OUTPUT TO A TERMINAL FOR ON-LINE SESSIONS                   *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALTERM          GET KEY FOR TERMINAL OUTPUT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
         AGO   .A2MEMBR
.A2MEMBR ANOP
         AIF (T'&#MEMBER EQ 'O').A2VOLS
*--------------------------------------------------------------------*
*   ADYN-SET UP MEMBER                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALMEMBR         GET THE KEY FOR DSNAME
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2MEM#
         LA    &#7,8                MAXIMUM LENGTH OF MEMBER NAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99MEMB         MOVE MEMBER
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2VOLS
.A2MEM#  ANOP
&PL      SETA  K'&MEMBER
         AIF ('&MEMBER'(1,1) NE '(').NMEMVAR
&VARNM   SETC  '&MEMBER'(2,&PL-2)   SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2VOLS              EXIT PROCESS
.NMEMVAR ANOP
&PL      SETA  K'&MEMBER
         LA    &#7,&PL              MAXIMUM LENGTH OF MEMBER NAME
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&MEMBER'
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2VOLS  ANOP
         AIF ('&#VOLR'(1,1) EQ 'Y').A2VOLSF
         AIF (T'&#VOLSER EQ 'O').A2DEST
*--------------------------------------------------------------------*
*   ADYN-SET UP VOLSER                                               *
*--------------------------------------------------------------------*
.A2VOLSF ANOP
&@VOLR   SETC  ''
&#VOLV   SETC  'DALVLSER'
         AIF ('&#VOLR'(1,1) NE 'Y').A2VOACT
&#VOLV   SETC  'DALRTVOL'
.A2VORIY ANOP
         AIF ('&PARMT'(1,1) EQ 'P').A2VORIP
&@VOLR   SETC  'YVOLSER'
         AGO   .A2VOACT
.A2VORIP ANOP
&@VOLR   SETC  '&#VOL'
.A2VOACT ANOP
.*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,&#VOLV           GET THE KEY FOR VOLSER
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,6                MAXIMUM LENGTH OF DATASET NAME
         AIF ('&#DSNR'(1,1) EQ 'Y').A2VOLR0 IF VOL RETURN REQ'D BYPASS
         AIF ('&PARMT'(1,1) EQ 'P').A2VOL#
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99VOLS         MOVE VOLSER
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AGO   .A2VOLR1
.A2VOLR0 ANOP
         LA    &#1,S99TUPAR         LOAD VOLSER VARIABLE ADDRESS
&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME
         AIF (T'&#VOLSER EQ 'O').NVOLVA1
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA1
&PL      SETA  K'&#VOLSER
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
.NVOLVA1 ANOP
         ST    &#1,&@VOLR           SAVE FOR LATER USE
.A2VOLR1 ANOP
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2VOL#0             EXIT PROCESS
.A2VOL#  ANOP
&PL      SETA  K'&#VOLSER
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA2
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME
         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME
         AGO   .A2VOL#0             EXIT PROCESS
.NVOLVA2 ANOP
         LA    &#7,&PL              MAXIMUM LENGTH OF VOLSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#VOLSER'
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2VOL#0 ANOP
.*--------------------------------------------------------------------*
.A2DEST  ANOP
         AIF (T'&#DEST EQ 'O').A2FCB
*--------------------------------------------------------------------*
*   ADYN-SET UP PRINTER DESTINATION                                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSUSER         GET THE KEY FOR DESTINATION
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DEST#
         LA    &#7,8                LENGTH OF DESTINATION
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99DEST         MOVE DESTINATION
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2FCB
.A2DEST# ANOP
&PL      SETA  K'&DEST
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&DEST' MOVE PRINTER-ID
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2FCB   ANOP
         AIF (T'&#FCB EQ 'O').A2COPY
*--------------------------------------------------------------------*
*   ADYN-SET UP FCB                                                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALFCBIM         GET THE KEY FOR FCB
         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2FCB#
         LA    &#7,4                LENGTH OF FCB
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99FCB          MOVE FCB
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2DISP
.A2FCB#  ANOP
&PL      SETA  K'&FCB
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&FCB' MOVE FCB
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2COPY  ANOP
         AIF (T'&#COPIES EQ 'O').A2DISP
*--------------------------------------------------------------------*
*   ADYN-SET UP COPIES                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALCOPYS         GET KEY FOR # OF COPIES
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE COPYS KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2CPY#
         MVC   S99TUPAR(1),YCOPIES  SET # OF COPIES
         AGO .A2CPY#0
.A2CPY#  ANOP
         MVC   S99TUPAR(1),=AL1(&COPIES) SET # OF COPIES
.A2CPY#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DISP  ANOP
         AIF (T'&#DISP1 EQ 'O').A2DISP2
*--------------------------------------------------------------------*
*   ADYN-DATASET STATUS DESIRED                                      *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSTATS         GET KEY FOR STATUS SPECIFICATIONS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DIS#
         MVC   S99TUPAR(1),YDISP       SET DISPOSITION
         AGO  .A2DIS#0
.A2DIS#  ANOP
         MVI   S99TUPAR,$&#DISP1    SET DISPOSITION
.A2DIS#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DISP2 ANOP
         AIF (T'&#DISP2 EQ 'O').A2DISP3
*--------------------------------------------------------------------*
*   ADYN-DATASET DISPOSITION ON NORMAL COMPLETION                    *
         AIF ('&#CHDISP' EQ 'NO').A2DCM12
         AIF ('&#CHDISP' EQ 'YES').A2DCM11
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'
         AGO   .A2DCM12  ANOP
.A2DCM11  ANOP
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''
.A2DCM12  ANOP
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALNDISP         GET KEY FOR NORMAL DISPOSITION
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2NDS#
         MVC   S99TUPAR(1),YNDISP   SET DISPOSITION
         AGO .A2NDS#0
.A2NDS#  ANOP
         MVI   S99TUPAR,$&#DISP2    SET DISPOSITION
.A2NDS#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DISP3 ANOP
         AIF (T'&#DISP3 EQ 'O').A2RECFM
*--------------------------------------------------------------------*
*   ADYN-DATASET DISPOSITION ON ABNORMAL COMPLETION                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALCDISP         GET KEY FOR CONDITIONAL DISPOSITION
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2CDS#
         MVC   S99TUPAR(1),YCDISP   SET DISPOSITION
         AGO .A2CDS#0
.A2CDS#  ANOP
         MVI   S99TUPAR,$&#DISP3    SET DISPOSITION
.A2CDS#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2RECFM ANOP
         AIF (T'&#RECFM EQ 'O').A2DSORG
*--------------------------------------------------------------------*
*   ADYN-RECORD FORMAT                                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALRECFM         GET KEY FOR RECORD FORMAT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2RFM#
         MVC   S99TUPAR(1),YRECFM   SET RECORD FORMAT
         AGO .A2RFM#0
.A2RFM#  ANOP
         AIF ('&#RECFM' EQ 'FBA').CON#130
         AIF ('&#RECFM' EQ 'VBA').CON#130
         AIF ('&#RECFM' EQ 'VB').CON#130
         AIF ('&#RECFM' EQ 'FB').CON#130
         AIF ('&#RECFM' EQ 'U').CON#130
         AIF ('&#RECFM' EQ 'F').CON#130
         AIF ('&#RECFM' EQ 'V').CON#130
         MNOTE 12,'RECFM OF "&#RECFM" NOT ALLOWED FOR.'
         AGO .MEXIT
.CON#130 ANOP
         MVI   S99TUPAR,$&RECFM     SET RECFM
.A2RFM#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DSORG ANOP
         AIF (T'&#DSORG EQ 'O').A2LRECL
*--------------------------------------------------------------------*
*   ADYN-DATASET ORGANISATION                                        *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALDSORG         GET KEY FOR DSORG
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,2                PARAMETER LENGTH OF 2
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2DSO#
         MVC   S99TUPAR(2),YDSORG   SET DATASET ORGANISATION
         AGO .A2DSO#0
.A2DSO#  ANOP
         AIF ('&#DSORG' EQ 'PO').CON#135
         AIF ('&#DSORG' EQ 'PS').CON#135
         AIF ('&#DSORG' EQ 'DA').CON#135
         AIF ('&#DSORG' EQ 'POU').CON#135
         AIF ('&#DSORG' EQ 'PSU').CON#135
         AIF ('&#DSORG' EQ 'DAU').CON#135
         MNOTE 12,'DSORG OF "&#DSORG" NOT ALLOWED FOR.'
         AGO .MEXIT
.CON#135 ANOP
         XC    S99TUPAR+1(1),S99TUPAR+1 INIT LOW ORDER BYTE OF ORG
         MVI   S99TUPAR,$&#DSORG    SET DATASET ORG
.A2DSO#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2CONVA ANOP
.A2LRECL ANOP
         AIF (T'&#LRECL EQ 'O').A2BLKSZ
*--------------------------------------------------------------------*
*   ADYN-LOGICAL RECORD LENGTH                                       *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALLRECL         GET KEY FOR LOGICAL RECORD LENGTH
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2LRL#
         MVC   S99TUPAR(2),YLRECL   SET RECORD LENGTH
         AGO .A2LRL#0
.A2LRL#  ANOP
         MVC   S99TUPAR(2),=H'&LRECL' SET RECORD LENGTH
.A2LRL#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2BLKSZ ANOP
         AIF (T'&#BLKSZ EQ 'O').A2UNIT
*--------------------------------------------------------------------*
*   ADYN-BLOCK SIZE                                                  *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALBLKSZ         GET KEY FOR BLOCK SIZE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         AIF ('&PARMT'(1,1) EQ 'P').A2BLK#
         MVC   S99TUPAR(2),YBLKSIZE SET BLOCK SIZE
         AGO .A2BLK#0
.A2BLK#  ANOP
         MVC   S99TUPAR(2),=H'&BLKSIZE' SET BLOCK SIZE
.A2BLK#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.*--------------------------------------------------------------------*
.A2UNIT  ANOP
         AIF (T'&#UNIT EQ 'O').A2AUNIT
*--------------------------------------------------------------------*
*   ADYN-DEVICE UNIT                                                 *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALUNIT          GET KEY FOR UNIT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2UNI#
         LA    &#7,8                LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99UNIT         MOVE VOLUME
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST DSNAME
         AGO   .A2AUNIT
.A2UNI#  ANOP
&PL      SETA  K'&#UNIT
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#UNIT' MOVE UNIT
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST DSNAME
.A2AUNIT ANOP
         AIF (T'&#SPACET EQ 'O').A2PRIM
*--------------------------------------------------------------------*
*   ADYN-SPACE ALLOCATION INIT (CYL, TRK or block_size)              *
*--------------------------------------------------------------------*
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS      POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR          POINT 3ND TXT UNIT PTR TO 2ND T.U.
         AIF ('&PARMT'(1,1) EQ 'P').A2ATY#
         MVI   S99TUKEY,X'00'        CLEAR HIGH ORDER BYTE
         MVC   S99TUKEY+1(1),YSPACET MOVE ALLOCATION TYPE TO KEY
         AGO   .A2ATY#0
.A2ATY#  ANOP
         AIF ('&#SPACET' EQ 'TRK').A2TRK
         AIF ('&#SPACET' EQ 'CYL').A2CYL
         MNOTE 12,'ALLOCATION TYPE OF "&#SPACET" NOT ALLOWED FOR.'
         AGO .MEXIT
.A2TRK   ANOP
&#DISP   SETC  'DALTRK'
         AGO .CON#140
.A2CYL   ANOP
&#DISP   SETC  'DALCYL'
.CON#140 ANOP
         LA    &#7,&#DISP           GET KEY FOR ALLOCATION UNITS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
.A2ATY#0 ANOP
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
*   ADYN-AR    &#6,&#7              POINT PAST PARAMETER
.A2PRIM  ANOP
         AIF (T'&#PRIM EQ 'O').A2SECND
*--------------------------------------------------------------------*
*   ADYN-PRIMARY ALLOCATION                                          *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALPRIME         GET KEY FOR RECORD PRIMARY ALLOC
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE
         AIF ('&PARMT'(1,1) EQ 'P').A2PRI#
         MVC   S99TUPAR+1(2),YPRIM  MOVE PRIMARY ALLOCATION
         AGO .A2PRI#0
.A2PRI#  ANOP
         MVC   S99TUPAR+1(2),=H'&#PRIM' SET PRIMARY ALLOCATION
.A2PRI#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2SECND ANOP
         AIF (T'&#SECOND EQ 'O').A2DIRB
*--------------------------------------------------------------------*
*   ADYN-SECONDARY ALLOCATION                                        *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSECND         GET KEY FOR RECORD PRIMARY ALLOC
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE
         AIF ('&PARMT'(1,1) EQ 'P').A2SEC#
         MVC   S99TUPAR+1(2),YSECOND  MOVE SECONDARY ALLOCATION
         AGO .A2SEC#0
.A2SEC#  ANOP
         MVC   S99TUPAR+1(2),=H'&#SECOND' SET SECONDARY ALLOCATION
.A2SEC#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2DIRB  ANOP
         AIF (T'&#DIRB EQ 'O').A2PERMA
*--------------------------------------------------------------------*
*   ADYN-DIRECTORY BLOCKS                                            *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALDIR           GET KEY FOR RECORD PRIMARY ALLOC
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE
         AIF ('&PARMT'(1,1) EQ 'P').A2DIR#
         MVC   S99TUPAR+1(2),YDIRB  MOVE DIRECTORY BLOCKS
         AGO .A2DIR#0
.A2DIR#  ANOP
         MVC   S99TUPAR+1(2),=H'&#DIRB' MOVE DIRECTORY BLOCKS
.A2DIR#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2PERMA ANOP
         AIF ('&#PERMA'(1,1) EQ 'N').A2BUFNO
*--------------------------------------------------------------------*
*   ADYN-PERMANENT ALLOCATED ATTRIBUTE                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALPERMA         GET KEY PERMANENT ATTRIBUTE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2BUFNO ANOP
         AIF (T'&#BUFNO EQ 'O').A2UCLOS
*--------------------------------------------------------------------*
*   ADYN-NO OF BUFFERS PER DCB                                       *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALBUFNO         GET KEY FOR NUMBER OF BUFFERS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#7,1                BECAUSE THE LRECL PARM REQUIRES 1
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         AIF ('&PARMT'(1,1) EQ 'P').A2BUF#
         MVC   S99TUPAR(2),YBUFNO   MOVE NUMBER OF BUFFERS
         AGO .A2BUF#0
.A2BUF#  ANOP
         MVC   S99TUPAR(1),=C'&BUFNO' MOVE NUMBER OF BUFFERS
.A2BUF#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2UCLOS ANOP
         AIF ('&UCLOSE' NE 'YES').A2RLSE
         AIF ('&#ACTION'(1,1) NE 'A').A2RLSE
*--------------------------------------------------------------------*
*   ADYN-UNALLOCATE DATASET ON CLOSING                               *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALCLOSE         GET KEY FOR UNALLOCATE ON CLOSE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2RLSE  ANOP
         AIF ('&#RLSE' NE 'R').A2CLASS
*--------------------------------------------------------------------*
*   ADYN-RELEASE ANY UNUSED SPACE AFTRE CLOSING                      *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALRLSE          GET KEY FOR RELEASE
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2CLASS ANOP
         AIF (T'&#CLASS EQ 'O').A2WRTR
*--------------------------------------------------------------------*
*   ADYN-ALLOCATE SYSOUT CLASS                                       *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSYSOU         GET KEY FOR CLASS
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1
         AIF ('&PARMT'(1,1) EQ 'P').A2CLA#
         MVC   S99TUPAR(1),YCLASS   MOVE SYSOUT CLASS
         AGO .A2CLA#0
.A2CLA#  ANOP
         MVC   S99TUPAR(1),=C'&#CLASS' SET SYSOUT CLASS
.A2CLA#0 ANOP
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
.A2WRTR  ANOP
         AIF (T'&#WRTR EQ 'O').A3ALOC
*--------------------------------------------------------------------*
*   ADYN-ALLOCATE SYSOUT WRITER-NAME/INTERNAL-READER                 *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DALSPGNM         GET KEY FOR UNIT
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         AIF ('&PARMT'(1,1) EQ 'P').A2PRG#
         LA    &#7,8                LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE
         EX    &#7,MV99WRTR         MOVE WRITER-NAME/INTRDR
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH
         AR    &#6,&#7              POINT PAST WRITER-NAME
         AGO   .A3ALOC
.A2PRG#  ANOP
&PL      SETA  K'&#WRTR
         LA    &#7,&PL              LENGTH OF VOLOSER
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         MVC   S99TUPAR(&PL),=C'&#WRTR' MOVE WRITER-NAME/INTRDR
         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT
         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH
         LA    &#6,&PL.(&#6)        POINT PAST WRITER-NAME
.*--------------------------------------------------------------------*
.A3ALOC  ANOP
         AIF ('&#ACTION'(1,1) EQ 'U').UNAL2
         AIF ('&#ACTION'(1,1) EQ 'F').UNAL2
         AGO   .A$END
.*--------------------------------------------------------------------*
.UNAL2   ANOP
*--------------------------------------------------------------------*
*   ADYN-UNALLOCATE/FREE DATASET                                     *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DUNUNALC         GET KEY FOR RETURN DSNAME
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0
         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   REMOVE IN-USE ATTRIBUTE                                          *
.*--------------------------------------------------------------------*
.*        LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
.*        ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
.*        LA    &#7,DUNREMOV         GET KEY FOR REMOVE IN-USE
.*        STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
.*        LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0
.*        STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD
.*--------------------------------------------------------------------*
         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR
         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH
         AR    &#6,&#7              POINT PAST PARAMETER
         AGO   .A$END
.*--------------------------------------------------------------------*
.INFO2   ANOP
&@DSNR   SETC  ''
         AIF ('&PARMT'(1,1) EQ 'D').SETDSNR
         AIF (T'&#DSN EQ 'O').A$END
.SETDSNR ANOP
*--------------------------------------------------------------------*
*   ADYN-INFO/ RETURN DSNAME FROM DDNAME                             *
*--------------------------------------------------------------------*
         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST
         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.
         LA    &#7,DINRTDSN         GET KEY FOR RETURN DSNAME
         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT
         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1
         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD
.*--------------------------------------------------------------------*
.*   TEST FOR PARAMETER TYPE                                          *
.*--------------------------------------------------------------------*
         LA    &#7,44               MAXIMUM LENGTH OF DATASET
         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH
         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS
         AIF ('&PARMT'(1,1) EQ 'P').A2DSNI
         ST    &#1,YDSN             SAVE FOR LATER USE
&@DSNR   SETC  'YDSN'
         AGO   .A$END
.A2DSNI  ANOP
         ST    &#1,&DSN             SAVE FOR LATER USE
&@DSNR   SETC  '&DSN'
         AGO   .A$END
.*--------------------------------------------------------------------*
.CONC2   ANOP
         AGO .CON#0E0
.DEAL2   ANOP
         AGO .CON#0E0
.*--------------------------------------------------------------------*
.A$END   ANOP
         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR
         AIF ('&PARMT'(1,1) EQ 'P').A$NOEXO
         AIF (&ADYNFL1).A$NOEXO
&ADYNFL1 SETB  1
         B     BYPASEX              BYPASS EX STATEMENTS
*---------------------------------------------------------------------*
*  CODE TO BE 'EX'D DURING PARAMETER BUILDING FROM PARAMETERS PASSED  *
*  AS DATA IN FIELD VARIABLES.                                        *
*---------------------------------------------------------------------*
MV99DSN  MVC   S99TUPAR(0),YDSN     MOVE DSNAME
MV99DDN  MVC   S99TUPAR(0),YDD      MOVE DDNAME
MV99DDCN MVC   S99TUPAR+10(0),YDDC  MOVE DDNAME TO CONCATENATE
MV99MEMB MVC   S99TUPAR(0),YMEMBER  MOVE MEMBER
MV99VOLS MVC   S99TUPAR(0),YVOLSER  MOVE VOLSER
MV99UNIT MVC   S99TUPAR(0),YUNIT    MOVE DVICE TYPE
MV99WRTR MVC   S99TUPAR(0),YWRITER  MOVE SYSOUT WRITER-NAME/INTRDR
MV99DEST MVC   S99TUPAR(0),YDEST    MOVE PRINTER-ID DESTINATION
MV99FCB  MVC   S99TUPAR(0),YFCB     MOVE FCB
*---------------------------------------------------------------------*
BYPASEX  DS    0H
.A$NOEXO ANOP
         AIF   ('&REGR' EQ 'NO').NORSAV2 BYPASS IF REGS NOT 2 BE REST'D
         LM    R0,R14,&REGSAVR      RESTORE USED REGISTERS
.NORSAV2 ANOP
         AIF (T'&BASE EQ 'O').UCALLIT
*---------------------------------------------------------------------*
*  IMPLICIT INVOCATION OF THE DYNALLOC COMMAND IF 'BASE' SUPPLIED     *
*---------------------------------------------------------------------*
         AIF ('&#DDR'(1,1) NE 'Y').A$DDR0 IF DD RETURN REQ'D BYPASS
&VARNM   SETC  '&#DD'               SET VARIABLE NAME
         AIF ('&#DD'(1,1) NE '(').NDDVAR3
&PL      SETA  K'&#DD
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
.NDDVAR3 ANOP
         MVC   &REGSAVR.(4),&VARNM  MOVE DDNAME VARIABLE ADDRESS SAVED
.A$DDR0  ANOP
         AIF ('&#DSNR'(1,1) NE 'Y').NODSNR
&VARNM   SETC  '&#DSN'              SET VARIABLE NAME
         AIF (T'&#DSN NE 'O').NDSNOM3
&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME
         AGO   .NDSNVA3
.NDSNOM3 ANOP
         AIF ('&#DSN'(1,1) NE '(').NDSNVA3
&PL      SETA  K'&#DSN
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
.NDSNVA3 ANOP
         MVC   &REGSAVR.(4),&VARNM  MOVE DSNAME VARIABLE ADDRESS SAVED
.NODSNR  ANOP
         AIF ('&#VOLR'(1,1) NE 'Y').NOVOLR
&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME
         AIF (T'&#VOLSER NE 'O').NVOLOM3
&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME
         AGO   .NVOLVA3
.NVOLOM3 ANOP
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA3
&PL      SETA  K'&#VOLSER
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
.NVOLVA3 ANOP
         MVC   &REGSAVR.+4(4),&VARNM  MOVE VOL VARIABLE ADDRESS SAVED
.NOVOLR  ANOP
         AIF ('&PDUMP'(1,1) NE 'Y').DYNALOC
         AIF (T'&PDUMPX EQ 'O').PDUMPWX
         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC "&#ACTION". NO
               O EXIT AVAILABLE.'
         AGO   .DYNALOC
.PDUMPWX ANOP
         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC "&#ACTION". EX
               XIT AVAILABLE  THRU "QUIT" COMMAND.'
.DYNALOC ANOP
         LR    &#1,&BASE            REQ BLK PTR ADR IN &#1 FOR DYNALLOC
         DYNALLOC
         AIF (T'&ERROR EQ 'O').TSTDELT
         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN
         BNZ   &ERROR                  N. GO TO ERROR ROUTINE
.TSTDELT ANOP
         AIF ('&#VOLR'(1,1) NE 'Y').A$DSR1
         L     R14,&REGSAVR+4       LOAD VOLSER VARIABLE ADDRESS SAVED
         AIF (T'&#VOLSER NE 'O').NVOLOM4
&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME
         AGO   .NVOLVA4 ANOP
.NVOLOM4 ANOP
         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA4
&PL      SETA  K'&#VOLSER
&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME
.NVOLVA4 ANOP
         MVC   &VARNM.(6),0(R14)    MOVE VOLSER RETURNED BY DYNALLOC
.A$DSR1  ANOP
         AIF ('&#DSNR'(1,1) NE 'Y').A$DDR1
         L     R14,&REGSAVR         LOAD DSNAME VARIABLE ADDRESS SAVED
         AIF (T'&#DSN NE 'O').NDSNOM4
&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME
         AGO   .NDSNVA4
.NDSNOM4 ANOP
         AIF ('&#DSN'(1,1) NE '(').NDSNVA4
&PL      SETA  K'&#DSN
&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME
.NDSNVA4 ANOP
         MVC   &VARNM.(44),0(R14)   MOVE DSNAME RETURNED BY DYNALLOC
         OC    &VARNM.(44),=CL44' ' CONVERT TRAILING X'00' TO SPACES
*                                          /\ <------
         AGO   .A$DDR2
.A$DDR1  ANOP
         AIF ('&#DDR'(1,1) NE 'Y').A$DDR2 IF DD RETURN REQ'D BYPASS
         L     R14,&REGSAVR         LOAD DDNAME VARIABLE ADDRESS SAVED
         AIF ('&#DD'(1,1) NE '(').NDDVAR4
&PL      SETA  K'&#DD
&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME
.NDDVAR4 ANOP
         MVC   &VARNM.(8),0(R14)    MOVE DDNAME RETURNED BY DYNALLOC
.A$DDR2  ANOP
         AIF ('&#ACTION'(1,1) NE 'F').BPALOC2 BYPASS IF NOT FREE
         AIF ('&ACTION'(1,1) NE 'A').BPALOC2  BYPASS IF NOT ALLOCATE
&#REUSEF SETC 'Y'
         AGO .A$RT                             GO ALLOCATE IT
.BPALOC2 ANOP
         AIF ('&#ACTION' NE 'ALLOC').UCALLIT
         AIF ('&ACTION'(1,3) NE 'DEL').UCALLIT
.*--------------------------------------------------------------------*
.*    CONTROL GETS HERE IF ACTION WAS DELETE AND WE HAVE JUST ALLOC'D *
.*    WITH DISP=(OLD,DELETE,DELETE)                                   *
.*--------------------------------------------------------------------*
         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN
         BNZ   &DELLAB                 N. BYPASS FREEING FOR DELETE
&#ACTION SETC 'FREE'                INIT PARMS FOR 'FREE'
&#DISP1  SETC ''
&#DISP2  SETC ''
&#DISP3  SETC ''
*---------------------------------------------------------------------*
*  FOR 'DELETE', RETURNING TO UNALLOCATE DATASET JUST ALLOCATED WITH: *
*     DISP=(OLD,DELETE,DELETE)                                        *
*---------------------------------------------------------------------*
         AGO .NOTDELT               GO SET UP FREE COMMANDS
.UCALLIT ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   ('&MF' EQ 'E').NOREGSV BYPASS SAVE REGISTERS
         AIF   (&REGDFLG).NOREGSV EXIT IF ALREADY PROCESSED
&REGDFLG SETB  1
         B     &DELLAB       BRANCH AROUND REG SAVE AREA
&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA
.NOREGSV ANOP
&DELLAB  DS    0H
*------------ END OF ADYN PARAMETER LIST BUILD -----------------------*
         AGO .MEXIT
*---------------------------------------------------------------------*
.MFELIST ANOP
.*--------------------------------------------------------------------*
.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *
.*--------------------------------------------------------------------*
         AIF   (&REGDFLG).MEXIT  EXIT IF ALREADY PROCESSED
&REGDFLG SETB  1
&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA
         AGO .MEXIT
.*-----------------CONSTANT MAPPING OF ADYN VARIABLES-----------------*
.DATAMAP ANOP
         AIF  ('&DATA'(1,3) EQ 'IBM').DATAIBM
.*-------------------------------------------------------------------*
.*     INITIALISE VARIABLES IF NOT PASSED                            *
.*-------------------------------------------------------------------*
.A2UNITD ANOP
         AIF (T'&#UNIT NE 'O').A2UNI11   PROCESS IF NOT OMITTED
         AIF ('&#DISP1' NE 'NEW').A2UNI11 BYPASS IF OMMITED AND NOT NEW
&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'
*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *
.A2UNI11 ANOP
.CDDNAME ANOP
&#DDR    SETC '&DDR'
         AIF ('&#DDR'(1,1) EQ 'Y').A$DDR3 IF DD RETURN REQ'D BLANK DD
         AIF (T'&#DD NE 'O').CDDCNAM
.A$DDR3  ANOP
&#DD     SETC ' '
.CDDCNAM ANOP
         AIF (T'&#DDC NE 'O').CDSNAME
&#DDC    SETC ' '
.CDSNAME ANOP
         AIF (T'&#DSN NE 'O').CMEMBER
&#DSN    SETC ' '
.CMEMBER ANOP
         AIF (T'&#MEMBER NE 'O').CVOLSER
&#MEMBER SETC ' '
.CVOLSER ANOP
         AIF (T'&#VOLSER NE 'O').CDEST
&#VOLSER SETC ' '
.CDEST   ANOP
         AIF (T'&#DEST NE 'O').CFCB
&#DEST   SETC ' '
.CFCB    ANOP
         AIF (T'&#FCB NE 'O').CCOPYS
&#FCB    SETC ' '
.CCOPYS  ANOP
         AIF (T'&#COPIES NE 'O').CDISP
&#COPIES SETC '0'
.CDISP   ANOP
         AIF (T'&#DISP1 NE 'O').CDISPV
&#DISP1  SETC '00'
         AGO .CNDISP
.CDISPV  ANOP
         AIF ('&#DISP1' EQ 'NEW').C2NEW
         AIF ('&#DISP1' EQ 'OLD').C2OLD
         AIF ('&#DISP1' EQ 'MOD').C2MOD
         AIF ('&#DISP1' EQ 'SHR').C2SHR
         AGO .CNDISP
.C2SHR   ANOP
&#DISP1  SETC  '08'
         AGO .CNDISP
.C2NEW   ANOP
&#DISP1  SETC  '04'
         AGO .CNDISP
.C2MOD   ANOP
&#DISP1  SETC  '02'
         AGO .CNDISP
.C2OLD   ANOP
&#DISP1  SETC  '01'
.CNDISP  ANOP
         AIF (T'&#DISP2 NE 'O').CNDISPV
&#DISP2  SETC '00'
         AGO .CCDISP
.CNDISPV ANOP
         AIF ('&#DISP2' EQ 'UNCATLG').C2UNC1
         AIF ('&#DISP2' EQ 'CATLG').C2CAT1
         AIF ('&#DISP2' EQ 'DELETE').C2DEL1
         AIF ('&#DISP2' EQ 'KEEP').C2KEP1
         AGO .CCDISP
.C2KEP1  ANOP
&#DISP2  SETC  '08'
         AGO .CCDISP
.C2UNC1  ANOP
&#DISP2  SETC  '01'
         AGO .CCDISP
.C2CAT1  ANOP
&#DISP2  SETC  '02'
         AGO .CCDISP
.C2DEL1  ANOP
&#DISP2  SETC  '04'
.CCDISP  ANOP
         AIF (T'&#DISP3 NE 'O').CCDISPV
&#DISP3  SETC '00'
.CCDISPV ANOP
         AIF ('&#DISP3' EQ 'UNCATLG').C2UNC2
         AIF ('&#DISP3' EQ 'CATLG').C2CAT2
         AIF ('&#DISP3' EQ 'DELETE').C2DEL2
         AIF ('&#DISP3' EQ 'KEEP').C2KEP2
         AGO .CSPACET
.C2KEP2  ANOP
&#DISP3  SETC  '08'
         AGO .CSPACET
.C2UNC2  ANOP
&#DISP3  SETC  '01'
         AGO .CSPACET
.C2CAT2  ANOP
&#DISP3  SETC  '02'
         AGO .CSPACET
.C2DEL2  ANOP
&#DISP3  SETC  '04'
.CSPACET ANOP
         AIF (T'&#SPACET NE 'O').CSPACEV
&#SPACET SETC '00'
         AGO .CPRIM
.CSPACEV ANOP
         AIF ('&#SPACET' NE 'CYL').C2TRK1
&#SPACET SETC  '08'
         AGO .CPRIM
.C2TRK1  ANOP
&#SPACET SETC  '07'
.CPRIM   ANOP
         AIF (T'&#PRIM NE 'O').CSECOND
&#PRIM   SETC '0'
.CSECOND ANOP
         AIF (T'&#SECOND NE 'O').CDIRB
&#SECOND SETC '0'
.CDIRB   ANOP
         AIF (T'&#DIRB NE 'O').CBUFNO
&#DIRB   SETC '0'
.CBUFNO  ANOP
         AIF (T'&#BUFNO NE 'O').CUNIT
&#BUFNO  SETC '0'
.CUNIT   ANOP
         AIF (T'&#UNIT NE 'O').CRECFM
&#UNIT   SETC ' '
.CRECFM  ANOP
         AIF (T'&#RECFM NE 'O').CRECFMV
&#RECFM  SETC '00'
         AGO .CDSORG
.CRECFMV ANOP
         AIF ('&#RECFM' EQ 'FBA').C2FBA
         AIF ('&#RECFM' EQ 'VBA').C2VBA
         AIF ('&#RECFM' EQ 'VB').C2VB
         AIF ('&#RECFM' EQ 'FB').C2FB
         AIF ('&#RECFM' EQ 'U').C2U
         AIF ('&#RECFM' EQ 'F').C2F
         AIF ('&#RECFM' EQ 'V').C2V
         AGO .CDSORG
.C2FBA   ANOP
&#RECFM  SETC  '94'
         AGO .CDSORG
.C2VBA   ANOP
&#RECFM  SETC  '54'
         AGO .CDSORG
.C2FB    ANOP
&#RECFM  SETC  '90'
         AGO .CDSORG
.C2VB    ANOP
&#RECFM  SETC  '50'
         AGO .CDSORG
.C2U     ANOP
&#RECFM  SETC  'C0'
         AGO .CDSORG
.C2F     ANOP
&#RECFM  SETC  '80'
         AGO .CDSORG
.C2V     ANOP
&#RECFM  SETC  '40'
.CDSORG  ANOP
         AIF (T'&#DSORG NE 'O').CDSORGV
&#DSORG  SETC '0000'
         AGO .CLRECL
.CDSORGV ANOP
         AIF ('&#DSORG' EQ 'PO').C2OPO
         AIF ('&#DSORG' EQ 'PS').C2OPS
         AIF ('&#DSORG' EQ 'DA').C2ODA
         AIF ('&#DSORG' EQ 'POU').C2OPOU
         AIF ('&#DSORG' EQ 'PSU').C2OPSU
         AIF ('&#DSORG' EQ 'DAU').C2ODAU
         AGO .CLRECL
.C2OPOU  ANOP
&#DSORG  SETC  '0300'
         AGO .CLRECL
.C2OPSU  ANOP
&#DSORG  SETC  '4100'
         AGO .CLRECL
.C2ODAU  ANOP
&#DSORG  SETC  '2100'
         AGO .CLRECL
.C2OPO   ANOP
&#DSORG  SETC  '0200'
         AGO .CLRECL
.C2OPS   ANOP
&#DSORG  SETC  '4000'
         AGO .CLRECL
.C2ODA   ANOP
&#DSORG  SETC  '2000'
.CLRECL  ANOP
         AIF (T'&#LRECL NE 'O').CBLKSZ
&#LRECL  SETC '0'
.CBLKSZ  ANOP
         AIF (T'&#BLKSZ NE 'O').CCLASS
&#BLKSZ  SETC '0'
.CCLASS  ANOP
         AIF (T'&#CLASS NE 'O').CWRTR
&#CLASS  SETC ' '
.CWRTR   ANOP
         AIF (T'&#WRTR NE 'O').CRLSE
&#WRTR   SETC ' '
.CRLSE   ANOP
         AIF (T'&#RLSE NE 'O').D$0END
&#RLSE   SETC 'N'
         AGO .D$0END
.D$0END  ANOP
.*-------------------------------------------------------------------*
         AIF  ('&DATA'(1,3) EQ 'VAR').DATAVAR
         AIF  ('&DATA'(1,3) EQ 'CON').DATACON
         MNOTE 12,'INVALID 'DATA' PARAMETER OF "&DATA".'
         AGO .MEXIT
.DATACON ANOP
*--------------------------------------------------------------------*
* CONSTANT MAP OF 'ADYN' DATA.                                       *
*--------------------------------------------------------------------*
         DC    CL8'&#DD'     DD NAME
         DC    CL8'&#DDC'    DD NAME TO CONCATENATE
         DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL
         DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION
         DC    CL6'&#VOLSER' DISK DATASET RESIDES ON
         DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)
.*-------------------------------------------------------------------*
         AIF ('&#CHDISP' EQ 'NO').A2DCM22
         AIF ('&#CHDISP' EQ 'YES').A2DCM21
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'
         AGO   .A2DCM22  ANOP
.A2DCM21  ANOP
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''
.A2DCM22  ANOP
.*-------------------------------------------------------------------*
         DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION
*                              CATLG,UNCATLG,DELETE,KEEP
         DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION
*                              SAME VALUES AS FOR 'ANDISP'
         DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)
         DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION
         DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION
         DC    H'&#DIRB'     DIRECTORY BLOCKS
         DC    CL1'&#BUFNO'  NUMBER OF BUFFERS
         DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)
         DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)
         DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)
         DC    H'&#LRECL'    RECORD LENGTH
         DC    H'&#BLKSZ'    BLOCK SIZE
         DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)
         DC    CL8'&#WRTR'   SYSOUT WRITER-NAME/INTRDR
         DC    CL8'&#DEST'   DESTINATION PRINTER-ID
         DC    CL4'&#FCB'    FCB
         DC    AL1(&#COPIES) NUMBER OF COPIES
         DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE
*                              SET TO NON X'00'
         AIF   ('&REGSMC1' NE 'ADYN').ECONST1
         DS    16F           GLOBAL REGISTER SAVE AREA
&REGSMC1 SETC  '    '
.ECONST1 ANOP
*--------------------END OF ADYN DSECT FORMAT-------------------------*
         AGO   .MEXIT
.*-------------------END OF CONSTANT FORMAT---------------------------*
.*
.*
.*--------------------DSECT MAPPING OF ADYN VARIABLES-----------------*
.DATAVAR ANOP
.*&NAME    DSECT
*--------------------------------------------------------------------*
* DSECT USED TO MOVE VARIABLE DYNAMIC ALLOCATION DATASET DETAILS.    *
*--------------------------------------------------------------------*
YDD      DC    CL8'&#DD'     DD NAME
YDDC     DC    CL8'&#DDC'    DD NAME TO CONCATENATE
YDSN     DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL
YMEMBER  DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION (-N,0,+N)
YVOLSER  DC    CL6'&#VOLSER' DISK DATASET RESIDES ON
*
YDISP    DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)
YSHR     EQU   X'08'          - SHARE DISPOSITION (STATUS)
YNEW     EQU   X'04'          - NEW   DISPOSITION (STATUS)
YMOD     EQU   X'02'          - MOD   DISPOSITION (STATUS)
YOLD     EQU   X'01'          - OLD   DISPOSITION (STATUS)
*
.*-------------------------------------------------------------------*
         AIF ('&#CHDISP' EQ 'NO').A2DCM32
         AIF ('&#CHDISP' EQ 'YES').A2DCM31
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'
         AGO   .A2DCM32  ANOP
.A2DCM31  ANOP
         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''
.A2DCM32  ANOP
.*-------------------------------------------------------------------*
YNDISP   DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION
*                              CATLG,UNCATLG,DELETE,KEEP
YUNCAT   EQU   X'01'           - UNCATALOG
YCATLG   EQU   X'02'           - CATALOG
YDELETE  EQU   X'04'           - DELETE
YKEEP    EQU   X'08'           - KEEP
YCDISP   DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION
*                              SAME VALUES AS FOR 'ANDISP'
YSPACET  DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)
YTRK     EQU   X'07'           - TRACK MASK
YCYL     EQU   X'08'           - CYLINDER MASK
*
YPRIM    DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION
YSECOND  DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION
YDIRB    DC    H'&#DIRB'     DIRECTORY BLOCKS
YBUFNO   DC    CL1'&#BUFNO'  NUMBER OF BUFFERS
YUNIT    DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)
*
YRECFM   DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)
YFBA     EQU   X'94'           - FBA
YVBA     EQU   X'54'           - VBA
YFB      EQU   X'90'           - FB
YVB      EQU   X'50'           - VB
YU       EQU   X'C0'           - U
YF       EQU   X'80'           - F
YV       EQU   X'40'           - V
*
YDSORG   DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)
YDSOPOU  EQU   X'0300'         - POU
YDSOPSU  EQU   X'4100'         - PSU
YDSODAU  EQU   X'2100'         - DAU
YDSOPO   EQU   X'0200'         - PO
YDSOPS   EQU   X'4000'         - PS
YDSODA   EQU   X'2000'         - DA
*
YLRECL   DC    H'&#LRECL'    RECORD LENGTH
YBLKSIZE DC    H'&#BLKSZ'    BLOCK SIZE
YCLASS   DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)
YWRITER DC     CL8'&#WRTR'   SYSOUT WRITER-MAME/INTRDR
YDEST    DC    CL8'&#DEST'   DESTINATION PRINTER-ID
YFCB     DC    CL4'&#FCB'    FCB
YCOPIES  DC    AL1(&#COPIES) NUMBER OF COPIES
YRLSE    DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE
*                              SET TO NON X'00'
         AIF   ('&REGSMC2' NE 'ADYN').EDSECT1
&REGSMC2 SETC  '    '
         AIF   (&REGDFLG).EDSECT1 EXIT IF ALREADY PROCESSED
&REGDFLG SETB  1
&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA
.EDSECT1 ANOP
*--------------------END OF ADYN DSECT FORMAT-------------------------*
         AGO .MEXIT
.DATAIBM ANOP
*---------------------------------------------------------------------*
*     IBM REQUIRED MACROS                                             *
*---------------------------------------------------------------------*
         IEFZB4D0
         IEFZB4D2
         AGO .MEXIT
*---------------------------------------------------------------------*
.CON#0E0 MNOTE 12,'"&#ACTION" NOT DEFINED YET.'
.MEXIT   ANOP
         MEXIT
         MEND
