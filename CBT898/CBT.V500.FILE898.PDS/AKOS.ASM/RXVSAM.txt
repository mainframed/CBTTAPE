 TITLE 'RXVSAM - REX Function To Perform VSAM Requests'
         PUSH PRINT
         PRINT OFF
         MACRO
&LABEL   GENMSGS &GEN=DSECT
         AIF   ('&GEN' EQ 'DSECT').OK
         AIF   ('&GEN' EQ 'CSECT').OK
         MNOTE 8,'GENMSGS MACRO STATEMENT HAD AN INVALID VALUE'
         AGO   .ENDMAC
.OK      ANOP
&LABEL   &GEN
M$ALLOK  DS      0CL38
         DC      CL4'0000'
         DC      CL4'I'
         DC      CL30'Request successfully processed'
M$BADARG DS      0CL31
         DC      CL4'0001'
         DC      CL4'E'
         DC      CL23'Invalid argument passed'
M$BADOPN DS      0CL19
         DC      CL4'0002'
         DC      CL4'E'
         DC      CL11'Open failed'
M$BADCLO DS      0CL20
         DC      CL4'0003'
         DC      CL4'E'
         DC      CL12'Close failed'
M$EOF    DS      0CL19
         DC      CL4'0004'
         DC      CL4'W'
         DC      CL11'End of File'
M$PREVOP DS      0CL28
         DC      CL4'0005'
         DC      CL4'E'
         DC      CL20'File is already open'
M$NOBLK  DS      0CL46
         DC      CL4'0006'
         DC      CL4'E'
         DC      CL38'Unable to access RXVSAM BLOCK variable'
M$NORECV DS      0CL67
         DC      CL4'0007'
         DC      CL4'E'
         DC      CL46'REXX record variable could not be accessed or '
         DC      CL13'was undefined'
M$DUPL   DS      0CL24
         DC      CL4'0008'
         DC      CL4'E'
         DC      CL16'Duplicate record'
M$VMSG   DS      0CL38
         DC      CL4'0010'
         DC      CL4'E'
         DC      CL30'Unable to save VSAM error data'
M$RMSG   DS      0CL41
         DC      CL4'0011'
         DC      CL4'E'
         DC      CL33'Unable to set return message text'
M$CLOSAC DS      0CL77
         DC      CL4'0012'
         DC      CL4'E'
         DC      CL46'ACB was not available to perform CLOSE request'
         DC      CL23' - file may not be open'
M$NOACB  DS      0CL71
         DC      CL4'0014'
         DC      CL4'E'
         DC      CL41'ACB was not available to perform request '
         DC      CL22'- file may not be open'
M$BADSCB DS      0CL56
         DC      CL4'0015'
         DC      CL4'E'
         DC      CL48'Unable to obtain max record length for this file'
M$NOTFND DS      0CL24
         DC      CL4'0016'
         DC      CL4'W'
         DC      CL16'Record not found'
M$BWDNF  DS      0CL87
         DC      CL4'0016'
         DC      CL4'W'
         DC      CL47'Record not found - a FULL KEY must be specified'
         DC      CL32' when issuing a STARTBWD request'
M$NORLEN DS      0CL41
         DC      CL4'0017'
         DC      CL4'E'
         DC      CL33'Cannot determine length of record'
M$BADUPD DS      0CL41
         DC      CL4'0018'
         DC      CL4'E'
         DC      CL33'Unable to modify RPL for "UPDate"'
M$BADFUN DS      0CL23
         DC      CL4'0019'
         DC      CL4'E'
         DC      CL15'Function failed'
M$NOREC  DS      0CL40
         DC      CL4'0020'
         DC      CL4'E'
         DC      CL32'Unable to update RECORD variable'
M$NOIN   DS      0CL34
         DC      CL4'0021'
         DC      CL4'E'
         DC      CL26'File is not open for INPUT'
M$NOOUT  DS      0CL35
         DC      CL4'0022'
         DC      CL4'E'
         DC      CL26'File is not open for OUTPUT'
M$BADDSW DS      0CL42
         DC      CL4'0023'
         DC      CL4'E'
         DC      CL34'Unable to switch to DIR processing'
M$NOGEN  DS      0CL41
         DC      CL4'0024'
         DC      CL4'E'
         DC      CL33'READGENERIC only allowed for KSDS'
M$NONNUM DS      0CL45
         DC      CL4'0025'
         DC      CL4'E'
         DC      CL37'Non-numeric key specified for an RRDS'
M$NOESDS DS      0CL48
         DC      CL4'0026'
         DC      CL4'E'
         DC      CL40'This function is not allowed for an ESDS'
M$NORRN  DS      0CL33
         DC      CL4'0027'
         DC      CL4'E'
         DC      CL25'Unable to set RXVSAM_RRN#'
M$NOPOS  DS      0CL55
         DC      CL4'0088'
         DC      CL4'E'
         DC      CL47'READPREV attempted without a previous STARTBWD '
M$NOGET  DS      0CL59
         DC      CL4'0092'
         DC      CL4'E'
         DC      CL47'REWRITE or DELETE attempted without a previous '
         DC      CL4'READ'
M$BADRL  DS      0CL99
         DC      CL4'0108'
         DC      CL4'E'
         DC      CL48'Record length = 0, > max, < key length (KSDS) or'
         DC      CL43' not equal to slot size (fixed length RRDS)'
.ENDMAC  ANOP
         MEND
         POP PRINT
         MACRO
&LABEL   SETMSG &MSG=
         AIF   ('&MSG' NE '').OK
         MNOTE 8,'NO MESSAGE SPECIFIED'
         AGO   .ENDMAC
.OK      ANOP
         L     14,RXVSMSG@        GET EPA FOR RXVSAM MSG CSECT
         USING MSGDSECT,14
         LA    15,&MSG
         ST    15,MSG@            SAVE -> MESSAGE TEXT
         LA    15,L'&MSG
         STH   15,MSGLEN          SAVE MESSAGE LENGTH
         DROP  14
.ENDMAC  ANOP
         MEND
         SPACE
         MACRO
&LABEL   NTERROR &REQ=,&SYM=,&GOTO=
         AIF   ('&REQ' NE '').CHKSYM
         MNOTE 8,'NO REQUEST TYPE SPECIFIED'
         AGO   .ENDMAC
.CHKSYM  ANOP
         AIF   ('&SYM' NE '').OK
         MNOTE 8,'NO SYMBOL (LABEL) SPECIFIED'
         AGO   .ENDMAC
.OK      ANOP
         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT MESSAGE AREA
         ST    R15,NAMTOKRC                SAVE RETURN CODE
         CVD   R15,DBLWRK
         OI    BYTEWRK2,X'F0'
         MVC   NTMSGR15,HALFWRK2
         MVC   NTREQ,=CL8'&REQ'            SAVE REQUEST TYPE
         MVC   NTLABEL,=CL8'&SYM'          AND RXVSAM LABEL
         AIF   ('&GOTO' EQ '').ENDMAC
         B     &GOTO
.ENDMAC  ANOP
         MEND
         EJECT
         MACRO
&LABEL   ADDTRACE &ENTRY=
         OC    TRACE@B,TRACE@B             DO WE HAVE A TRACE AREA?
         BNZ   YY&SYSNDX                   YES, ADD ENTRY TO IT
         STORAGE OBTAIN,LENGTH=4096000     NO GET A 4 MEG AREA
         ST    R1,TRACE@B                  SAVE BEGINNING ADDR
         LR    R0,R1                       CLEAR AREA
         L     R1,=F'4096000'
         SR    R15,R15
         MVCL  R0,R14
         L     R1,TRACE@B                  GET -> TO AREA
         MVC   0(8,R1),=CL8'TR@CET@B'      STICK EYECATCHER IN IT
         LA    R15,8(R1)
         ST    R15,TRACE@C                 POSITION FOR NEXT ENTRY
         LR    R15,R1
         A     R15,=F'4096000'
         ST    R15,TRACE@M                 ENDING ADDRESS OF AREA
YY&SYSNDX  L   R1,TRACE@C
         LA    R15,L'&ENTRY                MAKE SURE THIS ENTRY
         AR    R15,R1                      WON'T GO OFF THE END
         C     R15,TRACE@M
         BNL   ZZ&SYSNDX
         MVC   0(L'&ENTRY,R1),&ENTRY
         ST    R15,TRACE@C
ZZ&SYSNDX  DS  0H
         MEND
         EJECT
*---------------------------------------------------------------------
*  This function will provide access to a VSAM file from a REXX exec.
* It is designed to be called as an external function in the MVS/ESA
* environment.  The function call should take the form:
*    RXVSAM(<request>,<ddname>,{<key>|<filetype>,<recordarea>})
* The first 2 arguments are required, 3 and 4 are optional.  Argument
* definitions/values:
*  1. request: OPENINPUT OPENOUTPUT OPENIO
*              CLOSE
*              READ READGENERIC READNEXT READPREV READLAST
*              WRITE REWRITE DELETE
*              STARTFWD STARTBWD
*  2. ddname: must be 1 - 8 uppercase or national characters
*  3. key: the key or rrn (for requests other than OPEN)
*     filetype: either KSDS, ESDS or RRDS (one of the three must be
*               specified in uppercase for OPEN requests)
*     This argument may be null in some cases (READNEXT, READPREV,
*     READLAST, WRITE, DELETE).  A null key for WRITE requests
*     is designed for use in writing to an RRDS for the first time
*     (initialization), and should always be used when writing to
*     an ESDS.  To make the argument 3 null, code an extra comma
*     before argument 4, for example:
*         result = RXVSAM('READNEXT','MYFILE',,'MY_RECORD_AREA')
*     If the key is an RRN, it must be given in decimal.  Direct
*     READs are possible for an ESDS, using RBAs as the key.
*  4. recordarea: the REXX VARIABLE name that contains record data
*     this argument is always ignored for OPEN or CLOSE requests.
*     If this argument is omitted, the variable name RXVSAM_RECORD is
*     used (for READ requests) or assumed (for WRITE|REWRITE requets).
*
*----------------------------------------------------------------------
         EJECT
RXVSAM   CSECT
RXVSAM   AMODE 31
RXVSAM   RMODE ANY
         SPACE
R0       EQU   0                  REGISTER EQUATES
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6                  -> SHVBLOCK (also used as a work reg)
R7       EQU   7                  -> FILE WORK AREA
R8       EQU   8                  -> ARGUMENT LIST
R9       EQU   9                  -> LOCAL WORK AREA
R10      EQU   10                 BASE REGISTER 3
R11      EQU   11                 BASE REGISTER 2
R12      EQU   12                 BASE REGISTER 1
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
MSGDSECT GENMSGS GEN=DSECT
         SPACE 2
         IEANTASM
         PRINT NOGEN
         EJECT
RXVSAM   CSECT                    RESUME CSECT
RXVSAM   KICKOFF                  RESUME CSECT
   PDUMPR (R5),MSG='START',QUIT=ROFF
ROFF RACKOFF
         SPACE
         USING RXVSAM,R12,R11,R10
         BAKR  R14,0              SAVE CALLER'S REGS & RETURN LOC
         LR    R12,R15            SET 1ST BASE REG
         LR    R4,R1              PARK PARM POINTER (R1) IN R4
         LR    R5,R0              PARK ENV BLOCK PTR (R0) IN R5    @ANZ
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE OBTAIN,LENGTH=(R2)    GET LOCAL WORK AREA
         SPACE
         LR    R9,R1              SET BASE REGISTER FOR LOCAL WORK AREA
         USING LOCAL_WORKAREA,R9  SET ADDRESSABILITY
         LR    R2,R9
         LA    R3,LOCAL_WORKAREA_LENGTH
         SR    R15,R15            PAD OF X'00' & ZERO LENGTH
         MVCL  R2,R14             INIT WORKAREA TO BINARY ZERO
         LA    R15,SAVEAREA       SET -> TO OUR SAVE AREA
         ST    R13,4(R15)         CHAIN BACKWARD ->
         ST    R15,8(R13)         CHAIN FORWARD ->
         LR    R13,R15
         LA    R11,4095(R12)      SET 2ND BASE REG
         LA    R11,1(R11)
         LA    R10,4095(R11)      SET 3RD BASE REG
         LA    R10,1(R10)
         B     MAIN100            BRANCH AROUND EYECATCHER
         SPACE
EYECATCH DS    0D
         DC    CL8'RXVSAM'
         DC    CL8'&SYSDATE'
         DC    CL8'&SYSTIME'
         DC    CL16'RELEASE 2.0'
MOVEDDNM MVC   DDNAME(0),0(R3)    EXECUTED INSTRUCTION
         EJECT
MAIN100  DS    0H
   PDUMPR (R5),MSG='START',QUIT=GOBACK
         IAZXJSAB READ,JOBID=MYJOBID
         SPACE
         LR    R1,R4              RESTORE PARM (R1) FROM SAVED REG
         USING EFPL,R1            SET ADDRESSABILITY
         ST    R1,EFPL@           KEEP POINTER AROUND JUST IN CASE
         LA    R6,OURSHVBL        INIT -> TO OUR SHARED VAR BLK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         L     R8,EFPLARG         GET -> TO ARGUMENT LIST
         USING ARGTABLE_ENTRY,R8  SET ADDRESSABILITY
         DROP  R1                 DROP EFPL ADDRESSABILITY
         SPACE
         MVC   VSAMEMSG(VMSGLEN),VMSGINIT  INIT VSAM ERROR MSG AREA
         MVC   NTMSG(NTMSGLEN),NTMSGINI    INIT NAME/TOKEN MSG AREA
         SPACE
         SETMSG MSG=M$ALLOK       INITIALIZE RETURN MESSAGE
         MVC   VSAMER15,=CL2'00'  INITIALIZE VSAM REG 15 RC
         SPACE
*        LOAD  EP=IRXEXCOM        LOAD ROUTINE IRXEXCOM            @ANZ
   PDUMPR (R5)
         ST    R5,ENVB@           SAVE ENVIRONMENT BLOCK POINTER   @ANZ
         USING ENVBLOCK,R5        SET ADDRESSABILITY TO ENVBLOCK   @ANZ
         L     R5,ENVBLOCK_IRXEXTE EXTERNAL ENTRY VECTOR ADDRESS   @ANZ
         USING IRXEXTE,R5         SET ADDRESSABILITY TO EXTE       @ANZ
         L     R0,IRXEXCOM        IRXEXCOM ROUTINE ADDRESS         @ANZ
         DROP  R5                                                  @ANZ
         ST    R0,IRXEXCO@        SAVE ROUTINE ADDRESS FOR LATER USE
         L     R5,ARGTABLE_ARGSTRING_PTR  GET ADDR OF REQUEST ARG
         C     R5,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'
         BE    MAIN400            NO ARG PASSED,ERROR
         SPACE
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT (DDNAME)
         LM    R3,R4,ARGTABLE_ARGSTRING_PTR  GET ADDR & LENGTH OF ARG
         C     R3,=X'FFFFFFFF'    IF ADDRESS IS ALL X'FF'
         BE    MAIN400            NO ARG PASSED,ERROR
         SPACE
         CH    R4,=H'8'           IF DDNAME LONGER THAN 8 CHARACTERS
         BH    MAIN400            IT'S AN ERROR
         LA    R8,ARGTABLE_NEXT   BUMP TO "NEXT" ARGUMENT
         SPACE
         MVC   DDNAME,SPACES      INIT BLANK PADDED DDNAME
         BCTR  R4,0               DECR IN PREPARATION FOR EXECUTED MVC
         EX    R4,MOVEDDNM        SET OUR COPY OF THE DDNAME
         SPACE
         MVC   IEANTNA1,MYJOBID   CREATE "NAME" FOR NAME / TOKEN
         MVI   IEANTNA1,C'X'      SERVICES: JOBID (1ST CHAR ALWAYS "X")
         MVC   IEANTNA2,DDNAME    PLUS DDNAME
         XC    IEANTTOK,IEANTTOK  CLEAR OUT "TOKEN"
         MVC   IEANTLVL,=AL4(IEANT_TASK_LEVEL)  TASK LVL FOR ALL REQ
         EJECT
MAIN200  DS    0H
*
* THE FOLLOWING USING IS GLOBAL (FOR THE REST OF THE CSECT).  IT IS THE
* INDIVIDUAL ROUTINE'S RESPONSIBILITY TO ENSURE R7 CONTAINS A VALID
* ADDRESS WHEN A FILE WORK AREA IS "ACTIVE"
*
         USING FWABLOCK,R7
*
* PERFORM CORRECT ROUTINE BASED ON FUNCTION REQUEST - SET R14 AS A
* "RETURN" ADDRESS
*
         LA    R14,MAIN500        SERVES AS A "RETURN" POINT
         CLC   =CL4'OPEN',0(R5)
         BE    OPEN000
         CLC   =CL4'CLOS',0(R5)
         BE    CLOS000
         CLC   =CL4'READ',0(R5)
         BE    READ000
         CLC   =CL4'WRIT',0(R5)
         BE    WRIT000
         CLC   =CL4'REWR',0(R5)
         BE    REWR000
         CLC   =CL4'DELE',0(R5)
         BE    DELE000
         CLC   =CL4'STAR',0(R5)
         BE    STAR000
         SPACE
MAIN400  DS    0H
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         B     MAIN900            EXIT
         EJECT
MAIN500  DS    0H
         SPACE
*+*+*+
*  NEED TO CHECK FOR AN INVALID NAME / TOKEN REQUEST & PUT ERROR
*  MESSAGE IN A REXX VARIABLE IF NECESSARY
*+*+
         LA    R2,VMSGVAR         ELSE, SET MESSAGE: GET -> TO MESSAGE
         LA    R3,L'VMSGVAR       VARIABLE NAME & LENGTH OF VAR NAME
         STM   R2,R3,SHVNAMA      STORE IN SHV PARM LIST (2 FULLWORDS)
         CLC   VSAMER15,=CL2'00'  IS VSAM REG 15 RC ZERO?
         BE    MAIN520            YES, RESET VARIABLE TO ITS DEFAULT
         SPACE
         MVC   SHVVALL,=A(VSAMELEN)   ELSE, SET IT TO OUR "REAL"
         LA    R0,VSAMEMSG        VARIABLE
         ST    R0,SHVVALA
         B     MAIN530
         SPACE
MAIN520  DS    0H
         SPACE
         MVC   SHVVALL,SHVNAML    NAME LENGTH & VAR LENGTH ARE EQUAL
         MVC   SHVVALA,SHVNAMA    NAME AND VALUE ARE THE SAME TOO
         SPACE
MAIN530  DS    0H
         SPACE
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       GET EPA TO IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         BZ    MAIN900            IF ALL OK, CONTINUE
         SPACE
         SETMSG MSG=M$VMSG        ELSE, SET MESSAGE THEN FALL THRU
         SPACE
MAIN900  DS    0H
         LA    R0,L'RMSGVAR       LENGTH OF RET MSG VARIABLE NAME
         ST    R0,SHVNAML         SET LENGTH IN SHARED VARIABLE BLOCK
         LA    R0,RMSGVAR         -> TO VARIABLE NAME
         ST    R0,SHVNAMA
         LH    R0,MSGLEN          LENGTH OF VARIABLE
         ST    R0,SHVVALL
         L     R0,MSG@            GET -> TO MESSAGE
         ST    R0,SHVVALA
         MVI   SHVCODE,SHVSTORE   REQUEST: STORE A VARIABLE
         L     R15,IRXEXCO@       ADDR OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF  CHECK ERROR BITS
         BZ    MAIN950            IF ALL OK, CONTINUE
         SPACE
         SETMSG MSG=M$RMSG        REVISE RETURN MESSAGE
         EJECT
MAIN950  DS    0H
         L     R1,EFPL@           GET POINTER TO ORIGINAL PARM LIST
         USING EFPL,R1            SET ADDRESSABILITY
         L     R2,EFPLEVAL        GET -> TO EVALUATION BLOCK
         L     R2,0(,R2)          GET ACTUAL ADDRESS OF BLOCK
         USING EVALBLOCK,R2       SET ADDRESSABILITY
         L     R14,MSG@           1ST 4 BYTES OF MSG ARE THE RESULT
         MVC   EVALBLOCK_EVLEN,=F'4'          PASS RESULT BACK IN THE
         MVC   EVALBLOCK_EVDATA(4),0(R14)     EVALUATION BLOCK
         DROP  R2,R1
         SPACE
GOBACK   DS    0H
         LA    R2,LOCAL_WORKAREA_LENGTH  SIZE OF OUR LOCAL WORK AREA
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R9)    RELEASE WORK AREA
         SPACE
         SLR   R15,R15            MAKE SURE RETURN CODE IS ZERO
         PR                       RETURN TO CALLER
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
OPEN000  DS    0H
*
* UPON ENTRY, R8 -> ARGUMENT LIST 3 SLOT (FILE TYPE), R5 STILL -> TO
* TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         L     R4,ARGTABLE_ARGSTRING_PTR
         C     R4,=X'FFFFFFFF'    IS ADDRESS ALL X'FF' ?
         BNE   OPEN010            NO, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         B     OPEN999
         SPACE
OPEN010  DS    0H    -- SEE IF THERE'S A NAME / TOKEN FOR THIS FILE --
         BAS   R14,RTRVTOK0
         SPACE
         CH    R15,=AL2(IEANT_NOT_FOUND)   IF NO TOKEN EXISTS
         BE    OPEN020                     IT'S OK TO CONTINUE
         SPACE
         LTR   R15,R15                     IF A TOKEN EXISTS
         BZ    OPEN015                     FILE IS ALREADY OPEN
         SPACE
         NTERROR REQ=RETRIEVE,SYM=OPEN010,GOTO=OPEN999
         SPACE
OPEN015  DS    0H
         SETMSG MSG=M$PREVOP
         B     OPEN999          THE FILE IS ALREADY OPEN - EXIT
         SPACE
OPEN020  DS    0H
         LA    R2,FWALEN        LENGTH OF FILE WORK AREA
         STORAGE OBTAIN,LENGTH=(R2)    GET A NEW FILE WORK AREA
         SPACE
         LR    R7,R1            -> TO FWA (ADDRESSABILITY ALREADY SET)
         LR    R2,R7
         LA    R3,FWALEN
         SR    R15,R15
         MVCL  R2,R14           INIT AREA TO X'00'
*
* NOTE: R3 REMAINS AS A POINTER TO THE ACB THROUGHOUT THE REST OF THE
*       OPEN LOGIC
*
         LA    R3,ACBAREA         -> TO OUR ACB
         EJECT
         CLC   =CL4'KSDS',0(R4)   KSDS?
         BNE   OPEN030            NO, TRY NEXT POSSIBLITY
         SPACE
         OI    F@OPENFL,F@OSEQ+F@ODIR+F@OKSDS     SET OUR FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X
               LENGTH=ACBAREAL,WAREA=(R3),RMODE31=ALL,                 X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         BZ    OPEN100            YES - CONTINUE
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN030  DS    0H
         CLC   =CL4'ESDS',0(R4)   ESDS?
         BNE   OPEN040            NO, TRY NEXT POSSIBLITY
         SPACE
         OI    F@OPENFL,F@OSEQ+F@OESDS          SET FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(ADR,SEQ),              X
               LENGTH=ACBAREAL,WAREA=(R3),RMODE31=ALL,                 X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         BZ    OPEN100            YES - CONTINUE
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN040  DS    0H
         CLC   =CL4'RRDS',0(R4)   RRDS?
         BNE   OPEN050            NO, DO ERROR PROCESSING
         SPACE
         OI    F@OPENFL,F@OSEQ+F@ODIR+F@ORRDS         SET FLAGS
         GENCB BLK=ACB,DDNAME=(*,DDNAME),MACRF=(KEY,SEQ,DIR),          X
               LENGTH=ACBAREAL,WAREA=(R3),RMODE31=ALL,                 X
               MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            GENCB SUCCESSFUL?
         BZ    OPEN100            YES - CONTINUE
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN050  DS    0H
         SETMSG MSG=M$BADARG      SET BAD RESULT CODE
         B     OPEN999
         EJECT
OPEN100  DS    0H
         CLC   =CL9'OPENINPUT',0(R5)    OPEN INPUT?
         BNE   OPEN110            NO, TRY NEXT POSSIBILITY
         SPACE
         OI    F@OPENFL,F@OIN           SET FLAG
         MODCB ACB=(R3),MACRF=(IN),RMODE31=ALL,MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    OPEN200            YES - READY TO ISSUE OPEN
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN110  DS    0H
         CLC   =CL6'OPENIO',0(R5) INPUT & OUTPUT?
         BNE   OPEN120            NO, TRY NEXT POSSIBILITY
         SPACE
         OI    F@OPENFL,F@OIN+F@OOUT    SET FLAGS
         MODCB ACB=(R3),MACRF=(IN,OUT),RMODE31=ALL,                    X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    OPEN200            YES - READY TO ISSUE OPEN
         B     OPEN900            NO - DO ERROR HANDLING
         EJECT
OPEN120  DS    0H
         CLC   =CL10'OPENOUTPUT',0(R5)   ONLY OUTPUT?
         BNE   OPEN130            NO, BAD ARGUMENT
         SPACE
         OI    F@OPENFL,F@OOUT           SET FLAG
         MODCB ACB=(R3),MACRF=(OUT),RMODE31=ALL,MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    OPEN200            YES - READY TO ISSUE OPEN
         B     OPEN900            NO - DO ERROR HANDLING
         SPACE
OPEN130  DS    0H
         SETMSG MSG=M$BADARG     SET BAD RESULT CODE
         B     OPEN999
         EJECT
OPEN200  DS    0H
         XC    OPEN_PARMLIST,OPEN_PARMLIST   INIT AREA
         OI    OPEN_PARMLIST,X'80'           HI-ORDER ON = 31 BIT FORM
         ST    R3,OPEN_PARMLIST+4            STORE ACB -> IN 2ND WORD
         OPEN  MODE=31,MF=(E,OPEN_PARMLIST)  OPEN DATASET
         SPACE
         LTR   R15,R15            WAS OPEN SUCCESSFUL?
         BNZ   OPEN210            NO - DO ERROR PROCESSING
         SPACE
         B     OPEN300            READY TO GENERATE RPL
         SPACE
OPEN210  DS    0H
         MVC   VSAMELAB,=CL8'OPEN210'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    OPEN230            YES - GO PICK UP ERROR MESSAGE
         SPACE
OPEN220  DS    0H
         MVC   VSAMELAB,=CL8'OPEN220'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         B     OPEN990            AND EXIT ROUTINE
         SPACE
OPEN230  DS    0H
         LH    R0,HALFWRK2
         CVD   R0,DBLWRK
         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE
         OI    VSAMEREA+3,X'F0'
         B     OPEN990            AND EXIT ROUTINE
         EJECT
OPEN300  DS    0H      -- GET MAX RECORD LENGTH & GENERATE RPL --
         LA    R2,F@LRECL
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,                           X
               FIELDS=LRECL,MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    OPEN310            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'OPEN300'
         MVC   VSAMEREA,=CL4'0000'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CH    R15,=H'4'          IF R15 ISN'T 4, REASON CODE ISN'T
         BNE   OPEN999            IN R0
         SPACE
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SETMSG MSG=M$BADSCB      SET BAD RESULT CODE
         SPACE
         B     OPEN999
         SPACE
OPEN310  DS    0H
         L     R2,F@LRECL         GET MAX LRECL FROM SHOWCB
         N     R2,=X'FFFFFFFC'
         LA    R2,8(R2)           ROUND UP TO NEXT DOUBLEWORD
         ST    R2,F@BUFLEN        SAVE LENGTH FOR LATER USE
         STORAGE OBTAIN,LENGTH=(R2)
         SPACE
         ST    R1,F@RECBUF        SAVE ADDRESS OF STORAGE
         SPACE
OPEN320  DS    0H            -- READY TO GENERATE RPL --
         LA    R2,RPLAREA         -> TO WHERE RPL WILL BE BUILT
         CLC   =CL4'KSDS',0(R4)   KSDS?
         BE    OPEN400
         CLC   =CL4'RRDS',0(R4)   RRDS?
         BE    OPEN410
         CLC   =CL4'ESDS',0(R4)   ESDS?
         BE    OPEN420
         EJECT
OPEN400  DS    0H                        -- KSDS --
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         SPACE
OPEN410  DS    0H                        -- RRDS --
         OI    F@RPLFL,F@RKEY+F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(KEY,ARD,SEQ,FWD,KEQ,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         SPACE
OPEN420  DS    0H                        -- ESDS --
         OI    F@RPLFL,F@RARD+F@RSEQ+F@RFWD+F@RKEQ+F@RFKS
         L     R4,F@RECBUF        -> RECORD BUFFER
         L     R5,F@BUFLEN        SIZE OF BUFFER
         LA    R6,F@RPLARG        -> KEY (ARGUMENT)
         GENCB BLK=RPL,ACB=(R3),AREA=(R4),AREALEN=(R5),WAREA=(R2),     X
               LENGTH=RPLAREAL,OPTCD=(ADR,ARD,SEQ,FWD,KEQ,FKS),        X
               ARG=(R6),MF=(G,GENCB_PARMLIST)
         SPACE
         LTR   R15,R15            ALL OK?
         BZ    OPEN500            YES, CONTINUE
         B     OPEN910            NO, DO ERROR HANDLING
         EJECT
OPEN500  DS    0H
         XC    IEANTTOK,IEANTTOK  CLEAR OUT TOKEN AREA
         ST    R7,IEANTTOK        SAVE -> TO FILE WORK AREA
         MVC   IEANTPOP,=AL4(IEANT_NOPERSIST)
*
* CREATE A NAME / TOKEN SO WE CAN FIND THE FILE WORK AREA NEXT TIME
* RXVSAM IS CALLED
*
*        LOAD  EP=IEANTCR         LOAD ROUTINE IEANTCR             @ANZ
*        LR    R15,R0                                              @ANZ
         L     R15,=V(IEANTCR)    IEANTCR ENTRY POINT ADDRESS      @ANZ
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTPOP,IEANTRC),     X
               MF=(E,IEANTLST)
         SPACE
         LTR   R15,R15
         BZ    OPEN999            IF CREATE SUCCEEDED, ALL DONE
         SPACE
         NTERROR REQ=CREATE,SYM=OPEN500,GOTO=OPEN999
         SPACE 3
OPEN900  DS    0H      -- GENERAL ERROR GENERATING THE ACB --
         MVC   VSAMELAB,=CL8'OPEN900'
         B     OPEN920
         SPACE
OPEN910  DS    0H      -- GENERAL ERROR GENERATING THE RPL --
         MVC   VSAMELAB,=CL8'OPEN910'  SET LABEL & FALL THRU
         SPACE
OPEN920  DS    0H
         MVC   VSAMEREA,=CL2'00'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BAS   R14,GETREG0        CHECK FOR REASON CODE IN R0
         SPACE
OPEN990  DS    0H
         SETMSG MSG=M$BADOPN      SET BAD RESULT CODE & FALL-THRU
         SPACE
OPEN999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
CLOS000  DS    0H
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    CLOS100            FILE IS OPEN
         SPACE
         CH    R15,=AL2(IEANT_NOT_FOUND) FOR ANYTHING OTHER THAN "NOT
         BNE   CLOS050            FOUND" GENERATE A NAME / TOKEN ERROR
         SPACE
         SETMSG MSG=M$CLOSAC      ASSUME FILE ISN'T OPEN
         B     CLOS999
         SPACE
CLOS050  DS    0H
         NTERROR REQ=RETRIEVE,SYM=CLOS000,GOTO=CLOS999
         SPACE
CLOS100  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         OC    ACBAREA,ACBAREA    ACB AREA SHOULD BE NON-ZERO
         BNZ   CLOS150            IF IT IS, CONTINUE
         SPACE
         SETMSG MSG=M$CLOSAC      IF ACB IS ZERO, ASSUME FILE ISN'T
         B     CLOS999            OPEN - GENERATE MESSAGE & EXIT
         SPACE
CLOS150  DS    0H
         XC    CLOSE_PARMLIST,CLOSE_PARMLIST INIT AREA
         OI    CLOSE_PARMLIST,X'80'          HI-ORDER ON = 31 BIT FORM
         LA    R3,ACBAREA                    STORE POINTER TO ACB
         ST    R3,CLOSE_PARMLIST+4           IN 2ND WORD OF LIST
         CLOSE MODE=31,MF=(E,CLOSE_PARMLIST)
         SPACE
         LTR   R15,R15            SUCCESSFUL?
         BZ    CLOS500            YES - GO DELETE ACB VARIABLE
         SPACE
         MVC   VSAMELAB,=CL8'CLOS000'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB ACB=(R3),AREA=(R2),LENGTH=4,FIELDS=ERROR,              X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    CLOS300            YES - GO PICK UP ERROR MESSAGE
         EJECT
CLOS200  DS    0H
         MVC   VSAMELAB,=CL8'CLOS200'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         B     CLOS990            AND EXIT ROUTINE
         SPACE
CLOS300  DS    0H
         UNPK  VSAMEREA,HALFWRK2  SET REASON CODE IN MESSAGE
         OI    VSAMEREA+3,X'F0'
         B     CLOS990
         SPACE
CLOS500  DS    0H      -- CLEANUP STUFF --
         OC    F@RECBUF,F@RECBUF    DO WE HAVE A RECORD BUFFER?
         BZ    CLOS510              NO, JUST DO FWA CLEANUP
         SPACE
         L     R2,F@BUFLEN          LENGTH OF RECORD BUFFER
         L     R3,F@RECBUF          ADDRESS OF RECORD BUFFER
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R3)    RELEASE REC BUFFER
         SPACE
CLOS510  DS    0H
         LA    R2,FWALEN            LENGTH OF FILE WORK AREA
         STORAGE RELEASE,LENGTH=(R2),ADDR=(R7)    RELEASE FWA
         SPACE
*        LOAD  EP=IEANTDL         LOAD ROUTINE IEANTDL             @ANZ
*        LR    R15,R0                                              @ANZ
         L     R15,=V(IEANTDL)    IEANTDL ENTRY POINT ADDRESS      @ANZ
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTRC),MF=(E,IEANTLST)
         SPACE
         LTR   R15,R15              IF NAME / TOKEN DELETE WAS OK
         BZ    CLOS999              ALL DONE
         SPACE
         NTERROR REQ=DELETE,SYM=CLOS510,GOTO=CLOS999
         SPACE
CLOS990  DS    0H
         SETMSG MSG=M$BADCLO      SET MESSAGE & FALL-THRU
         SPACE
CLOS999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
READ000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    READ010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=READ000,GOTO=READ999
         SPACE
READ010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OIN     FILE OPEN FOR INPUT?
         BO    READ020            YES
         SPACE
         SETMSG MSG=M$NOIN        NO, SET MESSAGE
         B     READ999            AND EXIT
         SPACE
READ020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE READ LOGIC, R4 -> RPLAREA
*
         LA    R4,RPLAREA
*
*  FOR ANY READ TYPE, IF THE FILE IS OPEN FOR OUTPUT, ALLOW FOR THE
*  POSSIBILITY OF UPDATE (ENSURE RPL IS SET UP TO ALLOW UPDATE)
*
         TM    F@OPENFL,F@OOUT    IS FILE OPEN FOR OUTPUT?
         BZ    READ040            NO, LET RPL STAND AS IS
         SPACE
         TM    F@RPLFL,F@RUPD     ALREADY SET UP FOR UPDATE?
         BNZ   READ040            YES, NO CHANGE TO RPL NEEDED
         SPACE
         MODCB RPL=(R4),OPTCD=(UPD),MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID MODCB WORK?
         BZ    READ030            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ020'
         MVC   VSAMEREA,=CL2'00'
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BAS   R14,GETREG0        CHECK FOR REASON CODE IN REGISTER 0
         SETMSG MSG=M$BADUPD
         B     READ999            EXIT ROUTINE
         SPACE
READ030  DS    0H
         OI    F@RPLFL,F@RUPD     RESET FLAG TO INDICATE UPDATE
         EJECT
READ040  DS    0H        -- BRANCH TABLE FOR READ REQUEST TYPE --
         CLC   =CL11'READGENERIC',0(R5)
         BE    READ100
         CLC   =CL8'READNEXT',0(R5)
         BE    READ200
         CLC   =CL8'READPREV',0(R5)
         BE    READ300
         CLC   =CL8'READLAST',0(R5)
         BE    READ400
         B     READ500
         EJECT
READ100  DS    0H         -- GENERIC READ --
         TM    F@OPENFL,F@OKSDS   IS FILE A KSDS?
         BO    READ102            YES, GENERIC READ IS ALLOWED
         SETMSG MSG=M$NOGEN       OTHERWISE, SET ERROR MESSAGE
         B     READ999            AND EXIT ROUTINE
         SPACE
READ102  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BE    READ104            NO, DO ERROR STUFF
         LTR   R3,R3              WAS ARG LENGTH ZERO?
         BZ    READ104            YES, DO ERROR STUFF
         B     READ106            KEY IS OK, CONTINUE PROCESSING
         SPACE
READ104  DS    0H
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ106  DS    0H
         TM    F@RPLFL,F@RDIR     IS RPL SET UP FOR DIRECT READ?
         BO    READ108            YES, GO SET UP GENERIC KEY
         BAS   R14,TODIR          CHANGE TO DIRECT READ
         LTR   R15,R15            IF R15 IS ZERO
         BZ    READ108            RESET WAS SUCCESSFUL
         B     READ999            ELSE, EXIT IMMEDIATELY
         SPACE
READ108  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUR ARGUMENT/KEY AREA
         ST    R3,F@ARGLEN        SAVE LENGTH OF ARGUMENT
         BCTR  R3,0               DECREMENT FOR EXECUTED MVC
         EX    R3,ARGMVC          COPY KEY TO OUR AREA
         TM    F@RPLFL,F@RFKS+F@RKEQ   RPL SET UP FOR FULL KEY?
         BZ    READ600            NO, ALREADY SET FOR GENERIC, DO GET
         SPACE
         L     R2,F@ARGLEN        ACTUAL LENGTH OF GENERIC KEY
         MODCB RPL=(R4),OPTCD=(KGE,GEN),KEYLEN=(R2),                   X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ110            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ102'      SET LABEL IN ERROR MSG
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ110  DS    0H
         NI    F@RPLFL,X'FF'-(F@RFKS+F@RKEQ)    RESET OUR FLAG BITS
         B     READ600            GO GET RECORD
         EJECT
READ200  DS    0H         -- READ NEXT RECORD --
*
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BNE   READ202            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ202  DS    0H
         TM    F@RPLFL,F@RSEQ+F@RFWD  SET FOR SEQ / FWD ?
         BO    READ600            YES, READY TO GET RECORD
         SPACE
         MODCB RPL=(R4),OPTCD=(SEQ,FWD),                               X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            IF MODCB WORKED (RPL IS RESET)
         BZ    READ204            RESET OUR FLAG AND GO GET RECORD
         SPACE
         MVC   VSAMELAB,=CL8'READ204'   ELSE, SET ERROR MSG
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ204  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RFWD     RESET FLAG
         NI    F@RPLFL,X'FF'-F@RDIR
         B     READ600            GO GET RECORD
         EJECT
READ300  DS    0H         -- READ PREVIOUS RECORD --
*
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BNE   READ302            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ302  DS    0H
         CLI   F@POINT,F@POINTY   HAS FILE POSITIONING BEEN DONE?
         BE    READ304            YES, CONTINUE
         SPACE
         SETMSG MSG=M$NOPOS       SET MESSAGE - NO PREVIOUS "STARTBWD"
         B     READ999
         SPACE
READ304  DS    0H
         TM    F@RPLFL,F@RSEQ     SET FOR SEQUENTIAL ACCESS?
         BZ    READ306            NO, NEED TO ISSUE THE MODCB
         TM    F@RPLFL,F@RFWD     SET UP FOR FORWARD PROCESSING?
         BZ    READ600            NO, CAN PROCEED DIRECTLY TO GET REC
         SPACE
READ306  DS    0H
         MODCB RPL=(R4),OPTCD=(SEQ,BWD),                               X
               MF=(G,MODCB_PARMLIST)
         SPACE
         LTR   R15,R15            IF MODCB WORKED
         BZ    READ308            RESET OUR FLAG AND GO GET RECORD
         SPACE
         MVC   VSAMELAB,=CL8'READ306'   ELSE, SET ERROR MSG
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ308  DS    0H
         NI    F@RPLFL,X'FF'-(F@RFWD+F@RDIR)  NOW BACKWARD & NOT DIR
         OI    F@RPLFL,F@RSEQ           IS NOW SEQUENTIAL PROCESSING
         B     READ600            GO GET RECORD
         EJECT
READ400  DS    0H           -- READ LAST RECORD --
*
*  NOTE: THE NORMAL "GET" PROCESSING (AT LABEL READ600) IS NOT DONE
*        FOR THIS REQUEST SINCE THE RPL NEEDS TO BE SWITCHED BACK TO
*        ARD (USER'S ARGUMENT GOVERNS REQUEST) AFTER THE GET IS DONE.
*  A "KEY" (3RD ARGUMENT) MUST BE SUPPLIED, ALTHOUGH IT MAY BE NULL
*
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BNE   READ402            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ402  DS    0H
         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?
         BO    READ404            YES, CONTINUE
         SPACE
         BAS   R14,TODIR          NO, CHANGE TO DIRECT PROCESSING
         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL
         BZ    READ404
         B     READ999            ELSE, JUST GIVE UP
         SPACE
READ404  DS    0H
         MODCB RPL=(R4),OPTCD=(BWD,LRD),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ406            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ404'      NO, SET ERROR MESSAGE LABEL
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ406  DS    0H
         NI    F@RPLFL,X'FF'-F@RFWD   RESET OUR FLAG
         GET   RPL=(R4)
         SPACE
         LTR   R15,R15            SUCCESSFUL GET?
         BZ    READ408
         SPACE
         MVC   VSAMELAB,=CL8'READ406'
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ408  DS    0H
         MODCB RPL=(R4),OPTCD=(ARD),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ800            YES, GO SET RECORD AS A REXX VARIABLE
         SPACE
         MVC   VSAMELAB,=CL8'READ408'      NO, SET ERROR MESSAGE LABEL
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         EJECT
READ500  DS    0H           -- DIRECT READ --
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS KEY SUPPLIED?
         BE    READ502            NO, DO ERROR STUFF
         LTR   R3,R3              WAS KEY LENGTH ZERO?
         BZ    READ502            YES, DO ERROR STUFF
         B     READ504            KEY ARGUMENT OK, CONTINUE
         SPACE
READ502  DS    0H
         SETMSG MSG=M$BADARG      INVALID ARGUMENT
         B     READ999            EXIT ROUTINE
         SPACE
READ504  DS    0H
         TM    F@RPLFL,F@RDIR     SET UP FOR DIRECT PROCESSING?
         BO    READ506            YES, CONTINUE
         SPACE
         BAS   R14,TODIR          NO, GO CHANGE TO DIRECT PROCESSING
         LTR   R15,R15            IF R15 IS ZERO, CHANGE WAS SUCCESSFUL
         BZ    READ506
         B     READ999            OTHERWISE, QUIT
         SPACE
READ506  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR KEY AREA
         ST    R3,F@ARGLEN        SAVE KEY (ARGUMENT) LENGTH
         BCTR  R3,0               DECR LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY KEY
         TM    F@RPLFL,F@RFKS+F@RKEY   SET UP FOR FULL/EQUAL KEY?
         BO    READ510            YES, CHECK FOR DATASET TYPE
         SPACE
         MODCB RPL=(R4),OPTCD=(KEQ,FKS),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    READ508            YES, RESET OUR FLAG & GET RECORD
         SPACE
         MVC   VSAMELAB,=CL8'READ506'   NO, SET ERROR MESSAGE LABEL
         B     READ990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
READ508  DS    0H
         OI    F@RPLFL,F@RFKS+F@RKEQ   RESET OUR FLAG BITS
         SPACE
READ510  DS    0H
         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS
         BO    READ600            READY TO GET RECORD
         SPACE
         BAS   R14,CONVKEY        ELSE, CONVERT "KEY"
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         BNZ   READ999            ELSE, FALL-THRU TO READ600
         EJECT
READ600  DS    0H   -- PERFORM GET MACRO & CHECK RESULT --
         GET   RPL=(R4)
         SPACE
         LTR   R15,R15            SUCCESSFUL GET?
         BZ    READ800            YES, SET RECORD AS A REXX VARIABLE
         SPACE
         MVC   VSAMELAB,=CL8'READ600'
         BAS   R14,GETFDBK        GO GET FEEDBACK WORD
         SPACE
         CLC   VSAMEREA,FDBKNF    NOT FOUND?
         BNE   READ602            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$NOTFND      YES, SET MESSAGE
         B     READ999            AND CONSIDER READ "SUCCESSFUL"
         SPACE
READ602  DS    0H
         CLC   VSAMEREA,FDBKEOF   END OF FILE
         BNE   READ604            NO, MUST BE SOME HOSEUP
         SETMSG MSG=M$EOF         YES, SET MESSAGE
         B     READ999            AND CONSIDER READ "SUCCESSFUL"
         SPACE
READ604  DS    0H
         SETMSG MSG=M$BADFUN      READ FAILED
         B     READ999            EXIT ROUTINE
         EJECT
READ800  DS    0H      -- RECORD OBTAINED, SET REXX VARIABLE --
         LA    R2,FULLWRK1
         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(RECLEN),           X
               MF=(G,SHOWCB_PARMLIST)
         LTR   R15,R15            SHOWCB WORKED?
         BZ    READ802            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'READ800'
         CVD   R15,DBLWRK         SET R.C. FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE FROM SHOWCB
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SETMSG MSG=M$NORLEN
         B     READ999
         SPACE
READ802  DS    0H
         LA    R8,ARGTABLE_NEXT   GET LAST ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR
         C     R2,=X'FFFFFFFF'    WAS RECORD VARIABLE NAME SUPPLIED?
         BNE   READ804            YES, GO SET VARIABLE
         SPACE
         LA    R2,RECVARDF        NO, USE OUR DEFAULT
         LA    R3,L'RECVARDF
         SPACE
READ804  DS    0H
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         STM   R2,R3,SHVNAMA      STORE -> & LENGTH OF VARIABLE NAME
         MVC   SHVVALL,FULLWRK1   LENGTH OF RECORD AREA
         MVC   SHVVALA,F@RECBUF   ADDRESS OF RECORD AREA
         MVI   SHVCODE,SHVSTORE   NEED TO STORE THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF REXX VARIABLE ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF    CHECK ERROR BITS
         BZ    READ999            IF VAR STORED SUCCESSFULLY, ALL DONE
         SPACE
         SETMSG MSG=M$NOREC       SET ERROR MESSAGE
         B     READ999            EXIT ROUTINE
         SPACE
READ990  DS    0H     -- GENERAL ERROR LOGIC FOR MODCB FAILURE --
         BAS   R14,GETREG0        GET REASON CODE
         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT
         SPACE
READ999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
STAR000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    STAR010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=STAR000,GOTO=STAR999
         SPACE
STAR010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OESDS   ESDS FILE?
         BZ    STAR020            NO, THEN IT'S OK TO DO A START
         SPACE
         SETMSG MSG=M$NOESDS      YES, THEN START ISN'T ALLOWED
         B      STAR999           EXIT ROUTINE
         SPACE
STAR020  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR     WAS KEY SUPPLIED?
         C     R2,=X'FFFFFFFF'
         BE    STAR030            NO, DO ERROR STUFF
         LTR   R3,R3              WAS IT'S LENGTH ZERO?
         BZ    STAR030            YES, DO ERROR STUFF
         B     STAR040            KEY WAS OK, CONTINUE
         SPACE
STAR030  DS    0H
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     STAR999            AND EXIT ROUTINE
         SPACE
STAR040  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUT ARGUMENT AREA
         ST    R3,F@ARGLEN        SAVE KEY LENGTH
         BCTR  R3,0               DECREMENT FOR EXECUTE
         EX    R3,ARGMVC          COPY KEY
         TM    F@OPENFL,F@OKSDS   IF FILE IS A KSDS
         BO    STAR050            GO CHECK REQUEST
         SPACE
         BAS   R14,CONVKEY        ELSE, CONVERT "KEY"
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         BNZ   STAR999            ELSE, FALL-THRU TO STAR050
         EJECT
STAR050  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> RPLAREA
*
         LA    R4,RPLAREA
         CLC   =CL8'STARTFWD',0(R5)
         BE    STAR100
         CLC   =CL8'STARTBWD',0(R5)
         BE    STAR200
         SPACE
         SETMSG MSG=M$BADARG
         B     STAR999
         SPACE
STAR100  DS    0H           -- POSITION FOR FORWARD READING --
         TM    F@RPLFL,F@RSEQ+F@RFWD    SET FOR SEQUENTIAL/FWD?
         BNO   STAR102            NO, NEED TO ISSUE MODCB
         TM    F@RPLFL,F@RKEQ+F@RFKS    SET FOR KEY = / FULL KEY?
         BNZ   STAR102            YES, NEED TO ISSUE MODCB
         B     STAR600            READY TO ISSUE POINT MACRO
         SPACE
STAR102  DS    0H
         L     R2,F@ARGLEN        ARGUMENT (KEY LENGTH)
         MODCB RPL=(R4),OPTCD=(SEQ,FWD,KGE,GEN),KEYLEN=(R2),           X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    STAR104            YES, RESET OUR FLAGS & DO POINT
         SPACE
         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL
         BAS   R14,GETREG0        OBTAIN REASON CODE
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         B     STAR999
         SPACE
STAR104  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RFWD     SET OUR FLAGS
         NI    F@RPLFL,X'FF'-(F@RDIR+F@RKEQ+F@RFKS)
         B     STAR600            READY TO ISSUE POINT MACRO
         EJECT
STAR200  DS    0H      -- POSITION FOR BACKWARD READING --
         TM    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS  SEQ / KEY = / FULL KEY?
         BNO   STAR202            NO, NEED TO ISSUE MODCB
         TM    F@RPLFL,F@RFWD     FORWARD?
         BO    STAR202            YES, NEED TO ISSUE MODCB
         B     STAR600            READY TO ISSUE POINT MACRO
         SPACE
STAR202  DS    0H
         MODCB RPL=(R4),OPTCD=(SEQ,BWD,KEQ,FKS),                       X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB SUCCESSFUL?
         BZ    STAR204            YES, RESET OUR FLAGS & DO POINT
         SPACE
         MVC   VSAMELAB,=CL8'STAR102'    NO, SET ERROR MESSAGE LABEL
         BAS   R14,GETREG0        OBTAIN REASON CODE
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         B     STAR999
         SPACE
STAR204  DS    0H
         OI    F@RPLFL,F@RSEQ+F@RKEQ+F@RFKS     SET OUR FLAGS
         NI    F@RPLFL,X'FF'-(F@RDIR+F@RFWD)
         B     STAR600            READY TO ISSUE POINT MACRO
         EJECT
STAR600  DS    0H     -- ISSUE POINT FOR FILE POSITIONING --
         POINT RPL=(R4)
         SPACE
         LTR   R15,R15            POINT SUCCESSFUL?
         BZ    STAR900            YES, ALL DONE
         SPACE
         MVI   F@POINT,F@POINTN   NO FILE POSITIONING
         BAS   R14,GETFDBK        GO GET FEEDBACK WORD
         SPACE
         CLC   VSAMEREA,FDBKEOF   WAS IT AN "END OF FILE"?
         BNE   STAR602            NO, TRY NEXT POSSIBILITY
         SPACE
         SETMSG MSG=M$EOF         YES, SET MESSAGE
         B      STAR999           CONSIDER START "SUCCESSFUL"
         SPACE
STAR602  DS    0H
         CLC   VSAMEREA,FDBKNF    WAS IT A "NOT FOUND"?
         BNE   STAR604            NO, MUST BE SOME GENUINE HOSEUP
         SPACE
         SETMSG MSG=M$BWDNF       YES, SET MESSAGE
         B      STAR999           CONSIDER START "SUCCESSFUL"
         SPACE
STAR604  DS    0H
         MVC   VSAMELAB,=CL8'STAR604'   POINT GOT AN UNEXPECTED ERROR
         SETMSG MSG=M$BADFUN      SET MESSAGE
         B     STAR999            EXIT
         SPACE
STAR900  DS    0H
         MVI   F@POINT,F@POINTY   FILE POSITIONING HAS BEEN DONE
         SPACE 2
STAR999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
WRIT000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY) AND R5 STILL -> TYPE OF REQUEST
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    WRIT010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=WRIT000,GOTO=WRIT999
         SPACE
WRIT010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    WRIT020            YES
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         B     WRIT999            AND EXIT
         SPACE
WRIT020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE START LOGIC, R4 -> RPLAREA
*
         LA    R4,RPLAREA
         TM    F@RPLFL,F@RUPD     SET FOR UPDATE?
         BZ    WRIT100            NO, READY TO DO RECORD STUFF
         SPACE
         MODCB RPL=(R4),OPTCD=(NUP),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    WRIT030            YES, RESET OUR FLAGS, ETC.
         SPACE
         MVC   VSAMELAB,=CL8'WRIT020'
         B     WRIT990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
WRIT030  DS    0H
         NI    F@RPLFL,X'FF'-F@RUPD     RESET FLAG & FALL-THRU
         EJECT
WRIT100  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?
         BNE   WRIT110            YES, CONTINUE
         SPACE
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     WRIT999            EXIT ROUTINE
         SPACE
WRIT110  DS    0H
         LTR   R3,R3              IF ARG IS NONNULL,
         BNZ   WRIT130            COPY "KEY" INTO OUR AREA
         SPACE
         MODCB RPL=(R4),OPTCD=(SEQ),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    WRIT120            YES, RESET OUR FLAGS, ETC.
         SPACE
         MVC   VSAMELAB,=CL8'WRIT110'
         B     WRIT990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
WRIT120  DS    0H
         OI    F@RPLFL,F@RSEQ     NOW SET FOR SEQUENTIAL ACCESS
         NI    F@RPLFL,X'FF'-F@RDIR   NO LONGER SET FOR DIRECT
         B     WRIT140            SKIP OVER KEY COPY
         SPACE
WRIT130  DS    0H
         XC    F@RPLARG,F@RPLARG  ELSE CLEAR OUT OUR COPY OF THE "KEY"
         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER
         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY ARGUMENT TO OUR "KEY" AREA
         TM    F@RPLFL,F@RDIR     SET FOR DIRECT ACCESS?
         BO    WRIT140            YES, CONTINUE
         SPACE
         BAS   R14,TODIR          NO, SWITCH TO DIRECT
         LTR   R15,R15            IF THAT FAILED
         BNZ   WRIT999            JUST GIVE UP
         SPACE
WRIT140  DS    0H
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH
         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?
         BNE   WRIT150            NO, PICK UP REC AREA VARIABLE NAME
         SPACE
         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC
         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH
         EJECT
WRIT150  DS    0H
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME
         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE
         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV
         BZ    WRIT160            DID WE GET THE VARIABLE OK?
         SPACE
         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT
         B     WRIT999
         SPACE
WRIT160  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -
         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?
         BZ    WRIT170            NO, READY TO PUT RECORD
         SPACE
         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE
         B     WRIT999            AND EXIT ROUTINE
         SPACE
WRIT170  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --
         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)
         MODCB RPL=(R4),RECLEN=(R2),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB WORKED?
         BZ    WRIT180            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'WRIT170'   NO, SET LABEL IN ERROR MSG
         B     WRIT990            DO GENERAL MODCB FAILURE LOGIC
         SPACE
WRIT180  DS    0H
         TM    F@OPENFL,F@ORRDS   IS FILE AN RRDS?
         BZ    WRIT190            NO, READY TO PUT RECORD
         TM    F@RPLFL,F@RSEQ     SEQUENTIAL ACCESS?
         BO    WRIT190            YES, NO KEY TO CONVERT
         SPACE
         BAS   R14,CONVKEY        ELSE, CONVERT KEY
         LTR   R15,R15            IF CONVERSION FAILED, EXIT ROUTINE
         BNZ   WRIT999            ELSE, FALL-THRU & PUT RECORD
         EJECT
WRIT190  DS    0H
         PUT   RPL=(R4)           WRITE THE RECORD
         LTR   R15,R15            SUCCESSFUL?
         BZ    WRIT999            ALL DONE
         SPACE
         BAS   R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE
         BNE   WRIT200            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$DUPL        YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
WRIT200  DS    0H
         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?
         BNE   WRIT210            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$BADRL       YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
WRIT210  DS    0H
         MVC   VSAMELAB,=CL8'WRIT210'   SET LABEL IN ERROR MSG
         SETMSG MSG=M$BADFUN      BAD FUNCTION
         B     WRIT999            EXIT ROUTINE
         SPACE
WRIT990  DS    0H        -- GENERAL LOGIC FOR MODCB FAILURE --
         BAS   R14,GETREG0        OBTAIN FEEDBACK
         SETMSG MSG=M$BADFUN      SET MESSAGE & FALL-THRU TO EXIT
         SPACE
WRIT999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
REWR000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    REWR010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=REWR000,GOTO=REWR999
         SPACE
REWR010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    REWR020            YES
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         B     REWR999            AND EXIT
         SPACE
REWR020  DS    0H
*
* FROM THIS POINT THRU THE REST OF THE REWRITE LOGIC, R4 -> RPLAREA
* AND R6 -> SHARED VARIABLE BLOCK
*
         LA    R4,RPLAREA
         LA    R6,OURSHVBL        GET -> TO SHARED VARIABLE BLOCK
         USING SHVBLOCK,R6        SET ADDRESSABILITY
*        TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?                 @ANZ
*        BZ    REWR030            NO, OK TO CONTINUE               @ANZ
*        SPACE                                                     @ANZ
*        SETMSG MSG=M$NOESDS      YES, IT IS - THIS FUNCTION NOT   @ANZ
*        B     REWR999            ALLOWED FOR AN ESDS, SET MSG & EX@ANZ
         SPACE
REWR030  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IS THERE A REAL ARGUMENT?
         BE    REWR040            NO, DO ERROR STUFF
         LTR   R3,R3              IS KEY ARGUMENT LENGTH ZERO?
*        BZ    REWR040            YES, DO ERROR STUFF              @ANZ
         BZ    REWR052            YES, BYPASS SETTING KEY          @ANZ
         B     REWR050            KEY IS OK, CONTINUE
         SPACE
REWR040  DS    0H
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     REWR999            EXIT ROUTINE
         EJECT
REWR050  DS    0H
         XC    F@RPLARG,F@RPLARG  CLEAR OUT OUR COPY OF THE "KEY"
         ST    R3,F@ARGLEN        SAVE KEY LENGTH FOR LATER
         BCTR  R3,0               DECREMENT LENGTH FOR EXECUTE
         EX    R3,ARGMVC          COPY ARGUMENT TO OUR "KEY" AREA
REWR052  DS    0H                                                  @ANZ
         LA    R8,ARGTABLE_NEXT   BUMP TO NEXT ARGUMENT
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR    GET ADDR & LENGTH
         C     R2,=X'FFFFFFFF'    NULL ARGUMENT?
         BNE   REWR060            NO, PICK UP REC AREA VARIABLE NAME
         SPACE
         LA    R2,RECVARDF        YES, SET OUR OWN DEFAULTS FOR REC
         LA    R3,L'RECVARDF      VARIABLE NAME & NAME LENGTH
         SPACE
REWR060  DS    0H
         STM   R2,R3,SHVNAMA      SET -> & LENGTH OF VARIABLE NAME
         MVC   SHVBUFL,F@BUFLEN   SET LENGTH AREA TO HOLD VARIABLE
         MVC   SHVVALA,F@RECBUF   SET -> TO OUR VARIABLE VALUE AREA
         MVI   SHVCODE,SHVFETCH   WANT TO GET THIS VARIABLE
         L     R15,IRXEXCO@       ADDRESS OF IRXEXCOM ROUTINE
         CALL  (15),(IRXEXLIT,0,0,OURSHVBL),VL,MF=(E,EXCOPLST)
         SPACE
         TM    SHVRET,SHVBADN+SHVBADV+SHVBADF+SHVNEWV
         BZ    REWR070            DID WE GET THE VARIABLE OK?
         SPACE
         SETMSG MSG=M$NORECV      NO, SET ERROR MESSAGE & EXIT
         B     REWR999
         SPACE
REWR070  DS    0H  - OBTAINED RECORD AREA, ENSURE IT WASN'T TRUNCATED -
         TM    SHVRET,SHVTRUNC    WAS VARIABLE TRUNCATED?
         BZ    REWR100            NO, READY TO PUT RECORD
         SPACE
         SETMSG MSG=M$BADRL       YES, SET ERROR MESSAGE
         B     REWR999            AND EXIT ROUTINE
         EJECT
REWR100  DS    0H       -- OBTAINED RECORD AREA, DO VSAM PUT --
         L     R2,SHVVALL         SIZE OF RECORD AREA (LENGTH)
         MODCB RPL=(R4),RECLEN=(R2),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            MODCB WORKED?
         BZ    REWR110            YES, CONTINUE
         SPACE
         MVC   VSAMELAB,=CL8'REWR100'   NO, SET LABEL IN ERROR MSG
         BAS   R14,GETREG0        GET FEEDBACK FROM REGISTER 0
         SETMSG MSG=M$BADFUN      INDICATE FAILURE
         B     REWR999            EXIT ROUTINE
         SPACE
REWR110  DS    0H
         PUT   RPL=(R4)           WRITE THE RECORD
         LTR   R15,R15            SUCCESSFUL?
         BZ    REWR999            CONTINUE
         SPACE
         BAS   R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKDUPL  WAS IT A DUPLICATE
         BNE   REWR120            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$DUPL        YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
REWR120  DS    0H
         CLC   VSAMEREA,FDBKBADL  WAS IT A BAD RECORD LENGTH?
         BNE   REWR130            NO, TRY NEXT POSSIBILITY
         SETMSG MSG=M$BADRL       YES, SET MESSAGE
         B     REWR999            EXIT ROUTINE
         SPACE
REWR130  DS    0H
         MVC   VSAMELAB,=CL8'REWR130'   SET LABEL IN ERROR MSG
         SETMSG MSG=M$BADFUN      BAD FUNCTION
         B     REWR999            EXIT ROUTINE
         SPACE 2
REWR999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         DROP  R6                 DROP SHVBLOCK ADDRESSABILITY
         EJECT
DELE000  DS    0H
*
* UPON ENTRY, R8 -> 3RD ARGUMENT (KEY)
*
         ST    R14,RETURNTO       SAVE RETURN POINT
         BAS   R14,RTRVTOK0       GO SEE IF THERE'S A NAME / TOKEN
         SPACE
         LTR   R15,R15            IF TOKEN EXISTS
         BZ    DELE010            READY TO GO
         SPACE
         SETMSG MSG=M$NOACB
         NTERROR REQ=RETRIEVE,SYM=DELE000,GOTO=DELE999
         SPACE
DELE010  DS    0H
         L     R7,IEANTTOK        PICK UP ADDRESS OF FWA
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    DELE020            YES
         SPACE
         SETMSG MSG=M$NOOUT       NO, SET MESSAGE
         B     DELE999            AND EXIT
         SPACE
DELE020  DS    0H
         TM    F@OPENFL,F@OESDS   IS FILE AN ESDS?
         BZ    DELE030            NO, OK TO CONTINUE
         SPACE
         SETMSG MSG=M$NOESDS      YES, IT IS - THIS FUNCTION NOT
         B     REWR999            ALLOWED FOR AN ESDS, SET MSG & EXIT
         SPACE
DELE030  DS    0H
         LM    R2,R3,ARGTABLE_ARGSTRING_PTR   GET KEY ARGUMENT
         C     R2,=X'FFFFFFFF'    IF KEY ARGUMENT EXISTS, DO ERASE
         BNE   DELE100            (RECORD AREA ARGUMENT IS IGNORED)
         SPACE
         SETMSG MSG=M$BADARG      NO, SET ERROR MESSAGE
         B     REWR999            EXIT ROUTINE
         EJECT
DELE100  DS    0H
         LA    R4,RPLAREA
         ERASE RPL=(R4)           ERASE THE RECORD
         LTR   R15,R15            IF ERASE WAS SUCCESSFUL
         BZ    DELE999            EXIT ROUTINE
         SPACE
         MVC   VSAMELAB,=CL8'DELE100'   ERASE FAILED, SET LABEL
         BAS   R14,GETFDBK        GET FEEDBACK WORD
         CLC   VSAMEREA,FDBKNOGE  ERROR WAS "NO PREVIOUS GET"?
         BNE   DELE110            NO, INDICATE GENERAL FUNCTION FAILURE
         SPACE
         SETMSG MSG=M$NOGET       SET NO PREVIOUS GET MESSAGE
         B     DELE999            EXIT ROUTINE
         SPACE
DELE110  DS    0H
         SETMSG MSG=M$BADFUN      FUNCTION FAILED
         SPACE 2
DELE999  DS    0H
         L     R14,RETURNTO       GET RETURN POINT
         BR    R14                EXIT & RETURN TO MAINLINE
         EJECT
*
* ARGMVC - EXecuted MVC to copy argument (key / RRN / RBA) to the
*          area where the RPL expects to find it.  R2 must point to
*          the argument source.
*
         SPACE
ARGMVC   MVC   F@RPLARG(0),0(R2)  EXECUTED INSTRUCTION
         SPACE 3
*
* ARGTRT - EXecuted TRT to check for numeric bytes in an RRN key.
*
         SPACE
ARGTRT   TRT   F@RPLARG(0),NUMTAB      EXECUTED INSTRUCTION
         SPACE 3
*
* ARGPACK - EXecuted PACK for converting RRN key to packed decimal.
*
         SPACE
ARGPACK  PACK  DBLWRK,F@RPLARG(0)      EXECUTED INSTRUCTION
         EJECT
TODIR    DS    0H         -- CHANGE RPL TO DIRECT READ --
*
* ANY NON-ZERO VALUE IN R15 UPON EXIT INDICATES TO THE CALLER THAT
* THIS ROUTINE DETECTED A PROBLEM, AND FURTHER PROCESSING IS PROBABLY
* NOT A GOOD IDEA
*
* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         SR    R15,R15            CLEAR R15
         TM    F@OPENFL,F@OOUT    FILE OPEN FOR OUTPUT?
         BO    TODIR100           YES, MODIFY ONLY PROCESSING TYPE
         SPACE
         MODCB RPL=(R4),OPTCD=(DIR,NSP),                               X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    TODIR200           YES, RESET OUR FLAGS
         SPACE
         MVC   VSAMELAB,=CL8'TODIR'
         B     TODIR900           DO REST OF ERROR PROCESSING
         SPACE
TODIR100 DS    0H
         MODCB RPL=(R4),OPTCD=(DIR),                                   X
               MF=(G,MODCB_PARMLIST)
         LTR   R15,R15            SUCCESSFUL?
         BZ    TODIR200           YES, GO RESET OUR FLAG
         SPACE
         MVC   VSAMELAB,=CL8'TODIR200'
         B     TODIR900           DO REST OF ERROR PROCESSING
         SPACE
TODIR200 DS    0H
         OI    F@RPLFL,F@RDIR     RESET OUR FLAG - DIRECT PROCESSING
         NI    F@RPLFL,X'FF'-F@RSEQ       TURN OFF SEQUENTIAL FLAG
         B     TODIR999           ALL DONE, EXIT ROUTINE
         SPACE
TODIR900 DS    0H         -- ERROR MODIFYING A CONTROL BLOCK --
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         BAS   R14,GETREG0        GET REASON CODE FROM REGISTER 0
         SETMSG MSG=M$BADDSW      SET BAD RESULT CODE & FALL-THRU
         SPACE
TODIR999 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
RTRVTOK0 DS    0H
*
*  RETRIEVES THE NAME / TOKEN PAIR.  CALLER MUST CHECK FOR ERRORS -
*  R15 IS LEFT INTACT.
*
         ST    R14,LVL1R14        SAVE RETURN POINT
*        LOAD  EP=IEANTRT         LOAD ROUTINE IEANTRT             @ANZ
*        LR    R15,R0                                              @ANZ
         L     R15,=V(IEANTRT)    IEANTRT ENTRY POINT ADDRESS      @ANZ
         CALL  (15),(IEANTLVL,IEANTNAM,IEANTTOK,IEANTRC),              X
               MF=(E,IEANTLST)
         SPACE
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
CONVKEY  DS    0H    -- CONVERT AN RRN KEY TO BINARY --
*
*  A NON-ZERO VALUE IN R15 INDICATES THAT THE ARGUMENT (KEY) WAS
*  NOT NUMERIC.  THIS ROUTINE SETS THE ERROR MESSAGE.
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         SR    R15,R15            SET ROUTINE RETURN CODE TO ZERO
         L     R14,F@ARGLEN       GET KEY LENGTH
         BCTR  R14,0              DECREMENT FOR EXECUTE
         EX    R14,ARGTRT         TEST TO ENSURE IT'S NUMERIC
         BZ    CONVK100           IF IT WAS, CONTINUE
         SPACE
         SETMSG MSG=M$NONNUM      ELSE, SET MSG (WHICH PUTS A NON-ZERO
         B     CONVK999           VALUE IN R15 ALSO), AND EXIT ROUTINE
         SPACE
CONVK100 DS    0H
         EX    R14,ARGPACK        PACK KEY
         CVB   R14,DBLWRK         CONVERT TO BINARY
         ST    R14,F@RPLARG       REPLACE ARGUMENT, THEN EXIT
         SPACE
CONVK999 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              RETURN TO CALLER
         EJECT
GETFDBK  DS    0H          -- GET FDBK / SET REASON CODE --
*
* This routine will issue a SHOWCB to obtain the feedback fullword
* so the reason code can be added to the error message.  This routine
* assumes that R15 still contains the VSAM return code (probably 8).
* The caller of this routine is responsible for setting the value of
* VSAMELAB before the call and issuing the SETMSG macro upon return
* from the routine.
*
* !! THIS ROUTINE ASSUMES THE CALLER HAS SET R4 AS A -> TO THE RPL !!
*
         ST    R14,LVL1R14        SAVE RETURN POINT
         CVD   R15,DBLWRK
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         LA    R2,FULLWRK2
         SHOWCB RPL=(R4),AREA=(R2),LENGTH=4,FIELDS=(FDBK),             X
               MF=(G,SHOWCB_PARMLIST)
         SPACE
         LTR   R15,R15            DID SHOWCB WORK?
         BZ    GETFDBK1           YES - GO PICK UP ERROR MESSAGE
         SPACE
         MVC   VSAMELAB,=CL8'GETFDBK'   SET UP ERROR MESSAGE FIELDS
         CVD   R15,DBLWRK         SET RETURN CODE FROM SHOWCB
         UNPK  VSAMER15,HALFWRK2
         OI    VSAMER15+1,X'F0'
         CVD   R0,DBLWRK          SET REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         B     GETFDBK9           EXIT SUBROUTINE
         SPACE
GETFDBK1 DS    0H
*
*  TO CONSIDER:  SAVE FDBK WORD IN A DISPLAYABLE FORMAT SOMEWHERE
*
         SR    R14,R14
         IC    R14,BYTEWRK2       LAST BYTE OF FEEDBACK WORD
         CVD   R14,DBLWRK         IS THE REASON CODE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SPACE
GETFDBK9 DS    0H
         L     R14,LVL1R14        GET RETURN POINT
         BSM   0,R14              EXIT & RETURN TO CALLER
         EJECT
GETREG0  DS    0H
*
* Put reason code into VSAMEMSG - this routine assumes the return code
* from a VSAM SHOWCB, MODCB, etc., has been left intact in R15.  No
* registers are altered by this routine, can be called from anywhere
*
         CH    R15,=H'4'          REASON CODE IS ONLY IN R0 WHEN THE
         BNE   GETREG0X           VSAM R.C. IS 4
         SPACE
         CVD   R0,DBLWRK          PUT REASON CODE IN VSAM ERROR MESSAGE
         UNPK  VSAMEREA,HALFWRK2
         OI    VSAMEREA+3,X'F0'
         SPACE
GETREG0X DS    0H
         BSM   0,R14              RETURN TO CALLER
         SPACE
         TITLE 'RXVSAM - L T O R G'
         LTORG
         TITLE 'RXVSAM - Constants'
         DS    0D
NUMTAB   DC    256X'FF'           TRT TABLE FOR NUMERIC CLASS TEST
         ORG   NUMTAB+C'0'
         DC    10X'00'
         ORG
*
* COMMON FDBK REASON CODES IN CHARACTER (DECIMAL) FORMAT
*
FDBKEOF  DC    CL4'0004'               END OF FILE
FDBKDUPL DC    CL4'0008'               DUPLICATE RECORD
FDBKSEQE DC    CL4'0012'               SEQUENCE ERROR
FDBKNF   DC    CL4'0016'               RECORD NOT FOUND
FDBKNOGE DC    CL4'0092'               PUT OR ERASE, NO PREVIOUS GET
FDBKBADL DC    CL4'0108'               BAD RECORD LENGTH
*
* MISCELLANEOUS CONSTANTS
*
USCORE   DC    8C'_'              UNDERSCORES CONSTANT
SPACES   DC    CL8' '             SPACES CONSTANT
IRXEXLIT DC    CL8'IRXEXCOM'      PROGRAM NAME CONSTANT
RXVSMSG@ DC    V(RXVSAMSG)        -> TO RXVSAMSG CSECT
VMSGVAR  DC    CL19'RXVSAM_VSAMERRORMSG'     VSAM ERR MSG VAR NAME
RMSGVAR  DC    CL16'RXVSAM_RETURNMSG'  RETURN MESSAGE VARIABLE NAME
RECVARDF DC    CL13'RXVSAM_RECORD'     DEFAULT RECORD VARIABLE NAME
         SPACE
VMSGINIT DS    0X
         DC    CL43'VSAM error, return code in register 15 was '
         DC    CL2'00'
         DC    CL18', reason code was '
         DC    CL4'0000'
         DC    CL23' (label in RXVSAM was: '
         DC    CL8' '
         DC    CL1')'
VMSGLEN  EQU   *-VMSGINIT
         SPACE
NTMSGINI DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE
         DC    CL44'NAME / TOKEN service error, register 15 was '
         DC    CL2'00'
         DC    CL14', request was '
         DC    CL8' '
         DC    CL23' (label in RXVSAM was: '
         DC    CL8' '
         DC    CL1')'
         SPACE
         TITLE 'RXVSAM - Local Work Area'
*
* This area is initialized to X'00'
*
LOCAL_WORKAREA DSECT
DBLWRK   DS    0D
FULLWRK1 DS    F
FULLWRK2 DS    0F
HALFWRK1 DS    H
HALFWRK2 DS    0H
BYTEWRK1 DS    X
BYTEWRK2 DS    X
         SPACE
         DS    0D                 ALIGN ON A DOUBLEWORD
IEANTNAM DS    0CL16              NAME FOR NAME / TOKEN PAIR
IEANTNA1 DS    CL8                 - 1ST PART (BASED ON JOB ID)
IEANTNA2 DS    CL8                 - 2ND PART (BASED ON FILE DD)
IEANTTOK DS    XL16               TOKEN FOR NAME / TOKEN PAIR
*        The 1st fullword of the token is a -> to this file's FWA
IEANTLVL DS    A                  LEVEL FOR IEANT SERVICE
IEANTPOP DS    A                  PERSIST OPTION FOR IEANT SERVICE
IEANTRC  DS    F                  RETURN CODE FROM IEANT SERVICE
IEANTLST DS    5F                 ADDR LIST FOR ABOVE 5 PARMS (CALL)
         SPACE
SAVEAREA DS    18F
         SPACE
EXCOPLST DS    4F                 PARM LIST AREA FOR IREXCOM CALL
GENCB_PARMLIST DS  20F            PARM LIST FOR GENCB MACRO
MODCB_PARMLIST DS  20F            PARM LIST FOR MODCB MACRO
SHOWCB_PARMLIST DS 20F            PARM LIST FOR SHOWCB MACRO
OPEN_PARMLIST  DS  2F             PARM LIST FOR OPEN MACRO
CLOSE_PARMLIST DS  2F             PARM LIST FOR CLOSE MACRO
         SPACE
MSG@     DC    F'0'               -> TO ERROR MSG TEXT
EFPL@    DC    F'0'               -> TO EFPL (SAVED AT FUNCTION ENTRY)
ENVB@    DC    F'0'               -> TO ENVB (SAVED AT ENTRY)      @ANZ
IRXEXCO@ DC    F'0'               -> IRXEXCOM ENTRY ADDRESS
RECBUF@  DC    F'0'               -> TO RECORD BUFFER AREA
RETURNTO DC    F'0'               R14 SAVE FOR OPEN/READ/WRIT/CLOS ETC
LVL1R14  DC    F'0'               R14 SAVE - LEVEL 1 SUBROUTINES
NAMTOKRC DC    F'0'               R15 (R.C.) FROM NAME / TOKEN SERVICES
TRACE@B  DC    F'0'               -> TO TRACE AREA
TRACE@C  DC    F'0'               -> TO "NEXT" SLOT IN TRACE AREA
TRACE@M  DC    F'0'               -> TO END OF TRACE AREA
MSGLEN   DC    H'0'               LENGTH OF RETURN MESSAGE (MSG@)
RECBUFL  DC    H'0'               LENGTH OF RECORD BUFFER (RECBUF@)
MYJOBID  DS    CL8                JOB ID (1ST CHAR OVERLAID WITH "X")
DDNAME   DS    CL8                SPACE PADDED DDNAME
         SPACE
VSAMEMSG DS    0X                 VSAM ERROR MESSAGE
         DS    CL43
VSAMER15 DS    CL2
         DS    CL18
VSAMEREA DS    CL4
         DS    CL23
VSAMELAB DS    CL8
         DS    CL1
VSAMELEN EQU   *-VSAMEMSG
         SPACE
NTMSG    DS    0X              NAME / TOKEN SERVICES ERROR MESSAGE
         DS    CL44
NTMSGR15 DS    CL2
         DS    CL14
NTREQ    DS    CL8
         DS    CL23
NTLABEL  DS    CL8
         DS    CL1
NTMSGLEN EQU   *-NTMSG
         SPACE
         DS    0F
OURSHVBL DC  XL(SHVBLEN)'00'           OUR SHARED VARIABLE BLK STORAGE
         SPACE
LOCAL_WORKAREA_LENGTH EQU *-LOCAL_WORKAREA   TOTAL LENGTH OF AREA
         TITLE 'RXVSAM - File Work Area  '
FWABLOCK DSECT
*
* FWABLOCK - THERE WILL BE ONE OF THESE FOR EACH OPEN VSAM DATASET.
* The OPEN routine obtains the storage, and the CLOSE routine releases
* it.  NAME / TOKEN services are used to manage (keep track) of this
* block between invocations of RXVSAM.
*
FWA      DS    0F   --- BEGINNING OF FILE WORK AREA ---
ACBAREA  DS    XL76               OUR COPY OF CURRENT ACB
ACBAREAL EQU   *-ACBAREA          LENGTH OF AREA
         SPACE
RPLAREA  DS    XL76               OUR COPY OF CURRENT RPL
RPLAREAL EQU   *-RPLAREA          LENGTH OF AREA
         SPACE
FWAFLAGS DS    0F                 FLAGS
F@RECBUF DC    F'0'                - OUR RECORD BUFFER ADDRESS
F@BUFLEN DC    F'0'                - LENGTH OF OUR RECORD BUFFER
F@LRECL  DC    F'0'                - MAX RECORD LENGTH FOR THIS FILE
F@ARGLEN DC    F'0'                - LENGTH OF KEY (ARGUMENT)
F@OPENFL DC    X'0'                - ACB FLAGS
F@OIN    EQU   X'80'                 - OPEN FOR INPUT   | Both flags on
F@OOUT   EQU   X'40'                 - OPEN FOR OUTPUT  | if open I-O
F@OSEQ   EQU   X'20'                 - FILE SET FOR SEQUENTIAL ACCESS
F@ODIR   EQU   X'10'                 - FILE SET FOR DIRECT ACCESS
F@O###   EQU   X'08'                 - (UNUSED BIT SETTING)
F@OKSDS  EQU   X'04'                 - FILE IS A KSDS
F@ORRDS  EQU   X'02'                 - FILE IS AN RRDS
F@OESDS  EQU   X'01'                 - FILE IS AN ESDS
F@RPLFL  DC    X'0'                - RPL FLAGS
F@RKEY   EQU   X'80'                 - USE KEY (RRN) ARGS (OFF = ADR)
F@RARD   EQU   X'40'                 - USE USER'S ARGS (OFF = LRD)
F@RSEQ   EQU   X'20'                 - SEQUENTIAL ACCESS
F@RDIR   EQU   X'10'                 - DIRECT ACCESS (MAY ALSO SET NSP)
F@RUPD   EQU   X'08'                 - UPD (OFF = NUP {UNLESS F@RDIR})
F@RFWD   EQU   X'04'                 - FORWARD (OFF = BWD) PROCESSING
F@RKEQ   EQU   X'02'                 - EQUAL KEY (OFF = KGE)
F@RFKS   EQU   X'01'                 - FULL KEY SUPPLIED (OFF = GEN)
F@POINT  DS    X                  FILE POSITIONING IS SET
F@POINTN EQU   X'00'                - NO
F@POINTY EQU   X'FF'                - YES
         DS    X
F@RPLARG DC    XL255'00'          ARGUMENT (KEY) AREA FOR RPL
         SPACE
         DS    XL1
FWALEN   EQU   *-FWA              LENGTH OF FILE WORK AREA BLOCK
FWAEND   DS    0X                 END OF BLOCK MARKER
*
* End of FILE WORK AREA block
*
         TITLE 'RXVSAM - IRXEFPL Dsect'
         PRINT GEN
         IRXEFPL
         TITLE 'RXVSAM - IRXEVALB Dsect'
         IRXEVALB
         TITLE 'RXVSAM - IRXARGTB Dsect'
         IRXARGTB
         TITLE 'RXVSAM - IRXSHVB Dsect'
         IRXSHVB
         TITLE 'RXVSAM - IRXENVB Dsect'                            @ANZ
         IRXENVB                                                   @ANZ
         TITLE 'RXVSAM - IRXEXTE Dsect'                            @ANZ
         IRXEXTE                                                   @ANZ
         TITLE 'RXVSAM - MISC SYSTEM DESCTS'
STCB     DSECT
         DS    XL188
STCBJSAB DS    A
         DS    XL4
         SPACE 2
         IAZJSAB DSECT=YES
         EJECT
         IHAASCB
         EJECT
         IHAASSB
         EJECT
         IHAPSA
         EJECT
         IKJTCB
         SPACE 2
         END   RXVSAM
