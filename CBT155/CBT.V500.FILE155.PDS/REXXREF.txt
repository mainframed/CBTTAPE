/*--REXX REXXREF-------------------------------------------------------*/
/*                                                                     */
/*   09/13/99 Converted to MVS from CMS. Disabled lots of code and the */
/*            XREF dosen't work. Only good for reformating and         */
/*            restructuring all lines of the program.                  */
/*                                                                     */
/*--REXX REXXREF-------------------------------------------------------*/
/** REXXREF - XEDIT macro to reformat and cross reference REXX execs ***/
/*¬¬ **NB**  There are 'NOT' (¬) symbols in lines 2, 3, 4, 48, 245,    */
/*¬¬ **NB**  253, 275, 284, 370, 373, 505, 536, 549, 551, 554, 606,    */
/*¬¬ **NB**  616, 720, 734                                             */
/*|| **NB**  There are vertical bars (|) in lines 5, 6, 7, 8, 9, 10,   */
/*|| **NB**  37, 95, 96, 157, 199, 200, 208, 400, 403, 433, 435,       */
/*|| **NB**  438, 447, 449, 454, 467, 477, 496, 499, 534, 538, 629,    */
/*|| **NB**  632, 638, 642, 646, 679, 687, 695, 698, 734, 742, 748,    */
/*|| **NB**  751, 788, 797, 801, 865, 868, 874, 876, 879, 895, 899,    */
/*|| **NB**  905, 907, 910, 933, 937, 941, 945, 1021, 1022, 1024       */
/*--REXX REXXREF-------------------------------------------------------*/
/***********************************************************************\
 *  No other routines are called.                                      *
 *                                                                     *
 *  Written by Don Hughes. June, 1985                                  *
 *             EDP Techniques                                          *
 *             WHITE PLAINS, NY                                        *
 *             (914) 949-5994                                          *
 *                                                                     *
 *  Update log                                                         *
 *  Date       By        Comments                                      *
 *   6 Dec 85  Don Hughes Submitted to VMSHARE                         *
 *             HENDERS   Waterloo modifications performed by           *
 *                       Paul Henderson <henders@watdcs.UWaterloo.ca>  *
 *  ?? ??  86  HENDERS   Change to Waterloo up/low case conventions.   *
 *  16 Jan 87  HENDERS   Do label check before keyword check; set      *
 *                       SPILL OFF for main loop; only type XREF       *
 *                       when requested.                               *
 *  19 Jan 87  HENDERS   Split all '/*' and '*/' character strings,    *
 *                       use symbolic references; also for '' and ""   *
 *  21 Jan 87  HENDERS   Indent continuation lines by 2 spaces.        *
 *  12 May 87  HENDERS   Do not change indentation of comment lines.   *
 *  13 May 87  HENDERS   Fix sorting of cross-reference; change        *
 *                       comments to mixed case;                       *
 *                       invoke REXXREF on itself.                     *
 *  14 May 87  HENDERS   Issue a REFRESH at end of main loop; add      *
 *                       diag, diagrc, queued, watrxf to funct list.   *
 *  15 May 87  HENDERS   Recognize 'signal on|off|value token';        *
 *                       move variable assignments out of SCANTOKEN    *
 *                       and FUNCTION.                                 *
 *  18 May 87  HENDERS   Ensure that SORT routine maintains order;     *
 *                       change 'right align comment' philosophy.      *
 *  19 May 87  HENDERS   Re-work 'target' handling.                    *
 *  20 May 87  HENDERS   Change option parsing and add new ones.       *
 *   6 Jul 87  HENDERS   ALT count reflects actual number of changes.  *
 *                       implement 'Leftmargin' option.                *
 *   9 Jul 87  HENDERS   Fix indentation on continuation lines where   *
 *                       a comment follows the continuation ','.       *
 *   4 May 88  HENDERS@WATDCS Identify lines containing '¬' characters *
 *  17 May 88  HENDERS@WATDCS Use standard 'SORT' routine, not 'QSORT'.*
 *  18 May 88  OSG0309@UNLVM Fixed END indentations when END is not    *
 *                       the first token on the line (I.E. Do;a=i;end) *
 *                       fixed else/then indentation when continued;   *
 *                       reduce CPU consumption with parse statements. *
 *  19 May 88  OSG0309@UNLVM added more processing for quoted tokens.  *
 *  25 May 88  HENDERS@WATDCS Simulate VARCURL if not available;       *
 *  30 May 88  HENDERS@WATDCS Fixed else/then indent when continued,   *
 *                       and next line is a comment or blank line.     *
 *  31 May 88  HENDERS@WATDCS Implement 'REFRESH nn' option.           *
 *  29 Mar 89  henders@watdcs.UWaterloo.ca  Make slight change to way  *
 *                       the 'ALL' argument is recognized; tidy up     *
 *                       internal documentation.                       *
 *  30 Jan 90  henders@watdcs.UWaterloo.ca  Add VM/SP Release 6 new    *
 *                       functions to list of internal functions.      *
 *                                                                     *
\***********************************************************************/

   signal off ERROR; signal on NOVALUE; signal on SYNTAX

/**** Get a buffer for garbage collection.  Will be dropped at end *****/
/* address command 'MAKEBUF'; buf1 = rc */

/************************** Start of program ***************************/
START: trace n
   address ISREDIT
   "MACRO (parm) PROCESS"

   /* 'COMMAND EXTRACT /LINE /TOF /EOF' */
   "(curline)=line .zcsr" /* Get the line where the cursor is */
   line.1=curline
   tof.1='OFF'
   eof.1='OFF'
   do
      if (tof.1='ON') then line.1 = line.1 + 1
      if (eof.1='ON') then line.1 = line.1 - 1
   end
   start_line = line.1                           /* Line we started on */
   first_line = line.1                     /* Line to begin processing */

/***************** Set various variables and switches ******************/
   switch.debug = 0                                   /* Debugging aid */
   debug_cnt = 1
   if (switch.debug) then say 'At START'
/* if (cmsflag('CMSTYPE')) then typeflag = 'RT';  else typeflag = 'HT' */
                                 /* Save TYPEFLAG to be restored later */
   rtncode = 0        /* Holds return code to be passed back to system */
   switch.set = 1                      /* For setting switches to TRUE */
   switch.reset = 0
   left_margin = 0
   c_squote = "'"                               /* Character constants */
   c_dquote = '"'
   c_astslash = '*' || '/'
   c_slashast = '/' || '*'
/** 'keywords.scantok' & 'keywords.primary' are used in 'SCANTOKEN', ***/
/************* but defined here for execution efficiency. **************/
   keywords.scantok = ' do to end if then else' ,
     ' say iterate leave while until forever' ,
     ' select when otherwise nop' ,
     ' parse upper arg var external source pull push queue' ,
     ' address value arg call drop exit return interpret' ,
     ' signal on off error halt novalue syntax trace' ,
     ' procedure expose by for' ,
     ' numeric digits form scientific engineering fuzz'
   /*
   /*  This code segment was included by Don Hughes, presumably */
   /*  for future expansion. */
   keywords.primary = ' ADDRESS ARG CALL DO DROP EXIT IF',
     ' INTERPRET ITERATE LEAVE NOP NUMERIC PARSE PROCEDURE',
     ' PULL PUSH QUEUE RETURN SAY SELECT SIGNAL',
     ' TRACE UPPER'
   parent.value='ADDRESS PARSE SIGNAL TRACE'
   parent.to='DO';parent.by='DO';parent.for='DO';parent.while='DO'
   parent.until='DO';parent.forever='DO';parent.then='IF SELECT'
   parent.else='IF';parent.digits='NUMERIC';parent.form='NUMERIC'
   parent.scientific='NUMERIC';parent.engineering='NUMERIC'
   parent.fuzz='NUMERIC';parent.arg='PARSE';parent.external='PARSE'
   parent.numeric='PARSE';parent.pull='PARSE';parent.source='PARSE'
   parent.with='PARSE';parent.var='PARSE';parent.expose='PROCEDURE'
   parent.when='SELECT';parent.otherwise='SELECT'
   parent.on='SIGNAL';parent.off='SIGNAL';parent.error='SIGNAL'
   parent.halt='SIGNAL';parent.novalue='SIGNAL';parent.syntax='SIGNAL'
   */

/************ 'keywords.func' is used in routine 'FUNCTION' ************/
   keywords.func = ' abbrev abs address arg bitand bitor bitxor' ,
     ' center centre cmsflag compare copies c2d c2x' ,
     ' datatype date delstr delword diag diagrc d2c d2x errortext' ,
     ' externals find format index insert justify lastpos' ,
     ' left length linesize max min overlay pos' ,
     ' queued random reverse right right sign sourceline' ,
     ' space storage strip substr subword symbol time' ,
     ' trace translate trunc userid value verify word' ,
     ' wordindex wordlength words xrange x2c x2d' ,
     ' watrxf '
/* VM/SP Release 6 added the following: */
   keywords.func = keywords.func 'digits form fuzz wordpos' ,
     'dbadjust dbbracket dbcenter dbcentre dbcjustify dbtodbcs dbtosbcs',
     'dbleft dbright dbrleft dbrright dbunbracket dbvalidate dbwidth'

/******* Here are the switches that control the various options ********/

   switch.append = switch.reset             /* Append to previous XREF */
   switch.xref = switch.reset              /* Create XREF file;  Print */
   /******* COML = SET => Leave comments alone; RESET => INDENT ********/
   switch.coml = switch.set
   /** COMRJUST = SET => Right justify comments. RESET => Leave alone **/
   switch.comrjust = switch.set
   switch.variable_case = switch.set           /* Change variable case */
   switch.label_case = switch.set                 /* Change label case */
   switch.function_case = switch.set           /* Change function case */
   switch.keyword_case = switch.set             /* Change keyword case */
   switch.colin = switch.reset  /* Colin's 'standard' for case setting */
   switch.lcc   = switch.set      /* lcc's 'standard' for case setting */
   switch.signalonoffv = 0   /* Signal on|off|value .. being processed */
   switch.noniterativedo = switch.reset
   switch.type = switch.reset     /* Control typing of XREF when done. */

/************** Get right margin for justifying comments ***************/
   /* 'COMMAND EXTRACT /LRECL' */
   "(recl)=lrecl"
   lrecl.1=recl
   right_margin = lrecl.1
   if (right_margin>73) then right_margin = 73
                                             /* 63 is used by EXECUPDT */
   refresh = 1                        /* Issue 'REFRESH' at every line */
   continue_indent = 2     /* Number of spaces to indent continuations */
   thenelse_indent = 2     /* Number of spaces to indent hanging thens */
   indent_thenelse = 0    /* Current value of hanging then/else indent */
   switch.thenelse = switch.reset  /* For processing hanging then/else */
   switch.comment_only = switch.reset
   switch.skip = switch.reset                        /* Skip indenting */
   switch.skipend = switch.reset             /* For non-iterative DO's */
   last_delim = ''               /* Ending delimiter for previous line */
/************************** Search parameters **************************/
   switch.search = switch.reset; search_key = ''
   switch.literal = switch.reset            /* last item was a literal */
   searchkey_cnt. = 0                   /* Nesting level of delimiters */
   searchkey_list. = ''            /* Line-number stack for delimiters */

/******** 'com.' variables are also passed to called functions *********/
   com.linenum = 0                              /* Current line number */
   com.tokennum = 0                            /* Current token number */
   com.last_key_num = 0                /* Token number of last keyword */
   com.last_keyword = ''                           /* Previous keyword */
   com.last_token = ''                               /* Previous token */
   com.dolist = ''         /* line-number stack for DO's and SELECTS's */
   com.endlist = ''                     /* Line-number stack for END's */
   com.delim = ''                                 /* Current delimiter */
   com.nest = 1                 /* Current nesting level for indenting */
   com.indent = 3                        /* Number of spaces to indent */
   com.offset = 0                                    /* Current offset */

   xref. = 0                                 /* Cross reference tables */

/************************ Check input arguments ************************/
   /* parse arg args */
   args=parm /* From first ISREDIT ststement above(on entry) */
   if (word(args,1)='?') then signal EXPLAIN
/* if (args='' | left(args,1)='(') then args = '1' args */
   if (args='' | left(args,1)='(') then args = 'All ' args
   if (CAPS(word(args,1))='ALL' |,
     left(CAPS(word(args,1)),4)='ALL(') then do
      args = '*' substr(args,4)
      first_line = 1
      "(lastln) = LINENUM .ZLAST"
      last_line = lastln
   end
/* push args
   'MACRO PARSE 1 TARGET LINE'
   parse pull temp
   if (temp<=0 | temp>2) then signal PARSE_ERROR
   parse pull loc1 len1
   target = substr(args,loc1,len1) */
   Parse Var args target opts
/* opts = ''
   if (temp=2) then do
      parse pull loc1 len1
      opts = space(CAPS(substr(args,loc1,len1)))
   end */
      opts = space(CAPS(opts))
   if (opts<>'') then do              /* Ensure options begin with '(' */
      if (left(opts,1)='(') then opts = substr(opts,2)    /* Strip '(' */
      else signal PARSE_ERROR                /* If no '(', then error. */
   end
   valid_opts = ' 3APPEND 5COLIN 5DEBUG 2INDENT 7NODEBUG 3LCC',
     '2LM 2LEFTMARGIN 3NOTYPE 3NOXREF 2REFRESH 2RM 2RIGHTMARGIN',
     '1TYPE 1XREF'
   do while (opts<>'')
      parse var opts . opts 1 optword temp2 .
      optword = GETOPTWORD(optword,valid_opts)
      if (optword='LM') then optword = 'LEFTMARGIN'
      if (optword='RM') then optword = 'RIGHTMARGIN'
      select
         when (optword='APPEND') then do
            switch.append = switch.set
         end
         when (optword='COLIN') then do
            switch.colin = switch.set
            switch.lcc   = switch.reset
         end
         when (optword='LCC') then do
            switch.colin = switch.reset
            switch.lcc   = switch.set
         end
         when (optword='DEBUG') then do
            switch.debug = switch.set
         end
         when (optword='INDENT') then do
            parse var opts com.indent opts        /* Extract argument. */
            if (¬datatype(com.indent,'N')) then do
                Say  "INDENT operand  '"com.indent"'  is not numeric."
               signal EXIT16                       /* Take error exit. */
            end
         end
         when (optword='LEFTMARGIN') then do
            parse var opts left_margin opts       /* Extract argument. */
            if (¬datatype(left_margin,'N')) then do
                Say  "LEFTMARGIN operand  '"left_margin"'  is not numeric."
               signal EXIT16                       /* Take error exit. */
            end
            if (left_margin<1) then do
                Say  "LEFTMARGIN operand  '"left_margin"'  must be ",
"positive and non-zero."
               signal EXIT16                       /* Take error exit. */
            end
         end
         when (optword='NODEBUG') then do
            switch.debug = switch.reset
         end
         when (optword='NOTYPE') then do
            switch.type = switch.reset
         end
         when (optword='NOXREF') then do
            switch.xref = switch.reset
         end
         when (optword='REFRESH') then do
            parse var opts refresh opts           /* Extract argument. */
            if (¬datatype(refresh,'N')) then do
                Say ' REFRESH operand '''refresh'''',
                 'is not numeric.'
               signal EXIT16                       /* Take error exit. */
            end
            if (refresh<1) then refresh=99999999    /* 'Never' refresh */
         end
         when (optword='RIGHTMARGIN') then do
            parse var opts right_margin opts      /* Extract argument. */
            if (¬datatype(right_margin,'N')) then do
                Say ' RIGHTMARGIN operand '''right_margin'''',
                 'is not numeric.'
               signal EXIT16                       /* Take error exit. */
            end
         end
         when (optword='TYPE') then do
            switch.type = switch.set
         end
         when (optword='XREF') then do
            switch.xref = switch.set
         end
         otherwise
          Say ' Invalid option '''optword'''.'
         signal EXIT16                                        /* Exit. */
      end
   end

/************ Adjust Leftmargin value, if it was specified *************/
   if (left_margin>0) then left_margin = left_margin - com.indent - 1

/*********************** Get the range of lines ************************/
/* 'COMMAND LOCATE' target
   if (rc=2) then signal PARSE_ERROR
   temp = rc
   'COMMAND EXTRACT /LINE'
   if (line.1<start_line) then line.1 = line.1 + 1
   if (line.1>start_line) then line.1 = line.1 - 1
   'COMMAND :'line.1
   'EXTRACT /LINE /TOF /EOF'
   if (temp=1) then do
      if (tof.1='ON') then line.1 = line.1 + 1
      if (eof.1='ON') then line.1 = line.1 - 1
   end
   if (line.1>first_line) then do
      last_line = line.1
   end
   else do
      last_line = first_line
      first_line = line.1
   end
*/
/*********************** Setup XEDIT environment ***********************/
/* 'COMMAND PRESERVE'
   'COMMAND SET ZONE 1 *'
   'COMMAND SET LINEND OFF'
   'COMMAND SET VERIFY OFF'
   'COMMAND SET SCOPE ALL'
   'COMMAND SET CASE MIXED RESPECT' */
/* 'COMMAND SET SPILL OFF' */        /* SPILL ON might cause problems. */
/* 'COMMAND SET SCALE OFF' */
/* 'COMMAND SET TABLINE OFF' */
/* 'COMMAND EXTRACT /VARCURL'*/  /* VARiable CURrent Line - Waterloo mod */
/* if (rc=0) then do           /* to move pointer, not re-write screen */
      'COMMAND SET VARCURL ON 3'
      got_varcurl = switch.set      /* Set when XEDIT supports VARCURL */
   end */
/* else do */   /* All is not lost.  We can simulate VARCURL (sort of) */
      got_varcurl = switch.reset     /* XEDIT does not support VARCURL */
/*    'COMMAND EXTRACT /MSGMODE /LSCREEN'
      'COMMAND SET MSGMODE OFF'               /* Don't display errors. */
      do k=1 to lscreen.1
         'COMMAND SET CURLINE ON' k
         if (rc=0) then leave
      end  */
/*    curlmin = max(k,3) */           /* First screen line we can use. */
      curlmin = 3                     /* First screen line we can use. */
/*    do k=curlmin to lscreen.1
         'COMMAND SET CURLINE ON' k
         if (rc<>0) then leave
      end */
      curlmax = 23                     /* Last screen line we can use. */
/*    curlmax = k-1                    /* Last screen line we can use. */
      'COMMAND SET MSGMODE' msgmode.1 msgmode.2    /* Restore msgmode. */
      'COMMAND SET CURLINE ON' curlmin */
      curll = curlmin
/* end */

/****************** This is the main processing loop *******************/
   do linecnt=first_line to last_line
      if (linecnt=first_line+debug_cnt) then
        switch.debug = switch.reset
      switch.endtoken = switch.set      /* Check if end is first token */
      switch.comment_only = switch.reset
/*    'COMMAND :'linecnt
      'COMMAND EXTRACT /CURLINE' */
/*    raw_line = curline.3 */
      "(rawline) = line" linecnt
      raw_line = rawline
      curline.3=raw_line
      if (raw_line='') then do
         if (¬got_varcurl) then curll = curll + 1
         iterate linecnt
      end
      if (¬switch.search) then s = strip(raw_line); else s = raw_line
      com.linenum = linecnt          /* Line number to be used in XREF */
      out_string = ''                     /* Work area for output line */
      com.delim = ''                              /* Current delimiter */
      com.offset = left_margin + com.indent*com.nest,/* Current offset */
        + indent_thenelse
      p. = ''; pindex = 1                     /* Tokenized output line */
      do while (s<>'')
         if (switch.search) then do
            parse var s s1 (search_key) s +0
            if (search_key==c_astslash) then do
               /************* check for '/./' possibility **************/
               do while (s<>'' & right(s1,1)='/')
                  /** Search Found an imbedded comment instead of end **/
                  parse var s +1 s
                  parse var s s2 (search_key) s +0
                  s1 = s1'*'s2
               end
               parse var s1 . (c_slashast) s2 +0
               do while (s2<>'')
                  /************* Found an imbedded comment *************/
                  searchkey_cnt.search_key = searchkey_cnt.search_key + 1
                  searchkey_list.search_key = linecnt,
                    searchkey_list.search_key
                  parse var s2 (c_slashast) (c_slashast) s2 +0
               end
            end
            p.pindex = p.pindex || s1
            if (s<>'') then do
               /************** Found the ending delimiter **************/
               p.pindex = p.pindex || search_key
               s = substr(s,length(search_key)+1)
               searchkey_cnt.search_key = searchkey_cnt.search_key - 1
               searchkey_list.search_key =,
                 delword(searchkey_list.search_key,1,1)
               if (searchkey_cnt.search_key<=0) then do
                  if (search_key==c_astslash) then pindex = pindex + 1
                  else do
                     com.delim = search_key
                     switch.literal = switch.set
                     com.tokennum = com.tokennum + 1
                     com.last_token = s1
                  end
                  switch.search = switch.reset; search_key = ''
               end
            end
            iterate
         end
         /**************** looking for comment or quote ****************/
         parse var s s1a (c_slashast) s1b +0
         parse var s s2a (c_squote) s2b +0
         parse var s s3a (c_dquote) s3b +0
         select
            when (length(s1a)<length(s2a) & length(s1a)<length(s3a)) then
              do
               /************* Found the start of a comment *************/
               switch.search = switch.set; search_key = c_astslash
               searchkey_cnt.search_key = searchkey_cnt.search_key + 1
               searchkey_list.search_key = linecnt,
                 searchkey_list.search_key
               p.pindex = p.pindex || SCAN(s1a)
               pindex = pindex + 1
               p.pindex = p.pindex || c_slashast
               s = substr(s1b,3)
            end
            when (length(s3a)<length(s2a) | s2b<>'') then do
               /********* Found the start of a literal string **********/
               if (length(s3a)<length(s2a)) then do
                  search_key = c_dquote
                  s2a = s3a
                  s2b = s3b
               end
               else search_key = c_squote
               parse var s2b (search_key) s1 (search_key) s +0
               p.pindex = p.pindex || SCAN(s2a) || search_key || s1
               if (s<>'') then do
                  p.pindex = p.pindex || search_key
                  s = substr(s,2)
                  com.delim = search_key
                  switch.literal = switch.set
                  com.tokennum = com.tokennum + 1
                  com.last_token = search_key || s1 || search_key
                  search_key = ''
                  if (left(s,1)='(') then s1 = FUNCTION(s1)
               end
               else do
                  searchkey_cnt.search_key = searchkey_cnt.search_key + 1
                  searchkey_list.search_key = linecnt,
                    searchkey_list.search_key
                  switch.search = switch.set
               end
               switch.signalonoffv = switch.reset
            end
            otherwise                        /* Just process remainder */
            p.pindex = p.pindex || SCAN(s)
            s = ''
         end
      end
      if (p.pindex='') then pindex = pindex - 1

      if (switch.debug) then say 'One line scanned:' raw_line

      /****************** Check for continuation line ******************/
      if (last_delim==',') then com.offset = com.offset + continue_indent
      if (com.offset<0 | switch.skip) then com.offset = 0

      /* No further indenting if still searching for ending delimiter **/
      if (switch.search) then switch.skip = switch.set

      /****************** Justify comments as needed *******************/
      if (p.1='' & p.2<>'') then do
         if (switch.coml) then do
            com.offset = 0
            switch.skip = switch.set   /* Do not adjust comment indent */
            p.1 = left('',length(raw_line)-length(strip(raw_line,'L')))
         end
         else do
            /******* Do not re-indent already indented comments. *******/
            if (substr(raw_line,com.offset+1,2)==c_slashast) then
              switch.skip = switch.set
         end
      end

      p.1 = left('',com.offset) || p.1
      out_string = ''
      do i=1 to pindex
         out_string = out_string || p.i
      end

      len1 = length(out_string)
      if (len1>1) then do
         if (substr(out_string,len1-1,2)==c_astslash &,
           switch.comrjust & ¬switch.search) then do
            if (s1a='') then switch.comment_only = switch.set
            /****************** Right Adjust Comment *******************/
            i=index(out_string,c_slashast)
            if (i>1) then do           /* '/.' is to right of column 1 */
               comment=substr(out_string,i)
               line=strip(substr(out_string,1,i-1),'T')
               if (line<>'') then do       /* More than just a comment */
                  i=length(line)
                  if (i+length(comment)<right_margin) then do
                     out_string = line,    /* Adjust comment when room */
                       right(comment,right_margin-length(line)-1)
                  end
               end
            end
         end
      end

      /***************** Replace the line in the file ******************/
      if (out_string/==raw_line) then do
/*       'COMMAND REPLACE' out_string */
         outstr= out_string
         "line (linecnt) = (outstr)"
         /******** Check if new line was too long for the file *********/
/*       if (rc=3) then do */
         if (rc>0) then do
            "line (linecnt) = (rawline)"
/*          'COMMAND EXTRACT /ALT'
            'COMMAND SET ALT' alt.1-2 alt.2-2  */
         end
      end

      if ((pindex>2 | p.1<>'')) then last_delim = com.delim
      if (com.delim<>',') then do
         if (¬switch.comment_only) then do
            switch.thenelse = ,
              ((com.last_keyword='then' | com.last_keyword='else'),
              & com.tokennum=com.last_key_num)
            if (switch.thenelse) then
              indent_thenelse = indent_thenelse + thenelse_indent
            else indent_thenelse = 0
         end
         switch.signalonoffv = switch.reset
         com.tokennum = 0
         com.last_key_num = 0
         com.last_keyword = ''
         com.last_token = ''
         if (¬switch.search) then switch.skip = switch.reset
      end
      else if (¬switch.thenelse) then indent_thenelse = 0
      if (switch.debug) then say 'One line processed:' out_string
      else do
         if (¬got_varcurl) then do
            curll = curll + 1
            if (curll>curlmax) then curll = curlmin
          /*'COMMAND SET CURLINE ON' curll */
         end
    /*if (linecnt%refresh=linecnt/refresh) then 'COMMAND REFRESH' */
      end
   end linecnt                                        /* End main loop */

/*************************** Done processing ***************************/

/* 'COMMAND :'start_line */       /* Re-position to line we started at */
/* 'COMMAND RESTORE' */
   if (got_varcurl) then 'COMMAND SET VARCURL' varcurl.1 varcurl.2     /*
                                     Only at Waterloo, you say?  Pity! */
   if (switch.xref) then 'COMMAND MSG Sorting XREF ...'
/* 'COMMAND REFRESH' */

/******************* Check for Unbalanced delimiters *******************/
   if (com.endlist<>'') then
      Say  "Unbalanced  END's detected at:" com.endlist
   if (com.dolist<>'') then do
      temp = ''
      do i=1 to words(com.dolist)
         temp = word(com.dolist,i) temp
      end
       Say  "Unbalanced  DO's or  SELECT's at:" temp
   end
   if (searchkey_list.c_astslash<>'') then do
      temp = ''
      do i=1 to words(searchkey_list.c_astslash)
         temp = word(searchkey_list.c_astslash,i) temp
      end
       Say  "Unbalanced comments at:" temp
   end
   if (searchkey_list.c_squote<>'') then do
      temp = ''
      do i=1 to words(searchkey_list.c_squote)
         temp = word(searchkey_list.c_squote,i) temp
      end
       Say  "Unbalanced  ""'"" s at:" temp
   end
   if (searchkey_list.c_dquote<>'') then do
      temp = ''
      do i=1 to words(searchkey_list.c_dquote)
         temp = word(searchkey_list.c_dquote,i) temp
      end
       Say ' Unbalanced ''"''s At:' temp
   end

PRINT:
   if (switch.debug) then say 'At PRINT'
   if (¬switch.xref) then signal EXIT

   'COMMAND EXTRACT /FNAME /FTYPE /FMODE'
   fn = strip(fname.1)
   ft = strip(ftype.1)
   fm = strip(fmode.1)

   address command

/********** If adding to existing XREF, don't erase work file **********/
   if (¬switch.append) then 'ERASE REXXREF CMSUT1 A'
   'STATE REXXREF CMSUT1 A'
   if (rc=28) then do

      'ERASE' fn 'REXXREF A'

      /************************** Add heading **************************/
      fdate = date('U'); ftime = time()
      'MAKEBUF'
      'LISTFILE' fn ft fm '(DATE STACK LIFO'
      if (rc=0) then parse pull . . fm . . . . fdate ftime .
      'DROPBUF'
      pad = left('',24)
      temp=' 1'||pad||center('REXX CROSS REFERENCE - Created:',
        date('U') time(),80)
      'EXECIO 1 DISKW REXXREF CMSUT1 A 1 F 106 (STRING' temp
      temp=' 2'||pad||center('for file ' fn ft fm 'Dated:',
        fdate ftime,80)
      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp
      temp = ' 3'
      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp
      pad = left('.',24)
      temp = ' 4' || pad || '---- VARIABLES ----'
      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp
      temp = ' 5 '
      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp
      temp = ' 5' || pad || '---- LABELS ----'
      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp
      temp = ' 6 '
      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp
      temp = ' 6' || pad || '---- FUNCTIONS ----'
      'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp
   end

/***********************************************************************\
 * There are the following XREF variables:                             *
 * XREF.LABCNT                                                         *
 * XREF.LAB.i                                                          *
 * XREF.CNT.varname.                                                   *
 * XREF.REF.varname.i                                                  *
 *                                                                     *
 * XREF.LABCNT has the total count of labels found                     *
 * XREF.LAB.i  is a list of the labels in the order that they were found
 *       they are of the form xx string                                *
 *       xx = ' 4' => variable                                         *
 *            ' 5' => label                                            *
 *            ' 6' => subroutine                                       *
 *       xx is also used to control the sorting on the final listing   *
 * XREF.CNT.varname has the total count of occurrences of varname      *
 * XREF.REF.varname.i is a list of line number references for varname  *
 * XREF.REF.varname.0 is the first occurence where a label is defined  *
\***********************************************************************/

   outcnt = 0                        /* Initialize output line counter */
   do i=1 to xref.labcnt
      varname = xref.lab.i
      /* Label for SORT */
      parse var varname sortkey 3 varlabel
      sortkey2 = left(varname,23)
      /* Label */
      /****** Check for a label that's too long for a single line ******/
      if (length(varlabel)>=19) then do
         'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING',
           sortkey2 || right(outcnt,3) || varlabel
         outcnt = outcnt + 1                 /* Increment line counter */
         varlabel = left('',18)
      end
      varlabel = left(varlabel,18)
      temp3 = ''
      /**************** Check for function definitions *****************/
      if (sortkey=' 6') then do
         temp = 'REF.' || overlay(' 5',varname,1) || '.' || 0
         if (xref.temp<>0) then temp3 = temp3 xref.temp
      end

      /************ Build table of locations - 10 to a line ************/
      j2 = xref.cnt.varname
      do j=1 to j2 by 10
         do k=j to j+9 until (k=j2)
            temp = 'REF.' || varname || '.' || k
            temp3 = temp3 xref.temp
         end k
         temp3 = sortkey2 || right(outcnt,3) || varlabel temp3
         'EXECIO 1 DISKW REXXREF CMSUT1 A (STRING' temp3
         outcnt = outcnt + 1                 /* Increment line counter */
         temp3 = ''
         varlabel = left('',18)
      end j
   end i
   'FINIS REXXREF CMSUT1 A'

/*************************** Sort into order ***************************/
   'SET CMSTYPE HT'
   push '1 26'
   'SORT REXXREF CMSUT1 A REXXREF CMSUT2 A'
   if (rc<>0) then signal SORT_ERROR

/*********************** Remove sort search_key ************************/
   push '27-255 1'
   'COPYFILE REXXREF CMSUT2 A' fn 'REXXREF = (REPLACE SPECS RECFM V TRUNC'
   'SET CMSTYPE RT'
   if (switch.type) then 'TYPE' fn 'REXXREF A'

/********** If adding to existing XREF, don't erase work file **********/
   if (¬switch.append) then 'ERASE REXXREF CMSUT1 A'
   'ERASE REXXREF CMSUT2'            /* Always erase sorted work file. */
   signal EXIT

/******************* Internal routines and functions *******************/

/******* SCAN - Look for delimiters and break line into tokens. ********/
/** Delimiters such as <> will not be recognized as such, but we are ***/
/********** not checking syntax, only looking for delimiters. **********/

SCAN: procedure expose switch. com. xref. keywords.
   parse arg string
   if (switch.debug) then say 'At SCAN:' string
   if (string='') then return string
   delims = ',=()¬|&+-;:></%* '
   return_string = ''
   switch.eot = switch.reset
   do while (string<>'')
      iw = verify(string,delims,'M')
      if (iw=0) then do
         com.delim = ''
         switch.eot = switch.set
         return_string = return_string || SCANTOKEN(string)
         string = ''
      end
      else do
         com.delim = substr(string,iw,1)
         parse var string token (com.delim) string
         return_string = return_string || SCANTOKEN(token) || com.delim
         iw = verify(string'a',delims)
         if (iw>1) then do
            return_string = return_string || substr(string,1,iw-1)
            com.delim = right(strip(return_string,'T'),1)
            if (pos(com.delim,delims)=0) then com.delim = ''
            string = substr(string,iw)
         end
         if (com.delim==';') then do
            switch.signalonoffv = switch.reset
            com.tokennum = 0
            com.last_keyword = ''
            com.last_key_num = 0
            com.last_token = ''
         end
      end
      switch.literal = switch.reset
   end
   return return_string

/* SCANTOKEN - Classify TOKEN as KEYWORD, VARIABLE, LABEL, or FUNCTION.
   Currently, keywords are not scanned exactly as the language
   specifies,  ie. 'FUZZ' is always considered a keyword, not just
   when if follows 'NUMERIC'.
   Keywords are checked for last, in case a label or function has the
   same name as a keyword.
   Additional tables are provided if you wish to be more exacting.     */

SCANTOKEN: procedure expose switch. com. xref. keywords.
   parse arg string
   if (switch.debug) then say 'At SCANTOKEN:' string
   if (string='') then return string
   return_string = ''

   if (LOWER(string)<>'end') then
     switch.endtoken = switch.reset     /* END token not first on line */
   do i=1 to words(string)
      com.tokennum = com.tokennum + 1
      word1 = subword(string,i); temp = LOWER(word1)
      select
         when (datatype(word1)='NUM' | symbol(word1)='BAD') then
           /* Ignore whatever it is */
           return_string = return_string word1
         when (com.delim=':') then
           /* Things before ':'s are assumed to be LABELs */
           return_string = return_string LABEL(word1)
         when (com.delim='(') then
           /* Things before '(' (no BLANKs) are assumed to be FUNCTIONs*/
           return_string = return_string FUNCTION(word1)
         when ((com.last_token=='signal' | com.last_token=='call'),
           & com.tokennum>com.last_key_num) then do
           /* Things after 'SIGNAL' and 'CALL' are assumed to be LABELs*/
            if (com.last_token=='signal' & ,
              (temp=='on' | temp=='off' | temp=='value')) then do
               switch.signalonoffv = switch.set
               return_string = return_string KEYWORD(word1)
            end
            else return_string = return_string LABEL(word1)
         end
         when (find(keywords.scantok,temp)<>0) then do
            if (switch.signalonoffv) then do
               switch.signalonoffv = switch.reset
               return_string = return_string LABEL(word1)
            end
            else return_string = return_string KEYWORD(word1)
         end
         otherwise return_string = return_string VARIABLE(word1)
         switch.signalonoffv = switch.reset
      end
      com.last_token = temp
      switch.literal = switch.reset
   end
   return_string = strip(return_string)
   return return_string

KEYWORD: procedure expose switch. com. xref. keywords.
   parse arg word1
   if (switch.debug) then say 'At KEYWORD:' word1
   keyword = LOWER(word1)
   com.last_keyword = keyword
   com.last_key_num = com.tokennum
   if (switch.keyword_case) then do
      if (switch.colin) then word1 = CAPS(word1)
      else if (switch.lcc) then do
         word1 = LOWER(word1)
         temp = substr(word1,1,1)
         upper temp
         word1 = overlay(temp,word1,1,1)
      end
      else word1 = LOWER(word1)
   end
   select
      when (keyword='do') then do
         if (switch.noniterativedo & switch.eot) then
           switch.skipend = switch.set
         else com.nest = com.nest + 1
         com.dolist = com.linenum com.dolist
      end
      when (keyword='select') then do
         com.nest = com.nest + 1
         com.dolist = com.linenum com.dolist
      end
      when (keyword='end') then do
         if (switch.skipend) then switch.skipend = switch.reset
         else com.nest = com.nest - 1
         if (switch.endtoken) then com.offset = com.offset - com.indent
         if (com.dolist='') then com.endlist = com.endlist com.linenum
         else com.dolist = delword(com.dolist,1,1)
      end
      otherwise nop
   end
   return word1

VARIABLE: procedure expose switch. com. xref. keywords.
   parse arg word1
   if (switch.debug) then say 'At VARIABLE:' word1
   if (switch.variable_case) then word1 = LOWER(word1)
   sortkey = ' 4' || word1
   if (xref.cnt.sortkey=0) then do
      xref.labcnt = xref.labcnt + 1
      temp = 'LAB.' || xref.labcnt
      xref.temp = sortkey
   end
   xref.cnt.sortkey = xref.cnt.sortkey + 1
   temp2 = com.linenum
   if (com.tokennum=1) then do
      temp = 'REF.' || sortkey || '.' || 0
      /* Flag lines where variable is the first token (an assignment) **/
      temp2 = '*' || temp2
      xref.temp = temp2
   end
   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey
   xref.temp = temp2
   return word1

LABEL: procedure expose switch. com. xref. keywords.
   parse arg word1
   if (switch.debug) then say ' At LABEL:' word1
   if (switch.label_case) then do
      if (switch.colin) then do
         word1 = LOWER(word1)
         temp = substr(word1,1,1)
         upper temp
         word1 = overlay(temp,word1,1,1)
      end
      else word1 = CAPS(word1)
   end
   sortkey = ' 5' || word1
   if (com.tokennum<=1) then com.offset = 0
   if (xref.cnt.sortkey=0) then do
      xref.labcnt = xref.labcnt + 1
      temp = 'LAB.' || xref.labcnt
      xref.temp = sortkey
   end
   xref.cnt.sortkey = xref.cnt.sortkey + 1
   temp2 = com.linenum
   if (com.delim==':') then do
      temp = 'REF.' || sortkey || '.' || 0
      /******* Flag line for possible use as FUNCTION definition *******/
      temp2 = '*' || temp2
      if (xref.temp=0) then xref.temp = temp2
   end
   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey
   xref.temp = temp2
   return word1

FUNCTION: procedure expose switch. com. xref. keywords.
   parse arg word1
   if (switch.debug) then say ' At FUNCTION:' word1
   if (switch.function_case) then do
      word1 = LOWER(word1)
      /************** Check for system defined functions ***************/
      if (find(keywords.func,word1)=0) then do
         if (switch.colin) then do
            temp  = CAPS(word1)
            word1 = overlay(temp,word1,1,1)
         end
         else word1 = CAPS(word1)
      end
      else if (switch.lcc) then do
         temp  = CAPS(word1)
         word1 = overlay(temp,word1,1,1)
         if (verify(left(word1,1),'"''')) then do
            /* Put system functions in quotes */
            word1 = "'"CAPS(word1)"'"
            if (switch.literal) then word1 = '||'word1
         end
      end
   end
   if (left(word1,2)='||') then sortkey = ' 6'substr(word1,3)
   else sortkey = ' 6'word1
   if (xref.cnt.sortkey=0) then do
      xref.labcnt = xref.labcnt + 1
      temp = 'LAB.' || xref.labcnt
      xref.temp = sortkey
   end
   xref.cnt.sortkey = xref.cnt.sortkey + 1
   temp = 'REF.' || sortkey || '.' || xref.cnt.sortkey
   xref.temp = com.linenum
   return word1

CAPS: procedure
   parse upper arg args
   return args

LOWER: procedure
   parse arg args
   args = translate(args,,
     'abcdefghijklmnopqrstuvwxyz',,
     'ABCDEFGHIJKLMNOPQRSTUVWXYZ')
   return args

/***********************************************************************\
 *                                                                     *
 *     Internal function 'GETOPTWORD'                                  *
 *        Arguments are - single token, possibly abbreviated,          *
 *                      - string of valid full-length operands with    *
 *                        the length coded as the first character.     *
 *        If first argument is found, the full-length token is         *
 *        returned.  If not found, return original first argument.     *
 *                                                                     *
\***********************************************************************/
GETOPTWORD: procedure
   parse arg option, template
   nwords = words(template)
   do k=1 to nwords
      optword = word(template,k)
      len = left(optword,1)
      optword = substr(optword,2)
      if (length(option)>length(optword)) then iterate
      if (abbrev(optword,option,len)) then return optword
   end
   return option

EXIT16:
   rtncode = 16
EXIT:
/* address command 'DROPBUF' buf1
   address command 'SET CMSTYPE' typeflag */
   exit rtncode

EXPLAIN:
   signal EXPLAIN2
EXPLAIN2:
   do i=sigl+7 while (word(sourceline(i),1)<>c_astslash)
      say sourceline(i)
   end
   signal EXIT
/*
This XEDIT macro reformats and cross references REXX EXEC's.

REXXREF target (options

Where target is: (i)   (null) - process 1 line.  Target can not be null
                 when options are specified.

                 (ii)  ALL    - process complete file

                 (iii) a standard XEDIT target.  If the target is a
                 delimited string and options have been specified,
                 the string must be delimited on both left and right.

current options are (minimum abbrev in upper case, default first):

      APpend         - Prepare to append next XREF to one to be
                       generated by this call, or append current
                       XREF to previous one.
      COLIN          - Capitalize keywords/variables/labels the way
                       Colin thinks it should be done.
      INdent nn      - Number of spaces to indent loops. Default is 3.
      LEftmargin nn  - Create left margin such that the first non-comment
                       line begins in column 'nn'.  Useful when
                       REXXREF'ing subsections of a program.
      NODEBUG|DEBUG  - Generate a debugging trace.
      NOType|Type    - Type the cross reference.
      RIghtmargin nn - Column for right-aligning comments.  Default is 73
      Xref|NOXref    - Generate/don't generate a cross reference.

***** NOTE *****
In the following discussion '/*' is given as '/.' and '*/' as './'
This is because REXX treats the above as an imbedded comment even though
the comment delimiters are in quotes.  There would have to be matching
delimiters on each line, which confuses the discussion.
**********

Lines containing 'DO' or 'SELECT' are indented, while lines containing
'END' are un-indented.  Continuation lines are indented additional
space(s).  Indenting is supressed for lines containing a label.

Lines begining with '/.' can be either left alone or indented
(switch.coml).  The default is to leave alone.
Where possible, lines which end in a comment ('./') will be adjusted
so that the '/' will fall in column 73 (right_margin).

Blanks are not removed from the left of comments to avoid messing up
tables such as this.  However, comments that have already been indented
are not additionally indented.; so that you can REXXREF a file that has
already been REXXREFed.

If the modified line exceeds the LRECL of the original file, the
line is left unmodified.

Keywords are not scanned exactly as the language specifies.
'FUZZ', for example, is always considered a keyword, not just when it
follows 'NUMERIC'.
Keywords are checked for last, in case a label or function has the
same name as a keyword.
Keywords are listed in 'keywords.scantok' and an additional table is
provided if you wish to be more exacting.  Keywords are changed to
lower case (switch.keyword_case).

Builtin functions are treated as keywords.  Builtin functions are listed
in keywords.scantok.

Labels and user functions are changed to upper case (switch.label_case).
These are strings that preceed ':' or '(', or follow 'SIGNAL' or 'CALL'.

Variables are changed to lower case (switch.variable_case).

Comments and literal strings are left unchanged.

The cross reference has three parts.  The first part lists the
variables in alphabetical order (by the first 20 characters) and each
line that they were found on.  If the variable appeared more than once
on a line, then that line number will be repeated.  Line numbers where
the variable was the first token are preceeded by an '*' (these are
assumed to be assignments).

The second part lists the labels.  The line number where they are defined
is preceeded by an '*'.

The third part lists the functions.  A name may appear as both a label
and a function; and, for those that do, the line number where the
function is defined is preceeded by an '*' and prefixed to the LABELs
list.

The MACRO has the following subroutines:
1) SCAN:      Looks for delimiters and breaks a line into tokens.
2) SCANTOKEN: Clasifies a token as a keyword, variable, label, or function.
3) KEYWORD:   Processed keywords.
4) VARIABLE:  Processes variables.
5) LABEL:     Processes labels.
6) FUNCTION:  Processes functions.
7) CAPS:      Changes a token to upper case.
8) LOWER:     Changes a token to lower case.
9) EXPLAIN:   What you are reading now.
*/

PARSE_ERROR:
    Say ' reset while parsing arguments:' args
   signal EXIT16

SORT_ERROR:
   rtncode = rc
   'SET CMSTYPE RT'
   address xedit  Say ' Error' rtncode 'in line' sigl-1,
     'during SORT phase.'
   signal EXIT

NOVALUE:
   say 'NOVALUE'
   rtncode = 1
   temp_sigl = sigl
   signal ERROR2

ERROR:
   say 'ERROR'
   rtncode = 1
   temp_sigl = sigl
   signal ERROR2

SYNTAX:
   say 'SYNTAX'
   rtncode = rc
   temp_sigl = sigl

ERROR2:
   call trace('O')
   address command 'DROPBUF 0'
   typeflag = 'RT'
   temp = 'REXX error' rtncode 'in line' temp_sigl ':' errortext(rtncode)
   say temp
   say '***> You should definitely NOT be here.  Call SYSTEM support.'
   /* Signal EXIT                                                      */

/********************* For more serious debugging **********************/
   say sourceline(temp_sigl)
/* Trace ?r; Nop                                                       */
   call trace('O')
   parse source . . fn ft .
   push 'COMMAND :'temp_sigl
   push 'COMMAND EMSG' temp
   'XEDIT' fn ft
   signal off NOVALUE
   if (symbol(buf1)='LIT') then buf1 = '1'
   if (symbol(typeflag)='LIT') then typeflag = 'HT'
   signal EXIT
