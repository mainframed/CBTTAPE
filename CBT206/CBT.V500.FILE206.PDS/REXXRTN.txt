./   ADD   NAME=DASDVOLS
/* REXX                                                               */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/* DASDVOLS                                                           */
/*    PURPOSE: READS TYPE V AND C RECORDS FOR VOLUME DETAIL REPORT    */
/*             AND STORAGE GROUP SUMMARY REPORT, READS TYPE T RECORDS */
/*             FOR DFHSM TAPE SUMMARY REPORT                          */
/*                                                                    */
/*             DETAIL REPORT BY VOLSER CONTAINS THE FOLLOWING:        */
/*                DATE DCOLLECT RUN                                   */
/*                DATE DFHSM DATA COLLECT                             */
/*                VOLSER                                              */
/*                VOLUME CAPACITY IN KB                               */
/*                KB ALLOCATED ON VOLUME                              */
/*                FRAGMENTATION INDEX                                 */
/*                TARGET THRESHOLD                                    */
/*                TRIGGER THRESHOLD                                   */
/*                BEFORE OCCUPANCY                                    */
/*                AFTER OCCUPANCY                                     */
/*                PERCENT ELGIBLE TO MIGRATE                          */
/*             SUMMARY TOTALS BY STORAGE GROUP, SMS AND NON-SMS:      */
/*                CAPACITY IN KB                                      */
/*                KB ALLOCATED                                        */
/*                PERCENT ALLOCATED                                   */
/*                TARGET THRESHOLD (IF STORAGE GROUP)                 */
/*                TRIGGER THRESHOLD (IF STORAGE GROUP)                */
/*             SUMMARY TOTALS FOR DFHSM TAPE:                         */
/*                BACKUP: TOTAL, FULL, PARTIAL AND EMPTY              */
/*                DUMP: TOTAL, FULL, PARTIAL AND EMPTY                */
/*                MIGRATE: TOTAL, FULL, PARTIAL AND EMPTY             */
/*    INPUT:   SMS.UMB.COLLECT.RECTYPC                                */
/*             TYPE C RECORDS                                         */
/*             SMS.UMB.DCOLLECT.RECTYPV                               */
/*             TYPE V RECORDS                                         */
/*             SMS.UMB.DCOLLECT.RECTYPT                               */
/*             TYPE T RECORDS                                         */
/*    OUTPUT:  SMS.PMB.DCOLLECT.CAPACITY.DCCYYDDD                     */
/*    PRESORT: FOR TYPE C RECORDS                                     */
/*             SORT FIELDS=(29,6,CH,A,35,4,CH,D)                      */
/*             INCLUDE COND=(9,2,CH,EQ,C'C ')                         */
/*             RECORD TYPE=V,LENGTH=(264,,264)                        */
/*                                                                    */
/*             FOR TYPE V RECORDS                                     */
/*             SORT FIELDS=(87,8,CH,A,29,6,CH,A)                      */
/*             INCLUDE COND=(9,2,CH,EQ,C'V ')                         */
/*             RECORD TYPE=V,LENGTH=(264,,264)                        */
/*                                                                    */
/*             FOR TYPE T RECORDS                                     */
/*             SORT FIELDS=(29,6,CH,A)                                */
/*             INCLUDE COND=(9,2,CH,EQ,C'T ')                         */
/*             RECORD TYPE=V,LENGTH=(264,,264)                        */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT V RECORDS)     */
/***********************************************************/
 TRACE N
 INNAME = "'SMS.UMB.DCOLLECT.RECTYPV'"
 "ALLOC DD(INFILE) DA("INNAME") SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT C RECORDS)     */
/***********************************************************/
 INNAME2 = "'SMS.UMB.DCOLLECT.RECTYPC'"
 "ALLOC DD(INFILE2) DA("INNAME2") SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME2') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT T RECORDS)     */
/***********************************************************/
 INNAME = "'SMS.UMB.DCOLLECT.RECTYPT'"
 "ALLOC F(INFILE3) DA("INNAME") SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 OUT_COUNT = 0
 TOT_ALLOC_KB = 0
 SMS_ALLOC_KB = 0
 TOT_AVAIL_KB = 0
 SMS_AVAIL_KB = 0
 STG_ALLOC_KB. = 0
 STG_AVAIL_KB. = 0
 NONSMS_ALLOC_KB = 0
 NONSMS_AVAIL_KB = 0
 VOLSER = '      '
 COL_DATE. = '      '
 TARGET.  = '   '
 TRIGGER. = '   '
 TARGET_STG.  = '   '
 TRIGGER_STG. = '   '
 B4.      = '  '
 AFTER.   = '  '
 MIGELG.  = '  '
 STGRP_NAMES    = ' '

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE C RECORDS                  */
/***********************************************************/
 "EXECIO * DISKR INFILE2 (FINIS STEM RECORD."

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 DO K = 1 TO RECORD.0
    PARSE VAR RECORD.K 1 . 25 UCVOLSR 31 UCCOLDT 35 UCFLAG1,
      36 . 37 UCTOTAL 41 UCTGOCC 42 UCTROCC 43 UCBFOCC,
      44 UCAFOCC 45 UCNOMIG 46 UCNINTV 47 UCINTVM 48
    IF UCVOLSR \= VOLSER THEN DO
       VOLSER = UCVOLSR
       COL_DATE.VOLSER = LEFT(C2X(UCCOLDT),7)
       TARGET.VOLSER  = C2D(UCTGOCC)
       TRIGGER.VOLSER = C2D(UCTROCC)
       B4.VOLSER      = C2D(UCBFOCC)
       AFTER.VOLSER   = C2D(UCAFOCC)
       MIGELG.VOLSER  = C2D(UCNOMIG)
       END
 END

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE V RECORDS                  */
/***********************************************************/
 "EXECIO * DISKR INFILE (FINIS STEM RECORD."

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 DO K = 1 TO RECORD.0
    PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
       13 DCUTIME 17 DCUDATE 21 .
    PARSE VAR RECORD.K 1 . 25 DCVVOLSR 31 DCVFLAG1,
       32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,
       45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,
       65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .
    DATE = LEFT(C2X(DCUDATE),7)
    IF K=1 THEN DO
       OUT_COUNT = OUT_COUNT + 1
       OUT_LINE.OUT_COUNT = "DCOLLECT RUN ON:" DATE
       CALL OUTHEAD
       END
    VOLSER = DCVVOLSR
    IF BITAND(DCVFLAG1,'03'X) = '03'X  THEN DO  /* IS IT SMS?         */
       SMS_ALLOC_KB = SMS_ALLOC_KB + C2D(DCVALLOC)
       SMS_AVAIL_KB = SMS_AVAIL_KB + C2D(DCVVLCAP)
       IF DCVSGTCL = '        ' THEN DCVSGTCL = 'NO_GROUP'
       END
    SELECT
       WHEN SUBSTR(VOLSER,1,2) = 'ML' THEN
         TARGTRIG = (TARGET.VOLSER||"/"||TRIGGER.VOLSER)
       WHEN DCVSGTCL = '      ' | DCVSGTCL = 'NO_GROUP' THEN
         TARGTRIG = '  '
       OTHERWISE
         TARGTRIG = (TARGET.VOLSER||"/"||TRIGGER.VOLSER)
    END
/***********************************************************/
/* BUILD LIST OF STORAGE GROUP NAMES                       */
/*  AND PROCESS KBYTES INFORMATION BY STORAGE GROUP        */
/***********************************************************/

    IF DCVSGTCL \= '      ' THEN DO
       IF WORDPOS(DCVSGTCL,STGRP_NAMES,1) = 0 THEN DO
          STGRP_NAMES = STGRP_NAMES DCVSGTCL
          L = WORDPOS(DCVSGTCL,STGRP_NAMES,1)
          TARGET_STG.L = TARGET.DCVVOLSR
          TRIGGER_STG.L = TRIGGER.DCVVOLSR
          END
       L = WORDPOS(DCVSGTCL,STGRP_NAMES,1)
       STG_ALLOC_KB.L = STG_ALLOC_KB.L + C2D(DCVALLOC)
       STG_AVAIL_KB.L = STG_AVAIL_KB.L + C2D(DCVVLCAP)
       END
    ELSE DO
       NONSMS_ALLOC_KB = NONSMS_ALLOC_KB + C2D(DCVALLOC)
       NONSMS_AVAIL_KB = NONSMS_AVAIL_KB + C2D(DCVVLCAP)
       END

/***********************************************************/
/* BUILD TOTALS                                            */
/***********************************************************/

    TOT_ALLOC_KB = TOT_ALLOC_KB + C2D(DCVALLOC)
    TOT_AVAIL_KB = TOT_AVAIL_KB + C2D(DCVVLCAP)

/***********************************************************/
/* PUT OUT VOLUME DETAIL RECORD                            */
/***********************************************************/

    OUT_COUNT = OUT_COUNT + 1
    OUT_LINE.OUT_COUNT = CENTER(COL_DATE.VOLSER,7),
        LEFT(DCVSGTCL,8),
        RIGHT(DCVVOLSR,6),
        RIGHT(C2D(DCVVLCAP),10),
        RIGHT(C2D(DCVALLOC),10),
        RIGHT(C2D(DCVFRAGI),6),
        CENTER(TARGTRIG,7),
        RIGHT(B4.VOLSER,6),
        RIGHT(AFTER.VOLSER,6),
        RIGHT(MIGELG.VOLSER,4)
 END

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
 OUTNAME = "'SMS.PMB.DCOLLECT.CAPACITY.D"||DATE||"'"
 "ALLOC DSNAME("||OUTNAME||")",
     "DSORG(PS) LRECL(80) RECFM(F B) ",
     "TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)"
  IF RC¬= 0 THEN DO
     SAY  'ALLOC OF ('||OUTNAME||') FAILED'
     EXIT 12
     END

OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("++++",80,"+")
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER("    ",7),
    LEFT("      ",8),
    RIGHT("     ",6),
    RIGHT("CAPACITY",12),
    RIGHT("ALLOCATED",12),
    CENTER("PERCENT",9),
    CENTER("TARGET/",7)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER("    ",7),
    LEFT("      ",8),
    RIGHT("     ",6),
    RIGHT("IN KBYTES",12),
    RIGHT("IN KBYTES",12),
    CENTER("ALLOCATED",9),
    CENTER("TRIGGER",7)

/***********************************************************/
/* PUT OUT TOTALS BY STORAGE GROUP, SMS AND GRAND TOTAL    */
/***********************************************************/

L = WORDS(STGRP_NAMES)
DO K = 1 TO L
   PRCNT_ALC = FORMAT(((STG_ALLOC_KB.K/STG_AVAIL_KB.K)*100),3,1)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER('  ',7),
       RIGHT(WORD(STGRP_NAMES,K),8),
       LEFT("   ",6),
       RIGHT(STG_AVAIL_KB.K,12),
       RIGHT(STG_ALLOC_KB.K,12),
       RIGHT(PRCNT_ALC,9),
       CENTER(TARGET_STG.K||"/"||TRIGGER_STG.K,7)
END

PRCNT_ALC = FORMAT(((SMS_ALLOC_KB/SMS_AVAIL_KB)*100),3,1)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER('  ',7),
    RIGHT("SMS",8),
    LEFT("    ",6),
    RIGHT(SMS_AVAIL_KB,12),
    RIGHT(SMS_ALLOC_KB,12),
    RIGHT(PRCNT_ALC,9)

PRCNT_ALC = FORMAT(((NONSMS_ALLOC_KB/NONSMS_AVAIL_KB)*100),3,1)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER('  ',7),
    RIGHT("NON-SMS",8),
    LEFT("    ",6),
    RIGHT(NONSMS_AVAIL_KB,12),
    RIGHT(NONSMS_ALLOC_KB,12),
    RIGHT(PRCNT_ALC,9)

PRCNT_ALC = FORMAT(((TOT_ALLOC_KB/TOT_AVAIL_KB)*100),3,1)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = CENTER('  ',7),
    RIGHT("TOTAL",8),
    LEFT("     ",6),
    RIGHT(TOT_AVAIL_KB,12),
    RIGHT(TOT_ALLOC_KB,12),
    RIGHT(PRCNT_ALC,9)

/***********************************************************/
/* PROCESS EACH T RECORD UNTIL END-OF-FILE REACHED         */
/***********************************************************/
 UTALL = 0
 UTTOT = 0
 UTTOTFULL = 0
 UTTOTPART = 0
 UTTOTEMP = 0
 EOF = 'NO'
 CALL OUTHEADT
 TRACE N
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE3"
   IF RC¬= 0 THEN
      EOF = 'YES'
   ELSE DO
      PARSE PULL RECORD
/***********************************************************/
/* DETERMINE THE RECORD TYPE (M,B,C,T,D,A,V)               */
/***********************************************************/
      DCURCTYP=SUBSTR(RECORD,5,2)
         SELECT
/***********************************************************/
/* PROCESS TAPE     DATA SET INFORMATION RECORD            */
/***********************************************************/
         WHEN(DCURCTYP='T ') THEN DO
                             CALL DCTRECP
                             IF UTSTYPE = B THEN TYPE = "BACKUP "
                             IF UTSTYPE = M THEN TYPE = "MIGRATE"
                             IF UTSTYPE = D THEN TYPE = "DUMP   "
                             UTALL = UTFULL + UTPART + UTEMPTY
                             UTTOT = UTALL + UTTOT
                             UTTOTFULL = UTFULL + UTTOTFULL
                             UTTOTPART = UTPART + UTTOTPART
                             UTTOTEMP= UTEMPTY + UTTOTEMP
                             CALL OUTDET
                             END
         OTHERWISE
         END
      END
 END
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("TOTAL",9),
    RIGHT(UTTOT,7),
    RIGHT(UTTOTFULL,7),
    RIGHT(UTTOTPART,7),
    RIGHT(UTTOTEMP,7)

"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE ALL"
EXIT

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                                    */
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER("    ",7),
       LEFT("      ",8),
       RIGHT("      ",6),
       RIGHT("VOLUME",10),
       RIGHT("VOLUME",10),
       RIGHT("      ",6),
       RIGHT("       ",7),
       CENTER("      ",6),
       CENTER("     ",6),
       CENTER("%",4)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER("COLLECT",7),
       LEFT("STORAGE",8),
       RIGHT("      ",6),
       RIGHT("CAPACITY",10),
       RIGHT("ALLOCATED",10),
       CENTER("FRAG",6),
       CENTER("TARGET/",7),
       CENTER("BEFORE",6),
       CENTER("AFTER",6),
       CENTER("MIGR",4)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = CENTER("DATE",7),
       LEFT("GROUP",8),
       RIGHT("VOLSER",6),
       RIGHT("IN KBYTES",10),
       RIGHT("IN KBYTES",10),
       CENTER("INDEX",6),
       CENTER("TRIGGER",7),
       CENTER("OCCUPY",6),
       CENTER("OCCUPY",6),
       CENTER("ELG",4)
   RETURN

/***********************************************************/
/* PARSE   TAPE CAPACITY PLANNING RECORD                   */
/***********************************************************/
 DCTRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
      13 DCUTIME 17 DCUDATE 21 . ,
      25 UTSTYPE 26 . ,
      29 UTFULL 33 UTPART 37 UTEMPTY 41
       UTFULL = C2D(UTFULL)
       UTPART = C2D(UTPART)
       UTEMPTY = C2D(UTEMPTY)
 RETURN

/***********************************************************/
/*   PRINT OUT TAPE HEADINGS                               */
/***********************************************************/
OUTHEADT:
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT("++++",80,"+")
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT("HSM TAPES",9),
      RIGHT("TOTAL",7),
      RIGHT("FULL",7),
      RIGHT("PARTIAL",7),
      RIGHT("EMPTY",7)
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT("---------",9),
      RIGHT("-------",7),
      RIGHT("-------",7),
      RIGHT("-------",7),
      RIGHT("-------",7)
  RETURN

/***********************************************************/
/*   PRINT OUT TAPE TYPES                                  */
/***********************************************************/
OUTDET:
  OUT_COUNT = OUT_COUNT + 1
  OUT_LINE.OUT_COUNT = LEFT(TYPE,9),
      RIGHT(UTALL,7),
      RIGHT(UTFULL,7),
      RIGHT(UTPART,7),
      RIGHT(UTEMPTY,7)
  RETURN

./   ADD   NAME=DATERFSM
/* REXX                                                               */
/*                                                                    */
/* DATERFSM                                                           */
/*    PURPOSE: READS TYPE D AND M RECORDS AND PRODUCES REPORTS OF     */
/*             DAYS FROM LAST REFERENCE FOR THE FOLLOWING:            */
/*                L0, ML1 AND ML2 DATA COMBINED                       */
/*                ALL L0 DATA                                         */
/*                L0 SMS ONLY                                         */
/*                L0 NONSMS ONLY                                      */
/*                                                                    */
/*             A DETAIL REPORT IS PRODUCED THAT LISTS OUT ALL         */
/*             DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,   */
/*             VTOCS, VVDS, PAGE AND TEMPORARY DSNS                   */
/*                                                                    */
/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  SMS.UMB.DCOLLECT.DATE.LRF                              */
/*             SMS.UMB.DCOLLECT.DETAIL.LRF                            */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */
/***********************************************************/
TRACE N
INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'"
 "ALLOC F(INFILE) DA("INNAME") SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
 OUTNAME = "'SMS.UMB.DCOLLECT.DATE.LRF'"
"ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(50,20) RELEASE DDNAME(OUTFILE)"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE DETAIL BY DSN REPORT       */
/***********************************************************/
 OUTNAME = "'SMS.UMB.DCOLLECT.DATE.DETAIL.LRF'"
"ALLOC DSNAME("OUTNAME")",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(7000,3500) RELEASE DDNAME(OUTDET)"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 DAYS.1   = '0-15'
 DAYS.2   = '16-30'
 DAYS.3   = '31-60'
 DAYS.4   = '61-120'
 DAYS.5   = '121-365'
 DAYS.6   = '>365'
 DAYS.7   = 'VS INDX'
 DAYS.8   = 'SYSTEM'
 DAYS.TOT = 'TOTAL'
 DAYS.ERR = 'ERRORS'
 DAYST = 8
 DSN#.    = 0
 MBALLOC. = 0
 MBORG.   = 0
 DSNPER.  = 0
 MBORGPER. = 0
 K        = 0

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 EOF = 'NO'
 FIRST_REC = 'YES'
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE"
   IF RC¬= 0 THEN EOF = 'YES'
   ELSE DO
      PARSE PULL RECORD
      PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 17 DCUDATE 21 .,
         25 RECDSN 69 .
      VSINDX = 'NO'
      VS = 'NO'
      SYS = 'NO'

      IF FIRST_REC = 'YES' THEN DO               /* SPECIAL PROCESSING*/
         COLDATE  = RIGHT(LEFT(C2X(DCUDATE),7),5) /*FOR FIRST RECORD  */
         COLYY = LEFT(COLDATE,2)
         COLDDD = RIGHT(COLDATE,3)
         OUT_LINE = "DATA COLLECTED ON:" COLDATE
         PUSH OUT_LINE
         "EXECIO 1 DISKW OUTFILE"
         OUT_LINE2 = OUT_LINE
         PUSH OUT_LINE2
         "EXECIO 1 DISKW OUTDET"
         CALL OUTHEAD2
         FIRST_REC = 'NO'
         END

      SELECT
         WHEN(DCURCTYP='D ') THEN DO             /* ACTIVE DATA       */
                          CALL DCDRECP
                          DSN = DCDDSNAM
                          REFYY = LEFT(DCDLSTRF,2)
                          REFDDD = RIGHT(DCDLSTRF,3)
                          CREYY = LEFT(DCDCREDT,2)
                          CREDDD = RIGHT(DCDCREDT,3)
                          CREATED = DCDCREDT
                          CURRSIZE = DCDALLSP
                          ORGSIZE = DCDALLSP
                          DSORG = DCDDSORG
                          END
         WHEN(DCURCTYP='M ') THEN DO             /* MIGRATED DATA     */
                          CALL DCMRECP
                          DSN = UMDSNAM
                          REFYY = LEFT(UMLRFDT,2)
                          REFDDD = RIGHT(UMLRFDT,3)
                          CREYY = LEFT(UMCREDT,2)
                          CREDDD = RIGHT(UMCREDT,3)
                          CREATED = UMCREDT
                          CURRSIZE = UMDSIZE
                          ORGSIZE = UMALLSP
                          DSORG = UMDSORG
                          END
         OTHERWISE            /* DO NOT PROCESS OTHER RECORD TYPES */
         END

/***********************************************************/
/* CALULATE NUMBER OF DAYS SINCE LAST REFERENCE            */
/* ALL DATA, BOTH SMS AND NON-SMS                          */
/* BASED ON COLLECTION DATE OF DATA                        */
/***********************************************************/

      IF REFDDD = '00000' THEN DO      /*  IF LASTREF = 0'S THEN      */
         REFYY = CREYY                 /*  SET LAST REFERENCE TO      */
         REFDDD = CREDDD               /*  CREATION DATE              */
         END
      IF COLDDD <= REFDDD THEN DO
         REFYY = REFYY - 1
         REFDDD = REFDDD + 365
         END
      REFDAYS = COLDDD - REFDDD
      REFYRS = COLYY - REFYY
      REFDAYS = REFDAYS + (REFYRS * 365)

      IF SUBSTR(DSN,1,9) = "SYS1.VVDS" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,9) = "SYS1.VTOC" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,9) = "BHSM.VTOC" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,6) = "PAGE.V" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,4) = "SYS9" THEN SYS = 'YES'
      IF INDEX(DSN,'DUMYDSCB') >0 THEN SYS = 'YES'
      IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN DO
         VS = 'YES'
         IF INDEX(DSN,'INDEX') >0 THEN VSINDX = 'YES'
         END

      SELECT
         WHEN SYS = 'YES' THEN K=8
         WHEN VSINDX = 'YES' THEN K=7
         WHEN REFDAYS <=15 THEN K=1
         WHEN REFDAYS > 15 & REFDAYS <= 30 THEN K=2
         WHEN REFDAYS > 30 & REFDAYS <= 60 THEN K=3
         WHEN REFDAYS > 60 & REFDAYS <= 120 THEN K=4
         WHEN REFDAYS > 120 & REFDAYS <= 365 THEN K=5
         WHEN REFDAYS > 365  THEN K=6
      OTHERWISE K = 'ERR'  /* DO NOT PROCESS OTHER RECORD TYPES */
      END                                        /* END OF SELECT     */

/***********************************************************/
/* TOTAL UP STATS FOR ALL DATA - SMS AND NON-SMS           */
/* ACTIVE AND MIGRATED                                     */
/***********************************************************/

      DSN#.DM.REF.K    = DSN#.DM.REF.K + 1
      MBALLOC.DM.REF.K = MBALLOC.DM.REF.K + CURRSIZE
      MBORG.DM.REF.K   = MBORG.DM.REF.K + ORGSIZE
      DSN#.DM.REF.TOT    = DSN#.DM.REF.TOT + 1
      MBALLOC.DM.REF.TOT = MBALLOC.DM.REF.TOT + CURRSIZE
      MBORG.DM.REF.TOT   = MBORG.DM.REF.TOT + ORGSIZE

/***********************************************************/
/* TOTAL UP STATS FOR ACTIVE (L0) ONLY                     */
/***********************************************************/

      IF DCURCTYP='D ' THEN DO
         DSN#.L0.REF.K    = DSN#.L0.REF.K + 1
         MBALLOC.L0.REF.K = MBALLOC.L0.REF.K + CURRSIZE
         MBORG.L0.REF.K   = MBORG.L0.REF.K + ORGSIZE
         DSN#.L0.REF.TOT    = DSN#.L0.REF.TOT + 1
         MBALLOC.L0.REF.TOT = MBALLOC.L0.REF.TOT + CURRSIZE
         MBORG.L0.REF.TOT   = MBORG.L0.REF.TOT + ORGSIZE
         IF K>2 & K<7 THEN CALL OUTLINE2
         IF BITAND(DCDFLAG1,'40'X) = '40'X THEN DO
            DSN#.SMS.REF.K   = DSN#.SMS.REF.K + 1
            MBALLOC.SMS.REF.K = MBALLOC.SMS.REF.K + CURRSIZE
            MBORG.SMS.REF.K  = MBORG.SMS.REF.K + ORGSIZE
            DSN#.SMS.REF.TOT   = DSN#.SMS.REF.TOT + 1
            MBALLOC.SMS.REF.TOT = MBALLOC.SMS.REF.TOT + CURRSIZE
            MBORG.SMS.REF.TOT  = MBORG.SMS.REF.TOT + ORGSIZE
            END
         ELSE DO
            DSN#.NONSMS.REF.K = DSN#.NONSMS.REF.K + 1
            MBALLOC.NONSMS.REF.K = MBALLOC.NONSMS.REF.K + CURRSIZE
            MBORG.NONSMS.REF.K = MBORG.NONSMS.REF.K + ORGSIZE
            DSN#.NONSMS.REF.TOT = DSN#.NONSMS.REF.TOT + 1
            MBALLOC.NONSMS.REF.TOT = MBALLOC.NONSMS.REF.TOT + CURRSIZE
            MBORG.NONSMS.REF.TOT = MBORG.NONSMS.REF.TOT + ORGSIZE
            END
         END

   END
 END                                             /* END OF DOWHILE EOF*/
"EXECIO 0 DISKR INFILE (FINIS"
"FREE DDNAME(INFILE)"

/***********************************************************/
/* TOTAL IT ALL UP                                         */
/* PUT REPORT OUT TO DATASET                               */
/***********************************************************/

 CALL OUTLEG
 TYP = "DM.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0, ML1, AND ML2 DATA"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */

 TYP = "L0.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */

 TYP = "SMS.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0 SMS ONLY"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */

 TYP = "NONSMS.REF"
 CALL PERCENT
 REP = "LAST REFERENCE DATE - L0 NONSMS ONLY"
 CALL OUTHEAD
 DO J = 1 TO DAYST
    CALL OUTLINE
 END
 J = 'TOT'
 CALL OUTLINE
/* J = 'ERR'                                                          */
/* CALL OUTLINE                                                       */
"EXECIO 0 DISKW OUTFILE (FINIS"
"EXECIO 0 DISKW OUTDET (FINIS"
"FREE DDNAME(OUTFILE)"
"FREE DDNAME(OUTDET)"

 EXIT


/***********************************************************/
/* ROUTINE TO FIGURE OUT PERCENTAGES OF TOTALS             */
/*  AND                                                    */
/* CHANGE THE ALLOC AND ORG DATA TO MB INSTEAD OF KB       */
/***********************************************************/

 PERCENT:

    DO J = 1 TO DAYST
       DSN1 = DSN#.TYP.J/DSN#.TYP.TOT
       MBORG1 = MBORG.TYP.J/MBORG.TYP.TOT
       DSNPER.TYP.J   = FORMAT(((DSN1)*100),3,1)
       MBORGPER.TYP.J = FORMAT(((MBORG1)*100),3,1)
       MBALLOC.TYP.J = FORMAT((MBALLOC.TYP.J/1024),,0)
       MBORG.TYP.J   = FORMAT((MBORG.TYP.J /1024),,0)
    END
    MBALLOC.TYP.TOT = FORMAT((MBALLOC.TYP.TOT/1024),,0)
    MBORG.TYP.TOT   = FORMAT((MBORG.TYP.TOT /1024),,0)
    DSNPER.TYP.TOT = ' '
    MBORGPER.TYP.TOT = ' '
 RETURN

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                          */
   OUT_LINE = "   "
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = REP
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = CENTER("DAYS",9),
      CENTER("# BY DSN",9),
      CENTER("MB ALLOC",10),
      CENTER("ORG MB",10),
      CENTER("% DSN",8),
      CENTER("% ORG MB",8)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT OUT A LEGEND LINE                                   */
/***********************************************************/
 OUTLEG:
/*                                                          */
   OUT_LINE = "   "
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = "VS INDX = VSAM INDEXES"
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = "SYSTEM = VTOCS, VVDS, PAGE AND TEMPORARY DSNS"
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = "   "
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT SUMMARIZED INFO OUT TO NEW FILE                     */
/***********************************************************/
OUTLINE:
/*                                                          */
   OUT_LINE = LEFT(DAYS.J,9),
      RIGHT(DSN#.TYP.J,9),
      RIGHT(MBALLOC.TYP.J,10),
      RIGHT(MBORG.TYP.J,10),
      RIGHT(DSNPER.TYP.J,8),
      RIGHT(MBORGPER.TYP.J,8)
/* SAY OUT_LINE                                             */
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT OUT A HEADER LINE FOR DETAIL REPORT                 */
/***********************************************************/
 OUTHEAD2:
/*                                                          */
   OUT_LINE2 = "   "
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = "DSNS OLDER THAN 30 DAYS, NOT INCLUDING VSAM INDEXES,"
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = "VTOCS, VVDS, PAGE AND TEMPORARY DSNS"
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = "   "
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
   OUT_LINE2 = LEFT("DSN",44),
      CENTER("REF DAYS",9),
      CENTER("MGMTCL",8),
      CENTER("STOGRP",8)
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
 RETURN

/***********************************************************/
/* PUT DETAIL INFO OUT TO NEW FILE                         */
/***********************************************************/
OUTLINE2:
/*                                                          */
   OUT_LINE2 = LEFT(DCDDSNAM,44),
      RIGHT(REFDAYS,9),
      RIGHT(DCDMGTCL,8),
      RIGHT(DCDSTGRP,8)
/* SAY OUT_LINE2                                             */
   PUSH OUT_LINE2
   "EXECIO 1 DISKW OUTDET"
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .

   DCDALLSP = C2D(DCDALLSP)
   DCDCREDT = RIGHT(LEFT(C2X(DCDCREDT),7),5)
   DCDLSTRF = RIGHT(LEFT(C2X(DCDLSTRF),7),5)
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
   UMALLSP = C2D(UMALLSP)
   UMDSIZE = C2D(UMDSIZE)
   UMCREDT = RIGHT(LEFT(C2X(UMCREDT),7),5)
   UMLRFDT = RIGHT(LEFT(C2X(UMLRFDT),7),5)
   UMLBKDT = C2X(UMLBKDT)
 RETURN

./   ADD   NAME=DB2
/* REXX                                                               */
/*                                                                    */
/* DB2                                                                */
/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT ALL DB2             */
/*             DSNS, INCLUDING VOLSER, CREATION DATE AND              */
/*             ALLOCATED KBYTES. TOTALS ALLOCATED KBYTES.             */
/*                                                                    */
/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  SMS.UMB.DCOLLECT.DB2.DCCYYDDD                          */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/**********************************************************************/

TRACE N

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M RECORDS)   */
/***********************************************************/

INDD1 = "'SMS.UMB.DCOLLECT.RECTYPDM'"
"ALLOC DSNAME("||INDD1||") DDNAME(FILEA) SHR"

/****************************************************************/
/*  INITIALIZE VARIABLES                                        */
/****************************************************************/
DSNCOUNT = 0
STD_DSNCOUNT = 0
OUT_COUNT = 0
HLQ_SMS_DSNCT = 0
HLQ_DSNCT = 0
HLQ_STDDSN = 0
TOT_HLQ = 0
ALLOC = 0
FIRST_REC = "YES"

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/

"EXECIO 10000 DISKR FILEA (STEM IN_REC."
DO WHILE IN_REC.0 > 0
   DO J = 1 TO IN_REC.0
      PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
         13 DCUTIME 17 DCUDATE 21 .
      IF FIRST_REC = 'YES' THEN DO               /* SPECIAL PROCESSING*/
         COLDATE  = LEFT(C2X(DCUDATE),7)         /* FOR FIRST RECORD  */
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = "DATA COLLECTED ON:" COLDATE
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = "  "
         FIRST_REC = 'NO'
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = LEFT("DSN",44),
             RIGHT("VOLSER",6),
             RIGHT("CREATED",7),
             RIGHT("ALLOC_KB",10)
         OUT_COUNT = OUT_COUNT + 1
         OUT_LINE.OUT_COUNT = LEFT("-",44,"-"),
            RIGHT("------",6),
            RIGHT("-------",7),
            LEFT("----------",10)
         END
      IF DCURCTYP = "D " THEN DO
         CALL DCDRECP
         CREDT = LEFT(C2X(DCDCREDT),7)
         PARSE VAR IN_REC.J 1 . 25 HLQ.J "." HLQ2.J "." HLQ3.J "." .
         IF LENGTH(HLQ.J) > 8 THEN HLQ.J = LEFT(HLQ.J,8)
         IF LENGTH(HLQ2.J) > 8 THEN HLQ2.J = LEFT(HLQ2.J,8)
         IF LENGTH(HLQ3.J) > 8 THEN HLQ2.J = LEFT(HLQ3.J,8)
         IF LEFT(HLQ2.J,5) = "DSNDB" THEN DO
            ALLOC = ALLOC + C2D(DCDALLSP)
            OUT_COUNT = OUT_COUNT + 1
            OUT_LINE.OUT_COUNT = LEFT(DCDDSNAM,44),
            LEFT(DCDVOLSR,6),
            RIGHT(CREDT,7),
            RIGHT(C2D(DCDALLSP),10)
            END
         END
   END
   "EXECIO 10000 DISKR FILEA (STEM IN_REC."
END

/****************************************************************/
/*  PUT OUT TOTAL COUNTS                                        */
/****************************************************************/
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("  ",44)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("-",44,"-"),
   RIGHT("------",6),
   RIGHT("-------",7),
   LEFT("==========",10)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("  ",44)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("TOTAL ALLOCATED KBYTES",44),
    RIGHT("     ",6),
    RIGHT("     ",7),
    RIGHT(ALLOC,10)

/****************************************************************/
/*  FREE INPUT FILE AND CREATE OUTPUT FILE                      */
/****************************************************************/
"EXECIO 0 DISKR FILEA (FINIS"
"FREE DDNAME(FILEA)"
"ALLOC DSNAME('SMS.UMB.DCOLLECT.DB2.D"||COLDATE||"')",
    "DSORG(PS) LRECL(80) RECFM(F B) ",
    "TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)"
"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE DDNAME(OUTDD)"
EXIT

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
 RETURN

./   ADD   NAME=DCOLDLY
/* REXX                                                               */
"%NONSMS"
"%HLQSUM"
"%DSNCONV"
"%DASDVOLS"
EXIT
./   ADD   NAME=DCOLDREC
/* REXX                                                    */
/*                                                         */
/*                                                         */
/*  DCOLDREC                                               */
/*     PURPOSE: PRINTS OUT DETAIL INFORMATION FOR EVERY    */
/*              "D" AND "M" RECORD INPUT                   */
/*     INPUT:   LNICHO.DCOLLECT.D                          */
/*              TYPE D AND M RECORDS                       */
/*     OUTPUT:  SMS.UMB.DCOLLECT.DMREC.DETAIL              */
/*     PRESORT: NONE REQUIRED                              */
/*                                                         */
/***********************************************************/
/*                                                         */

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */
/***********************************************************/
 "ALLOC F(INFILE) DA('LNICHO.DCOLLECT.D') SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* OPEN THE OUTPUT FILE (CONTAINING YOUR REPORT)           */
/***********************************************************/
"ALLOC DSNAME('SMS.UMB.DCOLLECT.DMREC.DETAIL')",
  "DSORG(PS) LRECL(100) RECFM(F B) ",
  "TRACKS SPACE(1,5) RELEASE DDNAME(OUTFILE)"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 EOF = 'NO'
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE"
   IF RC¬= 0 THEN
      EOF = 'YES'
   ELSE DO
      PARSE PULL RECORD
/***********************************************************/
/* DETERMINE THE RECORD TYPE (M,B,C,T,D,A,V)               */
/***********************************************************/
      DCURCTYP=SUBSTR(RECORD,5,2)
         SELECT
/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD            */
/***********************************************************/
         WHEN(DCURCTYP='D ') THEN DO
                             CALL DCRECORD
                             CALL DISPLAYDC
                             END
/***********************************************************/
/* PROCESS MIGRATED DATA SET INFORMATION RECORD            */
/***********************************************************/
         WHEN(DCURCTYP='M ') THEN DO
                             CALL UMRECORD
                             CALL DISPLAYUM
                             END
/***********************************************************/
/* DO NOT PROCESS OTHER RECORD TYPES                       */
/***********************************************************/
         OTHERWISE
         END
      END
 END
 EXIT
/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */
/***********************************************************/
 DCRECORD:
/*                                                          */
       DCDDSNAM = SUBSTR(RECORD,25,44)
       DCDERROR = BITSTR(SUBSTR(RECORD,69,1))
       DCDFLAG1 = BITSTR(SUBSTR(RECORD,70,1))
       DCDFLAG2 = BITSTR(SUBSTR(RECORD,71,1))
       DCDDSORG = C2X(SUBSTR(RECORD,75,2))
       DCDRECRD = C2X(SUBSTR(RECORD,77,1))
       DCDNMEXT = C2X(SUBSTR(RECORD,78,1))
       DCDVOLSR = SUBSTR(RECORD,79,6)
       DCDBKLNG = C2D(SUBSTR(RECORD,85,2))
       DCDLRECL = C2D(SUBSTR(RECORD,87,2))
       DCDALLSP = C2D(SUBSTR(RECORD,89,4))
       DCDUSESP = C2D(SUBSTR(RECORD,93,4))
       DCDSCALL = C2D(SUBSTR(RECORD,97,4))
       DCDNMBLK = C2D(SUBSTR(RECORD,101,4))
       DCDCREDT = STRIP(C2X(SUBSTR(RECORD,105,4)),T,'F')
       DCDEXPDT = STRIP(C2X(SUBSTR(RECORD,109,4)),T,'F')
       DCDLSTRF = STRIP(C2X(SUBSTR(RECORD,113,4)),T,'F')
       DCDDSSER = SUBSTR(RECORD,117,6)
       DCDVOLSQ = C2X(SUBSTR(RECORD,123,2))
       DCDLBKDT = C2X(SUBSTR(RECORD,125,8))
       DCDDATCL = SUBSTR(RECORD,135,8)
       DCDSTGCL = SUBSTR(RECORD,167,8)
       DCDMGTCL = SUBSTR(RECORD,199,8)
       DCDSTGRP = SUBSTR(RECORD,231,8)
 RETURN

 /***********************************************************/
 /* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */
 /*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */
 /***********************************************************/
  UMRECORD:
        UMDSNAM = SUBSTR(RECORD,25,44)
        UMFLAG1 = BITSTR(SUBSTR(RECORD,69,1))
        UMLEVEL = SUBSTR(UMFLAG1,1,2)
        UMCHIND = SUBSTR(UMFLAG1,3,1)
        UMDEVCL = SUBSTR(RECORD,70,1)
        UMDSORG = C2X(SUBSTR(RECORD,71,2))
        UMDSIZE = C2D(SUBSTR(RECORD,73,4))
        UMTIME  = C2X(SUBSTR(RECORD,77,4))
        UMDATE  = STRIP(C2X(SUBSTR(RECORD,81,4)),T,'F')
        UMDATCL = SUBSTR(RECORD,87,30)
        UMSTGCL = SUBSTR(RECORD,119,30)
        UMMGTCL = SUBSTR(RECORD,151,30)
        UMRECRD = C2X(SUBSTR(RECORD,181,1))
        UMRECOR = C2X(SUBSTR(RECORD,182,1))
        UMBKLNG = C2D(SUBSTR(RECORD,183,2))
        UMFLAG2 = BITSTR(SUBSTR(RECORD,185,1))
        UMRACFD = SUBSTR(UMFLAG2,1,1)
        UMGDS   = SUBSTR(UMFLAG2,2,1)
        UMREBLK = SUBSTR(UMFLAG2,3,1)
        UMPDSE  = SUBSTR(UMFLAG2,4,1)
        UMSMSM  = SUBSTR(UMFLAG2,5,1)
        UMNMIG  = C2D(SUBSTR(RECORD,187,2))
        UMALLSP = C2D(SUBSTR(RECORD,189,4))
        UMUSESP = C2D(SUBSTR(RECORD,193,4))
        UMRECSP = C2D(SUBSTR(RECORD,197,4))
        UMCREDT = STRIP(C2X(SUBSTR(RECORD,201,4)),T,'F')
        UMEXPDT = STRIP(C2X(SUBSTR(RECORD,205,4)),T,'F')
        UMLBKDT = C2X(SUBSTR(RECORD,209,8))
        UMLRFDT = STRIP(C2X(SUBSTR(RECORD,217,4)),T,'F')
  RETURN

/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */
/***********************************************************/
 DISPLAYDC:
 PUSH "DCDDSNAM="   DCDDSNAM
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDERROR="   DCDERROR
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDFLAG1="   DCDFLAG1
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDFLAG2="   DCDFLAG2
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDDSORG="   DCDDSORG
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDRECRD="   DCDRECRD
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDNMEXT="   DCDNMEXT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDVOLSR="   DCDVOLSR
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDBKLNG="   DCDBKLNG
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDLRECL="   DCDLRECL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDALLSP="   DCDALLSP
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDUSESP="   DCDUSESP
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDSCALL="   DCDSCALL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDNMBLK="   DCDNMBLK
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDCREDT="   DCDCREDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDEXPDT="   DCDEXPDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDLSTRF="   DCDLSTRF
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDDSSER="   DCDDSSER
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDVOLSQ="   DCDVOLSQ
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDLBKDT="   DCDLBKDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDDATCL="   DCDDATCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDSTGCL="   DCDSTGCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDMGTCL="   DCDMGTCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDSTGRP="   DCDSTGRP
 "EXECIO 1  DISKW OUTFILE"
 PUSH "*******************************************************"
 "EXECIO 1  DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */
/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */
/***********************************************************/
 DISPLAYUM:
 PUSH  "UMDSNAM ="  UMDSNAM
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMFLAG1 ="  UMFLAG1
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMLEVEL ="  UMLEVEL
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMCHIND ="  UMCHIND
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMDEVCL ="  UMDEVCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMDSORG ="  UMDSORG
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMDSIZE ="  UMDSIZE
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMTIME  ="  UMTIME
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMDATE  ="  UMDATE
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMDATCL ="  UMDATCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMSTGCL ="  UMSTGCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMMGTCL ="  UMMGTCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMRECRD ="  UMRECRD
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMRECOR ="  UMRECOR
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMBKLNG ="  UMBKLNG
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMFLAG2 ="  UMFLAG2
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMRACFD ="  UMRACFD
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMGDS   ="  UMGDS
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMREBLK ="  UMREBLK
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMPDSE  ="  UMPDSE
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMSMSM  ="  UMSMSM
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMNMIG  ="  UMNMIG
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMALLSP ="  UMALLSP
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMUSESP ="  UMUSESP
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMRECSP ="  UMRECSP
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMCREDT ="  UMCREDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMEXPDT ="  UMEXPDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMLBKDT ="  UMLBKDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH  "UMLRFDT ="  UMLRFDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "*******************************************************"
 "EXECIO 1  DISKW OUTFILE"
 RETURN

/***********************************************************/
/* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */
/* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */
/***********************************************************/
 BITSTR:
       IF BIT.F ¬= "1111"  THEN DO
          BIT.0="0000"
          BIT.1="0001"
          BIT.2="0010"
          BIT.3="0011"
          BIT.4="0100"
          BIT.5="0101"
          BIT.6="0110"
          BIT.7="0111"
          BIT.8="1000"
          BIT.9="1001"
          BIT.A="1010"
          BIT.B="1011"
          BIT.C="1100"
          BIT.D="1101"
          BIT.E="1110"
          BIT.F="1111"
       END
       CH=C2X(ARG(1))
       BS=''
       DO I=1 TO LENGTH(CH)
          Q=SUBSTR(CH,I,1)
          BS=BS||BIT.Q
       END
RETURN BS

./   ADD   NAME=DSORG
/* REXX                                                               */
/*                                                                    */
/*                                                                    */
/*                                                                    */
/* DSORG                                                              */
/*    PURPOSE: BREAKOUT OF DATA SETS BY DSORG. DONE BY DSN COUNT AND  */
/*             BY KBYTES WITH PERCENTAGES                             */
/*    INPUT:   SMS.UMB.DCOLLECT.RECTYPDM                              */
/*             TYPE D AND M RECORDS                                   */
/*    OUTPUT:  SMS.PMB.DCOLLECT.DSORG.DCCYYDDD                        */
/*    PRESORT: SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/*    DCDDSORG XL2 MAPS AS FOLLOWS:                                   */
/*                                                                    */
/*             8000  IS - INDEXED SEQUENTIAL                          */
/*             4000  PS - PHYSICAL SEQUENTIAL                         */
/*             2000  DA - DIRECT                                      */
/*             0200  PO - PARTITIONED                                 */
/*             0100  U  - UNMOVEABLE                                  */
/*             0080  GS - GRAPHICS                                    */
/*             0008  VS - VSAM                                        */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D AND M RECORDS*/
/***********************************************************/
 TRACE N
 "ALLOC DD(INFILE) DA('SMS.UMB.DCOLLECT.RECTYPDM') SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 OUT_COUNT = 0
 DSORG_TYPES    = ' '
 DSORG_CNT.  = 0
 DSORG_KB.  = 0
 TOT_CNT  = 0
 TOT_KB  = 0

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE D AND M RECORDS            */
/***********************************************************/

 "EXECIO 10000 DISKR INFILE (STEM RECORD."
 K=1
 CALL DCURECP
 DATE = LEFT(C2X(DCUDATE),7)
 OUT_COUNT = OUT_COUNT + 1
 OUT_LINE.OUT_COUNT = "DCOLLECT RUN ON:" DATE
 OUT_COUNT = OUT_COUNT + 1
 OUT_LINE.OUT_COUNT = " "
 CALL OUTHEAD

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/

/***********************************************************/
/* NOTE: THE DSORG BIT STRING IS CONVERTED TO CHARACTERS   */
/* TO BE STORED IN A VARIABLE AND THEN CONVERTED BACK TO   */
/* A BIT-STRING FOR FINAL PROCESSING. SEEMS WHEN A         */
/* X'4000' GETS STORED AND TREATED AS A WORD, THE X'40'    */
/* GETS CONVERTED TO A BLANK.                              */
/***********************************************************/

 DO WHILE RECORD.0 > 0
    DO K = 1 TO RECORD.0
       CALL DCURECP
       IF DCURCTYP = "D " THEN DO
          CALL DCDRECP
          DSN = DCDDSNAM
          DSORG = C2X(DCDDSORG)
          IF WORDPOS(DSORG,DSORG_TYPES,1) = 0 THEN DO
             DSORG_TYPES = DSORG_TYPES DSORG
             L = WORDPOS(DCDDSORG,DSORG_TYPES,1)
             END
          ELSE NOP
          L = WORDPOS(DSORG,DSORG_TYPES,1)
          DSORG_CNT.L = DSORG_CNT.L + 1
          DSORG_KB.L = DSORG_KB.L + C2D(DCDALLSP)
          TOT_CNT = TOT_CNT + 1
          TOT_KB = TOT_KB + C2D(DCDALLSP)
          END

       IF DCURCTYP = "M " THEN DO
          CALL DCMRECP
          DSN = UMDSNAM
          DSORG = C2X(UMDSORG)
          IF WORDPOS(DSORG,DSORG_TYPES,1) = 0 THEN DO
             DSORG_TYPES = DSORG_TYPES DSORG
             L = WORDPOS(DCDDSORG,DSORG_TYPES,1)
             END
          ELSE NOP
          L = WORDPOS(DSORG,DSORG_TYPES,1)
          DSORG_CNT.L = DSORG_CNT.L + 1
          DSORG_KB.L = DSORG_KB.L + C2D(UMALLSP)
          TOT_CNT = TOT_CNT + 1
          TOT_KB = TOT_KB + C2D(UMALLSP)
          END

    END
    "EXECIO 10000 DISKR INFILE (STEM RECORD."
 END
 "EXECIO 0 DISKR INFILE (FINIS"

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
 OUTNAME = "'SMS.PMB.DCOLLECT.DSORG.D"||DATE||"'"
 "ALLOC DSNAME("||OUTNAME||")",
     "DSORG(PS) LRECL(80) RECFM(F B) ",
     "TRACKS SPACE(4,5) RELEASE DDNAME(OUTDD)"
  IF RC¬= 0 THEN DO
     SAY  'ALLOC OF ('||OUTNAME||') FAILED'
     EXIT 12
     END


/***********************************************************/
/* PUT OUT TOTALS BY DSORG                                 */
/***********************************************************/

L = WORDS(DSORG_TYPES)
DO K = 1 TO L
   DSORG = 'ERROR'         /* PRESET TO ERROR IF NO MATCHES ARE FOUND */
   DSORG_TYPES_BITS = X2C(WORD(DSORG_TYPES,K))
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'01'X) = '01'X THEN
      UNMOVE = 'U'
      ELSE UNMOVE = ''
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'40'X) = '40'X THEN
      DSORG = 'PS'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'20'X) = '20'X THEN
      DSORG = 'DA'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'02'X) = '02'X THEN
      DSORG = 'PO'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,1,1),'80'X) = '80'X THEN
      DSORG = 'IS'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,2,1),'08'X) = '08'X THEN
      DSORG = 'VS'||UNMOVE
   IF BITAND(SUBSTR(DSORG_TYPES_BITS,2,1),'80'X) = '80'X THEN
      DSORG = 'GS'||UNMOVE
   IF DSORG_TYPES_BITS = '0000'X THEN
      DSORG = 'UNKNOWN'
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       RIGHT(DSORG,8),
       RIGHT(DSORG_CNT.K,6),
       RIGHT(DSORG_KB.K,10),
       (WORD(DSORG_TYPES,K))
END

OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = ,
    RIGHT("TOTAL",8),
    RIGHT(TOT_CNT,6),
    RIGHT(TOT_KB,10)
"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE ALL"
EXIT

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                                    */
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       CENTER("DSORG",8),
       CENTER("     ",6),
       CENTER("     ",10),
       CENTER("DSORG",5)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       CENTER("TYPE",8),
       CENTER("COUNT",6),
       CENTER("KBYTES",10),
       CENTER("BITS",5)
   OUT_COUNT = OUT_COUNT + 1
   OUT_LINE.OUT_COUNT = ,
       CENTER("-",8,"-"),
       CENTER("-",6,"-"),
       CENTER("-",10,"-"),
       CENTER("-",5,"-")
   RETURN

/***********************************************************/
/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */
/***********************************************************/
 DCURECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
      13 DCUTIME 17 DCUDATE 21 .
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 25 DCDDSNAM 69 DCDERROR,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
 RETURN
./   ADD   NAME=ERRORS
/* REXX                                                               */
/*                                                                    */
/* ERRORS                                                             */
/*    PURPOSE: LISTS EVERY D RECORD THAT HAS ERROR BITS SET           */
/*                                                                    */
/*    INPUT:   SMS.UMB.DCOLLECT.RECTYPDM                              */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  SMS.UMB.DCOLLECT.ERRORS                                */
/*                                                                    */
/*    PRESORT: SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/*    DCDERROR XL1 MAPS AS FOLLOWS:                                   */
/*                                                                    */
/*             80  SMS MANAGED INCONSISTENCY                          */
/*             40  DUPLICATE VVR FOUND                                */
/*             20  NO SPACE INFORMATION PROVIDED                      */
/*             10  VSAM INDICATORS INCONSISTENT                       */
/*             08  NO FMT 1 DSCB FOR THIS DATA SET                    */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D AND M RECORDS*/
/***********************************************************/
 TRACE N
 INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'"
 "ALLOC DD(INFILE) DA("INNAME") SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END


/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
 OUT_COUNT = 0

/***********************************************************/
/* READ IN INPUT FILE WITH TYPE D AND M RECORDS            */
/***********************************************************/

 "EXECIO 10000 DISKR INFILE (STEM RECORD."

/***********************************************************/
/* OPEN THE OUTPUT FILE (CONTAINING YOUR REPORT)           */
/***********************************************************/
"ALLOC DSNAME('SMS.UMB.DCOLLECT.ERRORS')",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(200,200) RELEASE DDNAME(OUTFILE)"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

/***********************************************************/
/* PROCESS FIRST RECORD FOR DATE COLLECTED INFORMATION     */
/***********************************************************/

 K = 1
 CALL DCURECP
 DATE = LEFT(C2X(DCUDATE),7)
 PUSH "DCOLLECT RUN ON:" DATE
 "EXECIO 1  DISKW OUTFILE"
 PUSH " "
 "EXECIO 1  DISKW OUTFILE"

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/

 DO WHILE RECORD.0 > 0
    DO K = 1 TO RECORD.0
       CALL DCURECP
       IF DCURCTYP = "D" THEN DO
          CALL DCDRECP
          IF DCDERROR = '00'X THEN ITERATE
          IF BITAND(DCDERROR,'80'X) = '80'X THEN DO
             ERROR = "SMS MANAGED INCONSISTENCY"
             PUSH "ERROR=" ERROR
             "EXECIO 1  DISKW OUTFILE"
             END
          IF BITAND(DCDERROR,'40'X) = '40'X THEN DO
             ERROR = "DUPLICATE VVR FOUND"
             PUSH "ERROR=" ERROR
             "EXECIO 1  DISKW OUTFILE"
             END
          IF BITAND(DCDERROR,'20'X) = '20'X THEN DO
             ERROR = "NO SPACE INFORMATION PROVIDED"
             PUSH "ERROR=" ERROR
             "EXECIO 1  DISKW OUTFILE"
             END
          IF BITAND(DCDERROR,'10'X) = '10'X THEN DO
             ERROR = "VSAM INDICATORS INCONSISTEN"
             PUSH "ERROR=" ERROR
             "EXECIO 1  DISKW OUTFILE"
             END
          IF BITAND(DCDERROR,'08'X) = '08'X THEN DO
             ERROR = "NO FMT 1 DSCB FOR THIS DATA SET"
             PUSH "ERROR=" ERROR
             "EXECIO 1  DISKW OUTFILE"
             END
          CALL DCRECORD
          CALL DISPLAYDC
          END

       IF DCURCTYP = "M" THEN ITERATE

    END
    "EXECIO 10000 DISKR INFILE (STEM RECORD."
 END


/***********************************************************/
/* PUT OUT TOTALS BY DSORG                                 */
/***********************************************************/

"EXECIO 0 DISKR INFILE (FINIS"
"EXECIO * DISKW OUTFILE (FINIS"
"FREE ALL"
EXIT


/***********************************************************/
/* PARSE DCOLLECT HEADER INFORMATION - ALL RECORD TYPES    */
/***********************************************************/
 DCURECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
      13 DCUTIME 17 DCUDATE 21 .
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD.K 1 . 25 DCDDSNAM 69 DCDERROR,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      142 . 167 DCDSTGCL 174 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 238 .
 RETURN

/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */
/***********************************************************/
 DCRECORD:
/*                                                          */
       DCDDSNAM = SUBSTR(RECORD.K,25,44)
       DCDERROR = BITSTR(SUBSTR(RECORD.K,69,1))
       DCDFLAG1 = BITSTR(SUBSTR(RECORD.K,70,1))
       DCDFLAG2 = BITSTR(SUBSTR(RECORD.K,71,1))
       DCDDSORG = C2X(SUBSTR(RECORD.K,75,2))
       DCDRECRD = C2X(SUBSTR(RECORD.K,77,1))
       DCDNMEXT = C2X(SUBSTR(RECORD.K,78,1))
       DCDVOLSR = SUBSTR(RECORD.K,79,6)
       DCDBKLNG = C2D(SUBSTR(RECORD.K,85,2))
       DCDLRECL = C2D(SUBSTR(RECORD.K,87,2))
       DCDALLSP = C2D(SUBSTR(RECORD.K,89,4))
       DCDUSESP = C2D(SUBSTR(RECORD.K,93,4))
       DCDSCALL = C2D(SUBSTR(RECORD.K,97,4))
       DCDNMBLK = C2D(SUBSTR(RECORD.K,101,4))
       DCDCREDT = STRIP(C2X(SUBSTR(RECORD.K,105,4)),T,'F')
       DCDEXPDT = STRIP(C2X(SUBSTR(RECORD.K,109,4)),T,'F')
       DCDLSTRF = STRIP(C2X(SUBSTR(RECORD.K,113,4)),T,'F')
       DCDDSSER = SUBSTR(RECORD.K,117,6)
       DCDVOLSQ = C2X(SUBSTR(RECORD.K,123,2))
       DCDLBKDT = C2X(SUBSTR(RECORD.K,125,8))
       DCDDATCL = SUBSTR(RECORD.K,135,8)
       DCDSTGCL = SUBSTR(RECORD.K,167,8)
       DCDMGTCL = SUBSTR(RECORD.K,199,8)
       DCDSTGRP = SUBSTR(RECORD.K,231,8)
 RETURN


/***********************************************************/
/* PROCESS ACTIVE   DATA SET INFORMATION RECORD -          */
/*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */
/***********************************************************/
 DISPLAYDC:
 PUSH "DCDDSNAM="   DCDDSNAM
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDERROR="   DCDERROR
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDFLAG1="   DCDFLAG1
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDFLAG2="   DCDFLAG2
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDDSORG="   DCDDSORG
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDRECRD="   DCDRECRD
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDNMEXT="   DCDNMEXT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDVOLSR="   DCDVOLSR
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDBKLNG="   DCDBKLNG
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDLRECL="   DCDLRECL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDALLSP="   DCDALLSP
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDUSESP="   DCDUSESP
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDSCALL="   DCDSCALL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDNMBLK="   DCDNMBLK
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDCREDT="   DCDCREDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDEXPDT="   DCDEXPDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDLSTRF="   DCDLSTRF
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDDSSER="   DCDDSSER
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDVOLSQ="   DCDVOLSQ
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDLBKDT="   DCDLBKDT
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDDATCL="   DCDDATCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDSTGCL="   DCDSTGCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDMGTCL="   DCDMGTCL
 "EXECIO 1  DISKW OUTFILE"
 PUSH "DCDSTGRP="   DCDSTGRP
 "EXECIO 1  DISKW OUTFILE"
 PUSH "*******************************************************"
 "EXECIO 1  DISKW OUTFILE"
 RETURN


/***********************************************************/
/* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */
/* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */
/***********************************************************/
 BITSTR:
       IF BIT.F ¬= "1111"  THEN DO
          BIT.0="0000"
          BIT.1="0001"
          BIT.2="0010"
          BIT.3="0011"
          BIT.4="0100"
          BIT.5="0101"
          BIT.6="0110"
          BIT.7="0111"
          BIT.8="1000"
          BIT.9="1001"
          BIT.A="1010"
          BIT.B="1011"
          BIT.C="1100"
          BIT.D="1101"
          BIT.E="1110"
          BIT.F="1111"
       END
       CH=C2X(ARG(1))
       BS=''
       DO I=1 TO LENGTH(CH)
          Q=SUBSTR(CH,I,1)
          BS=BS||BIT.Q
       END
RETURN BS
./   ADD   NAME=EXPDT
/* REXX                                                               */
/*                                                                    */
/* EXPDT                                                              */
/*    PURPOSE: READS TYPE D AND M RECORDS FOR ALL DSNS THAT           */
/*             HAVE AN EXPDT > 0. (VSAM IS EXCLUDED SINCE IT          */
/*             ALWAYS HAS AN EXPDT = 1999365)                         */
/*                                                                    */
/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  SMS.UMB.DCOLLECT.EXPDT                                 */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/**********************************************************************/


TRACE N

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M RECORDS)   */
/***********************************************************/
"ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPDM') DDNAME(FILEA) SHR"

/***********************************************************/
/* INITIALIZE VARIABLES                                    */
/***********************************************************/
OUT_COUNT = 0
HLQ_STDDSN = 0
TOT_HLQ = 0
ALLOC = 0

/***********************************************************/
/* SPECIAL PROCESSING FOR FIRST RECORD                     */
/***********************************************************/
"EXECIO 10000 DISKR FILEA (STEM IN_REC."
J=1
PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
   13 DCUTIME 17 DCUDATE 21 .
COLDATE  = LEFT(C2X(DCUDATE),7)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = "DATA COLLECTED ON:" COLDATE
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = " "
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("DSN",44),
    LEFT("EXPDT",7)
OUT_COUNT = OUT_COUNT + 1
OUT_LINE.OUT_COUNT = LEFT("-",44,"-"),
    RIGHT("-",7,"-")

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
DO WHILE IN_REC.0 > 0
   DO J = 1 TO IN_REC.0
      PARSE VAR IN_REC.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
         13 DCUTIME 17 DCUDATE 21 .
      SELECT
         WHEN DCURCTYP = 'D ' THEN CALL DCDRECP
         WHEN DCURCTYP = 'M ' THEN CALL DCMRECP
         OTHERWISE ITERATE
         END
      IF EXPDT ¬= 0 THEN DO
          IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN ITERATE
             /* IGNORE VSAM DATA           */
             /* SINCE EXPDT = 99365        */
          OUT_COUNT = OUT_COUNT + 1
          OUT_LINE.OUT_COUNT = LEFT(DSNAME,44),
          RIGHT(EXPDT,7),
          MIGRATE
          END
      END
      "EXECIO 10000 DISKR FILEA (STEM IN_REC."
   END

/***********************************************************/
/*  FREE INPUT FILE AND CREATE OUTPUT FILE                 */
/***********************************************************/
"EXECIO 0 DISKR FILEA (FINIS"
"FREE DDNAME(FILEA)"
"ALLOC DSNAME('SMS.UMB.DCOLLECT.EXPDT')",
    "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
    "SPACE(100,50) RELEASE DDNAME(OUTDD)"
"EXECIO * DISKW OUTDD (FINIS STEM OUT_LINE."
"FREE DDNAME(OUTDD)"
EXIT

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
   EXPDT = LEFT(C2X(DCDEXPDT),7)
   DSNAME = DCDDSNAM
   DSORG = DCDDSORG
   MIGRATE = " "
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR IN_REC.J 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
   EXPDT = LEFT(C2X(UMEXPDT),7)
   DSNAME = UMDSNAM
   DSORG = UMDSORG
   MIGRATE = "MIGRATED"
 RETURN
./   ADD   NAME=HLQSUM
/* REXX                                                               */
/*                                                                    */
/* HLQSUM                                                             */
/*    PURPOSE: READS DCOLLECT "D" "M" AND "B" RECORDS AND PRODUCES    */
/*             A REPORT SUMMARIZED BY HLQ OF BYTES ALLOCATED AT EACH  */
/*             LEVEL (L0, ML1, AND ML2) AS WELL AS BACKUP BYTES       */
/*                                                                    */
/*             PRODUCES A SUMMARY REPORT OF THE FOLLOWING:            */
/*                                                                    */
/*                TOTAL FROM VOLUME (V) RECORDS:                      */
/*                   TOTAL AVAILABLE KBYTES                           */
/*                   TOTAL ALLOCATED KBYTES                           */
/*                   SMS AVAILABLE KBYTES                             */
/*                   SMS ALLOCATED KBYTES                             */
/*                                                                    */
/*                TOTAL FROM D, M AND B RECORDS:                      */
/*                   L0+ML1+ML2 DSN COUNT                             */
/*                   TOTAL L0 + ML1 +ML2 ALLOCATED                    */
/*                   TOTAL BACKUP KBYTES                              */
/*                   L0 DSN COUNT                                     */
/*                   L0 ALLOCATED KBYTES                              */
/*                   L0 USED KBYTES                                   */
/*                   SMS DSN COUNT                                    */
/*                   SMS ALLOCATED KBYTES                             */
/*                   ML1 DSN COUNT                                    */
/*                   ML1 ALLOCATED KBYTES                             */
/*                   ML1 ORIGINAL KBYTES                              */
/*                   ML2 DSN COUNT                                    */
/*                   ML2 ALLOCATED KBYTES                             */
/*                   ML2 ORIGINAL KBYTES                              */
/*                                                                    */
/*    INPUT:   SMS.UMB.COLLECT.DMB                                    */
/*             TYPE D, M AND B RECORDS                                */
/*                                                                    */
/*             SMS.UMB.DCOLLECT.RECTYPV                               */
/*             TYPE V RECORDS                                         */
/*                                                                    */
/*    OUTPUT:  SMS.PMB.DCOLLECT.SUMMARY.DCCYYDDD                      */
/*             SMS.PMB.DCOLLECT.HLQ.DETAIL.DCCYYDDD                   */
/*                                                                    */
/*    PRESORT: FOR TYPE D, M AND B RECORDS                            */
/*             SORT FIELDS=(29,44,CH,A),                              */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,                    */
/*                           (9,2,CH,EQ,C'M '),OR,                    */
/*                           (9,2,CH,EQ,C'B '))                       */
/*                                                                    */
/*             FOR TYPE V RECORDS                                     */
/*             SORT FIELDS=(87,8,CH,A,29,6,CH,A)                      */
/*             INCLUDE COND=(9,2,CH,EQ,C'V ')                         */
/*                                                                    */
/*                                                                    */
/**********************************************************************/


/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT D,M,B RECORDS) */
/***********************************************************/
TRACE N
 INNAME = "'SMS.UMB.DCOLLECT.DMB'"
 "ALLOC F(INFILE) DA("INNAME") SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

/***********************************************************/
/* SPECIAL PROCESSING FOR FIRST RECORD                     */
/***********************************************************/
 "EXECIO 10000 DISKR INFILE (STEM RECORD."
 CALL INITHLQ
 CALL INITTOT
 J = 1
 PARSE VAR RECORD.J 1 . 5 DCURCTYP 7 DCUVERS 9 DCUSYSID,
    13 DCUTIME 17 DCUDATE 21 . 25 DCDDSNAM 69 .
 DATE  = LEFT(C2X(DCUDATE),7)

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY HLQ REPORT   */
/***********************************************************/
 "ALLOC DSNAME('SMS.PMB.DCOLLECT.HLQ.DETAIL.D"||DATE||"')",
  "DSORG(PS) LRECL(172) RECFM(F B) AVGREC(U)",
  "SPACE(2000,1000) RELEASE DDNAME(OUTFILE)"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

 PARSE VAR DCDDSNAM RECHLQ "." .
 IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
 HLQ=RECHLQ
 OUT_LINE = "DATA COLLECTED ON:" DATE
 PUSH OUT_LINE
 "EXECIO 1 DISKW OUTFILE"
 OUT_LINE = " "
 PUSH OUT_LINE
 "EXECIO 1 DISKW OUTFILE"
 CALL OUTHEAD

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 DO WHILE RECORD.0 > 0
    DO J = 1 TO RECORD.0
      PARSE VAR RECORD.J 1 . 5 DCURCTYP 7 . 25 DCDDSNAM 69 .
      PARSE VAR DCDDSNAM RECHLQ "." .
      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
      IF RECHLQ ¬= HLQ THEN DO
         CALL OUTHLQ
         HLQ = RECHLQ
         END
      SELECT
         WHEN(DCURCTYP='D ') THEN DO               /* ACTIVE DATA  */
            CALL DCDRECP
            CALL DNEWINFO
            END
         WHEN(DCURCTYP='M ') THEN DO               /* MIGRATED DATA*/
            CALL DCMRECP
            CALL MNEWINFO
            END
         WHEN(DCURCTYP='B ') THEN DO               /* BACKUP DATA  */
            CALL DCBRECP
            CALL BNEWINFO
            END
         OTHERWISE            /* DO NOT PROCESS OTHER RECORD TYPES */
         END
      END
      "EXECIO 10000 DISKR INFILE (STEM RECORD."
 END
 CALL OUTHLQ
 "EXECIO 0 DISKR INFILE (FINIS"
 "EXECIO 0 DISKW OUTFILE (FINIS"
 "FREE DDNAME(INFILE)"
 "FREE DDNAME(OUTFILE)"

/***********************************************************/
/*   ALLOCATE NEW SUMMARY DATA SET                         */
/***********************************************************/

"ALLOC DSNAME('SMS.PMB.DCOLLECT.SUMMARY.D"||DATE||"')",
   "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
   "SPACE(10,5) RELEASE DDNAME(OUTSUM)"

/***********************************************************/
/*   PROCESS TYPE 'V' VOLUME INFORMATION RECORDS           */
/***********************************************************/

"ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPV') DDNAME(FILEV) SHR"
"EXECIO * DISKR FILEV (FINIS STEM IN_RECV."
"FREE DDNAME(FILEV)"
TOT_AVAIL_ALLOC_KBYTES = 0
SMS_AVAIL_ALLOC_KBYTES = 0
TOT_AVAIL_KBYTES       = 0
SMS_AVAIL_KBYTES       = 0
L = 0
DO K = 1 TO IN_RECV.0
   PARSE VAR IN_RECV.K 1 . 25 DCVVOLSR 31 DCVFLAG1,
      32 DCVERROR 33 . 36 DCVPERCT 37 DCVFRESP 41 DCVALLOC,
      45 DCVVLCAP 49 DCVFRAGI 53 DCVLGEXT 57 DCVFREXT 61 DCVFDSCB,
      65 DCFVIRS 69 DCVDVTYP 77 DCVDVNUM 79 . 83 DCVSGTCL 91 .
   TOT_AVAIL_ALLOC_KBYTES = TOT_AVAIL_ALLOC_KBYTES + C2D(DCVALLOC)
   TOT_AVAIL_KBYTES = TOT_AVAIL_KBYTES + C2D(DCVVLCAP)
   IF BITAND(DCVFLAG1,'03'X) = '03'X THEN DO           /* IS IT SMS?  */
      SMS_AVAIL_ALLOC_KBYTES = SMS_AVAIL_ALLOC_KBYTES + C2D(DCVALLOC)
      SMS_AVAIL_KBYTES = SMS_AVAIL_KBYTES + C2D(DCVVLCAP)
   END
END
L = L + 1
OUT_LINE2.L = "DATA COLLECTED ON:" DATE
L = L + 1
OUT_LINE2.L= " "
L = L + 1
OUT_LINE2.L = "TOTAL FROM VOLUME (V) RECORDS:"
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL AVAILABLE KBYTES",30),
    RIGHT(TOT_AVAIL_KBYTES,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL ALLOCATED KBYTES",30),
    RIGHT(TOT_AVAIL_ALLOC_KBYTES,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS AVAILABLE KBYTES",30),
    RIGHT(SMS_AVAIL_KBYTES,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS ALLOCATED KBYTES",30),
    RIGHT(SMS_AVAIL_ALLOC_KBYTES,11)
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = "TOTAL FROM D, M AND B RECORDS:"
L = L + 1
OUT_LINE2.L = " "
L = L + 1
OUT_LINE2.L = "  " LEFT("L0+ML1+ML2 DSN COUNT",30),
    RIGHT(TOT_ALL_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL L0 + ML1 +ML2 ALLOCATED KBYTES",30),
    RIGHT(TOT_KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("TOTAL BACKUP KBYTES",30),
    RIGHT(TOT_BKKB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("L0 DSN COUNT",30),
    RIGHT(TOT_L0_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("L0 ALLOCATED KBYTES",30),
    RIGHT(TOT_L0KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("L0 USED KBYTES",30),
    RIGHT(TOT_L0USEKB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS DSN COUNT",30),
    RIGHT(TOT_SMS_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("SMS ALLOCATED KBYTES",30),
    RIGHT(TOT_SMS_L0KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML1 DSN COUNT",30),
    RIGHT(TOT_ML1_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML1 ALLOCATED KBYTES",30),
    RIGHT(TOT_ML1KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML1 ORIGINAL KBYTES",30),
    RIGHT(TOT_ML1_ORGKB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML2 DSN COUNT",30),
    RIGHT(TOT_ML2_DSN_CTR,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML2 ALLOCATED KBYTES",30),
    RIGHT(TOT_ML2KB,11)
L = L + 1
OUT_LINE2.L = "  " LEFT("ML2 ORIGINAL KBYTES",30),
    RIGHT(TOT_ML2_ORGKB,11)
/*                                                                    */
/**********************************************************************/
/*   WRITE OUT HLQ SUMMARY AND VOLUME SUMMARY RECORDS TO DASD         */
/**********************************************************************/
/*                                                                    */
"EXECIO * DISKW OUTSUM (FINIS STEM OUT_LINE2."
"FREE DDNAME(OUTSUM)"

 EXIT


/***********************************************************/
/*         R O U T I N E S                                 */
/***********************************************************/

/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                          */
   OUT_LINE = LEFT("    ",8),
      RIGHT("L0+ML1+ML2",10),
      RIGHT("L0 ",10),
      RIGHT("L0",11),
      RIGHT("L0",11),
      RIGHT("SMS",10),
      RIGHT("SMS L0",11),
      RIGHT("ML1",10),
      RIGHT("ML1",11),
      RIGHT("   ",11),
      RIGHT("ML2",10),
      RIGHT("ML2",11),
      RIGHT("   ",11),
      RIGHT("   ",11),
      RIGHT("   ",11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = LEFT("    ",8),
      RIGHT("DSN",10),
      RIGHT("DSN",10),
      RIGHT("ALLOCATED",11),
      RIGHT("USED",11),
      RIGHT("DSN",10),
      RIGHT("ALLOCATED",11),
      RIGHT("DSN",10),
      RIGHT("ORGINAL",11),
      RIGHT("ML1",11),
      RIGHT("DSN",10),
      RIGHT("ORGINAL",11),
      RIGHT("ML2",11),
      RIGHT("L0+ML1+ML2",11),
      RIGHT("BACKUP",11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = LEFT("HLQ",8),
      RIGHT("COUNT",10),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("COUNT",10),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11),
      RIGHT("KBYTES",11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   OUT_LINE = LEFT("-",8,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",10,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-"),
      RIGHT("-",11,"-")
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT SUMMARIZED HLQ INFO OUT TO NEW FILE                 */
/***********************************************************/
OUTHLQ:
/*                                                          */
   OUT_LINE = LEFT(HLQ,8),
      RIGHT(HLQ_ALL_DSN_CTR,10),
      RIGHT(HLQ_L0_DSN_CTR,10),
      RIGHT(HLQ_L0KB,11),
      RIGHT(HLQ_L0USEKB,11),
      RIGHT(HLQ_SMS_DSN_CTR,10),
      RIGHT(HLQ_SMS_L0KB,11),
      RIGHT(HLQ_ML1_DSN_CTR,10),
      RIGHT(HLQ_ML1_ORGKB,11),
      RIGHT(HLQ_ML1KB,11),
      RIGHT(HLQ_ML2_DSN_CTR,10),
      RIGHT(HLQ_ML2_ORGKB,11),
      RIGHT(HLQ_ML2KB,11),
      RIGHT(HLQ_KB,11),
      RIGHT(HLQ_BKKB,11)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   CALL INITHLQ
 RETURN

/***********************************************************/
/* PUT IN "D" INFO FOR NEW DATASET                         */
/***********************************************************/
 DNEWINFO:
/*                                                          */
   HLQ_ALL_DSN_CTR = HLQ_ALL_DSN_CTR + 1
   TOT_ALL_DSN_CTR = TOT_ALL_DSN_CTR + 1
   HLQ_L0_DSN_CTR  = HLQ_L0_DSN_CTR + 1
   TOT_L0_DSN_CTR  = TOT_L0_DSN_CTR + 1
   IF DCDUSESP > DCDALLSP THEN DCDUSESP = DCDALLSP   /* BAD DATA      */
   IF SUBSTR(DCDDSORG,2,1) = '08'X THEN DCDUSESP = DCDALLSP
                                                   /*  VSAM DATA      */
   HLQ_L0KB = HLQ_L0KB + DCDALLSP
   HLQ_L0USEKB = HLQ_L0USEKB + DCDUSESP
   HLQ_KB = HLQ_KB + DCDALLSP
   TOT_L0KB = TOT_L0KB + DCDALLSP
   TOT_L0USEKB = TOT_L0USEKB + DCDUSESP
   TOT_KB = TOT_KB + DCDALLSP
   IF BITAND(DCDFLAG1,'40'X) = '40'X THEN DO           /* IS IT SMS?  */
      TOT_SMS_L0KB = TOT_SMS_L0KB + DCDALLSP
      TOT_SMS_DSN_CTR = TOT_SMS_DSN_CTR + 1
      HLQ_SMS_L0KB = HLQ_SMS_L0KB + DCDALLSP
      HLQ_SMS_DSN_CTR = HLQ_SMS_DSN_CTR + 1
      END
 RETURN

/***********************************************************/
/* PUT IN "M" INFO FOR NEW DATASET                         */
/***********************************************************/
 MNEWINFO:
/*                                                          */
   HLQ_ALL_DSN_CTR = HLQ_ALL_DSN_CTR + 1
   TOT_ALL_DSN_CTR = TOT_ALL_DSN_CTR + 1
   IF BITAND(UMFLAG1,'40'X) = '40'X THEN DO
      HLQ_ML1_DSN_CTR = HLQ_ML1_DSN_CTR + 1
      TOT_ML1_DSN_CTR = TOT_ML1_DSN_CTR + 1
      HLQ_ML1_ORGKB = HLQ_ML1_ORGKB + UMALLSP
      HLQ_KB = HLQ_KB + UMALLSP
      HLQ_ML1KB = HLQ_ML1KB + UMDSIZE
      TOT_ML1_ORGKB = TOT_ML1_ORGKB + UMALLSP
      TOT_KB = TOT_KB + UMALLSP
      TOT_ML1KB = TOT_ML1KB + UMDSIZE
      END
     ELSE DO
      HLQ_ML2_DSN_CTR = HLQ_ML2_DSN_CTR + 1
      TOT_ML2_DSN_CTR = TOT_ML2_DSN_CTR + 1
      HLQ_ML2_ORGKB = HLQ_ML2_ORGKB + UMALLSP
      HLQ_KB = HLQ_KB + UMALLSP
      HLQ_ML2KB = HLQ_ML2KB + UMDSIZE
      TOT_ML2_ORGKB = TOT_ML2_ORGKB + UMALLSP
      TOT_KB = TOT_KB + UMALLSP
      TOT_ML2KB = TOT_ML2KB + UMDSIZE
      END
 RETURN

/***********************************************************/
/* PUT IN "B" INFO FOR NEW DATASET                         */
/***********************************************************/
 BNEWINFO:
/*                                                          */
   HLQ_BKKB = HLQ_BKKB+UBDSIZE
   TOT_BKKB = TOT_BKKB+UBDSIZE
 RETURN

/***********************************************************/
/* INIT ALL HLQ SUMMARY FIELDS                             */
/***********************************************************/
 INITHLQ:
/*                                                          */
   HLQ_L0KB = 0
   HLQ_L0USEKB = 0
   HLQ_ML1_DSN_CTR = 0
   HLQ_ML1_ORGKB = 0
   HLQ_ML1KB = 0
   HLQ_ML2_DSN_CTR = 0
   HLQ_ML2_ORGKB = 0
   HLQ_ML2KB = 0
   HLQ_KB = 0
   HLQ_BKKB = 0
   HLQ_L0_DSN_CTR = 0
   HLQ_ALL_DSN_CTR = 0
   HLQ_SMS_L0KB = 0
   HLQ_SMS_DSN_CTR = 0
 RETURN

/***********************************************************/
/* INIT ALL TOT SUMMARY FIELDS                             */
/***********************************************************/
 INITTOT:
/*                                                          */
   TOT_L0KB = 0
   TOT_L0USEKB = 0
   TOT_ML1_DSN_CTR = 0
   TOT_ML1_ORGKB = 0
   TOT_ML1KB = 0
   TOT_ML2_DSN_CTR = 0
   TOT_ML2_ORGKB = 0
   TOT_ML2KB = 0
   TOT_KB = 0
   TOT_BKKB = 0
   TOT_L0_DSN_CTR = 0
   TOT_ALL_DSN_CTR = 0
   TOT_SMS_L0KB = 0
   TOT_SMS_DSN_CTR = 0
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD.J 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
   DCDALLSP = C2D(DCDALLSP)
   DCDUSESP = C2D(DCDUSESP)
 RETURN

/***********************************************************/
/* PARSE   MIGRATED DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCMRECP:
/*                                                          */
   PARSE VAR RECORD.J 1 . 25 UMDSNAM 69 UMFLAG1 70 UMDEVCL,
      71 UMDSORG 73 UMDSIZE 77 UMTIME 81 UMDATE 85 . 87 UMDATCL,
      117 . 119 UMSTGCL 149 . 151 UMMGTCL 181 UMRECRD 182 UMRECOR,
      183 UMBKLNG 185 UMFLAG2 186 . 187 UMNMIG 189 UMALLSP,
      193 UMUSESP 197 UMRECSP 201 UMCREDT 205 UMEXPDT 209 UMLBKDT,
      217 UMLRFDT
   UMALLSP = C2D(UMALLSP)
   UMDSIZE = C2D(UMDSIZE)
 RETURN

/***********************************************************/
/* PARSE   BACKUP   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCBRECP:
/*                                                          */
   PARSE VAR RECORD.J 1 . 25 UBDSNAM 69 UBFLAG1 70 UBDEVCL,
      71 UBDSORG 73 UBDSIZE 77 UBTIME 81 UBDATE 85 . 87 UBDATCL,
      117 . 119 UBSTGCL 149 . 151 UBMGTCL 181 UBRECRD 182 UBRECOR,
      183 UBBKLNG 185 UBFLAG2 186 . 187 UBNMIG 189 UBALLSP,
      193 UBUSESP 197 UBRECSP 200
   UBDSIZE = C2D(UBDSIZE)
 RETURN
./   ADD   NAME=MULTIVOL
/* REXX                                                               */
/*                                                                    */
/* MULTIVOL                                                           */
/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */
/*             THE VOLSER AND DSN FOR ALL RECORDS                     */
/*             THAT HAVE A VOLUME SEQUENCE NUMBER > 1                 */
/*                                                                    */
/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*    OUTPUT:  REXX SAY TO DEFAULT OUTPUT STREAM                      */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/**********************************************************************/

TRACE N
"FREE DDNAME(FILEA)"
"ALLOC DSNAME('SMS.UMB.DCOLLECT.RECTYPDM') DDNAME(FILEA) SHR"
"EXECIO 10000 DISKR FILEA (STEM IN_REC."
DO WHILE IN_REC.0 > 0
   DO J = 1 TO IN_REC.0
      PARSE VAR IN_REC.J S1 5 DCURCTYP 7
      IF DCURCTYP ¬= 'D ' THEN ITERATE J
      PARSE VAR IN_REC.J 1 . 25 DCDDSNAM 69 .  79 DCDVOLSR,
         85 . 123 DCDVOLSQ 125 .
      IF DCDVOLSQ > '0001'X THEN SAY DCDVOLSR DCDDSNAM
   END
   "EXECIO 10000 DISKR FILEA (STEM IN_REC."
END
"EXECIO 0 DISKR FILEA (FINIS"
"FREE DDNAME(FILEA)"
EXIT
./   ADD   NAME=NONSMS
/* REXX                                                               */
/*                                                                    */
/* NONSMS                                                             */
/*    PURPOSE: READS TYPE D RECORDS AND LISTS OUT                     */
/*             NON-SMS DSNS AND THE VOLSER THEY ARE ON.               */
/*             FOR EACH HLQ, LISTS OUT NUMBER OF DATASETS,            */
/*             SIZE IN KBYTES, SIZE FOR PRIME POOL (OURS IS           */
/*             DEFINED AS <102400 KBYTES), SIZE FOR LARGE POOL        */
/*             (ANY DSN >1024000 KBYTES), AND KYBTES NOT              */
/*             REFERENCED IN THE LAST 30 DAYS.                        */
/*                                                                    */
/*    INPUT:   SMS.UMB.COLLECT.RECTYPDM                               */
/*             TYPE D AND M RECORDS                                   */
/*                                                                    */
/*             (NOTE: EVEN THOUGH D AND M ARE BOTH INPUT, ONLY        */
/*              D IS USED)                                            */
/*                                                                    */
/*    OUTPUT:  SMS.PMB.DCOLLECT.NONSMS.DCCYYDDD                       */
/*                                                                    */
/*    PRESORT: FOR TYPE D AND M RECORDS                               */
/*             SORT FIELDS=(29,44,CH,A)                               */
/*             INCLUDE COND=((9,2,CH,EQ,C'D '),OR,(9,2,CH,EQ,C'M '))  */
/*                                                                    */
/*                                                                    */
/**********************************************************************/

/***********************************************************/
/* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */
/***********************************************************/
TRACE N
 INNAME = "'SMS.UMB.DCOLLECT.RECTYPDM'"
 "ALLOC DDNAME(INFILE) DA("INNAME") SHR"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('INNAME') FAILED'
    EXIT 8
    END

 EXCLUDES = 'HSM BHSM'
 EXCL = 'HSM BHS'

/***********************************************************/
/* SPECIAL PROCESSING FOR FIRST RECORD                     */
/***********************************************************/
 EOF = 'NO'
 FIRST = 'NO'
 DO UNTIL FIRST = 'YES'
    "EXECIO 1 DISKR INFILE"
    IF RC¬= 0 THEN
       EOF = 'YES'
    ELSE DO
       PARSE PULL RECORD
       PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 17 DCUDATE 21 .,
          25 RECDSN 69 . 70 DCDFLAG1 71 . 231 DCDSTGRP 239 .
       IF BITAND(DCDFLAG1,'40'X) ¬= '40'X THEN FIRST = 'YES'
       IF DCURCTYP ¬= 'D ' THEN FIRST = 'NO'
       END
 END
 CALL INITDSN
 CALL INITHLQ
 CALL INITTOT
 DATE  = LEFT(C2X(DCUDATE),7)
 DSNAME=RECDSN
 PARSE VAR RECDSN RECHLQ "." .
 IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
 HLQ=RECHLQ

/***********************************************************/
/* OPEN THE OUTPUT FILE FOR THE SUMMARIZED BY DSN REPORT   */
/***********************************************************/
OUTNAME ="SMS.PMB.DCOLLECT.NONSMS.D"||DATE
"ALLOC DSNAME('SMS.PMB.DCOLLECT.NONSMS.D"||DATE||"')",
  "DSORG(PS) LRECL(80) RECFM(F B) AVGREC(U)",
  "SPACE(5000,5000) RELEASE DDNAME(OUTFILE)"
 IF RC¬= 0 THEN DO
    SAY  'ALLOCATION OF ('OUTNAME') FAILED'
    EXIT 12
    END

 COLDATE  = RIGHT(LEFT(C2X(DCUDATE),7),5)
 COLYY = LEFT(COLDATE,2)
 COLDDD = RIGHT(COLDATE,3)
 OUT_LINE = "DATA COLLECTED ON:" LEFT(C2X(DCUDATE),7)
 PUSH OUT_LINE
 "EXECIO 1 DISKW OUTFILE"
 CALL OUTHEAD
 HLQ_DSN_CTR=1
 TOT_DSN_CTR=1
 CALL DCDRECP
 CALL DNEWINFO

/***********************************************************/
/* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */
/***********************************************************/
 EOF = 'NO'
 DO WHILE EOF='NO'
   "EXECIO 1 DISKR INFILE"
   IF RC¬= 0 THEN DO
      EOF = 'YES'
      CALL OUTLINE
      CALL OUTHLQ
      CALL OUTTOT
      END
   ELSE DO
      PARSE PULL RECORD
      PARSE VAR RECORD 1 . 5 DCURCTYP 7 . 25 RECDSN 69 .
      PARSE VAR RECDSN RECHLQ "." .
      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
      SELECT
         WHEN(DCURCTYP='D ') THEN DO             /* ACTIVE DATA       */
                         CALL DCDRECP
                         IF BITAND(DCDFLAG1,'40'X) = '40'X THEN ITERATE
                         END
         WHEN(DCURCTYP='M ') THEN ITERATE        /* MIGRATED DATA     */
         OTHERWISE ITERATE    /* DO NOT PROCESS OTHER RECORD TYPES */
         END

/***********************************************************/
/*        OUTPUT OUTLINE TO FILE AND STORE NEW INFO        */
/***********************************************************/
      CALL OUTLINE
      DSNAME=RECDSN
      PARSE VAR RECDSN RECHLQ "." .
      IF LENGTH(RECHLQ) > 8 THEN RECHLQ = LEFT(RECHLQ,8)
         IF RECHLQ ¬= HLQ THEN CALL OUTHLQ
      IF WORDPOS(RECHLQ,EXCLUDES) = 0 THEN DO
         HLQ_DSN_CTR = HLQ_DSN_CTR + 1
         TOT_DSN_CTR = TOT_DSN_CTR + 1
         END
      HLQ = RECHLQ
      SELECT
         WHEN(DCURCTYP='D ') THEN DO         /* ACTIVE DATA       */
                          CALL DNEWINFO
                          END
         WHEN(DCURCTYP='M ') THEN NOP         /* MIGRATED DATA     */
         WHEN(DCURCTYP='B ') THEN NOP         /* BACKUP DATA       */
         OTHERWISE NOP        /* DO NOT PROCESS OTHER RECORD TYPES */
         END
      END
 END
 "EXECIO 0 DISKW OUTFILE (FINIS"
 "EXECIO * DISKR INFILE (FINIS"
 "FREE DDNAME(INFILE)"
 "FREE DDNAME(OUTFILE)"
 EXIT


/***********************************************************/
/* PUT OUT A HEADER LINE                                   */
/***********************************************************/
 OUTHEAD:
/*                                                          */
    OUT_LINE = "  "
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
    OUT_LINE = LEFT(" ",17),
       RIGHT("DSN",7),
       RIGHT("L0",9),
       RIGHT("PRIME",9),
       RIGHT("LARGE",9),
       RIGHT(">30DAYS",9)
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
    OUT_LINE = LEFT("HLQ/DSN",17),
       RIGHT("COUNT",7),
       RIGHT("KBYTES",9),
       RIGHT("POOL",9),
       RIGHT("POOL",9),
       RIGHT("LASTREF",9)
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
    OUT_LINE = LEFT("-",17,"-"),
       RIGHT("-",7,"-"),
       RIGHT("-",9,"-"),
       RIGHT("-",9,"-"),
       RIGHT("-",9,"-"),
       RIGHT("-",9,"-")
    PUSH OUT_LINE
    "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT OUT A DETAIL LINE                                   */
/***********************************************************/
 OUTDET:
/*                                                          */
   OUT_LINE = LEFT("  ",2),
      LEFT(DCDDSNAM,62),
      LEFT(DCDVOLSR,8)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT SUMMARIZED INFO OUT TO NEW FILE                     */
/***********************************************************/
OUTLINE:
   CALL INITDSN
 RETURN

/***********************************************************/
/* PUT SUMMARIZED HLQ INFO OUT TO NEW FILE                 */
/***********************************************************/
OUTHLQ:
/*                                                          */
   OUT_LINE = '*',
      LEFT(HLQ,8),
      '      ',
      RIGHT(HLQ_DSN_CTR,7),
      RIGHT(HLQ_L0KB,9),
      RIGHT(HLQ_PRKB,9),
      RIGHT(HLQ_LGKB,9),
      RIGHT(HLQ_GT30,9)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
   CALL INITHLQ
 RETURN

/***********************************************************/
/* PUT SUMMARIZED TOTAL INFO OUT TO NEW FILE               */
/***********************************************************/
OUTTOT:
/*                                                          */
   OUT_LINE = '* TOTAL  ',
      '       ',
      RIGHT(TOT_DSN_CTR,7),
      RIGHT(TOT_L0KB,9),
      RIGHT(TOT_PRKB,9),
      RIGHT(TOT_LGKB,9),
      RIGHT(TOT_GT30,9)
   PUSH OUT_LINE
   "EXECIO 1 DISKW OUTFILE"
 RETURN

/***********************************************************/
/* PUT IN "D" INFO FOR NEW DATASET                         */
/***********************************************************/
 DNEWINFO:
/*                                                          */
   IF WORDPOS(SUBSTR(DCDDSNAM,1,3),EXCL) = 0 THEN DO
      L0KBYTES = DCDALLSP
      HLQ_L0KB = HLQ_L0KB+DCDALLSP
      TOT_L0KB = TOT_L0KB+DCDALLSP
      CALL REF
      IF L0KBYTES < 102400 THEN DO
            PRKBYTES = PRKBYTES
            HLQ_PRKB = HLQ_PRKB + DCDALLSP
            TOT_PRKB = TOT_PRKB + DCDALLSP
         END
         ELSE DO
            LGKBYTES = LGKBYTES
            HLQ_LGKB = HLQ_LGKB + DCDALLSP
            TOT_LGKB = TOT_LGKB + DCDALLSP
         END
      CALL OUTDET
      END
 RETURN


/***********************************************************/
/* CALULATE NUMBER OF DAYS SINCE LAST REFERENCE            */
/* ALL DATA, BOTH SMS AND NON-SMS                          */
/* BASED ON COLLECTION DATE OF DATA                        */
/***********************************************************/

 REF:
      IF REFDDD = '00000' THEN DO      /*  IF LASTREF = 0'S THEN      */
         REFYY = CREYY                 /*  SET LAST REFERENCE TO      */
         REFDDD = CREDDD               /*  CREATION DATE              */
         END
      IF COLDDD <= REFDDD THEN DO
         REFYY = REFYY - 1
         REFDDD = REFDDD + 365
         END
      REFDAYS = COLDDD - REFDDD
      REFYRS = COLYY - REFYY
      REFDAYS = REFDAYS + (REFYRS * 365)

      SYS = 'NO'
      VSINDX = 'NO'
      IF SUBSTR(DSN,1,9) = "SYS1.VVDS" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,9) = "SYS1.VTOC" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,9) = "BHSM.VTOC" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,6) = "PAGE.V" THEN SYS = 'YES'
      IF SUBSTR(DSN,1,4) = "SYS9" THEN SYS = 'YES'
      IF INDEX(DSN,'DUMYDSCB') >0 THEN SYS = 'YES'
      IF BITAND(SUBSTR(DSORG,2,1),'08'X) = '08'X THEN DO
         VS = 'YES'
         IF INDEX(DSN,'INDEX') >0 THEN VSINDX = 'YES'
         END

      SELECT
         WHEN SYS = 'YES' THEN NOP
         WHEN VSINDX = 'YES' THEN NOP
         WHEN REFDAYS > 30 THEN DO
            GT30YTES = DCDALLSP
            HLQ_GT30 = HLQ_GT30 + DCDALLSP
            TOT_GT30 = TOT_GT30 + DCDALLSP
            END
      OTHERWISE
      END                                        /* END OF SELECT     */
 RETURN

/***********************************************************/
/* INIT ALL DSN SUMMARY FIELDS                             */
/***********************************************************/
 INITDSN:
/*                                                          */
   L0KBYTES = 0
   PRKBYTES = 0
   LGKBYTES = 0
   GT30YTES = 0
 RETURN

/***********************************************************/
/* INIT ALL HLQ SUMMARY FIELDS                             */
/***********************************************************/
 INITHLQ:
/*                                                          */
   HLQ_L0KB = 0
   HLQ_PRKB = 0
   HLQ_LGKB = 0
   HLQ_GT30 = 0
   HLQ_DSN_CTR = 0
   HLQ_TOT = 0
 RETURN

/***********************************************************/
/* INIT ALL TOT SUMMARY FIELDS                             */
/***********************************************************/
 INITTOT:
/*                                                          */
   TOT_L0KB = 0
   TOT_PRKB = 0
   TOT_LGKB = 0
   TOT_GT30 = 0
   TOT_DSN_CTR = 0
   TOT_TOT = 0
 RETURN

/***********************************************************/
/* PARSE   ACTIVE   DATA SET INFORMATION RECORD -          */
/***********************************************************/
 DCDRECP:
/*                                                          */
   PARSE VAR RECORD 1 . 25 DCDDSNAM 69 DCDERROR 70,
      70 DCDFLAG1 71 DCDFLAG2 72 . 75 DCDDSORG 77 DCDRECRD,
      78 DCDNMEXT 79 DCDVOLSR 85 DCDBKLNG 87 DCDLRECL,
      89 DCDALLSP 93 DCDUSESP 97 DCDSCALL 101 DCDNMBLK,
      105 DCDCREDT 109 DCDEXPDT 113 DCDLSTRF 117 DCDDSSER,
      123 DCDVOLSQ 125 DCDLBKDT 133 . 135 DCDDATCL,
      143 . 167 DCDSTGCL 175 . 199 DCDMGTCL,
      207 . 231 DCDSTGRP 239 .
   DSN = DCDDSNAM
   DCDALLSP = C2D(DCDALLSP)
   DCDCREDT = RIGHT(LEFT(C2X(DCDCREDT),7),5)
   DCDLSTRF = RIGHT(LEFT(C2X(DCDLSTRF),7),5)
   REFYY = LEFT(DCDLSTRF,2)
   REFDDD = RIGHT(DCDLSTRF,3)
   CREYY = LEFT(DCDCREDT,2)
   CREDDD = RIGHT(DCDCREDT,3)
   CREATED = DCDCREDT
   DSORG = DCDDSORG
 RETURN

