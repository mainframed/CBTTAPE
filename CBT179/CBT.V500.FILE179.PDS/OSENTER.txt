         MACRO
&NFS     OSENTER  &BASE=12,&BASE2=,&BASE3=,&BASE4=,                    $
               &SAVE=*,&REGS=(YES,R),&F=,                              $
               &USING=,&SECTYPE=CSECT,&GETMAIN=,&PARMREG=,&LPARM=,     $
               &SP=1,&ID=*,&EXIT=,&ADDRREG=,&LENREG=,&ENV=CALL,        $
               &RC=,&RCLOC=,&T=T,&PL=,&LOAD=,&SYMREG=,&DSECT=,         $
               &TSFAKE=,&PARSE=,&MACRO=,&PRINT=,&DATE=,&TIME=,         $
               &IKJRLSA=,&DELETE=*,&MODE=,&AMODE=,&RMODE=,&GETMLOC=
         AGO   .SKIPCMT                 SKIP AROUND COMMENTS FOR MLOGIC
.*.
.*********************************************************************.
.*                                                                   *.
.*  OSENTER -- 29May88 -- LDW                                        *.
.*                                                                   *.
.*-------------------------------------------------------------------*.
.*                                                                   *.
.*  THIS MACRO WILL GENERATE THE HOUSEKEEPING CODE NEEDED FOR        *.
.*  STANDARD OS LINKAGE CONVENTIONS (FOR ENTRY AND EXIT)             *.
.*  THE GENERATED CODE WILL OPTIONALLY BE RE-ENTRANT                 *.
.*                                                                   *.
.*  Updates:                                                         *.
.*    10Oct96   LDW  Support PARMREG=(Rx,dsect) and LPARM=(Rx,dsect) *.
.*                      to automatically do USNGX                    *.
.*    29May88   LDW  Fix bug:  don't MNOTE for ENV=(CALL,SIM) with   *.
.*                      no GETMAIN=                                  *.
.*                   Add GETMLOC= for LOC= operand of GETMAIN=       *.
.*    26May88   LDW  Fix bug in ZERO code                            *.
.*    15May88   LDW  Fix bug in ENV= consistency check               *.
.*    12MAY88   LDW  ADD 'ZERO' AS THIRD OPERAND OF GETMAIN=         *.
.*    21FEB88   LDW  CHANGE GETMAIN/FREEMAIN FROM R TO RU FOR MVS/XA *.
.*                   ADD AMODE= AND RMODE= KEYWORDS                  *.
.*    01-07-85  EMS  FIX DELETE=* DEFAULT FOR LOAD=                  *.
.*    01-02-85  EMS  ADD DELETE=,MODE= KEYWORDS                      *.
.*    09-06-84  EMS  FIX BUG WHEN CODING 'PL=,LOAD=DATETIME'         *.
.*    06-24-84  LDW  FIX BUG WHEN CODING 'SAVE=,EXIT=LEAVE'          *.
.*    11-09-83  LDW  MAKE REGS=(NO,R) WORK CORRECTLY                 *.
.*    04-30-82  LDW  FIX PREVIOUS FIX                                *.
.*    04-25-82  LDW  FIX FOR "SAVE=" NULL OPERAND -> NO SAVEAREA     *.
.*    10-19-81  EMS  FIX FOR ASMH "L'" PROBLEM                       *.
.*    12-04-80  LDW  CHANGE NAME FROM "ENTR" TO "OSENTER"            *.
.*    11-13-80  LDW  FIX 10-23-80 FIX; FIX NON-RENT TEST             *.
.*    10-23-80  LDW  FIX 10-08-80 FIX                                *.
.*    10-08-80  LDW  FIX FOR ENV=(CP,SIMULATE) WITH NO PL=           *.
.*    07-07-80  LDW  MOVE USINGS TO CORRECT PROBLEMS IN EXIT CODE    *.
.*    05-14-80  LDW  REPLACE TSFAKE=YES WITH ENV=SIMULATE            *.
.*    05-13-80  LDW  ADD IKJRLSA KEYWORD; FIX BUGS IN ENV=CP CODE    *.
.*    09-27-79  LDW  FIX BUG IN TSO-CP SIMULATION CODE               *.
.*    02-21-79  LDW  ADD DATE= AND TIME= OPERANDS                    *.
.*    01-12-79  LDW  FIX BUG; ADD MVS CODE FOR LOAD=                 *.
.*    12-29-78  LDW  ADD BASE4=; FIX LENGTH OF GETMAIN IF MACRO=YES; *.
.*                   CHECK FOR RC=(R1) AND DYNAMIC AREA (GETMAIN=);  *.
.*                   ADD PRINT=; FIX FOR BATCH CALL OF ENV=CP PGMCK  *.
.*                                                                   *.
.*-------------------------------------------------------------------*.
.*                                                                   *.
.*  OPERANDS AVAILABLE ARE:                                          *.
.*                                                                   *.
.*                                                                   *.
.*  BASE=    -- DEFAULT:  BASE=12                                    *.
.*              THE BASE REGISTER TO BE USED                         *.
.*                                                                   *.
.*                                                                   *.
.*  BASE2=   -- DEFAULT:  (NONE)                                     *.
.*              A SECOND BASE REGISTER                               *.
.*                                                                   *.
.*                                                                   *.
.*  BASE3=   -- DEFAULT:  (NONE)                                     *.
.*              A THIRD BASE REGISTER (ONLY VALID IF BASE2= IS CODED)*.
.*                                                                   *.
.*  BASE4=   -- DEFAULT:  (NONE)                                     *.
.*              A FOURTH BASE REGISTER (MUST HAVE BASE2= AND BASE3=) *.
.*                                                                   *.
.*                                                                   *.
.*  SAVE=    -- DEFAULT:  SAVE=*                                     *.
.*              NAME OF A SAVE AREA TO BE USED.                      *.
.*              IF SAVE=* IS CODED, AN INLINE SAVE AREA WILL BE      *.
.*              GENERATED, WITH A UNIQUE NAME.  SAVE=* IS IGNORED    *.
.*              IF GETMAIN= IS CODED.  ANY OTHER VALUE OF SAVE=      *.
.*              WILL CAUSE AN ERROR IF GETMAIN= IS ALSO USED.        *.
.*                                                                   *.
.*                                                                   *.
.*  GETMAIN= -- Default:  (none)                                     *.
.*              GETMAIN=length, or                                   *.
.*              GETMAIN=(length,dsectname).                          *.
.*              GETMAIN=(length,dsectname,ZERO).                     *.
.*              This operand causes a GETMAIN for "length" bytes to  *.
.*              be generated.  The first 18 words will be reserved   *.
.*              for the save area.  The address of the area obtained *.
.*              is placed in R13, and if "dsectname" is coded, a     *.
.*              USING is done.  If the word "ZERO" is coded as the   *.
.*              third operand, then the work area will be zeroed     *.
.*              before it is used.                                   *.
.*              If MACRO=YES is coded, the default for GETMAIN= is   *.
.*              GETMAIN=(TSDSECTL,TSDSECT) and the EQU for TSDSECTL  *.
.*              will be generated by OSENTER.                        *.
.*                                                                   *.
.*                                                                   *.
.*  GETMLOC= -- Default:  (none)                                     *.
.*              GETMLOC=(ANY,ANY), etc                               *.
.*              This operand becomes the LOC= operand of GETMAIN.    *.
.*                                                                   *.
.*                                                                   *.
.*  SP=      -- DEFAULT:  SP=1                                       *.
.*              THE SUBPOOL FOR THE WORKAREA OBTAINED BY GETMAIN=    *.
.*                                                                   *.
.*                                                                   *.
.*  REGS=    -- DEFAULT:  REGS=(YES,R)                               *.
.*              THE FIRST OPERAND (YES/NO) INDICATES WHETHER THE     *.
.*              REGEQU MACRO WILL BE USED TO GENERATE EQU'S FOR      *.
.*              SYMBOLIC REGISTERS.  THE SECOND OPERAND IS THE       *.
.*              PREFIX TO BE USED.                                   *.
.*              NOTE:  REGS=(YES,Q) IS THE SAME AS REGS=(,Q)         *.
.*                                                                   *.
.*                                                                   *.
.*  F=       -- DEFAULT:  (NONE)                                     *.
.*              THE PREFIX TO BE USED FOR SYMBOLIC FLOATING POINT    *.
.*              REGISTER NAMES.                                      *.
.*                                                                   *.
.*                                                                   *.
.*  SECTYPE= -- DEFAULT:  SECTYPE=CSECT                              *.
.*              THE SECTION TYPE TO BE GENERATED.                    *.
.*              POSSIBLE VALUES:  CSECT/DSECT/ENTRY/NONE             *.
.*                                                                   *.
.*                                                                   *.
.*  USING=   -- DEFAULT:  (NONE)                                     *.
.*              A USING WILL BE DONE FOR EACH PAIR OF OPERANDS.      *.
.*              CODED AS FOLLOWS:                                    *.
.*              USING=(DSECT1,REG1,DSECT2,REG2,...)                  *.
.*                                                                   *.
.*                                                                   *.
.*  EXIT=    -- DEFAULT:  (NONE)                                     *.
.*              THE NAME OF AN EXIT ROUTINE TO BE BRANCHED TO THAT   *.
.*              WILL FREE THE WORKAREA (IF ONE WAS OBTAINED BY       *.
.*              GETMAIN=), DECHAIN SAVE AREAS, SET THE RETURN CODE,  *.
.*              AND RETURN TO CALLER.                                *.
.*                                                                   *.
.*                                                                   *.
.*  RC=      -- DEFAULT:  RC=(15)                                    *.
.*              THE RETURN CODE TO BE PASSED BACK TO THE CALLER.     *.
.*              THIS OPERAND IS IGNORED IF EXIT= IS NOT CODED.       *.
.*              RC= CAN BE CODED AS RC=(REG) OR RC=EXPRESSION.       *.
.*              THIS OPERAND IS MUTUALLY EXCLUSIVE WITH THE RCLOC=   *.
.*              OPERAND.                                             *.
.*                                                                   *.
.*                                                                   *.
.*  RCLOC=   -- DEFAULT:  (NONE)                                     *.
.*              THE STORAGE LOCATION FROM WHICH THE RETURN CODE WILL *.
.*              BE OBTAINED.  MUST HAVE FULLWORD OR HALFWORD TYPE    *.
.*              ATTRIBUTE.  THIS OPERAND IS MUTUALLY EXCLUSIVE       *.
.*              WITH THE RC= OPERNAND.                               *.
.*                                                                   *.
.*                                                                   *.
.*  T=       -- DEFAULT:  T=T                                        *.
.*              IGNORED IF EXIT= NOT CODED.  SPECIFIES THAT THE OLD  *.
.*              SAVE AREA WILL BE FLAGGED BY A X'FF' AT OFFSET 12    *.
.*              TO INDICATE THAT IT IS INACTIVE.  NOTE:  "T=" SHOULD *.
.*              NOT BE CODED FOR EXIT ROUTINES, SUCH AS STAE ROUTINES*.
.*                                                                   *.
.*                                                                   *.
.*  ID=      -- DEFAULT:  ID=CSECT NAME                              *.
.*              AN ID TO PUT IN CHARACTER FORM NEAR THE BEGINNING    *.
.*              OF THE CSECT, TO AID IN DUMP READING.                *.
.*                                                                   *.
.*                                                                   *.
.*  ENV=     -- DEFAULT:  ENV=CALL                                   *.
.*              THE ENVIRONMENT THAT THE PROGRAM WILL OR SHOULD BE   *.
.*              RUNNING UNDER.  VALID OPERANDS (MORE THAN ONE CAN    *.
.*              BE CODED, IN PARENS):                                *.
.*              CALL -- BATCH EXEC PGM=, OR TSO CALL, OR LINK MACRO  *.
.*              CP -- TSO COMMAND PROCESSOR                          *.
.*              TSOCP -- ALIAS FOR CP                                *.
.*              TSO -- MAY BE RUN ON TSO                             *.
.*              SIMULATE -- PROGRAM CAN BE INVOKED VIA CALL OR AS A  *.
.*                     COMMAND PROCESSOR (CP) (SEE BELOW)            *.
.*              SIM -- ALIAS FOR SIMULATE                            *.
.*              MVT -- PROGRAM WILL BE RUN UNDER MVT.                *.
.*              MVS -- PROGRAM WILL BE RUN UNDER MVS.  (OS/VS2 R3)   *.
.*              PLI -- PROGRAM WILL BE CALLED BY A PLIX PROGRAM.     *.
.*              PLIX -- ALIAS FOR PLI                                *.
.*                                                                   *.
.*              NOTE:  CALL IS MUTUALLY EXCLUSIVE WITH CP/TSOCP.  IF *.
.*              THE PROGRAM MAY BE RUN EITHER THRU CALL OR AS A CP,  *.
.*              SPECIFY ENV=TSO OR ENV=CP (ENV=CP IMPLIES ENV=TSO)   *.
.*                                                                   *.
.*              IF ENV=SIMULATE IS CODED, AND THE PROGRAM IS CALLED  *.
.*              VIA "CALL", THEN A FAKE CPPL, PSCB, CBUF, UPT, AND   *.
.*              ECT WILL BE BUILT, BASED ON THE INFO IN THE PARM     *.
.*              FIELD.  IF ENV=CALL IS CODED (OR DEFAULTED), A FAKE  *.
.*              PARM PTR WORD AND LENGTH WILL BE BUILT BASED ON THE  *.
.*              INFO IN THE CBUF.  THE NECESSARY AREA WILL BE        *.
.*              GENERATED AND NAMED EITHER IN THE WORK AREA (IF      *.
.*              ANY), OR INLINE.                                     *.
.*                                                                   *.
.*                                                                   *.
.*  PARMREG= -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER TO SAVE THE PARM POINTER PASSED IN R1   *.
.*              ("LR  PARMREG,R1")                                   *.
.*              PARMREG=(Rx,dsect) then generates:                   *.
.*              USNGX dsect,Rx                                       *.
.*                                                                   *.
.*                                                                   *.
.*  LPARM=   -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER INTO WHICH THE PARM ADDR WILL BE LOADED *.
.*              ( "L  LPARM,0(,R1)" )                                *.
.*              LPARM=(Rx,dsect) then generates:                     *.
.*              USNGX dsect,Rx                                       *.
.*                                                                   *.
.*                                                                   *.
.*  ADDRREG= -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER TO CONTAIN THE ADDRESS OF THE ACTUAL    *.
.*              TEXT OF THE PARM.                                    *.
.*              NOTE:  ADDRREG= AND LENREG= ARE AN OPERAND PAIR --   *.
.*              IF ONE IS CODED, THE OTHER MUST ALSO BE CODED.       *.
.*                                                                   *.
.*                                                                   *.
.*  LENREG=  -- DEFAULT:  (NONE)                                     *.
.*              THE REGISTER TO CONTAIN THE LENGTH OF THE PARM TEXT. *.
.*              SEE NOTE FOR ADDRREG=                                *.
.*                                                                   *.
.*                                                                   *.
.*  LOAD=    -- DEFAULT:  (NONE)                                     *.
.*              A LIST OF MODULES TO BE LOADED.  THE ADDRESS OF      *.
.*              EACH MODULE WILL BE SAVED IN A WORD WITH THE NAME    *.
.*              OF THE MODULE.                                       *.
.*                                                                   *.
.*                                                                   *.
.*  DELETE=  -- DEFAULT:  (NONE)                                     *.
.*              A LIST OF MODULES TO BE DELETED.  DELETE=* WILL      *.
.*              DELETE ALL MODULES LOADED VIA LOAD=.  INCLUDING      *.
.*              AN * IN THE LIST OF MODULES TO BE DELETED WILL       *.
.*              DELETE ALL LOADED MODULES IN ADDITION TO ENTRIES     *.
.*              SPECIFIED.                                           *.
.*                                                                   *.
.*                                                                   *.
.*  PL=      -- DEFAULT:  (NONE)                                     *.
.*              A LIST OF PARAMETER LISTS TO BE GENERATED AND        *.
.*              INITIALIZED.  THE FOLLOWING PARM LISTS ARE           *.
.*              SUPPORTED:  CSCAN, PARSE, DAIR, IO, MESSAGE.         *.
.*                                                                   *.
.*                                                                   *.
.*  MACRO=   -- DEFAULT:  MACRO=NO                                   *.
.*              IF 'YES' IS CODED, A 'TSWORK' MACRO WILL BE ISSUED   *.
.*              TO DEFINE MORE STORAGE IN THE WORK AREA.  (TSWORK    *.
.*              MACRO IS DEFINED BY THE USER.)                       *.
.*                                                                   *.
.*                                                                   *.
.*  PARSE=   -- DEFAULT:  (NONE)                                     *.
.*              FORMAT:  PARSE=PCLNAME OR PARSE=(PCLNAME,ERRADDR)    *.
.*              WILL USE THE TSPARSE MACRO TO PARSE THE COMMAND LINE *.
.*              (POINTED TO BY CPPLCBUF).  PCLNAME IS THE NAME OF    *.
.*              THE PCL CSECT.  IF ERRADDR IS GIVEN, GENERATES ERROR *.
.*              ANALYSIS ROUTINE ROUTINE WITH TSPARERR MACRO.        *.
.*                                                                   *.
.*                                                                   *.
.*  IKJRLSA= -- DEFAULT:  IKJRLSA=YES IF PARSE= CODED, =NO OTHERWISE *.
.*              IKJRLSA=YES SPECIFIES THAT THE EXIT CODE SHOULD DO   *.
.*              AN IKJRLSA TO RELEASE PARSE'S WORK AREA.  THIS       *.
.*              OPERAND IS IGNORED IF EXIT= IS NOT CODED.            *.
.*                                                                   *.
.*                                                                   *.
.*  PRINT=   -- DEFAULT:  (NONE)                                     *.
.*              PRINT=NOGEN SPECIFIES THAT THE DSECTS SHOULD NOT BE  *.
.*              PRINTED                                              *.
.*                                                                   *.
.*                                                                   *.
.*  DATE=    -- DEFAULT:  (DATE OF ASSEMBLY)                         *.
.*              SPECIFIES ASSEMBLY DATE (SHOULD ONLY BE USED WHEN    *.
.*              COMPARING AGAINST AN OLD LOAD MODULE)                *.
.*                                                                   *.
.*                                                                   *.
.*  TIME=    -- DEFAULT:  (TIME OF ASSEMBLY)                         *.
.*              SPECIFIES ASSEMBLY DATE (SHOULD ONLY BE USED WHEN    *.
.*              COMPARING AGAINST AN OLD LOAD MODULE)                *.
.*                                                                   *.
.*                                                                   *.
.*  MODE=    -- DEFAULT:  (NONE)                                     *.
.*              SPECIFIES WHAT MODE COMMAND WAS INVOKED WITH.        *.
.*              CONTAINS 2 TO 4 OPERANDS :                           *.
.*                  1)   FLAG BYTE                                   *.
.*                  2)   BATCH MODE EQUATE                           *.
.*                  3)   TSO CALL MODE EQUATE                        *.
.*                  4)   TSO CP MODE EQUATE                          *.
.*              BYTE IS SET VIA AN MVI INDICATING APPROPRIATE MODE.  *.
.*                                                                   *.
.*                                                                   *.
.*********************************************************************.
.*.
.*
.*
.*  IHB&SYSNDX LETTERS USED:  ABC EF    KL   PQ STUV X Z
.*                   UNUSED:     D  GHIJ  MNO  R    W Y 0123456789$#@
.*
.SKIPCMT ANOP
         GBLB  &GDAIRM,&GPARSEM         TO AVOID DUPLICATES
         GBLB  &GDAIR,&GPARSE           DAIR OR PARSE LOADED
         LCLC  &ZBASE,&ZSAVE,&Q,&NAME,&RCRC,&LR,&AR,&LQ
         LCLC  &GET1,&GET2,&PARNAME
         LCLC  &IHBNX,&BLANK1,&BLANK2
         LCLC  &R0,&R1,&R2,&R3,&R12,&R13,&R14,&R15
         LCLA  &L,&X,&Y
         LCLB  &ENVTSO,&ENVCALL,&ENVCP,&ENVPLI,&ENVMVT,&ENVMVS,&ENVSIM
         LCLB  &FKCALL,&FKCP,&MVSCVT,&ASMERR
         LCLB  &CSPL,&PARS,&DAIR,&IO,&MSG
         LCLB  &MODEBIT
&IHBNX   SETC  'IHB&SYSNDX'
&BLANK1  SETC  '        '
&BLANK2  SETC  '        '
&PARNAME SETC  ''
&LQ      SETC  'L'''                    STUPID ASSEMBLER
         AIF   ('&PRINT' NE 'NOGEN').PRINTOK
         AIF   ('&PRINT' NE '').PRINTOK
         MNOTE 4,'WHAT DOES PRINT=&PRINT MEAN???'
.*
.*
.*
.PRINTOK AIF   ('&SYMREG' EQ '').NOSYMRG
         MNOTE 0,'SYMREG= IS UNSUPPORTED -- USE REGS='
.NOSYMRG AIF   ('&DSECT' EQ '').NOD$ECT
         MNOTE 4,'DSECT= IS UNSUPPORTED'
.NOD$ECT ANOP
.*-----------------------------------*.
.*  ENVIRONMENT                      *.
.*-----------------------------------*.
&X       SETA  0
.ENVLOOP AIF   (N'&ENV EQ &X).ENVDONE
&X       SETA  &X+1
         AIF   ('&ENV(&X)' EQ 'TSO'     ).ENVTSO
         AIF   ('&ENV(&X)' EQ 'CALL'    ).ENVCALL
         AIF   ('&ENV(&X)' EQ 'CP'      ).ENVCP
         AIF   ('&ENV(&X)' EQ 'TSOCP'   ).ENVCP
         AIF   ('&ENV(&X)' EQ 'SIM'     ).ENVSIM
         AIF   ('&ENV(&X)' EQ 'SIMULATE').ENVSIM
         AIF   ('&ENV(&X)' EQ 'MVS'     ).ENVMVS
         AIF   ('&ENV(&X)' EQ 'MVT'     ).ENVMVT
.**      AIF   ('&ENV(&X)' EQ 'PLI'     ).ENVPLI
.**      AIF   ('&ENV(&X)' EQ 'PLIX'    ).ENVPLI
         MNOTE 4,'ENV=&ENV(&X) IS INVALID -- IGNORED'
         AGO   .ENVLOOP
.ENVTSO  ANOP
&ENVTSO  SETB  1
         AGO   .ENVLOOP
.ENVCALL ANOP
&ENVCALL SETB  1
         AGO   .ENVLOOP
.ENVCP   ANOP
&ENVCP   SETB  1
&ENVTSO  SETB  1                        ENV=CP IMPLIES ENV=TSO
         AGO   .ENVLOOP
.ENVSIM  ANOP
&ENVSIM  SETB  1
         AGO   .ENVLOOP
.ENVMVS  ANOP
&ENVMVS  SETB  1
         AGO   .ENVLOOP
.ENVMVT  ANOP
&ENVMVT  SETB  1
         AGO   .ENVLOOP
.ENVPLI  ANOP
&ENVPLI  SETB  1
         AIF   ('&BASE' NE '12' AND '&BASE' NE 'R12').ENVLOOP
         MNOTE 4,'WARNING:  BASE=&BASE IS NOT COMPATIBLE WITH ENV=PLIX'
         AGO   .ENVLOOP
.ENVDONE AIF   (NOT &ENVCALL OR NOT &ENVCP).ENVOK1
        MNOTE 4,'ENV=(CALL,CP) MAY NOT BOTH BE GIVEN.  "CALL" IGNORED.'
&ENVCALL SETB  0                        IGNORE IT
.ENVOK1  AIF   (NOT &ENVMVT OR NOT &ENVMVS).ENVOK2
         MNOTE 4,'MAKE UP YOUR MIND:  ENV=MVT OR ENV=MVS, BUT NOT BOTH.$
                 MVT ASSUMED.'
&ENVMVS  SETB  0                        IGNORE IT
.*NVOK2  AIF   (NOT &ENVCP).ENVOK5
.ENVOK2  AIF   (NOT &ENVCP).ENVOK3
         AIF   (&ENVCP AND '&PARMREG' NE '').ENVOK3
         MNOTE 4,'PARMREG= REQUIRED FOR ENV=CP'
&ASMERR  SETB  1                        ASSEMBLY ERRORS WILL RESULT
.ENVOK3  AIF   ('&TSFAKE' EQ '').ENVOK4
         MNOTE 4,'TSFAKE= DISCONTINUED.  ENV=SIMULATE USED INSTEAD.  CH$
               ANGE YOUR SOURCE'
&ENVSIM  SETB  1                        SET IT
.ENVOK4  AIF   (N'&GETMAIN EQ 2).ENVOK99
         AIF   (N'&GETMAIN EQ 3).ENVOK99
         AIF   ('&MACRO' EQ 'YES').ENVOK99
         AIF   (NOT &ENVSIM).ENVOK5
         AIF   (NOT &ENVCP ).ENVOK5
         MNOTE 4,'ENV=SIM(ULATE) WITH ENV=CP REQUIRES GETMAIN=(LENGTH,D$
               SECT) (OR MACRO=YES)'
&ASMERR  SETB  1                        ASSEMBLY ERRORS WILL RESULT
.ENVOK5  AIF   ('&PL' EQ '').ENVOK99
         MNOTE 4,'PL=&PL WITH ENV=CP REQUIRES GETMAIN=(LENGTH,DSECT) (O$
               R MACRO=YES)'
&ASMERR  SETB  1                        ASSEMBLY ERRORS WILL RESULT
.ENVOK99 AIF   (NOT &ASMERR).ENVOK      SKIP IF NO ASSEMBLY ERRORS
         MNOTE 0,'<<< ASSEMBLY ERRORS WILL RESULT >>>'
.*-----------------------------------*.
.*  ENV=SIMULATE                     *.
.*-----------------------------------*.
.ENVOK   AIF   (NOT &ENVSIM).NOFAKE
.FAKENO  AIF   ('&PARMREG' NE '').OKFAKE0
         MNOTE 4,'*** PARMREG= MUST BE GIVEN IF ENV=SIMULATE IS GIVEN. $
                ENV=SIMULATE IGNORED.'
         AGO   .NOFAKE
.OKFAKE0 AIF   (NOT &ENVCALL).NOFKCAL
&FKCALL  SETB  1
         AGO   .NOFAKE
.NOFKCAL AIF   (NOT &ENVCP).NOFKCP
&FKCP    SETB  1
         AGO   .NOFAKE
.NOFKCP  MNOTE 2,'WHAT TO SIMULATE?????'
.NOFAKE  ANOP
         AIF   (T'&MODE EQ 'O').NOMODE
         AIF   ((N'&MODE GE 2) OR (N'&MODE LE 4)).MODEOK
         MNOTE 0,'INVALID SPECIFICATION OF &&MODE OPERAND'
         AGO   .NOMODE
.MODEOK  ANOP  ,
&MODEBIT SETB  1                        MODE IS OK
.NOMODE  ANOP  ,
.*-----------------------------------*.
.*  SAVE/GETMAIN                     *.
.*-----------------------------------*.
&ZSAVE   SETC  '&SAVE'                  INIT DEFAULT
&GET1    SETC  '&GETMAIN(1)'
&GET2    SETC  '&GETMAIN(2)'
         AIF   ('&MACRO' NE 'YES').OKGET2
         AIF   ('&GET1' NE '').OKGET1
&GET1    SETC  'TSDSECTL'               SET DEFAULT
.OKGET1  AIF   ('&GET2' NE '').OKGET2
&GET2    SETC  'TSDSECT'                SET DEFAULT
.OKGET2  AIF   ('&MACRO' EQ 'YES' OR '&GET1' NE '').GMOK1
         AIF   ('&GETMAIN' EQ '').KEEPSAV
         MNOTE 8,'GETMAIN= CODED INCORRECTLY.  MACRO TERMINATED'
         MEXIT
.KEEPSAV AIF   ('&ZSAVE' EQ '').CHKBASE SAVE AREA NOT USED
         MNOTE *,'<<< GENERATED CODE WILL NOT BE RE-ENTRANT >>>'
         AGO   .CHKBASE
.GMOK1   ANOP
&ZSAVE   SETC  ''                       NO SAVE AREA
.*-----------------------------------*.
.*  BASES                            *.
.*-----------------------------------*.
.CHKBASE AIF   ('&BASE4' EQ '').NOBASE4
         AIF   ('&BASE3' NE '').BASE3
         MNOTE 8,'*** BASE4 IGNORED, INVALID WITHOUT BASE3= ***'
.NOBASE4 AIF   ('&BASE3' EQ '').OKBASES
.BASE3   AIF   ('&BASE2' NE '').OKBASES
         MNOTE 8,'*** BASE3 IGNORED, INVALID WITHOUT BASE2= ***'
.OKBASES AIF   (('&GETMAIN' EQ '') AND ('&MACRO' NE 'YES')).OK1
         AIF   ('&SAVE'   EQ '*').OK1
         AIF   ('&SAVE'    EQ '').OK1
         MNOTE 12,'*** SAVE= MUTUALLY EXCLUSIVE WITH GETMAIN= AND/OR MA$
               CRO=YES.  MACRO TERMINATED ***'
         MEXIT
.OK1     AIF   ('&NFS' NE '').GOTNAME
         MNOTE 12,'*** CSECT NAME OMITTED ***'
.*-----------------------------------*.
.*  SECTYPE=                         *.
.*-----------------------------------*.
.GOTNAME AIF   ('&SECTYPE' NE 'CSECT').NOCSECT
.DOCSECT ANOP
&NFS     CSECT                          OSENTER -- 29May88 -- LDW
         AGO   .SECDONE
.NOCSECT AIF   ('&SECTYPE' NE 'DSECT').NODSECT
&NFS     DSECT                          OSENTER -- 29May88 -- LDW
         AGO   .SECDONE
.NODSECT AIF   ('&SECTYPE' EQ 'NONE').SECNONE
         AIF   ('&SECTYPE' EQ 'ENTRY').ENTRY
       MNOTE 8,'*** SECTYPE=&SECTYPE IS INVALID, SECTYPE=CSECT ASSUMED'
         AGO   .DOCSECT
.ENTRY   ENTRY &NFS
.SECNONE ANOP
*  DEFINE NAME
&NFS     DC    0D'0'                    OSENTER -- 29May88 -- LDW
.*-----------------------------------*.
.*  AMODE=/RMODE=                    *.
.*-----------------------------------*.
.SECDONE AIF   ('&AMODE' EQ '').NOAMODE
&NFS     AMODE &AMODE
.NOAMODE AIF   ('&RMODE' EQ '').NORMODE
&NFS     RMODE &RMODE
.NORMODE ANOP
.*-----------------------------------*.
.*  REGS=                            *.
.*-----------------------------------*.
&Q       SETC  '&REGS(2)'
         AIF   ('&REGS(1)' EQ '' AND '&REGS(2)' NE '').DOREGS
         AIF   ('&REGS(1)' EQ 'NO').NOREGS
         AIF   ('&REGS(2)' NE '').DOREGS
&Q       SETC  'R'
.DOREGS  ANOP
*=====================================================================*
*        REGISTER EQUATES                                             *
         REGEQU  PREFIX=&Q,FR=&F
         SPACE 1
.NOREGS  ANOP
&L       SETA  K'&Q
&R0      SETC  '&Q'.'0'
&R1      SETC  '&Q'.'1'
&R2      SETC  '&Q'.'2'
&R3      SETC  '&Q'.'3'
&R12     SETC  '&Q'.'12'
&R13     SETC  '&Q'.'13'
&R14     SETC  '&Q'.'14'
&R15     SETC  '&Q'.'15'
&L       SETA  K'&REGS(2)
.*-----------------------------------*.
.*  MISC WORKAREA GOODIES            *.
.*-----------------------------------*.
.*%%%%%% AIF   (&ENVCP AND '&PL' NE '').NOGM2   WILL BE GENERATED LATER
         AIF   (&ENVCP).NOGM2           WILL BE GENERATED LATER
         AIF   ('&GET2' EQ '').NOGM2    DSECT NAME OMITTED
&GET2    DSECT
         DS    18F                      SAVE AREA
.* IF ENV=SIMULATE AND ENV=CP THEN GENERATE THE SIMULATION AREA HERE.
         AIF   (NOT (&ENVSIM AND &ENVCP)).NOSIM1
&IHBNX.F DS    A,2H,CL100               AREA FOR FAKE PARM FIELD
.NOSIM1  AIF   (NOT &ENVCP).NO$CPPL
         AIF   ('&PL' EQ '').NOTSECB
TSECB    DS    F
.NOTSECB SPACE 1
*        TSCPPL
         TSCPPL
.*-----------------------------------*.
.*  LOAD=                            *.
.*-----------------------------------*.
.NO$CPPL AIF   ('&LOAD' EQ '').NOLOAD1
&X       SETA  0
.LOADLP1 ANOP
&X       SETA  &X+1
&LOAD(&X) DS   A
         AIF   (&X LT N'&LOAD).LOADLP1
.*-----------------------------------*.
.*  BASE=                            *.
.*-----------------------------------*.
.NOLOAD1 SPACE 3
&NFS     CSECT                          RESUME
.NOGM2   ANOP
&ZBASE   SETC  '&BASE'
         AIF   (&L EQ 0).BASEOK
         AIF   ('&BASE'(1,&L) EQ '&Q').BASEOK
         AIF   (T'&BASE NE 'N').BASEOK
&ZBASE   SETC  '&Q&BASE'
.BASEOK  USING *,&R15                   TEMPORARY BASE
         B     &IHBNX.B                 AROUND GORF
         DROP  &R15                     DROP TEMP BASE
.*-----------------------------------*.
.* SET UP BASE REGISTERS FOR EXIT    *.
.*-----------------------------------*.
         USNGX &NFS,&ZBASE
         AIF   ('&BASE2' EQ '').BASEFIX
         USNGX &NFS+4096,&BASE2
         AIF   ('&BASE3' EQ '').BASEFIX
         USNGX &NFS+8192,&BASE3
         AIF   ('&BASE4' EQ '').BASEFIX
         USNGX &NFS+12288,&BASE4
.BASEFIX ANOP
.*-----------------------------------*.
.* GENERATE USINGS, IF GIVEN         *.
.*-----------------------------------*.
         AIF   (N'&USING LT 1).NOUSING
&X       SETA  1
.USINGLP USNGX &USING(&X),&USING(&X+1)
&X       SETA  &X+2
         AIF   (&X LT N'&USING).USINGLP
.NOUSING ANOP
.*-----------------------------------*.
.*  ID                               *.
.*-----------------------------------*.
         AIF   ('&ID(1)' EQ '*').IDSTAR
         AIF   ('&ID(1)' EQ '' ).IDSTAR
         AIF   ('&ID' EQ '*NONE*').DONEID
         ID    &ID(1),&ID(2),DATE=&DATE,TIME=&TIME
         AGO   .DONEID
.IDSTAR  ID    &NFS,&ID(2),DATE=&DATE,TIME=&TIME
.*-----------------------------------*.
.*  BASE2, BASE3, BASE4              *.
.*-----------------------------------*.
.DONEID  AIF   ('&BASE2' EQ '').NOBASE2
&IHBNX.A DC    A(&NFS+4096)             SECOND BASE REGISTER
         AIF   ('&BASE3' EQ '').NOBASE2
&IHBNX.Z DC    A(&NFS+8192)             LET'S NOT GET CARRIED AWAY...
         AIF   ('&BASE4' EQ '').NOBASE2
&IHBNX.Q DC    A(&NFS+12288)            BUT THIS IS GETTING RIDICULOUS
.NOBASE2 AIF   (('&ZSAVE' NE '*') OR ('&GET1' NE '')).NOSVSTR NO INL SA
.*OBASE2 AIF   ('&ZSAVE' NE '*').NOSVSTR NO INLINE SAVE AREA
&IHBNX.S DC    18F'0'                   SAVE AREA
&ZSAVE   SETC  '&IHBNX.S'
.NOSVSTR AIF   (NOT &ENVSIM OR &ENVCP OR '&GET2' NE '').NOFKY2
&IHBNX.F DC    A(0),2H'0',CL100' '      AREA FOR PHONY PARM FIELD
.*-----------------------------------*.
.*  GETMAIN=                         *.
.*-----------------------------------*.
.NOFKY2  AIF   ('&GET1&GET2' EQ '').NOSPLEN  NO SP & LENGTH
         AIF   ('&BASE2' NE '').BASE2L
.*       DC    0A(0)                    ALIGNMENT
.BASE2L  ANOP                           DON'T NEED ALIGNMENT
.*HBNX.L DC    AL1(&SP),AL3(&GET1)      GETMAIN SP AND LENGTH
&IHBNX.L DC    A(&GET1)                 GETMAIN LENGTH
.NOSPLEN AIF   ('&EXIT' EQ '').NOEXIT
.*-----------------------------------*.
.*  EXIT= AND RC=                    *.
.*-----------------------------------*.
         SPACE 2
*=====================================================================*
&RCRC    SETC  '&RC(1)'
         AIF   ('&RC' NE '').OKRC1
&RCRC    SETC  '&R15'
.OKRC1   AIF   ('&RCLOC' EQ '').OKRC3
         AIF   ('&RC'    EQ '').OKRC2
         MNOTE 0,'*** RC= AND RCLOC= MUTUALLY EXCLUSIVE -- RC= IGNORED'
.OKRC2   ANOP
&RCRC    SETC  '&RCLOC'
.OKRC3   ANOP
&X       SETA  8-K'&RCRC                NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKRCL
&BLANK1  SETC  ''
         AGO   .CHAR8RC
.OKRCL   ANOP
&BLANK1  SETC  '&BLANK1'(1,&X)
.CHAR8RC ANOP
&X       SETA  8-K'&EXIT(1)             NUMBER OF BLANKS NEEDED
         AIF   (&X GT 0).OKEXITL
&BLANK2  SETC  ''
         AGO   .CHAR8EX
.OKEXITL ANOP
&BLANK2  SETC  '&BLANK2'(1,&X)
.CHAR8EX AIF   ('&RC' EQ '').MREGRC
         AIF   ('&RC'(1,1) EQ '(').MREGRC
         MNOTE *,'   BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE=&RCRC  X
                 &BLANK1   &BLANK2    *'
         AGO   .MRCCONT
.MREGRC  MNOTE *,'   BRANCH TO "&EXIT" TO EXIT WITH RETURN CODE IN &RCR$
               C &BLANK1   &BLANK2    *'
.MRCCONT ANOP
*=====================================================================*
&NAME    SETC  '&EXIT'
         AIF   ('&GET2' EQ '').NOXITUS  SKIP IF NO DSECT NAME SUPPLIED
         USING &GET2,&R13
.NOXITUS AIF   ('&IKJRLSA' EQ 'NO').NO$RLSA    SKIP IF HE SAID NO
         AIF   ('&PARSE' EQ '').RLSA$2  CHECK FOR USER SPECIFIED AREA
         AIF   ('&IKJRLSA' EQ ''   ).RLSA$1  CONTINUE IF NAME OK
         AIF   ('&IKJRLSA' EQ 'YES').RLSA$1  CONTINUE IF NAME OK
         MNOTE 8,'IKJRLSA=&IKJRLSA CANNOT BE SPECIFIED WITH PARSE=&PARS$
               E (CODE IKJRLSA=YES/NO OR OMIT IKJRLSA=)'
.RLSA$1  ANOP
*        IKJRLSA  TSPARANS              FREE PARSE'S WORK AREAS
&NAME    IKJRLSA  TSPARANS
         AGO   .RLSA$3                  CONTINUE
.RLSA$2  AIF   ('&IKJRLSA' EQ '').NO$RLSA
*        IKJRLSA  &IKJRLSA              FREE PARSE'S WORK AREAS
&NAME    IKJRLSA  &IKJRLSA
.RLSA$3  SPACE 2
&NAME    SETC  ''
.NO$RLSA ANOP  ,
         AIF   ('&DELETE' EQ '').NODEL    SKIP DELETE SECTION
&X       SETA  1                        INIT TO FIRST ENTRY
.DEL$LP  AIF   ('&DELETE(&X)' EQ '').NODEL  DONE HERE
         AIF   ('&DELETE(&X)' EQ '*').NODELLD   REGULAR
         AIF   (NOT &ENVMVS).YESDEL1
&NAME    OSENT01  &DELETE(&X),IKJPTGT,464,DELETE
&NAME    OSENT01  &DELETE(&X),IKJPUTL,444,DELETE
&NAME    OSENT01  &DELETE(&X),IKJGETL,348,DELETE
&NAME    OSENT01  &DELETE(&X),IKJPARS,524,DELETE
&NAME    OSENT01  &DELETE(&X),IKJDAIR,732,DELETE
&NAME    OSENT01  &DELETE(&X),IKJSTCK,472,DELETE
&NAME    OSENT01  &DELETE(&X),IKJSCAN,480,DELETE
&NAME    OSENT01  &DELETE(&X),IKJEHCIR,740,DELETE
&NAME    OSENT01  &DELETE(&X),IKJEHDEF,736,DELETE
&NAME    OSENT01  &DELETE(&X),IKJEFF02,976,DELETE
.*****  DO ALL OF THESE HAVE THE SAME X'80' = LOADED DEFINITION????
         AIF   (NOT &MVSCVT).YESDEL1    IT WAS NOT ONE OF THE ABOVE
&NAME    SETC  ''                       IT WAS
         AGO   .YESDEL3
.YESDEL1 ANOP  ,
&NAME    OC    &DELETE(&X),&DELETE(&X)  IS IT HERE?
&NAME    SETC  ''
         BZ    *+10                     NO, SKIP DELETE
.YESDEL3 ANOP  ,
&MVSCVT  SETB  0                        RESET FOR LOAD SECTION
         MNOTE *,'       DELETE  EPLOC==CL8''&DELETE(&X)'''
         DELETE  EPLOC==CL8'&DELETE(&X)'
         AGO   .DEL$END                 LOOP AGAIN
.NODELLD ANOP
&Y       SETA  1                        INIT FOR FIRST ENTRY
.DEL$LLP AIF   ('&LOAD(&Y)' EQ '').DEL$END   DONE HERE
         AIF   (NOT &ENVMVS).YESDEL2
&NAME    OSENT01  &LOAD(&X),IKJPTGT,464,DELETE
&NAME    OSENT01  &LOAD(&X),IKJPUTL,444,DELETE
&NAME    OSENT01  &LOAD(&X),IKJGETL,348,DELETE
&NAME    OSENT01  &LOAD(&X),IKJPARS,524,DELETE
&NAME    OSENT01  &LOAD(&X),IKJDAIR,732,DELETE
&NAME    OSENT01  &LOAD(&X),IKJSTCK,472,DELETE
&NAME    OSENT01  &LOAD(&X),IKJSCAN,480,DELETE
&NAME    OSENT01  &LOAD(&X),IKJEHCIR,740,DELETE
&NAME    OSENT01  &LOAD(&X),IKJEHDEF,736,DELETE
&NAME    OSENT01  &LOAD(&X),IKJEFF02,976,DELETE
.*****  DO ALL OF THESE HAVE THE SAME X'80' = LOADED DEFINITION????
         AIF   (NOT &MVSCVT).YESDEL2    IT WAS NOT ONE OF THE ABOVE
&NAME    SETC  ''                       IT WAS
         AGO   .YESDEL4
.YESDEL2 ANOP  ,
&NAME    OC    &LOAD(&Y),&LOAD(&Y)      IS IT HERE?
&NAME    SETC  ''
         BZ    *+10                     NO, SKIP DELETE
.YESDEL4 ANOP  ,
&MVSCVT  SETB  0                        RESET FOR LOAD SECTION
         MNOTE *,'       DELETE  EPLOC==CL8''&LOAD(&Y)'''
         DELETE  EPLOC==CL8'&LOAD(&Y)'
&Y       SETA  &Y+1                     INCR IT
         AGO   .DEL$LLP                 LOOP IT AGAIN
.DEL$END ANOP  ,
&X       SETA  &X+1                     NEXT DELETE
         AGO   .DEL$LP                  LOOP AGAIN
.NODEL   ANOP  ,
         AIF   ('&RCRC' NE '0').RCNOT0
&NAME    XR    &R15,&R15                SET RETURN CODE ZERO
&NAME    SETC  ''
         AGO   .HAVERC
.RCNOT0  AIF   ('&RCLOC' EQ '').NORCLOC RCLOC NOT GIVEN
         AIF   (T'&RCLOC EQ 'F').RCLOCF
         AIF   (T'&RCLOC EQ 'H').RCLOCH
         MNOTE 0,'*** UNKNOWN TYPE FOR RCLOC=&RCLOC -- "F" ASSUMED'
.RCLOCF  ANOP
&NAME    L     &R15,&RCLOC              LOAD RETURN CODE
         AGO   .RCCOM                   GO TO COMMON
.RCLOCH  ANOP
&NAME    LH    &R15,&RCLOC              LOAD RETURN CODE
         AGO   .RCCOM                   GO TO COMMON
.NORCLOC AIF   ('&RC' EQ '').HAVERC     RC IS IN A REG
         AIF   ('&RC'(1,1) EQ '(').HAVERC   DITTO
&NAME    LA    &R15,&RCRC               LOAD RETURN CODE
.RCCOM   ANOP                           COMMON POINT
&NAME    SETC  ''
.HAVERC  AIF   ('&GET1' EQ '').NOWORK1  NO DSA TO FREE
&NAME    LR    &R1,&R13                 COPY DSA PTR
&NAME    SETC  ''
.NOWORK1 AIF   ('&GET2' EQ '').NOWORK2
         DROP  &R13
.NOWORK2 AIF   ('&SAVE' EQ '').NODECHN  SKIP IF NO SAVE AREA TO DECHAIN
&NAME    L     &R13,4(,&R13)            DECHAIN SAVE AREAS
&NAME    SETC  ''
.NODECHN AIF   ('&RC' EQ '').WORKE
         AIF   ('&RC'(1,1) NE '(').NOWORKE
.WORKE   AIF   ('&RCLOC' NE '').NOWORKE STORE R15
         AIF   ('&GET1' EQ '').RCNOT1   RC=(1) IS OK IF NO DYNAMIC AREA
         AIF   (('&RCRC' NE '&R1') AND ('&RCRC' NE '1')).RCNOT1
         MNOTE 4,'YOU TURKEY.  RC=(R1) DOESN''T WORK RIGHT IF YOU HAVE $
               A DYNAMIC AREA'
         MNOTE 0,'... I HOPE YOU INSTALLED ZAP...'
.RCNOT1  ANOP
&NAME    ST    &RCRC,16(,&R13)          SET RETURN CODE
&NAME    SETC  ''
         AGO   .WASRGRC
.NOWORKE ANOP
&NAME    ST    &R15,16(,&R13)           SET RETURN CODE
&NAME    SETC  ''
.WASRGRC ANOP  ,
         AIF   ('&GET1' EQ '').NOWRKE2  NO DSA TO FREE
         L     R0,&IHBNX.L              GET LENGTH TO FREEMAIN
        MNOTE '         FREEMAIN  RU,A=(1),LV=(0),SP=&SP  FREE THE DSA'
         FREEMAIN  RU,A=(1),LV=(0),SP=&SP
.NOWRKE2 LM    &R14,&R12,12(&R13)       RESTORE CALLERS REGS
         AIF   ('&T' NE 'T').BR14
         MVI   12(&R13),X'FF'           FLAG SAVEAREA AS INACTIVE
.BR14    BR    &R14                     RETURN TO CALLER
.NOEXIT  SPACE 3
*=====================================================================*
*    ENTRY CODE                                                       *
*=====================================================================*
&IHBNX.B STM   &R14,&R12,12(&R13)       SAVE CALLER'S REGS
.*-----------------------------------*.
.* SET UP BASE REGISTERS             *.
.*-----------------------------------*.
         LR    &ZBASE,&R15              LOAD BASE REGISTER
         AIF   ('&BASE2' EQ '').BASEFIN
         L     &BASE2,&IHBNX.A          LOAD SECOND BASE REGISTER
.*       USNGX &NFS+4096,&BASE2
         AIF   ('&BASE3' EQ '').BASEFIN
         L     &BASE3,&IHBNX.Z          LOAD BASE3 FOR MLE,BMD,VIC
.*       USNGX &NFS+8192,&BASE3
         AIF   ('&BASE4' EQ '').BASEFIN
         L     &BASE4,&IHBNX.Q          WHAT'S GOING ON HERE???
.*       USNGX &NFS+12288,&BASE4
.BASEFIN ANOP
.*-----------------------------------*.
.* FUTZ WITH THE PARM                *.
.*-----------------------------------*.
&AR      SETC  '&R14'                   SET DEFAULT FOR LENREG=
&LR      SETC  '&R15'                   SET DEFAULT FOR ADDRREG=
         AIF   (('&ADDRREG' EQ '') AND ('&LENREG' EQ '')).NO$AR
         AIF   (('&ADDRREG' NE '') AND ('&LENREG' NE '')).ARLR
         MNOTE 8,'ADDRREG= AND LENREG= MUST BOTH BE GIVEN'
.ARLR    ANOP
&AR      SETC  '&ADDRREG'
&LR      SETC  '&LENREG'
.NO$AR   AIF   ('&PARMREG' EQ '').NOPARMR
         LR    &PARMREG(1),&R1          SAVE PARM POINTER
         AIF   (N'&PARMREG LT 2).NOPARMR
         USNGX &PARMREG(2),&PARMREG(1)
.NOPARMR AIF   ('&LPARM' EQ '').NOLPARM
&NAME    L     &LPARM(1),0(,&R1)        PICK UP PARM POINTER
&NAME    SETC  ''
         AIF   (N'&LPARM LT 2).NOLPRM2
         USNGX &LPARM(2),&LPARM(1)
.NOLPRM2 AIF   (&ENVTSO).NOLPARM
         AIF   ('&ADDRREG' EQ '').NOLPARM
         LH    &LR,0(,&LPARM(1))        GET PARM LENGTH
         LA    &AR,2(,&LPARM(1))        POINT PAST LENGTH
.*-----------------------------------*.
.* GET A SAVE AREA,                  *.
.* EITHER STATIC OR DYNAMIC          *.
.*-----------------------------------*.
.NOLPARM AIF   ('&GET1' EQ '').STATIC
&NAME    L     R0,&IHBNX.L              GET LENGTH TO FREEMAIN
&NAME    SETC  ''
         AIF   ('&GETMLOC' NE '').USELOC
         MNOTE '         GETMAIN  RU,LV=(0),SP=&SP'
         GETMAIN  RU,LV=(0),SP=&SP
         AGO   .NOLOC
.USELOC  MNOTE '         GETMAIN  RU,LV=(0),SP=&SP,LOC=(&GETMLOC(1),&GE$
               TMLOC(2))'
         GETMAIN  RU,LV=(0),SP=&SP,LOC=(&GETMLOC(1),&GETMLOC(2))
*
.NOLOC   AIF   ('&GETMAIN(3)' NE 'ZERO').USE1
         XC    0(18*4,R1),0(R1)         clear save area in dyn area
.USE1    ST    &R1,8(,&R13)             FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R1)             BACK CHAIN SAVE AREAS
         LR    &R13,&R1                 GET NEW SAVE AREA ADDR
         AIF   ('&GETMAIN(3)' NE 'ZERO').NOZERO2
         LA    R14,18*4(,R1)            -> start of area to zero
         L     R15,&IHBNX.L             get length of dynamic area
         LA    R1,18*4                  amount already zeroed
         SR    R15,R1                   remaining length to clear
         BNP   *+8    >=====+           skip if nothing left
         SR    R1,R1        |           set source length = 0
         MVCL  R14,R0       V           clear dynamic area
.NOZERO2 AIF   ('&GET2' EQ '').CONT3
         USNGX &GET2,&R13
         AGO   .CONT3
.*-----------------------------------*.
.* CHAIN SAVE AREAS                  *.
.*-----------------------------------*.
.STATIC  AIF   ('&SAVE' EQ '').CONT3    NO SAVE AREA TO BE USED AT ALL
         AIF   ('&PARMREG(1)' NE '&R15').NOT15
&NAME    LA    &R1,&ZSAVE               GET SAVE AREA ADDR
&NAME    SETC  ''
         AGO   .USE1
.NOT15   LA    &R15,&ZSAVE              GET SAVE AREA ADDR
         ST    &R15,8(,&R13)            FORW CHAIN SAVE AREAS
         ST    &R13,4(,&R15)            BACK CHAIN SAVE AREAS
         LR    &R13,&R15                GET NEW SAVE AREA ADDR
.CONT3   AIF   ('&RCLOC' EQ '').CONT3B
         XC    &RCLOC,&RCLOC            INIT RCLOC TO ZERO
.CONT3B  SPACE 3
         AIF   (NOT &ENVCP).NMVCPPL
         MVC   CPPL(CPPLL),0(&PARMREG(1)) COPY CPPL TO SAFE PLACE
.NMVCPPL AIF   (&FKCALL OR &FKCP).FAKE$A
         AIF   ('&ADDRREG' EQ '').LOAD
         AIF   (&ENVTSO).FAKE$A
         L     &AR,0(,&PARMREG(1))      POINT TO PARM (LENGTH)
         LH    &LR,0(,&AR)              GET PARM LENGTH
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AGO   .INUSE
.FAKE$A  SPACE 2
*  DETERMINE WHETHER WE HAVE BEEN CALLED AS A TSO CP OR THRU CALL
         SPACE 1
         AIF   (NOT &MODEBIT).NOMOD01
         MVI   &MODE(1),0               CLEAR FLAG
.NOMOD01 ANOP  ,
         L     &R1,16                   -> CVT
         L     &R1,0(,&R1)              -> DISPATCH
         L     &R1,4(,&R1)              -> TCB
         L     &R1,180(,&R1)            -> JSCB
         L     &R1,264(,&R1)            -> PSCB
         LA    &R0,0(,&R1)              CLEAR HIGH BYTE
         LTR   &R0,&R0                  ANY PSCB?
         BZ    &IHBNX.E                 NO - JUMP AROUND NEXT CHECK
         L     &R1,8(,&PARMREG(1))      POSSIBLE PSCB PTR
         LA    &R1,0(,&R1)              CLEAR HIGH BYTE
         TM    0(&PARMREG(1)),X'80'     ONLY 1 PARM?
         BO    &IHBNX.E                 YES - // EXEC OR TSO CALL
         AIF   (NOT &MODEBIT).NOMOD02
         AIF   (N'&MODE NE 4).NOMOD02   IF NOT FOR CP, IGNORE
         MVI   &MODE(1),&MODE(4)        ASSUME CP
.NOMOD02 ANOP  ,
         CR    &R0,&R1                  THIRD PARM -> PSCB?
         AIF   (('&ADDRREG' NE '') OR (&FKCALL)).SETCPR
         BE    &IHBNX.C                 YES - WERE CALLED AS A TSO CP
         AGO   .CONT5                   SKIP AROUND
.SETCPR  BNE   &IHBNX.E                 NO - NOT TSO CP
         SPACE 2
*  HAVE BEEN CALLED AS A CP
         SPACE 1
         AIF   ('&ADDRREG' EQ '').NO$AR2
         L     &R1,0(,&PARMREG(1))      CBUF PTR
         LH    &LR,0(,&R1)              LENGTH OF CBUF
         LH    &AR,2(,&R1)              OFFSET TO FIRST NON-BLANK
         LA    &LR,0(&LR,&R1)           POINT PAST CBUF
         LA    &AR,4(&AR,&R1)           POINT TO FIRST NON-BLANK
         SR    &LR,&AR                  LENGTH OF PARMS
.NO$AR2  AIF   (&FKCALL).CONT4
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.*
.CONT4   AIF   (NOT &FKCALL).NOFAKE1
.*-----------------------------------*.
.*  FAKE A CALL                      *.
.*-----------------------------------*.
         STH   &LR,&IHBNX.F+4           SET FAKED LENGTH OF PARM
         LTR   &R1,&LR                  COPY LENGTH
         CH    &R1,=H'100'              PARM TOO BIG?
         BNH   *+8                      NO - OK
         LA    &R1,=H'100'              TOO BIG - USE TRUNCATE AT MAX
         LTR   &R1,&R1                  TEST PARM LENGTH
         BNP   *+16                     SKIP IF NO PARM       >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              |
         EX    &R1,*+4                  MOVE THE PARM TO WORKAREA   |
         MVC   &IHBNX.F+6(0),0(&AR)     << EXECUTED >>              |
         LA    &R1,&IHBNX.F+4           GET FAKE PARM ADDR    <=====+
         ST    &R1,&IHBNX.F             STORE IT
         LA    &PARMREG(1),&IHBNX.F     GET ADDR OF FAKED PARM
         MVI   &IHBNX.F,X'80'           SET END OF LIST BIT
         B     &IHBNX.C                 CONTINUE
         AGO   .CONT5
.NOFAKE1 AIF   (NOT &FKCP).LOAD
.CONT5   SPACE 2
*  HAVE BEEN CALLED FROM BATCH, OR TSO CALL
         SPACE 1
&IHBNX.E L     &AR,0(,&PARMREG(1))      POINT TO PARM LENGTH
         LH    &LR,0(,&AR)              GET LENGTH OF PARM
         LA    &AR,2(,&AR)              POINT PAST LENGTH
         AIF   (NOT &FKCP).NOFAKE2
*  CPPL=ADDR(CBUF,UPT,PSCB,ECT)
         LA    &R1,&IHBNX.F             GET ADDR OF FAKE CBUF
         ST    &R1,CPPLCBUF             SET INTO CPPL
         AIF   (NOT &MODEBIT).NOMOD03
         AIF   (N'&MODE LT 3).NOMOD03   IF NOT FOR CP, IGNORE
         MVI   &MODE(1),&MODE(3)        ASSUME TSO CALL
.NOMOD03 ANOP  ,
         LTR   &R1,&R0                  COPY PSCB ADDR
         BNZ   &IHBNX.T                 CONTINUE IF IT EXISTS
         SPACE 2
*  THE ENVIRONMENT AT THIS POINT IS BATCH (NOT TMP IN BACKGROUND)
         AIF   (NOT &MODEBIT).NOMOD04
         MVI   &MODE(1),&MODE(2)        MUST BE BATCH
.NOMOD04 ANOP  ,
         XC    &IHBNX.F(256),&IHBNX.F   CLEAR FIRST PART OF PHONY AREA
         XC    &IHBNX.F+256(&IHBNX.K-256),&IHBNX.F+256   AND THE REST
         LA    &R0,&IHBNX.P             -> PHONY PSCB
         ST    &R0,CPPLPSCB             SET INTO FAKE CPPL
         LA    &R0,&IHBNX.U             -> PHONY UPT
         ST    &R0,&IHBNX.P+52          SET INTO FAKE PSCB
.*10-81  MVI   &IHBNX.P+57,L'&IHBNX.U   SET LEN OF UPT IN PSCB
         MVI   &IHBNX.P+57,&LQ&IHBNX.U  SET LEN OF UPT IN PSCB
         OI    &IHBNX.U+12,X'40'        SET FLAG: NO PROMPTING
         LA    &R1,&IHBNX.V             -> PHONY ECT
         B     &IHBNX.X
         SPACE 2
&IHBNX.T ST    &R0,CPPLPSCB             SET INTO FAKE CPPL
         MVC   CPPLUPT(4),52(&R1)       MOVE UPT ADDR INTO CPPL
         L     &R1,48(,&R1)             PSCB.RLGB
         L     &R1,256(,&R1)            RLGB.ECT
&IHBNX.X ST    &R1,CPPLECT              SET ECT ADDR IN CPPL
         SPACE 1
*  CBUF=Y(CBUF_LEN,OFFSET_TO_NONBLANK),C'CMDNAME',C' ',C'OPERANDS'
         MVC   &IHBNX.F+4(8),12(&R1)    MOVE CMD NAME TO CBUF
         MVI   &IHBNX.F+4+8,C' '        PUT IN DELIMETER
         NI    28(&R1),X'7F'            TURN OFF "NO OPERANDS" BIT
         LTR   &LR,&LR                  ANY OPERANDS?
         BP    *+8                      YES - SKIP
         OI    28(&R1),X'80'            SET "NO OPERANDS" BIT IN ECT
         SPACE 1
         LA    &R1,8+1                  OFFSET TO FIRST NON-BLANK
         STH   &R1,&IHBNX.F+2           SET IN FAKE CBUF
         LA    &R0,8+1+4(,&LR)          GET LENGTH OF CBUF
         STH   &R0,&IHBNX.F             SET INTO FAKE CBUF
         LTR   &R1,&LR                  ANY OPERANDS?
         BNP   *+16                     NO - SKIP             >=====+
         BCTR  &R1,0                    -1 FOR EXECUTE              |
         MVC   &IHBNX.F+4+8+1(0),0(&AR) << EXECUTED >>              |
         EX    &R1,*-6                  MOVE THE PARM TO FAKE CBUF  |
         LA    &PARMREG(1),CPPL         POINT TO CPPL         <=====+
.NOFAKE2 SPACE 2
&NAME    SETC  '&IHBNX.C'
.*-----------------------------------*.
.*  LOAD=                            *.
.*-----------------------------------*.
.LOAD    AIF   ('&LOAD' EQ '').NOLOAD
&X       SETA  1
.LOAD$LP AIF   ('&LOAD(&X)' EQ '').NOLOAD
         AIF   (NOT &ENVMVS).YESLOAD
&NAME    OSENT01  &LOAD(&X),IKJPTGT,464
&NAME    OSENT01  &LOAD(&X),IKJPUTL,444
&NAME    OSENT01  &LOAD(&X),IKJGETL,348
&NAME    OSENT01  &LOAD(&X),IKJPARS,524
&NAME    OSENT01  &LOAD(&X),IKJDAIR,732
&NAME    OSENT01  &LOAD(&X),IKJSTCK,472
&NAME    OSENT01  &LOAD(&X),IKJSCAN,480
&NAME    OSENT01  &LOAD(&X),IKJEHCIR,740
&NAME    OSENT01  &LOAD(&X),IKJEHDEF,736
&NAME    OSENT01  &LOAD(&X),IKJEFF02,976                            SDM
.*****  DO ALL OF THESE HAVE THE SAME X'80' = LOADED DEFINITION????
         AIF   (NOT &MVSCVT).YESLOAD    IT WAS NOT ONE OF THE ABOVE
&NAME    SETC  ''                       IT WAS
.YESLOAD MNOTE *,'       LOAD  EPLOC==CL8''&LOAD(&X)'''
&NAME    LOAD  EPLOC==CL8'&LOAD(&X)'
&NAME    SETC  ''
.ADDRSAV ST    &R0,&LOAD(&X)
.SKIPASV SPACE 1
         AIF   ('&LOAD(&X)' NE 'IKJDAIR').NO$DAIR
&GDAIR   SETB  1                        DAIR LOADED
         AGO   .LOADNXT
.NO$DAIR AIF   ('&LOAD(&X)' NE 'IKJPARS').NO$PARS
&GPARSE  SETB  1                        PARSE WAS LOADED
&PARNAME SETC  'IKJPARS'
.NO$PARS ANOP
.LOADNXT ANOP
&X       SETA  &X+1
         AGO   .LOAD$LP
.*-----------------------------------*.
.*  PL=                              *.
.*-----------------------------------*.
.NOLOAD  AIF   ('&PL' EQ '').NO$PL$1
&X       SETA  1
.PLLOOP  AIF   ('&PL(&X)' NE 'CSCAN').PL2
&CSPL    SETB  1
         AGO   .PLNEXT
.PL2     AIF   ('&PL(&X)' NE 'PARSE').PL3
&PARS    SETB  1
         AGO   .PLNEXT
.PL3     AIF   ('&PL(&X)' NE 'DAIR').PL4
&DAIR    SETB  1
         AGO   .PLNEXT
.PL4     AIF   ('&PL(&X)' NE 'IO').PL5
&IO      SETB  1
         AGO   .PLNEXT
.PL5     AIF   ('&PL(&X)' NE 'MESSAGE').PL6
&MSG     SETB  1
         AGO   .PLNEXT
.PL6     MNOTE 4,'PL=&PL(&X) UNKNOWN -- IGNORED'
.PLNEXT  ANOP
&X       SETA  &X+1
         AIF   (&X LE N'&PL).PLLOOP
.*
.*
.NO$PL$1 AIF   ('&PARSE(2)' EQ '').PLNOTM
&MSG     SETB  1
.PLNOTM  AIF   (NOT (&CSPL OR &PARS OR &DAIR OR &IO OR &MSG)).NOSETPL
&NAME    L     &R1,CPPLUPT              GET UPT PTR
&NAME    SETC  ''
         L     &R2,CPPLECT              GET ECT PTR
         LA    &R3,TSECB                GET ECB PTR
         SR    &R0,&R0                  GET A 0
         ST    &R0,TSECB                CLEAR ECB
.*
         AIF   (NOT &CSPL).NOSETC
         SPACE 1
         STM   &R1,&R3,CSPL             INITIALIZE CSPL (UPT, ECT, ECB)
         ST    &R0,CSFLG                ZERO CSFLG
         LA    &R0,CSFLG
         ST    &R0,CSPLFLG
         LA    &R0,CSOA
         ST    &R0,CSPLOA
.*
.NOSETC  AIF   (NOT &PARS).NOSETP
         STM   &R1,&R3,PPL              INITIALIZE PPL (UPT, ECT, ECB)
         LA    &R0,TSPARANS             PTR TO PARSE ANSWER PLACE
         ST    &R0,PPLANS
         ST    &R13,PPLUWA              PARSE USER WORK AREA PTR
         XC    TSPARANS(4),TSPARANS     AVOID DUPLICATE IKJRLSA
.*
.NOSETP  AIF   (NOT &DAIR).NOSETD
         STM   &R1,&R3,DAPL             INITIALIZE DMPL (UPT, ECT, ECB)
         MVC   DAPLPSCB(4),CPPLPSCB
.*
.NOSETD  AIF   (NOT &IO).NOSETI
         STM   &R1,&R3,IOPL             INITIALIZE IOPL (UPT, ECT, ECB)
.*
.NOSETI  AIF   (NOT &MSG).NOSETM
         ST    &R3,MPLECB               INIT MPL ECB PTR
         LA    &R0,CPPL
         ST    &R0,MPLCPPL
         LA    &R0,MPLCSECT             PTR TO MSG CSECT
         ST    &R0,MPLCSECP
         XC    MPLSW(MPLZL),MPLSW       INITIALIZE REMAINING MPL TO 0
.NOSETM  ANOP
.NOSETPL AIF   ('&PARSE(1)' EQ '').NOPARSE
         SPACE 2
***********************************************************************
*                                                                     *
*  PARSE THE COMMAND LINE                                             *
*                                                                     *
***********************************************************************
         SPACE 2
         MNOTE *,'       TSPARSE CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I$
               ),'
         MNOTE *,'               SYNAD=&PARSE(2),ENTRY=&PARNAME'
         TSPARSE  CBUF=(CPPLCBUF,I),PCL=(=V(&PARSE(1)),I),             $
               SYNAD=&PARSE(2),ENTRY=&PARNAME
&NAME    SETC  ''
         SPACE 5
         AIF   ('&PARSE(2)' EQ '').NOPARSE   NO ERROR ANALYSIS ROUTINE
&NAME    SETC  '&IHBNX.P'
         SPACE 2
         B     &NAME                    SKIP AROUND PARSE ERR ANALYSIS
         SPACE 6
***********************************************************************
*                                                                     *
*  PARSE ERROR ANALYSIS SUBROUTINE                                    *
*                                                                     *
***********************************************************************
         TSPARERR
         SPACE 6
.NOPARSE AIF   ('&NAME' EQ '').NONAME
&NAME    DS    0H
.NONAME  ANOP
.INUSE   INUSE
         SPACE 2
         AIF   ('&PL' EQ '' AND NOT &ENVCP).MEND
         AIF   ('&GET2' NE '' OR '&MACRO' EQ 'YES').PLOK1
         MNOTE 8,'*** PL= INVALID WITHOUT SECOND OPERAND OF GETMAIN='
         MEXIT
.PLOK1   EJECT
&GET2    DSECT
         DS    18F                      SAVE AREA
         AIF   ('&PL' EQ '').NO$PL$2
TSECB    DS    F                        ECB FOR TSO SERVICES
.NO$PL$2 SPACE 2
*        TSCPPL
         TSCPPL
         AIF   (NOT &ENVSIM).NOFAKED
&IHBNX.F DS    2H,CL256                 AREA FOR FAKE CBUF
&IHBNX.P DS    XL72                     AREA FOR PHONY PSCB
&IHBNX.V DS    XL40                     AREA FOR PHONY ECT
&IHBNX.U DS    XL24                     AREA FOR PHONY UPT
&IHBNX.K EQU   *-&IHBNX.F               LENGTH OF PHONY BLOCKS TO CLEAR
.NOFAKED AIF   ('&PL' EQ '').NO$PL$3
         AIF   ('&PRINT' NE 'NOGEN').YESGEN1
         PRINT NOGEN                    SUPPRESS THE DSECTS
.YESGEN1 AIF   (NOT &CSPL).NOTCSPL
         SPACE 2
         MNOTE *,'       TSCSPL'
         TSCSPL
.NOTCSPL AIF   (NOT &PARS).NOTPARS
         SPACE 2
         MNOTE *,'       TSPPL'
         TSPPL
.NOTPARS AIF   (NOT &DAIR).NOTDAIR
         SPACE 2
         MNOTE *,'       TSDAPL'
         TSDAPL
DAPBAREA DS    22F                      AREA FOR DAIR PARAMETER BLOCK
         SPACE 2
         MNOTE *,'       TSDMPL'
         TSDMPL
.NOTDAIR AIF   (NOT &IO).NOTIO
         SPACE 2
         MNOTE *,'       TSIOPL'
         TSIOPL
.NOTIO   AIF   (NOT &MSG).NOTMSG
         SPACE 2
         MNOTE *,'       TSMPL'
         TSMPL
.NOTMSG  AIF   ('&PRINT' NE 'NOGEN').NOTMSGX
         PRINT GEN
.NO$PL$3 ANOP  ,
.NOTMSGX AIF   ('&LOAD' EQ '').NOLOAD2
         SPACE 2
&X       SETA  1
.NXTLOAD AIF   (&X GT N'&LOAD).NOLOAD2
&LOAD(&X) DS   A
&X       SETA  &X+1
         AGO   .NXTLOAD
.NOLOAD2 SPACE 2
         AIF   ('&MACRO' NE 'YES').NOMACRO
         SPACE 3
***********************************************************************
*                                                                     *
*  DYNAMIC STORAGE DEFINED BY USER TSWORK MACRO                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TSWORK
         SPACE 2
&GET1    EQU   *-&GET2                  LNTH OF DYNAMIC AREA TO GETMAIN
         SPACE 2
.NOMACRO AIF   (NOT &DAIR).NODAPBS
         AIF   (&GDAIRM).NODAPBS
&GDAIRM  SETB  1
         AIF   ('&PRINT' NE 'NOGEN').GEN4
         PRINT NOGEN                    SAVE SOME PAPER
.GEN4    EJECT
         MNOTE *,'       IKJDAP08'
         IKJDAP08
DAPB08L  EQU   *-DAPB08
         SPACE 5
         MNOTE *,'       IKJDAP18'
         IKJDAP18
DAPB18L  EQU   *-DAPB18
         SPACE 5
         MNOTE *,'       IKJDAP1C'
         IKJDAP1C
DAPB1CL  EQU   *-DAPB1C
         SPACE 5
         MNOTE *,'       IKJDAP30'
         IKJDAP30
DAPB30L  EQU   *-DAPB30
         AIF   ('&PRINT' NE 'NOGEN').NODAPBS
         PRINT GEN                      RESTORE
         SPACE 10
.NODAPBS ANOP
&NFS     CSECT
         SPACE 3
.MEND    MEND
