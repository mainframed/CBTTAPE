COPYPACK CSECT
*  MODIFIED 06/15/88 TO INSERT THE VOLID OF THE TOPACK INTO THE     NWK
*   FORMAT1 DSCB OF THE TARGET DATASET.  THE UNMODIFIED PROGRAM     NWK
*   USUALLY INSERTS THE VOLID OF THE FROMPACK.  S.GOLOB - NEWSWEEK. NWK
***********************************************************************
*****  COPYPACK IS DESIGNED TO COPY ALL THE PS, DA, AND PO DATA   *****
*****  SETS FROM ONE DISK PACK TO ANOTHER PACK.                   *****
*****  THE RECEIVING VOLUME SHOULD BE A CLEAN PACK, WITH A VTOC   *****
*****  OF THE CORRECT SIZE, AND IT SHOULD BE PUT IN MOUNT STATUS  *****
*****  (TO PREVENT DISMOUNTING OR THE ALLOCATION OF TEMPORARY     *****
*****  DATA SETS BY THE SYSTEM).                                  *****
*****                                                             *****
*****                                                             *****
*****  COPYPACK REQUIRES THE FOLLOWING:                           *****
*****     1. CORE-- WITH CURRENT DEDICATED TABLE SIZES            *****
*****               REGION=86K (2314 COPY)  REGION=96K (3330 COPY)*****
*****                                                             *****
*****     2. DDCARDS:                                             *****
*****         FROMPACK- ALLOCATION FOR DISK PACK FROM WHICH       *****
*****            DATA SETS WILL BE COPIED.                        *****
*****     EX-  //FROMPACK DD DISP=SHR,UNIT=3330,VOL=SER=TST003    *****
*****         TOPACK- ALLOCATION FOR DISK PACK TO WHICH DATA SETS *****
*****            ARE TO BE COPIED.                                *****
*****     EX-  //TOPACK  DD  DISP=SHR,UNIT=3330,VOL=SER=NEW003    *****
*****         GOODCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-     *****
*****            CODED IN PROGRAM. INDICATES ALL DATA SETS (AND   *****
*****            MEMBERS FOR A PDS) WHICH WERE COPIED CORRECTLY.  *****
*****         BADCOPY- SYSOUT DATA SET. DCB VALUES ARE HARD-CODED *****
*****            IN PROGRAM. INDICATES ALL DATA SETS (AND MEMBERS *****
*****            FOR A PDS) WHICH COULD NOT BE COPIED. A 2-DIGIT  *****
*****            ERROR CODE ACCOMPANIES EACH ENTRY.               *****
*****                                                             *****
*****                                                             *****
*****  OPTIONAL FEATURES ARE AS FOLLOWS:                          *****
*****     1. DELETES DD CARD-THIS IS AN UNBLOCKED DATA SET (RECFM *****
*****         = F OR U) WITH A BLOCKSIZE OF AT LEAST 44 BYTES.    *****
*****         IT IS USED TO OPTIONALLY SPECIFY ONE OR MORE DATA   *****
*****         SETS WHICH SHOULD NOT BE COPIED TO 'TOPACK'. EACH   *****
*****         RECORD SHOULD CONTAIN THE FULLY QUALIFIED DS NAME   *****
*****         LEFT-JUSTIFIED AND BLANK FILLED THROUGH THE 1ST 44  *****
*****         BYTES. MULTIPLE ENTRIES MUST BE IN THE SAME ORDER   *****
*****         AS THE DSCBS ARE FOUND IN THE VTOC ON 'FROMPACK'.   *****
*****     EX-  //DELETES  DD  *,DCB=BLKSIZE=80                    *****
*****          FOGZ.DONT.COPY.THIS.DATASET.G0001V00        COMMENT*****
*****          /*                                                 *****
*****                                                             *****
*****     2. PARM FIELD-- COPYPACK ACCEPTS 3 POSITIONAL PARAMETERS*****
*****            A) SUBFIELD 1- SPECIFIES WHETHER OR NOT MODEL    *****
*****                DSCBS WILL BE 'COPIED' TO THE NEW VOLUME     *****
*****                AND WHETHER OR NOT THE 'AUTOMATIC RECATALOG' *****
*****                FEATURE IS DESIRED.                          *****
*****                                                             *****
*****                'YN,' OR ',' IS DEFAULT, COPY MODEL DSCBS    *****
*****                   AND NO RECATALOG.                         *****
*****                'N-,' IS DON'T COPY MODEL DSCBS.             *****
*****                '-Y,' IS HAVE AUTOMATIC RECATALOG.           *****
*****                'Y,' IS YES; 'N,' FOR NO (DEFAULT IS YES ',')*****
*****            B) SUBFIELD 2- INDICATES ON WHAT BASIS PDS       *****
*****                DIRECTORIES WILL BE ALLOCATED ON THE NEW PACK*****
*****                'SAME,' IMPLIES THE DIRECTORY WILL BE THE SAME****
*****                SIZE AS ON THE ORIG PACK. 'USED,' MEANS THAT *****
*****                THE DIRECTORY WILL BE ALLOCATED AS--         *****
*****                   NEWDIR = (USED BLKS IN OLDDIR)*1.1  TRUNC *****
*****                THE DEFAULT VALUE (',') IS 'SAME,'           *****
*****            C) SUBFIELD 3- WHILE COPYPACK NORMALLY COPIES ALL*****
*****                DATA SETS FOUND IN TOPACK'S VTOC, ONE CAN    *****
*****                SPECIFY A CERTAIN DS TO START AND/OR END WITH*****
*****                FOR THIS FIELD, SPECIFY 'SSSSS*EEEEE*' WHERE *****
*****            SSSSS IS THE FULLY QUALIFIED STARTING DS NAME    *****
*****            EEEEE IS THE FULLY QUALIFIED ENDING DS NAME.     *****
*****         THE DEFAULT VALUE FOR BOTH SSSSS AND EEEEE IS '¬'   *****
*****         (UPPER CASE 'G' ON THE KEYPUNCH), WHICH IMPLIES TO  *****
*****         START WITH THE 1ST DS IN THE VTOC/ END WITH THE     *****
*****         LAST DS IN THE VTOC -- RESPECTIVELY.                *****
*****                                                             *****
*****         SUBFIELD 3 MAY BE USED INSTEAD TO INDICATE A GROUP  *****
*****         OF SIMILARLY-NAMED DATA SETS TO COPY. FOR THIS      *****
*****         FUNCTION, SPACIFY 'DD...D**' (NOTE 2 ASTERISKS). ALL*****
*****         OF FROMPACK IS SEARCHED AND ONLY THOSE NAMES THAT   *****
*****         BEGIN WITH 'DD...D' ARE COPIED. USE AS LITTLE OR AS *****
*****         MUCH DSNAME QUALIFICATION AS IS DESIRED.            *****
*****                                                             *****
*****     NOTE-- IF A PARM FIELD IS PRESENT, ALL 3 SUBFIELDS MUST *****
*****            BE SPECIFIED- EITHER BY DEFAULT OR EXPLICITELY   *****
*****                                                             *****
*****     PARM EX'S- PARM=',USED,¬*¬*'     PARM='N,,FOGZ.X*¬*'    *****
*****     PARM=',,¬*FOGZ.END*'  PARM=',,¬*¬*' (SAME AS NO PARM)   *****
*****     PARM=',,A**' (ONLY DSNAMES THAT BEGIN W/ 'A')           *****
*****     PARM=',,BACZ**' (ONLY DSNAMES THAT BEGIN W/ 'BACZ')     *****
*****     PARM=''BACZ.**' (ONLY DSNAMES WHOSE HIGH LEVEL INDEX IS *****
*****         'BACZ'- THIS IS NOT NECESSARILY THE SAME AS ABOVE)  *****
*****                                                             *****
*****                                                             *****
*****                                                             *****
***** PROGRAM ERROR CODES AND BADCOPY ERROR VALUES ARE AS FOLLOWS *****
*****                                                             *****
*****          FATAL ERRORS  (COPYPACK RETURN CODES)              *****
*****                                                             *****
*****              04  MISSING GOODCOPY DD CARD                   *****
*****              08  MISSING BADCOPY DD CARD                    *****
*****              12  MISSING TOPACK DD CARD                     *****
*****              16  MISSING FROMPACK DD CARD                   *****
*****              20  THIS RETURN CODE IS NO LONGER USED.        *****
*****              24  TO AND/OR FROM DEVICE NOT DIRECT ACCESS    *****
*****              28  PERM I/O ERROR READING FROMPACK VTOC       *****
*****              32  START DS NOT FOUND IN FROMPACK VTOC        *****
*****              36  PERM I/O ERROR FOR GOODCOPY OR BADCOPY     *****
*****                  SEE HARDCOPY LOG FOR BUFFERS' CONTENTS     *****
*****              40  INVALID OR INCORRECT PARM FIELD            *****
*****                                                             *****
*****                                                             *****
*****           'BADCOPY' DATA SET ERROR CODES                    *****
*****                                                             *****
*****  X'00' I/O ERROR. INDICATORS FOLLOW-  D AAA CCCHHRR MM..M   *****
*****        WHERE 'D' IS EITHER 'T' OR 'F' TO INDICATE A READ    *****
*****            ERROR ON FROMPACK OR A WRITE ERROR ON TOPACK     *****
*****              'AAA' IS THE UNIT ADDR                         *****
*****              'CCCHHRR' IS THE CYL, HEAD, AND RECORD ADDR    *****
*****            WHERE THE ERROR OCCURRED                         *****
*****        AND   'MM..M' IS A MESSAGE DESCRIBING THE ERROR      *****
*****  X'04' ALLOCATION.  DUPLICATE NAME IN TOPACK VTOC           *****
*****  X'08' ALLOCATION. NO ROOM AVAILABLE IN TOPACK VTOC         *****
*****  X'0C' ALLOCATION. PERM I/O ERROR READING/UPDATING VTOC     *****
*****  X'10' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****
*****  X'14' ALLOCATION. REQUESTED SPACE NOT AVAILABLE ON TOPACK  *****
*****  X'18' AVG REC LNGTH .GT. 65K BYTES. PROBABLE PROG ERROR    *****
*****  X'1C' SYSTEM DATA SET. NOT COPIED                          *****
*****  X'20' UNMOVABLE DATA SET ORGANIZATION                      *****
*****  X'24' DATA SET USES TRK OVERFLOW, BLKSIZE .GT. FULL TRK    *****
*****  X'28' MULTI-VOL DS. TOPACK VTOC COULD NOT BE UPDATED       *****
*****         CORRECTLY TO PRESERVE MULT-VOL STATUS. DS EXISTS.   *****
*****  X'2C' INVALID DCB VALUE IN BLKSIZE FIELD                   *****
*****  X'30' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****
*****  X'34' ALLOCATION. INV REQUEST. PROBABLE PROG ERROR         *****
*****  X'38' ALLOCATION.  DIRECTORY SIZE .GT. PRIMARY SPACE OR    *****
*****        .GT. LARGEST AREA ON PACK                            *****
*****  X'3C' ABSTRK ALLOCATION                                    *****
*****  X'40' INVALID EXTENT INFORMATION IN FMT1 DSCB              *****
*****  X'44' INVALID DSORG (IS OR UNDEFINED)                      *****
*****  X'48' PDS HAS MORE USED DIRECTORY BLKS THAN PGM CAN HANDLE *****
*****              (VALUE DEFINED BY MAXBLOKS)                    *****
*****  X'4C' PDS HAS MORE MEMBERS THAN PGM CAN HANDLE             *****
*****              (VALUE DEFINED AS 20*MAXBLOKS)                 *****
*****  X'50' PDS HAS MORE ALIASES THAN PGM CAN HANDLE             *****
*****               (VALUE IS DEFINED BY MAXALIAS)                *****
*****  X'54' PDS MEMBER. ERROR IN STOWING DIRECTORY ENTRY         *****
*****  X'58' PDS ALIAS. ALIAS TTRN COUNT.NE.MAIN MEMBER TTRN COUNT*****
*****  X'5C' PDS IS NULL (NO MEMBER ENTRIES IN DIRECTORY)         *****
*****  X'60' UNEXPECTED RETURN CODE IN BDAM COPY ROUTINE          *****
*****  X'64' PROGRAM ASKED NOT TO COPY THIS DATASET VIA 'DELETES' *****
*****  X'68' PDS ALIAS. MAIN MEMBER WAS NOT COPIED SUCCESSFULLY   *****
*****  X'6C' PDS CONTAINS MORE TTR FIELDS THAN PGM CAN HANDLE     *****
*****               (VALUE IS DEFINED BY MAXTTRNS)                *****
*****  X'70'  NOTELIST RECORD(S) NOT SUCCESSFULLY UPDATED.        *****
*****  X'74' MODEL DSCB. PGM ASKED NOT TO COPY IT VIA PARM VALUE N*****
*****  X'78' TRUNCATION ERROR. BLOCK TOO BIG FOR TOPACK.          *****
*****  X'7C' BDAM COPY ONLY. FROM AND TO DEVICES ARE DIFFERENT.   *****
*****  X'80' AUTOMATIC RECAT FAILED.  DS COPIED SUCCESSFULLY.     *****
*****                                                             *****
***********************************************************************
         EJECT
MAXBLOKS EQU   350                MAXIMUM PDS DIRECTORY SIZE
MAXALIAS EQU   500                MAXIMUM ALIAS NAMES IN PDS
MAXENTRY EQU   20*MAXBLOKS        SHOULD NOT BE .GT. 2*X'FFF'
MAXTTRNS EQU   35                 SHOULD NOT BE .GT. 63
         SAVE  (14,12)
         BALR  R12,0
         USING *,R12
         SPACE 5
***********************************************************************
*****    NOTE--  STARTING AT COPYPACK+8, ABOUT 800 BYTES OF ONE-  *****
*****    TIME ONLY CODE WILL BE OVERLAID BY JFCBS AND I/O BUFFERS *****
*****                                                             *****
*****    INCREMENTAL IMPROVERS ARE CAUTIONED TO FULLY EXAMINE THE *****
*****    BUFFERS DESCRIBED AT LABEL 'OVERLAY' BEFORE ALTERING ANY *****
*****    OF THE ONE TIME ONLY CODE                                *****
***********************************************************************
         SPACE 5
COPYBASE LA    R2,SA
         ST    R13,SA+4
         ST    R2,8(R13)
         LR    R13,R2
         L     R2,0(R1)           SAVE PTR TO PARM FIELD
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         USING SA,R13             SPECIFY 2ND BASE REGISTER
         USING PDSMEMBR,R7          INDICATE DSECT REGISTER
*        WTO   'COPYPACK  BEGIN ASMBLYDT 010676',ROUTCDE=(2,11)
         OPEN  (DELETES,INPUT,GOODCOPY,OUTPUT,BADCOPY,OUTPUT)
         TM    GOODCOPY+DCBOFLGS,X'10' WAS OPEN SUCCESSFUL
         BO    OPENCHK2           IF YES, BRANCH
         LA    R15,ERRORF04       INDICATE BAD OPEN FOR GOODCOPY
         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE
OPENCHK2 TM    BADCOPY+DCBOFLGS,X'10'  WAS OPEN SUCCESSFUL
         BO    DEVTYPES           IF YES, BRANCH
         LA    R15,ERRORF08       INDICATE BAD OPEN FOR BADCOPY
         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE
DEVTYPES DEVTYPE FROMVTOC+DCBDDNAM,DEVWORK,DEVTAB GET FROMPACK
         LTR   R15,R15            GOOD RETURN
         BZ    DEVTYP01           IF YES, BRANCH
         LA    R15,ERRORF16       INDICATE NO FROMPACK DD CARD
         B     ERROREND           B TO FATAL ERROR ROUTINE
DEVTYP01 DEVTYPE OUTPUT+DCBDDNAM,DEVWORK+X'20',DEVTAB  GET TOPACK
         LTR   R15,R15            GOOD RETURN
         BZ    DEVTYP02           IF YES, BRANCH
         LA    R15,ERRORF12       INDICATE NO TOPACK DD CARD
         B     ERROREND           B TO FATAL ERROR ROUTINE
DEVTYP02 CLI   DEVWORK+2,X'20'          IS FROM PACK DASD
         BNE   DEVTYP03           IF NOT,BRANCH
         CLI   DEVWORK+X'22',X'20'           IS  TO  PACK DASD
         BE    CHECKDEV           IF YES, BRANCH
DEVTYP03 LA    R15,ERRORF24       INDICATE TO/FROM NOT DIRECT ACCESS
         B     ERROREND           BRANCH TO FATAL ERROR ROUTINE
CHECKDEV LH    R1,DEVWORK+6       LOAD ROMPACK MAX BLKSIZE
         CLC   DEVWORK+6(2),DEVWORK+X'26' ARE DEVICES SAME
         BE    CHKDEV01           IF YES, BRANCH
         MVI   DIFFDEV1+1,X'00'   INDICATE DIFFERENT DEVICES (NOP BR)**
         MVI   DIFFDEV2+1,X'00'   NOP ONE MORE BRANCH******************
         BNL   CHKDEV01           IF FROM TRK .GE. TO, BRANCH
         LH    R1,DEVWORK+X'26'        USE TOPACK MAXBLKSIZE INSTEAD
CHKDEV01 LA    R1,1(R1)           ADD 1 FOR RECFM=U CONTROL
*  IF READ RESIDUAL BYTE COUNT GOES TO ZERO FOR RECFM=U, RECORD
*  WON'T FIT ON TOPACK
         MVC   VOLTYPE(4),DEVWORK+X'20'  SAVE TOPACK DEVTYPE
         MVC   MAXTO(6),DEVWORK+X'26'     SAVE TOPACK DEV CONSTANTS
         MVC   MAXFROM(6),DEVWORK+6      SAVE FROMPACK DEV CONSTANTS
         STH   R1,MAXLNGTH        SAVE MAX READ LENGTH (MAX BLKSZ+1)
         SPACE 5
**       OPEN FROMPACK VTOC AND GET UCB ADDRESS AND VOL SER ID
         RDJFCB (TOPKVTOC)        READ IN TOPACK JFCB
         MVI   VTOCJFCB,X'04'     INDICATE VTOC
         MVC   VTOCJFCB+1(43),VTOCJFCB
         MVI   VTOCJFCB+JFCBTSDM,X'08' DON'T WRITE OUT JFCB
         OPEN  (TOPKVTOC,UPDAT),TYPE=J
         L     R1,TOPKVTOC+DCBDEBAD-1  LOAD TOPKVTOC DEB ADDR
         L     R1,32(R1)          GET UCB ADDR FROM DEB
         STH   R1,UCBHOLD+2       SAVE TOPACK UCB ADDR
         MVC   VOLSERID(6),28(R1) SAVE VOL SER ID OF TOPACK
         SPACE 5
READJFCB RDJFCB (FROMVTOC)
         MVI   VTOCJFCB,X'04'     ALTER DSNAME TO INDICATE VTOC
         MVC   VTOCJFCB+1(43),VTOCJFCB
         MVI   VTOCJFCB+JFCBTSDM,X'08' DON'T WRITE OUT JFCB
         LH    R10,MAXLNGTH       LOAD MAX BLK LENGTH
         STH   R10,RDECB2+6       SET UP READ LENGTHS FOR
         STH   R10,RDECB3+6       RECFM=U DATA SETS
         LA    R10,7(R10)         ROUND UP TO NEXT DOUBLEWORD BOUNDARY
         SRL   R10,3
         SLL   R10,3
         LA    R0,0(R10,R10)      GET TWO I/O BUFFERS
         GETMAIN R,LV=(0)         GETMAIN MAX BLOCKSIZE BUFFERS
         ST    R1,RDECB2+12       ST BUFFER ADDR IN DECB
         ST    R1,WDECB1+12       ST BUFFER ADDR IN DECB
         ST    R1,RDECB4+20       ST KEY ADDRESS IN DECB
         AR    R10,R1             POINT TO SECOND BUFFER
         ST    R10,RDECB3+12      ST BUFFER ADDR IN DECB
         ST    R10,WDECB2+12      ST BUFFER ADDR IN DECB
         OPEN  (FROMVTOC,INPUT),TYPE=J OPEN VTOC
         LA    R1,VTOCDECB        READ IN FMT 4 DSCB
         L     R15,FROMVTOC+DCBREAD-1
         BALR  R14,R15
         LA    R1,VTOCDECB        CHECK READ
         L     R15,FROMVTOC+DCBCHECK-1
         BALR  R14,R15
         MVC   MAXCCHHR(5),DSCBUFR+4   SAVE VTOC HIGH WATER MARK
         L     R1,FROMVTOC+DCBDEBAD-1  LOAD DEB ADDR
         L     R1,32(R1)          GET UCB ADDR FROM DEB
         MVC   FROMVOL(6),28(R1)       SAVE FROMPACK VOL SER ID
         L     R9,BADPTR          INIT BADBUFR POINTER
         L     R11,GOODPTR        INIT GOODBUFR POINTER
         USING BADBUFR,R9
         USING GOODBUFR,R11
         MVC   GOODBUFR+89(6),VOLSERID      INSERT FROMPACK AND
         MVC   BADBUFR+89(6),VOLSERID       TOPACK VOL SER ID'S
         MVC   GOODBUFR+79(6),FROMVOL       INTO GOODCOPY AND
         MVC   BADBUFR+79(6),FROMVOL        BADCOPY MSG HEADERS
         DROP  R9,R11
         BAL   R14,WRTGOOD        OUTPUT GOODCOPY HEADER
         BAL   R14,WRITBAD        OUTPUT BADCOPY HEADER
         SPACE 5
         L     R1,WTORADDR        LOAD SUBTASK EP ADDR
         USING WTORRTNE,R1        MAKE DSNMSG ADDRESSABLE
         MVC   DSNMSG+11(6),FROMVOL    PUT FROM ID INTO WTOR REPLY
         DROP  R1
         IDENTIFY EPLOC=WTORNAME,ENTRY=(1)
         CHAP  -1
         ATTACH EPLOC=WTORNAME,DPMOD=+1,PARAM=(DSCBUFR,ENDECB)
         CLC   0(2,R2),ZERO       IS THERE A PARM FIELD
         BE    STOP3              IF NOT, BRANCH
         LA    R2,2(R2)           PT TO PARM FIELD
         CLI   0(R2),C'Y'         SHOULD MODEL DSCB'S BE COPIED
         BE    CHKPARM            IF YES, BR. CHK FOR AUTO RECAT
         CLI   0(R2),C'N'         IF 'N', DON'T COPY MODEL DSCB'S
         BNE   CHKPARM1           IF NEITHER Y OR N, CHK FOR DEFAULT
         MVC   OPTION1+2(2),NOMODEL    ALTER INSTR NOT TO COPY M DSCB**
CHKPARM  LA    R2,1(R2)           BUMP PAST MODEL DSCB CHAR
         CLI   0(R2),C'N'         SHOULD AUTO RECAT BE PROVIDED
         BE    CHKPARM0           IF NOT, BRANCH
         CLI   0(R2),C'Y'         CHECK FOR YES
         BNE   CHKPARM1           IF NEITHER, CHECK FOR DEFAULT
         MVI   READVTOC+1,X'00'   NOP BRANCH TO ENABLE RECAT **********
CHKPARM0 LA    R2,1(R2)           BUMP PAST Y OR N
CHKPARM1 CLI   0(R2),C','         CHECK FOR COMMA
         BNE   PARMERR            IF NO COMMA, PARM ERROR
         CLC   1(5,R2),SAME       SHOULD DIR BLK ALLOC BE SAME AS ORIG
         BE    CHKPARM4           IF YES, BR. CODE ALREADY SET UP
         CLC   1(5,R2),USED       SHOULD DIR BLKS = USED BLKS+10PERCENT
         BE    CHKPARM3           IF YES, BR TO SET UP CODE
         CLI   1(R2),C','         CHK FOR DEFAULT (SAME)
         BE    CHKPARM2           IF DEFAULT, BR
PARMERR  LA    R15,ERRORF40       INDICATE PARM FIELD ERROR
         B     ENDSBTSK           BR TO ERROR ROUTINE
CHKPARM2 LA    R2,2(R2)           BUMP PAST TWO COMMAS
         B     CHKPARM5           BRANCH
CHKPARM3 MVC   OPTION2+2(2),PDSUSED1   SET UP TO ALLOCATE DIRECTORY****
         MVC   OPTION3+2(2),PDSUSED2   BLOCKS BASED ON IN USE COUNT****
CHKPARM4 LA    R2,6(R2)           BUMP TO START OF NEXT FIELD
CHKPARM5 CLC   0(2,R2),UPPERG     IS THERE A START DS VALUE
         BE    START3             IF NOT, BRANCH
         LA    R4,44              MAX DS NAME LENGTH
         LR    R5,R2              HOLD DSNAME START
START1   CLI   1(R2),C'*'         IS THIS THE DS NAME END
         BE    START2             IF YES, BRANCH
         LA    R2,1(R2)           UPDATE DS NAME PTR
         BCT   R4,START1          CONTINUE LOOKING FOR DS NAME END
START2   LR    R3,R2              MOVE END ADDR TO R3
         SR    R3,R5              GET DS NAME LENGTH-1
         CLI   2(R2),C'*'         IS THIS A COPY BY DS GROUP INSTEAD
         BNE   START4             IF NOT, BRANCH
         MVI   GROUPCPY+1,X'00'   NOP BRANCH **************************
         ST    R5,GROUPTR         SAVE DSNAME START ADDRESS
         STC   R3,GROUPCHK+1      INSERT CLC LENGTH IN INSTRU**********
         B     STOP3              BRANCH
START4   STC   R3,CHKSTART+1      INSERT CLC LENGTH IN INSTR***********
         MVI   BRANCH01+1,0       NOP INSTRUCTION  *******************
START3   LA    R2,2(R2)           PT TO STOP FIELD
         CLC   0(2,R2),UPPERG     IS THERE A STOP DS VALUE
         BE    STOP3              IF NOT, BRANCH
         LR    R10,R2             HOLD STOP DS NAME PTR FOR FINDSTOP
         ST    R10,ENDSPTR        SAVE PTR TO END DATA SET NAME
         LA    R4,44              MAX DS NAME LENGTH
STOP1    CLI   1(R2),C'*'         IS THIS THE DS NAME END
         BE    STOP2              IF YES, BRANCH
         LA    R2,1(R2)           UPDATE DS NAME PTR
         BCT   R4,STOP1           CONTINUE LOOKING FOR DS NAME END
STOP2    LR    R3,R2              MOVE END ADDR TO R3
         SR    R3,R10             GET DS NAME LENGTH-1
         STC   R3,CLCSTOP+1       INSERT CLC LENGTH IN INSTRUCTION ****
         MVC   RDVTOC+2(2),BRANCH02  ALTER BRANCH POINT ***************
         MVC   RDVTOC0+2(2),BRANCH02   ALTER BRANCH POINT *************
STOP3    EQU   *
         MVI   DELETBUF,X'FF'     INDICATE BUFFER IS EMPTY
         TM    DELETES+DCBOFLGS,X'10'  WAS OPEN SUCCESSFUL
         BZ    DELEND01           IF NOT,ASSUME NO DS TO BE 'DELETED'
         READ  DELDECB,SF,MF=E    READ 1ST DELETES RECORD
         CHECK DELDECB            CHECK READ
SETSTAE  STAE  STAEEXIT,ASYNCH=YES,PURGE=NONE,XCTL=YES     ISSUE STAE
BRANCH01 B     RDVTOC2            NOP'ED IF THERE IS A START DS
FINDSTRT L     R2,DBUFADDR        LOAD TEMP BASE REG
         USING DBUFFER,R2
CHKSTART MVC   DSNAME(0),0(R5)    MOVE START DSNAME TO 44 BYTE AREA
         OBTAIN STARTDSN          GET DISK ADDR OF START DS
         LTR   R15,R15            WAS OBTAIN OK
         BZ    FIND0              IF YES, CONTINUE
         LA    R15,ERRORF32       INDICATE START DS NOT FOUND
         B     ENDSBTSK           BR TO ERROR ROUTINE
FIND0    MVC   DSCBUFR(44),DSNAME MOVE DSCB KEY AND DATA TO DSCBUFR
         DROP R2
         MVC   DSCBUFR+DS1FMTID(96),FMT3BUFR
         SR    R2,R2
         ST    R2,WORK2           SET MBB TO ZERO
         MVC   WORK2+3(5),FMT3BUFR+96  MOVE IN CCHHR
         L     R1,FROMVTOC+DCBDEBAD-1  POINT TO DEB OF FROMVTOC
         BAL   R14,DISKTTR0       CONVERT DISK ADDR TO TTR0
         ST    R0,WORK
         MVI   WORK+3,1           POSITION FROMVTOC TO CORRECT
         POINT FROMVTOC,WORK      DSCB FOLLOWING THE START DS FMT 1
         B     PROCESS
         SPACE 5
*****  ONE TIME ONLY CONSTANTS
PDSUSED1 DC    S(DIREND)
PDSUSED2 DC    S(DIREND00)
NOMODEL  DC    S(MODLDSCB)
SAME     DC    C'SAME,'
USED     DC    C'USED,'
UPPERG   DC    C'¬*'
         DC    CL128' '            EXTRA SPACE FOR I/O BUFFERS
         SPACE 5
*****  NOTE---    E N D   O F   O N E   T I M E   O N L Y   C O D E
         EJECT
***********************************************************************
*****            READ NEXT FORMAT 1 DSCB FROM FROMPACK VTOC       *****
***********************************************************************
         SPACE 2
READVTOC B     RDVTOC             CHANGED TO NOP FOR AUTO RECATALOG
RCATLGSW EQU   *+1                TURN ON/OFF AUTO RECAT FUNCTION
         B     RDVTOC             SET TO NOP IF DS COPIED OK
         MVI   RCATLGSW,X'F0'     TURN OFF AUTO RECAT SWITCH
        LOCATE LOCLIST1                READ CATALOG FOR DSNAME
         LTR   R15,R15                 WAS DATA SET CATALOGUED?
         BNZ   RDVTOC                  IF NOT, DO NOT CATALOG
         CLC   LOCAREA+6(6),FROMVOL    WAS DS CATALOGUED ON FROMPACK?
         BNE   RDVTOC                  IF NOT, DO NOT RECATALOG
         MVI   LOCAREA+1,X'01'         SINGLE VOLUME DATASET
         MVC   LOCAREA+2(4),VOLTYPE    RESET DEVICE TYPE FOR TOPACK
         MVC   LOCAREA+6(6),VOLSERID   INSERT TOPACK VOLUME SERIAL
       CATALOG LOCLIST2                RECATALOG
         LTR   R15,R15                 CHECK FOR GOOD RECATALOG
         BZ    RDVTOC                  IF GOOD, CONTINUE
         LA    R15,ERRORN80            IF BAD,
         B     DSERROR                   ISSUE ERROR MESSAGE
RDVTOC   B     RDVTOC1            CHANGED TO NOP FOR A MULTI-VOL DS
*        ABOVE BR ADDR CHANGED TO 'CHKSTOP' IF THERE IS A STOP DS
         MVI   RDVTOC+1,X'F0'     CHANGE INSTR BACK TO A BRANCH *******
         POINT TOPKVTOC,DSCBTTR   POINT TO FMT1 DSCB FOR THIS DS
         READ  VTCDECB2,SF,MF=E   READ IN FMT1 DSCB
         CHECK VTCDECB2           CHECK READ
         CLC   DSCBUFR(45),VTOCBUFR    IS THIS THE RIGHT DSCB
         BNE   VTOCERR0           IF NOT, BRANCH TO ERROR ROUTINE
         NI    VTOCBUFR+DS1DSIND,X'7F' TURN OFF LAST VOLUME INDICATOR
         WRITE VTCDECB2,SF,MF=E   WRITE BACK UPDATE DSCB
         LA    R1,VTCDECB2        CHECK WRITE
         L     R15,TOPKVTOC+DCBCHECK-1
RDVTOC0  LA    R14,RDVTOC1        LOAD RETURN POINT
*        ABOVE RETURN ADDR CHANGED TO 'CHKSTOP' IF THERE IS A STOP DS
         BR    R15                LINK TO CHECK ROUTINE
CHKSTOP  L     R1,ENDSPTR         LOAD PTR TO END DATA SET
CLCSTOP  CLC   0(0,R1),DSCBUFR    WAS DS JUST PROCESSED THE STOP DS
         BE    ENDOFJOB           IF YES, END NORMALLY
RDVTOC1  CLC   FROMVTOC+DCBFDAD+3(4),MAXCCHHR    LAST TRK IN VTOC
         BNE   RDVTOC2            IF NOT, BRANCH
         CLC   FROMVTOC+DCBFDAD+7(1),MAXCCHHR+4  LAST FMT1 IN VTOC
         BE    ENDVTOC            IF YES, END OF VTOC
RDVTOC2  READ  VTOCDECB,SF,FROMVTOC,DSCBUFR
         CHECK VTOCDECB
         CLI   DSCBUFR+DS1FMTID,C'1'   IS THIS A FORMAT 1 DSCB
         BNE   RDVTOC2            IF NOT, READ NEXT DSCB
GROUPCPY B     PROCESS            NOP'ED IF COPY IS BY DSGROUP
         L     R1,GROUPTR         LOAD PTR TO GROUP NAME
GROUPCHK CLC   0(0,R1),DSCBUFR+DS1DSNAM     IS THIS A DS TO COPY
         BNE   RDVTOC1            IF NOT, BRANCH
PROCESS  NOP   BEGIN              THIS INSTR ALTERED BY DELETEND RTNE
         CLC   DSCBUFR+DS1DSNAM(44),DELETBUF      SHOULD DS BE IGNORED
         BNE   BEGIN              IF NOT, CONTINUE
         READ  DELDECB,SF,MF=E     IF YES, READ IN A NEW DELETE CARD
         CHECK DELDECB
DELETMSG LA    R15,ERRORN64       INDICATE 'DELETES' DATA SET
         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE
         SPACE 3
DELETEND EQU   *                  DELETES EODAD ROUTINE
         CLOSE (DELETES)
DELEND01 MVI   PROCESS+1,X'F0'    CHANGE INSTR TO UNCOND BRANCH
         CLI   DELETBUF,X'FF'     EODAD ON 1ST READ
         BE    SETSTAE            IF YES, BRANCH
         B     DELETMSG           IF NOT, GO WRITE BADCOPY MSG
         SPACE 3
VTOCERRT EQU   *                  TOPKVTOC SYNAD ROUTINE
         NI    DCBIFLGS(R1),X'3F'      TURN OFF ERROR FLAGS IN TOPKVTOC
         NI    DCBCIND2(R1),X'EF'      DCB SO DCB CAN STILL BE USED
VTOCERR0 LA    R15,ERRORN28       INDICATE MULTI-VOL STATUS COULD NOT
*                                 BE RETAINED (DS STILL EXISTS)
         B     DSERROR            BR TO NON-FATAL ERROR RTNE
         EJECT
***********************************************************************
*****   CHECK FOR INVALID DS TYPES WHICH COPYPACK WON'T COPY      *****
***********************************************************************
         SPACE 5
BEGIN    EQU   *
         CLI   DSCBUFR+DS1NOEPV,0 IS THIS A MODEL DSCB (NO EXTENTS)
OPTION1  BE    BLDJFCBS           IF YES, DON'T WORRY ABOUT DCB INFO
*        ABOVE INSTRUCTION CHANGED TO 'BE MODLDSCB' IF PARM
*        FIELD HAS SPECIFIED NOT TO COPY MODEL DSCB'S
BEGIN01  CLC   DSCBUFR+DS1DSNAM+8(2),PERIOD#T COULD THIS BE A SYSTEM DS
         BNE   BEGIN02            IF NOT, BRANCH
         CLC   DSCBUFR+DS1DSNAM(3),SYS IS THIS A SYSTEM DS
         BNE   BEGIN02            IF NOT, BRANCH
         LA    R15,ERRORN1C       INDICATE SYSTEM DATA SET
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
BEGIN02  TM    DSCBUFR+DS1DSORG,X'01'  IS DS UNMOVABLE
         BZ    BEGIN03            IF NOT,BRANCH
         LA    R15,ERRORN20       INDICATE UNMOVABLE DATA SET
         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE
BEGIN03  EQU   *
         CLC   DSCBUFR+DS1BLKL(2),ZERO     IS BLKSIZE ZERO?
         BE    DCBERROR           IF YES, BR TO ERROR ROUTINE
         CLC   DSCBUFR+DS1BLKL(2),MAXLNGTH  IS BLKSZ .GE. MAX READ
         BL    BLDJFCBS           IF NOT, OK
         TM    DSCBUFR+DS1RECFM,X'C0'  IS RECFM=U
         BNO   BEGIN04            IF NOT, CONTINUE ERROR ISOLATION
         LH    R1,MAXLNGTH        LOAD MAX READ LENGTH
         BCTR  R1,0               MINUS 1 FOR MAX TOPACK BLKSIZE
         STH   R1,DSCBUFR+DS1BLKL      SET BLKSIZE AND LRECL TO
         STH   R1,DSCBUFR+DS1LRECL          ACTUAL MAXIMUM POSSIBLE
         B     BLDJFCBS      COPY DS UNLESS THERE REALLY IS A BIG BLK
BEGIN04  CLC   DSCBUFR+DS1BLKL(2),MAXFROM   IS BLKSZ VALID FOR FROMPACK
         BNH   TRUNCERR           IF YES, BRANCH. TOPACK TOO SMALL
         TM    DSCBUFR+DS1RECFM,X'20'  DOES DS HAVE TRK OVERFLOW
         BNO   DCBERROR           IF NOT, INVALID BLKSIZE VALUE
         LA    R15,ERRORN24       INDICATE TRK OFLOW, BLKSIZE TOO BIG
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
DCBERROR LA    R15,ERRORN2C       INDICATE INVALID BLKSIZE
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
TRUNCERR LA    R15,ERRORN78       INDICATE BLK WON'T FIT ON TOPACK
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
         EJECT
***********************************************************************
*****     BUILD SKELETON JFCB'S FOR INPUT AND OUTPUT DATA SETS    *****
***********************************************************************
         SPACE 5
BLDJFCBS EQU   *                  BUILD SKELETON JFCBS FOR I AND O DS
         MVC   INJFCB+JFCBDSNM(44),DSCBUFR+DS1DSNAM   MOVE IN DSNAME
         MVC   INJFCB+JFCBELNM(8),INJFCB+JFCBELNM-1 BLANK ELEMENT NAME
         MVI   INJFCB+JFCBTSDM,0
         MVC   INJFCB+JFCBTSDM+1(123),INJFCB+JFCBTSDM ZERO REST OF JFCB
         MVI   INJFCB+JFCBNVOL,X'01'   ONE VOL SER
         MVI   INJFCB+JFCBVOLS+6,C' '  VOL SER DELIMITER
         MVC   INJFCB+JFCDSORG(1),DSCBUFR+DS1DSORG    DSORG
         MVC   INJFCB+JFCKEYLE(1),DSCBUFR+DS1KEYL     KEYLENGTH
         MVC   INJFCB+JFCRECFM(1),DSCBUFR+DS1RECFM    RECFM
         MVC   INJFCB+JFCBLKSI(4),DSCBUFR+DS1BLKL     BLKSIZE/LRECL
         MVC   OUTJFCB(176),INJFCB     COPY JFCB
         MVI   INJFCB+JFCBTSDM,X'04'   PREVENT INPUT DSCB TO JFCB MERGE
**  THIS PREVENTS THE OPTCODE VALUE FROM BEING USED IF SPECIFIED
         MVC   INJFCB+JFCBVOLS(6),FROMVOL   FROMPACK VOL SER ID    ID
         MVC   OUTJFCB+JFCBVOLS(6),VOLSERID TOPACK VOL SER ID
         MVI   OUTJFCB+JFCBMASK+4,X'C0'     WRITE JFCB AND DSCB OUT
         MVI   OUTJFCB+JFCBIND1,X'C0'  RLSE
         MVI   OUTJFCB+JFCBIND2,X'C0'  NEW DATA SET
         NI    DSCBUFR+DS1SCAL0,X'F9'  DON'T ALLOW MXIG OR ALX
         MVC   DSCBHOLD(4),DSCBUFR+DS1SCAL0      SAVE SPACE/ SEC ALLOC
         MVC   INJFCB+JFCBCRDT(6),DSCBUFR+DS1CREDT    SAVE CREAT/EXPIR
         MVC   OUTJFCB+JFCBCTRI(1),DSCBUFR+DS1SCAL0   SPACE ALLOC
         CLI   DSCBUFR+DS1NOEPV,0      CHECK AGAIN FOR MODEL DSCB
         BNE   JFCBCONT           IF NOT, BRANCH
         SPACE 3
***********************************************************************
*****                     MODEL DSCB COPY ROUTINES                *****
***********************************************************************
         SPACE 2
         MVC   OUTJFCB+JFCBVLSQ(2),DSCBUFR+DS1VOLSQ   VOL SEQ
         MVC   OUTJFCB+JFCBCTRI(1),DSCBUFR+DS1SCAL0   SPACE ALLOC
         MVC   OUTJFCB+JFCBCRDT(6),DSCBUFR+DS1CREDT   EXPIRATION DATE
*****  NOTE-  ORIGINAL CREATION DATE AND VOL SER ID CANNOT BE
*****         RETAINED FOR A MODEL DSCB
         BAL   R10,ALLOCDS        ALLOCATE MODEL DSCB
         B     DSCOPYOK           BRANCH TO GOOD COPY RTNE
MODLDSCB LA    R15,ERRORN74       INDICATE MODEL DSCB NOT TO BE COPIED
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
         EJECT
**    DETERMINE SPACE ALLOCATION (INITIAL- CORRECT VALUE
**     ZAPPED INTO DSCB LATER) AND AMOUNT
**                RECORDS,ROUND=    CYLINDERS
**                RECORDS      =    TRACKS
**                TRACKS       =    TRACKS
**                CYLINDERS    =    CYLINDERS
**
**
JFCBCONT TM    DSCBUFR+DS1SCAL0,X'C0'  ALLOC IN TRKS OR BLKS
         BM    TRKORECS           IF YES, BRANCH
         BO    SPACE01            IF IN CYLS, BRANCH
         LA    R15,ERRORN3C       INDICATE ABS TRK ALLOCATION
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
TRKORECS NI    OUTJFCB+JFCBCTRI,X'0E' KEEP NEXT TO LOW 3 BITS
         TM    DSCBUFR+DS1SCAL0,X'41'  IS SPACE ALLOC ROUNDED
         BNO   TRKRECS1           IF NOT, BRANCH
         OI    OUTJFCB+JFCBCTRI,X'C0'  CHANGE ALLOC TO CYLS
         B     SPACE01            BRANCH
TRKRECS1 OI    OUTJFCB+JFCBCTRI,X'80'  ALLOCATE IN TRKS
SPACE01  SR    R5,R5              INIT TRK COUNT
         LR    R7,R5              CLEAR R7
         IC    R7,DSCBUFR+DS1NOEPV     SAVE EXTENT COUNT
         LA    R2,DSCBUFR+DS1EXT1 PT TO EXTENT LIST
         LA    R3,3               MAX OF 3 EXTENTS IN FMT 1 DSCB
         BAL   R14,NUMOFTRK
         CLC   DSCBUFR+DS1PTRDS(5),FIVEZERO IS THERE A FMT 3 DSCB
         BNE   SPACE02            IF YES, BRANCH
ALLOCERR LA    R15,ERRORN40       INDICATE BAD DSCB INFORMATION
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
SPACE02  MVC   WORK(5),DSCBUFR+DS1PTRDS     MOVE CCHHR OUT OF DSCB
         OBTAIN FORMAT3
         LA    R2,FMT3BUFR+DS3EXTNT
         LA    R3,4               4 EXT MAX IN 1ST FMT 3 FIELD
         BAL   R14,NUMOFTRK
         LA    R2,FMT3BUFR+DS3ADEXT
         LA    R3,9               9 EXT MAX IN 2ND FMT 3 FIELD
         BAL   R14,NUMOFTRK
NEWTRKS1 LH    R6,DSCBUFR+DS1BLKL LOAD DS BLKSIZE
         BAL   R10,NEWSPACE       GET PRIMARY SPACE FOR TOPACK
SAMEDEV1 TM    OUTJFCB+JFCBCTRI,X'C0'  ALLOCATION IN CYLS
         BNO   SPACE03            IF NOT, BRANCH
         LH    R2,TOCYLS          GET TOPACK TRKS/CYL
         SR    R4,R4              CLEAR FOR DIVIDE
         DR    R4,R2              CONVERT TRKS TO CYLS
         LTR   R4,R4              IS THERE A REMAINDER
         BZ    SPACE03            IF NOT, BRANCH
         LA    R5,1(R5)           ROUND UP
SPACE03  LTR   R5,R5              VERIFY SPACE QUANTITY
         BNP   ALLOCERR           BRANCH IF INVALID
         SLL   R5,8               PUT VALUE ON PROPER BOUNDARY
         IC    R5,OUTJFCB+JFCBCTRI     DON'T CLOBBER SPACE ALLOCATION
         ST    R5,OUTJFCB+JFCBPQTY     INSERT ALLOC INTO JFCB
DIFFDEV2 B     SAMEDEV2           NOP'ED IF FROM/TO DEVICES DIFFERENT
**  IF DIFFERENT DEVICES, RECALC SECONDARY SPACE ALSO
         CLC   DSCBHOLD+1(3),ZERO IS THERE A SECONDARY ALLOCATION
         BE    SPACE06            IF NOT, BRANCH
         L     R5,DSCBHOLD        LOAD SECONDARY QUANTITY
         LA    R5,0(R5)           CLEAR HIGH BYTE
         TM    DSCBUFR+DS1SCAL0,X'C0'  IS TRUE ALLOC IN CYLS
         BNO   SPACE04            IF NOT, BRANCH
         MH    R5,FROMCYLS        CONVERT TO FROMPACK TRKS
         BAL   R10,NEWSPACE       CONVERT TO TOPACK TRKS
         SR    R4,R4              CLEAR FOR DIVIDE
         LH    R2,TOCYLS          LOAD TOPACK TRKS/CYL
         DR    R4,R2              GET TOPACK CYLS
         LTR   R4,R4              IS THERE A REMAINDER
         BZ    SPACE05            IF NOT, BRANCH
         LA    R5,1(R5)           ROUND UP
         B     SPACE05            BRANCH
SPACE04  TM    DSCBUFR+DS1SCAL0,X'40'  IS TRUE ALLOC IN RECS
         BO    SPACE06            IF YES, SECONDARY IS OK
         BAL   R10,NEWSPACE       CONVERT TO TOPACK TRKS
SPACE05  ST    R5,DSCBHOLD        UPDATE SECONDARY VALUE
         MVC   DSCBHOLD(1),DSCBUFR+DS1SCAL0 RESTORE ALLOCATION TYPE
SAMEDEV2 EQU   *
SPACE06  EQU   *
         TM    OUTJFCB+JFCDSORG,X'20'  IS DSORG=DA
         BO    BDAMDS             IF YES, BR TO BDAM COPY ROUTINE
         MVC   OUTPUT+DCBDSORG(1),DSCBUFR+DS1DSORG    SET PS/PO DSORG
         MVC   INPUT+DCBDSORG(1),DSCBUFR+DS1DSORG     SET PS/PO DSORG
         TM    OUTJFCB+JFCRECFM,X'C0'  IS RECFM=U
         BNO   RECFM02            IF NOT, BRANCH
         MVC   WRITEBLK+2(2),WRITU     INDICATE WRITE ROUTINE ADDR
         B     RECFM03
RECFM02  TM    OUTJFCB+JFCRECFM,X'90'  IS RECFM=FB
         BNO   RECFM04            IF NOT, BRANCH
         MVC   WRITEBLK+2(2),WRITEFB   INDICATE WRITE ROUTINE ADDR
         B     RECFM03
RECFM04  MVC   WRITEBLK+2(2),WRITFORV  INDICATE WRITE ROUTINE ADDR
RECFM03  EQU   *
         TM    OUTJFCB+JFCDSORG,X'02'  IS DATA SET DSORG=PO
         BO    PARTITDS           IF YES, BRANCH
         TM    OUTJFCB+JFCDSORG,X'40'  IS DSORG=PS
         BO    PHYSEQDS           IF YES, BRANCH
         LA    R15,ERRORN44       INDICATE INVALID DSORG
         B     DSERROR            BRANCH TO NON-FATAL ERROR ROUTINE
         EJECT
***********************************************************************
*****                                                             *****
*****  BLDJFCBS SUBROUTINE. CALCULATES SPACE ALLOCTED ON          *****
*****  FROMPACK FROM EXTENT ENTRIES IN FMT 1 AND FMT 3 DSCBS      *****
*****                                                             *****
***********************************************************************
NUMOFTRK TM    0(R2),X'01'        IS THIS A VALID USED EXTENT
         BZ    ALLOCERR           IF NOT, DSCB ERROR
         MVC   WORK(8),2(R2)      MOVE CCHH'S TO FW BOUNDARIES
         LH    R4,WORK+4          LOAD HIGH CC
         SH    R4,WORK            SUBTRACT LOW CC
         MH    R4,FROMCYLS        CONVERT CYL COUNT TO TRKS
         AH    R5,WORK+6          ADD HIGH HH
         SH    R5,WORK+2          SUBTRACT LOW HH
         LA    R5,1(R4,R5)        ADD 1 TRK PLUS CYL VALUE
         LA    R2,10(R2)          PT TO NEXT EXTENT FIELD
         BCT   R7,NUMTRK1         DEC EXT BY 1, BR IF NONZERO
*  ALL EXTENTS HAVE BEEN PROCESSED
DIFFDEV1 B     SAMEDEV1           NOP'ED IF FROM/TO DEVICES DIFFERENT
         B     NEWTRKS1           REDO SPACE IN TERMS OF TOPACK
NUMTRK1  BCT   R3,NUMOFTRK        HANDLE NEXT EXTENT
         BR    R14                RETURN IF END OF EXTENT AREA
         SPACE 3
***********************************************************************
*****                                                             *****
*****  BLDJFCBS SUBROUTINE. RECALCULATES TOPACK SPACE REQUIREMENT *****
*****  WHEN TO AND FROM DEVICES ARE DIFFERENT. TAKES INTO ACCOUNT *****
*****  DIFFERING TRK LENGTHS AND TRK BLOCKING FACTORS-- TOTRKS=   *****
** ((FROMTRKS*MAXFROMBLKSZ+MAXTOBLKSZ-1)/BLKSZ) / (MAXTOBLKSZ/BLKSZ) **
*****                                                             *****
***********************************************************************
NEWSPACE EQU   *   R5=TRK QUANTITY, R6=BLKSIZE
         SR    R4,R4              CLEAR FOR DIVIDE
         MH    R5,MAXFROM         X MAX FROMPACK BLKSIZE
         AH    R5,MAXTO           + MAX TOPACK BLKSIZE
         SR    R2,R2              CLEAR FOR FUTURE DIVIDE
         BCTR  R5,0               SUBTRACT 1
         DR    R4,R6              NUMERATOR
         SR    R4,R4              CLEAR FOR DIVIDE
         LH    R3,MAXTO           LOAD MAX TOPACK BLKSIZE
         DR    R2,R6              DIVIDE BY BLKSIZE (DENOMINATOR)
         DR    R4,R3              R5=EFFECTIVE TOPACK TRKS
         BR    R10                RETURN
         EJECT
***********************************************************************
***********************************************************************
*****                                                             *****
*****      START OF PARTITIONED DATA SET COPY ROUTINES            *****
*****                                                             *****
*****  THE PDS COPY ROUTINES READ THE ENTIRE PDS DIRECTORY INTO   *****
*****  CORE AND MAKE USE OF 3 TABLES --                           *****
*****                                                             *****
*****                                                             *****
*****  1.MEMTABLE- ONE HALFWORD ENTRY FOR EACH MEMBER (MAIN OR    *****
*****              ALIAS) WITHIN THE PDS.                         *****
*****                                                             *****
*****      A.FORMAT OF AN ACTIVE ENTRY IS                         *****
*****          BIT 0-  1 IF MEMBER IS AN ALIAS, 0 IF A MAIN MEMBER*****
*****          BITS 1-6 ZERO                                      *****
*****          BITS 7-15 OFFSET OF NEXT DIRECTORY ENTRY FROM      *****
*****            CURRENT ENTRY (STARTING MEMBER ADDR IN DBUFADDR) *****
*****                                                             *****
*****      B.SPECIAL FLAGS-                                       *****
*****          X'7F00'  END OF ACTIVE ENTRIES                     *****
*****          X'FF00'  END OF MEMTABLE                           *****
*****                                                             *****
*****                                                             *****
*****  2.ALIASTAB- ONE FULLWORD ENTRY FOR EACH ALIAS              *****
*****                                                             *****
*****      A.FORMAT OF EACH ACTIVE ENTRY-                         *****
*****          AFTER PASS 1. BYTES 0-2 TTR VALUR OF ALIAS         *****
*****                        BYTE 3    ZERO                       *****
*****          AFTER PASS 2- AA.IF MAIN MEMBER FOR ALIAS FOUND    *****
*****                        BYTE 0    ZERO                       *****
*****                        BYTES 1-3 ABS ADDR OF CORRESPONDING  *****
*****                                  MAIN MEMBER DIRECTORY ENTRY*****
*****                        BB.IF MAIN MEMBER FOR ALIAS IS ABSENT*****
*****                        BYTE 0=X'70' INDICATES THIS ENTRY IS *****
*****                        NOT USED & ALIAS IS MADE A MAIN MEMBR*****
*****          AFTER ALIAS PROCESSOR                              *****
*****                        AA.IF MAIN MEMBER FOR ALIAS PROCESSED*****
*****                           BEFORE ALIAS-                     *****
*****                        BYTE 0  X'70'  BYTES 1-3 UNCHANGED   *****
*****                        (THIS INDICATES ALIAS ENTRY IS       *****
*****                        COMPLETE.NO MORE PROCESSING NEEDED)  *****
*****                        BB.IF MAIN MEMBER WAS NOT PROCESSED  *****
*****                           BEFORE ALIAS                      *****
*****                        BYTE 0   ZERO                        *****
*****                        BYTES 1-3 ABS ADDR OF ALIAS DIR ENTRY*****
*****            NOTE- ABS ADDR OF MAIN MEMBER HAS BEEN MOVED     *****
*****                  INTO TTR FIELD OF ALIAS ENTRY              *****
*****                        (INDICATE ALIAS MUST BE RESTOWED WITH*****
*****                        CORRECT TTR AND TTRN VALUES. 1ST STOW*****
*****                        IS A DUMMY USED AS A 'PLACE-HOLDER') *****
*****                                                             *****
*****      B.SPECIAL FLAGS                                        *****
*****          BYTE 0   X'7F'  END OF ACTIVE ALIASTAB ENTRIES     *****
*****          BYTE 0   X'FF'  END OF ALIASTAB                    *****
*****                                                             *****
         EJECT
*****                                                             *****
*****  3.TTRNTABL- 2 FULLWORD ENTRY FOR EACH TTR FIELD PER MEMBER *****
*****      (TTRN FIELDS IN DIRECTORY + NOTELIST TTR0'S)           *****
*****                                                             *****
*****      A.FORMAT FOR TTRN FIELDS IN DIRECTORY ENTRY-           *****
*****        1)TTR0'S AND PASS 1 ON NOTELISTS                     *****
*****          BYTE 0    X'80'                                    *****
*****          BYTES 1-3 ABS ADDR OF TTRN FIELD WITHIN DIRECTORY  *****
*****          BYTES 4-7 TTRN VALUE FROM DIRECTORY                *****
*****                                                             *****
*****        2)PASS 2 (IF REQUIRED) FOR NOTELIST ENTRY            *****
*****          BYTE 0  X'90'     BYTES 1-7  SAME AS 1)            *****
*****                                                             *****
*****      B.FORMAT FOR NOTELIST ENTRY FROM NOTELIST RECORD       *****
*****          1)BEFORE RECORD PT'ED TO BY NOTELIST ENTRY IS FOUND*****
*****              BYTE 0  X'0F'                                  *****
*****              BYTES 1-3 TTR OF NOTELIST RECORD               *****
*****              BYTES 4-6 TTR FROM NOTELIST ENTRY              *****
*****              BYTE 7    ABS OFFSET INTO NOTELIST RECORD OF   *****
*****                        THIS ENTRY                           *****
*****                                                             *****
*****          2)AFTER NOTELIST ENTRY RECORD IS ENCOUNTERED       *****
*****              BYTE 0  X'00'                                  *****
*****              BYTES 1-3 NEW TTR VALUE OF NOTELIST ENTRY      *****
*****              BYTES 4-6 TTR OF NOTELIST RECORD               *****
*****              BYTE 7    SAME AS 1)                           *****
*****                                                             *****
*****      C.SPECIAL FLAGS                                        *****
*****          BYTE 0      X'7F' END OF ACTIVE TTRNTABL ENTRIES   *****
*****          BYTE 0      X'FF' END OF TTRNTABL                  *****
*****                                                             *****
***********************************************************************
***********************************************************************
         SPACE 5
PARTITDS EQU   *                  PARTITIONED COPY ROUTINE
         MVI   TTRCOUNT,0         CLEAR TTR COUNT
         MVI   GOODMEM+1,0        CLEAR PARTITIONED DS FLAGS
         MVI   BADMEM+1,0
         MVI   BADFULL+1,X'F0'
         MVI   GOODFULL+1,X'F0'
         LA    R6,PARSYNAD        LOAD PDS SYNAD RTNE ADDR
         ST    R6,INPUT+DCBSYNAD-1
         ST    R6,OUTPUT+DCBSYNAD-1    INSERT ADDR IN DCBS
         LA    R6,BPAMEOD         LOAD LOAD PARTITIONED EODAD RTNE ADDR
         ST    R6,INPUT+DCBEODAD-1     INSERT AS EODAD ADDR IN DCB
         OPEN  (DIRECTRY,INPUT),TYPE=J OPEN FROM DS TO READ DIRECTORY
         L     R2,DBUFADDR        GET ADDR OF DIRECTORY BUFFER
*****     CLEAR MEMTABLE AND ALIASTAB IF NEEDED
         LA    R6,MAXENTRY/2      GET MEMTABLE LENGTH
         SLL   R6,2
         L     R7,MEMTBPTR        INIT MEMTABLE PTR
         SH    R7,HW2             POINT TO RESET VALUE
INIT1    CLI   2(R7),X'7F'        IS NEXT AREA ALREADY CLEAR
         BE    INIT3              IF YES, BRANCH
         CH    R6,HW256           IS THERE .LT. 256 BYTES TO CLEAR
         BL    INIT2              IF YES, BRANCH
         MVC   2(256,R7),0(R7)    CLEAR 256 BYTES
         LA    R7,256(R7)         UPDTE MEMTABLE PTR
         SH    R6,HW256           UPDATE COUNT OF BYTES LEFT TO CLEAR
         BNZ   INIT1              BRANCH TO CLEAR ANOTHER 256 BYTES
         B     INIT3              BRANCH OUT IF ZERO BYTES LEFT
CLRTABL1 MVC   2(0,R7),0(R7)      THIS INSTR EX'ED BELOW
CLRTABL2 MVC   4(0,R7),0(R7)      THIS INSTR EX'ED BELOW
INIT2    BCTR  R6,0               DEC BY 1 FOR MVC INSTR
         EX    R6,CLRTABL1        CLEAR REMAINDER OF MEMTABLE
INIT3    LA    R6,4*MAXALIAS      GET ALIASTAB LENGTH
         L     R7,ALIASADR        INIT ALIASTAB PTR
         SH    R7,FOUR+2          BACK UP PTR TO RESET VALUE
INIT4    CLI   4(R7),X'7F'        IS NEXT AREA ALREADY CLEAR
         BE    INIT6              IF YES, BRANCH OUT
         CH    R6,HW256           IS THERE .LT. 256 BYTES TO CLEAR
         BL    INIT5              IF YES, BRANCH
         MVC   4(256,R7),0(R7)    CLEAR 256 BYTES OF ALIASTAB
         LA    R7,256(R7)         UPDATE ALIASTAB PTR
         SH    R6,HW256           UPDATE COUNT OF BYTES LEFT TO CLEAR
         BNZ   INIT4              BRANCH TO CONTINUE
         B     INIT6              IF ZERO BYTES LEFT, BRANCH
INIT5    BCTR  R6,0               DEC BY 1 FOR MVC INSTR
         EX    R6,CLRTABL2        CLEAR REST OF ALIASTAB
INIT6    EQU   *
         SR    R10,R10            INIT BLOCK COUNT
         L     R4,MEMTBPTR        INIT PTR TO MEMTABLE
         L     R8,ALIASADR        INIT PTR TO ALIASTAB
         LA    R7,2(R2)           INIT LAST MEMBER PTR
         SPACE 5
***********************************************************************
*****            START OF PASS 1 DIRECTORY PROCESSOR              *****
***********************************************************************
         SPACE 5
READIR   CLI   0(R2),X'FF'        IS DIRECTORY BUFFER FULL
         BNE   GETBLOCK           IF NOT, BRANCH
         LA    R15,ERRORN48       INDICATE PDS HAS TOO MANY DIR BLKS
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
GETBLOCK READ  RDECB1,SF,DIRECTRY,(R2),256
         CHECK RDECB1
         LA    R10,1(R10)         UPDATE TOTAL BLOCK COUNT
         LH    R6,0(R2)           GET USED BYTE COUNT FOR BLOCK
         SH    R6,HALF10          DECREASE BY 10
         LA    R5,2(R2)
         SR    R5,R7    GET OFFSET FROM LAST MEMBER IN PREVIOUS BLOCK
         LA    R7,2(R2)           PT TO 1ST MEMBER IN THIS BLOCK
         LA    R2,256(R2)         UPDATE PTR
PASS1#1  CLC   PDSNAME,HEXFFS     IS THIS THE DIRECTORY END
OPTION2  BE    LASTBLK            IF YES, BR TO COUNT REMAINING BLKS
*        IF DIRECTORY BLK ALLOC IS TO BE MADE ON BASIS OF
*        USED BLK COUNT, ABOVE INSTR CHANGED TO 'BE DIREND'
         CLC   0(2,R4),HEXFFS     IS MEMTABLE FULL
         BNE   PASS1#2            IF NOT, BRANCH
         LA    R15,ERRORN4C       PDS HAS TOO MANY MEMBERS FOR PGM
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
PASS1#2  STH   R5,0(R4)           ST OFFSET IN MEMTABLE
         IC    R5,PDSC            LOAD C FIELD INTO R5
         N     R5,LNGTHMSK        ISOLATE USER LNGTH COUNT
         SLL   R5,1               CONVERT HW LENGTH TO BYTES
         LA    R5,12(R5)          INCLUDE NAME + TTRC LNGTHS
         TM    PDSC,X'80'         IS THIS AN ALIAS ENTRY
         BZ    PASS1#4            IF NOT, BRANCH
         OI    0(R4),X'80'        FLAG ENTRY AS AN ALIAS
         CLI   0(R8),X'FF'        IS ALIASTAB FULL
         BNE   PASS1#3            IF NOT, BRANCH
         LA    R15,ERRORN50       PDS HAS TOO MANY ALIASES FOR PGM
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
PASS1#3  MVC   1(3,R8),PDSTTR     STORE TTR PTR IN ALIASTAB
         MVI   0(R8),0            CLEAR HIGH BYTE
         LA    R8,4(R8)           UPDATE ALIASTAB PTR
PASS1#4  LA    R4,2(R4)           UPDATE MEMTABLE PTR
         SR    R6,R5              GET USED BYTES LEFT IN BLOCK-10
         BNP   READIR
         AR    R7,R5
         B     PASS1#1
         SPACE 2
LASTBLK  CLI   0(R2),X'FF'        IS DIRECTORY BUFFER FULL
         BE    DIREND             IF YES, USE CURRENT BLK COUNT
LASTBLK1 READ  RDECB1,SF,,(R2),MF=E    READ NEXT EMPTY BLOCK
         CHECK RDECB1             CHECK READ
         LA    R10,1(R10)         UPDATE TOTAL BLK COUNT
         B     LASTBLK1           CONTINUE
         SPACE 5
***********************************************************************
***** INSERT DIRECTORY BLOCK COUNT INTO JFCB AND CLOSE DIRECTORY  *****
***********************************************************************
         SPACE 5
DIREND   CLOSE (DIRECTRY)         CLOSE PDS DIRECTORY
OPTION3  B     DIREND01
*        IF DIRECTORY BLK ALLOC IS TO BE MADE ON BASIS OF
*        USED BLK COUNT, ABOVE INSTR CHANGED TO 'BH DIREND00'
DIREND00 LA    R5,8(R10)          NEW BLK = OLD USED BLKS + 10 PERCENT
         SR    R4,R4              CLEAR R4
         STH   R4,OUTJFCB+JFCBDQTY     CLEAR 2 BYTES IN DIR COUNT
         D     R4,FULL10          ADD 10 PER CENT TO BLK COUNT
         AR    R10,R5
         STC   R10,OUTJFCB+JFCBDQTY+2 INSERT BLOCK COUNT INTO JFCB
         B     DIREND02
         SPACE 2
DIREND01 EQU   *                  NEW BLK COUNT = OLD BLK COUNT
         SLL   R10,8              ALIGN DIRECTORY COUNT TO MATCH JFCB
         ST    R10,OUTJFCB+JFCBDQTY    INSERT DIRECTORY COUNT INTO JFCB
DIREND02 EQU   *
         L     R3,DBUFADDR
         LA    R3,2(R3)           PT TO 1ST POSSIBLE MEMBER NAME
         CR    R7,R3              IS THIS NULL PDS (NO MEMBERS)
         BNH   PREALLOC           IF YES, GO ALLOCATE NULL PDS
         SPACE 5
***********************************************************************
*****           START OF PASS 2 DIRECTORY PROCESSOR               *****
***********************************************************************
         SPACE 5
         L     R2,DBUFADDR        LOAD PTR TO START OF DIRECT BLKS
         LA    R2,2(R2)           PT TO 1ST MEMBER
         L     R8,ALIASADR        INIT PTR TO ALIASTAB
PASS2#1  TM    0(R8),X'7F'        IS THIS THE END OF THE ALIASES
         BO    PASS2#6            IF YES, BRANCH
         MVI   PASS2#0+1,X'00'    MAKE INSTRU A NOP    ****************
         L     R4,MEMTBPTR        INIT MEMTABLE PTR
         LR    R7,R2              PT TO 1ST BLOCK
PASS2#2  CLC   PDSTTR+1(2),2(R8)  DOES -TR ENTRY MATCH
         BNE   PASS2#4            IF NOT, BRANCH
         CLC   PDSTTR(1),1(R8)    DOES T-- ENTRY MATCH
         BNE   PASS2#4            IF NOT, BRANCH
*  THE PREVIOUS 2 TESTS COULD BE COMBINED, BUT IT'S FASTER THIS WAY
*  SINCE ALMOST ALL COMPARES WILL BE NE
         TM    PDSC,X'80'         MATCH SHOULDN'T BE AN ALIAS
         BO    PASS2#0            IF IT IS, BRANCH
         ST    R7,0(R8)           INSERT ADDR OF MAIN ENTRY
PASS2#3  LA    R8,4(R8)           UPDATE ALIASTAB PTR
         B     PASS2#1            HANDLE NEXT ALIAS
PASS2#0  NOP   PASS2#4           BR AFTER 1ST TTR-SAME, ALIAS HIT
         LR    R6,R7              SAVE PTR TO DIRECTORY ENTRY
         LR    R3,R4              SAVE MEMTABLE ENTRY ADDR
         MVI   PASS2#0+1,X'F0'    CHANGE NOP TO UNCOND BR  ************
PASS2#4  LA    R4,2(R4)           PT TO NEXT MEMTABLE ENTRY
         TM    0(R4),X'7F'        IS THIS THE END OF THE ENTRIES
         BNO   PASS2#5            IF NOT, CONTINUE
*  IF CONTROL REACHES HERE, ALIAS IS CHANGED INTO A MAIN MEMBER
         MVI   0(R8),X'70'        FLAG ALIASTAB ENTRY AS NOT IN USE
         NI    11(R6),X'7F'       TURN OFF ALIAS FLAG IN DIRECTORY
         NI    0(R3),X'7F'        TURN OFF ALIAS FLAG IN MEMTABLE
         B     PASS2#3
PASS2#5  LH    R5,0(R4)           INSERT MEMTABLE ENTRY
         N     R5,OFFSET          CLEAR ALIAS FLAG IF PRESENT
         AR    R7,R5              PT TO NEXT MEMBER
         B     PASS2#2
PASS2#6  EQU   *
         SPACE 5
***********************************************************************
*****             END OF PASS 2 DIRECTORY PROCESSOR               *****
***********************************************************************
         SPACE 5
         BAL   R10,ALLOCDS        ALLOCATE PDS ON TOPACK
         OPEN  (INPUT,INPUT,OUTPUT,OUTPUT),TYPE=J  OPEN IN AND OUT DCBS
         L     R4,MEMTBPTR        INIT MEMTABLE PTR
         L     R8,ALIASADR        INIT PTR TO ALIASTAB
         L     R7,DBUFADDR        INIT PTR TO DIRECTORY BLOCKS
         LA    R7,2(R7)           PT TO 1ST MEMBER
NEXTMEM  TM    0(R4),X'FE'        IS THERE A MAIN MEMBER TO PROCESS
         BZ    PARTITIO           IF YES, BRANCH
         TM    0(R4),X'7F'        IS THIS THE END OF THE ENTRIES
         BNO   ALIASP01           IF NOT, MUST BE AN ALIAS
         SPACE 5
***********************************************************************
*****      FINAL DIRECTORY PROCESSOR  - RESTOW ALIAS IF REQUIRED  *****
***********************************************************************
         SPACE 5
         L     R8,ALIASADR        INIT PTR TO ALIASTAB
FINAL01  TM    0(R8),X'7F'        IS THIS THE END OF THE ENTRIES
         BZ    FINAL02            BRANCH IF RESTOW REQUIRED
         BM    FINAL03            CONTINUE IF RESTOW NOT REQUIRED
         CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT
         CLI   BADFULL+1,X'F0'    IS BADBUFR PTR ON A FULL FIELD
         BE    NOBADMEM           IF YES, BRANCH
         LA    R9,30(R9)          RESET PTR TO NEXT FULL FIELD
         CLI   0(R9),X'FF'        IS BUFFER FULL
         BNE   NOBADMEM           IF NOT, BRANCH
         BAL   R14,WRITEBAD       OUTPUT BUFFER RTNE
NOBADMEM CLI   GOODMEM+1,X'F0'    WERE ANY MEMBERS COPIED OK
         BE    KEEPPDS            IF YES, BRANCH
         BAL   R2,SCRATCHD        SCRATCH DATA SET
         B     READVTOC           GO PROCESS NEXT DATA SET
KEEPPDS  CLI   GOODFULL+1,X'F0'   IS GOODBUFR PTR ON A FULL FIELD
         BE    READVTOC           IF YES, BRANCH
         LA    R11,20(R11)        RESET PTR TO NEXT FULL FIELD
         CLI   0(R11),X'FF'       IS BUFFER FULL
         BNE   READVTOC           IF NOT, BRANCH
         BAL   R14,WRITGOOD       OUTPUT BUFFER
         B     READVTOC           PROCESS NEXT DATA SET
FINAL02  L     R7,0(R8)           LOAD PTR TO ALIAS ENTRY
         MVC   WORK+1(3),PDSTTR   LOAD PTR TO MAIN ENTRY
         L     R6,WORK
         CLC   8(4,R6),HEXFFS     WAS MAIN MEMBER COPIED OK
         BNE   FINAL12            IF YES, BRANCH
         STOW  OUTPUT,(7),D       DELETE PLACE-HOLDER ENTRY
         LA    R15,ERRORN68       INDICATE MAIN MEMBER IN ERROR
FINAL32  BAL   R3,SCRMEM01        WRITE ERROR MESSAGE
         B     FINAL03            HANDLE NEXT ALIAS
FINAL12  LA    R1,FINAL32         LOAD ERROR RETURN POINT
         BAL   R14,ALIASMRG       UPDATE ALIAS DIRECTORY
         LR    R0,R7              LOAD PTR TO ALIAS DIRECTORY ENTRY
         STOW  OUTPUT,(0),R       RESTOW
         LTR   R15,R15            WAS STOW SUCCESSFUL
         BNZ   FINAL13            IF NOT, BRANCH
         BAL   R3,GOODEND         INDICATE GOOD ALIAS COPY
         B     FINAL03
FINAL13  STOW  OUTPUT,(7),D       TRY TO REMOVE ORIGINAL ENTRY
         LA    R15,ERRORN54       INDICATE UNSUCCESSFULL STOW
         BAL   R3,SCRMEM01        WRITE ERROR MESG
FINAL03  LA    R8,4(R8)           PT TO NEXT ALIASTAB ENTRY
         B     FINAL01            HANDLE NEXT ALIAS ENTRY
*****       START OF ALIAS PROCESSOR                              *****
ALIASP01 CLI   0(R8),X'70'        IS THIS A GOOD ALIASTAB ENTRY
         BNE   ALIASP02           IF YES, BRANCH
         LA    R8,4(R8)           PT TO NEXT ALIASTAB ENTRY
         B     ALIASP01           TRY AGAIN
ALIASP02 L     R6,0(R8)            GET ADDR OF MAIN MEMBER
         CR    R7,R6         HAS MAIN MEMBR BEEN PROCESSED (LOWER ADDR)
         BL    ALIASP03           IF NOT, BRANCH
         CLC   8(4,R6),HEXFFS     WAS MAIN MEMBER COPIED OK
         BNE   ALIASP12           IF YES, BRANCH
         LA    R15,ERRORN68       INDICATE MAIN MEMBER IN ERROR
ALIASP22 B     SCRATCHM           WRITE ERROR MESSAGE
ALIASP12 LA    R1,ALIASP22        ERROR RETURN POINT
         BAL   R14,ALIASMRG       UPDATE ALIAS DIRECTORY ENTRY
         MVI   0(R8),X'70'        INDICATE ENTRY IS COMPLETE
         LA    R8,4(R8)           UPDATE ALIASTAB PTR
         B     BPAMEOD7           GO STOW
ALIASP03 ST    R6,WORK            MOVE ALIAS ADDR TO WORK
         ST    R7,0(R8)           CHANGE ALIASTAB ENTRY TO ALIAS ADDR
         LA    R8,4(R8)           UPDATE ALIASTAB PTR
         MVC   PDSTTR(3),WORK+1   INSERT MAIN ADDR INTO ALIAS TTR FIELD
***** NOTE-   ALIAS STOW DOES NOT VERIFY TTR VALUE
         STOW  OUTPUT,(7),A       STOW PLACE-HOLDER ALIAS ENTRY
         LTR   R15,R15            WAS STOW GOOD
         BZ    MEMBEND1           IF YES, PROCESS NEXT MEMBER
         B     BPAMEOD8           IF NOT, FLAG ENTRY AS 'COMPLETE'
PARTITIO TM    PDSC,X'60'         ANY TTRN FIELDS
         BNZ   TTRNREAD           IF YES, BR TO SPECIAL RTNE
         MVC   WORK(3),PDSTTR     MOVE TTR TO FW BOUNDARY
         MVI   WORK+3,0           ZERO BYTE
         POINT INPUT,WORK         PT TO CURRENT MEMBER
         B     SEQIO00            BR TO NORMAL SEQ I/O ROUTINE
         SPACE 5
*****  THE NEXT I/O ROUTINE IS USED IF THE MEMBER HAS TTRN VALUES *****
TTRNREAD L     R6,TTRNADDR        INIT TTRNPTR AND R6
         USING TTRNTABL,R6
         ST    R6,TTRNPTR
         MVI   BPAMEODZ+1,X'F0'   CHANGE INSTR TO BRANCH **************
         SR    R2,R2
         MVC   TTRNTABL(MAXTTRNS*4),TTRNTABL-1   CLEAR TTRNTABL
         MVC   TTRNTABL+MAXTTRNS*4(MAXTTRNS*4),TTRNTABL-1+MAXTTRNS*4
         DROP  R6
         IC    R2,PDSC            INSERT C FIELD
         SRL   R2,5               ISOLATE TTRN COUNT
         STC   R2,TTRCOUNT        SET NO. OF TTRN FIELDS
         LA    R5,PDSUSER         POINT TO 1ST TTRN FIELD
MOVETTRN CLI   0(R6),X'FF'        IS TTRNTABL FULL
         BE    TTRNERR1           IF YES, BRANCH TO ERROR ROUTINE
         ST    R5,0(R6)           INSERT TTRN ADDRESS
         MVI   0(R6),X'80'        INDICATE TTRN ENTRY
         MVC   4(4,R6),0(R5)      INSERT TTRN VALUE
         LR    R10,R6             SAVE PTR TO TTRN ENTRY FOR NOTELIST
         CLI   3(R5),0            IS N VALUE=0
         LA    R6,8(R6)           UPDATE TTRNTABL PTR
         BE    MVETTRN2           IF YES, BR.  NO NOTELIST
         MVC   WORK(3),0(R5)      MOVE NOTELIST REC TTR TO FW
         MVI   WORK+3,0
         POINT INPUT,WORK         POINT TO NOTELIST RECORD
         LA    R1,RDECB2          LOAD READ DECB ADDR
         BAL   R14,READBLK        ISSUE READ FOR NOTELIST REC
         LA    R1,RDECB2          LOAD READ DECB ADDR
         BAL   R14,READCHK        CHECK READ
         SR    R1,R1
         LR    R15,R1
         IC    R15,3(R5)          INSERT NO. OF ENTRIES IN NOTELIST
         LR    R0,R15             IN USE ENTRY COUNT
         L     R3,RDECB2+12       LOAD RECORD ADDR
MVETTRN1 CLI   0(R6),X'FF'        IS THIS THE TABLE END
         BE    TTRNERR1           IF YES, BRANCH
         CLC   0(3,R3),ZERO       IS THE ENTRY EMPTY
         BNE   MVETTRN5           IF NOT, BRANCH
         BCTR  R0,0               DECREASE ACTUAL COUNT BY 1
         B     MVETTRN6           BRANCH
MVETTRN5 MVC   1(3,R6),0(R5)      INSERT TTR OF NOTELIST RECORD
         MVI   0(R6),X'0F'        FLAG AS NOTELIST ENTRY, NOT FOUND
         MVC   4(3,R6),0(R3)      INSERT NOTELIST ENTRY TTR VALUE
         STC   R1,7(R6)           INSERT NOTELIST ENTRY OFFSET
         LA    R6,8(R6)           UPDATE TTRNTABL PTR
MVETTRN6 LA    R1,4(R1)           UPDATE OFFSET VALUE
         LA    R3,4(R3)           UPDATE NOTELIST ENTRY PTR
         BCT   R15,MVETTRN1       HANDLE NEXT NOTELIST ENTRY
         STC   R0,7(R10)          INSERT ACTUAL TTR COUNT IN TTRN ENTRY
         IC    R15,TTRCOUNT       UPDATE TTR COUNT
         AR    R0,R15
         STC   R0,TTRCOUNT
MVETTRN2 LA    R5,4(R5)           PT TO NEXT TTRN FIELD
         BCT   R2,MOVETTRN        HANDLE NEXT TTRN
*****    SORT TTRNTABL ENTRIES IN ASCENDING ORDER OF TTR VALUE
         L     R6,TTRNADDR        INIT TTRNTABL PTR
TTRSORT1 LA    R5,8(R6)           INIT 1ST COMPARE ENTRY PTR
         TM    0(R5),X'7F'        IS THIS THE TABLE END
         BO    TTRSORT4           IF YES, BRANCH OUT
TTRSORT2 CLC   4(3,R6),4(R5)      IS TOP ENTRY .LE. CURRENT ENTRY
         BNH   TTRSORT3           IF YES, BYPASS SWAP
         MVC   WORK(8),0(R6)      SWAP TOP AND CURRENT ENTRIES
         MVC   0(8,R6),0(R5)
         MVC   0(8,R5),WORK
TTRSORT3 LA    R5,8(R5)           UPDATE CURRENT ENTRY PTR
         TM    0(R5),X'7F'        IS THIS THE TABLE END
         BNO   TTRSORT2           IF NOT,CONTINUE
         LA    R6,8(R6)           UPDATE TOP ENTRY PTR
         B     TTRSORT1
TTRSORT4 MVC   WORK(3),PDSTTR     REPOSITION TO START OF MEMBER
         MVI   WORK+3,0
         POINT INPUT,WORK
         L     R3,TTRNADDR        POINT TO 1ST TTRN VALUE
         BAL   R14,DISKCCHH       GET MBBCCHHR FOR 1ST TTR
TTRIOML0 EQU   *        MAIN I/O ROUTINE FOR MEMBERS WITH TTR'S
         LA    R1,RDECB2          LOAD READ1 DECB ADDR
         BAL   R14,READBLK        ISSUE READ 1
TTRIOML1 LA    R1,RDECB3          LOAD READ2 DECB ADDR
         BAL   R14,READBLK        ISSUE READ 2
         LA    R1,RDECB2          LOAD READ1 DECB ADDR
         BAL   R10,TTREADCK       CHECK READ1
         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR
         BAL   R10,TTRWRITE       ISSUE WRITE1
         LA    R1,RDECB3          LOAD READ2 DECB ADDR
         BAL   R10,TTREADCK       CHECK READ2
         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR
         BAL   R10,TTRWRITE       ISSUE WRITE2
         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR
         BAL   R14,WRITECHK       CHECK WRITE 1
         LA    R1,RDECB2          LOAD READ1 DECB ADDR
         BAL   R14,READBLK        ISSUE READ 1
         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR
         BAL   R14,WRITECHK       CHECK WRITE 2
         B     TTRIOML1           CONTINUE I/O
         SPACE 5
*  THE FOLLOWING SUBROUTINES ARE USED IN CONJUNCTION WITH THE         *
*  MAINLINE I/O LOOP ABOVE TO UPDATE THE TTRN FIELDS WITHIN THE       *
*  DIRECTORY OR NOTELIST.                                             *
TTREADCK EQU   *                  CHECK READ FOR TTR RECORD
         LR    R2,R1              SAVE DECB PTR
         BAL   R14,READCHK        CHECK READ
         L     R1,16(R2)          LOAD IOB ADDR OF READ
         LA    R1,0(R1)           CLEAR HIGH BYTE
         SH    R1,HW8             PT TO NEXT IOB PTR
         L     R1,0(R1)           LOAD IOB ADDR OF NEXT READ
*****  NOTE-- WITH MULTIPLE IOB'S, BSAM DOES NOT USE THE DCBFDAD
*****  FIELD FOR INPUT (IT STILL DOES FOR OUTPUT) BUT KEEPS THE
*****  EQUIVALENT IN THE IOBSEEK FIELD OF THE NEXT AVAILABLE IOB
         CLC   32+8(8,R1),WORK    IS THIS A TTR RECORD
         BCR   7,R10              IF NOT, RETURN
         L     R1,20(R2)          LOAD ADDR OF ASSOCIATED WRITE DECB
         L     R3,TTRNPTR         LOAD PTR TO CURRENT TTRNTABL ENTRY
         ST    R3,24(R1)          FLAG WRITE DECB AS A TTR RECORD
         TM    0(R3),X'80'        SEE IF THIS IS A NOTELIST RECORD
         BZ    TTREAD0            IF NOT, BRANCH
         CLI   7(R3),0
         BE    TTREAD0            IF NOT, BRANCH
         MVI   24(R1),X'FF'       FLAG AS A NOTELIST REC FOR WRT RTNE
TTREAD0  LR    R1,R3              SAVE CURRENT TTRNTABL PTR
         LA    R3,8(R3)           UPDATE TTRNTABL PTR
         ST    R3,TTRNPTR
         TM    0(R3),X'7F'        IS THIS THE TABLE END
         BNO   TTREAD1            IF NOT, BRANCH
         XC    WORK(8),WORK       CLEAR WORK TO PREVENT FURTHER TTR
*                                 RECORD GOOD COMPARES
         BR    R10                RETURN
TTREAD1  CLC   4(3,R1),4(R3)      ARE ENTRIES FOR THE SAME RECORD
         BE    TTREAD0            IF YES, LOOK FOR NEXT NEW REC ENTRY
         BAL   R14,DISKCCHH       GET DISK ADDR FOR NEW RECORD
         BR    R10                RETURN
         SPACE 3
TTRWRITE EQU   *                  CHECK FOR TTRN REC/WRITE RECORD
         L     R3,24(R1)          LOAD TTRN FIELD FOR THIS DECB
         LTR   R3,R3              CHECK VALUE
         BNZ   TTRWRIT0           IF ZERO, THIS IS NOT A TTRN REC
         BAL   R14,WRITEBLK       WRITE RECORD
         BR    R10                RETURN
TTRWRIT0 BP    TTRWRIT3           IF +, THIS IS A TTR RECORD
         LR    R0,R1              THIS IS A NOTELIST REC. SAVE DECB PTR
         L     R1,20(R1)          LOAD ADDR OF ASSOCIATED READ DECB
         BAL   R14,NOTELIST       ATTEMPT TO UPDATE NOTELIST RECORD
         BZ    TTRWRIT1           IF SUCCESSFUL, BRANCH
         MVI   0(R3),X'90'        FLAG ENTRY AS REQUIRING RE-PROCESSING
         B     TTRWRIT2           BYPASS UPDATING TTR COUNT
TTRWRIT1 STC   R5,TTRCOUNT        UPDATE TTR COUNT
TTRWRIT2 LR    R1,R0              RESTORE DECB ADDR TO R1
TTRWRIT3 BAL   R14,WRITEBLK       ISSUE WRITE
         SR    R5,R5              CLEAR R5
         ST    R5,24(R1)          CLEAR TTRN FIELD IN DECB
         TM    0(R3),X'80'        IS THIS A TTRN ENTRY
         BZ    TTRNWRT0           IF NOT, MUST BE A NOTELIST ENTRY
         BAL   R14,DISKTTR        GET TTR0 OF THIS RECORD
TTR0F80  ST    R0,WORK2           MOVE TTR0 TO CORE
TTR8080  L     R2,0(R3)           LOAD TTRN ADDR FROM TABLE
         MVC   0(3,R2),WORK2      UPDATE TTR FIELD WITHIN DIRECTORY
         IC    R5,TTRCOUNT        UPDATE REMAINING TTR COUNT
         BCTR  R5,0
         STC   R5,TTRCOUNT
NEXTTR   LR    R1,R3              SAVE CURRENT TTRNTABL PTR
         LA    R3,8(R3)           POINT TO NEXT ENTRY
         TM    0(R3),X'7F'        IS THIS THE TABLE END
         BCR   1,R10              IF YES, RETURN
**  CHECK FOR 2 ENTRIES FOR THE SAME RECORD
         CLI   0(R1),0            WAS PREVIOUS ENTRY FOR A NOTELIST
         BNE   NEXTTR1            IF NOT, BRANCH
         CLC   1(3,R1),4(R3)      IS TTR REC SAME AS PREVIOUS ENTRY
         BCR   7,R10              IF NOT, RETURN
         TM    0(R3),X'80'        IS CURRENT ENTRY A TTRN
         BZ    TTR0F0F            IF NOT, BRANCH
         SLL   R0,8               REPOSITION R0
         B     TTR0F80            BRANCH
NEXTTR1  CLC   4(3,R1),4(R3)      IS TTR REC SAME AS PREVIOUS ENTRY
         BCR   7,R10              IF NOT, RETURN
         TM    0(R3),X'80'        IS CURRENT ENTRY A TTRN
         BO    TTR8080            IF YES, BRANCH
         B     TTR800F            IF NOT, MUST BE A NOTELIST ENTRY
TTRNWRT0 BAL   R14,DISKTTR        GET TTR0 FOR THIS RECORD
TTR800F  SRL   R0,8               CHANGE TO 0TTR
TTR0F0F  MVC   4(3,R3),1(R3)      MOVE TTR OF NOTELIST REC TO WORD 2
         ST    R0,0(R3)           INSERT NEW TTR VALUE AND CLEAR
*                                 NOT FOUND FLAG
         B     NEXTTR
         SPACE 3
DISKTTR  EQU   *                  MBBCCHHR TO TTR CONVERSION ROUTINE
         L     R1,OUTPUT+DCBDEBAD-1    LOAD DEB ADDR
         MVC   WORK2(8),OUTPUT+5  MOVE MBBCCHHR TO WORKAREA
DISKTTR0 LA    R1,0(R1)           CLEAR HIGH BYTE
         L     R15,16             LOAD CVT PTR
         L     R15,X'20'(R15)     LOAD ADDR OF CONVERSION ROUTINE
         LA    R2,WORK2           POINT TO MBBCCHHR VALUE
         SR    R0,R0              CLEAR R0
         STM   R1,R14,SA2+12      SAVE REGS THAT CONVERT RTNE DESTROYS
         BALR  R14,R15            BR TO CONVERT ROUTINE
         USING *,R14              TEMP BASE REG TO RESTORE REGS
         DROP  R13
         LM    R1,R14,SA2+12      RESTORE REGS
         USING SA,R13
         DROP  R14
         BR    R14                RETURN
DISKCCHH EQU   *                  TTR TO MBBCCHHR CONVERSION RTNE
         L     R15,16             LOAD POINTER TO CVT
         L     R15,X'1C'(R15)     LOAD ADDR OF CONVERSION RTNE
         L     R1,INPUT+DCBDEBAD-1     LOAD DEB ADDRESS
         LA    R1,0(R1)           CLEAR HIGH BYTE
         LA    R2,WORK            PT TO AREA WHERE MBBCCHHR TO BE PUT
         L     R0,4(R3)           LOAD TTRX VALUE
         IC    R0,ZERO            CLEAR LOW BYTE
         STM   R1,R14,SA2+8       SAVE REGS THAT CONVERT RTNE DESTROYS
         BALR  R14,R15            BR TO CONVERT RTNE
         USING *,R14              TEMP BASE REG TO RESTORE REGS
         DROP  R13
         LM    R1,R14,SA2+8       RESTORE REGS
         USING SA,R13
         DROP  R14
         BR    R14                RETURN
         SPACE 3
***********************************************************************
*****               SA AND SA2 MUST BE ADDRESSABLE BY R12         *****
*****               AND ARE PUT HERE FOR THAT REASON              *****
***********************************************************************
         SPACE 1
SA       DC    18F'0'             COPYPACK SAVEAREA
EOJECB   DS    0F                 EOJECB FOR WTORRTNE SUBTASK
SA2      DC    18F'0'             TEMP STORAGE AREA AND HITDSCB SA
***********************************************************************
***********************************************************************
         SPACE 5
**  THIS SUBRTNE ATTEMPTS TO UPDATE THE TTRN FIELDS IN A NOTELIST REC
NOTELIST L     R2,TTRNADDR        INIT PTR TO TOP OF TTRNTABL
         L     R6,12(R1)          LOAD NOTELST REC ADDR FROM DECB
         SR    R5,R5              CLEAR R5
         LR    R1,R5              CLEAR R1
         IC    R5,TTRCOUNT        LOAD COUNT OF TTRS STILL TO BE UPDTED
         IC    R1,7(R3)           GET NO. OF TTR'S IN THIS NOTELIST
TTRNOTE2 CLI   0(R2),0            FIND A NOTELIST-FOUND ENTRY
         BNE   TTRNOTE3           IF NOT, BRANCH
         CLC   4(3,R2),4(R3)      IS ENTRY FOR THIS NOTELIST
         BNE   TTRNOTE3           IF NOT, BRANCH
         SR    R15,R15            CLEAR R1K
         IC    R15,7(R2)          GET NOTELIST ENTRY OFFSET
         LA    R15,0(R6,R15)      PT TO NOTELIST ENTRY OFFSET
         MVC   0(3,R15),1(R2)     UPDATE NOTELIST ENTRY
         BCTR  R5,0               DECREASE TOTAL TTR COUNT BY 1
         BCTR  R1,0               DEC NOTELIST ENTRY COUNT BY 1
TTRNOTE3 LA    R2,8(R2)           PT TO NEXT TTRNTABL ENTRY
         TM    0(R2),X'7F'        IS THIS THE TABLE END
         BNO   TTRNOTE2           IF NOT, CONTINUE
         LTR   R1,R1    HAVE ALL ENTRIES WITHIN THIS REC BEEN UPDATED
         BR    R14                RETURN.LET CALLING RTNE CHK COND CODE
         SPACE 3
TTRNERR1 LA    R15,ERRORN6C       INDICATE TOO MANY TTR'S FOR PGM
         MVC   PDSTTR(4),HEXFFS   FLAG MEMBR AS NOT BEING COPIED
         B     SCRATCHM           BR TO BAD COPY MEMBER RTNE
TTRNERR2 BAL   R6,QUIESCE         HALT ANY OUTSTANDING MULTIPLE I/O
         LA    R15,ERRORN70       INDICATE ERR IN UPDATING TTRN FIELDS
TTRNERR3 MVI   TTRCOUNT,0         CLEAR TTRN FLAGS AND VALUES
         MVI   BPAMEODZ+1,X'00'   CHANGE INSTR BACK TO NOP*************
         MVC   PDSTTR(4),HEXFFS   FLAG MEMBER AS NOT BEING COPIED
         BAL   R3,SCRMEM01        WRITE ERROR MESSAGE
         B     BPAMSYN7           CLEAR DIRECTORY FOR THIS MEMBER
         SPACE 5
***** PARTITDS SUBROUTINE WHICH UPDATES THE TTR AND TTRN FIELDS   *****
*****   OF ALIASES WITH THAT FROM THE CORRECT MAIN MEMBER.        *****
ALIASMRG EQU   *             THIS RTNE UPDATES AN ALIAS ENTRY W/ THE
*                            CORRECT TTR AND TTRN VALUES
         IC    R2,PDSC            INSERT ALIAS C FIELD
         N     R2,TTRMASK         ISOLATE TTRN COUNT
         IC    R3,11(R6)          INSERT MAIN C FIELD
         N     R3,TTRMASK         ISOLATE TTRN COUNT
         CR    R2,R3              ARE COUNTS EQUAL
         BE    AMERGE01           IF YES, BRANCH
         LA    R15,ERRORN58  ALIAS TTR/ MAIN TTR COUNTS DON'T MATCH
         BR    R1                 USE ERROR RETURN
MOVEFLDS MVC   PDSTTR(0),8(R6)    THIS INSTRUCTION EX'ED BELOW
AMERGE01 SRL   R2,5               CHANGE TO BYTE COUNT
         SLL   R2,2
         LA    R2,4(R2)           INCLUDE TTRC LENGTH
         BCTR  R2,0               DECREASE BY 1 FOR MVC
         IC    R3,PDSC       SAVE C FIELD (MAY BE DIFFERENT FROM MAIN)
         EX    R2,MOVEFLDS        MOVE IN TTRC AND TTRN'S FROM MAIN
         STC   R3,PDSC            RESTORE C FIELD IN ALIAS
         BR    R14                RETURN
         SPACE 5
***********************************************************************
*****            BPAM EODAD ROUTINE                               *****
***********************************************************************
         SPACE 5
BPAMEOD  LA    R2,RDECB3          WAS EOF ON CHECKING READ2
         CR    R1,R2              IF YES, WRITE1 MUST STILL BE CHECKED
BPAMEODZ NOP   BPAMEODA           SET TO BRANCH IF MEMBER HAS TTRN'S
         BNE   BPAMEOD7           BYPASS CHECK IF EOF ON READ1
         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR
         BAL   R14,WRITECHK       CHECK WRITE
         B     BPAMEOD7           CONTINUE WITH EOF PROCESSING
BPAMEODA BNE   BPAMEODC           BYPASS CHECK IF EOF ON READ1
         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR
         BAL   R14,WRITECHK       CHECK WRITE
BPAMEODC CLI   TTRCOUNT,0         HAVE ALL TTRN'S BEEN UPDATED OK
         BE    BPAMEOD6           IF YES, BRANCH
         B     TTRNERR2           BR TO ERROR ROUTINE
BPAMEOD6 MVI   BPAMEODZ+1,X'00'   RESTORE INSTR TO NOP ****************
BPAMEOD7 LR    R0,R7              PT TO MEMBER DIRECTORY ENTRY
         STOW  OUTPUT,(0),A       STOW MEMBER
         LTR   R15,R15            WAS STOW SUCCESSFUL
         BZ    PGOODEND           IF YES, BRANCH
         STOW  OUTPUT,(7),D       DELETE BAD STOW
         LA    R15,ERRORN54       INDICATE UNSUCCESSFULL STOW
         TM    PDSC,X'80'         IS THIS AN ALIAS ENTRY
         BZ    BPAMEOD9           IF NOT, BRANCH
BPAMEOD8 LA    R1,4(R8)           BACKUP TO 'CURRENT' ALIASTAB ENTRY
         SH    R1,HW8
         MVI   0(R1),X'70'        FLAG ENTRY AS COMPLETE
         B     SCRATCHM           INDICATE BAD MEMBER COPY
BPAMEOD9 MVC   PDSTTR(4),HEXFFS   FLAG AS BAD MEMBER COPY
         B     SCRATCHM           INDICATE BAD MEMBER COPY
         SPACE 5
***********************************************************************
*****                 PDS MEMBER GOOD COPY ROUTINE                *****
***********************************************************************
PGOODEND LA    R3,MEMBEND1        LOAD NEXT RTNE ADDR
GOODEND  NOP   GOODMEM            FALL THROUGH IF I/O IN PROGRESS
         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS
GOODMEM  NOP   GOODMEM1           BR AFTER 1ST GOOD MEMBER COPY
         MVI   GOODMEM+1,X'F0'    INDICATE 1ST GOOD MEMBER COPY
         MVC   0(33,R11),DSCBUFR+DS1DSNAM   MOVE IN DSNAME (33 CHARS)
         MVC   34(6,R11),MEMBREQ  MOVE IN MEMBER HEADER
         LA    R11,40(R11)        UPDATE PTR PASSED DSNAME
         MVI   GOODFULL+1,X'F0'   INDICATE ON A FULL FIELD
         CLI   0(R11),X'FF'       IS THE BUFFER FULL
         BNE   GOODMEM1           IF NOT, GO INSERT MEMBER NAME
         BAL   R14,WRTGOOD        OUTPUT BUFFER
         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS
GOODMEM1 MVC   1(8,R11),PDSNAME   INSERT MEMBER NAME
         TM    PDSC,X'80'         IS THIS AN ALIAS
         BNO   GOODMEM2
         MVI   0(R11),C'*'        INDICATE AN ALIAS
GOODMEM2 LA    R11,20(R11)        UPDATE GOODBUFR PTR
         XI    GOODFULL+1,X'F0'   FLIP GOODFULL FLAG
         CLI   0(R11),X'FF'       IS THE BUFFER FULL
         BCR   7,R3               IF NOT, BRANCH    (  BNE  0(R3)  )
         BAL   R14,WRITGOOD       OUTPUT BUFFER
         BR    R3                 BR TO NEXT ROUTINE
         SPACE 5
MEMBEND1 LA    R4,2(R4)           UPDATE MEMTABLE PTR
         LH    R5,0(R4)           GET OFFSET FOR NEXT MEMBER
         N     R5,OFFSET           CLEAR ALIAS FLAG IF PRESENT
         AR    R7,R5              PT TO NEXT MEMBER
         B     NEXTMEM            HANDLE NEXT MEMBER
         SPACE 5
***********************************************************************
*****                PDS MEMBER BAD COPY ROUTINE                  *****
***********************************************************************
         SPACE 5
SCRATCHM LA    R3,MEMBEND1        LOAD RETURN PT ADDR
SCRMEM01 ST    R15,SA             SAVE ERROR CODE
         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS
         BNE   BADMEM             IF NOT, BRANCH
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
BADMEM   NOP   BADMEM1            BR AFTER 1ST BAD MEMBER COPY
         MVI   BADMEM+1,X'F0'     INDICATE 1ST BAD MEMBER COPY
         MVC   0(40,R9),DSCBUFR+DS1DSNAM    INSERT DSNAME (40 CHARS)
         MVC   41(19,R9),MEMNOCPY INSERT BAD MEMBER HEADER
         LA    R9,60(R9)          UPDATE BUFR PTR PASSED DSNAME
         CLI   0(R9),X'FF'        IS THE BUFFER FULL
         BNE   BADMEM1            IF NOT, GO INSERT MEMBER NAME
         BAL   R14,WRITBAD        OUTPUT BUFFER
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
BADMEM1  MVC   1(8,R9),PDSNAME    INSERT MEMBER NAME
         TM    0(R4),X'80'        IS THIS AN ALIAS
         BNO   BADMEM2            IF NOT, BRANCH
         MVI   0(R9),C'*'         INDICATE AN ALIAS
BADMEM2  MVC   10(4,R9),ERRCODE   MOVE IN ERROR CODE BRACKETS
         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE HEX
         TR    WORK(2),TRTABLE-X'F0'
         MVC   11(2,R9),WORK      MOVE CODE INTO BUFFER
         LA    R9,30(R9)          UPDATE BADBUFR PTR
         XI    BADFULL+1,X'F0'    FLIP BADFULL FLAG
         CLI   0(R9),X'FF'        IS THE BUFFER FULL
         BCR   7,R3               IF NOT, GO TO NEXT RTNE
         BAL   R14,WRITEBAD       OUTPUT BUFFER
         BR    R3                 RETURN OR GO TO MEMBEND1
         SPACE 5
***********************************************************************
*****                     BPAM SYNAD ROUTINE                      *****
***********************************************************************
 SPACE 4
PARSYNAD EQU   *                  PARTITIONED I/O ERROR ROUTINE
         NI    DCBIFLGS(R1),X'3F' TURN OFF ERROR FLAGS IN DCB SO IT
         NI    DCBCIND2(R1),X'EF' CAN BE REUSED
BPAMSYN0 NOP   BPAMSYN2           SET TO BRANCH IF SYNAD ROUTINE ******
*                       MUST CHECK TO PREVENT A SYNAD LOOP       ******
         LR    R2,R0              SAVE DECB ADDR
         SYNADAF ACSMETH=BPAM
         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF
         DROP  R13
         LA    R13,SA             RESTORE MY SA ADDR (2ND BASE REG)
         USING SA,R13
         ST    R1,SA              SAVE PTR TO SYNAD MESSAGE
         MVI   BPAMSYN0+1,X'F0'   ALTER INSTR IN CASE CHECK ENTERS*****
*                                 SYNAD RTNE AGAIN (FROM QUIESCE)
         BAL   R6,QUIESCE         HALT ANY OUTSTANDING MULTIPLE I/O
BPAMSYN2 MVI   BPAMSYN0+1,X'00'   RESTORE TO NOP            ***********
BPAMSYN3 EQU   *   AT THIS PT, ALL OUTSTANDING I/O SHOULD BE COMPLETE
         MVC   PDSTTR(4),HEXFFS   FLAG MEMBER AS BAD COPY
         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS FOR BADCOPY
         BNE   BADFULL            IF NOT, BRANCH
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
         B     BPAMSYN5
BADFULL  B     BPAMSYN4           NOP'ED IF ON A HALF FIELD
         LA    R9,30(R9)          PT TO NEXT FULL FIELD
         MVI   BADFULL+1,X'F0'    INDICATE ON A FULL FIELD
BPAMSYN4 CLI   0(R9),X'FF'        IS BUFFER FULL
         BNE   BPAMSYN5           IF NOT, BRANCH
         BAL   R14,WRITBAD        OUTPUT BUFFER
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
BPAMSYN5 CLI   BADMEM+1,X'F0'     IS THIS THE 1ST MEMBER
         BE    BPAMSYN6           IF NOT, BRANCH
         MVI   BADMEM+1,X'F0'     INDICATE 1ST BAD MEMBER
         MVC   0(40,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (40 CHARS)
         MVC   41(19,R9),MEMNOCPY INSERT BAD MEMBER HEADER
         LA    R9,60(R9)          UPDATE BADBUFR PTR
         CLI   0(R9),X'FF'        IS BUFFER FULL
         BNE   BPAMSYN6           IF NOT, BRANCH
         BAL   R14,WRITBAD        WRITE BUFFER
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
BPAMSYN6 MVC   1(8,R9),PDSNAME    INSERT MEMBER NAME
         MVC   10(4,R9),ERRCODE   INDICATE I/O ERROR
         LA    R3,15(R9)          SET PTR FOR SYNADCMP
         BAL   R2,SYNADCMP        BUILD ERROR MESG
BPAMSYN7 STOW  OUTPUT,DUMMY,R     DUMMY STOW TO RESET I/O FIELDS
         STOW  OUTPUT,DUMMY,D     DELETE DUMMY MEMBER
         B     MEMBEND1           GO PROCESS NEXT MEMBER
         SPACE 5
*****  THIS ROUTINE WILL HALT ANY I/O OUTSTANDING FROM THE MULTIPLE
*****  I/O ROUTINES FOR BSAM AND BPAM
QUIESCE  LA    R3,IOTABLE         INIT PTR TO DECB LIST
         LA    R10,4              MAX NUMBER OF DECBS TO EXAMINE
QUIESCE0 L     R1,0(R3)           LOAD NEXT DECB ADDR
         CLI   0(R1),0            IS DECB IN USE
         BNE   QUIESCE1           IF NOT, BRANCH
         L     R2,16(R1)          LOAD PTR TO IOB
         LTR   R2,R2              VERIFY IOB ADDR
         BZ    QUIESCE1           IF ZERO, BRANCH
         LA    R2,0(R2)           CLEAR HIGH BYTE
         SH    R2,HW8             PT TO IOB PREFIX
         TM    0(R2),X'60'        IS THERE ANY OUTSTANDING I/O
         BZ    QUIESCE1           IF NOT, BRANCH
         CHECK (1)                CHECK DECB
         BR    R6       RETURN. THERE CAN BE A MAX OF 1 ACTIVE DECB
QUIESCE1 LA    R3,4(R3)           PT TO NEXT DECB ADDR
         BCT   R10,QUIESCE0       BR IF ANOTHER DECB TO CHK
         BR    R6                 RETURN
         EJECT
***********************************************************************
*****    START OF PHYSICAL SEQUENTIAL COPY ROUTINES               *****
***********************************************************************
         SPACE 5
PHYSEQDS EQU   *                  COPY PS DATA SET ROUTINE
         BAL   R10,ALLOCDS        ALLOCATE PS DS ON TOPACK
         LA    R6,PHYSYNAD        LOAD SYNAD ADDR
         ST    R6,INPUT+DCBSYNAD-1     INSERT ADDR INTO DCBS
         ST    R6,OUTPUT+DCBSYNAD-1
         LA    R6,DATAEND         LOAD PS EOF RTNE ADDR
         ST    R6,INPUT+DCBEODAD-1     INSERT AS EODAD ADDR IN DCB
         OPEN  (INPUT,INPUT,OUTPUT,OUTPUT),TYPE=J
         SPACE 5
SEQIO00  EQU   *        MAIN SEQ I/O ROUTINE     (BSAM AND BPAM)
         LA    R1,RDECB2          LOAD READ1 DECB ADDR
         BAL   R14,READBLK        ISSUE READ 1
SEQIO01  LA    R1,RDECB3          LOAD READ2 DECB ADDR
         BAL   R14,READBLK        ISSUE READ 2
         LA    R1,RDECB2          LOAD READ1 DECB ADDR
         BAL   R14,READCHK        CHECK READ 1
SEQIO02  LA    R1,WDECB1          LOAD WRITE1 DECB ADDR
         BAL   R14,WRITEBLK       ISSUE WRITE 1
         LA    R1,RDECB3          LOAD READ2 DECB ADDR
         BAL   R14,READCHK        CHECK READ 2
SEQIO03  LA    R1,WDECB2          LOAD WRITE2 DECB ADDR
         BAL   R14,WRITEBLK       ISSUE WRITE 2
         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR
         BAL   R14,WRITECHK       CHECK WRITE 1
         LA    R1,RDECB2          LOAD READ1 DECB ADDR
         BAL   R14,READBLK        ISSUE READ 1
         LA    R1,WDECB2          LOAD WRITE2 DECB ADDR
         BAL   R14,WRITECHK       CHECK WRITE 2
         B     SEQIO01            CONTINUE I/O
DATAEND  EQU   *                  EODAD ROUTINE
         LA    R2,RDECB3          WAS EOF ON CHECKING READ2
         CR    R1,R2              IF YES, WRITE1 MUST STILL BE CHECKED
         BNE   PSCLOSE            IF EOF ON READ1, BYPASS CHECK
         LA    R1,WDECB1          LOAD WRITE1 DECB ADDR
         BAL   R14,WRITECHK       CHECK WRITE
PSCLOSE  CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT
         B     DSCOPYOK
         SPACE 5
***********************************************************************
*****  PHYSICAL SEQUENTIAL (AND PO DIRECTORY READ) SYNAD ROUTINE  *****
***********************************************************************
         DS    0F                 DIRSYNAD MUST BE FW ALIGNED
DIRSYNAD BAL   R10,PSYNAD0        LOAD DCB CLOSE LIST ADDR AND BRANCH
         CLOSE (DIRECTRY),MF=L    BUILD CLOSE LIST
PHYSYNAD LA    R10,PSPODCBS       LOAD DCB CLOSE LIST ADDR
PSYNAD0  SYNADAF ACSMETH=BSAM
         LR    R5,R13             SAVE SA ADDR SET UP BY SYNADAF
         DROP  R13
         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)
         USING SA,R13             RESTORE ADDRESSABILITY
         ST    R1,SA              SAVE PTR TO SYNAD MSG
         CLI   BADEND+1,X'F0'     IS I/O IN PROGRESS
         BE    PSYNAD1            IF NOT, BRANCH
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
PSYNAD1  MVC   0(25,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (25 CHARS)
         MVC   25(4,R9),ERRCODE   INDICATE I/O ERROR
         LA    R3,30(R9)          PT TO FIELD FOR SYNADCMP
         BAL   R2,SYNADCMP        BUILD ERROR MESG
         CLOSE MF=(E,(10))        CLOSE APPROPRIATE DCB'S
         BAL   R2,SCRATCHD        DELETE DATA SET
         B     READVTOC           GO COPY NEXT DATA SET
         SPACE 2
***********************************************************************
***  COMMON I/O ERROR MESSAGE BUILDING ROUTINE
***********************************************************************
SYNADCMP L     R1,SA              RESTORE PTR TO SYNAD MSG
         MVC   0(1,R3),75(R1)     MOVE IN 1ST CHAR OF DDNAME
         MVC   2(3,R3),68(R1)     MOVE IN UNIT ADDR
         MVC   6(3,R3),112(R1)    MOVE IN CCC
         MVC   9(4,R3),117(R1)    MOVE IN HHRR
         MVC   14(15,R3),91(R1)   MOVE IN ERROR DESCRIPTION
         LR    R13,R5             RESTORE SYNAD SA ADDR
         DROP  R13
         BALR  R1,0               TEMP BASE REG FOR SYNADRLS
         USING *,R1
         SYNADRLS
         DROP  R1
         USING SA,R13
         LA    R9,60(R9)          UPDATE BADBUFR PTR
         CLI   0(R9),X'FF'        IS BUFFER FULL
         BCR   7,R2               IF NOT, RETURN  ( BNE 0(R2) )
         LR    R14,R2             MOVE RETURN PT TO R14
         B     WRITEBAD           IF YES, OUTPUT BUFFER
         EJECT
***********************************************************************
*****             START OF BDAM DATA SET COPY ROUTINES            *****
***********************************************************************
         SPACE 5
BDAMDS   EQU   *
         CLI   DIFFDEV1+1,X'F0'   ARE FROM/TO DEVICES THE SAME
         BE    BDAMDS00           IF YES, BDAM COPY OK
**  TOPACK AND FROMPACK MUST BE THE SAME DEVICE TYPE FOR A BDAM COPY
         LA    R15,ERRORN7C       INDICATE BDAM COPY- TO/FROM DIFFER
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
BDAMDS00 MVI   OUTJFCB+JFCBIND1,0 DON'T RELEASE SPACE FOR BDAM
         BAL   R10,ALLOCDS        ALLOCATE DATA SET ON TOPACK
         MVI   BDAMOUT+DCBDSORG,X'40'  SET DSORG FIELD IN DCB TO PS
         LA    R6,DASYNAD         LOAD BDAM OUTPUT DCB SYNAD ADDR
         ST    R6,BDAMOUT+DCBSYNAD-1   STORE ADDRESS IN DCB
         MVI   BDAMOUT+DCBMACR+1,X'28'      MACRF=(WL)  BDAM CREATE
         MVI   BDAMOUT+DCBNCP,1   SET NCP=1
         MVC   BDAMRD00+2(2),BDMWRTFV  SET WRT RTNE EP FOR RECFM=F,V***
         TM    OUTJFCB+JFCRECFM,X'40'  IS RECFM=F
         BO    BDAMDS01           IF NOT, BRANCH
         MVI   BDAMSYN2+1,X'F0'   BYPASS RZ BEFORE CLOSE **************
         MVC   RTNCOD04+2(2),BRETRNF   ALTER BR ADDR  *****************
         LA    R6,BDAMSYN1        LOAD RECFM=F SYNAD ADDR
         B     BDAMDS02
BDAMDS01 MVC   RTNCOD04+2(2),BRETRNUV  ALTER BR ADDR  *****************
         MVI   BDAMSYN2+1,X'00'   WRITE CAPACITY REC BEFORE CLOSE******
         LA    R6,BDAMSYN0        LOAD RECFM=U OR V SYNAD ADDR
         TM    OUTJFCB+JFCRECFM,X'C0'  IS RECFM=U
         BNO   BDAMDS02           IF NOT, BRANCH
         MVC   BDAMRD00+2(2),BDMWRTU   SET WRT RTNE EP FOR RECFM=U*****
BDAMDS02 SR    R3,R3              CLEAR R3
         ST    R6,BDAMIN+DCBSYNAD-1    SET SYNAD ADDRESS IN DCB
         ST    R3,BDAMTTR         INIT TTR VALUE (001)
         MVI   BDAMR,1
         OPEN  (BDAMIN,INPUT,BDAMOUT,OUTPUT),TYPE=J
         IC    R3,BDAMIN+DCBKEYLE
         L     R4,RDECB4+20       LOAD BUFFER ADDRESS
         AR    R4,R3
         ST    R4,RDECB4+12       INSERT DATA ADDRESS
BDAMREAD READ  RDECB4,DI,BDAMIN,0,'S',0,BDAMTTR  DATA AND KEY ADDR
*                                                FILLED IN ELSEWHERE
         CHECK RDECB4
BDAMRD00 B     BDAMWRT1           BRANCH TO WRITE RTNE
         MVI   BDAMRD00+1,X'F0'   CHANGE BACK TO BR  ******************
         WRITE WDECB3,SZ,BDAMOUT       WRITE CAPACITY RECORD
         STC   R15,SAVERC         SAVE RETURN CODE FROM WRITE
         CHECK WDECB3
         CLI   SAVERC,8           TEST FOR END OF DATA SET
         BE    BDAMCLOS           IF END, BRANCH
NEXTRACK LH    R1,BDAMTT          UPDATE TRK VALUE
         LA    R1,1(R1)
         STH   R1,BDAMTT
         MVI   BDAMR,1            RESET TO RECORD 1
         B     BDAMREAD           TRY TO READ REC ON NEXT TRK
BDAMWRT0 LH    R1,BDAMIN+DCBBLKSI LOAD READ LENGTH (FOR RECFM=U ONLY)
         L     R2,RDECB4+16       LOAD IOB ADDRESS
         SH    R1,14(R2)          SUBTRACT RESIDUAL BYTE COUNT
         STH   R1,WDECB1+6        INSERT WRITE LENGTH
BDAMWRT1 IC    R3,BDAMR           UPDATE RECORD VALUE
         LA    R3,1(R3)
         STC   R3,BDAMR
         WRITE WDECB1,SF,MF=E     WRITE RECORD
         STC   R15,SAVERC         SAVE WRITE RETURN CODE
         CHECK WDECB1             CHECK WRITE
         IC    R3,SAVERC          RELOAD WRITE RETURN CODE
         B     *+4(R3)            BR DEPENDING ON RC VALUE
RTNCOD00 B     BDAMREAD           GOOD WRITE. MORE SPACE ON TRK
RTNCOD04 B     NEXTRACK           FOR RECFM=F, GOOD WRITE. TRK FULL
*   FOR RECFM =U OR V, BR IS TO 'INVRETRN'. RC=4 MEANS RZ REQUIRED,
*   BUT THIS SHOULD HAVE BEEN DONE PREVIOUSLY BY NEXTRACK RTNE.
RTNCOD08 B     BDAMEOD            GOOD WRITE. DATA SET FULL
RETCOD12 EQU   *                  BAD WRITE. NO FREE IOB
INVRETRN EQU   *                  ROUT TO HANDLE UNEXPECTED RTRN CODES
         CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT
         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO
         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO
         BAL   R2,SCRATCHD        SCRATCH DATA SET
         LA    R15,ERRORN60       LOAD CODE FOR UNEXPECTED BDAM ERROR
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
         SPACE 5
***********************************************************************
*****      BDAM SYNAD AND EODAD ROUTINES (BDAM CREATE ALSO)       *****
***********************************************************************
         SPACE 5
BDAMSYN0 TM    RDECB4+1,X'80'     REC NOT FOUND (NORML COND AT TRK END
*                                 FOR RECFM = U OR V)
         BZ    BDAMSYN1           IF NOT, BRANCH
         MVI   BDAMRD00+1,X'00'   CHANGE INSTR TO NOP  ****************
         BR    R14                RETURN TO CHECK TO ACCEPT ERROR
BDAMSYN1 TM    RDECB4+1,X'04'     END OF DATA SET
         BZ    BDAMSYN3           IF NOT, BR. MUST BE PERM ERROR
BDAMEOD  EQU   *                  END OF DATA SET ROUTINE
BDAMSYN2 B     BDAMCLOS           NOP'ED IF RECFM=U OR V
         WRITE WDECB3,SZ,MF=E     WRITE FINAL CAPACITY RECORD
         CHECK WDECB3             CHECK WRITE
BDAMCLOS CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT
         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO
         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO
         B     DSCOPYOK
BDAMSYN3 SYNADAF ACSMETH=BDAM
         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF
         DROP  R13
         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)
         USING SA,R13
BDAMSYN4 ST    R1,SA              SAVE PTR TO SYNAD MESSAGE
         CLI   BADEND+1,X'F0'     IS I/O IN PROGRESS
         BE    BDAMSYN5           IF NOT, BRANCH
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
BDAMSYN5 MVC   0(25,R9),DSCBUFR+DS1DSNAM    MOVE IN DSNAME (25 CHARS)
         MVC   25(4,R9),ERRCODE   INDICATE I/O ERROR
         LA    R3,30(R9)          PT TO FIELD FOR SYNADCMP
         BAL   R2,SYNADCMP        BUILD ERROR MESSAGE
         CLOSE MF=(E,BDAMDCBS)    CLOSE BDAMIN AND BDAMOUT
         BAL   R2,SCRATCHD        DELETE DATA SET
         MVI   BDAMOUT+DCBMACR+1,X'24'      RESTORE MACRF=W FOR PS/PO
         MVI   BDAMOUT+DCBNCP,2   RESTORE NCP=2 FOR PS/PO
         B     READVTOC           GO COPY NEXT DATA SET
DASYNAD  EQU   *                  SYNAD ROUTINE FOR BDAMOUT
         SYNADAF ACSMETH=BSAM     BDAM CREATE IS BSAM
         LR    R5,R13             SAVE SA ADDR PROVIDED BY SYNADAF
         DROP  R13
         LA    R13,SA             RESTORE MY SA ADDR  (SECOND BASE REG)
         USING SA,R13
         B     BDAMSYN4           BR TO COMMON BDAM SYNAD ROUTINE
         EJECT
         SPACE 5
***********************************************************************
*****         THIS ROUTINE WRITES THE GOODCOPY RECORDS            *****
***********************************************************************
         SPACE 5
DSCOPYOK CLI   GOODEND+1,X'00'    IS I/O IN PROGRESS
         BNE   DSCOPY01           IF NOT, BRANCH
         BAL   R2,CHEKGOOD        CHECK WRITE AND RESET PTRS
DSCOPY01 MVC   0(39,R11),DSCBUFR+DS1DSNAM   MOVE IN DSNAME (39 CHARS)
         LA    R11,40(R11)        UPDATE GOODBUF PTR
         CLI   0(R11),X'FF'       IS BUFFER NOW FULL
         BNE   READVTOC           IF NOT, PROCESS NEXT DATA SET
         BAL   R14,WRITGOOD       OUTPUT BUFFER
         B     READVTOC           PROCESS NEXT DATA SET
         SPACE 5
***********************************************************************
*****      POST-ALLOCATION ERROR SCRATCH DATA SET ROUTINE         *****
***********************************************************************
SCRATCHD SR    R0,R0              INDICATE VOLUME MUST BE MOUNTED
         SCRATCH SCRCAM           SCRATCH DATA SET FROM TOPACK
         MVI   VOLIST+13,0        CLEAR RETURN CODE BYTE
         MVI   RDVTOC+1,X'F0'     DON'T UPDATE VTOC IF DS MULTI-VOL
         MVI   RCATLGSW,X'F0'     DON'T TRY AUTO RECAT FUNCTION
         BR    R2                 RETURN
         SPACE 5
***********************************************************************
*****                                                             *****
*****         THIS ROUTINE WRITES THE MAIN BADCOPY RECORDS        *****
*****                                                             *****
***********************************************************************
DSERROR  ST    R15,SA             SAVE ERROR CODE
BADEND   NOP   DSERROR1           FALL THROUGH IF I/O IN PROGRESS
         BAL   R2,CHECKBAD        CHECK WRITE AND RESET PTRS
DSERROR1 MVC   0(44,R9),DSCBUFR+DS1DSNAM    MOVE IN DS NAME
         MVC   45(4,R9),ERRCODE   INSERT ERROR FIELD
         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE HEX
         TR    WORK(2),TRTABLE-X'F0'
         MVC   46(2,R9),WORK      MOVE CODE INTO BUFFER
         LA    R9,60(R9)          UPDATE BUFFER PTR
         CLI   0(R9),X'FF'        IS PRINT BUFFER FILLED
         BNE   READVTOC           IF NOT, BRANCH
         BAL   R14,WRITEBAD       OUTPUT BUFFER
         B     READVTOC           HANDLE NEXT DATA SET
         SPACE 5
***********************************************************************
*****    COMMON READ, WRITE, AND CHECK ROUTINES USED              *****
*****    BY PHYS SEQ, PARTIT, AND GOODCOPY/BADCOPY ROUTINES       *****
***********************************************************************
         SPACE 2
WRITEBLK B     0                  BR ALTERED TO UWRITE,FVWRITE,FBWRITE
FBWRITE  LH    R15,INPUT+DCBBLKSI LOAD READ LENGTH
READPTR  EQU   20       OFFSET INTO WRITE DECB OF ASSOCIATED READ DECB
         L     R2,READPTR(R1)     LOAD READ DECB ADDR
         L     R2,16(R2)          LOAD IOB ADDR FROM READ DECB
         SH    R15,14(R2)         SUBTRACT RESIDUAL BYTE COUNT
         STH   R15,OUTPUT+DCBBLKSI  UPDATE WRITE LNGTH (FOR SHORT BLKS)
         L     R15,OUTPUT+DCBWRITE-1   LOAD WRITE ROUTINE ADDR
         BR    R15                BR TO WRITE ROUTINE (RETURN VIA R14)
UWRITE   LH    R15,MAXLNGTH       LOAD READ LENGTH (MAX BLKSIZE)
         L     R2,20(R1)          LOAD READ DECB ADDR
         L     R2,16(R2)          LOAD IOB ADDR FROM READ DECB
         LH    R2,14(R2)          LOAD RESIDUAL BYTE COUNT
         LTR   R2,R2              IS RESIDUAL COUNT ZERO
         BNP   UWRTERR            IF YES, BLK WON'T FIT ON TOPACK TRK
         SR    R15,R2             GET BLOCK LENGTH
         STH   R15,6(R1)          INSERT WRITE LNGTH INTO DECB
FVWRITE  L     R15,OUTPUT+DCBWRITE-1   LOAD WRITE RTNE ADDRESS
         BR    R15                BR TO WRITE ROUTINE  (RETURN VIA R14)
         SPACE 2
UWRTERR  BAL   R6,QUIESCE         HALT ALL I/O
         CLI   OUTPUT+DCBDSORG,X'02'   IS THIS A PDS
         BE    UWRTERR2           IF YES, BRANCH
         CLOSE MF=(E,PSPODCBS)    CLOSE INPUT AND OUTPUT)
         BAL   R2,SCRATCHD        DELETE DATA SET
         LA    R15,ERRORN78       INDICATE TRUNC ERROR
         B     DSERROR            BR TO NON-FATAL ERROR ROUTINE
UWRTERR2 LA    R15,ERRORN78       INDICATE TRUNCATION ERROR
         B     TTRNERR3           WRT ERR MSG AND DELETE MEMBER
         SPACE 3
WRITECHK L     R15,OUTPUT+DCBCHECK-1   LOAD CHECK ROUTINE ADDR
         BR    R15                RETURN
         SPACE 2
READBLK  L     R15,INPUT+DCBREAD-1     LOAD READ ROUTINE ADDR
         BR    R15                BR TO READ ROUTINE  (RETURN VIA R14)
         SPACE 2
READCHK  L     R15,INPUT+DCBCHECK-1    LOAD READ CHECK ROUT ADDR
         BR    R15                BR TO CHECK  (RETURN VIA R14)
         SPACE 2
WRITGOOD MVI   GOODEND+1,X'00'    INDICATE I/O IN PROGRESS
WRTGOOD  LA    R1,GOODECB1        LOAD DECB ADDRESS
         L     R15,GOODCOPY+DCBWRITE-1 LOAD WRITE RTNE ADDRESS
         BR    R15      BR TO WRT RTNE. (RETURN WILL BE VIA R14)
         SPACE 2
CHEKGOOD CHECK GOODECB1           WAIT FOR WRITE COMPLETION
         MVI   GOODEND+1,X'F0'    INDICATE I/O COMPLETE
         L     R11,GOODPTR        RESET GOODBUFR PTR
         USING GOODBUFR,R11
         MVI   GOODBUFR,C' '      CLEAR BUFFER
         MVC   GOODBUFR+1(119),GOODBUFR
         DROP  R11
         BR    R2                 RETURN
         SPACE 2
WRITEBAD MVI   BADEND+1,X'00'     INDICATE I/O IN PROGRESS
WRITBAD  LA    R1,BADDECB1        LOAD DECB ADDRESS
         L     R15,BADCOPY+DCBWRITE-1  LOAD WRITE RTNE ADDRESS
         BR    R15      BR TO WRT RTNE. (RETURN WILL BE VIA R14)
         SPACE 2
CHECKBAD CHECK BADDECB1           WAIT FOR WRITE COMPLETION
         MVI   BADEND+1,X'F0'     INDICATE I/O COMPLETE
         L     R9,BADPTR          RESET BADBUFR PTR
         USING BADBUFR,R9
         MVI   BADBUFR,C' '       CLEAR BADBUFR
         MVC   BADBUFR+1(119),BADBUFR
         DROP  R9
         MVI   BADFULL+1,X'F0'    INDICATE BADBUFR PTR ON A FULL FIELD
         BR    R2                 RETURN
         SPACE 5
***********************************************************************
*****  THIS ROUTINE OBTAINS THE SPACE ALLOCATION ON TOPACK        *****
***********************************************************************
         SPACE 5
ALLOCDS  EQU   *                  R0=A(JFCB),R1=A(VL UCB LIST)
         LA    R0,OUTJFCB         LOAD OUTJFCB ADDRESS
         LA    R1,UCBHOLD         PT TO UCB LIST
         SVC   32                 ISSUE DA SPACE ALLOCATION SVC
         LTR   R15,R15            WAS ALLOCATION MADE
         BNZ   DSERROR            IF NOT, BR TO NON-FATAL ERR ROUTINE
         MVI   RCATLGSW,X'00'     ENABLE AUTO RECAT IF IN USE
         BR    R10                RETURN
         SPACE 5
***********************************************************************
*****  THIS ROUTINE ALLOCATES EMPTY DATA SETS                     *****
***********************************************************************
         SPACE 5
PREALLOC EQU   *
         BAL   R10,ALLOCDS         ALLOCATE UNDEFINED DS ON TOPACK
         B     DSCOPYOK
         EJECT
***********************************************************************
*****             END OF JOB ROUTINES                             *****
***********************************************************************
ENDVTOC  EQU   *
ENDOFJOB POST  EOJECB             TERMINATE SUBTASK
         CLI   GOODEND+1,X'00'    IS I/O IN PROGRESS
         BE    END001A            IF YES, BRANCH
         C     R11,GOODPTR        IS THERE ANYTHING TO OUTPUT
         BE    END001             IF NOT, BRANCH
         BAL   R14,WRTGOOD        OUTPUT GOODBUFR
END001A  CHECK GOODECB1
END001   CLI   BADEND+1,X'00'     IS I/O IN PROGRESS
         BE    END002A            IF YES, BRANCH
         C     R9,BADPTR          IS THERE ANYTHING TO OUTPUT
         BE    END002             IF NOT, BRANCH
         BAL   R14,WRITBAD        OUTPUT BADBUFR
END002A  CHECK BADDECB1
END002   CLOSE MF=(E,MAINDCBS)    GOODCOPY,BADCOPY,FROMVTOC,TOPKVTOC
         WAIT  ECB=ENDECB         WAIT FOR SUBTASK TO END
         WTO   'COPYPACK  NORMAL END OF JOB',ROUTCDE=(2,11)
         L     R13,SA+4
         RETURN (14,12),RC=0
         SPACE 5
***********************************************************************
*****        FROMPACK VTOC I/O ERROR ROUTINE                      *****
VTOCERRF LA    R15,ERRORF28       INDICATE I/O ERROR READING VTOC
***********************************************************************
         SPACE 3
ENDSBTSK EQU   *                  TERMINATE SUBTASK
         ST    R15,SA             SAVE ERROR RETURN CODE
         POST  EOJECB             FLAG WTORRTNE TO TERMINATE
         WAIT  ECB=ENDECB         WAIT FOR SUBTASK TO EXIT
         B     EROREND1
         SPACE 3
ERROREND ST    R15,SA             SAVE RETURN CODE
EROREND1 WTO   'COPYPACK A ABNORMAL END. CHECK RETURN CODE',           X
               ROUTCDE=(2,11)
         L     R15,SA             RESTORE RETURN CODE
         L     R13,SA+4
         L     R14,12(R13)
         LM    R0,R12,20(R13)
         BR    R14
***********************************************************************
***********************************************************************
         EJECT
***********************************************************************
**********                                                   **********
**********          CONSTANTS AND STORAGE AREA               **********
**********                                                   **********
***********************************************************************
         WRITE GOODECB1,SF,GOODCOPY,GOODBUFR,MF=L     DECB FOR GOODCOPY
         WRITE BADDECB1,SF,BADCOPY,BADBUFR,MF=L  DECB FOR BADCOPY
         READ  RDECB2,SF,INPUT,0,MF=L  DECB FOR BSAM/BPAM READS
         DC    A(WDECB1)          ASSOCIATED WRITE DECB FOR RDECB2
         READ  RDECB3,SF,INPUT,0,MF=L  DECB FOR BSAM/BPAM READS
         DC    A(WDECB2)          ASSOCIATED WRITE DECB FOR RDECB3
         WRITE WDECB1,SF,OUTPUT,0,MF=L DECB FOR BSAM/BPAM/BDAM CREATE
         DC    A(RDECB2)          ASSOCIATED READ DECB FOR WDECB1
         DC    A(0)               TTR FLAG FIELD FOR WDECB1
         WRITE WDECB2,SF,OUTPUT,0,MF=L      DECB FOR BSAM/BPAM WRITE
         DC    A(RDECB3)          ASSOCIATED READ DECB FOR WDECB2
         DC    A(0)               TTR FLAG FIELD FOR WDECB2
         ORG   RDECB2                  PRESET DECBS SO
         DC    X'48'                   MULTIPLE I/O QUIESCE
         ORG   RDECB3                  ROUTINE CAN TELL
         DC    X'48'                   THE DIFFERENCE BETWEEN
         ORG   WDECB1                  A DECB WITH
         DC    X'48'                   OUTSTANDING I/O
         ORG   WDECB2                  AND ONE THAT
         DC    X'48'                   HASN'T BEEN USED
         ORG
         READ  DELDECB,SF,DELETES,DELETBUF,44,MF=L
         READ  VTCDECB2,SF,TOPKVTOC,VTOCBUFR,MF=L
BDAMDCBS CLOSE (BDAMIN,,BDAMOUT),MF=L  CLOSE LIST FOR BDAM COPY
PSPODCBS CLOSE (INPUT,,OUTPUT),MF=L    CLOSE LIST FOR PS AND PO COPY
*        FOLLOWING CLOSE LIST IS FOR DCBS THAT ARE OPEN ALL THE TIME
MAINDCBS CLOSE (GOODCOPY,,BADCOPY,,FROMVTOC,,TOPKVTOC),MF=L
GOODPTR  DC    A(GOODBUFR)
BADPTR   DC    A(BADBUFR)
MEMTBPTR DC    A(MEMTABLE)
UCBHOLD  DC    AL1(128),AL3(0)    UCB ADDRESS FOR TOPACK
DBUFADDR DC    A(DBUFFER)
TTRNADDR DC    A(TTRNTABL)
ALIASADR DC    A(ALIASTAB)
WTORADDR DC    A(WTORRTNE)
IOTABLE  DS    0F
         DC    A(RDECB2)
         DC    A(RDECB3)
         DC    A(WDECB1)
         DC    A(WDECB2)
         DS    0F
DUMMY    DC    CL8'#@$Z@#$Q',F'0'      DUMMY STOW ENTRY
         DS    0F
ZERO     EQU   *
FULL10   DC    H'0'
HALF10   DC    H'10'
FOUR     DC    F'4'               FULLWORD CONSTANT
OFFSET   DC    F'32767'           LOWER 15-BITS MASK
TTRMASK  DC    F'96'              2-BIT TTRN COUNT FIELD
LNGTHMSK DC    F'31'              5-BIT USER LENGTH FIELD
BDAMTTR  DS    0F                 RELATIVE TRK ADDR VALUE FOR BDAM READ
BDAMTT   DC    H'0'
BDAMR    DC    X'0',X'0'
*****         DSCBHOLD/DSCBTTR AND WTORNAME OCCUPY THE SAME 8 BYTES
DSCBHOLD DS    0F                 HOLDS ACTUAL SPACE AND SEC ALLOC
DSCBTTR  EQU   *+4                TTR VALUE OF TOPACK DSCB IF MULTI-VOL
WTORNAME DC    CL8'WTORRTNE'      SUBTASK EP NAME
VTOCEXLT DC    X'87',AL3(VTOCJFCB)
DIREXLST EQU   *                  USE INJFCB FOR PDS DIRECTORY READ
INEXLST  DC    X'87',AL3(INJFCB)
OUTEXLST DC    AL1(7),AL3(OUTJFCB),X'85',AL3(HITDSCB)
ENDECB   DC    F'0'
LOCLIST1 CAMLST NAME,DSCBUFR,,LOCAREA
LOCLIST2 CAMLST RECAT,DSCBUFR,,LOCAREA
FORMAT3  CAMLST SEEK,WORK,FROMVOL,FMT3BUFR
SCRCAM   CAMLST  SCRATCH,DSCBUFR+DS1DSNAM,,VOLIST,,OVRD
         ORG   COPYPACK+8         SEE NOTE AT BEGINNING OF CSECT
OVERLAY  DS    0D
DEVWORK  EQU   *                  DEVTYPE MACRO PARM AREA
SA3      EQU   *                  TEMP SA FOR TTR/CCHHR CONVERT RTNES
FMT3BUFR EQU   *                  BUFFER FOR READING FMT 3 DSCBS
*****    THE FOLLOWING JFCB IS NO LONGER NEEDED AFTER THE DCB IS OPENED
VTOCJFCB DS    176X'00'           JFCB FOR FROMPACK VTOC
WORK     DS    D                  GENERAL PURPOSE DOUBLEWORD WORKAREA
WORK2    DS    D                  DISKTTR AND STAE DOUBLEWORD WORKAREA
ENDSPTR  DS    F                  PTR TO LAST DS TO BE COPIED IN PARM
TTRNPTR  DS    F                  PTR TO CURRENT ENTRY IN TTRNTABL
DSCBUFR  DS    140X'00'           BUFFER FOR READING FMT 1 DSCBS
DELETBUF DS    44X'00'            BUFFER USED FOR READING 'DELETES'
VTOCBUFR EQU   *   BUFFER FOR UPDATING TOPACK VTOC FOR MULTI-VOL DS
INJFCB   DS    176X'00'           INPUT DS (AND DIRECTORY IF PO) JFCB
OUTJFCB  DS    176X'00'           OUTPUT DS JFCB
         DS    0D
LOCAREA  DS     CL265             WORKAREA FOR LOCATE/RECAT SVC'S
         ORG
GROUPTR  DC    F'0'          START OF DSNAME ADDR FOR DS GROUP COPY
GOODFULL EQU   *-1
         DC    X'F0'              GOODBUFR FULL FIELD FLAG
*  SAVERC AND TTRCOUNT OCCUPY SAME BYTE SINCE ONE IS BPAM AND ONE BDAM
SAVERC   DS    0C                 RETURN CODE SA FOR BDAM CREATE
TTRCOUNT DC    X'0'
TTRNPASS DC    X'00'              TTRN PROCESSING FLAG
TRTABLE  DC    C'0123456789ABCDEF'
VOLIST   DC    H'1'               ONLY ONE VOLUME TO CHECK
VOLTYPE  DC    4X'0'              TOPACK DEVICE TYPE
VOLSERID DS    CL6
         DC    H'0'               DA SEQ NO AND RETURN CODE
MAXTO    DC    H'0'               MAX TOPACK BLKSIZE
MAXLNGTH DC    H'0'               MAX READ LENGTH
TOCYLS   DC    H'0'               TRKS/CYL ON TOPACK
MAXFROM  DC    H'0'               MAX FROM PACK BLKSIZE
         DC    H'0'               UNUSED HW
FROMCYLS DC    H'0'               TRKS/CYL ON FROMPACK
** NOTE-- ABOVE 6 HW'S MUST REMAIN IN SAME ORDER AND CONTIGUOUS
BRANCH02 DC    S(CHKSTOP)
WRITU    DC    S(UWRITE)
WRITFORV DC    S(FVWRITE)
WRITEFB  DC    S(FBWRITE)
BRETRNUV DC    S(INVRETRN)
BRETRNF  DC    S(NEXTRACK)
BDMWRTFV DC    S(BDAMWRT1)
BDMWRTU  DC    S(BDAMWRT0)
HEXFFS   DC    8X'FF'
FROMVTOC DCB   DDNAME=FROMPACK,MACRF=(RP),DEVD=DA,DSORG=PS,RECFM=F,    $
               BLKSIZE=96,KEYLEN=44,EODAD=ENDVTOC,EXLST=VTOCEXLT,      $
               SYNAD=VTOCERRF,BUFNO=0
*****  EODAD AND SYNAD ADDRS FILLED IN BY CORRESPONDING ROUTINES
INPUT    DCB   DSORG=PS,DDNAME=FROMPACK,MACRF=(R),NCP=2,               X
               EXLST=INEXLST,DEVD=DA,BUFNO=0
*****  EODAD AND SYNAD ADDR'S FILLED IN BY APPROPRIATE ROUTINES
OUTPUT   DCB   DSORG=PS,DDNAME=TOPACK,MACRF=(W),EXLST=OUTEXLST,        X
               DEVD=DA,BUFNO=0,NCP=2
TOPKVTOC DCB   DDNAME=TOPACK,MACRF=(RP,WP),DEVD=DA,DSORG=PS,           X
               BLKSIZE=96,KEYLEN=44,EXLST=VTOCEXLT,SYNAD=VTOCERRT,     X
               BUFNO=0,RECFM=F
DELETES  DCB   DDNAME=DELETES,MACRF=(R),DSORG=PS,RECFM=U,BUFNO=0,      X
               BLKSIZE=44,EODAD=DELETEND,SYNAD=DELETEND,LRECL=44
BADCOPY  DCB   BLKSIZE=120,LRECL=120,RECFM=FBS,DSORG=PS,               *
               DDNAME=BADCOPY,MACRF=(W),BUFNO=0
GOODCOPY DCB   BLKSIZE=120,LRECL=120,RECFM=FBS,DSORG=PS,               *
               DDNAME=GOODCOPY,MACRF=(W),BUFNO=0
*        SYNAD ADDRESS FOR BDAMIN FILLED IN BY BDAM COPY ROUTINE
BDAMIN   DCB   DSORG=DA,DDNAME=FROMPACK,MACRF=(RIC),                   $
               BUFNO=0,EXLST=INEXLST
         SPACE 5
BDAMOUT  EQU   OUTPUT             BDAM CREATE DCB SAME AS PS OUTPUT
         SPACE 5
         LTORG
MEMBREQ  DC    C'MEMBR='          PDS MEMBER GOODCOPY HEADER
ERRCODE  DC    C'(00)'            BADCOPY ERROR FIELD
PERIOD#T DC    C'.T'              SYSTEM DATA SET CHK VALUE
SYS      DC    C'SYS'             SYSTEM DATA SET CHK VALUE
FIVEZERO DC    5X'0'              5 BYTES OF 'EX ZEROES
MEMNOCPY DC    CL19'MEMBERS NOT COPIED='    PDS MEMBER BADCOPY HEADER
HW8      DC    H'8'               HALFWORD CONSTANT
HW2      DC    H'2'               HALFWORD CONSTANT
HW256    DC    H'256'             HALFWORD CONSTANT
MAXCCHHR DS    CL5
FROMVOL  DS    CL6                FROMPACK VOL SER ID
         CNOP  2,4
         DC    X'007F'            RESET VALUE FOR TTRNTABL
TTRNTABL DC    (2*MAXTTRNS)F'0'
         DC    X'FF'              TABLE END INDICATOR
         DS    0F
         DC    X'7F',AL3(0)       RESET VALUE FOR ALIASTAB
ALIASTAB DC    (MAXALIAS)X'7F000000'
         DC    X'FF'
         SPACE 5
***** THE PDS DIRECTORY INPUT DCB IS PLACED HERE BECAUSE IT DOESN'T
*****  HAVE TO BE ADDRESSABLE BY COPYPACK'S BASE REGISTERS
DIRECTRY DCB   DSORG=PS,DDNAME=FROMPACK,RECFM=F,LRECL=256,DEVD=DA,     $
               EODAD=DIREND,MACRF=(R),BLKSIZE=256,EXLST=DIREXLST,      $
               BUFNO=0,SYNAD=DIRSYNAD
         SPACE 5
DCBREF   EQU   0             SYMBOLIC REFERENCES FOR BDAM/BSAM FIELDS
DCBRELAD EQU   0
DCBKEYCN EQU   4
DCBFDAD  EQU   5
DCBDVTBL EQU   13
DCBKEYLE EQU   16
DCBREL   EQU   17       BDAM
DCBDEVT  EQU   17       BSAM
DCBTRBAL EQU   18       BSAM
DCBBUFNO EQU   20
DCBBUFCB EQU   21
DCBBUFL  EQU   24
DCBDSORG EQU   26
DCBIOBAD EQU   28
DCBHIARC EQU   32
DCBBFTEK EQU   32
DCBBFALN EQU   32
DCBEODAD EQU   33
DCBRECFM EQU   36
DCBEXLST EQU   37
*****  BEFORE OPEN  *****
DCBDDNAM EQU   40
DCBIFLG  EQU   49
DCBMACR  EQU   50
*****  AFTER OPEN  *****
DCBTIOT  EQU   40
DCBMACRF EQU   42
DCBIFLGS EQU   44
DCBDEBAD EQU   45
DCBREAD  EQU   49
DCBWRITE EQU   49
*****
DCBOFLGS EQU   48
DCBOPTCD EQU   52
DCBCHECK EQU   53
DCBIOBL  EQU   56
DCBDMSYN EQU   56       BDAM SYNAD
DCBSYNAD EQU   57       BSAM SYNAD
DCBCIND1 EQU   60
DCBCIND2 EQU   61
DCBBLKSI EQU   62
DCBIOBSQ EQU   64       BDAM
DCBWCPO  EQU   64       BSAM
DCBWCPL  EQU   65       BSAM
DCBOFFSR EQU   66       BSAM
DCBOFFSW EQU   67       BSAM
DCBSQND  EQU   68       BDAM
DCBIOBA  EQU   68       BSAM
DCBIOBUQ EQU   72       BDAM
DCBNCP   EQU   72       BSAM
DCBEOBR  EQU   73       BSAM
DCBUQND  EQU   76       BDAM
DCBEOBW  EQU   76       BSAM
DCBDIRCT EQU   80       BSAM
DCBLIMCT EQU   81       BDAM
DCBLRECL EQU   82       BSAM
DCBCNTRL EQU   84       BSAM
DCBNOTE  EQU   84       BSAM
DCBPOINT EQU   84       BSAM
DCBXCNT  EQU   84       BDAM
DCBXARG  EQU   85       BDAM
DCBDRDX  EQU   88       BDAM
DCBDFOR  EQU   92       BDAM
DCBDFBK  EQU   96       BDAM
DCBDYNB  EQU   100      BDAM
         SPACE 5
DSCB1REF EQU   0             SYMBOLIC REFERENCES FOR FMT 1 DSCB FIELDS
DS1DSNAM EQU   0
DS1FMTID EQU   44
DS1DSSN  EQU   45
DS1VOLSQ EQU   51
DS1CREDT EQU   53
DS1EXPDT EQU   56
DS1NOEPV EQU   59
DS1NOBDB EQU   60
DS1SYSCD EQU   62
DS1DSORG EQU   82
DS1RECFM EQU   84
DS1OPTCD EQU   85
DS1BLKL  EQU   86
DS1LRECL EQU   88
DS1KEYL  EQU   90
DS1RKP   EQU   91
DS1DSIND EQU   93
DS1SCAL0 EQU   94
DS1LSTAR EQU   98
DS1TRBAL EQU   101
DS1EXT1  EQU   105
DS1EXT2  EQU   115
DS1EXT3  EQU   125
DS1PTRDS EQU   135
         SPACE 5
DSCB3REF EQU   0             SYMBOLIC REFERENCES FOR FMT 3 DSCB FIELDS
DS3KEYID EQU   0
DS3EXTNT EQU   4
DS3FMTID EQU   44
DS3ADEXT EQU   45
DS3PTRDS EQU   135
         SPACE 5
JFCBREG  EQU   0                  SYMBOLIC REFERENCES FOR JFCB FIELDS
JFCBDSNM EQU   0
JFCBELNM EQU   44
JFCBTSDM EQU   52
JFCBSYSC EQU   53
JFCBLTYP EQU   66
JFCBOTTR EQU   67
JFCBFLSQ EQU   68
JFCBVLSQ EQU   70
JFCBMASK EQU   72
JFCBCRDT EQU   80
JFCBXPDT EQU   83
JFCBIND1 EQU   86
JFCBIND2 EQU   87
JFCBUFNO EQU   88
JFCBHIAR EQU   89
JFCBFTEK EQU   89
JFCBFALN EQU   89
JFCBUFL  EQU   90
JFCEROPT EQU   92
JFCKEYLE EQU   93
JFCLIMCT EQU   95
JFCDSORG EQU   98
JFCRECFM EQU   100
JFCOPTCD EQU   101
JFCBLKSI EQU   102
JFCLRECL EQU   104
JFCNCP   EQU   106
JFCNTM   EQU   107
JFCBNVOL EQU   117
JFCBVOLS EQU   118
JFCBEXAD EQU   149
JFCBPQTY EQU   152
JFCBCTRI EQU   155
JFCBSQTY EQU   156
JFCBDQTY EQU   160
JFCBSPNM EQU   163
JFCBABST EQU   166
JFCBSBNM EQU   168
JFCBDRLH EQU   171
JFCBVLCT EQU   174
JFCBSPTN EQU   175
         SPACE 5
************************   FATAL ERROR CODES     **********************
ERRORF04 EQU   4                  MISSING GOODCOPY DD CARD
ERRORF08 EQU   8                  MISSING BADCOPY DD CARD
ERRORF12 EQU   12                 MISSING TOPACK DD CARD
ERRORF16 EQU   16                 MISSING FROMPACK DD CARD
ERRORF24 EQU   24                 TO/FROM DEVICE NOT DIRECT ACCESS
ERRORF28 EQU   28                 PERM I/O ERROR READING FROMPACK VTOC
ERRORF32 EQU   32                 START DS NOT FOUND IN FROMPACK VTOC
ERRORF36 EQU   36                 PERM GOODCOPY OR BADCOPY I/O ERROR
ERRORF40 EQU   40                 INVALID OR INCORRECT PARM FIELD
         SPACE 5
************************  BADCOPY ERROR CODES    **********************
ERRORN00 EQU   X'00'    PERMANENT I/O ERROR COPYING DATA SET OR MEMBER
ERRORN04 EQU   X'04'    ALLOCATION. DUPLICATE NAME IN TOPACK VTOC
ERRORN08 EQU   X'08'    ALLOCATION. NO MORE ROOM IN TOPACK VTOC
ERRORN0C EQU   X'0C'    ALLOCATION. PERM I/O ERR READING/UPDATING VTOC
ERRORN10 EQU   X'10'    ALLOCATION. INVALID REQ. POSSIBLE COPYPACK ERR
ERRORN14 EQU   X'14'    ALLOCATION. REQUESTED SPACE NOT AVAIL ON TOPACK
ERRORN18 EQU   X'18'    ALLOCATION. AVG RECLNGTH .GT. 65K.POSS PGM ERR
ERRORN1C EQU   X'1C'    SYSTEM DATA SET. COPYPACK WON'T COPY IT
ERRORN20 EQU   X'20'    UNMOVABLE DATA SET. COPYPACK WON'T COPY IT
ERRORN24 EQU   X'24'    DATASET HAS TRK O'FLOW AND BLKSIZE .GT. FULLTRK
ERRORN28 EQU   X'28'    MULTI-VOL STATUS NOT PRESERVED /NOT SCRATCHED/
ERRORN2C EQU   X'2C'    INVALID BLKSIZE VALUE
ERRORN30 EQU   X'30'    ALLOCATION. INV REQUEST. PROBABLE PGM ERROR
ERRORN34 EQU   X'34'    ALLOCATION. INV REQUEST. PROBABLE PGM ERROR
ERRORN38 EQU   X'38'    ALLOCATION. DIRECT SIZE .GT. PRIMARY SPACE OR
*                            .GT. LARGEST CONTIG AREA ON PACK
ERRORN3C EQU   X'3C'    DATASET ALLOCATED IN ABSTRK. PGM WON'T COPY
ERRORN40 EQU   X'40'    INVALID EXTENT INFORMATION IN FMT1 DSCB
ERRORN44 EQU   X'44'    INVALID DSORG -- IS OR UNDEFINED
ERRORN48 EQU   X'48'    PDS HAS TOO MANY USED DIR BLKS FOR PGMTO HANDLE
ERRORN4C EQU   X'4C'    PDS HAS TOO MANY MEMBERS FOR PGM TO HANDLE
ERRORN50 EQU   X'50'    PDS HAS TOO MANY ALIASES FOR PGM TO HANDLE
ERRORN54 EQU   X'54'    ERROR IN STOWING DIRECTORY ENTRY FOR PDS
ERRORN58 EQU   X'58'    ALIAS TTR COUNT .NE. MAIN MEMBER TTR COUNT
ERRORN5C EQU   X'5C'    PDS IS NULL (NO MEMBERS)
ERRORN60 EQU   X'60'              BDAM COPY ROUTINE RECEIVED INV I/O RC
ERRORN64 EQU   X'64'    DATA SET NOT COPIED DUE TO 'DELETES' REQUEST
ERRORN68 EQU   X'68'    ALIAS NOT COPIED BECAUSE MAIN MEMBER NOT COPIED
ERRORN6C EQU   X'6C'    PDS HAS TOO MANY TTRN FIELDS FOR PGM TO HANDLE
ERRORN70 EQU   X'70'    TTRN'S IN EITHER DIR OR NOTELIST NOT UPDATED OK
ERRORN74 EQU   X'74'    MODEL DSCB. PGM ASKED NOT TO COPY IT
ERRORN78 EQU   X'78'    TRUNC ERROR. BLK WON'T FIT ON TOPACK
ERRORN7C EQU   X'7C'    BDAM COPY ONLY. T/    TO/FROM DEVICES DIFFER
ERRORN80 EQU   X'80'     AUTOMATIC RECATALOG FAILURE
         SPACE 5
PDSMEMBR DSECT     DSECT FOR MEMBER ENTRIES IN PDS DIRECTORY
PDSNAME  DS    CL8
PDSTTR   DS    CL3
PDSC     DS    CL1
PDSUSER  DS    0CL2
         EJECT
***********************************************************************
***** THE FOLLOWING ROUTINE IS AN OPEN EXIT FROM OUTPUT OR BDAMOUT ****
***** WHICH ZAPS THE DSCB WHILE STILL IN CORE AND DOES THE INITIAL*****
*****            PROCESSING FOR A MULTI-VOLUME DATA SET           *****
***********************************************************************
         SPACE 5
HITDSCB  CSECT
         DROP  R13
         SAVE  (14,12)
         BALR  R11,0              LOAD BASE REG
         USING *,R11
         LA    R4,SA2
         USING SA2,R4
         ST    R4,8(R13)
         ST    R13,SA2+4
         LR    R13,R4
         L     R3,16              LOAD CVT POINTER
         L     R3,0(R3)           TCB DOUBLEWORD
         L     R3,4(R3)           CURRENT TCB
         L     R3,0(R3)           TOP RB
         L     R3,28(R3)          OPEN SVRB
         L     R3,104(R3)         LOAD PTR TO OPEN WORKAREA (R4)
         TM    DSCBUFR+DS1DSIND,X'80'  DOES DS EXTENT TO ANOTHER VOLUME
         BO    HITDSCB1           IF NOT, BRANCH
         MVI   RDVTOC+1,X'00'     CHANGE INSTR TO NOP *****************
         L     R1,TOPKVTOC+DCBDEBAD-1  LOAD TOPACK VTOC DEB ADDR
         LA    R1,0(R1)           CLEAR HIGH BYTE
         L     R2,X'180'(R3) GET 'READ CNT' ADDR FROM RD DSCB CHAN PGM
**  THE FOLLOWING CHANGE IS FOR RELEASE 21.6. PREVIOUS RELEASES BUILD
**  THE FOLLOWING CHANNEL PGM FOR READING THE FMT1 DSCB-- SEARCH ID EQ,
**  TIC *-8, READ COUNT, SEARCH KEY EQ, TIC *-16, READ DSCB--, BUT
**  21 USES SEARCH ID EQ, TIC *-8, SEARCH KEY EQ, NOP, READ DSCB (IF
**  THE JFCB CONTAINS A VALID DSCB TTR PTR IN THE 'JFCBDSCB' FIELD (1ST
**  3 BYTES OF THE JFCBSYSC)).  SEE MODULES IFG0194E (RLSE 21.6) AND
**  IGG0199Z (RLSE 20) FOR FURTHER INFORMATION.
         L     R15,UCBHOLD        LOAD TOPACK UCB ADDR
         CLC   X'99'(3,R3),X'24'(R15)  COMP JFCBDSCB AGAINST VTOC TTR
         BL    CHANPGM1           IF LOW, USE ADDR FROM 'READ CNT' CCW
         L     R2,X'170'(R3)      USE 'SEARCH ID' ADDR FROM CHAN PGM
CHANPGM1 SR    R0,R0              CLEAR R0
         ST    R0,WORK            SET 'MBB' VALUE
         MVC   WORK+3(5),0(R2)    SET 'CCHHR' VALUE (FROM CHAN PGM)
         L     R15,16             RELOAD CVT ADDR
         L     R15,X'20'(R15)     LOAD MBBCCHHR/TTR CONVERT RTNE ADDR
         LA    R2,WORK            PT TO MBBCCHHR VALUE
         LR    R8,R12             MOVE BASE ADDR FOR RESTORING REGS
*                                 (CONVERT ROUTINE DESTROYS R12)
         STM   R9,R13,SA3         STORE OFF REGS CONVERT RTNE DESTROYS
         BALR  R14,R15            BR TO CONVERSION RTNE
         DROP  R12
         USING COPYBASE,R8
         LM    R9,R13,SA3         RESTORE REGS
         DROP  R8
         USING COPYBASE,R12       RESTORE USE OF REGULAR BASE REG
         ST    R0,DSCBTTR         STORE OFF TTR FOR LATER USE
HITDSCB1 MODESET   KEY=ZERO       GO INTO ZERO PROTECT
         MVC   45-44(6,R3),VOLSERID         MOVE IN TOPACK ID       NWK
HITDSCB3 MVC   51-44(2,R3),DSCBUFR+DS1VOLSQ UPDATE VOL SEQ NUMBER
         MVC   53-44(6,R3),INJFCB+80      UPDATE CREAT/EXPIR DATES
         MVC   100+101(1,R3),DSCBUFR+DS1OPTCD    UPDATE OPTCODE IN JFCB
*  NOTE- OPTCODE IS UPDATED IN JFCB RATHER THAN DSCB TO PREVENT
*        BACKWARD MERGE JFCB-TO-DSCB CLOBBER BY OPEN
         MVC   94-44(4,R3),DSCBHOLD    UPDATE SPACE/ SEC ALLOCATION
         MVC   100+155(4,R3),DSCBHOLD  UPDATE SPACE/ SEC ALLOCATION
*                                 IN JFCB TO PREVENT D37 ABENDS
         MODESET   KEY=NZERO      LOAD PROGRAM PROTECT PASSWORD
         L     R13,SA2+4
         RETURN (14,12)
         DROP  R4,R11
         USING SA,R13             SPECIFY 2ND BASE REGISTER
         DS    0F                 PROTECT PASSWORDS FOR SVC 255
ZEROKEY  DC    F'0'
PROGKEY  DC    F'-1'
         SPACE 5
         EJECT
***********************************************************************
*****   THE FOLLOWING ROUTINE IS A SUBTASK WHICH WILL DISPLAY     *****
*****   THE NAME OF THE DATA SET CURRENTLY BEING COPIED.  THIS    *****
*****   STATUS IS PROVIDED AUTOMATICALLY EVERY 5 MINUTES OR IN    *****
*****         RESPONSE TO A WTOR REPLY OF 1-CHARACTER             *****
***********************************************************************
         DROP  R7,R12,R13
WTORRTNE CSECT
         SAVE  (14,12)
         BALR  R12,0
         USING *,R12
         LA    R2,WTORSAVE
         ST    R2,8(R13)
         ST    R13,4(R2)
         LR    R13,R2
         L     R10,0(R1)          POINT TO DSCBUFR
         L     R7,4(R1)           PT TO END OF JOB MAIN ECB
         LA    R1,FIRSTMSG        OUTPUT FIRST WTOR
WRITEMSG WTO   MF=(E,(1))         ISSUE WTOR/WTO
         STIMER REAL,TIMERTNE,TUINTVL=FIVEMIN
         WAIT  1,ECBLIST=ECBLIST
         TTIMER CANCEL            CLEAR TQE
         CLI   REPLYECB,X'40'     WAS WTOR ECB POSTED
         BNE   TIMER              IF NOT, MUST BE TIMER OR EOJ
         MVI   REPLYECB,0         CLEAR ECB
         LA    R5,WTOR            ISSUE A WTOR
BUILDMSG CLI   44(R10),C'1'       IS THIS A FMT1 DSCB
         BNE   VTOCREAD
         MVC   DSNMSG+27(35),0(R10)    INSERT DS NAME
         LA    R1,MESSAGE1(R5)
         B     WRITEMSG
VTOCREAD LA    R1,MESSAGE2(R5)
         B     WRITEMSG
TIMER    CLI   TIMERECB,X'40'     IS IT THE TIMER ECB
         BNE   EOJ                IF NOT, MUST BE EOJ
         MVI   TIMERECB,0         CLEAR ECB
         LA    R5,WTO             ISSUE A WTO
         B     BUILDMSG
EOJ      POST  (R7)               POST ENDECB IN COPYPACK TO INDICATE
*                                 END OF SUBTASK
         L     R13,WTORSAVE+4
         RETURN (14,12)
TIMERTNE SAVE (14,12)
         LR    R12,R15
         USING TIMERTNE,R12
         LA    R2,TIMESAVE
         ST    R2,8(R13)
         ST    R13,4(R2)
         LR    R13,R2
         POST  TIMERECB
         L     R13,TIMESAVE+4
         RETURN (14,12)
FIRSTMSG WTOR  'COPYPACK ENTER 1-CHAR REPLY TO OBTAIN CURRENT COPY STATX
               US',REPLY,1,REPLYECB,MF=L
         DS    0F
MESSAGE1 DC    AL1(1),AL3(REPLY),A(REPLYECB)
         DC    AL2(MSG1END-*),AL2(0)
DSNMSG   DC    C'COPYPACK   YYYYYY  DSNAME= XXXXXXXXXXXXXXXXXXXXXXXXXXXZ
               XXXXXXXX'
MSG1END  EQU   *
         DS    0F
MESSAGE2 DC    AL1(1),AL3(REPLY),A(REPLYECB)
         DC    AL2(MSG2END-*),AL2(0)
         DC    C'COPYPACK   VTOC READ CURRENTLY IN PROGRESS'
MSG2END  EQU   *
REPLY    DS    CL1                WTOR REPLY AREA
TIMERECB DS    0F
TIMESAVE DC    18F'0'
REPLYECB DS    0F
WTORSAVE DC    18F'0'
FIVEMIN  DC    F'11520000'        NUMBER OF TU IN 5 MINUTES
ECBLIST  DC    A(TIMERECB)
         DC    A(EOJECB)
         DC    X'80',AL3(REPLYECB)
WTOR     EQU   0                  WTOR IS 0 OFFSET INTO PARAM LIST
WTO      EQU   8                  WTO IS 8 OFFSET INTO PARAM LIST
         EJECT
STAESYNS CSECT
***********************************************************************
*****                                                             *****
*****    THIS CSECT CONTAINS THE GOODCOPY AND BADCOPY SYNAD       *****
****            ROUTINES AND THE PROGRAM STAE ROUTINE             *****
*****                                                             *****
***********************************************************************
         SPACE 5
         USING PDSMEMBR,R7
         DROP  R12
         USING *,R15              TEMP BASE REG
STAEEXIT STM   R13,R2,STAESAVE    SAVE ABEND REGS HERE (MAYBE NO SA)
         DROP  R15
         BALR  R11,0
         USING *,R11
SSBASE   LM    R12,R13,OTHRBASE   LOAD BASE REGS OF COPYPACK
         USING COPYBASE,R12
         USING SA,R13        NOTICE THAT THIS CSECT USES COPYPACK'S SA
         MVI   STAEFLAG,X'F0'     INDICATE STAE RTNE IN CONTROL
         STC   R0,WORK            MOVE STAE CODE TO CORE
         CLI   WORK,12            IS THERE A STAE WORK AREA
         BE    STAERTN0           IF NOT, BRANCH
         L     R2,4(R1)           LOAD ABEND CODE INTO R2
STAERTN0 SLL   R2,8
         SRL   R2,20              ISOLATE SYSTEM ABEND CODE
         STH   R2,WORK            MOVE ABEND CODE INTO CORE
         UNPK  WORK+4(4),WORK(3)  UNPK HEX CODE
         TR    WORK+4(3),TRTABLE-X'F0' CONVERT TO PRINTABLE FORM
         MVC   STAEWTO+4+11(3),WORK+4       MOVE CODE INTO WTO
         CLI   DSCBUFR+DS1FMTID,C'1'   IS THERE A FMT 1 IN DSCBUFR
         BNE   STAERTN1           IF NOT, BRANCH
         MVC   SWTOEND1(40),DSCBUFR    MOVE DSNAME INTO WTO
         LA    R3,SWTOEND2-STAEWTO     LOAD LONGER WTO LNGTH
         STH   R3,STAEWTO         INSERT VL RECORD LENGTH
         MVI   STAEWTO+4+09,C'1'  INSERT DS CODE
         TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT/BDAMOUT OPEN
         BNO   STAERTN1           IF NOT, BRANCH
         MVI   STAEWTO+4+09,C'2'  INDICATE DS DELETED
         CLOSE (OUTPUT)
         BAL   R2,SCRATCHD        SCRATCH DATA SET
STAERTN1 WTO   MF=(E,STAEWTO)     WTO STAE MSG
         CLI   SYNADG+1,X'F0'     HAS GOODCOPY SYNAD RTNE BEEN ENTERED
         BE    STAEGOOD           IF YES, BYPASS FURTHER GOODCOPY PROC
         BAL   R2,FINISHG         ATTEMPT TO PRNT GOODBUFR
STAEGOOD CLI   SYNADB+1,X'F0'     HAS BADCOPY SYNAD RTNE BEEN ENTERED
         BE    STAEBAD            IF YES, BYPASS FURTHER BADCOPY PROC
STAEBAD  BAL   R2,FINISHB         ATTEMPT TO PRNT CONTENTS OF BADBUFR
         LM    R13,R2,STAESAVE    RESTORE SAVED ABEND REGS
         SR    R15,R15            CONTINUE NORMAL ABEND PROCESSING
         BR    R14                RETURN TO ABEND
         EJECT
GOODSYN  EQU   *                  GOODCOPY SYNAD ROUTINE
         DROP  R11,R12,R13
         USING *,R15
         L     R11,SSBASEAD       LOAD BASE REG FOR THIS CSECT
         USING SSBASE,R11
         DROP  R15
         LM    R12,R13,OTHRBASE   LOAD COPYPACK BASE REGS (AND SA)
         USING COPYBASE,R12
         USING SA,R13
         MVI   SYNADG+1,X'F0'     SHOW GOODCOPY SYNAD HAS BEEN ENTERED
         MVC   SYNADWTO+4+11(4),GOOD   ALTER WTO TO SHOW GOODCOPY
         WTO   MF=(E,SYNADWTO)    WTO GOODBUFR I/O ERR MSG
         WTO   'GOODCOPY CONTENTS:',MCSFLAG=HRDCPY  HEADER TO HARDCOPY
         LA    R10,GOODBUFR-4     INIT MSG BUFFER PTR
         BAL   R14,WTOLOG         OUTPUT GOODBUFR TO HARD COPY
         CLI   STAEFLAG,X'F0'     IS STAE ROUTINE IN CONTROL
         BE    STAEGOOD           IF YES, RETURN TO STAE
         MVI   GOODBUFR,C' '      CLEAR 1ST LINE OF GOODBUFR
         MVC   GOODBUFR+1(119),GOODBUFR
         LA    R10,GOODBUFR       INIT BUFFER PTR
         LA    R6,4               INIT VL MESSAGE LENGTH
*  THE CHECK THAT CAUSED THIS SYNAD RTNE TO BE ENTERED WAS PROBABLY
*  ISSUED WHEN GOODBUFR WAS FULL AND A STATUS MSG WAS TO BE INSERTED.
*  THE NEXT ROUTINE ATTEMPTS TO WTL THIS OVERFLOW MESSAGE.
         LA    R2,0(R2)           EXAMINE CHK ROUTINE RTRN REG
         LA    R3,DSCOPY01        WAS RTRN AT BSAM, BDAM GOOD COPY
         CR    R2,R3
         BE    GOODMSG3           IF YES, BRANCH
         LA    R3,GOODMEM1        WAS RTRN AT MIDDLE OF BPAM GOOD COPY
         CR    R2,R3
         BE    GOODMSG2           IF YES, BRANCH
         LA    R3,GOODMEM         WAS RTRN AT STRT OF BPAM GOOD COPY
         CR    R2,R3
         BNE   SYNADB             IF NOT, ASSUME NO MSG TO BE BUILT
GOODMSG1 CLI   GOODMEM+1,X'F0'    HAS DSNAME ALREADY BEEN INSERTED
         BE    GOODMSG2           IF YES, BRANCH
         MVC   0(33,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME
         MVC   34(6,R10),MEMBREQ  INSERT MEMBER HEADER
         LA    R10,40(R10)        UPDATE BUFFER PTR
         LA    R6,40(R6)          UPDATE MSG LENGTH
         MVI   GOODMEM+1,X'F0'    INDICATE GOOD MEMBER COPY
GOODMSG2 MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME
         TM    PDSC,X'80'         IS MEMBER AN ALIAS
         BNO   GOODSYN3           IF NOT, BRANCH
         MVI   0(R10),C'*'        INSERT ALIAS FLAG
GOODSYN3 LA    R6,20(R6)          UPDATE MSG LENGTH
         B     GOODSYN4           BR TO WTL MSG
GOODMSG3 MVC   0(39,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME
         LA    R6,40(R6)          UPDATE MSG LENGTH
GOODSYN4 SLL   R6,16              COMPLETE VL MSG HEADER
         ST    R6,GOODBUFR-4      INSERT VL HEADER
         MVI   GOODBUFR-2,X'02'   INSERT MCSFLAG=HRDCPY BIT
         WTO   MF=(E,GOODBUFR-4)  WRITE MESSAGE TO HARDCOPY
SYNADB   NOP   GOODSYN7      ALTERED TO BR IF BADBUFR SYNAD ENTERED
         BAL   R2,FINISHB         TRY TO OUTPUT BADBUFR CONTENTS
GOODSYN7 TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN
         BNO   SYNADEND           IF NOT, BRANCH
         CLOSE (OUTPUT)
         B     SYNADEND
         EJECT
BADSYN   EQU   *                  BADBUFR SYNAD ROUTINE
         DROP  R11,R12,R13
         USING *,R15
         L     R11,SSBASEAD       LOAD BASE REG OF THIS CSECT
         USING SSBASE,R11
         DROP  R15
         LM    R12,R13,OTHRBASE   LOAD COPYP ACK BASE REGS AND SA
         USING COPYBASE,R12
         USING SA,R13
         MVI   SYNADB+1,X'F0'     SHOW BADCOPY SYNAD HAS BEEN ENTERED
         MVC   SYNADWTO+4+11(4),BAD    INDICATE BADCOPY I/O ERROR
         WTO   MF=(E,SYNADWTO)    WTO ERROR MSG
         WTO   'BADCOPY CONTENTS:',MCSFLAG=HRDCPY   HEADER TO HARDCOPY
         LA    R10,BADBUFR-4      INIT BUFFER PTR
         BAL   R14,WTOLOG         WTL CONTENTS OF BADBUFR
         CLI   STAEFLAG,X'F0'     IS STAE RTNE IN CONTROL
         BE    STAEBAD            IF YES, RETURN TO STAE
         MVI   BADBUFR,C' '       CLEAR 1ST LINE OF BADBUFR
         MVC   BADBUFR+1(119),BADBUFR
         LA    R10,BADBUFR        INIT BUFFER PTR
         LA    R6,4               INIT VL MSG HEADER
*  THE CHECK THAT CAUSED THIS SYNAD RTNE TO BE ENTERED WAS PROBABLY
*  ISSUED WHEN BADBUFR WAS FULL AND A STATUS MSG WAS TO BE INSERTED.
*  THE NEXT RTNE ATTEMPTS TO OUTPUT THIS OVERFLOW MESSAGE.
         LA    R2,0(R2)           CLEAR HIGH BYTE OF CHK RTRN REG
         LA    R3,BADMEM1         CHK IN MIDDLE OF BPAM BAD COPY
         CR    R2,R3
         BE    BADMSG6            IF YES, BRANCH
         LA    R3,BADMEM          CHK AT START OF BPAM BAD COPY
         CR    R2,R3
         BE    BADMSG5            IF YES, BRANCH
         LA    R3,BPAMSYN6        CHK AT END OF BPAM SYNAD RTNE
         CR    R2,R3
         BE    BADMSG4            IF YES, BRANCH
         LA    R3,BPAMSYN5        CHK AT MIDDLE OF BPAM SYNAD
         CR    R2,R3
         BE    BADMSG3            IF YES, BRANCH
         LA    R3,PSYNAD1         CHK IN PS SYNAD RTNE
         CR    R2,R3
         BE    BADMSG2            IF YES, BRANCH
         LA    R3,BDAMSYN5        CHK IN BDAM SYNAD RTNE
         CR    R2,R3
         BE    BADMSG2            IF YES, BRANCH
         LA    R3,DSERROR1        CHK IN DS BAD COPY
         CR    R2,R3
         BNE   SYNADG             IF NOT, ASSUME NO MSG TO WTL
BADMSG1  MVC   0(44,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME
         MVC   45(4,R10),ERRCODE  INSERT ERROR CODE FIELD
         UNPK  WORK(3),SA+3(2)    UNPACK ERROR CODE
         TR    WORK(2),TRTABLE-X'F0'   MAKE ERROR CODE PRINTABLE
         MVC   46(2,R10),WORK     INSERT ERROR CODE INTO MSG
         LA    R6,60(R6)          UPDATE VL REC LNGTH
         B     BADSYN4
BADMSG2  MVC   0(25,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME
         MVC   25(4,R10),ERRCODE       INDICATE I/O ERROR
         LA    R9,BADBUFR         FORCE SYNADCMP TO RETURN HERE
         LA    R3,30(R10)         INIT MSG FIELD PTR FOR SYNADCMP
         LA    R6,60(R6)          UPDATE VL MSG LENGTH
         TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN
         BNO   BADSYN4            IF NOT, BRANCH
         CLOSE (OUTPUT)
         BAL   R2,SCRATCHD        SCRATCH DS
         B     BADSYN4
BADMSG3  CLI   BADMEM+1,X'F0'     HAS DSNAME ALREADY BEEN INSERTED
         BE    BADMSG4            IF YES, BRANCH
         MVC   0(40,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME
         MVC   41(19,R10),MEMNOCPY     INSERT BAD MEMBER HEADER
         LA    R6,60(R6)          UPDATE VL REC LENGTH
         LA    R10,60(R10)        UPDATE BUFFER PTR
BADMSG4  MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME
         MVC   10(4,R10),ERRCODE       INDICAT& I/O &RROR
         LA    R9,BADBUFR         FORCE SYNADCMP TO RETURN HERE
         LA    R3,15(R10)         SET MSG PTR FOR SYNADCMP
         BAL   R2,SYNADCMP        COMPLETE SYNAD MSG
         LA    R6,45(R6)          UPDATE VL MSG LENGTH
         B     BADSYN3A
BADMSG5  CLI   BADMEM+1,X'F0'     HAS DSNAME BEEN INSERTED
         BE    BADMSG6            IF YES, BRANCH
         MVC   0(40,R10),DSCBUFR+DS1DSNAM   INSERT DSNAME
         MVC   41(19,R10),MEMNOCPY     INSERT BAD MEMBER HEADER
         LA    R6,60(R6)          UPDATE MSG LENGTH
         LA    R10,60(R10)        UPDATE BUFFER PTR
BADMSG6  MVC   1(8,R10),PDSNAME   INSERT MEMBER NAME
         TM    0(R4),X'80'        IS MEMBER AN ALIAS
         BNO   BADMSG7            IF NOT, BRANCH
         MVI   0(R10),C'*'        INSERT ALIAS FLAG
BADMSG7  MVC   10(4,R10),ERRCODE  INSERT ERROR CODE BOX
         UNPK  WORK(3),SA+3(2)    MAKE ERROR CODE PRINTABLE
         TR    WORK(2),TRTABLE-X'F0'
         MVC   11(2,R10),WORK     INSERT ERROR CODE INTO BOX
         LA    R6,15(R6)          UPDATE MSG LENGTH
BADSYN3A TM    OUTPUT+DCBOFLGS,X'10'   IS OUTPUT OPEN
         BNO   BADSYN4            IF NOT, BRANCH
         CLI   GOODMEM+1,X'F0'    WAS A MEMBER COPIED OK
         BE    BADSYN3B           IF YES, DON'T SCRATCH DS
         CLOSE (OUTPUT)
         BAL   R2,SCRATCHD        SCRATCH DATA SET
         B     BADSYN4
BADSYN3B CLOSE (OUTPUT)
BADSYN4  SLL   R6,16              COMPLETE VL MSG HEADER
         ST    R6,BADBUFR-4       INSERT VL HEADER
         MVI   BADBUFR-2,X'02'    INSERT MCSFLAG=HRDCPY BIT
         WTO   MF=(E,BADBUFR-4)   WRITE MESSAGE TO HARDCOPY
SYNADG   NOP   BADSYN7            BR SET IF GOODBUFR SYNAD RTNE ENTERED
         BAL   R2,FINISHG         TRY TO OUTPUT GOODBUFR CONTENTS
BADSYN7  EQU   *
SYNADEND BAL   R2,FATALEND        TRY TO CLOSE REMAINING OPEN DCBS
         LA    R15,ERRORF36       INDICATE BAD/GOODBUFR I/O ERR
         B     ENDSBTSK
         SPACE 5
WTOLOG   LA    R3,124             WTL GOODBUFR OR BADBUFR
         SLL   R3,16              BUILD VL MSG HEADER
         LA    R6,5               MAX OF 5 LINES
WTOLOG1  CLC   4(2,R10),TWOBLNKS  IS LINE EMPTY
         BCR   8,R14              IF YES, RETURN
         ST    R3,0(R10)          INSERT VL HEADER
         MVI   2(R10),X'02'       INSERT MCSFLAG=HRDCPY BIT
         WTO   MF=(E,(R10))       WRT 120 CHAR LINE TO HARD COPY
         LA    R10,120(R10)       PT TO NEXT LINE
         BCT   R6,WTOLOG1         PROCESS NEXT LINE
         BR    R14                RETURN
         SPACE 3
FINISHB  EQU   *                  TRY TO OUTPUT BADBUFR CONTNETS
         CLI   BADEND+1,X'00'     IS I/O IN PROGRESS FOR BADCOPY
         BE    FINB01             IF YES, BRANCH
         CLC   BADBUFR(2),TWOBLNKS     IS THERE ANYTHING TO OUTPUT
         BCR   8,R2               IF NOT, RETURN
         BAL   R14,WRITEBAD       OUTPUT BADBUFR
FINB01   CHECK BADDECB1           CHECK WRITE
         BR    R2                 RETURN
         SPACE 3
FINISHG  EQU   *                  TRY TO OUTPUT GOODBUFR CONTENTS
         CLI   GOODEND+1,X'00'    IS GOODBUFR I/O IN PROGRESS
         BE    FING01             IF YES, BRANCH
         CLC   GOODBUFR(2),TWOBLNKS    IS THERE A BADCOPY MSG TO PRNT
         BCR   8,R2               IF NOT, RETURN
FING01   CHECK GOODECB1           CHECK WRITE
         BR    R2                 RETURN
         SPACE 3
FATALEND EQU   *                  CLOSE REMAINING OPEN DCB'S
         CLOSE MF=(E,MAINDCBS)
         TM    INPUT+DCBOFLGS,X'10'    IS INPUT OPEN
         BNO   FATEND01           IF NOT, BRANCH
         CLOSE (INPUT)
         BR    R2                 RETURN
FATEND01 TM    BDAMIN+DCBOFLGS,X'10'   IS BDAMIN OPEN
         BCR   14,R2              IF NOT, RETURN
         CLOSE (BDAMIN)
         BR    R2                 RETURN
         SPACE 5
STAEWTO  DC    AL2(SWTOEND1-*),X'8000',C'COPYPACK   XXX ABEND  '
SWTOEND1 DC    X'00004020'        ROUTCDE=(2,11) IF DSNAME NOT IN WTO
         DC    36C' '
SWTOEND2 DC    X'00004020'        ROUTCDE=(2,11), IF DSNAME IN WTO
SYNADWTO WTO   'COPYPACK   GOODCOPY I/O ERROR',ROUTCDE=(2,11),MF=L
OTHRBASE DC    A(COPYBASE),A(SA)  COPYPACK'S 2 BASE REG VALUES
SSBASEAD DC    A(SSBASE)          STAESYNS BASE REG VALUE
STAESAVE DC    6F'0'              ABEND REG SA
GOOD     DC    C'GOOD'
BAD      DC    C' BAD'
TWOBLNKS DC    C'  '
STAEFLAG DC    X'0'
         LTORG
         EJECT
**  THE FOLLOWING ARE THE GOODCOPY AND BADCOPY MSG BUFFERS
         DC    F'0'               A FW PREFIX IS NEEDED FOR EACH BUFFER
*        IN CASE THE CONTENTS MUST BE OUTPUT VIA A WTL (FOR VL HEADER)
GOODBUFR DC    CL120'**********          THE FOLLOWING DATA SETS HAVE B$
               EEN SUCCESSFULLY COPIED FROM FMPACK TO TOPACK         **$
               **********'
         DC    X'FF'
         DS    0F
BADBUFR  DC    CL120'**********           THE FOLLOWING DATA SETS WERE $
               NOT SUCCESSFULLY COPIED FROM FMPACK TO TOPACK         **$
               **********'
         DC    X'FF'
*****  THE FOLLOWING IS A TABLE AND INPUT BUFFER FOR THE PARTIT RTNES
         DS    0F
         DC    X'7F',X'0'
MEMTABLE DC    (MAXENTRY)X'7F00'
         DC    X'FFFF'
         DS    0F
DBUFFER  DC    (256*MAXBLOKS)X'00'     DEFINE BUFFER FOR DIRECTORY
         DC    X'FF'              END OF DIRECTORY BUFFER
         ORG   DBUFFER
         DS    D
*        THIS IS A 1-TIME ONLY CAMLIST USED TO POSITION FROMVTOC
*        TO THE CORRECT DSCB IF THERE EXISTS A 'START' DATA SET
STARTDSN CAMLST SEARCH,DSNAME,FROMVOL,FMT3BUFR
DSNAME   DC    CL44' '
         ORG
         END
