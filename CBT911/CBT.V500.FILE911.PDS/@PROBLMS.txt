         	*The American Programmer*


**Home* <http://TheAmericanProgrammer.com/index.shtml>*
*Books on Mainframe Programming
<http://TheAmericanProgrammer.com/books/index.shtml>*
*Mainframe Manuals and Tutorials
<http://TheAmericanProgrammer.com/manuals/index.shtml>*
*System Abend codes, Sqlcodes, VSAM/QSAM codes
<http://TheAmericanProgrammer.com/error-codes/index.shtml>*
*Everything about the IBM AS/400 Midrange Computer - iSeries
<http://TheAmericanProgrammer.com/as400/index.shtml>*
*Everything about CICS <http://TheAmericanProgrammer.com/cics/index.shtml>*
*Everything about COBOL
<http://TheAmericanProgrammer.com/cobol/index.shtml>*
*Everything about DB2 and SQL
<http://TheAmericanProgrammer.com/db2-sql/index.shtml>*
*Everything about IMS <http://TheAmericanProgrammer.com/ims/index.shtml>*
*Everything about Java and JavaScript
<http://TheAmericanProgrammer.com/java-javascript/index.shtml>*
*Everything about JCL and JES
<http://TheAmericanProgrammer.com/jcl-jes/index.shtml>*
*Everything about REXX <http://TheAmericanProgrammer.com/rexx/index.shtml>*
*  Sorting in REXX: The Bubble Sort
<http://TheAmericanProgrammer.com/programming/rexx.bubble.sort.shtml>*
*  REXX Password Generator
<http://TheAmericanProgrammer.com/programming/rexx.password.generator.shtml>*

*  Using REXX to capture displayed output of TSO command
<http://TheAmericanProgrammer.com/programming/rexx.outtrap.capture.shtml>*
*  Count records in REXX
<http://TheAmericanProgrammer.com/programming/rexx.count.shtml>*
*  REXX program to calculate present value of money
<http://TheAmericanProgrammer.com/programming/rexx.discount.present.value.shtml>

*  REXX function to format a number in currency format
<http://TheAmericanProgrammer.com/programming/rexx.format.dollars.shtml>*
*  REXX function to produce a fixed-length number
<http://TheAmericanProgrammer.com/programming/rexx.fixed.length.number.shtml>*

*  REXX program to produce lottery numbers
<http://TheAmericanProgrammer.com/programming/rexx.lottery.numbers.shtml>*
*  REXX: what does your phone number spell?
<http://TheAmericanProgrammer.com/programming/rexx.phone.number.spell.shtml>*

*  REXX Practice Problems.
<http://TheAmericanProgrammer.com/programming/rexx2.prob.shtml>*
*  Just Enough REXX Tutorial
<http://TheAmericanProgrammer.com/programming/jerexx.shtml>*
*  Setting up to Execute REXX Programs on TSO/ISPF
<http://TheAmericanProgrammer.com/programming/rexxsetp.shtml>*
*  How to execute a REXX program
<http://TheAmericanProgrammer.com/programming/rexx.how.to.execute.shtml>*
*  REXX Boolean operators
<http://TheAmericanProgrammer.com/programming/rexx.boolean.operators.shtml>*

*  Comparison of CLIST language and REXX
<http://TheAmericanProgrammer.com/programming/rexx.clist.shtml>*
*  REXX Comparison operators
<http://TheAmericanProgrammer.com/programming/rexx.comparison.operators.shtml>*

*  REXX Debugging: the TRACE verb
<http://TheAmericanProgrammer.com/programming/rexx.debugging.trace.shtml>*
*  Using REXX OUTTRAP
<http://TheAmericanProgrammer.com/programming/rexx.outtrap.shtml>*
*  Reserved REXX Variables
<http://TheAmericanProgrammer.com/programming/rexx.reserved.variables.shtml>*

*  Executing REXX through JCL.
<http://TheAmericanProgrammer.com/programming/rexxjcl.shtml>*
*  Writing ISPF Edit Macros in REXX
<http://theamericanprogrammer.com/programming/holymac.shtml>*
*  REXX program to unload a PDS
<http://TheAmericanProgrammer.com/programming/rexx.pdstosequential.shtml>*
*  REXX book: The REXX Language on TSO
<http://TheAmericanProgrammer.com/programming/rexx.programming.book.shtml>*
*  REXX Functions Book
<http://TheAmericanProgrammer.com/programming/rexx.function.book.shtml>*
*  QMF Procedures Written in REXX
<http://TheAmericanProgrammer.com/programming/qmfrexx.shtml>*
*  Using REXX Subroutines with the QMF Calc panel
<http://TheAmericanProgrammer.com/programming/qmfcalc.shtml>*
*  REXX error codes (RC)
<http://TheAmericanProgrammer.com/programming/rexx.programming.book.shtml (cont)
    #errorcodes>*

*  REXX programming language manuals
<http://TheAmericanProgrammer.com/programming/manuals.rexx.shtml>*
*  Books on REXX programming
<http://TheAmericanProgrammer.com/books/books.rexx.shtml>*
*  The REXX Files
<http://TheAmericanProgrammer.com/programming/rexxfiles.shtml>*
*Everything about zOS, VSAM, Tivoli, Assembler
<http://TheAmericanProgrammer.com/system-vsam-tivoli-asm/index.shtml>*
*Everything about TSO, ISPF, Spufi
<http://TheAmericanProgrammer.com/tso-ispf-spufi/index.shtml>*
*Site Map and Site Search <http://TheAmericanProgrammer.com/sitemap.shtml>*

	*
           *Home* <http://theamericanprogrammer.com/>*   > *REXX*
<http://theamericanprogrammer.com/rexx/index.shtml>*   > REXX Practice
Problems ******

    *

    REXX Practice Problems. (Answers below)

    *

    This is to be used with the book The REXX Language on TSO
    <http://theamericanprogrammer.com/programming/rexx.programming.book.shtml>
    These problems go with the book.
    The book tells you to do specific problems after it covers the
    material.

    You'll find the answers <#answers> about halfway through this document.
    look for
      ******Suggested answers for workshops.******
      ******Suggested answers for workshops.******


    1. In Chapter 3, after say.
     Create and run the following REXX program using your name instead of Sue
     Name it PROB001.
    	Say 1 + 1
     	Say "Today is" Date()
     	Name = "Sue"
     	Say "Hello, " Name

    2. In Chapter 3, after literal. PROB002
    Using Say
     Display the literal "hello"
     display 1 + 1
     display the length of the literal "hello"	Say length(ôhelloö)
     set the variable NUM to 5
     display NUM + 5

    3. In Chapter 3, after literal. PROB003
    Type in this program without the line numbers.
     Run this program.
     Discuss the results.

     1	/* rexx */
     2	Say 1  + 1
     3	Say "1 + 1"
     4	Say "1"  + "1"
     5	Say one + 1
     6	one = 1
     7	Say one + 1
     8	Say "one" + 1

    4. In Chapter 3, after literal. PROB004
     Type in this program without the line numbers.
     Run this program.
     Discuss the results.
     1	/* rexx */
     2	one = 1
     3	Say one + 1
     4	Drop one
     5	Say one + 1

    5. Variables. In Chapter 3, after concatenate data. PROB005
    Set a variable to "Good morning"
     Set a variable to your name. (Joe in the example)
     Display Good morning Joe
     Display Good morningJoe
     Display Good morning   (10 spaces here)     Joe

    6. In Chapter 3, after Passing Commands to TSO. PROB006
    Run this program. Discuss the results.
    say "enter a message"
    pull message
    say "enter userid to send to"
    pull userid
    "send '"message"'user("userid")"

    7. In Chapter 3, after Passing Commands to TSO. PROB007
    Execute the TSO command LISTDS 'your-userid.REXX.EXEC' MEMBERS
     in a REXX program.

    8. In Chapter 3, after Passing Commands to TSO. PROB008
    Variables in TSO Command. Use of quotes.
     Like the previous, but MEMBERS is now a variable.
     Set it to nothing, in other words MEMBERS = ""
     Now run the program. It should not display any members.

    9. After Chapter 3. PROB009
    What does this program do?

     /*REXX SAMPLE PROB009*/
     X = 10
     Y = 20
     Z = Y - X
     SAY "THE ANSWER IS " Z

    10. After Chapter 3. PROB010
    Write an exec to execute the TSO commands:
     TIME
     SEND 'SAMPLE EXEC ' USER(*)

     Include the comment:    This is a sample exec for REXX class

     Expected results will be approximately like this:
     09:05:02  03/08/42  CPU  4.3  SVC  888.323
     + SAMPLE EXEC TSOU01

    11. After Chapter 3. PROB011
    What does this program do?
     /*REXX TRYME*/
     SAY GREETING

    12. After Chapter 3. PROB012
    What does this program do?

     /*REXX TRY ME TOO*/
     GREETING = "HELLO"
     SAY GREETING

    13. After Chapter 3. PROB013
    Can you tell what this does?  Try it out if you don't know.
     /*REXX TRY ME TOO*/
     GREETING = "HAPPY HALLOWEEN"
     SAY GREETING
     DROP GREETING
     SAY GREETING

    14. After Chapter 3. PROB014
    What does this display on the screen?
     SAY 'F2F3F4'X

    15. After Chapter 3. PROB015
    Write an exec that displays these lines exactly as shown:
     3 + 1 is 4
    '3 + 1 is 4'
    O'brien

    16. After Chapter 3. PROB016
    Write an exec that executes this TSO command:
       	LISTCAT ENTRY('SYS1.PROCLIB')

    17. After Chapter 3. PROB017
    What does this exec print out?
     /*REXX SHORT EXEC*/
     MESSAGE = MESSAGE
     SAY MESSAGE
     EXIT

    18. After Chapter 3. PROB018
    In an exec, assign the number 10 to a variable.
     Assign the number 20 to another variable.
     In one instruction display the total of the two.

    19. After Chapter 3. PROB019
    First assign the variable USERID the value of your neighbor's
    TSO userid.  Then execute the TSO command:

     LISTCAT LEVEL(your neighbor's userid)
    using the variable USERID in place of your neighbor's userid.

    20. After Chapter 4, IF. PROB020
    Write a program that will show you what happens when you
    create a number with more than 9 digits. Type this in. Run
    it with a trace I.

    NUM1 = 9876543211
    NUM2 = 9876543212
    If Num1 = Num2 then say "they are equal"
    else say "not equal"

    21. After Chapter 4, IF. PROB021
    What does this exec display?
     A = 5
     B = 4
     SAY A = B

    22. After Chapter 4, IF. PROB022
    What does this exec display?  Try it to find out.
     A = 2 + 2 = 2
     SAY A

     These are displaying the truth value of the comparison
     	true is 1
    	false is 0

    23. After Chapter 5. Looping, DO END PROB023
    	Type this in a program. Notice the results
     		DO
     			Say "hi"
     			Say "lo"
     		END

    24. After Chapter 5. Looping, DO END PROB024
     	Type this in a program. Notice the results
     		DO 5
     			Say "hi"
     			Say "lo"
     		END

    25. After Chapter 5. Looping, DO END PROB025
    	Type this in a program.
     		the first time, replace XXXXX with EXIT
     		2nd time replace with ITERATE
     		3rd time replace with LEAVE
     		4th time replace with SIGNAL BYE
     	Notice the difference
     	DO 10
     		Say "loop or stop now?"
     		Say "type STOP, or press enter to keep looping"
     		Pull Reply
     		If Reply = "STOP" then XXXXX
     	END
     	Bye:		Exit

    26. After Chapter 5. Looping, DO END PROB026
     Nesting.	Run this
     	DO Outer = 1 to 10
     		Do Inner = 1 to 5
     			Say Outer Inner
     		End Inner
     	End Outer

    27. After Chapter 5. Looping, DO END PROB027
     Nesting
     	Same as the previous, but change the last END OUTER to END INNER.
     	What is the result?

    28. After Chapter 5. Looping, DO END PROB028
    Write an exec that asks the user to enter a series of
    numbers, but never the same one twice in a row.  Limit it to
    10 numbers.

    29. After Chapter 5. Looping. PROB029
    Set secret number equal to 13.  Write an exec to keep asking
    the user to enter a number from 1 to 20 until the secret
    number is guessed.  Limit the loop to 10 guesses.  Expected
    results:

     ===> %myexec
          PLEASE ENTER YOUR GUESS, FROM 1 TO 20
     ===> 2
          WRONG
     ===> 7
          WRONG
     ===> 13
          RIGHT

    30. After Chapter 5. Looping, DO END PROB030
     Loop 10 times.  In the loop ask for a dataset name, then
     issue the TSO command LISTDS on the dataset.  If the RC
     (return code) is 0, get out of the loop; otherwise display
     the message "not found" and then automatically repeat the
     loop.

    31. After Chapter 6. Pull, If, Select PROB031
     Select.	Write a program that asks you for your name.
     	If you reply "JOHN" it displays "PAUL JONES"
     	If you reply "GEORGE" it displays "Washington"
     	NELSON -> Mandela
     	JULIUS -> Caesar
     	a blank, or just hitting Enter -> Please try again
     	any thing else, Bad reply.-> Please enter a name

    32. After Chapter 7. PROB032
    Parse Pull.
     Set this up so that the only valid reply is Yes - Upper case
     Y, lower case e, s.
     Ask for a reply. Get the reply.
     If the reply is Yes display "correct answer" otherwise
     display "wrong answer"

    33. After Chapter 7. PROB033
    Write an exec that breaks up the information contained in a
    variable into three variables.  Place this information in the
    first variable VAR1:

     ABCDEFGHIJKLMNOP

     Use the proper PARSE instruction to break up the first
     variable this way:

     VAR2 gets columns 3 and 4
     VAR3 gets columns 6 through 9
     VAR4 gets columns 9 through 14
     Display VAR2
     Display VAR3
     Display VAR4

     Expected results:

     CD
     FGHI
     IJKLMN


    34. After Chapter 7. PROB034
    What would this say?

     /*REXX program TESTING */
     ARG N1 N2 N3
     SAY N2 N3 N1

     if it is executed this way:

     ==> %TESTING MARYELLEN SUE KAREN

    35. After Chapter 7. PROB035
    Write an exec that will execute this TSO command:

     LISTCAT ENTRY(dataset-name)

     The dataset name is to be entered through an ARG.  Make sure
     it works on datasets belonging to you as well as those
     belonging to someone else.  Try executing it with these two
     dataset names:

     REXXPRGS.EXEC
     'SYS1.PROCLIB'

     ==> %myexec REXXPRGS.EXEC
     ==> %myexec  'SYS1.PROCLIB'

    36. After Chapter 7. PROB036
    This ARG, and this manner of execution, produces what display?
     /*REXX  addemup exec   */
     ARG NUM1 NUM2 NUM3
     TOTAL = NUM1 + NUM2 + NUM3
     SAY TOTAL

    ===> %ADDEMUP 10 20 30 40 50 60

    37. After Chapter 7. PROB037
    Write an exec that accepts three pieces of information and
    displays them in reverse order.  If more than three are
    entered, display an error message.  Expected results:

     ==>  %myexec peter paul mary
     MARY PAUL PETER
     ==> %myexec peter paul mary ringo
     I said enter only three items please!

    38. After Chapter 7. PROB038
    You want the user to type in three and only three items
    (words) of information, separated by spaces.  What does your
    PULL look like?

    39. After Chapter 7. PROB039
    Write an exec that asks for three words (only) and displays
    them in reverse order.  Expected results:

     ===> %myexec a b c
          C B A
     ===> %myexec a b c d
          C B A

    40. After Chapter 7. PROB040
    Write a front-end exec for the DELETE command.  Have it ask
    "Are you sure?"  If the dataset name is "junk.data," don't
    ask.  Expected results:

     ===> %erase abc.data
          ARE YOU SURE? Y/N
          ===> n
          NOT DELETED
     ===> %erase junk.data
          DELETED


    41. After Chapter 7. PROB041
    Write an exec that computes the percent of increase of one
    number over another.  Ask for the two amounts from the
    terminal.  The formula is:

     % increase =  100 * ((new - old) / old)

     Imagine your old salary was $21,203 and your new is $80,000.
     You would figure the % increase as:

     % increase =  100 * ((80000 - 21203) / 21203)

     Expected results:

     ===> %myexec 100 120
         20

    42. After Chapter 9, traps. PROB042
    Write an exec that asks for a dataset name and then issues
    the TSO command LISTDS on it.  Set up an ERROR trap to
    intercept the command that is not working.  In the ERROR
    trap, display the line of the program in error and the error
    code from TSO.  Ask for the dataset name again, reexecute the
    command, and exit.  Expected results:

     ===> %myexec
          PLEASE ENTER DATASET NAME
     ===> abc.nonesuch.data
          CANNOT EXECUTE TSO COMMAND
          TSO ERROR CODE IS 12
          LINE IN ERROR IS "LISTDS dsn"
          PLEASE REENTER
     ===> abc.real.data
          ABC.REAL.DATA VOLUME SERIAL D12345
          LRECL 80 BLKSIZE 3120 RECFM FB

    43. After Chapter 11, Math. PROB043
    Write an exec that will multiply two numbers.  Prompt the
    user for the two numbers, and set up a trap to intercept any
    error, such as invalid numbers.

    44. After Chapter 11, Math. PROB044
    Run this exec to determine the effect of parentheses on
    arithmetic operations. What is displayed?

     SAY (1 + 2) * 3
     SAY 1 + (2 * 3)
     SAY 1 +  2 * 3

    45. After Chapter 11, Math. PROB045
    Write an exec that asks for a number (record length) and
    another number (block size).  It determines if block size is
    an exact multiple of record length, that is, if record length
    was multiplied by a whole number to obtain block size.
    Expected results:

     ===> %myexec
          PLEASE ENTER RECORD LENGTH
     ===> 80
          PLEASE ENTER BLOCK SIZE
     ===> 3121
          BLOCK SIZE IS NOT A MULTIPLE OF RECORD LENGTH



    46. After Chapter 11, Math. PROB046

    Create a simple exec to calculate the effect of compound
    interest.  Ask for the following items from the terminal:

     Principal
     Percent of interest (yearly)
     Number of years money kept in account
     Compounding frequency (how many times per year is interest compounded?
     1 = yearly; 12 = monthly; 52 = weekly; 365 = daily)
     Perform the following calculations:
     Compute the yearly rate of interest as yearly percent of interest / 100.
     Compute r (the rate) as  yearly rate of interest /
     compounding frequency.
     Compute n (number of times compounded) as how many years X
     compounding frequency.
     Compute final amount as principal times ((1 + r)n).
     Display final amount.

    Keep this program, since you will be improving on it later.

    47. In Chapter 12. RC. PROB047

     put these into a REXX program. Notice the results.
      "LISTCAT LEVEL(your-userid)      "
     Say RC
     "LISTCAT LEVEL(JUNK)      "
     Say RC
     "LISTDOG LEVEL(your-userid )      "
     Say RC


    48. After Chapter 13. datatype, arg, math, look up the function. PROB048
    Accept two numbers from the command line, and check to be
    sure they are valid.  Subtract one from the other.  Drop the
    sign of the answer and display the answer.  Expected results:

    ===> %myexec 100 20
         80
    ===> %myexec 20 100
         80

    49. After Chapter 13. PROB049
    Use SYSDSN to see if there exists a dataset named
    WORKSHOP.TEMP.  If so, delete it.  If not, allocate a new one
    like your Exec library.  The TSO command is:

    ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)

    50. After Chapter 13. PROB050
     Redo the previous problem, supressing any display message
     from the DELETE command, using OUTTRAP.

    51. After Chapter 13. PROB051
    Redo the previous problem, supressing any display message
    from the DELETE command with the MSG function.

    52. After Chapter 13. PROB052
    Using the TRANSLATE function, create an exec that will
    convert one character string to another.  Set it up so that
    if you type in:

      GREAT

    it will print out:	  BUENO.

    53. After Chapter 13. arg, hex conversion functions. PROB053
    Write an exec that will accept a hex number, a plus or minus
    sign, and another hex number; then add or subtract based on
    the sign.  Display the answer in hex.  Expected results:

    ===> %hexmath e - 2
         C
    ===> %hexmath e + 2
         10

    54. After Chapter 13. PROB054
    Here is a working example of a program that will convert all
    the letters in a string of characters to lower case.  Modify
    it so that it converts from lower case to upper case.

    /*REXX LOWER EXEC converts upper to lower*/
    parse arg instring
    upper_alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower_alpha = "abcdefghijklmnopqrstuvwxyz"
    outstring = translate(instring,lower_alpha,upper_alpha)
    say outstring


    55. In Chapter 14. writing your own function. PROB055

     put these into a REXX program.

    SAY Mysub(1,2)
    Exit

     Mysub:
    ARG A, B
    C = A + B
     Return C

    56. After Chapter 15. PROB056
    Write an internal function that will concatenate two items
    passed to it (without spaces). Execute the internal function
    from within the same program. Expected results:

     ===> %myexec cat dog
     CATDOG

    57. After Chapter 15. PROB057
    Write an internal subroutine will concatenate two items
    passed to it (without spaces). Execute the internal
    subroutine from within the same program. Expected results:

     ===> %myexec cat dog
     CATDOG

    58. After Chapter 15. PROB058
    Redo the percent increase problem (problem 33) as an external
    function, naming it PERCENTI

      Have it accept two parameters (that is, arguments): first,
      Old salary; second, New salary.

     Have it return the percent increase on the RETURN statement.
     Check both numbers for numeric.
     If either is not valid, display a message and return a zero.

     Note that there will be two members in your library: the function
     and the main program that invokes the function.


    59. After Chapter 15. PROB059
    Using the solution to the CATDOG problem (problem 48), write
    your concatenate function as an external function

    60. After Chapter 15. user written external functions, math, arg. PROB060
    Create a metric conversion external function named Metric.
    It will accept two arguments: UNIT and QUANTITY.

     UNIT has these possible values:  LITER   QUART   MILE   KILOMETER.
     It returns a number equivalent to QUANTITY in the other
     measuring system, based on this table:

     	1 liter     	= 1.057 quarts
     	1 quart     	= .946  liters
     	1 mile      	= 8/5   kilometers
     	1 kilometer 	= .625  miles
     Also, write a main program that invokes this as a function.
     Expected results:

     ==> %myexec kilometer 1000
        625 MILES

    61. After Chapter 5. Looping, DO END PROB061
    Write an external subroutine to compute the square root of a
    number passed to it. Name it SQRT.  It will accept one ARG:
    the number.  Validate the number.  If negative, or not
    numeric, display a message and return a zero.  Make your
    guess one-half of the number.

     Repeat this loop 50 times.
       Make new guess = (guess + (number / guess)) / 2
       Make guess = new guess
     End-repeat
     Return the new guess to the caller

    62. After Chapter 17 Compound variables. PROB062
    Write an exec with a loop that sets NUMBER.1 through
    NUMBER.10 to the numbers 101 through 110; then loop through
    the array, displaying the contents of NUMBER.1 through
    NUMBER.11 (yes, NUMBER.11 is what I said) to see what
    happens.

    63. After Chapter 17 Compound variables. Outtrap. Loop. PROB063
    Write a program that captures the display from TSO commands
    in an array and then displays the lines of output one at a
    time.

    Display "Please enter a command."
    Accept the command into a variable.
    Turn on OUTTRAP using the array Display_line.
    Execute the command.  Turn off OUTTRAP.
    Display the message: "About to display command's output."
     Loop through the array, displaying each line of the command's output.

    64. Chapter 18. Execio. PROB064
    Choose a file that you currently have under your userid.
    Read it into an array.  Display every other record, starting
    with record 1.

    65. Chapter 18. Execio. PROB065
    Read in a file you currently have under your userid into an
    array, and write it out to another file.  Get both file names
    from the terminal by asking.  To allocate the new file, use
    an allocate command with LIKE.

    66. Chapter 18. Execio. PROB066
    Read any file of yours into an array.  Count each record, and
    keep track of the length of the longest one.  At the end of
    the program, display the record count and the length of the
    longest record.

    67. Chapter 18. Execio. PROB067
    Modify the command output capture exec (Problem 64) to store
    the lines of the display in the dataset:
    TEMP.CAPTURE.DATA

    Use SYSDSN to see if that dataset exists.  If it does, delete
    it.  Then allocate it (create it) with the following TSO
    command:

    ALLOC DDN(CAPTURE) DSN(TEMP.CAPTURE.DATA) NEW REUSE
      SPACE(1 1) TRACKS LRECL(80) BLKSIZE(4000) RECFM(F B)
    (Normally typed in on one line, not two.)

    OUTTRAP loads an array.  Use that array to write out the
    lines of the command display.  The WRITE command should close
    the file at the same time.

    68. Chapter 19. PROB069
    Create a quick calculator exec.  Use INTERPRET to execute an
    expression that is typed in, then display the result and name
    it CALC.  It will be used this way:

    ==> %CALC 1 + 1

    It will display "2"


    Extra practice problem. Loop. Pull. Numeric datatype function. PROB069
     Improve on your compound interest program written previously
     (problem 46)   These are the added requirements

     Put the terminal dialogue, calculations, and display into a
     loop that will repeat until you type in "NO."  After getting
     the amounts from the terminal, verify the following:

     If principal is blank, end the loop.

     If percent blank, or years blank, or years over 100, or
     principal not numeric, or percent not numeric, or years not
     numeric, then start the loop over again.


    *****************************Suggested answers for
    workshops.**********************************************

    *****************************Suggested answers for
    workshops.**********************************************

    *****************************Suggested answers for
    workshops.**********************************************

    *****************************Suggested answers for
    workshops.**********************************************


    Suggested answers for workshops:

    1.
    /* REXX PROB001*/
    	Say 1 + 1
     	Say "Today is" Date()
     	Name = "Sue"
     	Say "Hello, " Name
    2.
    /* REXX PROB002*/
    Say "hello"
    Say 1 + 1
    Say length("hello")
    num = 5

    say num + 5

    3.
    Quotes around a valid number donÆt stop REXX from doing math.
    Quotes around a variable prevent REXX from seeing the
    variableÆs contents.

    4.
    An undefined variable (or one that was DROPped) canÆt be used
    in math.

    5.
    /* REXX PROB005*/
    greeting = "Good morning"
    name = "Joe"
    say greeting name
    say greeting || name
    /*or*/
    say greeting""name
    say greeting "          "name

    6.
    It uses the TSO command SEND to send a message to another TSO user.
    The variables message and userid must be out of quotes.

    7.
    /* REXX PROB007*/
    "LISTDS 'userid.REXX.EXEC' MEMBERS"

    8.
    /* REXX PROB008*/
    members = ""
    "LISTDS 'userid.REXX.EXEC' " MEMBERS

    9.
    This program displays THE ANSWER IS 10

     10.
    /* REXX PROB010*/
    /* This is a sample exec for REXX class */
    "TIME"
    "SEND 'SAMPLE EXEC ' USER(*)"

    11.
    Displays GREETING

    12.
    Displays HELLO

    13.
    Displays HAPPY HALLOWEEN
             GREETING

    14.
    Displays 234

    15.
    /* REXX PROB015*/
    say "3 + 1 is 4"
    say "'3 + 1 is 4'"
    say "O'brien"

    16.
    /* REXX PROB016*/
    "LISTCAT ENTRY('SYS1.PROCLIB')"

    17.
    Displays MESSAGE

    18.
    /* REXX PROB018*/
    v1 = 10
    v2 = 20
    say v1 + v2

    19.
    /* REXX PROB019*/
    userid = "TSOU02" /*for example*/
    "LISTCAT LEVEL("userid")"


    20.
    They will be found equal, because a number with more than 9
    digits is rounded.

    21.
    Displays 0
    0 means the comparison is false.

    22.
    displays 0
    the comparison of "2 + 2" and "2" is false.

    23 û 27.
    Just do it.

    28.
    /* REXX PROB028*/
    previous = ""
    do 10
      say "please enter a number (not same as previous)"
      pull number
      if number = previous then say "that is same as previous"
      previous = number
    End

    29.
    /* REXX PROB029*/
    secret = 13
    do 10
      say "PLEASE ENTER YOUR GUESS, FROM 1 TO 20"
      pull number
      if number = secret then do
         say "RIGHT"
         leave
         end
      else do
         say "WRONG"
         end
    end


    30.
    /* REXX PROB030*/
    do 10
      say "PLEASE ENTER A DATASET NAME"
      pull dsn
      /* Standard TSO naming conventions:
         if name is fully qualified,
         specify with apostrophes:
         'MYUSERID.MY.DATA'
         if userid omitted, and it's yours,
         do not include apostrophes:
          MY.DATA
       */
      "LISTDS" dsn
      if rc = 0 then do
         leave
         end
      else do
         say "not found"
         end
    end

    31.
    /* REXX PROB031*/
    Say "Please enter name"
    Pull name
    select
    	when name = "JOHN" then say "PAUL JONES"
    	when name = "GEORGE" then say "Washington"
    	when name = "NELSON" then say "Mandela"
    	when name = "JULIUS" then say "Caesar"
    	when name = "" then say "Please try again"
    otherwise
    say "bad reply .> Please enter a name"
    end

    32.
    /* REXX PROB032*/
    Say "Please reply exactly Yes! "
    parse pull reply
    if reply = "Yes" then say "correct answer"
    else say "wrong answer"

    33.
    /* REXX PROB033*/
    VAR1 = "ABCDEFGHIJKLMNOP"
    Parse var VAR1  3 var2  5  6  var3  10  9  var4  15
    say var2
    say var3
    say var4

    34.
    Displays SUE KAREN MARYELLEN

    35.
    /* REXX PROB035*/
    arg dataset
      /* Standard TSO naming conventions:
         if name is fully qualified,
         specify with apostrophes:
         'MYUSERID.MY.DATA'
         if userid omitted, and it's yours,
         do not include apostrophes:
          MY.DATA
       */
    "LISTCAT ENTRY("dataset")"

    36.
    Syntax error.

    37.
    /* REXX PROB037*/
    arg v1 v2 v3 v4
    if v4 <> "" then say "I said enter only three items please!"
    say v3 v2 v1

    38.
    /* REXX PROB038*/
    Say "Please type in three words (only)"
    Pull word1 word2 word3 .
    Say  word1 word2 word3
    /* the period throws away words after the third*/

    39.
    /* REXX PROB039*/
    Say "Please type in three words (only)"
    Pull word1 word2 word3 .
    /* the period throws away words after the third*/
    Say word3 word2 word1

    40.
    /* REXX PROB040*/
    arg dataset
      /* Standard TSO naming conventions:
         if name is fully qualified,
         specify with apostrophes:
         'MYUSERID.MY.DATA'
         if userid omitted, and it's yours,
         do not include apostrophes:
          MY.DATA
       */
    if dataset = "JUNK.DATA" then "DELETE JUNK.DATA"
    else do
       Say "ARE YOU SURE? Y/N"
       pull reply
       if reply = "Y" then do
          "DELETE " dataset
          say "DELETED"
          end
        else do
          say "NOT DELETED"
          end
        end

    41.
    /* REXX PROB041*/
    Say "Please type in old salary"
    Pull old
    Say "Please type in new salary"
    Pull new
    increase =  100 * ((new - old) / old)
    Say "the % of increase was" increase

    42.
    /* REXX PROB042*/
    say "PLEASE ENTER DATASET NAME"
    pull dsn
      /* Standard TSO naming conventions:
         if name is fully qualified,
         specify with apostrophes:
         'MYUSERID.MY.DATA'
         if userid omitted, and it's yours,
         do not include apostrophes:
          MY.DATA
       */

    signal on error
    "LISTDS" dsn
    Exit

    error:
    say "CANNOT EXECUTE TSO COMMAND"
    say "TSO ERROR CODE IS " rc
    say "LINE IN ERROR IS " sourceline(sigl)
    say "PLEASE REENTER"
    pull dsn
    "LISTDS" dsn
    exit

    43.
    /* REXX PROB043*/
    say "Please type in a number"
    pull number1
    say "Please type in another number"
    pull number2

    signal on syntax
    say number1 * number2
    exit

    syntax:
    say "a syntax error has occured. "
    exit

    44.
    displays
    9
    7
    7

    45.
    /* REXX PROB044*/
    Say "PLEASE ENTER RECORD LENGTH"
    pull lrecl
    say "PLEASE ENTER BLOCK SIZE"
    pull blksize

    if (blksize // lrecl) = 0 then say "OK"
    else say "BLOCK SIZE IS NOT A MULTIPLE OF RECORD LENGTH"

    46.
    /* REXX PROB046*/
    say "Please enter principal"
    pull principal
    say "please enter yearly interest rate in percent"
    pull percent
    say "how many years is money kept in account?"
    pull years
    say "please enter how many times per year interest is compounded"
    say "1 = yearly; 12 = monthly; 52 = weekly; 365 = daily"
    pull frequency

    yearly_rate = percent / 100
    r = yearly_rate / frequency

    n = years * frequency

    final = principal * ((1 + r)**n)
    say final


    47.
    Just do it.

    48.
    /* REXX PROB048*/
    arg number1 number2
    if datatype(number1) = "CHAR" then do
       say number1 "is not a valid number"
       exit
       end

    if datatype(number2) = "CHAR" then do
       say number2 "is not a valid number"
       exit
       end

    answer = number1 - number2
    answer = abs(answer)
    say answer

    49.
    /* REXX PROB049*/
    if sysdsn(WORKSHOP.TEMP) = "OK" then do
       delete "WORKSHOP.TEMP"
       end
    else do
       "ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)"
      end

    50.
    /* REXX PROB050*/
    if sysdsn(WORKSHOP.TEMP) = "OK" then do
       call outtrap "line.", "*" /* or x = outtrap("line.","*") */
       delete "WORKSHOP.TEMP"
       end
    else do
       "ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)"
       end

    51.
    /* REXX PROB051*/
    if sysdsn(WORKSHOP.TEMP) = "OK" then do
       call msg "OFF"
       delete "WORKSHOP.TEMP"
       end
    else do
       "ALLOC DSN(WORKSHOP.TEMP) LIKE(REXXPRGS.EXEC)"
       end

    52.
    /* REXX PROB052*/
    say "Please type in GREAT"
    pull word
    say translate(word,"BUENO","GREAT")
       /* or */
    say translate(word,"ONEUB","TAERG")

    53.
    /* REXX PROB053*/
    arg hex1 sign hex2
    dec1 = x2d(hex1)
    dec2 = x2d(hex2)

    if sign = "+" then do
       dec_answer = dec1 + dec2
       end

    if sign = "-" then do
       dec_answer = dec1 - dec2
       end

    say d2x(dec_answer)

    54.
    /* REXX PROB054*/
    /*REXX Uppr EXEC converts upper to lower*/
    parse arg instring
    upper_alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower_alpha = "abcdefghijklmnopqrstuvwxyz"
    outstring = translate(instring,upper_alpha,lower_alpha)
    say outstring

    55.
    Just do it.

    56.
    /* REXX PROB056*/
    Say concat_nate("cat" "dog")
    exit

    concat_nate:
    arg var1 var2
    return var1 || var2
    /* or return var1""var2 */

    57.
    /* REXX PROB057*/
    call concat_nate "cat" "dog"
    say result
    exit

    concat_nate:
    arg var1 var2
    return var1 || var2
    /* or return var1""var2 */

    58.
    /* REXX PROB058*/
    /*REXX main program to execute PERCENTI*/
    say percenti(100000, 150000)


    /*REXX external function PERCENTI */
    /* this must be a member, named PERCENTI
    in your REXX library, or in another
    library allocated to SYSEXEC
    */
    arg old, new
    if datatype(old) = "CHAR" then do
       say "invalid number" old
       return 0
       end

    if datatype(new) = "CHAR" then do
       say "invalid number" new
       return 0
       end

    increase =  100 * ((new - old) / old)
    return increase

    59.
    /* REXX PROB059*/
    /*REXX main program*/
    call concatn "cat" "dog"
    say result
    exit


    /*REXX CONCATN external function*/
    /* this must be a member, named CONCATN
    in your REXX library, or in another
    library allocated to SYSEXEC
    */
    arg var1 var2
    return var1 || var2
    /* or return var1""var2 */

    60.
    /* REXX PROB060*/
    /*REXX main program*/
    say METRIC("KILOMETER" 1000)

    /*REXX external function METRIC*/
    /* this must be a member, named METRIC
    in your REXX library, or in another
    library allocated to SYSEXEC
    */
    arg unit quantity

    if unit = "LITER" then do
       return quantity * 1.057 "quarts"
       end

    if unit = "QUART" then do
       return quantity * .946 "liters"
       end

    if unit = "MILE" then do
       return quantity * (8/5) "kilometers"
       end

    if unit = "KILOMETER" then do
       return quantity * .625 "miles"
       end

     61.
    /* REXX PROB061*/
    /*REXX main program*/
    call SQRT 25
    say result
    /* ------------------------------------------*/
    /*REXX SQRT external function */
    /* this must be a member, named SQRT
    in your REXX library, or in another
    library allocated to SYSEXEC
    */
    arg number
    if number < 0 then do
       say "number must be positive"
       return 0
       end

    if datatype(number) = "CHAR" then do
       say "number must be numeric"
       return 0
       end

    guess = number / 2
    do 50
      new_guess = (guess + (number / guess)) / 2
      guess = new_guess
    end
    return new_guess


    62.
    /* REXX PROB062*/
    do i = 1 to 10
      number.i = i + 100
    end i

    do i = 1 to 11
      say number.i
    end i

    63.
    /* REXX PROB063*/
    say "please enter a command"
    pull command

    call outtrap "Display_line.", "*"
    command
    call outtrap "OFF"

    say "About to display command's output"
    do i = 1 to Display_line.0
      say Display_line.i
    end i

    64.
    /* REXX PROB064*/
    sample_file = "my.sample.file"
    "ALLOC DDN(INFILE) SHR REUSE DSN("sample_file")"
    "EXECIO * DISKR INFILE (STEM INFILE. FINIS)"
    "FREE DDN(INFILE)"
    Do i = 1 to infile.0 by 2
      say infile.i
    end i

    65.
    /* REXX PROB065*/
    sample_file   = "my.sample.file"
    sample_output = "my.sample.output"

    "ALLOC DDN(INFILE) SHR REUSE DSN("sample_file")"
    "EXECIO * DISKR INFILE (STEM INFILE. FINIS)"
    "FREE DDN(INFILE)"

    "ALLOC DDN(OUTFILE) NEW REUSE DSN("sample_output")",
      "LIKE("sample_file")"

    "EXECIO " infile.0 "DISKW OUTFILE (STEM INFILE. FINIS)"
    "FREE DDN(OUTFILE)"

    66.
    /* REXX PROB066*/
    sample_file = "my.sample.file"
    "ALLOC DDN(INFILE) SHR REUSE DSN("sample_file")"
    "EXECIO * DISKR INFILE (STEM INFILE. FINIS)"
    "FREE DDN(INFILE)"

    record_count = 0
    max_length = 0

    Do i = 1 to infile.0
      record_count = record_count + 1
      say infile.i

      if length(infile.i) > max_length
      then max_length = length(infile.i)

    end i

    Say "record count was " record_count
    /* or infile.0 instead of record_count */
    Say "length of longest record was " max_length

    67.
    /* REXX PROB067*/
    say "please enter a command"
    pull command

    call outtrap "Display_line.", "*"
    command
    call outtrap "OFF"

    if sysdsn("temp.capture.data") = "OK"
    then "DELETE TEMP.CAPTURE.DATA"

    "ALLOC DDN(CAPTURE) DSN(TEMP.CAPTURE.DATA) NEW REUSE",
      "SPACE(1 1) TRACKS LRECL(80) BLKSIZE(4000) RECFM(F B)"

    "EXECIO " Display_line.0 "DISKW CAPTURE (STEM Display_line. FINIS)"
    "FREE DDN(CAPTURE)"

    68.
    /* REXX PROB068*/
    arg expression
    interpret "say" expression

    /* REXX PROB069*/
    /*Extra practice problem.*/
    do until reply = "NO"
      say "Please enter principal"
      pull principal
      if principal = "" then leave
      if datatype(principal) = "CHAR" then iterate

      say "please enter yearly interest rate in percent"
      pull percent
      if percent = "" then iterate
      if datatype(principal) = "CHAR" then iterate

      say "how many years is money kept in account?"
      pull years
      if years = "" then iterate
      if years > 100 then iterate
      if datatype(principal) = "CHAR" then iterate

      say "please enter how many times per year interest is compounded"
      say "1 = yearly; 12 = monthly; 52 = weekly; 365 = daily"
      pull frequency

      yearly_rate = percent / 100
      r = yearly_rate / frequency

      n = years * frequency

      final = principal * ((1 + r)**n)
      say final

      say "do another calculation? YES/NO"
      pull reply
    end

*

ÝBooks Computer¨

| /Home/ <http://theamericanprogrammer.com/> | /Books for Computer
Professionals/ <http://theamericanprogrammer.com/books/index.shtml>
| /Privacy/ <http://theamericanprogrammer.com/privacy.shtml> | /Terms /
<http://theamericanprogrammer.com/terms.shtml> |
| /Site Map and Site Search/
<http://theamericanprogrammer.com/sitemap.shtml> | /Programming Manuals
and Tutorials/ <http://theamericanprogrammer.com/manuals/index.shtml>
| /The REXX Files/
<http://theamericanprogrammer.com/programming/rexxfiles.shtml>

