#pragma eject
#pragma title dd3270.C - display fields on a 3270 device

/*+-----------------------------------------------------------------+
  | Program:   dd3270.c                                             |
  | Language:  c                                                    |
  | Support:   DAF                                                  |
  | Purpose:   To learn some full screen 3270 coding techniques to  |
  |            use on the IBM 3270 display station.                 |
  |                                                                 |
  |            The following publications have been used in the     |
  |            developement of this program:                        |
  |              SC28-1875 TSO/E v2 programming Services            |
  |              GA23-0059 3270 Info. Display Sys. Data Stream      |
  |                        Programmers Reference.                   |
  |              GA27-3831 3174 Establishment Controller Character  |
  |                        Set Reference.                           |
  |              GA27-2837 3270 Character Set Reference.            |
  |              HUR 9058  IBM3270 Personal Computer Graphics       |
  |                        Control Program Data Stream Reference.   |
  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |
  |                        Station Description.                     |
  |              GG27-6999 Introduction to Programming the IBM 3270.|
  |                                                                 |
  |            This programs main routine creates a simple notepad  |
  |            window on the 3270. It uses routines to build the    |
  |            notepad that support the creation, modification,     |
  |            removal, and display of fields on the 3270 screen.   |
  |            A screen is represented as linked list of fields.    |
  |            These field routines can be viewed as an API that    |
  |            the main program (application) uses to create windows|
  |            on the 3270. The application is freed from managing  |
  |            things like buffer address translation, and data     |
  |            stream creation, and inbound data stream parsing.    |
  |            Varying length strings are represented by the data   |
  |            type LSTR. These strings can contain amy amount of   |
  |            data including the null character.                   |
  |                                                                 |
  |            The following techniques have not been implemented   |
  |            in this program but will be added later:             |
  |            - Data stream compression using RBA.                 |
  |            - Program symbol sets support.                       |
  |            - Graphics support.                                  |
  |                                                                 |
  | Notes:     1. Numeric fields do not work the same on all        |
  |               devices. The 3192-G allows lowercase character    |
  |               input. Many devices also upper case character     |
  |               input.                                            |
  |            2. Most devices do not support field attributes:     |
  |               Field Outlining, Background color, and Field      |
  |               Validation.                                       |
  |            3. The character set for APL does not appear to be   |
  |               allowed on the SFE order, only on the SA order.   |
  | End.                                                            |
  +-----------------------------------------------------------------+*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <svc.h>
#include <tput.h>
#include <ostask.h>

#define _AMODE31

#include "ps9x16u.inc"
#include "ps9x15u.inc"
#include "ps9x12u.inc"

/* escape character and device commands */
#define ESC     0x27
#define EW      0xf5
#define EWA     0x7e
#define WRT     0xf1
#define WSF     0xf3
#define RB      0xf2

/* write control characters, or'd together as required */
#define WCCMDT  0x01
#define WCCKBD  0x02
#define WCCRES  0xc0
#define WCCBEL  0x04

/* 3270 data stream orders */
#define GE      0x08
#define FF      0x0c
#define CRR     0x0d
#define SBA     0x11
#define EUA     0x12
#define ICUR    0x13
#define NL      0x15
#define EM      0x19
#define DUP     0x1c
#define SF      0x1d
#define FM      0x1e
#define SA      0x28
#define SFE     0x29
#define MF      0x2c
#define RA      0x3c
#define SUB     0x3f

#define PROT    0x20
#define NUM     0x10

/* Type byte of the SA, SFE and MF orders */
#define ALL     0x00
#define NONE    0x00
#define DFLT    0x00

#define ATTR    0xc0
#define FVALID  0xc1
#define OUTLIN  0xc2
#define HILITE  0x41
#define COLOR   0x42
#define SYMSET  0x43
#define BAKCOL  0x45
#define TRANSP  0x46

#define APL     0xF1

/* Out lines for the value byte of the SA, SFE, or MF order */
#define UNDR    0x01
#define OVR     0x04
#define OVRUND  0x05
#define NOOVR   0x0b
#define NOUNDR  0x0e
#define RECT    0x0f

/* Hilites for the value byte of the SA, SFE, or MF order */
#define BLINK   0xf1
#define RVIDEO  0xf2
#define USCORE  0xf4

/* Colors for the value byte of the SA, SFE, or MF order */
#define BLUE    0xf1
#define RED     0xf2
#define PINK    0xf3
#define GREEN   0xf4
#define TURQ    0xf5
#define YELLOW  0xf6
#define WHITE   0xf7

/* Attribute for the value byte of the SF, SFE and MF order */
#define UNPRT   0x40
#define UNNUM   0x50
#define UNNUMHI 0xd8
#define UNNON   0x4c
#define UNHI    0xc8
#define PRT     0x60
#define PRTHI   0xe4
#define PRTAS   0xf0
#define PRTHIAS 0xf8

/* Attention Identification (AID) Values */
#define NOAID   0x60
#define NOAIDP  0xe8
#define STRFLD  0x88
#define ENTER   0x7d
#define PF1     0xf1
#define PF2     0xf2
#define PF3     0xf3
#define PF4     0xf4
#define PF5     0xf5
#define PF6     0xf6
#define PF7     0xf7
#define PF8     0xf8
#define PF9     0xf9
#define PF10    0x7a
#define PF11    0x7b
#define PF12    0x7c
#define PF13    0xc1
#define PF14    0xc2
#define PF15    0xc3
#define PF16    0xc4
#define PF17    0xc5
#define PF18    0xc6
#define PF19    0xc7
#define PF20    0xc8
#define PF21    0xc9
#define PF22    0x4a
#define PF23    0x4b
#define PF24    0x4c
#define OID     0xe6
#define MAG     0xe7
#define PEN     0x7e
#define PA1     0x6c
#define PA2     0x6e
#define PA3     0x6b
#define CLEAR   0x6d
#define SYSREQ  0xf0

typedef
  struct LSTR     /* string with length */
  {
    int len ;             /* current length of data */
    char *data ;          /* pointer to data */
  } TLSTR ;

typedef
  struct SFLD     /* 3270 screen field information list entry */
  {
    int fid ;             /* unique field identifier */
    TLSTR fdata ;         /* field data (input or output) */
    int fxpos ;           /* X column position */
    int fypos ;           /* Y row position */
    char fattr ;          /* 3270 field attribute */
    char fcolor ;         /* 3270 color attribute */
    char fhilite ;        /* 3270 hilite attribute */
    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */
    struct SFLD *next ;   /* next list entry */
  } TSFLD ;

#define BUFFMAX 5000
char *buffer ;    /* buffer area for tput/tget */

TSFLD *screen ;   /* root of 3270 screen field list */

#define SFIDMAX 256
TSFLD *sfidtabÝSFIDMAX¨ ; /* field id address table */
int fidnext = 0 ;         /* next field id number to assign */
int curcol = 1 ;          /* current cursor column */
int currow = 1 ;          /* current cursor row */
int bellflg = 0 ;         /* ring bell on next display */
int iotrace = 0 ;         /* trace terminal I/O flag */


struct DCB        /* Device control block */
  {
    int model ;         /* model number ie: 3279, 3278, 3277 */
    int type ;          /* model type ie: 2, 3, 4, 5 */
    int rows ;          /* number of rows (height) on device */
    int cols ;          /* number of columns (width) on device */
    int celheigh ;      /* cell height on device */
    int celwidth ;      /* cell width on device */
    int colors ;        /* number of colors on device */
    int colora ;        /* number of actual colors on device */
    int hilites ;       /* number of colors on device */
    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/
    char unit ;         /* 0 = inch 1 = mm */
    char edsflg ;       /* extended data stream flag */
    char psflg ;        /* program symbols on device flag */
    char altflg ;       /* use alternate flag */
    char aplflg ;       /* 0 or apl's lcid=supports APL on device */
    char graflg ;       /* graphics device flag */
    char loadflg ;      /* loadable symbol sets supported flag */
    char triflg ;       /* triple plane symbol sets supported flag */
    char dbcsflg ;      /* double byte characters supported flag */
    char colorlstÝ17¨ ; /* list of color attributes on device */
    char hilitlstÝ5¨ ;  /* list of hilite attributes on device */
    char modnameÝ11¨ ;  /* name of device ie: IBM32793B IBM3179G ..*/
  } sdcb ;



/*-------------------------------------------------------------------*/
/* Function Prototypes                                               */
/*-------------------------------------------------------------------*/

/* field handling */
int initscr() ;
void termscr() ;
char dspflds() ;
int insfld(TLSTR *, int, int, char, char, char) ;
int getdev() ;
int remflds() ;
int delfld(int) ;
int erasefld(int) ;
int getfld(int, TLSTR *) ;
int modfld(int, TLSTR *) ;
int setfld(int, int, char) ;
void dumpfld() ;
/* 3270 support */
int tputn(char *, int) ;
int tgetn(char *, int) ;
int tpgn(char *, int) ;
void rc2sba(int, int, char *) ;
void sba2rc(char *, int *, int *, int) ;
int modsym(char *, char) ;
int modcolor(char *, char) ;
int modhilit(char *, char) ;
int modattr(char *, char) ;
int getterm(int *, int *, int *, int *, int *) ;
int querydev() ;
int dsummary(char *, short) ;
int darea(char *, short) ;
int dcharset(char *, short) ;
int dcolor(char *, short) ;
int dhilite(char *, short) ;
int dmodes(char *, short) ;
int dimpart(char *, short) ;
int loadps1() ;
void termstat() ;
void clear() ;
/* varying length string */
void lstran(TLSTR *, char, char) ;
int lstrlen(TLSTR *) ;
void lstrload(TLSTR *, char *, int) ;
int lstrunld(char *, TLSTR *) ;
void lstrcopy(TLSTR *, TLSTR *) ;
void lstrnew(TLSTR *, char *) ;
void lstrsub(TLSTR *, TLSTR *, int, int) ;
int lstrindx(TLSTR *, TLSTR *) ;
void lstrfill(TLSTR *, char *) ;
int lstrcmpc(TLSTR *, char *) ;
void lstrdel(TLSTR *) ;
void lstrrep(TLSTR *, char *, int) ;
void lstrcat(TLSTR *, TLSTR *, TLSTR *) ;
/* utility */
void fill(char *, char, int) ;
void dumpchar(char *, int) ;
void overlay(char *, int, char *, int, int) ;
void serror(int, char *) ;


/* application routines */
void buildwin() ;
void dispwin() ;
void winmsg(char *) ;

/* variables for application */
int cmdfid ;       /* field identifier for command line */
int msgfid ;       /* field identifier for message line */
int bt ;           /* top border */
int bb ;           /* bottom border */
int bl ;           /* left border */
int br ;           /* right border */
int cmdflg = 0 ;   /* command flag = true if command done */

 /*-----------------------------------------------------------------*
  | Main Program                                                    |
  *-----------------------------------------------------------------*/
void main(int argc, char **argv, char **envp)
  {
    int rc ;        /* return code */

    rc = initscr() ;  /* initialise environment */
    if (rc==0)         /* if env OK */
      {
        /* initial border positions */
        bt = 1 ;            /* top border */
        bb = sdcb.rows ;    /* bottom border */
        bl = 1 ;            /* left border */
        br = sdcb.cols ;    /* right border */

        /* indicate cursor on command field and set field to blank */
        cmdflg = 1 ;

        buildwin() ;  /* build the initial display window */
        dispwin() ;   /* display the window and run appl. */

        termscr() ;   /* terminate environment */
      }
  }


/*-------------------------------------------------------------------*/
/* Build a window with a title, command line and an edit space.      */
/*-------------------------------------------------------------------*/
void buildwin()
  {
    int t, tl ;                /* temp */
    int i ;                    /* counter */
    int fid ;                  /* field identifier handle */
    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */
    TLSTR title ;              /* title string */

    /* create title line */
    lstrnew(&title," DD3270: Note pad");

    /* create command line (prompt, input area, and help) */
    lstrnew(&data,"Command ===>") ;   /* create VLstring */
    fid = insfld(&data,bt+1,bl+2,PRT,WHITE,NONE);
    if (fid<0) serror(81,"Field insert failed") ;
    lstrnew(&data," ") ;   /* create VLstring */
    cmdfid = insfld(&data,bt+1,bl+15,UNPRT,GREEN,NONE);
    if (cmdfid<0) serror(81,"Field insert failed") ;
    if ((br-bl)>18)
      {
        lstrnew(&data,"PF1=Help PF3=End") ;   /* create VLstring */
        fid = insfld(&data,bt+1,br-18,PRT,WHITE,NONE);
        if (fid<0) serror(81,"Field insert failed") ;
      }

    /* create message line */
    lstrnew(&data," ") ;   /* create VLstring */
    msgfid = insfld(&data,bt+2,bl+2,PRTHI,RED,NONE);
    if (msgfid<0) serror(81,"Field insert failed") ;

    /*----------------------------------------------------------------*/
    /* Create top window border                                       */
    /*   The border outline is drawn with different characters        */
    /*     based on the devices abilities.                            */
    /*   Window border locations are based on four global variables:  */
    /*     bt - top border row                                        */
    /*     bb - bottom border row                                     */
    /*     br - right border column                                   */
    /*     bl - left border column                                    */
    /*----------------------------------------------------------------*/
    if (sdcb.loadflg)
      {
        lstrnew(&data1,"\x42\x47") ;     /* top left corner */
        lstrnew(&data2,"\x48\x46\x45\x44") ; /* top right corner */
        lstrnew(&data3," ") ;
        lstran(&title,0x40,0x48) ;      /* translate in PS blank char */
        tl = lstrlen(&title) ; /* actual title length */
        t = br-bl-5 ;           /* available space */
        if (tl>t)
          {
            lstrcopy(&data,&data1) ;       /* add left border */
            lstrsub(&data3,&title,1,t-1) ; /* shorten title */
            lstrcat(&data,&data,&data3) ;  /* add title */
            lstrcat(&data,&data,&data2) ;  /* add right border */
          }
        else
          {
            lstrcopy(&data,&data1) ;       /* add left border */
            lstrcat(&data,&data,&title) ;  /* add title */
            lstrrep(&data3,"\x48",t-tl-1) ;/* repeat char to string */
            lstrcat(&data,&data,&data3) ;  /* add top border chars */
            lstrcat(&data,&data,&data2) ;  /* concat strings */
          }
        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);
        if (fid<0) serror(81,"Field insert failed") ;
        setfld(fid,SYMSET,0x40) ;   /* make it id of PS symbols */
      }
    else if (sdcb.aplflg)
      {
        lstrnew(&data1,"\xc5\xee") ;     /* top left corner */
        lstrnew(&data2,"\xa2\xba\xbb\xd5") ;   /* top right corner */
        tl = lstrlen(&title) ; /* actual title length */
        t = br-bl-5 ;           /* available space */
        if (tl>t)
          {
            lstrcopy(&data,&data1) ;       /* add left border */
            lstrsub(&data4,&title,1,t-1) ; /* shorten title */
            lstrnew(&data3,"\x28\x43\x01") ;  /* stop APL chars */
            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */
            lstrcat(&data,&data,&data3) ;  /* add stop APL */
            lstrcat(&data,&data,&data4) ;  /* add title */
            lstrnew(&data3,"\x28\x43\xf1") ;  /* start APL */
            lstrcat(&data,&data,&data3) ;  /* add start APL */
            lstrcat(&data,&data,&data2) ;  /* add right border */
          }
        else
          {
            lstrcopy(&data,&data1) ;       /* add left border */
            lstrnew(&data3,"\x28\x43\x01") ;  /* stop APL chars */
            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */
            lstrcat(&data,&data,&data3) ;  /* add stop APL */
            lstrcat(&data,&data,&title) ;  /* add title */
            lstrnew(&data3,"\x28\x43\xf1") ;  /* start APL */
            lstrcat(&data,&data,&data3) ;  /* add start APL */
            lstrrep(&data3,"s",t-tl-1) ;   /* repeat char to string */
            lstrcat(&data,&data,&data3) ;  /* add top border chars */
            lstrcat(&data,&data,&data2) ;  /* concat strings */
          }
        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);
        if (fid<0) serror(81,"Field insert failed") ;
        setfld(fid,SYMSET,APL) ; /* make it APL */
      }
    else
      {
        lstrnew(&data1,"+#") ;     /* create VLstring */
        lstrnew(&data2,"-VA+") ;   /* create VLstring */
        lstrnew(&data3," ") ;
        tl = lstrlen(&title) ;     /* actual title length */
        t = br-bl-5 ;              /* available space */
        if (tl>t)
          {
            lstrcopy(&data,&data1) ;       /* add left border */
            lstrsub(&data4,&title,1,t-1) ; /* shorten title */
            lstrcat(&data,&data,&data4) ;  /* add title */
            lstrcat(&data,&data,&data2) ;  /* add right border */
          }
        else
          {
            lstrcopy(&data,&data1) ;       /* add left border */
            lstrcat(&data,&data,&title) ;  /* add title */
            lstrrep(&data3,"-",t-tl-1) ;   /* repeat char to string */
            lstrcat(&data,&data,&data3) ;  /* add top border chars */
            lstrcat(&data,&data,&data2) ;  /* concat strings */
          }
        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);
        if (fid<0) serror(81,"Field insert failed") ;
      }

    /* create edit area lines and left and right borders */
    for (i=bt+1; i<=bb-1; i++)    /* edit area fields */
      {
        /* add left border */
        if (sdcb.loadflg)
          {
            lstrnew(&data,"\x71") ;
            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;
            if (fid<0) serror(81,"Field insert failed") ;
            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */
          }
        else if (sdcb.aplflg)
          {
            lstrnew(&data,"e") ;
            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;
            if (fid<0) serror(81,"Field insert failed") ;
            setfld(fid,SYMSET,APL) ; /* make it APL */
          }
        else
          {
            lstrnew(&data,"|") ;
            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;
            if (fid<0) serror(81,"Field insert failed") ;
          }

        if (i> (bt+2))   /* if beyond title/command/msg area */
          {
            /* add text input area */
            lstrnew(&data," ") ;
            fid = insfld(&data,i,bl+2,UNHI,GREEN,NONE) ;
            if (fid<0) serror(81,"Field insert failed") ;
          }

        /* add right border */
        if (sdcb.loadflg)
          {
            lstrnew(&data,"\x71") ;
            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;
            if (fid<0) serror(81,"Field insert failed") ;
            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */
          }
        else if (sdcb.aplflg)
          {
            lstrnew(&data,"e") ;
            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;
            if (fid<0) serror(81,"Field insert failed") ;
            setfld(fid,SYMSET,APL) ; /* make it APL */
          }
        else
          {
            lstrnew(&data,"|") ;
            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;
            if (fid<0) serror(81,"Field insert failed") ;
          }
      }  /* of for edit area lines */

    /* create bottom border */
    if (sdcb.loadflg)
      {
        lstrnew(&data1,"\x67") ;       /* lower left corner */
        lstrnew(&data2,"\x69") ;       /* lower right corner */
        lstrrep(&data,"\x70",br-bl-2) ;/* lower border chars */
        lstrcat(&data,&data1,&data) ;  /* concat strings */
        lstrcat(&data,&data,&data2) ;  /* concat strings */
        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;
        if (fid<0) serror(81,"Field insert failed") ;
        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */
      }
    else if (sdcb.aplflg)
      {
        lstrnew(&data1,"D") ;          /* lower left corner */
        lstrnew(&data2,"M") ;          /* lower right corner */
        lstrrep(&data,"s",br-bl-2) ;   /* lower border chars */
        lstrcat(&data,&data1,&data) ;  /* concat strings */
        lstrcat(&data,&data,&data2) ;  /* concat strings */
        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;
        if (fid<0) serror(81,"Field insert failed") ;
        setfld(fid,SYMSET,APL) ; /* make it APL */
      }
    else
      {
        lstrnew(&data1,"+") ;          /* lower left corner */
        lstrnew(&data2,"+") ;          /* lower right corner */
        lstrrep(&data,"-",br-bl-2) ;   /* lower border chars */
        lstrcat(&data,&data1,&data) ;  /* concat strings */
        lstrcat(&data,&data,&data2) ;  /* concat strings */
        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;
        if (fid<0) serror(81,"Field insert failed") ;
      }
  }


/*-------------------------------------------------------------------*/
/* Display the window and process the keys/commands entered.         */
/*-------------------------------------------------------------------*/
void dispwin()
  {
    TLSTR temp  ;        /* temp varying length string */
    TLSTR command ;      /* command name varying length string */
    char key ;           /* AID for the key just pressed */

    lstrnew(&command," ") ;
    while(lstrcmpc(&command,"end") != 0)
      {
        if (cmdflg)
          {
            /* set initial cursor row and col to the command field */
            currow = bt + 1 ;
            curcol = bl + 16 ;
            /* blank out the command line */
            lstrnew(&command," ") ;
            modfld(cmdfid,&command) ;
            cmdflg = 0 ;
          }
        key = dspflds() ;     /* display the screen and get aid=key */
        lstrnew(&temp," ") ;
        modfld(msgfid,&temp) ;    /* blank message line */
        getfld(cmdfid,&command) ;  /* get the command line */

        /* Process function keys PFKs */
        switch (key)
          {
            case ENTER:
              if (currow == bt) /* window border accelerators */
                {
                  if (curcol == (bl+2))  /* close window */
                    {
                      lstrnew(&command,"end") ;
                    }
                  else if (curcol == (br-2))  /* minimise window */
                    {
                      bt = 1 ;
                      bl = 1 ;
                      br = 40 ;
                      bb = 6 ;
                      remflds() ;
                      buildwin() ;  /* re-build the display window */
                    }
                  else if (curcol == (br-1))  /* maximise window */
                    {
                      bt = 1 ;
                      bl = 1 ;
                      br = sdcb.cols ;
                      bb = sdcb.rows ;
                      remflds() ;
                      buildwin() ;  /* re-build the display window */
                    }
                }
              break ;
            case PF1:    /* No help message */
              winmsg(
                "Move border: PF23=Top PF11=Bottom PF10=Left PF12=Right"
                ) ;
              break ;
            case PF3:    /* Generate end command */
            case PF15:   /* Alternate generate end command */
              lstrnew(&command,"end") ;
              break ;

            case PF10:   /* move left border */
              if ((curcol<(br-25)) &&
                  (curcol>=1) )
                {
                  bl = curcol-1 ; /* adjust for attr byte */
                  remflds() ;
                  buildwin() ;  /* re-build the display window */
                }
              else
                winmsg("Left border move position too far.") ;
              break ;

            case PF11:   /* move bottom border */
              if ((currow>(bt+8)) &&
                  (currow<=sdcb.rows) )
                {
                  bb = currow ;
                  remflds() ;
                  buildwin() ;  /* re-build the display window */
                }
              else
                winmsg("Bottom border move position too far.") ;
              break ;

            case PF12:   /* move right border */
              if ((curcol>(bl+25)) &&
                 (curcol<=sdcb.cols) )
                {
                  br = curcol-1 ;  /* adjust for attr byte */
                  remflds() ;
                  buildwin() ;  /* re-build the display window */
                }
              else
                winmsg("Right border move position too far.") ;
              break ;

            case PF23:   /* move top border */
              if ((currow<(bb-8)) &&
                  (currow>=1) )
                {
                  bt = currow ;
                  remflds() ;
                  buildwin() ;  /* re-build the display window */
                }
              else
                winmsg("Top border move position too far.") ;
              break ;

            case PF24:   /* zoom to max window size */
              bt = 1 ;
              bl = 1 ;
              br = sdcb.cols ;
              bb = sdcb.rows ;
              remflds() ;
              buildwin() ;  /* re-build the display window */
              break ;

            case PA2:    /* reshow key does nothing - yet */
              break ;

            default:     /* any other key is not valid */
              bellflg = 1 ;  /* sound alarm */
              winmsg("Invalid function key.") ;
              break ;
          }

        /* Process command from the command line */
        if (lstrcmpc(&command,"test") == 0)   /* test command */
          {
            winmsg("The test command was entered.") ;
            cmdflg = 1 ;  /* reset command line */
          }
        else if (lstrcmpc(&command,"dump") == 0)  /* dump command */
          {
            dumpfld() ;
            winmsg("Dump command executed.") ;
            cmdflg = 1 ;  /* reset command line */
          }
        else if (lstrcmpc(&command,"load") == 0)  /* force load PS */
          {
            loadps1() ;
            winmsg("Load PS type 1 command executed.") ;
            cmdflg = 1 ;  /* reset command line */
          }
        else if (lstrcmpc(&command,"termstat") == 0) /*dump term data*/
          {
            termstat() ;
            winmsg("Terminal status printed.") ;
            cmdflg = 1 ;  /* reset command line */
          }
        else if (lstrcmpc(&command,"traceon") == 0) /* trace on */
          {
            iotrace = 1 ;
            winmsg("Trace is on.") ;
            cmdflg = 1 ;  /* reset command line */
          }
        else if (lstrcmpc(&command,"traceoff") == 0) /* trace off */
          {
            iotrace = 0 ;
            winmsg("Trace is off.") ;
            cmdflg = 1 ;  /* reset command line */
          }

      }   /* of while command not end */
    clear() ;   /* clear the 3270 screen */
  }


/*-------------------------------------------------------------------*/
/* Display the window and process the keys/commands entered.         */
/*-------------------------------------------------------------------*/
void winmsg(char *msg)
  {
    TLSTR msgstr  ;     /* message varying length string */

    lstrnew(&msgstr,msg) ;
    modfld(msgfid,&msgstr) ;
  }

/*********************************************************************/
/* 3270 field handling routines                                      */
/*   rc = initscr()                                                  */
/*   termscr()                                                       */
/*   fid = insfld(data,row,col,attr,color,hilite)                    */
/*   rc = remflds()                                                  */
/*   rc = delfld(fid)                                                */
/*   rc = erasefld(fid)                                              */
/*   rc = getfld(fid,returndata)                                     */
/*   rc = modfld(fid,newdata)                                        */
/*   rc = setfld(fid,attrtype,attrvalue)                             */
/*   dumpflds()                                                      */
/*                                                                   */
/*********************************************************************/


/*-------------------------------------------------------------------*/
/* Set up the screen environment.                                    */
/*-------------------------------------------------------------------*/
int initscr()
{
    int rc = 0 ;

    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */
    if (buffer)
      {
        rc = getdev() ;  /* get3270 device information */
        if (rc==0 && sdcb.loadflg==1)
          loadps1() ;
      }
    else
      rc = 1 ;   /* could not get buffer */

    return rc ;
}

/*-------------------------------------------------------------------*/
/* Terminate screen environment.                                     */
/*-------------------------------------------------------------------*/
void termscr()
{
    if (screen)
      remflds() ;       /* remove any remaining fields */

    free((char *)buffer) ;  /* remove tput/get buffer */
}

/*-------------------------------------------------------------------*/
/* Display current contents of the 3270 field list.                  */
/*-------------------------------------------------------------------*/
char dspflds()
{
  TSFLD *curr ;
  int rc, bufpos, trow = 0, tcol = 0, fstart, fend, ilen ;
  char sbaÝ2¨ ;
  char aid ;

  /* assemble buffer, it will contain: (EW WCC) followed by all  */
  /* the display fields. Each field will contain:                */
  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */
  if (sdcb.altflg)
    bufferÝ0¨ = EWA ;     /* erase write alternate */
  else
    bufferÝ0¨ = EW ;      /* erase write */

  /* determine if the bell should be rung */
  if (bellflg)
    {
      bufferÝ1¨ = WCCRES | WCCKBD | WCCMDT | WCCBEL ;
      bellflg = 0 ;  /* turn bell flag off, one ring only */
    }
  else
    bufferÝ1¨ = WCCRES | WCCKBD | WCCMDT ;

  bufpos = 2 ;
  curr = screen ;     /* first node in field list */
  while (curr)
    {
      bufferÝbufpos++¨ = SBA ;  /* set buffer address */
      rc2sba(curr->fypos,curr->fxpos,sba) ;
      bufferÝbufpos++¨ = sbaÝ0¨ ;
      bufferÝbufpos++¨ = sbaÝ1¨ ;
      if (sdcb.edsflg)
        {
          bufferÝbufpos++¨ = SFE ;  /* start field extended */
          bufferÝbufpos++¨ = 0x03 ;
          bufferÝbufpos++¨ = 0xc0 ;
          bufferÝbufpos++¨ = curr->fattr ;
          bufferÝbufpos++¨ = HILITE ;
          bufferÝbufpos++¨ = curr->fhilite ;
          bufferÝbufpos++¨ = COLOR ;
          bufferÝbufpos++¨ = curr->fcolor ;

          /* insert set character attribute before data if APL/PS syms*/
          /* are required and the field has protection turned on.     */
          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/
            && (curr->fattr & 0x40)) /* and protected field */
            {
              bufferÝbufpos++¨ = SA ;           /* set attribute */
              bufferÝbufpos++¨ = SYMSET ;       /* symbol */
              if (curr->symbol==APL) /* APL ? */
                bufferÝbufpos++¨ = sdcb.aplflg ; /* use APL's lcid */
              else
                bufferÝbufpos++¨ = curr->symbol ; /* use symbol value */
            }
        }
      else    /* dont used extended data stream */
        {
          bufferÝbufpos++¨ = SF ;  /* start field */
          bufferÝbufpos++¨ = curr->fattr ;
        }

      /* insert field data */
      ilen = lstrunld(&bufferÝbufpos¨,&curr->fdata) ;
      bufpos = bufpos + ilen ;

      /* revert to standard symbols after APL/PS data symbols  */
      if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/
        && (curr->fattr & 0x40)) /* and protected field */
        {
          bufferÝbufpos++¨ = SA ;       /* set attribute */
          bufferÝbufpos++¨ = SYMSET ;   /* symbol */
          bufferÝbufpos++¨ = DFLT ;     /* revert to default symbols */
        }

      curr = curr->next ;  /* go to next field */
    }

  /* insert the cursor in the same location the user left it */
  bufferÝbufpos++¨ = SBA ;     /* add set buffer address order */
  rc2sba(currow,curcol,sba) ;  /* determine SBA for current row/col */
  bufferÝbufpos++¨ = sbaÝ0¨ ;  /* add buffer addr part 1 */
  bufferÝbufpos++¨ = sbaÝ1¨ ;  /* add buffer addr part 2 */
  bufferÝbufpos++¨ = ICUR ;    /* add insert cursor order */

  /* dumpchar(buffer,bufpos) ; */

  /* write buffer to the 3270 */
  rc = tputn(buffer, bufpos) ;

  fill(buffer,0x00,bufpos) ;
  /* receive the response from the user */
  rc = tgetn(buffer, BUFFMAX ) ;

  /* decode input, should be an AID, a cursor pos bufferaddr */
  /* and a list of fields (SBA addr1 addr2 data)             */

  aid = bufferÝ0¨ ;      /* get code of key that was pressed */
  sbaÝ0¨ = bufferÝ1¨ ;
  sbaÝ1¨ = bufferÝ2¨ ;
  sba2rc(sba,&currow,&curcol,0) ;  /* convert and store cursor pos */
                                   /* adjust = 0 used for cursor pos */

  curr = screen ;
  fstart = 0 ;
  bufpos = 3 ;
  while(bufpos<=BUFFMAX)
    {
      if (bufferÝbufpos¨==SBA)
        {
          /* get new buffer address */
          bufpos++ ;
          sbaÝ0¨ = bufferÝbufpos++¨ ;
          sbaÝ1¨ = bufferÝbufpos++¨ ;
          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */
                              /* adjust = 1 used for retn. buf. addr */
          fstart = bufpos ;

          /* locate field by r/c then write data to field list entry */
          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )
            {                          /* locate */
              curr = curr->next ;
              if (!curr) break ; /* could not locate - real bad */
            }

          if (curr)    /* found field - copy the data into it */
            {
              /* first locate end of data */
              fend = fstart ;
              while ((bufferÝfend¨ != SBA) &&
                     (bufferÝfend¨ != 0x00))
                fend++ ;  /* leaves fend pointing at next char. */

              /* copy data from buffer into field list */
              ilen = fend - fstart ;
              lstrload(&curr->fdata,&bufferÝfstart¨,ilen) ;

              /* adjust bufpos to last char of this returned SBA */
              bufpos = fend -1 ;
            }
          else
            {
              /* SEVERE ERROR: This should never happen */
              printf("No locate field: row %d col %d SBA %.2X %.2X\n",
                trow,tcol,sbaÝ0¨,sbaÝ1¨) ;
              curr = screen ;  /* further searches from top */
            }
        }
      else
        bufpos++ ;   /* advance to next char */
    }

  return aid ;    /* data returned OK */
}


/*-------------------------------------------------------------------*/
/* Dump field list to stdout.                                        */
/*-------------------------------------------------------------------*/
void dumpfld()
{
  TSFLD *curr ;
  int i = 0, size = 0 ;
  char sbaÝ2¨ ;

  printf("Field list follows:\n") ;
  curr = screen ;     /* first node in field list */
  while (curr)
    {
      printf("  Field at row %d col %d\n",curr->fypos,curr->fxpos) ;
      rc2sba(curr->fypos,curr->fxpos,sba) ;
      printf("    BufAddr: %.2X %.2X ",sbaÝ0¨,sbaÝ1¨) ;
      printf("Attrib: %.2X ",curr->fattr) ;
      printf("Hilite: %.2X ",curr->fhilite) ;
      printf("Color: %.2X ",curr->fcolor) ;
      printf("Symbol: %.2X ",curr->symbol) ;
      printf("DataLen: %d\n",curr->fdata.len) ;
      printf("    Data dump: \n") ;
      dumpchar(curr->fdata.data,curr->fdata.len) ;
      size = size + curr->fdata.len  + 11 ;
      i++ ;
      curr = curr->next ;
    }
  printf("Total fields %d, buffer size required %d\n",i,size) ;
}


/*-------------------------------------------------------------------*/
/* Print terminal status.                                            */
/*-------------------------------------------------------------------*/
void termstat()
{
  printf("Terminal status follows:\n") ;
  printf("  Device name.........: %s\n",sdcb.modname) ;
  printf("  Device model........: %d\n",sdcb.model) ;
  printf("  Device type.........: %d\n",sdcb.type) ;
  printf("  Addressing mode.....: %d\n",sdcb.adrmode) ;
  printf("  Maximum rows........: %d\n",sdcb.rows) ;
  printf("  Maximum columns.....: %d\n",sdcb.cols) ;
  printf("  Cell height.........: %d\n",sdcb.celheigh) ;
  printf("  Cell width..........: %d\n",sdcb.celwidth) ;
  printf("  Supported colors....: %d\n",sdcb.colors) ;
  printf("  Actual colors.......: %d\n",sdcb.colora) ;
  printf("  Color attr list.....: %.32X\n",sdcb.colorlst) ;
  printf("  Number of Highlights: %d\n",sdcb.hilites) ;
  printf("  Highlight attr list.: %.8X\n",sdcb.hilitlst) ;
  if (sdcb.unit)
    printf("  Unit................: mm\n") ;
  else
    printf("  Unit................: inch\n") ;
  printf("  Alternate device....: %d\n",sdcb.altflg) ;
  printf("  APL symbol set......: %.2X\n",sdcb.aplflg) ;
  printf("  Extended data stream: %d\n",sdcb.edsflg) ;
  printf("  Loadable symbols....: %d\n",sdcb.loadflg) ;
  printf("  Load PS extended....: %d\n",sdcb.psflg) ;
  printf("  Triple plane symbols: %d\n",sdcb.triflg) ;
  printf("  Double byte symbols.: %d\n",sdcb.dbcsflg) ;
  printf("  Vector graphic......: %d\n",sdcb.graflg) ;
}


/*-------------------------------------------------------------------*/
/* Add a field to the 3270 field list.                               */
/*-------------------------------------------------------------------*/
int insfld(TLSTR *flddata,       /* the data */
            int ypos,            /* display at row */
            int xpos,            /* display at column */
            char attr,           /* field attribute PRT, UNPRT ...*/
            char color,          /* field color RED, BLUE, ...*/
            char hilite )        /* field hilite BLINK, RVIDEO,...*/
{
  int rc ;
  TSFLD *newfld, *last, *top ;

  /* get storage for new nodes */
  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;
  if (!newfld) serror(20,"Not enough memory") ;
  memset(newfld,0x00,sizeof(TSFLD)) ;

  /* verify contents of all parameters */
  if ((flddata->len > 0) &&
    (flddata->len <= (sdcb.rows * sdcb.cols)))
    lstrcopy(&newfld->fdata,flddata) ;
  else
    return -1 ;

  if ((xpos > 0) &&
    (xpos < sdcb.cols))
    newfld->fxpos = xpos ;
  else
    return -2 ;

  if ((ypos > 0) &&
    (ypos <= sdcb.rows))
    newfld->fypos = ypos ;
  else
    return -3 ;

  rc = modattr(&newfld->fattr,attr) ;
  if (rc) return -4 ;

  rc = modcolor(&newfld->fcolor,color) ;
  if (rc) return -5 ;

  rc = modhilite(&newfld->fhilite,hilite) ;
  if (rc) return -6 ;

  /* insert the field into the field list in order of buffer offset */
  top = screen ;
  if (!top)   /* first entry in the list (screen->00) */
    {
      newfld->next = NULL ;
      screen = newfld ;
    }
  else
    {
      last = NULL ;  /* last node examined */
      while(top)    /* loop through fields for insert place */
        {
          if ((top->fxpos+top->fypos*sdcb.cols) <
            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */
            {    /* chain to next node */
              last = top ;
              top = top->next ;
            }
          else
            {
              if (last)  /* insert the new node, in middle of list */
                {
                  last->next = newfld ;
                  newfld->next = top ;
                }
              else   /* insert new first node in list */
                {
                  newfld->next = top ;
                  screen = newfld ;
                }
              break ;   /* exit loop */
            }
        }
      if (!newfld->next)  /* stil not inserted? - add to end */
        last->next = newfld ;
    }

  /* update field id table and field id in field struct */
  newfld->fid = fidnext ;
  sfidtabÝfidnext¨ = newfld ;
  rc = fidnext++ ;
  return rc ;
}

/*-------------------------------------------------------------------*/
/* Remove all fields defined from the 3270 field list.               */
/*-------------------------------------------------------------------*/
int remflds()
{
  int i ;
  TSFLD *curr, *top ;

  for (i=0; i<SFIDMAX; i++)  /* empty fid table */
    sfidtabÝi¨ = NULL ;
  fidnext = 0 ;              /* reset next fid */

  top = screen ;             /* free field list */
  while(top)
    {
      curr = top ;
      top = top->next ;
      free((char *)curr->fdata.data) ;
      free((TSFLD *)curr) ;
    }
  screen = NULL ;
  return 0 ;
}

/*-------------------------------------------------------------------*/
/* Delete a field from the 3270 field list.                          */
/*-------------------------------------------------------------------*/
int delfld(int id)
{
    TSFLD *curr, *top, *last ;

    if ((id < SFIDMAX) && (id >= 0))
      {
        curr = sfidtabÝid¨ ;
        if (curr)
          {
            top = screen ;
            last = NULL ;
            while (top)
              {
                if (top == curr)
                  {
                    if (!last)   /* ? found node at top */
                      screen = top->next ;
                    else if (!top->next)  /* ? last node */
                      last->next = NULL ;
                    else           /* in middle of list */
                      last->next = top->next ;
                    /* delete the node */
                    free((char *)top->fdata.data) ;
                    free((TSFLD *)top) ;
                    sfidtabÝid¨ = NULL ; /* invalidate id */
                    return 0 ;  /* field id removed OK */
                  }
                last = top ;  /* remember last node */
                top = top->next ;   /* chain to next node */
              }    /* of while top */
          }
        else return 1 ;     /* invalid id */
      }
    else return 2 ;    /* out of range id */
    return 3 ;     /* idtab list mismatch */
}

/*-------------------------------------------------------------------*/
/* Erase the contents of a field in the 3270 field list.             */
/*-------------------------------------------------------------------*/
int erasefld(int id)
{
  TSFLD *curr ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = sfidtabÝid¨ ;
      if (curr)
        lstrfill(&curr->fdata,"\0") ; /* fill with zeros */
      else
        return 1 ;     /* invalid id */
    }
  else
    return 2 ;    /* out of range id */

  return 0 ;    /* id erased OK */
}

/*-------------------------------------------------------------------*/
/* Get the current contents of a field in the 3270 field list.       */
/*-------------------------------------------------------------------*/
int getfld(int id,
           TLSTR *retdata)
{
  TSFLD *curr ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = sfidtabÝid¨ ;
      if (curr)
        lstrcopy(retdata,&curr->fdata) ; /* copy data */
      else
        return 1 ;     /* invalid id */
    }
  else
    return 2 ;    /* out of range id */

  return 0 ;    /* data returned OK */
}

/*-------------------------------------------------------------------*/
/* Modify the contents of a field in the 3270 field list.            */
/*-------------------------------------------------------------------*/
int modfld(int id,
           TLSTR *newdata)
{
  TSFLD *curr ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = sfidtabÝid¨ ;
      if (curr)
        {
          if ((newdata->len > 0) &&
            (newdata->len <= (sdcb.rows * sdcb.cols)))
            lstrcopy(&curr->fdata,newdata) ; /* alter field data*/
          else
            return 1 ;  /* data too large or 0 */
        }
      else
        return 2 ;     /* invalid id */
    }
  else
    return 3 ;    /* out of range id */

  return 0 ;    /* data returned OK */
}

/*-------------------------------------------------------------------*/
/* Change the attributes of a field in the 3270 field list.          */
/*-------------------------------------------------------------------*/
int setfld(int id,
           int type,
           char value)
{
  TSFLD *curr ;
  int rc = 0 ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = sfidtabÝid¨ ;
      if (curr)
        {
          switch (type)
            {
            case ALL:
              rc = modcolor(&curr->fcolor,DFLT) ;
              rc = modhilite(&curr->fhilite,DFLT) ;
              rc = modattr(&curr->fattr,DFLT) ;
              break ;
            case HILITE:
              rc = modhilite(&curr->fhilite,value) ;
              break ;
            case COLOR:
              rc = modcolor(&curr->fcolor,value) ;
              break ;
            case ATTR:
              rc = modattr(&curr->fattr,value) ;
              break ;
            case SYMSET:
              rc = modsym(&curr->symbol,value) ;
              break ;
            default:
              return 1 ;    /* invalid type */
            }
        }
      else
        return 1 ;     /* invalid id */
    }
  else
    return 2 ;    /* out of range id */

  return rc ;   /* return */
}



/*********************************************************************/
/* 3270 support routines                                             */
/*   rc2sba(row,col,sba)                                             */
/*   sba2rc(sba,row,col,adjust)                                      */
/*   rc = modcolor(out,in)                                           */
/*   rc = modhilit(out,in)                                           */
/*   rc = modattr(out,in)                                            */
/*   rc = tputn(buf,buflen)                                          */
/*   rc = tgetn(buf,buflen)                                          */
/*   rc = tpgn(buf,buflen)                                           */
/*   rc = getdev()                                                   */
/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */
/*   rc = querydev()                                                 */
/*   rc = dsummary(buf,buflen)                                       */
/*   rc = darea(buf,buflen)                                          */
/*   rc = dcharset(buf,buflen)                                       */
/*   rc = dcolor(buf,buflen)                                         */
/*   rc = dhilite(buf,buflen)                                        */
/*   rc = dmodes(buf,buflen)                                         */
/*   rc = dimpart(buf,buflen)                                        */
/*                                                                   */
/*********************************************************************/

/*-------------------------------------------------------------------*/
/* The TPUTN routine is loaded below the 16M line                    */
/* It issues the TPUT macro with the NOEDIT option                   */
/*-------------------------------------------------------------------*/
int tputn(char *buf, int buflen)
  {
    int rc = 0 ;
    int (*tputn)(char *,int) ;

    loadm("TPUTN",&tputn) ;
    if (iotrace)      /* trace terminal I/O ? */
      {
        printf("Outbound data stream:\n") ;
        dumpchar(buf,buflen) ;
      }
    rc = (*tputn)(buf,buflen) ;
    unloadm(tputn) ;
    return rc ;
  }

/*-------------------------------------------------------------------*/
/* The TGETN routine is loaded below the 16M line                    */
/* It issues the TGET macro with the FULLSCR option.                 */
/*-------------------------------------------------------------------*/
int tgetn(char *buf, int buflen)
  {
    int rc = 0 ;
    int (*tgetn)(char *,int) ;

    loadm("TGETN",&tgetn) ;
    rc = (*tgetn)(buf,buflen) ;
    if (iotrace)      /* trace terminal I/O ? */
      {
        printf("Inbound data stream:\n") ;
        dumpchar(buf,buflen) ;
      }
    unloadm(tgetn) ;
    return rc ;
  }

/*-------------------------------------------------------------------*/
/* The TPGN routine is loaded below the 16M line                     */
/* It issues the TPG macro with the NOEDIT option.                   */
/*-------------------------------------------------------------------*/
int tpgn(char *buf, int buflen)
  {
    int rc = 0 ;
    int (*tpgn)(char *,int) ;

    loadm("TPGN",&tpgn) ;
    if (iotrace)      /* trace terminal I/O ? */
      {
        printf("Outbound data stream:\n") ;
        dumpchar(buf,buflen) ;
      }
    rc = (*tpgn)(buf,buflen) ;
    unloadm(tpgn) ;
    return rc ;
  }

/*-------------------------------------------------------------------*/
/* Convert row/column to 3270 12/16 bit buffer address.              */
/*-------------------------------------------------------------------*/
void rc2sba(int row,
            int col,
            char *sba)
{
  int offset, byte1, byte2 ;

  offset = ((row-1)*sdcb.cols)+(col-1) ;
  if (sdcb.adrmode == 12)  /* addressing mode = 12 */
    {
      byte1 = offset >> 6 ;           /* extract high order bits */
      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */

      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */
      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */

      sbaÝ0¨ = *((char *)&byte1+3) ;  /* assemble 2 byte sba */
      sbaÝ1¨ = *((char *)&byte2+3) ;
    }
  else /* adrmode = 16 or 14 */
    {
      byte1 = offset >> 8 ;           /* extract high order byte */
      byte2 = offset & 0x00ff ;       /* extract low order byte */
      sbaÝ0¨ = *((char *)&byte1+3) ;  /* assemble 2 byte sba */
      sbaÝ1¨ = *((char *)&byte2+3) ;
    }
}

/*-------------------------------------------------------------------*/
/* Convert 12/14/16-bit address to an offset and row/column.         */
/*-------------------------------------------------------------------*/
void sba2rc(char *inaddr,  /* input buffer addr */
            int *row,      /* returned row */
            int *col,      /* returned column */
            int adjust)    /* amount to subtract - usuallu 0 for the */
                           /*   returned cursor position, but is set */
                           /*   to one to get correct returned buffer*/
                           /*   addresses.                           */
{
  int taddr,     /* Temporary address holder */
      offset ;
  short addr ;
  memcpy((char *)&addr,inaddr,sizeof(short)) ;

  /* If 12-bit address, then we need to massage it a little */
  if (addr & 0xc000)    /* 12-bit address ? */
    {
       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */
       taddr = addr >> 8 ;   /* taddr is first 6 bits */
       addr &= 0x00ff ;      /* addr is second 6 bits */
       taddr = taddr << 6 ;  /* shift taddr left and .. */
       taddr |= addr ;       /*   merge taddr with addr into taddr */
       offset = taddr ;      /* taddr is the offset into the buffer */
    }
  else
    offset = addr ;          /* addr is the offset into the buffer */

  offset = offset - adjust ; /* adjust is either 0 or 1 */

  /* turn offset into row and column based on device num of columns */
  *col = (offset % sdcb.cols) + 1 ;
  *row = (offset / sdcb.cols) + 1 ;
}

/*-------------------------------------------------------------------*/
/* Check color attribute and copy if valid.                          */
/*-------------------------------------------------------------------*/
int modsym(char *out,
           char in )
{
  switch (in)
    {
    case DFLT:
      *out = in ;
      return 0 ;
    case APL:
      if (sdcb.aplflg)
        {
          *out = in ;
          return 0 ;
        }
      else
        return 1 ;
    default:
      if (sdcb.loadflg)
        {
          if ((in>=0x40) && (in<=0xef))
            {
              *out = in ;
              return 0 ;
            }
          else
            return 1 ;
        }
      else
        return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Check color attribute and copy if valid.                          */
/*-------------------------------------------------------------------*/
int modcolor(char *out,
             char in )
{
  switch (in)
    {
    case DFLT:
    case BLUE:
    case RED:
    case PINK:
    case GREEN:
    case TURQ:
    case YELLOW:
    case WHITE:
      *out = in ;
      return 0 ;
    default:
      return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Check hilite attribute and copy if valid.                         */
/*-------------------------------------------------------------------*/
int modhilit(char *out,
             char in )
{
  switch (in)
    {
    case NONE:
    case BLINK:
    case RVIDEO:
    case USCORE:
      *out = in ;
      return 0 ;
    default:
      return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Check field attribute and copy if valid.                          */
/*-------------------------------------------------------------------*/
int modattr(char *out,
            char in )
{
  switch (in)
    {
    case PRT:       /* protected normal intensity */
    case PRTHI:     /* protected high intensity */
    case PRTAS:     /* protected normal intensity auto skip */
    case PRTHIAS:   /* protected high intensity auto skip */
    case UNPRT:     /* unprotected normal intensity */
    case UNNUM:     /* unprotected numeric normal intensity */
    case UNNUMHI:   /* unprotected numeric high intensity */
    case UNNON:     /* unprotected non display */
    case UNHI:      /* unprotected high intensity */
      *out = in ;
      return 0 ;
    default:
      return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Load programmed symbols - type 1 load                             */
/*   loads programmed symbols without compression                    */
/*-------------------------------------------------------------------*/
int loadps1()
  {
    int rc ;         /* return code */
    int bufpos ;     /* next buffer position */
    int i, j ;       /* counters */
    short s ;        /* temp */

    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */

    bufpos = 0 ;
    bufferÝbufpos++¨ = WSF ;   /* write structured field */
    bufferÝbufpos++¨ = 0x00 ;  /* structured field length */
    bufferÝbufpos++¨ = 0x07 ;  /* structured field length contd. */
    bufferÝbufpos++¨ = 0x06 ;  /* load PS structured field */
    bufferÝbufpos++¨ = 0x41 ;  /* flags: clear sym.set and use type 1 */
    bufferÝbufpos++¨ = 0xff ;  /* make associated RWS = not assigned */
    bufferÝbufpos++¨ = 0x41 ;  /* starting code point */
    bufferÝbufpos++¨ = 0x02 ;  /* RWS of PSA symbol set */

    /* write buffer to the 3270 */
    rc = tputn(buffer, bufpos) ;

    memset(buffer,0x00, bufpos) ;  /* clear buffer */

    bufpos = 0 ;
    bufferÝbufpos++¨ = WSF ;   /* write structured field */
    bufferÝbufpos++¨ = 0x00 ;  /* structured field length */
    bufferÝbufpos++¨ = 0x00 ;  /* structured field length contd. */
    bufferÝbufpos++¨ = 0x06 ;  /* load PS structured field */
    bufferÝbufpos++¨ = 0x01 ;  /* flags: use type 1 */
    bufferÝbufpos++¨ = 0x40 ;  /* make associated RWS = 0x40 */
    bufferÝbufpos++¨ = 0x41 ;  /* starting code point (symbol=65) */
    bufferÝbufpos++¨ = 0x02 ;  /* RWS of PSA symbol set */

 /* This extra stuff needs the flags bit 1 on to indicate extended
    I dont think I need to use it yet.

    bufferÝbufpos++¨ = 0x08 ;     P length - length of extra parms
    bufferÝbufpos++¨ = 0x00 ;     flags: operator selectable ...
    bufferÝbufpos++¨ = 0x09 ;     LW - width of character
    bufferÝbufpos++¨ = 0x10 ;     LH - width of character
    bufferÝbufpos++¨ = 0x00 ;     SUBSN - only one byte codes
    bufferÝbufpos++¨ = 0xf1 ;     COLOR - F1 - first attr ???
    bufferÝbufpos++¨ = 0x00 ;     ST.SUBSN - default
    bufferÝbufpos++¨ = 0xf9 ;     ECHAR - last symbol=249

    bufferÝbufpos++¨ = 0x00 ;     NW - number width pairs
    bufferÝbufpos++¨ = 0x00 ;     NH - number height pairs
    bufferÝbufpos++¨ = 0x00 ;     RES - reserved
 */

    /* load specific font based on the cell height */
    if (sdcb.celheigh >= 16)
      {
        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */
          {
            for (j=0;j<=17;j++)      /* for each slice  */
              {
                bufferÝbufpos++¨ = ps9x16uÝi¨Ýj¨ ;
              }
          }
      }
    else if (sdcb.celheigh == 15)
      {
        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */
          {
            for (j=0;j<=17;j++)      /* for each slice  */
              {
                bufferÝbufpos++¨ = ps9x15uÝi¨Ýj¨ ;
              }
          }
      }
    else
      {
        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */
          {
            for (j=0;j<=17;j++)      /* for each slice  */
              {
                bufferÝbufpos++¨ = ps9x12uÝi¨Ýj¨ ;
              }
          }
      }

    s = bufpos - 1 ;
    memcpy(buffer+1,&s,sizeof(short)) ;

    /* write buffer to the 3270 to load the programmed symbols */
    rc = tputn(buffer, bufpos) ;

    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* Get the display device attributes.                                */
/*-------------------------------------------------------------------*/
int getdev()
  {
    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;
    int i ;

    /* set the default values, may get over ridden later */
    sdcb.adrmode = 12 ;  /* addressing mode */
    sdcb.altflg = 0 ;    /* use primary device */
    sdcb.edsflg = 0 ;    /* no extended data stream */
    sdcb.graflg = 0 ;    /* not a graphics device */
    sdcb.aplflg = 0 ;    /* no apl symbols on device */
    sdcb.psflg = 0 ;     /* no program symbols on device */
    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */
    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */
    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */
    sdcb.celheigh = 0 ;  /* zero cell height on device */
    sdcb.celwidth = 0 ;  /* zero cell width on device */
    sdcb.unit = 0 ;      /* units are inches */
    sdcb.colora = 1 ;    /* actual colors default to monochrome */
    sdcb.colors = 1 ;    /* supported colors default to monochrome */
    sdcb.hilites = 0 ;   /* supported hilites default to none */
    for (i=0;i<17;i++)
      sdcb.colorlstÝi¨ = 0x00 ; /* list of color attributes on device*/
    for (i=0;i<5;i++)
      sdcb.hilitlstÝi¨ = 0x00 ; /* list of hilite attributes on device*/


    /* get info from TSO about this device */
    rc = getterm(&pr,&pc,&ar,&ac,&att) ;
    if (rc==0)                 /* get terminal info worked ? */
      {
        if (att==0x00000001)   /* device has query structured fields */
          {
            /* set row and col may be later reset by query dev */
            if ((ar>0) && (ar!=pr) &&
                (ac>0) && (ac!=pc))
              {
                sdcb.altflg = 1 ;    /* use alternate device */
                sdcb.rows = ar ;     /* use alternate rows */
                sdcb.cols = ac ;     /* use alternate cols */
              }
            else
              {
                sdcb.rows = pr ;     /* use primary rows */
                sdcb.cols = pc ;     /* use primary cols */
              }

            rc = querydev() ;
            /* try to determine actual device */
            if (sdcb.rows == 32)
              {
                strcpy(sdcb.modname,"IBM3279-3") ;
                sdcb.model = 3279 ;
                sdcb.type = 3 ;
              }
            else if (sdcb.rows == 43)
              {
                strcpy(sdcb.modname,"IBM3278-4") ;
                sdcb.model = 3278 ;
                sdcb.type = 4 ;
              }
            else if (sdcb.rows == 27)
              {
                strcpy(sdcb.modname,"IBM3290") ;
                sdcb.model = 3290 ;
                sdcb.type = 5 ;
              }
            else  /* cant tell - use most primitive */
              {
                strcpy(sdcb.modname,"IBM3278-2") ;
                sdcb.model = 3278 ;
                sdcb.type = 2 ;
              }
          }
        else  /* dont know a lot about the device - make some guesses */
          {
            if ((ar>0) && (ar!=pr) &&
                (ac>0) && (ac!=pc))
              {
                sdcb.altflg = 1 ;    /* use alternate device */
                sdcb.rows = ar ;     /* use alternate rows */
                sdcb.cols = ac ;     /* use alternate cols */
              }
            else
              {
                sdcb.rows = pr ;     /* use primary rows */
                sdcb.cols = pc ;     /* use primary cols */
              }

            /* try to determine actual device */
            if (sdcb.rows == 32)
              {
                strcpy(sdcb.modname,"IBM3279-3") ;
                sdcb.model = 3279 ;
                sdcb.type = 3 ;
              }
            else if (sdcb.rows == 43)
              {
                strcpy(sdcb.modname,"IBM3278-4") ;
                sdcb.model = 3278 ;
                sdcb.type = 4 ;
              }
            else if (sdcb.rows == 27)
              {
                strcpy(sdcb.modname,"IBM3290") ;
                sdcb.model = 3290 ;
                sdcb.type = 5 ;
              }
            else  /* cant tell - use most primitive */
              {
                strcpy(sdcb.modname,"IBM3278-2") ;
                sdcb.model = 3278 ;
                sdcb.type = 2 ;
              }
          }
        return 0 ;
      }
    else  /* get term failed - return its code */
      return rc ;
  }

/*-------------------------------------------------------------------*/
/* This routine loads an assebbler module below the 16 MB line       */
/* that issues the GTTERM macro instruction to obtain the            */
/* dimensions of the screen and also some bit fields that            */
/* tell if the device can be queried. The module copies the          */
/* results from storage below the line to this routines              */
/* automatic storage.                                                */
/* Upon completion the module is unloaded.                           */
/*-------------------------------------------------------------------*/
int getterm(int *primrow, int *primcol,
             int *altrow, int *altcol,
             int *attrs)
  {
    struct {
      union {
        short sh ;
        char cÝ2¨ ;
      } prim ;
      union {
        short sh ;
        char cÝ2¨ ;
      } alt ;
      int attr ;
    } pm ;
    int rc = 0 ;
    int (*tgt327d)(void *) ;

    loadm("TGT327D",&tgt327d) ;   /* load ASM routine below 16M */
    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */
    if (rc==0)      /* data returned OK ? */
      {             /* yes - convert single byte numbers to int */
        *primrow = pm.prim.cÝ0¨ ;
        *primcol = pm.prim.cÝ1¨ ;
        *altrow = pm.alt.cÝ0¨ ;
        *altcol = pm.alt.cÝ1¨ ;
        *attrs = pm.attr ;
      }
    unloadm(tgt327d) ;            /* unload ASM routine */
    return rc ;                   /* return code from GTTERM */
  }

/*-------------------------------------------------------------------*/
/* Clear 3270 screen.                                                */
/*-------------------------------------------------------------------*/
void clear()
  {
    int rc ;
    char sbaÝ2¨ ;
    char out1Ý¨ = {      /* set up for erase */
      WRT, 0x40,
      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */
      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */
      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */
      ICUR               /* insert cursor */
      } ;
    char out2Ý¨ = {      /* erase write alternate */
      EWA, 0xc2
      } ;
    char out3Ý¨ = {      /* erase primary */
      WRT, 0xc2
      } ;

    /* set max screen size known so far sba */
    rc2sba(sdcb.rows,sdcb.cols,sba) ;
    out1Ý9¨ = sbaÝ0¨ ;
    out1Ý10¨ = sbaÝ1¨ ;

    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */
    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */
    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */
  }

/*-------------------------------------------------------------------*/
/* Select the entire screen buffer using SBA based on the            */
/* scrsize returned from GTTERM and EW/EWA to select the             */
/* primary or alternate buffer.                                      */
/* Then assemble a structured field query, and send it to the        */
/* device using TPG which will cause the device to imediately        */
/* send back the response without any user intervention.             */
/* Then decode the read partition, query operations, query and       */
/* put the interesting data in the sdcb structure.                   */
/*-------------------------------------------------------------------*/
int querydev()
  {
    short sflen ;      /* structured field length */
    char  sfid ;       /* structured field ID */
    char  qcode ;      /* query reply - query code */
    char inputÝ256¨ ;  /* query buffer */
    char *ibuf ;       /* current query buffer pointer */
    int rc ;
    char sbaÝ2¨ ;

    char out1Ý¨ = {      /* set up for erase */
      WRT, 0x40,
      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */
      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */
      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/
      ICUR               /* insert cursor */
      } ;

    char out2Ý¨ = {      /* erase write alternate */
      EWA, 0xc2
      } ;

    char out3Ý¨ = {      /* erase primary */
      WRT, 0xc2
      } ;

    char out4Ý¨ = {
      WSF,               /* write structured field */
      0x00, 0x05,        /* structured field length */
      0x01,              /* read partition */
      0xFF,              /* query operations */
      0x02               /* query */
      } ;

    /* set max screen size known so far sba */
    rc2sba(sdcb.rows,sdcb.cols,sba) ;
    out1Ý9¨ = sbaÝ0¨ ;
    out1Ý10¨ = sbaÝ1¨ ;

    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */

    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */
    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */
    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */
    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */
    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/

    ibuf = input ;       /* point at input */

    if (*input==0x88)    /* check for 88 AID byte */
      {
        ibuf = ibuf+1 ;         /* advance to 1st structured field */
        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */

        while (sfid==0x81)  /* while structured fields remain */
          {
            sflen = *((short *)ibuf) ;  /* get structured field len */
            if (sflen==0)           /* bad error - should not happen */
              {
                printf("Error: Structured field length zero at %p\n",
                  ibuf) ;
                dumpchar(input,sizeof(input)) ;
                return 1 ;
              }
            qcode = *(ibuf+3) ;     /* get query code */
            switch (qcode)
              {
                case 0x80:           /* Q-code summary */
                  rc = dsummary(ibuf,sflen) ;
                  break ;
                case 0x81:           /* Usable area */
                  rc = darea(ibuf,sflen) ;
                  break ;
                case 0x85:           /* Character sets */
                  rc = dcharset(ibuf,sflen) ;
                  break ;
                case 0x86:           /* Color */
                  rc = dcolor(ibuf,sflen) ;
                  break ;
                case 0x87:           /* Highlighting */
                  rc = dhilite(ibuf,sflen) ;
                  break ;
                case 0x88:           /* Modes */
                  rc = dmodes(ibuf,sflen) ;
                  break ;
                case 0xa6:           /* Implicit partition */
                  rc = dimpart(ibuf,sflen) ;
                  break ;
                default:
                  break ;
              }  /* of switch */
            ibuf = ibuf+sflen ; /* advance to next structured field */
            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */

          } /* of while sfid=81 */

      } /* of AID=88 */
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x80: Qcode summary                                               */
/*-------------------------------------------------------------------*/
int dsummary(char *buf, short buflen)
  {
     int i ;
     char qcode ;

     for (i=4;i<buflen;i++)
       {
          qcode = *(buf+i) ;     /* get query code */
          if (qcode == 0xb4)
            sdcb.graflg = 1 ;    /* indicate graphic support */
       }  /* of for i=4 */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x81: Usable area                                                 */
/*-------------------------------------------------------------------*/
int darea(char *buf, short buflen)
  {
     char celunitsÝ6¨ ;   /* screen size unit PEL or CELL */
     short w, h ;         /* screen size w=width h=height */
     char aw, ah ;        /* units per cell aw=width ah=height */
     float xr, xrd, yr, yrd ;  /* pel spacing ratio */
     float fw, fh ;       /* ratio - pels per unit */

     if ((*(buf+4) & 0x03)==0x03)
       sdcb.adrmode = 16 ;
     else if ((*(buf+4) & 0x01)==0x01)
       sdcb.adrmode = 12 ;

     w = *((short *)(buf+6)) ;   /* width of usable area */
     h = *((short *)(buf+8)) ;   /* height of usable area */

     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */
       sdcb.unit = 1 ;  /* units are mm */
     else
       sdcb.unit = 0 ;  /* units are inch */

     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */
     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */
     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */
     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */

     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */
     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */

     aw = *(buf+19) ;    /* number of X units in default cell */
     ah = *(buf+20) ;    /* number of Y units in default cell */

     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */
       strcpy(celunits,"pels") ;
     else                       /* other wise unit=cells */
       strcpy(celunits,"cells") ;

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x85: Character sets                                              */
/*-------------------------------------------------------------------*/
int dcharset(char *buf, short buflen)
  {
     int i, j ;         /* counters */
     int cgcsgid ;      /* Coded graphic character set identifier */
     short ccsid ;      /* Coded character set identifier */
     char gf = 0 ;      /* CGCSGID not present flag */
     char ch2 = 0 ;     /* Two byte char. set flag */
     char ms = 0 ;      /* Multiple slot sizes flag */
     char cf = 0 ;      /* CCSID not present flag */
     char sdw ;         /* Default character slot width */
     char sdh ;         /* Default character slot height */
     char dl ;          /* character set descriptor (CSD) length */
     char *csd ;        /* character set descriptor (CSD) ptr */
     char set ;         /* character set ID (PS store no.) */
     char lcid ;        /* character set Local ID (alias) */
     char sw ;          /* character set slot width */
     char sh ;          /* character set slot height */
     char ssubsn ;      /* character set starting subsection */
     char esubsn ;      /* character set ending subsection */

     if (*(buf+4) & 0x10)
       sdcb.psflg = 1 ;   /* load PS Extended supported */
     else
       sdcb.psflg = 0 ;   /* load PS Extended not supported */

     if (*(buf+4) & 0x08)
       ms = 1 ;   /* More than one size character slot supported */

     if (*(buf+4) & 0x04)
       ch2 = 1 ;  /* Two byte code character sets are supported */

     if (*(buf+4) & 0x02)
       gf = 1 ;   /* CGCSGID present */

     if (*(buf+5) & 0x20)
       cf = 1 ;   /* CCSID present */

     sdw = *(buf+6) ;
     sdh = *(buf+7) ;

     dl = *(buf+12) ;   /* get CSD length */
     i = 13 ;
     while (i<buflen)
       {
         csd = buf + i ;  /* point at CSD to process */
         set = *csd ;     /* get character set ID (PS store no.) */
         if (*(csd+1) & 0x80)
           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */

         if (*(csd+1) & 0x40)
           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */

         if (*(csd+1) & 0x20)
           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */

         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */

         j = 0 ;
         if (ms)
           {
             sw = *(csd+3) ;  /* slot width */
             sh = *(csd+4) ;  /* slot height */
             j = j + 2 ;
           }

         if (ch2)
           {
             ssubsn = *(csd+j+3) ;  /* starting sub-section */
             esubsn = *(csd+j+4) ; /* ending sub-section */
             j = j + 2 ;
           }

         if (gf)
           {
             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */
             if (cgcsgid==0x03c30136)
               sdcb.aplflg = lcid ;   /* APL supported store lcid */
             j = j + 4 ;
           }

         if (cf)
           {
             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */
           }

         i = i + dl ;  /* get pos of next CSD */
       }  /* of while i<buflen */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x86: Colors                                                      */
/*-------------------------------------------------------------------*/
int dcolor(char *buf, short buflen)
  {
     int colora = 0 ; /* number of actual colors on device */
     int icolor ;     /* color index */
     int i, j = 0 ;   /* counter */
     char attr ;      /* color attribute accepted by device */
     char dcolor ;    /* color displayed for this attribute */

     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */
     for (i=6;i<buflen;i=i+2)
       {
         attr = *(buf+i) ;        /* attribute used by appl. */
         sdcb.colorlstÝj++¨ = attr ;
         dcolor = *(buf+i+1) ;    /* attr/color used by device */
         icolor = (int)(dcolor - 0xf0) ;
         if ((icolor >= 0) && (icolor <= 15))
           colora++ ;
       }
     sdcb.colora = colora ;  /* number of actual colors on device */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x87: Highlighting                                                */
/*-------------------------------------------------------------------*/
int dhilite(char *buf, short buflen)
  {
     int i, j = 0 ;    /* counter */
     char attr ;       /* color attribute accepted by device */
     char dhilite ;    /* color displayed for this attribute */

     sdcb.hilites = (int)*(buf+4) ;
     for (i=5;i<buflen;i=i+2)
       {
         attr = *(buf+i) ;        /* attribute used by appl. */
         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */
         sdcb.hilitlstÝj++¨ = attr ;
       }

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x88: Modes                                                       */
/*-------------------------------------------------------------------*/
int dmodes(char *buf, short buflen)
  {
     int i ;           /* counter */
     char mode ;       /* device opperation mode */

     for (i=4;i<buflen;i++)
       {
         mode = *(buf+i) ;        /* attribute used by appl. */
         if ((mode==0x01) ||
             (mode==0x02))
           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/
       }   /* of for i */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0xa6: Implicit partition                                          */
/*-------------------------------------------------------------------*/
int dimpart(char *buf, short buflen)
  {
     char *sdp ;                /* self defining parameter (SDP) ptr */
     short wd, wa, hd, ha ;     /* screen dimensions */
     short wcd, wca, hcd, hca ; /* cell sizes */
     int i ;                    /* counter */

     i = 6 ;        /* length of header */
     while(i < buflen)   /* loop over all SDPs */
       {
         sdp = buf + i ;
         if (*sdp==0x0b)    /* is it a SDP ? */
           {
             if (*(sdp+1)==0x01)
               {
                 wd = *((short *)(sdp+3)) ;  /* default width */
                 hd = *((short *)(sdp+5)) ;  /* default height */
                 wa = *((short *)(sdp+7)) ;  /* alternate width */
                 ha = *((short *)(sdp+9)) ;  /* alternate height */
                 if ((ha>hd) || (wa>wd))
                   {
                     sdcb.altflg = 1 ;    /* use alternate device */
                     sdcb.rows = ha ;     /* use alternate rows */
                     sdcb.cols = wa ;     /* use alternate cols */
                   }
                 else
                   {
                     sdcb.rows = hd ;     /* use primary rows */
                     sdcb.cols = wd ;     /* use primary cols */
                   }
                 i = i + 11 ;     /* add length of this SDP */
               }
             else if (*(sdp+1)==0x03)
               {
                 i = i + 11 ;     /* add length of this SDP */
               }
             else if (*(sdp+1)==0x02)
               {
                 wcd = *((short *)(sdp+3)) ;  /* default cell width */
                 hcd = *((short *)(sdp+5)) ;  /* default cell height */
                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */
                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/
                 if (sdcb.altflg)         /* using alternate device */
                   {
                     sdcb.celheigh = hca ; /* use alt. cell height */
                     sdcb.celwidth = wca ; /* use alt. cell width */
                   }
                 else
                   {
                     sdcb.celheigh = hcd ; /* use primary cell height */
                     sdcb.celwidth = wcd ; /* use primary cols width */
                   }
                 i = i + 11 ;     /* add length of this SDP */
               }
           }
       }  /* of while */

     return 0 ;
  }




/*********************************************************************/
/* General string handling routines for varying length strings.      */
/*   lstran(mod_lstr,fromchar,tochar)                                */
/*   lstrload(to_lstr,fromchar,len)                                  */
/*   lstrunld(tochar,from_lstr)                                      */
/*   lstrcopy(to_lstr,from_lstr)                                     */
/*   lstrnew(to,fromchars)                                           */
/*   lstrsub(to_lstr,from_lstr,start,length)                         */
/*   len = lstrlen(haystack_lstr)                                    */
/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */
/*   lstrfill(to_lstr,fillchars)                                     */
/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */
/*   lstrdel(del-lstr)                                               */
/*   lstrrep(to_lstr,repchars,copies)                                */
/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */
/*********************************************************************/

/*-------------------------------------------------------------------*/
/* Translate a character in an lstr to another character.            */
/*-------------------------------------------------------------------*/
void lstran(TLSTR *in, char from, char to)
{
  int i ;      /* temp counter */

  if (in)      /* from string exists ? */
    {
      for (i=0;i<=in->len;i++)
        {
          if (*(in->data+i) == from)
            *(in->data+i) = to ;
        }
    }
}

/*-------------------------------------------------------------------*/
/* Get the length of an lstr.                                        */
/*-------------------------------------------------------------------*/
int lstrlen(TLSTR *in)
{
  if (in)      /* from string exists ? */
    {
      return in->len ;
    }
  else
    return 0 ;
}

/*-------------------------------------------------------------------*/
/* Unload varying length string contents into character buffer.      */
/*-------------------------------------------------------------------*/
int lstrunld(char *to,
             TLSTR *from)
{
  if (from)      /* from string exists ? */
    {
      memcpy(to,from->data,from->len) ;
      return from->len ;
    }
  else
    return 0 ;
}

/*-------------------------------------------------------------------*/
/* Load varying length string with contents of character buffer.     */
/*-------------------------------------------------------------------*/
void lstrload(TLSTR *to,
              char *from,
              int len)
{
  if (to)      /* to string exists ? */
    {
      if (len!=to->len)
        {
          free((char *)to->data) ;
          to->data = (char *)malloc(len) ;
          if (!to->data) serror(4,"Not enough memory") ;
          to->len = len ;
        }
      memcpy(to->data,from,len) ;
    }
}

/*-------------------------------------------------------------------*/
/* Copy varying length string.                                       */
/*-------------------------------------------------------------------*/
void lstrcopy(TLSTR *to,
              TLSTR *from)
{
  if (from)      /* from string exists ? */
    {
      if (!to)    /* to string does not exist */
        serror(2,"String does not exist") ;
      else     /* to string exists */
        {
          if (from->len > 0)
            {
              if (to->data == NULL)     /* does not exist yet ? */
                {
                  to->data = (char *)malloc(from->len) ;
                  if (!to->data) serror(14,"Not enough memory") ;
                }
              else if (from->len != to->len)   /* increase length ? */
                {
                  free((char *)to->data) ;
                  to->data = (char *)malloc(from->len) ;
                  if (!to->data) serror(4,"Not enough memory") ;
                }
              to->len = from->len ;
              memcpy(to->data,from->data,from->len) ;
            }
          else
            {
              if (to->len > 0)   /* empty data */
                free((char *)to->data) ;
              to->len = 0 ;
              to->data = NULL ;
            }
        }
    }
}

/*-------------------------------------------------------------------*/
/* Initialize a varying length string with a string.                 */
/*-------------------------------------------------------------------*/
void lstrnew(TLSTR *newstr,
             char *from)
{
  int i ;

  if (!newstr)
    serror(5,"String does not exist") ;
  else
    {
      i = strlen(from) ;
      if (i > 0)
        {
          newstr->data = (char *)malloc(i) ;
          if (!newstr->data) serror(17,"Not enough memory") ;
          newstr->len = i ;
          memcpy(newstr->data,from,i) ;
        }
      else
        {
          newstr->len = 0 ;
          newstr->data = NULL ;
        }
    }
}

/*-------------------------------------------------------------------*/
/* Create substring of a varying length string to a varying length   */
/* string.                                                           */
/*-------------------------------------------------------------------*/
void lstrsub(TLSTR *to,
             TLSTR *from,
             int start,
             int len)
{
  int i ;

  if (start <= from->len)
    {
      i = from->len - start ;
      if (len < i)
        i = len ;       /* i is the length of the sub string */

      if (!to)
        serror(8,"String does not exist") ;
      else
        {
          if (i > 0)
            {
              if (to->data == NULL)     /* does not exist yet ? */
                {
                  to->data = (char *)malloc(i) ;
                  if (!to->data) serror(20,
                    "Not enough memory") ;
                }
              else if (to->len != i)          /* wrong size ? */
                {
                  free((char *)to->data) ;
                  to->data = (char *)malloc(i) ;
                  if (!to->data) serror(10,
                    "Not enough memory") ;
                }
              to->len = i ;
              memcpy(to->data,from->data+start,i) ;
            }
          else
            {
              if (to->len > 0)   /* empty data */
                free((char *)to->data) ;
              to->len = 0 ;
              to->data = NULL ;
            }
        }
    }
}

/*-------------------------------------------------------------------*/
/* Find the position in a varying length string of a varying length  */
/* sub-string.                                                       */
/*-------------------------------------------------------------------*/
int lstrindx(TLSTR *haystack, /* string to search */
             TLSTR *needle)   /* sub-string to search for */
{
  int i, j, k, endpos ;

  endpos = haystack->len - needle->len ;
  for (i=0; i<endpos; i++)
    {
      k = 0 ;
      for (j=0; j<needle->len; j++)
        {
          if (haystack->dataÝi+j¨ == needle->dataÝj¨)
            k ++ ;
          else break ;
        }
      if (k==needle->len)
        return(i+1) ;
    }
  return 0 ;
}

/*-------------------------------------------------------------------*/
/* Compare a varying length string with a string.                    */
/*   rc = 0  == strings same                                         */
/*   rc = 1  == lstr has larger value than charstr                   */
/*   rc = -1 == lstr has smaller value than charstr                  */
/*-------------------------------------------------------------------*/
int lstrcmpc(TLSTR *lstr,   /* string to compare */
             char *cstr)    /* characters to compare with */
{
  int i ;               /* counter */
  int t=0 ;             /* compare flag */
  int l ;               /* compare length */
  int ld=0 ;            /* length differ flag */
  char *lstrptr ;
  char *cstrptr ;

  l = strlen(cstr) ;    /* determine shortest string */
  if (l != lstr->len)   /* same lengths ? */
    {                   /*   no .. */
      ld = 1 ;          /*   flag lengths differ */
      if (l > lstr->len)
        l = lstr->len ; /*   use shortest length */
    }

  /* compare to shortest length */
  lstrptr = lstr->data ;
  cstrptr = cstr ;
  for (i=0; i<l; i++)
    {
      if (*lstrptr > *cstrptr)
        {
          t = 1 ;    /* indicate left larger than right */
          break ;    /* end scan now  */
        }
      if (*lstrptr < *cstrptr)
        {
          t = -1 ;   /* indicate left smaller than right */
          break ;    /* end scan now  */
        }
      lstrptr++ ;
      cstrptr++ ;
    }

  if ((t==0) && (ld==1)) /* same after shortest length compared ? */
    {
      if (strlen(cstr) > lstr->len)
        t = -1 ;     /* lstr smaller */
      else
        t = 1 ;      /* lstr larger */
    }
  return t ;
}

/*-------------------------------------------------------------------*/
/* Fill a varying length string with a string.                       */
/*-------------------------------------------------------------------*/
void lstrfill(TLSTR *string,   /* string to fill */
              char *fillstr)  /* filler characters to use */
{
  int i ;
  char *strptr ;

  strptr = fillstr ;
  for (i=0; i<=string->len; i++)
    {
      string->dataÝi¨ = *(strptr++) ;
      if (*strptr=='\0')
        strptr = fillstr ;    /* start over on fill string */
    }
}

/*-------------------------------------------------------------------*/
/* Delete a varying length string (free associated memory).          */
/*-------------------------------------------------------------------*/
void lstrdel(TLSTR *string)   /* string to delete */
{
  free((char *)string->data) ;
  string->data = NULL ;
  string->len = 0 ;
}

/*-------------------------------------------------------------------*/
/* Create a varying length string with multiple copies of a string.  */
/*-------------------------------------------------------------------*/
void lstrrep(TLSTR *string,
             char *repstr,
             int copies)
{
  int repstrlen ;
  char *strptr ;
  int newlen ;
  int i ;

  /* The input string that replications are made from is assumed */
  /* to have a length of one or longer.                          */

  repstrlen = strlen(repstr) ;
  if (repstrlen==0)  /* assume repitition of 0x00 */
    repstrlen = 1 ;
  newlen = repstrlen * copies ;
  if (string->data==NULL)          /* alloc storage ? */
    {
      string->data = (char *)malloc(newlen) ;
      if (!string->data) serror(21,"Not enough memory") ;
    }
  else if (string->len!=newlen)    /* alloc more/less storage ? */
    {
      free((char *)string->data) ;
      string->data = (char *)malloc(newlen) ;
      if (!string->data) serror(11,"Not enough memory") ;
    }
  string->len = newlen ;     /* alter string length */
  strptr = repstr ;
  for (i=0; i<newlen; i++)        /* replicate the repstr data */
    {
      string->dataÝi¨ = *strptr++ ;
      if (*strptr == '\0')
        strptr = repstr ;
    }
}

/*-------------------------------------------------------------------*/
/* Concatenate two varying length strings together placing the       */
/* in a varying length string.                                       */
/*-------------------------------------------------------------------*/
void lstrcat(TLSTR *result,   /* result of concatenation */
             TLSTR *left,     /* left string to concatenate */
             TLSTR *right)    /* right string to concatenate */
{
  char *rstr ;
  int newlen ;

  newlen = left->len + right->len ;    /* extend LSTR */
  rstr = (char *)malloc(newlen) ;
  if (!rstr) serror(12,"Not enough memory") ;

  memcpy(rstr,left->data,left->len) ;   /* make new string */
  memcpy(rstr+left->len,right->data,right->len) ;

  free((char *)result->data) ;   /* assemble new LSTR */
  result->data = rstr ;
  result->len = newlen ;
}


/*********************************************************************/
/* General sub routines.                                             */
/*   fill(haystack,fillchar,number)                                  */
/*   dumpchar(buffer,length)                                         */
/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */
/*********************************************************************/

/*-------------------------------------------------------------------*/
/* Fill a character string with a number of filler characters.       */
/*-------------------------------------------------------------------*/
void fill(char *haystack,   /* area to fill */
          char filler,      /* fill characters */
          int num)          /* number of repetitions */
{
  int i = 0 ;
  for(i=0;i<=num;i++)
    *haystack++ = filler ;
  *haystack = '\0' ;
}

/*-------------------------------------------------------------------*/
/* Dump the contents of a buffer, formatted in a way that makes a    */
/* 3270 data stream easier to interpret.                             */
/*-------------------------------------------------------------------*/
void dumpchar(char *dat,    /* data to dump */
              int len)      /* length to dump */
{
  char *cptr ;
  char c ;
  char ccÝ3¨ ;
  int i ;
  int n, m ;

  n = 0 ;
  m = 0 ;
  cptr = dat ;
  do
    {
      printf("      %.8X ",dat) ;
      for(i=1;i<=16;i++)
        {                   /* 0 indicates all */
          if (*dat=='\0' && len==0)
            break ;
          if (n==len && len>0)
            break ;
          c = *dat++ ;
          n++ ;
          printf("%.2X",c) ;
          if ((i%4)==0)
            printf(" ") ;
        }
      printf("\n               ") ;

      for(i=1;i<=16;i++)
        {
          if (*cptr=='\0' && len==0)
            break ;
          if (m==len && len>0)
            break ;
          c = *cptr++ ;
          m++ ;
          if (c <= 0x3f || c==0xff)
            {
              switch (c)
                {
                  case GE:   strcpy(cc,"GE") ;
                    break ;
                  case FF:   strcpy(cc,"FF") ;
                    break ;
                  case CRR:  strcpy(cc,"CR") ;
                    break ;
                  case SBA:  strcpy(cc,"SB") ;
                    break ;
                  case EUA:  strcpy(cc,"EU") ;
                    break ;
                  case ICUR: strcpy(cc,"IC") ;
                    break ;
                  case NL:   strcpy(cc,"NL") ;
                    break ;
                  case EM:   strcpy(cc,"EM") ;
                    break ;
                  case DUP:  strcpy(cc,"DU") ;
                    break ;
                  case SF:   strcpy(cc,"SF") ;
                    break ;
                  case FM:   strcpy(cc,"FM") ;
                    break ;
                  case SA:   strcpy(cc,"SA") ;
                    break ;
                  case SFE:  strcpy(cc,"SX") ;
                    break ;
                  case MF:   strcpy(cc,"MF") ;
                    break ;
                  case RA:   strcpy(cc,"RA") ;
                    break ;
                  case SUB:  strcpy(cc,"SU") ;
                    break ;
                  default:   strcpy(cc,". ") ;
                    break ;
                }
              printf("%s",cc) ;
            }
          else
            printf("%c ",c) ;
          if ((i%4)==0)
            printf(" ") ;
        }
      printf("\n") ;
    }
  while( ((*dat!='\0') && (len==0)) ||
         ((m!=len) && (len>20))
       ) ;
  printf("\n") ;
}

/*-------------------------------------------------------------------*/
/* Overlay characterc in a buffer.                                   */
/*-------------------------------------------------------------------*/
void overlay(char *haystack,    /* area to overlay */
             int haylen,        /* length to overlay */
             char *needle,      /* overlay characters */
             int len,           /* length of overlay */
             int pos)           /* start postition of overlay */
{
  int hlen, nlen ;   /* length of haystack and needle */
  int i = 0 ;        /* itterator */

  if (haylen==0)
    hlen = strlen(haystack) ;
  else
    hlen = haylen ;

  if (len==0)
    nlen = strlen(needle) ;
  else
    nlen = len ;

  if (hlen>(nlen+pos))
    {
      haystack = haystack+pos ;    /* move to overlay pos */
      for(i=0;i<nlen;i++)          /* copy the data */
        *haystack++ = *needle++ ;
    }
}

/*-------------------------------------------------------------------*/
/* General error message routine.                                    */
/*-------------------------------------------------------------------*/
void serror(int errno,
            char *msg)
{
  printf("Error: %d - %s\n",errno,msg) ;
  abort() ;
}
