#pragma eject
#pragma title INFO3270.C - Program lists info. for this device

/*+-----------------------------------------------------------------+
  | Program:   info3270.c                                           |
  | Language:  c                                                    |
  | Support:   DAF                                                  |
  | Purpose:   This program queries the device that is being used   |
  |            for the active TSO session and displays as much      |
  |            information as it can about the device being used.   |
  | Method:    The GTTERM macro gets information from TSO/VTAM,     |
  |            and TPG is used to send a Read partition, Query      |
  |            operations, query, to get information from the       |
  |            3270 device.                                         |
  +-----------------------------------------------------------------+*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dynam.h>
#include <tput.h>

#define _AMODE31
/* --------------------- 3270 commands ----------------------------- */
#define ESC    0x27
#define EW     0xf5
#define EWA    0x7e
#define WRT    0xf1
#define WSF    0xf3
#define RB     0xf2

/* ------ write control characters, or'd together as required ------ */
#define WCCMDT 0x01
#define WCCKBD 0x02
#define WCCRES 0xc0

/* ------------- 3270 data stream orders --------------------------- */
#define GE     0x08
#define FF     0x0c
#define CRR    0x0d
#define SBA    0x11
#define EUA    0x12
#define ICUR   0x13
#define NL     0x15
#define EM     0x19
#define DUP    0x1c
#define SF     0x1d
#define FM     0x1e
#define SA     0x28
#define SFE    0x29
#define MF     0x2c
#define RA     0x3c
#define SUB    0x3f

#define PROT   0x20
#define NUM    0x10

/* ------ these are the sub commands of the set attribute SA ------- */
#define ALL    0x00
#define DFLT   0x00
#define OUTLIN 0xc2
#define HILITE 0x41
#define COLOR  0x42
#define SYMSET 0x43
#define BCOLOR 0x45
#define TRANSP 0x46

#define APL    0xf1

/* these are the hilites for the second byte of the set attribute SA */
#define NONE   0x00
#define BLINK  0xf1
#define RVIDEO 0xf2
#define USCORE 0xf4

/* these are the colors for the second byte of the set attribute SA  */
#define BLUE   0xf1
#define RED    0xf2
#define PINK   0xf3
#define GREEN  0xf4
#define TURQ   0xf5
#define YELLOW 0xf6
#define WHITE  0xf7

/* --------- the attribute byte for the SF command ----------------- */
#define UNPRT  0x40
#define UNPRTH 0xc8
#define PRT    0x60
#define PRTH   0xe8

#define ADDR1(row,col)  ((((row-1)*80)+(col-1) & 0xff00) >> 8)
#define ADDR2(row,col)  (((row-1)*80)+(col-1) & 0x00ff)


/* ------------------------- Prototypes ---------------------------- */
int getterm(int *, int *, int *, int *, int *) ;
int tputn(char *buf, int buflen) ;
int tpgn(char *buf, int buflen) ;
void rc2sba(int, int, char *) ;
void fill(char *, char, int) ;
void dumpchar(char *, int) ;
void querydev() ;
void help() ;

int dsummary(char *buf, short buflen) ;
int darea(char *buf, short buflen) ;
int dimage(char *buf, short buflen) ;
int dtextp(char *buf, short buflen) ;
int dalphap(char *buf, short buflen) ;
int dcharset(char *buf, short buflen) ;
int dcolor(char *buf, short buflen) ;
int dhilite(char *buf, short buflen) ;
int dmodes(char *buf, short buflen) ;
int dfieldv(char *buf, short buflen) ;
int dmsrcntl(char *buf, short buflen) ;
int dfieldol(char *buf, short buflen) ;
int dpartchr(char *buf, short buflen) ;
int doemaux(char *buf, short buflen) ;
int dformat(char *buf, short buflen) ;
int ddbcs(char *buf, short buflen) ;
int dsave(char *buf, short buflen) ;
int dfmtaux(char *buf, short buflen) ;
int ddist(char *buf, short buflen) ;
int dstrpool(char *buf, short buflen) ;
int ddocint(char *buf, short buflen) ;
int datchain(char *buf, short buflen) ;
int dauxdev(char *buf, short buflen) ;
int d3270ip(char *buf, short buflen) ;
int dpdds(char *buf, short buflen) ;
int danom(char *buf, short buflen) ;
int dibmaux(char *buf, short buflen) ;
int dbeof(char *buf, short buflen) ;
int ddevchar(char *buf, short buflen) ;
int drpqname(char *buf, short buflen) ;
int ddatastr(char *buf, short buflen) ;
int dimpart(char *buf, short buflen) ;
int dpaperf(char *buf, short buflen) ;
int dtrans(char *buf, short buflen) ;
int dsprnch(char *buf, short buflen) ;
int diocaaux(char *buf, short buflen) ;
int dcooproc(char *buf, short buflen) ;
int dsegment(char *buf, short buflen) ;
int dproc(char *buf, short buflen) ;
int dlinetyp(char *buf, short buflen) ;
int dport(char *buf, short buflen) ;
int dgrapcol(char *buf, short buflen) ;
int dextdraw(char *buf, short buflen) ;
int dgrapsym(char *buf, short buflen) ;

/* --------------------- Global Variables -------------------------- */
char force = 0 ;   /* -F Flag, if 1: force a query of the device */
char terse = 0 ;   /* -T Flag, if 1: do not do dump of buffers */
char dump  = 0 ;   /* -D Flag, if 1: only dump buffer contents */
int rows = 0 ;     /* Number of rows on the device */
int cols = 0 ;     /* Number of columns on the device */
int adrmode = 12 ; /* Device addressing mode 12 or 14 or 16 bit */

/* ------------------------- Main program -------------------------- */
void main(int argc, char **argv, char **envp)
  /*
     This program firstly extracts the screen size and some
     attributes from TSO/VTAM using the GTTERM macro, then
     uses the TPUT, TPG and TGET macro instructions to send
     a query operations to the device and read the response
     from the device. The response is decoded acording to the
     specifications in the IBM book 'Data Stream Programmers Ref'
     # GA23-0059. The decoded output is written to the STDOUT
     file.
  */
  {
    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;
    int i ;               /* counter */
    char nameÝ20¨ ;       /* documentory device name */

    printf("\nINFO3270  - 3270 Information Query Program.\n") ;

    /* extract program parameters */
    if (argc>0)
      {
        i = 1 ;           /* skip first arg(0)=(pgm name) */
        while(i<argc)
          {
            if (strcmp(argvÝi¨,"-F")==0)
              force = 1 ;     /* always query the device */
            else if (strcmp(argvÝi¨,"-T")==0)
              terse = 1 ;     /* dont print dump of buffer */
            else if (strcmp(argvÝi¨,"-D")==0)
              dump = 1 ;      /* only print dump of buffer */
            else if (strcmp(argvÝi¨,"-H")==0)
              help() ;        /* print some help info and end */
            else if (strcmp(argvÝi¨,"-N")==0)
              {               /* documentory name */
                i++ ;
                if (i<argc)
                  strcpy(name,argvÝi¨) ;
              }
            else
              {
                printf("Ingoring invalid parameter: %s \n",argvÝi¨) ;
                printf("Use -H parm. for more info.\n") ;
              }
            i++ ;
          }  /* of while more args */
        if (dump)
          terse = 0 ;
      }  /* of if args */
    printf("Options: Terse=%d Dump=%d Force=%d Name=%s\n",
      terse,dump,force,name) ;

    /* gripe about invalid environment options */
    i = 0 ;
    while (*envp)
      printf("Environment option %s ignored.\n",i++,*envp++) ;

    /* get info from TSO about this device */
    rc = getterm(&pr,&pc,&ar,&ac,&att) ;
    if (rc==0)                 /* get terminal info worked ? */
      {
        /* set row and col may used later by query dev */
        if ((ar>0) && (ar!=pr) &&
            (ac>0) && (ac!=pc))
          {
            rows = ar ;     /* use alternate rows */
            cols = ac ;     /* use alternate cols */
          }
        else
          {
            rows = pr ;     /* use primary rows */
            cols = pc ;     /* use primary cols */
          }

        printf("Getterm device info.: %s \n",name) ;
        printf("  Primary partition sereen size:\n") ;
        printf("    Rows...: %d \n",pr) ;
        printf("    Columns: %d \n",pc) ;
        printf("  Alternate partition screen size:\n") ;
        printf("    Rows...: %d \n",ar) ;
        printf("    Columns: %d \n",ac) ;
        printf("  Gtterm attributes '%.8X'x \n",att) ;
        if (att==0x00000001)     /* query structured fields */
          {
            printf("  Device supports query structured fields.\n") ;
            querydev() ;
          }
        else
          {
            printf("  Structured field query not supported.\n");
            if (force)
              {
                printf("  Warning: Query structured field forced.\n");
                querydev() ;
              }
          }
      }
    else
      printf("Error: GETTERM macro RC=%d \n",rc) ;
    printf("INFO3270 ended.\n") ;
  }


/* ------------------------- Sub routines -------------------------- */

void help()
  /*
     This routine displays a small amount of help
  */
  {
     printf("Parameters are:\n") ;
     printf("  -N name .. Supply a documentory name to display.\n") ;
     printf("  -F .. Force a query of the device.\n") ;
     printf("  -T .. Do not dump buffer contents.\n") ;
     printf("  -D .. Only dump buffer contents.\n") ;
     printf("  -H .. This help.\n") ;
  }

int getterm(int *primrow, int *primcol,
             int *altrow, int *altcol,
             int *attrs)
  /*
     This routine loads an assebbler module below the 16 MB line
     that issues the GTTERM macro instruction to obtain the
     dimensions of the screen and also some bit fields that
     tell if the device can be queried. The module copies the
     results from storage below the line to this routines
     automatic storage.
     Upon completion the module is unloaded.
  */
  {
    struct {
      union {
        short sh ;
        char cÝ2¨ ;
      } prim ;
      union {
        short sh ;
        char cÝ2¨ ;
      } alt ;
      int attr ;
    } pm ;
    int rc = 0 ;
    int (*tgt327d)(void *) ;

    loadm("TGT327D",&tgt327d) ;   /* load ASM routine below 16M */
    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */
    if (rc==0)      /* data returned OK ? */
      {             /* yes - convert single byte numbers to int */
        *primrow = pm.prim.cÝ0¨ ;
        *primcol = pm.prim.cÝ1¨ ;
        *altrow = pm.alt.cÝ0¨ ;
        *altcol = pm.alt.cÝ1¨ ;
        *attrs = pm.attr ;
      }
    unloadm(tgt327d) ;            /* unload ASM routine */
    return rc ;                   /* return code from GTTERM */
  }

void rc2sba(int row,
            int col,
            char *sba)
/*
   Convert row/column to 3270 12/16 bit buffer address.
*/
{
  int offset, byte1, byte2 ;

  offset = ((row-1)*cols)+(col-1) ;
  if (adrmode == 12)  /* addressing mode = 12 */
    {
      byte1 = offset >> 6 ;           /* extract high order bits */
      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */

      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */
      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */

      sbaÝ0¨ = *((char *)&byte1+3) ;  /* assemble 2 byte sba */
      sbaÝ1¨ = *((char *)&byte2+3) ;
    }
  else /* adrmode = 16 or 14 */
    {
      byte1 = offset >> 8 ;           /* extract high order byte */
      byte2 = offset & 0x00ff ;       /* extract low order byte */
      sbaÝ0¨ = *((char *)&byte1+3) ;  /* assemble 2 byte sba */
      sbaÝ1¨ = *((char *)&byte2+3) ;
    }
}

void querydev()
  /*
     Select the entire screen buffer using SBA based on the
     scrsize returned from GTTERM and EW/EWA to select the
     primary or alternate buffer.
     Then assemble a structured field query, and send it to the
     device using TPG which will cause the device to imediately
     send back the response without any user intervention.
     Then decode the read partition, query operations, query and
     print the results to STDOUT.
  */
  {
    short sflen ;    /* structured field length */
    char  sfid ;     /* structured field ID */
    char  qcode ;    /* query reply - query code */
    char inputÝ256¨ ;/* query buffer */
    char *ibuf ;     /* current query buffer pointer */
    int rc ;         /* return code */
    char sbaÝ2¨ ;    /* buffer address of max row/col */

    char out1Ý¨ = {      /* set up for erase */
      WRT, 0x40,
      SBA, 0x5d, 0x7f,   /* end addr - row=24 col=80 */
      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */
      SBA, 0xe7, 0x7f,   /* insert cursor location - row=max col=max */
      ICUR               /* insert cursor */
      } ;

    char out2Ý¨ = {      /* erase write alternate */
      EWA, 0xc2
      } ;

    char out3Ý¨ = {      /* erase primary */
      WRT, 0xc2
      } ;

    char out4Ý¨ = {
      WSF,               /* write structured field */
      0x00, 0x05,        /* structured field length */
      0x01,              /* read partition */
      0xFF,              /* query operations */
      0x02               /* query */
      } ;

    /* set max screen size known so far sba */
    rc2sba(rows,cols,sba) ;
    out1Ý9¨ = sbaÝ0¨ ;
    out1Ý10¨ = sbaÝ1¨ ;

    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */

    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */
    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */
    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */
    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */
    rc = TGET(input,sizeof(input),_FULLSCR) ; /* receive device resp.*/

    ibuf = input ;       /* point at input */

    if (*input==0x88)    /* check for 88 AID byte */
      {
        printf("\nRead device, Query operations info.: \n") ;
        ibuf = ibuf+1 ;         /* advance to 1st structured field */
        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */

        while (sfid==0x81)  /* while structured fields remain */
          {
            sflen = *((short *)ibuf) ;  /* get structured field len */
            if (sflen==0)           /* bad error - should not happen */
              {
                printf("Error: Structured field length zero at %p\n",
                  ibuf) ;
                dumpchar(input,sizeof(input)) ;
                break ;
              }
            qcode = *(ibuf+3) ;     /* get query code */
            switch (qcode)
              {
                case 0x80:           /* Qcode summary */
                  rc = dsummary(ibuf,sflen) ;
                  break ;
                case 0x81:           /* Usable area */
                  rc = darea(ibuf,sflen) ;
                  break ;
                case 0x82:           /* Image */
                  rc = dimage(ibuf,sflen) ;
                  break ;
                case 0x83:           /* Text partitions */
                  rc = dtextp(ibuf,sflen) ;
                  break ;
                case 0x84:           /* Alphanumeric partitions */
                  rc = dalphap(ibuf,sflen) ;
                  break ;
                case 0x85:           /* Character sets */
                  rc = dcharset(ibuf,sflen) ;
                  break ;
                case 0x86:           /* Color */
                  rc = dcolor(ibuf,sflen) ;
                  break ;
                case 0x87:           /* Highlighting */
                  rc = dhilite(ibuf,sflen) ;
                  break ;
                case 0x88:           /* Modes */
                  rc = dmodes(ibuf,sflen) ;
                  break ;
                case 0x8a:           /* Field validation */
                  rc = dfieldv(ibuf,sflen) ;
                  break ;
                case 0x8b:           /* MSR Control */
                  rc = dmsrcntl(ibuf,sflen) ;
                  break ;
                case 0x8c:           /* Field Outlining */
                  rc = dfieldol(ibuf,sflen) ;
                  break ;
                case 0x8e:           /* Partition Characteristics */
                  rc = dpartchr(ibuf,sflen) ;
                  break ;
                case 0x8f:           /* OEM Auxillary Device */
                  rc = doemaux(ibuf,sflen) ;
                  break ;
                case 0x90:           /* Format presentation */
                  rc = dformat(ibuf,sflen) ;
                  break ;
                case 0x91:           /* DBCS - Asia */
                  rc = ddbcs(ibuf,sflen) ;
                  break ;
                case 0x92:           /* Save restore format */
                  rc = dsave(ibuf,sflen) ;
                  break ;
                case 0x94:           /* Format auxillary storage devic*/
                  rc = dfmtaux(ibuf,sflen) ;
                  break ;
                case 0x95:           /* Distributed data management */
                  rc = ddist(ibuf,sflen) ;
                  break ;
                case 0x96:           /* Storage pools */
                  rc = dstrpool(ibuf,sflen) ;
                  break ;
                case 0x97:           /* Document interchange arch. */
                  rc = ddocint(ibuf,sflen) ;
                  break ;
                case 0x98:           /* Data chaining */
                  rc = datchain(ibuf,sflen) ;
                  break ;
                case 0x99:           /* Auxilliary device */
                  rc = dauxdev(ibuf,sflen) ;
                  break ;
                case 0x9a:           /* 3270 IPDS */
                  rc = d3270ip(ibuf,sflen) ;
                  break ;
                case 0x9c:           /* Product defined data stream */
                  rc = dpdds(ibuf,sflen) ;
                  break ;
                case 0x9d:           /* Anomaly implementation */
                  rc = danom(ibuf,sflen) ;
                  break ;
                case 0x9e:           /* IBM auxilliary device */
                  rc = dibmaux(ibuf,sflen) ;
                  break ;
                case 0x9f:           /* Begin / end of file */
                  rc = dbeof(ibuf,sflen) ;
                  break ;
                case 0xa0:           /* Device characteristics */
                  rc = ddevchar(ibuf,sflen) ;
                  break ;
                case 0xa1:           /* RPQ names */
                  rc = drpqname(ibuf,sflen) ;
                  break ;
                case 0xa2:           /* Data streams */
                  rc = ddatastr(ibuf,sflen) ;
                  break ;
                case 0xa6:           /* Implicit partition */
                  rc = dimpart(ibuf,sflen) ;
                  break ;
                case 0xa7:           /* Paper feed techniques */
                  rc = dpaperf(ibuf,sflen) ;
                  break ;
                case 0xa8:           /* Transparency */
                  rc = dtrans(ibuf,sflen) ;
                  break ;
                case 0xa9:           /* Settable printer chars. */
                  rc = dsprnch(ibuf,sflen) ;
                  break ;
                case 0xaa:           /* IOCA Auxillary Device */
                  rc = diocaaux(ibuf,sflen) ;
                  break ;
                case 0xab:           /* Cooperative proc requestor */
                  rc = dcooproc(ibuf,sflen) ;
                  break ;
                case 0xb0:           /* Segment */
                  rc = dsegment(ibuf,sflen) ;
                  break ;
                case 0xb1:           /* Procedure */
                  rc = dproc(ibuf,sflen) ;
                  break ;
                case 0xb2:           /* Line type */
                  rc = dlinetyp(ibuf,sflen) ;
                  break ;
                case 0xb3:           /* Port */
                  rc = dport(ibuf,sflen) ;
                  break ;
                case 0xb4:           /* Graphic color */
                  rc = dgrapcol(ibuf,sflen) ;
                  break ;
                case 0xb5:           /* Extended drawing routine */
                  rc = dextdraw(ibuf,sflen) ;
                  break ;
                case 0xb6:           /* Graphic symbol sets */
                  rc = dgrapsym(ibuf,sflen) ;
                  break ;
                default:
                  printf("Error: Invalid q-code at %p in buffer:\n",
                    ibuf+3) ;
                  dumpchar(input,sizeof(input)) ;
                  printf("INFO3270 ending early due to errors.\n") ;
                  abort() ;
              }  /* of switch */
            ibuf = ibuf+sflen ; /* advance to next structured field */
            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */

          } /* of while sfid=81 */

      } /* of AID=88 */
  }

int dsummary(char *buf, short buflen)
  /*
    0x80: Qcode summary
  */
  {
     int i ;
     char qcode ;

     printf("  Q-code summary:\n") ;
     printf("    Following Q-codes supported:\n") ;
     for (i=4;i<buflen;i++)
       {
          printf("      ") ;
          qcode = *(buf+i) ;     /* get query code */
          switch (qcode)
            {
              case 0x80:
                printf("(%.2X) Qcode summary.\n",qcode) ;
                break ;
              case 0x81:
                printf("(%.2X) Usable area.\n",qcode) ;
                break ;
              case 0x82:
                printf("(%.2X) Image.\n",qcode) ;
                break ;
              case 0x83:
                printf("(%.2X) Text partitions.\n",qcode) ;
                break ;
              case 0x84:
                printf("(%.2X) Alphanumeric partitions.\n",qcode) ;
                break ;
              case 0x85:
                printf("(%.2X) Character sets.\n",qcode) ;
                break ;
              case 0x86:
                printf("(%.2X) Color.\n",qcode) ;
                break ;
              case 0x87:
                printf("(%.2X) Highlighting.\n",qcode) ;
                break ;
              case 0x88:
                printf("(%.2X) Modes.\n",qcode) ;
                break ;
              case 0x8a:
                printf("(%.2X) Field validation.\n",qcode) ;
                break ;
              case 0x8b:
                printf("(%.2X) MSR Control.\n",qcode) ;
                break ;
              case 0x8c:
                printf("(%.2X) Field Outlining.\n",qcode) ;
                break ;
              case 0x8e:
                printf("(%.2X) Partition Characteristics.\n",qcode) ;
                break ;
              case 0x8f:
                printf("(%.2X) OEM Auxillary Device.\n",qcode) ;
                break ;
              case 0x90:
                printf("(%.2X) Format presentation.\n",qcode) ;
                break ;
              case 0x91:
                printf("(%.2X) DBCS - Asia.\n",qcode) ;
                break ;
              case 0x92:
                printf("(%.2X) Save restore format.\n",qcode) ;
                break ;
              case 0x94:
                printf("(%.2X) Format auxillary storage device.\n",
                  qcode) ;
                break ;
              case 0x95:
                printf("(%.2X) Distributed data management.\n",qcode) ;
                break ;
              case 0x96:
                printf("(%.2X) Storage pools.\n",qcode) ;
                break ;
              case 0x97:
                printf("(%.2X) Document interchange arch..\n",qcode) ;
                break ;
              case 0x98:
                printf("(%.2X) Data chaining.\n",qcode) ;
                break ;
              case 0x99:
                printf("(%.2X) Auxilliary device.\n",qcode) ;
                break ;
              case 0x9a:
                printf("(%.2X) 3270 IPDS.\n",qcode) ;
                break ;
              case 0x9c:
                printf("(%.2X) Product defined data stream.\n",qcode) ;
                break ;
              case 0x9d:
                printf("(%.2X) Anomaly implementation.\n",qcode) ;
                break ;
              case 0x9e:
                printf("(%.2X) IBM auxilliary device.\n",qcode) ;
                break ;
              case 0x9f:
                printf("(%.2X) Begin / end of file.\n",qcode) ;
                break ;
              case 0xa0:
                printf("(%.2X) Device characteristics.\n",qcode) ;
                break ;
              case 0xa1:
                printf("(%.2X) RPQ names.\n",qcode) ;
                break ;
              case 0xa2:
                printf("(%.2X) Data streams.\n",qcode) ;
                break ;
              case 0xa6:
                printf("(%.2X) Implicit partition.\n",qcode) ;
                break ;
              case 0xa7:
                printf("(%.2X) Paper feed techniques.\n",qcode) ;
                break ;
              case 0xa8:
                printf("(%.2X) Transparency.\n",qcode) ;
                break ;
              case 0xa9:
                printf("(%.2X) Settable printer chars..\n",qcode) ;
                break ;
              case 0xaa:
                printf("(%.2X) IOCA Auxillary Device.\n",qcode) ;
                break ;
              case 0xab:
                printf("(%.2X) Cooperative proc requestor.\n",qcode) ;
                break ;
              case 0xb0:
                printf("(%.2X) Segment.\n",qcode) ;
                break ;
              case 0xb1:
                printf("(%.2X) Procedure.\n",qcode) ;
                break ;
              case 0xb2:
                printf("(%.2X) Line type.\n",qcode) ;
                break ;
              case 0xb3:
                printf("(%.2X) Port.\n",qcode) ;
                break ;
              case 0xb4:
                printf("(%.2X) Graphic color.\n",qcode) ;
                break ;
              case 0xb5:
                printf("(%.2X) Extended drawing routine.\n",qcode) ;
                break ;
              case 0xb6:
                printf("(%.2X) Graphic symbol sets.\n",qcode) ;
                break ;
              default:
                printf("Warning: Q-code %.2X unknown.\n",qcode) ;
                break ;
            }  /* of switch qcode */
       }  /* of for i=4 */

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int darea(char *buf, short buflen)
  /*
    0x81: Usable area
  */
  {
     char celunitsÝ6¨ ;   /* screen size unit PEL or CELL */
     char unitsÝ3¨ ;      /* pel spacing inits IN or MM */
     short w, h ;         /* screen size w=width h=height */
     char aw, ah ;        /* units per cell aw=width ah=height */
     float xr, xrd, yr, yrd ;  /* pel spacing ratio */
     char vcpflg = 0 ;    /* VCP - variable cell size per partition */
     float fw, fh ;       /* ratio - pels per unit */

     printf("  Usable area:\n") ;
     if (*(buf+4) & 0x10)
       printf("    Device is hardcopy.\n") ;
     else
       printf("    Device is interactive.\n") ;

     if ((*(buf+4) & 0x0f)==0x0f)
       printf("    Addressing unmapped.\n") ;
     else if ((*(buf+4) & 0x03)==0x03)
       printf("    12/14/16 bit addressing allowed.\n") ;
     else if ((*(buf+4) & 0x01)==0x01)
       printf("    12/14 bit addressing allowed.\n") ;

     if (*(buf+5) & 0x80)
       {
         printf("    Variable cells supported.\n") ;
         vcpflg = 1 ;
       }
     else
       printf("    Variable cells not supported.\n") ;

     if (*(buf+5) & 0x40)
       printf("    Non-matrix character.\n") ;
     else
       printf("    Matrix character.\n") ;

     w = *((short *)(buf+6)) ;   /* width of usable area */
     h = *((short *)(buf+8)) ;   /* height of usable area */

     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */
       strcpy(units,"mm") ;
     else
       strcpy(units,"in") ;

     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */
     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */
     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */
     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */

     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */
     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */
     printf("    Horizontal pels per %s is: %f \n",units,fw) ;
     printf("    Vertical pels per %s is: %f \n",units,fh) ;

     aw = *(buf+19) ;    /* number of X units in default cell */
     ah = *(buf+20) ;    /* number of Y units in default cell */
     printf("    Character cell size is: %d by %d pels.\n",aw,ah) ;

     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */
       strcpy(celunits,"pels") ;
     else                       /* other wise unit=cells */
       strcpy(celunits,"cells") ;

     printf("    Screen width is: %d %s.\n",w,celunits) ;
     printf("    Screen height is: %d %s.\n",h,celunits) ;

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dimage(char *buf, short buflen)
  /*
    0x82: Image
  */
  {
     printf("  Image:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }


int dtextp(char *buf, short buflen)
  /*
    0x83: Text partitions
  */
  {
     printf("  Text partitions:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dalphap(char *buf, short buflen)
  /*
    0x84: Alphanumeric partitions
  */
  {
     short m ;        /* total available partition storage */

     printf("  Alphanumeric partitions:\n") ;

     m = *((short *)(buf+5)) ;
     printf("    Total partition storage: %d \n",m) ;

     if (*(buf+7) & 0x80)
       printf("    Vertical scrolling supported.\n") ;
     else
       printf("    Vertical scrolling not supported.\n") ;

     if (*(buf+7) & 0x40)
       printf("    Horizontal scrolling supported.\n") ;
     else
       printf("    Horizontal scrolling not supported.\n") ;

     if (*(buf+7) & 0x10)
       printf("    All ports addressability supported.\n") ;
     else
       printf("    All ports addressability not supported.\n") ;

     if (*(buf+7) & 0x08)
       printf("    Partition protection supported.\n") ;
     else
       printf("    Partition protection not supported.\n") ;

     if (*(buf+7) & 0x04)
       printf("    Presentation space local copy supported.\n") ;
     else
       printf("    Presentation space local copy not supported.\n") ;

     if (*(buf+7) & 0x02)
       printf("    Modify partition supported.\n") ;
     else
       printf("    Modify partition not supported.\n") ;

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dcharset(char *buf, short buflen)
  /*
    0x85: Character sets
  */
  {
     int i, j ;         /* counters */
     int cgcsgid ;      /* Coded graphic character set identifier */
     int form ;         /* Supported loaded PS format types */
     short ccsid ;      /* Coded character set identifier */
     char gf = 0 ;      /* CGCSGID not present flag */
     char ch2 = 0 ;     /* Two byte char. set flag */
     char ms = 0 ;      /* Multiple slot sizes flag */
     char cf = 0 ;      /* CCSID not present flag */
     char sdw ;         /* Default character slot width */
     char sdh ;         /* Default character slot height */
     char dl ;          /* character set descriptor (CSD) length */
     char *csd ;        /* character set descriptor (CSD) ptr */
     char set ;         /* character set ID (PS store no.) */
     char lcid ;        /* character set Local ID (alias) */
     char sw ;          /* character set slot width */
     char sh ;          /* character set slot height */
     char ssubsn ;      /* character set starting subsection */
     char esubsn ;      /* character set ending subsection */
     char nameÝ16¨ ;    /* character set name */

     printf("  Character sets:\n") ;

     if (*(buf+4) & 0x80)
       printf("    Graphic Escape (GE) supported.\n") ;
     else
       printf("    Graphic Escape not supported.\n") ;

     if (*(buf+4) & 0x40)
       printf("    Multiple LCIDs supported.\n") ;
     else
       printf("    Multiple LCIDs not supported.\n") ;

     if (*(buf+4) & 0x20)
       printf("    Load PSSF supported.\n") ;
     else
       printf("    Load PSSF not supported.\n") ;

     if (*(buf+4) & 0x10)
       printf("    Load PS Extended supported.\n") ;
     else
       printf("    Load PS Extended not supported.\n") ;

     if (*(buf+4) & 0x08)
       {
         ms = 1 ;
         printf("    More than one size character slot supported.\n") ;
       }
     else
       printf("    Only one size character slot is supported.\n") ;

     if (*(buf+4) & 0x04)
       {
         ch2 = 1 ;
         printf("    Two byte code character sets are supported.\n") ;
       }
     else
       printf("    Two byte code character sets are not supported.\n") ;

     if (*(buf+4) & 0x02)
       {
         gf = 1 ;
         printf("    CGCSGID present.\n") ;
       }
     else
       printf("    CGCSGID not present.\n") ;

     if (*(buf+5) & 0x40)
       printf("    Load PS match slot size not required.\n") ;
     else
       printf("    Load PS match slot size required.\n") ;

     if (*(buf+5) & 0x20)
       {
         cf = 1 ;
         printf("    CCSID present.\n") ;
       }
     else
       printf("    CCSID not present.\n") ;

     sdw = *(buf+6) ;
     sdh = *(buf+7) ;
     printf("    Default character slot width: %d\n",sdw) ;
     printf("    Default character slot height: %d\n",sdh) ;

     form = *((int *)(buf+8)) ;
     for (i=0;i<=31;i++)
       {
         if (form & 0x80000000)
           printf("    Load PS format type %d supported.\n",i) ;
         form = form << 1 ;
       }
     dl = *(buf+12) ;   /* get CSD length */
     i = 13 ;
     while (i<buflen)
       {
         csd = buf + i ;  /* point at CSD to process */
         set = *csd ;     /* get character set ID (PS store no.) */
         printf("    Character set: %d\n",set) ;
         if (*(csd+1) & 0x80)
           printf("      Loadable character set.\n") ;
         else
           printf("      Non-Loadable character set.\n") ;

         if (*(csd+1) & 0x40)
           printf("      Triple-plane character set.\n") ;
         else
           printf("      Single-plane character set.\n") ;

         if (*(csd+1) & 0x20)
           printf("      Double-byte coded character set.\n") ;
         else
           printf("      Single-byte coded character set.\n") ;

         if (*(csd+1) & 0x10)
           printf("      No LCID compare.\n") ;
         else
           printf("      LCID compare.\n") ;

         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */
         printf("      Local character set ID (alias): %d\n",lcid) ;

         j = 0 ;
         if (ms)
           {
             sw = *(csd+3) ;  /* slot width */
             sh = *(csd+4) ;  /* slot height */
             printf("      Slot width: %d \n",sw) ;
             printf("      Slot height: %d \n",sh) ;
             j = j + 2 ;
           }

         if (ch2)
           {
             ssubsn = *(csd+j+3) ;  /* starting sub-section */
             esubsn = *(csd+j+4) ; /* ending sub-section */
             printf("      Starting sub-section: %d \n",ssubsn) ;
             printf("      Ending sub-section: %d \n",esubsn) ;
             j = j + 2 ;
           }

         if (gf)
           {
             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */
             if (cgcsgid==0x00000000)
               strcpy(name,"Loadable") ;
             else if (cgcsgid==0x03c30136)
               strcpy(name,"APL") ;
             else if (cgcsgid==0x02b90025)
               strcpy(name,"U.S. English") ;
             else if (cgcsgid==0x02b9011d)
               strcpy(name,"U.K. English") ;
             else if (cgcsgid==0x02b90129)
               strcpy(name,"French") ;
             else if (cgcsgid==0x02b90111)
               strcpy(name,"Austrian/German") ;
             else if (cgcsgid==0x02b90118)
               strcpy(name,"Italian") ;
             else if (cgcsgid==0x02b9011c)
               strcpy(name,"Spanish") ;
             else
               strcpy(name,"Unknown") ;
             printf("      Coded graphic char. set ID: '%.8X'x ",
               cgcsgid) ;
             printf("- %s symbol set.\n",name) ;
             j = j + 4 ;
           }

         if (cf)
           {
             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */
             printf("      Coded character set ID: '%.4X'x\n",ccsid) ;
           }

         i = i + dl ;  /* get pos of next CSD */
       }  /* of while i<buflen */

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dcolor(char *buf, short buflen)
  /*
    0x86: Colors
  */
  {
     char acolorsÝ16¨Ý15¨ = {
       {"Black         "},    /* 'f0'x   00 */
       {"Blue          "},    /* 'f1'x   01 */
       {"Red           "},    /* 'f2'x   02 */
       {"Pink          "},    /* 'f3'x   03 */
       {"Green         "},    /* 'f4'x   04 */
       {"Turquoise     "},    /* 'f5'x   05 */
       {"Yellow        "},    /* 'f6'x   06 */
       {"White         "},    /* 'f7'x   07 */
       {"Black         "},    /* 'f8'x   08 */
       {"Deep Blue     "},    /* 'f9'x   09 */
       {"Orange        "},    /* 'fa'x   10 */
       {"Purple        "},    /* 'fb'x   11 */
       {"Pale Green    "},    /* 'fc'x   12 */
       {"Pale Turquoise"},    /* 'fd'x   13 */
       {"Gray          "},    /* 'fe'x   14 */
       {"White         "}     /* 'ff'x   15 */
     } ;
     int colors ;     /* number of colors */
     int icolor ;     /* color index */
     int i ;          /* counter */
     char attr ;      /* color attribute accepted by device */
     char dcolor ;    /* color displayed for this attribute */

     printf("  Colors:\n") ;
     colors = (int)*(buf+5) ;
     printf("    Number of colors supported: %d\n",colors) ;
     printf("    Color attribute map follows:\n") ;
     for (i=6;i<buflen;i=i+2)
       {
         attr = *(buf+i) ;        /* attribute used by appl. */
         dcolor = *(buf+i+1) ;    /* attr/color used ny device */
         icolor = (int)(dcolor - 0xf0) ;
         if ((icolor >= 0) && (icolor <= 15))
           printf("      Attr: %.2X Uses color: %s \n",
             attr,acolorsÝicolor¨) ;
         else
           printf("      Attr: %.2X Uses color is invalid.\n",attr) ;
       }

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dhilite(char *buf, short buflen)
  /*
    0x87: Highlighting
  */
  {
     char ahiliteÝ9¨Ý11¨ = {
       {"Normal    "},    /* 'f0'x   00 */
       {"Blink     "},    /* 'f1'x   01 */
       {"Reverse   "},    /* 'f2'x   02 */
       {"          "},    /* 'f3'x   03 */
       {"Underscore"},    /* 'f4'x   04 */
       {"          "},    /* 'f5'x   05 */
       {"          "},    /* 'f6'x   06 */
       {"          "},    /* 'f7'x   07 */
       {"Intensify "}     /* 'f8'x   08 */
     } ;
     int hilites ;     /* number of hilites */
     int ihilite ;     /* color index */
     int i ;           /* counter */
     char attr ;       /* color attribute accepted by device */
     char dhilite ;    /* color displayed for this attribute */

     printf("  Highlighting:\n") ;
     hilites = (int)*(buf+4) ;
     printf("    Number of highlights supported: %d\n",hilites) ;
     printf("    Highlight attribute map follows:\n") ;
     for (i=5;i<buflen;i=i+2)
       {
         attr = *(buf+i) ;        /* attribute used by appl. */
         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */
         ihilite = (int)(dhilite - 0xf0) ;
         if (attr == 0x00)
           printf("      Attr: %.2X (default) Uses highlight: %s\n",
             attr,ahiliteÝ0¨) ;
         else if ((ihilite >= 0) && (ihilite <= 9))
           printf("      Attr: %.2X Uses highlight: %s \n",
             attr,ahiliteÝihilite¨) ;
         else
           printf("      Attr: %.2X Used highlight is invalid.\n",
             attr) ;
       }

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dmodes(char *buf, short buflen)
  /*
    0x88: Modes
  */
  {
     int i ;           /* counter */
     char mode ;       /* device opperation mode */

     printf("  Modes:\n") ;
     printf("    Supported modes follow:\n") ;
     for (i=4;i<buflen;i++)
       {
         printf("      ") ;
         mode = *(buf+i) ;        /* attribute used by appl. */
         if (mode==0x00)
           printf("Field mode (SF order).\n") ;
         else if (mode==0x01)
           printf("Extended field mode (SFE + MF orders).\n") ;
         else if (mode==0x02)
           printf("Character mode (SA order).\n") ;
         else
           printf("Warning: Mode %.2X not unknown.\n") ;
       }   /* of for i */

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dfieldv(char *buf, short buflen)
  /*
    0x8a: Field validation
  */
  {
     printf("  Field validation:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dmsrcntl(char *buf, short buflen)
  /*
    0x8b: MSR Control
  */
  {
     printf("  MSR Control:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dfieldol(char *buf, short buflen)
  /*
    0x8c: Field Outlining
  */
  {
     printf("  Field Outlining:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dpartchr(char *buf, short buflen)
  /*
    0x8e: Partition Characteristics
  */
  {
     printf("  Partition Characteristics:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int doemaux(char *buf, short buflen)
  /*
    0x8f: OEM Auxillary Device
  */
  {
     printf("  OEM Auxillary Device Info.:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dformat(char *buf, short buflen)
  /*
    0x90: Format presentation
  */
  {
     printf("  Format Presentation:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int ddbcs(char *buf, short buflen)
  /*
    0x91: DBCS - Asia
  */
  {
     printf("  DBCS - Asia:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dsave(char *buf, short buflen)
  /*
    0x92: Save restore format
  */
  {
     printf("  Save Restore Format:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dfmtaux(char *buf, short buflen)
  /*
    0x94: Format auxillary storage device
  */
  {
     printf("  Format Auxillary Storage Device:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int ddist(char *buf, short buflen)
  /*
    0x95: Distributed data management
  */
  {
     printf("  Distributed Data Management:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dstrpool(char *buf, short buflen)
  /*
    0x96: Storage pools
  */
  {
     printf("  Storage Pools:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int ddocint(char *buf, short buflen)
  /*
    0x97: Document interchange arch.
  */
  {
     printf("  Document Interchange Architecture:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int datchain(char *buf, short buflen)
  /*
    0x98: Data chaining
  */
  {
     printf("  Data Chaining:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dauxdev(char *buf, short buflen)
  /*
    0x99: Auxilliary device
  */
  {
     printf("  Auxillary Device:\n") ;
     printf("    Auxillary devices are supported.\n") ;

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int d3270ip(char *buf, short buflen)
  /*
    0x9a: 3270 IPDS
  */
  {
     printf("  3270 IPDS:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dpdds(char *buf, short buflen)
  /*
    0x9c: Product defined data stream
  */
  {
     printf("  Product Defined Data Stream:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int danom(char *buf, short buflen)
  /*
    0x9d: Anomaly implementation
  */
  {
     printf("  Anomaly Implementation:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dibmaux(char *buf, short buflen)
  /*
    0x9e: IBM auxilliary device
  */
  {
     printf("  IBM Auxillary Device:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dbeof(char *buf, short buflen)
  /*
    0x9f: Begin / end of file
  */
  {
     printf("  Begin/End of File:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int ddevchar(char *buf, short buflen)
  /*
    0xa0: Device characteristics
  */
  {
     printf("  Device Characteristics:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int drpqname(char *buf, short buflen)
  /*
    0xa1: RPQ names
  */
  {
     printf("  RPQ Names:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int ddatastr(char *buf, short buflen)
  /*
    0xa2: Data streams
  */
  {
     printf("  Data Streams:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dimpart(char *buf, short buflen)
  /*
    0xa6: Implicit partition
  */
  {
     char *sdp ;                /* self defining parameter (SDP) ptr */
     short wd, wa, hd, ha ;     /* screen dimensions */
     short wcd, wca, hcd, hca ; /* cell sizes */
     int i ;                    /* counter */

     printf("  Implicit Partition:\n") ;
     i = 6 ;        /* length of header */
     while(i < buflen)   /* loop over all SDPs */
       {
         sdp = buf + i ;
         if (*sdp==0x0b)    /* is it a SDP ? */
           {
             if (*(sdp+1)==0x01)
               {
                 wd = *((short *)(sdp+3)) ;  /* default width */
                 hd = *((short *)(sdp+5)) ;  /* default height */
                 wa = *((short *)(sdp+7)) ;  /* alternate width */
                 ha = *((short *)(sdp+9)) ;  /* alternate height */
                 printf("    Default width: %d \n",wd) ;
                 printf("    Default height: %d \n",hd) ;
                 printf("    Alternate width: %d \n",wa) ;
                 printf("    Alternate height: %d \n",ha) ;
                 i = i + 11 ;     /* add length of this SDP */
               }
             else if (*(sdp+1)==0x03)
               {
                 printf("    Device is a printer.\n") ;
                 i = i + 11 ;     /* add length of this SDP */
               }
             else if (*(sdp+1)==0x02)
               {
                 wcd = *((short *)(sdp+3)) ;  /* default cell width */
                 hcd = *((short *)(sdp+5)) ;  /* default cell height */
                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */
                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/
                 printf("    Default cell width: %d \n",wcd) ;
                 printf("    Default cell height: %d \n",hcd) ;
                 printf("    Alternate cell width: %d \n",wca) ;
                 printf("    Alternate cell height: %d \n",hca) ;
                 i = i + 11 ;     /* add length of this SDP */
               }
           }
         else
           printf("  Warning: SDP invalid.\n") ;
       }  /* of while */

     printf("\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dpaperf(char *buf, short buflen)
  /*
    0xa7: Paper feed techniques
  */
  {
     printf("  Paper Feed Techniques:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dtrans(char *buf, short buflen)
  /*
    0xa8: Transparency
  */
  {
     printf("  Transparency:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dsprnch(char *buf, short buflen)
  /*
    0xa9: Settable printer chars.
  */
  {
     printf("  Settable Printer chars.:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int diocaaux(char *buf, short buflen)
  /*
    0xaa: IOCA Auxillary Device
  */
  {
     printf("  IOCA Auxillary Device:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dcooproc(char *buf, short buflen)
  /*
    0xab: Cooperative proc requestor
  */
  {
     printf("  Cooperative Proc Requestor:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dsegment(char *buf, short buflen)
  /*
    0xb0 Segment
  */
  {
     printf("  Segment:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dproc(char *buf, short buflen)
  /*
    0xb1: Procedure
  */
  {
     printf("  Procedure:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dlinetyp(char *buf, short buflen)
  /*
    0xb2: Line type
  */
  {
     printf("  Line Type:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dport(char *buf, short buflen)
  /*
    0xb3: Port
  */
  {
     printf("  Port:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dgrapcol(char *buf, short buflen)
  /*
    0xb4: Graphic color
  */
  {
     printf("  Graphic Color:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dextdraw(char *buf, short buflen)
  /*
    0xb5: Extended drawing routine
  */
  {
     printf("  Extended Drawing Routine:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int dgrapsym(char *buf, short buflen)
  /*
    0xb6: Graphic symbol sets
  */
  {
     printf("  Graphic Symbol Sets:\n") ;
     dumpchar(buf,(int)buflen) ;
     return 0 ;
  }

int tputn(char *buf, int buflen)
  /*
     The TPUTN routine is loaded below the 16M line
     It issues the TPUT macro with the NOEDIT option
  */
  {
    int rc = 0 ;
    int (*tputn)(char *,int) ;

    loadm("TPUTN",&tputn) ;
    rc = (*tputn)(buf,buflen) ;
    unloadm(tputn) ;
    return rc ;
  }

int tpgn(char *buf, int buflen)
  /*
    The TPGN routine is loaded below the 16M line
    It issues the TPG macro with the NOEDIT option
  */
  {
    int rc = 0 ;
    int (*tpgn)(char *,int) ;

    loadm("TPGN",&tpgn) ;
    rc = (*tpgn)(buf,buflen) ;
    unloadm(tpgn) ;
    return rc ;
  }

void fill(char *haystack, char filler, int num)
  /*
    Fills an area of memory with a specific fill
    character.
  */
  {
    int i = 0 ;
    for(i=0;i<=num;i++)
      *haystack++ = filler ;
    *haystack = '\0' ;
  }

void dumpchar(char *dat, int len)
  /*
    Dumps an area of memory using a HEX and character dump
    format that positions the hex charactes above the EBCIDC
    character representation. Also tries to interpret some
    of the special characters as 3270 data stream commands
    or orders.
  */
  {
    char *cptr ;
    char c ;
    char ccÝ3¨ ;
    int i ;
    int n, m ;

    if (terse)     /* dont dump buffer if terse parameter specified */
      return ;

    n = 0 ;
    m = 0 ;
    cptr = dat ;
    if (len==0)
      printf("    Buffer at: %.8X follows: \n",dat) ;
    else
      printf("    Buffer at: %.8X length: %d follows: \n",dat,len) ;

    do
      {
        printf("      %.8X  ",dat) ;
        for(i=1;i<=16;i++)
          {
            if (*dat=='\0' && len==0)
              break ;
            if (n==len && len>0)
              break ;
            c = *dat++ ;
            n++ ;
            printf("%.2X",c) ;
            if ((i%4)==0)
              printf(" ") ;
          }
        printf("\n                ") ;

        for(i=1;i<=16;i++)
          {
            if (*cptr=='\0' && len==0)
              break ;
            if (m==len && len>0)
              break ;
            c = *cptr++ ;
            m++ ;
            if (c <= 0x3f || c==0xff)
              {
                switch (c)
                  {
                    case GE:   strcpy(cc,"GE") ;
                      break ;
                    case FF:   strcpy(cc,"FF") ;
                      break ;
                    case CRR:  strcpy(cc,"CR") ;
                      break ;
                    case SBA:  strcpy(cc,"SB") ;
                      break ;
                    case EUA:  strcpy(cc,"EU") ;
                      break ;
                    case ICUR: strcpy(cc,"IC") ;
                      break ;
                    case NL:   strcpy(cc,"NL") ;
                      break ;
                    case EM:   strcpy(cc,"EM") ;
                      break ;
                    case DUP:  strcpy(cc,"DU") ;
                      break ;
                    case SF:   strcpy(cc,"SF") ;
                      break ;
                    case FM:   strcpy(cc,"FM") ;
                      break ;
                    case SA:   strcpy(cc,"SA") ;
                      break ;
                    case SFE:  strcpy(cc,"SX") ;
                      break ;
                    case MF:   strcpy(cc,"MF") ;
                      break ;
                    case RA:   strcpy(cc,"RA") ;
                      break ;
                    case SUB:  strcpy(cc,"SU") ;
                      break ;
                    default:   strcpy(cc,". ") ;
                      break ;
                  }
                printf("%s",cc) ;
              }
            else
              printf("%c ",c) ;
            if ((i%4)==0)
              printf(" ") ;
          }
        printf("\n") ;
      }
    while( ((*dat!='\0') && (len==0)) ||
           ((m!=len) && (len>20))
         ) ;
    printf("\n") ;
  }
