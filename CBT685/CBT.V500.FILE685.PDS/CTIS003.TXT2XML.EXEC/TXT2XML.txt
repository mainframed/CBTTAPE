       /* rexx procedure */
        ver = "1.25"
        /* --------------------------------------------------------- *
         *                                                           *
         * Name:      TXT2XML                                        *
         *                                                           *
         * Function:  Convert a text file to and from a XML one      *
         *            using a COBOL copybook as reference            *
         *                                                           *
         * Syntax:    TXT2XML   TXT txt-ds     (or DD:txt-ddname)    *
         *                      COB cob-ds     (or DD:cob-ddname)    *
         *                      XML xml-ds     (or DD:xml-ddname)    *
         *                      FORMAT format  (value: X or T)       *
         *                      PREFIX  prefix (see below)           *
         *                      DTD dtd-ds     (or DD:dtd-ddname)    *
         *                      VERBOSE        (display messages)    *
         *                      BROWSE         (will browse report)  *
         *                                                           *
         *  (MVS)     if no parameters and under ISPF then the ISPF  *
         *            dialog will be invoked.                        *
         *                                                           *
         *            Where:                                         *
         *                                                           *
         * ------------------- Mandatory --------------------------- *
         *                                                           *
         *  (MVS)     txt_ds    is a sequential dataset or member of *
         *                      a partitioned dataset                *
         *                                                           *
         *  (MVS)               or dd:ddname                         *
         *                                                           *
         *  (WIN/UNIX)          or a file                            *
         *                                                           *
         *                                                           *
         *  (MVS)     cob_ds    is a sequential dataset or member of *
         *                      a partitioned dataset                *
         *                                                           *
         *  (MVS)               or dd:ddname                         *
         *                                                           *
         *  (WIN/UNIX)          or a file                            *
         *                                                           *
         *                                                           *
         *  (MVS)     xml_ds    is a sequential dataset or member of *
         *                      a partitioned dataset                *
         *                                                           *
         *  (MVS)               or dd:ddname                         *
         *                                                           *
         *  (WIN/UNIX)          or a file                            *
         *                                                           *
         *                                                           *
         *            format    is the format of output data : X for *
         *                      XML or T for TXT                     *
         *                                                           *
         * ------------------- Optional ---------------------------- *
         *                                                           *
         *  (MVS)     dtd_ds    is a sequential dataset or member of *
         *                      a partitioned dataset                *
         *                                                           *
         *  (MVS)               or dd:ddname                         *
         *                                                           *
         *  (WIN/UNIX)          or a file                            *
         *                                                           *
         *                      or "INTERNAL" for the DTD included   *
         *                      in the XML file.                     *
         *                                                           *
         *                                                           *
         *            prefix    a leading string to be removed from  *
         *                      the COBOL item name or XML element   *
         *                                                           *
         *                                                           *
         *            noconfirm all messages will be suppressed.     *
         *                      Deprecated, see "verbose"            *
         *                                                           *
         *                                                           *
         *  (MVS)     browse    (will browse report) only used       *
         *                      under ISPF for use by the ISPF       *
         *                      interface                            *
         *                                                           *
         *                                                           *
         *            verbose   all message will be displayed.       *
         *                                                           *
         * --------------------------------------------------------- *
         *                                                           *
         * Author(s): Lionel B. Dyck                                 *
         *            Kaiser Permanente Information Technology       *
         *            Walnut Creek, CA 94598                         *
         *            (925) 926-5332                                 *
         *            Internet: lionel.b.dyck@kp.org                 *
         *                                                           *
         *            Pierre Delaunoy                                *
         *            Belgium                                        *
         *            Mail: sunuraxi@users.sourceforge.net           *
         *                                                           *
         * Web:       http://sourceforge.net/projects/txt2xml-rexx/  *
         *                                                           *
         * Doc:       See the documentation directory or dataset     *
         *                                                           *
         * Functions:                                                *
         *                                                           *
         *  txt2bin   txt2bin(text,length,signed) where              *
         *            - text is the text to convert.                 *
         *            - length is the length in bytes of binary      *
         *              data. May only be 2, 4 or 8.                 *
         *            - signed is a flag to tell that the binary     *
         *              item is signed. May only be "Y" or "N".      *
         *                                                           *
         *  txt2pack  txt2pack(text,length,signed) where             *
         *            - text is the text to convert.                 *
         *            - length is the length in bytes of binary      *
         *              data.                                        *
         *            - signed is a flag to tell that the binary     *
         *              item is signed. May only be "Y" or "N".      *
         *                                                           *
         *  txt2num   txt2num(text,length,signed,sign_pos) where     *
         *            - text is the text to convert.                 *
         *            - length is the length in bytes of binary      *
         *              data.                                        *
         *            - signed is a flag to tell that the binary     *
         *              item is signed. May only be "Y" or "N".      *
         *            - sign_pos is a flag to tell where the sign is *
         *              located. May only be "L", "T", "LS", "TS".   *
         *                                                           *
         *  bin2txt   bin2txt(bin,length,signed) where               *
         *            - bin is the binary data to convert.           *
         *            - length is the length in bytes of binary      *
         *              data. May only be 2, 4 or 8.                 *
         *            - signed is a flag to tell that the binary     *
         *              item is signed. May only be "Y" or "N".      *
         *                                                           *
         *  pack2txt  pack2txt(pack) where                           *
         *            - pack is the packed data to convert.          *
         *                                                           *
         *  num2txt   num2txt(num,signed,sign_pos) where             *
         *            - num is the numeric data to convert.          *
         *            - signed is a flag to tell that the binary     *
         *              item is signed. May only be "Y" or "N".      *
         *            - sign_pos is a flag to tell where the sign is *
         *              located. May only be "L", "T", "LS", "TS".   *
         *                                                           *
         *---------------------------------------------------------- */

         parse arg option
         i = time("R")        /* set start ot time */
         f = "X"              /* default format for ISPF panel */

        /* --------------------------------------------------------- *
         * Global variables                                          *
         * --------------------------------------------------------- */
         msgid = "TXT2XML:"   /* Default message identifier */
         r = 0                /* Used for reporting */
         browse = 0           /* Used for reporting */
         confirm = 0          /* Used for reporting */
         rpt.1 = ""           /* Used for reporting */
         exit_rc = 0          /* return code on exit  */
         rexx_os = ""         /* Operating system running rexx*/
         ret = 0              /* flag to return instead of exit */
                              /* at end of PGM */
         globals = "rexx_os exit_rc r rpt. browse confirm msgid ret"

        /* --------------------------------------------------------- *
         * Test if concatenation and OR operators works              *
         * --------------------------------------------------------- */
        /* first test concatenation operator */
         if "1" || "2" <> "12" then do
            say "==>Error: the Rexx concatenation operator doesn't work."
            say " "
            say "You may request help on the user forum at :"
            say " "
            say ,
                "http://sourceforge.net/forum/forum.php?forum_id=391891"
            say " "
            exit_rc = 12
            exit exit_rc
         end /* end if "1" || "2" <> "12" */

        /* Second test OR operator */
         if ("1" <> "1" | "2" <> "2") > 0 then do
            say "==>Error: the Rexx OR operator doesn't work." ,
            say " "
            say "You may request help on the user forum at :"
            say " "
            say ,
               "http://sourceforge.net/forum/forum.php?forum_id=391891"
            say " "
            exit_rc = 12
            exit exit_rc
         end /* end if ("1" <> "1" | "2" <> "2") > 0 */

        /* --------------------------------------------------------- *
         * Get REXX Operating System and type.                       *
         * --------------------------------------------------------- */
        /* get rexx interpreter name */
         parse version rexx_interpreter . .
         rexx_interpreter = translate(rexx_interpreter)
         if left(rexx_interpreter, 5) == "REXX-" then do
            parse var rexx_interpreter "REXX-" rexx_interpreter "_" .
         end /* end if left(rexx_interpreter, 5)  */

        /* get rexx operating system */
         parse source rexx_os .
         rexx_os = translate(word(rexx_os,1))

        /* Check OS and REXX interpreter */
         select
            when rexx_os = "TSO" then nop
            when substr(rexx_interpreter,1,6) = "REGINA" then nop
            otherwise do
               say "==>Error :" ,
                   "Unsupported Rexx interpreter" rexx_interpreter ,
                   "or unsupported operating system :" rexx_os
               say " "
               exit_rc = 12
               exit exit_rc
            end /* end otherwise do  */
         end /* end select */

        /* First viewable characters in code page */
         select
            when rexx_os= "TSO" THEN first_char = "40"x
            when rexx_os= "UNIX" THEN first_char = "20"x
            when rexx_os= "WIN32" THEN first_char = "20"x
            otherwise,
         end /* end select */

        /* --------------------------------------------------------- *
         * If no option provided and ISPF is active then call the    *
         * ISPF interface.                                           *
         * --------------------------------------------------------- */
         if length(option) <= 0 then do
            if rexx_os = "TSO" then do
               if sysvar('sysispf') = "ACTIVE" then do
                  ret = 1
                  cc = ""
                  do forever
                     cmd = ""
                     Address ISPExec "Display Panel(TXT2XML)"
                     if rc > 4 then exit rc
                     option = cmd
                     i = time("R")
                     drop r rpt.
                     r = 0
                     rpt.1 = ""
                     call do_it cmd
                  end /* end do forever */
               end /* end if sysvar('sysispf') = "ACTIVE"  */
               else call exit_no_options
            end /* end if rexx_os = "TSO"  */
            else call exit_no_options
         end /* end if length(option) <= 0  */

         Do_It:
        /* --------------------------------------------------------- *
         * Parse the input parameters.                               *
         * --------------------------------------------------------- */
         option = " " || option
         uopt = translate(option)
         i = pos(" TXT ",uopt)
         if i > 0 then option = overlay(" TXT ",option,i,5)
         i = pos(" COB ",uopt)
         if i > 0 then option = overlay(" COB ",option,i,5)
         i = pos(" XML ",uopt)
         if i > 0 then option = overlay(" XML ",option,i,5)
         i = pos(" FORMAT ",uopt)
         if i > 0 then option = overlay(" FORMAT ",option,i,8)
         i = pos(" DTD ",uopt)
         if i > 0 then option = overlay(" DTD ",option,i,5)
         i = pos(" PREFIX ",uopt)
         if i > 0 then option = overlay(" PREFIX ",option,i,8)
         i = pos(" BROWSE ",uopt)
         if i > 0 then option = overlay(" BROWSE ",option,i,8)
         i = pos(" NOCONFIRM ",uopt)
         if i > 0 then option = overlay(" NOCONFIRM ",option,i,11)
         i = pos(" VERBOSE ",uopt)
         if i > 0 then option = overlay(" VERBOSE ",option,i,9)
         parse var option . " TXT " txt ,
                          " COB " cobol ,
                          " XML " xml ,
                          " FORMAT " output . 1 ,
                          " DTD " dtd 1,
                          " PREFIX " prefix . 1
         txt = strip(txt)
         cobol= strip(cobol)
         xml = strip(xml)
         i = pos("PREFIX",translate(dtd))
         if i > 0 then dtd = overlay("      ",dtd,i,50)
         i = pos("BROWSE",translate(dtd))
         if i > 0 then dtd = overlay("      ",dtd,i,6)
         i = pos("NOCONFIRM",translate(dtd))
         if i > 0 then dtd = overlay("         ",dtd,i,9)
         i = pos("VERBOSE",translate(dtd))
         if i > 0 then dtd = overlay("       ",dtd,i,7)
         dtd = strip(dtd)
         output = translate(strip(output))
         prefix = translate(strip(prefix))
         prefix = translate(prefix,"-","_")

        /* --------------------------------------------------------- *
         * Test for noconfirm & verbose                              *
         * --------------------------------------------------------- */
         if wordpos("NOCONFIRM",uopt) > 1 then do
            call domsg "==>Warning :" ,
                       "NOCONFIRM is deprecated. Use VERBOSE instead."
            exit_rc = 4
            confirm = 0
         end /* end if wordpos("NOCONFIRM",uopt) > 1 */
         else confirm = 1
         if wordpos("VERBOSE",uopt) > 1 then do
            confirm = 1
         end /* end if wordpos("VERBOSE",uopt) > 1 */
         else confirm = 0

        /* --------------------------------------------------------- *
         * Test for Browse                                           *
         * --------------------------------------------------------- */
         if rexx_os = "TSO" then do
            if sysvar('sysispf') <> "ACTIVE" then browse = 0
            else if wordpos("BROWSE",uopt) > 1 then browse = 1
                 else browse = 0
         end /* end if rexx_os = "TSO"  */
         else browse = 0

        /* --------------------------------------------------------- *
         * Setup the default variables                               *
         * --------------------------------------------------------- */
         parse value "" with null txtdd cobdd xmldd dtddd top

         if confirm >= 1 then do
            call domsg "Text from & to XML Conversion Utility. Version:" ver
            call domsg " "
         end /* end if confirm >= 1 */

        /* --------------------------------------------------------- *
         * Test for the value of the output parameter                *
         * --------------------------------------------------------- */
         if output = null then do
            call domsg "==>Error :" ,
                       "The format parameter must be specified."
            exit_rc = 12
            signal done
         end /* end if output = null */
         else do
            output = substr(output,1,1)
            if output <> "X" & output <> "T" then do
               call domsg "==>Error :" ,
                          "The value of the format parameter" ,
                          "must be X or T."
               exit_rc = 12
               signal done
            end /* end if output <> "X" & output <> "T"  */
         end /* end else do  */

        /* --------------------------------------------------------- *
         * Test that the cobol file already exists                   *
         *      or that the cobol dd is allocated                    *
         *      or that the file can be opened                       *
         * --------------------------------------------------------- */
         select
            when rexx_os <> "TSO" then do
               if stream(cobol, 'C', 'OPEN READ') <> 'READY:' then do
                  call domsg "==>Error :" ,
                             "the cobol file" cobol "can not be opened."
                  exit_rc = 12
                  signal done
               end /* end if stream(cobol, 'C', 'OPEN READ') <> 'READY:' */
            end /* end when rexx_os <> "TSO" */
            when translate(left(cobol,3)) = "DD:" then do
               parse value cobol with "DD:" cobdd
               x = listdsi(cobdd "file")
               if x > 0 then do
                  call domsg "==>Error :" ,
                             "the cobol ddname" cobdd "can not be found."
                  exit_rc = 12
                  signal done
               end /* end if x > 0  */
            end /* end when translate(left(cobol,3)) = "DD:" */
            when "OK" <> sysdsn(cobol) then do
               call domsg "==>Error : the cobol dataset" cobol
               call domsg sysdsn(cobol)
               exit_rc = 12
               signal done
            end /* end when "OK" <> sysdsn(cobol) */
            otherwise
         end /* end select */

        /* --------------------------------------------------------- *
         * Test that the txt file already exists                     *
         *      or that the txt dd is allocated                      *
         *      or that the file can be opened                       *
         * --------------------------------------------------------- */
         select
            when rexx_os <> "TSO" then do
               if output = "X" then rc = stream(txt, 'C', 'OPEN READ')
               else rc = stream(txt, 'C', 'OPEN WRITE')
               if rc  <> 'READY:' then do
                  call domsg "==>Error :" ,
                             "the txt file" txt "can not be opened."
                  exit_rc = 12
                  signal done
               end /* end if rc  <> 'READY:'  */
            end /* end when rexx_os <> "TSO" */
            when txt = null then do
               call domsg "==>Error :" ,
                          "The txt file was not specified."
               exit_rc = 12
               signal done
            end /* end when txt = null */
            when translate(left(txt,3)) = "DD:" then do
               parse value txt with "DD:" txtdd
               x = listdsi(txtdd "file")
               if x > 0 then do
                  call domsg "==>Error :" ,
                             "The txt ddname" txtdd "can not be found."
                  exit_rc = 12
                  signal done
               end /* end if x > 0 */
            end /* end when translate(left(txt,3)) = "DD:" */
            when "OK" <> sysdsn(txt) & output = "X" then do
               call domsg "==>Error : the txt file" txt
               call domsg sysdsn(txt)
               exit_rc = 12
               signal done
            end /* end when "OK" <> sysdsn(txt) & output = "X" */
            when "OK" = sysdsn(txt) & output = "T" then do
               call domsg "==>Error :" ,
                          "The txt file currently exists." ,
                          "Please specify a file name to be created."
               exit_rc = 12
               signal done
            end /* end when "OK" = sysdsn(txt) & output = "T"  */
            otherwise
         end /* end select */

        /* --------------------------------------------------------- *
         * Test for a specified XML file                             *
         *      or that the XML dd is allocated                      *
         *      or that the file can be opened                       *
         * --------------------------------------------------------- */
         select
           when rexx_os <> "TSO" then do
               if output = "X" then rc = stream(xml, 'C', 'OPEN WRITE')
               else rc = stream(xml, 'C', 'OPEN READ')
               if rc  <> 'READY:' then do
                  call domsg "==>Error :" ,
                             "the XML file" xml "can not be opened."
                  exit_rc = 12
                  signal done
               end /* end if rc  <> 'READY:' */
            end /* end when rexx_os <> "TSO" */
            when xml = null then do
               call domsg "==>Error : the xml file was not specified."
               exit_rc = 12
               signal done
            end /* end when xml = null */
            when translate(left(xml,3)) = "DD:" then do
               parse value xml with "DD:" xmldd
               x = listdsi(xmldd "file")
               if x > 0 then do
                  call domsg "==>Error : " ,
                             "the xml ddname" xmldd "can not be found."
                  exit_rc = 12
                  signal done
               end /* end if x > 0 */
            end /* end when translate(left(xml,3)) = "DD:" */
            when "OK" <> sysdsn(xml) & output = "T" then do
               call domsg "==>Error : the xml file" xml
               call domsg sysdsn(xml)
               exit_rc = 12
               signal done
            end /* end when "OK" <> sysdsn(xml) & output = "T" */
            when "OK" = sysdsn(xml) & output = "X" then do
               call domsg "==>Error :" ,
                          "The xml file currently exists."
               call domsg "Please specify a file name to be created."
               exit_rc = 12
               signal done
            end /* end when "OK" = sysdsn(xml) & output = "X" */
            otherwise
         end /* end select */

        /* --------------------------------------------------------- *
         * Test that the dtd parameter is only present during txt    *
         *           to XML conversion                               *
         *      or that the dtd file already exists                  *
         *      or that the dtd dd is allocated                      *
         *      or that the file can be opened                       *
         * --------------------------------------------------------- */
          if output = "X" then do
             select
               when length(dtd) <= 0 then nop
               when translate(dtd) = "INTERNAL" then dtd = "INTERNAL"
               when rexx_os <> "TSO" then do
                  rc = stream(dtd, 'C', 'OPEN WRITE')
                  if rc  <> 'READY:' then do
                     call domsg "==>Error :" ,
                                "the dtd file" dtd "can not be opened."
                     exit_rc = 12
                     signal done
                  end /* end if rc  <> 'READY:'  */
               end /* end when rexx_os <> "TSO" */
               when translate(left(dtd,3)) = "DD:" then do
                  parse value dtd with "DD:" dtddd
                  x = listdsi(dtddd "file")
                  if x > 0 then do
                     call domsg "==>Error :" ,
                                "The dtd ddname" dtddd "can not be found."
                     exit_rc = 12
                     signal done
                  end /* end if x > 0 */
               end /* end when translate(left(dtd,3)) = "DD:" */
               when "OK" = sysdsn(dtd) then do
                  call domsg "==>Error :" ,
                             "The dtd file currently exists."
                  call domsg "Please specify a file name to be created."
                  exit_rc = 12
                  signal done
               end /* end when "OK" = sysdsn(dtd) */
               otherwise
            end /* end select */
         end /* end if output = "X" */
         else if length(dtd) > 0 then do
            call domsg "==>Error :" ,
                       "The DTD parameter may only be specified" ,
                       "for a text to XML conversion."
            exit_rc = 12
            signal done
         end /* end else if length(dtd) > 0 */

        /* --------------------------------------------------------- *
         * Alloc the txt, DTD and XML files if needed                *
         * --------------------------------------------------------- */
         if rexx_os = "TSO" then do
            if txtdd = null & output = "X" then do
               "Alloc f("textdd") shr ds("txt") reuse"
            end /* end if txtdd = null & output = "X" */
            if xmldd = null & output = "T" then do
               "Alloc f("xml2dd") shr ds("xml") reuse"
            end /* end if xmldd = null & output = "T" */
         end /* end if rexx_os = "TSO" */

        /* --------------------------------------------------------- *
         * Read the COBOL file into cob.                             *
         * --------------------------------------------------------- */
         select
            when rexx_os <> "TSO" then do
               i = 0
               do while lines(cobol) > 0
                  i = i + 1
                  cob.i = linein(cobol, , 1)
               end /* end do while lines(cobol) > 0 */
               cob.0 = i
               rc = stream(cobol, 'C', 'CLOSE')
            end /* end when rexx_os <> "TSO" */
            when cobdd = null then do
               "Alloc f("dd") shr ds("cobol") reuse"
               "Execio * diskr" dd "(finis stem cob."
               "Free f("dd")"
            end /* end when cobdd = null */
            when cobdd <> null then "Execio * diskr" cobdd "(finis stem cob."
            otherwise
         end /* end select */

        /* --------------------------------------------------------- *
         * "Clean" the COBOL file                                    *
         * --------------------------------------------------------- */
         j = 0
         nb_line = 0
         do i = 1 to cob.0

        /* skip comment lines */
            if substr(cob.i,7,1) = "*" then iterate
            if substr(cob.i,7,1) = "/" then iterate

        /* skip blank lines */
            if length(strip(substr(cob.i,8,65))) <= 0 then iterate
            j = j + 1

        /* Take only the interesting part of the line without line
           numbers */
            copybook.j = substr(cob.i,7,66)

        /* test to see if line is continuated on next line */
            k = i + 1
            do forever
               if k > cob.0 then leave

        /* leave the loop if new level is found */
               if datatype(word(substr(cob.k,8,65),1)) = "NUM" then leave

        /* if next line is not a comment, concatenate previous line
           with current line */
               if substr(cob.k,7,1) <> "*" & ,
                  substr(cob.k,7,1) <> "/" then do
                  copybook.j = strip(copybook.j,"t") ,
                               strip(substr(cob.k,8,65))
                  i = i + 1
               end /* end if substr(cob.k,7,1) <> "*" & */
               k = k + 1
            end /* end do forever */
            copybook.j = translate(copybook.j)

        /* replace PICTURE clause with PIC clause */
            if wordpos("PICTURE",copybook.j) > 0 then do
               copybook.j = ,
               overlay("     PIC ",copybook.j,pos(" PICTURE ",copybook.j))
            end /* end if wordpos("PICTURE",copybook.j) > 0 */

        /* ignore IS in PICTURE clause */
            if word(copybook.j,wordpos("PIC",copybook.j)+1) = "IS" then do
               copybook.j = overlay("    ",copybook.j,pos(" IS ",copybook.j))
            end /* end if word(copybook.j,wordpos("PIC",copybook.j)+1) ... */

        /* ignore IS in VALUE clause */
            if word(copybook.j,wordpos("VALUE",copybook.j)+1) ,
               = "IS" then do
               copybook.j = overlay("    ",copybook.j,pos(" IS ",copybook.j))
            end /* end if word(copybook.j,wordpos("VALUE",copybook.j)+1) , */

        /* ignore IS in USAGE clause */
            if word(copybook.j,wordpos("USAGE",copybook.j)+1) = "IS" then do
               copybook.j = overlay("    ",copybook.j,pos(" IS ",copybook.j))
            end /* end if word(copybook.j,wordpos("USAGE",copybook.j)+1) , */

        /* ignore USAGE clause */
            if wordpos("USAGE",copybook.j) > 0 then do
               copybook.j = ,
                  overlay("       ",copybook.j,pos(" USAGE ",copybook.j))
            end /* end if wordpos("USAGE",copybook.j) > 0 */

        /* ignore IS in SIGN clause */
            if word(copybook.j,wordpos("SIGN",copybook.j)+1) = "IS" then do
               copybook.j = overlay("    ",copybook.j, ,
               pos(" IS ",copybook.j))
            end /* end if word(copybook.j,wordpos("SIGN",copybook.j)+1) , */

        /* ignore SIGN clause */
            if wordpos("SIGN",copybook.j) > 0 then do
               copybook.j = overlay("      ",copybook.j, ,
                                    pos(" SIGN ",copybook.j))
            end /* end if wordpos("SIGN",copybook.j) > 0 */

        /* ignore NATIVE clause */
            if wordpos("NATIVE",copybook.j) > 0 then do
               copybook.j = overlay("        ",copybook.j, ,
                                    pos(" NATIVE ",copybook.j))
            end /* end if wordpos("NATIVE",copybook.j) > 0 */

        /* ignore DISPLAY clause */
            if wordpos("DISPLAY",copybook.j) > 0 then do
               copybook.j = overlay("         ",copybook.j, ,
                                    pos(" DISPLAY ",copybook.j))
            end /* end if wordpos("DISPLAY",copybook.j) > 0 */

        /* suppress final dot */
            copybook.j = strip(copybook.j,"t")
            if substr(copybook.j,length(copybook.j),1) = "." then do
               copybook.j = overlay(" ",copybook.j,length(copybook.j))
            end /* end if substr(copybook.j,length(copybook.j),1) = "." */

        /* replace 9(4) with 9999 in PIC clause */
            if pos("(",copybook.j) > 0 then do
               temp = word(copybook.j,wordpos("PIC",copybook.j)+1)
               clause = temp
               do k = 2 to length(temp)

        /* find "(" and ")" */
                  if substr(temp,k,1) = "(" then start_pos=k
                  if substr(temp,k,1) = ")" then do
                     end_pos = k

        /* find symbol and length */
                     lengt = substr(temp,start_pos+1,end_pos-start_pos-1)
                     symbole = substr(temp,start_pos-1,1)
                     temp = substr(temp,1,start_pos-1) || ,
                            copies(symbole,lengt-1) || ,
                            substr(temp,end_pos+1)
                  end /* end if substr(temp,k,1) = ")" */
               end /* end do k = 2 to length(temp) */

        /* replace old picture symbol with new */
               copybook.j = substr(copybook.j,1,pos(clause,copybook.j)-1) || ,
                 temp || ,
                 substr(copybook.j,pos(clause,copybook.j)+length(clause))
            end /* end if pos("(",copybook.j) > 0 */
         end /* end do i = 1 to cob.0 */
         nb_line = j
         drop cob. symbole temp lengt clause end_pos

        /* --------------------------------------------------------- *
         * Analyze the cobol copy book                               *
         * --------------------------------------------------------- */
         cobol_length = 0       /* total computed COBOL length of copybook */
         nb_items = 0           /* number of COBOL items */
         occurs_group_level = 0 /* level of an array group item */
         signed_group_level = 0 /* level of an signed group item */
         start_pos.1 = 1
         do i = 1 to nb_line

        /* stop if REDEFINES clause is found */
            if wordpos("REDEFINES", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "REDEFINES clause is not supported."
               exit_rc = 12
               signal done
            end /* end if wordpos("REDEFINES", copybook.i) > 0 */

        /* stop if POINTER clause is found */
            if wordpos("POINTER", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "POINTER clause is not supported."
               exit_rc = 12
               signal done
            end /* end if wordpos("POINTER", copybook.i) > 0 */

        /* stop if PROCEDURE-POINTER clause is found */
            if wordpos("PROCEDURE-POINTER", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "PROCEDURE-POINTER clause is not supported."
               exit_rc = 12
               signal done
            end /* end if wordpos("PROCEDURE-POINTER", copybook.i) > 0 */

        /* stop if FUNCTION-POINTER clause is found */
            if wordpos("FUNCTION-POINTER", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "FUNCTION-POINTER clause is not supported."
               exit_rc = 12
               signal done
            end /* end if wordpos("FUNCTION-POINTER", copybook.i) > 0 */

        /* stop if OBJECT REFERENCE clause is found */
             if wordpos("REFERENCE", copybook.i) = ,
                wordpos("OBJECT",copybook.i) + 1  then do
                call domsg "==>Error :" ,
                           "in the COBOL copybook," ,
                           "OBJECT REFERENCE clause is not supported."
                exit_rc = 12
                signal done
            end /* end if wordpos(" REFERENCE", copybook.i) =  */

        /* stop if one of COMP-1, COMP-2, COMP-5 clauses is found */
            if wordpos("COMPUTATIONAL-1", copybook.i) > 0  | ,
               wordpos("COMP-1", (copybook.i)) > 0 | ,
               wordpos("COMPUTATIONAL-2", copybook.i) > 0  | ,
               wordpos("COMP-2", copybook.i) > 0 | ,
               wordpos("COMPUTATIONAL-5", copybook.i) > 0  | ,
               wordpos("COMP-5", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "COMP-1, COMP-2, COMP-5",
                          "clauses are not supported."
               exit_rc = 12
               signal done
            end /* end if wordpos("COMPUTATIONAL-1", copybook.i) > 0  | , */

        /* stop if INDEX clause is found */
            if wordpos("INDEX", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "INDEX clause is not supported."
               exit_rc = 12
               signal done
            end /* end if wordpos("INDEX", copybook.i) > 0 */

        /* stop if DISPLAY-1 clause is found */
            if wordpos("DISPLAY-1", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "DISPLAY-1 clause is not supported."
               exit_rc = 12
               signal done
            end /* end if wordpos("DISPLAY-1", copybook.i) > 0 */

        /* stop if NATIONAL clause is found */
            if wordpos("NATIONAL", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "NATIONAL clause is not supported".
               exit_rc = 12
               signal done
            end /* end if wordpos("NATIONAL", copybook.i) > 0 */

        /* stop if SYNC clause is found */
             if wordpos("SYNC", copybook.i) > 0 | ,
                wordpos("SYNCHRONIZED", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "SYNCHRONYZED clause is not supported".
               exit_rc = 12
               signal done
            end /* end if wordpos("SYNC", copybook.i) > 0 */

        /* stop if DEPENDING clause is found */
            if wordpos("DEPENDING", copybook.i) > 0 then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "DEPENDING clause is not supported".
               exit_rc = 12
               signal done
            end /* end if wordpos("DEPENDING", copybook.i) > 0 */

        /* stop if level is not numeric */
            if datatype(word(copybook.i,1)) <> "NUM" then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "level" word(copybook.1,1) " is not numeric."
               exit_rc = 12
               signal done
            end /* end if datatype(word(copybook.i,1)) <> "NUM" */

        /* ignore level 77 or 88 or 66 items */
            if word(copybook.i,1) = "66" | ,
               word(copybook.i,1) = "77" | ,
               word(copybook.i,1) = "88" then do
               call domsg "==>Warning :" ,
                          "in the COBOL copybook," ,
                          "level 66, 77, 88 items are ignored."
               exit_rc = 4
               iterate
            end /* end if word(copybook.i,1) = "66" | , */

        /* stop if level is greater than 50 */
            if word(copybook.i,1) > "49" then do
               call domsg "==>Error :" ,
                          "in the COBOL copybook," ,
                          "level (" level ,
                          ") greater than 49 are not allowed" ,
                          "in COBOL."
               exit_rc = 12
               signal done
            end /* end if word(copybook.i,1) > "49" */

        /* if an OCCURS clause was detected for a group item and if we have
           reached the end of the group item then ... */
            if occurs_group_level > 0 & ,
               word(copybook.i,1) <= occurs_group_level then do

        /* go backward to the start of the group ... */
               do j = nb_items to 1 by -1
                  if level.j <= occurs_group_level then leave
               end /* end do j = nb_items to 1 by -1 */
               l = nb_items

        /* and repeat it according to the OCCURS clause */
               do occurs.j - 1
                  do k = j to l
                     nb_items = nb_items + 1
                     m = nb_items + 1
                     name.nb_items = name.k
                     type.nb_items = type.k
                     occurs.nb_items = occurs.j
                     default.nb_items = default.k
                     length.nb_items = length.k
                     signed.nb_items = signed.k
                     sign_pos.nb_items = sign_pos.k
                     level.nb_items = level.k
                     start_pos.m = start_pos.nb_items + length.nb_items
                     cobol_length = cobol_length + length.nb_items
                  end /* end do k = j to l */
               end /* end do occurs.j - 1 */
               occurs_group_level = 0
            end /* end if occurs_group_level > 0 & , */

        /* count number of items */
            nb_items = nb_items + 1

        /* find name and level of item */
            level.nb_items = word(copybook.i,1)
            name.nb_items = word(copybook.i,2)

        /* find sign characteristics of item */
            signed.nb_items = ""
            sign_pos.nb_items = ""
            if wordpos("PIC",copybook.i) > 0 then do
               temp = word(copybook.i,wordpos("PIC",copybook.i) + 1)
               if left(temp,1) = "S" then do
                  signed.nb_items = "Y"
                  if signed_group_item = "Y" then ,
                     sign_pos.nb_items = sign_pos_group_item
                  if wordpos("SEPARATE",copybook.i) > 0 then do
                     if wordpos("LEADING",copybook.i) > 0 then ,
                        sign_pos.nb_items = "LS"
                     else sign_pos.nb_items = "TS"
                  end /* end if wordpos("SEPARATE",copybook.i) > 0 */
                  else do
                     if wordpos("LEADING",copybook.i) > 0 then ,
                        sign_pos.nb_items = "L"
                     else if sign_pos.nb_items = "" then ,
                        sign_pos.nb_items = "T"
                  end /* end else do */
               end /* end if left(temp,1) = "S" */
               else signed.nb_items = "N"
            end /* end if wordpos("PIC",copybook.i) > 0 */

        /* check if sign applies to a group of items */
            else do
               if wordpos("LEADING",copybook.i) > 0 | ,
                  wordpos("TRAILING",copybook.i) > 0 then do
                  signed_group_item = "Y"
                  signed_group_level = level.i
                  if wordpos("SEPARATE",copybook.i) > 0 then do
                     if wordpos("LEADING",copybook.i) > 0 then ,
                        sign_pos_group_item = "LS"
                     else sign_pos_group_item = "TS"
                  end /* end if wordpos("SEPARATE",copybook.i) > 0 */
                  else do
                     if wordpos("LEADING",copybook.i) > 0 then ,
                        sign_pos_group_item = "L"
                     else sign_pos_group_item = "T"
                  end /* end else do */
                  signed.nb_items = "Y"
                  sign_pos.nb_items = sign_pos_group_item
               end /* end if wordpos("LEADING",copybook.i) > 0 | ,  */
               else if level.i <= signed_group_level then do
                  signed_group_level = 0
                  drop signed_group_item sign_pos_group_item
               end /* end else if level.i <= signed_group_level */
            end /* end else do */
            drop temp

        /* find length of item */
            if wordpos("PIC",copybook.i) > 0 then do
               temp = word(copybook.i,wordpos("PIC",copybook.i) + 1)
               if left(temp,1) = "S" then temp = substr(temp,2)
               length.nb_items = length(temp)
               if pos("V",temp) > 0 then length.nb_items = length.nb_items - 1
               if wordpos("SEPARATE",copybook.i) > 0 |,
                  sign_pos.nb_items = "LS" | ,
                  sign_pos.nb_items = "TS" then ,
                  length.nb_items = length.nb_items + 1
               else if wordpos("COMP-3",copybook.i) > 0 | ,
                       wordpos("COMPUTATIONAL-3",copybook.i) > 0 | ,
                       wordpos("PACKED-DECIMAL",copybook.i) > 0 then do
                       if length(temp) = 2 * (length(temp) % 2) then ,
                          length.nb_items  = (length.nb_items + 2) / 2
                       else length.nb_items  = (length.nb_items + 1) / 2
               end /* end else if wordpos("COMP-3",copybook.i) > 0 | , */
               else if wordpos("COMP-4",copybook.i) > 0 | ,
                       wordpos("COMPUTATIONAL-4",copybook.i) > 0 | ,
                       wordpos("COMPUTATIONAL",copybook.i) > 0 | ,
                       wordpos("COMP",copybook.i) > 0 | ,
                       wordpos("BINARY",copybook.i) > 0 then do
                       select
                          when length(temp) <= 4 then length.nb_items = 2
                          when length(temp) <= 9 then length.nb_items = 4
                          when length(temp) <= 18 then length.nb_items = 8
                          otherwise do
                             call domsg "==>Error :" ,
                                  "in the COBOL copybook, a binary item",
                                   name.nb_items ,
                                  "has a PICTURE length greater than 18."
                             exit_rc = 12
                             signal done
                          end /* end otherwise do */
                       end /* end select */
               end /* end else if wordpos("COMP-4",copybook.i) > 0 | , */
            end /* end if wordpos("PIC",copybook.i) > 0 */
            else length.nb_items = 0
            drop temp

        /* find type of item */
            if wordpos("PIC",copybook.i) > 0 then do
               j = word(copybook.i,wordpos("PIC",copybook.i)+1)
               select
                  when wordpos("COMP-3",copybook.i) > 0 then ,
                     type.nb_items = "PACK"
                  when wordpos("COMPUTATIONAL-3",copybook.i) > 0 then ,
                     type.nb_items = "PACK"
                  when wordpos("PACKED-DECIMAL",copybook.i) > 0 then ,
                     type.nb_items = "PACK"
                  when wordpos("COMP-4",copybook.i) > 0 then ,
                     type.nb_items = "BIN"
                  when wordpos("COMPUTATIONAL-4",copybook.i) > 0 then ,
                     type.nb_items = "BIN"
                  when wordpos("COMP",copybook.i) > 0 then ,
                     type.nb_items = "BIN"
                  when wordpos("COMPUTATIONAL",copybook.i) > 0 then ,
                     type.nb_items = "BIN"
                  when wordpos("BINARY",copybook.i) > 0 then ,
                     type.nb_items = "BIN"
                  when pos("P",j) > 0 then do
                     call domsg "==>Error :" ,
                                "in the COBOL copybook," ,
                                "the scaling postion character P" ,
                                "is not supported."
                     exit_rc = 12
                     signal done
                  end /* end when pos("P",j) > 0 */
                  when pos("9",j)>0 & pos("X",j) = 0 then type.nb_items = "NUM"
                  when pos("0",j)>0 & pos("X",j) = 0 then type.nb_items = "NUM"
                  when pos("Z",j)>0 & pos("X",j) = 0 then type.nb_items = "NUM"
                  when pos("G",j) > 0 then do
                     call domsg "==>Error :" ,
                                "in the COBOL copybook," ,
                                "DBCS symbols are not supported."
                     exit_rc = 12
                     signal done
                  end /* end when pos("G",j) > 0 */
                  when pos("N",j) > 0 then do
                     call domsg "==>Error :" ,
                                "in the COBOL copybook," ,
                                "DBCS or national symbols are not supported."
                     exit_rc = 12
                     signal done
                  end /* end when pos("N",j) > 0 */
                  otherwise type.nb_items = "CHAR"
               end /* end select */
            end /* end if wordpos("PIC",copybook.i) > 0 */
            else type.nb_items = "GROUP"
            if type.nb_items = "PACK" | ,
               type.nb_items = "BIN" | ,
               signed.nb_items = "" then ,
               sign_pos.nb_items = ""
            if type.nb_items = "CHAR" then do
               signed.nb_items = ""
               sign_pos.nb_items = ""
            end /* end if type.nb_items = "CHAR" */

        /* find VALUE clause and save the default value */
            if wordpos("VALUE",copybook.i) > 0 then do
               start_pos = 0
               end_pos = 0
               quote = 0
               apost = 0
               k = pos(" VALUE ",copybook.i) + length(" VALUE ")

        /* Alphanumeric value */
               do l = k to length(copybook.i)
                  if substr(copybook.i,l,1) = '"' | ,
                     substr(copybook.i,l,1) = "'" then do
                     if start_pos = 0 then do
                        start_pos = l + 1
                        if substr(copybook.i,l,1) = "'" then apost = 1
                        else quote = 1
                     end /* end if start_pos = 0 */
                     else if substr(copybook.i,l,2) <> '""' & ,
                             substr(copybook.i,l,2) <> "''" ,
                             then end_pos = l - 1
                  end /* end if substr(copybook.i,l,1) = '"' | , */

        /* Numeric value */
                  else if substr(copybook.i,l,1) <> " " then do
                     if quote = 0 & apost = 0 then do
                        if start_pos = 0 then start_pos = l
                        else if substr(copybook.i,l,1) = " " then end_pos = l
                     end /* end if quote = 0 & apost = 0 */
                  end /* end if substr(copybook.i,l,1) <> " " */
               end /* end do l = k to length(copybook.i) */
               if end_pos = 0 then end_pos = length(copybook.i)
               j = substr(copybook.i,start_pos,end_pos-start_pos+1)

        /* Literal value */
               select
                  when j = "LOW-VALUES" | j = "LOW-VALUE" then ,
                     default.nb_items = copies("00"x,length.nb_items)
                  when j = "HIGH-VALUES" | j = "HIGH-VALUE" then ,
                     default.nb_items = copies("FF"x,length.nb_items)
                  when j = "ZEROES" | j = "ZERO" | j = "ZEROS" then do
                     select
                        when type.nb_items = "BIN" then default.nb_items = ,
                           txt2bin(0,length.nb_items,"N")
                        when type.nb_items = "PACK" then default.nb_items = ,
                           txt2pack(0,length.nb_items,"N")
                        when type.nb_items = "NUM" then default.nb_items = ,
                           txt2num(0,length.nb_items,"N","")
                        otherwise ,
                           default.nb_items = copies("0",length.nb_items)
                     end /* end select */
                  end /* end when j = "ZEROES" | j = "ZERO" | j = "ZEROS" */
                  when j = "SPACES" | j = "SPACE" then ,
                     default.nb_items = copies(" ",length.nb_items)
                  when j = "NULL" then do
                     call domsg "==>Error :" ,
                                "in the COBOL copybook," ,
                                "NULL clause is not supported. "
                     exit_rc = 12
                     signal done
                  end /* end when j = "NULL" */
                  when j = "QUOTE" | j = "QUOTES" then do
                     call domsg "==>Error :" ,
                                "in the COBOL copybook," ,
                                "QUOTE clause is not supported. "
                     exit_rc = 12
                     signal done
                  end /* end when j = "QUOTE" | j = "QUOTES" */
                  when word(j,1) = "ALL" then do
                     k = ""
                     parse var j "ALL" k
                     k = strip(k)
                     if substr(k,1,1) = "'" | substr(k,1,1) = '"' then ,
                        k = substr(k,2)
                     default.nb_items = copies(k,length.nb_items)
                  end /* end when j = "ALL" */
                  otherwise do
                     temp = substr(copybook.i,start_pos,end_pos-start_pos+1)
                     select
                        when type.nb_items = "BIN" then default.nb_items = ,
                           txt2bin(temp,length.nb_items,signed.nb_items)
                        when type.nb_items = "PACK" then default.nb_items = ,
                           txt2pack(temp,length.nb_items,signed.nb_items)
                        when type.nb_items = "NUM" then default.nb_items = ,
                           txt2num(temp,length.nb_items,signed.nb_items, ,
                                   sign_pos.nb_items)
                        otherwise default.nb_items = temp
                     end /* end select */
                     drop temp
                  end /* end otherwise do */
               end /* end select */

        /* Suppress double quote or double apost */
               if (quote > 0 | apost > 0) then do
                  if (pos('""',default.nb_items) > 0 | ,
                     pos("''",default.nb_items) > 0 ) then do
                     temp = ""
                     do j = 1 to length(default.nb_items)
                        if substr(default.nb_items,j,2) = "''" & ,
                           apost > 0 then do
                           temp = temp || "'"
                           j = j + 1
                        end /* end if substr(default.nb_items,j,2) = "''" & */
                        else if substr(default.nb_items,j,2) = '""' &,
                             quote > 0 then do
                                temp = temp || '"'
                                j = j + 1
                             end /* end if substr(default.nb_items,j,2)='""'*/
                             else temp = temp || substr(default.nb_items,j,1)
                     end /* end if (pos('""',default.nb_items) > 0 | , */
                     default.nb_items = temp
                     drop temp
                  end /* end if (pos('""',default.nb_items) > 0 | , */
               end /* end if (quote > 0 | apost > 0) */
            end /* end if wordpos("VALUE",copybook.i) > 0 */

         /* No default values : initialize with zeroes and spaces */
            else do
               select
                  when type.nb_items = "BIN" then default.nb_items = ,
                     txt2bin(0,length.nb_items,"N")
                  when type.nb_items = "PACK" then default.nb_items = ,
                     txt2pack(0,length.nb_items,"N")
                  when type.nb_items = "NUM" then default.nb_items = ,
                     txt2num(0,length.nb_items,"N","")
                  otherwise default.nb_items = copies(" ",length.nb_items)
               end /* end select */
            end /* end else do */
            drop apost quote temp start_pos end_pos

        /* find OCCURS clause */
            if wordpos("OCCURS",copybook.i) > 0 then occurs.nb_items = ,
               word(copybook.i,wordpos("OCCURS",copybook.i) + 1)
            else occurs.nb_items = 1

        /* compute starting position of next item */
            k = nb_items + 1
            start_pos.k = start_pos.nb_items + length.nb_items

        /* handle OCCURS clause ...  */
            if occurs.nb_items > 1 then do

        /* ... for elementary items ... */
               if length.nb_items > 0 then do
                  cobol_length = cobol_length + length.nb_items
                  j = nb_items
                  do occurs.j - 1
                     nb_items = nb_items + 1
                     k = nb_items + 1
                     name.nb_items = name.j
                     type.nb_items = type.j
                     occurs.nb_items = occurs.j
                     signed.nb_items = signed.j
                     sign_pos.nb_items = sign_pos.j
                     default.nb_items = default.j
                     length.nb_items = length.j
                     level.nb_items = level.j
                     start_pos.k = start_pos.nb_items + length.nb_items
                     cobol_length = cobol_length + length.nb_items
                  end /* end do occurs.j - 1 */
               end /* end if length.nb_items > 0 */

        /* ... and for group items. */
               else do
                  if occurs_group_level <= 0 then do
                     occurs_group_level = level.nb_items
                  end /* end if occurs_group_level <= 0 */
               end /* end else do */
            end /* end if occurs.nb_items > 1 */

        /* compute total length of file */
            else cobol_length = cobol_length + length.nb_items

         end /* end do i = 1 to nb_line */

        /* if an OCCURS clause was detected for a group item and if we have
           reached the end of the copybook then ... */
         if occurs_group_level > 0 & i >= nb_line then do

        /* go backward to the start of the group ... */
            do j = nb_items to 1 by -1
               if level.j <= occurs_group_level then leave
            end /* end do j = nb_items to 1 by -1 */
            l = nb_items

        /* and repeat it according to the OCCURS clause */
            do occurs.j - 1
               do k = j to l
                  nb_items = nb_items + 1
                  m = nb_items + 1
                  name.nb_items = name.k
                  type.nb_items = type.k
                  occurs.nb_items = occurs.j
                  default.nb_items = default.k
                  signed.nb_items = signed.k
                  sign_pos.nb_items = sign_pos.k
                  length.nb_items = length.k
                  level.nb_items = level.k
                  start_pos.m = start_pos.nb_items + length.nb_items
                  cobol_length = cobol_length + length.nb_items
               end /* end do k = j to l */
            end /* end do occurs.j - 1 */
            occurs_group_level = 0
         end /* end if occurs_group_level > 0 & i >= nb_line */

         /* --------------------------------------------------------- *
         * If computed length equals zero, exit                      *
         * --------------------------------------------------------- */
         if cobol_length = 0 then do
            call domsg "==>Error :" ,
                       "in the COBOL copybook," ,
                       "The total length of the COBOL items is zero"
            exit_rc = 12
            signal done
         end /* end if cobol_length = 0 */

        /* --------------------------------------------------------- *
         * Renumber the COBOL level so that identation of XML        *
         * elements will smoother and independent of copybook        *
         * absolute level                                            *
         * --------------------------------------------------------- */
        /* firstly copy the level array and bubble sort it */
         do i = 1 to nb_items
            l.i = level.i
         end /* end do i = 1 to nb_items */
         j = nb_items
         do forever
            inversion = 0
            do i = 1 to j - 1
               k = i + 1
               if l.i > l.k then do
                  a = l.k
                  l.k = l.i
                  l.i = a
                  inversion = 1
               end /* end if l.i > l.k then do */
            end /* end do i = 1 to j - 1 */
            j = j - 1
            if inversion <= 0 then leave
         end /* end do forever */

        /* Secondly, suppress non-unique levels */
         k = 1
         m.k = l.1
         do i = 1 to nb_items - 1
            j = i + 1
            if l.j > l.i then do
               k = k + 1
               m.k = l.j
            end /* end if l.j > l.i */
         end /* end do i = 1 to nb_items - 1 */

        /* thirdly, renumber levels */
         do i = 1 to nb_items
            do j = 1 to k
               if level.i = m.j then do
                  level.i = j
                  leave
               end /* end if level.i = m.j */
            end /* end do j = 1 to k */
         end /* end do i = 1 to nb_items */
         drop l. m. inversion a

        /* --------------------------------------------------------- *
         * Now call the do_XML or the do_txt Conversion Routine      *
         * according to the value of the output parameter            *
         * --------------------------------------------------------- */
         if output = "X" then call do_XML
         else call do_TXT

        /* --------------------------------------------------------- *
         * Now Report What We Did                                    *
         * --------------------------------------------------------- */
         if confirm >= 1 then do
            call domsg    " "
            if txtdd = null then
               call domsg "Txt File:          " txt
            else
               call domsg "Txt DD:            " txtdd
            if cobdd = null then
               call domsg "Cobol File:        " cobol
            else
               call domsg "Cobol DD:          " cobdd
            if xmldd = null then
               call domsg "XML File:          " xml
            else
               call domsg "XML DD:            " xmldd
            if output = "X" then ,
               call domsg "Output data format: XML"
            else ,
               call domsg "Output data format: TXT"
            call domsg    "Prefix:            " prefix
            if dtddd = null then
               call domsg "DTD File:          " dtd
            else
               call domsg "DTD DD:            " dtddd
            call domsg    " "
            call domsg    "Text records:      " nb_txt_rec ,
                          "processed in" substr(time("E"),1,6) "seconds"
            call domsg    " "
            header.1 = "+-"
            header.1 = insert("-",header.1,length(header.1),5,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),30,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),5,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),4,"-")
            header.1 = insert("-]-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),5,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),6,"-")
            header.1 = insert("-+-",header.1,length(header.1),3)
            header.1 = insert("-",header.1,length(header.1),13,"-")
            header.1 = insert("-+",header.1,length(header.1),2)
            header.2 = "] "
            header.2 = insert("Level",header.2,length(header.2),5)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Name",header.2,length(header.2),30)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Type",header.2,length(header.2),5)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Sign",header.2,length(header.2),4)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Start",header.2,length(header.2),5)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Length",header.2,length(header.2),6)
            header.2 = insert(" ] ",header.2,length(header.2),3)
            header.2 = insert("Default value",header.2,length(header.2),13)
            header.2 = insert(" ]",header.2,length(header.2),2)
            if nb_items > 0 then do
               call domsg    copies("=",80)
               call domsg    " "
               call domsg    center("COBOL copybook analysis",80)
               call domsg    " "
               call domsg    header.1
               call domsg    header.2
               call domsg    header.1
               do i = 1 to nb_items
                  line = "] "
                  line = insert(level.i,line,length(line),5)
                  line = insert(" ] ",line,length(line),3)
                  if length(copies(" ",level.i-1) || name.i) <= 30 then ,
                     line = insert(copies(" ",level.i-1) || ,
                                   name.i,line,length(line),30)
                  else line = insert(copies(" ",level.i-1) || ,
                       substr(name.i,1,22) || "...",line,length(line),30)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(type.i,line,length(line),5)
                  line = insert(" ] ",line,length(line),3)
                  if sign_pos.i <> "" then ,
                     line = insert(sign_pos.i,line,length(line),4)
                  else line = insert(signed.i,line,length(line),4)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(start_pos.i,line,length(line),5)
                  line = insert(" ] ",line,length(line),3)
                  line = insert(length.i,line,length(line),6)
                  line = insert(" ] ",line,length(line),3)
                  select
                     when type.i = "BIN" then ,
                        line = insert(bin2txt(default.i,length.i,signed.i), ,
                                      line,length(line),13)
                     when type.i = "PACK" then ,
                        line = insert(pack2txt(default.i), ,
                                      line,length(line),13)
                     when type.i = "NUM" then ,
                        line = insert(num2txt(default.i,signed.i,sign_pos.i), ,
                                      line,length(line),13)
                     when type.i = "CHAR" & ,
                        default.i = copies("00"x,length.i) then ,
                        line = insert("LOW-VALUES",line,length(line),13)
                     when type.i = "CHAR" & ,
                        default.i = copies("FF"x,length.i) then ,
                        line = insert("HIGH-VALUES",line,length(line),13)
                     when type.i = "CHAR" & ,
                        default.i = copies(" ",length.i) then ,
                        line = insert("SPACES",line,length(line),13)
                     otherwise line = insert(default.i,line,length(line),13)
                  end /* end select */
                  line = insert(" ]",line,length(line),2)
                  call domsg line
               end /* end do i = 1 to nb_items */
               call domsg    header.1
               call domsg    " "
               call domsg    "Total computed COBOL length :" cobol_length
               call domsg    " "
            end /* end if nb_items > 0 */
         end /* end if confirm >= 1 then do */

        /* --------------------------------------------------------- *
         * Done so report out and leave                              *
         * --------------------------------------------------------- */
         Done:
         if browse = 1 & rexx_os = "TSO" then do
            call msg 'off'
            if sysvar("syspref") = null then hlq  = sysvar("sysuid")"."
            else hlq = null
            browse_dsn = hlq"TXT2XML.report"
            "Alloc f("dd") ds("browse_dsn") new spa(1,1) tr",
            "recfm(v b) lrecl(255) blksize(0)"
            "Execio * diskw" dd "(Finis stem rpt."
            Address ISPExec "Browse Dataset("browse_dsn")"
            "Free f("dd")"
            "Delete" browse_dsn
         end /* end if browse = 1 & rexx_os = "TSO" */

        /* free txt file */
         if rexx_os = "TSO" then do
            if txtdd = null & output = "X" then "Free f("textdd")"
            if xmldd = null & output = "T" then "Free f("xml2dd")"
         end /* end if rexx_os = "TSO" */

         if ret = 1 then return
         exit exit_rc

          Do_TXT:
        /* --------------------------------------------------------- *
         * Allocate the txt file                                     *
         * Space of txt file = space of the XML file % 3             *
         * Lrecl is set to the computed cobol length of the copybook *
         * --------------------------------------------------------- */
         if rexx_os = "TSO" then do
            if txtdd = null then do
               rc = listdsi(xml)
               space = SYSPRIMARY%3+1","SYSSECONDS%3+1
               if pos("(",txt) <= 0 then do
                  if SYSUNITS <> "BLOCK" then ,
                     "Alloc f("textdd") new ds("txt") reuse" SYSUNITS ,
                     "recfm(f b) lrecl("cobol_length")" ,
                     "spa("space") blksize("cobol_length") release"
                  else ,
                     "Alloc f("textdd") new ds("txt") reuse" ,
                     "recfm(f b) lrecl("cobol_length")" ,
                     "block("cobol_length*10")",
                     "spa("space") blksize("cobol_length") release"
               end /* end if pos("(",txt) <= 0 */
               else do
                  if "MEMBER NOT FOUND" = sysdsn(txt) then do
                     "Alloc f("textdd") shr ds("txt") reuse"
                  end /* end if "MEMBER NOT FOUND" = sysdsn(txt) */
                  else do
                     if SYSUNITS <> "BLOCK" then ,
                        "Alloc f("textdd") new ds("txt") reuse" SYSUNITS ,
                        "recfm(f b) lrecl("cobol_length") dir(27)" ,
                         "spa("space") blksize("cobol_length") release"
                     else ,
                        "Alloc f("textdd") new ds("txt") reuse" ,
                        "recfm(f b) lrecl("cobol_length") dir(27)" ,
                        "block("cobol_length*10")",
                        "spa("space") blksize("cobol_length") release"
                  end /* end else do */
               end /* end else do */
            end /* end if txtdd = null */
         end /* end if rexx_os = "TSO" */

        /* initialize array of boolean that shows if XML element or attribute
           has already beeing match with COBOL items */
         do i = 1 to nb_items
            cobol_item_found.i = 0
         end /* end do i = 1 to nb_items */
         file_eof = 0
         nb_txt_rec = 0       /* number of txt record read or writte */
         root = ""            /* name of the XML root element */
         first_child  = ""    /* name of the XML first child element */
         element = ""         /* one XML element */
         attribute = ""       /* one XML attribute */
         attributes = ""      /* all XML attributes of an XML element */
         content = ""         /* content of one XML element */
         text_pos = 1         /* current position in text ouput record */
         element_pos = 0      /* XML element position in COBOL copybook */
         record.1 = ""        /* output record */
         do a = 1 to nb_items
            record.1 = record.1 || default.a
         end /* end do a = 1 to nb_items */
         call reset_XML_flags
         do while file_eof = 0

        /* read one record from XML file */
            rc = 0
            select
               when rexx_os <> "TSO" then do
                  if lines(xml) > 0 then xml.1 = linein(xml, ,1)
                  else rc = 1
               end /* end when rexx_os <> "TSO" */
               when xmldd = null then "Execio 1 diskr" xml2dd "(stem xml."
               when xmldd <> null then "Execio 1 diskr" xmldd "(stem xml."
               otherwise
            end /* end select */

        /* if end of file then exit */
            if rc > 0 then do
               file_eof = 1
               select
                  when rexx_os <> "TSO" then ,
                     rc = stream(xml, 'C', 'CLOSE')
                  when xmldd = null then do
                     "Execio 0 diskr" xml2dd "(FINIS"
                     "Free f("xml2dd")"
                  end /* end when xmldd = null */
                  when xmldd <> null then ,
                     "Execio 0 diskr" xmldd "(FINIS"
                  otherwise
               end /* end select */
               select
                  when rexx_os <> "TSO" then ,
                     rc = stream(txt, 'C', 'CLOSE')
                  when txtdd = null then do
                     "Execio 0 diskw" textdd "(FINIS"
                     "Free f("textdd")"
                  end /* end when txtdd = null */
                  when txtdd <> null then "Execio 0 diskw" txtdd "(FINIS"
                  otherwise
               end /* end select */
            end /* end if rc > 0 */
            else do

        /* ------------------------------------------------------ *
         * skip blank lines                                       *
         * ------------------------------------------------------ */
               xml.1 = strip(xml.1)
               if length(xml.1) <= 0 then iterate

        /* ------------------------------------------------------ *
         * skip XML declaration and comments. Search for XML root *
         * , XML first child and XML elements, attributes and     *
         * content.                                               *
         * ------------------------------------------------------ */
               do i = 1 to length(xml.1)
                  select

        /* ------------------------------------------------------ *
         * start of XML declaration <?                            *
         * ------------------------------------------------------ */
                     when XML_declaration <= 0 ,
                          & substr(xml.1,i,2) = "<?" then do
                          XML_declaration = 1
                          i = i + 1
                     end /* end when XML_declaration <= 0 , */

        /* end of XML declaration ?> */
                     when XML_declaration > 0 then do
                          i = pos("?>",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 1
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_declaration > 0 */

        /* ------------------------------------------------------ *
         * start of XML entity <|ENTITY                           *
         * ------------------------------------------------------ */
                     when XML_entity <= 0 ,
                          & substr(xml.1,i,8) = "<|ENTITY" then do
                          call domsg "==>Error :" ,
                               "in the XML file, entity declaration" ,
                               "is not supported."
                          exit_rc = 12
                          signal done
                     end /* end when XML_entity <= 0 ,*/

        /* end of XML entity */
                     when XML_entity > 0 then do
                          i = pos(">",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 1
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_entity > 0 */

        /* ------------------------------------------------------ *
         * start of XML DOCTYPE <|DOCTYPE                         *
         * ------------------------------------------------------ */
                     when XML_DOCTYPE <= 0 & ,
                          substr(xml.1,i,9) = "<|DOCTYPE" then do
                          XML_DOCTYPE = 1
                          if pos("",xml.1,i) > 0 then XML_DOCTYPE = 2
                          i = i + 8
                     end /* end when XML_DOCTYPE <= 0 & , */

        /* end of XML DOCTYPE without DTD declaration > */
                     when XML_DOCTYPE = 1 then do
                          i = pos(">",xml.1,i)
                          if i <= 0 then leave
                          else call reset_XML_flags
                     end /* end when XML_DOCTYPE = 1 */

        /* end of XML DOCTYPE with inline DTD declaration > */
                     when XML_DOCTYPE >= 2 then do
                          i = pos("!>",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 1
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_DOCTYPE >= 2 */

        /* ------------------------------------------------------ *
         * start of XML comment <|--                              *
         * ------------------------------------------------------ */
                     when XML_comment <= 0 & substr(xml.1,i,4) = "<|--" ,
                          then do
                          XML_comment = 1
                          i = i + 3
                     end /* end when XML_comment <= 0 & substr(xml.1,i,4) */

        /* end of XML comment --> */
                     when XML_comment > 0 then do
                          i = pos("-->",xml.1,i)
                          if i <= 0 then leave
                          else do
                             i = i + 2
                             call reset_XML_flags
                          end /* end else do */
                     end /* end when XML_comment > 0 */

        /* ------------------------------------------------------ *
         * start of XML root element                              *
         * ------------------------------------------------------ */
                     when root = "" & XML_root <= 0 ,
                          & substr(xml.1,i,1) = "<" then do
                          XML_root = 1
                      end /* end when root = "" & XML_root <= 0 , */

        /* end of XML root element */
                     when XML_root > 0 then do

        /* XML root element end on this line ? */
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             root = strip(root substr(xml.1,i,l))
                             if words(root) >  1 then do
                                call domsg ,
                                "==>Warning : " ,
                                "XML attributes of root element" ,
                                word(root,1) "are ignored."
                                exit_rc = 04
                             end /* end if words(root) >  1 */
                             root = strip(word(root,1))
                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML root element */
                          else do
                             root = root substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_root > 0 */

        /* ------------------------------------------------------ *
         * start of XML first_child element                       *
         * ------------------------------------------------------ */
                     when first_child = "" & XML_first_child <= 0 ,
                          & substr(xml.1,i,1) = "<" & root <> "" then do
                          XML_first_child = 1
                          attributes = ""
                          element_pos = 0
                      end /* end when first_child = "" & XML_first_child */

        /* end of XML first_child element */
                     when XML_first_child > 0 then do

        /* XML first_child element end on this line ? */
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             first_child = strip(first_child substr(xml.1,i,l))
                             parse var first_child first_child attributes
                             element = first_child
                             call find_XML_equivalent
                             element_pos = x
                             call do_XML_attribute
                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                             XML_content = 1
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML first_child element */
                          else do
                             first_child = first_child substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_first_child > 0 */

        /* ------------------------------------------------------ *
         * start of XML element                                   *
         * ------------------------------------------------------ */
                     when XML_element <= 0 & substr(xml.1,i,1) = "<" & ,
                          substr(xml.1,i,2) <> "</" ,
                          & substr(xml.1,i,9) <> "<|CDATA" then do
                          call reset_XML_flags
                          XML_element = 1
                          element = ""
                          attributes = ""
                          element_pos = 0
                     end /* end when XML_element <= 0 & substr(xml.1,i,1) */

        /* end of XML element */
                     when XML_element > 0 then do

        /* XML element end on this line ? */
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             element = strip(element substr(xml.1,i,l))
                             parse var element element attributes

        /* if first child XML element then create and initialize,
           according to the COBOL copybook, the TXT record */
                             if element = first_child then do
                                drop record.
                                record.1 = ""
                                do a = 1 to nb_items
                                   record.1 = record.1 || default.a
                                end /* end do a = 1 to nb_items */
                             end /* end if element = first_child */
                             drop temp
                             call find_XML_equivalent
                             element_pos = x
                             call do_XML_attribute

        /* XML empty element ? */
                             if substr(xml.1,k-1,2) = "/>" then do
                                i = k
                                call reset_XML_flags
                                iterate
                             end /* end if substr(xml.1,k-1,2) = "/>" */

                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                             XML_content = 1
                             content = ""
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML element */
                          else do
                             element = element substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_element > 0 */

        /* ------------------------------------------------------ *
         * find the content of a XML element                      *
         * ------------------------------------------------------ */
                     when XML_content > 0 then do
                          k = pos("</",xml.1,i)

        /* no closing tag on line ? continue on next line */
                          if k <= 0 then do
                             content = content substr(xml.1,i)
                             leave
                          end /* end if k <= 0 */
                          else do
                             l = k - i
                             content = strip(content substr(xml.1,i,l))
                          end /* end else do */
                          call check_XML_content
                          i = pos("</",xml.1,i) - 1
                          drop content element
                          call reset_XML_flags
                     end /* end when XML_content > 0 */

        /* ------------------------------------------------------ *
         * Start of child closing tag </                          *
         * ------------------------------------------------------ */
                     when XML_end_child <= 0 & ,
                          substr(xml.1,i,2) = "</" then do
                          XML_end_child = 1
                          element = ""
                          i = i + 1
                     end /* end when XML_end_child <= 0 & , */

        /* end of XML child closing tag > */
                     when XML_end_child > 0 then do
                          if pos(">",xml.1,i) > 0 then do
                             k = pos(">",xml.1,i)
                             l = k - i
                             element = element substr(xml.1,i,l)
                             element = strip(word(element,1))

        /* Write record if we have reached the first child closing tag */
                             if element = first_child then do
                                rc = 0
                                select
                                   when rexx_os <> "TSO" then do
                                      if nb_txt_rec <= 0 then ,
                                         rc = lineout(txt,record.1,1)
                                      else rc = lineout(txt,record.1)
                                      if rc <> 0 then do
                                         call domsg "==>Error :" ,
                                                    "Unable to write to file",
                                          txt "RC :" rc
                                         exit_rc = 12
                                         signal done
                                      end /* end if rc <> 0 */
                                   end /* end when rexx_os <> "TSO" */
                                   when txtdd = null then ,
                                      "Execio 1 diskw" textdd "(stem record."
                                   when txtdd <> null then ,
                                      "Execio 1 diskw" txtdd "(stem record."
                                   otherwise
                                end /* end select */
                                drop record.
                                text_pos = 1
                                nb_txt_rec = nb_txt_rec + 1
                                if nb_txt_rec // 1000 = 0 then ,
                                   call domsg nb_txt_rec ,
                                   "text records processed in" ,
                                 substr(time("E"),1,6) "seconds."

        /* check that we have filled all COBOL items except group items */
                                do x = 1 to nb_items
                                   if cobol_item_found.x <= 0 & ,
                                      name.x <> "FILLER" & ,
                                      length.x > 0 then do
                                      call domsg ,
                                         "==>Warning : in text record number" ,
                                         nb_txt_rec ", COBOL item" ,
                                         name.x ,
                                         "starting at" start_pos.x
                                      call domsg ,
                                         "is filled with default values" ,
                                         "because the corresponding XML" ,
                                         "equivalent was not found"
                                      exit_rc = 4
                                   end /* end if cobol_item_found.x <= 0 & */
                                   cobol_item_found.x = 0
                                end /* end do x = 1 to nb_items */
                             end /* end if element = first_child */
                             i = pos(">",xml.1,i)
                             call reset_XML_flags
                          end /* end if pos(">",xml.1,i) > 0 */

        /* else concatenate XML child closing tag */
                          else do
                             element = element substr(xml.1,i)
                             leave
                          end /* end else do */
                     end /* end when XML_end_child > 0 */

        /* ------------------------------------------------------ *
         * In case of ...                                         *
         * ------------------------------------------------------ */
                     otherwise do
                          call domsg "==>Error :" ,
                               "unable to convert the following chars :" ,
                               substr(xml.1,i,20)
                          exit_rc = 12
                          signal done
                     end /* end otherwise do */
                  end /* end select */
               end /* end do i = 1 to length(xml.1) */
            end /* end else do */
         end /* end do while file_eof = 0 */

        /* free txt file */
         if rexx_os = "TSO" then do
            if txtdd = null then "Free f("textdd")"
         end /* end if rexx_os = "TSO" */

         return

         Do_XML:
        /* ------------------------------------------------------- *
         * Allocate the XML                                        *
         * Space of XML file = 5 times space of the txt file       *
         * because XML can generate very big files                 *
         * Lrecl is set to 4096 because, XML record length should  *
         * never reach such a length.                              *
         * ------------------------------------------------------- */
         if xmldd = null & rexx_os = "TSO" then do
            rc = listdsi(txt)
            space = SYSPRIMARY*5","SYSSECONDS*5
            if pos("(",xml) <= 0 then do
               if SYSUNITS <> "BLOCK" then ,
                  "Alloc f("xml2dd") new ds("xml") reuse " SYSUNITS ,
                  "recfm(v b) lrecl(4096)" ,
                  "blksize(0) spa("space") release"
               else ,
                  "Alloc f("xml2dd") new ds("xml") reuse " ,
                  "recfm(v b) lrecl(4096)" ,
                  "block(4096)",
                  "blksize(0) spa("space") release"
            end /* end if pos("(",xml) <= 0 */
            else do
               if "MEMBER NOT FOUND" = sysdsn(xml) then do
                  "Alloc f("xml2dd") shr ds("xml") reuse"
               end /* end if "MEMBER NOT FOUND" = sysdsn(xml) */
               else do
                  if SYSUNITS <> "BLOCK" then ,
                     "Alloc f("xml2dd") new ds("xml") reuse " SYSUNITS ,
                     "recfm(v b) lrecl(4096)" ,
                     "dir(27)" ,
                     "blksize(0) spa("space") release"
                  else ,
                     "Alloc f("xml2dd") new ds("xml") reuse " ,
                     "recfm(v b) lrecl(4096)" ,
                     "dir(27)" ,
                     "blksize(0) spa("space") release"
               end /* end else do */
            end /* end else do */
         end /* end if xmldd = null & rexx_os = "TSO" */

        /* ------------------------------------------------------- *
         * Allocate the DTD file if necessary                      *
         * ------------------------------------------------------- */
         if dtd <> "INTERNAL" & dtd <> "" & ,
            dtddd = null & rexx_os = "TSO" then do
            if pos("(",dtd) <= 0 then do
               "Alloc f("dtd2dd") new ds("dtd") reuse tracks" ,
               "recfm(f b) lrecl(80)" ,
               "blksize(0) spa(10,10) release"
            end /* end if pos("(",dtd) <= 0 */
            else do
               if "MEMBER NOT FOUND" = sysdsn(dtd) then do
                  "Alloc f("dtd2dd") shr ds("dtd") reuse"
               end /* end if "MEMBER NOT FOUND" = sysdsn(dtd) */
               else do
                  "Alloc f("dtd2dd") new ds("dtd") reuse tracks",
                  "recfm(f b) lrecl(80)" ,
                  "dir(27)" ,
                  "blksize(0) spa(10,10) release"
               end /* end else do */
            end /* end else do */
         end /* end if dtd <> "INTERNAL" & dtd <> " " , */

        /* Create XML declaration */
         i = 1
         root = "DATA"
         if dtd = "INTERNAL" then record.i = ,
         '<?xml version="1.0" encoding="ISO-8859-1" standalone="yes" ?>'
         else record.i = ,
         '<?xml version="1.0" encoding="ISO-8859-1" standalone="no" ?>'
         i = i + 1
         record.i = "<|-- "
         i = i + 1
         record.i = ""
         i = i + 1
         record.i = center("Created by TXT2XML on" date("N") "at" ,
                    time("N"), 70)
         i = i + 1
         record.i = ""
         i = i + 1
         record.i = center("More info on :" ,
                    "http://sourceforge.net/projects/txt2xml-rexx/", 70)
         i = i + 1
         record.i = ""
         i = i + 1
         record.i = "-->"
         i = i + 1
         record.i = ""

        /* ------------------------------------------------------- *
         * create DTD                                              *
         * ------------------------------------------------------- */
         if dtd <> "" then do

        /* internal or external DTD header with DOCTYPE tag */
            i = i + 1
            if dtd = "INTERNAL" then record.i = "<|DOCTYPE" root ""
            else record.i = "<|DOCTYPE" root 'SYSTEM "'|| dtd || '">'
            i = i + 1
            l = 1
            do j = 1 to nb_items
                if name.j = "FILLER" then iterate

        /* create root element DTD */
               if j < = 1 then do
                  dtd.l = '<?xml version="1.0" encoding="ISO-8859-1"?>'
                  l = l + 1
                  element = name.1
                  if length(prefix) > 0 then do
                     if left(element,length(prefix)) = prefix then ,
                        element = substr(element,length(prefix)+1)
                  end /* end if length(prefix) > 0 */
                  dtd.l = "   <|ELEMENT" root "(" || element || ", "

        /* find sub-elemenents of the element */
                  do k = 2 to nb_items
                     if name.k = "FILLER" then iterate
                     element = name.k
                     if length(prefix) > 0 then do
                        if left(element,length(prefix)) = prefix then ,
                           element = substr(element,length(prefix)+1)
                     end /* end if length(prefix) > 0 */
                     if level.k = level.1 then do
                        if length(dtd.l) + length(element) > 75 then do
                           dtd.l = translate(dtd.l)
                           dtd.l = translate(dtd.l,"_","-")
                           if dtd = "INTERNAL" then do
                              record.i = dtd.l
                              i = i + 1
                           end /* end if dtd = "INTERNAL" */
                           l = l + 1
                           dtd.l = copies(" ",3)
                        end /* end if length(dtd.l) + length(element) > 75 */

        /* Skip multiple occurences of a sub-element */
                        if occurs.k > 1 then do
                           dtd.l = dtd.l || element || "+, "
                           n = occurs.k
                           do m = k + 1 to nb_items
                              if level.m = level.k & ,
                                 name.m = name.k then n = n - 1
                              if n <= 1 then do
                                 k = m
                                 leave
                              end /* end if n <= 1 */
                           end /* end do m = k + 1 to nb_items */
                        end /* end if occurs.k > 1 */
                        else dtd.l = dtd.l || element || ", "
                     end /* end if level.k = level.1 */
                  end /* end do k = 2 to nb_items */

        /* Close tag */
                  dtd.l = left(dtd.l,length(dtd.l)-2) || ")>"
                  dtd.l = translate(dtd.l)
                  dtd.l = translate(dtd.l,"_","-")
                  if dtd = "INTERNAL" then do
                     record.i = dtd.l
                     i = i + 1
                  end /* end if dtd = "INTERNAL" */
               end /* end if j < = 1 */

        /* create complex element DTD */
               if type.j = "GROUP" then do
                  l = l + 1
                  element = name.j
                  if length(prefix) > 0 then do
                     if left(element,length(prefix)) = prefix then ,
                        element = substr(element,length(prefix)+1)
                  end /* end if length(prefix) > 0 */
                  dtd.l = "   <|ELEMENT" element "("
                  m = j + 1

        /* find sub-elemenents of the element */
                  do k = m to nb_items
                     if name.k = "FILLER" then iterate
                     if level.k = level.m then do
                        element = name.k
                        if length(prefix) > 0 then do
                           if left(element,length(prefix)) = prefix then ,
                              element = substr(element,length(prefix)+1)
                        end /* end if length(prefix) > 0 */
                        if length(dtd.l) + length(element) > 75 then do
                           dtd.l = translate(dtd.l)
                           dtd.l = translate(dtd.l,"_","-")
                           if dtd = "INTERNAL" then do
                              record.i = dtd.l
                              i = i + 1
                           end /* end if dtd = "INTERNAL" */
                           l = l + 1
                           dtd.l = copies(" ",6)
                        end /* end if length(dtd.l) + length(element) > 75 */

        /* Skip multiple occurences of a sub-element */
                        if occurs.k > 1 then do
                           dtd.l = dtd.l || element || "+, "
                           o = occurs.k
                           do n = k + 1 to nb_items
                              if level.n = level.k & ,
                                 name.n = name.k then o = o - 1
                              if o <= 1 then do
                                 k = n
                                 leave
                              end /* end if o <= 1 */
                           end /* end do n = k + 1 to nb_items */
                        end /* end if occurs.k > 1 */
                        else dtd.l = dtd.l || element || ", "
                     end /* end if level.k = level.m */
                     else if level.k < level.m then leave
                  end /* end do k = m to nb_items */

        /* Close tag */
                  dtd.l = left(dtd.l,length(dtd.l)-2) || ")>"
                  dtd.l = translate(dtd.l)
                  dtd.l = translate(dtd.l,"_","-")
                  if dtd = "INTERNAL" then do
                     record.i = dtd.l
/*                      i = i + 1 */
                  end /* end if dtd = "INTERNAL" */

        /* Skip multiple occurences of the element */
                  if occurs.j > 1 then do
                     m = occurs.j
                     do k = j + 1 to nb_items
                        if level.k = level.j & ,
                           name.k = name.j then m = m - 1
                        if m <= 1 then do
                           j = k
                           leave
                        end /* end if m <= 1 */
                     end /* end do k = j + 1 to nb_items */
                  end /* end if occurs.j > 1 */
               end /* end if type.j = "GROUP" */

        /* create elementary element DTD */
               else do
                  l = l + 1
                  element = name.j
                  if length(prefix) > 0 then do
                     if left(element,length(prefix)) = prefix then ,
                        element = substr(element,length(prefix)+1)
                  end /* end if length(prefix) > 0 */
                  dtd.l = "   <|ELEMENT" element "(#PCDATA)>"

        /* Skip multiple occurences of an element */
                  if occurs.j > 1 then do
                     n = occurs.j
                     do m = j + 1 to nb_items
                        if level.m = level.j & ,
                           name.m = name.j then n = n - 1
                        if n <= 1 then do
                           j = m
                           leave
                        end /* end if n <= 1 */
                     end /* end do m = j + 1 to nb_items */
                  end /* end if occurs.j > 1 */
               end /* end else do  */
               dtd.l = translate(dtd.l)
               dtd.l = translate(dtd.l,"_","-")
               if dtd = "INTERNAL" then do
                  record.i = dtd.l
                  i = i + 1
               end /* end if dtd = "INTERNAL" */
            end /* end do j = 1 to nb_items */

        /* Close tag */
            if dtd  = "INTERNAL" then do
               record.i = "!>"
               i = i + 1
            end  /* end if dtd = "INTERNAL" */

        /* write DTD records */
            else do
               select
                  when rexx_os <> "TSO" then do j = 1 to l
                     do j = 1 to l
                        if j <= 1 then rc = lineout(dtd,dtd.j,1)
                        else rc = lineout(dtd,dtd.j)
                        if rc <> 0 then do
                           call domsg "==>Error :" ,
                                      "Unable to write to file",
                                      dtd "RC :" rc
                           exit_rc = 12
                           signal done
                        end /* end if rc <> 0 */
                     end /* end do j = 1 to l */
                  end /* end when rexx_os <> "TSO" */
                  when dtddd = null then ,
                    "Execio " l " diskw" dtd2dd "(stem dtd."
                  when dtddd <> null then ,
                    "Execio " l " diskw" dtddd "(stem dtd."
                  otherwise
               end /* end select */
               drop dtd.
            end /* end else do */
         end /* end if dtd <> "" */
         drop dtd. j k l m n o

         record.i = ""
         i = i + 1
         record.i = "<" || root || ">"
         file_eof = 0
         nb_txt_rec = 0 /* number of text records read or written */
         do while file_eof <= 0

        /* read one record from txt file */
            rc = 0
            select
               when rexx_os <> "TSO" then do
                  if lines(txt) > 0 then txt.1 = linein(txt, ,1)
                  else rc = 1
               end /* end when rexx_os <> "TSO"  */
               when txtdd = null then "Execio 1 diskr" textdd "(stem txt."
               when txtdd <> null then "Execio 1 diskr" txtdd "(stem txt."
               otherwise
            end /* end select */

        /* if end of file then exit */
            if rc > 0 then file_eof = 1
            else do
               nb_txt_rec = nb_txt_rec + 1
               if nb_txt_rec // 1000 = 0 then do
                  call domsg nb_txt_rec "records processed in",
                             substr(time("E"),1,6) "seconds."
               end /* end if nb_txt_rec // 1000 = 0 */

         /* ----------------------------------------------------- *
         * If computed length not equal in file length, exit      *
         * ------------------------------------------------------ */
               if nb_txt_rec <= 1 & cobol_length <> length(txt.1) then do
                  call domsg "==>Error :" ,
                             "the total length of the COBOL items (" || ,
                             cobol_length || ")"
                  call domsg "doesn't match the txt file length (" || ,
                             length(txt.1) || ")."
                  exit_rc = 12
                  signal done
               end /* end if nb_txt_rec <= 1 & cobol_length <> length(txt.1) */

        /* write XML declaration in XML file */
               if nb_txt_rec <= 1 then do
                  rc = 0
                  select
                     when rexx_os <> "TSO" then do j = 1 to i
                        if j <= 1 then rc = lineout(xml,record.j,1)
                        else rc = lineout(xml,record.j)
                        if rc <> 0 then do
                           call domsg "==>Error :" ,
                                      "Unable to write to file",
                                      xml "RC :" rc
                           exit_rc = 12
                           signal done
                        end /* end if rc <> 0 */
                     end /* end when rexx_os <> "TSO" */
                     when xmldd = null then ,
                        "Execio " i " diskw" xml2dd "(stem record."
                     when xmldd <> null then ,
                       "Execio " i " diskw" xmldd "(stem record."
                     otherwise
                  end /* end select */
                  drop record.
               end /* end if nb_txt_rec <= 1 */

        /* ----------------------------------------------------- *
         * generate XML elements                                 *
         * ----------------------------------------------------- */
               do j = 1 to nb_items

        /* Skip fillers */
                  if name.j <> "FILLER" then do
                     element = name.j
                     if length(prefix) > 0 then do
                        if left(element,length(prefix)) = prefix then ,
                           element = substr(element,length(prefix)+1)
                     end /* end if length(prefix) > 0 */

        /* indent XML according to the level */
                     record.1 = copies(" ",level.j * 2) || ,
                                "<" || translate(element,"_","-") ||">"

        /* if item is not a COBOL group item then show content and close
           element */
                     if length.j > 0 then do
                        content = substr(txt.1,start_pos.j,length.j)
                        select
                           when type.j = "BIN" then content = ,
                              bin2txt(content,length.j,signed.j)
                           when type.j = "PACK" then content = ,
                              pack2txt(content)
                           when type.j = "NUM" then content = ,
                              num2txt(content,signed.j,sign_pos.j)
                           otherwise nop
                        end /* end select */

        /* Escape special characters in content */
                        if type.j = "CHAR" then do
                           k = 0
                           do forever
                              k = k + 1
                              if k > length(content) then leave
                              temp = substr(content,k,1)
                              select
                                 when temp = "&" then symbole = "&amp;"
                                 when temp = "<" then symbole = "&lt;"
                                 when temp = ">" then symbole = "&gt;"
                                 when temp = '"' then symbole = "&quot;"
                                 when temp = "'" then symbole = "&apos;"
                                 when c2d(temp) < c2d(first_char) then ,
                                    symbole = "&#" || c2d(temp) || ";"
                                 when temp = "FF"x then symbole = "&#255;"
                                 otherwise iterate
                              end /* end select */
                              if k > 1 then temp1 = substr(content,1,k-1)
                              else temp1 = ""
                              temp2 = substr(content,k+1)
                              content = temp1 || symbole || temp2
                              drop temp1 temp2 temp symbole
                           end /* end do forever */

        /* preserve space in content */
                           if content = copies(" ",length(content)) then ,
                              content = "<|CDATA" || content ||"!!>"
                        end /* end if type.j = "CHAR" */
                        record.1 = record.1 || content
                        record.1 = record.1 || "</" || ,
                                   translate(element,"_","-") ||">"
                     end /* end if length.j > 0 */

        /* write one record in XML file */
                     rc = 0
                     select
                        when rexx_os <> "TSO" then do
                           rc = lineout(xml,record.1)
                           if rc <> 0 then do
                              call domsg "==>Error :" ,
                                         "Unable to write to file",
                                         xml "RC :" rc
                              exit_rc = 12
                              signal done
                           end /* end if rc <> 0 */
                        end /* end when rexx_os <> "TSO" */
                        when xmldd = null then ,
                           "Execio 1 diskw" xml2dd "(stem record."
                        when xmldd <> null then ,
                           "Execio 1 diskw" xmldd "(stem record."
                        otherwise
                     end /* end select */
                     drop record.
                  end /* end if name.j <> "FILLER" */

        /* To close elements at end of record, add dummy level 0 */
                  l = j + 1
                  if l > nb_items then level.l = 0

        /* if item is a COBOL group item then close previous opened
               elements */
                  if level.j > level.l then do
                     close_level = level.j

        /* explore previous level to add close element if needed */
                     do k = j - 1 to 1 by -1
                        if length.k <= 0 then do

        /* if this level was already close, skip it */
                           if level.k >= close_level then iterate

        /* write one record in XML file */
                           element = name.k
                           if length(prefix) > 0 then do
                              if left(element,length(prefix)) = prefix then ,
                                 element = substr(element,length(prefix)+1)
                           end /* end if length(prefix) >  */
                           record.1 = copies(" ",level.k * 2) || ,
                                      "</" || translate(element,"_","-") ||">"
                           rc = 0
                           select
                              when rexx_os <> "TSO" then do
                                 rc = lineout(xml,record.1)
                                 if rc <> 0 then do
                                    call domsg "==>Error :" ,
                                               "Unable to write to file",
                                               xml "RC :" rc
                                    exit_rc = 12
                                    signal done
                                 end /* end if rc <> 0 */
                              end /* end when rexx_os <> "TSO" */
                              when xmldd = null then ,
                                 "Execio 1 diskw" xml2dd "(stem record."
                              when xmldd <> null then ,
                                 "Execio 1 diskw" xmldd "(stem record."
                              otherwise
                           end /* end select */
                           drop record.

        /* leave the loop only if the previous level was closed or
               if final level (level = 0 ) */
                           if level.k <= level.l & level.l <> 0 then leave

        /* else save current close level */
                           close_level = level.k
                        end /* end if length.k <= 0 */
                     end /* end do k = j - 1 to 1 by -1 */
                  end /* end if level.j > level.l then do */
               end /* end do j = 1 to nb_items */
            end /* end else do */
         end /* end do while file_eof = 0 */

        /* write one record in XML file and close it */
         record.1 = "</" || root || ">"
         rc = 0
         select
            when rexx_os <> "TSO" then do
               rc = lineout(xml,record.1)
               if rc <> 0 then do
                  call domsg "==>Error :" ,
                             "Unable to write to file",
                             xml "RC :" rc
                  exit_rc = 12
                  signal done
               end /* end if rc <> 0 */
               rc = stream(xml, 'C', 'CLOSE')
            end /* end when rexx_os <> "TSO" */
            when xmldd = null then do
               "Execio 1 diskw" xml2dd "(FINIS stem record."
               "Free f("xml2dd")"
            end /* end when xmldd = null */
            when xmldd <> null then ,
               "Execio 1 diskw" xmldd "(FINIS stem record."
            otherwise
         end /* end select */
         if dtd <> "" & dtd <> "INTERNAL" then do
            select
               when rexx_os <> "TSO" then do
                  rc = stream(dtd, 'C', 'CLOSE')
               end /* end when rexx_os <> "TSO" */
               when dtddd = null then do
                  "Execio 0 diskw" dtd2dd "(FINIS stem record."
                  "Free f("dtd2dd")"
               end /* end when dtddd = null */
               when dtddd <> null then ,
                  "Execio 0 diskw" dtddd "(FINIS stem record."
               otherwise
            end /* end select */
         end /* end if dtd <> "" & dtd "INTERNAL" */
         select
            when rexx_os <> "TSO" then rc = stream(txt, 'C', 'CLOSE')
            when txtdd = null then do
               "Execio 0 diskr" textdd "(FINIS"
               "Free f("textdd")"
            end /* end when rexx_os <> "TSO" */
            when txtdd <> null then "Execio 0 diskr" txtdd "(FINIS"
            otherwise
         end /* end select */
         drop record.

         return

         DoMsg:
        /* --------------------------------------------------------- *
         * Issue Messages                                            *
         * --------------------------------------------------------- */
           parse arg msg
           if confirm <= 0 then return
           if browse <= 0 then say msgid msg
           else do
              r = r + 1
              rpt.r = msg
           end /* end else do */
           return

           find_XML_equivalent:
        /* --------------------------------------------------------- *
         * XML element or XML attribute in COBOL copybook ?          *
         * --------------------------------------------------------- */
           equivalent = ""
           if XML_attribute > 0 then equivalent = attribute
           else if XML_element > 0 | ,
                   XML_content > 0 | ,
                   XML_first_child > 0 then equivalent = element
           else return
           found = 0
           equivalent = translate(equivalent)
           equivalent = translate(equivalent,"-","_")
           if length(prefix) > 0 then do
              if left(equivalent,length(prefix)) = prefix then ,
                 equivalent = substr(equivalent,length(prefix)+1)
           end /* end if length(prefix) > 0*/
           do x = 1 to nb_items
              if cobol_item_found.x > 0 then iterate

        /* Skip fillers and find next COBOL Item */
              if name.x = "FILLER" then do
                 text_pos = start_pos.x + length.x
                 cobol_item_found.x = 1
                 iterate
              end /* end if name.x = "FILLER" */
              if name.x = equivalent | ,
                 name.x = prefix || equivalent then do
                 if start_pos.x >= text_pos then do
                    found = 1
                    cobol_item_found.x = 1
                    text_pos = start_pos.x + length.x
                    leave
                 end /* end if start_pos.x >= text_pos */
              end /* end if name.x = equivalent then do */
           end /* end do x = 1 to nb_items */

        /* if XML attribute is not found in COBOL copybook, then warning */
           if found <= 0 then do
              x = 0
              if XML_attribute > 0 then do
                 call domsg "==>Warning :" ,
                            "XML attribute" equivalent ,
                            "not found in COBOL copybook"
                 call domsg "or occurs too many times" ,
                      "according to the COBOL copybook"
                 exit_rc = 4
              end /* end if XML_attribute > 0 */

        /* if XML element is not found in COBOL copybook, then exit */
              else do
                 call domsg "==>Error :" ,
                            "XML element" equivalent ,
                            "not found in COBOL copybook"
                 call domsg "or occurs too many times" ,
                            "according to the COBOL copybook"
                 exit_rc = 12
                 signal done
              end /* end else do */
           end /* end if found <= 0 */

           drop equivalent found
           return

         reset_XML_flags:
        /* --------------------------------------------------------- *
         * Reset XML flags                                           *
         * --------------------------------------------------------- */

           XML_declaration = 0
           XML_DOCTYPE = 0
           XML_comment = 0
           XML_root = 0
           XML_first_child = 0
           XML_element = 0
           XML_attribute = 0
           XML_end_child = 0
           XML_content = 0
           XML_entity = 0

           return

         do_XML_attribute:
        /* --------------------------------------------------------- *
         * Converting attribute value to text                        *
         * --------------------------------------------------------- */
           if length(attributes) > 0 then do
              XML_attribute = 1
              start_pos = 0
              end_pos = 0
              temp1 = strip(attributes)
              if right(temp1,1) = "/" then ,
                 temp1 = left(temp1,length(temp1)-1)
              temp1 = temp1 || " "

         /* Search attributes and content*/
              do b = 1 to length(temp1)
                 if substr(temp1,b,1) <> " " ,
                    & start_pos <= 0 then start_pos = b
                 if substr(temp1,b,2) = '" ' | ,
                    substr(temp1,b,2) = "' " then do
                    end_pos = b + 1
                    temp2 = substr(temp1,start_pos,end_pos-start_pos)
                    if substr(temp2,length(temp2),1) = "/" then ,
                       temp2 = substr(temp2,1,length(temp2)-1)
                    if pos("=",temp2) <= 0 then do
                       call domsg ,
                          "==>Error: equal sign not found in attribute :" ,
                          temp2
                       exit_rc = 12
                       signal done
                    end /* end if pos("=",temp2) <= 0 */
                    attribute = substr(temp2,1,pos("=",temp2)-1)

         /* Skip XML specials attributes */
                    if translate(substr(attribute,1,3)) = "XML" then do
                       start_pos = 0
                       end_pos = 0
                       iterate
                    end /* end if translate(substr(attribute,1,3)) = "XML" */
                    content = substr(temp2,pos("=",temp2)+2)
                    content = substr(content,1,length(content)-1)
                    start_pos = 0
                    end_pos = 0
                    call find_XML_equivalent
                    call check_XML_content
                 end /* end if substr(temp1,b,2) = '" ' | , */
              end /* end do b = 1 to length(temp1) */
              XML_attribute = 0
           end /* end if words(element) > 1 */
           drop b content attribute temp1 temp2 start_pos end_pos

           return

         check_XML_content:
        /* --------------------------------------------------------- *
         * Check XML content before transfering it to the output     *
         * record.                                                   *
         * --------------------------------------------------------- */
           if XML_content > 0 then x = element_pos
           if x <= 0 then return
           select
              when type.x = "BIN" then content = ,
                 txt2bin(content,length.x,signed.x)
              when type.x = "PACK" then content = ,
                 txt2pack(content,length.x,signed.x)
              when type.x = "NUM" then content = ,
                 txt2num(content,length.x,signed.x,sign_pos.x)
              otherwise nop
           end /* end select */

        /* scan content for CDATA */
           if pos("<|CDATA",content) > 0 & type.x = "CHAR" then do
              k = pos("<|CDATA",content)
              k = k + length("<|CDATA")
              l = pos("!!>",content)
              content = substr(content,k,l-k)
           end /* end if pos("<|CDATA",content) > 0 & type.x = "CHAR" */

        /* scan content for escaping characters */
           else
           if (pos("&amp;",content) > 0 | ,
              pos("&lt;",content) > 0 | ,
              pos("&gt;",content) > 0 | ,
              pos("&apos;",content) > 0 | ,
              pos("&quot;",content) > 0 | ,
              pos("&#",content) > 0) & type.x = "CHAR"  then
              do k = 1 to length(content)
                 k = pos("&",content,k)
                 l = pos(";",content,k)
                 temp = translate(substr(content,k+1,l-k-1))
                 select
                    when temp = "AMP" then symbole = "&"
                    when temp = "LT" then symbole = "<"
                    when temp = "GT" then symbole = ">"
                    when temp = "QUOT" then symbole = '"'
                    when temp = "APOS" then symbole = "'"
                    when substr(temp,1,1) = "#" then do
                       temp1 = substr(temp,2)
                       if left(temp1,1) = "X" then ,
                          symbole = x2c(substr(temp1,2))
                       else symbole = d2c(temp1)
                       call domsg ,
                          "==>Warning : character reference:" temp ,
                          "encountered in escaped characters."
                       exit_rc = 04
                       drop temp1
                    end /* end when substr(temp,1,1) = "#" */
                    otherwise do
                       call domsg ,
                         "==>Error: unknown escaping character" ,
                          "&" || symbole || ";" ,
                          "encounterd."
                       exit_rc = 12
                       signal done
                    end /* end otherwise do */
                 end /* end select */
                 if k > 1 then temp1 = substr(content,1,k-1)
                 else temp1 = ""
                 temp2 = substr(content,k+length(temp)+2)
                 content = temp1 || symbole || temp2
                 drop temp1 temp2 temp symbole
                 if pos("&",content,k) <= 0 | ,
                    pos(";",content,k) <= 0 then leave
           end /* end if (pos("&amp;",content) > 0 | */

        /* check length of content against length of item in COBOL
           copybook */
           if length(content) > length.x then do
              call domsg "==>Error :" ,
                   "the length of content" content "in XML element" ,
                   element
              call domsg ,
                   "is greater than the length of the" ,
                   "COBOL item" name.x ":" length.x
              exit_rc = 12
              signal done
           end /* end if length(content) > length.x */
           record.1 = overlay(content,record.1,start_pos.x,length.x)

           return

         exit_no_options:
        /* --------------------------------------------------------- *
         * Exit with error messages when no options are specified    *
         * --------------------------------------------------------- */
           say "==>Error: TXT2XML requires a minimum of TXT," ,
               "COB, XML and FORMAT keywords and values."
           say " "
           say "TXT2XML is a REXX script that converts TXT files"
           say "from and to XML files using a COBOL copybook"
           say "as reference. "
           say " "
           say "TXT2XML Syntax:"
           say " "
           say "TXT2XML TXT txt-ds"
           say "        COB cob-ds"
           say "        XML xml-ds"
           say "        FORMAT X or T"
           say "        DTD dtd-ds"
           say "        PREFIX prefix"
           say "        VERBOSE"
           say "        BROWSE"
           say " "

        /* --------------------------------------------------------- *
         * Trying to start Java gui front end                        *
         * --------------------------------------------------------- */
           if rexx_os <> "TSO" then do
              say "Trying to start JAVA GUI front-end ..."
              "java -jar txt2xml.jar"
           end /* end if rexx_os <> "TSO" */
           exit_rc = 12
           exit exit_rc

         txt2bin: procedure expose(globals)
        /* --------------------------------------------------------- *
         * Convert text to binary                                    *
         *                                                           *
         * Parameter(s) : txt (mandatory)                            *
         *                length (mandatory) (>0, in bytes)          *
         *                signed (mandatory) (Y/N)                   *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg txt, lengt, signed
           bin = ""
           txt = strip(word(txt,1))
           lengt = strip(word(lengt,1))
           signed = translate(left(strip(signed),1))
           if left(txt,1) <> "+" & left(txt,1) <> "-" then txt = "+" || txt
           signe = substr(txt,1,1)
           txt = substr(txt,2)
           old_msgid = msgid
           msgid = msgid || "txt2bin():"

        /* Check data type, sign and length */
           if datatype(translate(txt,".00",",$E")) <> "NUM" then do
              call domsg "==>Error :" ,
                         "During text to numeric conversion, text (" txt ,
                         ") is not numeric."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if datatype(translate(txt,".00",",$E")) <> "NUM" */
           if signe <> "+" & signe <> "-" then do
              call domsg "==>Error :" ,
                         "During text to binary conversion, sign (" signe ,
                         ") is not a valid sign."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if signe <> "+" & signe <> "-" */
           if length(txt) > 18 then do
              call domsg "==>Error :" ,
                         "During text to binary conversion, text (" txt ,
                         ") with length (" ,
                         length(txt) ,
                         ") is longer than 18 bytes."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if length(txt) > 18 */
           if (lengt <> 8 & lengt <> 4 & lengt <> 2) | ,
              datatype(lengt) <> "NUM" then do
              call domsg "==>Error :" ,
                         "During text to binary conversion,"  ,
                         "invalid length (" lengt ,
                         ") for COBOL binary item."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if (lengt <> 8 & lengt <> 4 & lengt <> 2) | , */
           if (lengt = 2 & length(txt) > 4 ) | ,
              (lengt = 4 & length(txt) > 9 ) | ,
              (lengt = 8 & length(txt) > 18 ) then do
              call domsg "==>Error :" ,
                         "During text to binary conversion,"  ,
                         "unable to convert text " txt ,
                         "of length (" length(txt) ,
                         ") into a COBOL binary item of length" lengt "."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if (lengt = 2 & length(txt) > 4 ) | , */
           if signed = "N" & signe = "-" then do
              call domsg "==>Error :" ,
                         "During text to binary conversion, unable" ,
                         "to convert signed data" signe || txt
                         "into unsigned binary item."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if signed = "N" & signe = "-" */

         /* If data is signed and negative, perform 2 complement */
           if signed = "Y" & signe = "-" then do
              i = 2 ** (lengt * 8)
              txt = i - txt
           end /* end if signed = "Y" & signe = "-" */

         /* Do the conversion according to the Operating System */
           select
              when rexx_os = "TSO" then do /* big endian */
                 bin = d2c(txt,lengt)
              end /* end when rexx_os = "TSO" */
              when rexx_os = "UNIX" then do /* little endian */
                 bin = reverse(d2c(txt,lengt))
              end /* end when rexx_os = "UNIX" */
              when rexx_os = "WIN32" then do /* little endian */
                 bin = reverse(d2c(txt,lengt))
              end /* end when rexx_os = "WIN32" */
              otherwise do
                 call Domsg "==>Error :" ,
                            "During text to binary conversion," ,
                            "unsupported operating system :" rexx_os
                 exit_rc = 12
                 signal done
              end /* end otherwise do  */
           end /* end select */
           msgid = old_msgid

           return bin

         txt2pack: procedure expose(globals)
        /* --------------------------------------------------------- *
         * convert text data to packed decimal                       *
         *                                                           *
         * Parameter(s) : txt (mandatory)                            *
         *                length (mandatory) (>0, in bytes)          *
         *                signed (mandatory) (Y/N)                   *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg txt, lengt, signed
           packed = ""
           txt = strip(word(txt,1))
           signed = translate(left(strip(signed),1))
           lengt = strip(word(lengt,1))
           if left(txt,1) <> "+" & left(txt,1) <> "-" then txt = "+" || txt
           signe = substr(txt,1,1)
           txt = substr(txt,2)
           old_msgid = msgid
           msgid = msgid || "txt2pack():"

        /* Check data type, sign and length */
           if datatype(translate(txt,".00",",$E")) <> "NUM" then do
              call domsg "==>Error :" ,
                         "During text to numeric conversion, text (" txt ,
                         ") is not numeric."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if datatype(translate(txt,".00",",$E")) <> "NUM" */
           if signe <> "+" & signe <> "-" then do
              call domsg "==>Error :" ,
                         "During text to packed conversion, sign (" signe ,
                         ") is not a valid sign."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if signe <> "+" & signe <> "-" */
           if lengt < 1  | datatype(lengt) <> "NUM" then do
              call domsg "==>Error :" ,
                         "During text to packed conversion," ,
                         "invalid length (" lengt ,
                         ") for COBOL packed item."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if lengt < 1  | datatype(lengt) <> "NUM" */
           if signed = "N" & signe = "-" then do
              call domsg "==>Error :" ,
                         "During text to packed conversion, unable" ,
                         "to convert signed data" signe || txt
                         "into unsigned packed item."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if signed = "N" & signe = "-" */

         /* if text length is odd, then add a zero so that with the sign,
            the total length will still be odd */
           if length(txt) = 2 * (length(txt) % 2) then txt = "0" || txt

         /* do the conversion */
           select
              when signed = "N" then txt = txt || "F"
              when signe = "+" then txt = txt || "C"
              when signe = "-" then txt = txt || "D"
              otherwise do
                 call domsg "==>Error :" ,
                            "During text to packed conversion, sign (" signe ,
                            ") is not a valid sign."
                 call domsg "Parameter values when the error occured:"
                 call domsg "txt           :" txt
                 call domsg "length        :" lengt
                 call domsg "signed        :" signed
                 exit_rc = 12
                 signal done
              end /* end otherwise do  */
           end /* end select */

         /* set packed data to requested length */
           if length(txt) / 2 <= lengt then do
              i = lengt - (length(txt) / 2)
              if i > 0 then txt = copies("00",i) || txt
           end /* end if length(txt) / 2 <= lengt */
           else do
              call domsg "==>Error :" ,
                         "During txt to packed conversion,"  ,
                         "unable to convert text" txt ,
                         "of length (" length(txt) ,
                         ") into a COBOL packed item of length" lengt "."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end else do */
           packed = x2c(txt)
           msgid = old_msgid

           return packed

         txt2num: procedure expose(globals)
        /* --------------------------------------------------------- *
         * convert text data to numeric data                         *
         *                                                           *
         * Parameter(s) : txt (mandatory)                            *
         *                length (mandatory) (>0, in bytes)          *
         *                signed (mandatory) (Y/N)                   *
         *                sign_pos (mandatory) (L/T/LS/TS)           *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg txt, lengt, signed, sign_pos
           num = ""
           txt = strip(word(txt,1))
           lengt = strip(word(lengt,1))
           signed = translate(left(strip(signed),1))
           sign_pos = translate(left(strip(sign_pos),2))
           if left(txt,1) <> "+" & left(txt,1) <> "-" then txt = "+" || txt
           signe = substr(txt,1,1)
           txt = substr(txt,2)
           old_msgid = msgid
           msgid = msgid || "txt2num():"

        /* Check data type, sign and sign position */
           if datatype(translate(txt,".00",",$E")) <> "NUM" then do
              call domsg "==>Error :" ,
                         "During text to numeric conversion, text (" txt ,
                         ") is not numeric."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if datatype(translate(txt,".00",",$E")) <> "NUM" */
           if signe <> "+" & signe <> "-" then do
              call domsg "==>Error :" ,
                         "During text to numeric conversion, sign (" signe ,
                         ") is not a valid sign."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              call domsg "sign_pos      :" sign_pos
              exit_rc = 12
              signal done
           end /* end if signe <> "+" & signe <> "-" */
           if sign_pos <> "L" & ,
              sign_pos <> "T" & ,
              sign_pos <> "LS" & ,
              sign_pos <> "TS" & signed = "Y" then do
              call domsg "==>Error :" ,
                         "During text to numeric conversion, sign position (" ,
                         sign_pos
                         ") is not valid."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              call domsg "sign_pos      :" sign_pos
              exit_rc = 12
              signal done
           end /* end if sign_pos <> "L" &, */
           if lengt < 1  | datatype(lengt) <> "NUM"  then do
              call domsg "==>Error :" ,
                         "During text to num conversion," ,
                         "invalid length (" lengt ,
                         ") for COBOL numeric item."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              call domsg "sign_pos      :" sign_pos
              exit_rc = 12
              signal done
           end /* end if lengt < 1  | datatype(lengt) <> "NUM" */
           if signed = "N" & signe = "-" then do
              call domsg "==>Error :" ,
                         "During text to numeric conversion, unable" ,
                         "to convert signed data" signe || txt ,
                         "into unsigned numeric item."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              call domsg "sign_pos      :" sign_pos
              exit_rc = 12
              signal done
           end /* end if signed = "N" & signe = "-" */

        /* Do the conversion according the OS */
           positive = "C"
           negative = "D"
           select
              when rexx_os = "TSO" then do
                 separator = "F"
                 sep_positive = "4E"
                 sep_negative = "60"
              end /* end when rexx_os = "TSO" */
              when rexx_os = "UNIX" then do
                 separator = "3"
                 sep_positive = "2B"
                 sep_negative = "2D"
              end /* end when rexx_os = "UNIX" */
              when rexx_os = "WIN32" then do
                 separator = "3"
                 sep_positive = "2B"
                 sep_negative = "2D"
              end /* end when rexx_os = "WIN32"*/
              otherwise do
                 call domsg "==>Error :" ,
                            "During text to numeric conversion," ,
                            "unsupported operating system :" rexx_os
                   exit_rc = 12
                 signal done
              end /* end otherwise do  */
           end /* end select */

         /* set numeric data to requested length */
           i = 0
           if (sign_pos = "LS" | sign_pos = "TS") then ,
              i = lengt - length(txt) - 1
           else i = lengt - length(txt)
           if i > 0 then txt = copies("0",i) || txt
           else if i < 0 then do
              call domsg "==>Error :" ,
                         "During txt to numeric conversion,"  ,
                         "unable to convert text" txt ,
                         "of length (" length(txt) ,
                         ") into a COBOL numeric item of length" lengt "."
              call domsg "Parameter values when the error occured:"
              call domsg "txt           :" txt
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              call domsg "sign_pos      :" sign_pos
              exit_rc = 12
              signal done
           end /* end else do */

           select
       /* Unsigned data */
              when signed = "N" then do
                 do i = 1 to length(txt)
                    if datatype(substr(txt,i,1)) <> "NUM" then ,
                       temp = temp || c2x(substr(txt,i,1))
                    else num = num || separator || substr(txt,i,1)
                 end /* end do i = 1 to length(txt)*/
              end /* end when signed = "N" */

       /* Trailing sign */
              when sign_pos = "T" then do
                 do i = 1 to length(txt) - 1
                    if datatype(substr(txt,i,1)) <> "NUM" then ,
                       temp = temp || c2x(substr(txt,i,1))
                    else num = num || separator || substr(txt,i,1)
                 end /* end do i = 1 to length(txt) - 1 */
                 if signe = "+" then num = num || positive || right(txt,1)
                 else num = num  || negative || right(txt,1)
              end /* end when sign_pos = "T" */

       /* Leading sign */
              when sign_pos = "L" then do
                 if signe = "+" then num = num  || positive || left(txt,1)
                 else num = num  || negative || left(txt,1)
                 do i = 2 to length(txt)
                    if datatype(substr(txt,i,1)) <> "NUM" then ,
                       temp = temp || c2x(substr(txt,i,1))
                    else num = num || separator || substr(txt,i,1)
                 end /* end do i = 2 to length(txt) */
              end /* end when sign_pos = "L" */

       /* Trailing sign separate */
              when sign_pos = "TS" then do
                 do i = 1 to length(txt)
                    if datatype(substr(txt,i,1)) <> "NUM" then ,
                       temp = temp || c2x(substr(txt,i,1))
                    else num = num || separator || substr(txt,i,1)
                 end /* end do i = 1 to length(txt) */
                 if signe = "+" then num = num || sep_positive
                 else num = num || sep_negative
              end /* end when sign_pos = "TS" */

       /* Leading sign separate */
              when sign_pos = "LS" then do
                 if signe = "+" then num = num || sep_positive
                 else num = num || sep_negative
                 do i = 1 to length(txt)
                    if datatype(substr(txt,i,1)) <> "NUM" then ,
                       temp = temp || c2x(substr(txt,i,1))
                    else num = num || separator || substr(txt,i,1)
                 end /* end do i = 1 to length(txt) */
              end /* end when sign_pos = "LS" */
              otherwise do
                 call domsg "==>Error :" ,
                            "During text to numeric conversion," ,
                            "sign position (" ,
                            sign_pos
                            ") is not valid."
                 call domsg "Parameter values when the error occured:"
                 call domsg "txt           :" txt
                 call domsg "length        :" lengt
                 call domsg "signed        :" signed
                 call domsg "sign_pos      :" sign_pos
                 exit_rc = 12
                 signal done
              end /* end otherwise do */
           end /* end select */

        /* Change MVS style signed characters to the Tiny-COBOL style */
           if rexx_os = "UNIX" | rexx_os = "WIN32"  then do
              if sign_pos = "T" then do
                 select
        /* - 0 */
                    when right(num,2) = "D0" then ,
                       num = overlay("7D",num,length(num)-1,2)
        /* - 1 */
                    when right(num,2) = "D1" then ,
                       num = overlay("4A",num,length(num)-1,2)
        /* - 2 */
                    when right(num,2) = "D2" then ,
                       num = overlay("4B",num,length(num)-1,2)
        /* - 3 */
                    when right(num,2) = "D3" then ,
                       num = overlay("4C",num,length(num)-1,2)
        /* - 4 */
                    when right(num,2) = "D4" then ,
                       num = overlay("4D",num,length(num)-1,2)
        /* - 5 */
                    when right(num,2) = "D5" then ,
                       num = overlay("4E",num,length(num)-1,2)
        /* - 6 */
                    when right(num,2) = "D6" then ,
                       num = overlay("4F",num,length(num)-1,2)
        /* - 7 */
                    when right(num,2) = "D5" then ,
                       num = overlay("50",num,length(num)-1,2)
        /* - 8 */
                    when right(num,2) = "D8" then ,
                       num = overlay("51",num,length(num)-1,2)
        /* - 9 */
                    when right(num,2) = "D9" then ,
                       num = overlay("52",num,length(num)-1,2)
        /* + 0 */
                    when right(num,2) = "C0" then ,
                       num = overlay("7B",num,length(num)-1,2)
        /* + 1 */
                    when right(num,2) = "C1" then ,
                       num = overlay("41",num,length(num)-1,2)
        /* + 2 */
                    when right(num,2) = "C2" then ,
                       num = overlay("42",num,length(num)-1,2)
        /* + 3 */
                    when right(num,2) = "C3" then ,
                       num = overlay("43",num,length(num)-1,2)
        /* + 4 */
                    when right(num,2) = "C4" then ,
                       num = overlay("44",num,length(num)-1,2)
        /* + 5 */
                    when right(num,2) = "C5" then ,
                       num = overlay("45",num,length(num)-1,2)
        /* + 6 */
                    when right(num,2) = "C6" then ,
                       num = overlay("46",num,length(num)-1,2)
        /* + 7 */
                    when right(num,2) = "C7" then ,
                       num = overlay("47",num,length(num)-1,2)
        /* + 8 */
                    when right(num,2) = "C8" then ,
                       num = overlay("48",num,length(num)-1,2)
        /* + 9 */
                    when right(num,2) = "C9" then ,
                        num = overlay("49",num,length(num)-1,2)
                    otherwise do
                       call domsg "==>Error :" ,
                                  "During text to numeric conversion, unable" ,
                                  "to convert signed data" ,
                                  right(num,2)
                       call domsg "Parameter values when the error occured:"
                       call domsg "txt           :" txt
                       call domsg "length        :" lengt
                       call domsg "signed        :" signed
                       call domsg "sign_pos      :" sign_pos
                       exit_rc = 12
                       signal done
                    end /* end otherwise do */
                 end /* end select */
              end /* end if sign_pos = "T" then do */
              else if sign_pos = "L" then do
                 select
        /* - 0 */
                    when left(num,2) = "D0" then ,
                       num = overlay("7D",num,1,2)
        /* - 1 */
                    when left(num,2) = "D1" then ,
                       num = overlay("4A",num,1,2)
        /* - 2 */
                    when left(num,2) = "D2" then ,
                       num = overlay("4B",num,1,2)
        /* - 3 */
                    when left(num,2) = "D3" then ,
                       num = overlay("4C",num,1,2)
        /* - 4 */
                    when left(num,2) = "D4" then ,
                       num = overlay("4D",num,1,2)
        /* - 5 */
                    when left(num,2) = "D5" then ,
                       num = overlay("4E",num,1,2)
        /* - 6 */
                    when left(num,2) = "D6" then ,
                       num = overlay("4F",num,1,2)
        /* - 7 */
                    when left(num,2) = "D5" then ,
                       num = overlay("50",num,1,2)
        /* - 8 */
                    when left(num,2) = "D8" then ,
                       num = overlay("51",num,1,2)
        /* - 9 */
                    when left(num,2) = "D9" then ,
                       num = overlay("52",num,1,2)
        /* + 0 */
                    when left(num,2) = "C0" then ,
                       num = overlay("7B",num,1,2)
        /* + 1 */
                    when left(num,2) = "C1" then ,
                       num = overlay("41",num,1,2)
        /* + 2 */
                    when left(num,2) = "C2" then ,
                       num = overlay("42",num,1,2)
        /* + 3 */
                    when left(num,2) = "C3" then ,
                       num = overlay("43",num,1,2)
        /* + 4 */
                    when left(num,2) = "C4" then ,
                       num = overlay("44",num,1,2)
        /* + 5 */
                    when left(num,2) = "C5" then ,
                       num = overlay("45",num,1,2)
        /* + 6 */
                    when left(num,2) = "C6" then ,
                       num = overlay("46",num,1,2)
        /* + 7 */
                    when left(num,2) = "C7" then ,
                       num = overlay("47",num,1,2)
        /* + 8 */
                    when left(num,2) = "C8" then ,
                       num = overlay("48",num,1,2)
        /* + 9 */
                    when left(num,2) = "C9" then ,
                        num = overlay("49",num,1,2)
                    otherwise do
                       call domsg "==>Error :" ,
                                  "During text to numeric conversion, unable" ,
                                  "to convert signed data" ,
                                  left(num,2)
                       call domsg "Parameter values when the error occured:"
                       call domsg "txt           :" txt
                       call domsg "length        :" lengt
                       call domsg "signed        :" signed
                       call domsg "sign_pos      :" sign_pos
                       exit_rc = 12
                       signal done
                    end /* end otherwise do */
                 end /* end select */
              end /* end else if sign_pos = "L" */
           end /* end if rexx_os = "UNIX" | rexx_os = "WIN32" */


           msgid = old_msgid
           return x2c(num)

         bin2txt: procedure expose(globals)
        /* --------------------------------------------------------- *
         * convert binary to text                                    *
         *                                                           *
         * Parameter(s) : bin (mandatory)                            *
         *                length (mandatory) (>0, in bytes)          *
         *                signed (mandatory) (Y/N)                   *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg bin, lengt, signed
           txt = ""
           lengt = strip(word(lengt,1))
           signed = translate(left(strip(signed),1))
           old_msgid = msgid
           msgid = msgid || "bin2txt():"

        /* Check data type and length */
           if signed <> "N" & signed <> "Y" then do
              call domsg "==>Error :" ,
                         "During binary to text conversion, signed (" signed ,
                         ") parameter value is not valid."
              call domsg "Parameter values when the error occured:"
              call domsg "bin           :" c2x(bin)
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if signed <> "N" & signed <> "Y" */
           if length(bin) > 8 then do
              call domsg "==>Error :" ,
                         "During binary to text conversion, length (" ,
                         length(bin) ,
                         ") of binary string is longer than 8 bytes."
              call domsg "Parameter values when the error occured:"
              call domsg "bin           :" c2x(bin)
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if length(txt) > 8 */
           if (lengt <> 8 & lengt <> 4 & lengt <> 2) | ,
              datatype(lengt) <> "NUM" then do
              call domsg "==>Error :" ,
                         "During binary to txt conversion,"  ,
                         "invalid length (" lengt ,
                         ") for COBOL binary item."
              call domsg "Parameter values when the error occured:"
              call domsg "bin           :" c2x(bin)
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if (lengt <> 8 & lengt <> 4 & lengt <> 2) | ,*/
           if lengt <> length(bin) then do
              call domsg "==>Error :" ,
                         "During binary to txt conversion,"  ,
                         "unable to convert a COBOL binary item of",
                         "length" lengt "to a text of length (" length(txt) ")"
              call domsg "Parameter values when the error occured:"
              call domsg "bin           :" c2x(bin)
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if lengt <> length(bin) */

         /* Do the conversion according to the Operating System */
           select
              when rexx_os = "TSO" then do
                 txt = strip(c2d(bin),"L","0")
              end /* end when rexx_os = "TSO" */
              when rexx_os = "UNIX" then do
                 txt = strip(c2d(reverse(bin)),"L","0")
              end /* end when rexx_os = "UNIX" */
              when rexx_os = "WIN32" then do
                 txt = strip(c2d(reverse(bin)),"L","0")
              end /* end when rexx_os = "WIN32" */
              otherwise do
                  call Domsg "==>Error :" ,
                             "During binary to text conversion," ,
                             "unsupported operating system :" rexx_os
                 exit_rc = 12
                 signal done
              end /* end otherwise do  */
           end /* end select */
           if length(txt) = 0 then txt = "0"

         /* If data is signed and negative, perform 2 complement */
           if signed = "Y" then do
              i = 2 ** ((lengt * 8) - 1)
              if txt >= i then do
                 txt = 2 * i - txt
                 txt = "-" || txt
              end /* end if txt >= i */
              else txt = "+" || txt
           end /* end if signed = "Y" */
           if length(txt) = 0 then txt = "0"

           msgid = old_msgid
           return txt

         pack2txt: procedure expose(globals)
        /* --------------------------------------------------------- *
         * convert packed decimal data to text                       *
         *                                                           *
         * Parameter(s) : packed (mandatory)                         *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg packed
           txt = c2x(packed)
           old_msgid = msgid
           msgid = msgid || "pack2txt():"

           /* Check data sign and length */
           signe = right(txt,1)
           if signe <> "A" & ,
              signe <> "B" & ,
              signe <> "C" & ,
              signe <> "D" & ,
              signe <> "E" & ,
              signe <> "F" then do
              call domsg "==>Error :" ,
                         "During packed to text conversion, sign (" signe ,
                         ") is not a valid packed-decimal sign."
              call domsg "Parameter values when the error occured:"
              call domsg "packed        :" c2x(packed)
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if signe <> "A" & , */
           if datatype(substr(txt,1,length(txt)-1)) <> "NUM" then do
              call domsg "==>Error :" ,
                         "During packed to text conversion, packed (" ,
                         txt ,
                         ") is not a valid packed-decimal."
              call domsg "Parameter values when the error occured:"
              call domsg "packed        :" c2x(packed)
              call domsg "length        :" lengt
              call domsg "signed        :" signed
              exit_rc = 12
              signal done
           end /* end if datatype(substr(txt,1,length(txt)-1)) <> "NUM" */
           txt = strip(substr(txt,1,length(txt)-1),"L","0")
           if length(txt) = 0 then txt = "0"
           select
              when signe = "F" then nop
              when signe = "C" then txt = "+" || txt
              when signe = "A" then txt = "+" || txt
              when signe = "E" then txt = "+" || txt
              when signe = "D" then txt = "-" || txt
              when signe = "B" then txt = "-" || txt
              otherwise do
                 call domsg "==>Error :" ,
                            "During packed to text conversion, sign (" ,
                            signe ,
                            ") is not a valid packed-decimal sign."
                 call domsg "Parameter values when the error occured:"
                 call domsg "packed        :" c2x(packed)
                 call domsg "length        :" lengt
                 call domsg "signed        :" signed
                 exit_rc = 12
                 signal done
              end /* end otherwise do */
           end /* end select */
           if length(txt) = 0 then txt = "0"

           msgid = old_msgid
           return txt

         num2txt: procedure expose(globals)
        /* --------------------------------------------------------- *
         * convert numeric data to text                              *
         *                                                           *
         * Parameter(s) : num (mandatory)                            *
         *                signed (mandatory) (Y/N)                   *
         *                sign_pos (mandatory) (L/T/LS/TS)           *
         *                                                           *
         * --------------------------------------------------------- */
           parse arg num, signed, sign_pos
           txt = c2x(num)
           signed = translate(left(strip(signed),1))
           sign_pos = translate(left(strip(sign_pos),2))
           old_msgid = msgid
           msgid = msgid || "num2txt():"

        /* Check data type, sign and sign position */
           if signed <> "Y" & signed <> "N" then do
              call domsg "==>Error :" ,
                         "During numeric to text conversion, signed (" signed ,
                         ") parameter value is not a valid."
              call domsg "Parameter values when the error occured:"
              call domsg "num           :" num
              call domsg "signed        :" signed
              call domsg "sign_pos      :" sign_pos
              exit_rc = 12
              signal done
           end /* end if signed <> "Y" & signed <> "N" */
           if sign_pos <> "L" & ,
              sign_pos <> "T" & ,
              sign_pos <> "LS" & ,
              sign_pos <> "TS" & signe = "Y" then do
              call domsg "==>Error :" ,
                         "During numeric to text conversion, sign position (" ,
                         sign_pos
                         ") is not valid."
              call domsg "Parameter values when the error occured:"
              call domsg "num           :" num
              call domsg "signed        :" signed
              call domsg "sign_pos      :" sign_pos
              exit_rc = 12
              signal done
           end /* end if sign_pos <> "L" &, */


        /* Change Tiny-COBOL signed characters to the MVS style  */
           if rexx_os = "UNIX" | rexx_os = "WIN32"  then do
              if sign_pos = "T" then do
                 select
        /* - 0 */
                    when right(txt,2) = "7D" then ,
                       txt = overlay("D0",txt,length(txt)-1,2)
        /* - 1 */
                    when right(txt,2) = "4A" then ,
                       txt = overlay("D1",txt,length(txt)-1,2)
        /* - 2 */
                    when right(txt,2) = "4B" then ,
                       txt = overlay("D2",txt,length(txt)-1,2)
        /* - 3 */
                    when right(txt,2) = "4C" then ,
                       txt = overlay("D3",txt,length(txt)-1,2)
        /* - 4 */
                    when right(txt,2) = "4D" then ,
                       txt = overlay("D4",txt,length(txt)-1,2)
        /* - 5 */
                    when right(txt,2) = "4E" then ,
                       txt = overlay("D5",txt,length(txt)-1,2)
        /* - 6 */
                    when right(txt,2) = "4F" then ,
                       txt = overlay("D6",txt,length(txt)-1,2)
        /* - 7 */
                    when right(txt,2) = "5D" then ,
                       txt = overlay("D7",txt,length(txt)-1,2)
        /* - 8 */
                    when right(txt,2) = "51" then ,
                       txt = overlay("D8",txt,length(txt)-1,2)
        /* - 9 */
                    when right(txt,2) = "52" then ,
                       txt = overlay("D9",txt,length(txt)-1,2)
        /* + 0 */
                    when right(txt,2) = "7B" then ,
                       txt = overlay("C0",txt,length(txt)-1,2)
        /* + 1 */
                    when right(txt,2) = "41" then ,
                       txt = overlay("C1",txt,length(txt)-1,2)
        /* + 2 */
                    when right(txt,2) = "42" then ,
                       txt = overlay("C2",txt,length(txt)-1,2)
        /* + 3 */
                    when right(txt,2) = "43" then ,
                       txt = overlay("C3",txt,length(txt)-1,2)
        /* + 4 */
                    when right(txt,2) = "44" then ,
                       txt = overlay("C4",txt,length(txt)-1,2)
        /* + 5 */
                    when right(txt,2) = "45" then ,
                       txt = overlay("C5",txt,length(txt)-1,2)
        /* + 6 */
                    when right(txt,2) = "46" then ,
                       txt = overlay("C6",txt,length(txt)-1,2)
        /* + 7 */
                    when right(txt,2) = "47" then ,
                       txt = overlay("C7",txt,length(txt)-1,2)
        /* + 8 */
                    when right(txt,2) = "48" then ,
                       txt = overlay("C8",txt,length(txt)-1,2)
        /* + 9 */
                    when right(txt,2) = "49" then ,
                        txt = overlay("C9",txt,length(txt)-1,2)
                    otherwise do
                       call domsg "==>Error :" ,
                                  "During text to numeric conversion, unable" ,
                                  "to convert signed data" ,
                                  right(txt,2)
                       call domsg "Parameter values when the error occured:"
                       call domsg "num           :" num
                       call domsg "signed        :" signed
                       call domsg "sign_pos      :" sign_pos
                       exit_rc = 12
                       signal done
                    end /* end otherwise do */
                 end /* end select */
              end /* end if sign_pos = "T" then do */
              else if sign_pos = "L" then do
                 select
        /* - 0 */
                    when left(txt,2) = "7D" then ,
                       txt = overlay("D0",txt,1,2)
        /* - 1 */
                    when left(txt,2) = "4A" then ,
                       txt = overlay("D1",txt,1,2)
        /* - 2 */
                    when left(txt,2) = "4B" then ,
                       txt = overlay("D2",txt,1,2)
        /* - 3 */
                    when left(txt,2) = "4C" then ,
                       txt = overlay("D3",txt,1,2)
        /* - 4 */
                    when left(txt,2) = "4D" then ,
                       txt = overlay("D4",txt,1,2)
        /* - 5 */
                    when left(txt,2) = "4E" then ,
                       txt = overlay("D5",txt,1,2)
        /* - 6 */
                    when left(txt,2) = "4F" then ,
                       txt = overlay("D6",txt,1,2)
        /* - 7 */
                    when left(txt,2) = "5D" then ,
                       txt = overlay("D7",txt,1,2)
        /* - 8 */
                    when left(txt,2) = "51" then ,
                       txt = overlay("D8",txt,1,2)
        /* - 9 */
                    when left(txt,2) = "52" then ,
                       txt = overlay("D9",txt,1,2)
        /* + 0 */
                    when left(txt,2) = "7B" then ,
                       txt = overlay("C0",txt,1,2)
        /* + 1 */
                    when left(txt,2) = "41" then ,
                       txt = overlay("C1",txt,1,2)
        /* + 2 */
                    when left(txt,2) = "42" then ,
                       txt = overlay("C2",txt,1,2)
        /* + 3 */
                    when left(txt,2) = "43" then ,
                       txt = overlay("C3",txt,1,2)
        /* + 4 */
                    when left(txt,2) = "44" then ,
                       txt = overlay("C4",txt,1,2)
        /* + 5 */
                    when left(txt,2) = "45" then ,
                       txt = overlay("C5",txt,1,2)
        /* + 6 */
                    when left(txt,2) = "46" then ,
                       txt = overlay("C6",txt,1,2)
        /* + 7 */
                    when left(txt,2) = "47" then ,
                       txt = overlay("C7",txt,1,2)
        /* + 8 */
                    when left(txt,2) = "48" then ,
                       txt = overlay("C8",txt,1,2)
        /* + 9 */
                    when left(txt,2) = "49" then ,
                        txt = overlay("C9",txt,1,2)
                    otherwise do
                       call domsg "==>Error :" ,
                                  "During numeric to text conversion, unable" ,
                                  "to convert signed data" ,
                                  left(txt,2)
                       call domsg "Parameter values when the error occured:"
                       call domsg "num           :" num
                       call domsg "signed        :" signed
                       call domsg "sign_pos      :" sign_pos
                       exit_rc = 12
                       signal done
                    end /* end otherwise do */
                 end /* end select */
              end /* end else if sign_pos = "L" */
           end /* end if rexx_os = "UNIX" | rexx_os = "WIN32" */

        /* Do the conversion according the OS */
           positive = "C"
           negative = "D"
           select
              when rexx_os = "TSO" then do
                 separator = "F"
                 sep_positive = "4E"
                 sep_negative = "60"
              end /* end when rexx_os = "TSO" */
              when rexx_os = "UNIX" then do
                 separator = "3"
                 sep_positive = "2B"
                 sep_negative = "2D"
              end /* end when rexx_os = "UNIX" */
              when rexx_os = "WIN32" then do
                 separator = "3"
                 sep_positive = "2B"
                 sep_negative = "2D"
              end /* end when rexx_os = "WIN32"*/
              otherwise do
                 call domsg "==>Error :" ,
                            "During numeric to text conversion," ,
                            "unsupported operating system :" rexx_os
                 exit_rc = 12
                 signal done
              end /* end otherwise do  */
           end /* end select */

           temp = ""
           select
        /* --------------------------------------------------------- *
         * Unsigned data.                                            *
         * --------------------------------------------------------- */
              when signed = "N" then do
                 do i = 2 to length(txt) by 2
                    if substr(txt,i-1,1) <> separator & ,
                       substr(txt,i-1,1) <> positive & ,
                       substr(txt,i-1,1) <> negative then ,
                       temp = temp || x2c(substr(txt,i-1,2))
                    else temp = temp || substr(txt,i,1)
                 end /* end do i = 2 to length(txt) by 2 */
                 txt = strip(temp,"L","0")
              end /* end when signed = "N" */

        /* --------------------------------------------------------- *
         * Signed data.                                              *
         * --------------------------------------------------------- */
              when signed = "Y" then do
                 select
       /* Trailing sign */
                    when sign_pos = "T" then do
                       do i = 2 to length(txt) by 2
                          if substr(txt,i-1,1) <> separator & ,
                             substr(txt,i-1,1) <> positive & ,
                             substr(txt,i-1,1) <> negative then ,
                             temp = temp || x2c(substr(txt,i-1,2))
                          else temp = temp || substr(txt,i,1)
                       end /* end do i = 2 to length(txt) by 2 */
                       temp = strip(temp,"L","0")
                       if left(right(txt,2),1) = positive then ,
                          temp = "+" || temp
                       else if left(right(txt,2),1) = negative then ,
                               temp = "-" || temp
                       txt = temp
                    end /* end when sign_pos = "T" */

       /* Leading sign */
                    when sign_pos = "L" then do
                       do i = 2 to length(txt) by 2
                          if substr(txt,i-1,1) <> separator & ,
                             substr(txt,i-1,1) <> positive & ,
                             substr(txt,i-1,1) <> negative then ,
                             temp = temp || x2c(substr(txt,i-1,2))
                          else temp = temp || substr(txt,i,1)
                       end /* end do i = 2 to length(txt) by 2 */
                       temp = strip(temp,"L","0")
                       if left(txt,1) = positive then temp = "+" || temp
                       else if left(txt,1) = negative then temp = "-" || temp
                       txt = temp
                    end /* end when sign_pos = "L" */

       /* Trailing sign separate */
                    when sign_pos = "TS" then do
                       do i = 2 to (length(txt) - 2) by 2
                          if substr(txt,i-1,1) <> separator & ,
                             substr(txt,i-1,1) <> positive & ,
                             substr(txt,i-1,1) <> negative then ,
                             temp = temp || x2c(substr(txt,i-1,2))
                          else temp = temp || substr(txt,i,1)
                       end /* end do i = 2 to (length(txt) - 2) by 2 */
                       temp = strip(temp,"L","0")
                       if right(txt,2) = sep_positive then temp = "+" || temp
                       else if right(txt,2) = sep_negative then ,
                               temp = "-" || temp
                       txt = temp
                    end /* end when sign_pos = "TS" */

       /* Leading sign separate */
                    when sign_pos = "LS" then do
                       do i = 4 to length(txt) by 2
                          if substr(txt,i-1,1) <> separator & ,
                             substr(txt,i-1,1) <> positive & ,
                             substr(txt,i-1,1) <> negative then ,
                             temp = temp || x2c(substr(txt,i-1,2))
                          else temp = temp || substr(txt,i,1)
                       end /* end do i = 2 to (length(txt) - 2) by 2 */
                       temp = strip(temp,"L","0")
                       if left(txt,2) = sep_positive then temp = "+" || temp
                       else if left(txt,2) = sep_negative then ,
                               temp = "-" || temp
                       txt = temp
                    end /* end when sign_pos = "LS" */
                    otherwise do
                       call domsg "==>Error :" ,
                                  "During text to numeric conversion," ,
                                  "sign position (" ,
                                  sign_pos
                                  ") is not valid."
                       call domsg "Parameter values when the error occured:"
                       call domsg "num           :" num
                       call domsg "signed        :" signed
                       call domsg "sign_pos      :" sign_pos
                       exit_rc = 12
                       signal done
                    end /* end otherwise do */
                 end /* end select */
              end /* end when signed = "Y" */
              otherwise do
                 call domsg "==>Error :" ,
                            "During numeric to text conversion," ,
                            "signed (" signed ,
                            ") parameter value is not a valid."
                 call domsg "Parameter values when the error occured:"
                 call domsg "num           :" num
                 call domsg "signed        :" signed
                 call domsg "sign_pos      :" sign_pos
                 exit_rc = 12
                 signal done
              end /* end otherwise do */
           end /* end select */
           drop temp
           if length(txt) = 0 then txt = "0"

           msgid = old_msgid
           return txt

