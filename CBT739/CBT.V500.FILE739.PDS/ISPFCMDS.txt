/*%NOCOMMENT  ==============>> REXX <<================================*/
/*                                                                    */
/*  ISPFCMDS   : This EXEC displays the contents of the currently     */
/*               active command tables. It also enables the user to   */
/*               (temporarily) update all the command tables, and to  */
/*               (permanently) save the User-, Application- or Site-  */
/*               tables to disk.  It can also create new command      */
/*               tables and update inactive command tables on disk.   */
/*                                                                    */
/*               It can be invoked from any ISPF application, and     */
/*               should be defined in a User or Site table as:        */
/*               Verb  . . . : CMDS                                   */
/*               Trunc . . . : 0                                      */
/*               Action  . . : SELECT CMD(ISPFCMDS &ZPARM) LANG(CREX) */
/*               Description : 'ISPF Commands' tool                   */
/*                                                                    */
/*  Externals  : pgms   ISPFCMDI,ISPFCMDO,ISPFCMDL                    */
/*             : panels ISPFCMDn  (where n=0-9,C,D)                   */
/*               (help) ISPFCMHn  (n=0-9,A,C,E,G,H,K,M,N,O,S,T,U)     */
/*--------------------------------------------------------------------*/
/*  Written by : Ron Brown                                            */
/*                                                                    */
/*  Version    : 7.0 (for z/OS 1.7)        Last updated: 25 Jan 2007  */
/*--------------------------------------------------------------------*/
/*  Changes    : - allow use in any zscreen (1-9,A-W)                 */
/*--------------------------------------------------------------------*/
/*  Notes      : This code uses the following conventions             */
/*               a) variables in lower case: only used in Rexx        */
/*               b) variables in UPPER CASE: used by ISPF             */
/*               c) functions in Mixed Case: built-in Rexx functions  */
/*               d) functions in UPPER CASE: subroutines in the code  */
/*               e) Rexx keywords in Mixed Case                       */
/*               f) Do .... End  has the 'End' indented               */
/*               g) "......" is addressed to ISPEXEC                  */
/*               h) '......' for all other strings                    */
/*  Please keep these conventions if you modify the code!             */
/*====================================================================*/
  Address ISPEXEC                         /* commands -> ISPEXEC      */
  "CONTROL ERRORS RETURN"                 /* handle return codes here */
  /*------------------------------------------------------------------*/
  /* Where are we, and what command tables could we have?             */
  /* (including the extra possible tables introduced in z/OS 1.5)     */
  /*------------------------------------------------------------------*/
  "VGET (ZAPPLID ZUCTPREF ZSCTPREF ZSCTSRCH ZSCREEN ZPDFREL) SHARED"
  "VGET (ZUCTPRE2 ZUCTPRE3 ZSCTPRE2 ZSCTPRE3) SHARED"  /* ISPF >= 5.5 */

  /*------------------------------------------------------------------*/
  /* Rexx program compiled/linked should be started with 'LANG(CREX)' */
  /* If ISPFCMDS pgm invoked without LANG(CREX) - reinvoke correctly  */
  /*------------------------------------------------------------------*/
  If ZAPPLID = 'ZAPPLID' Then Do   /* VGET no good without LANG(CREX) */
     Parse Arg zparm
     "SELECT CMD(ISPFCMDS" zparm") SCRNAME(CMDS) LANG(CREX)"
     Exit
     End
  /*------------------------------------------------------------------*/
  /* Create new cmds_table, then load all active commands into it     */
  /*------------------------------------------------------------------*/
  Do n = 1 to 8  Until rc > 0       /* create unique table names      */
     tsuf = ZSCREEN||n              /* up to 8 suffixes per ZSCREEN   */
     cmds_table = 'CMDSTB'||tsuf    /* table for list of commands     */
     "TBQUERY" cmds_table           /* check if table already exists  */
     End
  If rc = 0 Then Do                 /* table CMDSTBx8 is already open */
     ZERRLM = 'Sorry, a maximum of 8 "ISPF Commands" dialogs can',
              'run simultaneously in each screen - cannot continue.'
     ZERRSM = ''
     ZERRALRM = 'YES .WINDOW=LRESP' /* alarm, user must press ENTER   */
     "SETMSG MSG(ISRZ002)"
     Exit                           /* EXIT (and show message)        */
     End
  hex_tsuf = X2C(tsuf)              /* used in ZCTDESC of pending cmds*/
  cmdtbs_table = 'CMDTBS'||tsuf     /* table for cmd table statistics */

  /*------------------------------------------------------------------*/
  /* Process parms and create a table of all the active commands      */
  /*------------------------------------------------------------------*/
  Parse Arg zparm
  Call PROCESS_PARM                 /* process invocation parm(s)     */

  Call LOAD_CMDSTABL                /* load commands into cmds_table  */

  /*------------------------------------------------------------------*/
  /* Check if cmds_table was created successfully                     */
  /*------------------------------------------------------------------*/
  If init_rc > 0 Then Do            /* rc=12 (pgm not found)          */
     ZERRSM = ''                    /* rc=24 (use not authorised)     */
     ZERRLM = '** Sorry, ISPFCMDS is not able to start, RC='init_rc '**'
     ZERRALRM = 'YES .WINDOW=LRESP' /* alarm, user must press ENTER   */
     "SETMSG MSG(ISRZ002)"
     Exit
     End

  /*------------------------------------------------------------------*/
  /* Sort the new commands table (cmds_table)                         */
  /*------------------------------------------------------------------*/
  "VGET CUR#SORT PROFILE"             /* get last displayed sort order*/
  If CUR#SORT = '' | CUR#SORT = 'ALIAS' Then
     CUR#SORT = 'REAL ORDER'          /* this is the DEFAULT order    */
  If CUR#SORT = 'REAL ORDER' Then     /* current displayed sort order */
     CMDSORT = CUR#SORT               /* actual sort order            */
  Else Call SORT_CMDSTABL(CUR#SORT)

  /*------------------------------------------------------------------*/
  /* Prepare for table display (table: cmds_table on panel: ISPFCMD0) */
  /*------------------------------------------------------------------*/
  CMDFIND = ''                       /* display ALL commands          */
  Call SETUP_SCAN                    /* set TBSARG for panel ISPFCMD0 */
  Call READ_CONFIG                   /* get userpref & sitepref       */

  null = '00'x                        /* used in some messages        */
  ZCMD = ''
  SELCMD = 'RESIZE'                   /* no Pop-up window wanted      */
  csrrow = 0
  COPYPEND = ''                       /* no pending move/copy         */
  CMDSACT = ''                        /* intially use brief display   */
  MODELIN2 = 'OMIT'                   /* omit the line from )MODEL    */
  tbdispl_rc = 0                      /* RC from TBDISPL              */
  ONLY = ''                           /* displayed on ISPFCMD0 panel  */
  Call SET_ONLY                       /* set the ONLY variable        */

  /*------------------------------------------------------------------*/
  /* Initial display locked while SET_OVER marks the overriding cmds  */
  /*------------------------------------------------------------------*/
  updated = 'Y'                       /* so SETUP_OVER will be run    */
  ZERRSM = 'Checking Overrides'       /* msg while SETUP_OVER runs    */
  ZERRHM = '*'                        /* .HELP to appropriate panel   */
  ZERRALRM = 'NO'
  "SETMSG MSG(ISRZ002)"
  "CONTROL DISPLAY LOCK"              /* initial table display locked */

  Do tdloop = 1 to 9999
    /*----------------------------------------------------------------*/
    /* Prepare any pending selected cmd to be actioned by ISPFCMD0    */
    /*----------------------------------------------------------------*/
    cmdtop = ZTDTOP                   /* save the top line number     */
    If pendcmds > 0 & tbdispl_rc = 0 Then Do
       Call PREPARE_PENDCMD           /* put cmd into SELCMD variable */
       "CONTROL NONDISPL ENTER"       /* panel ISPFCMD0 will enter cmd*/
       End
    If pendcmds > 1
       Then PENDMSG = '*** Press ENTER for pending command ***'
       Else If COPYPEND ¬= ''
          Then PENDMSG = '***  Move / Copy  pending  ***'
          Else PENDMSG = ''

    /*----------------------------------------------------------------*/
    /* Display a list of active Commands, (panel ISPFCMD0).           */
    /*   - this panel has a variable model line so it can show either */
    /*    one or two lines per command depending on the user's choice */
    /*----------------------------------------------------------------*/
     "TBDISPL" cmds_table "PANEL(ISPFCMD0)",
        "AUTOSEL(YES) CSRROW("csrrow")"
     tbdispl_rc = RC

     If pendcmds > 0 Then
        Call DELETE_PENDCMD           /* delete pending cmd from table*/
     If pendcmds > 0 Then             /* loop thru the pending cmds   */
        Iterate tdloop
     If tbdispl_rc >= 8 Then          /* RC=8: END, RETURN, CAN, EXIT */
        Leave tdloop                  /* exitting from ISPFCMDS       */

     /*---------------------------------------------------------------*/
     /* Process any line commands  (ZTDSELS = no. of selected rows)   */
     /*---------------------------------------------------------------*/
     If ZCMD = 'COPY' ,               /* copy rows to another table   */
     | COPYCMDS = YES Then
        Call COPY_ROWS
     If ZTDSELS > 0 Then Do           /* some rows were selected      */
        "TBTOP" firstab               /* prepare to store pend selects*/
        pendcmds = 0                  /* ..added to top of first table*/
        End
     last_ZTDSELS = 0                 /* checked by VALIDATE_CMDSTABL */
     Do ZTDSELS                       /* only if some rows selected.. */
        Call GET_ROW                  /* get selected row from table  */
        If result = 0,
         & Pos(SEL,'SVX') = 0 Then    /* for any update selection ..  */
           Call VALIDATE_CMDSTABL     /* .... is cmds_table valid?    */
        If result = 0 Then Select
          When SEL = 'I' Then                /*  Insert a new command */
             Call INSERT_CMD
          When SEL = 'R' Then                /*  Repeat a command     */
             Call REPEAT_CMD
          When SEL = 'D' Then                /*  Delete the command   */
             Call DELETE_CMD
          When SEL = 'U' | SEL = 'E' Then    /*  Update the command   */
             Call UPDATE_CMD
          When SEL = ' ' Then                /*  Updated on ISPFCMD0  */
             If CMDSACT = '/' Then           /*  Actions displayed    */
                Call UPDATE_CMD
          When SEL = 'V' Then                /*  View a command       */
             Call VIEW_CMD
          When SEL = 'A' | SEL = 'B' Then    /*  'after' or 'before'  */
             Call COPY_CMD
          When SEL = 'C' | SEL = 'M' Then    /*  Copy or Move command */
             Call COPY_CMD
          When SEL = 'S' Then                /*  Invoke the command   */
             Call INVOKE_CMD
          When SEL = 'X' Then                /*  Exclude the command  */
             Call EXCLUDE_CMD
          When SEL = 'H' Then                /*  Display command HELP */
             Call DISPLAY_HELP
          Otherwise                          /*  Invalid              */
             Say '*** selection' SEL 'for' ZCTVERB 'ignored'
          End
        If ZTDSELS = 1 Then Leave     /* finished all selected rows   */
        SEL = ''
       "TBDISPL" cmds_table           /* get next selected row        */
        tbdispl_rc = RC
        If tbdispl_rc > 8 Then        /* some kind of ERROR           */
           Leave tdloop               /* exitting from ISPFCMDS       */
        End

     /*---------------------------------------------------------------*/
     /* Mark overriding and overridden commands with '*' and '-'      */
     /*---------------------------------------------------------------*/
     If updated = 'Y' Then Do         /* If the user updated the list */
        If CMDSORT ¬= 'REAL ORDER' Then   /* CMDSORT = actual order   */
           Call SORT_CMDSTABL('R')    /* sort for SETUP_OVER          */
        Call SETUP_OVER               /* ... mark the overriding cmds */
        If CUR#SORT ¬= 'REAL ORDER' Then  /* CUR#SORT = desired order */
           Call SORT_CMDSTABL(CUR#SORT) /*.. & restore the sort order */
        updated = 'N'
        End
     /*---------------------------------------------------------------*/
     /* Process primary commands                                      */
     /*---------------------------------------------------------------*/
     Parse Upper Var ZCMD cmd cmdparm
     Select
      When cmd = '1' Then Do            /**** SWITCH DISPLAYS      ****/
         If CMDSACT = '' Then CMDSACT = '/'
                         Else CMDSACT = ''
         End
      When cmd = '2' Then               /**** DISPLAY TABLE INFO   ****/
         Call DISPLAY_TABLINFO
      When cmd = '3' Then Do            /**** SAVE/CREATE USER CMDS ***/
         If ZUCTPREF || ZUCTPRE2 || ZUCTPRE3 = ''
            Then Call CREATE_TABL('USER')
            Else Call SAVE_TABL('USER')
         End
      When Pos(cmd,'SAVEUSER') = 1 ,    /**** SAVE USER COMMANDS   ****/
       & Length(cmd) > 3 Then
         Call SAVE_TABL('USER')
      When cmd = 'SAVEUSR1' Then        /**** SAVE USR1 COMMANDS   ****/
         Call SAVE_TABL('USR1')
      When cmd = 'SAVEUSR2' Then        /**** SAVE USR2 COMMANDS   ****/
         Call SAVE_TABL('USR2')
      When cmd = 'SAVEUSR3' Then        /**** SAVE USR3 COMMANDS   ****/
         Call SAVE_TABL('USR3')
      When Pos(cmd,'SAVEAPPL') = 1 ,    /**** SAVE APPL COMMANDS   ****/
       & Length(cmd) > 4 Then
         Call SAVE_TABL('APPL')
      When Pos(cmd,'SAVESITE') = 1 ,    /**** SAVE SITE COMMANDS   ****/
       & Length(cmd) > 4 Then
         Call SAVE_TABL('SITE')
      When cmd = 'SAVESIT1' Then        /**** SAVE SIT1 COMMANDS   ****/
         Call SAVE_TABL('SIT1')
      When cmd = 'SAVESIT2' Then        /**** SAVE SIT2 COMMANDS   ****/
         Call SAVE_TABL('SIT2')
      When cmd = 'SAVESIT3' Then        /**** SAVE SIT3 COMMANDS   ****/
         Call SAVE_TABL('SIT3')
      When Pos(cmd,'NEWUSER') = 1 ,     /**** CREATE NEW USER TABLE ***/
       & Length(cmd) > 3 Then
         Call CREATE_TABL('USER')
      When Pos(cmd,'NEWAPPL') = 1 ,     /**** CREATE NEW APPL TABLE ***/
       & Length(cmd) > 3 Then
         Call CREATE_APPLTABL
      When Pos(cmd,'NEWSITE') = 1 ,     /**** CREATE NEW SITE TABLE ***/
       & Length(cmd) > 3 Then
         Call CREATE_TABL('SITE')
      When cmd = 'L' Then               /**** LOCATE A COMMAND     ****/
         Call LOCATE_ROW
      When Pos(cmd,'SORT') = 1 ,        /**** SORT THE COMMANDS    ****/
       & Length(cmd) > 1 Then
         CMDSORT = cmdparm
      When Pos(cmd,'OVER') = 1 Then Do  /**** SHOW ONLY OVERRIDES  ****/
         ONLY = ' ONLY OVERRIDES'       /* text for panel ISPFCMD0    */
         CUR#SCAN = '?????????'         /* so SETUP_SCAN is called    */
         If CMDSORT = 'ALIAS' Then
            CMDSORT = 'REAL ORDER'
         End
      When Pos(cmd,'NOVER') = 1 Then Do /**** SHOW NOT OVERRIDES   ****/
         ONLY = ' NOT OVERRIDES'        /* text for panel ISPFCMD0    */
         CUR#SCAN = '?????????'         /* so SETUP_SCAN is called    */
         If CMDSORT = 'ALIAS' Then
            CMDSORT = 'REAL ORDER'
         End
      When Pos(cmd,'ALIAS') = 1 Then Do /**** SHOW ONLY ALIASES    ****/
         Call SORT_CMDSTABL('R')        /* sort into REAL ORDER       */
         Call FIND_ALIASES              /* find all alias commands    */
         ONLY = ' ONLY ALIASES'         /* text for panel ISPFCMD0    */
         CMDSACT = '/'                  /* show command actions       */
         CUR#SCAN = '?????????'         /* so SETUP_SCAN is called    */
         Call SORT_CMDSTABL('AL')       /* sort to ALIAS order        */
         End
      When Pos(cmd,'TRUNC') = 1 Then Do /**** SHOW ONLY TRUNCATED  ****/
         ONLY = ' ONLY TRUNCATED'       /* text for panel ISPFCMD0    */
         CMDSACT = '/'                  /* show command actions       */
         CUR#SCAN = '?????????'         /* so SETUP_SCAN is called    */
         If CMDSORT = 'ALIAS' Then
            CMDSORT = 'REAL ORDER'
         End
      When Pos(cmd,'RESET') = 1 ,       /**** RESET THE LIST       ****/
       & Length(cmd) > 2 Then Do
         COPYPEND = ''                  /* no pending move/copy       */
         COPYCMDS = ''                  /* no pending copy cmds       */
         Call SELECT_TABLES             /* update CMDSEL variables    */
         ONLY = ''                      /* no 'ONLY' text on panel    */
         Call SET_ONLY                  /* update the ONLY variable   */
         Call SETUP_SCAN                /* new scan is required       */
         If CMDSORT = 'ALIAS' Then
            CMDSORT = 'REAL ORDER'
         End
      When Pos(cmd,'REFRESH') = 1 ,     /**** REFRESH THE LIST     ****/
       & Length(cmd) > 2 Then Do
         COPYPEND = ''                  /* no pending move/copy       */
         COPYCMDS = ''                  /* no pending copy cmds       */
         Call LOAD_CMDSTABL             /* recreate cmds_table        */
         If CMDSORT ¬= 'REAL ORDER' Then  /* CMDSORT = actual order   */
            Call SORT_CMDSTABL('R')     /* sort into REAL ORDER       */
         Call SETUP_OVER                /* mark overriding commands   */
         If ONLY = ' ONLY ALIASES' Then
            Call FIND_ALIASES           /* find all alias commands    */
      /* CMDSCAN = '' */                /* display ALL commands       */
      /* CMDFIND = '' */                /* display ALL commands       */
         Call SETUP_SCAN                /* new scan is required       */
         If CUR#SORT ¬= 'REAL ORDER' Then /* CUR#SORT = desired order */
            Call SORT_CMDSTABL(CUR#SORT)  /* back to current order    */
         End
      When Pos(cmd,'CONFIG') = 1,       /**** CONFIGURATION UTILITY ***/
       & Length(cmd) > 3 Then Do
         "SELECT CMD(%JSPCCONF) NEWAPPL(ISR) PASSLIB"     /* Extended */
         If rc > 0 Then
            "SELECT CMD(%ISPCCONF) NEWAPPL(ISR) PASSLIB"  /* standard */
         End
      Otherwise
         csrrow = 0
      End
     /*---------------------------------------------------------------*/
     /* Process any changes to the selected tables or the cmd scan    */
     /*---------------------------------------------------------------*/
     If CUR#TABS ¬= T1','T2','T3','T4 Then Do
        Call SELECT_TABLES            /* update CMDSEL vars           */
        Call SET_ONLY                 /* update the ONLY variable     */
        new_tab_sel = 'Y'
        End
     Else new_tab_sel = 'N'           /* no new table selection       */

     If CUR#FIND ¬= CMDFIND | CUR#SCAN ¬= CMDSCAN Then Do
        Call SETUP_SCAN               /* setup row scan for TBDISPL   */
        new_cmd_scan = 'Y'
        End
     Else new_cmd_scan = 'N'          /* no new command scan          */

     If Left(CUR#SORT,1) ¬= Left(CMDSORT,1) Then Do
        Call SORT_CMDSTABL(CMDSORT)   /* sort the displayed commands  */
        new_cmd_sort = 'Y'
        End
     Else new_cmd_sort = 'N'          /* no new command sort          */

     /*----------------------------*/
     /* maintain top row displayed */
     /*----------------------------*/
     If  cmd ¬= 'L' ,
      &  new_cmd_sort = 'N' ,
      &  new_cmd_scan = 'N' ,
      &  new_tab_sel  = 'N' Then Do
        "TBTOP" cmds_table
        "TBSKIP" cmds_table "NUMBER("ZTDTOP") NOREAD"
        End
     End                              /* end of tdloop (Do loop)      */
  /*------------------------------------------------------------------*/
  /* Clean up and exit                                                */
  /*------------------------------------------------------------------*/
  "VPUT CUR#SORT PROFILE"             /* save last-used sort order    */
  "CONTROL ERRORS RETURN"
  "TBQUERY" cmdtbs_table
  If rc = 0 Then
     "TBEND" cmdtbs_table
  "TBEND" cmds_table                  /* finished with the tables     */
  If tbdispl_rc > 8 Then Do
     ZERRSM = ''                      /* no short message             */
     ZERRLM = '***  Error: TBDISPL of table' cmds_table',',
              'using panel ISPFCMD0 has FAILED, rc =' tbdispl_rc
     ZERRALRM = 'YES .WINDOW=LRESP'   /* alarm, user must press ENTER */
     "SETMSG MSG(ISRZ002)"            /* standard IBM message         */
     End
  Return

/*====================================================================*/
/*====                    SUBROUTINES                             ====*/
/*====================================================================*/

/*==================================================================*/
/* Process invocation parm(s)                                       */
/*------------------------------------------------------------------*/
PROCESS_PARM:
    Parse Upper Value zparm With 1 mask1 'APPL(' applid ')' mask2
    mask = mask1 mask2
    /*--------------------------------------------------*/
    /* process parms which include 'APPL(xx)' parameter */
    /*--------------------------------------------------*/
    If applid ¬= '' Then Do
       If applid = ZAPPLID Then Do     /* same as current Appl-Id     */
          CMDSCAN = Word(mask,1)
          If applid = 'ISP' Then
             only_syst = 'YES'       /* display only SYSTEM table     */
          Else
             only_appl = 'YES'       /* display only the APPL table   */
          Return
          End
       Call CONFIRM_TABLE              /* ensure the table exists     */
       If result > 0 Then Exit

       If applid = ZUCTPREF | applid = ZUCTPRE2 | applid = ZUCTPRE3 ,
        | applid = ZSCTPREF | applid = ZSCTPRE2 | applid = ZSCTPRE3 ,
        | applid = 'ISP' Then
          lib_type = '01'x               /* '01'x = library is known  */
       /*-----------------------------------------------------------*/
       /* re-invoke ISPFCMDS in the right appl-id to open the table */
       /*-----------------------------------------------------------*/
       Parse Source where_from
       If Word(where_from,4) = '?' Then
          "SELECT CMD(ISPFCMDS" lib_type mask ") SCRNAME(CMDS)",
             "NEWAPPL("applid") LANG(CREX) PASSLIB"
       Else
          "SELECT CMD(%ISPFCMDS" lib_type mask ") SCRNAME(CMDS)",
             "NEWAPPL("applid") PASSLIB"
       If libdef_rc = 0 Then
          "LIBDEF ISPTLIB"
       If alloc_rc = 0 Then Do
          "TBOPEN XXXXX LIBRARY(XXX)"  /* this makes the FREE work  */
          Address TSO "FREE FI(CMTEMP"tsuf")"
          End
       Exit
       End
    /*--------------------------------------------*/
    /* process parms without 'APPL(xx)' parameter */
    /*--------------------------------------------*/
    If Word(zparm,1) = '01'x ,
     | Word(zparm,1) = '02'x Then Do /* ISPFCMDS has been re-invoked  */
       If Word(zparm,1) = '02'x Then     /* 01 = known   02 = unknown */
          appl_lib = 'unknown'       /* Cannot be sure which library  */
                                     /* ... the table came from.      */
       CMDSCAN = Word(zparm,2)
       Select
         When ZAPPLID = 'ISP' Then
            only_syst = 'YES'        /* display only SYSTEM table     */
         Otherwise
            only_appl = 'YES'        /* display only the APPL table   */
         End
       End
    Else
       CMDSCAN = Word(zparm,1)       /* cmd-name mask, or display ALL */
    Return

/*==================================================================*/
/* Ensure that an application table exists                          */
/* - this is called by PROCESS_PARM and COPY_ROWS                   */
/*------------------------------------------------------------------*/
CONFIRM_TABLE:
    /*----------------------------------*/
    /* check status of the chosen table */
    /*----------------------------------*/
    "TBSTATS" applid"CMDS STATUS1(s1) STATUS2(s2) STATUS3(s3)"
    If s3 = 2 Then                  /* table not avail for WRITE mode */
       lib_type = '02'x             /* '02'x = open, library unknown  */
    /*-------------------------------------------------------------*/
    /* table not already open, library must be confirmed/specified */
    /*-------------------------------------------------------------*/
    Else Do
       TABNAME = applid'CMDS'
       LIBNAME = ''
       VOLUME  = ''
       If s1 = 1 Then                         /* table is in ISPTLIB  */
          LIBNAME = FIND_MEMBER(TABNAME 'ISPTLIB')
       conf_lib = LIBNAME
       conf_vol = VOLUME
       Call CONFIRM_LIBRARY        /* show window for user to confirm */
       If result > 0 Then Return 8
       /*----------------------------------------------------*/
       /* allocate the library (using a LIBDEF) if necessary */
       /*----------------------------------------------------*/
       If COPYROWS ¬= 'YES' ,       /* not copying rows to this table */
       & (LIBNAME ¬= conf_lib | VOLUME ¬= conf_vol) Then Do
          If VOLUME ¬= ''
             Then vol_parm = 'VOL('VOLUME')'
             Else vol_parm = ''
          Address TSO "ALLOC FI(CMTEMP"tsuf") DSN('"LIBNAME"')",
             vol_parm "SHR REUSE"
          alloc_rc = rc
          "LIBDEF ISPTLIB LIBRARY",       /* ISPTUSR not concatenated */
             "ID(CMTEMP"tsuf") STACK"
          libdef_rc = rc
          End
       lib_type = '01'x                  /* '01'x = library is known  */
       End
    Return

/*==================================================================*/
/* Load the temporary CMDS table from the open command tables       */
/* (in the correct order)                                           */
/*------------------------------------------------------------------*/
LOAD_CMDSTABL:
trace O
    CMDSEL = '/'              /* rows to be selected by the SCAN      */
    CMDALIAS = ''             /* alias commands initially blank       */
    CMDOVER = ''              /* command overrides initially blank    */
    CMDNUM = 90               /* command order numbers (for sorting)  */
    CMDFND = ''               /* desc/action finds initially blank    */
    firstab = ''              /* name of first command table          */
    pendcmds = 0              /* no pending selected commands         */
    "TBQUERY" Strip(ZUCTPREF)"CMDS ROWNUM(qrows)"
    If qrows = 0 Then
       user_empty = 'YES'     /* User table is empty (no commands)    */
    "TBQUERY" Strip(ZSCTPREF)"CMDS ROWNUM(qrows)"
    If qrows = 0 Then
       site_empty = 'YES'     /* Site table is empty (no commands)    */
  /*-----------------------------------------------------*/
  /*  create a new temporary CMDS table                  */
  /*  - table structure is documented in ISPFCMDI source */
  /*-----------------------------------------------------*/
  /*Address TSO "CALL *(ISPFCMDI) '"cmds_table"'" ** TBCREATE NOWRITE */

    "TBEND" cmds_table        /* remove any existing temp table first */
    "TBCREATE" cmds_table "NOWRITE",
       "NAMES(CMDTAB CMDTORD CMDOVER CMDSEL CMDALIAS CMDNUM CMDFND",
             "CMDTRUNC CMDMINL ZCTVERB ZCTTRUNC ZCTDESC, ZCTACT)"
    init_rc = rc
    If init_rc > 0 Then Return

  /*-----------------------------------*/
  /*  copy Appl table into cmds_table  */
  /*-----------------------------------*/
    If only_syst = 'YES' Then   /* If ISPFCMDS started with APPL(ISP) */
       CMDSEL = ' '             /* don't display this table initially */
    to_table = cmds_table       /* table to be copied to              */
    If ZAPPLID ¬= 'ISP' Then Do /* the ISP table is not an Appl table */
       from_table = ZAPPLID"CMDS"
       CMDTAB = ZAPPLID
       CMDTORD = 1              /* the command table order            */
       Call COPY_TABLE          /* copy from_table into cmds_table    */
       If result = 0 Then Do
          T1 = '/'              /* indicates the table was copied     */
          If firstab = '' Then
             firstab = from_table
          End
       Else T1 = ''             /* indicates the table was not copied */
       End
    Else T1 = ''                /* set to blank if Applid = 'ISP'     */
    If T1 = '' Then             /* NOAPPL is used by ISPFCMD0 panel   */
       NOAPPL = 'YES'
    If only_appl = 'YES' Then   /* If ISPFCMDS started with APPL(xx)  */
       CMDSEL = ' '             /* don't display the following tables */
  /*--------------------------------------*/
  /*  copy User table(s) into cmds_table  */
  /*--------------------------------------*/
    If ZUCTPREF || ZUCTPRE2 || ZUCTPRE3 ¬= '' Then Do
       T2 = ''
       If ZUCTPREF ¬= '',       /* User table prefix, but only if open*/
        & ZAPPLID ¬= ZUCTPREF Then Do       /* this is not Appl table */
          from_table = Strip(ZUCTPREF)"CMDS"          /* User table   */
          CMDTAB = ZUCTPREF
          CMDTORD = '2A'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T2 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       If ZUCTPRE2 ¬= '',        /* 2nd User table prefix, (iff open) */
        & ZAPPLID ¬= ZUCTPRE2 Then Do       /* this is not Appl table */
          from_table = Strip(ZUCTPRE2)"CMDS"          /* User table 2 */
          CMDTAB = ZUCTPRE2
          CMDTORD = '2B'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T2 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       If ZUCTPRE3 ¬= '',        /* 3rd User table prefix, (iff open) */
        & ZAPPLID ¬= ZUCTPRE3 Then Do       /* this is not Appl table */
          from_table = Strip(ZUCTPRE3)"CMDS"          /* User table 3 */
          CMDTAB = ZUCTPRE3
          CMDTORD = '2C'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T2 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       End
    Else T2 = ''                /* set to blank if no User table open */
  /*------------------------------------*/
  /*  copy third table into cmds_table  */
  /*------------------------------------*/
    If ZSCTSRCH = 'A' Then Do
       from_table = "ISPCMDS"                  /* System table */
       CMDTAB = "ISP"
       If only_syst = 'YES' Then
          CMDSEL = '/'          /* display only this table initially  */
       CMDTORD = 3              /* the command table order            */
       Call COPY_TABLE          /* copy from_table into cmds_table    */
       T3 = '/'                 /* indicates the table was copied     */
       If firstab = '' Then
          firstab = from_table
       End
    If ZSCTSRCH = 'B' Then Do
       T3 = ''
       If ZSCTPREF ¬= '',       /* Site table prefix, but only if open*/
        & ZAPPLID ¬= ZSCTPREF Then Do       /* this is not Appl table */
          from_table = Strip(ZSCTPREF)"CMDS"   /* Site table   */
          CMDTAB = ZSCTPREF
          CMDTORD = '3A'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T3 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       If ZSCTPRE2 ¬= '',        /* 2nd Site table prefix, (iff open) */
        & ZAPPLID ¬= ZSCTPRE2 Then Do       /* this is not Appl table */
          from_table = Strip(ZSCTPRE2)"CMDS"   /* Site table 2 */
          CMDTAB = ZSCTPRE2
          CMDTORD = '3B'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T3 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       If ZSCTPRE3 ¬= '',        /* 3rd User table prefix, (iff open) */
        & ZAPPLID ¬= ZSCTPRE3 Then Do       /* this is not Appl table */
          from_table = Strip(ZSCTPRE3)"CMDS"   /* Site table 3 */
          CMDTAB = ZSCTPRE3
          CMDTORD = '3C'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T3 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       End
  /*-------------------------------------*/
  /*  copy fourth table into cmds_table  */
  /*-------------------------------------*/
    If ZSCTSRCH = 'B' Then Do
       from_table = "ISPCMDS"                  /* System table */
       CMDTAB = "ISP"
       If only_syst = 'YES' Then
          CMDSEL = '/'          /* display only this table initially  */
       CMDTORD = 4              /* the command table order            */
       Call COPY_TABLE          /* copy from_table into cmds_table    */
       T4 = '/'                 /* indicates the table was copied     */
       If firstab = '' Then
          firstab = from_table
       End
    If ZSCTSRCH = 'A' Then Do
       T4 = ''
       If ZSCTPREF ¬= '',       /* Site table prefix, but only if open*/
        & ZAPPLID ¬= ZSCTPREF Then Do       /* this is not Appl table */
          from_table = Strip(ZSCTPREF)"CMDS"   /* Site table   */
          CMDTAB = ZSCTPREF
          CMDTORD = '4A'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T4 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       If ZSCTPRE2 ¬= '',        /* 2nd Site table prefix, (iff open) */
        & ZAPPLID ¬= ZSCTPRE2 Then Do       /* this is not Appl table */
          from_table = Strip(ZSCTPRE2)"CMDS"   /* Site table 2 */
          CMDTAB = ZSCTPRE2
          CMDTORD = '4B'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T4 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       If ZSCTPRE3 ¬= '',        /* 3rd User table prefix, (iff open) */
        & ZAPPLID ¬= ZSCTPRE3 Then Do       /* this is not Appl table */
          from_table = Strip(ZSCTPRE3)"CMDS"   /* Site table 3 */
          CMDTAB = ZSCTPRE3
          CMDTORD = '4C'        /* the command table order            */
          Call COPY_TABLE       /* copy from_table into cmds_table    */
          If result = 0 Then Do
             T4 = '/'           /* indicates the table was copied     */
             If firstab = '' Then
                firstab = from_table
             End
          End
       End
    "TBTOP" cmds_table

    /*---------------------------------*/
    /* ISPFCMDS started with APPL(xx)  */
    /*---------------------------------*/
    If only_appl = 'YES' Then Do
       only_appl = 'NO'               /* we want to do this only once */
       Parse Value '/,,,' With T1','T2','T3','T4 /* reset 'Tx' vars */
       End
    If only_syst = 'YES' Then Do
       only_syst = 'NO'
       If ZSCTSRCH = 'A' Then         /* Site AFTER System table      */
          Parse Value ',,/,' With T1','T2','T3','T4
       If ZSCTSRCH = 'B' Then         /* Site BEFORE System table     */
          Parse Value ',,,/' With T1','T2','T3','T4
       End
    /*-----------------------------------------------------------*/
    /* Preserving any existing table selections (for RES or REF) */
    /*-----------------------------------------------------------*/
    If CUR#TABS ¬= 'CUR#TABS' Then Do /* these are the old selections */
       curtabs = T1','T2','T3','T4 /* tables selected by LOAD_CMSTABL */
       Parse Var CUR#TABS T1','T2','T3','T4        /* reset 'Tx' vars */
       CUR#TABS = curtabs           /* keep previous table selection  */
       End
    Return

/*==================================================================*/
/* Copy a command table into the temporary CMDS table.              */
/* This is called from LOAD_CMDSTABL, once for each open command    */
/* table.  It is also called from SAVE_TABL.                        */
/* Any running or pending commands are not copied.                  */
/*------------------------------------------------------------------*/
COPY_TABLE:
    Arg copy_type
    If copy_type ¬= 'NODUMMY' Then Do
       "TBQUERY" from_table "ROWNUM(qrows)"
       If qrows = 0 Then Do
          ZCTVERB  = '--------'
          ZCTTRUNC = '0'
          ZCTACT   = ''            /* null action = 'do nothing'    */
          ZCTDESC  = '<<< no commands in this table >>>'
          CMDNUM = CMDNUM + 10     /* number the row (for sorting)  */
          CMDTRUNC = ''            /* no truncation                 */
          "TBADD" to_table
          Return 0
          End
       End
    "TBVCLEAR" from_table
    If rc > 0 Then Return 4          /* table not open -> return    */
    "TBTOP" from_table
    Do copying = 1 to 9999
       "TBSKIP" from_table
       If rc > 0 Then Leave copying         /* rc=8 at end of table */
       If (Word(ZCTDESC,2) = '<<RUNNING>>' ,
        |  Word(ZCTDESC,2) = '<<PENDING>>'),
        &  Word(ZCTDESC,1) <= '99'x ,
        &  Datatype(C2X(Word(ZCTDESC,1))) = 'NUM'
           Then Iterate copying        /* pending cmd - try next row*/
       CMDMINL = Length(Strip(ZCTVERB))    /* no. of chars required */
       If ZCTTRUNC = 0 | ZCTTRUNC = CMDMINL Then
          CMDTRUNC = ''
       Else Do
          If Datatype(ZCTTRUNC) <> 'NUM' Then Do  /* INVALID value| */
             CMDMINL = 8
             CMDTRUNC = '????????'
             End
          Else Do
             CMDMINL = Max(2,ZCTTRUNC)                 /* minimum=2 */
             CMDTRUNC = Copies('-',CMDMINL) /* underline in display */
             End
          End
       CMDNUM = CMDNUM + 10        /* number the rows (for sorting) */
       "TBADD" to_table "MULT(200)"     /* get storage for 200 rows */
       End
    Return 0

/*==================================================================*/
/* Search the table for ALIASes & update CMDALIAS variables         */
/*  - Table has been already been sorted into REAL ORDER, and       */
/*    will be sorted into ALIAS order for the next table display.   */
/*    That sort uses CMDALIAS, which is either blank or it has a    */
/*    unique number for each group of alias commands.               */
/*  - This is called whenever user issues 'ALIAS' command.          */
/*------------------------------------------------------------------*/
FIND_ALIASES:
    alias_list = ' '                /* list of all the ALIASes      */
    "TBTOP" cmds_table              /* going from top to bottom     */
    Do a = 1 To 9999                /* process up to 9999 rows||    */
       "TBSKIP" cmds_table
       If rc > 0 Then Leave         /* rc=8 when it's at the bottom */
       CMDALIAS = ' '               /* blank = do not show this row */

       If CMDTRUNC = '' Then Do     /* exact command verb matches   */
          vpos = WordPos(ZCTVERB,alias_list)
          If vpos > 0 Then
             CMDALIAS = vpos        /* show this row                */
          End
       If CMDTRUNC ¬= '' Then       /* when truncation is allowed   */
          Do b = ZCTTRUNC To Length(Strip(ZCTVERB))
             vpos = WordPos(Left(ZCTVERB,b),alias_list)
             If vpos > 0 Then Do    /* truncated verb in the list   */
                CMDALIAS = vpos     /* show this row                */
                Leave b
                End
             End

       Parse Upper Var ZCTACT act          /* convert to upper case */
       If Word(act,1) = 'ALIAS' Then Do
          alias = Word(act,2)
          apos = WordPos(alias,alias_list)
          If apos > 0 Then                 /* already in alias_list */
             CMDALIAS = apos                       /* show this row */
          Else Do
             If CMDALIAS = ' ' Then Do
                alias_list = alias_list alias
                CMDALIAS = Words(alias_list)       /* show this row */
                End
             Else Nop  /* alias of an alias - the row will be shown */
             End
          End

       "TBPUT" cmds_table "ORDER"     /* update CMDALIAS in the row */
       End
    Return

/*==================================================================*/
/* Set up argument for the SCAN in the TBDISPL panel (ISPFCMD0)     */
/* 1.If the user wants to find all cmds with a particular string in */
/*   the description or action fields, it must examine every table  */
/*   row and update the CMDFND field when there is a match.         */
/* 2.The search arguments are then set up according to the user's   */
/*   selections.                                                    */
/*------------------------------------------------------------------*/
SETUP_SCAN:
    "CONTROL NONDISPL ENTER"         /* so panel can update ZTDMARK */
    /*------------------------*/
    /* FIND all matching rows */
    /*------------------------*/
    If CMDFIND ¬= '' & CMDFIND ¬= '*' Then Do
       If Words(CMDFIND) > 1 ,
        & (Word(CMDFIND,1) = 'NOT' | Word(CMDFIND,1) = '¬')
       Then Do       /* find all cmds WITHOUT this character string */
          find_string = Subword(CMDFIND,2)
          find_type = 'NOT'
          End
       Else Do      /* find all cmds MATCHING this character string */
          find_string = CMDFIND
          find_type = 'MATCH'
          End
       "TBTOP" cmds_table
       "TBSKIP" cmds_table
       Do Until rc > 0               /* rc=8 when it's at the bottom */
          Parse Upper Var ZCTDESC upper_desc
          Parse Upper Var ZCTACT  upper_act /* convert to upper case */
          If (find_type = 'MATCH' & (Pos(find_string,upper_desc) > 0 ,
                                  | Pos(find_string,upper_act) > 0 )),
          |  (find_type = 'NOT'   & (Pos(find_string,upper_desc) = 0 ,
                                  & Pos(find_string,upper_act) = 0 ))
          Then Do
             CMDFND = CMDFIND
             "TBPUT" cmds_table "ORDER"  /* update CMDFND in the row */
             End
          "TBSKIP" cmds_table
          End
       End

    /*------------------------------------------------------------*/
    /* set up the TBSARG which is used for SCAN by panel ISPFCMD0 */
    /*------------------------------------------------------------*/
    "TBVCLEAR" cmds_table
    If CMDSCAN = '' Then
       ZCTVERB = '*'
    Else If Right(CMDSCAN,1) ¬= '*'
       Then ZCTVERB = CMDSCAN'*'
       Else ZCTVERB = CMDSCAN
    CMDSEL   = '/'
    name_conds = 'ZCTVERB,EQ,CMDSEL,EQ'
    If CMDFIND ¬= '' Then Do
       "TBTOP" cmds_table
       CMDFND = CMDFIND
       name_conds = name_conds',CMDFND,EQ'
       End
    If ONLY = ' ONLY ALIASES' Then Do
       CMDALIAS = ' '             /* CMDALIAS is numeric or blank*/
       name_conds = name_conds',CMDALIAS,NE'
       End
    If ONLY = ' ONLY TRUNCATED' Then Do
       CMDTRUNC = ' '             /* CMDTRUNC is numeric or '-'s */
       name_conds = name_conds',CMDTRUNC,NE'
       End
    If ONLY = ' ONLY OVERRIDES' Then Do
       CMDOVER = ' '              /* show CMDOVER = *, +, - or . */
       name_conds = name_conds',CMDOVER,NE'
       End
    If ONLY = ' NOT OVERRIDES' Then Do
       CMDOVER = ' '              /* show CMDOVER = ' ' only     */
       name_conds = name_conds',CMDOVER,EQ'
       End
    "TBSARG" cmds_table "NAMECOND("name_conds")"
    Return

/*==================================================================*/
/* Update the ONLY variable if only one table selected              */
/*------------------------------------------------------------------*/
SET_ONLY:
    If Word(ONLY,1) ¬= 'ONLY' & Word(ONLY,1) ¬= 'NOT' Then Do
       Select
         When T1','T2','T3','T4 = '/,,,' Then Do
            Select
              When ZAPPLID = ZUCTPREF Then ONLY = ' USER COMMANDS'
              When ZAPPLID = ZUCTPRE2 Then ONLY = ' USER COMMANDS'
              When ZAPPLID = ZUCTPRE3 Then ONLY = ' USER COMMANDS'
              When ZAPPLID = ZSCTPREF Then ONLY = ' SITE COMMANDS'
              When ZAPPLID = ZSCTPRE2 Then ONLY = ' SITE COMMANDS'
              When ZAPPLID = ZSCTPRE3 Then ONLY = ' SITE COMMANDS'
              When ZAPPLID = 'TOOL'   Then ONLY = '  ISPF TOOLS'
              Otherwise ONLY = ''
              End
            End
         When T1','T2','T3','T4 = ',/,,' Then
            ONLY = ' USER COMMANDS'
         When T1','T2','T3','T4 = ',,/,' Then Do
            If ZSCTSRCH = 'B'
               Then ONLY = ' SITE COMMANDS'
               Else ONLY = 'SYSTEM COMMANDS'
            End
         When T1','T2','T3','T4 = ',,,/' Then Do
            If ZSCTSRCH = 'A'
               Then ONLY = ' SITE COMMANDS'
               Else ONLY = 'SYSTEM COMMANDS'
            End
         Otherwise
            ONLY = ''
         End
       End
    Return

/*==================================================================*/
/* Check the correct value is in CMDSEL in every row of cmds_table  */
/*  - the Tx variables are updated by the user and can be either    */
/*    ' ' or '/'.  CMDSEL column is used for the table SCAN.        */
/*------------------------------------------------------------------*/
SELECT_TABLES:
    "TBTOP" cmds_table
    "TBSKIP" cmds_table
    Do Until rc > 0                  /* rc=8 when it's at the bottom */
       Select
          When CMDTORD = 1 Then
             If CMDSEL ¬= T1 Then Do       /* If the value is not OK */
                CMDSEL = T1
                "TBPUT" cmds_table "ORDER" /* ... update the row     */
                End
          When Left(CMDTORD,1) = 2 Then
             If CMDSEL ¬= T2 Then Do
                CMDSEL = T2
                "TBPUT" cmds_table "ORDER"
                End
          When Left(CMDTORD,1) = 3 Then
             If CMDSEL ¬= T3 Then Do
                CMDSEL = T3
                "TBPUT" cmds_table "ORDER"
                End
          When Left(CMDTORD,1) = 4 Then
             If CMDSEL ¬= T4 Then Do
                CMDSEL = T4
                "TBPUT" cmds_table "ORDER"
                End
          Otherwise
          End
       "TBSKIP" cmds_table
       End
    "CONTROL NONDISPL ENTER"         /* so panel can update ZTDMARK  */
    Return

/*==================================================================*/
/* Get the selected row from the temporary CMDS table.              */
/* This is called whenever a line command or direct update is done, */
/* because the ZCTACT field in ISPFCMD0 panel is only 66 bytes, but */
/* ZCTACT field in the table can be up to 240 bytes.                */
/*                                                                  */
/* Note: 'TBDISPL .. PANEL(ISPFCMD0) AUTOSEL(YES)' will retrieve    */
/*       the row in modified form (as displayed) so we must do a    */
/*       'TBGET ...' from the table to get the original values.     */
/*------------------------------------------------------------------*/
GET_ROW:
     /*----------------------------------*/
     /* get row when line command issued */
     /*----------------------------------*/
     If SEL ¬= '' Then             /* 'in-place' update is ignored  */
        "TBGET" cmds_table         /* get selected row from table   */
     /*------------------------------------------------*/
     /* get row when 'in-place' updating has been done */
     /*------------------------------------------------*/
     If SEL = '' Then Do           /* row updated on ISPFCMD0 panel */
        Call COPY_ZCTVARS          /* copy ZCTxxx -> ZETxxx vars    */
        If Length(CMDTRUNC) >= Length(Strip(ZCTVERB)) | CMDTRUNC = ''
           Then ZETTRUNC = 0
           Else ZETTRUNC = Max(2,Length(CMDTRUNC))   /* minimum = 2 */
        "TBGET" cmds_table         /* get selected row from table   */
        If ZETACT = Left(ZCTACT,66) Then  /* Action was not changed */
           Parse Var ZCTACT 1 ZETACT ,
              1 ZETACT1 61 ZETACT2 121 ZETACT3 181 ZETACT4

        /*--------------------------------------------------*/
        /* display panel for user to check the Action field */
        /*--------------------------------------------------*/
        If Length(ZCTACT) > 66 ,   /* Action longer than displayed  */
         & ZETACT ¬= ZCTACT Then Do   /* ... and Action was changed */
           Parse Var ZCTACT ,
              1 ZCTACT1 61 ZCTACT2 121 ZCTACT3 181 ZCTACT4
           /* keep old action values past byte 66 when probably OK */
           If Substr(ZETACT,61,6) <> ' ',
            & Substr(ZETACT,61,6) = Substr(ZCTACT,61,6) Then
              Parse Var ZCTACT,
                 61 ZETACT2 121 ZETACT3 181 ZETACT4
           "ADDPOP"                /* next panel in Pop-Up window   */
           Do dispno = 1 to 999 Until ZUCMKEY ¬= ''
              Call CHECK_PFKEYS('ISRSNAB')
              "DISPLAY PANEL(ISPFCMD8)"
              If RC = 8 & ZUCMKEY = '' Then  /* user 'PF3' ie END   */
                 ZUCMKEY = 'END'   /* .... allow update to be saved */
              "VGET ZVERB"
              If ZVERB = 'CANCEL' Then  /* user 'CANCEL' via PF Key */
                 ZUCMKEY = 'CANCEL'
              End
           "REMPOP"
           If ZUCMKEY = 'CANCEL' Then Do
              ZERRSM = 'Update cancelled'
              ZERRLM = ''
              ZERRALRM = 'NO'
              "SETMSG MSG(ISRZ002)"
              Return 4
              End
           End
        /*------------------------------------------------*/
        /* preserve the (unseen) last 20 bytes of ZCTDESC */
        /*------------------------------------------------*/
        Parse Var ZCTDESC 61 ZETDESC2
        End

    /*--------------------------------------------------------------*/
    /* save old values, to be checked by COMPARE_VARS when updating */
    /*--------------------------------------------------------------*/
    oldvars = ZCTVERB'|'ZCTTRUNC'|'ZCTDESC'|'ZCTACT
    Return 0

/*==================================================================*/
/* locate a command name exactly matching the cmdparm value         */
/* - if no match:  find the (first) command that should be after    */
/*   the desired one, then position the list on the row before that */
/*   (it looks for the first command starting with the same chars & */
/*   scans from there - this finds a better position in tables that */
/*   are mostly sorted into alphabetical order)                     */
/*------------------------------------------------------------------*/
LOCATE_ROW:
trace O
    CMDSEL = '/'            /* only locate from the selected commands */
    cmdparm = Strip(Left(cmdparm,8))
    ZCTVERB = cmdparm
    /*-------------------------*/
    /* look for an exact match */
    /*-------------------------*/
    "TBSCAN" cmds_table "NOREAD",
       "ARGLIST(ZCTVERB,CMDSEL) CONDLIST(EQ,EQ) POSITION(csrrow)"
    If RC > 0 Then Do
       ZCTVERB = cmdparm'*'     /* scan for same beginning characters */
       "TBSCAN" cmds_table "NOREAD",
          "ARGLIST(ZCTVERB,CMDSEL) CONDLIST(EQ,EQ) POSITION(csrrow)"
       End

    /*--------------------------------------*/
    /* no exact matching command name found */
    /*--------------------------------------*/
    If RC > 0 Then Do
       ZCTVERB = Left(cmdparm,1)'*' /* scan for same 1st character */
       "TBSCAN" cmds_table "NOREAD",
          "ARGLIST(ZCTVERB,CMDSEL) CONDLIST(EQ,EQ) ROWID(rowid)"
       If RC > 0
          Then rowid = 0
          Else "TBSKIP" cmds_table "NOREAD NUMBER(-1)"  /* row before */
       ZCTVERB = cmdparm
       "TBSCAN" cmds_table "NOREAD", /* find row that should be after */
          "ARGLIST(ZCTVERB,CMDSEL) CONDLIST(GT,EQ)"
       /*--------------------------------------------*/
       /* no following row with greater command name */
       /*--------------------------------------------*/
       If RC > 0 & rowid > 0 Then Do
          "TBSKIP" cmds_table "NOREAD ROW("rowid")"
          ZCTVERB = Left(cmdparm,1)'*'
          "TBSCAN" cmds_table "NOREAD",  /* scan for another 1st char */
             "ARGLIST(ZCTVERB,CMDSEL) CONDLIST(NE,EQ)"
          End
       /*------------------------------------------------------*/
       /* location found - position cursor on the previous row */
       /*------------------------------------------------------*/
       If RC = 0 Then
          "TBSKIP" cmds_table "NOREAD NUMBER(-1) POSITION(csrrow)"
       /*-----------------------------------------------------------*/
       /* location not found - find bottom of the displayed rows    */
       /*   - "TBBOTTOM" cmds_table "NOREAD POSITION(csrrow)" can't */
       /*    be used because csrrow can be invalid when some of the */
       /*    rows are not displayed.                                */
       /*-----------------------------------------------------------*/
       Else Do
          "TBSKIP" cmds_table "NOREAD ROW("rowid")" /* 1st char match */
          Do until RC > 0
             "TBSCAN" cmds_table "NOREAD ROWID(rowid)",
                "ARGLIST(CMDSEL) CONDLIST(EQ)"
             End
          "TBSKIP" cmds_table "NOREAD ROW("rowid") POSITION(csrrow)"
          End
       /*---------------------------------------*/
       /* message shown if no exact match found */
       /*---------------------------------------*/
       ZERRHM = '*'
       ZERRSM = 'Cmd "'cmdparm'" not found'
       ZERRLM = 'Command "'cmdparm'" not located, but list scrolled',
                'to where it should be'
       ZERRALRM = 'NO'                  /* no alarm with the message */
       "SETMSG MSG(ISRZ002)"            /* standard IBM message      */
       End
trace O
    Return

/*==================================================================*/
/* Delete the command from the live command table and cmds_table    */
/*------------------------------------------------------------------*/
DELETE_CMD:
    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL('R')      /* sort into REAL ORDER         */

    Call POSN_CSRS    /* position cursor on this row in both tables */
    "TBQUERY" upd_table "ROWNUM(qrows)"
    "TBDELETE" upd_table
    If qrows = 1 Then Do           /* deleting last row from table  */
       ZCTVERB  = '--------'
       ZCTTRUNC = '0'
       ZCTACT   = ''               /* null action = 'do nothing'    */
       ZCTDESC  = '<<< no commands in this table >>>'
       CMDTRUNC = ''               /* no truncation                 */
       CMDALIAS = ''
       CMDOVER  = ''
       "TBPUT" cmds_table "ORDER"  /* replaced by the dummy row     */
       End
    Else "TBDELETE" cmds_table

    If CUR#SORT ¬= 'REAL ORDER' Then
      Call SORT_CMDSTABL(CUR#SORT)  /* sort back to current order   */

    If temp_cmd ¬= 'Y' Then Do
       ZERRSM = 'Command deleted'
       ZERRLM = 'Command' ZCTVERB 'was deleted from' CMDTAB 'table'
       ZERRALRM = 'NO'              /* no alarm with the message    */
       "SETMSG MSG(ISRZ002)"        /* standard IBM message         */
       updated = 'Y'                /* command list was updated     */
       End
    Return

/*==================================================================*/
/* Copy the ZCTxxx vars into the ZETxxx vars                        */
/* - for the command View & Update panels (ISPFCMD5 & ISPFCMD4)     */
/*------------------------------------------------------------------*/
COPY_ZCTVARS:
    ZETVERB  = ZCTVERB                            /* command name     */
    ZETTRUNC = ZCTTRUNC                           /* truncation       */

    ZETDESC = Overlay(ZCTDESC,Copies(' ',80))     /* description      */
    ZETDESC1 = Left(ZETDESC,60)
    ZETDESC2 = Right(ZETDESC,20)

    ZETACT = Overlay(ZCTACT,Copies(' ',240))      /* command action   */
    Parse Var ZETACT ,
       1 ZETACT1 61 ZETACT2 121 ZETACT3 181 ZETACT4

    Return

/*==================================================================*/
/* Compare ZCTxxx vars before and after update                      */
/*------------------------------------------------------------------*/
COMPARE_VARS:
    /* oldvars = ZCTVERB'|'ZCTTRUNC'|'ZCTDESC'|'ZCTACT from GET_ROW */

    ZETDESC1 = Overlay(ZETDESC1,Copies(' ',60))
    ZETDESC = Strip(ZETDESC1||ZETDESC2)
    ZETACT1 = Overlay(ZETACT1,Copies(' ',60))
    ZETACT2 = Overlay(ZETACT2,Copies(' ',60))
    ZETACT3 = Overlay(ZETACT3,Copies(' ',60))
    ZETACT  = Strip(ZETACT1||ZETACT2||ZETACT3||ZETACT4)
    newvars = ZETVERB'|'ZETTRUNC'|'ZETDESC'|'ZETACT

    If newvars = oldvars
       Then Return 4              /* no actual update done          */
    Return 0

/*==================================================================*/
/* Copy the ZETxxx vars into the ZCTxxx vars                        */
/* - from the command Update panel (ISPFCMD4)                       */
/* - this sets up the variables for any command update to be saved  */
/*------------------------------------------------------------------*/
COPY_ZETVARS:
    ZCTVERB = ZETVERB
    ZCTTRUNC = ZETTRUNC
    ZETDESC1 = Overlay(ZETDESC1,Copies(' ',60))
    ZCTDESC = Strip(ZETDESC1||ZETDESC2)
    ZETACT1 = Overlay(ZETACT1,Copies(' ',60))
    ZETACT2 = Overlay(ZETACT2,Copies(' ',60))
    ZETACT3 = Overlay(ZETACT3,Copies(' ',60))
    ZCTACT  = Strip(ZETACT1||ZETACT2||ZETACT3||ZETACT4)

    /* Note: CMDTAB, CMDTORD, CMDSEL, CMDNUM & CMDALIAS not updated */
    CMDMINL = Length(Strip(ZCTVERB))
    If ZCTTRUNC = 0 | ZCTTRUNC = CMDMINL Then
       CMDTRUNC = ''
    Else Do
       CMDMINL = ZCTTRUNC
       CMDTRUNC = Copies('-',ZCTTRUNC)
       End
    CMDOVER = ''              /* this will be checked by SETUP_OVER */
    CMDFND = ''
    If CMDFIND ¬= '' Then Do                /* if FIND is active .. */
       Parse Upper Var ZCTDESC upper_desc
       If Pos(CMDFIND,upper_desc) > 0 ,
        | Pos(CMDFIND,ZCTACT) > 0  Then Do
          CMDFND = CMDFIND
          End
       End
    Return

/*==================================================================*/
/* Use panel (based on IBM panel: ISPUCMX) to update a command      */
/* - allow saving the command via PF3 (as is done by IBM)           */
/* - do some validity checking                                      */
/*   IBM state that a command must begin with A-Z, so that is what  */
/*   this tool enforces, however my testing shows that only a few   */
/*   characters are really invalid, as in the following code:       */
/*     vi = Pos(Left(ZETVERB,1),':;0123456789=>')                   */
/*     If vi > 0 Then vi = 1   /* vi=0 (valid) , vi=1 (invalid) */  */
/*------------------------------------------------------------------*/
UPDATE_PANEL:
    "CONTROL DISPLAY SAVE"        /* save the TBDISPL display       */
    "ADDPOP"                      /* next panel in Pop-Up window    */
    CURSOR = 'ZETVERB'            /* position cursor on cmd name    */
    Parse Var oldvars oldverb'|'oldtrunc'|'olddesc'|'oldact
    If c_type = 'COPY' Then Do
       ov_verb = ''
       al_verb = ''
       fov_verb = ''
       pov_verb = ''
       End
    Else Do
       ov_verb = oldverb
       al_verb = oldverb
       fov_verb = oldverb
       pov_verb = oldverb
       End
    cmd_num_p = CMDNUM
    cmd_min_l = CMDMINL
    Do dispno = 1 to 999 Until ZUCMKEY ¬= ''
       Call CHECK_PFKEYS('ISRSNAB')
       "DISPLAY PANEL(ISPFCMD4)"  /* "Command Update" panel         */
       If RC = 8 & ZUCMKEY = '' Then     /* user 'PF3' ie END       */
          ZUCMKEY = 'END'         /* ..... allow update to be saved */
       "VGET ZVERB"
       If ZVERB = 'CANCEL' Then         /* user 'CANCEL' via PF Key */
          ZUCMKEY = 'CANCEL'
       If ZUCMKEY = 'CANCEL' Then Leave /* user 'CANCEL'            */
       If ZETTRUNC = '' Then      /* null truncation value          */
          ZETTRUNC = 0            /* .. set it to the default (0)   */
       tn = Datatype(ZETTRUNC,'N')  /* check Trunc is numeric       */
       vc = Datatype(Left(ZETVERB,1),'M') /* check 1st char in Verb */
       /* vc = 1  *** uncomment this line to allow ANY command name */
       vl = Length(ZETVERB)       /* get length of the command Verb */
       If ¬vc | ¬tn | ,           /* If invalid Verb | Trunc value  */
          vl < 2 Then Do          /* Verb must be 2 - 8 characters. */
          ZUCMKEY = ''            /* force redisplay of the panel   */
          CURSOR = 'ZETVERB'      /* position cursor on ZETVERB     */
          ZERRSM = ''
          Select
            When ZETVERB = '' Then
              ZERRLM = "** Command name (Verb) MUST be specified **"
            When vl = 1 Then
              ZERRLM = '** Command name (Verb) must be at least',
                       '2 characters **'
            When ¬vc Then         /* vc=0 if invalid 1st char       */
              ZERRLM = '** Command name (Verb) must start with',
                       'A - Z **'
            When ¬tn Then Do      /* tn=0 if Trunc not numeric      */
              ZERRLM = '** Truncation value must be numeric **'
              CURSOR = 'ZETTRUNC' /* position cursor on ZETTRUNC    */
              End
            End
          ZERRHM = '*'
          ZERRALRM = 'YES'        /* alarm with the message         */
          "SETMSG MSG(ISRZ002)"   /* standard IBM message           */
          iterate dispno          /* redisplay the panel            */
          End
       If ZETTRUNC > vl Then   /* If Trunc > Verb length: fix it */
          ZETTRUNC = 0         /* .. command entry is now valid  */
       If ZETTRUNC = 1  Then   /* cmds must be at least 2 chars, */
          ZETTRUNC = 2         /* so trunc=2 is equiv to trunc=1 */
       If ZETTRUNC = 0
          Then CMDMINL = vl
          Else CMDMINL = ZETTRUNC
       /*-----------------------------------------------------------*/
       /* Correcting the Action syntax, (if necessary)              */
       /* - This is an attempt to fix the most common user errors.  */
       /*-----------------------------------------------------------*/
       Parse Var ZETACT1 cm_start 'C(' cm_end
       If cm_end ¬= '' & (cm_start = '' | cm_start = 'SELECT') Then
          ZETACT1 = 'CMD('cm_end
       Parse Var ZETACT1 cm_start 'CM(' cm_end
       If cm_end ¬= '' & (cm_start = '' | cm_start = 'SELECT') Then
          ZETACT1 = 'CMD('cm_end
       Parse Var ZETACT1 cm_start 'COMMAND(' cm_end
       If cm_end ¬= '' & (cm_start = '' | cm_start = 'SELECT') Then
          ZETACT1 = 'CMD('cm_end
       Parse Var ZETACT1 cm_start 'C=' cm_end1 cm_end2
       If cm_end1 ¬= '' & (cm_start = '' | cm_start = 'SELECT') Then
          ZETACT1 = 'CMD('cm_end1')' cm_end2
       Parse Var ZETACT1 cm_start 'CM=' cm_end1 cm_end2
       If cm_end1 ¬= '' & (cm_start = '' | cm_start = 'SELECT') Then
          ZETACT1 = 'CMD('cm_end1')' cm_end2
       Parse Var ZETACT1 cm_start 'CMD=' cm_end1 cm_end2
       If cm_end1 ¬= '' & (cm_start = '' | cm_start = 'SELECT') Then
          ZETACT1 = 'CMD('cm_end1')' cm_end2
       Parse Var ZETACT1 cm_start 'COMMAND=' cm_end1 cm_end2
       If cm_end1 ¬= '' & (cm_start = '' | cm_start = 'SELECT') Then
          ZETACT1 = 'CMD('cm_end1')' cm_end2
       Parse Var ZETACT1 pr_start 'PR(' pr_end
       If pr_end ¬= '' & (pr_start = '' | pr_start = 'SELECT') Then
          ZETACT1 = 'PGM('pr_end
       Parse Var ZETACT1 pr_start 'PROG(' pr_end
       If pr_end ¬= '' & (pr_start = '' | pr_start = 'SELECT') Then
          ZETACT1 = 'PGM('pr_end
       Parse Var ZETACT1 pr_start 'PROGRAM(' pr_end
       If pr_end ¬= '' & (pr_start = '' | pr_start = 'SELECT') Then
          ZETACT1 = 'PGM('pr_end
       Parse Var ZETACT1 pr_start 'PR=' pr_end1 pr_end2
       If pr_end1 ¬= '' & (pr_start = '' | pr_start = 'SELECT') Then
          ZETACT1 = 'PGM('pr_end1')' pr_end2
       Parse Var ZETACT1 pr_start 'PGM=' pr_end
       If (pr_start = '' | pr_start = 'SELECT' | pr_start = 'EXEC'),
        & pr_end ¬= '' Then Do
          Parse Var pr_end pgm_name ",PARM=" pr_parms
          If pr_parms = '' Then
             Parse Var pr_end pgm_name " PARM=" pr_parms
          If pr_parms = '' Then
             ZETACT1 = 'PGM('Word(pr_end,1)')' Subword(pr_end,2)
          Else Do
             Select
               When Left(pr_parms,1) = "'" Then
                  Parse Var pr_parms "'" pr_parms "'" pr_end
               When Left(pr_parms,1) = "(" Then
                  Parse Var pr_parms "(" pr_parms ")" pr_end
               Otherwise
                  Parse Var pr_parms pr_parms pr_end
               End
             ZETACT1 = 'PGM('Strip(pgm_name)') PARM('pr_parms')' pr_end
             End
          End
       Parse Var ZETACT1 pr_start 'PROG=' pr_end1 pr_end2
       If pr_end1 ¬= '' & (pr_start = '' | pr_start = 'SELECT') Then
          ZETACT1 = 'PGM('pr_end1')' pr_end2
       Parse Var ZETACT1 pr_start 'PROGRAM=' pr_end1 pr_end2
       If pr_end1 ¬= '' & (pr_start = '' | pr_start = 'SELECT') Then
          ZETACT1 = 'PGM('pr_end1')' pr_end2
       Parse Var ZETACT1 pn_start 'PAN(' pn_end
       If pn_end ¬= '' & (pn_start = '' | pn_start = 'SELECT') Then
          ZETACT1 = 'PANEL('pn_end
       Parse Var ZETACT1 pn_start 'PNL(' pn_end
       If pn_end ¬= '' & (pn_start = '' | pn_start = 'SELECT') Then
          ZETACT1 = 'PANEL('pn_end
       Parse Var ZETACT1 pn_start 'PANL(' pn_end
       If pn_end ¬= '' & (pn_start = '' | pn_start = 'SELECT') Then
          ZETACT1 = 'PANEL('pn_end
       Parse Var ZETACT1 pn_start 'PAN=' pn_end1 pn_end2
       If pn_end1 ¬= '' & (pn_start = '' | pn_start = 'SELECT') Then
          ZETACT1 = 'PANEL('pn_end1')' pn_end2
       Parse Var ZETACT1 pn_start 'PNL=' pn_end1 pn_end2
       If pn_end1 ¬= '' & (pn_start = '' | pn_start = 'SELECT') Then
          ZETACT1 = 'PANEL('pn_end1')' pn_end2
       Parse Var ZETACT1 pn_start 'PANL=' pn_end1 pn_end2
       If pn_end1 ¬= '' & (pn_start = '' | pn_start = 'SELECT') Then
          ZETACT1 = 'PANEL('pn_end1')' pn_end2
       Parse Var ZETACT1 pn_start 'PANEL=' pn_end1 pn_end2
       If pn_end1 ¬= '' & (pn_start = '' | pn_start = 'SELECT') Then
          ZETACT1 = 'PANEL('pn_end1')' pn_end2
       correctn = ''
       If Left(ZETACT1,4) = 'CMD(',
        | Left(ZETACT1,4) = 'PGM(',
        | Left(ZETACT1,6) = 'PANEL(' Then correctn = 'SEL'
       If Left(ZETACT1,1) = '%',
        | Left(ZETACT1,3) = 'EX ',
        | Left(ZETACT1,5) = 'EXEC ' Then correctn = 'CMD'
       If Left(ZETACT1,4) = 'TSO ' Then correctn = 'TSO'
       If correctn ¬= '' Then Do
          ZETACT  = Strip(ZETACT1||ZETACT2||ZETACT3||ZETACT4)
          If correctn = 'SEL' Then
             ZETACT = 'SELECT' ZETACT
          If correctn = 'CMD' Then
             ZETACT = 'SELECT CMD('ZETACT') SUSPEND MODE(FSCR)'
          If correctn = 'TSO' Then
             ZETACT = 'SELECT CMD('Substr(ZETACT,5)' &ZPARM )',
                      'SUSPEND MODE(FSCR)'
          ZETACT = Overlay(ZETACT,Copies(' ',240))
          ZETACT1  = Left(ZETACT,60)
          ZETACT2  = Substr(ZETACT,61,60)
          ZETACT3  = Substr(ZETACT,121,60)
          ZETACT4  = Right(ZETACT,60)
          ZUCMKEY = ''            /* force redisplay of the panel   */
          ZERRHM = '*'
          ZERRSM = ''
          ZERRLM = '** Action syntax corrected: please',
                      'check it **'
          ZERRALRM = 'YES'        /* alarm with the message         */
          "SETMSG MSG(ISRZ002)"   /* standard IBM message           */
          Iterate dispno          /* redisplay the panel            */
          End
       /*-----------------------------------------*/
       /* checking for recognised Action keywords */
       /*-----------------------------------------*/
       action_list = 'SELECT ALIAS PASSTHRU SETVERB NOP',
                     'ACTIONS CANCEL CRETRIEV CURSOR EXIT',
                     'PRINT PRINT-HI PRINTG PTINTL PRINTLHI',
                     'RETF RETP RETRIEVE SCRNAME SPLIT SPLIT-V',
                     'SWAP WINDOW WS'
       If actword ¬= Word(ZETACT1,1) Then Do
          actword = Word(ZETACT1,1)
          ZERRLM = ''
          If actword ¬= '' ,      /* blank Action is valid          */
           & Left(actword,1) ¬= '&' ,
           & Wordpos(actword,action_list) = 0 Then
             ZERRLM = '** Action not recognised: please check it **'
          If ZETACT1 = '' & lastact ¬= 'blank' Then Do
             ZERRLM = '** ISPF ignores any command with no action **'
             lastact = 'blank'
             End
          If ZERRLM ¬= '' Then Do
             ZUCMKEY = ''         /* force redisplay of the panel   */
             CURSOR = 'ZETACT1'   /* position cursor on ZETACT1     */
             ZERRHM = '*'
             ZERRSM = ''
             ZERRALRM = 'YES'     /* alarm with the message         */
             "SETMSG MSG(ISRZ002)"/* standard IBM message           */
             Iterate dispno       /* redisplay the panel            */
             End
          End
       /*------------------------------------------*/
       /* checking that a Description was supplied */
       /*------------------------------------------*/
       ZETDESC1 = Overlay(ZETDESC1,Copies(' ',60))
       ZETDESC = Strip(ZETDESC1||ZETDESC2)
       If ZETDESC = '' & lastdesc ¬= 'blank' Then Do
          lastdesc = 'blank'
          ZUCMKEY = ''            /* force redisplay of the panel   */
          CURSOR = 'ZETDESC1'     /* position cursor on ZETDESC1    */
          ZERRSM = ''
          ZERRHM = '*'
          ZERRLM = '** a Description is strongly recommended **'
          ZERRALRM = 'YES'        /* alarm with the message         */
          "SETMSG MSG(ISRZ002)"   /* standard IBM message           */
          Iterate dispno          /* redisplay the panel            */
          End
       If CMDTAB = 'TOOL' & Pos('HELP(',ZETDESC) = 0,
        & lastdesc ¬= ZETDESC Then Do
          lastdesc = ZETDESC
          ZUCMKEY = ''            /* force redisplay of the panel   */
          CURSOR = 'ZETDESC2'     /* position cursor on ZETDESC2    */
          ZERRSM = ''
          ZERRHM = '*'
          ZERRLM = "** TOOL commands should have:",
                   "'HELP(panelname)' in the Description **"
          ZERRALRM = 'YES'        /* alarm with the message         */
          "SETMSG MSG(ISRZ002)"   /* standard IBM message           */
          Iterate dispno          /* redisplay the panel            */
          End
       /*-----------------------------------------*/
       /* check if new command will be overridden */
       /*-----------------------------------------*/
       If ZETVERB ¬= ov_verb,         /* this been checked already? */
        | CMDMINL ¬= cmd_min_l Then Do
          ov_verb = ZETVERB
          cmd_min_l = CMDMINL
          CMDOVER = ''
          If ZETACT = '' Then Do  /* ignore commands with no action */
             over_cmd = ''
             part_cmds = ''
             End
          Else Call ISIT_OVERRIDDEN          /* find overriding cmd */
          If over_cmd ¬= '' Then Do
             CMDOVER = '-'
             If part_cmds = '' Then ZERRLM =,
                'Warning:' ZETVERB 'will be OVERRIDDEN by command',
                Word(over_cmd,1) 'in table' Word(over_cmd,2)
             Else Do
                ZERRLM = 'Warning: it can only be invoked by entering'
                If Length(part_cmds) < 30 Then
                   m2 = part_cmds Copies(' ',30) ,
                   null '        because it is partly overridden by'
                Else
                   m2 = part_cmds ' because it is partly overridden by'
                ZERRLM = ZERRLM m2,
                         Word(over_cmd,1) 'in table' Word(over_cmd,2)
                End
             ZUCMKEY = ''         /* force redisplay of the panel   */
             ZERRSM = ''
             ZERRHM = 'ISPFCMHO'  /* HELP for OVERRIDE              */
             ZERRALRM = 'YES'     /* alarm with the message         */
             "SETMSG MSG(ISRZ002)"         /* show message          */
             Iterate dispno       /* redisplay the panel            */
             End
          End
       /*--------------------------------------------------*/
       /* will new command fully override other commands ? */
       /*--------------------------------------------------*/
       If ZETVERB ¬= fov_verb ,        /*  been checked already? */
        & part_cmds ¬= '' Then Do
          fov_verb = ZETVERB
          CMDMINL = cmd_min_l
          Call DOES_IT_OVERRIDE           /* find overridden cmds */
          If fovrverb ¬= '' Then Do
             ZERRLM = 'This will override command' fovrverb,
                      'in table' fovrtabl
             ZUCMKEY = ''         /* force redisplay of the panel   */
             ZERRSM = ''
             ZERRHM = 'ISPFCMHO'  /* HELP for OVERRIDE              */
             ZERRALRM = 'YES'     /* alarm with the message         */
             "SETMSG MSG(ISRZ002)"         /* show message          */
             Iterate dispno       /* redisplay the panel            */
             End
          End
       /*---------------------------------------------------*/
       /* will new command partly override other commands ? */
       /*---------------------------------------------------*/
       If ZETVERB ¬= pov_verb ,        /*  been checked already? */
        & part_cmds ¬= '' Then Do
          pov_verb = ZETVERB
          If povrverb ¬= '' Then Do
             ZERRLM = 'Warning: this will partly override command',
                      povrverb 'in table' povrtabl
             ZUCMKEY = ''         /* force redisplay of the panel   */
             ZERRSM = ''
             ZERRHM = 'ISPFCMHO'  /* HELP for OVERRIDE              */
             ZERRALRM = 'YES'     /* alarm with the message         */
             "SETMSG MSG(ISRZ002)"         /* show message          */
             Iterate dispno       /* redisplay the panel            */
             End
          End
       /*--------------------------------------*/
       /* checking the ALIASes of this command */
       /*--------------------------------------*/
       If ZETVERB ¬= al_verb Then Do  /* this been checked already? */
          al_verb = ZETVERB
          ZERRLM = ''
          alias_cmds = FIND_ALIAS_CMDS()/* find ALIASes of this cmd */
          If Pos(',',alias_cmds) > 0 Then
             ZERRLM = 'Warning:' alias_cmds ' are ALIAS of' ZCTVERB
          Else If alias_cmds ¬= '' Then
             ZERRLM = 'Warning:' alias_cmds 'is ALIAS of' ZCTVERB
          If ZERRLM ¬= '' Then Do
             ZUCMKEY = ''         /* force redisplay of the panel   */
             ZERRSM = ''
             ZERRHM = 'ISPFCMHA'  /* HELP for ALIAS                 */
             ZERRALRM = 'YES'     /* alarm with the message         */
             "SETMSG MSG(ISRZ002)"         /* show message          */
             Iterate dispno       /* redisplay the panel            */
             End
          End
       /*------------------------------*/
       /* check effective ALIAS action */
       /*------------------------------*/
       If ZETACT1 ¬= Left(oldact,60) ,
        & Word(ZETACT1,1) = 'ALIAS' Then Do
          oldact = ZETACT1        /* oldact = last action checked   */
          ZCTACT = ZETACT1        /* used by FIND_ALIAS_ACTION      */
          Call FIND_ALIAS_ACTION
          If ZCTVERB = '' Then Do
             CURSOR = 'ZETACT1'   /* position cursor on ZETACT1     */
             ZERRLM = 'Warning:' ZETVERB 'will do NOTHING, because',
                      'ALIAS command' Word(ZETACT1,2) 'not found'
             ZUCMKEY = ''         /* force redisplay of the panel   */
             ZERRSM = ''
             ZERRHM = 'ISPFCMHA'  /* HELP for ALIAS                 */
             ZERRALRM = 'YES'     /* alarm with the message         */
             "SETMSG MSG(ISRZ002)"         /* show message          */
             End
          End

       End                        /* end of: Do Until ZUMKEY ¬= ''  */
    actword = ''
    lastdesc = ''
    "REMPOP"                      /* remove the Pop-Up window       */
    "CONTROL DISPLAY RESTORE"     /* restore the TBDISPL display    */
    "TBTOP" cmds_table
    CMDNUM = cmd_num_p
    "TBSCAN" cmds_table "ARGLIST(CMDNUM)"      /* refresh variables */
    Return

/*==================================================================*/
/* Repeat a command (before the selected row)                       */
/*------------------------------------------------------------------*/
REPEAT_CMD:
 /* "TBGET" cmds_table  */        /* ensure whole ZCTDESC & ZCTACT  */
    Call COPY_ZCTVARS             /* copy ZCTxx vars -> ZETxx vars  */

    PNLTITLE = 'Repeat command' ZCTVERB 'in table' CMDTAB'CMDS'
    PNLTITLE = Centre(PNLTITLE,55)
    Call UPDATE_PANEL             /* use ISPFCMD4 panel for update  */

    If ZUCMKEY = 'END' Then Do    /*** UPDATE ***/
       If CUR#SORT ¬= 'REAL ORDER' Then
          Call SORT_CMDSTABL('R')   /* sort into REAL ORDER         */

       Call POSN_CSRS /* position cursor on this row in both tables */

       Call COPY_ZETVARS          /* setup variables for new row    */

       Call ADD_CMD('-')          /* add new command BEFORE ('-')   */

       If CUR#SORT ¬= 'REAL ORDER' Then
         Call SORT_CMDSTABL(CUR#SORT) /* sort back to current order */
       ZERRSM = 'Command repeated'
       ZERRLM = 'Command' ZCTVERB 'was repeated in' CMDTAB 'table'
       updated = 'Y'              /* command list was updated       */
       End
    Else Do
       ZERRSM = 'Repeat cancelled'
       ZERRLM = 'No new command was created'
       End
    ZERRALRM = 'NO'               /* no alarm with the message      */
    "SETMSG MSG(ISRZ002)"         /* standard IBM message           */
    Return

/*==================================================================*/
/* Insert a new command (after the selected row)                    */
/*------------------------------------------------------------------*/
INSERT_CMD:
    PNLTITLE = 'Insert command after' ZCTVERB 'in table' CMDTAB'CMDS'
    PNLTITLE = Centre(PNLTITLE,55)

    ZCTVERB = ''                  /* user must supply command name  */
    ZCTTRUNC = 0                  /* default to whole command name  */
    ZCTACT  = ''                  /* user should supply action      */
    ZCTDESC = ''                  /* user should supply description */
    Call COPY_ZCTVARS             /* copy ZCTxx vars -> ZETxx vars  */

    Call UPDATE_PANEL             /* use ISPFCMD4 panel for update  */
    If ZUCMKEY = 'END' Then Do    /*** UPDATE ***/
       If CUR#SORT ¬= 'REAL ORDER' Then
          Call SORT_CMDSTABL('R')   /* sort into REAL ORDER         */

       Call POSN_CSRS /* position cursor on this row in both tables */

       Call COPY_ZETVARS          /* setup variables for new row    */

       Call ADD_CMD('+')          /* add new command AFTER ('+')    */

       If CUR#SORT ¬= 'REAL ORDER' Then
         Call SORT_CMDSTABL(CUR#SORT) /* sort back to current order */
       ZERRSM = 'Command inserted'
       ZERRLM = 'Command' ZETVERB 'was inserted in' CMDTAB 'table'
       updated = 'Y'              /* command list was updated       */
       End
    Else Do
       ZERRSM = 'Insert cancelled'
       ZERRLM = 'No new command was created'
       End
    ZERRALRM = 'NO'               /* no alarm with the message      */
    "SETMSG MSG(ISRZ002)"         /* standard IBM message           */
    Return

/*==================================================================*/
/* Update an existing command                                       */
/*------------------------------------------------------------------*/
UPDATE_CMD:
    PNLTITLE = 'Update command' ZCTVERB 'in table' CMDTAB'CMDS'
    PNLTITLE = Centre(PNLTITLE,55)
    If SEL ¬= ' ' Then Do         /* SEL = 'U' or 'E'               */
       Call COPY_ZCTVARS          /* copy ZCTxx vars -> ZETxx vars  */
       Call CHECK_RELATIONS       /* set msgs for any relationships */
       End
    Else                          /* updated in place on ISPFCMD0   */
       "CONTROL NONDISPL END"

    Call UPDATE_PANEL             /* use ISPFCMD4 panel for update  */
    Call COMPARE_VARS             /* was anything actually updated? */
    If result = 4 Then Return     /* .. if not - return             */

    If ZUCMKEY = 'END' Then Do    /*** UPDATE ***/
       If CUR#SORT ¬= 'REAL ORDER' Then
          Call SORT_CMDSTABL('R')   /* sort into REAL ORDER         */

       Call POSN_CSRS /* position cursor on this row in both tables */

       Call COPY_ZETVARS          /* setup variables for new row    */

       "TBPUT" upd_table          /* replace row in CMDS table      */
       If rc = 8 Then             /* if upd_table is empty          */
          "TBADD" upd_table       /* .. add the row instead         */
       "TBPUT" cmds_table "ORDER" /* replace row in temp table      */

       If CUR#SORT ¬= 'REAL ORDER' Then
         Call SORT_CMDSTABL(CUR#SORT) /* sort back to current order */
       ZERRSM = 'Command updated'
       ZERRLM = 'Command' ZCTVERB 'was updated in' CMDTAB 'table'
       updated = 'Y'              /* command list was updated       */
       End
    Else Do
       ZERRSM = 'Update cancelled'
       ZERRLM = ''
       End
    ZERRALRM = 'NO'               /* no alarm with the message      */
    "SETMSG MSG(ISRZ002)"         /* standard IBM message           */
    Return

/*==================================================================*/
/* Position the cursors on this selected row in both tables         */
/* - this is done to ensure that we get the correct row in the      */
/*   live table, in case that table has duplicate identical rows    */
/* - cmds_table must be sorted in REAL ORDER before this            */
/* This is used whenever a row is added, deleted or updated.        */
/*------------------------------------------------------------------*/
POSN_CSRS:
    "TBTOP" cmds_table
    "TBSCAN" cmds_table ,           /* find first row of upd_table  */
             "ARGLIST(CMDTAB) NOREAD POSITION(firstrow)"
    "TBSKIP" cmds_table "NOREAD NUMBER(-1)"

    "TBSCAN" cmds_table ,           /* find position of this row    */
             "ARGLIST(CMDNUM) NOREAD POSITION(thisrow)"
    rowskip = thisrow - firstrow + 1         /* relative row number */

    /*--------------------------------------------------------------*/
    /* Find equivalent row in the live table.  We cannot use:       */
    /*   "TBSKIP" upd_table "NOREAD NUMBER("rowskip")"              */
    /* because there could be some pending commands, which we must  */
    /* ignore.                                                      */
    /* If the table is empty - CRP will remain at the top.          */
    /*--------------------------------------------------------------*/
    Call SAVE_VARS("ZCTVERB ZCTTRUNC ZCTACT ZCTDESC")
    row = 0
    upd_table = CMDTAB'CMDS'        /* the live table to be updated */
    "TBTOP" upd_table
    Do posning = 1 to 9999
       "TBSKIP" upd_table
       If (Word(ZCTDESC,2) = '<<RUNNING>>' ,
        |  Word(ZCTDESC,2) = '<<PENDING>>'),
        &  Word(ZCTDESC,1) <= '99'x ,
        &  Datatype(C2X(Word(ZCTDESC,1))) = 'NUM'
           Then Iterate posning        /* pending cmd - try next row*/
       row = row + 1
       If row = rowskip Then Leave
       End
    Call RESTORE_VARS("ZCTVERB ZCTTRUNC ZCTACT ZCTDESC")

    Return

/*==================================================================*/
/* Add a command row to temporary and live command tables           */
/*------------------------------------------------------------------*/
ADD_CMD:
    Arg dirn                            /* dirn = '-' or '+'        */
    If dirn = '-' Then
       "TBSKIP" upd_table "NOREAD NUMBER(-1)"   /* position cursor  */
    "TBADD" upd_table             /* insert new row in CMD table    */
    If dirn = '+'
       Then CMDNUM = CMDNUM + 2   /* create new CMDNUM for the new  */
       Else CMDNUM = CMDNUM - 2   /* .. row in the temp table       */
    If dirn = '-' Then
       "TBSKIP" cmds_table "NOREAD NUMBER(-1)"
    "TBADD" cmds_table            /* insert new row in temp table   */
    added_cmd = CMDNUM CMDTAB

    /*---------------------------------------*/
    /* ensure there are no duplicate CMDNUMs */
    /*---------------------------------------*/
    copy_num = Word(COPYPEND,2)
    Do forever
       new_cmdnum = CMDNUM
       "TBSKIP" cmds_table "NUMBER("dirn"1)" /* previous or next row*/
       If rc > 0 Then Leave             /* rc = 8 at end of table   */
       If CMDNUM ¬= new_cmdnum Then Leave
       If dirn = '+'                    /*--------------------------*/
          Then CMDNUM = CMDNUM + 2      /* CMDNUM was the same, so  */
          Else CMDNUM = CMDNUM - 2      /* update it & save the row */
       "TBPUT" cmds_table               /*--------------------------*/
       If copy_num = new_cmdnum Then
          COPYPEND = Word(COPYPEND,1) CMDNUM Subword(COPYPEND,3)
       End
    Return

  /*==================================================================*/
  /* COPY the selected rows to another table                          */
  /*   - invoked via the 'COPY' primary command                       */
  /*------------------------------------------------------------------*/
  /*  a) user must specify the target table in panel ISPFCMDC         */
  /*  b) invoke CONFIRM_TABLE to check that the table exists          */
  /*  c) if table not open, CONFIRM_TABLE invokes CONFIRM_LIBRARY to  */
  /*     let user confirm one of the following:                       */
  /*       1) it found the table in the desired library               */
  /*       2) user must specify the desired library, then either      */
  /*           - table found (in that library)                        */
  /*           - if not found, invoke CONFIRM_SAVE for user to        */
  /*             confirm creation of a new table                      */
  /*  d) return to COPY_ROWS and allocate library to CMCOPYnn         */
  /*  e) open/create the target table                                 */
  /*  f) process the selected rows, copying then to the table         */
  /*  g) close the target table                                       */
  /*        1) if it was SHARED NOWRITE then only the in-storage copy */
  /*           is updated, and user must save it separately from the  */
  /*           active application in another split screen             */
  /*        2) if it was SHARED WRITE then it is saved to disk, then  */
  /*           free ddname CMCOPYnn                                   */
  /*------------------------------------------------------------------*/
COPY_ROWS:
    /*----------------------------------------------------*/
    /* 'RESet' command (only) turns off pending copy cmds */
    /*----------------------------------------------------*/
    If Pos(ZCMD,'RESET') = 1 & Length(ZCMD) > 2 Then Do
       Call CANCEL_COPY                    /* 'COPY Cancelled' msg    */
       Return
       End
    COPYCMDS = YES                         /* 'copy cmds' is pending  */
    /*----------------------------------------------------------*/
    /* check that some commands have been selected to be copied */
    /*----------------------------------------------------------*/
    If ZTDSELS = 0 Then Do
       ZERRSM = ''
       ZERRHM = 'ISPFCMHK'
       ZERRLM = "  *** Select commands to be copied, or enter 'RES' to",
                'CANCEL the copying ***'
       ZERRALRM = 'YES'                    /* alarm with the message  */
       "SETMSG MSG(ISRZ002)"               /* standard IBM message    */
       Return
       End
    If ZTDSELS = 1 & SEL = '' Then Do      /* ignore 1 auto-selection */
       ZTDSELS = 0
       Return
       End
    /*-------------------------------------------------*/
    /* user to specify table name, action and location */
    /*-------------------------------------------------*/
    Call CHECK_PFKEYS('ISRSNAB')
    "ADDPOP"
    "DISPLAY PANEL(ISPFCMDC)"        /* Ask user to confirm or cancel */
    conf_rc = rc          /* user replies: ENTER (rc=0) or END (rc=8) */
    "REMPOP"
    If conf_rc > 0 Then Do
       Call CANCEL_COPY                    /* 'COPY Cancelled' msg    */
       Return
       End
    /*------------------------------------------------------------*/
    /* confirm the table exists; user may need to specify library */
    /*------------------------------------------------------------*/
    Parse Value TABNAME With applid 'CMDS'
    Call CONFIRM_TABLE
    If result > 0 Then Do
       Call CANCEL_COPY                    /* 'COPY Cancelled' msg    */
       Return
       End
    /*-----------------------*/
    /* open the target table */
    /*-----------------------*/
    If lib_type = '02'x Then               /* table already active    */
       "TBOPEN" TABNAME "NOWRITE SHARE"
    Else Do                                /* lib_type = '01'x        */
       /*------------------*/
       /* allocate library */
       /*------------------*/
       If VOLUME ¬= ''
          Then vol_parm = 'VOL('VOLUME')'
          Else vol_parm = ''
       Address TSO "ALLOC FI(CMCOPY"tsuf") DSN('"LIBNAME"')",
          vol_parm "SHR REUSE"
       alloc_rc = rc
       /*-------------------------------*/
       /* open (or create) target table */
       /*-------------------------------*/
       If create_copy_table = 'YES' Then Do
          "TBCREATE" TABNAME "LIBRARY(CMCOPY"tsuf") WRITE SHARE",
             "NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)"
          create_copy_table = 'NO'
          End
       Else
          "TBOPEN" TABNAME "LIBRARY(CMCOPY"tsuf") WRITE SHARE"
       End

    /*--------------------------------------------*/
    /* copy the selected rows to the target table */
    /*--------------------------------------------*/
    cpynum = 0                          /* number of cmds copied      */
    cpynot = 0                          /* number of cmds not copied  */
    cpydup = 0                          /* number of cmds duplicated  */
    cpyrep = 0                          /* number of cmds replaced    */
    duplist = ','                       /* list of duplicate cmdnames */

    If WHS = '/' Then
       "TBTOP" TABNAME                  /* if commands go at start    */
    If WHE = '/' Then
       "TBBOTTOM" TABNAME "NOREAD"      /* if commands go at end      */

    Do ZTDSELS                        /* repeat for each selected row */
       Call GET_ROW                   /* get selected row from table  */
       If SEL ¬= '' Then Do           /* bypass auto-selection        */
          Select
             When WHA = ' ' Then           /* Insert at start or end  */
                "TBADD" TABNAME
             Otherwise                     /* Insert alphabetically   */
                "TBTOP" TABNAME
                "TBSCAN" TABNAME "NOREAD", /* look for duplicate cmd */
                   "ARGLIST(ZCTVERB) CONDLIST(EQ)"
                If RC > 0 Then Do
                   Call COPY_ALPHA   /* position cursor for insertion */
                   "TBADD" TABNAME
                   End
                Else Do               /* duplicate command name found */
                   duplist = duplist || ZCTVERB','
                   If DUPD = '/' Then Do               /* DUPLICATES */
                      cpydup = cpydup + 1
                   /* "TBSKIP" TABNAME "NOREAD NUMBER(-1)" */
                      "TBADD" TABNAME
                      End
                   If DUPR = '/' Then Do               /* REPLACE    */
                      cpyrep = cpyrep + 1
                      "TBPUT" TABNAME
                      End
                   If DUPN = '/' Then Do              /* NOREPLACE    */
                      cpynot = cpynot + 1
                      cpynum = cpynum - 1
                      End
                   End
             End
          cpynum = cpynum + 1
          End
       SEL = ''
       If ZTDSELS > 1 Then
         "TBDISPL" cmds_table         /* get next selected row        */
       Else Do                        /* no more selected rows        */
          /*-------------------------------------------------------*/
          /* if target table is in command list - refresh the list */
          /*-------------------------------------------------------*/
          If lib_type = '02'x ,            /* table already active    */
          & (TABNAME = 'ISPCMDS' | TABNAME = ZAPPLID'CMDS' |,
             TABNAME = ZUCTPREF'CMDS'  | TABNAME = ZUCTPRE2'CMDS' |,
             TABNAME = ZUCTPRE3'CMDS'  | TABNAME = ZSCTPREF'CMDS' |,
             TABNAME = ZSCTPRE2'CMDS'  | TABNAME = ZSCTPRE3'CMDS' )
            Then ZCMD = 'REFRESH'     /* refresh the command list     */
            Else ZCMD = ''            /* nothing more to do           */
          End
       End
    ZTDSELS = 0

    /*----------------*/
    /* create message */
    /*----------------*/
    ZERRSM = ''
    If lib_type = '02'x Then               /* table already active    */
       ZERRLM = cpynum 'commands copied to active table' TABNAME', but',
                'not saved to disk.                              '
    Else                                   /* lib_type = '01'x        */
       ZERRLM = cpynum 'commands copied to table' TABNAME' in library',
                LIBNAME
    duplist = Strip(duplist,,',')
    If DUPR = '/' & cpyrep > 0 Then                     /* REPLACE    */
       ZERRLM = ZERRLM cpyrep 'commands replaced:' duplist
    If DUPN = '/' & cpynot > 0 Then                     /* NOREPLACE  */
       ZERRLM = ZERRLM cpynot 'commands not replaced:' duplist
    If DUPD = '/' & cpydup > 0 Then                     /* DUPLICATES */
       ZERRLM = ZERRLM cpydup 'duplicate commands:' duplist
    ZERRALRM = 'NO'                     /* no alarm with the message  */
    "SETMSG MSG(ISRZ002)"
    /*----------*/
    /* clean up */
    /*----------*/
    COPYCMDS = ''                          /* end 'copy cmds pending' */
    If lib_type = '02'x Then              /* table was already active */
       "TBEND" TABNAME
    Else Do                             /* table was specially opened */
       "TBCLOSE" TABNAME "LIBRARY(CMCOPY"tsuf")"
       If rc > 0 Then Do
          ZERRLM = 'Error saving table' TABNAME' in library' LIBNAME,
                   ' return code =' rc
          ZERRALRM = 'YES'                 /* alarm with the message  */
          End
       "TBOPEN XXXXX LIBRARY(XXX)"       /* this makes the FREE work  */
       Address TSO "FREE FI(CMCOPY"tsuf")"
       End
    Return

  /*==================================================================*/
  /* COPY of selected commands was cancelled - show message           */
  /*   - invoked by COPY_ROWS                                         */
  /*------------------------------------------------------------------*/
CANCEL_COPY:
    Do ZTDSELS                             /* clear pending selects   */
       SEL = ''
       If ZTDSELS = 1 Then Leave
       "TBDISPL" cmds_table
       End
    ZTDSELS = 0                            /* nothing more to select  */
    ZCMD = ''                              /* reset primary command   */
    COPYCMDS = ''                          /* end 'copy cmds pending' */
    ZERRSM = 'COPY Cancelled'
    ZERRLM = 'COPYING the selected commands to another table',
             'was CANCELLED'
    ZERRALRM = 'YES'                       /* alarm with the message  */
    "SETMSG MSG(ISRZ002)"
    Return

  /*==================================================================*/
  /* Position cursor for alphabetical copying of rows, when no exact  */
  /* matching command name is found.                                  */
  /*   - the basic logic is the same as in LOCATE_ROW                 */
  /*   - invoked only by COPY_ROWS                                    */
  /*------------------------------------------------------------------*/
COPY_ALPHA:
    Parse Var oldvars cpyverb'|' .     /* oldvars from GET_ROW        */
    ZCTVERB = Left(cpyverb,1)'*'
    "TBSCAN" TABNAME "NOREAD",         /* scan for same 1st character */
      "ARGLIST(ZCTVERB) CONDLIST(EQ) ROWID(rowid)"
    If RC > 0
       Then rowid = 0
       Else "TBSKIP" TABNAME "NOREAD NUMBER(-1)"        /* row before */
    ZCTVERB = cpyverb
    "TBSCAN" TABNAME "NOREAD",       /* find row that should be after */
      "ARGLIST(ZCTVERB) CONDLIST(GT)"
    If RC > 0 & rowid > 0 Then Do                     /* no row found */
       "TBSKIP" TABNAME "NOREAD ROW("rowid")"
       ZCTVERB = Left(cpyverb,1)'*'
       "TBSCAN" TABNAME "NOREAD",        /* scan for another 1st char */
          "ARGLIST(ZCTVERB) CONDLIST(NE)"
       End
    If RC = 0 Then            /* location found - csr on previous row */
       "TBSKIP" TABNAME "NOREAD NUMBER(-1)"
    Else                      /* location not found - go to bottom    */
       "TBBOTTOM" TABNAME "NOREAD"
    ZCTVERB = cpyverb                /* restore correct ZCTVERB value */
    Return

  /*==================================================================*/
  /* MOVE or COPY a command                                           */
  /*------------------------------------------------------------------*/
COPY_CMD:
    /*-------------------------------------------------*/
    /* building 'copy pending' information             */
    /* - note that conflicting move/copy line commands */
    /*   are prevented by the ISPFCMD0 panel, or they  */
    /*   are ignored here (if there were more pending  */
    /*   line commands and the user pressed PF3|)      */
    /*-------------------------------------------------*/
    If SEL = 'A' | SEL = 'B' Then Do
       If Word(COPYPEND,1) = 'after' ,
        | Word(COPYPEND,1) = 'before' Then Return
       If SEL = 'A' Then
          COPYPEND =   COPYPEND 'after' ZCTVERB CMDNUM CMDTAB CMDTORD
       If SEL = 'B' Then
          COPYPEND =   COPYPEND 'before' ZCTVERB CMDNUM CMDTAB CMDTORD
       End
    If SEL = 'C' | SEL = 'M' Then Do
       If Word(COPYPEND,1) = 'COPY',
        | Word(COPYPEND,1) = 'MOVE' Then Return
       If SEL = 'C' Then
          COPYPEND = 'COPY' CMDNUM COPYPEND
       If SEL = 'M' Then
          COPYPEND = 'MOVE' CMDNUM COPYPEND
       End

    If Words(COPYPEND) < 6 Then Return

    /*-----------------------------*/
    /* process a pending move/copy */
    /*-----------------------------*/
    Parse Var COPYPEND c_type c_row c_dirn c_name c_where c_tab c_tord
    COPYPEND = ''

    CMDNUM = c_row
    "TBTOP" cmds_table
    "TBSCAN" cmds_table "ARGLIST(CMDNUM)"

    c_verb = ZCTVERB
    If c_type = 'COPY' Then Do
       PNLTITLE = 'Copy command' c_verb 'in table' CMDTAB'CMDS'
       PNLTITLE = Centre(PNLTITLE,55)
       Call COPY_ZCTVARS          /* copy ZCTxx vars -> ZETxx vars  */
       If c_dirn = 'after' Then
          CMDNUM = c_where + 1
       If c_dirn = 'before' Then
          CMDNUM = c_where - 1
       CMDTAB = c_tab
       Call UPDATE_PANEL          /* use ISPFCMD4 panel for update  */
       End

    If ZUCMKEY = 'END' | c_type = 'MOVE' Then Do      /*** UPDATE ***/
       If CUR#SORT ¬= 'REAL ORDER' Then
          Call SORT_CMDSTABL('R')   /* sort into REAL ORDER         */

       If c_type = 'MOVE' Then Do
          Call POSN_CSRS
          "TBDELETE" upd_table
          "TBDELETE" cmds_table
          End
       If c_type = 'COPY' Then
          Call COPY_ZETVARS       /* setup variables for new row    */

       CMDTAB = c_tab
       CMDTORD = c_tord
       CMDNUM = c_where
       Call POSN_CSRS          /* position cursors for ADD_CMD   */

       If c_dirn = 'after' Then
          Call ADD_CMD('+')
       If c_dirn = 'before' Then
          Call ADD_CMD('-')

       If CUR#SORT ¬= 'REAL ORDER' Then
         Call SORT_CMDSTABL(CUR#SORT) /* sort back to current order */
       ZERRSM = c_type 'done'
       ZERRLM = c_type 'command' c_verb c_dirn 'command' c_name 'in',
                c_tab 'table'
       updated = 'Y'              /* command list was updated       */
       End
    Else Do
       ZERRSM = c_type 'cancelled'
       ZERRLM = c_type 'of command' c_verb 'was cancelled'
       End
    ZERRALRM = 'NO'               /* no alarm with the message      */
    "SETMSG MSG(ISRZ002)"         /* standard IBM message           */
    c_type = ''                   /* checked by UPDATE_PANEL        */
    Return

/*==================================================================*/
/* View the details of a command                                    */
/*   use View Command Definition panel derived from ISPUCMXR panel  */
/*------------------------------------------------------------------*/
VIEW_CMD:
    PNLTITLE = 'View command' ZCTVERB 'in table' CMDTAB'CMDS'
    PNLTITLE = Centre(PNLTITLE,55)

    Call COPY_ZCTVARS             /* copy ZCTxx vars -> ZETxx vars  */

    Call CHECK_RELATIONS          /* setup any relationship messages*/

    "CONTROL DISPLAY SAVE"        /* save the TBDISPL display       */
    "ADDPOP"                      /* next panel in Pop-Up window    */
    Do While rc = 0
       "DISPLAY PANEL(ISPFCMD5)"  /* View command definition: panel */
       End
    "REMPOP"                      /* remove the Pop-Up window       */
    "CONTROL DISPLAY RESTORE"     /* restore the TBDISPL display    */
    Return

/*==================================================================*/
/* Check relationships to this command                              */
/*   called by VIEW_CMD and UPDATE_PANEL                            */
/*------------------------------------------------------------------*/
CHECK_RELATIONS:
    cmd_num_r = CMDNUM                           /* where am I now? */
    ZERRLM = ''
    If ZCTACT = '' Then Do  /* ISPF ignores commands with no action */
       over_cmd = ''
       part_cmds = ''
       End
    Else Call ISIT_OVERRIDDEN             /* find overriding cmd(s) */
    Select
      When ZCTACT = '' Then
         ZERRLM = '** ISPF will ignore this command because it',
                  'has NO ACTION'
      When Words(cmd_list) > 1 & over_cmd = '' Then Do
         If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',50)
         ZERRLM = ZERRLM '** This command is invoked by:'cmd_list
         End
      When over_cmd ¬= '' & part_cmds = '' Then Do
         If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',50)
         ZERRLM = ZERRLM '** This command cannot be invoked (directly)',
                         'because it is OVERRIDDEN by   ',
                         null '  command',
                         Word(over_cmd,1) 'in table' Word(over_cmd,2)
         End
      When over_cmd ¬= '' & part_cmds ¬= '' Then Do
         If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',50)
         m1 = '** This command can be invoked only by entering'
         If Length(part_cmds) < 30 Then
            m2 = part_cmds Copies(' ',30) ,
            null '  because it is partly overridden by'
         Else
            m2 = part_cmds ' because it is partly overridden by'
         ZERRLM = m1 m2 Word(over_cmd,1) 'in table' Word(over_cmd,2)
         End
      Otherwise
      End
    If part_cmds ¬= '' Then Do
       Call DOES_IT_OVERRIDE
       If fovrverb ¬= '' Then Do
          If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',50)
          ZERRLM = ZERRLM '** It overrides command' fovrverb,
                          'in table' fovrtabl
          End
       If povrverb ¬= '' Then Do
          If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',50)
          ZERRLM = ZERRLM '** It partly overrides command' povrverb,
                          'in table' povrtabl
          End
       End
    alias_cmds = FIND_ALIAS_CMDS()  /* find ALIASes of this command */
    If Pos(',',alias_cmds) > 0 Then Do
       If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',50)
       ZERRLM = ZERRLM '** Commands:' alias_cmds ' are ALIAS of' ZCTVERB
       End
    Else If alias_cmds ¬= '' Then Do
       If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',50)
       ZERRLM = ZERRLM '** Command:' alias_cmds 'is ALIAS of' ZCTVERB
       End
    CMDNUM = cmd_num_r
    Select
      When Word(ZCTACT,1) = 'ALIAS' Then Do
         Call FIND_ALIAS_ACTION
         If ZCTVERB = '' Then Do
            If ZERRLM ¬= '' Then ZERRLM = ZERRLM Copies(' ',72)
            ZERRLM = ZERRLM ,
                     '** This command does NOTHING because it is',
                     'an ALIAS of command:' srch_alias Copies(' ',20),
                     '              ' null ' ',
                     'which is not after' ZETVERB 'in the ISPF command',
                     'search order'
            End
         Else Do
            If Word(ZCTACT,1) = 'SETVERB' Then Do
               ZCTVERB = ZCTVERB Subword(ZCTACT,2)
               ZCTACT = 'SETVERB'
               End
            If Length(ZERRLM) < 120 Then
               msg = '** The effective action of this',
                     'command is to invoke' Copies(' ',30),
                     null '  Command:' ZCTVERB     Copies(' ',62),
                     null '  Table  :' CMDTAB'CMDS'  Copies(' ',59),
                     null '  Action :' ZCTACT
            Else
               msg = '** The effective action is to invoke command',
                     ZCTVERB 'from table' CMDTAB'CMDS.         ',
                     null '  Action :' ZCTACT
            ZERRLM = ZERRLM Copies(' ',72) , /* start new line of msg */
                     msg
            End
         End
      Otherwise
      End
    If ZERRLM ¬= '' Then Do
       If Right(ZERRLM,10) = '          ' Then
          ZERRSM = ''
       ZERRHM = '*'
       ZERRALRM = 'NO .WINDOW=NORESP'
       "SETMSG MSG(ISRZ002)"
       End
 /* Say Length(ZERRLM)        maximum of 512 bytes */

    CMDNUM = cmd_num_r                          /* now where was I? */
    Return

/*==================================================================*/
/*  Find the effective action for an ALIAS command                  */
/*  - this is called by VIEW_CMD and INVOKE_CMD                     */
/*------------------------------------------------------------------*/
FIND_ALIAS_ACTION:
    srch_alias = Word(ZCTACT,2)       /* verb to search for         */
    aparm = Subword(ZCTACT,3)         /* any parm to be passed      */

    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL('R')        /* sort into REAL ORDER       */
    "TBTOP" cmds_table
    "TBSCAN" cmds_table "NOREAD ARGLIST(CMDNUM)" /* position cursor */
    If SEL = 'R' Then                 /* repeated cmd maybe ALIAS   */
       "TBSKIP" cmds_table "NOREAD NUMBER(-1)" /* .. of the old cmd */

    lsa = Length(srch_alias)
    Do al = 1 to 9999
       "TBSKIP" cmds_table
       If rc > 0 Then Do              /* rc=8 at end of table       */
          ZCTVERB = ''
          Leave al
          End
       If ZCTTRUNC = 0 Then ZCTTRUNC = Length(Strip(ZCTVERB))
       If Left(ZCTVERB,lsa) = srch_alias,
        & ZCTTRUNC <= lsa Then Do
          If Word(ZCTACT,1) ¬= 'ALIAS' Then Leave al
          srch_alias = Word(ZCTACT,2) /* it is an ALIAS of an ALIAS */
          If Subword(ZCTACT,3) ¬= '' Then
             aparm = Subword(ZCTACT,3) /* ISPF only knows last parm|*/
          lsa = Length(srch_alias)
          Iterate al                  /* follow the alias chain     */
          End
       End
    If aparm ¬= '' Then Do
       zp = Pos('&ZPARM',ZCTACT)      /* does the action use &ZPARM?*/
       If zp > 0 Then                 /* parm replaces the '&ZPARM' */
          ZCTACT = Left(ZCTACT,zp-1)||aparm||Substr(ZCTACT,zp+6)
       Else
          ZCTACT = ZCTACT aparm       /* add the parm to the action */
       End

    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL(CUR#SORT)   /* sort back to current order */
    Return

/*==================================================================*/
/*  Make list of all commands that are ALIAS of ZCTVERB             */
/*  - this is called by VIEW_CMD and UPDATE_PANEL                   */
/*------------------------------------------------------------------*/
FIND_ALIAS_CMDS:
    alias_cmds = ''
    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL('R')        /* sort into REAL ORDER       */

    "TBTOP" cmds_table
    cmd_num_a = CMDNUM
    "TBSCAN" cmds_table "ARGLIST(CMDNUM)"        /* position cursor */

    /* save some details about this command */
    If CMDTRUNC = ''
       Then this_len = Length(Strip(ZCTVERB))/* # of required chars */
       Else this_len = Length(CMDTRUNC)
    this_verb = ZCTVERB
    this_over = CMDOVER                  /* is this cmd overridden? */

    /*--------------------------------------------------------------*/
    /* Check all the previous commands for 'ALIAS this_verb'.       */
    /*  a) If this_cmd is overridden, we must stop when we reach    */
    /*     the overriding command.                                  */
    /*  b) When checking ALIAS, we must allow for truncation.  The  */
    /*     matching name maybe shorter if this_verb can be truncated*/
    /*--------------------------------------------------------------*/
    Do alsrch = 1 to 9999
       "TBSKIP" cmds_table "NUMBER(-1)"        /* get previous row  */
       If rc > 0 Then Leave
       If this_over = '-',               /* this cmd is overridden  */
        & CMDOVER ¬= '' Then Do          /* possibly overriding cmd */
          If CMDTRUNC = ''
             Then ZCT_len = Length(Strip(ZCTVERB)) /* # req'd chars */
             Else ZCT_len = Length(CMDTRUNC)
          If Pos(this_verb,ZCTVERB) = 1 ,
           & this_len >= ZCT_len
             Then Leave alsrch          /* it is the overriding cmd */
          End
       If CMDOVER = '-' Then             /* overridden command      */
          Iterate alsrch
       If Word(ZCTACT,1) = 'ALIAS' Then Do
          alias_verb = Word(ZCTACT,2)
          If Pos(alias_verb,this_verb) = 1 ,   /* names match       */
           & Length(alias_verb) >= this_len    /* truncation OK?    */
             Then alias_cmds = ZCTVERB','alias_cmds
          End
       End
    alias_cmds = Strip(alias_cmds,,',')

    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL(CUR#SORT)   /* sort back to current order */

    "TBTOP" cmds_table
    CMDNUM = cmd_num_a
    "TBSCAN" cmds_table "ARGLIST(CMDNUM)"      /* refresh variables */
    Return alias_cmds

/*==================================================================*/
/*  Look for overriding command(s)                                  */
/*  - creates a) list of overriding cmds & their tables: over_cmd   */
/*            b) list of cmds that can invoke this one : part_cmds  */
/*  - this is called by CHECK_RELATIONS and UPDATE_PANEL            */
/*------------------------------------------------------------------*/
ISIT_OVERRIDDEN:
    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL('R')        /* sort into REAL ORDER       */

    valid_cmds = '.'
    valid_lengths = ''
    oververb = ''
    overtabl = ''
    cmd_list = ''
    cmd_numo = CMDNUM
    /*---------------------------------------------------------------*/
    /* scan for each possible truncation of our command, looking for */
    /* the first command that matches                                */
    /*---------------------------------------------------------------*/
/*  Say 'Verb' ZETVERB 'has CMDMINL =' CMDMINL */
/*  Say 'Verb' ZETVERB 'has length:' Length(ZETVERB) */
    Do ovsrch = CMDMINL To Length(Strip(ZETVERB))/* make list of all */
       cmd_list = cmd_list Left(ZETVERB,ovsrch) /* poss. truncations */
       End
    "TBTOP" cmds_table
    Do ovsrch = Words(cmd_list) To 1 By -1
       ZCTVERB = Word(cmd_list,ovsrch)'*'
       CMDMINL = Length(ZCTVERB) - 1
       ZCTACT  = ''
       "TBSCAN" cmds_table "ARGLIST(ZCTVERB,CMDMINL,ZCTACT)",
                           "CONDLIST(EQ,LE,NE)"
       If CMDNUM >= cmd_numo Then Do      /* no other cmd before it  */
          valid_cmds = Word(cmd_list,ovsrch) 'or' valid_cmds
          valid_lengths = Length(Word(cmd_list,ovsrch))||valid_lengths
          End
       Else                               /* scan found another cmd  */
          If Pos(Strip(ZCTVERB)',',oververb) = 0 Then Do    /* new?  */
             oververb = Strip(ZCTVERB)','oververb  /* add it to list */
             overtabl = CMDTAB','overtabl
             End
       "TBTOP" cmds_table
       End
    overtabl = Strip(overtabl,,',')
    If overtabl ¬= '' & Pos(',',overtabl) = 0 Then
       overtabl = overtabl'CMDS'           /* only one table */
    over_cmd = Strip(oververb,,',') overtabl
    Parse Var valid_cmds part_cmds ' or .'
    If part_cmds = '.' Then part_cmds = ''
 /*
    say part_cmds
    say valid_lengths
 */

    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL(CUR#SORT)    /* sort back to current order */

    "TBTOP" cmds_table
    CMDNUM = cmd_numo
    "TBSCAN" cmds_table "ARGLIST(CMDNUM)"       /* refresh variables */
    Return

/*==================================================================*/
/*  Look for overridden command(s)                                  */
/*  - uses    list of cmds that can invoke this one : part_cmds     */
/*  - creates list of overridden cmds & their tables: dead_cmds     */
/*  - this is called by CHECK_RELATIONS and UPDATE_PANEL            */
/*------------------------------------------------------------------*/
DOES_IT_OVERRIDE:
    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL('R')        /* sort into REAL ORDER       */

    fovrverb = ''                /* list of fully-overridden verbs  */
    fovrtabl = ''                /* list of tables for fovrverb's   */
    povrverb = ''                /* list of partly-overridden verbs */
    povrtabl = ''                /* list of tables for povrverb's   */
    this_verb = ZETVERB
    this_num = CMDNUM
    "TBTOP" cmds_table
    CMDNUM = this_num
    "TBSCAN" cmds_table "ARGLIST(CMDNUM) CONDLIST(EQ) NOREAD"
    this_part = Word(part_cmds,1)        /* shortest valid command */
    this_leng = Left(valid_lengths,1)    /* length of the shortest */

    Do scan = 1 To 999
       ZCTVERB = this_part'*'
       ZCTACT = ''
       "TBSCAN" cmds_table "ARGLIST(ZCTVERB,ZCTACT)",
                           "CONDLIST(EQ,NE)"
       If rc = 0 Then Do
          /*-------------------------------------------------*/
          /* update lists of fully- & partly-overridden cmds */
          /*-------------------------------------------------*/
          ZCTVERB = Strip(ZCTVERB)
          found_lengths = '' /* list of valid lengths for found verb */
          Do jj = CMDMINL To Length(ZCTVERB)
             found_lengths = found_lengths||jj
             End
          If Length(ZCTVERB) <= Length(this_verb) Then Do
             If Pos(ZCTVERB,this_verb) = 1 Then Do  /* name matches  */
                If Pos(found_lengths,valid_lengths) > 0 Then Do
                   fovrverb = fovrverb','ZCTVERB      /* add to list */
                   fovrtabl = fovrtabl','CMDTAB
                   End
                Else Do                         /* partly overridden */
                   povrverb = povrverb','ZCTVERB      /* add to list */
                   povrtabl = povrtabl','CMDTAB
                   End
                End
             End
          Else Do         /* found verb name doesn't match this_verb */
             If CMDMINL <= this_leng Then Do  /* partly overridden */
                povrverb = povrverb','ZCTVERB      /* add to list */
                povrtabl = povrtabl','CMDTAB
                End
             Else Do ll = 2 To Length(valid_lengths)
                cleng = Substr(valid_lengths,ll,1) /* get next length */
                If CMDMINL > cleng Then Iterate ll
                If Left(ZCTVERB,cleng) = Left(this_verb,cleng) Then Do
                   povrverb = povrverb','ZCTVERB      /* add to list */
                   povrtabl = povrtabl','CMDTAB
                   End
                Leave ll
                End
             End
          End
       If rc = 8 Then Leave
       End
    /*-----------------------------------------------------------*/
    /* cleanup the lists - they are displayed in an ISPF message */
    /*-----------------------------------------------------------*/
    fovrverb = Strip(fovrverb,,',')
    fovrtabl = Strip(fovrtabl,,',')
    If Pos(',',fovrtabl) = 0 Then          /* only one table */
       fovrtabl = fovrtabl'CMDS'
    povrverb = Strip(povrverb,,',')
    povrtabl = Strip(povrtabl,,',')
    If Pos(',',povrtabl) = 0 Then          /* only one table */
       povrtabl = povrtabl'CMDS'

    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL(CUR#SORT)    /* sort back to current order */

    "TBTOP" cmds_table
    CMDNUM = cmd_numo
    "TBSCAN" cmds_table "ARGLIST(CMDNUM)"       /* refresh variables */
    Return

/*==================================================================*/
/* Exclude a command                                                */
/*------------------------------------------------------------------*/
EXCLUDE_CMD:
    CMDSEL = ' '
    "TBPUT" cmds_table "ORDER"    /* update CMDSEL                  */
    Return

/*==================================================================*/
/* Display HELP panel (if one is defined in ZCTDESC)                */
/*------------------------------------------------------------------*/
DISPLAY_HELP:
    Parse Upper Var ZCTDESC . 'HELP(' hpanl ')'
    If hpanl = '' & CMDTAB = 'ISP' Then
       Call ISPCMDS_HELP      /* standard IBM help for this command */
    If ZCTDESC = '<<< no commands in this table >>>' ,
     & ZCTVERB = '--------' Then hpanl = 'ISPFCMHE'
    If hpanl ¬= '' Then Do
       CMDHLPNM = ZCTVERB
       CMDHLPDE = ZCTDESC
       CMDHLPTB = CMDTAB
       "VPUT (CMDHLPNM CMDHLPDE CMDHLPTB) SHARED"
       "SELECT PGM(ISPTUTOR) PARM("hpanl")"
       End
    Else Do
       ZERRSM = 'No HELP defined'
       ZERRLM = 'No HELP panel defined in the description of command',
                 ZCTVERB
       ZERRALRM = 'YES'             /* alarm with the message       */
       "SETMSG MSG(ISRZ002)"        /* standard IBM message         */
       End
    Return

/*==================================================================*/
/* Select appropriate (standard IBM) HELP panel for this command    */
/* - most of these are the ones specified in panel ISP01305         */
/* - this is up to date for ISPF 5.7 & z/OS 1.7                     */
/*------------------------------------------------------------------*/
ISPCMDS_HELP:
    Select
      When ZCTVERB = 'ACTIONS'  Then hpanl = 'ISP01370'
      When ZCTVERB = 'AUTOTYPE' Then hpanl = 'ISR00900'
      When ZCTVERB = 'BACKWARD' Then hpanl = 'ISP01316'
      When ZCTVERB = 'BOTTOM'   Then hpanl = 'ISP01316'
      When ZCTVERB = 'CANCEL'   Then hpanl = 'ISP01390'
      When ZCTVERB = 'CMDE'     Then hpanl = 'ISPCMDEH'
      When ZCTVERB = 'COLOR'    Then hpanl = 'ISP06200'
      When ZCTVERB = 'CRETRIEV' Then hpanl = 'ISP01391'
      When ZCTVERB = 'CUAATTR'  Then hpanl = 'ISP06100'
      When ZCTVERB = 'CURSOR'   Then hpanl = 'ISP01318'
      When ZCTVERB = 'DDLIST'   Then hpanl = 'ISRDDNPT'
      When ZCTVERB = 'DOWN'     Then hpanl = 'ISP01316'
      When ZCTVERB = 'DSLIST'   Then hpanl = 'ISR34099'
      When ZCTVERB = 'DTEST'    Then hpanl = 'ISP01904'
      When ZCTVERB = 'END'      Then hpanl = 'ISP01313'
      When ZCTVERB = 'ENVIRON'  Then hpanl = 'ISP05700'
      When ZCTVERB = 'EPDF'     Then hpanl = 'ISREPDFT'
      When ZCTVERB = 'EXHELP'   Then hpanl = 'ISP01367'
      When ZCTVERB = 'EXIT'     Then hpanl = 'ISP01392'
      When ZCTVERB = 'EXPAND'   Then hpanl = 'ISP01324'
      When ZCTVERB = 'FKA'      Then hpanl = 'ISP01326'
      When ZCTVERB = 'FORWARD'  Then hpanl = 'ISP01316'
      When ZCTVERB = 'HELP'     Then hpanl = 'ISP01362'
   /* When ZCTVERB = 'INT'      Then hpanl = '????????' */
      When ZCTVERB = 'ISPDTLC'  Then hpanl = 'ISP0300'
      When ZCTVERB = 'ISPFVAR'  Then hpanl = 'ISP01344'
   /* When ZCTVERB = 'ISPFTTRC' Then hpanl = '????????' */
      When ZCTVERB = 'ISPFWORK' Then hpanl = 'ISR00400'
      When ZCTVERB = 'ISPLIBD'  Then hpanl = 'ISP01375'
      When ZCTVERB = 'ISPPREP'  Then hpanl = 'ISP01340'
   /* When ZCTVERB = 'ISPVCALL' Then hpanl = '????????' */
      When ZCTVERB = 'ISRRLIST' Then hpanl = 'ISP01346'
      When ZCTVERB = 'ISRROUTE' Then hpanl = 'ISP01348'
      When ZCTVERB = 'KEYLIST'  Then hpanl = 'ISP01380'
      When ZCTVERB = 'KEYS'     Then hpanl = 'ISP01320'
      When ZCTVERB = 'KEYSHELP' Then hpanl = 'ISP01367'
      When ZCTVERB = 'LEFT'     Then hpanl = 'ISP01316'
      When ZCTVERB = 'LIST'     Then hpanl = 'ISP90200'
      When ZCTVERB = 'LOG'      Then hpanl = 'ISP90200'
      When ZCTVERB = 'MSGID'    Then hpanl = 'ISP01354'
   /* When ZCTVERB = 'NRETRIEV' Then hpanl = '????????' */
      When ZCTVERB = 'PANELID'  Then hpanl = 'ISP01322'
      When ZCTVERB = 'PFSHOW'   Then hpanl = 'ISP01326'
      When ZCTVERB = 'PRINTG'   Then hpanl = 'ISP05600'
      When ZCTVERB = 'PRINT'    Then hpanl = 'ISP01319'
      When ZCTVERB = 'PRINT-HI' Then hpanl = 'ISP01319'
      When ZCTVERB = 'PRINTL'   Then hpanl = 'ISP01325'
      When ZCTVERB = 'PRINTLHI' Then hpanl = 'ISP01325'
      When ZCTVERB = 'PSCOLOR'  Then hpanl = 'ISP06100'
      When ZCTVERB = 'RCHANGE'  Then hpanl = 'ISP01315'
      When ZCTVERB = 'RETURN'   Then hpanl = 'ISP01314'
      When ZCTVERB = 'RFIND'    Then hpanl = 'ISP01315'
      When ZCTVERB = 'REFADDD'  Then hpanl = 'ISR00315'
      When ZCTVERB = 'REFADDL'  Then hpanl = 'ISR00315'
      When ZCTVERB = 'REFACTD'  Then hpanl = 'ISR00315'
      When ZCTVERB = 'REFACTL'  Then hpanl = 'ISR00315'
      When ZCTVERB = 'REFLISTD' Then hpanl = 'ISR00315'
      When ZCTVERB = 'REFLISTL' Then hpanl = 'ISR00315'
      When ZCTVERB = 'REFOPEND' Then hpanl = 'ISR00315'
      When ZCTVERB = 'REFOPENL' Then hpanl = 'ISR00315'
      When ZCTVERB = 'RESIZE'   Then hpanl = 'ISP01377'
      When ZCTVERB = 'RETF'     Then hpanl = 'ISP01360'
      When ZCTVERB = 'RETP'     Then hpanl = 'ISP01360'
      When ZCTVERB = 'RETRIEVE' Then hpanl = 'ISP01360'
      When ZCTVERB = 'RETURN'   Then hpanl = 'ISP01314'
      When ZCTVERB = 'RIGHT'    Then hpanl = 'ISP01316'
      When ZCTVERB = 'SAREA'    Then hpanl = 'ISPSAMHP'
      When ZCTVERB = 'SCRNAME'  Then hpanl = 'ISPSM940'
      When ZCTVERB = 'SETTINGS' Then hpanl = 'ISPSM000'
      When ZCTVERB = 'SPLIT'    Then hpanl = 'ISP01312'
      When ZCTVERB = 'SPLITV'   Then hpanl = 'ISP01330'
      When ZCTVERB = 'START'    Then hpanl = 'ISP01361'
      When ZCTVERB = 'SWAP'     Then hpanl = 'ISP01317'
      When ZCTVERB = 'SWITCH'   Then hpanl = 'ISP01358'
      When ZCTVERB = 'SYSNAME'  Then hpanl = 'ISP01327'
      When ZCTVERB = 'TOP'      Then hpanl = 'ISP01316'
      When ZCTVERB = 'TSO'      Then hpanl = 'ISP01321'
      When ZCTVERB = 'TSOCMD'   Then hpanl = 'ISR60010'
      When ZCTVERB = 'TSOGUI'   Then hpanl = 'ISP01384'
      When ZCTVERB = 'TUTOR'    Then hpanl = 'ISP00000'
      When ZCTVERB = 'UP'       Then hpanl = 'ISP01316'
      When ZCTVERB = 'USERID'   Then hpanl = 'ISP01328'
      When ZCTVERB = 'WINDOW'   Then hpanl = 'ISP01368'
      When ZCTVERB = 'WS'       Then hpanl = 'ISP01388'
      When ZCTVERB = 'WSCON'    Then hpanl = 'ISP01394'
      When ZCTVERB = 'WSDISCON' Then hpanl = 'ISP01396'
      When ZCTVERB = 'ZKEYS'    Then hpanl = 'ISP05300'
      Otherwise hpanl = 'ISP01305'
      End
    Return

/*==================================================================*/
/* Invoke a command                                                 */
/* (&ZPARM is taken from the command line or from panel ISPFCMD6)   */
/*------------------------------------------------------------------*/
INVOKE_CMD:
    Select
    When act = 'PASSTHRU' Then Return
    When act = '' Then Return
    When Left(ZCTACT,1) = '&' Then Return  /* variable substitution */
    Otherwise
       /*--------------------------------------------------------*/
       /* The selected commands are written at the start of the  */
       /* first command table, and invoked after all other line  */
       /* commands have been processed.                          */
       /*                                                        */
       /* ZCTVERB is made unique unless it is a SETVERB command, */
       /* by putting a hex prefix at the start.  This causes a   */
       /* problem with ALIAS processing, so FIND_ALIAS_ACTION is */
       /* used to get the effective action.  If the ZCTVERB is   */
       /* changed to something like $TMPtt-nn (where tt = TSUF & */
       /* nn = a unique number) the ALIAS processing works OK &  */
       /* overridden ALIAS commands will search from the top for */
       /* a matching cmd; but then the user may see these funny  */
       /* verb names (when ISPFCMD0 panel shows an error msg) so */
       /* the hex prefix method is used instead.                 */
       /*                                                        */
       /* ZCTDESC is changed so that it will be recognised later */
       /* as a pending command; (and its length <= 80).          */
       /*                                                        */
       /* ZCTACT is unchanged except for ALIAS commands, which   */
       /* have their effective action instead (unless there is   */
       /* no matching cmd, then the original action is used -    */
       /* perhaps it can find a matching cmd when it is invoked  */
       /* from the top of the first table - see above).          */
       /*--------------------------------------------------------*/
       /*---------------------------------------------------*/
       /* insert '<<PENDING>>' & HELP panel name in ZCTDESC */
       /*---------------------------------------------------*/
       Parse Upper Var ZCTDESC . 'HELP(' hpanl ')'
       If hpanl = '' & CMDTAB = 'ISP' Then
          Call ISPCMDS_HELP   /* standard IBM help for this command */
       If hpanel = '' Then
          ZCTDESC = Left(hex_tsuf '<<PENDING>>' ZCTDESC,80)
       Else Do
          ZCTDESC = Left(hex_tsuf '<<PENDING>>' ZCTDESC,65),
                    'HELP('hpanl')'        /* HELP starts in col 67 */
          End
       /* ZCTDESC = Left(hex_tsuf '<<PENDING>>',                    */
       /*           tsuf ZCTDESC,80)   * so tsuf can be easily read */
       /*-----------------------------------------------*/
       /* make ZCTVERB unique (unless Action='SETVERB') */
       /*-----------------------------------------------*/
       If Word(ZCTACT,1) ¬= 'SETVERB' Then Do
       /* ZCTVERB = '$T'tsuf'-'pendcmds        * create unique name */
          ZCTVERB = Left(hex_tsuf||ZCTVERB,8) /* create unique name */
          ZCTTRUNC = 0
          End
       /*----------------------------------------------------*/
       /* change Action from 'ALIAS' to the effective action */
       /*----------------------------------------------------*/
       If Word(ZCTACT,1) = 'ALIAS' Then Do
          Call SAVE_VARS('ZCTVERB ZCTTRUNC ZCTACT ZCTDESC')
          Call FIND_ALIAS_ACTION
          If ZCTVERB = '' Then Do      /* no cmd matching alias */
             Call RESTORE_VARS('ZCTVERB ZCTTRUNC ZCTACT ZCTDESC')
             End
          Else Do
             If Word(ZCTACT,1) = 'SETVERB' Then
                Call RESTORE_VARS('ZCTDESC')
             Else
                Call RESTORE_VARS('ZCTVERB ZCTTRUNC ZCTDESC')
             End
          End
       /*----------------------------------------------------------*/
       /* add cmd to top first table, after the other pending cmds */
       /*----------------------------------------------------------*/
       "TBTOP" firstab
       "TBSKIP" firstab "NOREAD NUMBER("pendcmds")"
       "TBADD" firstab
       pendcmds = pendcmds + 1
    End
    Return

/*==================================================================*/
/*  Check that rows in cmds_table match the actual live table       */
/*  - this is used before any table updating                        */
/*------------------------------------------------------------------*/
VALIDATE_CMDSTABL:
    /*-----------------------------------------------------------*/
    /* only compare once when multiple rows are directly updated */
    /*-----------------------------------------------------------*/
    If ZTDSELS = last_ZTDSELS - 1 Then Do
       If SEL = '' & last_ZTDSELS = '' Then Do     /* auto-selected */
          last_ZTDSELS = ZTDSELS
          last_SEL = SEL
          Return 0
          End
       End
    last_ZTDSELS = ZTDSELS
    last_SEL = SEL
    VALVERB = ZCTVERB          /* can be shown on ISPFCMD7 if error */

    /*--------------------*/
    /* prepare to compare */
    /*--------------------*/
    If CMDSORT ¬= 'REAL ORDER' Then       /* CMDSORT = actual order */
       Call SORT_CMDSTABL('R')          /* sort into REAL ORDER */

    Call SAVE_VARS('CMDTAB CMDTORD CMDOVER CMDSEL CMDALIAS CMDNUM',
          'CMDFND CMDTRUNC CMDMINL ZCTVERB ZCTTRUNC ZCTDESC ZCTACT')

    LIVE = CMDTAB
    LIVETABL = CMDTAB'CMDS'
    "TBTOP" LIVETABL
    "TBTOP" cmds_table
    "TBSCAN" cmds_table ,             /* find first row of LIVETABL */
             "ARGLIST(CMDTAB) NOREAD"
    "TBSKIP" cmds_table "NOREAD NUMBER(-1)"
    retcode = 0
    /*------------------------------------------*/
    /* compare all rows that should be matching */
    /*------------------------------------------*/
trace O
    Do valno = 1 to 9999
       "TBSKIP" LIVETABL
       lskip_rc = rc
       lvars = ZCTVERB'|'ZCTTRUNC'|'ZCTACT'|'ZCTDESC
       If (Word(ZCTDESC,2) = '<<RUNNING>>' ,
        |  Word(ZCTDESC,2) = '<<PENDING>>'),
        &  Word(ZCTDESC,1) <= '99'x ,
        &  Datatype(C2X(Word(ZCTDESC,1))) = 'NUM'
           Then Iterate valno          /* pending cmd - try next row*/
       "TBSKIP" cmds_table
       cskip_rc = rc
       If lskip_rc = 8 & valno = 1,            /* LIVETABL is empty */
        & (ZCTDESC = '<<< no commands in this table >>>' ,
        &  ZCTVERB = '--------') Then Leave valno
       If (cskip_rc = 8 | CMDTAB ¬= LIVE ),
        & lskip_rc = 8 Then Leave valno   /* end of tables */
       If lskip_rc = 0 & cskip_rc = 0 Then Do
          If lvars = ZCTVERB'|'ZCTTRUNC'|'ZCTACT'|'ZCTDESC
             Then Iterate valno        /* rows matched - try next   */
          End
       /*------------------------*/
       /* something didn't match */
       /*------------------------*/
       "CONTROL DISPLAY SAVE"          /* save the TBDISPL display  */
       "ADDPOP COLUMN(10)"
       "DISPLAY PANEL(ISPFCMD7)"       /* 'Validate ERROR' panel    */
       "REMPOP"
       "CONTROL DISPLAY RESTORE"       /* restore TBDISPL display   */
       retcode = 8
       Leave valno
       End

    Call RESTORE_VARS('CMDTAB CMDTORD CMDOVER CMDSEL CMDALIAS CMDNUM',
          'CMDFND CMDTRUNC CMDMINL ZCTVERB ZCTTRUNC ZCTDESC ZCTACT')

    If CUR#SORT ¬= 'REAL ORDER' Then
       Call SORT_CMDSTABL(CUR#SORT)   /* restore the sort order     */
    Return retcode                    /* retcode = 0 or 8           */

/*==================================================================*/
/* SAVE and RESTORE variables                                       */
/* - used instead of VPUT/VGET so we don't pollute any SHARED pool  */
/*------------------------------------------------------------------*/
SAVE_VARS:
    Arg vars
    Do v = 1 to Words(vars)
       savevar = Word(vars,v)
       Interpret 'SAVED_'savevar '=' savevar
       End
    Return 0

RESTORE_VARS:
    Arg vars
    Do v = 1 to Words(vars)
       restvar = Word(vars,v)
       Interpret restvar '= SAVED_'restvar
       End
    Return 0

/*==================================================================*/
/* Prepare any pending selected cmd to be actioned by ISPFCMD0      */
/* - this works even if the number of pending rows ¬= pendcmds,     */
/*   or the pending rows have been moved within the table           */
/*------------------------------------------------------------------*/
PREPARE_PENDCMD:
     "TBTOP" firstab
     Do sloop = 1 to 9999           /* get next pending cmd row     */
        "TBSKIP" firstab ,          /* next row of table            */
           "POSITION(pendrow)"      /* save the row number          */
        If rc > 0 Then Do           /* end of table|                */
           pendcmds = 0             /* no pending cmds              */
           Leave sloop
           End
       If Left(ZCTDESC,1) ¬= hex_tsuf ,
        | Word(ZCTDESC,2) ¬= '<<PENDING>>'
          Then Iterate sloop        /* row is not pending cmd|      */

        parm_rc = GET_PARMS()       /* get &ZPARM for cmd action    */
        If parm_rc = 0 Then Do
           If ZCMD = '' & Word(ZCTACT,1) = 'SETVERB' Then
              ZCMD = Subword(ZCTACT,2)
           SELCMD = ZCTVERB ZCMD    /* SELCMD is the cmd to enter   */
           End
        Leave sloop                 /* parm_rc = 0 or 8             */
        End
    "TBTOP" cmds_table
    "TBSKIP" cmds_table "NUMBER("cmdtop") NOREAD"
     Return
/*==================================================================*/
/*  User given a chance to suppy parameters for a command           */
/*------------------------------------------------------------------*/
GET_PARMS:
    zp = Pos('&ZPARM',ZCTACT)       /* does the action use &ZPARM?  */
    If ZCTACT = 'SETVERB' ,         /* SETVERB can use parameters   */
     | zp > 0 Then Do               /* put ZCMD where &ZPARM was    */
       If ZCMD = '' Then Do
          If ZCTACT = 'SETVERB'     /* show cmdname in window title */
             Then IVERB = ZCTVERB            /* cmdname is the same */
             Else IVERB = Substr(ZCTVERB,2)  /* original cmdname    */
          Parse Upper Var ZCTDESC 67 'HELP(' HPANL ')'
          ZETDESC = Subword(ZCTDESC,3) /* strip <<PENDING>> prefix  */
          Parse Var ZCTACT,            /* vars to display Action    */
             1 ZETACT1 61 ZETACT2 121 ZETACT3
          CMDHLPNM = IVERB             /* var for HELP panel: hpanl */
          CMDHLPDE = Left(ZETDESC,52)  /* var for HELP panel: hpanl */
          "VPUT (CMDHLPNM CMHLPDE) SHARED"
          "CONTROL DISPLAY SAVE"       /* save the TBDISPL display  */
          Call CHECK_PFKEYS('ISRSNAB')
          "ADDPOP"
          "DISPLAY PANEL(ISPFCMD6)"    /* Ask user to supply &ZPARM */
          parm_rc = rc  /* user replies: ENTER (rc=0) or END (rc=8) */
          "REMPOP"
          "CONTROL DISPLAY RESTORE"    /* restore TBDISPL display   */
          If parm_rc > 0 Then Do
             ZERRSM = 'Cancelled'
             ZERRLM = 'Invocation of command' ZCTVERB 'was CANCELLED'
             Return parm_rc
             End
          End
    /* ZCTACT = Left(ZCTACT,zp-1)||ZCMD||Substr(ZCTACT,zp+6) */
       End
    /*--------------------------------------------------------------*/
    /* Sometimes ISPF moves the CRP to the TOP of firstab ||        */
    /* Hence, ensure its on the right row before trying to update.  */
    /*--------------------------------------------------------------*/
    "TBTOP" firstab
    "TBSKIP" firstab "NUMBER("pendrow") NOREAD"
    pr = Pos('PENDING>>',ZCTDESC)
    ZCTDESC = Overlay('RUNNING',ZCTDESC,pr)
    "TBPUT" firstab            /* change <<PENDING>> to <<RUNNING>> */
    Return 0

/*==================================================================*/
/* Remove any pending selected command row from the first table     */
/* - this works even if the number of pending rows ¬= pendcmds,     */
/*   or the pending rows have been moved within the table           */
/*------------------------------------------------------------------*/
DELETE_PENDCMD:
    Call SAVE_VARS('CMDTAB CMDTORD CMDOVER CMDSEL CMDALIAS CMDNUM',
          'CMDFND CMDTRUNC CMDMINL ZCTVERB ZCTTRUNC ZCTDESC ZCTACT')

     Do ploop = 1 to pendcmds
        "TBTOP" firstab
        Do sloop = 1 to 9999          /* delete 1 pending cmd row     */
           "TBSKIP" firstab
           If rc > 0 Then Do
              pendcmds = 0
              Leave ploop
              End
           If Left(ZCTDESC,1) = hex_tsuf Then Do
              "TBDELETE" firstab
              pendcmds = pendcmds - 1
              If pendcmds >= 1 Then   /* If pendcmds <= 0, then clean */
                 Leave sloop          /* .. all remaining rows        */
              End
           End
        If ZCMD ¬= 'REF',             /* REF deletes all pending cmds */
         & ZCMD ¬= 'RES' Then Leave   /* RES deletes all pending cmds */
        End

    Call RESTORE_VARS('CMDTAB CMDTORD CMDOVER CMDSEL CMDALIAS CMDNUM',
          'CMDFND CMDTRUNC CMDMINL ZCTVERB ZCTTRUNC ZCTDESC ZCTACT')
     Return

/*==================================================================*/
/*  Mark which commands override others - in variable CMDOVER       */
/*  1. '*' completely overriding other command(s)                   */
/*     '+' partially overriding other command(s)                    */
/*     '.' partially overridden command                             */
/*     '-' completely overridden command                            */
/*  2. The cmds_table has been first sorted into REAL ORDER         */
/*  3. Each command is checked by scanning for any following verb   */
/*       which would be overridden                                  */
/*  This is invoked whenever any command(s) is updated.             */
/*------------------------------------------------------------------*/
SETUP_OVER:
    "SELECT CMD(CALL *(ISPFCMDO) '"cmds_table"') MODE(FSCR)"
    Return

  /*"SELECT PGM(ISPFCMDO) PARM("cmds_table")"   <--- not working yet  */
  /*Address TSO "CALL *(ISPFCMDO) '"cmds_table"'"    <-- ISPF abend   */

 trace O
    /*---------------------------*/
    /* clear CMDOVER in all rows */
    /*---------------------------*/
    "TBTOP" cmds_table                    /* starting at top of table */
    CMDOVER = ' '
    Do oloop = 1 To 9999
      "TBSCAN" cmds_table "ARGLIST(CMDOVER) CONDLIST(NE)"
       If rc > 0 Then Leave oloop         /* we reached end of table  */
       CMDOVER = ' '
       "TBPUT" cmds_table "ORDER"
       End

    /*----------------------------------------------------------------*/
    /* scan the table for every row, updating CMDOVER when necessary  */
    /*----------------------------------------------------------------*/
    "TBTOP" cmds_table                    /* starting at top of table */
    Do sloop = 1 To 9999
       "TBSKIP" cmds_table
       If rc > 0 Then Leave sloop         /* we reached end of table  */

       If CMDOVER = '-' Then              /* ignore overridden command*/
          Iterate sloop
       If ZCTACT  = ''  Then              /* ignore no-action command */
          Iterate sloop
       If ZCTDESC = '<<< no commands in this table >>>' ,
        & ZCTVERB = '--------' Then Iterate sloop

       this_verb = Strip(ZCTVERB)
       this_leng = CMDMINL                /* no. of required chars    */
       this_short = Left(this_verb,this_leng)  /* shortest cmd string */
       this_num = CMDNUM
       override = ''
       Do scan = 1 To 999
          ZCTVERB = this_short'*'
          ZCTACT = ''
          "TBSCAN" cmds_table "ARGLIST(ZCTVERB,ZCTACT)",
                              "CONDLIST(EQ,NE)"
          If rc = 0 Then Do
             /*------------------------------------------------*/
             /* update CMDOVER for overridden cmd in the table */
             /*------------------------------------------------*/
             ZCTVERB = Strip(ZCTVERB)
             If Pos(ZCTVERB,this_verb) = 1 Then Do
                If CMDMINL >= this_leng Then Do
                   override = '*'
                   CMDOVER = '-'
                   End
                Else Do
                   If override ¬= '*' Then override = '+'
                   If CMDOVER  ¬= '-' Then CMDOVER = '.'
                   End
                End
             Else Do
                If Pos(Left(ZCTVERB,CMDMINL),this_verb) = 1 ,
                 | CMDMINL <= this_leng Then Do
                   If override ¬= '*' Then override = '+'
                   If CMDOVER  ¬= '-' Then CMDOVER = '.'
                   End
                End
             "TBPUT" cmds_table "ORDER"
             End
          Else Do   /* no more matching commands found */
             /*---------------------------------------------------*/
             /* finally update CMDOVER for this_verb in the table */
             /*---------------------------------------------------*/
             CMDNUM = this_num
             "TBSCAN" cmds_table "ARGLIST(CMDNUM)"
             If (override = '*' & Pos(CMDOVER,'.-') = 0),
              | (override = '+' & Pos(CMDOVER,'.-') = 0) Then Do
                CMDOVER = override
                "TBPUT" cmds_table "ORDER"
                End
             Iterate sloop
             End
          End
       End
    Return

/*==================================================================*/
/*  Sort user table into desired sequence                           */
/*------------------------------------------------------------------*/
SORT_CMDSTABL:
    Arg CMDSORT
    Select
      When Left(CMDSORT,2) = 'AL' Then Do    /* sort by alias order */
        CMDSORT = 'ALIAS'
        "TBSORT "cmds_table " FIELDS(CMDALIAS,N,A,CMDNUM,N,A)"
        End
      When Left(CMDSORT,1) = 'R' Then Do  /* sort by original order */
        CMDSORT = 'REAL ORDER'
        "TBSORT "cmds_table " FIELDS(CMDNUM,N,A)"
        End
      When Left(CMDSORT,1) = 'T' Then Do  /* sort by Table & Verb   */
        CMDSORT = 'TABLE'
        "TBSORT "cmds_table " FIELDS(CMDTORD,C,A,ZCTVERB,C,A)"
        End
      When Left(CMDSORT,1) = 'A' Then Do  /* sort by Action & Verb  */
        CMDSORT = 'ACTION'
        "TBSORT "cmds_table "FIELDS(ZCTACT,C,A,ZCTVERB,C,A,CMDNUM,N,A)"
        End
      When Left(CMDSORT,1) = 'D' Then Do  /* sort by Desc & Verb    */
        CMDSORT = 'DESCRIPTION'
        "TBSORT "cmds_table "FIELDS(ZCTDESC,C,A,ZCTVERB,C,A,CMDNUM,N,A)"
        End
      When Left(CMDSORT,1) = 'C' Then Do  /* sort by Verb & Table   */
           CMDSORT = 'COMMAND NAME'
           "TBSORT "cmds_table " FIELDS(ZCTVERB,C,A,CMDNUM,N,A)"
           End
      Otherwise   /* when no parameter: 1st COMMAND, then flip/flop */
        If CUR#SORT = 'COMMAND NAME' Then Do
           CMDSORT = 'REAL ORDER'         /* sort by original order */
           "TBSORT "cmds_table " FIELDS(CMDNUM,N,A)"
           End
        Else Do
           CMDSORT = 'COMMAND NAME'       /* sort by Verb & Table   */
           "TBSORT "cmds_table " FIELDS(ZCTVERB,C,A,CMDNUM,N,A)"
           End
      End
    csrrow = 0
    Return

/*==================================================================*/
/* Put table stats into a table and display it                      */
/*------------------------------------------------------------------*/
DISPLAY_TABLINFO:
 /* "TBEND" cmdtbs_table                     always renew the table */
    "TBCREATE" cmdtbs_table "NOWRITE KEYS(CMDTABL)",
       "NAMES(CMDROWS,CMDDSN,CMDVOL,CMDDATE,CMDTIME,CMDUSER)"
    tbcreate_rc = rc              /* rc > 0 if table already exists */
    If tabnames = 'TABNAMES' Then Do
       tabnames =  TB2A TB2B TB2C TB3A TB3B TB3C TB4A TB4B TB4C
       If ZAPPLID ¬= 'ISP' Then tabnames = ZAPPLID tabnames
       End
    Do t = 1 to Words(tabnames)
       CMDTABL = Word(tabnames,t)'CMDS'
       "TBSTATS" cmdtabl "ROWCURR(CMDROWS) STATUS2(status2)",
          "UDATE(CMDDATE) UTIME(CMDTIME) USER(CMDUSER)"
       If status2 ¬= 1 Then Do                   /* table is open    */
          CMDROWS = Format(CMDROWS)   /* remove the leading zeros    */
        /*If tbget_rc = 8  */  /* no existing row - get dataset name */
          If CMDTABL = ZAPPLID'CMDS' & appl_lib = 'unknown' Then Do
             CMDDSN = '-- unknown --'
             CMDVOL = ''
             End
          Else Do
             CMDDSN = FIND_MEMBER(cmdtabl 'ISPTLIB')
             CMDVOL = VOLUME
             /* If Length(CMDDSN) < 28 Then           */
             /*    CMDDSN = Overlay(VOLUME,CMDDSN,29) */
             End
          "TBMOD" cmdtbs_table              /* update or add the row */
          End
       End
    old_tbtop = ZTDTOP                      /* save old top line no. */
    "TBTOP" cmdtbs_table
    /*-------------------------------*/
    /* display the table stats panel */
    /*-------------------------------*/
    "TBDISPL" cmdtbs_table "PANEL(ISPFCMD3) AUTOSEL(NO)"
    If rc > 8 Then Do
       ZERRLM   '***  Error: TBDISPL of table' cmdtbs_table',',
                'using panel ISPFCMD3 has FAILED, rc =' rc
       ZERRSM = ''                   /* no short message             */
       ZERRALRM = 'YES .WINDOW=LRESP'/* alarm, user must press ENTER */
       "SETMSG MSG(ISRZ002)"         /* standard IBM message         */
       End
    ZTDTOP = old_tbtop                      /* restore top line no.  */
    Return

/*==================================================================*/
/* Look for 'member' in the 'file' concatenation                    */
/*  - return the name of the first library with that member, and if */
/*    it is accessed by a LIBDEF put '**' or '****' before the      */
/*    dsname, plus put the volser into variable: VOLUME             */
/*  - note that only Application cmd tables can come from a LIBDEF, */
/*    User, Site & System tables must come from ISPTLIB.            */
/*  - this code assumes that all concatenated datasets are catlg'd, */
/*    which is true if TSO ALLOC was used for allocations           */
/*------------------------------------------------------------------*/
FIND_MEMBER:
  trace O
    Parse Upper Arg member file              /* file = ISPTLIB      */
    If member = ZAPPLID'CMDS' Then Do        /* Application cmds    */
       "QLIBDEF" file "TYPE(libtype) ID(libid)"
       If rc = 0 Then Do                     /* a LIBDEF is active  */
          dlist = Translate(libid,"  ","',") /* no quotes or commas */
          /*----------------------------------*/
          /* check user-level libraries first */
          /*----------------------------------*/
          If libtype = 'DATASET' Then Do
             If Left(file,3) = 'ISP' Then
                userlib = Left(file,4)'USR'  /* userlib = ISPTUSR   */
             Call CHECK_1ST_DSN(userlib)     /* check first library */
             If result = 0 Then Do
                VOLUME = sysvolume
                Return '****' sysdsname      /* '****' -> ISPTUSR   */
                End
             If result < 20 Then Do
                Call FIND_DSNLIST(userlib)   /* get library list    */
                If result = 0 Then Do i = 2 To Words(dsnlist)
                   dsn = Word(dsnlist,i)
                   x = Sysdsn("'"dsn"("member")'")
                   If x = 'OK' Then Do       /* member found        */
                      y = LISTDSI("'"dsn"'")
                      VOLUME = sysvolume
                      Return '****' dsn      /* RETURN the DSNAME   */
                      End
                   End
                End
             End
          /*-------------------------------*/
          /* check normal LIBDEF libraries */
          /*-------------------------------*/
          If libtype = 'DATASET' Then        /* only catlg'd d'sets */
             dsnlist = Translate(libid,"  ","',") /* no quote/comma */
          If libtype = 'LIBRARY' Then Do
             Call CHECK_1ST_DSN(libid)       /* check first library */
             If result = 0 Then Do
                VOLUME = sysvolume
                Return '**' sysdsname       /* '***' -> LIBDEF     */
                End
             If result < 20 Then
                Call FIND_DSNLIST(libid)     /* get library list    */
             End
          Do i = 1 To Words(dsnlist)
             dsn = Word(dsnlist,i)
             x = Sysdsn("'"dsn"("member")'")
             If x = 'OK' Then Do             /* member found        */
                y = LISTDSI("'"dsn"'")
                VOLUME = sysvolume
                Return '**' dsn             /* RETURN the DSNAME   */
                End
             End
          End
       End

    /*------------------------------------*/
    /* check normally allocated libraries */
    /*------------------------------------*/
    Call CHECK_1ST_DSN(file)                 /* check first library */
    If result = 0 Then Do
       VOLUME = sysvolume
       Return sysdsname
       End
    If result < 20 Then Do
       Call FIND_DSNLIST(file)   /* get list of libraries allocated */
       Do i = 2 To Words(dsnlist)
          dsn = Word(dsnlist,i)
          x = Sysdsn("'"dsn"("member")'")    /* look for the member */
          If x = 'OK' Then Do                /* member found        */
             y = LISTDSI("'"dsn"'")
             VOLUME = sysvolume
             Return dsn                      /* RETURN the DSNAME   */
             End
          End
       End
    Return  '????? (uncataloged dataset)'    /* member not found    */

/*==================================================================*/
/* Check for the member in the first library in the ddname          */
/*   - if BROWSE rc>0 then no panel would be displayed, and a dummy */
/*     DISPLAY is done to use the pending 'END' command             */
/*------------------------------------------------------------------*/
CHECK_1ST_DSN: Arg ddfind

    x = LISTDSI(ddfind 'FILE')               /* get 1st dsn & vol   */
    If x > 0 Then Return 69

    "CONTROL DISPLAY SAVE"                   /* save what we have   */
    "CONTROL NONDISPL END"                   /* pending 'END' cmd   */
    "BROWSE DATASET('"sysdsname"("member")') VOLUME("sysvolume")"
    browse_rc = rc                           /* rc=0 when found     */
    If browse_rc > 0 Then
       "DISPLAY PANEL(ISRBROM)"              /* dummy display       */
    "CONTROL DISPLAY RESTORE"                /* restore environment */

    Return browse_rc                         /* rc=14,16: not found */

/*==================================================================*/
/* Return a list of the datasets in the specified file allocation   */
/*   - This is called only by FIND_MEMBER & CREATE_TABL             */
/*------------------------------------------------------------------*/
FIND_DSNLIST:
    Parse Upper Arg file

    If var.0 = 'VAR.0' Then Do   /* do LISTA only once|             */
       x = Outtrap('var.')       /* trap TSO messages in stem var.  */
       Address TSO "LISTA ST"    /* list dataset allocations in TSO */
       x = Outtrap('OFF')        /* end message trapping            */
       End

    ddname  = ''
    dsnlist = ''
    Do i = 2 To var.0 By 2       /* process the trapped messages    */
       parse var var.i dsn .
       If dsn = 'TERMFILE' | dsn = 'NULLFILE' then i = i - 1
       Else Do
          j = i + 1
          Parse Var var.j newdd disp
          If disp ¬= ' ' Then
             ddname = Strip(newdd)   /* get a new DDNAME            */
          End
       If ddname = file Then         /* If it's the DDNAME we want  */
          dsnlist = dsnlist dsn      /* .... add the dsn to dsnlist */
       Else   /* ddname ¬= file */
          If dsnlist ¬= '' Then      /* if dsnlist has been created */
             Return 0
       End
    Return 8                         /* dsnlist not created         */

/*==================================================================*/
/*  Save table to disk                                              */
/*  This is called for commands: SAVEAPPL,3,SAVE,SAVEUSER,SAVESITE. */
/*  The target table is open SHARE NOWRITE, so we copy it to a      */
/*  temporary table, then use TBSAVE with the NAME parameter to     */
/*  write it to disk.                                               */
/*   Note: that any user with UPDATE access to the library can      */
/*         use this dialog to permanently update the table on disk. */
/*   Hence, ensure that table libraries have appropriate protection.*/
/*------------------------------------------------------------------*/
SAVE_TABL:
    Arg SAVTAB
    ZERRSM = ''
    Select
      When SAVTAB = 'USER' & ZUCTPREF||ZUCTPRE2||ZUCTPRE3 ¬= '' Then Do
         If (ZUCTPREF ¬= '') + (ZUCTPRE2 ¬= '') + (ZUCTPRE3 ¬= '') = 1 ,
         Then      /* only 1 User Command table active */
            from_table = Strip(ZUCTPREF||ZUCTPRE2||ZUCTPRE3)'CMDS'
         Else Do
          /*-------------------------------------------*/
          /* user must select which User table to save */
          /*-------------------------------------------*/
            SELDDACT = 'Save'
            Call CHECK_PFKEYS('ISRSNAB')
            "ADDPOP"
            "DISPLAY PANEL(ISPFCMDD)"     /* Ask user to select table */
            selt_rc = rc  /* user replies: ENTER (rc=0) or END (rc=8) */
            "REMPOP"
            If selt_rc > 0 Then Do
               ZERRSM = 'Save cancelled'
               ZERRLM = 'No User Command table selected to be saved'
               "SETMSG MSG(ISRZ002)"         /* standard IBM message  */
               Return
               End
            If selt_rc = 0 Then
               from_table = TABNAME
            End
         to_table = 'USERCM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'USR1' & ZUCTPREF ¬= '' Then Do
         from_table = Strip(ZUCTPREF)'CMDS'
         to_table = 'USERCM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'USR2' & ZUCTPRE2 ¬= '' Then Do
         from_table = Strip(ZUCTPRE2)'CMDS'
         to_table = 'USR2CM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'USR3' & ZUCTPRE3 ¬= '' Then Do
         from_table = Strip(ZUCTPRE3)'CMDS'
         to_table = 'USR3CM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'SITE' & ZSCTPREF||ZSCTPRE2||ZSCTPRE3 ¬= '' Then Do
         If (ZSCTPREF ¬= '') + (ZSCTPRE2 ¬= '') + (ZSCTPRE3 ¬= '') = 1 ,
         Then      /* only 1 Site Command table active */
            from_table = Strip(ZSCTPREF||ZSCTPRE2||ZSCTPRE3)'CMDS'
         Else Do
          /*-------------------------------------------*/
          /* user must select which Site table to save */
          /*-------------------------------------------*/
            SELDDACT = 'Save'
            Call CHECK_PFKEYS('ISRSNAB')
            "ADDPOP"
            "DISPLAY PANEL(ISPFCMDD)"     /* Ask user to select table */
            selt_rc = rc  /* user replies: ENTER (rc=0) or END (rc=8) */
            "REMPOP"
            If selt_rc > 0 Then Do
               ZERRSM = 'Save cancelled'
               ZERRLM = 'No Site Command table selected to be saved'
               "SETMSG MSG(ISRZ002)"         /* standard IBM message  */
               Return
               End
            If selt_rc = 0 Then
               from_table = TABNAME
            End
         to_table = 'SITECM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'SIT1' & ZSCTPREF ¬= '' Then Do
         from_table = Strip(ZSCTPREF)'CMDS'
         to_table = 'SITECM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'SIT2' & ZSCTPRE2 ¬= '' Then Do
         from_table = Strip(ZSCTPRE2)'CMDS'
         to_table = 'SIT2CM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'SIT3' & ZSCTPRE3 ¬= '' Then Do
         from_table = Strip(ZSCTPRE3)'CMDS'
         to_table = 'SIT3CM'||tsuf        /* make a unique table name */
         End
      When SAVTAB = 'APPL' & NOAPPL  ¬= 'YES' Then Do
         from_table = Strip(ZAPPLID)'CMDS'
         to_table = 'APPLCM'||tsuf        /* make a unique table name */
         End
      Otherwise
       ZERRSM = 'No' SAVTAB 'commands'
       ZERRLM = 'INVALID: there is no' SAVTAB ,
                'Command table to be saved'
       ZERRHM = 'ISPFCMHC'
      End

    If ZERRSM ¬= '' Then Do
       ZERRALRM = 'YES'                  /* alarm with the message    */
       "SETMSG MSG(ISRZ002)"             /* standard IBM message      */
       Return
       End

    cmdfile = 'CMSAVE'||tsuf
    Parse Var from_table CMDTAB 'CMDS'
    Call VALIDATE_CMDSTABL            /* .... is cmds_table valid?    */
    If result > 0 Then Return

    "TBEND" to_table          /* remove any existing temp user table  */
    "TBCREATE" to_table ,     /* create temporary table in WRITE mode */
       "NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC) WRITE"

    /*------------------------------*/
    /* create copy of Command Table */
    /*------------------------------*/
    Call COPY_TABLE('NODUMMY')    /* copy cmds to temp table xxxxCMyy */
    If Result = 0 Then Do
       If (Left(SAVTAB,2) = 'US' & user_empty = 'YES'),
        | (Left(SAVTAB,2) = 'SI' & site_empty = 'YES') Then Do
          /*----------------------------------------------*/
          /* put list of ISPTLIB libraries in table CMTLIBS */
          /*----------------------------------------------*/
          SAVTABL = from_table
          Call CREATE_CMTLIBS
          /*----------------------------------------------------------*/
          /* Display panel asking user to identify the target library */
          /*----------------------------------------------------------*/
          ZTDSELS = 0
          Do until ZTDSELS > 0
             "TBDISPL CMTLIBS PANEL(ISPFCMD1)",/* display ISPTLIB libs*/
                "AUTOSEL(NO)"              /*  no auto-select of rows */
             If rc > 0 Then Do
                "TBEND" to_table
                "TBEND CMTLIBS"
                Return
                End
             End
          "TBEND CMTLIBS"
          End
       /*-------------------------------------------------*/
       /* get valid library name & allocate it to cmdfile */
       /*-------------------------------------------------*/
       Else Do
          If SAVTAB = 'APPL' & appl_lib = 'unknown' Then Do
             cmdlib = '-- unknown --'
             VOLUME = ''
             End
          Else Do
             cmdlib = FIND_MEMBER(from_table 'ISPTLIB')
             If Words(cmdlib) = 2 Then      /* '***' if dsn in LIBDEF */
                cmdlib = Word(cmdlib,2)
             End
          End
       /*------------------------------------*/
       /* get confirmation before continuing */
       /*------------------------------------*/
       conf_rc = CONFIRM_SAVE(from_table cmdlib)
       If conf_rc > 0 Then Do
          "TBEND" to_table
          Return
          End
       If VOLUME = '' Then
          Address TSO "ALLOC FI("cmdfile") DS('"LIBNAME"') SHR REUSE"
       Else
          Address TSO "ALLOC FI("cmdfile") DS('"LIBNAME"')",
                      "VOL("VOLUME") SHR REUSE"
       /*-------------------------------------------------------------*/
       /* SAVE temporary table, replacing any existing table on disk. */
       /*-------------------------------------------------------------*/
       "TBSAVE" to_table "NAME("TABNAME") LIBRARY("cmdfile")"
       If rc = 0 Then Do
          "TBQUERY" from_table "ROWNUM(qrows)"
          If qrows = 0 Then Do
             If Left(SAVTAB,2) = 'US' Then user_empty = 'YES'
             If Left(SAVTAB,2) = 'SI' Then site_empty = 'YES'
             End
          Else Do    /* qrows ¬= 0  */
             If Left(SAVTAB,2) = 'US' Then user_empty = 'NO'
             If Left(SAVTAB,2) = 'SI' Then site_empty = 'NO'
             End
          ZERRSM = SAVTAB 'commands saved'
          ZERRLM = SAVTAB 'command table saved in' LIBNAME'('TABNAME')'
          ZERRALRM = 'NO'                /* no alarm with the message */
          End
       Else Do
          ZERRSM = 'Commands not saved'
          ZERRLM = 'Unable to save cmds in' LIBNAME 'dataset, rc='rc
          ZERRALRM = 'YES'               /* alarm with the message    */
          End
       "SETMSG MSG(ISRZ002)"             /* standard IBM message      */
       "TBOPEN XXXXX LIBRARY(XXX)"       /* this makes the FREE work  */
       Address TSO "FREE FI("cmdfile")"
       End
    "TBEND" to_table           /* finished with the temp user table   */
    Return

/*==================================================================*/
/*  User to Confirm that the new table should be written to disk    */
/*    - invoked from SAVE_TABL  & CREATE_TABL                       */
/*------------------------------------------------------------------*/
CONFIRM_SAVE:
    Parse Arg TABNAME LIBNAME      /* get table name & library name */
    If LIBNAME = '????? (uncataloged dataset)' Then Do
       LIBNAME = ''
       EXISTS = 24
       End
    Else Do          /* check if it will replace an existing member */
       "CONTROL DISPLAY SAVE"                /* save what we have   */
       "CONTROL NONDISPL END"                /* pending 'END' cmd   */
       "BROWSE DATASET('"LIBNAME"("TABNAME")') VOLUME("VOLUME")"
       browse_rc = rc                        /* rc=0 when found     */
       If browse_rc > 0 Then
          "DISPLAY PANEL(ISRBROM)"           /* dummy display       */
       "CONTROL DISPLAY RESTORE"             /* restore environment */
       EXISTS = browse_rc
       End
    TABFIRST = TABNAME      /* original table-name to show on panel */
    Do cs = 1 to 99
       Call CHECK_PFKEYS('ISRSNAB')
       "ADDPOP"
       "DISPLAY PANEL(ISPFCMD2)"   /* Ask user to confirm or cancel */
       conf_rc = rc     /* user replies: ENTER (rc=0) or END (rc=8) */
       "REMPOP"
       If conf_rc > 0 & COPYCMDS ¬= 'YES' Then Do
          ZERRSM = 'SAVE Cancelled'
          ZERRLM = 'SAVE of Command Table' TABNAME 'was CANCELLED'
          ZERRALRM = 'YES'               /* alarm with the message  */
          "SETMSG MSG(ISRZ002)"          /* standard IBM message    */
          Leave cs
          End
       Else Do  /* conf_rc = 0 */
          "CONTROL DISPLAY SAVE"             /* save what we have   */
          "CONTROL NONDISPL END"             /* pending 'END' cmd   */
          "BROWSE DATASET('"LIBNAME"("TABNAME")') VOLUME("VOLUME")"
          browse_rc = rc                     /* rc=0 when found     */
          If browse_rc > 0 Then
             "DISPLAY PANEL(ISRBROM)"        /* dummy display       */
          "CONTROL DISPLAY RESTORE"          /* restore environment */
          EXISTS = browse_rc
          If EXISTS < 20  Then Leave cs
          ZERRSM = ''
          ZERRLM = "*** ERROR: '"LIBNAME"' not found"
          If VOLUME = ''
             Then ZERRLM = ZERRLM "***"
             Else ZERRLM = ZERRLM "on volume" VOLUME "***"
          ZERRALRM = 'YES .WINDOW=LNORESP' /* alarm, msg in window  */
          "SETMSG MSG(ISRZ002)"          /* standard IBM message    */
          End
       End
    Return conf_rc

/*==================================================================*/
/*  User to specify which library should be used to open table      */
/*  - this is called only by CONFIRM_TABLE                          */
/*------------------------------------------------------------------*/
CONFIRM_LIBRARY:
    Do co = 1 to 99
       Call CHECK_PFKEYS('ISRSNAB')
       If applid = 'TOOL' & COPYCMDS ¬= 'YES' Then
          "CONTROL NONDISPL ENTER"
       "ADDPOP"
       "DISPLAY PANEL(ISPFCMD9)"   /* Ask user to confirm or cancel */
       conf_rc = rc     /* user replies: ENTER (rc=0) or END (rc=8) */
       "REMPOP"
       If conf_rc > 0 Then Do
          If COPYCMDS = 'YES' Then
             Call CANCEL_COPY          /* 'COPY cancelled' message  */
          Else Do
             ZERRSM = 'OPEN Cancelled'
             ZERRLM = 'OPEN of Command Table' TABNAME 'was CANCELLED'
             ZERRALRM = 'YES'            /* alarm with the message  */
             "SETMSG MSG(ISRZ002)"       /* standard IBM message    */
             End
          Leave co
          End
       Else Do  /* conf_rc = 0 */
          "CONTROL DISPLAY SAVE"             /* save what we have   */
          "CONTROL NONDISPL END"             /* pending 'END' cmd   */
          "BROWSE DATASET('"LIBNAME"("TABNAME")') VOLUME("VOLUME")"
          browse_rc = rc                     /* rc=0 when found     */
          If browse_rc > 0 Then
             "DISPLAY PANEL(ISRBROM)"        /* dummy display       */
          "CONTROL DISPLAY RESTORE"          /* restore environment */
          EXISTS = browse_rc
          If EXISTS < 20  Then Leave co
          ZERRSM = ''
          ZERRLM = "*** Library '"LIBNAME"' not found"
          If VOLUME ¬= '' Then
             ZERRLM = ZERRLM "on volume" VOLUME
          ZERRLM = ZERRLM Copies(' ',50)  null ,
                   '   (the name must be fully qualified)'
          ZERRALRM = 'YES .WINDOW=LNORESP' /* alarm, msg in window  */
          "SETMSG MSG(ISRZ002)"          /* standard IBM message    */
          End
       End
    If EXISTS = 14 | EXISTS = 16 Then Do        /* member not found */
       CONFOPEN = 'YES'                   /* used by ISPFCMD2 panel */
       If COPYCMDS = 'YES' Then Do
          conf_rc = CONFIRM_SAVE(TABNAME LIBNAME)
          If conf_rc = 0 Then create_copy_table = 'YES'
          End
       Else Do
          new_appl_lib = LIBNAME
          Call CREATE_APPLTABL
          conf_rc = result
          End
       End
    Return conf_rc

/*==================================================================*/
/*  Create a new Application Table                                  */
/*  - this is called by MAINLINE or by CONFIRM_LIBRARY              */
/*------------------------------------------------------------------*/
CREATE_APPLTABL:
    SAVTAB = 'APPL'
    /*-------------------------------------------------*/
    /* get valid library name & allocate it to cmdfile */
    /*-------------------------------------------------*/
    If new_appl_lib ¬= 'NEW_APPL_LIB' Then
       cmdlib = new_appl_lib
    Else Do
       TABNAME = Strip(ZAPPLID)"CMDS"
       cmdlib = FIND_MEMBER(TABNAME 'ISPTLIB')
       If Words(cmdlib) = 2 Then          /* '***' if dsn in LIBDEF */
          cmdlib = Word(cmdlib,2)
       End
    /*----------------------------------------------------------*/
    /* get confirmation before continuing                       */
    /* - user can change table-name & library name in the panel */
    /*----------------------------------------------------------*/
    conf_rc = CONFIRM_SAVE(TABNAME cmdlib)
    If conf_rc > 0 Then
       Return conf_rc              /* RETURN if PF3/PF12 from panel */
    cmdfile = 'CM'ZAPPLID||tsuf         /* attempt unique file name */
    If VOLUME = '' Then
       Address TSO "ALLOC FI("cmdfile") DS('"LIBNAME"') SHR REUSE"
    Else
       Address TSO "ALLOC FI("cmdfile") DS('"LIBNAME"')",
                   "VOL("VOLUME") SHR REUSE"
    /*-------------------------------------*/
    /* create temp table & add 1 dummy row */
    /*-------------------------------------*/
    Parse Var TABNAME tabpref 'CMDS'
    t_table = tabpref'CM'||tsuf      /* try to make a unique tbname */
    "TBEND" t_table            /* ensure no temp table already open */
    "TBCREATE" t_table,        /* create new user table, WRITE mode */
       "NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC) WRITE"
    If COPYCMDS ¬= 'YES' Then Do
       ZCTVERB  = '??'
       ZCTTRUNC = '0'
       ZCTACT   = ''               /* null action = 'do nothing'    */
       ZCTDESC  = '<<< table created by' Userid() 'on' Date() '>>>'
       "TBADD" t_table             /* add row to temp table         */
       End
    /*----------------------------------------*/
    /* write new table into the table library */
    /*----------------------------------------*/
    "TBCLOSE" t_table ,            /* pad 500% to leave extra space */
       "NAME("TABNAME") LIBRARY("cmdfile") PAD(500)"
    save_rc = rc
    If rc = 0 & COPYCMDS ¬= 'YES' Then Do
       ZERRSM = TABNAME 'commands saved'
       ZERRLM = TABNAME 'command table saved in' LIBNAME 'dataset'
       ZERRALRM = 'NO'                 /* no alarm with the message */
       End
    Else If rc > 0 Then Do
       ZERRSM = 'Commands not saved'
       ZERRLM = 'Unable to save cmds in' LIBNAME 'dataset, rc='rc
       ZERRALRM = 'YES'                /* alarm with the message    */
       End
    "SETMSG MSG(ISRZ002)"
    "TBOPEN XXXXX LIBRARY(XXX)"        /* this makes the FREE work  */
    Address TSO "FREE FI("cmdfile")"
    Return save_rc

/*==================================================================*/
/*  Create a new User or Site Command Table                         */
/*------------------------------------------------------------------*/
CREATE_TABL:
    Arg SAVTAB
    If (SAVTAB = 'USER' & USERPREF||USR2PREF||USR3PREF = '') ,
     | (SAVTAB = 'SITE' & SITEPREF||SIT2PREF||SIT3PREF = '') Then Do
       ZERRSM = ''
       ZERRLM = 'INVALID:' SAVTAB 'Command Tables are not in use.',
                'Enter HELP for details.'
       ZERRHM = 'ISPFCMHC'          /* HELP: configuring cmd tables  */
       ZERRALRM = 'YES'
       "SETMSG MSG(ISRZ002)"
       ZERRHM = '*'                 /* .HELP reset                   */
       Return
       End
    If SAVTAB = 'USER' Then Do
       If (USERPREF ¬= '') + (USR2PREF ¬= '') + (USR3PREF ¬= '') = 1 ,
       Then      /* only 1 User Command table defined */
          SAVTABL = Strip(USERPREF||USR2PREF||USR3PREF)'CMDS'
       Else Do
          /*---------------------------------------------*/
          /* user must select which User table to create */
          /*---------------------------------------------*/
          SELDDACT = 'Create'
          Call CHECK_PFKEYS('ISRSNAB')
          "ADDPOP"
          "DISPLAY PANEL(ISPFCMDD)"      /* Ask user to select table */
          selt_rc = rc   /* user replies: ENTER (rc=0) or END (rc=8) */
          "REMPOP"
          If selt_rc > 0 Then Do
             ZERRSM = 'Create cancelled'
             ZERRLM = 'No User Command table selected to be created'
             "SETMSG MSG(ISRZ002)"          /* standard IBM message  */
             Return
             End
          If selt_rc = 0 Then
             SAVTABL = TABNAME
          End
       End
    If SAVTAB = 'SITE' Then Do
       If (SITEPREF ¬= '') + (SIT2PREF ¬= '') + (SIT3PREF ¬= '') = 1 ,
       Then      /* only 1 Site Command table defined */
          SAVTABL = Strip(SITEPREF||SIT2PREF||SIT3PREF)'CMDS'
       Else Do
          /*---------------------------------------------*/
          /* user must select which Site table to create */
          /*---------------------------------------------*/
          SELDDACT = 'Create'
          Call CHECK_PFKEYS('ISRSNAB')
          "ADDPOP"
          "DISPLAY PANEL(ISPFCMDD)"      /* Ask user to select table */
          selt_rc = rc   /* user replies: ENTER (rc=0) or END (rc=8) */
          "REMPOP"
          If selt_rc > 0 Then Do
             ZERRSM = 'Create cancelled'
             ZERRLM = 'No Site Command table selected to be created'
             "SETMSG MSG(ISRZ002)"          /* standard IBM message  */
             Return
             End
          If selt_rc = 0 Then
             SAVTABL = TABNAME
          End
       End
    /*----------------------------------------------*/
    /* put list of ISPTLIB libraries in table CMTLIBS */
    /*----------------------------------------------*/
    Call CREATE_CMTLIBS
    /*----------------------------------------------------------*/
    /* Display panel asking user to identify the target library */
    /*----------------------------------------------------------*/
    ZTDSELS = 0
    Do until (rc > 0 | ZTDSELS > 0)
       "TBDISPL CMTLIBS PANEL(ISPFCMD1)", /* display list of ISPTLIB */
          "AUTOSEL(NO)"                  /*  no auto-select of rows */
       If ZTDSELS > 0 Then Do      /* if user selects a library ... */
          /*------------------------------------*/
          /* get confirmation before continuing */
          /*------------------------------------*/
          conf_rc = CONFIRM_SAVE(SAVTABL CMDLIB)
          If conf_rc > 0 Then Do
             "TBEND CMTLIBS"
             Return
             End
          /* allocate library to unique ddname */
          If SAVTAB = 'USER' Then cmdfile = 'CMDU'||tsuf
          If SAVTAB = 'SITE' Then cmdfile = 'CMDS'||tsuf
          Address TSO "ALLOC FI("cmdfile") DS('"CMDLIB"') SHR REUSE"
          alloc_rc = rc
          /*-------------------------------------*/
          /* create temp table & add 1 dummy row */
          /*-------------------------------------*/
          t_table = SAVTAB'CM'||tsuf /* try to make a unique tbname */
          "TBEND" t_table      /* ensure no temp table already open */
          "TBCREATE" t_table, /* create new user table, WRITE mode */
             "NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC) WRITE"
          ZCTVERB  = '??'
          ZCTTRUNC = '0'
          ZCTACT   = ''            /* null action = 'do nothing'    */
          ZCTDESC  = '<<< Dummy command for you to modify >>>'
          If SAVTAB = 'APPL' Then
            ZCTDESC  = '<<< table created by' Userid() 'on' Date() '>>>'
          "TBADD" t_table          /* add row to temp table         */
          /*----------------------------------------*/
          /* write new table into the table library */
          /*----------------------------------------*/
          "TBCLOSE" t_table ,      /* pad 500% to leave extra space */
             "NAME("SAVTABL") LIBRARY("cmdfile") PAD(500)"
          If rc = 0 Then Do
             If (SAVTAB = 'USER' &,    /* User table already exists */
                 (ZUCTPREF = SAVTABL | ZUCTPRE2 = SAVTABL |,
                  ZUCTPREF = SAVTABL) ),
              | (SAVTAB = 'SITE' &,    /* Site table already exists */
                 (ZSCTPREF = SAVTABL | ZSCTPRE2 = SAVTABL |,
                  ZSCTPREF = SAVTABL) ),
             Then Do
                Call UPDATE_NEWTABL    /* ... update it             */
                txt = 'Now'            /* text in ZERRLM message    */
                End
             Else                      /* no existing User table    */
                txt = 'Next you should EXIT from ISPF,',
                      'then start ISPF again and your',
                      'new command table will be active.  Then'
             ZERRLM = 'A new' SAVTAB 'Command Table ('SAVTABL') was',
                      'created in' CMDLIB 'library. ' txt ,
                      'use this "ISPF Commands" tool to',
                      'update your' SAVTAB 'Commands table. ',
                      'It contains a dummy command for you to modify,',
                      'and you can add extra commands too. '
             If SAVTAB = 'USER' Then ZERRLM = ZERRLM ||,
                      'Then use option 3 to SAVE your new commands.'
             If SAVTAB = 'SITE' Then ZERRLM = ZERRLM ||,
                      'Then use command SAVESITE to SAVE the new table.'
             ZERRSM = ''
             End
          Else Do
             ZERRSM = 'Table not created'
             ZERRLM = 'Unable to save a new' SAVTABL 'table in' CMDLIB ,
                      'dataset, rc='rc ', ALLOC rc='alloc_rc
             End
          ZERRALRM = 'YES'             /* alarm with the message    */
          "SETMSG MSG(ISRZ002)"        /* standard IBM message      */
          "TBOPEN XXXXX LIBRARY(XXX)"  /* this makes the FREE work  */
          Address TSO "FREE FI("cmdfile")"
          End
       End
       "TBEND CMTLIBS"
    Return

/*==================================================================*/
/*  Create a table of the ISPTLIB datasets                          */
/*  - ISPTLIB concatenation cannot be changed while ISPF is active  */
/*      therefore CMTLIBS table can be shared.                      */
/*  - these datasets are (almost) always cataloged, so SYSDSN can   */
/*      be used to check for the member, and LISTDSI to get volume  */
/*  - this is only called from CREATE_TABL and SAVE_TABL            */
/*------------------------------------------------------------------*/
CREATE_CMTLIBS:
    "TBCREATE CMTLIBS",             /* table of libraries in ISPTLIB */
       "NAMES(POINT,CMDLIB,VOLUME) SHARE NOWRITE"
    If rc = 0 Then Do                  /* new table created          */
       Call FIND_DSNLIST('ISPTLIB') /* get list of ISPTLIB libraries */
       Do d = 1 to Words(dsnlist)
          CMDLIB = Word(dsnlist,d)
          y = LISTDSI("'"CMDLIB"'")
          VOLUME = sysvolume
          If Sysdsn("'"CMDLIB"("SAVTABL")'") = 'OK' ,
             Then POINT = '-->'        /* pointer if member found    */
             Else POINT = ''
          "TBADD CMTLIBS"              /* populate the table         */
          End
       End
    Else Do                            /* table already existed      */
       "TBTOP CMTLIBS"
       Do d = 1 to 999
          "TBSKIP CMTLIBS"
          If rc > 0 Then Leave
          If Sysdsn("'"CMDLIB"("SAVTABL")'") = 'OK' ,
             Then POINT = '-->'        /* pointer if member found    */
             Else POINT = ''
          "TBPUT CMTLIBS"              /* update the table           */
          End
       End
    "TBTOP CMTLIBS"
    Return

/*==================================================================*/
/*  Update new User or Site command table                           */
/*  - update existing active table to have only the dummy cmd       */
/*  - refresh current table of commands                             */
/*  - this is only called from CREATE_TABL                          */
/*------------------------------------------------------------------*/
UPDATE_NEWTABL:
    "TBTOP" SAVTABL
    Do until RC > 0                          /* delete all the rows */
       "TBSKIP" SAVTABL "NOREAD"
       "TBDELETE" SAVTABL
       End
    "TBADD" SAVTABL                          /* add the dummy cmd   */
    If SAVTAB = 'USER' Then user_empty = 'NO'
    If SAVTAB = 'SITE' Then site_empty = 'NO'
    /*-----------------------------------*/
    /* refresh current table of commands */
    /*-----------------------------------*/
    If Left(CUR#SORT,1) ¬= 'R' Then /* if sort order not standard - */
       Call SORT_CMDSTABL('R')      /* sort back to original order  */
    "TBTOP" cmds_table
    Parse Var SAVTABL CMDTAB 'CMDS'
    "TBSCAN" cmds_table "ARGLIST(CMDTAB)"
    CMDOVER  = ''
    CMDFND   = ''
    CMDSEL   = '/'
    CMDALIAS = ''
    "TBGET" t_table                   /* get new row variables       */
    "TBPUT" cmds_table "ORDER"        /* dummy row replaces 1st row  */
    "TBSCAN" cmds_table "ARGLIST(CMDTAB) NOREAD"
    Do while rc = 0                   /* deleting rest of the rows   */
       "TBDELETE" cmds_table
       "TBSCAN" cmds_table "ARGLIST(CMDTAB) NOREAD"
       End
    updated = 'Y'                     /* so SETUP_OVER will be run   */
    /*--------------------------------------------------------------*/
    /* select (only) the new table upon return to the command list  */
    /*--------------------------------------------------------------*/
    CMDSCAN = ''
    CMDFIND = ''
    If SAVTAB = 'USER' Then Do
       T1 = ''
       T2 = '/'
       T3 = ''
       T4 = ''
       End
    If SAVTAB = 'SITE' Then Do
       T1 = ''
       T2 = ''
       If ZSCTSRCH = 'B'
          Then T3 = '/'
          Else T3 = ''
       If ZSCTSRCH = 'A'
          Then T4 = '/'
          Else T4 = ''
       End
    Return

/*==================================================================*/
/*  Read the specified keylist to look for certain PF keys.         */
/*  - looking for:  HELP, EXIT/END and CANCEL keys                  */
/*  - only check the first 12 keys, since they are always available */
/*------------------------------------------------------------------*/
CHECK_PFKEYS:
    Arg KEYLISTN                     /* usually = 'ISRSNAB'         */
    "TBTOP ISRPROF"
    "TBSCAN ISRPROF ARGLIST(KEYLISTN)"
    If rc <> 0 Then Do
       "TBTOP ISRKEYS"
       "TBSCAN ISRKEYS ARGLIST(KEYLISTN)"
       End
    If Translate(KEY1DEF) = 'HELP'   /* this is default for ISRSNAB */
       Then HE = 'F1'
       Else HE = ''
    Do key = 1 to 12 While HE = ''
       Interpret 'kdef = Translate(KEY'key'DEF)'
       If kdef = 'HELP'
          Then HE = 'F'key
       End
    If Translate(KEY3DEF) = 'EXIT'   /* this is default for ISRSNAB */
       Then EN = 'F3'
       Else EN = ''
    Do key = 1 to 12 While EN = ''
       Interpret 'kdef = Translate(KEY'key'DEF)'
       If kdef = 'EXIT' | kdef = 'END'
          Then EN = 'F'key
       End
    If Translate(KEY12DEF) = 'CANCEL'    /* the default for ISRSNAB */
       Then CA = 'F12'
       Else CA = ''
    Do key = 1 to 12 While CA = ''
       Interpret 'kdef = Translate(KEY'key'DEF)'
       If kdef = 'CAN'| kdef = 'CANCEL'
          Then CA = 'F'key
       End
    Return

/*==================================================================*/
/*  Read ISPF configuration module to get USERCMDS and SITECMDS     */
/*  - the values of ZUCTPREx & ZSCTPREx are assumed to be correct   */
/*     for any ACTIVE tables, (then config module is not checked).  */
/*  - offsets after ISPF 5.7 unknown, therefore in that case assume */
/*     the configuration module name and the field offsets are the  */
/*     same as in ISPF 5.7 (which will probably be true).           */
/*------------------------------------------------------------------*/
READ_CONFIG:
    "VGET ZPDFREL SHARED"                /* ISPF version 'PDF x.y'  */
    USERPREF = ZUCTPREF
    USR2PREF = ZUCTPRE2
    USR3PREF = ZUCTPRE3
    SITEPREF = ZSCTPREF
    SIT2PREF = ZSCTPRE2
    SIT3PREF = ZSCTPRE3
    Select
      When Word(ZPDFREL,2) < '4.2' Then Do
         CONFMOD = ''                    /* no User/Site tables     */
         End
      When Word(ZPDFREL,2) = '4.2' Then Do
         user_off = 564                  /* offset to USERCMDS parm */
         site_off = 572                  /* offset to SITECMDS parm */
         CONFMOD = 'ISRCONFG'
         End
      When Word(ZPDFREL,2) < '4.8' Then Do        /* 4.3, 4.4 & 4.5 */
         user_off = 572
         site_off = 580
         CONFMOD = 'ISRCONFG'
         End
      When Word(ZPDFREL,2) <= '5.2' Then Do       /* 4.8, 5.0 & 5.2 */
         user_off = 636
         site_off = 640
         CONFMOD = 'ISPCFIGU'
         End
      Otherwise                                   /* 5.5, 5.6 & 5.7 */
         user_off = 636
         site_off = 640
         usr2_off = 2888
         usr3_off = 2892
         sit2_off = 2896
         sit3_off = 2900
         CONFMOD = 'ISPCFIG'
      End
    If CONFMOD ¬= '' Then Do
       pgm_addr = ISPFCMDL(CONFMOD)      /* get pgm load address    */
       dec_addr = X2D(C2X(pgm_addr))
       If dec_addr > 0 Then Do           /* if program is loaded .. */
          USERPRE1 = Storage( D2X(dec_addr + user_off), 4)
          SITEPRE1 = Storage( D2X(dec_addr + site_off), 4)
          If Word(ZPDFREL,2) < '5.5' Then
             Parse Value '' With USERPRE2 USERPRE3 SITEPRE2 SITEPRE3
          Else Do        /* extra cmd tables possible from ISPF 5.5 */
             USERPRE2 = Storage( D2X(dec_addr + usr2_off), 4)
             USERPRE3 = Storage( D2X(dec_addr + usr3_off), 4)
             SITEPRE2 = Storage( D2X(dec_addr + sit2_off), 4)
             SITEPRE3 = Storage( D2X(dec_addr + sit3_off), 4)
             End
          If USERPRE1 ¬= '' & USERPREF = '' Then
             USERPREF = CMD_PREF(USERPRE1)
          If USERPRE2 ¬= '' & USR2PREF = '' Then
             USR2PREF = CMD_PREF(USERPRE2)
          If USERPRE3 ¬= '' & USR3PREF = '' Then
             USR3PREF = CMD_PREF(USERPRE3)
          If SITEPRE1 ¬= '' & SITEPREF = '' Then
             SITEPREF = CMD_PREF(SITEPRE1)
          If SITEPRE2 ¬= '' & SIT2PREF = '' Then
             SIT2PREF = CMD_PREF(SITEPRE2)
          If SITEPRE3 ¬= '' & SIT3PREF = '' Then
             SIT3PREF = CMD_PREF(SITEPRE3)
          End
       End
    Return

/*==================================================================*/
/*  Resolve actual value of command table prefix.                   */
/*  - check that prefix conforms to naming conventions              */
/*  - ISPF 5.7 introduced the option of masks in these fields to    */
/*    create a prefix from the MVS system name.                     */
/*  - this invoked only by READ_CONFIG                              */
/*------------------------------------------------------------------*/
CMD_PREF:
    Arg prefix
    prefix = Strip(prefix,'T')
    Select
      When Word(ZPDFREL,2) <= '5.6' Then
         resolved_prefix = prefix
      When Left(prefix,1) ¬= '*' Then
         resolved_prefix = prefix
      Otherwise
        "VGET ZSYSID"                 /* current MVS system name */
        Select
          When prefix = '*' Then
             resolved_prefix = Left(zsysid,4)
          When Length(prefix) = 2 Then Do     /* format:  *m     */
             m = Substr(prefix,2)
             If Verify(m,'12345678') = 0 Then /* value of m is valid */
                resolved_prefix = Left(Substr(zsysid,m),4)
             Else  /* value of m is invalid */
                resolved_prefix = '????'
             End
          Otherwise                           /* format:  *m:n   */
             m = Substr(prefix,2,1)
             n = Substr(prefix,4,1)
             resolved_prefix = '????'    /* m &/or n is invalid  */
             If Verify(m,'12345678') = 0 ,
             &  Verify(n,'12345678') = 0 Then Do
                If  m <= n & n - m <= 3 Then  /* m & n are valid */
                   resolved_prefix = Left(Substr(zsysid,m,1+n-m),4)
                End
          End
      End
    valid_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@$#'
    If Verify(Strip(resolved_prefix,'T'),valid_chars) > 0,
     | Pos(Left(resolved_prefix,1),'0123456789') > 0 Then
       resolved_prefix = ''      /* configured prefix is invalid */
    Return Strip(resolved_prefix)

/*========================  That's all folks  ========================*/

