 /*                            S T R O B E                         */
 /*                                                                */
 /**++**++**++**++**++**++**++**++**++**++**++**++**++**++**++**++**/
 /*                                                                */
 /*      PDSDOC *STROBE2 - ENHANCED SMF SNAPSHOT PROGRAM.............*/ STROBE
 /*                                                                */
 /*                                                                */
 /*  STROBE                                                        */
 /*  ------                                                        */
 /*                                                                */
 /*  THIS PROGRAM TAKES SNAPSHOTS OF SMF OR OTHER DATA, AND SHOWS  */
 /*  SNAPSHOTS OF WHAT IS HAPPENING AT ANY PARTICULAR TIME, GIVING */
 /*  A PICTORIAL IMAGE OF MULTI-PROGRAMMING LEVELS ETC..           */
 /*  ORIGINALLY WRITTEN BY THE GREAT PETE FAYERS.                  */
 /*                                                                */
 /*                                                                */
 /* 21JUL00 CART1 CHANGE LINES PER PAGE FOR A4 PAPER.              */
 /*  THIS PROGRAM WILL COMPILE WITH PL1/F FROM CBT FILE 092 BUT    */
 /*  NEEDS OTHER SUB-ROUTINES. APPLY TO DAVE CARTWRIGHT FOR THESE. */
 /*                                                                */
 /* 14APR93 CART1 ADDED COUNT DISPLAY, TMON TIME PROCESSING AND    */
 /*               DUPLICATE NAME MERGING.                          */
 /*                                                                */
 /*                                                                */
 /******************************************************************/
 /*                                                                */
 /*  FILES                                                         */
 /*  -----                                                         */
 /*                                                                */
 /*  SYSUT1 - THE INPUT SMF DATA FILE. FORMAT WILL BE DEFINED      */
 /*           IN THE SYSLIN CONTROL CARD SET. THIS FILE MUST BE    */
 /*           IN ASCENDING SEQUENCE OF START-TIME. MAXIMUM LOGICAL */
 /*           RECORD LENGTH IS 32K  BYTES.                         */
 /*                                                                */
 /*  PRINT  - THE REPORT FROM THE PROGRAM. WILL CONTAIN, ON EACH   */
 /*           LINE, THE TIME OF THE SNAPSHOT, AND THEN A LIST      */
 /*           OF THE THINGS HAPPENING AT THAT TIME. REQUIRED DCB   */
 /*           IS RECFM=FBA,BLKSIZE=133.                            */
 /*                                                                */
 /*  SYSLIN - THE CONTROL CARD SET, DEFINING THE FORMAT OF THE     */
 /*           SMF RECORDS TO BE PROCESSED.                         */
 /*           THIS FILE CONTAINS CARD IMAGES, WITH FREE-FORMAT     */
 /*           KEYWORD PARAMETERS ACROSS EACH CARD.                 */
 /*           THESE KEYWORD PARAMETERS MUST BE SEPARATED BY AT     */
 /*           LEAST ONE SPACE, AND MUST NOT THEMSELVES CONTAIN     */
 /*           SPACES, EXCEPT IN QUOTED LITERALS.                   */
 /*  M/O      MANDATORY/OPTIONAL KEYWORDS ARE:                     */
 /*                                                                */
 /*  O        RECORDID=(PPP,LL,'LIT')   RECORD SELECTION CRITERIA  */
 /*  O        TITLE='REPORT TITLE'      REPORT TITLE               */
 /*  M        STARTTIME=PPP             POSITION OF START TIME     */
 /*  O-OR-    ENDTIME=PPP               POSITION OF END TIME       */
 /*   -OR-O   DURATION=PPP              POSITION OF DURATION FIELD */
 /*  M        NAME=(PPP,LL)             POSN & LEN OF NAME FIELD   */
 /*  O        RESIDENCY=NNNNN           RESIDENCY ALLOWANCE 100*SEC*/
 /*  M        STARTDATE=PPP             POSITION OF START DATE     */
 /*  O        ENDDATE=PPP               POSITION OF END DATE       */
 /*  M        TIMEFORMAT=XXXXXX         FORMAT OF TIME FIELD       */
 /*  M        DATEFORMAT=XXXXXX         FORMAT OF DATE FIELD       */
 /*  O        EXIT=XXXXXXXX             NAME OF USER EXIT          */
 /*  O        MAXOFLOW=NN               MAXIMUM PERMITTED OVERFLOWS*/
 /*  O        COLUMNS=(XXXX,XXXX,.......,XXXX)                       */
 /*                                    PRE-SELECTED COLUMN NAMES;    */
 /*                                    ALL OTHERS GO TO OVERFLOW.    */
 /*                                                                */
 /*           PERMITTED ABBREVIATIONS FOR THESE KEYWORDS ARE:      */
 /*                                                                */
 /*           RECORDID=   :  ID=        TITLE=       :  TL=        */
 /*           STARTTIME=  :  ST=        ENDTIME=     :  ET=        */
 /*           DURATION=   :  DR=        NAME=        :  NM=        */
 /*           STARTDATE=  :  SD=        EXIT=        :  EX=        */
 /*           ENDDATE=    :  ED=        TIMEFORMAT=  :  TF=        */
 /*           DATEFORMAT= :  DF=        MAXOFL=      :  MO=        */
 /*           COLUMNS=    :  CL=        RESIDENCY=   :  RES=         */
 /*                                                                */
 /*      CURRENTLY SUPPORTED DATE FORMATS ARE:                     */
 /*                                                                */
 /*      YYDDDP   - JULIAN DATE IN 3-BYTE PACKED DECIMAL FIELD     */
 /*      YYMMDD   - 6-BYTE DISPLAY NUMERIC FIELD                   */
 /*                                                                */
 /*                                                                */
 /*      CURRENTLY SUPPORTED TIME FORMATS ARE:                     */
 /*                                                                */
 /*      HUNSEC   - TIME IN HUNDREDTHS OF SECOND IN 4-BYTE BINARY  */
 /*      TM64MS   - TIME IN 64 MICROSECONDS FROM TMON CICS         */
 /*      PAKMIN   - TIME IN HUNDREDTHS OF MINUTE IN 4-BYTE PACKED  */
 /*      HHMMPS   - START TIME IN 4-BYTE DISPLAY NUMERIC,          */
 /*                 DURATION IN 3-BYTE PACKED DECIMAL IN SECONDS   */
 /*                                                                */
1/*  SYSIN   - CONTROL CARD SET OF THE CRITERIA FOR THE TIMING     */
 /*            OF THE SNAPSHOTS. ONE OR MORE CARDS CONTAINING      */
 /*            KEYWORD PARAMETERS, EACH SEPARATED BY AT LEAST      */
 /*            ONE BLANK. OPTIONALLY THIS DATA SET MAY BE REPLACED */
 /*            BY A SINGLE EXECUTION-TIME PARAMETER CONTAINING     */
 /*            THE REQUIRED KEYWORDS. IF BOTH THE SYSIN DATA SET   */
 /*            AND THE EXECUTION TIME PARAMETER ARE ENTERED, THE   */
 /*            SYSIN FILE WILL BE IGNORED.                         */
 /*                                                                */
 /*            REQUIRED KEYWORDS ARE:                              */
 /*            SNAPSTART=YYDDDHHMM     /     SS=YYDDDHHMM          */
 /*            SNAPEND=YYDDDHHMM       /     SE=YYDDDHHMM          */
 /*            INTERVAL=(XX,NN)        /     IV=(XX,NN)            */
 /*            (IN THIS LAST ONE, XX IS INTERVAL TYPE MM, SS ETC)  */
 /*            OPTIONALLY, SS=SS MEANS START AT START OF FILE      */
 /*                        SE=SE MEANS END SNAPSHOT AT EOF.        */
 /*                                                                */
 /*            OPTIONAL KEYWORD:                                   */
 /*            BLANK=NO                /     BL=NO                 */
 /*            (WILL SUPPRESS PRINTING SNAPS WHERE NOTHING HAPPENS)*/
 /*                                                                */
 /**++**++**++**++**++**++**++**++**++**++**++**++**++**++**++**++**/
1STROBE2: PROC(PARAM) OPTIONS(MAIN);
0/********************************************************************/
 /*                                                                  */
 /*      FILES: SYSUT1 = CMF DATA RECORDS                            */
 /*             SYSLIN = UNPACKING CRITERIA FOR SYSUT1               */
 /*             SYSIN  = TIMING CRITERIA FOR SNAPSHOTS               */
 /*             PRINT  = OUTPUT REPORT                               */
 /*                                                                  */
 /*            (PARAM) = OPTIONAL PARAMETER TO REPLACE SYSIN FILE    */
 /*                                                                  */
 /*      DECLARES ARE FOR: THE FILES THEMSELVES                      */
 /*                        THE RECORD AREAS (EXCEPT PRINT)           */
 /*                        END-OF-FILE FLAGS                         */
 /*                        AREA FOR USER EXIT NAME                   */
 /*                        POINTERS FOR USER EXIT & SYSUT1 RECORD    */
 /*                                                                  */
 /*      ENDFILE CONDITIONS FOR THE THREE INPUT FILES ARE SET.       */
 /*                                                                  */
 /********************************************************************/
-        DCL
         SYSUT1 FILE RECORD SEQUENTIAL,
         SYSLIN FILE RECORD SEQUENTIAL,
         SYSIN  FILE RECORD SEQUENTIAL,
         PRINT  FILE RECORD SEQUENTIAL;
0        DCL
         PARAM CHAR(4096) VARYING;
0        DCL
         SYSLIN_RECORD CHAR(80);
0        DCL
         SYSIN_RECORD CHAR(80);
0        DCL
         SYSUT1_RECORD CHAR(32760) VARYING;
0        DCL
         EOF_SYSLIN CHAR(2) INIT('NO'),
         EOF_SYSUT1 CHAR(2) INIT('NO'),
         EOF_SYSIN  CHAR(2) INIT('NO');
         DCL
         EXIT_NAME CHAR(8) INIT(' '),
         EXIT_PTR1 FIXED(15) BASED(EXIT_P1),
         EXIT_PTR2 FIXED(15) BASED(EXIT_P2);
         EXIT_P1 = ADDR(EXIT_NAME);
         EXIT_P2 = ADDR(SYSUT1_RECORD);
-        ON ENDFILE(SYSLIN) EOF_SYSLIN = 'YS';
         ON ENDFILE(SYSUT1) EOF_SYSUT1 = 'YS';
         ON ENDFILE(SYSIN)  EOF_SYSIN  = 'YS';
1/********************************************************************/
 /*                                                                  */
 /*      THE TWO MAJOR ARRAYS FOR THE PROGRAM DATA, THE PRINT        */
 /*      ARRAY AND THE OVERFLOW ARRAY. AS EACH RECORD IS PROCESSED,  */
 /*      IT WILL BE LOADED INTO ONE OF THESE ARRAYS IF THE TIMES     */
 /*      (START AND END) STRADDLE THE 'CURRENT SNAPSHOT TIME'        */
 /*      HELD INTERNALLY.                                            */
 /*                                                                  */
 /*      ALSO A SWITCH THAT WILL BE SET BY SCANNING THE PRINT        */
 /*      ARRAY, TO TEST IF ALL THE NAMES HELD IN THE ARRAY ARE       */
 /*      BLANK. VALID SETTINGS ARE 'YES' AND 'NO '. THE SWITCH       */
 /*      IS SET AND TESTED AFTER END OF FILE IS REACHED ON SYSUT1,   */
 /*      TO CLEAR OUT RESIDUAL STORE ELEMENTS. ALL SETTINGS AND      */
 /*      TESTINGS ARE IN THE LAST DOZEN OR SO LINES OF $PSUT1.       */
 /*                                                                  */
 /*      ARRAY & INDICATOR USED FOR COLUMNAR PROCESSING.             */
 /*      ARRAY OF COLUMN NAMES, & A SWITCH ('YES' OR 'NO ') SET      */
 /*      DEPENDING ON THE ABSENCE OF THE SYSLIN KEYWORD.             */
 /*                                                                  */
 /********************************************************************/
-        DCL
         1 PRINT_ARRAY BASED(PA_PTR),
           3 LEN_PRINT_ARRAY,
           3 ARRAY_PRINT(MAX_PRINT REFER(LEN_PRINT_ARRAY)),
             5 PRAR_NAME CHAR(44),
             5 PRAR_RECEND   FIXED(15,4);
-        DCL
         1 OVERFLOW_ARRAY BASED(OF_PTR),
           3 LEN_OFLOW_ARRAY,
           3 ARRAY_OFLOW(MAX_OFLOW REFER(LEN_OFLOW_ARRAY)),
             5 OFAR_NAME CHAR(44),
             5 OFAR_RECEND   FIXED(15,4);
-        DCL
         ALL_NAMES_BLANK CHAR(3) INIT('YES');
-        DCL
         1 COLUMNAR_ARRAY BASED(CL_PTR),
           3 LEN_COLMN_ARRAY,
           3 ARRAY_COLMN(MAX_COLMN REFER(LEN_COLMN_ARRAY)),
             5 COLN_NAME CHAR(44);
0        DCL
         COLUMNAR CHAR(3) INIT('NO ');
1/********************************************************************/
 /*                                                                  */
 /*      VARIOUS FIELDS USED IN EDITING THE CONTROL PARAMETERS,      */
 /*      WHETHER FROM SYSIN, SYSLIN, OR PARAMETER.                   */
 /*      ALL THE RECORDS FROM EITHER FILE ARE STRUNG OUT IN ONE      */
 /*      CHARACTER STRING AND UNPACKED FROM THERE, ALTERNATING       */
 /*      THE KEYWORD FIELD BETWEEN DATA- AND EDITSTRING.             */
 /*                                                                  */
 /*      DURING UNPACKING THE KEYWORDS, AN ERROR FLAG IS USED        */
 /*      IF ANY MANDATORY KEYWORD IS MISSING, AND THE END-DUR FLAG   */
 /*      IS USED FOR THE CONDITION THAT EITHER THE 'ENDTIME' OR      */
 /*      THE 'DURATION' PARAMETER MUST BE PRESENT.                   */
 /*                                                                  */
 /*      THE CONTROL BLOCKS THEMSELVES ARE THEN DECLARED,            */
 /*      THOSE PREFIXED 'CTL_' ARE TO HOLD THE INFO UNPACKED         */
 /*      FROM THE SYSLIN DATA SET, THE OTHERS (SNAPSTART, SNAPEND    */
 /*      INTERVAL) FOR THE INFO FROM SYSIN/PARAMETER. IVTYP AND      */
 /*      IVVAL ARE INTERMEDIATE FIELD FOR UINPACKING THE INTERVAL    */
 /*      NOBLANK SET IF BLANK=NO PARAMETER FOUND                     */
 /*                                                                  */
 /********************************************************************/
-        DCL
         EDITSTRING CHAR(4096) VARYING,
         DATASTRING CHAR(4096) VARYING;
0        DCL
         ERROR_FLAG CHAR(1) INIT(' '),
         END_DUR_FLAG CHAR(2) INIT('NO');
0        DCL
         CTL_IDP FIXED BIN(31) INIT(0) STATIC,
         CTL_IDL FIXED BIN(31) INIT(0) STATIC,
         CTL_IDX CHAR(80) VARYING,
         CTL_ST  FIXED BIN(31) INIT(0) STATIC,
         CTL_ET  FIXED BIN(31) INIT(0) STATIC,
         CTL_DR  FIXED BIN(31) INIT(0) STATIC,
         CTL_NMP FIXED BIN(31) INIT(0) STATIC,
         CTL_NML FIXED BIN(31) INIT(0) STATIC,
         CTL_RES FIXED BIN(31) INIT(0) STATIC,
         CTL_SD  FIXED BIN(31) INIT(0) STATIC,
         CTL_ED  FIXED BIN(31) INIT(0) STATIC,
         CTL_TF  CHAR(8),
         CTL_DF  CHAR(8),
         CTL_MO  FIXED BIN(31) INIT(20);
0        DCL
         SNAPSTART FIXED(15,4),
         SNAPEND   FIXED(15,4),
         INTERVAL  FIXED(15,4),
         IVTYP     CHAR(2),
         IVVAL     FIXED(3),
         NOBLANK   CHAR(3);
1/********************************************************************/
 /*                                                                  */
 /*      MISCELLANEOUS SUBSCRIPTS I,J,K,L. THESE, IN ACCORDANCE      */
 /*      WITH THE PRINCIPLES OF STRUCTURED PROGRAMMING, WILL ONLY    */
 /*      BE USED LOCALLY, WILL NEVER BE PASSED BETWEEN PROCS AS      */
 /*      CONTROL INFORMATION, AND WILL ALWAYS BE STARTED ANEW WITH   */
 /*      EACH INVOCATION OF THE PROC IN WHICH THEY ARE USED.         */
 /*                                                                  */
 /*      THEN, OVERLAYED CONTROL FORMATS FOR USE IN UNPACKING        */
 /*      VARIOUS FIELD FORMATS FROM THE SYSUT1 FILE. IN EACH OF      */
 /*      THE THREE, A CHARACTER STRING IS OVERLAYED RESPECTIVELY     */
 /*      WITH A DISPLAY DECIMAL, A PACKED DECIMAL, & A BINARY FIELD. */
 /*      THE DISPLAY DECIMAL FIELD IS DUPLICATED FOR 4 OR 5 DECIMALS */
 /*                                                                  */
 /*      THEN, THE TIME-CONTROLS OF THE PROGRAM. RECSTART AND RECEND */
 /*      HOLD THE START AND END TIME OF THE SYSUT1 RECORD CURRENTLY  */
 /*      BEING PROCESSED (FORMATS YYDDDHHMMSS.SSSS, FIXED(15,4)),    */
 /*      AND NOWTIME HOLDS THE TIME (SAME FORMAT) OF THE CURRENT     */
 /*      SNAPSHOT.                                                   */
 /*                                                                  */
 /********************************************************************/
-        DCL
         I FIXED BIN(31) STATIC,
         J FIXED BIN(31) STATIC,
         K FIXED BIN(31) STATIC,
         L FIXED BIN(31) STATIC;
0        DCL
         AREC CHAR(15) ALIGNED,
         NREC PIC'9999999999V99999' DEF AREC,
         NREX PIC'99999999999V9999' DEF AREC;
0        DCL
         APAK CHAR(8) ALIGNED,
         NPAK FIXED(15) DEF APAK;
0        DCL
         ABIN CHAR(4) ALIGNED,
         NBIN FIXED BIN(31) DEF ABIN;
0        DCL
         RECSTART FIXED(15,4) INIT(0) STATIC,
         RECEND   FIXED(15,4) INIT(0) STATIC,
         NOWTIME  FIXED(15,4) INIT(0) STATIC,
         COUNT    FIXED(15,4) INIT(0) STATIC;
1/********************************************************************/
 /*                                                                  */
 /*      HERE WE DECLARE THE EXTERNAL ROUTINE $ADINV. THIS ROUTINE   */
 /*      TAKES TWO FULL-WORD PACKED DECIMAL NUMBERS, THE FIRST       */
 /*      HOLDING A DATE, THE SECOND A TIME INTERVAL, BOTH IN THE     */
 /*      FORMAT YYDDDHHMMSS.SSSS, AND ADDS THE SECOND TO THE         */
 /*      FIRST, RATIONALISING THE RESULT TO THE REAL DATE/TIME.      */
 /*                                                                  */
 /*      SEE MODULE $ADINV - IS00D LIBRARY.                          */
 /*                                                                  */
 /*      ALSO A FIXED DECIMAL ZERO FIELD FOR USE WHEN CALLING        */
 /*      $ADINV TO RATIONALISE A SET DATE/TIME.                      */
 /*                                                                  */
 /********************************************************************/
-        DCL
         $ADINV ENTRY(FIXED DEC(15,4), FIXED DEC(15,4));
-        DCL
         ZERODEC FIXED(15,4) INIT(0) STATIC;
1/********************************************************************/
 /*                                                                  */
 /*      REPORT AREAS - HEADING LINES, DETAIL LINE, PAGE COUNT, ETC. */
 /*                                                                  */
 /********************************************************************/
-        DCL
         1 HEADA,
           3 HA_FILA CHAR(20) INIT('1'),
           3 HA_TITL CHAR(80) INIT(' '),
           3 HA_DATE CHAR(9),
           3 HA_FILB CHAR(11) INIT('      PAGE '),
           3 HA_PAGE PIC'ZZZ9',
           3 HA_FILC CHAR(9) INIT(' ');
-        DCL
         1 HEADB,
           3 HB_FILA CHAR(17) INIT('0YY.DDD HH.MM.SS '),
           3 HB_FILB CHAR(4) INIT('NUM.'),
           3 HB_FILC CHAR(102) INIT(' '),
           3 HB_FILD CHAR(10) INIT('OVERFLOW-*');
-        DCL
         1 LINEA,
           3 LA_CBYT CHAR(1),
           3 LA_TIME PIC'99.999B99.99.99',
           3 LA_FIL1 CHAR(1) INIT(' '),
           3 LA_COUNT PIC'999',
           3 LA_FIL2 CHAR(1) INIT(' '),
           3 LA_SNAP CHAR(112);
-        DCL
         PAGENO FIXED(5) INIT(0) STATIC,
         LINECT FIXED(3) INIT(99);
-        DCL
         1 UT458_AREA,
           3 UT458_OPCODE CHAR(1),
           3 UT458_MMDDYY CHAR(6),
           3 UT458_DDMMYY CHAR(6),
           3 UT458_YYMMDD CHAR(6),
           3 UT458_DWWYY  CHAR(5),
           3 UT458_YYWWD  CHAR(5),
           3 UT458_YYDDD  PIC'99999',
           3 UT458_REPORT CHAR(9),
           3 UT458_FILLA  CHAR(42),
           3 UT458_RETCOD CHAR(1);
         DCL
         UT458_NAME CHAR(8) INIT('UT458   ');
         DCL
         UT458_PTR1 FIXED(15) BASED(UT458_P1),
         UT458_PTR2 FIXED(15) BASED(UT458_P2);
         UT458_P1 = ADDR(UT458_NAME);
         UT458_P2 = ADDR(UT458_AREA);
         CALL DYNAML(UT458_PTR1);
         UT458_OPCODE = '0';
         CALL DYNAMO(UT458_PTR1,UT458_PTR2);
         HA_DATE = UT458_REPORT;
1/*********************************************************************/
 /*                                                                   */
 /*          MM        MM     AAAAAAAA     IIII    NN     NN          */
 /*          MMM      MMM    AAAAAAAAAA    IIII    NNN    NN          */
 /*          MMMM    MMMM    AA      AA     II     NNNN   NN          */
 /*          MM MM  MM MM    AAAAAAAAAA     II     NN NN  NN          */
 /*          MM  MMMM  MM    AAAAAAAAAA     II     NN  NN NN          */
 /*          MM   MM   MM    AA      AA     II     NN   NNNN          */
 /*          MM        MM    AA      AA    IIII    NN    NNN          */
 /*          MM        MM    AA      AA    IIII    NN     NN          */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                  */
 /*      MAIN-STREAM PROCESSING:                                     */
 /*                                                                  */
 /*            UNPACK THE SYSLIN DATA SET                            */
 /*            ACCESS THE PARAMETER                                  */
 /*            IF THE PARAMETER EXISTS, THEN UNPACK IT               */
 /*            OTHERWISE UNPACK THE SYSIN DATA SET                   */
 /*            ALLOCATE AND ZEROIFY THE PRINT AND OVERFLOW ARRAYS    */
 /*            PROCESS THE SYSUT1 FILE OF SMF DATA                   */
 /*                                                                  */
 /********************************************************************/
-        CALL $USLIN;
-        L = LENGTH(PARAM);
         IF L ¬= 0
            THEN DATASTRING = PARAM;
            ELSE CALL $USYSN;
         CALL $USTRNG;
-        MAX_PRINT = 112 / (CTL_NML + 2);
         MAX_OFLOW = CTL_MO;
0        ALLOCATE PRINT_ARRAY;
         ALLOCATE OVERFLOW_ARRAY;
0        PRAR_NAME = ' ';
         PRAR_RECEND   = 0;
         OFAR_NAME = ' ';
         OFAR_RECEND   = 0;
-        CALL $PSUT1;
1/*********************************************************************/
 /*                                                                   */
 /*    UU      UU     SSSSSSSS     LL            IIII    NN     NN    */
 /*    UU      UU    SSSSSSSSSS    LL            IIII    NNN    NN    */
 /*    UU      UU    SS            LL             II     NNNN   NN    */
 /*    UU      UU    SSSSSSSSS     LL             II     NN NN  NN    */
 /*    UU      UU     SSSSSSSSS    LL             II     NN  NN NN    */
 /*    UU      UU            SS    LL             II     NN   NNNN    */
 /*    UUUUUUUUUU    SSSSSSSSSS    LLLLLLLLLL    IIII    NN    NNN    */
 /*     UUUUUUUU      SSSSSSSS     LLLLLLLLLL    IIII    NN     NN    */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $USLIN.                                           */
 /*                                                                  */
 /*           THIS PROCEDURE UNPACKS THE SYSLIN CONTROL CARD SET     */
 /*            INTO THE RELEVANT CONTROL BLOCKS. FIRSTLY, ALL        */
 /*            THE RECORDS FROM THE FILE ARE STRUNG OUT INTO ONE     */
 /*            LONG CHARACTER STRING, WHICH IS LATER ACCESSED        */
 /*            IN SEARCH OF EACH INDIVIDUAL KEYWORD PARAMETER.       */
 /*                                                                  */
 /********************************************************************/
-$USLIN: PROC;
0        DATASTRING = '';
0        READ FILE(SYSLIN) INTO(SYSLIN_RECORD);
0        DO WHILE(EOF_SYSLIN = 'NO');
            DATASTRING = DATASTRING || SYSLIN_RECORD;
            READ FILE(SYSLIN) INTO(SYSLIN_RECORD);
         END;
-/********************************************************************/
 /*                                                                  */
 /*      AT THIS POINT, THE CHARACTER STRING 'DATASTRING' CONTAINS   */
 /*      ALL THE RECORDS FROM SYSUT1, CONCATENATED.                  */
 /*      WE CAN NOW COMMENCE UNPACKING.                              */
 /*                                                                  */
 /********************************************************************/
1/********************************************************************/
 /*                                                                  */
 /*      SCAN FOR RECORDID; IF THERE, UNPACK POSITION, LENGTH AND    */
 /*      LITERAL TO THE CONTROL BLOCKS. IF NOT, SET THESE TO ZERO    */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'RECORDID=');
         J = INDEX(DATASTRING,'ID=');
0        IF I = 0 & J = 0
0        THEN DO;
                 CTL_IDP = 0;
                 CTL_IDL = 0;
                 CTL_IDX = '';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 4;
                 ELSE K = I + 10;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,',');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_IDP = NREC;
0                EDITSTRING = SUBSTR(EDITSTRING,I+1,4096-I);
                 I = INDEX(EDITSTRING,',');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_IDL = NREC;
0                EDITSTRING = SUBSTR(EDITSTRING,I+2,4095-I);
                 I = INDEX(EDITSTRING,'''');
                 CTL_IDX = SUBSTR(EDITSTRING,1,I-1);
              END;
1/********************************************************************/
 /*                                                                  */
 /*      SCAN FOR THE REPORT TITLE, INSERTING IT INTO THE HEADING    */
 /*      LINE IF FOUND, BLANKING OUT IF NOT.                         */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'TITLE=');
         J = INDEX(DATASTRING,'TL=');
0        IF I = 0 & J = 0
         THEN HA_TITL = ' ';
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 4;
                 ELSE K = I + 7;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,'''');
                 HA_TITL = SUBSTR(EDITSTRING,1,I-1);
              END;
-/********************************************************************/
 /*                                                                  */
 /*      SCAN FOR RECORD START TIME POSITION. LOAD CB IF THERE,      */
 /*      PRINT ERROR MESSAGE AND SET FLAG IF NOT                     */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'STARTTIME=');
         J = INDEX(DATASTRING,'ST=');
0        IF I = 0 & J = 0
0        THEN DO;
                 PUT SKIP EDIT('NO START TIME PARAMETER FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 10;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_ST = NREC;
              END;
1/********************************************************************/
 /*                                                                  */
 /*      GET ENDTIME; IF NOT THERE, NO ERROR YET. IF THERE, SET      */
 /*      END-DUR FLAG FOR LATER TESTING THAT ONE OF THE TWO THERE    */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'ENDTIME=');
         J = INDEX(DATASTRING,'ET=');
0        IF I = 0 & J = 0
         THEN DO;
              END;
0        ELSE DO;
                 END_DUR_FLAG = 'YS';
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 8;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_ET = NREC;
              END;
-/********************************************************************/
 /*                                                                  */
 /*    GET DURATION PARAMETER; SET END-DUR FLAG IF THERE (SEE ABOVE) */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'DURATION=');
         J = INDEX(DATASTRING,'DR=');
0        IF I = 0 & J = 0
         THEN DO;
              END;
0        ELSE DO;
                 END_DUR_FLAG= 'YS';
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 9;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_DR = NREC;
              END;
1/********************************************************************/
 /*                                                                  */
 /*    UNPACK NAME POSITION AND LENGTH. SET ERROR FLAG IF NOT THERE  */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'NAME=');
         J = INDEX(DATASTRING,'NM=');
0        IF I = 0 & J = 0
         THEN DO;
                 PUT SKIP EDIT('NO NAME PARAMETER FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 4;
                 ELSE K = I + 6;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,',');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_NMP = NREC;
0                EDITSTRING = SUBSTR(EDITSTRING,I+1,4096-I);
                 I = INDEX(EDITSTRING,')');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_NML = NREC;
              END;
1/********************************************************************/
 /*                                                                  */
 /*      UNPACK POSITION PARAMETERS OF START AND END DATE FIELDS     */
 /*      IF EITHER NOT FOUND, SET ERROR FLAG FOR LATER DUMPING       */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'STARTDATE=');
         J = INDEX(DATASTRING,'SD=');
0        IF I = 0 & J = 0
         THEN DO;
                 PUT SKIP EDIT('START DATE PARAMETER NOT FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 10;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_SD = NREC;
              END;
-        I = INDEX(DATASTRING,'ENDDATE=');
         J = INDEX(DATASTRING,'ED=');
0        IF I = 0 & J = 0
         THEN DO;
                 CTL_ED = CTL_SD;
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 8;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_ED = NREC;
              END;
1/********************************************************************/
 /*                                                                  */
 /*    UNPACK TIME AND DATE FORMATS FROM THE FILE. IF EITHER IS      */
 /*      MISSING, SET THE ERROR FLAG                                 */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'TIMEFORMAT=');
         J = INDEX(DATASTRING,'TF=');
0        IF I = 0 & J = 0
         THEN DO;
                 PUT SKIP EDIT('TIME FORMAT PARAMETER NOT FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 11;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 CTL_TF = SUBSTR(EDITSTRING,1,I-1);
              END;
-        I = INDEX(DATASTRING,'DATEFORMAT=');
         J = INDEX(DATASTRING,'DF=');
0        IF I = 0 & J = 0
         THEN DO;
                 PUT SKIP EDIT('DATE FORMAT PARAMETER NOT FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 11;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 CTL_DF = SUBSTR(EDITSTRING,1,I-1);
              END;
1        I = INDEX(DATASTRING,'EXIT=');
         J = INDEX(DATASTRING,'EX=');
         IF I = 0 & J = 0
         THEN EXIT_NAME = ' ';
         ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 5;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 EXIT_NAME = SUBSTR(EDITSTRING,1,I-1);
                 CALL DYNAML(EXIT_PTR1);
              END;
1/********************************************************************/
 /*                                                                  */
 /*      UNPACK OVERFLOW MAXIMUM; IF NOT PRESENT, DEFAULT TO 20.     */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'MAXOFLOW=');
         J = INDEX(DATASTRING,'MO=');
0        IF I = 0 & J = 0
0        THEN CTL_MO = 20;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 9;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_MO = NREC;
              END;
1/********************************************************************/
 /*                                                                  */
 /*      UNPACK ADDITIONAL RESIDENCY, IF PRESENT (ONLY FOR TMON)     */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'RESIDENCY=');
         J = INDEX(DATASTRING,'RES=');
0        IF I = 0 & J = 0
0        THEN CTL_RES = 0;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 4;
                 ELSE K = I + 11;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,' ');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 CTL_RES = NREC;
              END;
-/********************************************************************/
 /*                                                                  */
 /*      UNPACK COLUMN NAMES; IF NOT THERE, SET COLUMNAR SWITCH OFF  */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'COLUMNS=');
         J = INDEX(DATASTRING,'CL=');
0        IF I = 0 & J = 0
0        THEN COLUMNAR = 'NO ';
0        ELSE DO;
                 COLUMNAR = 'YES';
                 IF I = 0
                 THEN K = J + 4;
                 ELSE K = I + 9;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 MAX_COLMN = 1;
                 I = INDEX(EDITSTRING,',');
                 IF I = 0 THEN I = 4099;
                 J = INDEX(EDITSTRING,')');
                 IF J = 0 THEN J = 4099;
                 DO WHILE(I<J);
                    MAX_COLMN = MAX_COLMN + 1;
                    EDITSTRING = SUBSTR(EDITSTRING,I+1,4096-I);
                    I = INDEX(EDITSTRING,',');
                    IF I = 0 THEN I = 4099;
                 END;
                 ALLOCATE COLUMNAR_ARRAY;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 DO I = 1 TO (MAX_COLMN - 1);
                    J = INDEX(EDITSTRING,',');
                    COLN_NAME(I) = SUBSTR(EDITSTRING,1,J-1);
                    EDITSTRING = SUBSTR(EDITSTRING,J+1,4096-J);
                 END;
                 I = INDEX(EDITSTRING,')');
                 COLN_NAME(MAX_COLMN) = SUBSTR(EDITSTRING,1,I-1);
              END;
-/********************************************************************/
 /*                                                                  */
 /*      IF END-DUR FLAG STILL SET AT 'NO', THEN NEITHER ENDTIME     */
 /*      NOR DURATION PARAMETER FOUND, SO PRINT ERROR & SET FLAG     */
 /*                                                                  */
 /********************************************************************/
-      IF END_DUR_FLAG = 'NO'
       THEN DO;
               PUT SKIP EDIT('NEITHER ENDTIME NOR DURATION FOUND')(A);
               ERROR_FLAG = '*';
            END;
-/********************************************************************/
 /*                                                                  */
 /*      FINALLY, IF THE ERROR FLAG IS SET, DUMP.                    */
 /*                                                                  */
 /*      THIS TERMINATES THE PROCEDURE $USLIN.                       */
 /*                                                                  */
 /********************************************************************/
-      IF ERROR_FLAG = '*'
       THEN STOP;
-END; /* END OF PROCEDURE $USLIN */
1/*********************************************************************/
 /*                                                                   */
 /*  UU      UU  SSSSSSSS  TTTTTTTTTT RRRRRRRRR  NN     NN  GGGGGGGG  */
 /*  UU      UU SSSSSSSSSS TTTTTTTTTT RRRRRRRRRR NNN    NN GGGGGGGGGG */
 /*  UU      UU SS             TT     RR      RR NNNN   NN GG      GG */
 /*  UU      UU SSSSSSSSS      TT     RRRRRRRRRR NN NN  NN GG         */
 /*  UU      UU  SSSSSSSSS     TT     RRRRRRRRR  NN  NN NN GG   GGGGG */
 /*  UU      UU         SS     TT     RR    RR   NN   NNNN GG      GG */
 /*  UUUUUUUUUU SSSSSSSSSS     TT     RR     RR  NN    NNN GGGGGGGGGG */
 /*   UUUUUUUU   SSSSSSSS      TT     RR      RR NN     NN  GGGGGGGG  */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $USTRNG: UNPACK CONTROL BLOCKS FROM EITHER        */
 /*      SYSIN OR PARAMETER; ONE OR THE OTHER WILL BE SET UP IN      */
 /*      DATASTRING.                                                 */
 /*                                                                  */
 /********************************************************************/
-$USTRNG: PROC;
-/********************************************************************/
 /*                                                                  */
 /*      UNPACK THE SNAP START AND END TIMES, SETTING ERROR FLAG     */
 /*      IF EITHER IS MISSING. THE TIMES ARE UNPACKED INTO THE       */
 /*      FRONT END OF THE TIME FIELDS OF FORMAT YYDDDHHMMSS.SSS      */
 /*      IF START PARAMETER = SS, SNAP IS TO START WITH FIRST SMF    */
 /*      RECORD; SET PARAMETER TO ZERO TO SIGNIFY THIS.              */
 /*      IF END PARAMETER = SE, SNAP IS TO TERMINATE AT END OF FILE, */
 /*      SET PARAMETER HIGH TO FORCE THIS.                           */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'SNAPSTART=');
         J = INDEX(DATASTRING,'SS=');
0        IF I = 0 & J = 0
         THEN DO;
                 PUT SKIP EDIT('NO SNAP START PARAMETER FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 10;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
0                IF SUBSTR(EDITSTRING,1,2) = 'SS'
                 THEN SNAPSTART = 0;
0                ELSE DO;
                         I = INDEX(EDITSTRING,' ');
                         NREC = 0;
                         SUBSTR(AREC,1,I-1) = SUBSTR(EDITSTRING,1,I-1);
                         SNAPSTART = NREX;
                      END;
              END;
1        I = INDEX(DATASTRING,'SNAPEND=');
         J = INDEX(DATASTRING,'SE=');
0        IF I = 0 & J = 0
         THEN DO;
                 PUT SKIP EDIT('NO SNAP END PARAMETER FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 3;
                 ELSE K = I + 8;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
0                IF SUBSTR(EDITSTRING,1,2) = 'SE'
                 THEN SNAPEND = 99999999999.9999;
0                ELSE DO;
                         I = INDEX(EDITSTRING,' ');
                         NREC = 0;
                         SUBSTR(AREC,1,I-1) = SUBSTR(EDITSTRING,1,I-1);
                         SNAPEND = NREX;
                      END;
              END;
1/********************************************************************/
 /*                                                                  */
 /*      UNPACK THE TWO PORTIONS OF THE INTERVAL PARAMETER. LOAD     */
 /*      THE PARAMETER ACCORDINGLY AS TO WHETHER THE FIRST FIELD     */
 /*      SPECIFIES INTERVAL IS IN DAYS (DD), HOURS (HH),             */
 /*      MINUTES (MM) OR SECONDS (SS).                               */
 /*                                                                  */
 /********************************************************************/
-        I = INDEX(DATASTRING,'INTERVAL=');
         J = INDEX(DATASTRING,'IV=');
0        IF I = 0 & J = 0
         THEN DO;
                 PUT SKIP EDIT('NO INTERVAL PARAMETER FOUND')(A);
                 ERROR_FLAG = '*';
              END;
0        ELSE DO;
                 IF I = 0
                 THEN K = J + 4;
                 ELSE K = I + 10;
                 EDITSTRING = SUBSTR(DATASTRING,K,4097-K);
                 I = INDEX(EDITSTRING,',');
                 IVTYP = SUBSTR(EDITSTRING,1,I-1);
0                EDITSTRING = SUBSTR(EDITSTRING,I+1,4096-I);
                 I = INDEX(EDITSTRING,')');
                 NREC = 0;
                 SUBSTR(AREC,12-I,I-1) = SUBSTR(EDITSTRING,1,I-1);
                 IVVAL = NREC;
0                IF IVTYP = 'DD'
                 THEN INTERVAL = IVVAL * 1000000;
                 ELSE
                 IF IVTYP = 'HH'
                 THEN INTERVAL = IVVAL * 10000;
                 ELSE
                 IF IVTYP = 'MM'
                 THEN INTERVAL = IVVAL * 100;
                 ELSE
                 IF IVTYP = 'SS'
                 THEN INTERVAL = IVVAL;
0                ELSE DO;
                         PUT SKIP EDIT('INVALID INTERVAL TYPE')(A);
                         ERROR_FLAG = '*';
                      END;
              END;
         I = INDEX(DATASTRING,'BLANK=NO');
         J = INDEX(DATASTRING,'BL=NO');
         IF I = 0 & J = 0
         THEN NOBLANK = 'NO ';
         ELSE NOBLANK = 'YES';
1/********************************************************************/
 /*                                                                  */
 /*      FINALLY FOR UNPACKING THE PARAMETER, TEST IF THE ERROR      */
 /*      FLAG IS SET ON (I.E., IF ANY OF THE PARAMETERS WAS          */
 /*      MISSING). IF SO, DUMP.                                      */
 /*                                                                  */
 /*      THIS TERMINATES THE PROCESSING OF $USTRNG.                  */
 /*                                                                  */
 /********************************************************************/
-        IF ERROR_FLAG = '*'
         THEN STOP;
-END; /* END OF PROCEDURE $USTRNG */
1/*********************************************************************/
 /*                                                                   */
 /*   UU      UU    SSSSSSSS    YY      YY    SSSSSSSS    NN     NN   */
 /*   UU      UU   SSSSSSSSSS    YY    YY    SSSSSSSSSS   NNN    NN   */
 /*   UU      UU   SS             YY  YY     SS           NNNN   NN   */
 /*   UU      UU   SSSSSSSSS       YYYY      SSSSSSSSS    NN NN  NN   */
 /*   UU      UU    SSSSSSSSS       YY        SSSSSSSSS   NN  NN NN   */
 /*   UU      UU           SS       YY               SS   NN   NNNN   */
 /*   UUUUUUUUUU   SSSSSSSSSS       YY       SSSSSSSSSS   NN    NNN   */
 /*    UUUUUUUU     SSSSSSSS        YY        SSSSSSSS    NN     NN   */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $USYSN                                            */
 /*                                                                  */
 /*      THIS PROCEDURE READS THROUGH THE SYSIN DATA SET,            */
 /*      CONCATENATING THE RECORDS INTO ONE LONG CHARACTER           */
 /*      STRING, WHICH WILL THEN BE UNPACKED BY PROC $USTRNG.        */
 /*                                                                  */
 /********************************************************************/
-$USYSN: PROC;
0        DATASTRING = '';
         READ FILE(SYSIN) INTO(SYSIN_RECORD);
0        DO WHILE(EOF_SYSIN = 'NO');
            DATASTRING = DATASTRING || SYSIN_RECORD;
            READ FILE(SYSIN) INTO(SYSIN_RECORD);
         END;
-END; /* END OF PROCEDURE $USYSN */
1/*********************************************************************/
 /*                                                                   */
 /*      PPPPPPPPP     SSSSSSSS    UU      UU   TTTTTTTTTT    11      */
 /*      PPPPPPPPPP   SSSSSSSSSS   UU      UU   TTTTTTTTTT   111      */
 /*      PP      PP   SS           UU      UU       TT       111      */
 /*      PPPPPPPPPP   SSSSSSSSS    UU      UU       TT        11      */
 /*      PPPPPPPPP     SSSSSSSSS   UU      UU       TT        11      */
 /*      PP                   SS   UU      UU       TT        11      */
 /*      PP           SSSSSSSSSS   UUUUUUUUUU       TT       1111     */
 /*      PP            SSSSSSSS     UUUUUUUU        TT       1111     */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $PSUT1: PROCESS THE SYSUT1 FILE OF SMF RECORDS    */
 /*                                                                  */
 /*      FIRST, SET CURRENT SNAPSHOT TIME TO PROGRAM SNAPSTART,      */
 /*      OR TO START TIME OF FIRST RECORD IF SS=SS WAS CODED.        */
 /*                                                                  */
 /*      THEN READ THROUGH THE FILE SELECTING RECORDS (IF SELECTION  */
 /*      CRITERIA WAS SPECIFIED), AND CALLING ROUTINE $PRECD TO      */
 /*      PROCESS THOSE RECORDS SELECTED.                             */
 /*                                                                  */
 /*      CONTINUE UNTIL EITHER END OF FILE IS REACHED, OR ALL        */
 /*      REQUIRED SNAPSHOTS HAVE BEEN PRINTED  (NOWTIME = SNAPEND)   */
 /*                                                                  */
 /*      IF END OF FILE REACHED, CONTINUE PRINTING STORED NAMES      */
 /*      UNTIL EITHER SNAP IS COMPLETE OR ALL NAMES HAVE EXPIRED.    */
 /*                                                                  */
 /********************************************************************/
-$PSUT1: PROC;
         READ FILE(SYSUT1) INTO(SYSUT1_RECORD);
         IF EOF_SYSUT1 = 'NO'
         THEN DO;
                 IF EXIT_NAME ¬= ' '
                 THEN CALL DYNAMO(EXIT_PTR1,EXIT_PTR2);
                 IF SNAPSTART = 0
                 THEN DO;
                         CALL $UNPDT;
                         NREX = RECSTART;
                         IF IVTYP = 'SS'
                         THEN SUBSTR(AREC,10,6) = '000000';
                         IF IVTYP = 'MM'
                         THEN SUBSTR(AREC,8,8) = '00000000';
                         IF IVTYP = 'HH'
                         THEN SUBSTR(AREC,6,10) = '0000000000';
                         IF IVTYP = 'DD'
                         THEN SUBSTR(AREC,3,13) = '0000000000000';
                         SNAPSTART = NREX;
                      END;
                 NOWTIME = SNAPSTART;
              END;
         DO WHILE(EOF_SYSUT1 = 'NO' & NOWTIME <= SNAPEND);
            IF CTL_IDP = 0
             | SUBSTR(SYSUT1_RECORD,CTL_IDP,CTL_IDL) = CTL_IDX
            THEN CALL $PRECD;
            READ FILE(SYSUT1) INTO(SYSUT1_RECORD);
            IF EXIT_NAME ¬= ' '
            THEN CALL DYNAMO(EXIT_PTR1,EXIT_PTR2);
         END;
         ALL_NAMES_BLANK = 'YES';
         DO I = 1 TO LEN_PRINT_ARRAY;
            IF PRAR_NAME(I) ¬= ' '
            THEN ALL_NAMES_BLANK = 'NO ';
         END;
         DO WHILE(NOWTIME <= SNAPEND & ALL_NAMES_BLANK = 'NO ');
            CALL $PSTOR;
            ALL_NAMES_BLANK = 'YES';
            DO I = 1 TO LEN_PRINT_ARRAY;
               IF PRAR_NAME(I) ¬= ' '
               THEN ALL_NAMES_BLANK = 'NO ';
            END;
         END;
 END; /* END OF PROCEDURE $PSUT1 */
1/*********************************************************************/
 /*                                                                   */
 /*     PPPPPPPPP   RRRRRRRRR   EEEEEEEEEE   CCCCCCCC   DDDDDDDDD     */
 /*     PPPPPPPPPP  RRRRRRRRRR  EEEEEEEEEE  CCCCCCCCCC  DDDDDDDDDD    */
 /*     PP      PP  RR      RR  EE          CC      CC  DD      DD    */
 /*     PPPPPPPPPP  RRRRRRRRRR  EEEEEEE     CC          DD      DD    */
 /*     PPPPPPPPP   RRRRRRRRR   EEEEEEE     CC          DD      DD    */
 /*     PP          RR    RR    EE          CC      CC  DD      DD    */
 /*     PP          RR     RR   EEEEEEEEEE  CCCCCCCCCC  DDDDDDDDDD    */
 /*     PP          RR      RR  EEEEEEEEEE   CCCCCCCC   DDDDDDDDD     */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $PRECD: PROCESS A SINGLE SELECTED SYSUT1 RECORD   */
 /*                                                                  */
 /*      FIRST UNPACK THE START AND END DATES AND TIMES FROM THE     */
 /*      RECORD, THEN PRINT ALL SNAPSHOTS (IF ANY) UP UNTIL THE      */
 /*      START TIME OF THE CURRENT RECORD.                           */
 /*                                                                  */
 /*      THEN LOAD THE RECORD TO STORE FOR PRINTING.                 */
 /*                                                                  */
 /********************************************************************/
-$PRECD: PROC;
       CALL $UNPDT;
 /*
       COMMENT: FIELDS RECSTART & RECEND NOW CONTAIN COMBINED
                DATE || TIME FROM THE RECORD
 */
       DO WHILE(RECSTART > NOWTIME);
          CALL $PSTOR;
       END;
         IF COLUMNAR = 'YES'
         THEN CALL $LCOLS;
         ELSE CALL $LSTOR;
 END; /* END OF PROCEDURE $PRECD */
1/*********************************************************************/
 /*                                                                   */
 /*     UU      UU  NN     NN  PPPPPPPPP   DDDDDDDDD   TTTTTTTTTT     */
 /*     UU      UU  NNN    NN  PPPPPPPPPP  DDDDDDDDDD  TTTTTTTTTT     */
 /*     UU      UU  NNNN   NN  PP      PP  DD      DD      TT         */
 /*     UU      UU  NN NN  NN  PPPPPPPPPP  DD      DD      TT         */
 /*     UU      UU  NN  NN NN  PPPPPPPPP   DD      DD      TT         */
 /*     UU      UU  NN   NNNN  PP          DD      DD      TT         */
 /*     UUUUUUUUUU  NN    NNN  PP          DDDDDDDDDD      TT         */
 /*      UUUUUUUU   NN     NN  PP          DDDDDDDDD       TT         */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $UNPDT: UNPACK DATES AND TIMES                    */
 /*                                                                  */
 /*      SIMPLY TEST FOR THE PRE-SELECTED FORMATS, AND CALL THE      */
 /*      APPROPRIATE ROUTINES. IF THE FORMAT IS UNKNOWN, DUMP.       */
 /*                                                                  */
 /*      IF CONTROL PARAMETER FOR ENDDATE WAS SAME AS THAT FOR       */
 /*      STARTDATE, CHECK THAT RESULTING END IS GREATER THAN         */
 /*      START; IF NOT, THE NAME RAN OVER MIDNIGHT, SO ADD 1 DAY     */
 /*      TO ENDTIME.                                                 */
 /*                                                                  */
 /*      CALL $ADINV TO RATIONALISE DATE/TIME, IN CASE JOB RAN       */
 /*      OVER MIDNIGHT, AND DURATION FIELD OR NO ENDATE SPECIFIED    */
 /*                                                                  */
 /********************************************************************/
-$UNPDT: PROC;
         IF CTL_DF = 'YYDDDP  '
         THEN CALL $YYDDDP;
         ELSE
         IF CTL_DF = 'YYMMDD'
         THEN CALL $YYMMDD;
 /********************************************************************/
 /*                                                                  */
 /*      ELSE                      EXTRA FORMATS FOR DATE            */
 /*      IF CTL_DF = 'XXXXXX  '    SHOULD BE ENTERED IN THIS         */
 /*      THEN CALL $XXXXXX;        TYPE OF NESTED TEST.              */
 /*      ELSE                      THE RELEVANT PROCEDURE TO UNPACK  */
 /*      IF CTL_DF = 'YYYYYY  '    THE DATE SHOULD PUT THE START     */
 /*      THEN CALL $YYYYYY;        AND END DATES INTO RECSTART &     */
 /*                                RECEND, FORMAT YYDDD000000.0000   */
 /*                                                                  */
 /********************************************************************/
         ELSE DO;
                 PUT SKIP EDIT('DATE FORMAT ',CTL_DF,' NOT SUPPORTED')
                              (A(12),A(8),A(14));
                 STOP;
              END;
         IF CTL_TF = 'HUNSEC  '
         THEN CALL $HUNSEC;
         ELSE
         IF CTL_TF = 'PAKMIN  '
         THEN CALL $PAKMIN;
         ELSE
         IF CTL_TF = 'HHMMPS  '
         THEN CALL $HHMMPS;
         ELSE
         IF CTL_TF = 'TM64MS  '
         THEN CALL $TM64MS;
 /********************************************************************/
 /*                                                                  */
 /*      ELSE                      EXTRA FORMAT FOR TIME FIELDS      */
 /*      IF CTL_TF = 'AAAAAA  '    SHOULD BE ENTERED WITH THIS TYPE  */
 /*      THEN CALL $AAAAAA;        OF NESTED IF. THE PROC SHOULD     */
 /*      ELSE                      UNPACK THE START AND END TIMES    */
 /*      IF CTL_TF = 'BBBBBB  '    AND ADD THEM IN TO RECSTART,      */
 /*      THEN CALL $BBBBBB;        RECEND, TO COMPLETE THE FORMATS   */
 /*                                YYDDDHHMMSS.SSSS                  */
 /*                                                                  */
 /********************************************************************/
         ELSE DO;
                 PUT SKIP EDIT('TIME FORMAT ',CTL_TF,' NOT SUPPORTED')
                              (A(12),A(8),A(14));
                 STOP;
              END;
         IF CTL_SD = CTL_ED & RECEND < RECSTART
         THEN RECEND = RECEND + 1000000;
         CALL $ADINV(RECSTART,ZERODEC);
         CALL $ADINV(RECEND,ZERODEC);
 END;  /*** END OF PROCEDURE $UNPDT ***/
1/********************************************************************/
 /*                                                                   */
 /* YY      YY YY      YY DDDDDDDDD  DDDDDDDDD  DDDDDDDDD  PPPPPPPPP  */
 /*  YY    YY   YY    YY  DDDDDDDDDD DDDDDDDDDD DDDDDDDDDD PPPPPPPPPP */
 /*   YY  YY     YY  YY   DD      DD DD      DD DD      DD PP      PP */
 /*    YYYY       YYYY    DD      DD DD      DD DD      DD PPPPPPPPPP */
 /*     YY         YY     DD      DD DD      DD DD      DD PPPPPPPPP  */
 /*     YY         YY     DD      DD DD      DD DD      DD PP         */
 /*     YY         YY     DDDDDDDDDD DDDDDDDDDD DDDDDDDDDD PP         */
 /*     YY         YY     DDDDDDDDD  DDDDDDDDD  DDDDDDDDD  PP         */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $YYDDDP: DATES ARE JULIAN IN 3-BYTE PACKED FIELDS */
 /*                                                                  */
 /*      USE APAK/NPAK CHARACTER STRING TO PACKED DECIMAL CONVERSION */
 /*      FIELDS                                                      */
 /*                                                                  */
 /********************************************************************/
-$YYDDDP: PROC;
         NPAK = 0;
         SUBSTR(APAK,6,3) = SUBSTR(SYSUT1_RECORD,CTL_SD,3);
         RECSTART = NPAK * 1000000;
         NPAK = 0;
         SUBSTR(APAK,6,3) = SUBSTR(SYSUT1_RECORD,CTL_ED,3);
         RECEND = NPAK * 1000000;
 END; /* END OF PROCEDURE $YYDDDP */
1/*********************************************************************/
 /*                                                                   */
 /*********************************************************************/
 $YYMMDD: PROC;
         UT458_OPCODE = '3';
         UT458_YYMMDD = SUBSTR(SYSUT1_RECORD,CTL_SD,6);
         CALL DYNAMO(UT458_PTR1,UT458_PTR2);
         RECSTART = UT458_YYDDD * 1000000;
         UT458_YYMMDD = SUBSTR(SYSUT1_RECORD,CTL_ED,6);
         CALL DYNAMO(UT458_PTR1,UT458_PTR2);
         RECEND = UT458_YYDDD * 1000000;
 END; /*** END OF PROC $YYMMDD ****/
1/*********************************************************************/
 /*                                                                   */
 /*  HH      HH UU      UU NN     NN  SSSSSSSS  EEEEEEEEEE  CCCCCCCC  */
 /*  HH      HH UU      UU NNN    NN SSSSSSSSSS EEEEEEEEEE CCCCCCCCCC */
 /*  HH      HH UU      UU NNNN   NN SS         EE         CC      CC */
 /*  HHHHHHHHHH UU      UU NN NN  NN SSSSSSSSS  EEEEEEE    CC         */
 /*  HHHHHHHHHH UU      UU NN  NN NN  SSSSSSSSS EEEEEEE    CC         */
 /*  HH      HH UU      UU NN   NNNN         SS EE         CC      CC */
 /*  HH      HH UUUUUUUUUU NN    NNN SSSSSSSSSS EEEEEEEEEE CCCCCCCCCC */
 /*  HH      HH  UUUUUUUU  NN     NN  SSSSSSSS  EEEEEEEEEE  CCCCCCCC  */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $HUNSEC: TIMES ARE IN FULL-WORD BINARY IN         */
 /*      HUNDREDTHS OF A SECOND.                                     */
 /*                                                                  */
 /*      USE ABIN/NBIN FIELDS FOR CHARACTER TO BINARY CONVERSION.    */
 /*                                                                  */
 /*      FIRST EXTRACT HOURS, THEN MINUTES, THEN REMAINDER ARE       */
 /*      SECONDS.                                                    */
 /*                                                                  */
 /*      FOR ENDTIME, CHECK IF ENDTIME OR DURATION PARAMETER         */
 /*      WAS SPECIFIED, AND EITHER SELECT TIME OR ADD DURATION       */
 /*      FIELD TO STARTTIME.                                         */
 /*                                                                  */
 /*      INTERMEDIATE FIELD INTVAL IS DECLARED AND USED TO SPLIT     */
 /*      UP CALCULATIONS WHICH INTERMINGLE BINARY AND PACKED         */
 /*      FIELDS, AS THE PL/I OPTIMISING COMPILER TENDS TO GET        */
 /*      THESE SCREWED UP. (WHAT OTHER COMPILER COULD POSSIBLY       */
 /*      GIVE A DIVIDE EXCEPTION CALCULATING A = B + (C * D) ?????)  */
 /*                                                                  */
 /********************************************************************/
-$HUNSEC: PROC;
         DCL
         INTVAL FIXED(15,4);
-        ABIN  = SUBSTR(SYSUT1_RECORD,CTL_ST,4);
         I = NBIN / 360000;
         INTVAL = I * 10000;
         RECSTART = RECSTART + INTVAL;
         NBIN = NBIN - (I * 360000);
         I = NBIN / 6000;
         INTVAL = I * 100;
         RECSTART = RECSTART + INTVAL;
         NBIN = NBIN - (I * 6000);
         INTVAL = NBIN;
         INTVAL = INTVAL / 100;
         RECSTART = RECSTART + INTVAL;
         IF CTL_ET = 0
         THEN DO;
                 ABIN = SUBSTR(SYSUT1_RECORD,CTL_ST,4);
                 I = NBIN;
                 ABIN = SUBSTR(SYSUT1_RECORD,CTL_DR,4);
                 NBIN = NBIN + I;
              END;
         ELSE ABIN = SUBSTR(SYSUT1_RECORD,CTL_ET,4);
         I = NBIN / 360000;
         INTVAL = I * 10000;
         RECEND = RECEND + INTVAL;
         NBIN = NBIN - (I * 360000);
         I = NBIN / 6000;
         INTVAL = I * 100;
         RECEND = RECEND + INTVAL;
         NBIN = NBIN - (I * 6000);
         INTVAL = NBIN;
         INTVAL = INTVAL / 100;
         RECEND = RECEND + INTVAL;
 END; /* END OF PROCEDURE $HUNSEC */
1/*********************************************************************/
 /*                                                                   */
 /*  TTTTTTTTTT MM      MM  6666666  44         MM      MM  SSSSSSSS  */
 /*  TTTTTTTTTT MMMM  MMMM 666666666 44         MMMM  MMMM SSSSSSSSSS */
 /*      TT     MM MMMM MM 66        44         MM MMMM MM SS         */
 /*      TT     MM  MM  MM 66666666  44         MM  MM  MM  SSSSSSSS  */
 /*      TT     MM      MM 666666666 44   44    MM      MM   SSSSSSSS */
 /*      TT     MM      MM 66     66 4444444444 MM      MM         SS */
 /*      TT     MM      MM 666666666 4444444444 MM      MM SSSSSSSSSS */
 /*      TT     MM      MM 66666666       44    MM      MM  SSSSSSSS  */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $TM64MS: TIMES ARE IN FULL-WORD BINARY IN         */
 /*      64 MICROSECOND UNITS AS USED BY THE MONITOR FOR CICS.       */
 /*                                                                  */
 /*      USE ABIN/NBIN FIELDS FOR CHARACTER TO BINARY CONVERSION.    */
 /*                                                                  */
 /*      FIRST CONVERT TO HUNDREDTHS OF SECONDS, THEN USE CODE       */
 /*      COPIED FROM PROC HUNSEC, IN WHICH WE -                      */
 /*                                                                  */
 /*      FIRST EXTRACT HOURS, THEN MINUTES, THEN REMAINDER ARE       */
 /*      SECONDS.                                                    */
 /*                                                                  */
 /*      FOR ENDTIME, CHECK IF ENDTIME OR DURATION PARAMETER         */
 /*      WAS SPECIFIED, AND EITHER SELECT TIME OR ADD DURATION       */
 /*      FIELD TO STARTTIME. WE MAY OPTIONALLY ADD 'RESIDENCY' IN    */
 /*      HUNDREDTHS OF SECONDS TO DO A 'WHAT IF' STUDY.              */
 /*                                                                  */
 /*      INTERMEDIATE FIELD INTVAL IS DECLARED AND USED TO SPLIT     */
 /*      UP CALCULATIONS WHICH INTERMINGLE BINARY AND PACKED DATA.   */
 /*                                                                  */
 /********************************************************************/
-$TM64MS: PROC;
         DCL
         F64    FLOAT BINARY(51,0),
         G64    FLOAT BINARY(51,0),
         INTVAL FIXED(15,4);
-        ABIN  = SUBSTR(SYSUT1_RECORD,CTL_ST,4);
         F64 = NBIN;
         G64 = (F64 * 64) / 10000;
         NBIN = G64;               /* NOW IN SECS * 100 */
0        I = NBIN / 360000;
         INTVAL = I * 10000;
         RECSTART = RECSTART + INTVAL;
         NBIN = NBIN - (I * 360000);
         I = NBIN / 6000;
         INTVAL = I * 100;
         RECSTART = RECSTART + INTVAL;
         NBIN = NBIN - (I * 6000);
         INTVAL = NBIN;
         INTVAL = INTVAL / 100;
         RECSTART = RECSTART + INTVAL;
         IF CTL_ET = 0
         THEN DO;
                 ABIN = SUBSTR(SYSUT1_RECORD,CTL_ST,4);
                 F64 = NBIN;
                 G64 = (F64 * 64) / 10000;
                 I = G64;          /* NOW IN SECS * 100 */
                 ABIN = SUBSTR(SYSUT1_RECORD,CTL_DR,4);
                 F64 = NBIN;
                 G64 = (F64 * 64) / 10000;
                 NBIN = NBIN + I;
              END;
         ELSE ABIN = SUBSTR(SYSUT1_RECORD,CTL_ET,4);
         F64 = NBIN;
         G64 = (F64 * 64) / 10000;
         NBIN = G64;               /* NOW IN SECS * 100 */
         NBIN = NBIN + CTL_RES;
         I = NBIN / 360000;
         INTVAL = I * 10000;
         RECEND = RECEND + INTVAL;
         NBIN = NBIN - (I * 360000);
         I = NBIN / 6000;
         INTVAL = I * 100;
         RECEND = RECEND + INTVAL;
         NBIN = NBIN - (I * 6000);
         INTVAL = NBIN;
         INTVAL = INTVAL / 100;
         RECEND = RECEND + INTVAL;
 END; /* END OF PROCEDURE $TM64MS */
1/*********************************************************************/
 /*                                                                   */
 /*  PPPPPPPPP    AAAAAAAA   KK   KK   MM        MM  IIII  NN     NN  */
 /*  PPPPPPPPPP  AAAAAAAAAA  KK  KK    MMM      MMM   II   NNN    NN  */
 /*  PP      PP  AA      AA  KK KK     MMMM    MMMM   II   NNNN   NN  */
 /*  PPPPPPPPPP  AAAAAAAAAA  KKKK      MM MM  MM MM   II   NN NN  NN  */
 /*  PPPPPPPPP   AAAAAAAAAA  KKKKK     MM  MMMM  MM   II   NN  NN NN  */
 /*  PP          AA      AA  KK  KK    MM   MM   MM   II   NN   NNNN  */
 /*  PP          AA      AA  KK   KK   MM        MM   II   NN    NNN  */
 /*  PP          AA      AA  KK    KK  MM        MM  IIII  NN     NN  */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /*      PROCEDURE $PAKMIN; TIMES ARE IN HUNDREDTHS OF A MINUTE IN    */
 /*      A 4-BYTE PACKED DECIMAL FIELD.                               */
 /*                                                                   */
 /*      FIRST EXTRACT FROM RECORD VIA APAK/NPAK, THEN EXTRACT        */
 /*      HOURS, MINUTES, AND CONVERT DECIMAL MINUTES TO SECONDS.      */
 /*                                                                   */
 /*      REPEAT FOR EITHER DURATION OR ENDTIME, WHICHEVER WAS         */
 /*      SPECIFIED.                                                   */
 /*                                                                   */
 /*********************************************************************/
 $PAKMIN: PROC;
         DCL
         FIXEDDEC FIXED(15);
         NPAK = 0;
         SUBSTR(APAK,5,4) = SUBSTR(SYSUT1_RECORD,CTL_ST,4);
         FIXEDDEC = NPAK / 6000;
         RECSTART = RECSTART + (FIXEDDEC * 10000);
         NPAK = NPAK - (6000 * FIXEDDEC);
         FIXEDDEC = NPAK / 100;
         RECSTART = RECSTART + (FIXEDDEC * 100);
         NPAK = NPAK - (100 * FIXEDDEC);
         RECSTART = RECSTART + (NPAK * 0.60);
         NPAK = 0;
         IF CTL_ET = 0
         THEN DO;
                 SUBSTR(APAK,5,4) = SUBSTR(SYSUT1_RECORD,CTL_ST,4);
                 FIXEDDEC = NPAK;
                 NPAK = 0;
                 SUBSTR(APAK,5,4) = SUBSTR(SYSUT1_RECORD,CTL_DR,4);
                 NPAK = NPAK + FIXEDDEC;
              END;
         ELSE SUBSTR(APAK,5,4) = SUBSTR(SYSUT1_RECORD,CTL_ET,4);
         FIXEDDEC = NPAK / 6000;
         RECEND = RECEND + (FIXEDDEC * 10000);
         NPAK = NPAK - (6000 * FIXEDDEC);
         FIXEDDEC = NPAK / 100;
         RECEND = RECEND + (100 * FIXEDDEC);
         NPAK = NPAK - (100 * FIXEDDEC);
         RECEND = RECEND + (NPAK * 0.6);
 END;    /***** END OF PROCEDURE $PAKMIN *****/
1/*********************************************************************/
 /*                                                                   */
 /*********************************************************************/
 $HHMMPS: PROC;
         DCL
         FIXED1 FIXED(15),
         FIXED2 FIXED(15,4);
         NREC = 0;
         SUBSTR(AREC,7,4) = SUBSTR(SYSUT1_RECORD,CTL_ST,4);
         FIXED2 = NREC * 100;
         RECSTART = RECSTART + FIXED2;
         RECEND = RECSTART;
         NPAK = 0;
         SUBSTR(APAK,6,3) = SUBSTR(SYSUT1_RECORD,CTL_DR,3);
         FIXED1 = NPAK / 3600;
         FIXED2 = FIXED1 * 10000;
         NPAK = NPAK - (FIXED1 * 3600);
         FIXED1 = NPAK / 60;
         FIXED2 = FIXED2 + (FIXED1 * 100);
         NPAK = NPAK - (FIXED1 * 60);
         FIXED2 = FIXED2 + NPAK;
         CALL $ADINV(RECEND,FIXED2);
 END;  /***** END OF PROCEDURE $HHMMPS *****/
1/*********************************************************************/
 /*                                                                   */
 /*     PPPPPPPPP    SSSSSSSS   TTTTTTTTTT   OOOOOOOO   RRRRRRRRR     */
 /*     PPPPPPPPPP  SSSSSSSSSS  TTTTTTTTTT  OOOOOOOOOO  RRRRRRRRRR    */
 /*     PP      PP  SS              TT      OO      OO  RR      RR    */
 /*     PPPPPPPPPP  SSSSSSSSS       TT      OO      OO  RRRRRRRRRR    */
 /*     PPPPPPPPP    SSSSSSSSS      TT      OO      OO  RRRRRRRRR     */
 /*     PP                  SS      TT      OO      OO  RR    RR      */
 /*     PP          SSSSSSSSSS      TT      OOOOOOOOOO  RR     RR     */
 /*     PP           SSSSSSSS       TT       OOOOOOOO   RR      RR    */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $PSTOR: PRINT THE STORE.                          */
 /*                                                                  */
 /*      FIRSTLY PRINT THE SNAPSHOT, THEN INCREMENT THE INTERNAL     */
 /*      CLOCK (NOWTIME) TO THE TIME OF THE NEXT SNAPSHOT.           */
 /*                                                                  */
 /*      THEN SCAN THROUGH THE OVERFLOW ARRAY DELETING ITEMS THAT    */
 /*      WILL HAVE EXPIRED BY THEN.                                  */
 /*                                                                  */
 /*      FINALLY, SCAN THROUGH THE PRINT ARRAY, AGAIN DELETING       */
 /*      EXPIRED ITEMS; IN THIS CASE, HOWEVER, WHEN AN ITEM IS       */
 /*      DELETED, THE OVERFLOW ARRAY IS CHECKED FOR A REPLACEMENT    */
 /*      IF ONE EXISTS, IT IS LOADED INTO THE PRINT ARRAY.           */
 /*      (UNLESS COLUMNAR PRINTING REQD, WHEN THIS IS BYPASSED)      */
 /*                                                                  */
 /*      THEN (MOD ADDED 15 JUNE 1978)                               */
 /*      IF THE PRINT ARRAY IS EMPTY, AND BLANK = NO WAS SPECIFIED,  */
 /*      SET THE INTERNAL CLOCK TO THEN START TIME OF THE NEXT RECD  */
 /*                                                                  */
 /********************************************************************/
-$PSTOR: PROC;
         CALL $PSNAP;
         CALL $ADINV(NOWTIME,INTERVAL);
         DO I = 1 TO LEN_OFLOW_ARRAY;
            IF OFAR_RECEND(I) < NOWTIME
            THEN OFAR_NAME(I) = ' ';
         END;
         DO I = 1 TO LEN_PRINT_ARRAY;
            IF PRAR_RECEND(I) < NOWTIME
            THEN DO;
                    PRAR_NAME(I) = ' ';
                    J = 1;
                    DO WHILE(J <= LEN_OFLOW_ARRAY
                           & OFAR_NAME(J) = ' ');
                       J = J + 1;
                    END;
                    IF J <= LEN_OFLOW_ARRAY & COLUMNAR = 'NO '
                    THEN DO;
                            PRAR_NAME(I) = OFAR_NAME(J);
                            PRAR_RECEND(I) = OFAR_RECEND(J);
                            OFAR_NAME(J) = ' ';
                         END;
                 END;
         END;
         J = 0;
         DO I = 1 TO LEN_PRINT_ARRAY WHILE(J = 0);
           IF PRAR_NAME(I) ¬= ' '
            THEN J = 1;
         END;
         IF J = 0 & NOBLANK = 'YES'
         THEN DO;
                 NREX = RECSTART;
                 IF IVTYP = 'SS' THEN SUBSTR(AREC,10,6) = '000000';
                 IF IVTYP = 'MM' THEN SUBSTR(AREC,8,8) = '00000000';
     IF IVTYP = 'HH' THEN SUBSTR(AREC,6,10) = '0000000000';
     IF IVTYP = 'DD' THEN SUBSTR(AREC,3,13) = '0000000000000';
                 NOWTIME = NREX;
                 DO WHILE(RECSTART > NOWTIME);
                    CALL $ADINV(NOWTIME,INTERVAL);
                 END;
              END;
 END; /* END OF PROCEDURE $PSTOR */
1/*********************************************************************/
 /*                                                                   */
 /*     LL           SSSSSSSS   TTTTTTTTTT   OOOOOOOO   RRRRRRRRR     */
 /*     LL          SSSSSSSSSS  TTTTTTTTTT  OOOOOOOOOO  RRRRRRRRRR    */
 /*     LL          SS              TT      OO      OO  RR      RR    */
 /*     LL          SSSSSSSSS       TT      OO      OO  RRRRRRRRRR    */
 /*     LL           SSSSSSSSS      TT      OO      OO  RRRRRRRRR     */
 /*     LL                  SS      TT      OO      OO  RR    RR      */
 /*     LLLLLLLLLL  SSSSSSSSSS      TT      OOOOOOOOOO  RR     RR     */
 /*     LLLLLLLLLL   SSSSSSSS       TT       OOOOOOOO   RR      RR    */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $LSTOR: LOAD AN ITEM TO STORE.                    */
 /*                                                                  */
 /*      CHECK THROUGH THE PRINT ARRAY FOR THE FIRST VACANT SLOT     */
 /*      (NAME BLANK), AND LOAD CURRENT NAME TO IT. IF NO VACANT     */
 /*      SLOTS, CHECK THROUGH OVERFLOW; IF THIS IS ALSO FULL, DUMP.  */
 /*                                                                  */
 /********************************************************************/
-$LSTOR: PROC;
         DCL LS_NAME CHAR(44) STATIC;
         LS_NAME = SUBSTR(SYSUT1_RECORD,CTL_NMP,CTL_NML);
         I = 1;
         DO WHILE(I <= LEN_PRINT_ARRAY & (PRAR_NAME(I) ¬= LS_NAME));
            I = I + 1;
         END;
         IF I <= LEN_PRINT_ARRAY
         THEN DO;
                 PRAR_NAME(I) = LS_NAME;
                 PRAR_RECEND(I) = RECEND;
              END;
         ELSE DO;
              I = 1;
              DO WHILE(I <= LEN_PRINT_ARRAY & (PRAR_NAME(I) ¬= ' '));
                 I = I + 1;
              END;
              IF I <= LEN_PRINT_ARRAY
              THEN DO;
                      PRAR_NAME(I) = LS_NAME;
                      PRAR_RECEND(I) = RECEND;
                   END;
0        ELSE DO;
              I = 1;
              DO WHILE(I <= LEN_OFLOW_ARRAY
                       & (OFAR_NAME(I) ¬= LS_NAME));
                 I = I + 1;
              END;
                 IF I <= LEN_OFLOW_ARRAY
                 THEN DO;
                         OFAR_NAME(I) = LS_NAME;
                         OFAR_RECEND(I) = RECEND;
                      END;
                 ELSE DO;
              I = 1;
              DO WHILE(I <= LEN_OFLOW_ARRAY
                       & (OFAR_NAME(I) ¬= ' '));
                 I = I + 1;
              END;
                 IF I <= LEN_OFLOW_ARRAY
                 THEN DO;
                         OFAR_NAME(I) = LS_NAME;
                         OFAR_RECEND(I) = RECEND;
                      END;
                 ELSE DO;
                         PUT SKIP EDIT('INSUFFICIENT OVERFLOW')(A);
                         STOP;
                      END;
              END;
         END;
         END;
 END; /* END OF PROCEDURE $LSTOR */
1/*********************************************************************/
 /*                                                                   */
 /*     LL           CCCCCCCC    OOOOOOOO   LL           SSSSSSSS     */
 /*     LL          CCCCCCCCCC  OOOOOOOOOO  LL          SSSSSSSSSS    */
 /*     LL          CC          OO      OO  LL          SS            */
 /*     LL          CC          OO      OO  LL          SSSSSSSSS     */
 /*     LL          CC          OO      OO  LL           SSSSSSSSS    */
 /*     LL          CC          OO      OO  LL                  SS    */
 /*     LLLLLLLLLL  CCCCCCCCCC  OOOOOOOOOO  LLLLLLLLLL  SSSSSSSSSS    */
 /*     LLLLLLLLLL   CCCCCCCC    OOOOOOOO   LLLLLLLLLL   SSSSSSSS     */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /*     PROCEDURE $LCOLS: LOAD AN ITEM TO STORE IF COLUMNAR REQUIRED  */
 /*                                                                   */
 /*     CHECK THROUGH COLUMNAR ARRAY FOR THIS NAME.                   */
 /*     IF THERE, LOAD TO PRINT ARRAY, ELSE TO OVERFLOW.              */
 /*                                                                   */
 /*********************************************************************/
-$LCOLS: PROC;
0        DO I = 1 TO LEN_COLMN_ARRAY
         WHILE(COLN_NAME(I) ¬= SUBSTR(SYSUT1_RECORD,CTL_NMP,CTL_NML));
         END;
         IF COLN_NAME(I) = SUBSTR(SYSUT1_RECORD,CTL_NMP,CTL_NML)
         THEN DO;
                 PRAR_NAME(I) = COLN_NAME(I);
                 PRAR_RECEND(I) = RECEND;
              END;
         ELSE DO;
                 I = 1;
                 DO WHILE(I <= LEN_OFLOW_ARRAY & OFAR_NAME(I) ¬= ' ');
                    I = I + 1;
                 END;
                 IF I <= LEN_OFLOW_ARRAY
                 THEN DO;
                         OFAR_NAME(I) = SUBSTR(SYSUT1_RECORD,
                                               CTL_NMP,CTL_NML);
                         OFAR_RECEND(I) = RECEND;
                      END;
                 ELSE DO;
                         PUT SKIP EDIT('INSUFFICIENT OVERFLOW')(A);
                         STOP;
                      END;
              END;
 END; /* END OF PROCEDURE $LCOLS */
1/*********************************************************************/
 /*                                                                   */
 /*     PPPPPPPPP    SSSSSSSS   NN     NN   AAAAAAAA   PPPPPPPPP      */
 /*     PPPPPPPPPP  SSSSSSSSSS  NNN    NN  AAAAAAAAAA  PPPPPPPPPP     */
 /*     PP      PP  SS          NNNN   NN  AA      AA  PP      PP     */
 /*     PPPPPPPPPP  SSSSSSSSS   NN NN  NN  AAAAAAAAAA  PPPPPPPPPP     */
 /*     PPPPPPPPP    SSSSSSSSS  NN  NN NN  AAAAAAAAAA  PPPPPPPPP      */
 /*     PP                  SS  NN   NNNN  AA      AA  PP             */
 /*     PP          SSSSSSSSSS  NN    NNN  AA      AA  PP             */
 /*     PP           SSSSSSSS   NN     NN  AA      AA  PP             */
 /*                                                                   */
 /********************************************************************/
 /*                                                                  */
 /*      PROCEDURE $PSNAP: PRINT A SINGLE SNAPSHOT.                  */
 /*                                                                  */
 /*      TEST IF NEW PAGE NEEDED, IF SO PRINT HEADINGS.              */
 /*      SET CURRENT CLOCK TIME INTO LINE                            */
 /*      COMPLETE NAMES IN LINE FROM PRINT ARRAY                     */
 /*      IF ANY ELEMENTS IN OVERFLOW ARRAY, SET FLAG TO *.           */
 /*      WRITE LINE UNLESS BLANK AND BLANK=NO PARAMETER SET.         */
 /*                                                                  */
 /********************************************************************/
-$PSNAP: PROC;
         IF LINECT > 52
         THEN DO;
                 PAGENO = PAGENO + 1;
                 HA_PAGE = PAGENO;
                 WRITE FILE(PRINT) FROM(HEADA);
                 WRITE FILE(PRINT) FROM(HEADB);
                 LA_CBYT = ' ';
                 LINECT = 0;
              END;
         LA_TIME = NOWTIME;
         LA_SNAP = ' ';
         COUNT = 0;
         DO I = 1 TO LEN_PRINT_ARRAY;
            SUBSTR(LA_SNAP,(I-1)*(CTL_NML+2)+1,CTL_NML+2)
                                   = PRAR_NAME(I);
            IF PRAR_NAME(I) ¬= ' ' THEN COUNT = COUNT + 1;
         END;
         DO I = 1 TO LEN_OFLOW_ARRAY;
            IF OFAR_NAME(I) ¬= ' '
            THEN SUBSTR(LA_SNAP,112,1) = '*';
            IF OFAR_NAME(I) ¬= ' ' THEN COUNT = COUNT + 1;
         END;
         IF NOBLANK = 'YES' & SUBSTR(LA_SNAP,1,111) = ' '
         THEN DO;
                 LA_CBYT = '0';
              END;
         ELSE DO;
                 LA_COUNT = COUNT;
                 WRITE FILE(PRINT) FROM(LINEA);
                 IF LA_CBYT = ' '
                 THEN LINECT = LINECT + 1;
                 ELSE LINECT = LINECT + 2;
                 LA_CBYT = ' ';
              END;
 END; /* END OF PROCEDURE $PSNAP */

         END;      /********* END OF MAIN PROCEDURE STROBE2*********/
