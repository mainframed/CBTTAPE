*/GILBERTS JOB (ACCT#),STRING-MACRO,
*/ NOTIFY=&SYSUID,
*/ CLASS=A,MSGCLASS=H,COND=(0,NE)
*/HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,
*/*FLAG(PAGE0),NORXREF,NODXREF,                   HLASM R3
*/ NOBATCH)
***********************************************************************
*                                                                     *
*            COPYRIGHT (C) 1989-2010 GILBERT SAINT-FLOUR              *
*                       ALL RIGHTS RESERVED                           *
*                                                                     *
* MACRO NAME = STRING                                                 *
*                                                                     *
* DESCRIPTIVE NAME = STRING Macro Instruction.                        *
*                                                                     *
* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *
*            or STRING (of COBOL) to assembler programs.              *
*                                                                     *
* STATUS = R518                                                       *
*                                                                     *
* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *
*          http://gsf-soft.com/Freeware/STRING.shtml                  *
*                                                                     *
* ENVIRONMENT = SEE BELOW                                             *
*                                                                     *
*     AMODE = ANY                                                     *
*     RMODE = ANY                                                     *
*     SCP   = OS/360, OS/VS, MVS/370, MVS/XA, MVS/ESA, OS/390 or z/OS *
*     KEY   = ANY                                                     *
*     MODE  = ANY                                                     *
*     APF   = ANY                                                     *
*                                                                     *
* Processor = Assembler H, High-Level Assembler                       *
*                                                                     *
* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *
*                                                                     *
* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *
*                                                                     *
* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*200 Build STRING macro based on $PUNCH,$FIELD,@PRTPUN            1989*
*300 @STRING always runs with AMODE31                             1992*
*    Make slight modifications to the SCON2A routine                  *
*    Length used in output field returned in R15                      *
*    @JDATE routine integrated into @STRING CSECT                     *
*301 FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 1993*
*302 GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION              *
*303 REPLACE @STRPAD WITH @STRBLANKS                              1994*
*304 USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES               *
*306 TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS                   *
*    LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'            *
*    USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)            *
*307 "FINAL_CALL" OPTION CHANGED TO "GENERATE"                        *
*    ADD NOCSECT AND LOCTR OPTIONS TO "GENERATE" CALL                 *
*308 USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)                *
*    PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO                 *
*400 Reorg the code to simplify feature selection                 1995*
*    BLANKS no longer used or generated                               *
*401 Generate @STRHEXT when ((REG),,X) only hex field                 *
*502 @STRING Routine rewritten for MVS/ESA:                       1996*
*    . Use linkage stack to store caller's registers                  *
*    . Add support for AR Mode                                        *
*    . @STRING now executes in caller's AMODE                         *
*    . Rename previous version to STRINGXA                            *
*503 Date Conversion to YYYY-MM-DD Format (ISO Standard)              *
*    Improve Support for AR mode                                      *
*504 Set &STRBLANKS to 10 when processing dates                   1997*
*505 Allow for 128K-offset                                        1998*
*506 Remove literal from BAL instruction for HLASM R3             1999*
*507 Merge STRINGXA code, add AR_MODE option                      2000*
*    Change syntax of GENERATE call                                   *
*508 Compatibility with FLAG(PAGE0) in HLASM R3                       *
*    Compatibility with pre-XA version of the SAVE macro              *
*    Remove AMODE-based R2 cleanup in 370 mode                        *
*509 Hex string can contain commas, e.g. X'12,3456,7890'          2001*
*    Length of parm-list entries can vary between 2 and 6 bytes       *
*    Short literals (up to 5 bytes) are generated in parm list        *
*510 JDATE=90366 produces 90/13/01 instead of S0C7                2002*
*511 Prevent ACTR error with long literals                        2003*
*512 Packed fields no longer ignored when R0=0                        *
*513 Local base not needed for (GENERATE,,LOCTR)                  2004*
*514 '&&'(1,1) at .LIT11C                                         2005*
*515 Negative Value: -12345678 (Tim Alpaerts)                     2007*
*516 STRING may be present in multiple CSECTs in same assembly    2009*
*    One of the CSECTs that use STRING may have no name               *
*517 Fix addressability error in CSECT23/CSECT28 reported by IBM/AU   *
*518 %TIME hh:mm:ss.hh instead of hh:mm:ss:hh                     2010*
*    (%TIME,5) or (%TIME,8) or (%TIME,11) or (%TIME,12)               *
*    Fix bug near GENL2D reported by IBM/AU                           *
*                                                                     *
***********************************************************************
         MACRO
&NAME    STRING &INTO=,&PRINT=NOGEN,&STRING_MACRO_VERSION=518
         AIF   ('&PRINT' EQ 'NOGEN').NOGEN
         PUSH  PRINT
         PRINT GEN
.NOGEN   GBLA  &$_LIT
         GBLA  &$_CSECT_NO             Number of CSECTs
         GBLB  &$_FEAT(16)             FEATURES
.*                                       1 LITERALS
.*                                       2 REGISTER (BIN)
.*                                       3 REGISTER (HEX)
.*                                       4 PACKED
.*                                       5 JDATE
.*                                       6 BINARY
.*                                       7 HEX
.*                                       8 NUMERIC
.*                                       9 LEFT JUST (NUMERIC)
.*                                       10 LEADING ZEROES
.*                                       11 TRUNCATE (CHAR STRING)
.*                                       12 %TIME
         GBLC  &$_LITS(9999)           LITERALS
         GBLC  &$_CSECT(99)            CSECTs
         GBLC  &$_LITS_CSECT(9999)     CSECT OF LITERALS
         LCLA  &I,&J,&L,&N,&FLAG,&LEN2,&STRBLANKS
         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC,&NUMERIC
         LCLC  &LABEL,&LQ,&STR,&TO1,&TO2,&P1S,&P2C,&P2L,&P3C,&P3L
         LCLC  &LIT,&ALLFEAT,&OPT2,&OPT3
         LCLC  &LOCTR1,&SYSECT2
.* MNOTE *,'CSECT_NO=&$_CSECT_NO CSECT1=&$_CSECT(1) CSECT2=&$_CSECT(2) X
               CSECT3=&$_CSECT(3) .'
         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X
               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL
&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS
&LQ      SETC  'L'''                   LENGTH ATTRIBUTE
&STR     SETC  '  R&STRING_MACRO_VERSION'
.*MNOTE ' &$_CSECT_NO &$_CSECT(&$_CSECT_NO) .'
&SYSECT2 SETC  '&SYSECT'
         AIF   ('&SYSECT' NE '').CSECT21
&SYSECT2 SETC  'NO_NAME'
.CSECT21 ANOP
         AIF   (&$_CSECT_NO GT 0).CSECT22
&$_CSECT_NO SETA 1
&$_CSECT(1) SETC '&SYSECT2'
.CSECT22 ANOP
&I       SETA  1
.*loop
.CSECT23 ANOP
         AIF   ('&$_CSECT(&I)' EQ '&SYSECT2').CSECT27
&I       SETA  1+&I
         AIF   (&I LE &$_CSECT_NO).CSECT23
.*endloop
&$_CSECT_NO SETA &I
&$_CSECT(&I) SETC '&SYSECT2'
.*MNOTE ' &$_CSECT_NO &$_CSECT(&I) .'
.CSECT27 ANOP                                         <=== New line
         AIF   (&I EQ 1).CSECT28                      <=== New line
.**      AIF   ('&SYSECT' EQ '&$_CSECT(&I)').CSECT28
&STR     SETC  '_'.'&SYSECT2'          $STRING_CSECT2
.CSECT28 ANOP
&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE
         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR
         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR
         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)
         DC    AL2((&LABEL.P-*)/2)     OFFSET TO FIELD DESCRIPTORS
&LOCTR1  SETC  '&SYSLOC'
         AIF   ('&SYSLOC' NE '').LOCTR1X
&LOCTR1  SETC  'LOCTR_'.'NO_NAME'
&LOCTR1  LOCTR                         IN-LINE CODE IN FIRST CSECT
.*MNOTE 1,'LOCTR1=&LOCTR1'
.LOCTR1X ANOP
         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP
$LTORG   LOCTR                         ADDRESSABLE CONSTANTS
$FARRTNE LOCTR                         FAR ROUTINES
.LOCTR2  AIF   ('&SYSECT2' NE '&$_CSECT(1)').LOCTR3
$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS
.LOCTR3  AIF   ('&SYSECT2' EQ '&$_CSECT(1)').LOCTR5
&STR     SETC  '$LTORG_&$_CSECT(&I)'
         AIF   (D'&STR).LOCTR4         NOT FIRST TIME, JUMP
&STR     LOCTR                         ADDRESSABLE CONSTANTS
&STR     SETC  '$FARRTNE_&$_CSECT(&I)'
&STR     LOCTR                         FAR ROUTINES
.LOCTR4  ANOP
&STR     SETC  '$LITERAL_&$_CSECT(&I)'
&STR     LOCTR                         NON-ADDRESSABLE CONSTANTS
.LOCTR5  ANOP
.*once   DS    0H
&TO1     SETC  '&INTO(1)'
&TO2     SETC  '&LQ&INTO'
         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX
         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)
&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)
.PUNTO3  ANOP
&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)
         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)
&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))
.PUNTO8  ANOP
&LABEL.P DC    S(&TO1,&TO2)
.*--------------------------------------------------------------------*
.*-------      FIELDS       ------------------------------------------*
.*--------------------------------------------------------------------*
&I       SETA  1
.*LOOP
.LOOP1   ANOP
         ACTR  200                            SYSDEBUG/DIAG055
         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS
&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP
         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00
         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01
.*--------------------------------------------------------------------*
.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *
.*--------------------------------------------------------------------*
&P1S     SETC  '&SYSLIST(&I,1)'
&P2L     SETC  '0'                     INPUT LENGTH
&P3L     SETC  '0'                     OUTPUT LENGTH
         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES
         AIF   ('&SYSLIST(&I,1)' EQ '%TIME').FLD190 %TIME
         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)
         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250
&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)
.FLD115  ANOP
.*
         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200
.*
.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)
.*
&L       SETA  1
.*--LOOP
.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133
&L       SETA  &L+1
         AIF   (&L LT K'&P1S).FLD131
.*--ENDLOOP
&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF
         AGO   .FLD134
.FLD133  ANOP
&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE
.FLD134  ANOP
.*
         AIF   (NOT D'&P2L).FLD140
&P2C     SETC  T'&P2L
.*MNOTE *,'&P1 &P2C'
         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220
         AIF   ('&P2C' EQ 'G').FLD210  FL2
.FLD140  ANOP
.*
.*       EXTRACT PSATOLD FROM PSATOLD-PSA
.*
&L       SETA  1
.*--LOOP
.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143
         AIF   ('&P2L'(&L,1) EQ '+').FLD143
&L       SETA  &L+1
         AIF   (&L LT K'&P2L).FLD141
.*--ENDLOOP
&P2L     SETC  '&LQ&P2L'               L'ABCDEF
         AGO   .FLD300
.FLD143  ANOP
&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA
         AGO   .FLD300
.*
.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800
&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12
         AIF   (&LAST).FLD186
         DC    X'60',AL1(&P2L)         BLANKS
         AGO   .LIT90
.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS
         AGO   .LIT90
.*
.FLD190  AIF   (N'&SYSLIST(&I) GT 2).FLD992
&P1S     SETC  '1(14)'                 %TIME
&$_FEAT(12) SETB 1                     %TIME
&P2L     SETC  '12'                    hh:mm:ss.hh
         AIF   (N'&SYSLIST(&I) EQ 1).FLD1905
         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD1904
&P2L     SETC  '&SYSLIST(&I,2)'        5,8,11,12
&L       SETA  &SYSLIST(&I,2)
         AIF   (&L EQ 5 OR &L EQ 8 OR &L EQ 11 OR &L EQ 12).FLD1905
.FLD1904 MNOTE 8,'Second sub-parameter is invalid: &SYSLIST(&I)'
.FLD1905 ANOP
.*MNOTE 1,'FLD1905 &SYSLIST(&I) &P1S &P2L '
         AGO   .FLD800
.*--------------------------------------------------------------------*
.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *
.*--------------------------------------------------------------------*
.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED
&P2C     SETC  '&SYSLIST(&I,2)'
         AGO   .FLD220
.*T'&P1=G
.FLD210  ANOP
&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'
&P2C     SETC  'FL&L'                  T'&P1 = 'G'
.*
.FLD220  ANOP
&P2L     SETC  '0&P2C'                 (R2) LENGTH
         AIF   ('&P2C'(1,1) EQ '(').FLD300
&P2L     SETC  '&P2C'                  3(R2) LENGTH
         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300
&P2L     SETC  '0'
&PACKED  SETB  ('&P2C' EQ 'P')
         AIF   (&PACKED).FLD290
&P2L     SETC  '1'
         AIF   ('&P2C' EQ 'FL1').FLD240
&P2L     SETC  '3'
         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240
&P2L     SETC  '7'
         AIF   ('&P2C' EQ 'FL3').FLD240
&P2L     SETC  '15'
         AIF   ('&P2C' EQ 'F').FLD240
&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD
         AGO   .FLD300
.*
.FLD240  ANOP                          BINARY VARIABLE
&BIN     SETB  1
         AGO   .FLD300
.*
.FLD250  ANOP                          REGISTER CONTENT
&REG     SETB  1
         AGO   .FLD300
.*
.FLD290  ANOP                          PACKED
&P2L     SETC  '1'
.*--------------------------------------------------------------------*
.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *
.*--------------------------------------------------------------------*
.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800
&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL
&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE
         AIF   (&HEX OR &TRUNC).FLD800
.*
&P3C     SETC  '&SYSLIST(&I,3)'
&P3L     SETC  '248'
         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308
&P3L     SETC  '249'
         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308
&P3L     SETC  '250'
         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308
&P3L     SETC  '251'
         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308
&P3L     SETC  '252'
         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308
&P3L     SETC  '253'
         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308
&P3L     SETC  '0'
         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310
         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'
         AGO   .FLD310
.FLD308  ANOP
&$_FEAT(5) SETB 1                      JDATE
         AGO   .FLD800
.*--LOOP
.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) NE 'L').FLD311
&LEFT    SETB  1
         AGO   .FLD318
.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312
&ZERO    SETB  1
         AGO   .FLD318
.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993       nn in RnnB is not num
         AIF   ('&P3C'(1,1) GT '9').FLD993       nn in RnnB is not num
&P3L     SETC  '&P3L'.'&P3C'(1,1)
.FLD318  ANOP
.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'
&P3C     SETC  '&P3C '(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER
         AIF   (K'&P3C GT 0).FLD310
.*--ENDLOOP
         AIF   (&P3L GT 16).FLD993               nn in RnnB is too big
.*--------------------------------------------------------------------*
.FLD800  ANOP
&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))
&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))
&LEFT    SETB  (&LEFT AND &NUMERIC)
         AIF   (NOT &NUMERIC).FLD810
         AIF   (&LEFT OR '&P3L' NE '0').FLD810
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))
         AIF   (&REG).FLD810
&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'FL1').FLD810
&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH
.FLD810  ANOP
&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1
&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L
&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)
&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)
&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED
&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY
&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX
&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED
&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))
&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)
&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)
&BIN     SETB  0                    RESET FLAGS
&HEX     SETB  0                    RESET FLAGS
&REG     SETB  0                    RESET FLAGS
&PACKED  SETB  0                    RESET FLAGS
&LEFT    SETB  0                    RESET FLAGS
&ZERO    SETB  0                    RESET FLAGS
&TRUNC   SETB  0                    RESET FLAGS
         AIF   (&FLAG GE 10).FLD995
         AIF   (&LAST).FLD816
         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)
         AGO   .LIT99
.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)
         AGO   .LIT99
.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'
         AGO   .LIT99
.FLD992  MNOTE 12,'Too many sub-operands: &SYSLIST,(&I)'
         AGO   .LIT99
.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''
         AGO   .LIT99
.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'
         AGO   .LIT99
.*--------------------------------------------------------------------*
.*------------ LITERALS ----------------------------------------------*
.*--------------------------------------------------------------------*
.LIT00   ANOP
&LIT     SETC  'C&SYSLIST(&I)'
         AGO   .LIT09
.LIT01   ANOP
&LIT     SETC  '&SYSLIST(&I)'
.LIT09   ANOP                              calculate length of literal
&J       SETA  3
&L       SETA  0
         ACTR  K'&LIT+K'&LIT+100
         AIF   ('&LIT'(1,1) EQ 'X').LIT11X
.*--LOOP
.LIT11C AIF ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&'(1,1)).LIT12C
&J       SETA  &J+1
.LIT12C  ANOP
&J       SETA  &J+1
&L       SETA  &L+1
         AIF   (&J LT K'&LIT).LIT11C
.*--ENDLOOP
         AGO   .LIT15
.*--LOOP
.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X
&L       SETA  &L+1
.LIT12X  ANOP
&J       SETA  &J+1
         AIF   (&J LT K'&LIT).LIT11X
.*--ENDLOOP
&L       SETA  (&L+1)/2
.LIT15   ANOP                               generate in-line literal
         AIF   (&L GT 5).LIT40
         AIF   (&LAST).LIT16
         DC    X'4&L',&LIT
         AGO   .LIT90
.LIT16   DC    X'C&L',&LIT,0S(0)
         AGO   .LIT90
.LIT40   ANOP                                  check literal table
         AIF   (&$_LIT EQ 0).LIT50
&N       SETA  1
         ACTR  &$_LIT*3+200
         AIF   (&$_CSECT_NO GT 1).LIT42
.*--loop
.LIT41   AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80       LOOP
&N       SETA  &N+1                                  LOOP
         AIF   (&N LE &$_LIT).LIT41                  LOOP
.*--endloop
         AGO   .LIT50
.LIT42   ANOP
.*--loop
.LIT422  AIF   ('&$_LITS_CSECT(&N)' EQ '&SYSECT2' AND                  X
               '&LIT' EQ '&$_LITS(&N)').LIT80 LOOP
&N       SETA  &N+1                                  LOOP
         AIF   (&N LE &$_LIT).LIT422                 LOOP
.*--endloop
.LIT50   ANOP
&$_LIT   SETA  &$_LIT+1
&$_LITS(&$_LIT) SETC '&LIT'
&$_LITS_CSECT(&$_LIT) SETC '&SYSECT2'
.LIT55   ANOP
.*NOTE 0,' &$_LIT &$_LITS_CSECT(&$_LIT) &SYSECT'
.*NOTE 0,'&$_CSECT_NO &$_CSECT(1) &$_CSECT(2) &$_CSECT(3) &$_CSECT(4)'
.**            &$_LITS(9999)           LITERALS
&N       SETA  &$_LIT
.LIT80   ANOP                               generate remote literal
&N       SETA  &N+1000
         AIF   (&LAST).LIT86
         DC    X'40',AL1(&L),AL2($LIT&N-*)
         AGO   .LIT90
.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)
.LIT90   ANOP
&$_FEAT(1) SETB 1                      LITERAL
.LIT99   ANOP
.*--------------------------------------------------------------------*
&I       SETA  1+&I                              LOOP
         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP
.*ENDLOOP
&LOCTR1  LOCTR
         AGO   .MEND
.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'
         AGO   .MEND
.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'
         AGO   .MEND
.**********************************************************************
.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *
.**********************************************************************
.GENL    ANOP
         AIF   (N'&SYSLIST(1) GT 3).GENL1R
&OPT2    SETC  '&SYSLIST(1,2)'
         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X
               AND '&OPT2' NE 'NO_CSECT').GENL1R
&OPT3    SETC  '&SYSLIST(1,3)'
         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R
         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R
         AGO   .GENL1D
.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'
&OPT2    SETC  ''
&OPT3    SETC  ''
.GENL1D  ANOP
&STRBLANKS SETA 2
         AIF   (D'$LTORG).GENL1F             CSECT-ONLY
&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1
.GENL1F  ANOP
&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'
&STR     SETC  '&STRING_MACRO_VERSION'
         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'
         AIF   (&$_LIT EQ 0).GENL3
&STR     SETC  '*CSECT'
.*LOOP
.GENL2   ANOP                                LOOP
&N       SETA  &N+1                          LOOP
&I       SETA  &N+1000                       LOOP
.*MNOTE *,'&$_LITS_CSECT(1) &$_LITS_CSECT(&N) &N &I'
         AIF   ('&STR' EQ '&$_LITS_CSECT(&N)').GENL2L
&STR     SETC  '&$_LITS_CSECT(&N)'           LOOP
&LOCTR1  SETC  '$LITERAL'                    LOOP
         AIF   ('&$_CSECT(1)' EQ '&$_LITS_CSECT(&N)').GENL2D
&LOCTR1  SETC  '$LITERAL_&STR'               LOOP
.GENL2D  ANOP                                LOOP
&LOCTR1  LOCTR
.GENL2L  ANOP                                LOOP
$LIT&I   DC    &$_LITS(&N)
         AIF   (&N LT &$_LIT).GENL2          LOOP
.*ENDLOOP
.GENL3   ANOP
         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8
&ARMODE  SETB  ('&OPT2' EQ 'AR_MODE')
.**********************************************************************
.*                                                                    *
.*       STRING SUB-ROUTINE                                           *
.*                                                                    *
.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *
.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *
.*                                                                    *
.**********************************************************************
         AIF   ('&OPT3' EQ 'LOCTR').GENL4L
@STRING  CSECT
@STRING  RMODE ANY
         AGO   .GENL4X
.GENL4L  PUSH  USING                   GENERATE,LOCTR
         DROP
@STRING@ LOCTR
@STRING  DS    0H                      ALIGNMENT
.GENL4X  ANOP
@00      EQU   0                       WORK REGISTER
@01      EQU   1                       WORK REGISTER
@02      EQU   2                       WORK REGISTER
@03      EQU   3                       WORK REGISTER
@04      EQU   4                       WORK REGISTER
@05      EQU   5                       WORK REGISTER
@06      EQU   6                       WORK REGISTER
         AIF   (NOT &ARMODE).ARMODE1X
@07      EQU   7                       WORK REGISTER
@08      EQU   8                       WORK REGISTER
@09      EQU   9                       WORK REGISTER
@10      EQU   10                      WORK REGISTER
@11      EQU   11                      WORK REGISTER
@12      EQU   12                      WORK REGISTER
.ARMODE1X ANOP
@13      EQU   13                      CALLER'S SAVE AREA
@14      EQU   14                      WORK REGISTER
@15      EQU   15                      BASE REG
         USING @STRING,@15
         USING @STRSAVE,@13
         B     @STR003                 BRANCH AROUND EYE-CATCHER
         AIF   (&ARMODE).ARMODE2Y
         DC    C'@STRING/370 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'
@STR003  STM   @14,@06,12(@13)         Save caller's registers
         SLR   @06,@06                 R6=0
&LAE     SETC  'LA'
         AGO   .ARMODE2X
.ARMODE2Y ANOP
         DC    C'@STRING/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'
@STR002  DC    H'2'
@STR003  STM   @14,@12,12(@13)         SAVE REGS (DEBUGGING ONLY)
.*+++    BSM   @14,0                   Set AMODE when invoked via BAL
         AH    @14,@STR002-@STRING(@15,0) POINT PAST PARM-LIST OFFSET
         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS
         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET
         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET
         LAE   @06,0                   R6=0 AR6=0
         CPYA  @14,@06                 AR14=0
         CPYA  @15,@06                 AR15=0
&LAE     SETC  'LAE'
.ARMODE2X ANOP
         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET
         ALR   @06,@06                 PICK UP PARM-LIST OFFSET
         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST
         USING @STRSCON,@06
         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         BAL   @14,@STRS2A             GET ADDRESS IN R2
         &LAE  @04,0(,@02)             KEEP ADDRESS OF "INTO" FIELD
         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO
         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         BAL   @14,@STRS2A             GET LENGTH IN R2
         LR    @05,@02                 KEEP LENGTH OF "INTO" FIELD
         CR    @05,@04                 END ADDRESS?
         BL    @STR282                 NO, JUMP
         SR    @05,@04                 CALCULATE LENGTH
         AIF   (NOT &ARMODE).ARMODE5N
@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK
.*SLAC   DC    X'B247,0040'            SLAC assembler error
         AGO   .ARMODE5X
.ARMODE5N ANOP
@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER
.ARMODE5X ANOP
.**********************************************************************
.*       MOVE FIELDS TO OUTPUT AREA                                   *
.**********************************************************************
         &LAE  @06,@STRNEXT            POINT TO 1ST FIELD DESC
         USING @STRPARM,@06
.*LOOP
@STR310  EQU   *
         AIF   (NOT &$_FEAT(1)).FEAT1A
         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?
         BO    @STR372                 YES, JUMP
.FEAT1A  ANOP
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A
         TM    @STRFLAG,@STRREG        REGISTER?
         BO    @STR323                 YES, JUMP
.FEAT23A ANOP
         AIF   (NOT &$_FEAT(12)).FEAT12A
         CLI   @STRSCON,X'E0'          IS IT %TIME ?
         BE    @STR378                 YES, JUMP
.FEAT12A ANOP
.*
.*       IT'S A FIELD (SCON)
.*
         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         BAL   @14,@STRS2A             GET LENGTH IN R2
         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)
         LTR   @03,@02                 KEEP/TEST LENGTH
         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT
         AGO   .FEAT9E2
.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH
         BP    @STR313                 LENGTH POSITIVE, JUMP
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK
@STR313  EQU   *
.FEAT9E2 ANOP
         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         BAL   @14,@STRS2A             GET ADDRESS IN R2
         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO
         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         CR    @03,@02                 END ADDRESS?
         BL    @STR314                 NO, JUMP
         LA    @00,X'0080'             PSA ADDRESS
         CLR   @02,@00                 PSA REFERENCE?
         BL    @STR314                 YES, JUMP
         SR    @03,@02                 CALCULATE LENGTH
@STR314  EQU   *
         AIF   (NOT &$_FEAT(6)).FEAT6A
         TM    @STRFLAG,@STRBIN        BINARY FIELD?
         BO    @STR328                 YES, JUMP
.FEAT6A  ANOP
         AIF   (NOT &$_FEAT(4)).FEAT4A
         TM    @STRFLAG,@STRPACK       PACKED FIELD?
         BO    @STR351                 YES, JUMP
.FEAT4A  ANOP
         AIF   (NOT &$_FEAT(7)).FEAT7A
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         BO    @STR376                 YES, JUMP
.FEAT7A  ANOP
.*
.*       TRUNCATE CHARACTER STRING
.*
         AIF   (NOT &$_FEAT(11)).FEAT11A
         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN
         BNE   @STR390                 NO STRING TRUNCATION, JUMP
         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD
@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP
         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP
         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP
         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP
         B     @STR398                 BLANK FIELD, DO NOT EDIT
         AGO   .FEAT11B
.FEAT11A ANOP
         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B
         B     @STR390                 EDIT
.FEAT11B ANOP
.*
.*       REGISTER (R0-R13)
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B
         AIF   (NOT &ARMODE).ARMODE7N
@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31
         CLI   @STRSCON+1,@06          IS THIS R7-R13?
         BH    @STR323R                YES, JUMP
         LR    @07,@01                 SAVE R1 (R)
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREG  @00,@06                 RELOAD CALLER'S R0-R6
         EX    @07,@STR323L            COPY R0-R6 VALUE
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         B     @STR323T
@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT
@STR323R EQU   *
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    @01,@STR323L            COPY R7-R13 INTO R0
         AGO   .ARMODE7X
.ARMODE7N ANOP
@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT
@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31
         EX    @01,@STR323L            COPY R7-R13 INTO R0
         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?
         BNL   @STR323T                YES, JUMP
         SLL   @01,2                   R1= 000000BB BASE * 4
         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6
.ARMODE7X ANOP
@STR323T EQU   *
         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX
         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         BNO   @STR330                 NO, EDIT FWD
.FEAT2H  ANOP
         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK
         LA    @03,8                   OUTPUT LENGTH
         B     @STR376X                EDIT IN HEX
.FEAT3R  ANOP
         AIF   (NOT &$_FEAT(6)).FEAT23B
         B     @STR330                 EDIT R0
.FEAT23B ANOP
.*
.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)
.*
         AIF   (NOT &$_FEAT(6)).FEAT6B
@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**
@STR328  SLR   @00,@00
         EX    @03,@STR328M            LOAD THE BINARY VARIABLE
.FEAT6B  ANOP
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C
@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL
         AIF   (NOT &$_FEAT(4)).FEAT6C
         B     @STR361                 EDIT DWD
.FEAT6C  ANOP
.*
.*       PACKED FIELD
.*
         AIF   (NOT &$_FEAT(4)).FEAT4B
@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD
@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD
         BALR  @14,0
         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?
         LA    @03,1(,@03)              (NEXT BYTE)
         BNOR  @14                     NO, LOOP MORE
         SLR   @03,@02                 GET LENGTH OF PACKED FIELD
         BCTR  @03,0
         EX    @03,@STRZAP             EXECUTE ZAP
         AIF   (NOT &$_FEAT(5)).FEAT4B
         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?
         BNL   @STR375                 YES, JUMP
.FEAT4B  ANOP                          PACKED
.*
.*       EDIT @STRDWD (BIN, REG, PACKED)
.*
         AIF   (NOT &$_FEAT(8)).FEAT8B
@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH
         LA    @03,X'003F'             MASK FOR "AND"
         NR    @03,@00                 OUTPUT LENGTH
         MVC   @STRWK16(16),@STRMASK   EDIT MASK
.*
.*       LEFT-JUSTIFICATION (NUMERIC)
.*
         AIF   (NOT &$_FEAT(9)).FEAT9B
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         BNO   @STR367                 NO, JUMP
         &LAE  @01,@STRWK16+15         PREVENT BAD R1
         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL
         BNM   @STR362                 skip if not a negative number
         BCTR  @01,0                   R1 = significance start ptr -1
         MVI   0(@01),C'-'             sink negative sign in front
@STR362  &LAE  @02,0(,@01)             FIRST STRING POSITION
         LTR   @03,@03                 CHECK OUTPUT LENGTH
         BNZ   @STR363                 JUMP IF NOT ZERO
.*       L0    (LEFT JUSTIFIED, NO PADDING)
         &LAE  @03,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @03,@02                 COMPUTE STRING LENGTH
         B     @STR390                 MOVE FIELD TO OUTPUT LINE
.*       L1-L63 (LEFT JUSTIFIED, PADDING)
@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN
         BNH   @STR364                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH
         AIF   (NOT &ARMODE).ARMODE8N
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 LENGTH WITH PADDING
         AGO   .ARMODE8X
.ARMODE8N ANOP
         LR    @00,@04                 POINTER IN OUTPUT LINE
         LR    @01,@03                 LENGTH WITH PADDING
.ARMODE8X ANOP
         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @03,@02                 COMPUTE STRING LENGTH
         B     @STR392                 MOVE FIELD TO OUTPUT LINE
@STR367  EQU   *
.FEAT9B  ANOP
         AIF   (NOT &$_FEAT(10)).FEAT10B
         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?
         BNO   @STR368                 NO, JUMP
         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'
@STR368  EQU   *
.FEAT10B ANOP
         &LAE  @01,@STRWK16+15         PREVENT BAD R1
         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL
         BNM   @STR369                 skip if not a negative number
         BCTR  @01,0                   R1 = significance start ptr -1
         MVI   0(@01),C'-'             sink negative sign in front
@STR369  &LAE  @02,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @02,@03                 FIRST STRING POSITION
.FEAT8B  ANOP
.*
.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)
.*       Short Literal (low-order 4 bits of @STRFLAG contains length)
.*       BLANKS  (@STRSCON=ZERO)
.*
         AIF   (NOT &$_FEAT(1)).FEAT1B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR372  LA    @01,7                   mask for NR
         &LAE  @02,@STRLEN2            1st byte of short literal
         IC    @03,@STRFLAG            pick up flags+length
         NR    @03,@01                 R3 has length of short literal
         BNZ   @STR390                 short literal, go move it
         SLR   @02,@02                 Clear Address Register
         IC    @03,@STRLEN2            GET LITERAL LENGTH
         TM    @STRFLAG,@STRX40        string of spaces?
         BO    @STR390                 yes, go move them
         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET
         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS
.FEAT1B  ANOP
.*
.*       CONVERT JULIAN DATE TO YYMMDD
.*
         AIF   (NOT &$_FEAT(5)).FEAT5F
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR375  LA    @00,248                 MASK FOR 'SLR'
         SLR   @01,@01
         IC    @01,@STRLEN2            248-255
         SLR   @01,@00                 000-007
         LA    @00,12                  L'@STR375W
         MR    @00,@00                 COMPUTE OFFSET
         &LAE  @01,@STR375W(@01)       ENTRY IN "TR" MASK TABLE
         SLR   @03,@03
         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)
         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT
         BNZ   @STR375B                NO, JUMP                    @JDT
@STR375Z &LAE  @02,@STRBLANKS          WORK AREA
&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS
         B     @STR390                 MOVE FIELD TO OUTPUT LINE
@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248
         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249
         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250
         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251
         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252
         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253
.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254
.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255
@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'
         DC    P'999'                  Prevent S0C7 with 90366
@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?
         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)
         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20
         BE    @STR375C                CC=01, USE CC=20
         CLI   @STRDWD+4+1,X'50'       YY<50?
         BL    @STR375C                YES, USE CC=20
         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19
@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?
         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER
         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)
         TM    @STRDWD+4+1,X'01'       ODD YEARS
         BO    @STR375N                  AREN'T LEAP YEARS
         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992
         BNM   @STR375L                MIXED IN 1982/1990
.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD
@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?
         BNH   @STR375L                NO, JUMP
         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD
.*--LOOP WHILE DDD > 0
@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH
         LA    @02,2(,@02)             NEXT ENTRY IN "MONTHS" TABLE
         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD
         BP    @STR375L
.*--ENDLOOP
         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST "SP" INSTRUCTION
         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??
         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD
         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD
         MVC   @STRWK16+8(1),1(@01)    SEPARATOR
         &LAE  @02,@STRWK16+9          WORK AREA
         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK
         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT
.FEAT5F  ANOP                          JDATE
.*
.*       HEX STRING
.*
         AIF   (NOT &$_FEAT(7)).FEAT7B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK
@STR376  LA    @00,8                   MAX LENGTH
         CLR   @03,@00                 CHECK LENGTH
         BNH   @STR376B                JUMP IF LE 8
         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH
@STR376B LR    @01,@03                 INPUT LENGTH
         BCTR  @01,0
         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE
         ALR   @03,@03                 OUTPUT LENGTH
         AGO   .FEAT37B
.FEAT7B  ANOP
         AIF   (NOT &$_FEAT(3)).FEAT37C
         B     @STR390                 MOVE STRING TO OUTPUT LINE
.FEAT37B ANOP
@STR376X &LAE  @02,@STRWK16            WORK AREA
         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR "TR"
         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR "TR"
         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'
.FEAT37C ANOP
.*
.*       %TIME
.*
         AIF   (NOT &$_FEAT(12)).FEAT12B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STRTIME DC    X'4021207A20207A20204B20204000' 0X:XX:XX.XX
@STR378  LR    @02,@15                 SAVE BASE REG
         TIME  DEC                     GET HHMMSSHH
         LR    @15,@02                 RESTORE BASE REG
         ST    @00,@STRDWD             STORE HHMMSSHH
         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK
         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS.HH
         &LAE  @02,@STRWK16+1          WORK AREA
         LA    @03,12                  HH:MM:SS.HH+ SPACE
 ORG *-4
         LH    @03,@STRFLEN            length is 5 8 11 12
.FEAT12B ANOP
.*MOVE
@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN
         BNH   @STR391                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH
         AIF   (NOT &ARMODE).ARMODE39N
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 PASS REMAINING LENGTH
         AGO   .ARMODE39X
.ARMODE39N ANOP
         LR    @00,@04                 POINTER IN OUTPUT LINE
         LR    @01,@03                 PASS REMAINING LENGTH
.ARMODE39X ANOP
         LTR   @02,@02                 BLANKS?
         BNZ   @STR392                 NO, JUMP
         SLR   @03,@03                 YES, ZERO LENGTH
@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS
         AIF   (NOT &ARMODE).ARMODE44N
         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE
         LR    @04,@08                 NEW POINTER IN OUTPUT LINE
         AGO   .ARMODE44X
.ARMODE44N ANOP
         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE
         LR    @04,@00                 NEW POINTER IN OUTPUT LINE
.ARMODE44X ANOP
@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR
         BO    @STR399                 Done, exit
         AIF   (NOT &$_FEAT(1)).FEAT1C
         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?
         BM    @STR398L                Literal, not spaces
         BZ    @STR398X                Neither literal nor spaces
         LA    @06,@STRSCON            2-byte entry for blank spaces
         B     @STR310                 PROCESS NEXT ENTRY
@STR398L LA    @01,7                   mask for NR
         IC    @03,@STRFLAG            pick up flags+length
         NR    @03,@01                 R3 has length of short literal
         BZ    @STR398T                not an in-line literal, jump
         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal
         B     @STR310                 PROCESS NEXT ENTRY
@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal
         B     @STR310                 PROCESS NEXT ENTRY
.FEAT1C  ANOP
@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY
         B     @STR310                 PROCESS NEXT ENTRY
.*ENDLOOP
.*
.*       END-OF-LINE PROCESSING - PAD WITH BLANKS
.*
@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING
         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING
.***     DROP  @06,@13,@15
         AIF   (&ARMODE).ARMODE52Y
         LA    @14,2                   INCREMENT
         AL    @14,12(,@13)            RETURN ADDRESS
         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD
         SL    @15,8(,@13)             CALCULATE LENGTH USED
         MVCL  @04,@00                 PAD WITH BLANKS
         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS
         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL
         OI    15(@13),1               SIMULATE "T" OPTION OF RETURN
         BR    @14                     RETURN TO CALLER
         AGO   .ARMODE52X
.ARMODE52Y ANOP
         LA    @15,3                   MODIFIABLE AREA
         ESTA  @14,@15                 R14 = START OF OUTPUT AREA
         LR    @15,@04                 END OF OUTPUT AREA
         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA
         MVCL  @04,@00                 PAD WITH BLANKS
         EREG  @00,@14                 RESTORE WORK REGISTERS
         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL
         OI    15(@13),1               SIMULATE "T" OPTION OF RETURN
         PR                            RETURN TO CALLER
.ARMODE52X ANOP
.*
         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T
@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION
.FEAT37T ANOP
         AIF   (NOT &$_FEAT(8)).FEAT8T
@STRMASK DC    X'4020202020202020,2020202020202120'
.FEAT8T  ANOP
.**********************************************************************
.*       Convert S-con to address                                     *
.*             Input: GPR2 points to an S-CON in the remote parm list *
.*             Output: GPR2 contains the address                      *
.**********************************************************************
@STRS2A  SLR   @00,@00
         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD
         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....
         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)
         AIF   (&ARMODE).ARMODE88Y
         CLI   0(@02),@06*16+15        R7-R13?
         BH    @STRS2A3                YES, JUMP
.*BASE REG IS R0-R6
         LTR   @02,@00                 IS R0 THE BASE REG?
         BNZ   @STRS2A2                NO, JUMP
         LTR   @02,@01                 IS THIS A PSA ADDRESS?
         BNZR  @14                     YES, GOBACK
@STRS2A2 SLL   @02,2                   R2= 000000BB BASE * 4
         L     @02,20(@02,@13)         PICK UP BASE REG VALUE
         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL
         BR    @14
.*BASE REG IS R7-R13
@STRS2A3 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)
         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL
         BR    @14
@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL
         AGO   .ARMODE88X
.ARMODE88Y ANOP                        AR_MODE=YES
         SLL   @00,2                   MULT BY 4
         CLI   0(@02),@06*16+15        R7-R13?
         BH    @STRS2A6                YES, JUMP
.*BASE REG IS R0-R6
         LTR   @02,@00                 IS R0 THE BASE REG?
         BNZ   @STRS2A5                NO, JUMP
         LTR   @02,@01                 IS THIS A PSA ADDRESS?
         BNZR  @14                     YES, GOBACK
         EREG  @00,@00                 POP R0
         LAE   @02,0                   R2=0 AR2=0
         LR    @02,@00                 PASS R0 VALUE
         LA    @02,0(,@02)             CLEAN UP
         BR    @14                     GOBACK
.*BASE REG IS R1-R6
@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)
         LR    @08,@01                 SAVE R1 (DDD)
         LR    @09,@03                 SAVE R3
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREG  @01,@06                 RELOAD CALLER'S R1-R6
         EX    0,@STRS2A7-4(@07)       ADD BASE REG VALUE TO DISPL
         LR    @03,@09                 RESTORE R3
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         BR    @14                     GOBACK
.*BASE REG IS R7-R13
@STRS2A6 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    0,@STRS2A7-4(@02)       ADD BASE REG VALUE TO DISPL
         BR    @14                     GOBACK
@STRS2A7 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL
.ARMODE88X ANOP
         AIF   ('&OPT3' EQ 'LOCTR').GENL7L
@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '
         AGO   .GENL7X
.GENL7L  ANOP
@STRBLANKS DC  CL&STRBLANKS.' '
.GENL7X  ANOP
@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT
         DROP  @06,@13,@15
.**********************************************************************
.*       WORK AREA (CALLER'S SAVE AREA)                               *
.**********************************************************************
@STRSAVE DSECT                         24-BYTE WORK AREA
         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)
@STRWK16 DS    F'7,8,9,10'             WORK AREA
@STRDWD  DS    D'1112'                 WORK AREA
@STRPARM DSECT
@STRFLAG DS    B                   +0  FORMAT, FLAGS
@STRLAST EQU   X'80'                     LAST ENTRY
@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET
@STRX40  EQU   X'20'                   String of Spaces
.*             X'0F'                   CONVERSION REQUIRED
.*                                     or length of short literal
@STRHEX  EQU   X'08'                     HEXADECIMAL
@STRBIN  EQU   X'04'                     BINARY
@STRPACK EQU   X'02'                     PACKED
@STRREG  EQU   X'01'                     REGISTER
@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH
.*                                     or start of short literal
@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION
@STRZERO EQU   X'40'                     LEADING ZEROES
.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.
@STRSCON DS    S                   +2  FIELD ADDRESS
@STRFLEN DS    S                   +4  FIELD LENGTH
@STRNEXT EQU   *                   +6
         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY
         AIF   (D'$STRING).MEND99      CSECT-ONLY
$LTORG   LOCTR
         AIF   ('&OPT3' EQ 'LOCTR').GENL9L
         CNOP  0,4
$STRING  BALR  @15,0                   LOCAL BASE
         L     @15,6(@15,0)            ROUTINE ADDRESS           00
         BR    @15                     GO TO @STRING             04
         AGO   .GENL9
.GENL8   ANOP                          GENERATE,NOCSECT
&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE
&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL
$LTORG   LOCTR
         CNOP  0,4
$STRING  BALR  R15,0                   LOCAL BASE
         L     R15,6(R15,0)            ROUTINE ADDRESS           00
         BR    R15                     GO TO @STRING             04
.GENL9   ANOP
         DC    V(@STRING)              ROUTINE ADDRESS           06
.* MNOTE   1,'&$_CSECT_NO '
         AIF   (&$_CSECT_NO EQ 1).MEND
&I       SETA  2
.*loop
.GENL8K  ANOP
.* MNOTE   1,'&$_CSECT(&I) '
         AIF   ('&$_CSECT(&I)' EQ '').MEND
&STR     SETC  '&$_CSECT(&I)'
$LTORG_&STR LOCTR
         CNOP  0,4
$STRING_&STR BALR R15,0                LOCAL BASE
         L     R15,6(R15,0)            ROUTINE ADDRESS           00
         BR    R15                     GO TO @STRING             04
         DC    V(@STRING)              ROUTINE ADDRESS           06
&I       SETA  1+&I
         AGO   .GENL8K
.*endloop
         AGO   .MEND
.GENL9L  POP   USING                   GENERATE,LOCTR
$STRING  BASR  R15,0                   Local Base
         AH    R15,6(R15,0)            Add offset to @STRING routine
         BR    R15                     Branch to @STRING
         DC    Y(@STRING-$STRING-2)    Offset to @STRING Routine
.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99
         POP   PRINT
.MEND99  MEND
         EJECT
**********************************************************************
**********************************************************************
********* MVS TEST PROGRAM FOR THE 'STRING' MACRO ********************
**********************************************************************
**********************************************************************
**       STRING (GENERATE,AR_MODE)
**       END
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
TESTPGM  START X'027000'
TESTPGM  AMODE 24                      (PRE-SMS PUT)
         BALR  R12,0
         USING *,R12
 LOAD EP=SYSDEBUG,ERRET=DEBUG111
 LR R15,R0
 BASSM R14,R15
DEBUG111 EQU *
*STRING 1X,INTO=XXX
*RC8     STRING ((R1),,R**B),((R1),,R22Z),((R1),,R16B),INTO=XXX
         OPEN  (SYSPRINT,OUTPUT)
         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX
         PUT   SYSPRINT,XXX
         STRING 'AMPERSAND=&& AND APOSTROPHE='' ',INTO=XXX
         PUT   SYSPRINT,XXX
RBPREFIX EQU   *
RBINTCOD EQU   *+6,2,C'H'
         L     R1,PSATOLD-PSA(0,0)     TCB
         L     R1,0(,R1)               TCBRBP
         L     R2,PSAAOLD-PSA(0,0)     ASCB
R2ASCB   USING ASCB,R2
         L     R8,=X'88888888'
         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X
               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X
               ((R8),,X),1X,           COM-REG ADDR                    X
               'ASID=',(R2ASCB.ASCBASID,,X),1X,                        X
               PARM1,1X,               MAIN PGM NAME                   X
               INTO=XXX
         PUT   SYSPRINT,XXX
*
         LA    R2,XXX
         STRING 1X,INTO=((R2),8)
         MACRO                                       JDATE MACRO
        @JDATE &DATE                                 JDATE MACRO
         LA    R1,=P'&DATE'                          JDATE MACRO
*** STRING ((R1),P),2X,((R1),P),INTO=XXX
         STRING ((R1),P,R5Z),                        JDATE MACRO       X
               2X,((R1),P,YYMMDD),                   JDATE MACRO       X
               2X,((R1),P,YY/MM/DD),                 JDATE MACRO       X
               2X,((R1),P,DD/MM/YY),                 JDATE MACRO       X
               2X,((R1),P,MM/DD/YY),                 JDATE MACRO       X
               2X,((R1),P,YYYYMMDD),                 JDATE MACRO       X
               2X,((R1),P,YYYY-MM-DD),               JDATE MACRO       X
               INTO=XXX                              JDATE MACRO
         PUT   SYSPRINT,XXX                          JDATE MACRO
         MEND                                        JDATE MACRO
        @JDATE 90058
        @JDATE 91059
        @JDATE 93060
        @JDATE 94365
        @JDATE 80058
        @JDATE 84059
        @JDATE 88060
        @JDATE 92061
        @JDATE 00366
         LA    R2,1234
         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X
               ' 1234=',((R2),,R4Z)
         PUT   SYSPRINT,XXX
         L     R1,CVTPTR(0,0)
         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R0,1000
         LA    R3,0033
         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X
               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X
               ((R3),,R9B),'/',INTO=XXX
         LR    R4,R15                   LENGTH USED
         PUT   SYSPRINT,XXX
         STRING WWWW,                                                  X
               (4(R13),4,X),'''',(4(R13),F),'''',                      X
               (4(R13),F,L),'''',                                      X
               (4(R13),F,L11),'''',                                    X
               (4(R13),F,Z9),'''',                                     X
               8X,'R4=',((R4),,L),      LENGTH USED                    X
               INTO=XXX
         PUT   SYSPRINT,XXX
         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X
               INTO=XXX
         PUT   SYSPRINT,XXX
         STRING (%TIME,5),'|',(%TIME,8),'|',(%TIME,11),'|',(%TIME,12), X
               '|',INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R3,17
         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)
         PUT   SYSPRINT,XXX
         STRING C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                   +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
         AIF   ('&SYSVER' EQ 'ASMH').HLASM99
PSABASE  USING PSA,R0
         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
.HLASM99 ANOP
         BALR  R0,0
         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX
         PUT   SYSPRINT,XXX
         STRING 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX
         PUT   SYSPRINT,XXX
         SLR   R0,R0
         STRING 'R0=',((R0),,X),'   CTR2=',(CTR2,P,L),'.',INTO=XXX
         PUT   SYSPRINT,XXX
*
         CALL  TCSECT2              <- 2nd CSECT
*
         CALL  TCSECT3              <- 3rd CSECT
*
AMODE31  LA    R12,0(,R12)             BALR->BASR
         L     R15,=A(*+X'80000006')   AMODE=31
         BSM   0,R15                   AMODE=31
         L     R1,=A(@STRING)          point at CSECT
         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?
         BNE   EXIT                    no, prevent S0E0
         DSPSERV CREATE,                                               X
               NAME==CL8'STRING00',    C'STRING00'                     X
               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X
               STOKEN=DSPCSTKN,                                        X
               ORIGIN=DSPCORG
         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET
         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE
         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)
         SAC   512                     MODE=AR
 LAM R14,R6,TESTPGM+40                 S0E0-28
         STRING WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)
         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE
         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)
         STRING (2048+L'WWWW(R2),30,T),INTO=XXX
         SAC   0                       MODE=AR OFF
         PUT   SYSPRINT,XXX            AR_MODE WORKS OK
*
EXIT     SLR   R15,R15
         SVC   3                       GOBACK
*
*        2ND CSECT
*
TCSECT2  CSECT
         BAKR  R14,0
         LR    R10,R15
         USING TCSECT2,R10
         STRING '----> TCSECT2 STRING <----  R516',INTO=XXX
         PUT   SYSPRINT,XXX
         L     R1,CVTPTR(0,0)
         STRING 'CVTDATE=',(56(R1),4,X),',R8=',((R8),,L),INTO=XXX
         PUT   SYSPRINT,XXX
         PR
         DROP
*
*        3RD CSECT with NO name
*
         CSECT                           no-name
         ENTRY TCSECT3
TCSECT3  BAKR  R14,0
         LR    R12,R15
         USING TCSECT3,R12
         L     R10,PRT3ADDR
         USING SYSPRINT,R10
         STRING '----> TCSECT3 STRING <----  R517',INTO=XXX
         PUT   SYSPRINT,XXX
         L     R1,CVTPTR(0,0)
         STRING 'CVTDATE=',(56(R1),4,X),',R9=',((R9),,L),INTO=XXX
         PUT   SYSPRINT,XXX
         PR
         DS    0F
PRT3ADDR DC    A(SYSPRINT)
*
TESTPGM  CSECT
D1       DC    C'D1-----D1    '
WWWW     DC    C'WWWW'
CTR1     DC    P'1'
CTR2     DC    P'-33'
PARM1    DC    C'<-PARM1->'
PARM2    DC    C'<-PARM2->'
DSPCSTKN DS    XL8                  0  AS TOKEN
DSPCALET DS    F                    8  ALET
DSPCORG  DS    F                   12  ORIGIN
HDRBLKS  DC    F'100'
CVTPTR   EQU   0016,4,C'A'
SYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121
XXX      DS    CL121
*
XYZ      DSECT
         STRING GENERATE
**       STRING (GENERATE,NO_CSECT) -\
**       STRING (GENERATE,AR_MODE)  -/
**       STRING (GENERATE,,LOCTR)
**       STRING (GENERATE,AR_MODE,LOCTR)
**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination
         YREGS
PSA      DSECT
PSATOLD  EQU   *+X'21C',4,C'A'
PSAAOLD  EQU   *+X'224',4,C'A'
ASCB     DSECT
ASCBASID EQU   *+36,2,C'X'
         END
//SYSPRINT DD SYSOUT=*
//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//*
//GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,2)
//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)
//SYSLOUT  DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//SYSDEBUG DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
