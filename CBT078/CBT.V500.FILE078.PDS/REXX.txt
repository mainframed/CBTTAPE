./ ADD NAME=ACFCOMP  0129-95291-98280-1333-00094-00042-00000-REXX
/* REXX */
ADDRESS ISREDIT
"ISREDIT MACRO (PARM)"
TRACE
IF TRANSLATE(parm) = 'HELP' |,
   parm = '?' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#ACFCOMP)"
    EXIT 0
  END

"ISREDIT SAVE"
"ISREDIT (MEM) = MEMBER"
"ISREDIT (DS) = DATASET"

ADDRESS TSO
"ACFCOMP '"ds"("mem")' STORE FORCE"

/* Resource rule ? */
"ISREDIT FIND FIRST 'TYPE('"
IF rc = 0 THEN
  DO
    "ISREDIT (LINE) = LINE .ZCSR"
     name = 'R'||SUBSTR(line,POS('TYPE(',line)+5,3)
     show_header = '-- RESIDENT INFOSTORAGE DIRECTORIES --'
  END
ELSE
  DO
    name = mem
    show_header = '-- RESIDENT ACCESS RULES --'
  END

QUEUE 'SHOW RESIDENT'
QUEUE 'END'
x = OUTTRAP("trap.","*")
ADDRESS TSO
"ACF"
x= OUTTRAP("off")

showres = ''
DO line = 1 to trap.0
  IF trap.line = show_header THEN
    DO rar = line+1 to trap.0
      showres = showres||trap.rar||' '
      IF trap.rar = '  ' THEN
        LEAVE line
    END
END

showres = TRANSLATE(showres,' ',',')   /* Remove commas for WORDPOS */
IF WORDPOS(name,showres) > 0 THEN
  DO
    user_attr = GETATTR()              /* TSO attributes */
    /* Sysprog? */
    IF SUBSTR(user_attr,1,4) <> 'OPER' THEN
      DO
        zedsmsg = 'Not authorized'
        zedlmsg = 'You are not authorized to use operator commands'
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
        EXIT 12
      END

    /* Prevent SDSF panel from displaying after operator command */
    /* with optional mod to panel ISFPANEL or ISFPCU4x           */
    sdsfoper = 'END'
    ADDRESS ISPEXEC "VPUT (SDSFOPER) SHARED"

    IF WORDPOS('ACCESS',show_header) > 0 THEN
      DO
        action = 'RELOAD'
        resident = 'RESIDENT ACCESS RULE'
      END
    ELSE
      DO
        /* Remove 'R' from name */
        name = SUBSTR(name,2)
        action = 'REBUILD'
        resident = 'RESIDENT DIRECTORY'
      END

    /* Leave out NEWAPPL(ISF) or sdsfoper variable not passed */
    ADDRESS ISPEXEC,
      "SELECT PGM(ISFISP) PARM(/F ACF2,"action"("name"))"
    zedsmsg = 'ACF2 'action' issued'
    zedlmsg = 'ACF2 'action' issued for 'resident name
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
  END
EXIT

/* Source:  CBT Mods tape, Michael Botos  042685             */
/* J. KALINICH, X4521 */
/* Edit macro to compile the ACF2 rule being edited          */
/* Issue "F ACF2,RELOAD(rule)" or "F ACF2,REBUILD(dir)"      */
/* if rule is in the SHOW RESIDENT list                      */
./ ADD NAME=ACFTRAP  0166-96068-97113-1411-00070-00040-00000-REXX
/* REXX */
TRACE
ADDRESS ISREDIT
"ISREDIT MACRO (PARM) NOPROCESS"

parm = TRANSLATE(parm)
IF parm = "HELP" |,
   parm = "?" THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#ACFTRAP)"
    EXIT 0
  END

line = 1
DO FOREVER
  IF RIGHT(STRIP(input,T),1) = "-" THEN
    NOP          /* continuation, don't prompt */
  ELSE
    SAY ACF.     /* new subcommand, prompt */
  PARSE PULL input
  IF TRANSLATE(input) = "END" THEN
    LEAVE
  acf_cmds.line = input
  line = line + 1
END
command_count = line - 1

DO line = 1 TO command_count
  QUEUE acf_cmds.line
END
QUEUE "END"

x = OUTTRAP("trap.","*")
ADDRESS TSO
"ACF"
IF rc > 0 THEN
  DO
    zedsmsg = "rc="rc
    zedlmsg = "ACF command processor set a return code of "rc
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
  END
x= OUTTRAP("off")

IF parm = "DATA" |,
   parm = "NOTE" THEN
  NOP
ELSE
  parm = "NOTE"

"ISREDIT (TOP) = DISPLAY_LINES"
IF rc > 4 THEN
  top = '0'

DO line = trap.0 TO 1 BY -1
  acfout = trap.line
  "ISREDIT LINE_AFTER "top" = "parm"LINE (acfout)"
END
"ISREDIT LINE_AFTER "top" = MSGLINE 'ACF OUTPUT:'"
DO line = command_count TO 1 BY -1
  acfin = acf_cmds.line
  "ISREDIT LINE_AFTER "top" = NOTELINE (acfin)"
END
"ISREDIT LINE_AFTER "top" = MSGLINE 'ACF INPUT:'"

"ISREDIT LOCATE "top

EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO QUEUE ACF SUBCOMMANDS, TRAP OUTPUT FROM ACF,      */
/*  AND WRITE TO "=NOTE=" OR "DATA" LINES                          */
./ ADD NAME=ASA2PC   0120-96068-96082-0630-00044-00040-00000-REXX
/* REXX */
TRACE
ADDRESS ISREDIT
"ISREDIT MACRO (PARM) NOPROCESS"
IF TRANSLATE(parm) = 'HELP' |,
   parm = '?' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#ASA2PC)"
    EXIT 0
  END
"ISREDIT (DSN) = DATASET"
rc = LISTDSI("'"dsn"'" NORECALL)
IF sysreason > 0 THEN
  DO
    ADDRESS ISPEXEC
    zedsmsg = 'LISTDSI reason code 'sysreason
    zedlmsg = 'Look up LISTDSI reason code'
    "ISPEXEC SETMSG MSG(ISRZ001W)"
    "ISPEXEC SELECT PGM(QWIKREF1) PARM(T=LISTDSI) NEWAPPL(QWRF)"
    EXIT sysreason
  END
IF POS('A',sysrecfm) > 0 THEN
  DO
    "ISREDIT CHANGE ALL '1' X'0C' 1"        /* SKIP TO NEW PAGE */
/*--"ISREDIT CHANGE ALL ' ' X'..' 1"        /* SPACE 1 LINE  */--*/
    "ISREDIT CHANGE ALL '0' X'0D25' 1"      /* SPACE 2 LINES */
    "ISREDIT CHANGE ALL '-' X'0D250D25' 1"  /* SPACE 3 LINES */

    "ISREDIT EXCLUDE ALL"
    "ISREDIT FIND ALL '+' 1"                /* SUPPRESS SPACE */
    "ISREDIT DELETE ALL NX"
    "ISREDIT RESET EXCLUDED"
  END
ELSE
  DO
    ADDRESS ISPEXEC
    zedsmsg = 'No ASA control'
    zedlmsg = 'Dataset must have ASA print control characters'
    "ISPEXEC SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO CONVERT ASA PRINTER CONTROL TO ASCII CODE */
./ ADD NAME=CEILING  0112-96283-97029-1229-00045-00031-00000-REXX
/* rexx */
trace
numeric digits 32
say 'ceiling of -0   is 'ceiling(-0)
say 'ceiling of  0   is 'ceiling(0)
say 'ceiling of -1   is 'ceiling(-1)
say 'ceiling of  1   is 'ceiling(1)
say 'ceiling of  1.0 is 'ceiling(1.0)
say 'ceiling of  1.1 is 'ceiling(1.1)
say 'ceiling of  1.2 is 'ceiling(1.2)
say 'ceiling of  1.3 is 'ceiling(1.3)
say 'ceiling of  1.4 is 'ceiling(1.4)
say 'ceiling of  1.5 is 'ceiling(1.5)
say 'ceiling of  1.6 is 'ceiling(1.6)
say 'ceiling of  1.7 is 'ceiling(1.7)
say 'ceiling of  1.8 is 'ceiling(1.8)
say 'ceiling of  1.9 is 'ceiling(1.9)
say 'ceiling of -1.0 is 'ceiling(-1.0)
say 'ceiling of -1.1 is 'ceiling(-1.1)
say 'ceiling of -1.2 is 'ceiling(-1.2)
say 'ceiling of -1.3 is 'ceiling(-1.3)
say 'ceiling of -1.4 is 'ceiling(-1.4)
say 'ceiling of -1.5 is 'ceiling(-1.5)
say 'ceiling of -1.6 is 'ceiling(-1.6)
say 'ceiling of -1.7 is 'ceiling(-1.7)
say 'ceiling of -1.8 is 'ceiling(-1.8)
say 'ceiling of -1.9 is 'ceiling(-1.9)
say 'ceiling of -2.0 is 'ceiling(-2.0)
say 'ceiling of -2.1 is 'ceiling(-2.1)
say 'ceiling of -2.5456789 is 'ceiling(-2.5456789)
say 'ceiling of -2.0000000054567899 is 'ceiling(-2.0000000054567899)
say 'ceiling of +2.0000000054567899 is 'ceiling(+2.0000000054567899)
say 'ceiling of -3 is 'ceiling(-3)
exit

ceiling: procedure
/* rexx      smallest integer greater than or equal       */
parse arg number
if number > 0 then
  if (number - trunc(number)) > 0 then
    number = number + 1
return trunc(number)

/* J. KALINICH, X4521 */
/* REXX CEILING FUNCTION - SMALLEST INTEGER GREATER THAN OR EQUAL    */
./ ADD NAME=CLONEID  0155-95137-98300-0925-00144-00056-00000-REXX
/* REXX */
TRACE

ADDRESS TSO
"NEWSTACK"
ARG modelid
QUEUE 'LIST 'modelid
QUEUE 'END'
x = OUTTRAP("lids.","*")

"ACF"

acfrc = rc
x= OUTTRAP("off")
"DELSTACK"

IF acfrc > 0 THEN
  DO
    zedsmsg = 'ACF LIST rc='acfrc
    zedlmsg = 'List failure, check for misspelled logonid'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END

"NEWSTACK"
DO line = 1 TO lids.0
  SELECT
    WHEN SUBSTR(lids.line,1,1) ¬= ' ' THEN
      NOP
    WHEN SUBSTR(lids.line,2,21) = ' ' THEN
      DO

        /* Add other sections per the ACFFDR specification */

        IF section = 'PRIVILEGES' |,
           section = 'TSO' |,
           section = 'CICS' |,
           section = 'IMS' |,
           section = 'M204' |,
           section = 'IDMS' |,
           section = 'MUSASS' |,
           section = 'RESTRICTIONS' |,
           section = 'DFP' |,
           section = 'KEYPLUS' THEN
        CALL lid_fields
      END
    WHEN SUBSTR(lids.line,2,8) = SUBSTR(lids.line,30,8) THEN
      DO
        logonid = STRIP(SUBSTR(lids.line,2,9))
        name    = STRIP(SUBSTR(lids.line,47,20))
        phone   = STRIP(SUBSTR(lids.line,68,12))
        QUEUE "INSERT "logonid" NAME("name") PHONE("phone") -"
        line = line + 1
        QUEUE "  "STRIP(lids.line)" -"
      END
    WHEN SUBSTR(lids.line,2,14) = 'CANCEL/SUSPEND' THEN
      DO
        section = STRIP(SUBSTR(lids.line,2,21))
        QUEUE "  SUSPEND -"
      END
    WHEN SUBSTR(lids.line,2,6)  = 'ACCESS' THEN
      section = STRIP(SUBSTR(lids.line,2,21))
    WHEN SUBSTR(lids.line,2,8)  = 'PASSWORD' THEN
      DO
        section = STRIP(SUBSTR(lids.line,2,21))
        PARSE VAR lids.line 23 maxdays mindays .
        lineout = ''
        IF POS('DAYS',maxdays) > 0 THEN
          lineout = lineout' '||maxdays
        IF POS('DAYS',mindays) > 0 THEN
          lineout = lineout' '||mindays
        IF lineout ¬ = '' THEN
          QUEUE "  "STRIP(lineout)" -"
      END
    WHEN SUBSTR(lids.line,2,10) = 'STATISTICS' THEN
      section = STRIP(SUBSTR(lids.line,2,21))

    /* Add WHEN code per the ACFFDR specification */

    WHEN SUBSTR(lids.line,2,10) = 'PRIVILEGES' |,
         SUBSTR(lids.line,2,3)  = 'TSO' |,
         SUBSTR(lids.line,2,4)  = 'CICS' |,
         SUBSTR(lids.line,2,3)  = 'IMS' |,
         SUBSTR(lids.line,2,4)  = 'M204' |,
         SUBSTR(lids.line,2,4)  = 'IDMS' |,
         SUBSTR(lids.line,2,6)  = 'MUSASS' |,
         SUBSTR(lids.line,2,12) = 'RESTRICTIONS' |,
         SUBSTR(lids.line,2,3)  = 'DFP' |,
         SUBSTR(lids.line,2,7)  = 'KEYPLUS' THEN
      DO
        section = STRIP(SUBSTR(lids.line,2,21))
        CALL lid_fields
      END
    OTHERWISE
      NOP
  END
END

IF password = 'NO' THEN
  QUEUE " "
ELSE
  QUEUE "  PASSWORD(OPENSESAME)"

ADDRESS TSO
"ALLOC F(CLONEID) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS",
  "LRECL(80) RECFM(F B) BLKSIZE(0)"
QUEUE
"EXECIO * DISKW CLONEID (FINIS"
"DELSTACK"
ADDRESS ISPEXEC
"ISPEXEC LMINIT DATAID(ID) DDNAME(CLONEID) ENQ(EXCLU)"
IF rc ¬= 0 THEN
  DO
    SAY LMINIT failed
    EXIT 12
  END
"ISPEXEC EDIT DATAID("id")"
"ISPEXEC LMFREE DATAID("id")"

EXIT

lid_fields:
lidflds = WORDS(SUBSTR(lids.line,23))
IF section = 'PRIVILEGES' THEN
  DO
    IF POS(' STC ',SUBSTR(lids.line,23)) > 0 |,
       POS(' RESTRICT ',SUBSTR(lids.line,23)) > 0 THEN
      password = 'NO'
  END

fields = SUBSTR(lids.line,23)
lineout = ''
DO count = 1 TO lidflds BY 5
  DO x = 1 TO 5
    y = (count + x)  - 1
    lineout = lineout' '||word(fields,y)
  END
  QUEUE "  "STRIP(lineout)" -"
  lineout = ''
END
RETURN

/* J. KALINICH, X4521 */
/* DECOMP a logonid record into INSERT format for cloning  */
./ ADD NAME=COMPUTE  0127-92149-97216-1415-00049-00068-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       COMPUTE                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Calculator                                           |
 | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |
 | Programmer: Norman Pearl                                         |
 |             TSO Times $250 winner, 1992                          |
 | Abstract:   The result of any valid Rexx expression will be      |
 |             displayed in the ISPF message area.                  |
 | Mods:       If no expression is given as an argument, then a     |
 |             pop-up window is displayed that prompts for input    |
 |             (ISPF mode only).                                    |
 +------------------------------------------------------------------+ */
TRACE
NUMERIC DIGITS 20  /* M.F. Cowlishaw */
ARG formula
IF formula = '' &,
   SYSVAR('SYSISPF') = 'ACTIVE' THEN
  DO
    DO WHILE poprc < 8
      zwinttl = 'Calculator'
      ADDRESS ISPEXEC "ADDPOP ROW(3) COLUMN(1)"
      ADDRESS ISPEXEC "DISPLAY PANEL(CALCP)"
      poprc = rc
      ADDRESS ISPEXEC "REMPOP"
      formula = xpreshun
      INTERPRET 'result = ' formula
      zedsmsg = result
      zedlmsg = formula '===>' result
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    END
    zedsmsg = ''
    zedlmsg = ''
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ000)"
    EXIT
  END
INTERPRET 'result = ' formula
IF SYSVAR('SYSISPF') = 'ACTIVE' THEN
  DO
    zedsmsg = result
    zedlmsg = formula '===>' result
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
  END
ELSE
  SAY formula '===>' result
EXIT
/* J. KALINICH, X4521 */
/* EXEC TO COMPUTE EXPRESSIONS (from TSO Times)        */
./ ADD NAME=EDITALL  0103-93074-93362-1417-00045-00047-00000-REXX
/* ---------------------  rexx procedure  ---------------------- *
 * Name:      Editall                                            *
 *                                                               *
 * Function:  Run an ISPF Edit Macro against every member of     *
 *            a PDS.                                             *
 *                                                               *
 * Syntax:    %Editall dsname edit-macro                         *
 *                                                               *
 * Author:    Lionel B. Dyck                                     *
 *            Rockwell International                             *
 *            P.O. Box 2515                                      *
 *            Seal Beach, California 90740                       *
 *            (310) 797-1125                                     *
 *            IBMMail:  USROKNTN                                 *
 *            IBMLINK:  ROK2027                                  *
 *                                                               *
 * History:   11/30/90 - created                                 *
 *                                                               *
 * ------------------------------------------------------------- */

arg dsn exec

if left(dsn,1) <> "'" then do
   dsn = sysvar(syspref)"."dsn
   end
   else do
        dsn = substr(dsn,2,length(dsn)-2)
        end


x = outtrap("lm.","*")

"LISTD" "'"dsn"'" "MEMBERS"

x = outtrap("off")

do i = 1 to lm.0
   if lm.i = "--MEMBERS--" then signal domem
   end

domem:  do j = i+1 to lm.0
        parse value lm.j with mem extra
        Address ISPEXEC "EDIT DATASET('"dsn"("mem")') MACRO("exec")"
        end

./ ADD NAME=EOL      0112-93216-96032-0622-00066-00038-00000-REXX
/* REXX */
ADDRESS ISREDIT
"ISREDIT MACRO (HELP)"
TRACE
IF help = '?' |,
   TRANSLATE(help) = 'HELP' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#EOL)"
    EXIT 1
  END
"ISREDIT (CL,CC) = CURSOR"
save_cc = cc
CALL find_end
/* If already at EOL, then jump to next line and go to EOL */
IF save_cc = cc THEN
  DO
    cl = cl + 1
    CALL find_end
  END
"ISREDIT CURSOR = " cl cc
EXIT
find_end:
"ISREDIT (WIDTH) = DATA_WIDTH"
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
"ISREDIT (XSTATUS) = XSTATUS" cl
IF rc = 0 THEN
  IF xstatus = "X" THEN
    DO
      /* Bypass eXcluded lines */
      "ISREDIT FIND P'=' 1 NX"
      IF rc > 0 THEN
        DO
          zedsmsg = '*BOTTOM OF DATA REACHED*'
          zedlmsg = 'No more lines to process'
          ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
          EXIT
        END
      "ISREDIT (CL) = CURSOR"
    END
  ELSE
    NOP
ELSE
  DO
    "ISREDIT CURSOR = " cl-1 cc
    zedsmsg = '*BOTTOM OF DATA REACHED*'
    zedlmsg = 'No more lines to process'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    EXIT
  END
"ISREDIT (LINE) = LINE " cl
DO cc = width to 1 by -10     /* backtab 10 for speed */
  IF SUBSTR(line,cc,10) /= ' ' THEN
    LEAVE
END
tab_10 = cc + 10              /* tab forward */
DO cc = tab_10 to 1 by -1     /* backspace 1 */
  IF SUBSTR(line,cc,1) /= ' ' THEN
    LEAVE
END
IF cc = width THEN
  NOP
ELSE
  cc = cc + 1
RETURN
/* J. KALINICH, X4521 */
/* EDIT MACRO TO SET CURSOR AT END OF CURRENT SCREEN LINE          */
./ ADD NAME=FLOOR    0110-96283-97029-1226-00045-00031-00000-REXX
/* rexx */
trace
numeric digits 32
say 'floor of -0   is 'floor(-0)
say 'floor of  0   is 'floor(0)
say 'floor of -1   is 'floor(-1)
say 'floor of  1   is 'floor(1)
say 'floor of  1.0 is 'floor(1.0)
say 'floor of  1.1 is 'floor(1.1)
say 'floor of  1.2 is 'floor(1.2)
say 'floor of  1.3 is 'floor(1.3)
say 'floor of  1.4 is 'floor(1.4)
say 'floor of  1.5 is 'floor(1.5)
say 'floor of  1.6 is 'floor(1.6)
say 'floor of  1.7 is 'floor(1.7)
say 'floor of  1.8 is 'floor(1.8)
say 'floor of  1.9 is 'floor(1.9)
say 'floor of -1.0 is 'floor(-1.0)
say 'floor of -1.1 is 'floor(-1.1)
say 'floor of -1.2 is 'floor(-1.2)
say 'floor of -1.3 is 'floor(-1.3)
say 'floor of -1.4 is 'floor(-1.4)
say 'floor of -1.5 is 'floor(-1.5)
say 'floor of -1.6 is 'floor(-1.6)
say 'floor of -1.7 is 'floor(-1.7)
say 'floor of -1.8 is 'floor(-1.8)
say 'floor of -1.9 is 'floor(-1.9)
say 'floor of -2.0 is 'floor(-2.0)
say 'floor of -2.1 is 'floor(-2.1)
say 'floor of -2.5456789 is 'floor(-2.5456789)
say 'floor of -2.0000000054567899 is 'floor(-2.0000000054567899)
say 'floor of +2.0000000054567899 is 'floor(+2.0000000054567899)
say 'floor of -3 is 'floor(-3)
exit

floor: procedure
/* rexx      largest integer less than or equal       */
parse arg number
if number < 0 then
  if (abs(number) - abs(trunc(number))) > 0 then
    number = number - 1
return trunc(number)

/* J. KALINICH, X4521 */
/* REXX FLOOR FUNCTION - LARGEST INTEGER LESS THAN OR EQUAL         */
./ ADD NAME=GETACCT  0143-92148-96089-1228-00072-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETACCT                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get job accounting information                       |
 | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/29/96                                              |
 | Abstract:   A sub-function to return the job account number      |
 |                                                                  |
 | Call Format:  GETACCT()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT+x'10')                             |
 |        Addresses the ACT (JCT+x'28')                             |
 |        Extracts ACTACCNT                                         |
 +------------------------------------------------------------------+ */
/* rexx */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
jct_prefix_ptr  = get_ptr(jscb_ptr,'104')
jct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))
act_ptr = get_ptr3(jct_ptr,'28')
pgmr = get_data(act_ptr,'18',20)
acct_len = c2d(get_data(act_ptr,'30',1))
actaccnt = get_data(act_ptr,'31',acct_len)
exit actaccnt

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_ptr3: procedure
    /* +-----------------------------------------+
       | returns a 3 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,3))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE JOB ACCOUNT NUMBER                */
./ ADD NAME=GETACF2  0134-92148-95325-0738-00066-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETACF2                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get the ACF2 release identifier                      |
 | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |
 | Programmer: John Kalinich                                        |
 | Date:       10/17/95                                             |
 | Abstract:   A sub-function to return the ACF2 release id         |
 |             from the ACCVT.                                      |
 |                                                                  |
 | Call Format:  GETACF2()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of 1st SSCT (JESCT+x'18')                |
 |        Locates the ACF2 SSCT                                     |
 |        Extracts address of ACCVT (SSCT+x'14')                    |
 |        Extracts ACF2 release identifier (ACCVT+x'4F')            |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
jesct_ptr = get_ptr(cvt_ptr,'128')
sscvt_ptr = get_ptr(jesct_ptr,'18')
do while sscvt_ptr ¬= '00000000'
  ssctsnam = get_data(sscvt_ptr,'8',4)
  if ssctsnam = 'ACF2' then
    do
      ssctsuse_ptr = get_ptr(sscvt_ptr,'14')
      acf2rel = c2x(get_data(ssctsuse_ptr,'4f',1))
      leave
    end
  sscvt_ptr = get_ptr(sscvt_ptr,'4')
end
exit substr(acf2rel,1,1)'.'substr(acf2rel,2,1)

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE ACF2 RELEASE IDENTIFIER           */
./ ADD NAME=GETATTR  0105-93099-93314-0815-00070-00070-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETATTR                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get the TSO user attributes                          |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to return the TSO user attributes     |
 |             from the Protected Step Control Block                |
 |                                                                  |
 | Call Format:  GETATTR()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of PSCB (JSCB+x'108')                    |
 |        Tests PSCBATR1, bit 0 for OPERATOR authority              |
 |        Tests PSCBATR1, bit 1 for ACCOUNT  authority              |
 |        Tests PSCBATR1, bit 2 for SUBMIT   authority              |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
pscb_ptr  = get_ptr(jscb_ptr,'108')
pscbatr1 =  get_data(pscb_ptr,'10',1)
if bitand(pscbatr1,'80'x) = '80'x then
  oper = 'OPER  '
else
  oper = 'NOOPER'
if bitand(pscbatr1,'40'x) = '40'x then
  account = 'ACCOUNT  '
else
  account = 'NOACCOUNT'
if bitand(pscbatr1,'20'x) = '20'x then
  submit = 'SUBMIT  '
else
  submit = 'NOSUBMIT'
tsoattr = oper||account||submit
exit tsoattr

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE TSO USER ATTRIBUTES               */
./ ADD NAME=GETCIB   0150-92148-96276-0623-00092-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETCIB                                               |
 | Type:       REXX exec                                            |
 | Purpose:    Get the command verb code from first CIB             |
 | Release:    MVS/ESA v5.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       09/30/96                                             |
 | Abstract:   A sub-function to return the command verb code from  |
 |             the first command input buffer.                      |
 |                                                                  |
 | Call Format:  GETCIB()                                           |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts the TIOT (TCB+x'0C')                             |
 |        Extracts the JOBNAME (TIOT+x'0')                          |
 |        Extracts the CVT (at x'10')                               |
 |        Extracts the ASVT (CVT+x'22C')                            |
 |        Extracts the Master ASCB (ASVT+x'210')                    |
 |        Extracts the next ASCB (ASCB+x'4')                        |
 |        Extracts the CSCB (ASCB+x'38')                            |
 |        Run the CSCB chain until JOBNAME equal                    |
 |        Extracts the CSCX (CSCB+x'DC')                            |
 |        Extracts the CIB (CSCX+x'0C')                             |
 |        Extracts CIBVERB                                          |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
tiot_ptr = get_ptr(tcb_ptr,'c')
jobname = get_data(tiot_ptr,'0','8')
cvt_ptr = get_ptr(10,0)
asvt_ptr = get_ptr(cvt_ptr,'22c')
master_ascb_ptr = get_ptr(asvt_ptr,'210')
next_ascb_ptr = get_ptr(master_ascb_ptr,'4')
cscb_ptr = get_ptr(next_ascb_ptr,'38')

do while cscb_ptr ¬= '00000000'
  chkey = get_data(cscb_ptr,'8',8)
  if chkey = jobname then
    leave
  cscb_ptr = get_ptr(cscb_ptr,'0')
end

cscx_ptr = get_ptr(cscb_ptr,'dc')
cib_ptr = get_ptr(cscx_ptr,'c')
if cib_ptr = '00000000' then
  cib_verb = 'NO CIB'
else
  do
    cib_verb = get_data(cib_ptr,'4','1')
    if cib_verb = '04'x then
      cib_verb = 'START'
    if cib_verb = '08'x then
      cib_verb = 'STC COMMUNICATION'
    if cib_verb = '44'x then
      cib_verb = 'MODIFY'
    if cib_verb = '40'x then
      cib_verb = 'STOP'
    if cib_verb = '0C'x then
      cib_verb = 'MOUNT'
  end
exit cib_verb

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit
get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE COMMAND VERB CODE FROM THE 1ST CIB */
./ ADD NAME=GETCPUM  0120-92148-93314-0815-00052-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETCPUM                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the CVTMDL of the System you are on          |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the cpu model number from  |
 |             the CVT prefix.                                      |
 |                                                                  |
 | Call Format:  GETCPUM()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the CVTFIX+250 (CVT-x'6')                       |
 |        Extracts CVTMDL                                           |
 +------------------------------------------------------------------+ */
trace

cvt_ptr = get_ptr(10,0)
cvtmdl_ptr = d2x(x2d(cvt_ptr) - x2d(6))
cvtmdl = c2x(get_data(cvtmdl_ptr,'0',2))
exit substr(cvtmdl,1,4)

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE CPU MODEL NUMBER                  */
./ ADD NAME=GETDEST  0140-92148-95325-0840-00055-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETDEST                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get the TSO default SYSOUT destination               |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       4/09/93                                              |
 | Abstract:   A sub-function to return the TSO user's default      |
 |             SYSOUT destination                                   |
 |                                                                  |
 | Call Format:  GETDEST()                                          |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of PSCB (JSCB+x'108')                    |
 |        Extracts the PSCBDEST                                     |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
pscb_ptr  = get_ptr(jscb_ptr,'108')
dest = get_data(pscb_ptr,'28',8)
exit dest

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE TSO DEFAULT SYSOUT DESTINATION    */
./ ADD NAME=GETDFPL  0123-93032-98091-0857-00053-00056-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETDFPL                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the DFAREL of the System you are on          |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the DFP level from the     |
 |             Data Facilities Area (DFA).                          |
 |                                                                  |
 | Call Format:  GETDFPL()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of DFA (CVT+x'4C0')                      |
 |        Extracts DFAREL                                           |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
dfa_ptr = get_ptr(cvt_ptr,'4c0')
dfarel = c2x(get_data(dfa_ptr,'2',2))
exit substr(dfarel,1,1)'.'substr(dfarel,2,1)'.'substr(dfarel,3,1)

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE DFP LEVEL                         */
./ ADD NAME=GETGRPN  0125-92148-95003-0744-00056-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETGRPN                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the ACEEGRPN from the RACF ACEE.             |
 | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |
 | Programmer: John Kalinich                                        |
 | Date:       1/3/95                                               |
 | Abstract:   A sub-function to extract connect group name from    |
 |             the RACF Accessor Environment Element.  The ACEE is  |
 |             not fetch protected.  This function works in ACF2    |
 |             systems.                                             |
 |                                                                  |
 | Call Format:  GETGRPN()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of ASXB (ASCB+x'6C')                     |
 |        Extracts address of ACEE (ASXB+x'C8')                     |
 |        Extracts ACEEGRPN                                         |
 +------------------------------------------------------------------+ */
trace

ascb_ptr = get_ptr(224,0)
asxb_ptr = get_ptr(ascb_ptr,'6c')
acee_ptr = get_ptr(asxb_ptr,'c8')
aceegrpn = get_data(acee_ptr,'1e',8)
exit aceegrpn

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE RACF ACEE CONNECT GROUP NAME              */
./ ADD NAME=GETIPLD  0121-93032-93314-0816-00053-00056-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETIPLD                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SMCAIDTE of the System you are on        |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/19/93                                              |
 | Abstract:   A sub-function to extract the IPL date from the      |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETIPLD()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCAIDTE                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
smca_ptr = get_ptr(cvt_ptr,'c4')
smcaidte = c2x(get_data(smca_ptr,'154',4))
exit substr(smcaidte,3,2)'.'substr(smcaidte,5,3)

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE MVS IPL DATE                      */
./ ADD NAME=GETIPLT  0131-92363-94118-1259-00057-00003-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETIPLT                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SMCAITME of the System you are on        |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to extract the IPL time from the      |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETIPLT()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCAITME                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
smca_ptr = get_ptr(cvt_ptr,'c4')
smcaitme = c2x(get_data(smca_ptr,'150',4))
total_seconds = x2d(smcaitme) % 100
seconds = right((total_seconds // 60),2,'0')
minutes = right(((total_seconds % 60) // 60),2,'0')
hours   = right(((total_seconds / 60) % 60),2,'0')
exit hours'.'minutes'.'seconds

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE MVS IPL TIME                      */
./ ADD NAME=GETJES2  0128-92148-98132-1333-00057-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETJES2                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Get the JES2 product name                            |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to return the JES2 product name       |
 |             from HASPSSSM.                                       |
 |                                                                  |
 | Call Format:  GETJES2()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of 1st SSCT (JESCT+x'18')                |
 |        Extracts address of SSCTSUSE (SSCT+x'14')                 |
 |        Extracts JES2 product name from HASPSSSM+x'C'             |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
jesct_ptr = get_ptr(cvt_ptr,'128')
sscvt_ptr = get_ptr(jesct_ptr,'18')
haspsssm_plus12 = get_ptr(sscvt_ptr,'14')
jeslevel = get_data(haspsssm_plus12,'0',8)
exit jeslevel

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE JES2 PRODUCT LEVEL                */
./ ADD NAME=GETJOBID 0127-92148-93314-0816-00055-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETJOBID                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SSIBJBID from the SSIB.                  |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the job id from the        |
 |             Subsystem Identification Block (SSIB).               |
 |                                                                  |
 | Call Format:  GETJOBID()                                         |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of SSIB (JSCB+x'13C')                    |
 |        Extracts the SSIBJBID                                     |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
ssib_ptr  = get_ptr(jscb_ptr,'13c')
ssibjbid = get_data(ssib_ptr,'c',8)
exit ssibjbid

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE JES2 JOB ID                       */
./ ADD NAME=GETLPAR  0128-93032-93314-0816-00057-00056-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETLPAR                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the Logical Partition mode (YES or NO)       |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to extract the LPAR mode from the     |
 |             Service Call Control Block (SCCB).                   |
 |                                                                  |
 | Call Format:  GETLPAR()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SCCP (CVT+x'340')                     |
 |        Tests SCCBCON1, bit 0 for LPAR configuration              |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
sccb_ptr = get_ptr(cvt_ptr,'340')
sccbcon1 = get_data(sccb_ptr,'50',1)
if bitand(sccbcon1,'80'x) = '80'x then
  lpar = 'YES'
else
  lpar = 'NO'
exit lpar

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE LOGICAL PARTITION MODE            */
./ ADD NAME=GETNAME  0107-95297-96094-1425-00059-00057-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETNAME                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract ACEEUNAM from the RACF ACEE.                 |
 | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |
 | Programmer: John Kalinich                                        |
 | Date:       10/24/95                                             |
 | Abstract:   A sub-function to extract the ACEE user name from    |
 |             the RACF Accessor Environment Element.  The ACEE is  |
 |             not fetch protected.  This function works in ACF2    |
 |             systems.                                             |
 |                                                                  |
 | Call Format:  GETNAME()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of ASXB (ASCB+x'6C')                     |
 |        Extracts address of ACEE (ASXB+x'C8')                     |
 |        Extracts address of ACEEUNAM (ACEE+x'64')                 |
 |        Extracts ACEEUNAM                                         |
 +------------------------------------------------------------------+ */
trace

ascb_ptr = get_ptr(224,0)
asxb_ptr = get_ptr(ascb_ptr,'6c')
acee_ptr = get_ptr(asxb_ptr,'c8')
acee_unam_ptr = get_ptr(acee_ptr,'64')
unam_len = c2d(get_data(acee_unam_ptr,'0',1))
user_name = get_data(acee_unam_ptr,'1',unam_len -1)
exit user_name

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE RACF ACEE USER NAME                       */
./ ADD NAME=GETPLEX  0129-92148-96220-1232-00052-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETPLEX                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the sysplex name of the System you are on    |
 | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       4/29/96                                              |
 | Abstract:   A sub-function to extract the sysplex name from      |
 |             the Extended CVT.                                    |
 |                                                                  |
 | Call Format:  GETPLEX()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the ECVT (CVT+x'8C')                            |
 |        Extracts ECVTSPLX                                         |
 +------------------------------------------------------------------+ */
trace

cvt_ptr = get_ptr(10,0)
cvtecvt_ptr = get_ptr(cvt_ptr,'8c')
ecvtsplx = get_data(cvtecvt_ptr,'8',8)
exit ecvtsplx

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE SYSPLEX NAME                      */
./ ADD NAME=GETPRGNM 0143-92148-96089-1227-00070-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETPRGNM                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Get programmer name                                  |
 | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/29/96                                              |
 | Abstract:   A sub-function to return the programmer name         |
 |                                                                  |
 | Call Format:  GETPRGNM()                                         |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT+x'10')                             |
 |        Addresses the ACT (JCT+x'28')                             |
 |        Extracts ACTPRGNM                                         |
 +------------------------------------------------------------------+ */
/* rexx */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
jct_prefix_ptr  = get_ptr(jscb_ptr,'104')
jct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))
act_ptr = get_ptr3(jct_ptr,'28')
actprgnm = get_data(act_ptr,'18',20)
exit actprgnm

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_ptr3: procedure
    /* +-----------------------------------------+
       | returns a 3 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,3))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE PROGRAMMER NAME                   */
./ ADD NAME=GETREALM 0126-92148-93314-0816-00052-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETREALM                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the CVTRLSTG from the CVT.                   |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the real storage size      |
 |             online at IPL.  Returns value in number of           |
 |             megabytes (M).                                       |
 |                                                                  |
 | Call Format:  GETREALM()                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts CVTRLSTG                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
cvtrlstg = c2d(get_data(cvt_ptr,'358',4)) / 1024
exit cvtrlstg

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE REAL STORAGE SIZE                 */
./ ADD NAME=GETREGK  0126-92148-93314-0817-00054-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETREGK                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the LDAREGRQ from the LDA.                   |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the region size requested  |
 |             from the Local Data Area (LDA).  Returns value in    |
 |             number of kilobytes (K).                             |
 |                                                                  |
 | Call Format:  GETREGK()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of LDA  (ASCB+x'30')                     |
 |        Extracts LDAREGRQ                                         |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
ascb_ptr = get_ptr(224,0)
lda_ptr  = get_ptr(ascb_ptr,'30')
ldaregrq = c2d(get_data(lda_ptr,'cc',4)) / 1024
exit ldaregrq

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE REGION SIZE (IN K)                */
./ ADD NAME=GETSCPN  0118-92148-98154-1117-00053-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSCPN                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the CVTPRODN of the System you are on        |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to extract the system control program |
 |             product name (e.g., SP3.1.3) from the CVT prefix.    |
 |                                                                  |
 | Call Format:  GETSCPN()                                          |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Addresses the CVTFIX+216 (CVT-x'28')                      |
 |        Extracts CVTPRODN                                         |
 +------------------------------------------------------------------+ */
trace

cvt_ptr = get_ptr(10,0)
cvtprod = d2x(x2d(cvt_ptr) - x2d(28))
cvtprodn = get_data(cvtprod,'0',8)
cvtprodn = insert(' ',cvtprodn,2)
exit cvtprodn

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE MVS SCP PRODUCT NAME              */
./ ADD NAME=GETSMFID 0114-92148-94129-1441-00085-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSMFID                                             |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the SMCASID of the System you are on         |
 | Release:    MVS/ESA v4.1   and TSO/E v2.1                        |
 | Programmer: Paul S. Waterhouse                                   |
 |             (Code modified from apf list routine put on          |
 |              exchange by Joe Millar)                             |
 | Date:       1/24/92                                              |
 | Abstract:   A sub-function to extract the smfid from the         |
 |             System Management Control Area (SMCA).               |
 |                                                                  |
 | Call Format:  GETSMFID('smf-id')                                 |
 |                                                                  |
 |               When 'smf-id' is null, function returns            |
 |               the SMF-ID.                                        |
 |               When 'smf-id' is four bytes long, a 1 will be      |
 |               returned if current SMF-ID = smf-id or a 0 if      |
 |               not equal.                                         |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of SMCA (CVT+x'C4')                      |
 |        Extracts SMCASID                                          |
 |                                                                  |
 |        If arg is null, return smfid                              |
 |        If arg len = 4 then compare                               |
 |           If equal return 1                                      |
 |           If not equal return 0                                  |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
parse arg check_id, .
cvt_ptr = get_ptr(10,0)
smca_ptr = get_ptr(cvt_ptr,'c4')
smcasid = get_data(smca_ptr,'10',4)
select
  when check_id = "" then
    do
      exit smcasid
    end
  when length(check_id) ¬= 4 then
    do
      exit -3
    end
  otherwise
    do
      if check_id =  smcasid then
        do
          exit 1
        end
    end
end

exit 0

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE SMF SYSTEM ID (from NaSPA)        */
./ ADD NAME=GETSMS   0128-92148-96225-1336-00059-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSMS                                               |
 | Type:       REXX exec                                            |
 | Purpose:    Get the status of SMS (On or Off)                    |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/22/93                                              |
 | Abstract:   A sub-function to return the status of SMS in the    |
 |             system.                                              |
 |                                                                  |
 | Call Format:  GETSMS()                                           |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of JESCTEXT (JESCT+x'64')                |
 |        Tests pointer to JESSMSIB                                 |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
jesct_ptr = get_ptr(cvt_ptr,'128')
jesctext_ptr = get_ptr(jesct_ptr,'64')
jessmsib = c2x(get_data(jesctext_ptr,'54',4))
if x2d(jessmsib) = 0 then
  smsstat = 'Off'
else
  smsstat = 'On'
exit smsstat

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE STATUS OF SMS                     */
./ ADD NAME=GETSWA   0136-92148-97065-0840-00061-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETSWA                                               |
 | Type:       REXX exec                                            |
 | Purpose:    Get the location of SWA (ABOVE or BELOW)             |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       8/24/93                                              |
 | Abstract:   A sub-function to return the status of SWA in the    |
 |             system.                                              |
 |                                                                  |
 | Call Format:  GETSWA()                                           |
 |                                                                  |
 | Logic: Extracts address of TCB (PSATOLD at x'21C')               |
 |        Extracts address of JSCB (TCB+x'B4')                      |
 |        Extracts address of JCT prefix (JSCB+x'104')              |
 |        Addresses the JCT (JCT+x'10')                             |
 |        Tests JCTSTAT2, bit 7 for location of SWA                 |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
tcb_ptr = get_ptr(21c,0)
jscb_ptr  = get_ptr(tcb_ptr,'b4')
jct_prefix_ptr  = get_ptr(jscb_ptr,'104')
jct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))
jctstat2 = get_data(jct_ptr,'74',1)
if bitand(jctstat2,'01'x) = '01'x then
  jctswaup = 'ABOVE'
else
  jctswaup = 'BELOW'
exit jctswaup

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE LOCATION OF SWA                   */
./ ADD NAME=GETTRID  0124-92148-97273-0754-00056-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETTRID                                              |
 | Type:       REXX exec                                            |
 | Purpose:    Extract the ACEETRID from the RACF ACEE.             |
 | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |
 | Programmer: John Kalinich                                        |
 | Date:       3/10/93                                              |
 | Abstract:   A sub-function to extract the VTAM terminal id from  |
 |             the RACF Accessor Environment Element.  The ACEE is  |
 |             not fetch protected.  This function works in ACF2    |
 |             systems.                                             |
 |                                                                  |
 | Call Format:  GETTRID()                                          |
 |                                                                  |
 | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts address of ASXB (ASCB+x'6C')                     |
 |        Extracts address of ACEE (ASXB+x'C8')                     |
 |        Extracts ACEETRID                                         |
 +------------------------------------------------------------------+ */
trace

ascb_ptr = get_ptr(224,0)
asxb_ptr = get_ptr(ascb_ptr,'6c')
acee_ptr = get_ptr(asxb_ptr,'c8')
aceetrid = get_data(acee_ptr,'40',8)
exit aceetrid

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE RACF ACEE TERMINAL ID             */
./ ADD NAME=GETUID   0137-92148-95325-0741-00076-00087-00000-REXX
/* REXX -
 +------------------------------------------------------------------+
 | Name:       GETUID                                               |
 | Type:       REXX exec                                            |
 | Purpose:    Get the ACF2 userid string                           |
 | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |
 | Programmer: John Kalinich                                        |
 | Date:       11/21/95                                             |
 | Abstract:   A sub-function to return the ACF2 userid string.     |
 |                                                                  |
 | Call Format:  GETUID()                                           |
 |                                                                  |
 | Logic: Extracts address of CVT (at x'10')                        |
 |        Extracts address of JESCT (CVT+x'128')                    |
 |        Extracts address of 1st SSCT (JESCT+x'18')                |
 |        Locates the ACF2 SSCT                                     |
 |        Extracts address of ACCVT (SSCT+x'14')                    |
 |        Extracts address of ACFASVT (ACCVT+x'64')                 |
 |        Extracts address of ASCB (PSAAOLD at x'224')              |
 |        Extracts the ASID (ASCB+x'24')                            |
 |        Extracts address of ACUCB (ACFASVT+(32*ASID)+x'1C')       |
 |        Extracts address of ACUUIDP (ACUCB+x'18')                 |
 |        Extracts the UID string                                   |
 +------------------------------------------------------------------+ */
trace

numeric digits 10          /* Required for 31-bit addresses */
cvt_ptr = get_ptr(10,0)
jesct_ptr = get_ptr(cvt_ptr,'128')
sscvt_ptr = get_ptr(jesct_ptr,'18')
do while sscvt_ptr ¬= '00000000'
  ssctsnam = get_data(sscvt_ptr,'8',4)
  if ssctsnam = 'ACF2' then
    do
      accvt_ptr = get_ptr(sscvt_ptr,'14')
      accasvt_ptr = get_ptr(accvt_ptr,'64')
      ascb_ptr = get_ptr(224,0)
      asid = c2d(get_data(ascb_ptr,'24',2))
      accasvt_ptr = d2x(x2d(accasvt_ptr) + (32 * asid))
      asvucb_ptr = get_ptr(accasvt_ptr,'1c')
      acuuidp_ptr = get_ptr(asvucb_ptr,'18')
      uid_string = get_data(acuuidp_ptr,'0',24)
      leave
    end
  sscvt_ptr = get_ptr(sscvt_ptr,'4')
end
exit uid_string

/* +-----------------------------------------+
   | Procedures and functions defined below. |
   +-----------------------------------------+ */

get_ptr: procedure
    /* +-----------------------------------------+
       | returns a 4 byte pointer as hexadecimal |
       | string at address addr+offset.          |
       | ADDR and OFFSET must be HEX strings.    |
       +-----------------------------------------+ */
  arg addr, offset
  temp = d2x(x2d(addr) + x2d(offset))
  return c2x(storage(temp,4))
  exit

get_data: procedure
    /* +-----------------------------------------+
       | returns LENGTH bytes at ADDR+OFFSET as  |
       | an EBCDIC string.                       |
       | ADDR and OFFSET must be HEX strings.    |
       | LENGTH must be a decimal string.        |
       +-----------------------------------------+ */
  arg addr, offset, length
  temp = d2x(x2d(addr) + x2d(offset))
  return storage(temp,length)
  exit
/* J. KALINICH, X4521 */
/* EXEC TO GET THE ACF2 USERID STRING                */
./ ADD NAME=IDCAMS   0154-96068-97098-1253-00074-00040-00000-REXX
/* REXX */
TRACE
ADDRESS ISREDIT
"ISREDIT MACRO (PARM) NOPROCESS"

parm = TRANSLATE(parm)
IF parm = 'HELP' |,
   parm = '?' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#IDCAMS)"
    EXIT 0
  END

/* PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED */
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
"ISREDIT PROCESS RANGE C"
IF rc > 0 THEN
  DO
    zedsmsg = 'ENTER "Cn" LINE CMD'
    zedlmsg = 'YOU MUST SPECIFY THE "DATA" LINES',
              'TO BE PASSED TO IDCAMS, USING "Cn" OR "CC"'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    EXIT 12
  END

"ISREDIT (FR)  = LINENUM .ZFRANGE"
"ISREDIT (LR)  = LINENUM .ZLRANGE"

/* SET CURSOR ON FIRST LINE IN RANGE */
"ISREDIT CURSOR = .ZFRANGE 1"

ADDRESS TSO
"NEWSTACK"
i = fr
DO WHILE i <= lr
  "ISREDIT (LINE) = LINE "i
  QUEUE line
  i = i + 1
END
QUEUE

ADDRESS TSO
"ALLOC F(SYSIN) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS",
  "LRECL(80) RECFM(F)"
"EXECIO * DISKW SYSIN (FINIS"
"DELSTACK"

"ALLOC F(SYSPRINT) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS",
  "LRECL(121) RECFM(F B A)"

ADDRESS LINKMVS "IDCAMS"

ADDRESS ISPEXEC
"ISPEXEC LMINIT DATAID(ID) DDNAME(SYSPRINT) ENQ(EXCLU)"
IF rc ¬= 0 THEN
  DO
    SAY LMINIT failed
    EXIT 12
  END
"ISPEXEC BROWSE DATAID("id")"
"ISPEXEC LMFREE DATAID("id")"

ADDRESS TSO
"ALLOC F(SYSPRINT) DA(*) SHR REUSE"
"ALLOC F(SYSIN)    DA(*) SHR REUSE"
EXIT


/* SET CURSOR ON FIRST LINE IN RANGE */
"ISREDIT CURSOR = "fr 0

EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO EXECUTE IDCAMS COMMANDS IN EDIT BUFFER         */
./ ADD NAME=LIBDIR   0168-95137-97038-1246-00075-00056-00000-REXX
/* REXX */
TRACE
ARG dsn
dsn = TRANSLATE(dsn)

IF LENGTH(dsn) = 0 THEN
  DO
    zedsmsg = 'No file name'
    zedlmsg = 'Specify a Librarian master file'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    EXIT 12
  END

ADDRESS TSO
"ALLOC F(INDEX) UNIT(VIO) NEW REUSE SPACE(10,10) TRACKS",
  "LRECL(121) RECFM(F B M) BLKSIZE(0)"
"ALLOC F(SYSIN) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS",
  "LRECL(80) RECFM(F)"
"NEWSTACK"
QUEUE '-OPT INDEX'
"EXECIO 1 DISKW SYSIN (FINIS"
"DELSTACK"
"ALLOC F(MASTER) DA('"dsn"') SHR REUSE"
"ALLOC F(OSJOB) DUMMY REUSE"
"ALLOC F(SYSPRINT) DUMMY REUSE"
parm = "IEX=IEFBR14,NRJS,NJTA"
ADDRESS LINKMVS "ADRLIB parm"

SAY ' Name                VV.MM Created     Changed      Size',
    ' Init   Mod   ID'
"EXECIO * DISKR INDEX (STEM MBR. FINIS"
DO line = 1 to mbr.0
  IF SUBSTR(mbr.line,2,1) = ' ' |,
     SUBSTR(mbr.line,2,7) = 'RUN NO.' |,
     SUBSTR(mbr.line,2,13) = 'MODULE   PSWD' |,
     SUBSTR(mbr.line,2,9) = 'THE TOTAL' THEN
    NOP
  ELSE
    DO
      name = SUBSTR(mbr.line,2,8)
      created = SUBSTR(mbr.line,49,8)
      IF SUBSTR(mbr.line,60,11) = 'NOT UPDATED' THEN
        DO
          lastmod = COPIES(' ',8)
          time = COPIES(' ',5)
        END
      ELSE
        DO
          lastmod = SUBSTR(mbr.line,59,8)
          time = SUBSTR(mbr.line,68,2)||':'||SUBSTR(mbr.line,70,2)
        END
      size = SUBSTR(mbr.line,77,5)
      init = size
      mod = 0
      id = SUBSTR(mbr.line,107,8)
      SAY name,
          '           ',
          '01.00',
          created,
          lastmod,
          time,
          FORMAT(size,5),
          FORMAT(init,5),
          FORMAT(mod,5),
          id
    END
END

ADDRESS TSO
"ALLOC F(SYSPRINT) DA(*) SHR REUSE"
"ALLOC F(SYSIN)    DA(*) SHR REUSE"
"FREE  F(INDEX MASTER OSJOB)"
EXIT
/* J. KALINICH, X4521 */
/* EXEC TO DISPLAY LIBRARIAN INDEX                                 */
./ ADD NAME=NOWARN   0114-91345-97016-0636-00008-00037-00000-REXX
/* REXX */
ADDRESS ISREDIT
"ISREDIT MACRO"
"ISREDIT RECOVERY OFF NOWARN"
"ISREDIT END"
EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO ISSUE COMMANDS TO CHANGE PROFILE */
./ ADD NAME=PDSDIR   0116-96283-98290-0850-00099-00086-00000-REXX
/*% NOCOMMENT REXX */
TRACE
/*  For batch, use the following JCL and comment out the TSO
    ALLOCATE sequence:

    //REXX     EXEC  PGM=IRXJCL,PARM='name.of.rexx.exec'
    //SYSEXEC  DD  DSN=your.rexx.library,DISP=SHR
    //SYSTSPRT DD  SYSOUT=*
    //SYSTSIN  DD  DUMMY
    //PDS      DD  DSN=your.pds.name,DISP=SHR,
    //             DCB=(RECFM=F,DSORG=PS,LRECL=256,BLKSIZE=256)

*/

/*  For TSO, use the following ALLOCATE sequence:   */

ARG dsn
ADDRESS TSO
"ALLOC F(PDS) DA("dsn") SHR REUSE",    /* pds directory */
"  RECFM(F) DSORG(PS) LRECL(256) BLKSIZE(256)"

/*-------------------------------------------------------------------*/

mainline:
SAY ' Name                VV.MM Created   Changed    Size',
    ' Init   Mod   ID'
"EXECIO * DISKR PDS (STEM DIR. FINIS"  /* read pds directory */
DO blk = 1 to dir.0
  usedbytes = C2D(SUBSTR(dir.blk,1,2))
  index = 3                            /* skip past used bytes */
  DO WHILE index < usedbytes
    IF SUBSTR(dir.blk,index,8) = 'FFFFFFFFFFFFFFFF'x THEN
      LEAVE blk
    pds2name = SUBSTR(dir.blk,index,8) /* member name */
    index = index + 11                 /* skip past name and ttr */
    pds2indc = SUBSTR(dir.blk,index,1)
    len = BITAND(pds2indc,'1F'x)       /* isolate user data length */
    userdata = C2D(len) * 2            /* halfwords to bytes */
    IF userdata = 30 THEN              /* ISPF statistics? */
      DO
        vv = c2d(SUBSTR(dir.blk,index+1,1))
        mm = c2d(SUBSTR(dir.blk,index+2,1))
        created = p2d(SUBSTR(dir.blk,index+6,3))
        lastmod = p2d(SUBSTR(dir.blk,index+10,3))
        time = p2d(SUBSTR(dir.blk,index+13,3))
        time = SUBSTR(time,1,2)||':'||SUBSTR(time,3,2)
        size = c2d(SUBSTR(dir.blk,index+15,2))
        init = c2d(SUBSTR(dir.blk,index+17,2))
        mod = c2d(SUBSTR(dir.blk,index+19,2))
        id = SUBSTR(dir.blk,index+21,8)
        SAY pds2name,
            '           ',
            RIGHT(vv,2,0)||'.'||RIGHT(mm,2,0),
            created,
            ' ',
            lastmod,
            time,
            FORMAT(size,5),
            FORMAT(init,5),
            FORMAT(mod,5),
            id
      END
    ELSE
      SAY pds2name
    index = index + userdata + 1       /* skip past user data */
  END
END
EXIT

p2d: procedure
/* rexx      convert packed decimal to number */
/* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
/* Tel: +49-711-2012-387                                       */
/* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
parse arg number_p
erg = c2x(number_p)
sign = right(erg,1)
number = left(erg,length(erg)-1)
if sign = 'D' then
   return '-'||number
else
   return number

d2p: procedure
/* rexx   convert number to packed decimal  */
/* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */
/* Tel: +49-711-2012-387                                       */
/* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */
arg number
if datatype(number) ¬= 'NUM' then
   return ''
if number < 0 then
   interpret "number_p = '"abs(number)"D'x"
else
   interpret "number_p = '"number"C'x"
return number_p

/* J. KALINICH, X4521 */
/* EXEC TO DEBLOCK PDS DIRECTORY                                      */
./ ADD NAME=PDSFTP   0156-97059-98169-1000-00218-00132-00000-REXX
/* ---------------------  Rexx procedure  ---------------------- *
 *                                                               *
 * Name:      PDSFTP                                             *
 *                                                               *
 * Function:  Invoked by the user to display the PDSFTP ISPF     *
 *            pop-up and then use the TCP/IP FTP command to copy *
 *            data sets to and from the remote TCP/IP host.      *
 *                                                               *
 *            If a local dataset name is entered on the panel,   *
 *            then PUT subcommands will be generated by the      *
 *            dialog and FTP will be invoked in a batch mode.    *
 *            Otherwise, FTP will be invoked in it's normal      *
 *            interactive mode where any subcommand can be       *
 *            issued.                                            *
 *                                                               *
 *            When a PDS dataset name is entered, a member list  *
 *            will be displayed.  Members selected for PUT will  *
 *            have a foreign file name generated in the form of  *
 *            'mbr.llq' where 'mbr' is the PDS member name and   *
 *            'llq' is the 1st 3 characters of the MVS low level *
 *            qualifier.                                         *
 *                                                               *
 *            When a sequential dataset name is entered, the     *
 *            foreign file name will be generated as 'llq'.  If  *
 *            a PDS member name is entered in parenthesis (a     *
 *            sequential file) then the name is generated as     *
 *            'mbr.llq'.  If a wild card '*' character is used   *
 *            as part of the PDS member name, then MPUT will be  *
 *            used and the foreign file names will be the same   *
 *            as the PDS member names.                           *
 *                                                               *
 *                                                               *
 * Syntax:    %pdsftp                                            *
 *                                                               *
 * Author:    John P. Kalinich                                   *
 *            USA Logistics Systems Support Center               *
 *            AMSEL-SE-BSD-LS-TD, Room 7.103                     *
 *            1222 Spruce Street                                 *
 *            St. Louis, MO.  63103-2834                         *
 *            314-331-4521                                       *
 *            314-331-4520 (FAX)                                 *
 *            Internet:  kalinich@st-louis-emh2.army.mil         *
 *                                                               *
 * History:                                                      *
 *                                                               *
 *            04/14/97 - Add support for Knet or IBM TCP/IP      *
 *                                                               *
 * Credits:                                                      *
 *            Lionel Dyck's LPRPRINT dialog from the IBM SHARE   *
 *            Software PC was the basis for this code.           *
 * ------------------------------------------------------------- */

Trace
Do forever

  Address ISPEXEC
  "addpop row(5) column(5)"
  "Display Panel(PDSFTP)"
  If rc > 3 Then
     Exit 0

  "rempop"

  lower_case = 'abcdefghijklmnopqrstuvwxyz'
  upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

  Address TSO
  "Newstack"

  /* Queue initial commands */
  Queue ftpuser
  Queue ftppass
  Queue 'cd 'ftpdir
  Queue 'pwd'
  Queue 'stat'
  initcmds = 5

  If Translate(ftptcp) = "KNET" Then Do
    Queue "strip"
    Queue "hash 51200"
    initcmds = initcmds + 2
    End

  Address ISPEXEC

  If ftppinds = "" Then Do
    Call Do_ftp
    Iterate
    End

  If pos('*',ftppinds) > 1 Then Do
    parse value ftppinds with dsn_only "("
    If left(dsn_only,1) = "'" Then
      dsn_only = dsn_only"'"
    End
  Else
    dsn_only = ftppinds

  If sysdsn(dsn_only) <> "OK" Then Do
    zedsmsg = "Error"
    zedlmsg = "Specified data set does not exist:" ftppinds
    "SETMSG MSG(ISRZ001)"
    Call Delete_stack
    Iterate
    End
  Else Do
    x = listdsi(dsn_only)
    If pos("(",ftppinds) > 1 Then sysdsorg = "PS"
    Select
      When sysdsorg = "PS" | pos("(",ftppinds) > 1 Then Do
        If left(ftppinds,1) = "'" Then
          parse value ftppinds with "'" w_dsn "'"
        Else
          w_dsn = sysvar("syspref")"."ftppinds
        If pos("(",w_dsn) > 1 Then Do
          If pos("*",w_dsn) > 1 Then Do
            parse value w_dsn with "(" member ")"
            parse value w_dsn with lcd_name "("
            Queue "lcd '"lcd_name"'"
            If Translate(ftptcp) = "KNET" Then
              Queue "mput "member "(noprompt"
            Else
              Queue "mput "member
            Queue 'quit'
            End
          Else Do
            ext = substr(w_dsn,lastpos('.',w_dsn)+1,3)
            parse value w_dsn with "(" member ")"
            put = "put '"w_dsn"'" member"."ext
            Queue Translate(put,lower_case,upper_case)
            Queue 'quit'
            End
          End
        Else Do
          llq = substr(w_dsn,lastpos('.',w_dsn)+1)
          llq = Translate(llq,'. ','()')
          put = "put '"w_dsn"'" llq
          Queue Translate(put,lower_case,upper_case)
          Queue 'quit'
          End
        Call Do_ftp
        End
      When sysdsorg = "PO" Then Do
        Call Do_pds
        If queued() > initcmds Then Do
          Queue 'quit'
          Call Do_ftp
          End
        Else Call Delete_stack
        End
      Otherwise Nop;
      End
    End
End

Do_pds:
  "Lminit Dataid(dataid) Dataset("ftppinds") Enq(Shrw)"
  "Lmopen Dataid("dataid") Option(Input)"
  "Lmmdisp Dataid("dataid") Option(Display)",
    "Commands(Any) Panel(PDSFTPLM)"
  Do while rc == 0
    Call Process_selection
    "Lmmdisp Dataid("dataid") Option(Get)"
    If rc == 8 Then
      "Lmmdisp Dataid("dataid") Option(Display)",
        "Commands(Any) Panel(PDSFTPLM)"
  End
  "Lmmdisp Dataid("dataid") Option(Free)"
  "Lmclose Dataid("dataid")"
  "Lmfree  Dataid("dataid")"
  Return

Process_selection:
  If left(ftppinds,1) = "'" Then
    parse value ftppinds with "'" w_dsn "'"
  Else
    w_dsn = sysvar("syspref")"."ftppinds
  zlmember = strip(zlmember)
  Select
  When zllcmd = "/" | zllcmd = "S" Then Do
    "Lmmdisp Dataid("dataid") Option(Put) Member("zlmember")",
      "Zludata(*Queued)"
    ext = substr(w_dsn,lastpos('.',w_dsn)+1,3)
    put = "put '"w_dsn"("zlmember")'" zlmember"."ext
    Queue Translate(put,lower_case,upper_case)
    End
  When zllcmd = "B" Then Do
    "Lmmdisp Dataid("dataid") Option(Put) Member("zlmember")",
        "Zludata(*Browsed)"
    "Browse Dataid("dataid") Member("zlmember")"
    End
  When zllcmd = "V" Then Do
    "Lmmdisp Dataid("dataid") Option(Put) Member("zlmember")",
        "Zludata(*Viewed)"
    "View Dataid("dataid") Member("zlmember")"
    End
  Otherwise nop;
  End
  Return

Do_ftp:
  Address TSO
  If Translate(ftptcp) = "KNET" Then
    "CALL 'AP.KNET50C.CMDLIB(FTP)' '"ftpnode"'"
  Else
    "FTP "ftpnode
  Call Delete_stack
  Return

Delete_stack:
  Address TSO
  "Delstack"
  Return

/* J. KALINICH, X4521 */
/* Rexx dialog to FTP with MVS TCPIP.                         */
/* Generate FTP PUT commands for PDS members or sequential    */
/* file if a local DSN is entered on pop-up.                  */
./ ADD NAME=PLUG     0122-93316-97213-1427-00126-00102-00000-REXX
/* REXX */
ADDRESS ISREDIT
"ISREDIT MACRO (PLUGSTR COL LABEL1 LABEL2) NOPROCESS"
TRACE
IF plugstr = '?' |,
   TRANSLATE(plugstr) = 'HELP' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#PLUG)"
    EXIT 1
  END
IF plugstr = '' THEN
  DO
    zedsmsg = 'NO PLUG STRING'
    zedlmsg = 'YOU MUST SPECIFY A PLUG STRING'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    EXIT 12
  END
/* SEE IF LABELS WERE USED WITH NO COLUMN SPECIFIED */
IF SUBSTR(col,1,1) = '.' THEN
  DO
    label2 = label1
    label1 = col
    col = ''
  END
/* IF NO COLUMN SPECIFIED, THEN USE CURSOR POSITION */
IF col = '' THEN
  DO
    "ISREDIT (END)  = LRECL"
    "ISREDIT (CL,CC) = CURSOR"
    IF cc = 0 |,
       cc > end THEN
      DO
        zedsmsg = 'SPECIFY START COLUMN'
        zedlmsg = 'USE A NUMBER OR CURSOR LOCATION FOR START OF PLUG'
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
        EXIT 12
      END
    ELSE
      col = cc
  END
ELSE
  IF DATATYPE(col) <> 'NUM' THEN
    DO
      zedsmsg = 'START COLUMN NOT NUMERIC'
      zedlmsg = 'USE A NUMERIC FOR THE START COLUMN NUMBER'
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
      EXIT 12
    END
/* IF .LABELS WERE SPECIFIED, IGNORE (O) LINE RANGE */
IF SUBSTR(label1,1,1) = '.' THEN
  DO
    label1 = TRANSLATE(label1)
    label2 = TRANSLATE(label2)
    ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
    "ISREDIT (FR)  = LINENUM "label1
    IF rc > 0 THEN
      DO
        zedsmsg = 'PROBABLE LABEL ERROR'
        zedlmsg = '"'label1'" RECOGNIZED AS INVALID',
                  'OR UNDEFINED LABEL IN PLUG CMD'
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
        EXIT 12
      END
    "ISREDIT (LR)  = LINENUM "label2
    IF rc > 0 THEN
      DO
        zedsmsg = 'PROBABLE LABEL ERROR'
        zedlmsg = '"'label2'" RECOGNIZED AS INVALID',
                  'OR UNDEFINED LABEL IN PLUG CMD'
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
        EXIT 12
      END
    /* SET CURSOR ON FIRST LINE IN RANGE */
    "ISREDIT CURSOR = "label1 "1"
    labels = 'YES'
  END
/* PROCESS LINE COMMANDS, CHECK IF O/C WAS SPECIFIED */
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
"ISREDIT PROCESS RANGE O C"
IF rc > 0 &,
   labels <> 'YES' THEN
  DO
    zedsmsg = 'ENTER "O" LINE CMD'
    zedlmsg = 'YOU MUST SPECIFY THE "DATA" LINES',
              'TO BE PLUGGED, USING "On" OR "OO",',
              'OR LABELS'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    EXIT 12
  END
IF labels <> 'YES' THEN
  DO
    "ISREDIT (FR)  = LINENUM .ZFRANGE"
    "ISREDIT (LR)  = LINENUM .ZLRANGE"
    /* SET CURSOR ON FIRST LINE IN RANGE */
    "ISREDIT CURSOR = .ZFRANGE 1"
  END

pluglen = LENGTH(plugstr)
/* CHECK FOR PLUG STRING DELIMITERS */
IF SUBSTR(plugstr,1,1) = "'" |,
   SUBSTR(plugstr,1,1) = '"' THEN
  pluglen = pluglen - 2
ELSE
  plugstr = "'"plugstr"'"
anychar = COPIES('=',80)
i = fr
DO WHILE i <= lr
  "ISREDIT CHANGE P'"SUBSTR(anychar,1,pluglen)"'" plugstr col
  chgcc = rc
  IF chgcc > 0 THEN
    DO
      zedsmsg = "PLUG FAILED, RC="chgcc
      zedlmsg = "TARGET LINES "fr+0" TO "lr+0" AT COLUMN" col+0
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
      EXIT 12
    END
  i = i + 1
END
zedsmsg = "CHARS "plugstr" PLUGGED"
zedlmsg = "CHARS "plugstr" PLUGGED IN LINES "fr+0" TO "lr+0" AT COLUMN" col+0
ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
/* SET CURSOR ON FIRST LINE IN RANGE */
"ISREDIT CURSOR = "fr col
EXIT 0
/* J. KALINICH, X4521 */
/* EDIT MACRO TO PLUG DATA INTO A RANGE OF LINES             */
./ ADD NAME=PROFSET  0132-91345-97310-0805-00065-00037-00000-REXX
/* REXX */
ADDRESS ISREDIT
"ISREDIT MACRO (PARM)"
TRACE
parm = TRANSLATE(parm)
IF parm = 'HELP' |,
   parm = '?' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#PROFSET)"
    EXIT 0
  END
IF parm = '' THEN
  DO
    zedsmsg = "No parm specified"
    zedlmsg = "Specify an edit macro containing profile settings"
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END

ADDRESS ISPEXEC "VGET ZAPPLID"
profile = zapplid||EDIT
ADDRESS ISPEXEC "TBTOP "profile
ADDRESS ISPEXEC "TBSKIP "profile
skiprc = rc
prof. = ''
n = 1

DO WHILE skiprc = 0
  prof.n = zedptype zedplrcl zedprcfm
  ADDRESS ISPEXEC "TBSKIP "profile
  skiprc = rc
  prof.0 = n
  n = n + 1
END

x = MSG('OFF')
DO n = 1 to prof.0
  PARSE VAR prof.n ptype plrcl prcfm .
  IF ptype = 'ZDEFAULT' THEN
    NOP
  ELSE
    DO
      IF prcfm = 'V' THEN
        pblks = plrcl + 4
      ELSE
        pblks = plrcl
      /* Allocate temp file with matching low level qualifier,
         record length, and record format */
      ADDRESS TSO
      "ALLOC F($PROFSET) UNIT(SYSALLDA) NEW REUSE SPACE(1) TRACKS",
          "LRECL("plrcl") RECFM("prcfm") BLKSIZE("pblks")",
          "DA($PROFSET."ptype")"
      ADDRESS ISPEXEC "EDIT DATASET($PROFSET."ptype")",
           "MACRO("parm")"
      SAY n". Edit macro "parm "issued for ."ptype" edit profile"
      "DELETE $PROFSET."ptype
    END
END

EXIT

/* J. Kalinich, x4521 */
/* Edit macro to issue a set of profile commands for each        */
/* edit profile (low level qualifier) found in xxxEDIT.          */
/* Based on PROFLIST edit macro by Bob Zimmerman, CNA Insurance. */
./ ADD NAME=RESETID  0124-92339-96332-0646-00048-00012-00000-REXX
/* REXX */
TRACE
ARG userid
IF userid = '' THEN
  EXIT
IF SUBSTR(userid,1,2) = 'U=' THEN
  userid = DELSTR(userid,1,2)
user_attr = GETATTR()                  /* TSO attributes */
/* Sysprog? */
IF SUBSTR(user_attr,1,4) <> 'OPER' THEN
  DO
    zedsmsg = 'NOT AUTHORIZED'
    zedlmsg = 'YOU ARE NOT AUTHORIZED TO USE OPERATOR COMMANDS'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
uid_string = GETUID()
/* Security admin? */
IF SUBSTR(uid_string,6,2)  = 'CF' &,      /* Jobfunc */
   SUBSTR(uid_string,16,4) = 'ISSO' THEN  /* Group   */
  DO
    SAY 'ACF'
    QUEUE 'SET TERSE'
    QUEUE 'CHANGE 'userid' PSWD-VIO(0)'
    QUEUE 'END'
    ACF
  END
ELSE
  DO
    /* Prevent SDSF panel from displaying after operator command */
    /* with optional mod to panel ISFPANEL or ISFPCU4x           */
    sdsfoper = 'END'
    ADDRESS ISPEXEC "VPUT (SDSFOPER) SHARED"

    /* Leave out NEWAPPL(ISF) or sdsfoper variable not passed */
    ADDRESS ISPEXEC,
      "SELECT PGM(ISFISP)",
      "PARM(/F ACF2,RESET("userid"))"
  END

zedsmsg = 'ACF2 RESET ISSUED'
zedlmsg = 'ACF2 RESET ISSUED FOR U='userid
ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"

EXIT
/* J. KALINICH, X4521 */
/* EXEC TO REDUCE ACF2 PASSWORD VIOLATION COUNT BY 1        */
/* IF TSO OPERATOR PRIVILEGE OR TO ZERO IF SECURITY ADMIN   */
./ ADD NAME=RUNACF   0153-96068-97164-0908-00066-00040-00000-REXX
/* REXX */
TRACE
ADDRESS ISREDIT
"ISREDIT MACRO (PARM) NOPROCESS"

parm = TRANSLATE(parm)
IF parm = 'HELP' |,
   parm = '?' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#RUNACF)"
    EXIT 0
  END

/* PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED */
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
"ISREDIT PROCESS RANGE C"
IF rc > 0 THEN
  DO
    zedsmsg = 'ENTER "Cn" LINE CMD'
    zedlmsg = 'YOU MUST SPECIFY THE "DATA" LINES',
              'TO BE PASSED TO ACF, USING "Cn" OR "CC"'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END

"ISREDIT (FR)  = LINENUM .ZFRANGE"
"ISREDIT (LR)  = LINENUM .ZLRANGE"

/* SET CURSOR ON FIRST LINE IN RANGE */
"ISREDIT CURSOR = .ZFRANGE 1"

i = fr
DO WHILE i <= lr
  "ISREDIT (LINE) = LINE "i
  QUEUE line
  i = i + 1
END
QUEUE 'END'  /* terminate continuations, if needed */
QUEUE 'END'  /* terminate command processor        */

IF parm = 'DATA' |,
   parm = 'NOTE' THEN
  DO
    x = OUTTRAP("trap.","*")
    ADDRESS TSO
    "ACF"
    x= OUTTRAP("off")

    DO line = trap.0 TO 1 BY -1
      acfout = trap.line
      "ISREDIT LINE_AFTER "lr" = "parm"LINE (acfout)"
    END
    "ISREDIT LINE_AFTER "lr" = MSGLINE 'ACF OUTPUT'"
  END
ELSE
  DO
    ADDRESS TSO
    "ACF"
  END

/* SET CURSOR ON FIRST LINE IN RANGE */
"ISREDIT CURSOR = "fr 0

EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO SEND ACF SUBCOMMANDS TO ACF COMMAND PROCESSOR */
./ ADD NAME=SORTWORK 0113-93055-94118-0714-00059-00068-00000-REXX
/* REXX */
PARSE ARG debug .
IF TRANSLATE(debug) = "DEBUG" THEN
  TRACE RESULTS
ELSE
  TRACE OFF
dispcc = 0
DO WHILE dispcc < 8
  "ISPEXEC DISPLAY PANEL(SORTWORK)"
  dispcc = rc
  IF dispcc = 8 THEN EXIT
  trace i
  SELECT
  WHEN dtyp = 3330 THEN
    DO
      trkcap = 13030
      trkcyl = 19
    END
  WHEN dtyp = 3350 THEN
    DO
      trkcap = 19069
      trkcyl = 30
    END
  WHEN dtyp = 3380 THEN
    DO
      trkcap = 47476
      trkcyl = 15
    END
  WHEN dtyp = 3390 THEN
    DO
      trkcap = 56664
      trkcyl = 15
    END
  OTHERWISE
    DO
      SAY 'Impossible to get here',
          '(unless panel logic modified) - bye.'
      EXIT
    END
  END
/* SYNCSORT RELEASE 3.5 (PAGE 11.10) */
ttrk = (numrec * lrecl * 1.3) / trkcap
IF ((numrec * lrecl * 1.3) // trkcap) ¬= 0 THEN
  ttrk = (ttrk + 1) % 1
tcyl = ttrk / trkcyl
IF (ttrk // trkcyl) ¬= 0 THEN
  tcyl = (tcyl + 1) % 1
ttrksw = ttrk / numsw
IF (ttrk // numsw) ¬= 0 THEN
  ttrksw = (ttrksw + 1) % 1
tcylsw = tcyl / numsw
IF (tcyl // numsw) ¬= 0 THEN
  tcylsw = (tcylsw + 1) % 1
/* RECOMPUTE TOTAL TRACKS AND CYLINDERS AFTER ROUNDING */
ttrk = ttrksw * numsw
tcyl = tcylsw * numsw
END
/* J.KALINICH, X4521 */
/* EXEC TO COMPUTE SYNCSORT SORTWORK SPACE CALCULATION          */
./ ADD NAME=TESTACF  0175-96068-97114-0616-00108-00040-00000-REXX
/* REXX */
TRACE
"ISREDIT MACRO (LID PARM ACCESS) NOPROCESS"

"NEWSTACK"
IF LENGTH(lid) = 0 THEN
  DO
    zedsmsg = 'LID or UID string missing'
    zedlmsg = 'A logonid or UID(string) is a required parameter'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001)"
    EXIT 12
  END

lid =    TRANSLATE(lid)
parm =   TRANSLATE(parm)
access = TRANSLATE(access)

IF lid = 'HELP' |,
   lid = '?' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#TESTACF)"
    EXIT 0
  END

/* Process line commands, check if C was specified */
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
"ISREDIT PROCESS RANGE C"
IF rc > 0 THEN
  DO
    zedsmsg = 'Enter "Cn" line cmd'
    zedlmsg = 'You must specify the "DATA" lines',
              'to be tested by ACF, using "Cn" or "CC"'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END

"ISREDIT (FR)  = LINENUM .ZFRANGE"
"ISREDIT (LR)  = LINENUM .ZLRANGE"

/* Set cursor on first line in range */
"ISREDIT CURSOR = .ZFRANGE 1"

i = fr
DO WHILE i <= lr
  "ISREDIT (LINE) = LINE "i
  IF POS('DSN=',line) > 0 THEN
    DO
      PARSE VALUE line WITH "DSN=" rule "." dsn .
      PARSE VALUE dsn WITH dsn "," rest .

      QUEUE 'DECOMP 'rule         /* Test if rule exists */
      QUEUE 'END'                 /* Terminate ACF command */
      x = OUTTRAP("trap.","*")
      ADDRESS TSO
     "ACF"
      acfrc = rc
      x= OUTTRAP("off")

      IF POS('&',rule) > 0 |,     /* Skip symbolics */
         POS('&',dsn)  > 0 |,     /* Skip symbolics */
         acfrc > 0 THEN           /* Skip if no rule */
        NOP
      ELSE
        DO

          QUEUE 'TEST 'rule
          QUEUE 'DSN('dsn') -'
          IF access = '' THEN
            access = 'READ'
          QUEUE 'ACCESS('access') -'
          IF SUBSTR(lid,1,4) = 'UID(' THEN
            QUEUE lid
          ELSE
            QUEUE 'LID('lid')'
          QUEUE 'END'       /* Terminate TEST subcommand */
          QUEUE 'END'       /* Terminate ACF command */
          IF parm = 'DATA' |,
             parm = 'NOTE' THEN
            DO
              x = OUTTRAP("trap.","*")
              ADDRESS TSO
             "ACF"
              x= OUTTRAP("off")

              DO line = trap.0 TO 1 BY -1
                acfout = trap.line
                "ISREDIT LINE_AFTER "i" = "parm"LINE (acfout)"
              END
              "ISREDIT LINE_AFTER "i" = MSGLINE 'ACF TEST OUTPUT'"
            END
          ELSE
            DO
              ADDRESS TSO
             "ACF"
            END
        END
    END
    i = i + 1
END


/* Set cursor on first line in range */
"ISREDIT CURSOR = "fr 0

"DELSTACK"
EXIT
/* J. KALINICH, X4521 */
/* EDIT MACRO TO TEST ACF RULES USING DSNAMES IN JCL        */
./ ADD NAME=TRAPCMD  0111-92177-94336-0815-00033-00036-00000-REXX
/* REXX */
TRACE
PARSE ARG tsocmd parm
tsocmd = TRANSLATE(tsocmd)
ADDRESS ISPEXEC
"ISPEXEC TBCREATE TRAPTBL NAMES(CMDLINE) NOWRITE REPLACE"
IF rc > 4 THEN
  DO
    SAY TBCREATE failed
    EXIT
  END
dquayle = outtrap("sysoutline.","*")
ADDRESS TSO
tsocmd parm
ADDRESS ISPEXEC
DO i = 1 to sysoutline.0
  cmdline = sysoutline.i
  "ISPEXEC TBADD TRAPTBL"
  IF rc <> 0 THEN
    DO
      SAY TBADD failed
    END
END
"ISPEXEC TBTOP TRAPTBL"
tbcc = 0
DO WHILE tbcc < 8
  "ISPEXEC TBDISPL TRAPTBL PANEL(TRAPTBL) CURSOR(ZCMD)"
  tbcc = rc
END
"ISPEXEC TBCLOSE TRAPTBL"
EXIT
/* J. KALINICH, X4521 */
/* EXEC TO TRAP AND DISPLAY TSO COMMAND OUTPUT IN ISPF TABLE         */
./ ADD NAME=WEAVE    0144-93316-98168-0729-00108-00102-00000-REXX
/* REXX */
ADDRESS ISREDIT
"ISREDIT MACRO (LABEL1 LABEL2 CUTTBL) NOPROCESS"
TRACE
IF label1 = '?' |,
   TRANSLATE(label1) = 'HELP' THEN
  DO
    ADDRESS ISPEXEC "DISPLAY PANEL(#WEAVE)"
    EXIT 1
  END
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
/* IF .LABELS WERE SPECIFIED, IGNORE (O) LINE RANGE */
IF SUBSTR(label1,1,1) = '.' &,
   SUBSTR(label2,1,1) = '.' THEN
  DO
    label1 = TRANSLATE(label1)
    label2 = TRANSLATE(label2)
    "ISREDIT (FR)  = LINENUM "label1
    IF rc > 0 THEN
      DO
        zedsmsg = 'PROBABLE LABEL ERROR'
        zedlmsg = '"'label1'" RECOGNIZED AS INVALID',
                  'OR UNDEFINED LABEL IN PASTEES CMD'
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
        EXIT 12
      END
    "ISREDIT (LR)  = LINENUM "label2
    IF rc > 0 THEN
      DO
        zedsmsg = 'PROBABLE LABEL ERROR'
        zedlmsg = '"'label2'" RECOGNIZED AS INVALID',
                  'OR UNDEFINED LABEL IN PASTEES CMD'
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
        EXIT 12
      END
    /* SET CURSOR ON FIRST LINE IN RANGE */
    "ISREDIT CURSOR = "label1 "1"
    labels = 'YES'
  END
/* PROCESS LINE COMMANDS, CHECK IF O/C WAS SPECIFIED */
"ISREDIT PROCESS RANGE O C"
IF rc > 0 &,
   labels <> 'YES' THEN
  DO
    zedsmsg = 'ENTER "O" LINE CMD'
    zedlmsg = 'YOU MUST SPECIFY THE "DATA" LINES',
              'TO BE INTERLACED, USING "On" OR "OO",',
              'OR LABELS'
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
IF labels <> 'YES' THEN
  DO
    "ISREDIT (FR)  = LINENUM .ZFRANGE"
    "ISREDIT (LR)  = LINENUM .ZLRANGE"
    /* SET CURSOR ON FIRST LINE IN RANGE */
    "ISREDIT CURSOR = .ZFRANGE 1"
  END
IF cuttbl <> '' THEN
  ct = TRANSLATE(cuttbl)
ELSE
  DO
    ADDRESS ISPEXEC "VGET (CUTNAME) PROFILE"
    ct = cutname
  END
cutpst = cutpst||ct
ADDRESS ISPEXEC "TBOPEN "cutpst" NOWRITE SHARE"
IF rc <> 0 THEN
  DO
    zedsmsg = "TABLE ERROR"
    zedlmsg = "TBOPEN FAILED FOR CUT TABLE '"ct"'"
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
ADDRESS ISPEXEC "TBQUERY "cutpst" ROWNUM("cutcnt")"
IF cutcnt <= 0 THEN
  DO
    zedsmsg = "USE CUT FIRST"
    zedlmsg = "NO DATA HAS BEEN STORED VIA THE CUT MACRO"
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
    EXIT 12
  END
i = fr
DO WHILE i <= (((lr - fr) * (cutcnt + 1)) + fr)
  /* GET EACH CUT LINE FROM THE TABLE AND INTERLACE INTO RANGE */
  j = cutcnt
  ADDRESS ISPEXEC "TBBOTTOM "cutpst
  DO WHILE j > 0
    "ISREDIT LINE_AFTER "i" = DATALINE (CTPT)"
    lacecc = rc
    IF lacecc > 12 THEN
      DO
        zedsmsg = "INTERLACE FAILED, RC="lacecc
        zedlmsg = "TARGET LINES "fr+0" TO "lr+0
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
        EXIT 12
      END
    ADDRESS ISPEXEC "TBSKIP "cutpst" NUMBER(-1)"
    j = j - 1
  END
  i = i + (cutcnt + 1)
END
zedsmsg = "TABLE '"ct"' INTERLACED"
zedlmsg = "CUT TABLE '"ct"' INTERLACED INTO LINES "fr+0" TO "lr+0
ADDRESS ISPEXEC "SETMSG MSG(ISRZ001W)"
EXIT 0
/* J. KALINICH, X4521 */
/* EDIT MACRO TO INTERLACE PDS 8.5 CUT TABLE INTO A RANGE OF LINES  */
