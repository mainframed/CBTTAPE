         TITLE ' T S O   I N T E R F A C E  TO  T S S O / TSSOPCMD'
OSCMD    CSECT
***********************************************************************
* THIS IS THE OSCMD TSO COMMAND PROCESSOR. IT IS THE PRIMARY INTERFACE*
* TO TSSO FROM A TSO CLIST. IT IS DESIGNED TO ISSUE MVS COMMANDS, AND *
* OPTIONALLY (THROUGH TSSOPCMD) RETRIEVE THE OUTPUT AND PLACE IT INTO *
* CLIST VARIABLES. OSCMD WILL BEHAVE DIFFERENTLY DEPENDING ON HOW IT  *
* IS CALLED. THE FOLLOWING TABLE DEPICTS OSCMD COMMAND BEHAVIOR.      *
*                                                                     *
*---------------------------------------------------------------------*
*         OSCMD IS CALLED FROM A CLIST                                *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*                                                                     *
*                                                                     *
*                TSO ADDRESS SPACE              TSSO ADDRESS SPACE    *
*                -----------------              ------------------    *
*                                                                     *
*                                                                     *
*                MAXCMDOUT DEFAULT - 200        MAXCMDOUT DEFAULT     *
*                CMDWAIT   DEFAULT - 1 SEC      IS 200.               *
*                                                                     *
*                CMDRESP VARIABLE DETERMINES    CMDWAIT DEFAULT IS 1  *
*                WHERE COMMAND RESPONSE SHOULD  SECOND                *
*                GO                                                   *
*                                                                     *
*                CMDRESP = 'CLIST' -                                  *
*                  CLIST VARIABLES CONTAINING   CMDRESP VARIABLE      *
*                  COMMAND RESPONSE ARE         DETERMINES WHERE      *
*                  GENERATED                    RESPONSE GOES.        *
*                                                                     *
*                CMDRESP = 'TERMINAL'                                 *
*                  OUTPUT IS DISPLAYED ON       CMDRESP = 'CLIST'     *
*                  TERMINAL.                     CLIST VARIABLES      *
*                                                CONTAINING RESPONSE  *
*                                                ARE GENERATED.       *
*                AUTHORITY IS BASED ON OSCMDATH                       *
*                HOWEVER, IF USER IS NOT                              *
*                AUTHORIZED, THEN THE CMDRESP   CMDRESP = 'NOWHERE'   *
*                MUST BE RETURNED TO THE USER    COMMAND IS ISSUED -  *
*                OR THE CLIST.                   RESPONSE NOT RETURNED*
*                                                                     *
*                                                                     *
*                                               CMDRESP DEFAULT =     *
*                                                'CLIST' IF MAXCMDOUT *
*                                                IS SPECIFIED.        *
*                                                                     *
*                                                                     *
*                                               AUTHORITY BASED ON    *
*                                               INVOKING CONSOLE      *
*---------------------------------------------------------------------*
*         OSCMD IS NOT CALLED FROM A CLIST                            *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*                                                                     *
*                                                                     *
*                TSO ADDRESS SPACE              TSSO ADDRESS SPACE    *
*                -----------------              ------------------    *
*                                                                     *
*                                                                     *
*                MAXCMDOUT DEFAULT IS                ILLEGAL          *
*                200                                                  *
*                                                                     *
*                                                                     *
*                CMDWAIT DEFAULT IS 1 SECOND                          *
*                                                                     *
*                                                                     *
*                RESPONSE IS RETURNED TO THE                          *
*                TERMINAL                                             *
*                                                                     *
*                                                                     *
*                AUTHORITY IS BASED ON OSCMDATH                       *
*                MODULE.                                              *
*                                                                     *
***********************************************************************
***********************************************************************
***********************************************************************
*                                                                     *
*  FIXES                                                              *
*     15OCT92  GLA  PUT IN CHANGES FROM 4.2 VERSION                   *
*                   A. ADD SUPPORT FOR REXX EXECS TO USE VIA          *
*                      VARIABLES SYSAUTH_MAXCMDOUT AND SYSAUTH_CMDWAIT*
*                   B. WITH ES/9000 PROCESSORS THE HARDWARE SYSTEM    *
*                      CONSOLE IS CONID=100, BUT DOESN'T HAVE A UCME  *
*                      THEREFORE HANDLE AS SPECIAL CASE. NOTE,        *
*                      NO MVS SYSTEM CAN HAVE MORE THAN 99 CONSOLES   *
*                      (SYSTEM OR SYSPLEX!!).                         *
*                                                                     *
*     NOV 2002 EEJ  Support MCS extended consoles               EEJ1102
*                                                               EEJ1102
***********************************************************************
***********************************************************************
         EQUATES
         STM   R14,R12,12(R13)    SAVE CALLERS REGSITERS
         LR    R12,R15            LOAD ENTRY POINT OF OSCMD
         LR    R8,R1              SAVE INPUT PARMS.
         USING OSCMD,R12
         B     EYE1
         COPY  EYECATCH
EYE1     DS    0H
         LA    R7,4095(R12)       I HATE TO USE R7 AS A SECOND BASE
         LA    R7,1(R7)           BUT I REALLY DIDNT HAVE A CHOICE..
         USING OSCMD+4096,R7
         GETMAIN R,LV=72          WE NEED STORAGE FOR THE SAVE AREA
         ST    R13,4(R1)          STORE ADDRESS OF CALLERS SAVE AREA
*                                  SAVE AREA
         ST    R1,8(R13)          REMEMBER WHERE THIS CORE IS
         LR    R13,R1             KEEP A COPY IN R13
*
         GETMAIN R,LV=4096         GETMAIN SOME PRIVATE STORAGE...
         LR    R11,R1
         USING OSCMDATD,R11
***********************************************************************
* THIS SECTION OF THE CODE SETS UP THE TSO IOPL, ALLOWING FOR GETLINE *
* AND PUTLINE.                                                        *
***********************************************************************
         LA    R2,IOPLADS
         USING IOPL,R2
         L     R3,0(8)
         ST    R3,CPPLCBUF
         L     R3,4(8)
         ST    R3,CPPLUPT
         ST    R3,IOPLUPT
         L     R3,8(8)
         ST    R3,CPPLPSCB
         L     R3,12(8)
         ST    R3,CPPLECT
         ST    R3,IOPLECT
         L     R3,ECBADS
         ST    R3,IOPLECB
         DROP  R2
         XC    FLAGS(4),FLAGS
***********************************************************************
* SINCE OSCMD IS A RE-ENTRANT MODULE, WE WILL COPY THE CONSTANTS INTO *
* THE VARIABLE WORK AREA.                                             *
***********************************************************************
         MVC   LINE1HD(80),LINE1HC
         MVC   LINE2HD(80),LINE2HC
         MVC   LINE3HD(80),LINE3HC
         MVC   LINE4HD(80),LINE4HC
         MVC   LINE5HD(80),LINE5HC
         MVC   LINE6HD(80),LINE6HC
         MVC   LINE7HD(80),LINE7HC
         MVC   LINE8HD(80),LINE8HC
         MVC   LINE9HD(80),LINE9HC
         MVC   LINE10HD(80),LINE10HC
         MVC   LINE11HD(80),LINE11HC
         MVC   LINE12HD(80),LINE12HC
         MVC   LINE13HD(80),LINE13HC
         MVC   LINE14HD(80),LINE14HC
         MVC   LINE15HD(80),LINE15HC
         MVC   LINE16HD(80),LINE16HC
*        MVC   LINE17HD(80),LINE17HC
*
         MVC   OSCALL1D(OSCALL1E-OSCALL1C),OSCALL1C
         MVC   OSCALL2D(OSCALL2E-OSCALL2C),OSCALL2C
         MVC   PUTBLOK(PUTBLOKE-PUTBLOKC),PUTBLOKC
*
         LA    R2,MVSCMD+4
         ST    R2,PARMCMD          SET UP PARMS TO TSSOPCMD
         LA    R2,MVSCMDL
         ST    R2,PARMCMDL
         LA    R2,USERID
         ST    R2,PARMUSER         SET UP ANOTHER PARM TO TSSOPCMD
         LA    R2,ERRORCDE
         ST    R2,PARMERR          AND ANOTHER
         LA    R2,AUTHBYTE
         ST    R2,PARMAUTH         AND ANOTHER
         LA    R2,WAITTIME
         ST    R2,PARMWTME         YET ANOTHER.
         LA    R2,MAXLINES
         ST    R2,PARMLINE         AND ANOTHER...
*
EXTCMD   DS    0H
         L     R2,CPPLCBUF         POINT TO THE COMMAND BUFFER
         LH    R3,2(R2)            GET THE OFFSET TO THE FIRST OPERAND
         LH    R4,0(R2)            GET THE TOTAL LENGTH OF THE BUFFER
         LA    R5,4(R3,R2)         R5 NOW POINTS TO THE MVS COMMAND
         LA    R3,0(R2,R4)         R3 NOW POINTS TO THE END OF THE
*                                  BUFFER
         SR    R3,R5               R3 NOW HAS THE LENGTH OF THE COMMAND
         LTR   R3,R3
         CH    R3,=H'1'            AT LEAST ONE CHARACTER LONG
         BL    ERROR7
         MVI   MVSCMD+4,X'40'
         MVC   MVSCMD+5(125),MVSCMD+4   BLANK OUT THE PREVIOUS MVS
*                                     COMMAND
         MVI   CMDRESPV,X'40'
         MVC   CMDRESPV+1(7),CMDRESPV
*
         MVC   MVSCMD(2),=H'127'
         MVC   MVSCMD+2(2),=H'0'
         ST    R3,MVSCMDL          STORE AWAY LENGTH
         BCTR  R3,0
         EX    R3,MOVECMD
         B     AR1
MOVECMD  MVC   MVSCMD+4(0),0(R5)     ** EXECUTED **
AR1      DS    0H
*
         L     R2,CPPLPSCB
         USING PSCB,R2
         MVC   USERID(8),=CL8' '
         MVC   USERID(7),PSCBUSER
         DROP  R2
*
***********************************************************************
* MVS AUTHORIZATION IS REQUIRED TO RUN THIS MODULE, LETS CHECK.       *
*                                                                     *
***********************************************************************
         TESTAUTH FCTN=1           ARE WE AUTHORIZED ?
         LTR   R15,R15
         BNZ   ERROR1             NOT EVEN AUTHORIZED...
*
***********************************************************************
* WE MUST CHECK TO SEE IF THE ENVIRONMENT IS AMENIABLE TO RUNNING THE *
* COMMAND. LETS CHECK IF TSSO WILL BE AVAILABLE TO PROCESS THIS       *
* COMMAND.                                                            *
***********************************************************************
         GETCVT (R10)
         LTR   R10,R10           IS TSSO EVEN THERE ?
         BZ    ERROR12          NO, BLOW HIM AWAY
         USING TSSOCVT,R10
         TM    TSSOFLG1,TSSOGONE TSSO BLOWN AWAY ?
         BO    ERROR12
         TM    TSSOFLG2,TSSOPLOA WAS OPCMD LOADED ?
         BNO   ERROR12           BAD NEWS...
         L     R2,OPCMDADR       GET OPCMD ADDRESS
         ST    R2,AOPCMD         AND PUT IT AWAY FOR LATER
         L     R2,X'224'         GET OUR ASCB
         C     R2,TSSOASCB       IS THIS THE TSSO ADDRESS SPACE ?
         BNE   NOTTSSO
         OI    FLAGS,X'40'       YES, IT IS THE TSSO ADDRESS SPACE
         DROP  R10
NOTTSSO  DS    0H
*
***********************************************************************
* NEXT, CHECK THE VALUE OF THE CLIST VARIABLES... ALSO, CHECK TO SEE  *
* IF WE ARE RUNNING UNDER A CLIST. SINCE THIS IS EASILY DONE BY TRYING*
* TO OBTAIN THE VALUE OF A CLIST VARIABLE, LETS HAVE AT IT.           *
*                                                                     *
***********************************************************************
         L     R9,16               GET CVT
         USING CVT,R9
         L     R9,CVTTVT           GET TIME SHARING VECTOR TABLE
         USING TSVT,R9
         LTR   R9,R9               IS THIS A TSO/E R2 SYSTEM ?
         BZ    NOCLIST             FAKE NO CLIST...
***********************************************************************
* THE NEXT STEP IS TO EXTRACT THE VALUE OF THE CMDRESP CLIST VARIABLE,*
* IF ONE EXISTS..                                                     *
***********************************************************************
         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO
         ST    R15,VACCRTN         STORE THIS SUCKER AWAY
*
         LA    R2,TSVNOIMP         "ENTRY CODE" = RETRIEVE
         ST    R2,ECODE            SET PARM 1
***********************************************************************
* EXTRACT CLIST VARIABLE  "CMDRESP"                                   *
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
*
         CALL  (15),                                                   X
               (ECODE,             ENTRY CODE                          X
               CMDRESPA,           PTR TO VAR NAME                     X
               CMDRESPL,           PTR TO VAR LENGTH                   X
               VALPTR,             PTR TO VALUE                        X
               VALLENGT,           PTR TO VALUE LENGTH                 X
               TOKEN),             TOKEN                               X
               VL,MF=(E,OSCALL1D)
         LTR   R15,R15
         BZ    CMDRESPF            YUP, COMMAND RESPONSE VARIABLE
*                                  WAS FOUND ... PROCESS.
         CH    R15,=H'40'          INCORRECT ENVIRONMENT ?
         BE    NOCLIST             YUP - CLIST ENVIRONMENT NOT ACTIVE
         OI    FLAGS,X'80'         SET CLIST BIT.
         CH    R15,=H'52'          CMDRESP NOT FOUND
         BE    CMDRESNF            COMMAND RESPONSE NOT FOUND
         B     ERROR3              UNKNOWN ERROR
CMDRESPF DS    0H
         OI    FLAGS,X'80'         INDICATE CLIST IS ACTIVE
         L     R2,VALPTR           POINT TO CMDRESP VARIABLE
         L     R3,VALLENGT         GET ITS LENGTH
         LTR   R3,R3
         BZ    CMDRESNF            SIMULATE THIS VARIABLE NOT FOUND
         BCTR  R3,0
         CH    R3,=H'7'            CHECK OUT LENGTH
         BH    ERROR5              BAD NEWS... INVALID CMDRESP VAR
         EX    R3,MOVERESP         MOVE THE RESPONSE
         B     AR2
MOVERESP MVC   CMDRESPV(0),0(R2)    ** EXECUTED **
AR2      DS    0H
         CLC   CMDRESPV(8),=CL8'TERMINAL'
         BE    PASTRESP
         CLC   CMDRESPV(8),=CL8'CLIST'
         BE    PASTRESP
         CLC   CMDRESPV(8),=CL8'NOWHERE'
         BE    PASTRESP
         B     ERROR5              GO PAST THE RESPONSE...
CMDRESNF DS    0H
***********************************************************************
* DEFAULT VALUE OF COMMAND RESPONSE MUST BE DELAYED UNTIL AFTER WE
* HAVE THE MAXCMDOUT VALUE.
***********************************************************************
         MVC   CMDRESPV(8),=CL8'NOTSPEC'  PUT IN DUMMY VALUE FOR NOW
         B     PASTRESP
NOCLIST  DS    0H
***********************************************************************
* WE COME HERE IF THE ATTEMPT TO OBTAIN THE CMDRESP VARIABLE FAILED   *
* BECAUSE WE ARE NOT RUNNING UNDER A CLIST. WE WILL SET THE NOCLIST   *
* BIT, WHICH WILL SIGNAL MAXCMDOUT AND CMDWAIT DEFAULTS...            *
***********************************************************************
         NI    FLAGS,255-X'80'      SET NO CLIST FLAG
PASTRESP DS    0H
***********************************************************************
* THE NEXT STEP IS TO DETERMINE THE VALIDITY OF THE ENVIRONMENT. WE   *
* HAVE THE FOLLOWING VARIABLES: CMDRESP, TSSO/NOTSSO AND CLIST/NOCLIST*
* THE FOLLOWING PSEUDOCODE REPRESENTS THE PROCESS                     *
*                                                                     *
* IF CLIST=YES THEN                                                   *
*    IF TSSO=YES THEN                                                 *
*      IF CMDRESP=' ' AND MAXCMDOUT IS DEFINED THEN                   *
*       CMDRESP='CLIST'                                               *
*      IF CMDRESP=' ' AND MAXCMDOUT NOT DEFINED THEN                  *
*       CMDRESP='NOWHERE'                                             *
*                                                                     *
*      IF CMDRESP='TERM' INVALID    AUTHORITY BASED ON INVOKING       *
*      IF CMDRESP='CLIST' VALID    CONSOLE. SS CONSOLE USED           *
*      IF CMDRESP='NOWHERE' VALID           SS CONSOLE NOT USED       *
*                                                                     *
* IF CLIST=YES THEN                                                   *
*    IF TSSO=NO THEN                                                  *
*      IF CMDRESP=' ' THEN CMDRESP='NOWHERE'                          *
*                                                                     *
*    CMDRESP='TERM'    VALID                                          *
*    CMDRESP='CLIST'   VALID     SS CONSOLE WILL ALWAYS BE USED       *
*    CMDRESP='NOWHERE' VALID     AUTHORITY BASED ON CALL TO OSCMDATH  *
*                                                                     *
*                                                                     *
* IF CLIST=NO THEN
*    IF TSSO=YES THEN COMMAND IS INVALID
*
*    IF TSSO=NO THEN                                                  *
*       CMDRESP='TERM'  DEFAULT... SS CONSOLE USED AUTH BASED ON CALL *
*                                  TO OSCMDATH                        *
*                                                                     *
*                                                                     *
*                                                                     *
*    MAXCMDOUT AND CMDWAIT CLIST VARS WILL BE USED IF AVAILABLE, ELSE *
*    THE DEFAULTS ARE TAKEN: MAXCMDOUT-200    CMDRESP-1 SECOND        *
*                                                                     *
***********************************************************************
         TM    FLAGS,X'80'        IS THIS A CLIST ?
         BNO   PROCNCLS           NO - PROCESS NON CLIST ACTIVITY
PROCCLST DS    0H
***********************************************************************
* WE COME HERE TO PROCESS THE VARIABLES IF WE ARE RUNNING UNDER A     *
* CLIST                                                               *
***********************************************************************
         TM    FLAGS,X'40'        UNDER CLIST AND UNDER TSSO ?
         BO    PROCCTSS           YUP - GOTTA TO PROCESS UT
*
***********************************************************************
* WE COME HERE TO PROCESS THE CASE WHERE WE ARE UNDER A CLIST BUT     *
* NOT USING TSSO. ALL VALUES OF CMDRESP ARE VALID, BUT WE NEED TO     *
* CHECK IF ONE WAS SPECIFIED.                                         *
***********************************************************************
GTCMDVAR DS    0H
         CALL  OSCMDATH,(AUTHBYTE),MF=(E,OSCALL2D)
         LTR   R15,R15
         BNZ   ERROR11
         B     GETVARS
*
PROCCTSS DS    0H
***********************************************************************
* WE COME HERE TO PROCESS THE CASE WHERE WE ARE IN A CLIST, AND USING *
* TSSO.    THE DEFAULT FOR CMDRESP WILL BE SET BASED ON THE VALUE OF  *
* THE MAXCMDOUT VARIABLE. IN THIS CASE, WE MUST GET THIS VALUE BEFORE *
* PROCEEDING. WHILE WE ARE HERE, LETS CHECK FOR INVALID REQUESTS OF   *
* CMDRESP VARIABLE.
***********************************************************************
         CLC   CMDRESPV(8),=CL8'TERMINAL' TSSO TERMINAL - DOESNT MAKE
*                                         SENSE
         BE    ERROR4
         B     GETVARS            GET THE REST OF THE VARIABLES
PROCNCLS DS    0H
***********************************************************************
* WE COME HERE IF WE ARE NOT OPERATING UNDER A CLIST                  *
*                                                                     *
***********************************************************************
         TM    FLAGS,X'40'        NOT UNDER CLIST AND UNDER TSSO
         BO    PRONCTSS           YUP - GOTTA PROCESS IT.
PROCNCNT DS    0H
***********************************************************************
* WE COME HERE IF WE ARE NOT RUNNING A CLIST, AND WE ARE NOT UNDER    *
* TSSO. THIS IS THE CASE OF A STRAIGHT OSCMD COMING FROM A TSO USER.  *
***********************************************************************
         MVC   CMDRESPV(8),=CL8'TERMINAL'  ASSIGN DEFAULT TO CMDRESPV
         CALL  OSCMDATH,(AUTHBYTE),MF=(E,OSCALL2D)
         LTR   R15,R15
         BNZ   ERROR11
         B     GETVARS                     AND GET REST OF VARS
*
PRONCTSS DS    0H
***********************************************************************
* WE COME HERE IF WE ARE NOT RUNNING A CLIST, AND WE ARE UNDER TSSO.  *
* THIS IS AN ERROR, AS AN OPERATING WOULD NOT NEED OSCMD TO ISSUE MVS *
* COMMANDS.                                                           *
***********************************************************************
         B     ERROR4
*
GETVARS  DS    0H
***********************************************************************
* METHOD OF OPERATION:                                                *
*                                                                     *
* NOW THAT WE HAVE VALUE FOR THE KEY "CLIST" "CMDRESP" AND "TSSO"     *
* VARIABLES, AND THEY ARE VALID, LET US GET THE VALUES OF THE         *
* MAXCMDOUT AND CMDWAIT VARIABLES. THESE MAY BE OBTAINED FROM THE     *
* CLIST, OR DEFAULTED TO IF NOT PRESENT IN THE CLIST, OR IF OSCMD     *
* IS NOT RUNNING UNDER A CLIST. NOTE THAT THE AUTHORITY BYTE IS       *
* ALSO FILLED IN, IF NOT RUNNING UNDER TSSO. IF OSCMD IS RUNNING      *
* UNDER TSSO, THE AUTHORITY BYTE WILL WAIT UNTIL WE FIGURE OUT THE    *
* CMDRESP VARIABLE.                                                   *
***********************************************************************
*
***********************************************************************
* STEP 1: OBTAIN THE VALUE OF MAXCMDOUT.                              *
***********************************************************************
         TM    FLAGS,X'80'         RUNNING UNDER CLIST?
         BNO   DEFCMDOT            YUP, GO DEFAULT MAXCMDOUT
         CLC   CMDRESPV(8),=CL8'NOWHERE'   RESPONSE GOING NOWHERE ?
         BE    DEFCMDOT                    YUP - DONT BOTHER.
         L     R15,TSVTVACC        GET ADDRESS OF CLIST ROUTINE TO
         ST    R15,VACCRTN         STORE THIS SUCKER AWAY
*
         LA    R2,TSVNOIMP         "ENTRY CODE" = RETRIEVE
         ST    R2,ECODE            SET PARM 1
         CALL  (15),                                                   X
               (ECODE,             ENTRY CODE                          X
               CMDOUTA,            PTR TO VAR NAME                     X
               CMDOUTL,            PTR TO VAR LENGTH                   X
               VALPTR,             PTR TO VALUE                        X
               VALLENGT,           PTR TO VALUE LENGTH                 X
               TOKEN),             TOKEN                               X
               VL,MF=(E,OSCALL1D)
*
         LTR   R15,R15
         BZ    CMDOUTF             YUP, COMMAND OUT WAS OK
***********************************************************************
* WE COME HERE IF THERE WAS A PROBLEM OBTAINING MAXCMDOUT FROM THE    *
* CLIST                                                               *
***********************************************************************
         MVC   LINE13+52(8),=CL8'DEFCMDOT' JUST IN CASE
         CH    R15,=H'40'          CLIST ENVIRONMENT ACTIVE ?
         BE    ERROR13             NO, A LOGIC PROBLEM EXISTS... .
         CH    R15,=H'52'          UNDEFINED SYMBOL ?
         BNE   ERROR13             REAL PROBLEMS                15OCT92
****************************************************************15OCT92
**       TRY INSTEAD THE REXX AUTH CMD VARIABLE NAME            15OCT92
****************************************************************15OCT92
         L     R15,VACCRTN         GET CLIST VARIABLE ROUTINE   15OCT92
         LA    R2,TSVNOIMP         "ENTRY CODE" = RETRIEVE ONLY 15OCT92
         ST    R2,ECODE            SET PARM 1                   15OCT92
*                                                               15OCT92
         CALL  (15),                                            15OCT92X
               (ECODE,             ENTRY CODE                   15OCT92X
               REXOUTA,            PTR TO VAR NAME              15OCT92X
               REXOUTL,            PTR TO VAR LENGTH            15OCT92X
               VALPTR,             PTR TO VALUE                 15OCT92X
               VALLENGT,           PTR TO VALUE LENGTH          15OCT92X
               TOKEN),             TOKEN                        15OCT92X
               VL,MF=(E,OSCALL1D)                               15OCT92
         LTR   R15,R15                                          15OCT92
         BZ    CMDOUTF             YUP, COMMAND OUT WAS OK      15OCT92
         CH    R15,=H'40'          CLIST ENVIRONMENT ACTIVE ?   15OCT92
         BE    DEFCMDOT            NO, WE ARE NOT UNDER A REXX..15OCT92
         CH    R15,=H'52'          UNDEFINED SYMBOL ?           15OCT92
         BNE   ERROR13             NO, WE HAVE REAL PROBLEMS.   15OCT92
         B     DEFCMDOT            GO USE DEFAULT               15OCT92
DEFCMDOT DS    0H
         CLC   CMDRESPV(8),=CL8'NOTSPEC'   CMDRESP NOT SPECIFIED ?
         BNE   PSTACMD1
         MVC   CMDRESPV(8),=CL8'NOWHERE'   FUDGE DEFAULT IF UNDER
*                                          TSSO AND IN CLIST
PSTACMD1 DS    0H
         LA    R15,200             DEFAULT IS 200 LINES
         ST    R15,MAXLINES        DOESN'T WANT COMMAND RESPONSE
*                                  RETURNED.
         B     CLVARWT             GO AND PROCESS THE WAIT VARIABLE
*
CMDOUTF  DS    0H
         L     R1,VALPTR           GET ADDRESS OF VARIABLE VALUE
         L     R0,VALLENGT         AND ITS LENGTH
         LTR   R0,R0
         BZ    ERROR6              INVALID MAXCMDOUT VALUE
         LA    R10,OSWKAREA
         CALL  JCECVTDB            GET SOMETHING IN BINARY.
         BNZ   ERROR6
         LTR   R1,R1
         BNP   ERROR6              ASSURE THIS IS A POSITIVE NUMBER
         CH    R1,=H'200'
         BH    ERROR6
         ST    R1,MAXLINES         MAXIMUM NUMBER OF LINE TO ALLOW.
         TM    FLAGS,X'40'         UNDER TSSO ?
         BNO   PSTACMD2            NO, DONT CHANGE DEFAULT
         CLC   CMDRESPV(8),=CL8'NOTSPEC'   CMDRESP NOT SPECIFIED ?
         BNE   PSTACMD2
         MVC   CMDRESPV(8),=CL8'CLIST'     FUDGE DEFAULT IF UNDER
*                                          TSSO AND IN CLIST
PSTACMD2 DS    0H
         B     CLVARWT             GET THE MVS WAIT TIME FROM THE CLIST
*
*
CLVARWT  DS    0H
***********************************************************************
* YET ANOTHER USE OF THE CLIST EXTRACT ROUTINE. THIS TIME, WE NEED    *
* THE ADDRESS OF THE CMDWAIT CLIST VARIABLE.                          *
***********************************************************************
         TM    FLAGS,X'80'         RUNNING UNDER CLIST ?
         BNO   DEFCMDWT            NO - ASSIGN DEFAULT TO CMD WAIT TIME
*
         CLC   CMDRESPV(8),=CL8'NOWHERE'   RESPONSE GOING NOWHERE ?
         BE    DEFCMDWT                    YUP - DONT BOTHER.
*
         L     R15,VACCRTN         GET CLIST VARIABLE ROUTINE
         LA    R2,TSVNOIMP         "ENTRY CODE" = RETRIEVE
         ST    R2,ECODE            SET PARM 1
         CALL  (15),                                                   X
               (ECODE,             ENTRY CODE                          X
               CMDWAITA,           PTR TO VAR NAME                     X
               CMDWAITL,           PTR TO VAR LENGTH                   X
               VALPTR,             PTR TO VALUE                        X
               VALLENGT,           PTR TO VALUE LENGTH                 X
               TOKEN),             TOKEN                               X
               VL,MF=(E,OSCALL1D)
*
*
         LTR   R15,R15
         BZ    CMDWAITF            YUP, COMMAND OUT WAS OK
         MVC   LINE13+52(8),=CL8'CLVARWT'
         CH    R15,=H'52'          UNDEFINED SYMBOL ?
         BNE   ERROR13             NO, WE HAVE REAL PROBLEMS.
****************************************************************15OCT92
**       TRY INSTEAD THE REXX AUTH CMD VARIABLE NAME            15OCT92
****************************************************************15OCT92
         L     R15,VACCRTN         GET CLIST VARIABLE ROUTINE   15OCT92
         LA    R2,TSVNOIMP         "ENTRY CODE" = RETRIEVE      15OCT92
         ST    R2,ECODE            SET PARM 1                   15OCT92
         CALL  (15),                                            15OCT92X
               (ECODE,             ENTRY CODE                   15OCT92X
               REXWAITA,           PTR TO VAR NAME              15OCT92X
               REXWAITL,           PTR TO VAR LENGTH            15OCT92X
               VALPTR,             PTR TO VALUE                 15OCT92X
               VALLENGT,           PTR TO VALUE LENGTH          15OCT92X
               TOKEN),             TOKEN                        15OCT92X
               VL,MF=(E,OSCALL1D)                               15OCT92
*                                                               15OCT92
*                                                               15OCT92
         LTR   R15,R15                                          15OCT92
         BZ    CMDWAITF            YUP, COMMAND OUT WAS OK      15OCT92
         CH    R15,=H'52'          UNDEFINED SYMBOL ?           15OCT92
         BNE   ERROR3              NO, WE HAVE REAL PROBLEMS.   15OCT92
         B     DEFCMDWT            GO AND DEFAULT THE COMMAND WAIT
*                                  PARM.
*
CMDWAITF DS    0H
         L     R1,VALPTR           GET ADDRESS OF VARIABLE VALUE
         L     R0,VALLENGT         AND ITS LENGTH
         LTR   R0,R0
         BZ    ERROR14             NOT DEFINED.
         LA    R10,OSWKAREA
         CALL  JCECVTDB            GET SOMETHING IN BINARY.
         BNZ   ERROR14
         LTR   R1,R1               LETS DO SOME TESTS.
         BNP   ERROR14             NEGATIVE OR ZERO, SKIP IT.
         CH    R1,=H'60'           ABOVE SIXTY SECONDS ?
         BH    ERROR14
         M     R0,=F'100'          MAKE UP FOR LOST TIME
         ST    R1,WAITTIME         STORE IT AWAY
         B     PASTCMWT            GO ON AND DO THE COMMAND.
DEFCMDWT DS    0H
***********************************************************************
* WE COME HERE TO ASSIGN THE DEFAULT COMMAND WAIT TIME. THIS OCCURS   *
* IF WE ARE NOT RUNNING IN A CLIST, OR IF THE CMDWAIT CLIST VARIABLE  *
* IS NOT FOUND.                                                       *
***********************************************************************
         LA    R1,150
         ST    R1,WAITTIME          ASSIGN THE DEFAULT.
*
PASTCMWT DS    0H
***********************************************************************
* THE FINAL PIECE OF BUSINESS BEFORE CALLING TSSOPCMD IS TO           *
* DETERMINE THE AUTHORITY OF THE INVOKING CONSOLE, IF THE COMMAND IS  *
* BEING ISSUED FROM THE TSSO ADDRESS SPACE. TO ACCOMPLISH THIS, WE    *
* LOOK IT UP IN THE TSSO CVT, WHICH WE HAVE ACCESS TO IFF WE ARE IN   *
* THE TSSO ADDRESS SPACE.                                             *
***********************************************************************
         TM    FLAGS,X'40'         ARE WE UNDER TSSO ?
         BNO   SETUPPRM            NO, AUTHORITY HAS BEEN SET UP
*                                                               EEJ1102
****************************************************************EEJ1102
*                                                              *EEJ1102
* TSSO used to get the console authorization by searching the  *EEJ1102
* UCM entries. This technique is incompatible with the use of  *EEJ1102
* MCS extended consoles since they don't have UCM entries.     *EEJ1102
* All of this logic has been removed. Instead, console auth-   *EEJ1102
* orization is obtained from the SSCM when the command enters  *EEJ1102
* the TSSO environment.                                        *EEJ1102
*                                                              *EEJ1102
****************************************************************EEJ1102
*                                                               EEJ1102
         GETCVT (10)
         USING TSSOCVT,R10
*
         L     R10,TSSODSEC
         USING DATD,R10
         MVC   CONSID,CURRCONS     Copy console ID              EEJ1102
         MVC   CONSNAME,CURRCNAM   Copy console name            EEJ1102
         MVC   AUTHBYTE,CURRCATH   Copy console auth bits       EEJ1102
         DROP  R10
*                                                               EEJ1102
         NI    AUTHBYTE,255-X'01'     LAST BYTE ALWAYS TURNED OFF...
*
SETUPPRM DS    0H
*
***********************************************************************
* THE SUBSYSTEM CONSOLE, AND THE CALL TO TSSOPCMD WILL BE MADE UNLESS *
* THE FOLLOWING IS TRUE:                                              *
*                                                                     *
* 1) OSCMD IS RUNNING IN A CLIST                                      *
* 2) OSCMD IS RUNNING FROM THE TSSO ADDRESS SPACE                     *
* 3) CMDRESP IS SET TO "NOWHERE". IF THIS IS THE CASE, WE WILL        *
*    ISSUE THE COMMAND DIRECTLY FROM THIS MODULE, USING THE CONSOLE   *
*    ID OF THE INVOKER OF OSCMD.                                      *
*                                                                     *
***********************************************************************
         TM    FLAGS,X'80'            UNDER A CLIST ?
         BNO   USEOPCMD               NO, USE TSSOPCMD
         TM    FLAGS,X'40'            USING TSSO ?
         BNO   USEOPCMD
         CLC   CMDRESPV(8),=CL8'NOWHERE'  RESPONSE GOING NOWHERE ?
         BNE   USEOPCMD                   NO, USE TSSOPCMD
*                                                               EEJ1102
         LH    R0,MVSCMD           Get command buffer length    EEJ1102
         SH    R0,=H'4'            Decrement for MGCR prefix    EEJ1102
         STH   R0,MVSCMD+2         Store true command text len  EEJ1102
         MVC   OSWKAREA(MGCREL),MGCRE Copy MGCRE parm list      EEJ1102
         LA    R2,MVSCMD+2         Point to command text        EEJ1102
         MODESET KEY=ZERO,MODE=SUP        ** WOW **
         MGCRE TEXT=(2),           Issue the command            EEJ1102+
               CONSID=CONSID,      (same)                       EEJ1102+
               MF=(E,OSWKAREA)     (same)                       EEJ1102
         MODESET KEY=NZERO,MODE=PROB      ** UNWOW **
*
         B     ENDPROG                    GET OUT FAST
*                                                               EEJ1102
MGCRE    MGCRE MF=L                MGCRE parameter list         EEJ1102
MGCREL   EQU   *-MGCRE             (same)                       EEJ1102
*
*
USEOPCMD DS    0H
***********************************************************************
***********************************************************************
* WE NEED TO GETMAIN A HEFTY 40K CHUNK OF STORAGE TO PASS TO TSSOPCMD.*
* THIS STORAGE IS IN PRIVATE.                                         *
***********************************************************************
         L     R2,=F'40000'           WE NEED 40,000 BYTES
         GETMAIN RC,LV=(R2)
         LTR   R15,R15
         BNZ   ERROR15
         ST    R1,PARMSTOR            AND PASS ADDRESS TO PARM LIST
         OI    FLAGS,X'20'            MARK STORAGE AS OBTAINED.
***********************************************************************
* WE NOW HAVE ALL THE PARAMETERS NECCESARY FOR THE CALL TO TSSOPCMD.  *
* WE NEED TO SET UP THE CALL, ISSUE IT, AND PROCESS THE RESULTS.      *
***********************************************************************
***********************************************************************
* THE TSSOPCMD MODULE IS LOADED INTO GLOBAL STORAGE AT TSSO           *
* INITIALIZATION, AND ITS ADDRESS IS CHAINED OFF THE TSSO CVT. WE WILL*
* GET THIS ADDRESS, AND CALL THE MODULE.                              *
***********************************************************************
         L     R15,AOPCMD             LOAD UP OPCMD ADDRESS
         LA    R1,OPCMDPRM            AND THE PARAMETER LIST...
         BALR  R14,R15                ISSUE THE CALL TO TSSOPCMD
         LTR   R15,R15
         BNZ   OPCMDERR               PROBLEM WITH TSSO OPCMD
*
***********************************************************************
* WE NOW HAVE THE 40,000 BYTE BUFFER RETURNED FROM TSSOPCMD. WE WILL  *
* DISPLAY THIS, OF FORMAT IT, BASED ON THE USER REQUEST.              *
***********************************************************************
AFTOPCMD DS    0H
***********************************************************************
* NEXT, WE MUST GO ABOUT THE BUSINESS OF CONVERTING THE RESULTS OF    *
* THE COMMAND INTO CLIST VARIABLES, SO THE CLIST CAN ACCESS THEM.     *
* THIS IS, OF COURSE, ONLY NECCESARY IF THE COMMAND WAS INVOKED FROM  *
* A CLIST. IF NOT, WE WILL SIMPLY TAKE THE RESPONSE, AND PUTLINE IT   *
* OUT TO THE TSO TERMINAL.                                            *
***********************************************************************
         L     R1,PARMSTOR     GET COUNT OF LINES RETURNED
         L     R1,0(R1)
         ST    R1,NUMLINES     AND STORE IN SAFE PLACE
         CLC   CMDRESPV(8),=CL8'NOWHERE'   REPSONSE GOING NOWHERE ?
         BE    ENDCMD                      NUKE IT ALL
         CLC   CMDRESPV(8),=CL8'TERMINAL'  RESPONSE TO TERMINAL ?
         BNE   PUTCLSTV        YES, PUTLINE THE RESPONSE TO THE TUBE.
PUTRESP  DS    0H
***********************************************************************
* HERE, WE WILL SIMPLY RETURN THE COMMAND RESPONSE TO THE TERMINAL.   *
* THE PUTLINE MACRO WILL BE USED.                                     *
***********************************************************************
         L     R3,NUMLINES
         LTR   R3,R3
         BZ    ERROR16         FOR SOME REASONS, NO LINES WERE RETURNED
         L     R2,PARMSTOR
         LA    R2,4(R2)        GET TO BEGINNING OF BUFFER
         MVC   PUTRESPD(2),=H'150' (PTF1)LENGTH IS ALWAYS 150
         XC    PUTRESPD+2(2),PUTRESPD+2  CLEAR OUT BUFFER
PUTRLOOP DS    0H
         MVC   PUTRESPD+4(150),0(R2)        (PTF1)
         PUTLINE PARM=PUTBLOK,OUTPUT=(PUTRESPD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         LA    R2,150(R2)           (PTF1)
         BCT   R3,PUTRLOOP
         B     ENDCMD
PUTCLSTV DS    0H
***********************************************************************
* FIRST, WE WILL CONVERT THE COUNT INTO A CLIST VARIABLE. THIS IS DONE*
* EVEN IF NO DATA WAS RETURNED...                                     *
***********************************************************************
         LA    R4,TSVEUPDT
         ST    R4,ECODE
*
         LA    R4,CLVARNME         GET VARNAME PTR
         ST    R4,NAMEPTR          TELL IKJCT441
         MVC   CLVARNME(6),=CL6'CMDOUT'
*
         LA    R4,6
         ST    R4,NAMELEN
*
         LA    R4,EBCCOUNT         GET ADDRESS OF EBCCOUNT
         ST    R4,VALUEPTR
         L     R1,NUMLINES
         XR    R0,R0
         LA    R10,OSWKAREA
         CALL  JCECVTBD
         ST    R1,EBCCOUNT
*
         LA    R4,4                LENGTH WILL BE FOUR...
         ST    R4,VALUELEN
         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE
         CALL  (15),                                                   X
               (ECODE,             ENTRY CODE                          X
               NAMEPTR,            PTR TO VAR NAME                     X
               NAMELEN,            PTR TO VAR LENGTH                   X
               VALUEPTR,           PTR TO VALUE                        X
               VALUELEN,           PTR TO VALUE LENGTH                 X
               TOKEN),             TOKEN                               X
               VL,MF=(E,OSCALL1D)
*
         LTR   R15,R15
         BNZ   ERROR9
         L     R2,PARMSTOR
         LA    R2,4(R2)            POINT TO BEGINNING OF BUFFER
         ST    R2,CURRLPOS
         LA    R3,1
         ST    R3,CURRLNUM
CLISTLP  DS    0H
***********************************************************************
* NOTE, NAMEPTR SET UP FROM PREVIOUS CALL TO IKJCT441.                *
***********************************************************************
         L     R2,CURRLPOS         GET CURRENT LINE POSTION
         L     R3,CURRLNUM         GET CURRENT LINE NUMBER
         C     R3,NUMLINES         ARE THERE ANY MORE LINES ?
         BH    OUTOFVRS            NOPE, ALL OUT OF VARIABLES...
GETNAME  DS    0H
***********************************************************************
* NEXT, WE MUST EXTRACT THE NAME AND LENGTH OF THE "CMDOUT" VARIABLES.*
* THE PROBLEM IS THAT THE NAME CAN BE 7 8 OR 9 CHARACTERS.. WE WILL   *
* CONSTRUCT THE NAME BASED ON THE NUMBER OF THE LINE WE ARE PROCESSING*
* E.G. 1-9 10-99 OR HIGHER -> CMDOUT1-CMDOUT9  CMDOUT10-CMDOUT99 ETC..*
***********************************************************************
         LR    R1,R3
         XR    R0,R0
         LA    R10,OSWKAREA
         CALL  JCECVTBD
         CH    R3,=H'10'
         BL    CPY1BYTE
         CH    R3,=H'100'
         BL    CPY2BYTE
CPY3BYTE DS    0H
         LA    R4,9
         ST    R4,NAMELEN
         STCM  R1,B'0111',CLVARNME+6
         B     GOTNAME
*
CPY2BYTE DS    0H
         LA    R4,8
         ST    R4,NAMELEN
         STCM  R1,B'0011',CLVARNME+6
         B     GOTNAME
*
CPY1BYTE DS    0H
         LA    R4,7
         ST    R4,NAMELEN
         STCM  R1,B'0001',CLVARNME+6
         B     GOTNAME
*
GOTNAME  DS    0H
         ST    R2,VALUEPTR        R2 WILL POINT TO THE CURRENT LINE
*                                 ENTRY IN THE OSCMDICB.
         LA    R15,150
         LA    R4,149(R2)         POINT AT END OF STRING
LLOOP4   DS    0H
         CLI   0(R4),C' '         FOUND THE LAST NON BLANK ?
         BE    DLLOOP4            YUP - TRUE LENGTH IS IN R15
         CLI   0(R4),X'00'        MAYBE THIS IS THE LAST NONBLANK
         BE    DLLOOP4
         B     ELLOOP4
DLLOOP4  DS    0H
         BCTR  R15,0              DECREMENT LENGTH
         BCTR  R4,0               POINT TO PRECEEDING CHARACTER
         B     LLOOP4
ELLOOP4  DS    0H
* R15 SHOULD HAVE REAL LENGTH OF LINE
         ST    R15,VALUELEN
*
         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE
         CALL  (15),                                                   X
               (ECODE,             ENTRY CODE                          X
               NAMEPTR,            PTR TO VAR NAME                     X
               NAMELEN,            PTR TO VAR LENGTH                   X
               VALUEPTR,           PTR TO VALUE                        X
               VALUELEN,           PTR TO VALUE LENGTH                 X
               TOKEN),             TOKEN                               X
               VL,MF=(E,OSCALL1D)
*
         LTR   R15,R15
         BNZ   ERROR9
*
***********************************************************************
* NOW, WE WANT TO PARSE THIS RETURNED LINE INTO ITS COMPONENT FORM. TO*
* ACCOMPLISH THIS, WE CALL THE TSSOPARS ROUTINE, SCAN THE RESULTS,    *
* AND PUT THE WORDS INTO CLIST VARIABLES.                             *
* WE BEGIN BY SETTING UP THE CALL TO TSSOPARS                         *
***********************************************************************
         ST    R2,OSPARS1      FIRST PARM -> ADDRESS OF STRING TO PARSE
*
         MVC   OSPARS2(4),=F'150' SECOND PARM -> LENGTH OF STRING (PTF1
*
         MVI   OSPARARR,X'40'
         MVC   OSPARARR+1(255),OSPARARR   BLANK OUT THE RETURNED ARRAY
         MVC   OSPARARR+255(64),OSPARARR  FINISH THE JOB
         MVC   OSPARARR(2),=H'20'         MAX 20 TOKENS...
         LA    R4,OSPARARR                GET ADDRESS
         ST    R4,OSPARS3                 AND PASS TO TSSOPARS
*
         LA    R4,WORDSEPS                TELL TSSOPARS ABOUT THE
         ST    R4,OSPARS4             SEPARATOR CHARACTERS.
         MVC   WORDSEPS(4),=CL4' ,= '
*
         LA    R1,OSPARSPM
         CALL  TSSOPARS              ** PARSE IT **
         LH    R8,OSPARARR
         ST    R8,WORDLINE
***********************************************************************
* PARSE HAS RETURNED.. LETS ANALYZE THE RESULTS...                    *
* FIRST, GET NUMBER OF WORDS RETURNED ON THIS LINE...                 *
***********************************************************************
         LA    R4,CLVARNME           GET VARIABLE NAME
         ST    R4,NAMEPTR
         A     R4,NAMELEN            GET LENGTH OF VARIABLE SO FAR...
         MVI   0(R4),C'W'            MOVE IN A "W"
*
*
         L     R4,NAMELEN
         LA    R4,1(R4)
         ST    R4,NAMELEN
*
         LA    R4,EBCCOUNT
         ST    R4,VALUEPTR
         L     R1,WORDLINE           GET NUMBER OF WORDS RETURNED
         XR    R0,R0
         LA    R10,OSWKAREA
         CALL  JCECVTBD
         STCM  R1,B'1111',EBCCOUNT
*
         LA    R4,4
         ST    R4,VALUELEN
*
         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE
         CALL  (15),                                                   X
               (ECODE,             ENTRY CODE                          X
               NAMEPTR,            PTR TO VAR NAME                     X
               NAMELEN,            PTR TO VAR LENGTH                   X
               VALUEPTR,           PTR TO VALUE                        X
               VALUELEN,           PTR TO VALUE LENGTH                 X
               TOKEN),             TOKEN                               X
               VL,MF=(E,OSCALL1D)
         LTR   R15,R15
         BNZ   ERROR9
*
***********************************************************************
* THE NEXT STEP IS TO CREATE THE CMDOUTXWN VARIABLES, WHERE "N" IS    *
* THE CURRENT WORD THAT WE ARE WORKING ON...                          *
* THE STRING IS PARSED, WE JUST NEED TO LOOP AROUND, PLACING IT IN    *
* CLIST VARIABLES.                                                    *
***********************************************************************
*
*
         LA    R4,1
         ST    R4,CURRWNUM               INITIALIZE CURRENT WORD
         LA    R4,OSPARARR+2
         ST    R4,CURRWPOS               INITIALIZE CURRENT POSITION IN
*                                        THE PARSE ARRAY
*
WORDLOOP DS    0H
         L     R4,NAMELEN               LOAD LENGTH OF VAR NAME SO FAR
         ST    R4,NAMELENW              AND KEEP A COPY
         L     R4,CURRWNUM               WHICH WORD ARE WE STARTING ON?
         C     R4,WORDLINE               IS IT PASSED THE LAST WORD ?
         BH    ENDWORDS                  YUP, NO MORE WORDS TO WORK ON
*
         LA    R4,CLVARNME               GET THE VARIABLE NAME
         ST    R4,NAMEPTR                TELL CLIST ROUTINE
*
         L     R4,CURRWNUM               GET BACK CURRENT WORD NUM
         LR    R1,R4
         XR    R0,R0
         LA    R10,OSWKAREA
         CALL  JCECVTBD
         CH    R4,=H'10'
         BL    WOR1BYTE
WOR2BYTE DS    0H
         LA    R3,CLVARNME
         A     R3,NAMELENW               START OF VARIABLE PLUS
*                                        LENGTH = A(END OF VARIABLE)
         STCM  R1,B'0011',0(R3)          PLACE EBCIDIC FOR WORD NUMBER
         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING
*                                        THE LEADING "W")
         LA    R3,2(R3)                  INCREMENT BY TWO BYTES
         ST    R3,NAMELENW               RESTORE LENGTH OF NAME
         B     GOTNAME2
WOR1BYTE DS    0H
         LA    R3,CLVARNME
         A     R3,NAMELENW               START OF VARIABLE PLUS
*                                        LENGTH = A(END OF VARIABLE)
         STCM  R1,B'0001',0(R3)          PLACE EBCIDIC FOR WORD NUMBER
         L     R3,NAMELENW               GET LENGTH OF NAME (INCLUDING
*                                        THE LEADING "W")
         LA    R3,1(R3)                  INCREMENT BY TWO BYTES
         ST    R3,NAMELENW               RESTORE LENGTH OF NAME
         B     GOTNAME2
GOTNAME2 DS    0H
***********************************************************************
* CALCULATE THE LENGTH OF THE RETURNED WORD.                          *
*                                                                     *
***********************************************************************
         L     R4,CURRWPOS
         LA    R5,16          MAXIMUM LENGTH FOR WORD IS 16..
         XR    R6,R6
WLENLOOP DS    0H
         CLI   0(R4),C' '    BLANK FOUND ?
         BE    WLENELOP      YUP.. WE HAVE THE LENGTH IN R6
         LA    R6,1(R6)
         LA    R4,1(R4)
         BCT   R5,WLENLOOP
WLENELOP DS    0H
         ST    R6,VALUELEN
*
         L     R4,CURRWPOS
         ST    R4,VALUEPTR
*
         L     R15,VACCRTN         GET VARIABLE ACCESS ROUTINE
         CALL  (15),                                                   X
               (ECODE,             ENTRY CODE                          X
               NAMEPTR,            PTR TO VAR NAME                     X
               NAMELENW,           PTR TO VAR LENGTH                   X
               VALUEPTR,           PTR TO VALUE                        X
               VALUELEN,           PTR TO VALUE LENGTH                 X
               TOKEN),             TOKEN                               X
               VL,MF=(E,OSCALL1D)
*
         LTR   R15,R15
         BNZ   ERROR9
*
         L     R4,CURRWPOS
         LA    R4,16(R4)
         ST    R4,CURRWPOS
*
         L     R4,CURRWNUM
         LA    R4,1(R4)
         ST    R4,CURRWNUM
         B     WORDLOOP
*
ENDWORDS DS    0H
***********************************************************************
* WE COME HERE WHEN WE ARE COMPLETED PROCESSING A WORD.. STANDARD     *
* PROCEDURE IS TO GO ONTO THE NEXT WORD...                            *
***********************************************************************
         L     R2,CURRLPOS
         LA    R2,150(R2)                (PTF1)
         ST    R2,CURRLPOS               RESTORE CURRENT LINE
*
         L     R3,CURRLNUM
         LA    R3,1(R3)
         ST    R3,CURRLNUM               CURRENT LINE NUMBER
*
         B     CLISTLP
*
OUTOFVRS DS    0H
         B     ENDCMD
OPCMDERR DS    0H
***********************************************************************
* WE COME HERE IN CASE OF A NON ZERO RETURN CODE FROM THE TSSOPCMD    *
* MODULE. IF THIS IS THE CASE, WE WILL DISPLAY AN APPROPRIATE ERROR   *
* MESSAGE. NOTE THE THE ERROR MESSAGES ARE KEPT IN THE OPCMDMSG CSECT *
***********************************************************************
         L     R10,=V(OPCMDMSG)
         LR    R3,R15                 COPY THE RETURN CODE
         BCTR  R3,0                   MULTIPLICATION WORKS BETTER
         SRL   R3,2                   DIVIDE BY 4
         M     R2,=F'80'              AND MULTIPLY BY 80
         AR    R10,R3                 R10 NOW POINTS TO THE MSG TO
*                                     BE DISPLAYED.
         PUTLINE PARM=PUTBLOK,OUTPUT=((10),TERM,SINGLE,DATA),          X
               MF=(E,IOPLADS)
         B     ENDCMD                 END OF COMMAND PROCESSING
ENDCMD   DS    0H
         L     R10,PARMSTOR           GET BUFFER STORAGE
         L     R2,=F'40000'
         FREEMAIN R,LV=(R2),A=(R10)
         B     ENDPROG
ENDPROG  DS    0H
         FREEMAIN R,LV=4096,A=(R11)   FREEMAIN THE PRIVATE STORAGE
         LR    R1,R13              GET ADDRESS OF CORE IN R1
         L     R13,4(R13)          RESTORE R13
         FREEMAIN R,LV=72,A=(R1)    FREE UP THE CORE
         XR    R8,R8
         B     ENDPROG1
ENDPROG1 DS    0H
         L     R14,12(R13)         RELOAD RETURN POINT
         LR    R15,R8              PICK UP RETURN CODE.
         LM    R0,R12,20(R13)      RELOAD MORE REGISTERS
         BR    R14
*
***********************************************************************
* E R R O R   C O N D I T I O N S ...                                 *
*                                                                     *
***********************************************************************
ERROR1   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE1HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR2   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE2HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR3   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE3HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR4   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE4HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR5   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE5HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR6   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE6HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR7   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE7HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR8   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE8HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR9   DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE9HD,TERM,SINGLE,DATA),       X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR10  DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE10HD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR11  DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE11HD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR12  DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE12HD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         B     ENDPROG
*
ERROR13  DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE13HD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         B     ENDPROG
ERROR14  DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE14HD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         B     ENDPROG
ERROR15  DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE15HD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         B     ENDPROG
ERROR16  DS    0H
         PUTLINE PARM=PUTBLOK,OUTPUT=(LINE16HD,TERM,SINGLE,DATA),      X
               MF=(E,IOPLADS)
         B     ENDPROG
*RROR17  DS    0H
*        PUTLINE PARM=PUTBLOK,OUTPUT=(LINE17HD,TERM,SINGLE,DATA),     X
*              MF=(E,IOPLADS)
*        B     ENDPROG
*
OSCALL1C CALL  ,(0,0,0,0,0,0),MF=L
OSCALL1E EQU  *
*
OSCALL2C CALL  ,(0),MF=L
OSCALL2E EQU  *
*
*
PUTBLOKC PUTLINE MF=L
PUTBLOKE EQU   *
*
LINE1HC  DC    H'80',H'0'
LINE1H   DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT INVOKED AUTHORX
               IZED'
*
LINE2HC  DC    H'80',H'0'
LINE2H   DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX
               LEASE 2 OR HIGHER'
*
LINE3HC  DC    H'80',H'0'
LINE3H   DC    CL76'OSCMD TERMINATING --> ERROR IN CLIST VARIABLE ACCESX
               S ROUTINE'
*
LINE4HC  DC    H'80',H'0'
LINE4H   DC    CL76'OSCMD TERMINATING --> ACCESS FROM TSSO TO OSCMD MUSX
               T BE FROM A CLIST'
*
LINE5HC  DC    H'80',H'0'
LINE5H   DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR "CMDRESP" VX
               ARIABLE'
*
LINE6HC  DC    H'80',H'0'
LINE6H   DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR "MAXCMDOUT"X
                VARIABLE'
*
LINE7HC  DC    H'80',H'0'
LINE7H   DC    CL76'OSCMD TERMINATING --> THE MVS COMMAND TO BE ISSUED X
               IS MISSING'
*
LINE8HC  DC    H'80',H'0'
LINE8H   DC    CL76'OSCMD TERMINATING --> TSSO HAS NOT ACQUIRED A SUBSYX
               STEM CONSOLE'
*
LINE9HC  DC    H'80',H'0'
LINE9H   DC    CL76'OSCMD TERMINATING --> ERROR IN UPDATING A "CMDOUT" X
               VARIABLE'
*
LINE10HC DC    H'80',H'0'
LINE10H  DC    CL76'OSCMD TERMINATING --> OSCMD INTERFACE IS ALREADY INX
                USE'
*
LINE11HC DC    H'80',H'0'
LINE11H  DC    CL76'OSCMD TERMINATING --> YOU ARE NOT AUTHORIZED TO USEX
                IT'
*
LINE12HC DC    H'80',H'0'
LINE12H  DC    CL76'OSCMD TERMINATING --> TSSO IS UNAVAILABLE TO PROCESX
               S THE COMMAND'
*
*
LINE13HC DC    H'80',H'0'
LINE13H  DC    CL76'OSCMD TERMINATING --> LOGIC ERROR IN OSCMD -- LABELX
                XXXXXXXX'
*
*
LINE14HC DC    H'80',H'0'
LINE14H  DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR "CMDWAIT" VX
               ARIABLE'
*
LINE15HC DC    H'80',H'0'
LINE15H  DC    CL76'OSCMD TERMINATING --> UNABLE TO OBTAIN 40,000 BYTE X
               BUFFER'
*
LINE16HC DC    H'80',H'0'
LINE16H  DC    CL76'OSCMD TERMINATING --> NO LINES WERE RETURNED IN RESX
               PONSE TO THE COMMAND'
***********************************************************************
* THESE ARE CONSTANTS REQUIRED FOR THE RETRIEVAL FUNCTION OF THE      *
* TSO/E CLIST FEATURE.                                                *
***********************************************************************
CMDOUTA  DC    A(CMDOUT)
CMDOUT   DC    CL9'MAXCMDOUT'
CMDOUTL  DC    F'9'
*
CMDWAITA DC    A(CMDWAIT)
CMDWAIT  DC    CL7'CMDWAIT'
CMDWAITL DC    F'7'
*
CMDRESPA DC    A(CMDRESP)
CMDRESP  DC    CL7'CMDRESP'
CMDRESPL DC    F'7'
*                                                               15OCT92
REXOUTA  DC    A(REXOUT)                AUTHORIZED REX SUPPORT  15OCT92
REXOUT   DC    CL17'SYSAUTH_MAXCMDOUT'                          15OCT92
REXOUTL  DC    F'17'                                            15OCT92
*                                                               15OCT92
REXWAITA DC    A(REXWAIT)               AUTHORIZED REX SUPPORT  15OCT92
REXWAIT  DC    CL15'SYSAUTH_CMDWAIT'                            15OCT92
REXWAITL DC    F'15'                                            15OCT92
***********************************************************************
* DSECT AREA FOR THE OSCMD TSO COMMAND PROCESSOR                      *
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
OSCMDATD DSECT
OSWKAREA DS    CL200
CPPLCBUF DS    A
CPPLUPT  DS    A
CPPLPSCB DS    A
CPPLECT  DS    A
IOPLADS  DS    4F               SPACE FOR IO PARM LIST
ECBADS   DC    F'0'             ECB FOR PUTLINE, GETLINE
*
OSCALL1D CALL  ,(0,0,0,0,0,0),MF=L
OSCALL2D CALL  ,(0),MF=L
*
PUTBLOK  PUTLINE MF=L             DEFAULT PUTLINE MACRO, LIST FORM
*
FLAGS    DS    F
* BYTE 1
* X'80' - OSCMD IS RUNNING FROM A CLIST
* X'40' - OSCMD IS RUNNING FROM THE TSSO ADDRESS SPACE
* X'20' - STORAGE HAS BEEN OBTAINED FOR THE 40K BUFFER.
***********************************************************************
* VARIABLES TO USE FOR THE TSO/E SERVICE ROUTINES...                  *
*                                                                     *
*                                                                     *
***********************************************************************
CMDRESPV DS    CL8              VALUE OF COMMAND RESPONSE VAR.
*
*
*
VACCRTN  DS    A                ADDRESS OF CLIST VARIABLE ACCESS RTN.
VALPTR   DS    A                FOR CLIST VARIABLE ACCESS ROUTINE.
VALLENGT DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.
TOKEN    DS    F                FOR CLIST VARIABLE ACCESS ROUTINE.
ECODE    DS    F
*
***********************************************************************
* THESE ARE THE VARIABLES THAT ARE REQUIRED FOR THE CLIST VARIABLE    *
* UPDATE ROUTINE.                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
CURRLNUM DS    F                CURRENT LINE NUMBER FROM ALL LINES RET
CURRLPOS DS    F        (PTF1)  POINTER TO 150 BYTES OF DATA FOR THE
*                               LINE
CURRWNUM DS    F                CURRENT WORD NUMBER IN THE CURRENT LINE
CURRWPOS DS    F                POINTER TO 16 BYTE WORD RETURNED IN
*                               TSSOPARS
WORDLINE DS    F                NUMBER OF WORDS IN CURRENT LINE
NUMLINES DS    F                NUMBER OF LINES RETURNED FROM COMMAND
NAMEPTR  DS    F                FOR UPDATE ROUTINE
NAMELEN  DS    F                FOR UPDATE ROUTINE
VALUEPTR DS    F                FOR UPDATE ROUTINE
VALUELEN DS    F                FOR UPDATE ROUTINE
NAMELENW DS    F                FOR UPDATE ROUTINE FROM "CMDOUTNWM"
CLVARNME DS    CL12
EBCCOUNT DS    CL4
*
*
***********************************************************************
* THESE VARIABLES ARE USED IN CALLING THE NOW FAMOUS TSSO PARSE       *
* ROUTINE.                                                            *
***********************************************************************
OSPARSPM DS    0H
OSPARS1  DS    F
OSPARS2  DS    F
OSPARS3  DS    F
OSPARS4  DS    F
WORDSEPS DS    CL4           PROBABLY CL4' ,= '
OSPARARR DS    20CL16
USERID   DS    CL8              USERID OF OSCMD FACILITY.
ERRORID  DS    CL2              ERROR ID (NOT USED IN TSSO 4.3)
*
WAITTIME DS    F                WAIT TIME, IN SECONDS FOR COMMAND
CONSID   DS    F                CONSOLE ID IF COMMAND ISSUED FROM TSSO
CONSNAME DS    CL8              Console name                    EEJ1102
*
MVSCMD   DS    CL132            2 BYTES LENGTH, 2 BYTES TRASH, 127 FOR
*                               THE MVS COMMAND
*
MVSCMDL  DS    F                LENGTH OF THE MVS COMMAND
*
MAXLINES DS    F                MAXIMUM NUMBER OF LINES IN CMD RESP.
*
AOPCMD   DS    A                ADDRESS OF THE TSSOPCMD ROUTINE
*
ERRORCDE DS    F                ERROR  CODE FROM THE TSSOPCMD MODULE
*
AUTHBYTE DS    XL2              AUTHORIZATION BYTE TO PASS TO TSSOPCMD
*
PUTRESPD DC    H'150',H'0' PTF1 FOR PUTTING COMMAND RESPONSE TO TUBE
         DC    CL150' '    PTF1
*
LINE1HD  DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT INVOKED AUTHORX
               IZED'
*
LINE2HD  DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING BECAUSE IT WAS NOT UNDER TSO/E REX
               LEASE 2 OR HIGHER'
*
LINE3HD  DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> ERROR IN CLIST VARIABLE ACCESX
               S ROUTINE'
*
LINE4HD  DC    H'80',H'0'
LINE4    DC    CL76'OSCMD TERMINATING --> ACCESS FROM TSSO TO OSCMD MUSX
               T BE FROM A CLIST'
*
LINE5HD  DC    H'80',H'0'
LINE5    DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR "CMDRESP" VX
               ARIABLE'
*
LINE6HD  DC    H'80',H'0'
LINE6    DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR "MAXCMDOUT"X
               VARIABLE'
*
LINE7HD  DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> THE MVS COMMAND TO BE ISSUED X
               IS MISSING'
*
LINE8HD  DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> TSSO HAS NOT ACQUIRED A SUBSYX
               STEM CONSOLE'
*
LINE9HD  DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> ERROR IN UPDATING A "CMDOUT" X
               VARIABLE'
*
LINE10HD DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> OSCMD INTERFACE IS ALREADY INX
                USE'
LINE11HD DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> YOU ARE NOT AUTHORIZED TO USEX
                IT'
*
LINE12HD DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> TSSO IS UNAVAILABLE TO PROCESX
               S THE COMMAND'
LINE13HD DC    H'80',H'0'
LINE13   DC    CL76'OSCMD TERMINATING --> YOU MAY NOT ISSUE TSSO COMMANX
               DS USING THIS INTERFACE'
*
LINE14HD DC    H'80',H'0'
LINE14   DC    CL76'OSCMD TERMINATING --> INVALID VALUE FOR "CMDWAIT" VX
               ARIABLE'
*
LINE15HD DC    H'80',H'0'
LINE15   DC    CL76'OSCMD TERMINATING --> UNABLE TO OBTAIN 40,000 BYTE X
               BUFFER'
*
LINE16HD DC    H'80',H'0'
         DC    CL76'OSCMD TERMINATING --> NO LINES WERE RETURNED IN RESX
               PONSE TO THE COMMAND'
***********************************************************************
* THESE ARE THE VARIABLES REQUIRED BY THE CALL TO TSSOPCMD.           *
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
OPCMDPRM DS    0D                 PARAMETER LIST FOR TSSOPCMD
PARMCMD  DS    A   0(R1)          ADDRESS OF THE MVS COMMAND
PARMCMDL DS    F   4(R1)          LENGTH OF THE MVS COMMAND
PARMWTME DS    F   8(R1)          MAXIMUM WAIT TIME - IN SECONDS
PARMLINE DS    F  12(R1)          MAXIMUM LINES FOR COMMAND
PARMAUTH DS    A  16(R1)          AUTHORIZATION BYTE FOR COMMAND
PARMUSER DS    A  20(R1)          A(USERID OF THE OSCMD FACILITY)
PARMSTOR DS    A  24(R1)          ADDRESS OF A 40K BUFFER
PARMERR  DS    A  28(R1)          ADDRESS OF A REASON CODE.
PARMREAS DS    A  32(R1)          ADDRESS OF THE REASON CODE.
         IKJTSVT
         IKJIOPL
         IKJPSCB
         TSSOCVT
         COPY  TSSODATD
         OSCMDICB
         CVT   DSECT=YES
         IEFJSCVT
         IEFJESCT
UCM      DSECT
         IEECUCM
         END   OSCMD
 PUNCH ' SETCODE  AC(1)'
 PUNCH ' IDENTIFY OSCMD(''TSSO V 4.3.0 &SYSDATE &SYSTIME'') '
 PUNCH ' INCLUDE  SYSLMOD(JCECVT)'
 PUNCH ' INCLUDE  SYSLMOD(TSSOPARS)'
 PUNCH ' INCLUDE  SYSLMOD(OSCMDATH)'
 PUNCH ' INCLUDE  SYSLMOD(OPCMDMSG)'
 PUNCH ' ENTRY    OSCMD'
 PUNCH ' NAME     OSCMD(R)'
         END
