./ ADD NAME=ASMGASM  0101-88357-88358-0729-00909-00908-00001-CHSY227
ASM      TITLE     'ASMG     MASTER ROOT SEGMENT'
         ISEQ  73,78
*TITLE-ASMGASM- PHASE 'ASM'- MASTER ROOT SEGMENT
*FUNCTION- PERMANENT RESIDENT PHASE.
*   SAVES CONTROL PROGRAM (O.S. OR INVOKER) REGS.
*   LINK'S TO ASMGF1 TO INITIATE THE ASSEMBLY.
*   RECEIVES CONTROL FROM 'FPP' VIA 'RTA' AT THE END
*   OF THE ASSEMBLY.  ASMGASM THEN
*   RETURNS TO ITS INVOKER AFTER CLOSING ALL DATASETS.
*   DEFINES DCB'S FOR ALL 10 DATASETS.
*   CONTAINS SYSIN AND QSAM OUTPUT MONITORING ROUTINES, I/O ERROR
*     ROUTINE AND ABEND (NAMED FOR HISTORICAL REASON) ROUTINE.
*ENTRY POINT- ASMGASM
*EXIT-   BR        R14
         SPACE     2
         COPY      ASMGSET
         EJECT
ASMGASM  START
*
*        REGISTER DEFINITIONS
*
         SETR
         SPACE     2
*        TO SAVE SOME CORE INITIALIZE IN A FUTURE SAVE AREA.
         USING     ASMGASM,R15         FOR A SINGLE BRANCH
         B         INITIAL             BRANCH FOR INITIALIZING
         DROP      R15                 FORGET R15
         USING     ASMGASM,R12         NOW WE'RE USING R12
         DC        AL1(8),CL8'ASMGV2L7'
*./      DELETE    SEQ1=00580025,SEQ2=00640025
*
*        LINK TO PHASE ASMGF1
*
DONEINIT DS        0H
         SVC       6                   ISSUE LINK SVC TO ASMGF1
         EJECT
*
*        RETURN AFTER ALL ASSEMBLIES
*
RETURN   DS        0H
         BALR      R14,0               SET TEMPORARY BASE
         USING     *,R14
         L         R12,=A(ASMGASM)     SET UP NORMAL BASE
         DROP      R14
         LA        R13,SAVE2            OS SAVE AREA
*./      DELETE    SEQ1=00940022,SEQ2=01400022
*
*        RETURN TO INVOKING PROGRAM
*
*
*        FREE THE CORE IF NECESSARY
         L         R1,FREEMEM          FREE GETMAIN AREA
         L         R0,FREEMEM+4
         LTR       R0,R0               TEST IF CORE GOTTEN YET
         BZ        CLOSE               BR IF NOT
         FREEMAIN  R,LV=(0),A=(1)
*
*        CLOSE ALL DCB'S. A FEW MAY NOT HAVE BEEN OPENED - CLOSE ANYWAY
*
CLOSE    DS        0H
*./      DELETE    SEQ1=01574426,SEQ2=01575226
         LA        R2,LIST1+L1DCBADS   POINT TO 1ST DCB ADDR
CLOSLOOP DS        0H
         L         R5,0(,R2)           GET DCB ADDRESS
         L         R3,L1DCBPAD(,R5)    GET PATCHED GET/PUT ADDRESS
         LA        R3,0(,R3)           CLEAR HIGH BYTE
         LTR       R3,R3               WAS DCB PATCHED INTO .Q
         BZ        CLOSPTCH            BRANCH IF NOT
         MVC       DCBGET+1(3,R5),L1DCBPAD+1(R5)  RESTORE REAL ADDRESS
CLOSPTCH DS        0H
         LA        R2,4(,R2)           POINT TO NEXT DCB ADDR
         LTR       R5,R5               LAST DCB .Q
         BP        CLOSLOOP            BRANCH IF NOT
        CLOSE (SYSTERM,LEAVE,          SYSTERM                         X
               SYSUP,DISP,             SYSUP                           X
               SYSLIB,DISP,            SYSLIB                          X
               SYSIN,DISP,             SYSIN                           X
               SYSLIN,DISP,            SYSLIN                          X
               SYSPRINT,LEAVE,         SYSPRINT                        X
               SYSPUNCH,LEAVE,         SYSPUNCH                        X
               SYSUT1,REREAD,          SYSUT1                          X
               SYSUT2,REREAD,          SYSUT2                          X
               SYSUT3,REREAD)          SYSUT3
*
*        FREE ALL QSAM BUFFERS.
         CLC       SYSIN+DCBBUFCB(3),SYSLIN+DCBBUFCB TEST IF SYSIN AND
         BE        FREEPRT               SYSLIN HAVE SAME BUFFER POOL
         LA        R1,SYSIN
         BAL       R2,FREEPOOL
FREEPRT  LA        R1,SYSPRINT
         BAL       R2,FREEPOOL
         LA        R1,SYSPUNCH
         BAL       R2,FREEPOOL
         LA        R1,SYSLIN
         BAL       R2,FREEPOOL
         LA        R1,SYSTERM
         BAL       R2,FREEPOOL
         LA        R1,SYSUP
         BAL       R2,FREEPOOL
*        DELETE THE ASMGISXX MODULE IN CASE BATCH
         DELETE    EPLOC=ISNAME
*        DELETE THE ASMGUP ROUTINE IN CASE UPDATE
         DELETE    EP=ASMGUP
*
*        RESTORE CALLER'S REGISTERS AND RETURN
         L         R13,SAVE1            RESTORE CTL PROG SAVE ADDRESS
         LM        R14,R12,12(R13)      RESTORE CALLER'S REGISTERS
         L         R15,SAVECC-ASMGASM(,R15)  GET COMPLETION CODE
         LTR       R15,R15              IF ERR CODE IN REG,
         BCR       7,R14                RETURN IMMEDIATELY  (BNZR)
         MVI       12(R13),X'FF'        SET FOR NORMAL RETURN
         BR        R14                  RETURN
*        FREEPOOL SUBROUTINE
FREEPOOL TM        23(R1),X'01'        TEST IF BUFFERS EXIST
         BCR       1,R2                BOR  BRANCH IF NOT
         FREEPOOL  (1)                 DO THE FREEPOOL
         BR        R2                  RETURN
         EJECT
ABWTO    DC        0F'0',AL2(120+4),X'8000'  MF=E WTO INCL ROUTE CODES
ABMESS   DS        0CL133
         DC        C'  ASMG999A   ASSEMBLY TERMINATED. I/O ERROR. SYNAD*
               AF INFO='''
*        THE NEXT 77 BYTES MAY BE CLOBBERED BY THE ABEND OR
*        THE I/O ERROR ROUTINES.
         SPACE     5
*
*        THIS EXLST ROUTINE IS ENTERED DURING OPEN FOR EACH DCB
*        R8 CONTAINS ADDRESS OF EXLST ROUTINE IN F1 (LOADED BY F1)
*        IT IS ALSO ENTERED ON EACH IMPLICIT OPEN FORCED BY THE
*           CONCATENATION OF UNLIKE DEVICES
*
         DC        0F'0'
EXITLIST DC        X'85'
         DC        AL3(EXITROUT)
EXITROUT DS        0H
         USING     *,R15
         LA        R1,0(,R1)           ZERO TOP BYTE
         C         R1,LIST1+L1DCBADS+L1SIN  IS THIS SYSIN .Q
         BE        EXIT0               YES, CONTINUE FURTHER ON
         C         R1,LIST1+L1DCBADS+L1SUP  IS THIS SYSUP .Q
         BCR       7,R8                NO, BR TO EXLST ROUTINE IN F1
EXIT0    TM        DCBOFLGS(R1),X'08'  TEST IF FIRST OPEN
         BO        EXIT1               BR IF NOT
         OI        DCBOFLGS(R1),X'08'  TURN ON CONCAT OF UNLIKE DEVICES
         BR        R8                  GO TO EXLST ROUTINE IN F1
EXIT1    OI        SYSINSW,X'01'       SET RE-GET SWITCH
         NI        DCBRECFM(R1),X'EF'  TURN OFF BLOCKED BIT
         LH        R2,DCBBLKSI(,R1)    GET THE BLOCKSIZE
         CH        R2,DCBLRECL(,R1)    TEST IF BLOCKED
         BE        *+8                 BR IF NOT
         OI        DCBRECFM(R1),X'10'  SET THE  B  BIT
         TM        DCBBUFCB+2(R1),X'01' TEST FOR MY BUFCB
         BCR       1,R14               BOR  BRANCH IF NOT
         L         R3,DCBBUFCB-1(,R1)  POINT AT BUFFER CONTROL BLOCK
         CLC       DCBBUFNO(1,R1),5(R3) TEST IF ENOUGH BUFFERS
         BH        EXIT2               BRANCH IF NOT
*./      DELETE    SEQ1=02572023,SEQ2=02572023
         LA        R2,4(,R2)           ADD 4 IN CASE IT GETS DUMMY BUF
         CH        R2,6(,R3)           TEST IF POOL BUFFERS LONG ENOUGH
         BCR       13,R14              BNHR  RETURN TO OPEN IF OK
EXIT2    OI        DCBBUFCB+2(R1),X'01' SET NO BUFCB IN DCB
         BR        R14                 RETURN TO OPEN
         DROP      R15
         EJECT
*
*        THIS ROUTINE MONITORS SYSIN TO HANDLE EOF AND $JOB SITUATIONS
*
*        IT IS ENTERED BY DOING A NORMAL GET MOVE ON THE SYSIN DCB
*        PHASE F1 HAS ALTERED THE DCBGET ADDR IN THE DCB TO POINT HERE
*
SYSINMON DS        0H
         USING     SYSINMON,R15        USE CALLER'S BRANCH REGISTER
         CLI       SYSINSW,X'00'       TEST FOR EOF OR $JOB
         BZ        SYSINMOV            NOT YET, THEN BRANCH
         L         R15,DCBEODAD(,R1)   LOAD EODAD ADDRESS
         BR        R15                 AND SIMULATE AN EOF
*
SYSINMOV DS        0H
         STM       R12,R14,GETSAVE     SAVE SOME OF CALLER'S REGS
         LR        R12,R15             TRANSFER THE BASE
         DROP      R15                 DROP THE OLD
         USING     SYSINMON,R12        AND USE THE NEW
         LR        R14,R0              POINT TO USER'S INPUT AREA
         L         R15,SYSINBUF        GET ADDR OF NEXT RECORD
         MVC       0(80,R14),0(R15)    GIVE USER THE LAST RECORD
         MVC       SYSINEOD(3),DCBEODAD+1(R1)  SAVE USER'S EODAD ADDR
         MVC       DCBEODAD+1(3,R1),=AL3(SYSINEOF) SET MY EODAD
SYSINGET DS        0H
         NI        SYSINSW,X'FE'       TURN OFF RE-READ SWITCH
         L         R15,DCBGETSV        GET REAL QSAM ADDRESS
         BALR      R14,R15             DO THE GET
         TM        SYSINSW,X'01'       TEST RE-READ SWITCH
         BZ        SYSINGOK            GO ON IF NO RE-READ REQ'D
         MVC       DCBGETSV+1(3),SYSIN+DCBGET+1  SAVE GET ADDR AGAIN
         MVC       SYSIN+L1DCBPAD+1(3),SYSIN+DCBGET+1  SAVE FOR CLOSE
         MVC       SYSIN+DCBGET+1(3),SYSINAD+1   RESET FAKE ADDRESS
         B         SYSINGET            RE-ISSUE THE GET
SYSINGOK DS        0H
         TM        PARBYT1,X'10'       WAS BATCH SPECIFIED .Q
         BZ        SYSINRET            BRANCH IF NOT
         TM        PARBYT2,X'20'       WAS EXECUTE SPECIFIED .Q
         BZ        SYSINRET            BRANCH IF NOT
         CLC       0(L'$JOB,R1),$JOB   TEST FOR A $JOB CARD
         BNE       SYSINRET            BRANCH IF NOT
         MVI       SYSINSW,X'40'       SET $JOB SWITCH
         B         SYSINRET            AND QUIT
*
SYSINEOF DS        0H
         MVI       SYSINSW,X'80'       SET EOF SWITCH
*
SYSINRET DS        0H
         ST        R1,SYSINBUF         SAVE ADDR OF NEXT RECORD
         MVC       SYSIN+DCBEODAD+1(3),SYSINEOD  RESTORE USER'S EODAD
*./      DELETE    SEQ1=03480026,SEQ2=03500026
         LM        R12,R14,GETSAVE     RESTORE CALLER'S REGISTERS
         BR        R14                 RETURN TO USER
         USING     ASMGASM,R12         RESTORE USE OF R12
*
GETSAVE  DC        3F'0'               R12,R13,R14 GET ROUTINE SAVE
SYSINBUF DC        A(BLANKS+1)         ADDR FOR READING 1 CARD AHEAD
SYSINEOD DC        AL3(0)              SAVE REAL SYSIN EODAD
         EJECT
*
*        OUTPUT MONITORING ROUTINE FOR ALL OUTPUT FILES
*
ASMGPUT  DS        0H                  THIS IS IT
         STM       R14,R12,PUTSAVE-ASMGASM(R15)  SAVE CALLER'S REGS
         LR        R12,R15             TRANSFER BASE ADDRESS
         LR        R2,R0               TRANSFER DATA ADDRESS
         LR        R3,R1               TRANSFER DCB ADDRESS
         LM        R4,R5,L1DCBRCT(R3)  R4 IS RECORD COUNT
*                                      R5 IS PREVIOUS LINE LOCATION
*
         TM        L1DCBCC(R3),X'C0'   WHICH CARRIAGE CONTROL .Q
         BM        SYSLNUM             BRANCH IF NUMERIC
         BO        SYSLASA             BRANCH IF ASA
         BAL       R10,SYSLPUT         AS IT IS, GET A BUFFER
         EX        R6,SYSLASIS         PUT OUT THE LINE
         B         SYSLRET             AND RETURN
SYSLASA  DS        0H
         CLI       0(R2),C'1'          NEW PAGE .Q
         BNE       NOTONE              BRANCH IF NOT
         MVI       CARCONT,EJECTIM     SET CARRIAGE CONTROL
         B         FIRSTPUT            BRANCH TO 1ST PUT
NOTONE   DS        0H
         CLI       0(R2),C'-'          TRIPLE SPACE .Q
         BNE       NOTRIP              BRANCH IF NOT
         MVI       CARCONT,SPACE3IM    SET CARRIAGE CONTROL
         B         FIRSTPUT            BRANCH TO FIRST PUT
NOTRIP   DS        0H
         CLI       0(R2),C'0'          DOUBLE SPACE .Q
         BNE       NOTDOUB             BRANCH IF NOT
         MVI       CARCONT,SPACE2IM    DOUBLE SPACE IMMEDIATE
         B         FIRSTPUT            BRANCH TO 1ST PUT
NOTDOUB  CLI       0(R2),C'+'          NO SPACE AT ALL .Q
         BE        SECNDPUT            BRANCH IF YES TO 2ND PUT
NOTPLUS  DS        0H
         MVI       CARCONT,SPACE1IM    MOVE IN SINGLE SPACE
FIRSTPUT DS        0H
         BAL       R10,SYSLPUT         GET OUTPUT BUFFER
         MVC       0(1,R5),CARCONT     SET CARRIAGE CONTROL
         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE
         EX        R6,SYSLBLNK         AND BLANK LINE
SECNDPUT DS        0H
         BAL       R10,SYSLPUT         GET A BUFFER
         MVI       0(R5),SPACE0AP      NO SPACE AFTER PRINT
         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE
         EX        R6,SYSLMOVE         MOVE RECORD
         B         SYSLRET             AND RETURN
SYSLNUM  DS        0H
         CLI       0(R2),X'00'         NORMAL PRINT CODE .Q
         BE        SYSLNORM            BRANCH TO PUT IF YES
         LTR       R5,R5               HAS FILE BEEN WRITTEN BEFORE .Q
         BNZ       SYSLCC2             BRANCH IF YES
         BAL       R10,SYSLPUT         GET AN OUTPUT BUFFER
         BCTR      R6,0                DECREMENT LRECL BY ANOTHER
         EX        R6,SYSLBLNK         AND BLANK THE LINE
SYSLCC2  DS        0H
         CLI       0(R2),200           DO WE WANT AN EJECT .Q
         BL        SYSLSPCE            BRANCH LOW FOR SPACES
SYSLEJCT DS        0H
         MVI       0(R5),EJECTAP       PUT IN EJECT CODE
         B         SYSLNORM            CONTINUE AS USUAL
SYSLSPCE DS        0H
         SR        R7,R7               01 TO 54 FORCES THAT NUMBER
         IC        R7,0(,R2)           OF BLANK LINES (SPACES)
         CLI       0(R2),X'02'         SEE IF LESS THAN 2
         BH        SYSLTRIP            NO, SPACE 3 AT A TIME
         IC        R7,APTBL-1(R7)      01 OR 02 FORCES ONLY
         STC       R7,0(,R5)           NEW CODE IN PREVIOUS LINE
         B         SYSLNORM            CONTINUE AS NORMAL
SYSLTRIP DS        0H
         MVI       0(R5),SPACE3AP      03 TO 54 GENERATES MINIMUM
         S         R7,FW002            NUMBER OF LINES WITH
SYSLSPLP DS        0H                  SPACE IMMEDIATE CODES
         BAL       R10,SYSLPUT         PUT OUT 3 BLANK LINES
         BCTR      R6,0                DECREMENT BY ANOTHER ONE
         EX        R6,SYSLBLNK         BLANK ENTIRE LINE
         C         R7,FW003            ARE WE LESS THAN 3 .Q
         BNH       SYSLDBL             YES, PUT IN NUMBER SPACES LEFT
         MVI       0(R5),SPACE3IM      NO, SPACE ANOTHER 3
         S         R7,FW003            REDUCE COUNTER BY 3
         B         SYSLSPLP            LOOP
SYSLDBL  DS        0H
         IC        R7,IMTAB-1(R7)      PUT IN CORRECT SPACING
         STC       R7,0(,R5)           SAVE NUMBER OF SPACES
SYSLNORM DS        0H
         BAL       R10,SYSLPUT         PUT OUT RECORD
         MVI       0(R5),SPACE1AP      PUT IN NORMAL SPACE
         BCTR      R6,0                DECREMENT BY ANOTHER ONE
         EX        R6,SYSLMOVE         TRANSFER LINE TO BUFFER
SYSLRET  DS        0H
         STM       R4,R5,L1DCBRCT(R3)  RESTORE RECORD COUNT, POINTER
         LM        R14,R12,PUTSAVE     RESTORE CALLER'S REGISTERS
         BR        R14                 RETURN
SYSLPUT  DS        0H
         L         R15,L1DCBPAD(,R3)   GET REAL PUT ADDRESS
         LR        R1,R3               RESTORE DCB ADDRESS
         BALR      R14,R15             GO DO IT
         LR        R5,R1               SAVE POSITION OF NEXT RECORD
         LA        R4,1(,R4)           INCREMENT LINE COUNT
         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE
         BCTR      R6,0                DECREMENT BY ONE
         BR        R10                 RETURN
         SPACE     2
PUTSAVE  DC        15F'0'              PUT ROUTINE SAVE AREA
FW002    DC        F'2'                FULL WORD TWO
FW003    DC        F'3'                FULL WORD THREE
SYSLBLNK MVC       1(*-*,R5),BLANKS+1  MOVE BLANKS TO OUTPUT LINE
SYSLMOVE MVC       1(*-*,R5),1(R2)     TRANSFER LINE TO BUFFER
SYSLASIS MVC       0(*-*,R5),0(R2)     OUTPUT RECORD AS IS
CARCONT  DC        X'00'               WORK AREA FOR CARRIAGE CONTROL
APTBL    DC        AL1(SPACE2AP,SPACE3AP)        SPACE AFTER PRINT
IMTAB    DC        AL1(SPACE1IM,SPACE2IM,SPACE3IM)  SPACE IMMEDIATE TBL
SPACE0AP EQU       X'01'
SPACE1AP EQU       X'09'
SPACE2AP EQU       X'11'
SPACE3AP EQU       X'19'
EJECTAP  EQU       X'89'
SPACE0IM EQU       X'03'
SPACE1IM EQU       X'0B'
SPACE2IM EQU       X'13'
SPACE3IM EQU       X'1B'
EJECTIM  EQU       X'8B'
*
         EJECT
*
*        THIS ROUTINE IS ENTERED BY THE SYNAD EXIT ON AN I/O ERROR
*        R1 POINTS AT THE DCB FOR WHICH THE ERROR OCCURED
*
IOERR    DS        0H
         USING     *,R15
         STM       R11,R12,SAVE3       SAVE REGISTERS
         L         R12,=A(ASMGASM)     LOAD REGULAR BASE VALUE
         DROP      R15
         LA        R11,0(0,R1)         CLEAR TOP BYTE OF REG FOR COMPAR
         C         R11,LIST1+L1DCBADS+L1SPRINT  IS THIS SYSPRINT .Q
         BE        SYSPNTER
         C         R11,LIST1+L1DCBADS+L1SPUNCH  IS THIS SYSPUNCH .Q
         BE        SYSPCHER
         BNL       SYNADQ              SYSPUNCH & ABOVE ARE QSAM
         MVI       SYNADAF+16,2        SYNADAF ACSMETH CODE FOR BSAM
         C         R11,LIST1+L1DCBADS+L1SLIB  IS THIS SYSLIB .Q
         BNE       SYNADQ
         MVI       SYNADAF+16,1        SYNADAF ACSMETH CODE FOR BPAM
SYNADQ   DS        0H
         CNOP      0,4
SYNADAF  SYNADAF   ACSMETH=QSAM
         MVC         ABMESS+59(60),68(1) PICK UP PART OF MESSAGE I WANT
         MVI         ABMESS+119,C''''
         SYNADRLS    ,                 RELEASE SYNADAF BUFF & SAVE AREA
         MVI         AB3+1,X'00'       NOP SW TO TYPE AND PRINT
         B           AB2
*
SYSPCHER LH        R11,PCHERTOT        INCREMENT
         LA        R11,1(0,R11)        PCHERTOT
         STH       R11,PCHERTOT
         OI        ERRORSW,X'20'
         B         BACK1
*
SYSPNTER LH        R11,PRTERTOT        INCREMENT
         LA        R11,1(0,R11)        PRTERTOT
         STH       R11,PRTERTOT
         OI        ERRORSW,X'10'
*
BACK1    LM        R11,R12,SAVE3
         BR        R14                 RETURN TO I/O SUPERVISOR
         EJECT
*        THIS POINT IS ENTERED IF BUFF RUNS OUT OF CORE
BUFFERR  DS        0H
         USING     *,R1
         L         R12,=A(ASMGASM)
         DROP      R1
         BAL       R0,ABEND            PRINT ERROR AND ABEND
         DC        C'990I',AL1(L'MESS990-1)
MESS990  DC        C'INSUFFICIENT MEMORY TO BUFFER UTILITIES'
         EJECT
*
*        ABEND ROUTINE  (ACTUALLY ONLY DOES A RETURN WITH CC=20)
*        ENTER WITH R0 POINTING AT MESSAGE IN FOLLOWING FORMAT
*        DC        C'NNNX',AL1(L'MES-1)
* MES    DC        C'MESSAGE'
*                  NNN IS ERROR NUMBER, X IS 'BLANK', 'I' OR 'A'.
*
ABEND    LR        R1,R0               R1 -> PARMS NOW
         LA        R13,SAVE2           R13 -> OS SAVE AREA
         MVC       AB1+1(1),4(R1)      PLACE LENGTH IN MVC
         MVC       ABMESS+6(4),0(R1)   MOVE ERROR NUMBER
         MVC       ABMESS+13(132-13),ABMESS+12   BLANK LINE
AB1      MVC       ABMESS+13(*-*),5(R1) PLACE MESSAGE
         TM        SYSPRINT+DCBOFLGS,X'10' TEST IF PRINTER IS OPEN
         BO        AB4                 BRANCH IF OPEN
         TM        SYSTERM+DCBOFLGS,X'10'  TEST IF SYSTERM OPEN
         BO        AB6                 BRANCH IF SYSTERM OPEN
AB2      MVC       ABMESS+120(4),=X'02004020' PLACE ROUTE AND DESC CODE
         WTO       MF=(E,ABWTO)        TYPE THE MESSAGE
         MVC       ABMESS+120(12),BLANKS+1  REMOVE ROUTE & DESC CODES
AB3      BC        *-*+15,AB5          BYPASS PRINTING
AB4      DS        0H
         MVI       ABMESS,X'03'        NUMERIC SPACE 3 LINES AND PRINT
         NI        SYSPRINT+L1DCBCC,X'7F'  KILL ASA FLAG
         OI        SYSPRINT+L1DCBCC,X'40'  SET NUMERIC FLAG
         PUT       SYSPRINT,ABMESS     PUT ABEND MESSAGE
*
         TM        SYSTERM+DCBOFLGS,X'10'  IS SYSTERM OPEN .Q
         BZ        AB5                 NO, THEN DON'T PRINT THERE
*
AB6      DS        0H
         NI        SYSTERM+L1DCBCC,X'7F'  KILL ASA FLAG
         OI        SYSTERM+L1DCBCC,X'40'  SET NUMERIC FLAG
         PUT       SYSTERM,ABMESS      PUT ABEND MESSAGE
*
AB5      DS        0H
         AIF       (&DEBUG).AB1
         MVI       SYSINSW,X'80'       SIMULATE EOF ON SYSIN
         SR        R10,R10             ZERO R10 SO RTA MAY TERMINATE
         LA        R15,20              SET RETURN CODE TO 20
         ST        R15,SAVECC          AND PASS IT ON FOR LATER
         SVC       3                   RETURN SVC TO DELETE MODULE
         AGO       .AB2
.AB1     ANOP
         CLOSE     (SYSPRINT,LEAVE)    FORCE BUFFERS
         ABEND     20,DUMP
.AB2     ANOP
*
*./      DELETE    SEQ1=05300022,SEQ2=05360022
         EJECT
*
*        ASM PARAM LIST. ORDER-DEPENDENT. REFERENCED RELATIVE TO
*        'LIST1' BY OTHER PHASES.
*
*
         LIST1EQU
         CNOP      4,8                 DEFDDNAM SHOULD BE ON D BOUNDARY
LIST1    EQU       *
*
* LIST1+L1DCBADS
*
         DC        A(SYSLIN)
         DC        A(SYSTERM)
         DC        A(SYSUP)
         DC        A(SYSLIB)
         DC        A(SYSIN)
         DC        A(SYSPRINT)
         DC        A(SYSPUNCH)
         DC        A(SYSUT1)
         DC        A(SYSUT2)
         DC        X'80'               MARK THE LAST DCB ADDRESS
         DC        AL3(SYSUT3)
*
* LIST1+L1VACFL
*
         DC        A(0)                VACANT FULL WORD AREA
*
*
* LIST1+L1CTLPRM
*
         DC        A(0)                ADDR OF CNTRL PROG PARM LIST
*
* LIST1+L1TIMELM
*
*                  PARAMETERS FILLED BY F1 FROM EXEC CARD
         DC        F'0'          EXECUTION TIME IN SECONDS
*
* LIST1+L1LINECT
*
         DC        H'0'          LINE COUNT
*
* LIST1+L1PBYT1
*
PARBYT1  DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    FULLUPLIST   1    DOS
*                                 2    ESD          3    BATCH
*                                 4    FULLLIST     5    EXTEN
*                                 6    FULLXREF     7    ALGN
*
* LIST1+L1PBYT
*
PARBYT   DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    DECK         1    LOAD
*                                 2    RENT         3    LIST
*                                 4    RLD          5    UPLIST
*                                 6    XREF         7    TEST
*
* LIST1+L1PBYT2
*
PARBYT2  DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    LREF         1    UPDATE
*                                 2    EXECUTE      3    SPACE=MAX
*                                 4    TERM         5    NUM
*                                 6    STMT         7    RESERVED
*
* LIST1+L1PBYT3
*
PARBYT3  DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    RESERVED     1    RESERVED
*                                 2    RESERVED     3    RESERVED
*                                 4    RESERVED     5    RESERVED
*                                 6    RESERVED     7    UNUSED
*
* LIST1+L1SYNERR
*
*        FOLLOWING 3 ITEMS SET BY SYNAD ROUTINE AND
*        AND MACRO TABLE BUILDER FOR ASMGFD.
ERRORSW  DC        X'0000'             ERROR SWITCHES IN TOP BYTE
*                            BIT  ERROR       BIT  ERROR
*                             0  204 SEV 16    1  204 SEV 4
*                             2    207         3    206
*                             4    208         5    209
*                             6    203         7   UNUSED
*                             8    ---         9    ---
*                            10    ---        11    ---
*                            12    ---        13    ---
*                            14    ---        15    115
*
* LIST1+L1IOERR
*
PCHERTOT DC        H'0'                COUNTS I/O ERRORS ON SYSPUNCH
PRTERTOT DC        H'0'                COUNTS I/O ERRS ON SYSPRINT
*
* LIST1+L1FINDCT
*
         DC        F'0'                FINDS ON SYSLIB COUNT
*
* LIST1+L1CALIGN
*
         DC        X'00',XL3'00'       COMMENT ALIGNMENT VALUE
*
* LIST1+L1BUFADR
*
BUFRTADR DC        V(BUFFENT)          ADDR OF SUPER BUFFER AND CORE   X
                             MANAGEMENT ROUTINE
*
* LIST1+L1DDNAM
*
*        TABLE OF DDNAMES. MAY BE ALTERED BY F1.
DEFDDNAM DC        C'SYSLIN  '
         DC        C'SYSTERM '
         DC        C'SYSUP   '
         DC        C'SYSLIB  '
         DC        C'SYSIN   '
         DC        C'SYSPRINT'
         DC        C'SYSPUNCH'
         DC        C'SYSUT1  '
         DC        C'SYSUT2  '
         DC        C'SYSUT3  '
*
* LIST1+L1PRDATE
*
         DC        C'DD MON YY'        SET TO DATE BY F1
*
* LIST1+L1UPCOND
*
         DC        X'00'               MAX UPDATE CONDITION CODE
*./      DELETE    SEQ1=07110025,SEQ2=07116025
*
* LIST1+L1ABEND
*
         USING     LIST1,R1
         L         R12,=A(ASMGASM)     THIS POINT ENTERED TO TYPE/PRINT
         B         ABEND                 MESSAGE AND ABEND
         DROP      R1
*
* LIST1+L1LSETC
*
         DC        X'00'               DEFAULT SETC VARIABLE LENGTH
*
* LIST1+L1COLCT
*
         DC        X'00'               COLUMN= COUNT FOR XREFS
*
* LIST1+L1BUFERR
*
         DC        A(BUFFERR)          BUFF ERROR HANDLING ROUTINE
*
* LIST1+L1SINAD
*
SYSINAD  DC        A(SYSINMON)         SYSIN MONITOR
DCBGETSV DC        2F'0'               SAVE FOR DCBGET IN SYSIN DCB
*
* LIST1+L1FREEMN
*
FREEMEM  DC        2F'0'               FREEMAIN OPERANDS  SET BY F1
*
* LIST1+L1ISADDR
*
         DC        F'0'                ADDRESS OF ASMGISXX MODULE
*
* LIST1+L1ISNAME
*
ISNAME   DC        C'ASMGISXX'         NAME OF THE INSTRUCTION SET MOD.
*
* LIST1+L1PRTIME
*
         DC        C'HH:MM:SS'         SET TO TIME BY F1
*
* LIST1+L1BTCSUM
*
BATCHSUM DC        A(0)                ADDRESS OF FIRST BATCH SUMMARY
*
* LIST1+L1ASPARM
*
ASYSPARM DC        F'0'                LENGTH AND ADDRESS OF SYSPARM
*
* LIST1+L1SAVECC
*
SAVECC   DC        F'0'                SAVES HIGHEST COND CODE RETURNED
*
* LIST1+L1BLDL-4
*
BLDLADDR DC        H'7'                SEVEN ENTRIES TO BUILD
         DC        H'36'               EACH ONE 36 BYTES LONG
         DC        CL8'ASMGFPP'        L1BLDL
         DC        14H'0'
         DC        CL8'ASMGF1'
         DC        14H'0'
         DC        CL8'ASMGF2'
         DC        14H'0'
         DC        CL8'ASMGF3'
         DC        14H'0'
         DC        CL8'ASMGF7'
         DC        14H'0'
         DC        CL8'ASMGF8'
         DC        14H'0'
         DC        CL8'ASMGRTA'
         DC        14H'0'
*                                      L1BLDL+7*L1LENBL
* LIST1+L1SINSW
*
SYSINSW  DC        X'00'               EOF AND $JOB SWITCHES
*                  X'80'               EOF
*                  X'40'               $JOB
*                  X'01'               CLOSE & OPEN AT CONCATENATION
*
* LIST1+L1RLSDTE
*
RELSDATE DC        C'21FEB74'          ASSEMBLER RELEASE DATE
*
* LIST1+L1ASDATE
*
ASYSDATE DC        C'LYYMONDD'         LENGTH & DATE IN INTERNAL CODE
*
* LIST1+L1ASTIME
*
ASYSTIME DC        C'HH:MM:SS'         TIME IN INTERNAL CODE
*
* LIST1+L1VERMOD
*
         DC        CL4'0207'           ASSEMBLER VERSION AND LEVEL
*
* LIST1+L1JDATE
*
         DC        CL6'YYDDDS'         TODAY'S JULIAN DATE
*
* LIST1+L1PID
*
         DC        CL10'ASMG21FEB'     PROGRAM IDENTIFICATION
*
* LIST1+L1TRSAVE
*
TRSAVE   DC        F'0'                SYSTERM LINES PER PAGE
         DC        A(0)                ADDRESS OF LAST LINE IN BUFFER
*
* LIST1+L1UTLINO
*
         DC        F'0'                LINE NUMBER FOR UPDATE FEATURE
*
* LIST1+L1PAGENO
*
         DC        F'0'                PAGE NUMBER FOR SYSPRINT
*
* LIST1+L1LENMC
*
         DC        F'0'                LENGTH OF MACRO DRCTRY D ALIGNED
*
* LIST1+L1BOTMC
*
         DC        F'0'                BOTTOM OF MACRO DIRECTORY
*
* LIST1+L1TOPMC
*
         DC        F'0'                TOP ENTRY IN MACRO DIRECTORY
*
*
* LIST1+L1OUTRTN
*
         USING     *,R15               ENTRY ADDRESS SET BY PUT
         L         R15,=A(ASMGASM)     CHANGE BASE ADDRESSES
         USING     ASMGASM,R15         TRANSFER BASE
         B         ASMGPUT             BRANCH TO GENERAL PUT ROUTINE
         DROP      R15
*
* LIST1+L1DPTRTN
*
         BR        R14                 RETURN IMMEDIATELY
*
* LIST1+L1BLANKS
*
BLANKS   DC        X'00',CL133' '      ZERO FOLLOWED BY BLANKS
*
* LIST1+L1$JOB
*
$JOB     DC        CL5'$JOB '          BATCH,EXECUTE JOB SEPARATOR
*
* LIST1+L1PATCH
*
         DC        41S(*)              COMMON PATCH, ASMGASM/ASMGBUFF
*                                      ALIGNING TO 2K MULTIPLE.
*
*
*        LIST1 ENDS HERE
*
         EJECT
SAVE1    DC        F'0'                POINTER TO INVOKER'S SAVE AREA
*        THE FOLLOWING SAVE AREA IS USED BY ASM, RTA AND ABEND
SAVE2    DS        18F                 OS SAVE AREA
         SPACE     2
         ORG       SAVE2               OVERLAY SAVE AREA
INITIAL  STM       R14,R12,12(R13)     SAVE REGISTERS IN CALLER'S AREA
         LR        R12,R15             SET R12 AS THE BASE
         ST        R13,SAVE1           SAVE CONTROL PROGRAM SAVE AREA
         ST        R1,LIST1+L1CTLPRM   SAVE ADDR OF CTL PROG PARAM LIST
         LA        R13,SAVE2           SET SAVE AREA ADDRESS
         SR        R10,R10             TURN BATCH SWITCH OFF IN F1
         BLDL      0,BLDLADDR          DO BLDL ON LOAD MODULES
         LTR       R15,R15             WAS IT SUCCESSFUL .Q
         BZ        INITLINK            YES, INITIALIZE LINK TO ASMGF1
         L         R1,SYS806           LOAD DUMP MASK
         ABEND     (1)                 SYSTEM ABEND 806
         DS        0F                  ALIGNMENT
SYS806   DC        X'80806000'         SYSTEM 806 WITH DUMP
INITLINK DS        0H
         ENTRYOUT  ASM
         LA        R9,LIST1            PASS LIST1 ADDRESS TO ASMGF1
         LA        R15,F1LINK          LINK ARGUMENT LIST
         B         DONEINIT            GO BACK AND LINK
         ORG
SAVE3    DS        2F                  SAVE AREA FOR I/O ERROR ROUTINE
         ORG       SAVE3               BACK UP
F1LINK   DS        0F                  ALIGN THE LINK ARG LIST
         DC        X'80'               SET DE SWITCH BIT ON
         DC        AL3(LIST1+L1BLDL+L1LENBL)  DE PARAMETER
         DC        A(0)                DCB ADDRESS PARAMETER
         ORG
         SPACE     2
         LTORG
         EJECT
*
*        DCB'S ARE GENERATED HERE
*
DCBBUFNO EQU       20                  NUMBER OF BUFFERS
DCBBUFCB EQU       21                  ADDR OF BUFFER CONTROL BLOCK
DCBEODAD EQU       32                  EODAD EXIT ADDRESS
DCBRECFM EQU       36                  RECORD FORMAT
DCBDDNAM EQU       40                  DD NAME POSITION WITHIN DCB
DCBOFLGS EQU       48                  DCB OPEN FLAGS
DCBGET   EQU       48                  DCB GET ADDRESS
DCBBLKSI EQU       62                  BLOCK SIZE
DCBLRECL EQU       82                  LOGICAL RECORD LENGTH
*
*
         SPACE     2
***********************************************************************
*        EACH DCB IS FOLLOWED BY A WORK AREA FOR THAT FILE            *
*        AT DCB + L1DCBRCT  -  F'A COUNT OF RECORDS PASSED'           *
*               + L1DCBLPT  -  A(LAST RECORD POINTER IN LOCATE MODE)  *
*               + L1DCBCC   -  X'CARRIAGE CONTROL INDICATOR'          *
*                           -  X'C0'        ASA                       *
*                           -  X'40'        NUMERIC                   *
*                           -  X'00'        NONE                      *
*               + L1DCBPAD  -  X'08'    MONITOR FOR PUTS              *
*                           -  X'04'    MONITOR FOR GETS              *
*                           -  X'02'    SUMMARY OF PUT RECORDS AT END *
*                           -  X'01'    SUMMARY OF GET RECORDS AT END *
*                           -  AL3(REAL GET/PUT ADDRESS)              *
***********************************************************************
*
*        DATA CONTROL BLOCK FOR SYSUT1
SYSUT1   DCB       DDNAME=SYSUT1,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X
               SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUT1+L1DCBBLK
         DC        H'0'                SYSUT1 BLKSIZE FROM JFCB
         DC        F'0'                RECORD COUNT FOR SYSUT1
         DC        A(0)                LAST RECORD POINTER
         DC        X'00'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSUT2
SYSUT2   DCB       DDNAME=SYSUT2,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X
               SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUT2+L1DCBBLK
         DC        H'0'                SYSUT2 BLKSIZE FROM JFCB
         DC        F'0'                RECORD COUNT FOR SYSUT2
         DC        A(0)                LAST RECORD POINTER
         DC        X'00'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSUT3
SYSUT3   DCB       DDNAME=SYSUT3,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X
               SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUT3+L1DCBBLK
         DC        H'0'                SYSUT3 BLKSIZE FROM JFCB
         DC        F'0'                RECORD COUNT FOR SYSUT3
         DC        A(0)                LAST RECORD POINTER
         DC        X'00'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSLIB
         DC    CL8'SYSLIB'         DDNAME SAVE/PASS FOR F1
SYSLIB   DCB       DDNAME=SYSLIB,MACRF=(R),RECFM=F,DSORG=PO,           X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSLIB+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSLIB
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08514026,SEQ2=08514026
         DC        X'01'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSPUNCH
SYSPUNCH DCB       DDNAME=SYSPUNCH,MACRF=(PL),RECFM=F,DSORG=PS,        X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSPUNCH+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSPUNCH
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08614026,SEQ2=08614026
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSPRINT
SYSPRINT DCB       DDNAME=SYSPRINT,MACRF=(PL),RECFM=FM,DSORG=PS,       X
               LRECL=0,EROPT=ACC,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSPRINT+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSPRINT
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08714026,SEQ2=08714026
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSIN
SYSIN    DCB       DDNAME=SYSIN,MACRF=(GL),RECFM=F,DSORG=PS,           X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSIN+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSIN
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08814026,SEQ2=08814026
         DC        X'05'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSLIN
SYSLIN   DCB       DDNAME=SYSLIN,MACRF=(PL),RECFM=F,DSORG=PS,          X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSLIN+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSLIN
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08900726,SEQ2=08900726
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSTERM
SYSTERM  DCB       DDNAME=SYSTERM,MACRF=(PL),RECFM=FM,DSORG=PS,        X
               LRECL=0,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSTERM+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSTERM
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08905726,SEQ2=08905726
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSUP
SYSUP    DCB       DDNAME=SYSUP,MACRF=(GL),RECFM=F,DSORG=PS,           X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUP+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSUP
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08917026,SEQ2=08917026
         DC        X'05'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
         END       ASMGASM
./ ADD NAME=ASMGBUFF
         ICTL      1,71,20
         ISEQ      73,78
         PRINT     ON,GEN,NODATA
BUFF     TITLE     ' '
***********************************************************************
*
*        THIS DECK CONTAINS THE BUFFERING ROUTINES FOR ASMG.
*
*                  WRITTEN AUG. 67 BY RENNIE PETERSEN
*
***********************************************************************
*
*        GENERAL COMMENTS
*
*                  THESE ROUTINES ARE DESIGNED TO BUFFER THE UTILITIES
*        IN CORE TO AS LARGE AN EXTENT AS POSSIBLE.
*                  WHEN A CALL TO THE WRITE ROUTINE IS EXECUTED, IT
*        MOVES THE DATA INTO A CORE BUFFER INSTEAD OF WRITING THE DATA
*        ON THE DISK.
*                  ALL DATA IS WRITTEN INTO AND READ FROM CORE AS LONG
*        AS THERE IS ENOUGH CORE AVAILABLE.
*                  WHEN THE SUPPLY OF MEMORY RUNS OUT, THE ROUTINES
*        BEGIN TO SPILL SOME OF THE RECORDS OUT ONTO THE DISK.
*                  AT WORST THE UTILITIES WILL STILL BE DOUBLE BUFFERED
*                  THE NUMBER OF UTILITIES THAT THIS PROGRAM TRIES TO
*        BUFFER IS VARIABLE FROM ALL TO NONE.
*                  THIS IS BECAUSE FOR A LARGE FILE A LOT OF MEMORY IS
*        USED UP FOR A TABLE EVEN IF ALL THE RECORDS HAVE BEEN SPILLED
*        ONTO THE DISK.
*                  ALTHOUGH WRITTEN SPECIFICALLY FOR ASMG THE ROUTINES
*        ARE DESIGNED TO BE AS GENERAL AS POSSIBLE.
*                  THIS PROGRAM IS NOT REENTRANT. IT IS SERIALLY
*        REUSEABLE IF &SERUSE IS SET TO 1 .
*
***********************************************************************
*
*        ROUTINES AVAILABLE
*
* NO.    LABEL     NAME            PURPOSE
* ---    -----     ----            -------
*  0     READK     READ & KEEP     READ A RECORD WHICH MAY BE REREAD
*  4     READP     READ & PURGE    READ A RECORD AND FREE BUFFER SPACE
*  8     WRITE     WRITE           WRITE A RECORD
* 12     POINTR    POINT TO READ   POINT TO READ A NOTED RECORD
* 16     POINTW    POINT TO WRITE  POINT TO WRITE A NOTED RECORD.
* 20     NOTE      NOTE            NOTE POSITION FOR FUTURE POINTS
* 24     TCLOSE    CLOSE TYPE=T    REWIND AND SWITCH FROM WRITE TO READ
*                                     OR READ TO WRITE
* 28     CHECK     CHECK           CHECK READ OR WRITE COMPLETED
* 32     GROW      GROW            ADD CORE TO BUFFER SPACE
* 36     SHRINK    SHRINK          DELETE CORE FROM BUFFER SPACE
* 40     INIT      INITIALIZE      INITIALIZE TABLES
*
***********************************************************************
*
*        LINKAGE CONVENTIONS
*
*        ALL ROUTINES ARE CALLED IN THE SAME WAY.
*        REGISTER 0 POINTS TO A PARAMETER LIST WHICH IS IN-LINE.
*        THE PARAMETER LIST CONSISTS OF ONE OR MORE FULL WORDS.
*        THE PARAMETER LIST CONTENTS IS DEFINED FOR EACH ROUTINE.
*        THE FIRST PARAMETER WORD SELECTS THE ROUTINE BEING CALLED.
*        THE ENTRY ADDRESS IS 'BUFFENT'.
*        REGISTER 1 MUST CONTAIN THIS ADDRESS.
*        ONLY R0 AND R1 ARE ALTERED.
*        R13 NEED NOT POINT AT A SAVE AREA.
*        RETURN IS TO THE INSTRUCTION FOLLOWING THE PARAMETER LIST.
*        EXAMPLE
*                  L       1,ADDRESS OF BUFFENT
*                  CNOP    2,4
*                  BALR    0,1
*                  DC      F           1ST PARAMETER
*                  DC      F           2ND PARAMETER
*                  INSTRUCTION     RETURN POINT
*
***********************************************************************
*
*        REGISTER USAGE
*
*        R2 TO R15 ARE SAVED ON ENTRY AND RESTORED ON EXIT.
*        R0 TO R7 & R14,R15 ARE WORK REGISTERS.
*        R8        IS RETURN FROM SUBROUTINES.
*        R9        POINTS TO UCT FOR MOST I/O ROUTINES.
*        R10       ALWAYS POINTS TO THE PARAMETER LIST.
*        R11       BASE REGISTER.
*        R12       BASE REGISTER.
*        R13       ALWAYS POINTS AT SAVE AREA. DOUBLES AS BASE REGISTER
*        FR0       IS SAVED ON ENTRY AND RESTORED ON EXIT. USED IN MOVE
*
***********************************************************************
*
*        ABBREVIATIONS AND DEFINITIONS
*
*        UCT       UTILITY CONTROL TABLE
*        UUCT      UNBUFFERED UTILITY CONTROL TABLE
*        CML       CORE MANAGEMENT LIST
*        RCL       RECORD CONTROL LIST
*        RCP       RECORD CONTROL PREFIX
*        FCP       FREE CORE PREFIX
*        READ      DATA MOVEMENT FROM THIS PROGRAM TO USER
*        WRITE     DATA MOVEMENT FROM USER TO THIS PROGRAM
*        SPILLOUT  DATA MOVEMENT FROM THIS PROGRAM TO THE DISK
*        SPILLIN   DATA MOVEMENT FROM THE DISK TO THIS PROGRAM
*        USER      THE PROGRAMS WHICH CALL THIS ONE
*        DISK      DIRECT ACCESS STORAGE DEVICE
*        RECORD    A BLOCK OF DATA
*
***********************************************************************
*
*        ASSUMPTIONS AND RESTRICTIONS
*
*                  A READ MAY ONLY FOLLOW A POINTR, A TCLOSE PRECEEDED
*        BY A WRITE, OR ANOTHER READ. SIMILARLY A WRITE MAY ONLY
*        FOLLOW A POINTW, A TCLOSE PRECEEDED BY A READ, OR ANOTHER
*        WRITE.
*
*                  THE MOVE SUBROUTINE IS OPTIMIZED FOR A MODEL 75.
*
*                  THE ROUTINES ARE WRITTEN FOR BSAM WITH NOTE, POINT,
*        AND TCLOSE. THE DCB MUST SPECIFY RECFM=U,NCP=1, NO EODAD.
*
*                  THE USERS I/O AREA MUST BEGIN ON A DOUBLE WORD
*        BOUNDRY. (THIS RESTRICTION IS FOR MOD 75 PERFORMANCE PURPOSES
*        ONLY. SEE MOVE SUBROUTINE.)
*
*                  THE DCB'S MUST BE OPENED BY THE USER BEFORE THE
*        FIRST CALL TO THE BUFFERING ROUTINES AND CLOSED BY THE USER
*        AFTER THE LAST CALL.
*
*                  THE USER MUST NOT EXECUTE ANY MACROS ON THE DCB
*        ONCE HE HAS STARTED USING BUFF'S I/O FACILITIES.
*
*                  THE INITIALIZATION CALL SETS THINGS UP AS IF A
*        POINTW 1 HAD BEEN DONE ON EACH UTILITY.
*
*                  IF SIX OR MORE UTILITIES ARE BEING BUFFERED THE
*        FOLLOWING MINIMUM RECORD LENGTH RESTRICTION APPLIES. THE
*        RECORD LENGTH MUST NOT BE LESS THAN 4*NUMBER OF BUFFERED
*        UTILITIES - 16 REDUCED TO THE NEAREST MULTIPLE OF 8.
*
*                  UTILITIES THAT ARE BEING BUFFERED MUST BE ON DIRECT
*        ACCESS STORAGE. UTILITIES THAT ARE NOT BEING BUFFERED MAY BE
*        ON DIRECT ACCESS OR TAPE.
*
*                  ONE AND ONLY ONE CHECK CALL MUST FOLLOW EVERY
*        READ OR WRITE CALL.
*
*                  THE READ ROUTINE CANNOT READ PARTIAL RECORDS.
*        IT ALWAYS READS THE WHOLE RECORD.
*
***********************************************************************
         TITLE     'MACRO DEFINITIONS'
***********************************************************************
*
*        MACRO DEFINITIONS
*
*                  THIS MACRO SETS UP R0 TO R15
         MACRO
         SETR
         LCLA      &A
&A       SETA      0
.S       ANOP
R&A      EQU       &A
&A       SETA      &A+1
         AIF       (&A NE 16).S
         MEND
*           THIS MACRO SETS UP XR1 TO XR15 FOR ADDRESSING PURPOSES
         MACRO
         SETX
         LCLA      &A
&A       SETA      1
.S       ANOP
XR&A     DSECT
         USING     XR&A,R&A
&A       SETA      &A+1
         AIF       (&A NE 16).S
&SYSECT  CSECT
         MEND
*                  THIS MACRO RESETS XRN WHEN RN IS DROPED
         MACRO
         DROPR
         LCLA      &A
         AIF       (N'&SYSLIST EQ 0).ALL
&A       SETA      1
.S       AIF       (N'&SYSLIST(&A) EQ 0).EXIT
         USING     X&SYSLIST(&A),&SYSLIST(&A)
&A       SETA      &A+1
         AGO       .S
.ALL     SETX
.EXIT    MEND
*                  DROP ONE BASE AND USE A NEW ONE
         MACRO
         DROPRUSE  &OR,&S,&NR
         DROPR     &OR
         USING     &S,&NR
         MEND
*                  THIS MACRO SETS UP MASK BIT SYMBOLS
         MACRO
         SETM
         LCLC      &B1(8),&B2(8),&B3
         LCLA      &WORK,&BITPT
.*       INITIALIZE &B2 TO '1'S AND &B1 TO NUMBERS
.LOOP1   ANOP
&B1(&WORK+1) SETC  '&WORK'
&B2(&WORK+1) SETC  '1'
&WORK    SETA      &WORK+1
         AIF       (&WORK LE 7).LOOP1
.*       ADD AND RIPPLE
.LOOP2   ANOP
&BITPT   SETA      1
.LOOP3   AIF       ('&B2(&BITPT)' EQ '1').ADD
&B2(&BITPT) SETC   '1'
&WORK    SETA      &BITPT-1
&B1(&BITPT) SETC   '&WORK'
&BITPT   SETA      &BITPT+1
         AIF       (&BITPT EQ 9).EXIT
         AGO       .LOOP3
.ADD     ANOP
&B2(&BITPT) SETC   '0'
&B1(&BITPT) SETC   ''
.*       GENERATE THE EQU
&B3      SETC      '&B2(1)&B2(2)&B2(3)&B2(4)&B2(5)&B2(6)&B2(7)&B2(8)'
M&B1(1)&B1(2)&B1(3)&B1(4)&B1(5)&B1(6)&B1(7)&B1(8)    EQU     B'&B3'
         AGO       .LOOP2
.EXIT    MEND
*                  THIS MACRO SETS UP INVERSE MASK BIT SYMBOLS
         MACRO
         SETN
         LCLC      &B1(8),&B2(8),&B3
         LCLA      &WORK,&BITPT
.*       INITIALIZE &B2 TO '0'S AND &B1 TO NUMBERS
.LOOP1   ANOP
&B1(&WORK+1) SETC  '&WORK'
&B2(&WORK+1) SETC  '0'
&WORK    SETA      &WORK+1
         AIF       (&WORK LE 7).LOOP1
.*       ADD AND RIPPLE
.LOOP2   ANOP
&BITPT   SETA      1
.LOOP3   AIF       ('&B2(&BITPT)' EQ '0').ADD
&B2(&BITPT) SETC   '0'
&WORK    SETA      &BITPT-1
&B1(&BITPT) SETC   '&WORK'
&BITPT   SETA      &BITPT+1
         AIF       (&BITPT EQ 9).EXIT
         AGO       .LOOP3
.ADD     ANOP
&B2(&BITPT) SETC   '1'
&B1(&BITPT) SETC   ''
.*       GENERATE THE EQU
&B3      SETC      '&B2(1)&B2(2)&B2(3)&B2(4)&B2(5)&B2(6)&B2(7)&B2(8)'
N&B1(1)&B1(2)&B1(3)&B1(4)&B1(5)&B1(6)&B1(7)&B1(8)    EQU     B'&B3'
         AGO       .LOOP2
.EXIT    MEND
*                  ALIGN MACRO  UPS REGISTER TO MULTIPLE OF 2,4, OR 8
         MACRO
&L       ALIGN     &R,&B,&INC=0
.*       THIS MACRO WILL NOT WORK ON R0
         AIF       ('&B' NE 'H').F
&L       LA        &R,&INC+1(0,&R)
         N         &R,=X'FFFFFFFE'
         AGO       .EXIT
.F       AIF       ('&B' NE 'F').D
&L       LA        &R,&INC+3(0,&R)
         N         &R,=X'FFFFFFFC'
         AGO       .EXIT
.D       AIF       ('&B' EQ 'D').D1
         MNOTE     'ALIGN ERROR. &B NOT VALID SECOND ARGUMENT'
.D1      ANOP
&L       LA        &R,&INC+7(0,&R)
         N         &R,=X'FFFFFFF8'
.EXIT    MEND
*                  MACRO USED IN GATHERING STATISTICS
         MACRO
&L       ACCUM     &S
         GBLB      &NOTSTAT
&L       DS        0H
         AIF       (&NOTSTAT).EXIT
         AP        &S.(5),=PL2'10'
.EXIT    MEND
*                  MACRO USED TO AID DEBUGGING
         MACRO
         LINKCHK
         GBLB      &LINKCHK
.*       THIS CODE VERIFIES THE VALIDITY OF THE CML
         AIF       (NOT &LINKCHK).END
.*       SAVE REGISTERS
         STM       R8,R10,LSAV&SYSNDX
.*       CHECK THE UP POINTERS
         LA        R8,CORELIST
         LR        R9,R8
         LR        R10,R8
         L         R9,FCPPTUP-FCP(0,R9)
         L         R10,CMLPTUP-CML(0,R10)
         CR        R10,R9
         BNE       *-6
         CR        R10,R8
         BNE       *-16
.*       CHECK THE DOWN POINTERS
         L         R9,FCPPTDWN-FCP(0,R9)
         L         R10,CMLPTDWN-CML(0,R10)
         LA        R10,0(0,R10)
         CR        R10,R9
         BNE       *-10
         CR        R10,R8
         BNE       *-20
.*       RESTORE REGISTERS
         LM        R8,R10,LSAV&SYSNDX
         CNOP      0,4
         B         *+16
LSAV&SYSNDX DC     3F'0'
.END     MEND
*                  GENERATE CROSS REFERENCE ENTRY MACRO
         MACRO
         REF
         LCLA      &WORK
&WORK    SETA      1
.LOOP    AIF       (T'&SYSLIST(&WORK) EQ 'O').EXIT
         DS        0AL4(&SYSLIST(&WORK))
&WORK    SETA      &WORK+1
         AGO       .LOOP
.EXIT    MEND
*./      DELETE    SEQ1=05780020,SEQ2=05900020
*                  THESE MACROS DEFINE INSTRUCTIONS WHICH ACT          X
                   DIFFERENTLY WHEN 0 IS ONE OF THE OPERANDS
         MACRO
&L       BALR0     &R
&L       BALR      &R,0
         MEND
         MACRO
&L       BCTR0     &R
&L       BCTR      &R,0
         MEND
*                  THESE MACROS ARE EXTENDED BRANCH CONDITIONALS
         MACRO
&L       BN        &A
&L       BC        4,&A            BRANCH NEGATIVE
         MEND
         MACRO
&L       BNLC      &S
&L       BC        12,&S           BRANCH NOT LOGICAL CARRY
         MEND
         MACRO
&L       BZR       &R
&L       BCR       8,&R            BRANCH ZERO REGISTER
         MEND
         MACRO
&L       BNER      &R
&L       BCR       7,&R            BRANCH NOT EQUAL REGISTER
         MEND
         MACRO
&L       BNZR      &R
&L       BCR       7,&R            BRANCH NOT ZERO REGISTER
         MEND
         MACRO
&L       BLR       &R
&L       BCR       4,&R            BRANCH LOW REGISTER
         MEND
         MACRO
&L       BER       &R
&L       BCR       8,&R            BRANCH EQUAL REGISTER
         MEND
         MACRO
&L       BNLR      &R
&L       BCR       11,&R           BRANCH NOT LOW REGISTER
         MEND
*                  TEST UNDER MASK AND BRANCH CONDITIONALS
         MACRO
&L       TMBZ      &S,&M,&B
&L       TM        &S,&M           TEST UNDER MASK AND
         BZ        &B              BRANCH ZERO
         MEND
         MACRO
&L       TMBNZ     &S,&M,&B
&L       TM        &S,&M           TEST UNDER MASK AND
         BNZ       &B              BRANCH NOT ZERO
         MEND
         MACRO
&L       TMBZR     &S,&M,&R
&L       TM        &S,&M           TEST UNDER MASK AND
         BZR       &R              BRANCH ZERO REGISTER
         MEND
*                  TEST UNDER MASK REGISTER AND BRANCH CONDITIONAL
         MACRO
&L       TMRBZ     &R,&M,&B
&L       STC       &R,*+5          TEST UNDER
         TM        =AL1(&M),*-*    MASK REGISTER AND
         BZ        &B              BRANCH ZERO
         MEND
         MACRO
&L       TMRBNZ    &R,&M,&B
&L       STC       &R,*+5          TEST UNDER
         TM        =AL1(&M),*-*    MASK REGISTER AND
         BNZ       &B              BRANCH NOT ZERO
         MEND
*                  LOAD AND TEST AND MACRO
         MACRO
&L       LTAND     &R,&S
&L       L         &R,&S           LOAD AND
         LTR       &R,&R           TEST AND
         MEND
*                  LOAD AND TEST AND BRANCH CONDITIONAL MACROS
         MACRO
&L       LTBZ      &R,&S,&B
&L       LTAND     &R,&S           LOAD AND TEST AND
         BZ        &B              BRANCH ZERO
         MEND
         MACRO
&L       LTBNZ     &R,&S,&B
&L       LTAND     &R,&S           LOAD AND TEST AND
         BNZ       &B              BRANCH NOT ZERO
         MEND
         MACRO
&L       LTBP      &R,&S,&B
&L       LTAND     &R,&S           LOAD AND TEST AND
         BP        &B              BRANCH POSITIVE
         MEND
*                  LOAD AND TEST AND BRANCH CONDITIONAL REGISTER MACROS
         MACRO
&L       LTBZR     &R,&S,&B
&L       LTAND     &R,&S           LOAD AND TEST AND
         BZR       &B              BRANCH ZERO REGISTER
         MEND
*                  LOAD AND TEST REGISTER AND BRANCH CONDITIONAL MACROS
         MACRO
&L       LTRBZ     &R,&B
&L       LTR       &R,&R           LOAD AND TEST REGISTER AND
         BZ        &B              BRANCH ZERO
         MEND
         MACRO
&L       LTRBNL    &R,&B
&L       LTR       &R,&R           LOAD AND TEST REGISTER AND
         BNL       &B              BRANCH NOT LOW
         MEND
*                  COMPARE AND BRANCH CONDITIONAL MACROS
         MACRO
&L       CBNH      &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BNH       &B              BRANCH NOT HIGH
         MEND
         MACRO
&L       CBNL      &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BNL       &B              BRANCH NOT LOW
         MEND
         MACRO
&L       CBL       &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BL        &B              BRANCH LOW
         MEND
         MACRO
&L       CBE       &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BE        &B              BRANCH EQUAL
         MEND
         MACRO
&L       CBH       &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BH        &B              BRANCH HIGH
         MEND
         MACRO
&L       CBNE      &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BNE       &B              BRANCH NOT EQUAL
         MEND
*                  COMPARE AND BRANCH CONDITIONAL REGISTER MACROS
         MACRO
&L       CBLR      &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BLR       &B              BRANCH LOW REGISTER
         MEND
         MACRO
&L       CBNLR     &R,&S,&B
&L       C         &R,&S           COMPARE AND
         BNLR      &B              BRANCH NOT LOW REGISTER
         MEND
*                  COMPARE LOGICAL AND BRANCH CONDITIONAL MACROS
         MACRO
&L       CLBNL     &R,&S,&B
&L       CL        &R,&S           COMPARE LOGICAL AND
         BNL       &B              BRANCH NOT LOW
         MEND
         MACRO
&L       CLBL      &R,&S,&B
&L       CL        &R,&S           COMPARE LOGICAL AND
         BL        &B              BRANCH LOW
         MEND
*                  COMPARE REGISTER AND BRANCH CONDITIONAL MACROS
         MACRO
&L       CRBNH     &R1,&R2,&B
&L       CR        &R1,&R2         COMPARE REGISTER AND
         BNH       &B              BRANCH NOT HIGH
         MEND
         MACRO
&L       CRBH      &R1,&R2,&B
&L       CR        &R1,&R2         COMPARE REGISTER AND
         BH        &B              BRANCH HIGH
         MEND
         MACRO
&L       CRBE      &R1,&R2,&B
&L       CR        &R1,&R2         COMPARE REGISTER AND
         BE        &B              BRANCH EQUAL
         MEND
         MACRO
&L       CRBL      &R1,&R2,&B
&L       CR        &R1,&R2         COMPARE REGISTER AND
         BL        &B              BRANCH LOW
         MEND
         TITLE     ' '
***********************************************************************
*
*        SET SYMBOL DEFINITIONS
*
*./      DELETE    SEQ1=09720020,SEQ2=09800020
         COPY      ASMGSET
*./      DELETE    SEQ1=09840020,SEQ2=09900020
         EJECT
***********************************************************************
*
*        ASSORTED PARAMETERS AND INITIAL SYMBOL SETTING
*
ASMGBUFF START
         ENTRY     BUFFENT
RCLINITL EQU       4*100           NUMBER OF BYTES INITIALLY ASSIGNED  X
                   TO RCL PER UTILITY. MUST BE MULTIPLE OF 8.
FR0      EQU       0               FLOATING REGISTER 0
         SETR
         SETX
         PRINT     NOGEN
         SETM
         SETN
         PRINT     GEN
         EJECT
***********************************************************************
*
*        ENTRY AND EXIT ROUTINES
*
*                  ENTRY ROUTINE
         USING     BUFFENT,R1      FROM CALL LINKAGE
BUFFENT  STM       R2,R15,SAVE1    SAVE USERS REGISTERS
         LM        R11,R13,ADCON1  LOAD BASE AND SAVE POINTER
         DROPRUSE  R1,BUFFENT,R12
         USING     SAVE2,R13,R11
         LINKCHK
         STD       FR0,FSAVE       SAVE FR0
         LR        R10,R0          R10 IS PARAMETER LIST POINTER
         L         R1,XR10         PICK UP 1ST PARAMETER
         CBH       R1,=F'28',NOTIO CHECK FOR I/O CALL
         L         R2,XR10+4       PICK UP UTILITY NO. (0,4,...)
         LTBP      R9,UCTADDR(R2),NOTIO CHECK WHETHER UCT OR UUCT
         LA        R1,2(0,R1)      PT AT UNBUFF ADDRESSES IN BRANCH TAB
NOTIO    LH        R1,BRTAB1(R1)   BRANCH TO ROUTINE
         B         BUFFENT(R1)
*
*                  EXIT ROUTINE
*
*        R10 MUST POINT AT LAST PARAMETER
BUFFEXIT LD        FR0,FSAVE       RESTORE FR0
         LA        R1,XR10+4       COMPUTE RETURN ADDRESS
         LINKCHK
         LM        R2,R15,SAVE1    RESTORE GENERAL REGISTERS
         BR        R1              RETURN
         TITLE     'INIT'
***********************************************************************
*        USER CALLABLE CORE MANAGEMENT ROUTINES
*
*        INITIALIZATION ROUTINE
*
*        PARAMETER LIST
*        DC        A(40)
*        DC        A(LENGTH OF AVAILABLE MEMORY. MUST BE MULTIPLE OF 8)
*        DC        A(ADDRESS OF AVAILABLE MEMORY. MUST BE ON DOUBLE    X
                   WORD BOUNDRY.)
*        DC        A(NUMBER OF UTILITIES)
*        DC        A(NUMBER OF UTILITIES WHICH ARE TO BE BUFFERED)
*        DC        A(1ST UTILITY DCB ADDRESS)
*        DC        A(2ND UTILITY DCB ADDRESS)
*        ETC
*        DC        A(ADDRESS OF ERROR EXIT TO TAKE WHEN CORE EXHAUSTED)
*
*        THIS ROUTINE MUST BE CALLED ONCE AFTER PROGRAM IS LOADED.
*        THE I/O TABLES ARE INITIALIZED AND THE CORE MANAGEMENT LISTS
*        ARE CREATED.
*        IT IS ASSUMED THAT THE CORE GIVEN ON THE INITIALIZATION CALL
*        IS SUFFICENT TO ACCOMADATE THESE TABLES.
*        THE MINIMUM AMOUNT IS RCLINITL*NUMBUFUT+24
*
INIT     LM        R1,R4,XR10+4    PICK UP SOME PARAMETERS
         SNAPOUT   'BUFFINIT','MEMORY LENGTH=',(R1),                   X
                   'MEMORY ADDRESS=',(R2),                             X
                   'NUMBER UTILITIES=',(R3),                           X
                   'NUMBER BUFFERED=',(R4)
         AIF       (&NOTBUG).GOGO3
*        CLEAR MEMORY SO DUMPS ARE SMALLER
         SDR       FR0,FR0             CLEAR FR0
         LR        R5,R2               STARTING ADDRESS
         LA        R7,XR5(R1)          STOPPING ADDRESS
         BCTR0     R7                  SO BXLE WORKS LIKE BXL
         L         R6,=F'8'            INCREMENT
         STD       FR0,XR5             ZERO A DOUBLE WORD
         BXLE      R5,R6,*-4           ZAP ALL OF MEMORY
.GOGO3   ANOP
         ST        R4,NUMBUFUT     STORE NUMBER BUFFERED UTILITIES
         LA        R10,XR10+5*4    POINT AT FIRST DCB ADDRESS
         LA        R7,XR1(R2)      POINT AT TOP OF CORE
         ST        R7,TOPCORE       KEEP IT
         SR        R3,R4           NUMBER OF UNBUFFERED UTILITIES
         LA        R3,XR3+1        ADD 1 FOR BCT
         LA        R9,UCTADDR      POINT AT UCTADDR
         LTRBZ     R4,IN3              THERE ANY BUFFERED UTILITIES
         LR        R8,R7           TOP OF RCL
         SR        R6,R6           LENGTH OF RCL
*        LOOP TO CREATE UCTS
IN1      L         R5,XR9          LOAD ADDRESS OF UCT
         L         R15,=A(UCT)     FROM ADDRESS FOR MOVE
*./      DELETE    SEQ1=11800020,SEQ2=11800020
         MVC       XR5(UCTLNGTH),XR15 PLACE UCT
         USING     UCT,R5
         L         R0,XR10         PICK UP DCB ADDRESS
         ST        R0,UCTDCB       PLACE IT IN UCT
         S         R8,=F'4'        POINT AT NEXT RCL ENTRY
         ST        R8,UCTRCLN1     POINTER TO TOP OF RCL
         ST        R8,UCTRLAST     POINTER TO LAST RECORD+1
         ST        R8,UCTRNEXT     POINTER TO NEXT ACTIVE RECORD
         ST        R8,UCTNEXTO     POINTER TO NEXT SPILLOUT RECORD
         LA        R10,XR10+4      POINT AT NEXT DCB IN PARAMETER LIST
         DROPR     R5
         LA        R9,XR9+4        POINT AT NEXT SLOT IN UCTADDR
         A         R6,=A(RCLINITL) INCREMENT LENGTH OF RCL
         BCT       R4,IN1          LOOP FOR EACH BUFFERED UTILITY
         SR        R8,R7           CALCULATE RCLINC
         ST        R8,RCLINC       STORE IT
*        SET BOTTOM OF RCL POINTER
         SR        R7,R6           CALCULATE BOTTOM OF RCL
         ALIGN     R7,D            PUT TO DOUBLE WORD BOUNDRY
         ST        R7,RCLEND       SET BOTTOM OF RCL POINTER
         B         IN3
*        PICK UP DCBS FOR UNBUFFERED UTILITIES
IN4      L         R0,XR10         PICK UP DCB ADDRESS
         L         R5,XR9          LOAD ADDRESS OF UUCT
         MVI       XR9,M0          STORE FLAG BIT
         L         R15,=A(UUCT)    LOAD FROM ADDRESS FOR MOVE
         MVC       XR5(UUCTLTH),XR15 CREATE UUCT
         USING     UUCT,R5
         ST        R0,UUCTDCB      PLACE DCB ADDRESS
         DROPR     R5
         LA        R10,XR10+4      POINT AT NEXT DCB
         LA        R9,XR9+4        POINT AT NEXT UCTADDR ENTRY
IN3      BCT       R3,IN4          LOOP FOR UNBUFFERED UTILITIES
*        CREATE CML LISTS
         S         R7,=F'8'        SPACE FOR CML ENTRY
         USING     CML,R7
         ST        R2,CMLPTDWN     SET DOWN POINTER
         LA        R1,CORELIST     POINT AT CML POINTERS
         ST        R1,CMLPTUP      SET UP POINTER
         MVI       CMLFLAG,M1      SET FLAG
         DROPRUSE  R7,CML,R2       INITIALIZE BOTTOM CML
         ST        R1,CMLPTDWN     SET DOWN POINTER
         ST        R7,CMLPTUP      SET UP POINTER
         MVI       CMLFLAG,M0      SET FLAG
         USING     FCP,R2          INITIALIZE 1ST FCP
         ST        R1,FCPPTDWN     SET DOWN POINTER
         ST        R1,FCPPTUP      SET UP POINTER
         DROPRUSE  R2,CML,R1       INITIALIZE CORELIST
         ST        R7,CMLPTDWN     SET DOWN POINTER
         ST        R2,CMLPTUP      SET UP POINTER
         MVI       CMLFLAG,N       SET FLAG
         USING     FCP,R1
         ST        R2,FCPPTDWN     SET DOWN POINTER
         ST        R2,FCPPTUP      SET UP POINTER
         DROPR     R1
*        RESET SOME CONTROL WORDS
         AIF       (NOT &SERUSE).NOSER1
         SR        R0,R0           CREATE 0
         ST        R0,MAXBLOCK     SET MAXBLOCK
.NOSER1  ANOP
*        PICK UP ERROR EXIT ADDRESS
         L         R0,XR10         PICK UP ERROR EXIT ADDRESS
         ST        R0,NOGOEXIT     STORE IT
         B         BUFFEXIT
         TITLE     'GROW'
*        GROW ROUTINE
*
*        DC        A(32)
*        DC        A(LENGTH OF AVAILABLE AREA)
*        DC        A(ADDRESS OF AVAILABLE AREA)
*        BOTH THE ABOVE NUMBERS MUST BE MULTIPLES OF 8
*        LENGTH MUST BE GREATER THAN 16
*
*        THIS ROUTINE ENLARGES THE BUFFER AREA
*        THE AVAILABLE AREA MUST BE CONTIGUOUS WITH THE CORE PRESENTLY X
                   BEING USED
*        IT MAY BE EITHER AT THE TOP OR THE BOTTOM
*        IF IT IS AT THE BOTTOM IT IS SIMPLY LINKED INTO THE FREE CORE X
                   LIST
*        IF IT IS AT THE TOP THEN THE RCL IS MOVED UP AND THE VACATED  X
                   AREA IS LINKED INTO THE FREE CORE LIST
*
GROW     LM        R14,R15,XR10+4  LOAD LENGTH AND ADDRESS
         SNAPOUT   'GROW','LENGTH=',(R14),'ADDRESS=',(R15)
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         CBNE      R15,TOPCORE,GR6 TEST IF CONTIGUOUS WITH TOP
*        GROW UP
*        MOVE RCL
         L         R7,TOPCORE      CALCULATE LENGTH OF RCL
         LA        R3,CORELIST     POINT AT CML POINTERS
         USING     CML,R3
         L         R5,CMLPTDWN     POINT AT BOTTOM OF RCL
         LA        R5,XR5          CLEAR TOP BYTE
         SR        R7,R5           LENGTH OF RCL
         LA        R6,XR5(R14)     TO ADDRESS FOR MOVE
         BAL       R8,MOVE         MOVE RCL
*        FIX UP CML CHAIN
         ST        R6,CMLPTDWN     RESET RCL POINTER IN CORELIST
         MVI       CMLFLAG,N       RESET FLAG
         DROPRUSE  R3,CML,R6       FIX NEW RCL CML
         ST        R5,CMLPTDWN     POINT IT DOWN TO ITS OLD SELF
         MVI       CMLFLAG,M1      RESET FLAG
         DROPRUSE  R6,CML,R5        FIX OLD RCL CML
         ST        R6,CMLPTUP      POINT IT UP AT NEW RCL CML
*        FREE THE EXTRA CORE
         LR        R3,R5           SET UP POINTERS FOR FREECORE
         LR        R4,R6
         L         R2,CMLPTDWN
         BAL       R8,FREECORE
         DROPR     R5
*        FIX POINTERS IN DATA AREA
         L         R0,TOPCORE      FIX TOPCORE
         AR        R0,R14
         ST        R0,TOPCORE
         L         R0,RCLEND       FIX RCLEND
         ALR       R0,R14
         ST        R0,RCLEND
*        FOR EACH BUFFERED UTILITY FIX UCT
         L         R1,NUMBUFUT     NUMBER OF BUFFERED UTILITIES
         LA        R1,XR1+1        ADD 1 FOR BCT
         LA        R2,UCTADDR      POINT AT UCT ADDRESSES
         L         R4,RCLINC       FOR BXH
         B         GR5
GR1      L         R3,XR2          POINT AT UCT
         USING     UCT,R3
         L         R6,UCTRCLN1     FIX UCTRCLN1
         AR        R6,R14
         ST        R6,UCTRCLN1
         L         R0,UCTRNEXT     FIX UCTRNEXT
         AR        R0,R14
         ST        R0,UCTRNEXT
         L         R5,UCTRLAST     FIX UCTRLAST
         AR        R5,R14
         ST        R5,UCTRLAST
         L         R0,UCTNEXTO     FIX UCTNEXTO
         AR        R0,R14
         ST        R0,UCTNEXTO
         LTBZ      R0,UCTSPLI,GR21 TEST IF SPILLIN GOING
         AR        R0,R14          FIX UCTSPLI
         ST        R0,UCTSPLI
GR21     LTBZ      R0,UCTSPLO,GR22 TEST IF SPILLOUT GOING
         AR        R0,R14
         ST        R0,UCTSPLO
GR22     SR        R6,R4           FOR BXH
         B         GR4
*        FIX RCP POINTERS TO RCL
         USING     RCL,R6
GR3      TMBNZ     RCLFLAG,M7,GR4  TEST IF IN CORE
         L         R7,RCLPT        POINT AT RCP
         USING     RCP,R7
         L         R0,RCPPT        FIX RCPPT
         AR        R0,R14
         ST        R0,RCPPT
GR4      BXH       R6,R4,GR3       LOOP FOR EACH RCL
         LA        R2,XR2+4        POINT AT NEXT UCTADDR ENTRY
GR5      BCT       R1,GR1          LOOP FOR EACH UCT
         B         BUFFEXIT        END OF GROW UP
         DROPR     R3,R6,R7
*        GROW DOWN
GR6      LA        R2,CORELIST     POINT AT CORELIST
         USING     CML,R2
         L         R4,CMLPTUP      POINT AT BOTTOM CORE ENTRY
         ST        R15,CMLPTUP     SET CORELIST
         DROPRUSE  R2,CML,R15
         ST        R2,CMLPTDWN     SET NEW ENTRY DOWN POINTER
         ST        R4,CMLPTUP      SET NEW ENTRY UP POINTER
         DROPRUSE  R15,CML,R4
         IC        R0,CMLFLAG      SAVE FLAG
         ST        R15,CMLPTDWN    SET DOWN POINTER IN BOTTOM ENTRY
         STC       R0,CMLFLAG      RESTORE FLAG
         LR        R3,R15          FOR FREECORE
         BAL       R8,FREECORE     FREE NEW ENTRY
         B         BUFFEXIT        RETURN
         DROPR     R4
         TITLE     'SHRINK'
*        SHRINK ROUTINE
*
*        PARAMETER LIST
*        DC        A(36)
*        DC        A(LENGTH DESIRED (MULTIPLE OF 8))
*        DS        F   WILL BE SET TO ADDRESS (DOUBLE ALIGNED) OF      X
                   CORE, OR -1 IF NOT ENOUGH AVAILABLE
*
*        A GETCORE IS DONE TO ASSURE THAT ENOUGH FREE AREA EXISTS
*        THE GOTTEN CORE IS THEN FREEED AND A SQUISH DONE TO MOVE IT   X
                   TO THE BOTTOM OF MEMORY
*        THE BOTTOM FCP IS THEN PLACED ABOVE THE CORE RETURNED TO      X
                   THE USER
*
SHRINK   L         R9,XR10+4       LOAD LENGTH
         SNAPOUT   'SHRINK','LENGTH=',(R9)
         LA        R10,XR10+8      POINT AT LAST PARAMETER
*        DO GETCORE
         MVI       SHRINKSW+1,M    NOP THE SWITCH
         LR        R7,R9           DO A GETCORE FOR AMOUNT
         BAL       R8,GC0          DO A GETCORE
         REF       GETCORE
         MVI       SHRINKSW+1,M0123 RESET THE SWITCH
*        TEST FOR NOT ENOUGH
         LTRBNL    R5,SH1          TEST FOR ERROR
         ST        R5,XR10         PASS THE BAD NEWS BACK
         B         BUFFEXIT        EXIT, WEEPING
*        DO FREECORE
         USING     CML,R5
SH1      L         R4,CMLPTUP      SET THINGS UP FOR FREECORE
         L         R2,CMLPTDWN
         DROPR     R5
         LR        R3,R5
         BAL       R8,FREECORE
*        DO SQUISH
         BAL       R8,SQUISH
*        TAKE CORE OFF BOTTOM AND FIX UP CML AND FCP CHAINS
         LA        R1,CORELIST     POINT AT CORELIST
         USING     CML,R1
         L         R2,CMLPTUP      POINT AT BOTTOM FCP
         ST        R2,XR10         GIVE USER HIS ADDRESS
         LA        R3,XR2(R9)      CALCULATE TOP OF HIS AREA
         ST        R3,CMLPTUP      RESET CORELIST
         USING     FCP,R1
         ST        R3,FCPPTUP
         ST        R3,FCPPTDWN
         DROPRUSE  R1,CML,R2       POINT AT OLD BOTTOM
         L         R4,CMLPTUP      FIND UPPER ENTRY
         DROPRUSE  R2,CML,R3       CREATE NEW ENTRY
         ST        R1,CMLPTDWN
         MVI       CMLPTDWN,M0
         ST        R4,CMLPTUP
         USING     FCP,R3
         ST        R1,FCPPTUP
         ST        R1,FCPPTDWN
         DROPRUSE  R3,CML,R4       ALTER UPPER ENTRY
         IC        R0,CMLFLAG
         ST        R3,CMLPTDWN
         STC       R0,CMLFLAG
         B          BUFFEXIT       RETURN
         DROPR     R4
         TITLE     'READ'
***********************************************************************
*        USER CALLABLE BUFFERED I/O ROUTINES
*
*        READ ROUTINE
*
*        PARAMETER LIST
*        DC        A(0) IF DATA MAY BE RE-READ
*                           OR
*                  A(4) IF DATA MAY BE PURGED AFTER READING
*        DC        A(UTILITY NUMBER)
*        DC        A(ADDRESS OF READ AREA)
*
*        THE READ ROUTINE MOVES THE DATA TO THE USER
*        IT THEN CHECKES THAT THE NEXT RECORD IS IN CORE
*        IF NOT IT PERFORMS A SPILLIN TO GET THE NEXT RECORD
*
         USING     UCT,R9
*        READ AND PURGE ENTRY
READP    MVI       READSW+1,M      NOP THE SWITCH
*        READ AND KEEP ENTRY
READK    L         R6,XR10+8       LOAD DATA ADDRESS
         SNAPOUT   'READ','UTILITY=',XR10+4,'ADDRESS=',(R6)
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         ACCUM     UCTRDCNT        INCREMENT COUNTER
         L         R7,UCTRNEXT     POINT AT RCL OF NEXT RECORD
         USING     RCL,R7
*        IF EODAD EXIT NEEDED COMPARE R1 WITH UCTRLAST HERE
*        IF EQUAL SET A SWITCH TO BE INTEROGATED BY CHECK ROUTINE
*        THEN EXIT TO BUFFEXIT
         AIF       (&NOTBUG).RDOK
         CBNE      R1,UCTRLAST,RDOK
         SNAPOUT   'READ OF EOF'
         ABEND     20,DUMP
RDOK     DS        0H
.RDOK    CBNE      R7,UCTSPLI,RD1  IS RECORD BEING SPILLED IN
         BAL       R8,CHECKIN      CHECK IT
RD1      L         R3,RCLPT        POINT AT RCP
         USING     RCP,R3
         LH        R7,RCPRL        PICK UP RECORD LENGTH
         DROPR     R7
         ST        R7,UCTRRL       STORE IT FOR CHECK
         LA        R5,RCPDATA      POINT AT DATA
         SNAPDATA  ADDR=(R5),LENGTH=(R7)
         BAL       R8,MOVE         MOVE IT TO USER
         L         R7,UCTRNEXT     POINT AT RCL AGAIN
         USING     RCL,R7
READSW   BC        *-*+15,RD0(*-*) PURGE SWITCH
         MVI       READSW+1,M0123  RESET SWITCH
*        FREE THE RECORDS CORE
         OI        RCLFLAG,M7      SHOW NOT IN CORE
         MVC       RCLNOTE(3),RCPNOTE SAVE THE NOTE IF ANY
         USING     CML,R3
         L         R4,CMLPTUP      LOAD STUFF FOR FREECORE
         L         R2,CMLPTDWN
         BAL       R8,FREECORE     FREE THE CORE
         B         RD2
         DROPR     R3
*./      DELETE    SEQ1=17540020,SEQ2=17640020
RD0      OI        UCTSW,M1        SHOW SOMETHING SPILLOUTABLE
         CLBNL     R0,UCTFLAG,RD2  IS THIS LOWER PRIORITY
         ST        R0,UCTFLAG      SHOW THIS LOWEST PRIORITY
         ST        R7,UCTNEXTO     SET NEXT SPILLOUT POINTER
*        ADVANCE NEXT RECORD POINTER TO NEXT RECORD
RD2      A         R7,RCLINC       POINT AT NEXT RCL ENTRY
*./      DELETE    SEQ1=17780020,SEQ2=17820020
*        DROP INTO SPILLIN ROUTINE TO GET NEXT RECORD INTO CORE
         DROPR     R7,R9
         TITLE     'SPILLIN'
*        SPILLIN CODE   (PART OF READ ROUTINE)
*        ALSO USED BY POINTR
*
         USING     UCT,R9
         USING     RCL,R7
*        SET THE NEXT RECORD POINTER
SPILLIN  ST        R7,UCTRNEXT         STORE NEXT RECORD POINTER
*        ADD 1 TO THE PRIORITY COUNTER IN THE RCL
         L         R0,RCLFLAG      PICK UP THE FLAG
         AL        R0,=X'04000000' ADD 1 TO BIT 5
         BNLC      SI0             TEST FOR OVERFLOW
         O         R0,=X'FC000000' INSERT MAX COUNT
SI0      ST        R0,RCLFLAG      STORE UPDATED COUNT
*        TEST IF NEXT RECORD IS ALREADY IN CORE
         CBE       R7,UCTRLAST,BUFFEXIT EXIT IF THIS LAST RECORD
         TMBZ      RCLFLAG,M7,BUFFEXIT  RETURN IF IN CORE
         DROPR     R7
         SNAPOUT   'SPILLIN'
         ACCUM     UCTSICNT        ADD 1 TO STATISTICS COUNTER
*        CHECK IF SPILLIN IN PROGRESS
         LTBZ      R7,UCTSPLI,SI1  IS SPILLIN IN PROGRESS
         BAL       R8,CHECKIN
*        GET CORE TO READ INTO
SI1      L         R7,UCTMAXRL     PICK UP MAX RECORD LENGTH
         ST        R7,SILRECL      SAVE MAX RECORD LENGTH
         ALIGN     R7,D,INC=16     ADD 16 FOR RCP AND DOUBLE ALIGN IT
         BAL       R8,GETCORE
         USING     RCP,R5
*        CHECK IF SPILLOUT IN PROGRESS
*./      DELETE    SEQ1=18140020,SEQ2=18160020
         LTBZ      R7,UCTSPLO,SI2  IS SPILLOUT IN PROGRESS
         BAL       R8,CHECKOUT
*        DO A POINT ON UTILITY
SI2      L         R1,UCTDCB       POINT AT DCB
         L         R7,UCTRNEXT     RESET RCL POINTER
         USING     RCL,R7
         L         R0,RCLFLAG      PICK UP FTTR
*./      DELETE    SEQ1=18320020,SEQ2=18420020
         SLL       R0,8            MAKE TTR0
         ST        R0,SIWORK
         POINT     (1),SIWORK
         REF       R1
         OI        UCTSW,M2        TURN ON POINT BEFORE WRITE SW
*        DO THE READ
         L         R2,UCTDCB       POINT AT THE DCB
         LA        R3,RCPDATA      POINT AT DATA ADDRESS
         L         R4,SILRECL      LOAD MAX RECORD LENGTH
         READ      UCTIDECB,SF,(R2),(R3),(R4),MF=E
*        FIX UP MISC POINTERS AND THINGS
         ST        R7,UCTSPLI      SET SPILLIN POINTER
         ST        R4,UCTIRL       STORE RECORD LENGTH
         ST        R7,RCPPT        SET RCP POINTER
         MVC       RCPNOTE(3),RCLNOTE MOVE NOTE INFO TO RCP
         IC        R0,RCLFLAG      SAVE FLAG
         ST        R5,RCLPT        SET RCL POINTER
         N         R0,=A(N7)       TURN ON IN CORE SWITCH
         STC       R0,RCLFLAG      RESTORE FLAG
         SNAPOUT   'SPILLIN EXIT','ADDRESS=',(R5)
         B         BUFFEXIT        RETURN
         DROPR     R5,R7,R9
SIWORK   DC        F'0'
SILRECL  DC        F'0'
         TITLE     'WRITE'
*        WRITE ROUTINE
*
*        PARAMETER LIST
*        DC        A(8)
*        DC        A(UTILITY NUMBER)
*        DC        A(ADDRESS OF DATA)
*        DC        A(LENGTH OF DATA)
*
*        THE WRITE ROUTINE ONLY STORES THE ADDRESS AND LENGTH OF THE   X
                   DATA
*        THE DATA IS MOVED BY THE CHECK ROUTINE WHEN THE CHECK IS DONE
*
         USING     UCT,R9
WRITE    LM        R1,R2,XR10+8    LOAD ADDRESS AND LENGTH
         SNAPOUT   'WRITE','UTILITY=',XR10+4,'ADDRESS=',(R1),          X
                   'LENGTH=',(R2)
         SNAPDATA  ADDR=(R1),LENGTH=(R2)
         LA        R10,XR10+12     POINT AT LAST PARAMETER
         ACCUM     UCTWRCNT        INCREMENT COUNTER
         STM       R1,R2,UCTWRADD  STORE ADDRESS AND LENGTH
         REF       UCTWRLTH
         B         BUFFEXIT        RETURN
         DROPR     R9
         TITLE     'CHECK'
*        CHECK ROUTINE
*
*        PARAMETER LIST IF CHECKING A WRITE
*        DC        A(28)
*        DC        A(UTILITY NUMBER)
*        IF CHECKING A READ ADD ONE MORE PARAMETER
*        DS        F   FILLED WITH RECORD LENGTH OF READ BY CHECK ROUTN
*
*        IF FILE BEING READ THE CHECK ROUTINE SIMPLY SETS RECORD       X
                   LENGTH IN PARAMETER LIST AND RETURNS
*        IF FILE BEING WRITTEN THE NECESSARY BUFFER SPACE IS OBTAINED  X
                   AND THE DATA MOVED FROM THE USERS AREA
*
         USING     UCT,R9
CHECK    SNAPOUT   'CHECK','UTILITY=',XR10+4
         CLI       UCTSW,M0        CHECK MODE OF FILE
         BL        CKW             BRANCH IF WRITE
         L         R0,UCTRRL       LOAD RECORD LENGTH
         ST        R0,XR10+8       GIVE TO USER
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         B         BUFFEXIT        RETURN
*        CHECK FOLLOWS WRITE
CKW      LA        R10,XR10+4      POINT AT LAST PARAMETER
         L         R7,UCTWRLTH     GET DATA LENGTH
         ALIGN     R7,D,INC=16     ADD 16 FOR RCP AND DBL ALIGN
         BAL       R8,GETCORE      GET SOME MEMORY MAN
         USING     RCP,R5          LIKE R5 IS THE SWINGING ADDRESS
         L         R4,UCTRNEXT     POINT AT RCL
         USING     RCL,R4
         ST        R5,RCLPT        POINT RCL AT RCP AND SET SWITCHES
         L         R7,UCTWRLTH     LENGTH OF RECORD
         STH       R7,RCPRL        STORE IN RCP
         ST        R4,RCPPT        POINT RCP AT RCL
         LA        R6,RCPDATA      SET TO ADDRESS
         L         R5,UCTWRADD     SET FROM ADDRESS
         DROPR     R5
         BAL       R8,MOVE         DO MOVE
CKW1     LM        R0,R1,RCLINC    LOAD RLCINC AND RCLEND
         REF       RCLEND
         BXLE      R4,R0,RCLGROW   MOVE POINTER DOWN ONE ENTRY
         DROPR     R4
         ST        R4,UCTRNEXT     SET POINTER TO NEXT RCL
         ST        R4,UCTRLAST         SET LAST RECORD + 1 POINTER
         B         BUFFEXIT        RETURN
         TITLE     'RCLGROW'
*        RCLGROW CODE (PART OF CHECK ROUTINE)
*
*        A GETCORE IS DONE TO ASSURE THAT ENOUGH FREE AREA EXISTS
*        THE GOTTEN CORE IS THEN FREEED AND A SQUISH DONE TO MOVE IT   X
                   TO THE BOTTOM OF MEMORY
*        ALL OF MEMORY IS THEN SHIFTED DOWN AND THE RCL EXTENDED DOWN
*
RCLGROW  SNAPOUT   'RCLGROW'
*        DO A GETCORE FOR 256 + 16
         LA        R7,256+16
         BAL       R8,GETCORE
         USING     CML,R5
*        DO THE FREECORE
         L         R4,CMLPTUP
         L         R2,CMLPTDWN
         DROPR     R5
         LR        R3,R5
         BAL       R8,FREECORE
*        DO THE SQUISH
         BAL       R8,SQUISH
*        MOVE EVERYTHING DOWN
         LA        R1,CORELIST         R1 -> CORELIST
         USING     CML,R1
         L         R5,CMLPTDWN         R5 -> RCL CML ENTRY
         LA        R5,XR5              ZERO TOP BYTE
         L         R2,CMLPTUP          R2 -> FREE CML ENTRY
         DROPRUSE  R1,CML,R2
         L         R6,CMLPTUP          BOTTOM BYTE TO BE MOVED
         LA        R4,256              DISTANCE TO MOVE MEMORY
         LR        R7,R6               TO ADDRESS = BOTTOM - DISTANCE
         SR        R7,R4
RC2      MVC       XR7(256),XR6        MOVE 256 BYTES
         AR        R7,R4               INC TO ADDRESS
         BXLE      R6,R4,RC2           INC FROM ADDRESS AND LOOP
*        SET RCL END POINTER
         SR        R5,R4               NEW RCL CML ENTRY
         LA        R6,XR5+8            + 8 = NEW RCLEND
         ST        R6,RCLEND
*        RELOCATE THE POINTER IN CORELIST
         DROPRUSE  R2,CML,R1           POINT AT CORELIST
         ST        R5,CMLPTDWN         POINT IT AT TOP CML ENTRY
         MVI       CMLFLAG,N           RESET CORELIST FLAG
*        RELOCATE ALL THE REST OF THE CML AND RCL POINTERS
         DROPRUSE  R1,CML,R5           POINT AT NEW TOP CML ENTRY
RC0      L         R6,CMLPTDWN         GO DOWN ONE ENTRY
         LA        R6,XR6              ZERO TOP BYTE
         CRBE      R6,R2,RC1           ARE WE AT FREE ENTRY
         SR        R6,R4               GO DOWN TO NEW LOCATION
         DROPRUSE  R5,CML,R6           FIX THIS UP POINTER
         ST        R5,CMLPTUP
         USING     RCP,R6              FIX RCL POINTER
         L         R1,RCPPT            POINT AT RCL
         USING     RCL,R1
         IC        R0,RCLFLAG          SAVE FLAG
         ST        R6,RCLPT            SET RCLPT
         STC       R0,RCLFLAG          RESET FLAG
         DROPRUSE  R6,CML,R5           FIX ABOVE DOWN POINTER
         IC        R0,CMLFLAG          SAVE FLAG
         ST        R6,CMLPTDWN         SET DOWN POINTER
         STC       R0,CMLFLAG          RESET FLAG
         LR        R5,R6               MAKE PRESENT ENTRY ABOVE ENTRY
         B         RC0                 LOOP DOWN ONE ENTRY
*        FIX BOTTOM UP POINTER
         DROPRUSE  R5,CML,R6
RC1      ST        R5,CMLPTUP          SET UP POINTER
*        RESET R4 TO UCTRNEXT AND RETURN
         L         R4,UCTRNEXT
         LINKCHK
         B         CKW1            RETURN
         DROPR     R1,R6,R9
         TITLE     'NOTE'
*        NOTE ROUTINE
*
*        PARAMETER LIST
*        DC        A(20)
*        DC        A(UTILITY NUMBER)
*        DS        F   NOTE INFORMATION IS RETURNED IN TOP 3 BYTES,    X
                         BOTTOM BYTE SET TO 0
*
*        THE NOTE INFORMATION IS THE RELATIVE POSITION OF THE RCL      X
                   NEXT RECORD POINTER
*        THIS INFORMATION MUST NOT BE ALTERED IF TO BE USED IN POINTR  X
                   OR POINTW
*
         USING     UCT,R9
NOTE     SNAPOUT   'NOTE','UTILITY=',XR10+4
         ACCUM     UCTNTCNT
         L         R1,UCTRCLN1     TOP OF RCL
         S         R1,UCTRNEXT     RELATIVE POSITION
*        THUS A NOTE OF AN EMPTY FILE RETURNS 0
         SLL       R1,8            PLACE IN TOP 3 BYTES
         ST        R1,XR10+8       GIVE TO USER
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         SNAPOUT   'NOTE EXIT','NOTE=',(R1)
         B         BUFFEXIT        RETURN
         DROPR     R9
         TITLE     'POINTR'
*        POINTR ROUTINE
*
*        PARAMETER LIST
*        DC        A(12)
*        DC        A(UTILITY NUMBER)
*        DC        AL3(NOTE INFORMATION)
*        DC        AL1(0)   IF POINTING TO NOTED RECORD
*                           OR
*                  AL1(1)   IF POINTING 1 RECORD PAST NOTED RECORD
*
*        THE NOTE INFORMATION MUST BE THE UNALTERED DATA RETURNED      X
                   BY THE NOTE ROUTINE
*        TO POINT AT THE 1ST RECORD THE NOTE INFORMATION IS 0 AND THE  X
                   LOW ORDER BYTE IS 1
*        THE FILE MODE IS SET TO READ
*
         USING     UCT,R9
POINTR   L         R1,XR10+8       PICK UP NOTE INFO
         SNAPOUT   'POINTR','UTILITY=',XR10+4,'NOTE=',(R1)
         ACCUM     UCTPRCNT
*        SET NEXT RECORD POINTER
         SRL       R1,8            RESTORE NUMBER TO RELATIVE ADDRESS
         L         R7,UCTRCLN1     TOP OF RCL
         SR        R7,R1           POINT TO ONE RECORD BEYOND NOTED REC
         CLI       XR10+11,M7      SEE IF LOW BYTE SET TO 1
         BE        PR1             BRANCH IF POINT TO NEXT RECORD
         S         R7,RCLINC       GO BACK ONE ENTRY
         USING     RCL,R7
PR1      DC        0H'0'
         AIF       (&NOTBUG).PROK
         CBNL      R7,UCTRLAST,PROK
         SNAPOUT   'POINTR BEYOND EOF'
         ABEND     20,DUMP
PROK     DS        0H
.PROK    ANOP
*        IF SWITCHING FROM WRITE TO READ MUST INITIALIZE SPILLOUT FIELD
         CLI       UCTSW,M0        TEST MODE OF FILE
         BNL       PR2             BRANCH IF READ
         OI        UCTSW,M01       TURN ON READ MODE AND SPILLOUTABLE
         SR        R0,R0           SET UCTFLAG TO ZERO
         ST        R0,UCTFLAG
         CBL       R7,UCTNEXTO,PR2 IS SPILLOUT POINTER ABOVE OR BELOW  X
                                   READ POINT
         L         R0,UCTRLAST     BELOW. FORCE SPILLOUT TO END OF FILE
         S         R0,RCLINC
         ST        R0,UCTNEXTO
*        SEE IF NEXT RECORD IN CORE BY GOING TO SPILLIN ROUTINE
PR2      LA        R10,XR10+8      POINT AT LAST PARAMETER
         B         SPILLIN
         DROPR     R7,R9
         TITLE     'POINTW'
*        POINTW ROUTINE
*
*        PARAMETER LIST SAME AS FOR POINTR EXCEPT 1ST IS
*        DC        A(16)
*
*        SEE COMMENTS ON POINTR
*        SWITCHES MODE TO WRITE
*
         USING     UCT,R9
POINTW   L         R1,XR10+8       PICK UP NOTE INFO
         SNAPOUT   'POINTW','UTILITY=',XR10+4,'NOTE=',(R1)
         ACCUM     UCTPWCNT        ADD TO ACCUMULATOR
*        SET NEXT RECORD POINTER
         SRL       R1,8            RESTORE NUMBER TO RELATIVE ADDRESS
         L         R6,UCTRCLN1     TOP OF RCL
         SR        R6,R1           POINT ONE RECORD BEYOND NOTED RECORD
         CLI       XR10+11,M7      SEE IF LOW BYTE SET TO 1
         BE        PW1             BRANCH IF POINT TO NEXT RECORD
         S         R6,RCLINC       GO BACK ONE ENTRY
         USING     RCL,R6
PW1      ST        R6,UCTRNEXT     SET NEXT RECORD POINTER
*        CHECK ALL SPILLS BELOW POINT
         LTBZ      R7,UCTSPLI,PW2  TEST SPILLIN IN PROGRESS
         CRBH      R7,R6,PW2       IS IT BELOW NEW POINT
         BAL       R8,CHECKIN
PW2      LTBZ      R7,UCTSPLO,PW3  TEST SPILLOUT IN PROGRESS
         CRBH      R7,R6,PW3       IS IT BELOW NEW POINT
         BAL       R8,CHECKOUT
*        FREE ALL BUFFERS BELOW NEW POINT
PW3      L         R14,RCLINC      LOAD BXH OPERANDS
         L         R15,UCTRLAST
         ST        R6,UCTRLAST     SET LAST+1 = THIS POINT
         CRBE      R15,R6,PW6      TEST FOR ALREADY AT END OF FILE
PW4      TMBNZ     RCLFLAG,M7,PW5  TEST IF RECORD IN CORE
         L         R3,RCLPT        LOAD FREECORE POINTERS
         USING     CML,R3
         L         R2,CMLPTDWN
         L         R4,CMLPTUP
         BAL       R8,FREECORE     FREE RECORD
PW5      BXH       R6,R14,PW4      GO DOWN TILL END OF FILE
*        SET A COUPLE OF THINGS
PW6      NI        UCTSW,N01       SET WRITE MODE
         L         R0,UCTRCLN1     SET SPILLOUT POINTER
         ST        R0,UCTNEXTO
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         CBNE      R0,UCTRNEXT,BUFFEXIT TEST FOR POINTW 1
         SR        R0,R0           CREATE 0
         ST        R0,UCTMAXRL     RESET MAX RECORD LENGTH
         ST        R0,UCTONOTE     RESET SPILLOUT NOTE ADDRESS
         OI        UCTSW,M2        CAUSE A POINT BEFORE 1ST SPILLOUT
         MVI       UCTTRBAL,X'FF'      SHOW TRACK BALANCE INVALID
         B         BUFFEXIT        RETURN
         DROPR     R3,R6,R9
*./      DELETE    SEQ1=23740020,SEQ2=24400020
         TITLE     'CONSTANT AND DATA AREA'
***********************************************************************
*        CONSTANT AND DATA AREA
*
*        USER SAVE AREA
*
SAVE1    DC        14F'0'          USER REGISTER SAVE
FSAVE    DC        D'0'            FR0 SAVE
*
*         BASE VALUES
*
ADCON1   DC        A(SAVE2+4096,BUFFENT,SAVE2)
*
*        O.S. SAVE AREA
*
SAVE2    DC        18F'0'
*
*        ROUTINE BRANCH TABLE USED BY ENTRY ROUTINE
*
BRTAB1   DC        AL2(READK-BUFFENT,UREAD-BUFFENT)          0
         DC        AL2(READP-BUFFENT,UREAD-BUFFENT)          4
         DC        AL2(WRITE-BUFFENT,UWRITE-BUFFENT)         8
         DC        AL2(POINTR-BUFFENT,UPOINTR-BUFFENT)      12
         DC        AL2(POINTW-BUFFENT,UPOINTW-BUFFENT)      16
         DC        AL2(NOTE-BUFFENT,UNOTE-BUFFENT)          20
         DC        AL2(TCLOSE-BUFFENT,UTCLOSE-BUFFENT)      24
         DC        AL2(CHECK-BUFFENT,UCHECK-BUFFENT)        28
         DC        AL2(GROW-BUFFENT,0)                      32
         DC        AL2(SHRINK-BUFFENT,0)                    36
         DC        AL2(INIT-BUFFENT,0)                      40
*
*        MISC CONTROL WORDS
*
TOPCORE  DC        F'0'            POINTS AT TOP OF MY CORE
RCLINC   DC        F'0'            - 4 * NUMBER OF BUFFERED UTILITIES
RCLEND   DC        F'0'            POINTS AT BOTTOM OF RCL
NUMBUFUT DC        F'0'            NUMBER OF BUFFERED UTILITIES
MAXBLOCK DC        F'0'            MAX BLOCKSIZE POSSIBLE IN MEMORY
*
*        POINTERS TO ENDS OF CORE MANAGEMENT LISTS
*
*        THE FOLLOWING TABLE MUST BE SAME FORMAT AS FCP
CORELIST DC        X'FF'           CML END OF LIST FLAG
         DC        AL3(CORELIST)   POINTS TO RCL CML ENTRY
         DC        A(CORELIST)     POINTS TO BOTTOM CML ENTRY
         DC        A(CORELIST)     POINTS TO TOP FREE CORE CML ENTRY
         DC        A(CORELIST)     POINTS TO BOTTOM FREE CORE CML ENTRY
*
*        UCT ADDRESS TABLE
*
*        THIS TABLE CONTAINS ONE FULL WORD FOR EACH UTILITY
*        IT CONTAINS THE ADDRESS OF THE UCT OR UUCT FOR THAT UTILITY
*        1ST BIT IN WORD IS TURNED ON IF UNBUFFERED UTILITY
UCTADDR  DS        0F
&WORK    SETA      0
.UTAB    DC        A(UCT+UCTLNGTH*(&WORK+&SERUSE))
&WORK    SETA      &WORK+1
         AIF       (&WORK LT &MAXUT).UTAB
*
*        RUN OUT CORE ERROR EXIT
*
NOGOEXIT DC        F'0'            ADDRESS OF EXTERNAL ERROR ROUTINE
*
         AIF       (&NOTSTAT).NOUNCNT
*        UNIVERSAL COUNTERS
UNSQCNT  DC        PL5'0'              SQUISH COUNTER
UNMOCNT  DC        PL5'0'              MOVE COUNTER
.NOUNCNT ANOP
         TITLE     'TCLOSE'
*        TCLOSE ROUTINE
*
*        PARAMETER LIST
*        DC        A(24)
*        DC        A(UTILITY NUMBER)
*        DC        A(1)
*
*        IF FILE IN WRITE MODE A POINTR 1 IS DONE
*        ELSE A POINTW 1 IS DONE
*
         USING     UCT,R9
TCLOSE    SNAPOUT  'TCLOSE'
          SNAPOUT  ' UTILITY=',XR10+4,'  POINTR=',UCTPRCNT,            X
                   '  POINTW=',UCTPWCNT,'   NOTES=',UCTNTCNT,TYPE=STAT
         SNAPOUT   '   READS=',UCTRDCNT,'  WRITES=',UCTWRCNT,          X
                   ' SPILLIN=',UCTSICNT,'SPILLOUT=',UCTSOCNT,TYPE=STAT
         AIF       (&NOTSTAT).NOS1
         CLI       XR10+7,8            TEST FOR UT3
         BNE       TCNOTUT3
         SNAPOUT   'SQUISHES=',UNSQCNT,'   MOVES=',UNMOCNT,TYPE=STAT
         MVC       UNSQCNT(5),=PL5'0'
         MVC       UNMOCNT(5),=PL5'0'
TCNOTUT3 DC        0H'0'
         MVC       UCTRDCNT(5),=PL5'0'
         MVC       UCTWRCNT(5),=PL5'0'
         MVC       UCTSICNT(5),=PL5'0'
         MVC       UCTSOCNT(5),=PL5'0'
         MVC       UCTPRCNT(5),=PL5'0'
         MVC       UCTPWCNT(5),=PL5'0'
         MVC       UCTNTCNT(5),=PL5'0'
.NOS1    ANOP
         CLI       UCTSW,M0        IS FILE IN READ MODE
         BL        POINTR          DO POINTR 1 IF NOT
         B         POINTW          DO POINTW 1
         DROPR     R9
         TITLE     'UREAD'
***********************************************************************
*        USER CALLABLE UNBUFFERED I/O ROUTINES
*        FOR PARAMETER LISTS SEE CORRESPONDING BUFFERED ROUTINE
*
*        UREAD ROUTINE
*
         USING     UUCT,R9
UREAD    L         R6,XR10+8       LOAD DATA ADDRESS
         SNAPOUT   'UREAD','UTILITY=',XR10+4,'ADDRESS=',(R6)
         ACCUM     UUCTRDNO
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         L         R2,UUCTDCB      POINT AT DCB
         L         R3,UUCTMAXR     LOAD MAX RECORD LENGTH
         READ      UUCTRDEB,SF,(R2),(R6),(R3),MF=E
         B         BUFFEXIT        RETURN
         DROPR     R9
         TITLE     'UWRITE'
*        UWRITE ROUTINE
*
         USING     UUCT,R9
UWRITE   LM        R2,R3,XR10+8    LOAD DATA ADDRESS AND LENGTH
         SNAPOUT   'UWRITE','UTILITY=',XR10+4,'ADDRESS=',(R2),         X
                   'LENGTH=',(R3)
         SNAPDATA  ADDR=(R2),LENGTH=(R3)
         ACCUM     UUCTWRNO
         LA        R10,XR10+12     POINT AT LAST PARAMETER
         L         R4,UUCTDCB      POINT AT DCB
         WRITE     UUCTWDEB,SF,(R4),(R2),(R3),MF=E
         CBNH      R3,UUCTMAXR,BUFFEXIT TEST FOR NEW MAX RECORD
         ST        R3,UUCTMAXR     SET NEW MAX RECORD LENGTH
         B         BUFFEXIT        RETURN
         DROPR     R9
         AIF       (&NOTBUG).NOSNPDT
         TITLE     'SNAPDATA'
*
*        INPUT:  R8 ->  ADDRESS OF AREA TO BE OUTPUT
*               R8+4->  LENGTH OF AREA TO BE OUTPUT
*               R8+8->  RETURN ADDRESS
*
SNAPDATA DS        0H
         STM       R13,R7,SNAPSAVE     SAVE SOME REGISTERS
         L         R3,XR8              START OF AREA TO BE DUMPED
         LR        R4,R3               TRANSFER FOR CALCULATION
         A         R4,XR8+4            ADD LENGTH
         BCTR      R4,0                POINT TO LAST USED BYTE
         ST        R4,XR8+4            REMEMBER THAT INSTEAD
         MVI       SNAPAREA+86,C'*'    BEFORE AND
         MVI       SNAPAREA+119,C'*'   AFTER CHARACTER EQUIV
SNAPLOOP DS        0H
         C         R3,XR8+4            ARE WE DONE .Q
         BH        SNAPDONE            BRANCH TO EXIT IF SO
         ST        R3,SNAPWORK         STORE ADDRESS
         UNPK      SNAPAREA(7),SNAPWORK+1(4) MAKE IT PRINTABLE
         MVI       SNAPAREA+6,C' '     KNOCK OFF LAST DIGIT
         MVC       SNAPAREA+7(77),SNAPAREA+6  BLANK HEX DUMP AREA
         TR        SNAPAREA(6),SNAPHEX RENDER INTO ENGLISH
         MVC       SNAPAREA+87(32),XR3 PUT IN CHARACTERS
         TR        SNAPAREA+87(32),SNAPTRAN  TRANS INTO ANGLAIS
         LA        R2,SNAPAREA+9       POINT TO 1ST BUFFER POS'N
         LA        R6,2                2 TIMES THRU, 16 BYTES EACH
SNAPHALF DS        0H
         LA        R7,4                4 WORDS PER HALF LINE
SNAPWORD DS        0H
         C         R3,XR8+4            ARE WE DONE.Q
         BH        SNAPOUT             GET OUT IF SO
         L         R4,XR3              GET NEXT WORD FOR OUTPUT
         ST        R4,SNAPWORK         PUT IN UNPACK AREA
         UNPK      XR2(9),SNAPWORK(5)  UNPACK INTO BUFFER
         MVI       XR2+8,C' '          BLANK DUMMY DIGIT
         TR        XR2(8),SNAPHEX      MAKE IT PRINTABLE
         LA        R2,XR2+9            BUMP TO NEXT OUTPUT AREA
         LA        R3,XR3+4            POINT TO NEXT WORD
         BCT       R7,SNAPWORD         GO BACK UNLESS FINISHED HALF
         LA        R2,XR2+3            SKIP 3 PRINT POS'NS
         BCT       R6,SNAPHALF         GO BACK IF ONLY HALF DONE
SNAPOUT  DS        0H
         STM       R13,R1,SNAP$4       SAVE REGS TO BE ZONKED
         LA        R13,SNAPAREA        POINT TO OUTPUT AREA
         LA        R14,119             LENGTH-1 TO OUTPUT
         BAL       R1,SNAP$0           GO PRINT IT
         LM        R13,R1,SNAP$4       RESTORE ZONKED REGS
         B         SNAPLOOP            GO CHECK NEXT LINE
SNAPDONE DS        0H
         LM        R13,R7,SNAPSAVE     RESTORE REGISTERS
         B         XR8+8               RETURN
         EJECT
*
*        WORK AND DATA AREA
*
SNAPWORK DC        D'0'
SNAPSAVE DC        11F'0'              SAVE AREA FOR SNAPDATA
SNAPAREA DC        CL120' '            FORMAT DATA HERE
SNAPHEX  EQU       *-240               START OF TRANSLATE DOESN'T HURT
SNAPTRAN DC        X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC        X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'
         DC        X'E6E7E8E95B7B7C4E605C616B7E504B4D'
         DC        X'5D7D404B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC        192XL1'4B'
*
.NOSNPDT ANOP
         TITLE     'UCHECK'
*        UCHECK ROUTINE
*
*        FOR CHECK AFTER WRITE SIMPLY DOES A CHECK
*        IF AFTER A READ ALSO COMPUTES AND RETURNS RECORD LENGTH
         USING     UUCT,R9
UCHECK   SNAPOUT   'UCHECK','UTILITY=',XR10+4
         CLI       UUCTSW,M0       TEST WHETHER READ OR WRITE
         BL        UCW             BRANCH FOR WRITE
         CHECK     UUCTRDEB
         L         R1,UUCTRDEB+16  POINT AT STATUS STUFF
         L         R2,UUCTMAXR     PICK UP RECORD LENGTH USED IN READ
         SH        R2,XR1+14       CALCULATE ACTUAL RECORD LENGTH
         ST        R2,XR10+8       GIVE TO USER
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         B         BUFFEXIT        RETURN
*        CHECK AFTER WRITE
UCW      CHECK     UUCTWDEB
         LA        R10,XR10+4      POINT AT LAST PARAMETER
         B         BUFFEXIT        RETURN
         DROPR     R9
         TITLE     'UNOTE'
*        UNOTE ROUTINE
*
*        FOR D.A. DEVICES THE THREE BYTES RETURNED ARE TTR
*        FOR TAPE THE RECORD NUMBER IS RETURNED, AFTER SHIFTING IT     X
                   INTO THE TOP 3 BYTES
*
         USING     UUCT,R9
UNOTE    SNAPOUT   'UNOTE','UTILITY=',XR10+4
         ACCUM     UUCTNTNO
         L          R2,UUCTDCB     POINT AT DCB
         USING     DCB,R2
         NOTE      (R2)
         TMBNZ     DCBDEVT,M2,UN1  TEST FOR D.A. DEVICE
         SLL       R1,8            LEFT SHIFT TAPE COUNT
UN1      ST        R1,XR10+8       GIVE NOTE TO USER
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         B         BUFFEXIT        RETURN
         DROPR     R2,R9
         TITLE     'UPOINT'
*        UPOINT ROUTINE
*
*        IF D.A. DEVICE SIMPLY DOES A POINT
*        IF TAPE LOW BYTE IS ADDED TO TOP 3 BYTES SHIFTED RIGHT 1 BYTE X
                   BEFORE DOING POINT
*
         USING     UUCT,R9
*        UNBUFFERED POINT TO READ
UPOINTR  MVI       UUCTSW,M0       TURN ON READ SWITCH
         ACCUM     UUCTPRNO
         B         UP1
*        UNBUFFERED POINT TO WRITE
UPOINTW  MVI       UUCTSW,M        TURN OFF READ SWITCH
         ACCUM     UUCTPWNO
UP1      L         R2,XR10+8       PICK UP NOTE INFO
         SNAPOUT   'UPOINT','UTILITY=',XR10+4,'NOTE=',(R2)
         L         R1,UUCTDCB      POINT AT DCB
         USING     DCB,R1
         TMBNZ     DCBDEVT,M2,UP2  TEST FOR D.A. DEVICE
         SRL       R2,8            SHIFT TAPE COUNT RIGHT
         CLI       XR10+11,M7      SEE IF 1 SHOULD BE ADDED
         BNE       UP2             BRANCH IF NOT
         LA        R2,XR2+1        ADD 1 CAUSE LOW BYTE WAS 1
UP2      ST        R2,UPWORK       PLACE IT IN MEMORY
         LA        R0,UPWORK       SET POINTER TO IT
         POINT     (1),(0)         DO POINT
         REF       R1,R0
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         B         BUFFEXIT        RETURN
         DROPR     R1,R9
UPWORK   DC        F'0'
         TITLE     'UTCLOSE'
*        UTCLOSE ROUTINE
*
*        THE FILE MODE IS SWITCHED AND A TCLOSE DONE
*
         USING     UUCT,R9
UTCLOSE  SNAPOUT   'UTCLOSE'
         SNAPOUT   ' UTILITY=',XR10+4,'  POINTR=',UUCTPRNO,            X
                   '  POINTW=',UUCTPWNO,'   NOTES=',UUCTNTNO,TYPE=STAT
         SNAPOUT   '   READS=',UUCTRDNO,'  WRITES=',UUCTWRNO,TYPE=STAT
         AIF       (&NOTSTAT).NOS2
         MVC       UUCTPRNO(5),=PL5'0'
         MVC       UUCTPWNO(5),=PL5'0'
         MVC       UUCTNTNO(5),=PL5'0'
         MVC       UUCTRDNO(5),=PL5'0'
         MVC       UUCTWRNO(5),=PL5'0'
.NOS2    ANOP
         XI        UUCTSW,M0       FLIP MODE SWITCH
         L         R2,UUCTDCB      POINT AT DCB
         CLOSE     ((R2),REREAD),TYPE=T
         LA        R10,XR10+8      POINT AT LAST PARAMETER
         B         BUFFEXIT        RETURN
         DROPR     R9
         TITLE     'GETCORE'
***********************************************************************
*        SUBROUTINES CALLED BY ROUTINES AND OTHER SUBROUTINES
*
*        GETCORE SUBROUTINE
*
*        R7 IS AMOUNT (MULTIPLE OF 8)
*        R8 IS RETURN
*        R5 WILL CONTAIN ADDRESS OF CML OF AVAILABLE CORE
*        CLOBBERS R0,R1,R2,R3,R4,R5,R6,R14,R15
*
*        CML WILL BE SET UP FOR USER
*        IF NO CORE IS AVAILABLE NOGOEXIT IS TAKEN UNLESS SHRINKSW     X
                   IS ON IN WHICH CASE RETURN IS MADE WITH R5 = -1
*
*        UP MAX BLOCKSIZE IF NECESSARY
GETCORE  CBNH      R7,MAXBLOCK,GC0 IS THIS REQUEST BIGGEST YET
         ST        R7,MAXBLOCK     NEW MAX
*        FIND ENOUGH FREE CORE FOR USER
*        INITIALIZE SEARCH
GC0      SNAPOUT   'GETCORE','AMOUNT=',(R7)
         LINKCHK
         MVI       GCRESW,M            INITIALIZE SWITCH
GC00     SR        R0,R0           INITIALIZE ACCUMULATOR
         LA        R1,CORELIST     START SCAN OF FCPS
         USING     FCP,R1
GC1      L         R1,FCPPTDWN     POINT AT NEXT ENTRY
         USING     CML,R1
         CLI       CMLFLAG,M0      TEST TYPE OF ENTRY
         BH        GC2             BRANCH IF END OF LIST
         L         R2,CMLPTUP          CALCULATE LENGTH OF ENTRY
         SR        R2,R1
         AR        R0,R2               ADD TO ACCUMULATOR
         CRBL      R2,R7,GC1       SEE IF BIG ENOUGH FOR USER
         SR        R0,R7           REMOVE USER SPACE FROM ACCUMULATOR
         CBNL      R0,MAXBLOCK,GC5 TEST IF ENOUGH FREE CORE IN RESERVE
*        SEE IF ENOUGH FREE CORE TO SATISFY RESERVE REQUIREMENT
*        THERE SHOULD USUALLY BE MAXBLOCK CORES AVAILABLE IN RESERVE
*        THE PURPOSE OF THE RESERVE IS TO FORCE SPILLOUTS WHEN THE     X
                    BUFFER SPACE BECOMES NEARLY FULL
         LR        R2,R1           LEAVE R1 POINTING AT GOOD ENTRY
         DROPRUSE  R1,FCP,R2
GC3      L         R2,FCPPTDWN     GO DOWN ONE ENTRY
         USING     CML,R2
         CLI       CMLFLAG,M0      TEST TYPE OF ENTRY
         BH        GC4             BRANCH IF END OF LIST
         SR        R0,R2           ADD LENGTH OF ENTRY
         A         R0,CMLPTUP       TO ACCUMULATOR
         CBL       R0,MAXBLOCK,GC3 TEST IF ENOUGH FOUND
*        ENOUGH CORE FOUND
*        CREATE CML ENTRY FOR USER
         DROPRUSE  R2,CML,R1
GC5      L         R3,CMLPTUP      CALCULATE LENGTH OF ENTRY
         SR        R3,R1
         SR        R3,R7           SEE IF MORE CORE THAN NEEDED IN CML
         CBL       R3,=F'16',GC6   IF ONLY 16 EXTRA CANNOT MAKE FCP
*        MUST RETAIN PRESENT FCP AND CREATE NEW CML
         L         R2,CMLPTUP      POINT AT UPPER ENTRY
         LR        R5,R2           CALCULATE ADDRESS OF NEW CML
         SR        R5,R7           POINT AT NEW CML
         ST        R5,CMLPTUP      ALTER UP POINTER IN LOWER CML
         DROPRUSE  R1,CML,R5
         ST        R1,CMLPTDWN     SET DOWN POINTER IN NEW CML
         ST        R2,CMLPTUP      SET UP POINTER IN NEW CML
         DROPRUSE  R5,CML,R2
         IC        R0,CMLFLAG      SAVE FLAG
         ST        R5,CMLPTDWN     ALTER DOWN POINTER IN UPPER CML
         STC       R0,CMLFLAG      RESTORE FLAG
         SNAPOUT   'GETCORE EXIT1','ADDRESS=',(R5)
         LINKCHK
         BR        R8              RETURN
*        FREE CORE ENTRY LESS THAN 16 BYTES LARGER THAN USER REQUEST
*        CHANGE FREE CORE ENTRY TO I/O ENTRY
         DROPRUSE  R2,FCP,R1       REMOVE FCP
GC6      L         R2,FCPPTUP      POINT AT UPPER FCP
         L         R3,FCPPTDWN     POINT AT LOWER FCP
         USING     CML,R1
         MVI       CMLFLAG,M       SHOW I/O ENTRY NOW
         DROPRUSE  R1,FCP,R2       ALTER UPPER FCP
         ST        R3,FCPPTDWN     SET DOWN POINTER
         DROPRUSE  R2,FCP,R3       ALTER LOWER FCP
         ST        R2,FCPPTUP      SET UP POINTER
         LR        R5,R1           MOVE ANSWER
         SNAPOUT   'GETCORE EXIT2','ADDRESS=',(R5)
         LINKCHK
         BR        R8              RETURN
         DROPR     R3
*        DECIDE WHETHER TO SQUISH OR SPILLOUT
GC2      CRBL      R0,R7,GC20      MUST SPILLOUT IF NOT ENOUGH         X
                   NONCONTIGUOUS CORE TO SATISFY USER
         STM       R7,R8,GCSV      SAVE LENGTH AND RETURN ADDRESS
         BAL       R8,SQUISH       SQUISH MEMORY
         LM        R7,R8,GCSV      RESTORE REGISTERS
         B         GC00            TRY AGAIN
*        IF SPILLOUTS ARE IN PROGRESS SEE IF THEIR CORE WILL MEET      X
                   RESERVE REQUIREMENT
GC4      LTBZ      R4,NUMBUFUT,GC5 FORGET IT IF NOTHING TO SPILLOUT
         LA        R2,UCTADDR
GC11     L         R5,XR2          POINT AT UCT
         USING     UCT,R5
         LTBZ      R5,UCTSPLO,GC10 TEST IF SPILLOUT IN PROGRESS
         USING     RCL,R5
         L         R5,RCLPT        POINT AT CML OF RECORD
         USING     CML,R5
         LA        R5,0(0,R5)          CLEAR TOP BYTE
         SR        R0,R5           ADD LENGTH OF ENTRY TO ACCUMULATOR
         A         R0,CMLPTUP
         CBNL      R0,MAXBLOCK,GC5 SEE IF ENOUGH
GC10     LA        R2,XR2+4        POINT AT NEXT UCT ADDRESS
         BCT       R4,GC11         TRY NEXT UTILITY
         DROPR     R5
         MVI       GCRESW,N            SET SWITCH
         ST        R1,GCSV1            SAVE R1
*        TRY TO DO A SPILLOUT TO GET MORE MEMORY
GC20     L         R1,NUMBUFUT         ERROR IF NOTHING TO SPILL
         LTR       R2,R1           NUMBER OF BUFFERED UTILITIES
         BZ        GCERROR
         SLL       R2,2            TIMES 4
         LA        R2,UCTADDR-4(R2) POINT AT ADDRESS OF LAST UCT
         LR        R5,R2           SAVE POINTR
*        SEE IF UTILITY IS BEING WRITTEN ON
GC21     L         R3,XR2          POINT AT UCT
         USING     UCT,R3
         CLI       UCTSW,M0        TEST FOR WRITE
         BNL       GC221           BRANCH IF NOT
         L         R4,UCTNEXTO     CHECK FOR SPILLOUT AT END OF FILE
GC211    CBE       R4,UCTRLAST,GC22
         USING     RCL,R4
         TMBZ      RCLFLAG,M7,SPILLOUT SPILLOUT IF RECORD IN CORE
         A         R4,RCLINC       POINT AT NEXT ENTRY
         B         GC211
GC22     ST        R4,UCTNEXTO     SAVE POINTER
GC221    S         R2,=F'4'        FIND NEXT UCT
         BCT       R1,GC21         ARE THERE MORE BUFFERED UTILITIES
*        UNABLE TO FIND SPILLOUTABLE WRITE FILE
*        TRY THE READ FILES
         L         R1,NUMBUFUT     NUMBER OF UTILITIES
GC23     L         R3,XR5          POINT AT UCT
         CLI       UCTSW,M01       TEST FOR READ AND SPILLOUTABLE
         BL        GC25            BRANCH IF NOT
         L         R2,=X'FFFFFFFF' INITIALIZE MINIMUM FLAG REGISTER
         LA        R14,GC244       SET RECORD IN CORE SW OFF
         LA        R15,GC240       SET FULL SEARCH SW OFF
         L         R0,UCTFLAG      PICK UP COMPARE FLAG
         O         R0,=X'03FFFFFF' CLEAR JUNK
         L         R4,UCTNEXTO     POINT AT RCL
         CBE       R4,UCTRLAST,GC234 SEE IF AT END OF FILE
         CBNH      R4,UCTRNEXT,GC235 SEE IF NOT IN FIRST PART OF FILE
*        IN FIRST SECTION OF FILE
GC233    TMBNZ     RCLFLAG,M7,GC232 TEST IF IN CORE
         CLBNL     R0,RCLFLAG,SPILLOUT SPILLOUT IF FLAG LOW ENOUGH
         LA        R14,GC243       SET RECORD IN CORE SW
         CLBL      R2,RCLFLAG,GC232 SEE IF NEW MIN FLAG
         L         R2,RCLFLAG      NEW LOW FLAG
GC232    A         R4,RCLINC       GO DOWN ONE ENTRY
GC236    CBH       R4,UCTRNEXT,GC233 TEST FOR DONE FIRST SECTION
         L         R4,UCTRLAST     PREPARE TO DO LAST SECTION
         B         GC234           GO CHECK IF LAST SECTION EXISTS
*./      DELETE    SEQ1=31060020,SEQ2=31060020
*        IN LAST SECTION OF FILE
GC231    TMBNZ     RCLFLAG,M7,GC234 TEST IF IN CORE
         CLBNL     R0,RCLFLAG,SO1  SPILLOUT IF FLAG LOW ENOUGH
         LA        R14,GC243       SET RECORD IN CORE SW
         CLBL      R2,RCLFLAG,GC234 SEE IF NEW MIN FLAG
         L         R2,RCLFLAG      NEW LOW FLAG
GC234    S         R4,RCLINC       GO UP ONE ENTRY
GC235    CBL       R4,UCTRNEXT,GC231 SEE IF STILL IN LAST SECTION
         BR        R15             END OF SCAN
*        FIRST EXIT. PARTIAL SCAN
GC240    LA        R15,GC242       TURN ON FULL SCAN SW.
GC241    L         R4,UCTRCLN1     START FULL SCAN
         B         GC236
*        SECOND EXIT. FULL SCAN COMPLETED
GC242    BR        R14             TEST IN CORE SWITCH
*        RECORDS IN CORE. ADJUST UCTFLAG AND TRY AGAIN
GC243    ST        R2,UCTFLAG      STORE MIN FLAG ACCEPTABLE
         LR        R0,R2           USE IT IN FINAL SCAN
         B         GC241
*        NO RECORDS IN CORE. TURN OFF POSSIBLE SPILLOUT SWITCH
GC244    NI        UCTSW,N1        TURN OFF SWITCH
GC25     S         R5,=F'4'        FIND NEXT UCT
         BCT       R1,GC23         TRY NEXT UTILITY
         DROPR     R3,R4
         L         R1,GCSV1            RESTORE R1
         CLI       GCRESW,M            TEST SWITCH
         BNE       GC5                 BR IF ONLY TRYING TO GET RESERVE
*        ONE LAST CHANCE. TRY CHECKING A SPILLOUT IF ANY.
*        THIS WILL KILL DOUBLE BUFFERING OF OUTPUT.
         L         R4,NUMBUFUT         NUMBER OF BUFFERED UTILITIES
         LA        R2,UCTADDR          UCT'S ADDRESS TABLE
         STM       R7,R9,GCSV          SAVE R7, R8, AND R9
GC7      L         R9,XR2              POINT AT UCT
         USING     UCT,R9
         LTBNZ     R7,UCTSPLO,GC8      TEST IF SPILLOUT IN PROGRESS
         DROPR     R9
         LA        R2,XR2+4            POINT AT NEXT UCT ADDRESS
         BCT       R4,GC7              BRANCH IF MORE BUFFERED UT'S
*        UNABLE TO SPILLOUT ANYWHERE. ABORT CONDITION
GCERROR  L         R1,NOGOEXIT     PREPARE TO DIE
SHRINKSW BC        *-*+15,XR1(*-*) EXIT UNLESS SHRINKSW ON
         L         R5,=X'FFFFFFFF' PLACE THE BAD NEWS
         BR        R8              RETURN
*        CHECK A SPILLOUT TO FREE UP A BIT MORE CORE
GC8      LA        R8,SO9              SET CHECKOUT RETURN ADDRESS
         B         CHECKOUT
*        GETCORE SAVE AREA
GCSV     DC        3F'0'           R7, R8, AND R9 SAVE AREA
GCSV1    DC        F'0'                R1 SAVE AREA
GCRESW   DC        X'00'               M IF TRYING TO MEET REQUEST,    X
                                       N IF TRYING TO MEET RESERVE
         TITLE     'SPILLOUT'
*        SPILLOUT CODE (PART OF GETCORE SUBROUTINE)
*
SPILLOUT LR        R5,R4           ENTRY TO MOVE UCTNEXTO DOWN
         USING     RCL,R5
         USING     UCT,R3
         A         R4,RCLINC
         B         SO2
SO1      LR        R5,R4           ENTRY TO MOVE UCTNEXTO UP
         S         R4,RCLINC
SO2      ST        R4,UCTNEXTO     STORE NEW UCTNEXTO
         STM       R7,R9,GCSV
*        IF RECORD HAS ALREADY BEEN SPILLED ONCE DO NOT SPILL AGAIN
         TMBZ      RCLFLAG,M6,SO0  TEST ON DISK SWITCH
*        IF RECORD BEING SPILLED IN MUST CHECK IT
         CBNE      R5,UCTSPLI,SO00 CHECK IF BEING SPILLED IN
         LR        R9,R3               SET UP THINGS FOR CHECKIN
         LR        R7,R5
         BAL       R8,CHECKIN
SO00     L         R3,RCLPT        POINT AT RCP
         USING     RCP,R3
         MVC       RCLNOTE(3),RCPNOTE MOVE TTR INTO RCL
         USING     CML,R3
         L         R2,CMLPTDWN     PICK UP POINTERS FOR FREECORE
         L         R4,CMLPTUP
         BAL       R8,FREECORE     FREE THE RECORD
         B         SO6
         USING     UCT,R3
SO0      SNAPOUT   'SPILLOUT'
         ACCUM     UCTSOCNT        ADD 1 TO STATISTICS COUNTER
         LR        R9,R3           FOR CHECK SUBROUTINES
         DROPRUSE  R3,UCT,R9
*        CHECK IF SPILLOUT OR SPILLIN IN PROGRESS
         LTBZ      R7,UCTSPLI,SO3  IS SPILLIN IN PROGRESS
         BAL       R8,CHECKIN
SO3      LTBZ      R7,UCTSPLO,SO4  IS SPILLOUT IN PROGRESS
         BAL       R8,CHECKOUT
*        TEST IF A POINT IS NECESSARY
SO4      TM        UCTSW,M2
         BZ        SO41
*        DO POINT TO WRITE ON UTILITY
         L         R1,UCTDCB       POINT AT DCB
         MVI       UCTONOTE+3,1    SET 1 TO WRITE BEYOND LAST RECORD
         POINT     (1),UCTONOTE
         REF       R1
         NI        UCTSW,N2        TURN OFF POINT SW
*        RESTORE THE TRACK BALANCE IN THE DCB TO AVOID SVC 25 USAGE
         CLI       UCTTRBAL,X'FF'      TEST IF TRACK BALANCE IS VALID
         BE        SO41                BR IF NOT
         L         R1,UCTDCB           POINT AT THE DCB
         USING     DCB,R1
         MVC       DCBTRBAL(2),UCTTRBAL RESTORE SAVED TRACK BALANCE
         OI        DCBOFLGS,X'80'      PRETEND LAST OPERATION WAS WRITE
         DROPR     R1
*        DO WRITE ON UTILITY
SO41     L         R2,UCTDCB       POINT AT DCB
         L         R4,RCLPT        POINT AT RCP
         USING     RCP,R4
         LA        R3,RCPDATA      POINT AT DATA RECORD
         LH        R7,RCPRL        PICK UP RECORD LENGTH
         WRITE     UCTODECB,SF,(R2),(R3),(R7),MF=E
*        CLEANUP MISC THINGS
         CBNH      R7,UCTMAXRL,SO5 SEE IF NEW MAX RECORD LENGTH
         ST        R7,UCTMAXRL     NEW RECORD LENGTH BIGGER
SO5      ST        R5,UCTSPLO      SET SPILLOUT RECORD POINTER
         DROPR     R4,R9
         SNAPOUT   'SPILLOUT EXIT','ADDRESS=',(R4),                    X
                   'DATA=',XR4+16,XR4+20,XR4+24,XR4+28,XR4+32
SO6      OI        RCLFLAG,M7      TURN OFF IN CORE SWITCH
SO9      LM        R7,R9,GCSV      RESTORE REGISTERS
         B         GC00            TRY AGAIN TO FIND CORE FOR USER
         DROPR     R5
         TITLE     'FREECORE'
*        FREECORE SUBROUTINE
*
*        R3 MUST POINT TO CML BEING FREEED
*        R4 MUST POINT TO NEXT UPPER CML
*        R2 MUST POINT TO NEXT LOWER CML
*        R8 IS RETURN
*        CLOBBERS R0,R1,R2,R3
*
*        RESTORES CORE TO AVAILABLE STATUS
         USING     CML,R3
FREECORE SNAPOUT   'FREECORE','FROM=',(R3),'TO=',CMLPTUP
         LINKCHK
         MVI       CMLFLAG,M0      SET FREE CORE FLAG
         DROPRUSE  R3,CML,R2
         LA        R3,XR3            CLEAR TOP BYTE
         CLI       CMLFLAG,M0      TEST FOR FREE CORE OR END OF LIST
         BH        FC3             BRANCH END OF LIST
         BE        FC1             BRANCH FREE CORE
*        SEARCH DOWN LIST FOR NEXT LOWEST FREE CORE
FC2      L         R2,CMLPTDWN     GO DOWN ONE ENTRY
         CLI       CMLFLAG,M0      TEST FOR FREE CORE OR END OF LIST
         BL        FC2
         USING     FCP,R2
FC3      L         R1,FCPPTUP      SAVE ADDRESS OF HIGHER FREE CORE
         ST        R3,FCPPTUP      SET POINTER TO NEW ENTRY
         DROPRUSE  R2,FCP,R3
         LA        R2,XR2            CLEAR TOP BYTE
         ST        R2,FCPPTDWN     SET DOWN POINTER IN NEW ENTRY
         ST        R1,FCPPTUP      SET UP POINTER IN NEW ENTRY
         B         FC4
         DROPRUSE  R3,CML,R2
*        LOWER ENTRY IS FREE CORE. REMOVE NEW ENTRY
FC1      ST        R4,CMLPTUP      SET UP POINTER IN LOWER ENTRY
         USING     FCP,R2
         L         R1,FCPPTUP      SAVE POINTER TO NEXT ABOVE FREE CORE
         DROPRUSE  R2,CML,R4       CHANGE UPPER ENTRY
         IC        R0,CMLFLAG      SAVE FLAG
         LA        R2,XR2            CLEAR TOP BYTE
         ST        R2,CMLPTDWN     SET DOWN POINTER
         STC       R0,CMLFLAG      RESTORE FLAG
         LR        R3,R2           MAKE LOWER ENTRY NEW ENTRY
*        SET DOWN POINTER IN NEXT ABOVE FCP
         DROPRUSE  R4,FCP,R1
FC4      ST        R3,FCPPTDWN     SET DOWN POINTER
         LINKCHK
*        CHECK IF NEXT ABOVE ENTRY IS FREE CORE AND IF SO MERGE WITH   X
                   NEW ENTRY
         DROPRUSE  R1,CML,R4
         CLI       CMLFLAG,M0      TEST FOR FREE CORE
         BNER      R8              RETURN IF NOT
         L         R2,CMLPTUP      LOCATE ENTRY ABOVE THIS ONE
         DROPRUSE  R4,CML,R2       ALTER THIS UPPER UPPER ENTRY
         IC        R0,CMLFLAG      SAVE FLAG
         ST        R3,CMLPTDWN     SET DOWN POINTER
         STC       R0,CMLFLAG      RESTORE FLAG
         DROPRUSE  R2,FCP,R4
         L         R1,FCPPTUP      SAVE UP POINTER
         DROPRUSE  R4,CML,R3       ALTER NEW ENTRY
         ST        R2,CMLPTUP      SET UP POINTER
         USING     FCP,R3
         ST        R1,FCPPTUP      SET UP POINTER IN NEW ENTRY
         DROPRUSE  R3,FCP,R1
         ST        R3,FCPPTDWN     SET DOWN POINTER IN UPPER UPPER FCP
         LINKCHK
         BR        R8              RETURN
         DROPR     R1
         TITLE     'MOVE'
*        MOVE SUBROUTINE
*
*        R5 IS FROM ADDRESS
*        R6 IS TO ADDRESS
*        R7 IS LENGTH
*        R8 IS RETURN
*        CLOBBERS NONE
*
*        MOVE IS DONE FROM RIGHT TO LEFT SO SQUISH OR GROW UP OF       X
                   OVERLAPPING AREAS WILL WORK
*        THE MOVE INVOLVES LD STD SEQUENCES, THUS REQUIRING THAT THE   X
                   AREAS MUST BE ON DOUBLE WORD BOUNDRIES
*
MOVE     SNAPOUT   'MOVE','FROM=',(R5),'TO=',(R6),'LENGTH=',(R7)
         SNAPOUT   'MOVE','DATA=',XR5,XR5+4,XR5+8,XR5+12,XR5+16
         ACCUM     UNMOCNT             COUNT THE MOVES
         AIF       (&NOTBUG).MOVE
*        CHECK OPERANDS ON DOUBLE WORD BOUNDRY
         TMRBZ     R5,M567,MV1
MV2      SNAPOUT   'MOVE NOT ON DOUBLE WORD BOUNDRY'
         ABEND     20,DUMP
MV1      TMRBNZ    R6,M567,MV2
.MOVE    STM       R0,R15,MSV1     STORE EVERYTHING
         LA        R14,XR5(R7)     ADD LENGTH TO FROM ADDRESS
         LA        R15,XR6(R7)     ADD LENGTH TO TO ADDRESS
         N         R7,=A(M567)     TEST LENGTH MULTIPLE OF 8
*        IF LENGTH IS NOT A MULTIPLE OF 8 THE LAST BYTES ARE MOVED BY  X
                   AN MVC TO YIELD A LENGTH THAT IS A MULTIPLE OF 8
         BZ        MV3             BRANCH IF LENGTH IS A MULTIPLE OF 8
         SR        R14,R7          ADJUST TO ADDRESS
         SR        R15,R7          ADJUST FROM ADDRESS
         BCTR0     R7              SUBTRACT 1 FOR MVC LENGTH
         EX        R7,MVMVC        MOVE 1 TO 8 BYTES
         B         MV3             AND CONTINUE
MVMVC    MVC       XR15(*-*),XR14  EXECUTED MOVE 1 TO 8 BYTES
         DROPR     R11,R12,R13     BASES ABOUT TO BE CLOBBERED
MV4      DS        0D              DOUBLE ALIGN THE INSTRUCTIONS FOR   X
                   MODEL 75 PERFORMANCE
*        THE FOLLOWING BLOCK OF CODING IS A FAST MOVE METHOD
*        EACH LM STM PAIR OF INSTRUCTIONS MOVES 14*4 BYTES
&WORK    SETA      &MOVENUM/14/4-1
.MOVE1   LM        R0,R13,XR14+&WORK*14*4 LOAD 56 BYTES
         STM       R0,R13,XR15+&WORK*14*4 STORE 56 BYTES
&WORK    SETA      &WORK-1
         AIF       (&WORK GE 0).MOVE1
         LR        R0,R0           FAST HALF-WORD NOP TO ALIGN MVSW
MV3      BALR0     R13             LOAD ME A BASE
         USING     MVSW,R13
MVSW     EQU       *               WILL BE ONE OF THE FOLLOWING LINES
*        B         MOVEXIT         RETURN TO USER. MVSW INST NO. 1
*                    OR
         S         R14,=A(&MOVENUM) PREPARE FOR NEXT MOVE. MVSW INST 2
         S         R15,=A(&MOVENUM)
*        IF THE REMAINING NUMBER OF BYTES TO BE MOVED IS .GE. THE      X
                   NUMBER THAT THE MOVE BLOCK MOVES DO THE MOVE BLOCK
         L         R1,=A(MV4)      PREPARE TO BRANCH INTO MOVE BLOCK
         CBNLR     R14,MSV1+4*R5,R1  DO MOVE BLOCK UNLESS TOO MUCH
         L         R0,MVSW1        SET MVSW TO EXIT INSTRUCTION
         ST        R0,MVSW
         LA        R12,XR14+&MOVENUM COMPUTE NUMBER OF CHARACTERS LEFT
         L         R14,MSV1+4*R5   SET ORIGINAL TO ADDRESS
         L         R15,MSV1+4*R6   SET ORIGINAL FROM ADDRESS
         SR        R12,R14         NUMBER OF CHARACTERS LEFT
         L         R10,MVTAB(R12)  ADDRESS OF PRIMARY ROUTINE
         L         R11,MVTAB+4(R12) ADDRESS OF SECONDARY ROUTINE
         BR        R10             GO DO PRIMARY
MSV1     DC        16F'0'          REGISTER SAVE AREA
MVSW1    B         MOVEXIT         MOVED TO MVSW
MVSW2    S         R14,=A(&MOVENUM) MOVED TO MVSW
MVTAB    DS        0F
*        THE PRIMARY ADDRESS IS THE ADDRESS OF A ROUTINE TO MOVE       X
                   0, 8, 16, 24, 32, 40, OR 48 BYTES
*        THE SECONDARY ADDRESS IS AN ADDRESS WITHIN THE MOVE BLOCK TO  X
                   MOVE A MULTIPLE OF 56 BYTES
         DC        A(MVP0)             PRIMARY ADDRESS
         DC        A(MOVEXIT)          SECONDARY ADDRESS
         DC        A(MVP8)             PRIMARY ADDRESS
         DC        A(MOVEXIT)          SECONDARY ADDRESS
         DC        A(MVP16)            PRIMARY ADDRESS
         DC        A(MOVEXIT)          SECONDARY ADDRESS
         DC        A(MVP24)            PRIMARY ADDRESS
         DC        A(MOVEXIT)          SECONDARY ADDRESS
         DC        A(MVP32)            PRIMARY ADDRESS
         DC        A(MOVEXIT)          SECONDARY ADDRESS
         DC        A(MVP40)            PRIMARY ADDRESS
         DC        A(MOVEXIT)          SECONDARY ADDRESS
         DC        A(MVP48)            PRIMARY ADDRESS
         DC        A(MOVEXIT)          SECONDARY ADDRESS
&MOVENUM SETA      &MOVENUM/14/4-1
.MOVE4   DC        A(MVP0)             PRIMARY ADDRESS
         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS
         DC        A(MVP8)             PRIMARY ADDRESS
         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS
         DC        A(MVP16)            PRIMARY ADDRESS
         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS
         DC        A(MVP24)            PRIMARY ADDRESS
         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS
         DC        A(MVP32)            PRIMARY ADDRESS
         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS
         DC        A(MVP40)            PRIMARY ADDRESS
         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS
         DC        A(MVP48)            PRIMARY ADDRESS
         DC        A(MV4+8*&MOVENUM)   SECONDARY ADDRESS
&MOVENUM SETA      &MOVENUM-1
         AIF       (&MOVENUM GE 1).MOVE4
*        THE PRIMARY ROUTINES FOLLOW
MVP0     BR        R11             GO TO SECONDARY
MVP8     S         R12,=F'8'       REDUCE LENGTH BY 8
         LD        FR0,XR14(R12)   PICK UP 8 BYTES
         STD       FR0,XR15(R12)   STORE 8 BYTES
         BR        R11             GO TO SECONDARY
MVP16    S         R12,=F'16'      REDUCE LENGTH BY 16
         LD        FR0,XR14+8(R12) MOVE TOP 8 BYTES
         STD       FR0,XR15+8(R12)
         LD        FR0,XR14(R12)   MOVE LOWER 8 BYTES
         STD       FR0,XR15(R12)
         BR        R11             GO TO SECONDARY
MVP24    S         R12,=F'24'      REDUCE LENGTH BY 24
         LD        FR0,XR14+16(R12) MOVE TOP 8 BYTES
         STD       FR0,XR15+16(R12)
         LD        FR0,XR14+8(R12) ANOTHER 8 BYTES
         STD       FR0,XR15+8(R12)
         LD        FR0,XR14(R12)   LAST 8 BYTES
         STD       FR0,XR15(R12)
         BR        R11             GO TO SECONDARY
MVP32    S         R12,=F'32'      REDUCE LENGTH BY 32
         LD        FR0,XR14+24(R12) MOVE 8 BYTES
         STD       FR0,XR15+24(R12)
         LD        FR0,XR14+16(R12) MOVE 8 BYTES
         STD       FR0,XR15+16(R12)
         LD        FR0,XR14+8(R12) MOVE 8 BYTES
         STD       FR0,XR15+8(R12)
         LD        FR0,XR14(R12)   LAST 8 BYTES (THANK HEAVEN)
         STD       FR0,XR15(R12)
         BR        R11             GO TO SECONDARY
MVP40    S         R12,=F'40'      REDUCE LENGTH BY 40
         LA        R10,XR15(R12)   TO ADDRESS
         LA        R12,XR14(R12)   FROM ADDRESS
         LM        R0,R9,XR12      PICK UP 40 BYTES
         STM       R0,R9,XR10      PLUNK EM DOWN
         BR        R11             GO TO SECONDARY
MVP48    S         R12,=F'48'      REDUCE LENGTH BY 48
         LD        FR0,XR14+40(R12) MOVE TOP 8 BYTES
         STD       FR0,XR15+40(R12)
         LA        R10,XR15(R12)   TO ADDRESS
         LA        R12,XR14(R12)   FROM ADDRESS
         LM        R0,R9,XR12      MOVE 40 BYTES
         STM       R0,R9,XR10
         BR        R11             GO TO SECONDARY
*        EXIT ROUTINE FOR MOVE
MOVEXIT  L         R0,MVSW2        RESET SWITCH
         ST        R0,MVSW
         LM        R0,R15,MSV1     RESTORE EVERYTHING
         USING     BUFFENT,R12
         USING     SAVE2,R13,R11
         BR        R8              RETURN
         TITLE     'SQUISH'
*        CORE SQUISH SUBROUTINE
*
*        R8 IS RETURN
*        CLOBBERS R0,R1,R2,R3,R4,R5,R6,R7,R14,R15
*
*        THIS SUBROUTINE DE-FRAGMENTS CORE
*        THIS IS DONE BY MOVING ALL THE USED CORE UP TO THE TOP OF     X
                   THE AVAILABLE CORE
*        THE SUBROUTINE ASSUMES THERE IS ALWAYS SOME FREE CORE
*
SQUISH   SNAPOUT   'SQUISH'
         ACCUM     UNSQCNT             COUNT THE SQUISHES
         LINKCHK
*        CHECK ALL I/O IN PROGRESS
         LTBZR     R6,NUMBUFUT,R8  LOAD NUMBER OF BUFFERED UTILITIES,  X
                   RETURN IF NONE
         LA        R5,UCTADDR      POINT AT UCT ADDRESS
         STM       R8,R9,SQSV1     SAVE RETURN AND UCT BASE
SQ1      L         R9,XR5          POINT AT UCT
         USING     UCT,R9
         LTBZ      R7,UCTSPLI,SQ2  TEST FOR SPILLIN IN PROGRESS
         BAL       R8,CHECKIN      CHECK SPILLIN
SQ2      LTBZ      R7,UCTSPLO,SQ3  TEST FOR SPILLOUT IN PROGRESS
         BAL       R8,CHECKOUT     CHECK SPILLOUT
         DROPR     R9
SQ3      LA        R5,XR5+4        POINT AT NEXT UCT ADDRESS
         BCT       R6,SQ1          DO NEXT BUFFERED UTILITY
*        SHIFT ALL USED CORE UP INTO FREE AREAS
*        INITIALIZATION
         LA        R3,CORELIST     START DOWN CHAIN
         USING     FCP,R3
         L         R3,FCPPTDWN     POINT AT FIRST FREE AREA
         USING     CML,R3
         L         R3,CMLPTUP      POINT AT ENTRY ABOVE
         SR        R7,R7           ZERO MOVE LENGTH
         LR        R4,R7           ZERO MOVE DISTANCE
         LR        R6,R3           INITIALIZE NEW UPPER ENTRY POINTER
*        GO DOWN ONE ENTRY AND EXAMIN TYPE
SQLOOP   LR        R5,R3           R5 POINTS AT UPPER ENTRY
SQLOOP2  L         R3,CMLPTDWN     POINT AT NEXT ENTRY
         LA        R3,0(0,R3)      ZERO TOP BYTE
         CLI       CMLFLAG,M       TEST FOR I/O RECORD
         BE        SQIO
*        FREE CORE OR END OF LIST ENTRY FOUND.
*        MOVE ALL I/O RECORDS SINCE LAST FREE CORE ENTRY UPWARDS
         LTRBZ     R7,SQFR2        TEST FIRST FREE OR FREE NEXT TO END
         BAL       R8,MOVE         MOVE THE RECORDS UP
*        RESET THINGS TO PREPARE FOR NEXT MOVE
         SR        R7,R7           ZERO MOVE LENGTH
SQFR2    AR        R4,R5           ADD LENGTH OF FREE BLOCK TO MOVE
         SR        R4,R3            DISTANCE
         LR        R5,R6           POINT R5 AT NEW UPPER ENTRY
         CLI       CMLFLAG,N       TEST END OF LIST
         BNE       SQLOOP2
*        END OF LIST FOUND. CREATE A FREE CORE CML AND EXIT
         L         R2,CMLPTUP      POINT AT BOTTOM OF MY CORE
         USING     FCP,R3
         ST        R2,FCPPTUP      SET UP POINTER IN CORELIST
         ST        R2,FCPPTDWN     SET DOWN POINTER IN CORELIST
         DROPRUSE  R3,CML,R2       ALTER CML AT BOTTOM OF MY CORE
         ST        R5,CMLPTUP      SET UP POINTER
         MVI       CMLFLAG,M0      SHOW FREE CORE
         USING     FCP,R2          CREATE FCP AT BOTTOM OF MY CORE
         ST        R3,FCPPTUP      SET UP POINTER
         ST        R3,FCPPTDWN     SET DOWN POINTER
         DROPRUSE  R2,CML,R5
         IC        R0,CMLFLAG      SAVE FLAG
         ST        R2,CMLPTDWN     SET DWN PTR IN 2ND FROM BOTTOM ENTRY
         STC       R0,CMLFLAG
         LM        R8,R9,SQSV1     RESTORE REGISTERS
         LINKCHK
         BR        R8              RETURN
         DROPRUSE  R5,CML,R3
*        I/O RECORD FOUND. RELOCATE POINTERS IN PREPARATION FOR MOVE.
SQIO     A         R7,CMLPTUP      ADD LENGTH OF ENTRY TO MOVE LENGTH
         SR        R7,R3
         ST        R6,CMLPTUP      INCREMENT UP POINTER
         LR        R6,R3           CALCULATE NEW POSITION FOR ENTRY
         AR        R6,R4
         USING     RCP,R3
         L         R2,RCPPT        POINT AT RCL FOR THIS ENTRY
         DROPRUSE  R3,RCL,R2
         IC        R0,RCLFLAG      SAVE FLAG
         ST        R6,RCLPT        PLACE POINTER TO NEW POSITION
         STC       R0,RCLFLAG      RESET FLAG
         DROPRUSE  R2,CML,R5       POINT AT UPPER ENTRY
         IC        R0,CMLFLAG      SAVE FLAG
         ST        R6,CMLPTDWN     SET NEW DOWN POINTER
         STC       R0,CMLFLAG
         B         SQLOOP          GO EXAMIN NEXT ENTRY
         DROPR     R5
SQSV1    DC        2F'0'           SAVE AREA FOR R8 AND R9
         TITLE     'CHECKIN'
*        CHECKIN SUBROUTINE
*
*        R7 SHOULD CONTAIN UCTSPLI
*        R8 IS RETURN
*        CLOBBERS R0,R1,R2,R3,R4,R14,R15
*
*        THIS SUBROUTINE CHECKS COMPLETION OF A SPILLIN
*        DO NOT CALL UNLESS SPILLIN IN PROGRESS
         USING     UCT,R9
         USING     RCL,R7
CHECKIN  SNAPOUT   'CHECKIN'
         CHECK     UCTIDECB        WAIT FOR END OF SPILLIN
         SR        R0,R0           CREATE 0
         ST        R0,UCTSPLI      ZERO POINTER
         L         R1,UCTIDECB+16  POINT AT STATUS STUFF
         L         R3,UCTIRL       LOAD BLOCKSIZE USED IN READ
         L         R2,RCLPT        POINT AT RCP OF RECORD
         CBE       R7,UCTRNEXT,CI1 TEST IF THIS IS SPILLOUTABLE
         OI        UCTSW,M1        TURN ON SPILLOUTABLE SWITCH
         CLBNL     R2,UCTFLAG,CI1  TEST IF THIS NEW LOW FLAG
         ST        R2,UCTFLAG      STORE IT
*./      DELETE    SEQ1=39760020,SEQ2=39760020
CI1      SH        R3,XR1+14       SUBTRACT CSW COUNT FIELD
         SNAPOUT   'CHECKIN EXIT','LENGTH=',(R3),                      X
                   'DATA=',XR2+16,XR2+20,XR2+24,XR2+28,XR2+32
         USING     RCP,R2
         STH       R3,RCPRL
         ALIGN     R3,D,INC=16     ADD 16 FOR RCP AND DOUBLE ALIGN
         LA        R2,0(0,R2)        CLEAR FLAG BYTE
         USING     CML,R2
         L         R1,CMLPTUP      COMPUTE UNUSED SPACE
         SR        R1,R2           PRESENT BLOCK SIZE
         SR        R1,R3           DIFFERENCE
         CBLR      R1,=F'16',R8    RETURN IF NOT ENOUGH CORE TO FREE
*        CREATE A NEW CML ENTRY
         L         R4,CMLPTUP      POINT AT TOP ENTRY
         AR        R3,R2           POINT AT NEW ENTRY
         ST        R3,CMLPTUP      CHANGE UP POINTER
         DROPRUSE  R2,CML,R3       SET NEW ENTRY
         ST        R2,CMLPTDWN     SET DOWN POINTER
         ST        R4,CMLPTUP      SET UP POINTER
         DROPRUSE  R3,CML,R4       CHANGE TOP ENTRY
         IC        R0,CMLFLAG      SAVE FLAG
         ST        R3,CMLPTDWN     SET DOWN POINTER
         STC       R0,CMLFLAG      RESTORE FLAG
*        GO TO FREECORE TO SET FLAG AND CREATE FCP IN NEW ENTRY
         B         FREECORE
         DROPR     R4,R7,R9
         TITLE     'CHECKOUT'
*        CHECKOUT SUBROUTINE
*
*        R7 SHOULD CONTAIN UCTSPLO
*        R8 IS RETURN
*        CLOBBERS R0,R1,R2,R3,R4,R14,R15
*
*        THIS SUBROUTINE CHECKS COMPLETION OF A SPILLOUT
*        DO NOT CALL UNLESS A SPILLOUT IS IN PROGRESS
         USING     UCT,R9
         USING     RCL,R7
CHECKOUT SNAPOUT   'CHECKOUT'
         CHECK     UCTODECB        WAIT FOR END OF SPILLOUT
         L         R1,UCTDCB       LOAD DCB ADDRESS
         USING     DCB,R1
         MVC       UCTTRBAL(2),DCBTRBAL SAVE THE TRACK BALANCE
         DROPR     R1
         NOTE      (1)             FIND PRESENT LOCATION
         REF       R1
         ST        R1,UCTONOTE     SAVE FOR NEXT SPILLOUT
         L         R3,RCLPT        POINT AT RECORD IN CORE
         IC        R0,RCLFLAG      PICK UP FLAG BYTE
         SRDL      R0,8            RIGHT JUSTIFY FTTR
         O         R1,=X'02000000' TURN ON DISK SW.
         ST        R1,RCLFLAG      PLACE IN RCL
         SR        R0,R0           CREATE 0
         ST        R0,UCTSPLO      ZERO SPILLOUT POINTER
         USING     CML,R3
         L         R2,CMLPTDWN     PICK UP POINTERS FOR FREECORE
         L         R4,CMLPTUP
         B         FREECORE        FREE THE RECORD
         DROPR     R3,R7,R9
         TITLE     ' '
***********************************************************************
*        LITERALS
*
         LTORG
         EJECT
***********************************************************************
*        THIS AREA IS WHERE THE UCTS AND UUCTS ARE PLACED AT INIT TIME
*
UCTS     CSECT
*./      DELETE    SEQ1=41020020,SEQ2=41400020
         EJECT
*        THIS CODE DESCRIBES THE UTILITY CONTROL TABLE
*        IT IS ALSO THE INITIALIZATION OF THE UCTS
*
UCT      EQU       *                   PLACE INIT AS FIRST UCT
*        POINTERS TO RCL ENTRIES
UCTRCLN1 DC        F'0'            POINTER TO 1ST ENTRY ON RCL
UCTRNEXT DC        F'0'            POINTER TO RCL ENTRY OF NEXT RECORD X
                                   TO BE READ OR WRITTEN
UCTRLAST DC        F'0'            POINTER TO RCL ENTRY OF LAST RECORD X
                                   WRITTEN ON FILE + 1
UCTNEXTO DC        F'0'            POINTER TO RCL ENTRY OF NEXT RECORD X
                                   TO BE SPILLED OUT
UCTSPLI  DC        F'0'            POINTER TO RCL ENTRY OF RECORD      X
                                   BEING SPILLED IN
UCTSPLO  DC        F'0'            POINTER TO RCL ENTRY OF RECORD      X
                                   BEING SPILLED OUT
*        STATISTICS GATHERING ACCUMULATORS
          AIF      (&NOTSTAT).UCT1 ARE WE GATHERING STATISTICS
UCTRDCNT DC        PL5'0'          READ COUNTER
UCTWRCNT DC        PL5'0'          WRITE COUNTER
UCTSICNT DC        PL5'0'          SPILLIN COUNTER
UCTSOCNT DC        PL5'0'          SPILLOUT COUNTER
UCTPRCNT DC        PL5'0'          POINTR COUNTER
UCTPWCNT DC        PL5'0'          POINTW COUNTER
UCTNTCNT DC        PL5'0'          NOTE COUNTER
.UCT1    ANOP
*        MISC STUFF
         READ      UCTIDECB,SF,MF=L SPILLIN DECB DEFINITION
UCTIRL   DC        F'0'            SPILLIN RECORD LENGTH
UCTRRL   DC        F'0'            RECORD LENGTH OF LAST THING READ
UCTWRADD DC        F'0'            ADDRESS OF LAST WRITE
UCTWRLTH DC        F'0'            LENGTH OF LAST WRITE
         WRITE     UCTODECB,SF,MF=L SPILLOUT DECB DEFINITION
UCTONOTE DC        F'0'            NOTE OF LAST SPILLOUT
UCTMAXRL DC        F'0'            MAXIMUM RECORD LENGTH SPILLED OUT
UCTFLAG  DC        F'0'            COMPARISON FLAG FOR SPILLOUT OF READ
UCTTRBAL DC        X'FF00'             SAVED TRACK BALANCE AFTER WRITE
UCTSW    DC        X'00'
*        BIT       PURPOSE
*        0         ON FOR READ, OFF FOR WRITE
*        1         ON IF SPILLOUT MAY BE POSSIBLE AT READ TIME
*        2         ON IF POINT NECESSARY BEFORE SPILLOUT
UCTDCB   DC        F'0'            ADDRESS OF DCB FOR THIS UTILITY
         DS        0D              UCT MUST BE DOUBLE WORDS LONG
UCTLNGTH EQU       *-UCT
         SPACE     3
         DC        ((&MAXUT-1+&SERUSE)*UCTLNGTH)X'00'  SP FOR MORE UCTS
         EJECT
*        THIS CODE DESCRIBES THE UNBUFFERED UTILITY CONTROL TABLE
*        INITIALIZATION OF A UUCT IS THE SAME AS FOR A UCT
*
UUCT     EQU       UCT
UUCTRDEB EQU       UCTIDECB         READ DECB DEFINITION
UUCTMAXR EQU       UCTMAXRL        MAX RECORD LENGTH WRITTEN
UUCTWDEB EQU       UCTODECB         WRITE DECB DEFINITION
*        STATISTICS GATHERING ACCUMULATORS
         AIF       (&NOTSTAT).UUCT
UUCTRDNO EQU       UCTRDCNT
UUCTWRNO EQU       UCTWRCNT
UUCTPRNO EQU       UCTPRCNT
UUCTPWNO EQU       UCTPWCNT
UUCTNTNO EQU       UCTNTCNT
.UUCT    ANOP
UUCTSW   EQU       UCTSW
*        BIT       PURPOSE
*        0         ON FOR READING, OFF FOR WRITTING
UUCTDCB  EQU       UCTDCB          ADDRESS OF DCB FOR THIS UTILITY
UUCTLTH  EQU       UCTLNGTH
         EJECT
***********************************************************************
*        DSECT DESCRIPTIONS OF TABLES
*
*        THIS DSECT DESCRIBES A RECORD CONTROL LIST ENTRY
*
RCL      DSECT
RCLFLAG  DC        X'00'
*        BITS 0 TO 5 ARE COUNT OF NUMBER OF TIMES RECORD IS READ OR    X
                   SPILLED IN.
*        BIT 6     ON IF RECORD ON DISK
*        BIT 7      ON IF RECORD NOT IN CORE
RCLNOTE  DC        AL3(0)          IF RECORD IN CORE THIS CONTAINS     X
                                   POINTER TO RCP, OTHERWISE IS TTR
RCLPT    EQU       RCL             USED FOR FULL WORD OPERATIONS ON    X
                                   RCLFLAG AND RCLNOTE
*        THE RCL GROWS DOWNWARDS IN CORE
*        THE BOTTOM CAN GROW DOWNWARDS (SEE RCLGROW) BUT THE LIST CAN  X
                   NEVER BECOME SHORTER AGAIN
*        THE WHOLE LIST CAN BE RELOCATED UPWARDS IF A GROW UP IS DONE
*        THE RCL ENTRIES FOR THE DIFFERENT UTILITIES ALTERNATE
*        I.E.      UT1 R1
*                  UT2 R1
*                  UT3 R1
*                  UT1 R2
*                  UT2 R2
*                  UT3 R2
*                   ETC
*
*        TOTAL LENGTH OF RCL ENTRY = 1F = 4 BYTES
         EJECT
*        THIS DSECT DESCRIBES THE CORE MANAGEMENT LIST ENTRIES
*
CML      DSECT
CMLFLAG  DC        X'00'
*        =M        I/O RECORD
*        =M0       FREE CORE
*        =M1       RCL SPACE OR TOP OF MY MEMORY IF NO RCL
*        =N        END OF LIST (CORELIST)
         DC        AL3(0)          CHAIN DOWN TO NEXT CML
CMLPTDWN EQU       CML             USED FOR FULL WORD OPERATIONS ON    X
                                   CMLFLAG AND DOWN CHAIN POINTER
CMLPTUP  DC        F'0'            CHAIN UP TO NEXT CML
*
*        TOTAL LENGTH OF CML = 1D = 8 BYTES
         EJECT
*        THIS DSECT DESCRIBES THE RECORD CONTROL PREFIX
*
RCP      DSECT
         DC        D'0'            CML ENTRY
RCPRL    DC        H'0'            LENGTH OF RECORD
RCPNOTE  DC        3X'00'          TTR OF NOTE
         DC        AL3(0)          POINTER BACK TO RCL
RCPPT    EQU       *-4             FULL WORD ADDRESSING OF ABOVE
RCPDATA  DC        0D'0'           DATA RECORD FOLLOWS
*
*        TOTAL LENGTH OF RCP = 2D = 16 BYTES
         EJECT
*        THIS DSECT DESCRIBES THE FREE CORE PREFIX
*
FCP      DSECT
         DC        D'0'            CML ENTRY
FCPPTDWN DC        F'0'            CHAIN DOWN TO NEXT FCP
FCPPTUP  DC        F'0'            CHAIN UP TO NEXT FCP
*
*        TOTAL LENGTH OF FCP = 2D = 16 BYTES
         EJECT
*        THIS DSECT DESCRIBES THE DCB
*
DCB      DSECT
DCBDEVT  EQU       DCB+17          DEVICE TYPE
DCBTRBAL EQU       DCB+18              TRACK BALANCE AFTER WRITE
DCBOFLGS EQU       DCB+48              OPEN FLAGS
*./      DELETE    SEQ1=43680020,SEQ2=43880020
         EJECT
***********************************************************************
*        AND NOW FOR MY LAST ACT...
*
*
*
         END       ASMGBUFF
./ ADD NAME=ASMGFD
FD       TITLE     'ASMG     DIAGNOSTIC PROCESSOR'
         ISEQ  73,78
         SPACE 3
*./      DELETE    SEQ1=00080020,SEQ2=00760020
         COPY      ASMGSET
ASMGFD   START
         PRINT      NOGEN
         FDIMEN
         PRINT GEN
         SPACE 2
*TITLE 'ASMGFD' ...  DIAGNOSTIC PROCESSOR                             *
*FUNCTION/OPERATION-                                                  *
*  ASMGFD LISTS ALL THE ERROR NUMBERS AND THEIR ASSOCIATED ERROR      *
*   MESSAGE. IT PRINTS OUT THE NUMBER OF STATEMENTS FLAGGED,          *
*   AND HIGHEST SEVERITY CODE.                                        *
*ENTRY POINTS- ASMGFD  CALLED VIA-                                    *
*        L     GR15,=V(ASMGFD)                                        *
*        BR    GR15                                                   *
*INPUT- ERROR RECORDS TYPE 0, THE FORMAT IS-                          *
*        BYTE       CONTENTS                                          *
*         0-1       LENGTH OF RECORD                                  *
*          2        TYPE RECORD  (ALWAYS 0)                           *
*          3        NUMBER OF ERRORS (MAXIMUM OF 16)                  *
*         4-5       STATEMENT NUMBER                                  *
*         6-7       ERROR                                             *
*               6        ERROR NUMBER                                 *
*               7        COLUMN POINTER (ZERO IF NO POINTER)          *
*         8-37      REST OF THE ERRORS                                *
*OUTPUT- ERROR MESSAGE, NUMBER OF STATEMENTS FLAGGED MESSAGE, HIGHEST *
*        SEVERITY MESSAGE, CARDS READ AND LINES PRINTED MESSAGES.
*EXTERNAL ROUTINES- NONE                                              *
*EXITS- RETURNS TO ASMGRTA VIA-                                       *
*        L     GR14,CTMRSRTN(,ACT)
*        BR    GR14                                                   *
*TABLES/WORKAREAS-                                                    *
*   PRSAVE     SAVE AREA FOR REGISTERS FOR SYSLSTD                    *
*   HEDN       FIRST HEADING LINE                                     *
*   HEDR       SECOND HEADING LINE                                    *
*   SVMES      HIGHEST SEVERITY MESSAGE                               *
*   PCMSG      LINES PRINTED MESSAGE                                  *
*   ERCTM      STATEMENT FLAGGED MESSAGE                              *
*   BUFR       DETAIL OUTPUT BUFFER                                   *
*   ERRBUF     INPUT BUFFER AREA                                      *
*   ERRTAB     I/O CONTROL TABLE                                      *
*   IOSAVE     O/S SAVE AREA                                          *
*   PTRTBL     HALF WORDS OF RELATIVE POINTERS TO ERROR MESSAGES      *
*   E0001-E0117     ERROR MESSAGES                                    *
*              BYTE 0   LENGTH OF ERROR MESSAGE                       *
*              BYTE 1   SEVERITY CODE                                 *
*              BYTE 2   BEGINNING OF ERROR MESSAGE                    *
*                                                                     *
         EJECT
STMT     EQU   X'02'                    STATEMENT NUMBER OPTION
NUM      EQU   X'04'                    LINE NUMBER OPTION
TERM     EQU   X'08'                    TERM OPTION
ON       EQU   X'FF'                    NORMAL SWITCH SETTING
OFF      EQU   X'00'                    NORMAL SWITCH SETTING
GEN      EQU   C'+'                     A GENERATED LINE MARKER
L1F      EQU   1                        NUMBER OF BYTES TO MOVE
L2D      EQU   2                        NUMBER OF BYTES TO MOVE
L8C      EQU   8                        NUMBER OF BYTES TO MOVE
L3B      EQU   3                        NUMBER OF BYTES TO MOVE
MLG      EQU   120-1                    LENGTH OF BLANKING
MKF      EQU   X'10'                    MASK FOR SYSPRINT
L4C      EQU   4                        NUMBER OF BYTES TO COMPARE
L4D      EQU   4                        OFFSET IN AN AREA
L2E      EQU   2                        NUMBER OF BYTES TO COMPARE
L3H      EQU   3                        NUMBER OF BYTES TO MOVE
L16      EQU   16                       NUMBER OF BYTES TO MOVE
L7A      EQU   7                        OFFSET IN AN AREA
L102     EQU   102                      NUMBER OF BYTES TO MOVE
L111     EQU   111                      NUMBER OF BYTES TO MOVE
MKI      EQU   X'80'                    LAST RECORD MASK
L2F      EQU   2                        OFFSET IN AN AREA
L2G      EQU   2                        NUMBER OF BYTES TO MOVE
L1G      EQU   1                        OFFSET IN AN AREA
L119     EQU   119                      NUMBER OF BYTES TO MOVE
L120     EQU   120                      NUMBER OF BYTES TO MOVE
L121     EQU   121                      NUMBER OF BYTES TO MOVE
L2H      EQU   2                        OFFSET IN AN AREA
L5       EQU   5                        NUMBER OF BYTES TO MOVE
L81      EQU   81                       NUMBER OF BYTES TO MOVE
L8D      EQU   8                        NUMBER OF BYTES TO MOVE
L73      EQU   73                       NUMBER OF BYTES TO MOVE
*
GRH      EQU   13                       OS SAVE AREA POINTER
GR14     EQU   14                       GENERAL REGISTER 14
GR15     EQU   15                       GENERAL REGISTER 15
         SPACE 3
         LR    FRB,GRY                  TRANSFER ENTRY REG AS THE BASE
         USING ASMGFD,FRB               TELL THE ASSEMBLER WHICH BASE
         ENTRYOUT  FD,CSECT=GGECT
         MVC       HDECKID(8),CTITLE(ACT) MOVE DECK I.D. TO HEADER
         MVC       HDATE(9),CTDATE(ACT)   MOVE DATE INTO HEADER
         LA        GRA,1               LOAD ONE IN A REGISTER
         ST        GRA,YLCNT           INITIALIZE LINES FOR NEW PAGE
*
         L         GRA,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM
         TM        CTTRMI(ACT),TERM    IS TERM OPTION SPECIFIED .Q
         BZ        NODNEMES            NO, DON'T PRINT FINAL MESSAGE
MNO      DS        0H
         MVC       BUFR+1(L'TMSG),TMSG BUFFER AREA
         MVC       BUFR+L'TMSG+2(8),CTITLE(ACT)  ADD PROGRAM I.D.
         MVC       BUFR+30(8),L1PRTIME(GRA)  MOVE TIME TO HEADING LINE
         MVC       BUFR+41(9),L1PRDATE(GRA)  MOVE DATE TO HEADING LINE
         LA        SP1,BUFR            ADDR TO PUT
         BAL       SRR,SYSTRMD         ASSEMBLER (G) DONE MSG
*./      DELETE    SEQ1=01950025,SEQ2=01952025
         MVC       BUFR,L1BLANKS(GRA)  BLANK PRINT AREA
NODNEMES DS        0H                  GRA POINTS TO LIST1 IN ASMGASM
         LA        GRB,ESTART          POINT TO START OF ERRORS
         MVC       E0115-ESTART+1(1,GRB),L1UPCOND(GRA)  SET UPCOND SEV
         CLI       L1SYNERR(GRA),X'00' ANY ERROR SWITCHES ON .Q
         BZ        NOERSW              NO, BRANCH AROUND
         LA        GRB,X'80'           SET TO CHECK FIRST SWITCH
         LA        GRC,BRANCHES        ROUTINES FOR VARIOUS SWITCHES
TST      DS        0H
         TM        L1SYNERR(GRA),X'80'+*-*  TEST A SWITCH
         BCR       1,GRC        BOR    GO TO APPROPRIATE ROUTINE
         CLC       CTSEVCOD(1,ACT),SVCODE  HIGHEST SO FAR .Q
         BNL       BFBR                NO THEN SKIP IT
         MVC       CTSEVCOD(1,ACT),SVCODE  YES THEN REPLACE IT
         MVI       SVCODE,X'00'        RESET THE TEMP CODE
BFBR     DS        0H
         LA        GRC,4(,GRC)         SET TO NEXT ROUTINE
         SRA       GRB,1               NEXT SWITCH TO TEST
         STC       GRB,TST+1           IS PUT INTO CODING
         BNZ       TST                 BRANCH IF NOT LAST SWITCH TO TST
*
         MVI       TST+1,X'01'         RESTORE CODING
         LH        GRB,L1SYNERR(,GRA)  GET ERROR SWITCHES
         N         GRB,=X'00000801'    KEEP SOME, FORGET SOME
         XC        L1SYNERR(10,GRA),L1SYNERR(GRA)  ZERO SW AND COUNTERS
         STH       GRB,L1SYNERR(,GRA)  RESTORE AS REQUIRED
*./      DELETE    SEQ1=02280026,SEQ2=02300026
*./      DELETE    SEQ1=02320020,SEQ2=02400020
NOERSW   TM    F8YDC(ACT),X'FF'         REL Y-CONS ENCOUNTERED .Q
         BZ    ML00                     NO
         MVI   MLSW,X'FF'               YES, SET ERROR 58 OR 46
         LA    SP1,=AL1(0,0,0,1,0,0,46,0)    MESSAGE 46
         BAL   SP2,ML01S                PUT OUT MESSAGE 46
ML00     DS    0H
         LH    SP1,CTCERR(,ACT)         GET NUMBER OF ERROR RECORDS
         LTR   SP1,SP1                  WERE THERE ANY .Q
         BNZ   ML00A                    YES, THEN PROCESS
         L     SP1,CTLINECT(,ACT)       GET LINES LEFT ON THIS PAGE
         ST    SP1,YLCNT                AND SET IF FOR DIAGNOSTICS
         B     ML102                    GO ENDUP ASMGFD WITH STATS
*
ML00A    DS    0H
         L         GR1,BUFFPT(,ACT)    POINT AT FIRST ERROR RECORD
         MVC       ERRPT,CTRERR(ACT)   POINT ADDRESS
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(12,0)
ERRPT    DC        F'0'
ML00B    BAL   SP2,RDERR                GET OVERFLOW ERROR RECORD
ML01     L     SP2,ERRPTR               NEXT LOGICAL RECORD POINTER
         CLC   0(L4C,SP2),EOF           END OF DATA SET .Q
         BE    ML102                    YES, GO TERMINATE WITH STATS
         TM    CTTRMI(ACT),TERM         IS TERM OPTION ON .Q
         BZ    ML00E                    NO
         L     GR1,=V(ERRCDL)
         CLC   LSTMTN(L2E),L4D(GR1)     HAS STMT NUMBER CHANGED
         BE    ML00G                    NO, STILL SAME STATEMENT
         BAL   SP2,TREDIT               YES, PUT SOURCE STATEMENT
         B     ML00F                    CONTINUE
ML00G    BAL   SP2,TREDT                EDIT WITHOUT EXTRA SPACE
ML00F    L     GR1,=V(ERRCDL)           ERROR MESSAGE BUFFER ADDR
         ST    GR1,ERRPTR               REMEMBER IT
ML00E    BAL   SRR,GETERR               RETRIEVE AN ERROR RECORD
*
ML01A    MVC   SAVWD+2(2),4(SP1)        GET STATEMENT NUMBER
         CLC   LSTMTN(2),SAVWD+2        HAS STATEMENT NO. CHANGED
         BE    ML01B                    NO, GO PROCESS
         MVC   LSTMTN(2),SAVWD+2        SAVE NEW STATEMENT NUMBER
         L     GRX,ERCTR                STEP STATEMENTS IN ERROR
         LA    GRX,1(GRX)                COUNTER BY 1 AND SAVE FOR
         ST    GRX,ERCTR                LISTING
ML01B    LTR   GR1,GR1                  ERROR RECORD (ERLI=0) .Q
         BZ    ML07                     NO, GET NEXT BLOCK
         L         GRX,SAVWD           GET STATEMENT NUMBER
         LTR       GRX,GRX             IS STMT NO 0
         BZ        ML01S               DO NOT PRINT STMT NO IF SO
         BAL   SRR,CVTBTC               GO CONVERT NUMBER FOR LISTING
         MVC   STMNO(L5),WORD-1         MOVE STATEMENT NUMBER FOR PRINT
ML01S    EQU   *                        PRINT WITHOUT STNO
         MVC       ERCD(10),PRGTYP     MOVE PROGRAM TYPE TO MESSAGE
         SR    GRA,GRA                  ZERO REGISTER
         LA    GRB,ERM(SP1)             SET POINTER TO ERROR CODES
         IC    GRA,ERCT(SP1)            GET ERROR COUNT
         LTR   GRA,GRA                  IS COUNT ZERO
         BNZ   ML02                     NO, GO OUTPUT ERROR MESSAGES
         LA    GRA,1                    YES, SET ERROR COUNT TO 1
         LA    GRC,6                    SET ERROR CODE TO PROCEDURE ERR
         B     ML03                     SKIP GETTING ERROR CODE
ML02     SR    GRC,GRC
         IC    GRC,0(GRB)               GET ERROR CODE
ML03     MVC   MSGBG(112),MSGBG-1       BLANK PRINT BUFFER
         LR    GRX,GRC
         BAL   SRR,CVTBTC               GO CONVERT ERROR MESSAGE FOR
         OC    WORD(4),MASK             CHANGE BLANKS TO ZEROS
         MVC   ERNO(3),WORD+1           MOVE ERROR NUMBER TO PRINT
         LTR   GRC,GRC                  IS ERROR CODE ZERO
         BZ    ML031                    YES, BAD ERROR CODE
         BCTR  GRC,0                    REDUCE ERROR NUMBER BY 1
         AR        GRC,GRC             MULTIPLY BY 2
         LA    GRY,PTRTBL(GRC)          POINT TO TABLE
         LA    GRZ,ENDTBL               GET END OF TABLE LOCATION
         CR    GRY,GRZ                  IS NUMBER IN TABLE
         BL    ML04                     YES GO PUT MESSAGE
*
ML031    LH    GRD,ENDTBL               ERROR NUMBER NOT KNOWN
         LA    GRD,ESTART(GRD)          ERROR CODE
         LA    GRY,MSGBG                SET POINTER FOR MESSAGE MOVE
         B     ML05                     CONTINUE
ML04     LH    GRY,PTRTBL(GRC)          GET POINTER TO MESSAGE
         LA    GRD,ESTART(GRY)          SET POINTER TO MESSAGE
         LA    GRY,MSGBG                SET POINTER FOR MESSAGE MOVE
         CLI   1(GRB),0                 IS COLUMN POINTER ZERO
         BE    ML05                     YES, GO PUT MESSAGE
*
         SR    GRX,GRX                  NO, PUT OUT COLUMN POINTER
         IC    GRX,1(,GRB)              GET POINTER
         BAL   SRR,CVTBTC               GO CONVERT FOR LISTING
         MVC   MSGBG(25),PTRMSG         MOVE COLUMN POINTER MESSAGE
         MVC   MSGBG+20(3),WORD+1       MOVE COLUMN POINTER
         LA    GRY,25(,GRY)             STEP POINTER TO WHERE TO PUT
*                                       MESSAGE BY 20 BYTES
ML05     DS    0H
         IC    GRX,0(,GRD)              GET MOVE LENGTH-1 OF MESSAGE
         EX    GRX,MVMSG                MOVE MESSAGE TO BUFR
         SR    GRX,GRX                  PROCESS SEVERITY CODE.
         CLC   CTSEVCOD(1,ACT),1(GRD)   COMPARE SEVCODE OF CURRENT
         BNL   ML051                    MESSAGE TO HIGHEST CODE SO FAR
         MVC   CTSEVCOD(1,ACT),1(GRD)   ENCOUNTERED(INCLUDING MNOTE)
ML051    DS    0H
         LA    SP1,BUFR                 SET POINTER TO PRINT BUFFER
         BAL   SRR,WRLST                GO LIST MESSAGE
         MVC   DIAGSAVE,STMNO           SAVE STMTNO/ERR TYPE
         MVC   BUFR+2(9),ERCD           MOVE OVER ERROR NUMBER
         MVC   BUFR+11(112),MSGBG       AND ERROR TEXT
*                                       BECAUSE TERMINALS ARE SLOW
ML06     DS    0H
         BAL   SRR,SYSTRMD              GO LIST SYSTERM ERROR MSG
         MVC   STMNO(L'DIAGSAVE),DIAGSAVE  RESTORE STMTNO/ERR TYPE
         MVI   BUFR,X'00'               SET SINGLE SPACE
         TM    MLSW,X'FF'               IS THIS ERROR 58 OR 46
         BC    7,MLWW                   YES, BRANCH
         LA    GRB,2(GRB)               STEP POINTER TO NEXT ERROR CODE
         BCT   GRA,ML02                 BRANCH BACK IF MORE MESSAGES
ML07     DS    0H
         L     SP2,ACTERRPT
         TM    L2F(SP2),MKI             LAST RECORD BIT .Q
         BZ    ML01                     NO, RETRIEVE NEXT ERR RCD
         L     SP2,=V(TERLI)            YES, READ NEXT ERROR RCD
         ST    SP2,ERRPTR               AND SET NEW RECORD POINTER
         B     ML00B                    GO AND DO THE READ
MLWW     MVI   MLSW,X'0'                SET NOT ERROR 58 OR 46
         BR    SP2                      RETURN TO CALLER
ML102    DS    0H
         L     SP1,YLCNT                GET NUMBER OF LINES LEFT
         S     SP1,=F'11'               DECREMENT BY TRAILER LENGTH
         BP    ML103                    BRANCH IF STILL ROOM
         LA    SP1,1                    GET ONE IN A REGISTER
         ST    SP1,YLCNT                SET UP FOR A NEW PAGE
         MVC   HEAD2+2(50),HEAD2+1      BLANK SECOND HEADER INFO
ML103    DS    0H
*
*
*        PRINT ERROR SUMMARY RECORDS
*
ML10     DS        0H
         L         GR2,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM
         MVC       BUFR,L1BLANKS(GR2)  BLANK SYSPRINT BUFFER
         L         GRX,ERCTR           GET NUMBER OF ERROR RECORDS
         LTR       GRX,GRX             WERE THERE ANY ERRORS
         BNZ       ML101               BRANCH IF YES
         MVC       BUFR(39),ERCTM+2    'NO STATEMENTS FLAGGED'
         MVC       BUFR(3),CAC         'NO'
         B         ML112               GO AND PRINT IT
ML101    DS        0H
         MVC       BUFR(42),ERCTM-1    ENTER STMTS FLAGGED MESSAGE
         BCT       GRX,ML101A          TEST FOR ONLY 1 ERROR RECORD
         MVC       BUFR+16(27),BUFR+17 BLANK 'S' ON 'STATEMENTS'
ML101A   DS        0H
         LA        GRX,1(,GRX)         RESTORE STMTS FLAGGED
         BAL       SRR,CVTBTC          CONVERT ERROR COUNT
         MVC       BUFR+2(4),WORD      FOR LISTING MESSAGE
ML112    DS        0H
         LA        SP1,BUFR            GET MESSAGE LOCATION
         BAL       SRR,WRLST           PRINT NUMBER OF ERRORS
         BAL       SRR,TBLANK          LEAVE A LINE ON SYSTERM
         BAL       SRR,SYSTRMD         SYSTERM NUMBER OF ERRORS
*
ML100    DS        0H
         IC        GRX,CTSEVCOD(,ACT)  GET SEVERITY CODE
         LTR       GRX,GRX             IS IT ZERO .Q
         BZ        ZSVCD               IF SO, DON'T PRINT SEV CODE
         BAL       SRR,CVTBTC          CONVERT TO DECIMAL
         MVC       BUFR(42),SVMES      MOVE SEVERITY MESSAGE
         MVC       BUFR+32(10),L1BLANKS+1(GR2)  BLANK PART OF RECORD
         MVC       BUFR+3(3),WORD+1    PUT IN SEVERITY CODE
         LA        SP1,BUFR            POINT TO MESSAGE
         BAL       SRR,WRLST           PRINT SEVERITY MESSAGE
         BAL       SRR,SYSTRMD         SYSTERM SEVERITY MESSAGE
ZSVCD    DS        0H
*
*        PRINT OUT CARDS READ/LINES OUTPUT STATISTICS
*
         MVI       BUFR,X'03'          LEAVE THREE LINES AGAIN
STATLOP1 DS        0H
         SR        GRA,GRA             ZERO OFFSET IN DCB ADDR LIST
         MVC       BUFR+1(L'BUFR-1),L1BLANKS+1(GR2)  BLANK OUTPUT LINE
         LA        SP1,BUFR            POINT TO OUTPUT LINE
STATLOP2 DS        0H
         L         GR1,L1DCBADS(GRA,GR2)  GET ADDRESS OF NEXT DCB
TYPESW   TM        L1DCBPAD(GR1),X'01'+*-*  IS IT TYPE WE WANT .Q
         BZ        STATLOP3            BRANCH IF NOT
         L         GRX,L1DCBRCT(,GR1)  GET NUMBER OF RECORDS
         LTR       GRX,GRX             IS IT ZERO .Q
         BZ        STATLOP3            BRANCH IF SO
         BAL       SRR,CVTBTC          CONVERT TO CHARACTER
         SR        GRX,GRX             ZERO A REGISTER
         ST        GRX,L1DCBRCT(,GR1)  ZERO RECORD COUNT
         MVC       1(5,SP1),WORD-1     MOVE IN COUNT
         LA        GRB,L1DDNAM(GRA,GRA)  GET DDNAME OFFSET IN LIST1
         AR        GRB,GR2             POINT TO DDNAME
         MVC       7(8,SP1),0(GRB)     ADD DDNAME
         LA        SP1,14(SP1)         BUMP TO END OF DDNAME
DDNAMLOP DS        0H
         CLI       0(SP1),BLANK        IS THIS THE END .Q
         BNE       DDNAMOUT            BRANCH IF YES
         BCT       SP1,DDNAMLOP        DECREMENT AND BRANCH
DDNAMOUT DS        0H
         MVC       2(L'RECMESS,SP1),RECMESS  ADD TEXT
         LA        SP1,L'RECMESS+2(,SP1)  NEW END OF STRING
         MVI       0(SP1),C','         FOLLOWED BY A COMMA
STATLOP3 DS        0H
         LA        GRA,4(,GRA)         POINT TO NEXT DCB IN LIST
         LTR       GR1,GR1             AT END OF DCB LIST .Q
         BP        STATLOP2            BRANCH IF NOT
         MVI       0(SP1),C' '         BLANK LAST COMMA
         LA        SP1,BUFR            LINE TO PRINT
         BAL       SRR,WRLST           GO PRINT IT
         TM        TYPESW+1,X'02'      HAVE WE DONE OUTPUT .Q
         BO        STATEND             BRANCH IF YES
         MVI       TYPESW+1,X'02'      DO OUTPUT RECORDS NOW
         MVC       RECMESS(6),=C'OUTPUT'  CHANGE MESSAGE TEXT
         MVI       BUFR,X'00'          SINGLE SPACE
         B         STATLOP1            DO IT AGAIN
STATEND  DS        0H
*
*        DO WE GO TO ASMGFEX .Q
*
TESTFEX  DS        0H
         TM        L1PBYT2(GR2),X'20'  EXECUTE OPTION SPECIFIED .Q
         BZ        RETFEX              NO, GO AROUND BRANCH TO FEX
         L         GR1,LSTDCB(,ACT)    POINT TO SYSPRINT DCB
         OI        L1DCBCC(GR1),X'C0'  SET ASA CARRIAGE CONTROL FOR FEX
         ST        FRB,PRSAVE          SAVE BASE REGISTER
         L         GR2,=V(ASMGFEX)     ENTRY TO FEX
         BALR      GR14,GR2            BRANCH TO FEX WITH RETURN
         SPACE     2
*
         USING     *,GR14              GR14 LOADED WITH * BY FEX
         L         FRB,PRSAVE          RESTORE BASE REGISTER
         DROP      GR14
RETFEX   DS    0H
         LA    GRH,IOSAVE               SET UP OS SAVE AREA
         L     GR1,LSTDCB(,ACT)         POINT TO SYSPRINT DCB
         NI    L1DCBCC(GR1),X'7F'       TURN OF ASA INDICATION
         OI    L1DCBCC(GR1),X'40'       TURN ON NUMERIC INDICATOR
         SR    GR0,GR0                  ZERO A WORK REGISTER
         ST    GR0,L1DCBRCT(,GR1)       ZERO SYSPRINT RECORD COUNT
         B     ARND                     CLOSE PHASE
CVTBTC   DS    0H
         CVD   GRX,CVDA                 CONVERT BINARY TO DECIMAL
         MVC   WORD-2(6),=X'402020202120'  EDIT MASK WITH BLANKS
         ED    WORD-2(6),CVDA+5         EDIT IN THE NUMBER
         BR    SRR                      AND RETURN
*./      DELETE    SEQ1=05160020,SEQ2=05260020
*
GETERR   L     SP2,ERRPTR               LOGICAL RECORD PTR
         ST    SP2,ACTERRPT             SAVE LOGICAL RECORD POINTER
         MVC   ERLI(L2G),0(SP2)         RETRIEVE RLI
*./      DELETE    SEQ1=05360020,SEQ2=05500020
         LH    GR1,ERLI
         LR    GR2,SP2                  SAVE REC PTR
       AR      GR2,GR1                  ADVANCE TO NEXT RECORD
         ST    GR2,ERRPTR               RESTORE PTR
         LR    SP1,SP2                  SET POINTER TO ERROR RECORD
         BR    SRR                      EXIT
*./      DELETE    SEQ1=05640020,SEQ2=05720020
ERRPTR   DC    V(TERLI)                 LOGICAL RECORD POINTER
ACTERRPT DC    F'0'                     ACTUAL LOGICAL RECORD POINTER
EOF      DC    4X'7F'                   EOF INDICATOR
ERLI     DC    H'0'                     LENGTH OF RECORD
DIAGSAVE DC    CL20' '                  STMT NUMBER SAVE AREA
         SPACE     3
ARND     L         GR1,BUFFPT(0,ACT)   TCLOSE SYSUT1
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(24,0,1)
         SR        GR15,GR15
         IC        GR15,CTSEVCOD(ACT)  RC  =  HIGHEST SEVCODE
         L         GR2,ADLIST1(,ACT)   GET ADDRESS OF LIST1 IN ASM
         C         GR15,L1SAVECC(,GR2) IS THIS HIGHEST CC SO FAR
         BNH       *+8                 NO, PROCEED
         ST        GR15,L1SAVECC(,GR2) YES, SAVE HIGHEST SO FAR
         TM        L1PBYT1(GR2),X'10'  IS BATCH ON .Q
         BO        CHECKEX             YES, CHECK FOR EXECUTE
         TM        L1SINSW(GR2),X'80'  HAVE WE HIT END OF FILE .Q
         BO        RETURN              YES, THEN WE'RE DONE
         MVI       BUFR+1,BLANK        INSERT A BLANK
         MVC       BUFR+2(L'BUFR-2),BUFR+1  AND MOVE IT ACROSS
         MVC       BUFF+1(L'MSUNPROC),MSUNPROC  TEXT OF ERROR MESSAGE
         MVC       BUFF+23(8),L1DDNAM+2*L1SIN(GR2)   PLACE SYSIN DDNAME
         MVC       BUFF+39(8),L1DDNAM+2*L1SUP(GR2)   AND SYSUP DDNAME
         TM        L1PBYT2(GR2),X'40'  WAS UPDATE SPECIFIED .Q
         BO        TWOFILES            BRANCH IF YES
         MVI       BUFF+7,C'5'         CHANGE TO ASMG205
         MVC       BUFF+32(30),BUFF+48 BLANK SYSUP INFORMATION
TWOFILES DS        0H
         MVC       HEAD2+1(30),HEAD2+31        BLANK SECOND HEADER
         MVI       BUFF,X'03'          TRIPLE SPACE
         LA        SP1,BUFF            POINT TO OUTPUT LINE
         BAL       SRR,WRLST           GO LIST FINAL MESSAGE
         MVI       BUFF,X'00'          PREPARE FOR SYSTERM
         BAL       SRR,TBLANK          LEAVE A LINE
         BAL       SRR,SYSTRMD         AND PRINT THE UNPROCESSED ERROR
         B         RETURN              THAT'S ALL
CHECKEX  TM        L1PBYT2(GR2),X'20'  IS EXECUTE ON .Q
         BNO       SAVESUM             NO, SAVE SUMMARY OF ASSEMBLY
         L         SRR,L1DCBADS+L1SIN(,GR2)  ADDRESS OF SYSIN DCB
         MVC       DCBEODAD+1(3,SRR),=AL3(EOFTEST) SET EODAD EXIT
         MVC       DCBGET+1(3,SRR),L1SINAD+1(GR2)  RE-FAKE GET ADDRESS
         LA        SP1,BUFF+1          GET CARD IN BUFFER AREA
FLUSH    GET       (SRR),(SP1)         READ A CARD
         B         FLUSH               READ UNTIL EODAD IS TAKEN
EOFTEST  CLI       L1SINSW(GR2),X'80'  TEST REAL EOF SWITCH
         BE        RETURN              THAT'S ALL
GOAGAIN  DS        0H
         LA        SP1,X'FF'           SET BATCH SWITCH FOR RTA
         LR        SRR,GR2             ADDRESS OF LIST1 IN R9
         LA        GR2,L1BLDL+1*L1LENBL(,GR2)  ADDR OF F1 IN BLDL TABLE
         B         RETURN1             GO AND TERMINATE
*
*        SAVE BATCH SUMMARY INFORMATION
SAVESUM  L         GR1,BUFFPT(,ACT)    ADDRESS OF ASMGBUFF
         CNOP      2,4                 ALIGN PARAMETERS
         BALR      GR0,GR1             BRANCH TO SHRINK
         DC        F'36'               MEANS A SHRINK OF BUFF SPACE
         DC        F'16'               I NEED BATCH WORK BUFFER
SHADR    DC        F'0'                BUFF WILL FILL THIS IN
*        MUST BE 8 BYTES SINCE FPP DID A GROW ON SYMBOL TABLE
*
         L         GR1,SHADR           ADDRESS OF CORE WE GOT
         L         GRA,L1BTCSUM(,GR2)  GET FIRST BATCH SUMMARY ADDRESS
         LTR       GRA,GRA             FIRST PROGRAM IN BATCH .Q
         BNZ       *+8                 NO, THEN BRANCH AROUND
         ST        GR1,L1BTCSUM(,GR2)  REMEMBER 1ST 8 BYTES IN CHAIN
         MVI       0(GR1),X'00'        THIS MAY NOT BE LAST ASSEMBLY
         STC       GR15,1(,GR1)        SEVERITY CODE OF THIS PROGRAM
         MVC       2(2,GR1),ERCTR+2    NUMBER OF STMTS FLAGGED
         MVC       8(8,GR1),CTITLE(ACT)  PROGRAM I.D.
         TM        L1SINSW(GR2),X'80'  ARE WE AT EOF .Q
         BNO       GOAGAIN             NO, SET XCTL FOR RTA
*
*        NOW PRINT THE BATCH SUMMARY
         MVI       0(GR1),X'FF'        MARKS THE LAST ASSEMBLY
         L         GRB,L1BTCSUM(,GR2)  ADDRESS OF FIRST BATCH ENTRY
         CLI       0(GRB),X'FF'        IS FIRST THE LAST .Q
         BE        RETURN              YES, SUMMARY IS THEN USELESS
         SR        GRA,GRA             ZERO A REGISTER
         ST        GRA,L1PAGENO(,GR2)  ZERO PAGE COUNT
         LA        GRA,1               ONE IN A REGISTER
         ST        GRA,YLCNT           INITIALIZE LINES FOR NEW PAGE
         MVI       HEAD1+1,BLANK       INSERT A BLANK INTO HEADER
         MVC       HEAD1+2(100),HEAD1+1  AND MOVE IT THROUGH
         MVC       HEAD1+23(14),BSUMMARY SET UP 1ST HEADING
         MVC       HEAD2+1(59),=C'DECK NUMBER  DECK I.D.  SEVERITY CODEX
                 NUMBER STMTS FLAGGED'
         MVI       BUFF+1,BLANK        INSERT A BLANK
         MVC       BUFF+2(119),BUFF+1  AND PROPAGATE IT
         SR        GRD,GRD             ZERO TOTAL ERROR COUNT
         SR        GRC,GRC             ZERO FOR DECK NUMBER
NEXTPGM  LA        GRC,1(,GRC)         INCREMENT DECK NUMBER
         LR        GRX,GRC             TRANSFER DECK NUMBER
         BAL       SRR,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+3(4),WORD      MOVE INTO PRINT LINE
         MVC       BUFF+15(8),8(GRB)   MOVE IN PROGRAM I.D.
         IC        GRX,1(GRB)          INSERT SEVERITY CODE
         BAL       SRR,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+30(4),WORD     MOVE INTO PRINT LINE
         LH        GRX,2(GRB)          GET NUMBER OF STMTS FLAGGED
         AR        GRD,GRX             INCREASE TOTAL ERROR COUNT
         BAL       SRR,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+46(4),WORD     MOVE INTO PRINT LINE
         LA        SP1,BUFF            POINT TO PRINT LINE
         BAL       SRR,WRLST           PRINT INFORMATION LINE
         CLI       0(GRB),X'FF'        IS THIS THE END .Q
         BE        TESTMESS            YES, MAKE UP FIRST MESSAGE
         LA        GRB,16(,GRB)        POINT TO NEXT SUMMARY
         B         NEXTPGM             DO NEXT PROGRAM IN BATCH
*
*        OUTPUT NO STATEMENTS FLAGGED MESSAGE
TESTMESS MVI       BUFF,X'02'          LEAVE 2 LINES
         LTR       GRD,GRD             WERE NO STATEMENTS FLAGGED .Q
         BNZ       TWOMESS             NO, MAKE UP TWO MESSAGES
         MVC       BUFF+1(38),ERCTM+3  MOVE IN MESSAGE
         MVC       BUFF+1(2),CAC+1     MOVE IN 'NO'
         MVC       BUFF+31(6),BSUMMARY CHANGE MESSAGE
         MVC       BUFF+37(20),BUFF+36 BLANK THE REST OF THE LINE
         B         LASTMESS            THAT'S ALL HERE
*
*        NUMBER FLAGGED AND SEVERITY CODE
TWOMESS  LR        GRX,GRD             NUMBER OF STATEMENTS FLAGGED
         BAL       SRR,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+1(41),ERCTM    MOVE IN MESSAGE
         MVC       BUFF+34(6),BSUMMARY CHANGE MESSAGE
         MVC       BUFF+40(20),BUFF+39 BLANK REST OF LINE
         BCT       GRD,*+8             ONLY ONE ERROR .Q
         MVI       BUFF+16,X'40'       REMOVE 'S'
         MVC       BUFF+2(4),WORD      MOVE IN NUMBER
         LA        SP1,BUFF            POINT TO OUTPUT LINE
         BAL       SRR,WRLST           AND PRINT IT
         MVI       BUFF,X'00'          DON'T SKIP LINE
         MVC       BUFF+1(40),SVMES+1  MOVE IN SEVERITY MESSAGE
         L         GRX,L1SAVECC(,GR2)  GET HIGHEST SEVERITY CODE
         BAL       SRR,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+2(4),WORD      MOVE IN NUMBER
LASTMESS DS        0H
         LA        SP1,BUFF            POINT TO MESSAGE
         BAL       SRR,WRLST           AND PRINT IT
RETURN   DS        0H
         SR        SP1,SP1             RETURN TO ASMGASM VIA RTA
RETURN1  DS        0H
         L         GR14,CTMRSRTN(,ACT) GET RETURN ADDRESS
         BR        GR14                RETURN TO RTA
*
BRANCHES EQU       *                   ROUTINES
         B         AE20416   0
         B         AE204     1
         B         AE207     2
         B         AE206     3
         B         AE208     4         IN CORE MACRO DIR EXCEEDED
         B         AE209     5         THIS MANY FINDS RESULTED
         B         AE203     6
         B         BFBR      7
         SPACE     2
AE203    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
         MVC       BUFR+20(21),=C'ILLEGAL DCB OPERANDS.'
         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'
         LA        GRD,C'3'            ASMG203
         B         ASMGDDDI
AE204    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
AE204B   MVC       BUFR+20(21),=C'UNOPENABLE DATA SETS.'
         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'
         LA        GRD,C'4'            ASMG204
         B         ASMGDDDI
AE20416  MVI       SVCODE,X'10'        SEVERITY CODE OF 16
         NI        L1SYNERR(GRA),X'FF'-X'40'  SKIP 204 SEV 4 TEST
         B         AE204B              OTHERWISE SAME AS OTHER 204
AE206    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
         LA        GRD,C'6'            ASMG206
         MVC       BUFR+39(8),L1DDNAM+2*L1SPRINT(GRA)  SYSPRINT DDNAME
         LH        GRH,L1IOERR+2(,GRA) GET NUMBER OF SYSPRINT ERRORS
         B         MSG67
AE207    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
         LA        GRD,C'7'            ASMG207
         MVC       BUFR+39(8),L1DDNAM+2*L1SPUNCH(GRA)  SYSPUNCH DDNAME
         LH        GRH,L1IOERR(,GRA)   GET NUMBER OF SYSPUNCH ERRORS
         B         MSG67
AE208    DS        0H
         MVC       BUFR+20(34),=C'MORE THAN****** MACROS ON LIBRARY.'
         L         SP1,L1TOPMC(,GRA)   GET ADDR OF TOP OF MACRO TABLE
         S         SP1,L1BOTMC(,GRA)   LESS THE BOTTOM
         SRDA      SP1,32              SET FOR A DIVIDE
         D         SP1,=F'11'          DIVIDE BY EACH ENTRY LENGTH
         BCTR      SP2,0               LESS THE END DUMMY ENTRY
         CVD       SP2,CVDA            CONVERT TO DECIMAL
         MVC       BUFR+29(6),=X'402020202020'  ADD MASK
         ED        BUFR+29(6),CVDA+5   EDIT IN NUMBER OF MACROS
         LA        GRD,C'8'            ASMG208
         B         ASMGDDDI            GO DO IT
AE209    DS        0H
         MVC       BUFR+25(40),=C'LIBRARY FINDS DONE TO COMPLETE ASSEMB*
               LY.'
         L         GRH,L1FINDCT(,GRA)  GET NUMBER OF FINDS DONE
         CVD       GRH,CVDA            CONVERT TO DECIMAL
         BCT       GRH,*+8             ONLY 1 FIND .Q
         MVI       BUFR+37,BLANK       BLANK THE 'S'
         MVC       BUFR+18(6),=X'402020202020'  ADD MASK
         ED        BUFR+18(6),CVDA+5   EDIT IN THE COUNT
         LA        GRD,C'9'            ASMG209
         B         ASMGDDDI            GO DO IT
MSG67    MVC       BUFR+25(13),=C'I/O ERRORS ON'
         CVD       GRH,CVDA            CONVERT NUMBER TO DECIMAL
         BCT       GRH,*+8             ONLY 1 ERROR .Q
         MVI       BUFR+34,BLANK       YES, BLANK 'S' ON 'ERRORS'
*./      DELETE    SEQ1=06660020,SEQ2=06660020
         MVC       BUFR+18(6),=X'402020202020'
         ED        BUFR+18(6),CVDA+5
         LA        GRH,BUFR+39         POINT TO DDNAME
BLKSAD   LA        GRH,1(GRH)          ADVANCE 1 CHARACTER
         CLI       0(GRH),C' '         END OF DDNAME?
         BNE       BLKSAD              NO, CONTINUE LOOKING
         MVI       0(GRH),C'.'         YES, PUT IN PERIOD
ASMGDDDI DS        0H
         MVC       BUFR+9(10),PRGTYP
         STC       GRD,BUFR+15         PUT IN LAST DIGIT
         LA        SP1,BUFR
         BAL       SRR,WRLST           GO LIST ERROR
         MVC       CTLINECT(4,ACT),YLCNT  UPDATE LINES LEFT ON PAGE
         MVI       BUFR,X'00'          SET UP FOR SYSTERM
         BAL       SRR,SYSTRMD         GO PRINT ERROR ON SYSTERM
         BAL       SRR,TBLANK          AND LEAVE A BLANK LINE
         MVC       BUFR(L'BUFR),L1BLANKS(GRA)  RESET CARR CONT AND LINE
         B         BFBR                TEST NEXT SWITCH
***********************************************************************
*        WRITE RECORDS ON SYSLST
***********************************************************************
WRLST    STM       GR0,GR15,PRSAVE     SAVE ALL REGISTERS
         L         GR2,YLCNT           CURRENT LINE COUNT
         BCT       GR2,WRLINE          AT BOTTOM OF PAGE .Q
         L         SRR,ADLIST1(,ACT)   YES, POINT TO LIST1 IN ASMGASM
         L         GRX,L1PAGENO(,SRR)  GET CURRENT PAGE NUMBER
         LA        GRX,1(,GRX)         INCREMENT BY ONE
         ST        GRX,L1PAGENO(,SRR)  UPDATE CURRENT PAGE NUMBER
         BAL       SRR,CVTBTC          CONVERT TO CHARACTER
         MVC       HPAGENO(4),WORD     MOVE TO HEADER LINE
         LA        GR2,HEAD1           POINT TO FIRST HEADER
         BAL       SRR,SYSL            PRINT IT
         LA        GR2,HEAD2           POINT TO SECOND HEADER
         BAL       SRR,SYSL            PRINT IT
         MVI       BUFF,X'01'          LEAVE A LINE NEXT TIME
         SR        GR2,GR2             ZERO A REGISTER
         IC        GR2,CTPGLNCT(,ACT)  RESTORE LINE COUNT PER PAGE
WRLINE   ST        GR2,YLCNT           SAVE NEW LINES LEFT
         LR        GR2,SP1             POINT TO LINE TO BE OUTPUT
         BAL       SRR,SYSL            PRINT IT
         MVI       BUFF,X'00'          RESET SPACE OPERAND
         LM        GR0,GR15,PRSAVE     RESTORE ALL REGISTERS
         BR        SRR                 RETURN
***********************************************************************
*        SYSTEM LIST SUBROUTINE
***********************************************************************
SYSL     DS        0H
         LA        GRZ,IOSAVE          O/S SAVE AREA
         L         GR1,LSTDCB(,ACT)    GET SYSPRINT DCB ADDRESS
         PUT       (1),(GR2)           PRINT THE LINE
         BR        SRR                 AND RETURN
*./      DELETE    SEQ1=07580025,SEQ2=08200025
         EJECT
*
*
*        SYSTERM OUTPUT LISTING VIA SYSTERM
*
SYSTRMD  TM    CTTRMI(ACT),TERM         IS TERM OPTION ON .Q
         BCR   8,SRR                    NO, THEN EXIT
         STM   GR0,GR15,PRSAVE          SAVE ALL REGISTERS
SYSTRMD1 L     GR2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM
         LA    GRH,IOSAVE               OS SAVE AREA POINTER
         L     GRA,L1TRSAVE(,GR2)       RESTORE PAST LINE DATA
         BCT   GRA,SYSTRA               TEST FOR NO EJECT
         MVI   0(SP1),X'FF'             SKIP TO A NEW PAGE
         SR    GRA,GRA                  ZERO A REGISTER
         IC    GRA,CTPGLNCT(,ACT)       GET LINE COUNT PER PAGE
SYSTRA   L     GR1,L1DCBADS+L1STERM(,GR2)  SYSTERM DCB ADDRESS
         ST    GRA,L1TRSAVE(,GR2)       RESTORE LINES LEFT
         PUT   (1),(SP1)                PUT A LINE
         MVI   0(SP1),X'00'             RESET CARRIAGE CONTROL
*./      DELETE    SEQ1=08351025,SEQ2=08359025
         LM    GR0,GR15,PRSAVE          RESTORE REGISTERS
         BR    SRR                      AND RETURN
         SPACE 2
*
*        BLANK LINE ON SYSTERM
*
TBLANK   TM    CTTRMI(ACT),TERM         IS TERM OPTION ON .Q
         BCR   8,SRR                    NO, THEN EXIT IMMEDIATELY
         STM   GR0,GR15,PRSAVE          SAVE REGISTERS
         L     GR2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM
         LA    SP1,L1BLANKS(,GR2)       POINT TO X'00'.BLANKS
         B     SYSTRMD1                 GO AND PRINT IT
         SPACE 2
*
*        THIS ROUTINE REARRANGES SOURCE DATA FOR SYSTERM, IF TERM
*
ZERX     EQU   X'F0'
BLANK    EQU   X'40'
         SPACE 1
TREDIT   BAL   SRR,TBLANK               MAKE A BLANK LINE
TREDT    L     GR2,VERRBUF              GET UT1 BUFFER ADDRESS
         CLC   L1G(L4C,GR2),EOF         IS IT END OF DATA SET .Q
         BNE   TREDE                    NO, GO ON
         SR    SP1,SP1                  NO MORE DATA TO PROCESS
         B     ML102                    AND QUIT
TREDE    MVI   LINENO,BLANK             INSERT A BLANK IN OUTPUT AREA
         MVC   LINENO+1(L'BUFR-2),LINENO  AND PUSH IT THROUGH
         USING TYPE,GR2
         SR    GR1,GR1                  ZERO A REGISTER
         IC    GR1,TRLI                 GET ONE BYTE OF LENGTH
         SLL   GR1,8                    SHIFT ONE BYTE LEFT
         IC    GR1,TRLI+1               GET REST OF LENGTH
         LTR   GR1,GR1                  RECORD WITH ONLY ERROR MSGS
         BCR   8,SP2                    YES, EXIT (TRLI EQ ZERO)
         LA    GR2,3(,GR2)              POINT TO FIRST SOURCE STMT
         USING INPUT,GR2
TREDA    TM    CTNUMI(ACT),NUM          IS NUM OPTION REQUIRED .Q
         BO    TREDB                    YES, MOVE LINENO
         TM    CTSTMI(ACT),STMT         IS STMT OPTION REQUIRED .Q
         BZ    TREDAA                   NO, SKIP STATEMENT NUMBER
         MVC   OUTPUT+1(L5),ISTMT       STATEMENT NUMBER
         MVC   OUTPUT+8(L81),IGEN       GEN / SOURCE RECORD
         B     TREDD
TREDAA   MVC   OUTPUT+1(L81),IGEN       GEN / SOURCE RECORD
         B     TREDD
*
TREDB    DS    0H
         MVC   OUTPUT+1(L8D),ILINE      LINE NUMBER
TREDF    TM    CTSTMI(ACT),STMT         IS STMT OPTION REQUIRED .Q
         BO    TREDH                    YES, STMT TO OUTPUT
*./      DELETE    SEQ1=08418025,SEQ2=08424025
TREDG    MVC   OUTPUT+10(L73),IGEN      GEN / SOURCE RECORD
         B     TREDD
TREDH    MVC   OUTPUT+11(L5),ISTMT      STATEMENT NUMBER
*./      DELETE    SEQ1=08432025,SEQ2=08438025
TREDK    MVC   OUTPUT+17(L73),IGEN      GEN / SOURCE RECORD
         SPACE 1
TREDD    LA    SP1,OUTPUT               ADDRESS OF OUTPUT AREA
         BAL   SRR,SYSTRMD              PUT A LINE
         MVI   LINENO,BLANK             BLANK OUTPUT AREA
         MVC   LINENO+1(L'BUFR-2),LINENO  ALL OF IT
         LA    GR2,NEXTENT              GET NEXT INPUT RECORD
         SH    GR1,LENGTH               ALL RECORDS TO SYSTERM
         BP    TREDA                    NO MORE RECORDS LEFT .Q
         BR    SP2                      RETURN
         DROP  GR2
PRSAVE   DC    16F'0'                   SAVE AREA FOR SYSTEM LIST
PATCH    DC    10S(*)                   ASMGFD PATCH AREA
         SPACE 2
YLCNT    DC    F'0'                     LINE COUNTER
ERCTR    DC    F'0'                     NUMBER OF ERRORS
MLSW     DC    X'00'                    FF= ERROR 58 OR 46, 00= NOT
*
LSTMTN   DC    H'0'                     LAST STATEMENT WITH ERROR
*./      DELETE    SEQ1=08640020,SEQ2=08660020
PTRMSG   DC    C'NEAR OPERAND COLUMN 000--'
PRGTYP   DC        C'ASMG200   '
*
CVDA     DC        D'0'
SVCODE   DC        X'00'               SEVERITY CODE FOR L1SYNERR'S
MASK     DC    4X'F0'                   MASK TO SET BLANKS ZERO
BUFR     DS    0CL133                   DETAIL OUTPUT BUFFER
         DC        X'01'                NUMERIC CARRIAGE CONTROL
         DC    120C' '
         DC        CL12' '              USED FOR A MOVE INSTRUCTION
BUFF     EQU       BUFR
ERNO     EQU       BUFR+13             ERROR NUMBER
MSGBG    EQU   BUFR+20                  BEGINNING OF ERROR MESSAGE
ERCD     EQU   BUFR+9                   ERROR CODE
STMNO    EQU   BUFR+1                   STATEMENT NUMBER
OUTPUT   EQU   BUFR                     ALSO FOR SOURCE RECORD, TERM
LINENO   EQU   OUTPUT+1
*
HEAD1    DS        0CL133              HEADER LINE ONE
         DC        X'FF'               SKIP TO NEW PAGE
HDECKID  DC        CL8' '              PROGRAM I.D.
         DC        CL46' '
         DC        CL11'DIAGNOSTICS'
         DC        CL46' '
         DC        CL4'PAGE'
         DC        C' '
HPAGENO  DC        CL4' '              PAGE NUMBER
         DC        CL12' '
*
HEAD2    DS        0CL133              HEADER LINE TWO
         DC        X'02'               LEAVE TWO LINES BEFORE
         DC        CL111' STMT  ERROR CODE  MESSAGE'
HDATE    DC        CL9' '
         DC        CL12' '
*
BSUMMARY DC        CL14'BATCH  SUMMARY'
DCBEODAD EQU       32                  EODAD EXIT ADDRESS
DCBGET   EQU       48                  DCB GET ADDRESS
ERM      EQU   6                        POSITION OF ERROR CODE
ERCT     EQU   3                        POSITION OF ERROR COUNT
SVMES    DC        X'00',C'  000 WAS HIGHEST SEVERITY CODE'
         DC        10C' '
MSUNPROC DC        C'ASMG202   UNPROCESSED ******** AND/OR ******** RECX
               ORDS EXIST.'
TMSG     DC    C'ASSEMBLER (G) DONE'
MVMSG    MVC   0(0,GRY),2(GRD)          EXECUTED MOVE MESSAGE TO BUFFER
         CNOP  2,4                      FOR PRELUDE ALIGNMENT
         DC    H'0'                     PRELUDE TO WORD
WORD     DC    F'0'                     DECIMAL RESULTS OF CVTBTC
*
SAVWD    DC    F'0'                     STATEMENT NUMBER
SAVE     DC    F'0'                     SAVE AREA FOR ONE WORD
SP1SAV   DC    F'0'                     SAVE AREA FOR GRY
         DC    X'03'                    BEGIN MESSAGE ERCTM
ERCTM    DC    C' '                     ERROR COUNT
         DC    C'     STATEMENTS FLAGGED IN THIS ASSEMBLY'
NOERM    EQU   ERCTM+2                  NO ERROR MESSAGES POINTER
CAC      DC    X'03D5D6'                NUMERIC TRIPLE SPACE 'NO'
RECMESS  DC    C'SOURCE RECORDS'
ZERO     DC    F'0'                     FULL WORD OF ZERO
         DC    H'0'
LENGTH   DC    H'86'                    STMTNO/GEN/SOURCE LENGTH
         EJECT
*READ ERROR RECORD FROM OVERFLOW FILE
*
* READ OVERFLOW FILE INTERFACE WITH BUFF ROUTINE
*
*
RDERR    STM   GR0,GR1,IOSAVE           SAVE REGISTERS
RDF1     L         GR1,BUFFPT(0,ACT)   DO THE READ
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(4,0)
VERRBUF  DC        V(ERRBUF)            EXTERNAL BUFFER ADDRESS
         L         GR1,BUFFPT(0,ACT)   DO A CHECK
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,0,0)
         L         GR1,VERRBUF          POINT TO THE RECORD
         CLI       0(GR1),X'00'         CORRECT TYPE .Q
         BNE   RDF1                     NO,READ NEXT BLOCK
         LM    GR0,GR1,IOSAVE           RESTORE SAVED REGISTERS
         BR    SP2                      EXIT RDOF
*
IOSAVE   DC        18F'0'               IO REGISTER SAVE AREA
         LTORG
*
         EJECT
         DS        0H                   START ALIGNMENT
         DC    AL2(E0017-ESTART)        FOR A ZERO
PTRTBL   EQU   *                        POINTER TABLE
         EPTR  117,ERROR=(36,53,54,113,114,117)  ERROR POINTERS
ENDTBL   DC    AL2(EFM-ESTART)          MESSAGE NOT DEFINED POINTER
         EJECT
         PRINT NODATA
ESTART   DS    0H
         EMSG  001,12,'DUPLICATION FACTOR ERROR'
         EMSG  002,12,'RELOCATABLE DUPLICATION FACTOR'
         EMSG  003,12,'LENGTH ERROR'
         EMSG  004,12,'RELOCATABLE LENGTH'
         EMSG  005,08,'S-TYPE CONSTANT IN LITERAL'
         EMSG  006,12,'INVALID ORIGIN'
         EMSG  007,12,'LOCATION COUNTER ERROR'
         EMSG  008,08,'INVALID DISPLACEMENT'
         EMSG  009,12,'MISSING OPERAND'
         EMSG  010,08,'INCORRECT SPECIFICATION OF REGISTER OR MASK'
         EMSG  011,08,'SCALE MODIFIER ERROR'
         EMSG  012,08,'RELOCATABLE SCALE MODIFIER'
         EMSG  013,08,'EXPONENT MODIFIER ERROR'
         EMSG  014,08,'RELOCATABLE EXPONENT MODIFIER'
         EMSG  015,08,'INVALID LITERAL USAGE'
         EMSG  016,08,'INVALID NAME'
         EMSG  017,08,'DATA ITEM TOO LARGE'
         EMSG  018,08,'INVALID SYMBOL'
         EMSG  019,08,'EXTERNAL SYMBOL ERROR'
         EMSG  020,08,'INVALID IMMEDIATE FIELD'
         EMSG  021,08,'SYMBOL NOT PREVIOUSLY DEFINED'
         EMSG  022,12,'ESD TABLE OVERFLOW'
         EMSG  023,08,'PREVIOUSLY DEFINED NAME'
         EMSG  024,08,'UNDEFINED SYMBOL'
         EMSG  025,08,'RELOCATABILITY ERROR'
         EMSG  026,12,'TOO MANY LEVELS OF PARENTHESES'
         EMSG  027,12,'TOO MANY TERMS'
         EMSG  028,04,'REGISTER NOT USED'
         EMSG  029,08,'CCW ERROR'
         EMSG  030,12,'INVALID CNOP'
         EMSG  031,08,'UNKNOWN TYPE'
         EMSG  032,08,'OP-CODE NOT ALLOWED TO BE GENERATED'
         EMSG  033,04,'ALIGNMENT ERROR'
         EMSG  034,08,'INVALID OP-CODE'
         EMSG  035,08,'ADDRESSABILITY ERROR'
         EMSG  036,16,'ASSEMBLER ERROR'
         EMSG  037,00,'MNOTE STATEMENT'
         EMSG  038,08,'ENTRY ERROR'
         EMSG  039,12,'INVALID DELIMITER'
         EMSG  040,12,'STATEMENT IS TOO LONG'
         EMSG  041,08,'UNDECLARED VARIABLE SYMBOL'
         EMSG  042,08,'SINGLE TERM LOGICAL EXPRESSION IS NOT A SETB SYM-
               BOL'
         EMSG  043,08,'SET SYMBOL PREVIOUSLY DEFINED'
         EMSG  044,08,'SET SYMBOL USAGE INCONSISTENT WITH DECLARATION'
         EMSG  045,08,'ILLEGAL SYMBOLIC PARAMETER'
         EMSG  046,04,'AT LEAST ONE RELOCATABLE Y-TYPE CONSTANT IN ASSE-
               MBLY'
         EMSG  047,12,'SEQUENCE SYMBOL PREVIOUSLY DEFINED'
         EMSG  048,12,'SYMBOLIC PARAMETER PREVIOUSLY DEFINED OR SYSTEM *
               VARIABLE SYMBOL DECLARED AS SYMBOLIC PARAMETER'
         EMSG  049,12,'VARIABLE SYMBOL MATCHES A PARAMETER'
         EMSG  050,08,'INCONSISTENT GLOBAL DECLARATIONS'
         EMSG  051,12,'MACRO DEFINITION PREVIOUSLY DEFINED'
         EMSG  052,08,'NAME FIELD CONTAINS ILLEGAL SET SYMBOL'
         EMSG  053,16,'ASSEMBLER ERROR'
         EMSG  054,16,'ASSEMBLER ERROR'
         EMSG  055,08,'INVALID EXECUTE CARD PARAMETER(S)'
         EMSG  056,08,'ARITHMETIC OVERFLOW'
         EMSG  057,08,'SUBSCRIPT NOT WITHIN DIMENSIONS'
         EMSG  058,04,'RE-ENTRANCY VIOLATION'
         EMSG  059,12,'UNDEFINED SEQUENCE SYMBOL'
         EMSG  060,08,'ILLEGAL ATTRIBUTE NOTATION'
         EMSG  061,12,'ACTR COUNTER EXCEEDED'
         EMSG  062,08,'GENERATED STRING GREATER THAN 255 CHARACTERS'
         EMSG  063,08,'EXPRESSION 1 OF SUBSTRING IS ZERO OR MINUS'
         EMSG  064,08,'EXPRESSION 2 OF SUBSTRING IS ZERO OR MINUS'
         EMSG 065,08,'INVALID OR ILLEGAL TERM IN ARITHMETIC EXPRESSION'
         EMSG  066,12,'UNDEFINED OR DUPLICATE KEYWORD OPERAND'
*./      DELETE    SEQ1=11320020,SEQ2=11320020
         EMSG  067,08,'EXPRESSION 1 OF SUBSTRING GREATER THAN LENGTH OF*
                CHARACTER EXPRESSION'
         EMSG  068,8,'ILLEGAL LENGTH SPECIFICATION IN GBL OR LCL STATEMX
               ENT'
         EMSG  069,08,'VALUE OF EXPRESSION 2 OF SUBSTRING TOO LARGE'
         EMSG  070,12,'FLOATING POINT CHARACTERISTIC OUT OF RANGE'
         EMSG  071,08,'ILLEGAL OCCURRENCE OF LCL, GBL, OR ACTR STATEMEN-
               T'
         EMSG  072,04,'ILLEGAL RANGE ON ISEQ STATEMENT'
         EMSG  073,08,'ILLEGAL NAME FIELD'
         EMSG  074,08,'ILLEGAL STATEMENT IN COPY CODE OR SYSTEM MACRO'
         EMSG  075,08,'ILLEGAL STATEMENT OUTSIDE OF A MACRO DEFINITION'
         EMSG  076,12,'SEQUENCE ERROR'
         EMSG  077,08,'ILLEGAL CONTINUATION CARD'
         EMSG  078,00,'FOLLOWING ERRORS OCCURED WHILE EDITING LIBRARY MX
               ACROS'
         EMSG  079,08,'ILLEGAL STATEMENT IN MACRO DEFINITION'
         EMSG  080,08,'ILLEGAL START CARD'
         EMSG  081,08,'ILLEGAL FORMAT IN GBL OR LCL STATEMENTS'
         EMSG  082,08,'ILLEGAL DIMENSION SPECIFICATION IN GBL OR LCL ST-
               ATEMENT'
         EMSG  083,08,'SET STATEMENT NAME FIELD NOT A VARIABLE SYMBOL'
         EMSG  084,08,'ILLEGAL OPERAND FIELD FORMAT'
         EMSG  085,08,'INVALID SYNTAX IN EXPRESSION'
         EMSG  086,08,'ILLEGAL USAGE OF SYSTEM VARIABLE SYMBOL'
         EMSG  087,08,'NO ENDING APOSTROPHE'
         EMSG  088,12,'UNDEFINED OPERATION CODE'
         EMSG  089,08,'INVALID ATTRIBUTE NOTATION'
         EMSG  090,08,'INVALID SUBSCRIPT'
         EMSG  091,08,'INVALID SELF-DEFINING TERM'
         EMSG  092,08,'INVALID FORMAT FOR VARIABLE SYMBOL'
         EMSG  093,08,'UNBALANCED PARENTHESES OR EXCESSIVE LEFT PARENTH-
               ESES'
         EMSG  094,12,'INVALID OR ILLEGAL NAME OR OPERATION IN PROTOTYP-
               E STATEMENT'
         EMSG  095,08,'ENTRY TABLE OVERFLOW'
         EMSG  096,12,'MACRO INSTRUCTION OR PTOTOTYPE OPERAND EXCEEDS 2-
               55 CHARACTERS IN LENGTH'
         EMSG  097,12,'INVALID FORMAT IN MACRO INSTRUCTION OPERAND OR P-
               ROTOTYPE PARAMETER'
         EMSG  098,12,'EXCESSIVE NUMBER OF OPERANDS OR PARAMETERS'
         EMSG  099,12,'POSITIONAL MACRO INSTRUCTION OPERAND, PROTOTYPE *
               PARAMETER OR EXTRA COMMA FOLLOWS KEYWORD'
         EMSG  100,08,'STATEMENT COMPLEXITY EXCEEDED'
         EMSG  101,12,'EOD ON SYSIN'
         EMSG  102,16,'INVALID OR ILLEGAL ICTL'
         EMSG  103,12,'ILLEGAL NAME IN OPERAND FIELD OF COPY CARD'
         EMSG  104,12,'COPY CODE NOT FOUND'
         EMSG  105,12,'EOD ON SYSTEM MACRO LIBRARY'
         EMSG  106,08,'NOT NAME OF DSECT OR DXD'
         EMSG  107,08,'INVALID OPERAND'
         EMSG  108,08,'INVALID EQU ARGUMENTS'
         EMSG  109,08,'PRECISION LOST'
         EMSG  110,08,'EXPRESSION VALUE TOO LARGE'
         EMSG  111,08,'INVALID PRINT, PUSH OR POP OPERAND'
         EMSG  112,08,'INVALID PUSH/POP REQUEST'
         EMSG  113,16,'ASSEMBLER ERROR'
         EMSG  114,16,'ASSEMBLER ERROR'
         EMSG  115,*-*,'UPDATE CONDITION CODE EXCEEDED'
         EMSG  116,08,'ILLEGAL OPSYN'
         EMSG  117,16,'ASSEMBLER ERROR'
EFM      DC    AL1(39,16),C'MESSAGE NOT DEFINED FOR THIS ERROR CODE'
ENDM     DC    AL1(0)
         SPACE 2
*
*        INPUT AREA DESCRIPTION IF TERM OPTION
INP      DSECT
TYPE     DS    X                        RECORD TYPE
TRLI     DS    2C                       UNALIGNED HALF-WORD REC LEN
INPUT    DS    CL86                     PREFIX AND SOURCE RECORD
ISTMT    EQU   INPUT                    FIVE DIGIT STATEMENT NUMBER
IGEN     EQU   INPUT+5                  (+) GENERATED OR (BLANK) NOT
ISRC     EQU   INPUT+6                  SOURCE RECORD
ILINE    EQU   INPUT+78                 EIGHT DIGIT LINE NUMBER
NEXTENT  EQU   *
*
         SPACE 3
         END       ASMGFD
./ ADD NAME=ASMGFEX
FEX      TITLE     'ASMG     LOAD AND EXECUTE PHASE'
         ISEQ      73,78
         COPY      ASMGSET
ASMGFEX  CSECT
         PRINT     NOGEN
         FDIMEN
         PRINT     GEN
*
R0       EQU       0
R1       EQU       1
R2       EQU       2
R3       EQU       3
R4       EQU       4
R5       EQU       5
R6       EQU       6
R7       EQU       7
R8       EQU       8
R9       EQU       9
R10      EQU       10
R11      EQU       11
R12      EQU       12
R13      EQU       13
R14      EQU       14
R15      EQU       15
**       FD MUST SAVE ANY NECESSARY REGISTERS EXCEPT ACT.  IT MUST ALSO
**       TEST FOR EXECUTE OPTION BEFORE BRANCHING TO FEX. THE RETURN
**       ADDRESS IS IN R14.
**       BASE REGISTER (R2) IS ENTRY REGISTER FROM ASMGFD
         USING     ASMGFEX,R2          TELL THE ASSEMBLER
         L         R13,=A(SARA)        OS SAVE AREA
         USING     SARA,R13
         ST        R14,FDRETURN
         LR        R9,ACT              SAVE BASE REGISTER FOR REF. FDIM
         MVC       COUNT+3(1),CTPGLNCT(R9)  LINES PER PAGE
***********************************************************************
*        CALL SHRINK TO GET 6000 BYTES FOR ESD PROCESSING.
*        IF -1 IS RETURNED IN ADDRESS FIELD, ABEND BATCH.
         L         R1,ADLIST1(0,R9)
         L         R1,L1BUFADR(,R1)    GET BUFF ROUTINE ADDRESS
         ST        R1,RENNIE
         CNOP      2,4
         BALR      R0,R1
         DC        F'36'               ROUTINE NUMBER
         DC        F'6144'             BYTES DESIRED
BEGADD   DS        F                   ADDRESS OF 1ST BYTE
         CLI       *-4,X'FF'           REQUEST GRANTED ?
         BE        ABEND               NO, QUIT
         MVI       BEGADD,X'00'        ZERO 1ST BYTE (AVOID OVERFLOWS)
***********************************************************************
         L         R6,BEGADD           POINT TO AREA FOR TABLES
         A         R6,BEGADD-4         FIND END OF CORE
         ST        R6,ENDCORE          AND STORE IT
         S         R6,BEGADD-4         RESTORE R6
         LR        R7,R6
         A         R7,=F'3072'
         ST        R7,BEGADD-4         SAVE ADDRESS OF DEFTBL
         LR        R12,R6              TABLES WILL BE OVERLAID BY TEXT
         LR        R10,R6              AFTER THEY ARE PROCESSED
         MVC       OB+56(8),=C'LOAD MAP'
         MVI       OB-1,C'1'           SET TO BEGIN NEW PAGE
         BAL       R8,PUT              PUT OUT HEADING
         MVC       OB+56(8),OB+55      ERASE BUFFER
         MVC       OB-1(29),=C'-CSECT NAME  LOCATION  LENGTH'
         MVC       OB+111(9),CTDATE(R9) MOVE IN DATE
         BAL       R8,PUT              PUT OUT SUBHEADING
         MVC       OB(20),OB+47        BLANK HEADINGS
         MVI       OB-1,C'0'           SET TO SKIP SPACE
         MVC       OB+111(9),OB+110    BLANK OUT DATE
***********************************************************************
*        CALL READP TO GET NEXT OBJECT CARD INTO C.
NEWCARD  EQU       *
         L         R1,RENNIE
         CNOP      2,4
         BALR      R0,R1
         DC        F'4'
         DC        F'4'
         DC        A(C)
***********************************************************************
***********************************************************************
*        CALL CHECK.
         L         R1,RENNIE
         CNOP      2,4
         BALR      R0,R1
         DC        F'28'
         DC        F'4'
         DS        F
***********************************************************************
         CLC       C+1(3),=C'ESD'      IS IT ESD?
         BE        ESD
         CLC       C+1(3),=C'TXT'      IS IT TXT?
         BE        TXT
         CLC       C+1(3),=C'RLD'      IS IT RLD?
         BE        RLD
         CLC       C+1(3),=C'END'      IS IT LAST CARD?
         BE        END
         CLC       C+1(3),=C'EOF'      IS IT SIMULATED END-OF-FILE?
         BNE       EXFET
         MVC       OB-1(10),=C'0ASMG307I '
         MVC       OB+20(53),=C'OBJECT FILE MISSING OR INCOMPLETE. EXEC1
               UTION DELETED.'
         BAL       R8,PUT
         B         THATSIT
EXFET    MVC       OB-1(10),=C'0ASMG300I '
         MVC       OB+20(47),=C'FEATURES INCOMPATIBLE WITH EXECUTE OPTIX
               ON USED '
         MVC       OB+67(53),OB+66     BLANK REST
         BAL       R8,PUT              GIVE MESSAGE
         B         THATSIT             QUIT
ESD      NOP       EXFET               BECOMES BRANCH TO ERROR
         LA        R3,C+16
         LR        R4,R3                BEGINNING OF DATA FIELD
         AH        R4,C+10             POINT R4 TO END OF DATA FIELD
         LH        R5,C+14             IDENTIFY FIRST NON-LD ID VALUE
ESD1     CLI       8(R3),X'03'         IS IT LR?
         BE        LD                  TES, TREAT AS LD
         BH        G03                 IS IT SD,PC?
         CLI       8(R3),X'01'         IS IT LD?
         BE        LD
         BL        SD
         LM        R14,R15,0(R3)       GET AND STORE ENTRY'S NAME IN
         STM       R14,R15,0(R6)       REFERENCES TO BE SATISFIED TABLE
         ST        R5,8(R6)            STORE ID #
         LA        R6,12(R6)           POINT TO NEXT SPOT IN TABLE
GOA      A         R5,=F'1'            COMPUTE NEXT ID #
         LA        R3,16(R3)           POINT TO NEXT ESD MEMBER
         CR        R3,R4               AT END OF DATA FIELD?
         BL        ESD1                NO, CONTINUE
         B         NEWCARD             YES, GO GET NEW CARD
ABEND    EQU       *                   MINIMUM MEMORY REQUIREMENTS NOT
         BAL       R0,ABEND20                    MET
         DC        C'306 ',AL1(L'MES306-1)
MES306   DC        C'INSUFFICIENT MEMORY FOR USE OF EXECUTE OPTION WITHX
                ANY PROGRAM'
ABEND20  L         R1,ADLIST1(0,R9)    BRANCH TO ABEND ROUTINE IN ASM
         B         L1ABEND(,R1)
*./      DELETE    SEQ1=02680020,SEQ2=02780020
*./      DELETE    SEQ1=02800020,SEQ2=02840020
***********************************************************************
*                                                                     *
*        INPUT CARRIAGE CONTROL IS A RESTRICTED VERSION OF ASA.       *
*        THIS ROUTINE MONITORS THAT CARRIAGE CONTROL CHARACTER        *
*        IN ORDER TO COUNT LINES AND DO PAGE EJECTS AS REQUIRED.      *
*        THE SYSPRINT DCB TRAILER HAS BEEN ALTERED BY ASMGFD          *
*        TO ACCEPT ASA CARRIAGE CONTROL DIRECTLY FOR MODIFICATION     *
*        TO THE ACTUAL CHARACTERISTICS OF SYSPRINT.                   *
*                                                                     *
         SPACE     2
PUT      DS        0H
         L         R11,COUNT           LINES LEFT BEFORE PAGE SKIP
         MVC       CCC(1),OBM1         SAVE ASA CARRIAGE CONTROL
         CLI       OBM1,C'1'           NEW PAGE .Q
         BE        NPAGE               BRANCH IF YES
         CLI       OBM1,C' '           SKIP TO NEXT LINE .Q
         BE        DEC                 YES, DO SO
         BCT       R11,DOUBLE          BEYOND LINE LIMIT .Q
         B         NPAGE               YES, THEN NEW PAGE
DOUBLE   DS        0H
         CLI       OBM1,C'0'           ONLY ONE EXTRA SKIP .Q
         BE        DEC                 YES, ALL SET
         BCT       R11,DEC             BEYOND LINE LIMIT .Q
         B         NPAGE               YES, NEW PAGE
DEC      DS        0H
         BCT       R11,ACTPUT          PRESENT LINE, CHECK LINE LIMIT
NPAGE    DS        0H
         IC        R11,CTPGLNCT(,R9)   RESET LINE COUNTER
         MVI       OBM1,C'1'           SET TO SKIP PAGE
ACTPUT   DS        0H
         MVI       ACTPMVC,X'D2'       MAKE SURE OF OPCODE
         L         R1,LSTDCB(,R9)      GET SYSPRINT DCB ADDRESS
         PUT       (1),OBM1            DO THE PUT
ACTPMVC  MVC       OBM1(1),CCC         RESTORE CARRIAGE CONTROL
         MVI       ACTPMVC,X'00'       PREVENT UNEXPECTED RETURNS
         ST        R11,COUNT           STORE LINES-TO-GO
         BR        R8                  RETURN TO CALLER
         SPACE     2
***********************************************************************
G03      CLI       8(R3),X'05'         IS IT CM?
         BL        PC                  NO, ITS PC
         BH        EXFET               OR PR AND UNUSABLE WITH FEX
         CLI       0(R3),C' '          TEST IF NAMED
         BNE       SD                  TREAT LIKE CSECT IF SO
         MVC       OB+1(8),=C'/COMMON/' INDICATE CM ON LOAD MAP
         B         SDPCCM              GO FIND ADDRESS, LENGTH
PC       MVC       OB+1(8),=C'/NONAME/' INDICATE UNNAMED CSECT
         B         SDPCCM
SD       EQU       *                   NAMED CSECT
         LM        R14,R0,0(R3)        MOVE NAME TO DEFINITION TABLE
         STM       R14,R0,0(R7)        ALONG WITH VALUE
         MVC       OB+1(8),0(R3)       MOVE NAME TO BUFFER
         LA        R7,12(R7)           POINT TO NEXT TABLE VACANCY
SDPCCM   LA        R12,7(,R12)         DOUBLE ALIGN ADDRESS COUNTER
         N         R12,=X'FFFFFFF8'
         ST        R12,FA              STORE ADDRESS OF CSECT
         CLI       FLAG,X'FF'          ARE WE LOADING, OR JUST CHECKING
         BE        GOA                 FOR ERRORS? NO, NEXT ENTRY
         UNPK      OB+13(7),FA+1(4)    YES, PREPARE ADDRESS FOR PRINTIN
         MVI       OB+19,C' '
         MVI       12(R3),X'00'        WIPE OUT POSSIBLE HIGH-ORDER
         A         R12,12(R3)          BYTE ON LENGTH BEFORE ADDING TO
*                                      GET ADDRESS OF NEXT CSECT
         MVC       FA(4),12(R3)        PREPARE LENGTH FOR PRINTING
         UNPK      OB+22(7),FA+1(4)
         MVI       OB+28,C' '
         TR        OB+13(6),TRTBLH     MAKE PROGRAM LOCATION PRINTABLE
         TR        OB+22(6),TRTBLH     MAKE PROGRAM LENGTH PRINTABLE
         BAL       R8,PUT              PUT NAME ADDRESS AND LENGTH
         MVC       OB-1(21),OB+50      BLANK BUFFER
         LA        R8,THATSIT          THIS HAS SOME FORGOTTEN USE
         C         R12,ENDCORE         HAS CSECT OUTRUN CORE SPACE?
         BL        GOA                 NO, KEEP GOING
***********************************************************************
*        CALL SHRINK TO GET ENOUGH CORE TO LOAD CSECT NAMED BY
*        RLD CARD.  ACTUAL LOADING DOES NOT TAKE PLACE UNTIL
*        ENTIRE ESD HAS BEEN PROCESSED AND REPROCESSED.  IF -1
*        IS RETURNED IN ADDRESS FIELD, GIVE ERROR MESSAGE, AND THEN
*        ABEND THE ENTIRE TASK.
         LR        R1,R12              TAKE ADDRESS OF NEXT CSECT,
         LA        R1,7(R1)            AND TAKE LEAST MULTIPLE OF 8 >
         SRA       R1,3                OR = TO IT (SINCE SHRINK DEALS
         SLA       R1,3                ONLY IN DOUBLE WORDS)
         LR        R0,R1               SAVE THIS VALUE TO DEFINE FUTURE
         S         R1,ENDCORE          END OF CORE. ALSO SUBTRACT FORMR
         ST        R0,ENDCORE          END OF CORE TO FIND AMOUNT NEEDD
         ST        R1,ASK              STORE THIS AS REQUIRED BY SHRINK
         L         R1,RENNIE
         CNOP      2,4
         BALR      R0,R1
         DC        F'36'               36 IDENTIFIES SHRINK
ASK      DS        F                   AMOUNT WANTED
         DS        F                   -1 OR ADDRESS OF ALLOTTED CORE
         CLI       *-4,X'FF'           WAS CORE GIVEN?
         BNE       GOA                 YES, AWAY WE GO AGAIN
         BAL       R0,ABEND20          NO, GIVE MESSAGE AND ABEND
         DC        C'302 ',AL1(L'MES302-1)
MES302   DC        C'INSUFFICIENT MEMORY TO LOAD ABOVE CSECT'
***********************************************************************
LD       DC        0H'0'
         LM        R14,R0,0(R3)        MOVE NAME AND VALUE TO
         STM       R14,R0,0(R7)        DEFINITION TABLE
         LA        R7,12(R7)           POINT TO NEXT POSITION IN TABLE
         B         GOA+4               AVOID INCREMENTING ID #
PESD     EQU       *                   ENTERED ON FIRST TXT ENCOUNTER
         LR        R3,R10              POINT TO BEGINNING OF ERTBL
         LA        R5,ESDTBL           POINT TO PROCESSED TABLE
         B         NEXT+4
         L         R4,BEGADD-4         POINT TO BEGINNING OF DEFTBL
TRY      CLC       0(8,R3),0(R4)       COMPARE NAMES
         BE        GOOD                SAME, GOOD
         LA        R4,12(R4)           DIFFERENT, POINT TO NEXT DEFTBL
         CR        R4,R7                BEYOND DEF. TBL?
         BNH       TRY                 NO, CHECK NEXT NAME
         MVC       OB-1(9),=C'0ASMG303I'
         MVC       OB+20(30),=C'UNRESOLVED EXTERNAL REFERENCE.'
         MVC       OB+50(9),OB+100     BLANKS
         MVC       OB+60(8),0(R3)      GIVE NAME
         BAL       R8,PUT
         MVI       FLAG,X'FF'          FLAG ERROR
         B         NEXT
GOOD     EQU       *                   COMPACT PROCESSED TABLE IS BUILT
*        AND STORED IN FEX'S PRIVATE CORE. IT CONSISTS OF 1-WORD ENTRYS
         L         R11,8(R4)           -- 3 LOW-ORDER BYTES OF VALUE
         ST        R11,0(R5)           FROM THE DEFTBL
         L         R11,8(R3)           AND 1 HIGH-ORDER BYTE OF ID #
         STC       R11,0(R5)           FROM ERTBL
         LA        R5,4(R5)            POINT TO NEXT ENTRY
NEXT     EQU       *
         LA        R3,12(R3)           ADVANCE TO NEXT ER ENTRY
         CR        R3,R6               CHECK IF END OF ER TABLE
         BL        TRY-4               NO, GO LOOK FOR A DEFINITION
         CLI       FLAG,X'FF'          CHECK FOR ERROR CONDITION
         BE        THATSIT             INHIBIT LOADING
         OI        ESD+1,X'F0'         NEXT ESD CARD WILL CAUSE ERROR
         NI        TXT+1,X'0F'         DO NOT RETURN TO THIS SECTION
TXT      B         PESD                ONCE ONLY - THEN NOP
         NOP       EXFET               BECOMES BRANCH TO ERROR AFTER LG
         L         R3,BEGADD           POINT TO BEGINNING OF LOAD AREA
         MVI       C+4,X'00'           WIPE OUT ANY HIGH ORDER BIT ON
         A         R3,C+4              ADDRESS & ADD TO GET ABSOLUTE AD
         IC        R0,C+11             MOVE LENGTH FACTOR IN
         BCTR      R0,0                AFTER DECREMENTING BY ONE
         STC       R0,*+5
         MVC       0(*-*,R3),C+16      MOVE IN CODE
         B         NEWCARD             GET ANOTHER CARD
PTXT     OI        TXT+5,X'F0'       NEXT TXT CARD GIVES ERROR MESSAGE
         NI        RLD+1,X'0F'         DO NOT RETURN TO THIS SECTION
         L         R3,BEGADD           POINT TO BEGINNING OF LOAD AREA
         LR        R10,R3
RLD      B         PTXT                ONCE ONLY, THEN NOP
         LA        R4,C+16
         LR        R6,R4
         AH        R6,C+10             POINT TO DATA BOUNDARIES
NEXTADD  EQU       *
         IC        R0,4(R4)            GET AND ISOLATE LENGTH FACTOR
         N         R0,=F'12'           AND SHIFT IT 2 BITS. TO SEE WHY
         SRA       R0,2                LOOK AT ENDUP
         STC       R0,FLAG             STORE LENGTH
         A         R3,4(R4)            FIND ACTUAL ADDRESS OF CONSTANT
         TM        4(R4),X'30'         CHECK TYPE OF RLD ENTRY
         BZ        NBR
         BO        EXFET               PSEUDO-REGISTERS NOT HANDLED
         LA        R7,ESDTBL-4         ADD. OF WORD BEFORE TABLE
WEINMAL  EQU       *
**       IF IT BOMBS IN THIS LOOP IT COULD BE THAT ASMG HAS ASKED FOR
**       AN ER ENTRY IT DIDNT SUPPLY, CAUSING A SEARCH BEYOND CORESEND
         LA        R7,4(R7)            POINT TO NEXT ENTRY
         CLC       0(1,R7),1(R4)       IS IT 1 WE LOOK FOR?
         BNE       WEINMAL             NO, KEEP LOOKING
**       IF IT BOMBS IN THIS LOOP IT COULD BE THAT ASMG HAS ASKED FOR
**       AN ER ENTRY IT DIDNT SUPPLY, CAUSING A SEARCH BEYOND CORESEND
FOUND    EQU       *
         A         R10,0(R7)           ADD VALUE OF CONSTANT TO BASE
         LA        R10,0(R10)          BLANK TOP BYTE
         ST        R10,FA              STORE ADD. CONSTANT, POINT TO
         LA        R7,FA+3             LAST BYTE, SHIFT BACK 1 PER BYTE
*        DESIRED. ACTUALLY,IF THE LENGTH IS N, BOTH THE LENGTH GIVEN BY
*        THE RLD CARD AND THE LENGTH REQUIRED BY THE MVC INSTRUCTION
*        ARE N-1. THE SH SHIFTS R7 BACK REQUIRED AMOUNT.
         SH        R7,HALF              FLAG FOLLOWS HALF (X'00')
ENDUP    EQU       *
         STC       R0,*+5              MOVE IN LENGTH FACTOR
         MVC       0(*-*,R3),0(R7)     MOVE IN CONSTANT
         L         R3,BEGADD           RESTORE R3 TO BASE ADDRESS
         LR        R10,R3
         TM        4(R4),X'01'         CHECK FOR DUPLICATE ID'S
         BZ        *+16
         L         R11,0(R4)           IF SAME, SHIFT
         ST        R11,4(R4)
         S         R4,=F'4'
         LA        R4,8(R4)            POINT TO NEXT RLD ITEM
         CR        R4,R6                & IF NOT PAST END OF CARD,
         BL        NEXTADD             MOVE IN THIS CONSTANT
         B         NEWCARD             OTHERWISE, GET A NEW CARD
NBR      EQU       *
         SR        R1,R1               USE R1 TO SET FA TO ZEROS
         ST        R1,FA
         LA        R7,FA+3             POINT TO END OF SPACE
         SH        R7,HALF             BACK UP TO DESIRED ADDRESS
         STC       R0,*+5              PUT IN LENGTH FACTOR
         MVC       0(*-*,R7),0(R3)      MOVE REL. ADDRESS TO FULL WORD
         TM        4(R4),X'02'         SUBTRACT BASE?
         BZ        *+8                 NO, BRANCH AROUND
         MVI       *+4,X'5B'            CHANGE OPCODE TO SUBTRACT
         A         R10,FA               ADD BASE TO GET CONSTANT
         MVI       *-4,X'5A'            RESTORE OPCODE TO AD IF NECESS.
         ST        R10,FA              AND PREPARE TO MOVE IT
         B         ENDUP
*./      DELETE    SEQ1=06820020,SEQ2=06820020
END      EQU       *
         TM        CTLSTI(R9),X'10'    WAS NOLIST SPECIFIED .Q
         BC        8,SPIE              NO, FORGET IT
         MVC       OB-1(18),=C'1EXECUTION BEGINS '
         MVC       OB+17(11),OB+80
         BAL       R8,PUT
         MVC       OB-1(18),OB+80      BLANK THE ENTIRE LINE
         BAL       R8,PUT              AND LEAVE A LINE
         MVI       EOFLAG,X'01'
SPIE     SPIE      EXER,((1,15))       RETAIN CONTROL IF ERROR BY USER
         ST        R1,SAVEPICA         PREVIOUS SPIE MAY BE RESTORED
         SR        R1,R1               ZERO A REGISTER
         SPM       R1                  AND SET ZERO PROGRAM MASK
         L         R5,ADLIST1(0,R9)    GET ADDRESS OF TIME ALLOWED
         L         R5,L1TIMELM(,R5)    GET EXECUTE TIME (IN SECONDS)
         MH        R5,=H'100'          CONVERT TO HUNDREDTHS
         ST        R5,FULL             STORE IT
         MH        R5,=H'10'           CONVERT TO THOUSANDTHS
         ST        R5,FA
         STIMER    TASK,TIMERR,BINTVL=FULL  START TIMING
         L         R15,BEGADD          LOAD BASE ADDRESS
         USING     SARA,R13
         ST        R9,ESDTBL+64         SAVE LIFE-LINE TO ASM
         L         R1,ADLIST1(,R9)     POINT TO LIST1 IN ASM
         L         R6,L1DCBADS+L1SIN(,R1)  GET SYSIN DCB ADDRESS
         MVC       33(3,R6),=AL3(FEXEOF) SET MY OWN EOF ADDRESS
         LA        R1,L1DCBADS(,R1)    POINT TO ASMG'S DCB ADDR LIST
         ST        R12,BEGADD-4        STORE VARIOUS REGISTERS
         ST        R2,BASE
         CLC       C+5(3),=C'   '      ENTRY SPECIFIED?
         BE        TOP                 NO, ASSUME FIRST BYTE. BRANCH.
         AH        R15,C+6             YES, SET TO SPECIFIED ADDR.
TOP      BALR      R14,R15             RELUCTANTLY RELINQUISH CONTROL
         DROP      R13
         SPACE     3
         TTIMER    CANCEL              STOP TIMER AND GET TIME
         LR        R7,R0               TIME IN TIMER UNITS
         BALR      R15,0
         USING     *,R15
         L         R2,BASE
         L         R13,=A(SARA)        OS SAVE AREA
         DROP      R15
         USING     SARA,R13
*./      DELETE    SEQ1=07600020,SEQ2=07600020
         L         R9,ESDTBL+64        RESTORE ASM POINTER
         SR        R6,R6               ZERO R6
         M         R6,=F'26'           CONVERT TIME NOT USED FROM
         D         R6,=F'1000'         TIMER UNITS TO MILLISECONDS AND
         L         R6,FA               SUBTRACT FROM TIME ALLOWED TO
         SR        R6,R7               GET TIME USED
         CVD       R6,TIMAREA          AND IN DECIMAL FORM
         SR        R11,R11
         IC        R11,CTPGLNCT(R9)    PRETEND AT TOP OF A PAGE
         CLI       EOFLAG,X'00'        IF END OF FILE, SAY SO
         BNE       TIMEOUT
         MVI       OBM1,C' '           SPACE 1 LINE
         BAL       R8,PUT              PRINT THE LINE
         MVC       OB-1(10),=C'0ASMG308I '
         MVC       OB+10(10),OB+9
         MVC    OB+20(41),=C'END OF FILE ON INPUT DCB. JOB TERMINATED.'
         BAL       R8,PUT              PRINT THE MESSAGE
         MVI       OB,C' '             BLANK START OF LINE
         MVC       OB+1(L'OBM1-2),OB   AND PUSH IT THRU
*
TIMEOUT  DS        0H
         MVI       OBM1,C' '           SPACE 1 LINE
         BAL       R8,PUT              PRINT THE LINE
         MVC       OB-1(42),MASK1
         ED        OB+14(9),TIMAREA+4
         LA        R8,NEARLYIT         RETURN AND RESTORE PREVIOUS SPIE
         B         PUT                 PUT OUT EXECUTION TIME.
MASK1    DC        C'0EXECUTION TIME ',X'20202021',C'.',X'202020',CL18'X
                SEC.'
         DROP      R13
FEXEOF   BALR      R15,R0              END OF INPUT FILE
         USING     *,R15
         MVI       EOFLAG,X'00'        SET FLAG
         L         R15,=A(TOP+2)
         BR        R15
EXER     EQU       *                   ERROR DURING EXECUTION
         USING     *,R15
         L         R2,BASE
         ST        R13,ESDTBL+52
         L         R13,=A(SARA)        OS SAVE AREA
         DROP      R15
         USING     SARA,R13
         ST        R1,SAVEPIE
*./      DELETE    SEQ1=08440020,SEQ2=08440020
         MVI       0(R1),X'00'         FOOL SYSTEM INTO THINKING IT HAS
*        HAD CONTROL RETURNED TO IT SO THAT IT COULD RETURN TO BUNGLER
*./      DELETE    SEQ1=08500020,SEQ2=08500020
         STM       R3,R12,ESDTBL+12    SAVE BUNGLER'S REGISTERS
         L         R9,ESDTBL+64
         TTIMER CANCEL
         L         R1,SAVEPICA         RESTORE CALLER'S PICA
         SPIE      MF=(E,(1))          RESET TO ORIGINAL SPIE FOR TERM
         L         R1,SAVEPIE          RETRIEVE PIE ADDRESS
         MVC       ESDTBL+56(8),12(R1)  SOME MUST BE RETREIVED FROM
         MVC       ESDTBL(12),20(R1)   PROGRAM INTERRUPT AREA
         MVC       OB-1(9),=C'1ASMG304I'
         MVC       OB+20(16),=C'EXECUTION ERROR.'
         MVC       OB+8(12),OB+90      BLANKS TO BUFFER
         LA        R3,4(R1)            ADDRESS OF PSW
         BAL       R8,PUT
         MVC       OB(9),OB+9           BLANKS
EXER1    DS        0H                   ENTER HERE ON TIMER DUMPS
         MVC       OB+20(27),=C'ADDRESS OF NEXT INSTRUCTION'
         MVC       FA+1(3),5(R3)        MOVE NEXT ADDRESS TO UNPACK ARE
         UNPK      OB+50(7),FA+1(4)     UNPACK IT
         TR        OB+50(6),TRTBLH      MAKE IT READABLE
         MVI       OB+56,C' '           BLANK DUMMY DIGIT
         MVI       OB-1,C'-'
         BAL       R8,PUT
         MVI       OB-1,C' '            SET TO SINGLE SPACE ONLY
         MVC       OB+20(18),=C'INSTRUCTION LENGTH'
         SR        R1,R1
         SPM       R1                  SO ASMG WON'T CATCH ITSELF
         IC        R1,4(R3)            FIND INSTRUCTION LENGTH,
         SRA       R1,5                CONDITION CODE AND COMPLETION
         STC       R1,OB+50            CODE FROM PSW
         NI        OB+50,X'F6'
         MVC       OB+51(6),=C' BYTES'
         MVC       OB+38(9),OB+60
         OI        OB+50,X'F0'
         BAL       R8,PUT
         CLI       TIMESW,X'01'        IS THIS A TIMER OVERFLOW DUMP
         BE        PUTCC               YES, THEN NO INTERRUPTION CODE
         MVC       OB+20(18),=C'INTERRUPTION CODE '
         MVC       FA+2(2),2(R3)
         UNPK      OB+50(5),FA+2(3)
         MVC       OB+54(3),OB+57
         TR        OB+50(4),TRTBLH
         LH        R4,2(R3)
         N         R4,=X'0000000F'     IN CASE MOD 91 OR 195
         SLA       R4,5
         LA        R4,ERAR(R4)        POINT AT ERROR TEXT
         MVC       OB+60(32),0(R4)
         BAL       R8,PUT
*        FOLLOWING CODE OUTPUTS ERROR TEXT FOR IMPRECISE BITS
         TM        3(R3),X'0F'         TEST FOR 0 INTERRUPT CODE
         BNZ       PUTCC
         MVC       OB+20(40),OB+19     BLANK LINE
         LH        R4,2(,R3)           LOAD IMPRECISE BITS
         SLL       R4,16               SHIFT TO TOP OF REG
         LA        R5,12               NUMBER OF BITS
IMPLOOP  LTR       R4,R4               TEST SIGN BIT
         BNM       IMPEND
         SR        R8,R8               GET THE CORRESPONDING PRECISE
         IC        R8,IMPTAB-1(R5)         CODE FROM TABLE
         SLL       R8,5                POINT AT THE INTERRUPT
         LA        R8,ERAR(R8)          MESSAGE TEXT
         MVC       OB+60(32),0(R8)     MOVE IN MESSAGE
         BAL       R8,PUT              WRITE THE LINE
IMPEND   SLL       R4,1                TRY NEXT BIT
         BCT       R5,IMPLOOP          TEST IF ALL BITS DONE
PUTCC    MVC       OB+20(15),=C'CONDITION CODE '
         MVC       OB+35(57),OB+34
         SR        R5,R5                CLEAR R5
         IC        R5,4(R3)
         SRA       R5,4                 SHIFT CODE BITS OVER
         STC       R5,OB+50             TO STORE ON BYTE BOUNDARY
         NI        OB+50,X'F3'
         OI        OB+50,X'F0'          MAKE PRINTABLE
         MVC       OB+51(13),OB+65      BLANKS
         BAL       R8,PUT
         MVI       OB-1,C'-'            SET TO TRIPLE SPACE
         MVC       OB+20(18),OB         BLANKS
         MVC       OB+46(26),=C'REGISTERS AT TIME OF ERROR'
         BAL       R8,PUT
         MVI       OB-1,C'0'            SET TO DOUBLE SPACE
         MVC       OB(9),=C'R     HEX' HEADING
         MVC       OB+16(7),=C'DECIMAL'
         MVC       OB+31(87),OB         REPEAT 3 MORE TIMES
         BAL       R8,PUT              BY PROPAGATING ACROSS
         LA        R5,C'0'             NAME OF FIRST REGISTER LISTED
         LA        R7,ESDTBL            POINT TO SAVE AREA
NEXTLINE EQU       *
         LR        R4,R7                R4 WILL INCREMENT DURING LINES
         LR        R10,R5               R7 WILL INCREMENT AFTER EACH LN
         LA        R14,4                COUNTS REGISTERS PER LINE
         LA        R3,OB                POINTS TO NEXT BUFFER SECTION
BACK     STC       R10,0(R3)            REGISTER # TO BUFFER
         TR        0(1,R3),TRTBLH       MAKE PRINTABLE
         MVC       FA(4),0(R4)          MOVE CONTENTS TO UNPACK AREA
         UNPK      4(9,R3),FA(5)
         TR        4(8,R3),TRTBLH       MAKE PRINTABLE
         MVI       12(R3),C' '          BLANK DUMMY DIGIT
         L         R6,0(R4)             LOAD CONTENTS FOR CVD
         MVI       14(R3),C' '         SET + SIGN
         LTR       R6,R6               SEE IF PLUS
         BNM       *+8
         MVI       14(R3),C'-'         SET - SIGN
         CVD       R6,TIMAREA
         UNPK      15(10,R3),TIMAREA
         OI        24(R3),X'F0'
         LA        R4,4(R4)
         LA        R10,1(R10)
         LA        R3,31(R3)            POINT TO NEXT BUFFER SECTION
         BCT       R14,BACK             UNLESS ALREADY 4 REG'S, GET 1
         BAL       R8,PUT               PUT LINE
         MVI       OB-1,C' '            SET SINGLE SPACE
         LA        R7,16(R7)
         LA        R5,4(R5)
         CH        R5,=H'256'          RF DONE?
         BL        NEXTLINE             SO DONT DO IT AGAIN
         SR        R5,R5
         LA        R5,C'0'             NUMBER OF FIRST FLOATING REG
         MVI       OB-1,C'0'           SET TO DOUBLE SPACE
         STD       R0,ESDTBL
         STD       R2,ESDTBL+8
         STD       R4,ESDTBL+16
         STD       R6,ESDTBL+24
         LA        R3,ESDTBL
         LA        R4,OB
         MVI       ESDTBL+99,C' '
         MVC       ESDTBL+100(120),ESDTBL+99 BLANK BUFFER
         LA        R6,ESDTBL+100       POINT TO SECOND BUFFER
NEXTREG  EQU       *
         MVC       EXP(2),=P'00'
         MVI       6(R4),C'+'
         TM        0(R3),X'80'
         BZ        *+8
         MVI       6(R4),C'-'          NO, MOVE IN - SIGN
         MVC       0(6,R4),=C'FPR   '
         STC       R5,3(R4)            MOVE IN REGISTER NUMBER
         NI        0(R3),X'7F'         THROW OUT SIGN BIT
         MVC       FA,0(R3)            MOVE FIRST HALF TO UNPACK AREA
         UNPK      8(9,R4),FA(5)
         MVC       FA,4(R3)
         UNPK      17(9,R4),FA(5)
         TR        8(17,R4),TRTBLH     RENDER PRINTABLE
         MVC       7(2,R4),8(R4)       SHIFT CHARACTERISTIC OVER 1 BYTE
         MVI       9(R4),C'.'          TO MAKE ROOM FOR DECIMAL POINT
         MVI       16(R4),C' '         BLANK 1ST DUMMY DIGIT
         MVI       25(R4),C' '         BLANK 2ND DUMMY DIGIT
         MVC       1(1,R6),6(R4)       MOVE SIGN INTO 2ND BUFFER
         LD        R0,0(R3)
RECHECK  EQU       *                   CONVERT TO DECIMAL
         LTDR      R0,R0
         BZ        ZERO
         CD        R0,ONE
         BNL       DIV
         CD        R0,TENTH
         BL        MULT
         DD        R0,FUDGE1
         STD       R0,0(R3)
         MVI       0(R3),X'00'
         LM        R10,R11,0(R3)
         CD        R0,ONE              TEST FOR RIGHT SHIFT
         BL        *+8
         SLDL      R10,4               NULLIFY IT
         D         R10,FUDGE2          SPLIT INTO 2 DEC NUMBERS
         CVD       R11,TIMAREA
         UNPK      3(9,R6),TIMAREA
         OI        11(R6),X'F0'        RENDER PRINTABLE
         CVD       R10,TIMAREA
         UNPK      12(8,R6),TIMAREA
         OI        19(R6),X'F0'
         MVI       2(R6),C'.'              DECIMAL POINT
         MVC       21(2,R6),=C'E+'
         ZAP       EXP,EXP
         BNM       *+8
         MVI       22(R6),C'-'
         UNPK      23(2,R6),EXP
         OI        24(R6),X'F0'
RESET    EQU       *
         LA        R6,31(R6)           POINT TO NEXT BUFFER SECTION
         LA        R5,2(,R5)           POINT TO NEXT REG. NAME
         LA        R3,8(R3)            POINT TO NEXT REG. CONTENTS
         LA        R4,31(R4)           POINT TO NEXT BUFFER SECTION
         CH        R5,=H'248'  X'00',C'8'  ARE WE UP TO R8 YET?
         BL        NEXTREG             NO, BRANCH BACK
         BAL       R8,PUT
         MVC       OB-1(121),ESDTBL+99
         BAL       R8,PUT
DUMP     MVC       OB-1(26),=C'-STORAGE AT TIME OF ERROR '
         MVC       OB+25(95),OB+24
         L         R12,BEGADD-4
*        R12 POINTS TO END OF USERS CORE +2
         BCTR      R12,0               POINT TO LAST USED BYTE
         SRA       R12,5               GET FIRST BYTE OF LAST LINE TO
         SLA       R12,5               BE DUMPED
         ST        R12,ROUNDEND        SAVE END OF AREA TO BE DUMPED
         L         R3,BEGADD           POINT TO FIRST BYTE OF USERS COR
         SRA       R3,5
         SLA       R3,5
         BAL       R8,PUT              PRINT STORAGE HEADER
         MVC       OB-1(26),OB+25      BLANK ENTIRE LINE
         L         R11,COUNT
         BAL       R8,NPAGE-4
         MVI       OB-1,C' '           SET TO SINGLE SPACE
         B         *+8                 AVOID PUT
DUPLINES BAL       R8,PUT              PUT OUT LINE
         MVI       OB+8,C' '           PREPARE FOR DUMP FORMAT
         MVI       OB+86,C'*'
         MVI       OB+119,C'*'
OUTLINE  BAL       R8,OU               OU SAVES R3 (ADDRESS OF 32 BYTES
*        TO BE DUMPED IN R7, INCREMENTS R3 BY 32, AND DUMPS THE LINE
         CLC       0(64,R3),0(R7)      NEXT 2 LINES SAME AS LAST?
         BNE       OUTLINE             NO, PUT OUT FIRST
*        IF ONLY 2 LINES IN A ROW MATCH, THEY WILL BOTH BE PRINTED.
         LR        R5,R3
RUNROUND LA        R5,32(R5)           POINT TO LINE BEFORE LINE TO BE
         C         R5,BEGADD-4         CHECKED. HAS LAST LINE BEEN DUN?
         BE        *+14                YES, COMPARE NO MORE
         CLC       32(32,R5),0(R7)     NO, CHECK NEXT LINE
         BE        RUNROUND            SAME, KEEP CHECKING
         MVC       OB(6),=C' LINES'    INFORM USER OF DUPLICATE LINES
         MVI       OB+9,C' '
         MVC       OB+10(110),OB+9     BLANK BUFFER
         MVC       OB+27(13),=C'SAME AS ABOVE'
         ST        R3,FA               ADDRESS OF FIRST DUPLICATE LINE
         UNPK      OB+11(7),FA+1(4)    UNPACK INTO BUFFER
         TR        OB+11(6),TRTBLH
         MVI       OB+17,C'-'
         ST        R5,FA               LAST DUPLICATE LINE'S ADDRESS
         UNPK      OB+18(7),FA+1(4)    UNPACK INTO BUFFER
         TR        OB+18(6),TRTBLH
         MVI       OB+24,C' '          BLANK OUT DUMMY DIGIT
         LA        R3,32(R5)           POINT TO 1ST NON-DUPLICATE LINE
         B         DUPLINES            PUT MESSAGE, NEXT LINE & GO AGAN
OU       EQU       *
         C         R3,ROUNDEND         EXTRA WORK .Q
         BH        ISTHATIT            YES, REFUSE
         ST        R3,FA
         LR        R7,R3
         UNPK      OB(7),FA+1(4)       UNPACK ADDRESS INTO BUFFER
         MVI       OB+6,C' '           BLANK DUMMY DIGIT
         LA        R15,OB+9            POINT TO FIRST BUFFER POSITION
         LA        R10,2               2 TIMES THROUGH, 16 BYTES EACH
HALFB    LA        R14,4               4 WORDS PER HALF LINE
WORD     EQU       *
         L         R4,0(R3)
         ST        R4,FA               MOVE NEXT WORD TO UNPACK AREA
         LA        R3,4(R3)            POINT TO NEXT WORD
         UNPK      0(9,R15),FA(5)      UNPACK INTO BUFFER
         MVI       8(R15),C' '         BLANK DUMMY DIGIT
         LA        R15,9(R15)          POINT TO NEXT BUFFER POSITION
         BCT       R14,WORD             GO BACK UNLESS FINISHED HALF
         LA        R15,3(R15)          SKIP 3 PRINT POSITIONS
         BCT       R10,HALFB            GO BACK IF ONLY HALF DONE
         LR        R6,R9
         USING     SARA,R4
         DROP      R13
         LR        R4,R13
         LM        R8,R15,0(R7)        MOVE CHARACTERS TO BUFFER
         STM       R8,R15,OB+87
         LR        R9,R6
         LR        R13,R4
         USING     SARA,R13
         DROP      R4
         TR        OB+87(32),TRTBL     ACTUAL CHARACTERS OR . FOR I(VAL
         TR        OB(85),TRTBLH
         LA        R8,OUTLINE+4        NEVER CALLED FROM ANYWHERE ELSE
         B         PUT                 PUT LINE & RETURN (R8)
DIV      DD        R0,TEN
         AP        EXP,PONE
         B         RECHECK
MULT     MD        R0,TEN
         SP        EXP,PONE
         B         RECHECK
ZERO     MVC       1(24,R6),=C'+.00000000000000000 E+00'
         B         RESET
         DROP      R13                 RESTORE R13 BEFORE USING
         EJECT
TIMERR   EQU   *                       USER'S JOB EXCEEDED TIME LIMIT
*        OS EXPECTS A RETURN SO THAT IT CAN RESTORE CONTROL TO USER'S
*        PROGRAM.  TO AVOID THIS, WE DUMP THE USER'S CORE AND THEN
*        ZERO HIS PROGRAM AREA, ISSUE A SPIE AND RETURN TO THE USER.
*        THE RESULTING ERROR (HOPEFULLY) GIVES US BACK CONTROL AT
*        TIMER1 WHERE A NORMAL RETURN TO ASMGASM TAKES PLACE.  SPIE
*        ALSO EXPECTS A RETURN BUT THIS CAN BE SIMULATED BY TURNING
*        OFF A BIT.
*
         USING TIMERR,R15              R15 IS OUR FIRST BASE
         L     R13,=A(SARA)            NOW WE CAN USE R13
         USING SARA,R13                AS A DATA BASE
         DROP  R15
         STM   R14,R2,TIMESAVE         SAVE RETURN AND WORK REGISTERS
         L     R2,BASE
         MVI   TIMESW,X'01'            SET TIMER OVERFLOW SWITCH
         L     R1,16(0,0)              POINT AT CVT
         L     R1,0(0,R1)              POINT AT TCB ADDRESS PAIR
         L     R1,4(0,R1)              POINT AT CURRENT TCB
         L     R1,0(0,R1)              POINT AT TIMER RB
         MVC   ESDTBL(64),32(R1)       SAVE USER'S REGISTERS FOR DUMP
         L     R1,28(0,R1)             POINT AT PROGRAM RB
         MVC   TIMESAVE+4(4),20(R1)    SAVE OLD APSW FOR DUMP
         MVC   OB-1(9),=C'1ASMG304I'   MOVE IN ERROR NUMBER FOR PRINT
         MVI   OB+6,C'5'               MAKE IT 'ASMG305I'
         MVC   OB+20(57),MASK2         SET UP ERROR MESSAGE
         MVC   OB+8(12),OB+80          BLANKS
         L     R7,FULL                 LOAD TIME ALLOWED
         CVD   R7,TIMAREA              MAKE IT PACKED
         ED    OB+62(9),TIMAREA+4      ENTER TIME IN MESSAGE
         BAL   R8,PUT                  PRINT ERROR MESSAGE
         LA    3,TIMESAVE              MAKE R3 POINT TO OLD APSW-4
         MVI   OB,C' '                 BLANK START OF PRINT LINE
         MVC   OB+1(119),OB            BLANK ALL OF PRINT LINE
         B     EXER1                   RETURN FOR A DUMP
*        ZAP ABOVE BRANCH TO NOP IF NO DUMP DESIRED FOR TIMER OVERFLOWS
ISTHATIT CLI   TIMESW,X'01'            HAS A TIMER OVERFLOW OCCURRED .Q
         BNE   THATSIT                 NO, WE'RE THROUGH
         SPIE  TIMER1,((1,15))         COME BACK TO TIMER1
         L     R3,BEGADD               LOAD BEGINNING OF USER'S AREA
         MVI   0(R3),X'00'             ZERO FIRST BYTE
         LA    R0,256                  PICK UP BXH INCREMENT
         SR    R3,R0                   BACK OFF USER ADDR FOR 1ST BXH
         L     R1,ENDCORE              GET END OF USER AREA
         SR    R1,R0                   BACK OFF TO
         BCTR  R1,0                    INCR+1 BYTES BEFORE END
ENCORE   DS    0H
         BXH   R3,R0,FINCORE           BUMP UP INCR BYTES
         MVC   1(256,R3),0(R3)         ZERO SOME BYTES
         B     ENCORE                  GO DO SOME MORE
FINCORE  DS    0H
         LR    R4,R3                   COPY CURRENT ADDRESS
         SR    R4,R1                   WHAT'S DONE - (END-INCR)
         SR    R0,R4                   INCR MINUS ABOVE DIFFERENCE
         BNP   FINLM                   BRANCH IF NOTHING TO DO
         BCTR  R0,0                    LESS 1 FOR MVC
         LR    R1,R0                   TRANSFER LENGTH
         EX    R1,FINMVC               ZERO WHAT'S LEFT
FINLM    DS        0H
         LM    R14,R2,TIMESAVE         RESTORE RETURN AND WORK REGS
         BR    R14                     RETURN TO USER'S OR OTHER AREA
FINMVC   MVC   1(*-*,R3),0(R3)         EXECUTED ZERO REMAINING AREA
         DROP  R13
*        NOW STIMER IRB SHOULD BE GONE
         USING *,R15                   TEMPORARY BASE
TIMER1   L     R13,=A(SARA)            GET R13 BASE
         USING SARA,R13
         DROP  R15                     DON'T NEED IT ANY MORE
         L     R2,BASE                 RESTORE R2 BASE
         MVI   0(R1),X'00'             SIMULATE RETURN FROM SPIE
         L     R9,ESDTBL+64            RESTORE LINK TO ASMGASM
***********************************************************************
*        RESTORE PREVIOUS SPIE, IF ANY
NEARLYIT L         R1,SAVEPICA         GET OLD PICA ADDRESS
         SPIE      MF=(E,(R1))         DO THE SPIE
*
THATSIT  MVI       OB+11,C' '
         MVC       OB+12(108),OB+11
         MVC       OB-1(12),=C'0END OF TASK'
         BAL       R8,PUT
         MVC       OB-1(12),OB+11      CLEAR BUFFER TO BLANKS
         MVI       TIMESW,X'00'        RESET TIMER OVERFLOW SWITCH
         NI        ESD+1,X'0F'         RECONSTITUTE PROGRAM
         OI        TXT+1,X'F0'
         NI        TXT+5,X'0F'
         OI        RLD+1,X'F0'
         NI        FA,X'00'
         NI        FLAG,X'00'
*./      DELETE    SEQ1=14690024,SEQ2=14699024
***********************************************************************
*        CALL TCLOSE TO RESET SYSUT2 TO WRITE IN CASE WE ARE IN BATCH
         L         R1,RENNIE
         CNOP      2,4
         BALR      R0,R1
         DC        F'24'
         DC        F'4'
         DC        F'1'
***********************************************************************
***********************************************************************
*        CALL GROW TO RETURN ALL CORE OBTAINED BY VARIOUS SHRINKS.
         L         R1,ENDCORE
         S         R1,BEGADD
         ST        R1,GIVE
         L         R12,BEGADD
         ST        R12,GIVE+4
         L         R1,RENNIE
         CNOP      2,4
         BALR      R0,R1
         DC        F'32'
GIVE     DS        F
         DS        F
***********************************************************************
RETURN   EQU       *
         LR        ACT,R9
         L         R14,FDRETURN        GET RETURN ADDR TO ASMGFD
         BR        R14
         LTORG
         DS        0D                  ALIGN START OF SAVE AREA
SARA     DS        18F                 OS SAVE AREA
PATCH    DC        8S(*)               ASMGFEX PATCH AREA
TRTBL    DC        64C'.',C' ',12C'.',C'(+',C'.',C'&&',10C'.',C'$*)',2CX
               '.',C'-',10C'.',C',',17C'.',C'''=',66C'.',C'ABCDEFGHI',7X
               C'.',C'JKLMNOPQR',8C'.',C'STUVWXYZ',6C'.',C'0123456789'
         DC        6C'.'               THIS CARD MUST FOLLOW TRTBL
EOFLAG   DS        CL1
TIMESW   DC        X'00'               TIMER OVERFLOW SWITCH
SAVEPICA DC        A(0)                SAVE OLD PICA ADDRESS
SAVEPIE  DS        F
ENDCORE  DS        F
ROUNDEND DS        F                   ROUNDED END OF USER'S AREA
RENNIE   DS        F
FULL     DS        F
TIMESAVE DS        5F                  SAVE FOR R14,APSW,R0,R1,R2
FUDGE1   DC        D'.72057594037927936'
FUDGE2   DC        F'100000000'
P16      DC        P'16'
         DS        0D
C        DS        CL80
MASK2    DC        C'EXCESSIVE EXECUTION TIME. TIME ALLOWED WAS ',X'202X
               0202021',C'.',X'2020',C'0 SEC.'
         DS        0D                  DO NOT ADD DATA AFTER THIS POINT
*        STORAGE IS DELICATELY ARRANGED TO WORK. SEE NEXT COMMENTS.
         DC        C' '
*        THERE MUST BE EXACTLY 175 BYTES BETWEEN ABOVE CARD & TRTBL
*        ALSO OBM1 MUST BE ALIGNED TO A FULL WORD BOUNDARY
*        IN ADDITION, C MUST BE ALIGNED TO A DOUBLE WORD BOUNDARY
ANY      DC        X'00'               *********  NOT USED
         DS        6C                  UNUSED
FA       DC        F'0',X'CC'
EXP      DS        CL2
PONE     DC        P'1'
OBM1     DC        CL133' '
OB       EQU       OBM1+1
CCC      DS        CL1
HALF     DC        H'0'
FLAG     EQU       HALF+1
COUNT    DC        F'0'
TEN      DC        D'10'
ONE       DC       D'1'
TENTH    DC        D'0.1'
TIMAREA  DS        D
TRTBLH   EQU       *-240                FIRST 240 BYTES OF TRANSLATE
         DC        C'0123456789ABCDEF'  TABLE UNNECESSARY (NEVER USED)
ESDTBL   DS        128D
BASE     EQU       ESDTBL+68
FDRETURN DS        F                   RETURN ADDRESS TO ASMGFD
ERAR     EQU       *
         DC        C'IMPRECISE AS FOLLOWS            '
         DC          C'INVALID OP-CODE                 '
         DC          C'PRIVILEGED OP-CODE              '
         DC          C'EXECUTE OF EXECUTE              '
         DC          C'INVALID ADDRESS (PROTECTION)    '
         DC          C'INVALID ADDRESS (UNAVAILABLE)   '
         DC          C'INVALID INSTRUCTION OPERAND     '
         DC          C'INVALID DATA                    '
         DC          C'FIXED OVERFLOW                  '
         DC          C'FIXED DIVIDE OR CVB OVERFLOW    '
         DC          C'DECIMAL OVERFLOW                '
         DC          C'DECIMAL DIVIDE OVERFLOW         '
         DC          C'EXPONENT OVERFLOW               '
         DC          C'EXPONENT UNDERFLOW              '
         DC          C'SIGNIFICANCE EXCEPTION          '
         DC          C'FLOATING DIVIDE OVERFLOW        '
IMPTAB   DC        AL1(11,10,15,14,13,12,9,8,7,6,5,4)
*******  WARNING  *******    CONSTANTS ARE CAREFULLY ARRANGED
*                            TAMPERING WITH THEIR ORDER IS DANGEROUS
*        WRITTEN BY DAVE POTTER, AUGUST 1967
         END
./ ADD NAME=ASMGFI
FI       TITLE     'ASMG     INTERLUDE, ESD OUTPUT PHASE'
         ISEQ  73,78
         COPY      ASMGSET
ASMGFI   CSECT
*                                                                     *
*                                                                     *
*TITLE 'ASMGFI      G ASSEMBLER INTERLUDE PHASE                       *
*FUNCTION/OPERATION-                                                  *
*   TO WRITE THE EXTERNAL SYMBOL DICTIONARY ON SYSPRINT, SYSPUNCH,    *
*   AND/OR SYSGO DATA SETS. THE EXTERNAL SYMBOL TABLE SEGMENTS AND    *
*   LITERAL POOL BASES ARE LOCATED IN CORE. IF EXECUTE WAS REQUESTED  *
*   THEN THE ESD IS ALSO WRITTEN ON SYSUT2 FOR FEX.                   *
*ENTRY POINT- ASMGFI                                                  *
*   CALLING SEQUENCE                                                  *
*        L         SRB,=A(ASMGFI)                                     *
*        BR        SRB                  TRANSFER CONTROL TO ASMGFI    *
*INPUT-                                                               *
*   REGISTER- ACT CONTAINS CONTROL TABLE POINTER                      *
*   PARAMETERS- LITERAL BASE TABLE AND EXTERNAL SYMBOL DICTIONARY.    *
*OUTPUT-                                                              *
*   REGISTER- ACT CONTAINS CONTROL TABLE POINTER                      *
*   PARAMETERS- ADJUSTMENT TABLE AND LITERAL ADDRESS TABLE.           *
*EXTERNAL REFERENCES- NONE                                            *
*EXITS-                                                               *
*   NORMAL- TRANSFERS CONTROL TO PHASE 8 VIA                          *
*        XCTL  ,DE=(SRR)     I.E. EP=ASMGF8                           *
*   ERROR- NONE                                                       *
*TABLES/WORK AREAS-                                                   *
*   ADJUSTMENT TABLE- (1092 BYTES) CONTAINS THE EXTERNAL TABLE SEGMENT*
*                                  AND LITERAL POOL BASES             *
*./      DELETE    SEQ1=00620020,SEQ2=00620020
*   CARD- (81 BYTES) PUNCH CARD AREA FOR ESD OUTPUT                   *
*   ESDSTG- (6240 BYTES) BUFFER FOR ESD ENTRIES                       *
*   HD1-  PRINT LINE FOR FIRST LINE OF HEADING                        *
*   HD2-  PRINT LINE FOR SECOND LINE OF HEADING                       *
*   LBUFR-  PRINT LINE AREA FOR ESD OUTPUT                            *
*                                                                     *
         EJECT
         PRINT     NOGEN
         FDIMEN
         PRINT GEN
CTRTBL   EQU   CTRTBP                   TRANSLATE TABLE
GR14     EQU   14                       GENERAL REGISTER 14
GR15     EQU   15                       GENERAL REGISTER 15
*                        TYPES OF ESD ENTRIES
SDCON    EQU   0                        SECTION DEF NAME (CSECT,START)
LDCON    EQU   1                        NAME IN ENTRY
ERCON    EQU   2                        EXTERNAL REFERENCE
PCCON    EQU   4                        UNNAMED CONTROL SECTION
CMCON    EQU   5                        COMMON CONTROL SECTION
VCCON    EQU   8                        V-TYPE ADDRESS CONSTANT
DXCON    EQU   6                        DUMMY EXTERNAL SECTION
WXCONA   EQU   10                       WEAK EXTERNAL REFERENCE
*                        ENTRY AND EXTERN POINTS
         ENTRY     F7ABEND             NO CORE FOR SYMBOL TABLE ABEND
         ENTRY     SYSO1               OBJECT OUTPUT ROUTINE
         EXTRN     STGETR              SYMBOL TABLE LOOKUP IN ASMGF7S
         EJECT
         LR    FRB,SRB                  TRANSFER ENTRY ADDRESS
         USING ASMGFI,FRB               AND TELL THE ASSEMBLER
         ENTRYOUT FI,CSECT=GAECT
         BAL   SRR,FII                  CALL INTERLUDE INITIATOR
         L     ACC,CCRDCT(,ACT)         PASSED FROM F7 (SYMCARDS)
         CVD   ACC,CRDCNT               CONVERT TO PACKED
         UNPK  CDCTFD(4),CRDCNT         PUT IN CARD NUMBER
         L     ADJPTR,CADJBS(,ACT)      ADDRESS OF ADJUSTMENT TABLE
         LH    NOESD,CNOESD(,ACT)       GET NUMBER OF ESD ENTRIES
         LTR   NOESD,NOESD              IS NUMBER ZERO .Q
         BZ    CALLF8                   NOESD, CALL ASMGF8I
         SPACE
         L     GRZ,=V(ASMGF7D)          GET FINISHED ROUTINE ADDR
         USING PRINTBUF,GRZ             USE IT FOR A PRINT BUFFER
         MVC   LBUFR,L1BLANKS(GR1)      BLANK PRINT BUFFER
         MVC   HD1,L1BLANKS(GR1)        BLANK HEADER ONE
         MVI   HD1,X'FF'                PAGE EJECT
         MVC   HD1+1(8),CTITLE(ACT)     PROGRAM I.D. TO HEADING LINE
         MVC   HD1ESD(L'SD1ESD),SD1ESD  SET TITLE
         MVC   HD1PAGE(L'SD1PAGE),SD1PAGE  AND 'PAGE'
         MVC   HD2,L1BLANKS(GR1)        BLANK HEADER TWO
         MVI   HD2,X'02'                DOUBLE SPACE
         MVC   HD2SYMT(L'SD2SYMT),SD2SYMT  SECONDARY TITLE
         MVC   HD2+112(9),CTDATE(ACT)   DATE TO SECOND HEADER
         SPACE
         L     VARFLD,CRD17             POSITION IN ESD FOR ESD TEXT
*        INITIALIZE LINE COUNT TO 1 SO FIRST LINE WILL INCLUDE HEADING
         LA    ACC,1                    INITIALIZE LINES LEFT TO ONE
         STH   ACC,LINECT               STORE
         LH    NOESD,CNOESD(ACT)        NUMBER OF ESD ENTRIES
         LA        NOESD,1(0,NOESD)    ADD 1 FOR BCT
         L         ACC,CTESRB(0,ACT)   RESET CTESRP
         ST        ACC,CTESRP(0,ACT)
         L         ESDPTR,0(0,ACC)     POINT AT FIRST ESD SEGMENT
         B         FI8A                BEGIN BY JUMPING DUMMY 00 ENTRY
         EJECT
*                        BUILD THE ADJUSTMENT TABLE
*                  FIRST PASS ON ESD
FI3      CLI   TTYPE(ESDPTR),SDCON      IF TYPE = SD OR PC
         BE    FI30                     YES,BUILD ADJUSTMENT TABLE ENTR
         CLI   TTYPE(ESDPTR),PCCON
         BNE   FI8A                     NOT, DONT BUILD ADJUSTMENT TABL
 SPACE
FI30     L     ACC,CSTVAL(ACT)          GET RELATIVE LOC FROM START CD
         ST    ACC,AID(ADJPTR)          PUT IN ADJUSTMENT TABLE
         MVC   AID(1,ADJPTR),TID(ESDPTR)     MOVE IN ESD/ID
         MVC   TADDR(3,ESDPTR),ADDR(ADJPTR)     SET LOCATION IN ESD
         LA    ADJPTR,4(ADJPTR)         SET ADJPTR FOR NEXT ENTRY
         A     ACC,TLTH-1(ESDPTR)       ADD LENGTH
         LA    ACC,7(ACC)               ADJUST START VALUE
         ST    ACC,CSTVAL(ACT)          TO NEXT DOUBLE WORD
         NI    CSTVAL+3(ACT),X'F8'
 SPACE
FI8A     LA        ESDPTR,16(0,ESDPTR)  POSITION TO NEXT ESD
         LH    ACC,ITEMCT               NUMBER LEFT IN THIS BLOCK
         BCT   ACC,STARP2               BRANCH IF MORE LEFT
 SPACE
         L         ACC,CTESRP(0,ACT)   POINT AT NEXT SEGMENT
         LA        ACC,4(0,ACC)
         ST        ACC,CTESRP(0,ACT)
         L         ESDPTR,0(0,ACC)     SET ESD POINTER
         LA    ACC,16                  RESET ENTRIES/SEGMENT COUNTER
 SPACE
STARP2   STH   ACC,ITEMCT               SAVE NO. LEFT IN BLOCK
         BCT   NOESD,FI3                LOOP FOR ALL ESD ENTRIES
         ST        ADJPTR,CTADJEND(0,ACT)  END OF ADJ TABLE POINTER
 EJECT
*                             OUTPUT THE ESD
*                  SECOND PASS ON ESD
         L         ACC,CTESRB(0,ACT)   RESET SEGMENT POINTER
         ST        ACC,CTESRP(0,ACT)
         L     ESDPTR,0(0,ACC)          SET ESD POINTER
         LH    NOESD,CNOESD(ACT)           NUMBER OF ESD ENTRIES
         LA    NOESD,1(0,NOESD)        ADD 1 FOR BCT
         MVI       ITEMCT+1,16          NUMBER OF ESD S PER BLOCK
         B         FI8B                JUMP DUMMY ENTRY AGAIN
         SPACE 2
FI4      CLI   TTYPE(ESDPTR),LDCON      SEE IF AN ENTRY
         BE    FI4LD                    YES, GO COMPLETE ENTRY
TABLOOK  SR    GR2,GR2
         TRT   TTYPE(1,ESDPTR),BTBL     FIND WHERE TO BRANCH TO
         B     TYPBR(GR2)               COMPUTED BRANCH
*                        BRANCH TABLE
BTBL     DC    12AL1(FIONA-TYPBR)       IF NOT DEFINED BELOW,
*                                          THEN GO TO FIONA
 SPACE
         ORG   BTBL+SDCON               IF START OR CSECT
         DC    AL1(FI7-TYPBR)           GO TO FI7
         ORG   BTBL+ERCON               IF EXTERNAL REFERENCE
         DC    AL1(FI7-TYPBR)           GO TO FI7
         ORG   BTBL+PCCON               IF PRIVATE CODE
         DC    AL1(FI7-TYPBR)           GO TO FI7
         ORG   BTBL+CMCON               IF COMMON SECTION
         DC    AL1(FI7CM-TYPBR)         GO TO FI7CM
         ORG   BTBL+VCCON               IF V-TYPE CONSTANT
         DC    AL1(FI7VC-TYPBR)         GO TO FI7VC
         ORG   BTBL+DXCON               IF EXTERNAL DUMMY SECTION
         DC    AL1(DXD-TYPBR)           GO TO DXD
         ORG   BTBL+WXCONA              IF WEAK EXTERNAL REFERENCE
         DC    AL1(FI7WX-TYPBR)         GO TO FI7WX
         ORG
TYPBR    EQU   *-2
FIONA    B     FI8B                     SKIP AND GO TO NEXT ESD
 EJECT
*                        PROCESS ENTRY
FI4LD    CLI   TID(ESDPTR),1            HAS THIS ENTRY BEEN COMPLETED
         BE    LDCOM                    YES
 SPACE
         LA    SP1,TNAME(ESDPTR)        NO, GET ADDRESS OF NAME
         LA        SP2,8               SET SYMBOL LENGTH
         L         SRB,=A(STGETR)      DO SYMBOL TABLE LOOKUP
         BALR      SRR,SRB
         LTR   SP1,SP1                  NOT FOUND - ERROR
         BZ    FI8B
 SPACE
         CLI   ESDDD(SP1),0             ABSOLUTE - ERROR
         BZ    FI8B
 SPACE
         TM    ADJCD(SP1),4             DEFINED IN DSECT OR COM - ERROR
         BO    FI8B                     ERROR
 SPACE
         TM    ADJCD(SP1),ENTCMBS       IF XD OR LD COMPLETE
         BNZ   FI8B                     ERROR
         OI    ADJCD(SP1),ENTCMBI       SET XD COMPLETE
         TM    ADJCD(SP1),SDBIT         IS THIS A CSECT,DSECT OR EXTRN
         BC    14,FI8B                   YES,IGNORE
 SPACE
         MVC   TADDR(3,ESDPTR),VALUE(SP1)  SET ADDRESS AND LENGTH IN
         MVC   TLTH+2(1,ESDPTR),ESDDD(SP1)   ESD FROM ST
         B     ADJSCH                   CONTINUE
 SPACE
LDCOM    MVI   TID(ESDPTR),0
         SPACE 1
ADJSCH   L     ACC,CADJBS(ACT)          SET ACC TO ADJUSTMENT TABLE
ADJLP    CLC   TLTH+2(1,ESDPTR),0(ACC)  IS THIS THE RIGHT CONTROL SECT
         BE    ADJFND                     YES
 SPACE
         LA    ACC,4(ACC)               SET FOR NEXT
         B     ADJLP                    LOOP
 SPACE
ADJFND   L     ACC,0(ACC)               SET ACC WITH
         LA    ACC,0(ACC)                 ADJUSTMENT VALUE
         A     ACC,TTYPE(ESDPTR)        ADD DISPLACEMENT VALUE
         ST    ACC,TTYPE(ESDPTR)        SET TADDR
ELLDID   UNPK  TEMPAR(3),TLTH+2(2,ESDPTR)         CONVERT LLDID
         TR    TEMPAR(2),HEXTBL                   TO HEX
         MVC   LLDID(2),TEMPAR          PUT IN OUTPUT AREA
         B     RETLLD                        SET LLDID WHEN TYPE = LD
 EJECT
*                        PROCESS EXTERNAL DUMMY SECTION
DXD      MVC   ESDNO,TADDR(ESDPTR)      GET ESD NUMBER
         LH    SP1,ESDNO
         LTR   SP1,SP1                  TEST FOR ZERO
         BZ    CALN                     ZERO-GENERATE FROM DXD
         LA    SP2,15                   NON-ZERO-GENERATE FROM V-TYPE
         NR    SP2,SP1                  GET LOW ORDER BYTE
         SR        SP1,SP2             SP1 = SEGMENT NUMBER
         SLL   SP2,4                    FIND THE DSECT IN THE
         SRL   SP1,2                    ESD TABLE THAT THIS
         A         SP1,CTESRB(0,ACT)    Q-TYPE REFERENCES
         L     SP1,0(0,SP1)
         AR    SP1,SP2
         MVC   TLTH(3,ESDPTR),TLTH(SP1)           MOVE IN DSECT LENGTH
CALN     MVC   CALIGN(1,VARFLD),TALIGN(ESDPTR)    PUT IN ALIGNMENT
FI7CM    XC    TADDR(3,ESDPTR),TADDR(ESDPTR)  SET COM TO ZERO
         B     FI7                      CONTINUE
*                        V-TYPE CONSTANTS
FI7VC    MVI   TTYPE(ESDPTR),ERCON      SET V-TYPE SAME AS EXTERNAL
         B     FI7                      CONTINUE
 SPACE
*                        WEAK EXTERNAL REFERENCE
FI7WX    MVI   TTYPE(ESDPTR),WXCONA     SET WXTRN SAME AS V-TYPE
         SPACE 1
*                        START, CSECT, PRIVATE CODE, OR EXTERNAL
FI7      UNPK  TEMPAR(3),TID(2,ESDPTR)  CONVERT TID TO HEX
         TR    TEMPAR(2),HEXTBL
         MVC   LID(2),TEMPAR                 SET LID
         CLI   COL15,C' '               SEE IF COLUMN 15 HAS BEEN SET
         BNE   ISITER                   YES, DONT SET AGAIN
 SPACE
STCL15   MVC   COL15+1(1),TID(ESDPTR)        SET COL15 = TID
         MVI   COL15,X'0'
ISITER   CLI   TTYPE(ESDPTR),ERCON      SEE IF EXTERNAL TYPE
         BE    EER                      YES, BRANCH
         CLI   TTYPE(ESDPTR),WXCONA     SEE IF WEAK EXTERNAL TYPE
         BE    EER                      YES, BRANCH
 SPACE
ELLTH    UNPK  TEMPAR(7),TLTH(4,ESDPTR) CONVERT LENGTH
         TR    TEMPAR(6),HEXTBL         TO HEX FOR OUTPUT
         MVC   LLTH(6),TEMPAR
 SPACE
RETLLD   MVC   CLTH(3,VARFLD),TLTH(ESDPTR)   SET CLTH
         UNPK  TEMPAR(7),TADDR(4,ESDPTR)     CONVERT LADDR TO HEX
         TR    TEMPAR(6),HEXTBL
         MVC   LADDR(6),TEMPAR               SET LADDR
         OC    LALIGN(1),CALIGN(VARFLD) SET ALIGNMENT
         B     RETEER                   ALREADY SET CLTH SO SKIP NEXT
 SPACE
EER      MVC   CLTH(3,VARFLD),CLTH-1(VARFLD)
RETEER   L     ACC,CTRTBL(ACT)          ADDRESS OF TRT TABLE
         TR    TNAME(8,ESDPTR),0(ACC)        CAUTION - CHANGES ESD
         MVC   CNAME(8,VARFLD),TNAME(ESDPTR) SET CNAME
         MVC   LNAME(8),TNAME(ESDPTR)          AND LNAME
         MVC   CTYPP(4,VARFLD),TTYPE(ESDPTR) SET CTYPE AND CADDR
         SR    ACC,ACC
         IC    ACC,TTYPE(ESDPTR)        GET TYPE
         AR    ACC,ACC                  DOUBLE
         LA    ACC,TYPTBL(ACC)          POINT AT NAME IN TABLE
         MVC   LTYPE(2),0(ACC)          MOVE TYPE NAME FROM TABLE
 SPACE
MOD20ZAP LA    VARFLD,*-*+16(,VARFLD)   BUMP VARFLD BY ESD ENTRY LENGTH
         C     VARFLD,CRDTOP            SEE IF CARD IMAGE IS FULL
         BNE   OUTLNE                   NO, DONT PUT OUT CARD
 SPACE
NOROUT   MVI   CBYTE+1,*-*+X'30'        PUT IN NO. BYTES IN CARD
         BAL   INTSUB,SUB               OUTPUT ESD CARD IMAGE
OUTLNE   DS    0H
         TM    CTESDI(ACT),X'20'        WAS ESD OPTION SPECIFIED .Q
         BZ    FI8B                     BRANCH IF NOT
         LH    ACC,LINECT               GET LINE COUNT
         BCT   ACC,LINEOK               REDUCE COUNT BY ONE
         BAL   SRR,PRNTHD               IF ZERO, START WITH A HEADED PG
LINEOK   DS    0H
         STH   ACC,LINECT               SAVE UPDATED LINE COUNT
         LA    SP1,LBUFR                ADDR OF PRINT AREA
         BAL   SRR,SYSL                 PRINT ON SYSPRINT
         L     GR1,ADLIST1(,ACT)        POINT TO LIST1 COMMON AREA
         MVC   LBUFR(L'LBUFR),L1BLANKS(GR1)  BLANK THE LINE
 SPACE
FI8B     LA    ESDPTR,16(0,ESDPTR)      POSITION TO NEXT ESD
         LH    ACC,ITEMCT               NUMBER LEFT IN THIS BLOCK
         BCT   ACC,FI9                  BRANCH IF MORE LEFT
 SPACE
         L         ACC,CTESRP(0,ACT)   POINT AT NEXT SEGMENT
         LA        ACC,4(0,ACC)
         ST        ACC,CTESRP(0,ACT)
         L         ESDPTR,0(0,ACC)
         LA    ACC,16                  RESET ENTRIES PER SEG COUNTER
FI9      STH   ACC,ITEMCT               SAVE NUMBER LEFT IN BLOCK
         BCT   NOESD,FI4                LOOP FOR ALL ESD ENTRIES
 SPACE
FI10     S     VARFLD,CRD17             GET NUMBER OF FIELDS IN CARD
         BZ    FI5                      NONE, CONTINUE ON
 SPACE
         SH    VARFLD,=H'16'            SEE IF ONE OR TWO FIELDS LEFT
         LA    INTSUB,FI5               RETURN FOR OUTPUT CARD ROUTINE
         BZ    ONEFLD                   ONE FIELD LEFT - PUT IT OUT
 SPACE
         MVI   CBYTE+1,X'20'            TWO FIELDS LEFT
         B     SUB                      PUT IT OUT
 EJECT
*                        BUILD THE LITERAL ADDRESS TABLES (LAT)
FI5      L         SRR,LBPTR           POINT AT NEXT LBT/LAT ENTRY
         L         SRR,16(0,SRR)       CHAIN POINTER
         LTR       SRR,SRR             TEST FOR NO MORE ENTRIES
         BZ        CALLF8               NO MORE LBT S, GET NEXT PHASE
 SPACE
         ST        SRR,LBPTR            SET AS NEXT POINTER
         SR        ACC,ACC             INITIALIZE ADDRESS
         L     ADJCT,CADJBS(ACT)        SET PTR TO ADJ BASE FOR SEARCH
         IC    GRB,LBTID(LBTPTR)
         STC       GRB,LOOPSR+1         SET UP LBT/ID
LOOPSR   CLI       AID(ADJCT),*-*         SEARCH ESD ADJ TAB WITH LBTID
         BE    RELFND                       FOUND
         LA    ADJCT,4(ADJCT)              IF NOT, INCREMENT ESD ADJPTR
         CLR   ADJCT,ADJPTR               ARE WE AT TOP
         BL    LOOPSR                   NO, TRY AGAIN
         B     ATOP                     YES
 SPACE 3
RELFND   MVC   TEMPF+1(3),ADDR(ADJCT)   SET LITERAL ADJ TABLE
         A     ACC,TEMPF                WHERE IT WAS FOUND
ATOP     MVC   TEMPF+1(3),LITAD(LBTPTR)
         A     ACC,TEMPF                1ST ITEM = ID, ADDR, + LITAD
         ST    ACC,AID(LADJP)
         MVC   TEMPF+1(3),D8(LBTPTR)
         A     ACC,TEMPF                2ND ITEM = 1ST + D8
         ST    ACC,AID+4(LADJP)
         MVC   TEMPF+1(3),D4(LBTPTR)
         A     ACC,TEMPF                3RD ITEM = 2ND + D4
         ST    ACC,AID+8(LADJP)
         MVC   TEMPF+1(3),D2(LBTPTR)
         A     ACC,TEMPF                4TH ITEM = 3RD + D2
         ST    ACC,AID+12(LADJP)
*        SET ESD ID
         STC       GRB,AID+00(0,LADJP)
         STC       GRB,AID+04(0,LADJP)
         STC       GRB,AID+08(0,LADJP)
         STC       GRB,AID+12(0,LADJP)
         B         FI5
 EJECT
*                        PUNCH OUTPUT CARD
ONEFLD   MVI   CBYTE+1,X'10'            NUMBER BYTES FOR ONE FIELD
SUB      MVI   CBYTE,X'0'                    INTERNAL SUBROUTINE FOR
         MVC   CRDNME(4),CTITLE(ACT)    OUTPUTTING CARD IMAGE
         CVB   ACC,CRDCNT               PUT IN CARD SEQUENCE
         LA    ACC,1(ACC)               ADD ONE
         CVD   ACC,CRDCNT
         UNPK  CDCTFD(4),CRDCNT         PUT IN COUNT FIELD
         OI    CDCTFD+3,X'F0'           SET ZONE
         LA    SP1,CARD-1               WHERE TO START OUTPUTTING
         BAL   SRR,SYSO                 PUT OUT CARD
         L     VARFLD,CRD17             RESTORE WHERE TO PUT ESD ON CD
         MVC   CARD+5(67),CARD+4        BLANK OUT CARD
         BR    INTSUB                   RETURN
 SPACE
*                        PRINT HEADING
PRNTHD   ST    SRR,SAVEF                SAVE RETURN
         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM
         L     ACC,L1PAGENO(,SRR)       GET CURRENT PAGE NUMBER
         LA    ACC,1(,ACC)              INCREMENT PAGE COUNT BY ONE
         ST    ACC,L1PAGENO(,SRR)       UPDATE CURRENT PAGE NUMBER
         CVD   ACC,PGCNT                CONVERT PAGE COUNT TO PACKED
         MVC   CNTFLD,=X'40202120'      EDIT MASK WITH BLANKS
         ED    CNTFLD,PGCNT+6           EDIT IN PAGE NUMBER
*./      DELETE    SEQ1=06940020,SEQ2=07000020
         LA    SP1,HD1                  PRINTS HEADING ONE
         BAL   SRR,SYSL                 CALL SYSLIST
         LA    SP1,HD2                  PRINTS HEADING TWO
         BAL   SRR,SYSL                 CALL SYSLIST
         MVI   LBUFR,X'01'              RESET PRINT BUFFER TO SKIP LINE
         SR    ACC,ACC
         IC    ACC,CTPGLNCT(ACT)        SET LINE COUNT
         L     SRR,SAVEF                RESTORE RETURN ADDRESS
         BR    SRR                      RETURN
MVBLNK   MVC   CNTFLD(*-*),=CL6' '      EXECUTED MOVE TO BLANK LEAD 0'S
 EJECT
* F/INTERLUDE INITIALIZATION
         SPACE 1
FII      DS    0H
         L         GR1,CTXIO1(0,ACT)   PUT ADJ TAB IN F7 OUTPUT BUFFER
         S         GR1,=F'1092'
         ST    GR1,CADJBS(ACT)          ADDRESS OF ADJUSTMENT TABLE
         LA    SP1,CTLBTP-16(0,ACT)     LBT CHAIN
         ST    SP1,LBPTR                LOG REC PTR
         NI        CTXRFI(ACT),X'FD'   TURN OFF XREF SWITCH FOR F7S
         L         GR1,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM
         CLC       =C'20',L1ISNAME+6(GR1)  INSTRUCTION SET 20 .Q
         BNE       FIIDONE             NO, PROCEDE
         MVI       MOD20ZAP+3,X'30'    YES, ONLY 1 ESD ENTRY PER CARD
         MVI       NOROUT+1,X'10'      LENGTH OF DATA PER CARD IS 16
FIIDONE  TM        CTEXEC(ACT),X'20'   IS EXECUTE ON .Q
         BCR       8,SRR               NO, EXIT NOW
         MVI       PCHX+1,0            NOP THE OBJECT ON SYSUT2 SWITCH
         BR    SRR                      EXIT
 EJECT
* F/INTERLUDE PHASE CLOSE
******************
 SPACE
CALLF8   MVC   CCRDCT(4,ACT),CDCTFD     MOVE IN CARD COUNT
         LA    GRZ,IOSAVE               SAVE AREA FOR OS/360
******************
         L     SRR,ADLIST1(,ACT)        GET ADDRESS OF LIST1 IN ASM
         LA    SRR,L1BLDL+5*L1LENBL(,SRR) BLDL TABLE ADDRESS OF F8
         XCTL  ,DE=(SRR)                CALL IN PHASE ASMGF8 IN ASMGF8I
         EJECT
* SYSTEM OUTPUT SUBROUTINE G ASSEMBLER
         USING SYSO1,FRB                TEMP ENTRY FROM F7I
SYSO1    DS    0H
         SH    FRB,=AL2(SYSO1-ASMGFI)  SET UP NORMAL BASE
         USING ASMGFI,FRB              REVERT TO ACTUAL BASE
SYSO     LA    SP1,1(SP1)               BYPASS CTL CHAR.
         STM   13,1,IOSAVE              SAVE
         LA    13,IOSAVE+20             AND SET UP SAVE AREA
         TM    CTPCHI(ACT),X'80'        PUNCH OPTION BIT
         BZ    PCHI                     NO, DONT PUNCH CARD
         L     1,PCHDCB(ACT)            YES, GET PUNCH DCB
         PUT   (1),(SP1)                OUTPUT TO SYSPUNCH
PCHI     TM    CTCGOI(ACT),X'40'        LOAD OPTION SPECIFIED .Q
         BZ    PCHX                     NO, DON'T PUT ON SYSLIN
         L     1,GODCB(,ACT)            YES, GET SYSLIN DCB
         PUT   (1),(SP1)                OUTPUT TO SYSLIN
PCHX     BC        *-*+15,PCHX1(*-*)   OBJECT ON SYSUT2 FOR FEX SWITCH
         ST        SP1,PCHAD           PUT DATA ADDRESS IN WRITE CALL
         L         GR1,BUFFPT(0,ACT)   DO A WRITE ON SYSUT2
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(8,4)
PCHAD    DS        F
         DC        A(80)               RECORD LENGTH
         L         GR1,BUFFPT(0,ACT)   DO A CHECK ON SYSUT2
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,4)
PCHX1    LM    13,1,IOSAVE              RESTORE REGISTERS
         BR    SRR                      RETURN
 EJECT
* SYSTEM LIST SUBROUTINE G ASSEMBLER
*
SYSL     DS    0H
         STM   GRZ,GR1,IOSAVE           SAVE 13-01
         LA    GRZ,IOSAVE+20            O/S SAVE AREA
         L     GR1,LSTDCB(,ACT)         GET SYSPRINT DCB ADDRESS
         PUT   (1),(SP1)                PUT OUT RECORD
*./      DELETE    SEQ1=08440020,SEQ2=09180020
         LM    GRZ,GR1,IOSAVE           RESTORE 13-01
         BR    SRR                      AND RETURN
         SPACE 5
*        NO CORE FOR SYMBOL TABLE ABEND
*./      DELETE    SEQ1=09280020,SEQ2=09380020
F7ABEND  L         GR1,ADLIST1(,ACT)   POINT TO LIST1 IN ASMGASM
         BAL       GR0,L1ABEND(,GR1)   GO TO ABEND ROUTINE IN ASM
         DC        C'996I',AL1(L'MES996-1)
MES996   DC        C'INSUFFICIENT MEMORY TO PROCESS SYMBOL TABLE'
  SPACE 2
IOSAVE   DS    23F                      IO REGISTER SAVE AREA
 EJECT
*                        INDEX IN ESD TABLE
TTYPE    EQU   0                        TYPE
TADDR    EQU   1                        ADDRESS
TALIGN   EQU   3                        ALIGNMENT
TID      EQU   4                        ESD/ID
TLTH     EQU   5                        LENGTH
TNAME    EQU   8                        NAME
 SPACE
TYPTBL   DC    C'SDLDER  PCCMXD      WX'  ESD TYPE IN EBCDIC
HXTBL    DC    C'0123456789ABCDEF'      TABLE TO CONVERT TO HEX
HEXTBL   EQU   HXTBL-240
*./      DELETE    SEQ1=09760020,SEQ2=09780020
         SPACE 2
ITEMCT   DC    H'16'                    COUNT PER ESD BLOCK
LINECT   DS    H                        LINES PER PAGE, INIT TO ONE
         SPACE
         DS    0D                       FOR ALIGNMENT
CRDCNT   DC    PL8'0'                   CARD COUNT
PGCNT    DC    PL8'0'                   PAGE COUNT WORK AREA
 SPACE
         LTORG
 SPACE
ESDNO    DC    H'0'                     NUMBER OF ESD
 EJECT
PRINTBUF DSECT
LBUFR    DS    0CL133                   SYSPRINT LINE BUFFER
         DC    X'00'                    NUMERIC CARRIAGE CONTROL
LNAME    DC    10C' '                   NAME
LTYPE    DC    4C' '                    TYPE
LID      DC    3C' '                    ESD/ID
LADDR    DC    7C' '                    ADDRESS
LALIGN   EQU   LADDR+5                  ALIGNMENT
LLTH     DC    8C' '                    LENGTH
LLDID    DC    87C' '                   LD ID
         DC    CL13' '                  TRAILING BLANKS
 SPACE
HD1      DS    0CL133                   FIRST LINE OF HEADING
         DC    X'FF'                    PAGE EJECT
         DC    CL46' '
HD1ESD   DC    CL65'EXTERNAL SYMBOL DICTIONARY'
HD1PAGE  DC    C'PAGE '
CNTFLD   DC    CL4' '                   PAGE NUMBER
         DC    CL12' '                  TRAILING BLANKS
 SPACE
HD2      DS    0CL133                   SECOND LINE OF HEADING
         DC    X'02'                    DOUBLE SPACE
HD2SYMT  DC    C'SYMBOL   TYPE ID  ADDR  LENGTH LD ID'
         DC    CL96' '                  TRAILING BLANKS AND DATE
ASMGFI   CSECT
SD1ESD   DC    C'EXTERNAL SYMBOL DICTIONARY'
SD1PAGE  DC    C'PAGE'
SD2SYMT  DC    C'SYMBOL   TYPE ID  ADDR  LENGTH LD ID'
 SPACE
         CNOP      6,8                 PUT CARD ON D BOUNDRY
         DC    H'0'                     CARD CONTROL CHARACTER
CARD     DC    X'02C5E2C4404040404040'  CARD IMAGE   (ESD)
         DC    70C' '
CBYTE    EQU   CARD+10                  NUMBER OF BYTES ON CARD
COL15    EQU   CARD+14                  COLUMN 15
CRDNME   EQU   CARD+72                  CARD NAME
CNAME    EQU   0                        NAME RELATIVE TO VARFLD
CTYPP    EQU   8                        TYPE
CALIGN   EQU   12                       ALIGNMENT
CLTH     EQU   13                       LENGTH
         ORG   CARD+76
CDCTFD   DC    ZL4'0'                   CARD NUMBER
         ORG
CRD17    DC    A(CARD+16)               BEGINNING OF VARFLD
CRDTOP   DC    A(CARD+64)               END OF VARFLD
 SPACE
TEMPF    DS    0F                       CONTIGUOUS
         DC    X'0'                     WORKSPACE
TEMPAR   DC    XL3'0'                    AND
SAVEF    DC    F'0'                      SAVE AREA
 SPACE
LBPTR    DS        F                    POINTER IN LBT
 EJECT
AID      EQU   0                        ID IN ADJUSTMENT
ADDR     EQU   1                        ADDRESS IN ADJUSTMENT TABLE
ENTCMBS  EQU   X'18'                    MASK FOR COMPLETION OF XD OR LD
SDBIT    EQU   3                        MASK FOR CSECT,DSECT,OR EXTERN
ENTCMBI  EQU   X'10'                    MASK FOR COMPLETE CD
LBTID    EQU   3                        LITERAL BASE TABLE ID
LITAD    EQU   4                        LBT  ADDRESS
D8       EQU   7                        LENGTH OF 8 BYTE STRINGS
D4       EQU   10                                 4
D2       EQU   13                                 2
ADJCD    EQU   1                        ADJECTIVE CODE IN SYMBOL TABLE
ESDDD    EQU   2                        ESD ID
VALUE    EQU   3                        VALUE OF SYMBOL
 SPACE
**                            REGISTER USAGE                         **
*
U1       EQU   FRB            BASE REGISTERS
ESDPTR   EQU   GRA            POINT TO ESD TABLE
VARFLD   EQU   GRB            POINTS TO FIELD ON CARD
SEGNO    EQU   GRB                      NO OF SEGMENTS TO FETCH
LBTPTR   EQU       SRR        POINTS TO LITERAL BASE TABLE
NOESD    EQU   GRC            COUNTS THROUGH ESD
SRPTR    EQU   GRC
ADJPTR   EQU   GRD            POINTS TO ESD ADJUSTMENT TABLE
LADJP    EQU       SRR        POINTS TO LITERAL ADJUSTMENT TABLE
ACC      EQU   SP1           ACCUMLATOR
DSPTR    EQU   GRY
INTSUB   EQU   GRY            REGISTER FOR SUBROUTINE SUB
ADJCT    EQU   GRY            USED TO SEARCH ADJ TABLE FOR A LIT POOL
 SPACE
         END       ASMGFI
./ ADD NAME=ASMGFPP
FPP      TITLE     'ASMG     POST PROCESSOR'
         ISEQ      73,78
         COPY      ASMGSET
*                                                                     *
ASMGFPP  START
         PRINT     NOGEN
         FDIMEN
         PRINT     GEN
         SPACE
*                                                                     *
*TITLE 'ASMGFPP ' ... POST PROCESSOR                                  *
*FUNCTION/OPERATION-                                                  *
*  ASMGFPP SORTS, PRINTS, AND PUNCHES THE RELOCATION DICTIONARY (RLD) *
*   SORTS AND PRINTS THE SYMBOL CROSS-REFERENCE (XRF),                *
*   AND PROCESSES AND PRINTS THE LITERAL CROSS-REFERENCE (LRF).       *
*ENTRY POINT- ASMGFPP  CALLED VIA                                     *
*        XCTL  EP=ASMGFPP               CALL POST PROCESSOR           *
*INPUT- RECORDS TYPE 7 (XRF) AND 8 (RLD)                              *
*   FORMAT OF THE XRF RECORD TYPE 7 IS-                               *
*                                                                     *
*   *******************************************************           *
*   *                                     *               *           *
*   *          SQUISHED SYMBOL            *   STATEMENT   *           *
*   *                                     *    NUMBER     *           *
*   *******************************************************           *
*    BYTES            6                            2                  *
*                                                                     *
*   FORMAT OF THE RLD RECORD TYPE 8 IS-                               *
*                                                                     *
*   **************************************************                *
*   *       *          *            *      *         *                *
*   * TABLE * POSITION * RELOCATION * FLAG * SYMBOL  *                *
*   *  ID   *   ID     *    ID      *      * ADDRESS *                *
*   **************************************************                *
*   BYTES 1      1          1           1       3                     *
*        FLAG- BITS                                                   *
*               0-1  00                                               *
*               2-3  00  A AND Y TYPE ADDRESS CONSTANTS               *
*                    01  V TYPE ADDRESS CONSTANTS                     *
*                    10  Q TYPE ADDRESS CONSTANTS                     *
*                    11  CXD                                          *
*               4-5      LENGTH OF ADDRESS CONSTANT MINUS ONE         *
*                6       ESD SIGN 0=PLUS(+), 1=MINUS(-)               *
*                7    0  NEXT ENTRY HAS SAME POSITION AND RELOCATION  *
*                        ID                                           *
*                     1  NEXT ENTRY HAS DIFFERENT POSITION AND/OR     *
*                        RELOCATION ID                                *
         SPACE
*                                                                     *
*   FORMAT OF THE LREF RECORDS IN THE SYMBOL TABLE IS --              *
*                                                                     *
*DISP     -6                -3              0               3         *
*   ***************************************************************   *
*   *                 *               *               *           *   *
*   * START REF CHAIN * END REF CHAIN * LITERAL CHAIN * AS BEFORE *   *
*   *             F7D *           F7D *           F7G *           *   *
*   ***************************************************************   *
*BYTES    3                 3               3             7+LV        *
*                                                                     *
*DISP   10+LV        12+LV      13+LV       16+LV                     *
*   **************************************************                *
*   *             *         *            *           *                *
*   * STMT NUMBER *  ESDID  *  LOCATION  * AS BEFORE *                *
*   *         F7G *     F7G *        F7G *           *                *
*   **************************************************                *
*BYTES    2            1          3           11                      *
*                                                                     *
*        WHERE  LV = LENGTH OF TEXT FORM OF LITERAL                   *
*                                                                     *
         SPACE     2
*OUTPUT- THE RELOCATION DICTIONARY AND CROSS REFERENCE IS PRINTED ON  *
*        SYSPRINT. RLD AND END CARDS ARE PUT ON SYSPUNCH AND/OR SYSGO.*
*   FORMAT OF RLD CARD-                                               *
*       COLUMN      CONTENTS                                          *
*          1        12-2-9 PUNCH                                      *
*         2-4       'RLD'                                             *
*         5-10      BLANK                                             *
*        11-12      NUMBER OF BYTES IN DATA FIELD                     *
*        13-16      BLANK                                             *
*        17-72      DATA FIELD                                        *
*           17-18      POSITION ESD/ID                                *
*           19-20      RELOCATION ESD/ID                              *
*            21        FLAG (SAME AS RLD INPUT)                       *
*           22-24      ABSOLUTE ADDRESS                               *
*           25-72      REMAINING RLD ENTRIES                          *
*        73-76      DECK ID                                           *
*        77-80      CARD SEQUENCE NUMBER                              *
*   FORMAT OF END CARD-                                               *
*       COLUMN      CONTENTS                                          *
*          1        12-2-9 PUNCH                                      *
*         2-4       'END'                                             *
*          5        BLANK                                             *
*         6-8       ENTRY ADDRESS FROM OPERAND OF END CARD            *
*         9-14      BLANK                                             *
*        15-16      ESDID OF ENTRY POINT                              *
*        17-30      BLANK                                             *
*         31        IDR COUNT  (BLANK,C'1' OR C'2')                   *
*        32-50      IDR1 IDENTIFYING THIS ASSEMBLER                   *
*           32-41      I.D.                                           *
*           42-45      VERSION/LEVEL                                  *
*           46-50      JULIAN DATE                                    *
*        51-69      IDR2 FROM SECOND OPERAND OF END CARD              *
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
*   NAME           DECK       USE                                     *
*   CTDUMP(ACT)    ASMGRTA    FOR PATCHES TO FPP AND FD               *
*   ASMGFD         ASMGFD     FOR DIAGNOSTIC OUTPUT                   *
*EXITS- CALLS ASMGFD VIA-                                             *
*        L     R15,=V(ASMGFD)                                         *
*        BR    R15                                                    *
         EJECT
*TABLES/WORKAREAS-                                                    *
*   XRFTAB         I/O CONTROL INFO FOR READING XREF                  *
*   RLDTAB         I/O CONTROL INFO FOR READING RLD                   *
*   IOSAVE     OS SAVE AREA                                           *
*   SAVE       GENERAL REGISTER SAVE AREA                             *
*   UMPH1      USING MAP HEADING ONE                                  *
*   UMPH2      USING MAP HEADING TWO                                  *
*   LRFH1      LITERAL CROSS-REFERENCE HEADING ONE                    *
*   LRFH2      LITERAL CROSS-REFERENCE HEADING TWO                    *
*   XRFH1      CROSS REFERENCE HEADING ONE                            *
*   XRFH2      CROSS REFERENCE HEADING TWO                            *
*   RLDH1      RELOCATION DICTIONARY HEADING ONE                      *
*   RLDH2      RELOCATION DICTIONARY HEADING TWO                      *
*   RLDOUT     CARD IMAGE FOR RLD AND END PUNCH                       *
*   RESBUF     INTERNAL I/O BUFFER                                    *
*   ICT        INPUT CONTROL TABLE                                    *
*      THE FORMAT OF THE I/O CONTROL TABLE  (ICT)  IS-                *
*       WORD  TABLE+     CONTENTS                                     *
*         0      0       POINTER TO END OF BLOCK                      *
*         1      4       POINTER TO NEXT RECORD                       *
*         2      8       LENGTH OF RECORD                             *
*         3     12       TYPE OF BUFF ROUTINE READ TO USE             *
*       1 BYTE  16       RECORD TYPE                                  *
*NOTES-                                                               *
*   STORAGE IS OBTAINED BY A SHRINK TO BUFF ROUTINE IF NECESSARY.     *
*   IF THE REQUIRED STORAGE IS NOT AVAILABLE THE ASSEMBLY IS ABENDED. *
*                                                                     *
*                                                                     *
         SPACE     2
         ENTRY     ERRBUF
         ENTRY     TERLI
         ENTRY     ERRCDL
*                                                                     *
         SPACE     2
XRFLN    EQU       8                   XRF LOGICAL RECORD LENGTH
RLDLN    EQU       6                   RLD LOGICAL RECORD LN
BLKFC1   EQU       200                 XRF BLOCKING FACTOR
BLKFC2   EQU       20                  RLD BLOCKING FACTOR
R0       EQU       0
R1       EQU       1
R2       EQU       2
*ACT     EQU       3                                                  *
R4       EQU       4
R5       EQU       5
R6       EQU       6
R7       EQU       7
R8       EQU       8
R9       EQU       9
R10      EQU       10
*11      EQU       11                                                 *
R12      EQU       12
R13      EQU       13
R14      EQU       14
R15      EQU       15
*                                                                     *
*        BITS NEEDED FOR TWO-COLUMN XREF AND THREE-COLUMN RLD         *
*                                                                     *
MULT     EQU       X'80'               TWO COLUMNS REQUESTED
TRIPLE   EQU       X'40'               THREE COLUMNS REQUESTED
MTBUFF   EQU       X'20'               BUFFER BEING EMPTIED
PTOP     EQU       X'10'               TOP OF PAGE BIT
CTOP     EQU       X'08'               TOP OF COLUMN BIT
RMULT    EQU       X'04'               GLOBAL MULT BIT
XFIRST   EQU       X'01'               FIRST TIME FOR XREF HEADING
*        **************************************************************
         SPACE     4
         LR        R12,R15             TRANSFER BASE ADDRESS
         USING     ASMGFPP,R12         AND TELL THE ASSEMBLER
         LA        R13,IOSAVE          POINT TO OS SAVE AREA
         USING     IOSAVE,R13          USE IT FOR DATA AREA
         ENTRYOUT  FPP
*        **************************************************************
* PHASE INITIALIZATION                                                *
*        **************************************************************
         MVC       DKNO(4),CCRDCT(ACT) CARD COUNT
         MVC       DKID(4),CTITLE(ACT) PARTIAL PROGRAM I.D. ON DECK
         MVC       HEAD1+1(8),CTITLE(ACT) PROGRAM I.D. TO PAGE HEADING
         MVC       HEAD2+112(9),CTDATE(ACT) DATE TO PAGE HEADINGS
         L         R1,ADLIST1(,ACT)    POINT TO LIST1 IN ASMGASM
         SR        R2,R2               CLEAR OUT A WORK REGISTER
         IC        R2,L1COLCT(,R1)     GET COL= VALUE
         IC        R2,CTAB(R2)         GET CORRESPONDING BIT SETTINGS
         STC       R2,CFLGS            INITIALIZE THE FLAGS
         L         R1,CADJBS(,ACT)     MOVE ADJUSTEMENT TABLE INTO PROG
         MVC       ADJBS(256),0(R1)
         MVC       ADJBS+256(256),256(R1)
         MVC       ADJBS+512(256),512(R1)
         MVC       ADJBS+768(256),768(R1)
         MVC       ADJBS+1024(68),1024(R1)
         L         R2,CTADJEND(,ACT)   SET END POINTER
         SR        R2,R1
         LA        R2,ADJBS(R2)
         ST        R2,ADJBSEND
*        **************************************************************
*        PRINT USING MAP IF ENTRIES PRESENT                           *
*        **************************************************************
         L         R2,STUMAP(,ACT)     GET CHAIN OF UMAP ENTRIES
         LTR       R2,R2               ARE THERE ANY .Q
         BZ        LRFLOD              IF NOT THEN DO THE LREF
         MVC       HEAD1ID,UMP1ID      SET HEADER ONE
         MVI       HEAD2ID,C' '        CLEAR HEADER TWO
         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT
         MVC       HEAD2ID(L'UMP2ID),UMP2ID  SET SECOND HEADER
         TM        CFLGS,MULT          IS IT MULTIPLE COLUMNS .Q
         BZ        UMPSING             BRANCH IF NOT
         MVC       HEAD2ID+60(L'UMP2ID),UMP2ID  MULTIPLE HEADER
UMPSING  DS        0H
         USING     USNGMAP,R2          SET USING POINTER
         LA        R1,1                INITIALIZE LINES LEFT ON PAGE
         ST        R1,CTLINECT(,ACT)   PASS IT ON
         LA        R7,UMAPOUT+1        OUTPUT LINE POSITION
         SR        R6,R6               ZERO AREA OFFSET OF UMAP BLOCK
UMPNXT   DS        0H
         SR        R1,R1               CLEAR A WORK REGISTER
         IC        R1,USNGREG(R6)      GET REGISTER NUMBER
         CVD       R1,DWORD            CONVERT TO DECIMAL
         MVC       0(6,R7),EDMASK      MOVE IN EDIT MASK
         ED        0(6,R7),DWORD+5     EDIT IN REGISTER NUMBER
         LH        R1,USNGSTRT(R6)     GET USING STATEMENT NUMBER
         N         R1,=X'0000FFFF'     REMOVE NEGATIVE BITS
         CVD       R1,DWORD            CONVERT TO DECIMAL
         MVC       12(6,R7),EDMASK     MOVE IN EDIT MASK
         ED        12(6,R7),DWORD+5    EDIT IN USING STATEMENT NUMBER
         LH        R1,USNGDROP(R6)     GET DROP STATEMENT NUMBER
         N         R1,=X'0000FFFF'     REMOVE NEGATIVE BITS
         LTR       R1,R1               WAS REGISTER NEVER DROPPED .Q
         BNZ       UMPDRP              BRANCH IF DROPPED
         MVC       26(3,R7),ENDCR      ENTER 'END'
         B         USGCPS              BRANCH AROUND
UMPDRP   DS        0H
         CVD       R1,DWORD            CONVERT TO DECIMAL
         MVC       23(6,R7),EDMASK     MOVE IN EDIT MASK
         ED        23(6,R7),DWORD+5    EDIT IN DROP STATEMENT
USGCPS   DS        0H
         LA        R0,USNGESD(R6)      POINT TO ESDID
         BAL       R14,ADJUST          CONVERT ADDRESS
         MVC       34(6,R7),DWORD      ENTER VALUE
         L         R1,USNGCHN(R6)      GET NEXT AREA ON THE CHAIN
         LA        R1,0(,R1)           CLEAR HIGH BYTE
         LTR       R1,R1               AT END OF THE CHAIN .Q
         BZ        UMPEND              BRANCH IF YES
         TM        CFLGS,MULT          IS MULTIPLE UMAP .Q
         BZ        UMPPRT              BRANCH IF NOT
         LA        R4,UMAPOUT+1        INITIAL OUTPUT POSITION
         CR        R4,R7               ARE WE AT THE FIRST .Q
         BNE       UMPPRT              BRANCH IF NOT
         LA        R7,UMAPOUT+61       POINT TO SECOND AREA
         B         UMPBMP              BRANCH TO NEXT POINT
UMPPRT   DS        0H
         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE
         BCT       R1,UMPSKP           DECREMENT LINES LEFT
         BAL       R9,PAGEHED          YES, PRINT HEADINGS
UMPSKP   DS        0H
         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT
         LA        R1,UMAPOUT          POINT AT OUTPUT LINE
         BAL       R9,WRLST            PRINT THE LINE
         MVC       UMAPOUT(2),=X'0040' RESET SPACE OPERAND
         MVC       UMAPOUT+2(L'UMAPOUT-2),UMAPOUT+1  AND CLEAR AREA
         LA        R7,UMAPOUT+1        RESET OUTPUT LINE POS'N
UMPBMP   DS        0H
         LTR       R6,R6               SPECIAL LAST ENTRY CASE .Q
         BM        UMPCLR              BRANCH IF YES
         LA        R6,USNGLEN(,R6)     NEXT BLOCK OFFSET
         C         R6,USDPLEN          IS IT TOO BIG .Q
         BL        UMPNXT              BRANCH IF NOT
UMPCLR   DS        0H
         ST        R2,USDPADDR         SET ADDRESS TO FREE
         L         R2,USNGCHN+USNGLEN*(USNGDUP-1) POINT TO NEXT BLOCK
         LA        R2,0(,R2)           CLEAR HIGH BYTE
         L         R1,BUFFPT(,ACT)     POINT TO BUFF IN ASM
         CNOP      2,4                 ALIGN ARGUMENTS
         BALR      R0,R1               GO DO THE GROW
         DC        A(32)               GROW CODE
USDPLEN  DC        A(USNGLEN*USNGDUP)  LENGTH OF ONE UMAP AREA
USDPADDR DC        A(0)                UMAP AREA ADDRESS
         LTR       R6,R6               TEST WHO CALLED
         BM        LRFLOD              BRANCH IF LAST CALL
         SR        R6,R6               ZERO UMAP BLOCK OFFSET
         B         UMPNXT              AND DO NEXT REFERENCE
UMPEND   DS        0H
         SR        R6,R6               ZERO UMAP OFFSET
         BCTR      R6,0                AND MAKE IT NEGATIVE
         B         UMPPRT              COMMON PRINT THEN GROW ROUTINE
         DROP      R2                  FORGET UMAP BLOCK BASE
*        **************************************************************
*        ADJUST RELOCATABLE ADDRESS FROM ADJUSTMENT TABLE             *
*        **************************************************************
*        INPUT     (R0) POINTS TO ESDID AND DISPLACEMENT              *
*                  R14 IS RETURN REGISTER                             *
*        OUTPUT    ALWRD HAS DISPLACEMENT VALUE                       *
*                  FWORD HAS ADJUSTED VALUE                           *
*                  DWORD(6) HAS PRINTABLE CHARACTER VALUE             *
ADJUST   DS        0H
         STM       R1,R15,SAVE         SAVE ALL REGISTERS BUT ONE
         LR        R1,R0               TRANSFER ADDRESS OF ARGUMENT
         SR        R4,R4               ZERO REGISTER
         CLI       0(R1),X'00'         NO ADJUSTMENT IF ESDID = 0
         BE        NOADJUST            IF NO ADJUSTMENT, BRANCH
         LA        R4,ADJBS-4          ADJUSTMENT TABLE ADDRESS
         MVC       ADJCLI+1(1),0(R1)   CAUSE CLI BEATS CLC
ADJLOOP  DS        0H
         LA        R4,4(,R4)           POINT TO NEXT ENTRY
         C         R4,ADJBSEND         NO MORE TRYS .Q
         BL        ADJCLI              BRANCH IF NOT
         SR        R4,R4               ADJUSTMENT IS ZERO
         B         NOADJUST            IF TABLE ENTRY NOT FOUND
ADJCLI   CLI       0(R4),*-*           IS THIS THE RIGHT ENTRY .Q
         BNE       ADJLOOP             NO, THEN LOOP BACK
         L         R4,0(,R4)           GET ADJUSTMENT
NOADJUST DS        0H
         MVC       ALWRD+1(3),1(R1)    ALIGN DISPLACEMENT IN WORD
         AL        R4,ALWRD            ADD DISPLACEMENT TO DEFN
         ST        R4,FWORD            STORE SUM TO PASS BACK
         UNPK      DWORD(7),FWORD+1(4) UNPACK ADDRESS + 1 EXTRA
         TR        DWORD(6),SQTRTAB1   CHANGE TO CHARACTER
         LM        R1,R15,SAVE         RESTORE CALLER'S REGS
         BR        R14                 AND RETURN
*        **************************************************************
*        CONVERT LITERAL STRINGS TO EBCDIC                            *
*        **************************************************************
LRFLOD   DS        0H
         L         R2,STLREF(,ACT)     GET CHAIN OF ALL LITERALS
         LTR       R2,R2               ARE THERE ANY .Q
         BZ        XRFLOD              IF NOT DO XREF
         MVC       HEAD1ID,LRF1ID      SET HEADER 1
         MVI       HEAD2ID,C' '        CLEAR HEADER 2
         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT
         MVC       HEAD2ID(L'LRF2ID),LRF2ID  SET SECOND HEADER TITLE
         L         R4,CTRTBP(,ACT)     GET ADDRESS OF TRANSLATE TABLE
LREFLOOP DS        0H
         IC        R1,3(,R2)           LENGTH-1 OF LITERAL
         EX        R1,LREFTR           TRANSLATE LITERAL TO EBCDIC
         MVC       ALWRD+1(3),0(R2)    MOVE CHAIN POINTER
         L         R2,ALWRD            LOAD NEXT CHAIN POINTER
         LTR       R2,R2               ARE WE AT THE END OF CHAIN .Q
         BNZ       LREFLOOP            NO, TRANSLATE NEXT LITERAL
         LA        R1,1                INITIALIZE LINES LEFT ON PAGE
         ST        R1,CTLINECT(,ACT)   SET IT FOR NEW LREF PAGE
*        **************************************************************
*        FIND NEXT SMALLEST LITERAL FOR PRINTING                      *
*        **************************************************************
LREFNEXT DS        0H
         L         R2,STLREF(,ACT)     GET CHAIN OF REMAINING LITERALS
         LTR       R2,R2               ARE THERE ANY LEFT .Q
         BZ        XRFLOD              THAT'S ALL
         ST        R2,LREFSMLL         ASSUME FIRST IS SMALLEST
         LA        R1,STLREF+1(,ACT)   THIS POINTS TO THE SMALLEST
         ST        R1,LREFSPNT         AND DON'T FORGET IT
         SR        R4,R4               ZERO FOR MANIPULATING BYTES
LREFEND  DS        0H
         LR        R1,R2               MOVE PREVIOUS POINTER DOWN CHAIN
         MVC       ALWRD+1(3),0(R1)    GET ADDRESS OF NEXT IN CHAIN
         L         R2,ALWRD            LOAD IT
         LTR       R2,R2               IS THIS THE END .Q
         BZ        LREFPRNT            YES, GO PRINT SMALLEST
         L         R5,LREFSMLL         POINT TO SMALLEST SO FAR
         CLC       3(1,R5),3(R2)       WHICH LITERAL IS SHORTER ,Q
         BNL       *+12                NEW ONE IS SHORTER
         IC        R4,3(R5)            INSERT FORMER LENGTH
         B         *+8                 BRANCH AORUND
         IC        R4,3(R2)            INSERT NEW LENGTH
         EX        R4,LREFCOMP         COMPARE LITERALS
         BL        LREFEND             SMALLEST IS STILL SMALLEST
         BH        LREFCNGE            LITERALS WEREN'T EQUAL
         CLC       3(1,R5),3(R2)       WHICH LITERAL IS SHORTER .Q
         BL        LREFEND             SMALLEST WAS SHORTER
LREFCNGE DS        0H
         ST        R2,LREFSMLL         ADDRESS OF NEW SMALLEST
         ST        R1,LREFSPNT         ADDRESS POINTS TO NEW SMALLEST
         B         LREFEND             MAKE NEXT TEST
*        **************************************************************
*        UPDATE LITERAL CHAIN & PRINT LITERAL                         *
*        **************************************************************
LREFPRNT DS        0H
         L         R1,LREFSPNT         ENTRY POINTING TO SMALLEST
         L         R2,LREFSMLL         ADDRESS OF SMALLEST LITERAL
         MVC       0(3,R1),0(R2)       SHORTEN LITERAL CHAIN BY ONE
*        MAKE UP PRINT LINE UP TO REFERENCES                          *
         IC        R4,3(R2)            GET LENGTH-1 OF LITERAL STRING
         LA        R1,5(R4,R2)         POINT TO LENGTH GENERATED
         IC        R4,0(R1)            LOAD LENGTH INTO REGISTER
         CVD       R4,DWORD            CONVERT TO DECIMAL
         MVC       LRFOUT+5(6),EDMASK  MOVE IN EDIT MASK
         ED        LRFOUT+5(6),DWORD+5 EDIT LENGTH INTO LINE
         MVC       ALWRD+2(2),6(R1)    ALIGN DEFINITION STATEMENT
         LH        R4,ALWRD+2          LOAD STATEMENT INTO REGISTER
         N         R4,=X'0000FFFF'     REMOVE NEGATIVE SIGN BITS
         CVD       R4,DWORD            CONVERT TO DECIMAL
         MVC       LRFOUT+12(7),EDMASK MOVE IN EDIT MASK
         ED        LRFOUT+12(6),DWORD+5 EDIT IN DEFINITION LINE
         MVC       LRFOUT+19(L'LRFOUT-19),LRFOUT+18  BLANK REST OF LINE
         LA        R0,8(,R1)           POINT TO ESDID/DISPLACEMENT
         BAL       R14,ADJUST          GET RELOCATED ADDRESS
         MVC       LRFOUT+1(6),DWORD   MOVE RESULT TO PRINT LINE
         MVI       LRFOUT+21,C'='      PUT = SIGN BEFORE LITERAL
         SR        R4,R4               ZERO R4 AGAIN
         CLI       3(R2),99            IS LITERAL GT 100 CHARS .Q
         BL        *+12                YES, BRANCH AROUND
         LA        R4,99               MAKE IT 100 CHARS
         B         *+8                 BRANCH AROUND
         IC        R4,3(R2)            MAKE IT WHAT IT IS
         EX        R4,LREFMOVE         MOVE IN LITERAL STRING
         S         R2,=F'6'            POINT TO LITERAL PREFIX
*        **************************************************************
*        NOW PRINT OUT REFERENCES                                     *
*        **************************************************************
         LA        R7,LRFSN1           FIRST POSSIBLE REF POSITION
         LA        R4,LRFOUT+23(R4)    WHERE THE LITERAL TOOK US
LCAGAIN  DS        0H
         CR        R7,R4               COMPARE TWO POSITIONS
         BNL       LREFGET             OK TO PROCEED
         LA        R7,6(R7)            INCREMENT BY 6
         B         LCAGAIN             TRY AGAIN
LREFGET  DS        0H
         MVC       ALWRD+1(3),0(R2)    ALIGN NEXT REFERENCE IN CHAIN
         L         R2,ALWRD            LOAD NEXT ADDRESS
         LTR       R2,R2               IS THIS END OF CHAIN .Q
         BZ        LREFEOC             YES, PRINT REMAINING LINE
         MVC       ALWRD+2(2),3(R2)    ALIGN REFERENCE STMT NUMBER
         LH        R4,ALWRD+2          LOAD STMT INTO REGISTER
         N         R4,=X'0000FFFF'     REMOVE NEGATIVE SIGN BITS
         CVD       R4,DWORD            CONVERT TO DECIMAL
         LA        R1,LRFOUT+120       LAST PRINT POSITION
         CR        R7,R1               ARE WE AT END OF LINE .Q
         BL        LREFIN              NO, MAKE NEW ENTRY
         LA        R7,LRFSN1           NEXT LINE STARTS HERE
         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE
         BCT       R1,LREFNOHD         DECREMENT LINES LEFT
         BAL       R9,PAGEHED          YES, PRINT HEADINGS
LREFNOHD DS        0H
         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT
         LA        R1,LRFOUT           POINT AT OUTPUT LINE
         BAL       R9,WRLST            PRINT THE LINE
         MVC       LRFOUT(2),=X'0040'  RESET SPACE OPERAND AND
         MVC       LRFOUT+2(119),LRFOUT+1 BLANK LINE
LREFIN   DS        0H
         MVC       0(6,R7),EDMASK      MOVE IN EDIT MASK
         ED        0(6,R7),DWORD+5     EDIT IN REFERENCE STATEMENT
         LA        R7,6(R7)            INCREASE POSITION BY 6
         B         LREFGET             GO FURTHER DOWN CHAIN
LREFEOC  DS        0H
         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE
         BCT       R1,LREFSKIP         DECREMENT LINES LEFT
         BAL       R9,PAGEHED          YES, PRINT HEADINGS
LREFSKIP DS        0H
         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT
         LA        R1,LRFOUT           POINT AT OUTPUT LINE
         BAL       R9,WRLST            PRINT THE LINE
         MVI       LRFOUT,X'00'        RESET SPACE OPERAND
         B         LREFNEXT            AND RETURN
*        **************************************************************
* MOVE THE SYMBOL TABLE DEFINITIONS TO THE BOTTOM OF MEMORY           *
*        **************************************************************
XRFLOD   DS        0H
         L         R2,STCHAIN(,ACT)    CHAIN OF ALL SYMBOLS
         LTR       R2,R2               ARE THERE ANY
         BZ        RLDLOD              IF NOT DO RLD
         MVC       HEAD1ID,XRF1ID      SET HEADER ONE
         MVI       HEAD2ID,C' '        CLEAR HEADER TWO
         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT
         TM        CTFXRFI(ACT),X'02'  TEST WHICH XREF
         BO        FULLXSET            BRANCH IF FULLXREF
         LA        R1,HEAD2ID          POINT TO START OF AREA
         TM        CFLGS,MULT          IS IT MULTI COLUMN .Q
         BO        *+8                 BRANCH IF YES
         LA        R1,HEAD2ID+21       ONLY ONE SQUISHED COLUMN
         MVC       0(L'SRF2ID,R1),SRF2ID  SET SQUISHED XREF HEADER TWO
         B         XRFTSTM             TEST FOR MULTI COLUMNS AGAIN
FULLXSET DS        0H
         MVC       HEAD2ID(L'XRF2ID),XRF2ID  SET FULL XREF HEADER
XRFTSTM  DS        0H
         TM        CFLGS,MULT          IS IT MULTI COLUMN .Q
         BZ        XRFSING             BRANCH IF ONLY ONE
         MVC       HEAD2ID+60(50),HEAD2ID  DOUBLE THE INFORMATION
XRFSING  DS        0H
         L         R10,CESIOA(,ACT)    BOTTOM OF MEMORY
         MVI       XISYMB(R10),0       PLACE DUMMY ENTRY AT BOTTOM
         LA        R1,16(,R10)         POINT AT NEXT ENTRY
         LR        R6,R1               REMEMBER THE START
MOVEDEF  DS        0H
         MVC       XISYMB(6,R1),ISYMB(R2) MOVE NAME
         MVC       XILINE(2,R1),ILINE(R2) MOVE DEFN LINE NUMBER
         TM        IADJ(R2),UNDEF      TEST IF UNDEFINED ENTRY
         BZ        NOTUNDEF            BRANCH IF NOT
         XC        XILINE(2,R1),XILINE(R1) ZERO DEFN LINE NUMBER
NOTUNDEF DS        0H
         MVC       XIESDID(6,R1),IESDID(R2)  MOVE ESDID,VALUE,LENGTH
         TM        IADJ(R2),NAMES      IS THIS A NAME ENTRY .Q
         BO        NAMEOK              BRANCH IF YES
         XC        XIVALUE(5,R1),XIVALUE(R1)  ZERO VALUE AND LENGTH
NAMEOK   DS        0H
         TM        CTXRFFSI(ACT),X'20' XREF(FULL) .Q
         BZ        NAMENZRF            BRANCH IF YES
         OC        INOREFS(2,R2),INOREFS(R2)  ZERO REFERENCES .Q
         BZ        NAMEZORF            FORGET IT IF YES
NAMENZRF DS        0H
         MVC       XIOFFSET(2,R1),INOREFS(R2)  MOVE NUMBER OF REFS
         LA        R1,16(,R1)          POINT TO NEXT ENTRY
NAMEZORF DS        0H
         C         R2,CHAINPT(,ACT)    TEST FOR LAST SYMBOL
         L         R2,ICHAIN(,R2)      CHAIN TO NEXT DEFN
         LA        R2,0(,R2)           CLEAR TOP BYTE
         BNE       MOVEDEF
         CR        R1,R6               ANY SYMBOLS NOW .Q
         BE        RLDLOD              NO, GO DO RLD
         MVI       0(R1),X'FF'         PLACE DUMMY ENTRY AT TOP
*        **************************************************************
* SORT THE DEFINITIONS                                                *
*        **************************************************************
         LA        R6,16(,R1)          INITIALIZE DELTA TO SIZE OF DATA
         SR        R6,R10
XSORT1   DS        0H
         SRL       R6,1                DELTA/2 FOR NEXT PASS
         N         R6,=F'-16'
         BZ        XREFALOC            END OF SORT WHEN DELTA=0
         SR        R8,R8               INITIALIZE SUBSEQUENCE BASE
XSORT4   DS        0H
         LA        R14,0(R8,R10)       START NEW SUBSEQUENCE
XSORT2   DS        0H
         LR        R4,R14              STEP TO NEXT SUBSEQUENCE PAIR
XSORT3   DS        0H
         LA        R14,0(R6,R4)        UPPER INDEX = LOWER + DELTA
         CR        R14,R1              BRANCH IF END OF SUBSEQUENCE
         BH        XSORT6
         CLC       XISYMB(8,R4),XISYMB(R14) COMP SYMBOL & LINE
         BNH       XSORT2              BRANCH IF IN SEQUENCE
         LD        FR0,0(,R4)          SWAP THE ENTRIES
         LD        FR2,0(,R14)
         STD       FR0,0(,R14)
         STD       FR2,0(,R4)
         LD        FR0,8(,R4)
         LD        FR2,8(,R14)
         STD       FR0,8(,R14)
         STD       FR2,8(,R4)
         SR        R4,R6               LET UPPER ITEM SINK
         CR        R4,R10              TEST FOR BOTTOM
         BH        XSORT3
         B         XSORT2
XSORT6   DS        0H
         LA        R8,16(,R8)          STEP TO NEXT SUBSEQUENCE
         CR        R8,R6               TEST FOR END OF PASS
         BL        XSORT4
         B         XSORT1
*        **************************************************************
* ALLOCATE MEMORY FOR THE REFERENCES                                  *
*        **************************************************************
XREFALOC DS        0H
         LA        R2,16(,R10)         FIRST ENTRY
         LA        R0,16               INC FOR BXLE
         SR        R5,R5               OFFSET FOR 1ST REF
         LR        R6,R5
ALOCLOOP DS        0H
         AR        R5,R6               OFFSET FOR THIS DEFN'S REFS
         LH        R6,XIOFFSET(,R2)    PICK UP NUMBER OF REFS
         STH       R5,XIOFFSET(,R2)    PLACE OFFSET
         BXLE      R2,R0,ALOCLOOP      LOOP FOR ALL DEFNS
*        **************************************************************
* DO A SHRINK TO GET CORE FOR REFS IF NECESSARY                       *
*        **************************************************************
         AR        R5,R5               DOUBLE FOR 2 BYTES/REF
         LA        R5,16(R5,R1)        ADD TO DEFN AREA
         ST        R5,CBUFAD           SAVE R5...IT'S IMPORTANT
         ST        R5,CBUFPT           ALSO INIT BUFFER PTR
         S         R5,CESIOB(,ACT)     DO WE HAVE ENOUGH ALREADY
         BNH       IL0050              BRANCH IF SO
         LA        R5,7(,R5)           D ALIGN AMOUNT
         N         R5,=F'-8'
         ST        R1,SR1              SAVE REGISTER 1 FOR THE SHRINK
         ST        R5,SHLEN            DO THE SHRINK
         L         R1,BUFFPT(,ACT)
         CNOP      2,4
         BALR      R0,R1
         DC        A(36)
SHLEN    DS        F
SHADR    DS        F
         L         R1,SR1              RESTORE REGISTER 1 AFTER SHRINK
         AL        R5,SHADR            SET NEW TOP OF CORE
         ST        R5,CESIOB(,ACT)
         BNO       IL0050              TEST FOR CORE NOT AVAILABLE
         BAL       R0,ABEND            END OF LINE
         DC        C'995I',AL1(L'MES995-1)
MES995   DC        C'INSUFFICIENT MEMORY TO PROCESS XREF'
*        **************************************************************
* TRY TO ALLOCATE STORAGE FOR A TWO-COLUMN XREF IF REQ'D              *
*        **************************************************************
IL0050   DS        0H
         TM        CFLGS,MULT          TWO-COLUMN .Q
         BZ        XREFREAD            IF NOT, FORGET WHOLE THING
         L         R5,CBUFAD           GET HOPEFUL BUFFER ADDRESS
         SR        R0,R0               ZERO A WORK REGISTER
         IC        R0,CTPGLNCT(,ACT)   GET LINES PER PAGE
         LTR       R0,R0               IS IT ZERO .Q
         BZ        IL0055              IF SO, TWO-COLUMN ILLEGAL
         MH        R0,=H'60'           HOW MUCH CORE NEEDED
         AR        R5,R0               BUMP TOP OF CORE POINTER
         ST        R5,CBUFND           AND SAVE AS BUFFER END + 1
         S         R5,CESIOB(,ACT)     SEE IF OVER THE TOP
         BNH       XREFREAD            IF NOT, ALL'S WELL
         LA        R5,7(,R5)           AND WE MUST ALLOCATE
         N         R5,=F'-8'           BY DOUBLEWORDS ONLY
         ST        R1,SR1              SAVE R1 ACROSS SHRINK
         ST        R5,SQLEN            SAVE LENGTH TO GET
         L         R1,BUFFPT(,ACT)     GET LIFELINE TO BUFF
         CNOP      2,4                 ALIGN ADCONS
         BALR      R0,R1               GO ALLOCATE
         DC        A(36)               CODE FOR A SHRINK
SQLEN    DS        A                   LENGTH OF EXTRA NEEDED
SQADR    DS        A                   ADDRESS RETURNED HERE
         L         R1,SR1              RESTORE R1
         L         R5,SQADR            GET ADDRESS OF NEW CORE
         LTR       R5,R5               IS IT NON-POSITIVE .Q
         BP        IL0060              ON FALL-THRU, ACT LIKE
IL0055   DS        0H
         NI        CFLGS,X'FF'-MULT-TRIPLE NOTHING HAPPENED
         B         XREFREAD            AND GO PROCESS XREF
IL0060   DS        0H
         AL        R5,SQADR            ELSE PROCESS NEW TOP
         ST        R5,CESIOB(,ACT)     AND STASH IT BACK
*        **************************************************************
* READ THE XREF REFERENCES                                            *
*        **************************************************************
XREFREAD DS        0H
         LH        R0,CTCXRF(,ACT)     SEE IF ANY REF RECORDS
         LTR       R0,R0
         BZ        XREFOUT             IF NOT DO NOT READ
         MVC       ICT(4*4+1),XRFTAB   SET FOR READING ICT
READLOOP DS        0H
         BAL       R9,GTO              READ REF
         BZ        XREFOUT             TEST FOR EOF
*        **************************************************************
* DO A BINARY SEARCH TO FIND DEFINITION                               *
*        **************************************************************
         LA        R6,16(,R1)          INITIALIZE DELTA TO DATA SIZE
         SR        R6,R10
         LR        R14,R10             SO R14 WILL START IN MIDDLE
UP       DS        0H
         LPR       R6,R6               MAKE DELTA + SO MOVE UP
HALF     DS        0H
         SRA       R6,1                HALF DELTA
         N         R6,=F'-16'
         BNZ       ADD                 TEST FOR DELTA=0
         LA        R6,16               SLOWLY MOVE UP AFTER DELTA = 0
ADD      DS        0H
         AR        R14,R6              MOVE UP OR DOWN BY DELTA
         CR        R14,R10             TEST FOR BELOW DEFNS
         BNL       *+6
         LR        R14,R10             SET TO BOTTOM OF TABLE
         CLC       HOLD(6),XISYMB(R14) COMP SYMBOL
         BE        FOUND               GO CHECK FOR DUPLICATES
         BH        UP                  SEARCH HIGHER UP
         LNR       R6,R6               MAKE DELTA - SO MOVE DOWN
         B         HALF                GO TRY AGAIN
FOUND    DS        0H
         A         R14,=F'-16'         TEST IF LOWER ONE SAME
         CLC       HOLD(6),XISYMB(R14)
         BE        FOUND               LOWEST DEFN IS NOT DUPLICATE
*        **************************************************************
* PLACE THE REF IN REF AREA AND INCREMENT OFFSET POINTER              *
*        **************************************************************
         LH        R6,16+XIOFFSET(,R14) PICK UP OFFSET FOR REF
         N         R6,=X'0000FFFF'     REMOVE SIGN BITS
         LA        R6,1(,R6)           INCREMENT IT BY 1
         STH       R6,16+XIOFFSET(,R14) REPLACE IT
         AR        R6,R6               DOUBLE FOR 2 BYTES/REF
         AR        R6,R1               POINT TO WHERE REF GOES - 14
         MVC       16-2*1(2,R6),HOLD+6 PLACE THE REFERENCE
         B         READLOOP
*        **************************************************************
*        XRF OUTPUT ALL DATA FROM CORE                                *
*        **************************************************************
XREFOUT  DS        0H
         SR        R4,R4               REFERENCE POINTER
         LR        R8,R10              DEFINITION POINTER - 16
         ST        R1,RAPOINTR         REF AREA POINTER - 16
         LA        R7,XRFSN1+85        LOAD ADDR OF LAST PRINT POSN
         TM        CFLGS,MULT          SEE IF COL GREATER THAN ONE
         BZ        XAR                 BRANCH IF NOT
         LA        R7,XRFSN1+22        ELSE MODIFY LENGTH
XAR      DS        0H
         LR        R2,R7               FORCE NEW LINE
         BAL       R9,XRFHED           PRINT A PAGE HEADING
         ST        R1,CTLINECT(,ACT)   SET LINES LEFT ON PAGE
         B         PUTXR1              AND CONTINUE
*        GO TO NEXT REFERENCE                                         *
LODREF   DS        0H
         LA        R4,1(,R4)           POINT AT NEXT REFERENCE
LODDEF   DS        0H
         LH        R1,16+XIOFFSET(,R8) TEST FOR LAST REFERENCE
         N         R1,=X'0000FFFF'
         CR        R1,R4
         BE        PUTXR2
         LA        R1,0(R4,R4)         GET NEXT REFERENCE
         A         R1,RAPOINTR         PLUS REF AREA POINTER - 16
         LH        R1,16(,R1)          GET NEXT REFERENCE
         B         PUTXR3
*        GO TO NEXT DEFINITION                                        *
PUTXR2   DS        0H
         LA        R8,16(,R8)          POINT AT NEXT DEFN
         CLI       16+XISYMB(R8),X'FF' TEST FOR LAST ONE
         BE        SQEND
PUTXR1   DS        0H
         L         R1,16+XISYMB(,R8)   CONVERT SYMBOL TO EBCDIC
         SR        R0,R0
         SLDL      R0,6
         SLL       R0,2
         SLDL      R0,6
         SLL       R0,2
         SLDL      R0,6
         SLL       R0,2
         SLDL      R0,6
         ST        R0,XRFHLD
         SR        R0,R0
         SLDL      R0,6
         SLL       R0,2
         SLDL      R0,2
         L         R1,16+XISYMB+4(,R8)
         SLDL      R0,4
         SLL       R0,2
         SLDL      R0,6
         SLL       R0,2
         SLDL      R0,6
         ST        R0,XRFHLD+4
         TR        XRFHLD(8),EBCDIC
         LH        R1,16+XILINE(,R8)   LOAD BIN STATEMENT NUMBER
         LTR       R1,R1               TEST FOR UNDEFINED SYMBOL
         BZ        UNDSYM
         MVI       SQPUTSW+1,X'F0'     SET SWITCH FOR DEFN
*        CONVERT THE STATEMENT NUMBER TO CHARACTER                    *
PUTXR3   DS        0H
         N         R1,=X'0000FFFF'     REMOVE PROPAGATED SIGN BITS
         CVD       R1,DWORD            CONVERT STMT NO. TO DECIMAL
         LA        R1,SQFWORD+17       IN CASE ONLY 1 SIG DIGIT
         MVC       SQFWORD+12(6),EDMASK SET UP EDIT FIELD
         EDMK      SQFWORD+12(6),DWORD+5 EDIT AND MARK 1ST SIG CHAR
         LA        R14,SQFWORD+17      CALCULATE LENGTH-1
         SR        R14,R1
SQPUTSW  BC        15+*-*,NEWXRF(*-*)  REF OR DEFN SWITCH
*        OUTPUT REFERENCE                                             *
         CR        R2,R7               CHECK FOR LAST ST-NO ON LINE
         BNH       SQLINEOK
         ST        R1,SQSAVE2          SAVE SIG DIG POINTER
         BAL       R15,SQOUT           OUTPUT THE LINE
         TM        CTFXRFI(ACT),X'02'  TEST TYPE OF XREF
         BO        SQLINEOK
         L         R1,SQSAVE2          RESTORE SIG DIG POINTER
         LA        R2,XRFOUT+3         SQ XREF  START REFS IN COL 3
SQLINEOK DS        0H
         TM        CTFXRFI(ACT),X'02'  TEST TYPE OF XREF
         BZ        SQSQREF
         MVC       0(5,R2),SQFWORD+13  MOVE FULL TYPE REF TO LINE
         LA        R2,6(R2)            6 COLUMNS PER FULL REF
         B         LODREF
SQSQREF  DS        0H
         EX        R14,SQSMVC          PLACE SQ REF ON LINE
         LA        R2,2(R14,R2)        REF LENGTH + 1 BLANK
         B         LODREF
SQSMVC   MVC       0(*-*,R2),0(R1)     PLACE SQUISHED REF ON LINE
*        UNDEFINED DEFINITION TO BE OUTPUT                            *
UNDSYM   DS        0H
         MVC       SQFWORD(18),=C' ****UNDEFINED****' SET STACK
         TM        CTFXRFI(ACT),X'02'  TEST TYPE OF XREF
         BO        SQPUTD1             GO DO FULL XREF
         LA        R1,SQFWORD+1        SET TOP OF STACK POINTER
         LR        R0,R2               CAUSE TRT CLOBBERS 2
         B         SQPUTD2             DO SQ XREF
*        OUTPUT NORMAL OR DUPLICATE DEFINITION                        *
*        ADJUST RELOCATABLE ADDRESS FROM ADJUSTMENT TABLE             *
NEWXRF   DS        0H
         LA        R0,16+XIESDID(,R8)  POINT TO ESDID/DISPL
         BAL       R14,ADJUST          CONVERT TO A VALUE
         MVC       SQFWORD+6(6),DWORD  PLACE IN STACK AT FULL POSN
         TM        CTFXRFI(ACT),X'02'  TEST IF IT IS FULL WANTED
         BO        SQLENGET
         S         R1,=F'7'            MOVE TOP OF STACK UP 7
         MVI       6(R1),C','          PUT COMMA LEFT OF DEFN
         LR        R0,R2               SAVE R2 CAUSE TRT CLOBBERS
         MVC       0(6,R1),DWORD       PLACE VALUE NEXT TO DEFN
         LR        R14,R1              FIND HIGH SIG DIGIT
         LA        R1,5(,R1)           IN CASE VALUE 0
         TRT       0(6,R14),SQTRTAB2
SQLENGET DS        0H
         LH        R14,16+XILENG(,R8)  LOAD BIN SYMBOL LENGTH
         LA        R14,1(,R14)         ADD 1 FOR TRUE LENGTH
         N         R14,=X'0000FFFF'    REMOVE PROPAGATED SIGN BITS
         CVD       R14,DWORD
         MVC       SQFWORD-1(7),EDMASK PLACE  EDIT FIELD
         ED        SQFWORD-1(6),DWORD+5 ASSUME FULL XREF
         TM        CTFXRFI(ACT),X'02'  TEST IF REALLY FULL XREF
         BO        SQPUTD1
         S         R1,=F'7'            MOVE STACK POINTER UP 7
         MVC       0(6,R1),EDMASK      EDIT FIELD
         MVI       6(R1),C','          AND COMMA
         LR        R14,R1              FIND HIGH SIG DIGIT
         LA        R1,5(,R1)           IN CASE ONLY 1 SIG DIG
         EDMK      0(6,R14),DWORD+5    EDIT AND MARK LENGTH
SQPUTD2  DS        0H
         LR        R14,R1              SAVE TOP OF STACK POINTER
         LA        R1,XRFHLD+8         FIND NO CHAR IN SYMBOL
         TM        CFLGS,MULT          MULTI-COLUMN .Q
         BO        IL0015              BRANCH IF SO, FORCE LENGTH=8
         TRT       XRFHLD+1(7),SQTRTAB3
IL0015   DS        0H
         S         R1,=A(XRFHLD+1)     NO CHAR - 1
         LA        R6,SQFWORD+17       CALCULATE STACK LENGTH - 1
         SR        R6,R14
         TM        CFLGS,MULT          MULTIPLE COLUMNS .Q
         LR        R2,R0               RESTORE R2
         BO        IL0030              MAYBE MAKE NL FOR DEFN
         LA        R2,19(R6,R1)        TOTAL LENGTH REQUIRED
         AR        R2,R0               NEW LINE POSITION
         CR        R2,R7               TEST IF ENOUGH ROOM
         LR        R2,R0               RESTORE LINE POINTER
         BNH       SQADDNEW
IL0030   DS        0H
         STM       R14,R1,SQSAVE4      SAVE SOME REGS
         BAL       R15,SQOUT           PRINT LAST LINE
         LM        R14,R1,SQSAVE4      RESTORE THE REGS
         LA        R2,XRFOUT-1         SET NEW LINE POINTER
SQADDNEW DS        0H
         EX        R1,SQADDMVC         PUT SYMBOL ON LINE
         LA        R2,5(R1,R2)         UP LINE POINTER
         EX        R6,SQADDLVD         MOVE STACK GIVEN LENGTH
         LA        R2,3(R6,R2)         SET POINTER FOR FIRST REF
         B         SQNEWDON
SQADDMVC MVC       2(*-*,R2),XRFHLD    EXECUTED MOVE
SQADDLVD MVC       0(*-*,R2),0(R14)    EX STACK ON LINE  (LEN,VAL,DEF)
SQPUTD1  DS        0H
         BAL       R15,SQOUT           PRINT LAST FULL XREF LINE
         MVC       XRFOUT+1(8),XRFHLD  PUT SYMBOL ON NEW LINE
         MVC       XRFHOLD,XRFHLD      SAVE SYMBOL IN CASE
         MVC       XRFOUT+10(18),SQFWORD PUT STACK  (LEN,VAL,DEF) ON
SQNEWDON DS        0H
         MVI       SQPUTSW+1,X'00'     ASSUME REFS COME NEXT
         CLC       XISYMB(6,R8),16+XISYMB(R8) TEST FOR DUP DEFN
         BNE       LODDEF
         MVC       0(17,R2),=C'****DUPLICATE****'
         LA        R2,18(,R2)          UP THE LINE POINTER
         B         LODDEF
SQOUT    BC        *-*+15,SQOUTEND     TEST IF FIRST LINE
         TM        CFLGS,CTOP          TOP OF COLUMN .Q
         BZ        IL0065              NO...SKIP CODE
         NI        CFLGS,X'FF'-CTOP    TURN OFF FLAG
         TM        CTFXRFI(ACT),X'02'  WAS FULLXREF SPECIFIED .Q
         BZ        IL0065              BRANCH IF NOT
         CLI       XRFOUT+1,C' '       SEE IF CONTINUATION
         BNE       IL0065              BRANCH IF NOT
         MVC       XRFOUT+1(8),XRFHOLD MOVE SYMBOL NAME
         MVC       XRFOUT+17(11),=C'(CONTINUED)' AND INDICATOR
IL0065   DS        0H
         TM        CFLGS,MULT          SEE IF TWO COLUMN
         BZ        IL0100              BRANCH IF NOT
         TM        CFLGS,MTBUFF        DO WE FILL OR EMPTY
         BZ        IL0080              BRANCH IF WE FILL
IL0070   DS        0H
         MVC       XRFOUT+61(60),XRFOUT+1 MOVE COLUMN TO RIGHT
         L         R1,CBUFPT           GET PLACE IN BUFFER
         MVC       XRFOUT+1(60),0(R1)  PLUG TEXT FROM BUFFER
         AH        R1,=H'60'           POINT TO NEXT PLACE
         ST        R1,CBUFPT           SAVE IT BACK
         B         IL0100              EXIT LAUGHING...
IL0080   DS        0H
         L         R1,CBUFPT           GET BUFFER POINTER
         C         R1,CBUFND           SEE IF WE ARE OUTSIDE
         BNE       IL0090              BRANCH IF NOT, NORMAL CASE
         L         R1,CBUFAD           RESET BUFFER POINTER
         OI        CFLGS,MTBUFF        WE EMPTY NOW
         ST        R1,CBUFPT           STORE NEW POINTER
         B         IL0070              MAKE LIKE WE EMPTY
IL0090   DS        0H
         MVC       0(60,R1),XRFOUT+1   MOVE TEST INTO BUFFER
         AH        R1,=H'60'           BUMP BUFFER POINTER
IL0095   DS        0H
         ST        R1,CBUFPT           STORE IT BACK
         C         R1,CBUFND           ARE WE AT THE END .Q
         BNE       SQOUTEND            IF SO, THE NEXT LINE WILL
         OI        CFLGS,CTOP          START A NEW COLUMN
         B         SQOUTEND            AND GO EXIT
IL0100   DS        0H
         LA        R1,XRFOUT           POINT AT OUTPUT LINE
         TM        CFLGS,PTOP          PAGE TOP .Q
         BZ        IL0110              IF NOT, THEN BRANCH
         MVI       XRFOUT,X'01'        ELSE DOUBLE SPACE
         NI        CFLGS,X'FF'-PTOP    AND TURN OFF THE BIT
IL0110   DS        0H
         BAL       R9,WRLST            PRINT THE LINE
         L         R1,CTLINECT(,ACT)   GET LINES LEFT ON PAGE
         BCT       R1,SQOUTSKP         DECREMENT BY ONE
         BAL       R9,XRFHED           PRINT HEADINGS
SQOUTSKP DS        0H
         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT
SQOUTEND DS        0H
         LA        R2,XRFSN1           SET LINE POINTER FOR FULL XREF
         MVC       XRFOUT(2),=X'0040'  RESET SPACE OPERAND
         MVC       XRFOUT+2(L'XRFOUT-2),XRFOUT+1  AND BLANK THE LINE
         MVI       SQOUT+1,X'00'       RESET FIRST SWITCH
         BR        R15
SQEND    DS        0H
         L         R1,CTLINECT(,ACT)   GET LINES LEFT
         A         R1,=F'1'            ADD ONE
         ST        R1,CTLINECT(,ACT)   PREVENT A NEW PAGE
         BAL       R15,SQOUT           PRINT LAST LINE
         TM        CFLGS,MULT          ARE WE IN COLUMN MODE .Q
         BZ        RLDLOD              IF NOT, SKIP IT
         L         R15,CBUFPT          GET BUFFER LOCATION
         TM        CFLGS,MTBUFF        DO WE EMPTY .Q
         BNZ       SQLP                BRANCH IF SO
         MVI       XRFOUT,X'01'        INDICATE NEW PAGE
         L         R1,QBUFAD           GET QSAM BUFFER ADDRESS
         MVI       60(R1),C' '         WHICH STILL HAS PAGE HEADING
         MVC       61(50,R1),60(R1)    AND BLANK THE RIGHT HALF
         ST        R15,CBUFND          ACT AS IF THE
         L         R15,CBUFAD          BUFFER IS SHORTER
SQLP     DS        0H
         C         R15,CBUFND          ARE WE AT THE END .Q
         BNL       RLDLOD              BRANCH IF SO... EXIT
         MVC       XRFOUT+1(60),0(R15) MOVE THE TEXT
         L         R1,CTLINECT(,ACT)   GET LINES LEFT
         BCTR      R1,0                DECREMENT BY ONE
         ST        R1,CTLINECT(,ACT)   AND SAVE IT BACK
         LA        R1,XRFOUT           POINT AT THE LINE
         BAL       R9,WRLST            GO PRINT IT
         MVI       XRFOUT,X'00'        RESET TO SINGLE SPACE
         AH        R15,=H'60'          BUMP THE POINTER
         B         SQLP                GO LOOP
*        **************************************************************
*        PRINT XRF PAGE HEADINGS                                      *
*        **************************************************************
XRFHED   DS        0H
         TM        CFLGS,MULT          TWO COLUMNS .Q
         BZ        EXPCOM              BRANCH IF NOT
         NI        CFLGS,X'FF'-MTBUFF-XFIRST INDICATE FILL MODE
         L         R1,CBUFAD           GET BUFFER ADDRESS
         ST        R1,CBUFPT           STORE IT AS CURRENT PLACE
EXPCOM   DS        0H
         OI        CFLGS,CTOP+PTOP     SAY WE'RE AT COLUMN TOP
         B         PAGEHED             DO THE OUTPUT
*        **************************************************************
*        START RLD INPUT PASS                                         *
*        **************************************************************
RLDLOD   DS        0H
         TM        CTPCHI(ACT),X'C8'   SEE IF DECK,LOAD OR RLD
         BNZ       RLDOK               BRANCH IF ANY SPECIFIED
         TM        CTEXEC(ACT),X'20'   WAS EXECUTE SPECIFIED .Q
         BZ        ENDJOB              BRANCH IF NOT
RLDOK    DS        0H
         LH        R10,CTCRLD(,ACT)    SEE IF ANY RLD'S PRODUCED
         LTR       R7,R10
         BZ        ENDJOB
         MH        R10,=AL2(4*BLKFC2)  SPACE NEEDED FOR POINTERS
         MH        R7,=AL2(RLDLN*BLKFC2) SPACE NEEDED FOR RLD'S
         L         R8,CESIOA(,ACT)     BOTTOM OF SORT AREA
         AR        R10,R8              BOTTOM OF RLD AREA
         ST        R10,BASED
         AR        R7,R10              TOP OF CORE NEEDED
         S         R7,CESIOB(,ACT)     DO WE HAVE ENOUGH ALREADY
         BNH       RLDPOINT
         LA        R7,7(,R7)           D ALIGN AMOUNT
         N         R7,=F'-8'
         ST        R7,SKLEN            SAVE LENGTH TO BE SHRANK
         L         R1,BUFFPT(,ACT)     POINT TO BUFF IN ASM
         CNOP      2,4                 ALIGN ARGUMENTS
         BALR      R0,R1               GO DO THE SHRINK
         DC        A(36)               SHRINK CODE FOR BUFF
SKLEN    DC        F'0'                LENGTH TO BE GOTTEN
SKADR    DC        A(0)                ADDRESS RETURNED BY BUFF
         AL        R7,SKADR            LENGTH PLUS ADDRESS
         ST        R7,CESIOB(,ACT)     SAVE NEW HIGH
         BNO       RLDPOINT            TEST FOR CORE NOT AVAILABLE
         LA        R0,MSG994           THE BITTER END
ABEND    DS        0H
         L         R1,ADLIST1(,ACT)    POINT TO LIST1 IN ASMGASM
         B         L1ABEND(,R1)        BRANCH TO ABEND ROUTINE IN ASM
MSG994   DC        C'994I',AL1(L'MES994-1)
MES994   DC        C'INSUFFICIENT MEMORY TO PROCESS RLD'
RLDPOINT DS        0H
         MVC       RLDPT,CTRRLD(ACT)   GET ADDRESS OF 1ST RLD BLOCK
         L         R1,BUFFPT(,ACT)     POINT AT IT
         CNOP      2,4
         BALR      R0,R1
         DC        A(12,0)
RLDPT    DS        F
         MVC       ICT(4*4+1),RLDTAB   SET FOR READING RLD
         SR        R2,R2               ZERO INDEX IN SORT BLOCK POINTR
*        **************************************************************
*        READ RLD FROM INPUT TAPE AND STORE                           *
*        **************************************************************
READRLD  DS        0H
         BAL       R9,GTO              BRANCH TO IO ROUTINE
         BZ        EOFRH               BRANCH IF EOF
         MVC       0(2,R10),HOLD       MOVE IN RLD- ESD/ID
         MVC       2(3,R10),HOLD+3     SYMBOL ADDRESS
         MVC       5(1,R10),HOLD+2     FLAG
*        **************************************************************
*        UP ALL POINTERS FOR NEXT RLD                                 *
*        **************************************************************
         ST        R10,0(R2,R8)        STORE ADDRESS POINTER
         LA        R2,4(R2)            UP COUNTER BY FULL WORD
         LA        R10,RLDLN(,R10)     UP DATA POINTER BY RECORD LENGT
         B         READRLD             GET NEXT RECORD
*        **************************************************************
*        END OF FILE ON RLD                                           *
*        **************************************************************
EOFRH    DS        0H
         LR        R7,R2               LOAD UPPER LIMIT OF STRING
         S         R7,=F'4'            BACK IT UP ONE
         TM        CTDOSI(ACT),X'40'   TEST IF DOS OPTION
         BO        SETOT1              DON'T SORT RLD IF SO
*        **************************************************************
*        INTERNAL SORT FOR RLD                                        *
*        **************************************************************
*        SHELL'S METHOD                                               *
         LR        R6,R7               INITIALIZE DELTA AND
         L         R10,BASED           DATA ITEM BASE
         LA        R6,4(R6)
ESORT1   DS        0H
         SRL       R6,1                DELTA/2 INITIALIZES NEXT PASS
         N         R6,=F'-4'           FULL WORD ALIGN
         BZ        SETOT1              END OF SORT WHEN DELTA =0
         SR        R0,R0               INITIAL SUBSEQUENCE BASE INDEX
ESORT4   DS        0H
         LR        R14,R0
ESORT2   DS        0H
         LR        R9,R14              STEP TO NEXT SUBSEQUENCE PAIR
ESORT3   DS        0H
         LA        R14,0(R6,R9)        UPPER INDEX = LOWER+DELTA
         CR        R14,R7              BRANCH IF END OF SUBSEQUENCE
         BH        ESORT6
         L         R1,0(R9,R8)         POINT TO LOWER DATA ITEM
         L         R4,0(R14,R8)        POINT TO UPPER DATA ITEM
         CLC       0(RLDLN,R1),0(R4)   COMPARE
         BNH       ESORT2              IN SEQUENCE
         ST        R1,0(R14,R8)        LET UPPER ITEM SINK
         ST        R4,0(R9,R8)
         SR        R9,R6
         BNL       ESORT3              POSSIBLY ALL THE WAY
         B         ESORT2              TO THE BOTTOM.....
ESORT6   DS        0H
         A         R0,=F'4'            STEP TO NEXT SUBSEQUENCE
         CR        R0,R6               TEST FOR END OF PASS
         BL        ESORT4              NO -SORT NEXT SUBSEQUENCE
         B         ESORT1              YES -INITIALIZE NEW PASS
*        **************************************************************
*        RLD OUTPUT ALL DATA FROM CORE                                *
*        **************************************************************
SETOT1   DS        0H
         TM        CTRLDI(ACT),X'08'   WAS RLD SPECIFIED .Q
         BZ        SETOT3              BRANCH IF NOT
         MVC       HEAD1ID,RLD1ID      SET HEADER ONE
         MVI       HEAD2ID,C' '        CLEAR HEADER TWO
         MVC       HEAD2ID+1(L'HEAD2ID-1),HEAD2ID  ALL OF IT
         MVC       HEAD2ID(L'RLD2ID),RLD2ID  SET SECOND HEADER
         TM        CFLGS,RMULT         IS IT MULTIPLE RLD .Q
         BZ        SETOT2              BRANCH IF NOT
         MVC       RLDH2+55(54),RLDH2+1 EXPAND FOR TWO COLUMN
         TM        CFLGS,TRIPLE        IS IT TRIPLE RLD .Q
         BZ        SETOT2              BRANCH IF NOT
         MVC       RLDH2+37(72),RLDH2+1  EXPAND FOR THREE COLUMN
SETOT2   DS        0H
         BAL       R9,PAGEHED          PRINT RLD HEADING ON FIRST PAGE
         ST        R1,CTLINECT(,ACT)   SET LINES LEFT ON PAGE
SETOT3   DS        0H
         SR        R10,R10             SET ADDRESS POINTER TO ZERO
         LA        R5,48               LOAD UPPER LIMIT OF CARD
         LA        R2,VARRLD           SET BASE ADDRESS OF OUTPUT REC
         SR        R4,R4
LODHLD   DS        0H
         L         R1,0(R10,R8)        LOAD POINTER TO NEXT DATA ELEM
         LA        R10,4(,R10)         UP POINTER BY FULL WORD
         CR        R10,R7              LOOK FOR END OF STRING
         BNH       MOVE1               BRANCH IF NOT END
         MVI       ENDSWX,X'FF'        END OF STRING TURN END SWH ON
MOVE1    DS        0H
         MVC       PESDID,1(R1)
         MVC       RESDID,0(R1)        MOVE FROM WORK AREA TO OUTPUT
         MVC       ENDRLD,2(R1)
         UNPK      FWORD(15),HLDRLD(8) UNPACK RLD ENTRY
         LA        R6,FWORD            LOAD ADDRESS OF FIRST BYTE
CONV     DS        0H
         OI        0(R6),X'F0'         MASK HIGH END
         CLI       0(R6),X'F9'         IS VALUE EQ OR LESS THAN 9
         BNH       UP1                 YES
         SR        R0,R0               NO
         IC        R0,0(,R6)           LOAD CHR IN REG
         SH        R0,THRNIN           SUBTRACT 39 FROM CHR
         STC       R0,0(,R6)           STORE EDITED CHR IN WORK AREA
UP1      DS        0H
         LA        R6,1(,R6)           UP POINTER BY ONE
         LA        R0,FWORD+16         LOAD UPPER LIMIT OF WORK AREA
         CR        R6,R0               CHECK FOR END
         BL        CONV                RETURN FOR NEXT CHR
         MVC       RLDIMAGE+3(2),FWORD+2 POS. ID
         MVC       RLDIMAGE+11(2),FWORD REL. ID
         MVC       RLDIMAGE+18(2),FWORD+10 FLAG
         MVC       RLDIMAGE+24(6),FWORD+4 ADDRESS
         TM        CTRLDI(ACT),X'08'   TEST RLD SWITCH
         MVC       RLDHLD+1(1),PESDID  MOVE FOR CARD- POSITION ID
         MVC       RLDHLD+3(1),RESDID  RELOCATION ID
         MVC       RLDHLD+5(3),ENDRLD  ADDRESS
         MVC       RLDHLD+4(1),ENDRLD+3 FLAG
         BZ        SQNO1               BRANCH IF NORLD
         STM       R1,R4,REGHLD        STORE WORK REGISTERS
         L         R2,NXTRLD           FIND WHERE WE ARE
         MVC       1(36,R2),RLDIMAGE   MOVE THE TEXT
         LA        R1,108(,R2)         ASSUME ONE COLUMN
         TM        CFLGS,RMULT         IS IT TWO OR THREE .Q
         BZ        RLDGUNK             BRANCH IF NEITHER
         LA        R1,54(,R2)          SO ASSUME TWO
         TM        CFLGS,TRIPLE        IS IT THREE .Q
         BZ        RLDGUNK             BRANCH IF NOT
         LA        R1,36(,R2)          SO MAKE IT THREE
RLDGUNK  DS        0H
         CL        R1,=A(RLDDET+108)   END OF LINE .Q
         ST        R1,NXTRLD           STORE POINTER BACK
         BNE       NORLD               SEE IF WE SHOULD PRINT
         LA        R1,RLDDET           RESET POINTER
         ST        R1,NXTRLD           TO BUFFER START
         L         R1,CTLINECT(,ACT)   GET LINES PER PAGE
         BCT       R1,NORLDH           DECREMENT LINES LEFT
         BAL       R9,PAGEHED          BRANCH TO HEADING ROUTINE
NORLDH   DS        0H
         ST        R1,CTLINECT(,ACT)   UPDATE LINES LEFT
         LA        R1,RLDDET           LOAD ADDRESS OF OUTPUT
         BAL       R9,WRLST            WRITE OUTPUT
         MVI       RLDDET,X'00'        RESET SPACING
         MVI       RLDDET+1,C' '       BLANK THE ENTIRE LINE
         MVC       RLDDET+2(L'RLDDET-2),RLDDET+1  BY PROPAGATION
NORLD    DS        0H
         LM        R1,R4,REGHLD        RESTORE WORK REGISTERS
SQNO1    DS        0H
         CLC       COMPID,RLDHLD       IS THIS THE SAME ID .Q
         BNE       NEWRLD              NO START NEW
         LA        R6,4                SET MOVE LENGTH- 4 BYTES
         LA        R9,RLDHLD+4         SET REGISTER FOR MOVE
         SR        R2,R6
         OI        0(R2),X'01'         TURN DUP RLD FLAG ON
         AR        R2,R6               RESET OUTPUT POINTER
         LA        R6,3                SET MOVE LENGTH
         B         CRDTST
NEWRLD   DS        0H
         LA        R9,RLDHLD           SET REGISTER FOR MOVE
         LA        R6,7                SET MOVE LENGTH- 7 BYTES
         MVC       TSTPES,1(R1)
         MVC       TSTRES,0(R1)
CRDTST   DS        0H
         LA        R5,56               SET BYTE COUNT LIMIT
         LA        R4,1(R4,R6)         STEP BYTE COUNT
         CR        R4,R5               IF END OF OUTPUT RECORD
         BH        WRITE0              WRITE OUT
         EX        R6,MVRLD            EXECUTE MOVE INSTRUCTION
         BE        WRITE1              BRANCH IF CARD FULL
         LA        R2,1(R2,R6)         STEP OUTPUT POINTER
         CLI       ENDSWX,X'FF'        IS END SWITCH ON
         BE        WRITE1              YES, GO WRITE RLD
         B         LODHLD              RETURN AND GET NEXT RECORD
MVRLD    MVC       0(*-*,R2),0(R9)     EXECUTED MOVE INSTRUCTION
WRITE0   DS        0H
         OI        PKFLG,X'FF'         TURN ON RLD SPLIT FLAG
         BCTR      R4,0
         SR        R4,R6               GET BYTE COUNT
WRITE1   DS        0H
         STH       R4,REGDMP           STORE BYTE COUNT
         MVC       BYTOUT(2),REGDMP    MOVE BYTE COUNT TO OUTPUT
         BAL       R9,DKCNT            BRANCH TO UP DECK COUNTER BY 1
         MVC       VARRLD+60(4),DKNO   PUT IN DECK SEQUENCE NUMBER
         MVC       VARRLD+56(4),DKID   MOVE DECK ID TO OUTPUT
         BAL       R9,WRPUN            PUNCH THE CARD
         XC        COMPID,COMPID       ZERO SO ID'S GO OUT NEXT TIME
         MVI       RLDOUT+4,X'40'      BLANK OUT CARD
         MVC       RLDOUT+5(67),RLDOUT+4 RESET OUTPUT LINE
         LA        R2,VARRLD           RESET REG FOR NEXT RECORD
         SR        R4,R4               START INDEX AT ZERO
         CLI       PKFLG,X'FF'         IS SPLIT FLAG ON
         BNE       TSTND               NO, CONTINUE RLD OUTPUT
         MVI       PKFLG,X'00'         ZERO SPLIT FLAG
         B         NEWRLD              PUT IN REST OF RLD
TSTND    DS        0H
         CLI       ENDSWX,X'FF'        IS RLD OUTPUT COMPLETE
         BNE       LODHLD              NO, GET NEXT RECORD
         LA        R1,RLDDET           GET BUFFER POINTER
         CL        R1,NXTRLD           SEE IF STUFF TO PRINT
         BE        ENDJOB              BRANCH IF NOT
         CLI       RLDDET,X'00'        ONLY ONE LINE ON PAGE .Q
         BE        RLDBAL              BRANCH IF NOT
         L         R2,QBUFAD           GET ADDR OF PAGE HEADER
         A         R2,NXTRLD           ADD RLD POS'N POINTER
         LA        R4,RLDDET-1         GET STARTING LOC - 1
         SR        R2,R4               GET SPOT TO
         MVI       0(R2),C' '          PLACE FIRST BLANK
         S         R4,NXTRLD           FIND OUT THE LENGTH
         LA        R4,107(,R4)         AND MAKE IT PROPER
         EX        R4,RLDMVC           BLANK THE REST OF IT
RLDBAL   DS        0H
         BAL       R9,WRLST            ELSE PRINT THE STUFF
         B         ENDJOB              YES, EXIT RLD
RLDMVC   MVC       1(*-*,R2),0(R2)     TO PROPAGATE BLANKS
*        **************************************************************
*        DECK COUNTING SUBROUTINE                                     *
*        **************************************************************
DKCNT    DS        0H
         PACK      DWORD,DKNO          CONVERT TO DECIMAL
         CVB       R1,DWORD            CONVERT TO BINARY
         LA        R1,1(,R1)           BUMP SEQUENCE BY ONE
         CVD       R1,DWORD            CONVERT BACK TO DECIMAL
         UNPK      DKNO,DWORD          AND BACK TO ZONED
         OC        DKNO,CDZERO         MAKE IT PRINTABLE
         BR        R9                  AND RETURN
*        **************************************************************
*        PRINT PAGE HEADINGS                                          *
*        **************************************************************
PAGEHED  DS        0H
         ST        R9,RETHLD           REMEMBER RETURN ADDRESS
         BAL       R9,PGCNT            CALL PAGE COUNT SUBROUTINE
         LA        R1,LRFH1            ADDRESS OF HEADING 1
         BAL       R9,WRLST            PUT OUT HEADING 1
         LA        R1,LRFH2            ADDRESS OF HEADING 2
         BAL       R9,WRLST            PUT OUT HEADING 2
         MVI       HEAD1,X'FF'         EJECT HEADING 1
         MVI       HEAD2,X'02'         DOUBLE SPACE HEADING 2
         MVI       OUTLINE,X'01'       AND SPACE AFTER HEADING 2
         SR        R1,R1               ZERO REGISTER
         IC        R1,CTPGLNCT(,ACT)   GET LINES PER PAGE
         L         R9,RETHLD           RESTORE RETURN ADDRESS
         BR        R9                  AND RETURN
*        **************************************************************
*        PAGE COUNTER SUBROUTINE                                      *
*        **************************************************************
PGCNT    DS        0H
         STM       R1,R2,REGHLD+16     STORE WORK REGISTERS
         L         R1,ADLIST1(,ACT)    POINT TO LIST1 IN ASMGASM
         L         R2,L1PAGENO(,R1)    GET PAGE NUMBER ON SYSPRINT
         LA        R2,1(,R2)           ADD ONE TO PAGE NUMBER
         ST        R2,L1PAGENO(,R1)    AND RESTORE PAGE COUNT
         CVD       R2,DWORD            CONV BIN COUNTER TO DECIMAL
         MVC       FWORD(6),EDMASK     ENTER EDIT MASK FOR NO ZEROS
         ED        FWORD(6),DWORD+5    EDIT IN THE PAGE NUMBER
         MVC       HEAD1PGE,FWORD+2    MOVE EDITED PAGE NO TO USER
         LM        R1,R2,REGHLD+16     RESET WORK REGISTERS
         BR        R9                  RETURN TO USER
*        **************************************************************
*        WRITE RECORDS ON SYSLST                                      *
*        **************************************************************
WRLST    DS        0H
         STM       R1,R15,SAVE         SAVE ALL CALLER'S REGISTERS
         LR        R0,R1               TRANSFER OUTPUT ADDRESS
         L         R1,LSTDCB(,ACT)     GET SYSPRINT DCB ADDRESS
         PUT       (1),(0)             PRINT IT OUT
         L         R1,LSTDCB(,ACT)     GET SYSPRINT DCB ADDRESS
         L         R1,L1DCBLPT(,R1)    GET LAST QSAM BUFFER POINTER
         LTR       R1,R1               WAS IT DUMMIED .Q
         BZ        WRLSTAR             BRANCH IF YES
         ST        R1,QBUFAD           PASS ON THAT ADDRESS
WRLSTAR  DS        0H
         LM        R1,R15,SAVE         RESTORE CALLER'S REGISTERS
         BR        R9                  AND RETURN
*        **************************************************************
* SYSTEM OUTPUT SUBROUTINE                                            *
*        **************************************************************
WRPUN    DS        0H
         STM       R1,R15,SAVE         SAVE ALL REGISTERS
         TM        CTPCHI(ACT),X'80'   IS A DECK WANTED .Q
         BZ        PCH1                NO DECK, TRY SYSGO
         L         R1,PCHDCB(ACT)      GET ADDRESS OF PUNCH DCB
         PUT       (1),RLDOUT          PUNCH OUT RLD CARD
PCH1     DS        0H
         TM        CTCGOI(ACT),X'40'   IS LOAD OPTION ON .Q
         BZ        PCH11               NO, EXIT
         L         R1,GODCB(ACT)       YES, GET SYSGO DCB
         PUT       (1),RLDOUT          PUT CARD IMAGE ON SYSGO
PCH11    DS        0H
         TM        CTEXEC(ACT),X'20'   TEST FOR EXECUTION
         BZ        PCH111
         L         R1,BUFFPT(,ACT)     DO A WRITE
         CNOP      2,4
         BALR      R0,R1
         DC        A(8,4,RLDOUT,80)
         L         R1,BUFFPT(,ACT)     DO A CHECK
         CNOP      2,4
         BALR      R0,R1
         DC        A(28,4)
PCH111   DS        0H
         LM        R1,R15,SAVE         RESTORE ALL REGISTERS
         BR        R9                  EXIT
*        **************************************************************
* GET XRF OR RLD FROM SYSUT1                                          *
*        **************************************************************
GTO      DS        0H
         STM       R0,R8,SAVE          SAVE SOME REGS
         LM        R4,R8,ICT           LOAD I/O CONTROL JUNK
         CR        R4,R5               TEST FOR NEW BLOCK NEEDED
         BNE       GET
         ST        R7,READCODE         SET TYPE OF READ
READ     DS        0H
         L         R1,BUFFPT(,ACT)     DO THE READ
         CNOP      2,4                 ALIGN PARAMETERS
         BALR      R0,R1               GO DO THE READ
READCODE DS        F
         DC        A(0,RESBUF)
         L         R1,BUFFPT(,ACT)     DO A CHECK
         CNOP      2,4                 ALIGN PARAMETERS
         BALR      R0,R1               GO DO THE CHECK
         DC        A(28,0,0)
         CLC       RESBUF(1),ICT+16    TEST FOR RIGHT RECORD TYPE
         BNE       READ
         LA        R5,RESBUF+1         SET RECORD POINTER
GET      DS        0H
         CLC       0(4,R5),EOF         TEST FOR END OF FILE
         BE        GETOUT
         MVC       HOLD(8),0(R5)       MOVE THE RECORD
         AR        R5,R6               INCREMENT POINTER
         ST        R5,ICT+4            STORE IT
GETOUT   DS        0H
         LM        R0,R8,SAVE          RESTORE CALLER'S REGS
         BR        R9
*        **************************************************************
* END OF ASMGFPP                                                      *
*        **************************************************************
ENDJOB   DS        0H
         MVI       RLDOUT+1,X'40'      BLANK CARD OUTPUT AREA
         MVC       RLDOUT+2(79),RLDOUT+1
         CLC       DKNO(4),CDZERO      WERE ANY CARDS PUT OUT
         BE        YPN                 NO, SKIP
         BAL       R9,DKCNT            GO STEP AND FORMAT NUMBER FOR
         MVC       RLDOUT+76(4),DKNO   MOVE NUMBER TO OUTPUT ARRY
         MVC       RLDOUT+1(3),ENDCR   MOVE CHARACTERS -END- TO CARD
         MVC       RLDOUT+72(4),DKID   GET DECK ID
         L         R1,ADLIST1(,ACT)    POINT AT LIST1 TABLE IN ASM
         TM        CTDOSI(ACT),X'40'   WAS DOS OPTION SPECIFIED .Q
         BO        NOTDOS              YES, DON'T INDICATE IDR
         MVC       RLDOUT+32(1),CTIDR(ACT) MOVE IN IDR INDICATOR
NOTDOS   DS        0H
         MVC       RLDOUT+33(10),L1PID(R1) MOVE PROR9M I.D. TO END
         MVC       RLDOUT+43(4),L1VERMOD(R1) ADD VERSION AND LEVEL
         MVC       RLDOUT+47(5),L1JULDTE(R1) ADD TODAY'S JULIAN DATE
         MVC       RLDOUT+53(8),L1PRTIME(R1) MAYBE ADD TIME OF DAY
         MVC       RLDOUT+62(9),L1PRDATE(R1) AND A READABLE DATE
         CLI       CTIDR(ACT),C'2'     IS A 2ND IDR PRESENT .Q
         BNE       ONEIDR              BRANCH IF NOT
         MVC       RLDOUT+52(19),CT2IDR(ACT) MOVE 2ND IDR TO CARD
ONEIDR   DS        0H
         L         R1,ENDSWH(,ACT)     GET ENTRY ADDRESS
         LTR       R1,R1               IS THERE AN ENTRY ADDRESS
         BZ        XYZ                 NO
         MVC       RLDOUT+5(3),ENDSWH+1(ACT) YES, PUT IN THE ADDRESS
         MVC       RLDOUT+15(1),ENDSWH(ACT)
         MVI       RLDOUT+14,X'00'
XYZ      DS        0H
         BAL       R9,WRPUN            GO PUNCH CARD
YPN      DS        0H
         L         R1,CESIOA(,ACT)     BOTTOM OF CORE GOTTEN FROM BUFF
         L         R2,CESIOB(,ACT)     TOP OF CORE GOTTEN FROM BUFF
         SR        R2,R1               AMT OF CORE GOTTEN FROM BUFF
         ST        R1,R9D              ADDRESS OF GROW AREA
         ST        R2,R15EN            LENGTH OF GROW AREA
         L         R1,BUFFPT(,ACT)     DO A GROW
         CNOP      2,4
         BALR      R0,R1
         DC        A(32)
R15EN    DS        F
R9D      DS        F
         LA        R9,PAIN
         STM       R1,R15,SAVE
         MVC       RLDOUT+1(3),=C'EOF'
         B         PCH11
PAIN     DS        0H
         MVC       RLDOUT+1(3),=C'RLD'
         TM        CTEXEC(ACT),X'20'   TEST EXECUTE OPTION
         BZ        EXIT
         L         R1,BUFFPT(,ACT)     TCLOSE THE OBJECT DECK UTILITY
         CNOP      2,4
         BALR      R0,R1
         DC        A(24,4,1)
EXIT     DS        0H
         L         R15,=V(ASMGFD)      LOAD ADDRESS OF ASMGFD
         BR        R15                 CALL DIAGNOSTIC ROUTINE
*        **************************************************************
* I/O CONTROL TABLES.  SEE PAGE 4 FOR FORMAT.                         *
*        **************************************************************
IOSAVE   DS        18F                 OS SAVE AREA
PATCH    DC        10S(*)              ASMGFPP PATCH AREA
SAVE     DS        15F                 SAVE AREA FOR REGISTERS 1-15
SR1      DS        F                   SAVE AREA FOR R1 DURING SHRINK
FWORD    DS        2D                  PACKED AND DECIMAL VALUE
DWORD    DS        D                   BINARY VALUE
         DS        C
SQFWORD  DS        18C                 STACK TO ACCUMULATE LEN,VAL,DEF
SQSAVE4  DS        4F
RAPOINTR DC        A(0)                REF AREA POINTER - 16
SQSAVE2  DS        F
CDZERO   DC        X'F0F0F0F0'         MASK FOR ZEROING BLANKS
XRFSIZ   EQU       (XRFLN*BLKFC1+1)/8*8+8 SIZE OF XRF BUFFER
*                                                                     *
XRFTAB   DC        2A(XRFLN*BLKFC1+1+RESBUF)
         DC        A(XRFLN)
         DC        A(4)                READ & PURGE
         DC        X'07'
RLDTAB   DC        2A(RLDLN*BLKFC2+1+RESBUF)
         DC        A(RLDLN)
         DC        A(0)                READ & KEEP
         DC        X'08'
ICT      DS        4F,C                INPUT CONTROL TABLE
*                                                                     *
FR0      EQU       0                   FLOATING REGISTER 0
FR2      EQU       2                   FLOATING REGISTER 2
*                  SYMBOLIC DISPLACEMENTS FOR XREF DEFN ENTRIES       *
XISYMB   EQU       0
XILINE   EQU       6
XIESDID  EQU       8
XIVALUE  EQU       9
XILENG   EQU       12
XIOFFSET EQU       14
*                  SYMBOLIC DISPLACEMENTS FOR SYMBOL TABLE ENTRIES    *
ICHAIN   EQU       0
INOREFS  EQU       4
ILINE    EQU       6
ISYMB    EQU       8
IADJ     EQU       15
IESDID   EQU       16
*                  SYMBOLIC MASKS FOR ADJ CODES                       *
UNDEF    EQU       X'20'
NAMES    EQU       X'03'
         SPACE
EOF      DC        X'7F7F7F7F'         EOF RECORD IN XREF AND RLD
EBCDIC   DC        C' '                TRANSLATE 2ND INTERNAL CODE TO C
         DS        9C
         DC        C'$#@'
         DS        3C
         DC        C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         DS        6C
         DC        C'0123456789'
         SPACE
CFLGS    DC        X'00'               2 COLUMN XREF FLAGS
PKFLG    DC        X'00'               RLD SPLIT FLAG FF=SPLIT,00=NOT
CBUFAD   DS        A                   ADDRESS OF 2 COLUMN BUFFER
CBUFPT   DS        A                   ADDRESS OF CURRENT LINE
CBUFND   DS        A                   ADDRESS OF END OF BUFFER+1
QBUFAD   DC        A(RLDH1)            ADDRESS OF LAST QSAM BUFFER
NXTRLD   DC        A(RLDDET)           WHERE WE ARE IN RLDDET
CTAB     DC        AL1(RMULT+TRIPLE+XFIRST) THIS TABLE IS THE
         DC        AL1(XFIRST)         BIT SETTINGS
         DC        AL1(MULT+RMULT+XFIRST) CORRESPONDING TO THE
         DC        AL1(MULT+RMULT+TRIPLE+XFIRST) VALUES FOR COL=
RETHLD   DS        F                   RETURN ADDRESS FOR WRLST
REGHLD   DS        6F                  SAVE AREA FOR WORK REGISTERS
ADJBS    DS        CL1092              ADJUSTMENT TABLE
ADJBSEND DS        F                   ADJ TABLE FINAL ENTRY +4
DKID     DC        4X'40'              DECK ID
ENDSWX   DC        X'00'               END SWITCH  FF=ON, 00=OFF
EDMASK   DC        XL7'40202020212040' EDIT MASK
CNTSAV   DC        H'0'                LINE COUNTER SAVE AREA
THRNIN   DC        H'57'               THIRTY-NINE HEX
REGDMP   DS        H                   TEMP FOR BYTE COUNT
DKNO     DC        C'0000'             OBJECT DECK SEQUENCE NUMBER
HOLD     DS        D                   RLD HOLD AREA
XRFHLD   EQU       HOLD                XRF HOLD AREA
XRFHOLD  DS        D                   SYMBOL FOR 'CONTINUED' IND
RLDIMAGE DC        CL40' '             RLD COLUMN IMAGE
COMPID   DS        0CL4                COMPARE FOR SAME ID
         DC        X'00'
TSTPES   DS        C                   POS. ID
         DC        X'00'
TSTRES   DS        C                   REL. ID
RLDHLD   DC        8X'0'               RLD FOR CARD OUTPUT
HLDRLD   DS        0CL8                TO UNPACK RLD FOR CARD
PESDID   DS        C                   POS. ESD/ID
RESDID   DS        C                   REL. ESD/ID
ENDRLD   DS        CL6                 RLD FOR OUTPUT
ALWRD    DC        F'0'                ALIGNMENT WORD
LREFSPNT DS        F                   ADDRESS OF POINTER TO SMALLEST
LREFSMLL DS        F                   ADDRESS OF SMALLEST LITERAL
LREFMOVE MVC       LRFOUT+22(*-*),4(R2) MOVE LITERAL STRING TO LINE
LREFTR   TR        4(*-*,R2),0(R4)     EX LITERAL TRANSLATE TO EBCDIC
LREFCOMP CLC       4(*-*,R5),4(R2)     COMPARE LITERALS FOR ORDER
HEAD1    DS        0CL133              1ST PAGE HEADING
UMAPH1   DS        0CL133              USING MAP PAGE HEADING
LRFH1    DS        0CL133              LITERAL CROSS REFERENCE HEAD1
XRFH1    DS        0CL133              SYMBOL CROSS REFERENCE HEAD1
RLDH1    DS        0CL133              RLD HEADING ONE
         DC        X'FF'               EJECT
HEAD1LAB DC        CL8' '              PROGRAM I.D.
         DC        CL32' '             SPACE TO HEADID
HEAD1ID  DC        CL23' '             HEADING IDENTIFIER
         DC        CL48' '             SPACE TO PAGE
         DC        CL5'PAGE '
HEAD1PGE DC        CL4' '              PAGE NUMBER
         DC        CL12' '             FILL TO 133 CHARACTERS
         SPACE     2
HEAD2    DS        0CL133              SECOND PAGE HEADING
UMAPH2   DS        0CL133              USING MAP SECOND HEADING
LRFH2    DS        0CL133              LITERAL CROSS REFERENCE HEAD2
XRFH2    DS        0CL133              SYMBOL CROSS REFERENCE HEAD2
RLDH2    DS        0CL133              RLD HEADING TWO
         DC        X'02'               TRIPLE SPACE
HEAD2ID  DC        CL111' '            HEADING TWO IDENTIFIER
HEAD2DTE DC        CL9'DD MMM YY'      ASSEMBLY DATE
         DC        CL12' '             FILL TO 133 CHARACTERS
         SPACE     2
OUTLINE  DS        0CL133              OUTPUT WORK LINE
UMAPOUT  DS        0CL133              USING MAP DETAIL OUTPUT LINE
LRFOUT   DS        0CL133              LREF DETAIL OUTPUT LINE
XRFOUT   DS        0CL133              XREF DETAIL OUTPUT LINE
RLDDET   DS        0CL133              RLD DETAIL OUTPUT LINE
         DC        X'00'               NO SPACEING CARRIAGE CONTROL
         DC        CL132' '            OUTPUT LINE
LRFSN1   EQU       LRFOUT+37           LITERAL REFERENCES
XRFSN1   EQU       XRFOUT+31           XREF REFERENCES
         SPACE     2
UMP1ID   DC        CL23'       USING MAP       '
LRF1ID   DC        CL23'LITERAL CROSS-REFERENCE'
XRF1ID   DC        CL23'    CROSS-REFERENCE    '
RLD1ID   DC        CL23' RELOCATION DICTIONARY '
         SPACE     2
UMP2ID   DC        C' REGISTER  USING STMT  DROP STMT  VALUE'
LRF2ID   DC        C'  LOC  LEN   DEFN     LITERAL                  REF*
               ERENCES'
XRF2ID   DC        C'SYMBOL     LEN  VALUE  DEFN    REFERENCES'
SRF2ID   DC        C'SYMBOL    LENGTH,VALUE,DEFN  REFERENCES'
RLD2ID   DC        C' POS.ID  REL.ID  FLAGS  ADDRESS'
         SPACE     2
ENDCR    DC        C'END'              FOR END CARD
         DS        0D                  FOR RLDOUT
RLDOUT   DC        X'02'               CARD IMAGE FOR RLD OUTPUT
         DC        C'RLD'
         DC        6C' '
BYTOUT   DS        2C                  NUMBER OF BYTES
         DC        4C' '
VARRLD   DC        56C' '              RLD OUTPUT
         DC        8C' '
BASED    DS        F                   START OF SORT AREA
SQTRTAB2 DC        X'FF'               TABLE TO PASS 0'S
SQTRTAB1 DC        16C'0123456789ABCDEF' TABLE TO TR HEX TO CHAR
         ORG       SQTRTAB2+C'0'
         DC        X'00'
         ORG
SQTRTAB3 DC        256X'00'            TABLE TO FIND BLANKS
         ORG       SQTRTAB3+C' '
         DC        X'FF'
         ORG
         LTORG
RESBUF   DS        0D,XL(XRFSIZ)       INTERNAL I/O BUFFERS
ERRBUF   EQU       RESBUF
TERLI    EQU       ERRBUF+1
ERRCDL   EQU       ERRBUF+519
         SPACE     2
ENDFPP   DS        0D
         SPACE     2
USNGMAP  DSECT
USNGREG  DS        0AL1                REGISTER NUMBER
USNGCHN  DS        A                   CHAIN OF USING BLOCKS
USNGSTRT DS        H                   START USING STATEMENT NUMBER
USNGDROP DS        H                   DROP USING STATEMENT NUMBER
USNGFILL DS        F                   FILLER
USNGESD  DS        0XL1                ESD-ID OF USING LOCATION
USNGDISP DS        F                   OFFSET OF USING LOCATION
USNGLEN  EQU       *-USNGMAP           LENGTH OF CONTROL BLOCK
USNGDUP  EQU       5                   NUM USING MAP BLOCKS PER AREA
         SPACE     2
         END       ASMGFPP
./ ADD NAME=ASMGF1   0114-88357-88358-0759-02084-02166-00000-CHSY227
F1       TITLE     'ASMG     MACRO GENERATOR INITIALIZATION PHASE'
*TITLE-'ASMGF1' (PHASE F1)
*FUNCTION- INITIALIZATION, INCLUDING...
*   PROCESS INVOKER'S DD NAMES, IF ANY.
*   PROCESS ASSEMBLER PARAMETER LIST.
*   OPEN ALL NECESSARY DATASETS.
*   LOAD THE CORRECT OP-CODE TABLE AND ASSOCIATED HASH TABLE FOR
*     THE GLOBAL DICTIONARY.
*   GET MAIN STORAGE AND ALLOCATE BUFFER AREAS.
*   INITIALIZE CONSTANTS AND INDICATORS IN COMMON AREA FOR PHASE F2.
*   BUILD A DIRECTORY OF ALL MACROS ON SYSLIB VS TTR DISK ADDRESS.
*   PROCESS ICTL RECORD.
*ENTRY POINT-ASMGF1. ENTERED FROM PHASE 'ASM' BY
*        LINK DE=(R2),MF=(E,(1))     I.E. EP=ASMGF2
*INPUT-
*   ON SYSIN- SOURCE CARDS.
*   IN REG R14 - RETURN ADDRESS TO PHASE 'ASM'.
*   IN REG R9 - ADDRESS OF PARAMETER LIST 'LIST1' IN PHASE 'ASM'.
*   IN REG R10- 00 IF FIRST ENTRY, FF IF LOOP IN BATCH MODE.
*   'LIST1' INCLUDES ADDRESS OF CONTROL PROG PARAM LIST.
*   CONTROL PROG PARAM LIST HAS THE FOLLOWING FORMAT...
*     IF NO DDNAMES ARE SPECIFIED-
*        DC    X'80',AL3(ASMPAR)   POINT TO ASSEMBLER PARAMETER STRING
*     IF ANY DDNAMES ARE SPECIFIED-
*        DC    A(ASMPAR)           POINT TO ASSEMBLER PARAMETER STRING
*        DC    X'80',AL3(DDNAM)    POINT TO DDNAME PARAMETER STRING
*
*   FORMAT OF ASMPAR STRING- LLPARAM1,PARAM2,PARAM3,....
*              IT MUST START ON A HALFWORD BOUNDARY.
*   FORMAT OF DDNAME STRING- LLDDNAME01DDNAME02DDNAME03....
*              IT MUST START ON A HALFWORD BOUNDARY.
*
*   LL IS BYTE LENGTH OF STRING IN BINARY (EXCLUDING LL)
*
*   EACH DDNAME USES 8 BYTES. DDNAME LIST IS ORDER- AND POSITION-
*   DEPENDENT. EACH NAME IN THE LIST REPLACES THE CORRESPONDINGLY
*   POSITIONED NAME IN THE FOLLOWING STANDARD LIST-
*                   SYSLIN
*                   SYSUP
*                   SYSTERM
*                   SYSLIB
*                   SYSIN
*                   SYSPRINT
*                   SYSPUNCH
*                   SYSUT1
*                   SYSUT2
*                   SYSUT3
*   THE ASSEMBLER USES ALL TEN ENTRIES IN THIS STRING.
*   EIGHT HEX ZEROS MEANS KEEP THE STANDARD NAME.
*
*   EXAMPLE. TO CHANGE SYSIN TO MYNAME AND SYSPUNCH TO HISNAME, THE
*   FORMAT OF THE DDNAME STRING IS
*            5800000000000000000000000000000000MYNAME  00000000HISNAME
*              WHERE '0' IS A BYTE OF BINARY ZEROS.
*
*EXTERNAL ROUTINES- I/O PACKAGE IN PHASE 'ASM', DECK 'BUFF'
*   READ, WRITE, CHECK, NOTE
*EXIT- AFTER LOCATION F2XCTL
*        XCTL     EP=ASMGF2
*
*   EXIT CONDITIONS INDICATED IN ERRSW1 BYTE -
*   ERRBDPM='0' -- PARM FIELD OK.
*   ERRBDPM='1' -- ERROR IN PARM FIELD.
*
         SPACE     4
*
*        SET ALL GLOBAL SWITCHES NOW
         COPY      ASMGSET
*
*        END OF SETTING GLOBAL SWITCHES
         EJECT
ASMGF1   CSECT
*
*
*        REGISTER DEFINITIONS-
         SETR
*
         LR        R11,R15             TRANSFER ENTRY ADDRESS
         USING     ASMGF1,R11,R12      TELL ASSEMBLER ABOUT MY BASES
         LA        R12,4095(,R11)      FORM ALMOST THE SECOND BASE
         LA        R12,1(,R12)         THIS IS MY SECOND BASE
*
         ENTRYOUT  F1,CSECT=GAECT
*
         LR        R15,R13             SAVE ASM SAVE AREA ADDRESS
         L         R13,=A(COMMON)      USE SAVE AREA AT START OF COMMON
         USING     COMMON,R13
*
*        GET ASM PARAMETER LIST STUFF
*
         ST        R15,ASMSAVE         ADDRESS OF SAVE AREA IN ASM
         ST        R14,RETURN          SAVE RETURN ADDRESS TO ASM
         ST        R9,ADLIST1          SAVE ADDRESS OF LIST1 IN ASM
         MVC       BUFFENT(4),L1BUFADR(R9)  GET ADDRESS OF BUFF RTN
         MVC       INITERAD(4),L1BUFERR(R9)  BUFF ERROR HANDLER IN ASM
         MVC       ADCBLB(8),L1DCBADS+L1SLIB(R9) SYSLIB/SYSIN DCB ADDR
*
         L         R6,L1CTLPRM(,R9)    POINT TO CONTROL PROG PARAM LIST
         SPACE     2
DDLIST   DS        0H
         LTR       R10,R10             ONLY SET DDNAMES ON 1ST PASS
         BNZ       SYSTYPE
*
***   PROCESS LIST OF INVOKERS DD NAMES, IF PRESENT.   ***
*
         TM        0(R6),X'80'         TEST FOR END OF PARAM LIST
         BO        SYSTYPE             BRANCH IF END
         L         R3,4(,R6)           POINT TO INVOKER'S DDNAME LIST
         LA        R4,12*8             WILL ACCEPT 12 DDNAMES AT MOST
         CH        R4,0(,R3)           ARE THERE MORE .Q
         BL        DDLENMX             USE ONLY MAXIMUM IF SO
         LH        R4,0(,R3)           GET OVERRIDING LENGTH
DDLENMX  DS        0H
         L         R7,=F'-8'           BXH INCREMENT
         NR        R4,R7               DOUBLE WORD ALIGN LENGTH
         LA        R3,2(R4,R3)         POINT TO END OF LAST DDNAME
         B         DDINC               POINT TO NEXT TO LAST
*
*        PICK UP INVOKER'S DD NAMES
DDLOOP   DS        0H
         OC        0(8,R3),0(R3)       IS DDNAME ZERO .Q
         BZ        DDINC               BRANCH AROUND IF YES
         LR        R1,R4               GET DDNAME OFFSET
         SRL       R1,2                DIVIDE BY FOUR
         LH        R1,DCTDVTAD(R1)     CONVERT TO INTERNAL DISPLACEMENT
         L         R5,L1DCBADS(R1,R9)  POINT TO DCB
         MVC       DCBDDNAM(8,R5),0(R3)  ALTER DDNAME IN DCB
         AR        R1,R1               DOUBLE OFFSET
         LA        R5,L1DDNAM(R1,R9)   POINT TO DDNAME IN LIST
         MVC       0(8,R5),0(R3)       ALTER NAME IN DDNAME LIST
DDINC    DS        0H
         AR        R3,R7               POINT AT PREVIOUS USER DDNAME
         BXH       R4,R7,DDLOOP        REDUCE LENGTH BY EIGHT AND TEST
         SPACE     2
*
***      PROCESS LIST OF ACCESS METHOD ADDRESSES, IF PRESENT   ***
*
SYSACSMS DS        0H
         TM        4(R6),X'80'         END OF PARAM LIST .Q
         BO        SYSTYPE             BRANCH IF END
         L         R3,8(,R6)           POINT TO INVOKER'S LIST
SYSACSML DS        0H
         TM        3(R3),X'03'         A MULTIPLE OF FOUR .Q
         BNZ       SYSACSME            BRANCH IF NOT
         IC        R4,0(,R3)           GET ACMETH CODE
         N         R4,=F'127'          PURIFY THE OFFSET
         CH        R4,=H'48'           IS IT TOO BIG .Q
         BNL       SYSACSME            BRANCH IF YES
         SRL       R4,1                DIVIDE BY TWO
         LH        R4,DCTDVTAD(R4)     GET DCB LIST OFFSET
         CLC       1(3,R3),F1+1        IS THIS ONE OR LESS
         BNH       SYSACSME            FORGET IT IF SO
         L         R1,L1DCBADS(R4,R9)  GET DCB ADDRESS
         TM        L1DCBPAD(R1),X'0C'  MONITOR FOR PUTS/GETS
         BZ        SYSACSME            BRANCH IF NO
         MVI       DCBOFLGS(R1),X'10'  OPEN BUT LOCKED
         MVC       DCBGET+1(3,R1),1(R3)  ENTER USER'S ADDRESS
SYSACSME DS        0H
         TM        0(R3),X'80'         AT THE END .Q
         BO        SYSTYPE             BRANCH IF YES
         LA        R3,4(,R3)           NEXT ENTRY
         B         SYSACSML            LOOP ALONG
         SPACE     2
*
*        DETERMINE TYPE OF OPERATING SYSTEM
*
SYSTYPE  DS        0H
         L         R1,CVTPTR           GET CVT POINTER
         S         R1,F8               POINT AT CVT PREFIX
         CLI       CVTRELNO(R1),C'C'   DOES RELNO START WITH 'C' .Q
         BNE       SYSNCMS             NOT CMS IF NO
         LA        R2,7                OFFSET POINTER FOR CMS
         OI        PARBYT3,CMS         TURN ON CMS OPTION
         B         SYSTNV              AND CONTINUE PROCESSING
SYSNCMS  DS        0H
         IC        R2,CVTDCB(,R1)      TYPE OF SYSTEM FLAG
         SRL       R2,4                SHIFT TO OFFSET
         N         R2,F7               CLEAR GARBAGE
         BCTR      R2,0                DECREMENT BY ONE
         AR        R2,R2               DOUBLE IT
         TM        CVTDCB(R1),X'02'    ARE WE VIRTUAL .Q
         BZ        SYSTNV              BRANCH IF NOT
         LA        R2,1(,R2)           INCREMENT OFFSET
SYSTNV   DS        0H
         SLL       R2,2                WORK WITH MULTIPLES OF FOUR
         LA        R2,SYSTAB(R2)       POINT AT ENTRY IN SYSTAB
         MVC       SPACENEG+2(1),3(R2) SET DEFAULT SPACE PARAMETER
         MVC       SYSTEM+7(3),0(R2)   SET NAME OF SYSTEM FOR HEADER
         MVC       SYSTEM+11(4),CVTRELNO(R1)  SET RELEASE NUMBER
         CLI       SYSTEM+14,C' '      IS RELEASE TOO SHORT
         BNE       SYSMODEL            BRANCH IF NOT
         MVC       SYSTEM+14(1),SYSTEM+13  SHUFFLE AROUND
         MVI       SYSTEM+13,C'.'      AND ADD A SEPARATOR
SYSMODEL DS        0H
         UNPK      DWORD(4),CVTMDL(3,R1)  CONVERT MODEL NUMBER
         MVC       MODEL+6(2),DWORD+1  ASSUME IT'S A 360
         CLI       DWORD,C'0'          BUT TEST IT
         BE        PARMSCAN            BRANCH IF IT IS
         MVC       MODEL+6(3),DWORD    SET THREE DIGIT MODEL NUMBER
         SPACE     2
*
*        SCAN OFF THE PARM FIELD
*
*        CHECK IF ANY PARM FIELD
PARMSCAN DS        0H
         L         R1,0(,R6)           POINT AT PARM
         LH        R2,0(,R1)           PICK UP LENGTH
         LTR       R2,R2               TEST FOR NO PARM
         BZ        ENDSCN
*        INITIALIZE FOR SCAN
         LA        R1,2(,R1)           INITIALIZE FIELD SCAN POINTER
         AR        R2,R1               LAST CHARACTER + 1
*        SCAN OFF ONE WORD
NEXTWORD DS        0H
         ST        R1,PARMOFF          SAVE INITIAL ADDRESS
         LR        R4,R1               START OF WORD
         LR        R3,R1               INITIALIZE FORMER CHARACTER
         NI        ERRSW1,X'FF'-ERRLPRN  CLEAR PARENS SWITCH
         CLI       0(R1),C' '          IS A BLANK FIRST .Q
         BNE       WORDSCAN            START SCANNING IF NOT
         CR        R1,R2               TEST FOR END OF PARM
         BNL       WORDEND             BRANCH IF THAT'S ALL
         LA        R1,1(,R1)           POINT TO NEXT CHARACTER
         B         NEXTWORD            AND TRY AGAIN
WORDSCAN DS        0H
         CR        R1,R2               TEST FOR END OF PARM
         BNL       WORDEND             BRANCH IF AT THE END
         CLI       0(R1),C','          TEST FOR COMMA
         BE        WORDEND             BRANCH IF COMMA
         CLI       0(R1),C' '          TEST FOR BLANK
         BE        WORDEND             BRANCH IF BLANK
         CLI       0(R1),C'='          TEST FOR EQUAL
         BE        WORDEND             BRANCH IF EQUAL
         CLI       0(R1),C'('          LEFT PAREN
         BE        WORDLPRN            BRANCH IF LEFT PAREN
         LA        R1,1(,R1)           POINT AT NEXT CHARACTER
         B         WORDSCAN            DO IT AGAIN
WORDLPRN DS        0H
         OI        ERRSW1,ERRLPRN      SET PAREN DELIMITER SWITCH
*
*        COMPUTE PARM LENGTH
WORDEND  DS        0H
         LR        R5,R1               LAST LETTER OF WORD+1
         SR        R5,R4               MINUS FIRST LETTER
         BZ        COMTEST             TEST FOR ZERO LENGTH, NOW OK
         CH        R5,H12              TEST FOR TOO LONG
         BH        PARMERR             ERROR IF SO
         BCTR      R5,0                LENGTH-1
         LA        R3,OPTEST           POINT TO START OF PARAM TABLE
NEXTOPT  DS        0H
         CLI       0(R3),X'FF'         AT THE END .Q
         BE        PARMERR             ERROR IF SO
         IC        R6,OPTPLEN(,R3)     GET MIN LENGTH-1 OF PARM
         SRL       R6,4                SHIFT
         N         R6,F15              AND PURIFY
         CR        R5,R6               IS THIS A CANDIDATE .Q
         BL        BXLEOPT             BRANCH IF NOT
         EX        R5,OPTCLC           DO THE COMPARE
         BE        FOUND               BRANCH IF THIS IS IT
BXLEOPT  DS        0H
         LA        R3,OPTPEND(,R3)     POINT TO NEXT ENTRY
         B         NEXTOPT             TRY AGAIN
OPTCLC   CLC       OPTPSTR(*-*,R3),0(R4)  COMPARE NAMES
*
*        A MATCH HAS BEEN FOUND
FOUND    DS        0H
         ST        R1,PARMOFF          SAVE CURRENT PARM POINTER
         IC        R5,OPTPFLGS(,R3)    PICK UP CONTROL BYTE
         N         R5,F15              KNOCK OFF TOP HALF BYTE
         AR        R5,R5               DOUBLE IT
         LH        R5,ONOFFTBL(R5)     GET ROUTINE OFFSET
         B         ASMGF1(R5)          DO WHAT CONTROL BYTE SAYS
ONOFFTBL DC        AL2(ON1ON2-ASMGF1)       CONTROL BYTE =X'0'
         DC        AL2(OFF1OFF2-ASMGF1)     CONTROL BYTE =X'1'
         DC        AL2(OFF1ON2-ASMGF1)      CONTROL BYTE =X'2'
         DC        AL2(ONDIGIT-ASMGF1)      CONTROL BYTE =X'3'
         DC        AL2(ONSPARM-ASMGF1)      CONTROL BYTE =X'4'
         DC        AL2(ONSPACE-ASMGF1)      CONTROL BYTE =X'5'
ON1ON2   DS        0H
         OC        PARBYT0(6),OPTPBITS(R3)  TURN SWITCHES ON
         B         SUFFTEST            AND CONTINUE
OFF1OFF2 DS        0H
         NC        PARBYT0(6),OPTPBITS(R3)  TURN SWITCHES OFF
         B         SUFFTEST            AND CONTINUE
OFF1ON2  DS        0H
         NC        PARBYT0(2),OPTPBITS(R3)  TURN SOME BITS OFF
         OC        PARBYT(4),OPTPBITS+2(R3) AND SOME BITS ON
SUFFTEST DS        0H
         TM        OPTPFLGS(R3),X'40'  IS THIS AN XREF SUFFIX .Q
         BO        ONSXREF             BRANCH IF YES
         B         COMTEST             GO TEST FOR COMMAS AND BLANKS
ONDIGIT  DS        0H
*        SCAN OFF NUMBER
         CLI       0(R1),C'='          EQUAL DELIMITER .Q
         BE        ONDIGDLM            BRANCH IF YES
         CLI       0(R1),C'('          PAREN DELIMITER .Q
         BNE       ONDIGST             BRANCH IF NOT
         OI        ERRSW1,ERRLPRN      SET PARENS SWITCH
ONDIGDLM DS        0H
         LA        R1,1(,R1)           BUMP PAST DELIMITER
ONDIGST  DS        0H
         LR        R4,R1               1ST DIGIT IN NUMBER
NUMSCAN  DS        0H
         CR        R1,R2               TEST FOR END OF PARM FIELD
         BE        NUMEND
         CLI       0(R1),C'0'          TEST FOR NUMERIC
         BL        NUMEND
         CLI       0(R1),C'9'
         BH        NUMEND
         LA        R1,1(,R1)           POINT AT NEXT CHARACTER
         B         NUMSCAN
NUMEND   DS        0H
         LR        R5,R1               COMPUTE LENGTH OF NUMBER
         SR        R5,R4
         BZ        PARMERR             ERROR IF NO DIGITS
         C         R5,F7               TEST FOR TOO MANY DIGITS
         BH        PARMERR
         BCTR      R5,0                LENGTH-1
         EX        R5,PARMPACK         PACK DIGITS INTO DWORD
         CVB       R4,DWORD            PLACE BINARY NUM IN R4
*        TEST IF NUMBER FOLLOWED BY LETTER K
         CR        R1,R2               TEST FOR END OF PARM FIELD
         BE        NOK
         CLI       0(R1),C'K'          TEST FOR LETTER K
         BNE       NOK
         LA        R1,1(,R1)           POINT AT NEXT CHARACTER
         SLA       R4,10               MULTIPLY BY 1024
         BO        PARMERR             TEST FOR OVERFLOW
NOK      DS        0H
         SR        R5,R5               ZERO OFFSET REGISTER
         IC        R5,OPTPBITS(,R3)    1ST HALF OF OFFSET INTO TAB3PARM
         SLL       R5,8                MOVE ONE BYTE OVER
         IC        R5,OPTPBITS+1(,R3)  2ND HALF OF OFFSET INTO TAB3PARM
         C         R4,TAB3PARM+TAB3MIN(R5)  CHECK FOR BIG ENOUGH
         BL        PARMERR                  BRANCH IF TOO SMALL
*
         CL        R4,TAB3PARM+TAB3MAX(R5)  CHECK FOR SMALL ENOUGH
         BH        PARMERR                  BRANCH IF TOO BIG
         ST        R4,TAB3PARM+TAB3DEF(R5)  STORE CONVERTED NUMBER
PNCMTEST DS        0H
         TM        ERRSW1,ERRLPRN      LEFT PARENS AROUND PARM .Q
         BZ        COMTEST             BRANCH IF NOT
         CLI       0(R1),C')'          RIGHT PAREN
         BE        BLKTEST             IGNORE IT IF SO
COMTEST  DS        0H
         ST        R1,PARMOFF          SAVE CURRENT PARM POINTER
         CR        R1,R2               TEST FOR END OF PARM FIELD
         BNL       ENDSCN
         CLI       0(R1),C' '          TEST FOR A BLANK
         BE        BLKTEST             BRANCH IF YES
         CLI       0(R1),C','          TEST FOR COMMA
         BNE       PARMERR             THEN IT MUST BE AN ERROR
BLKTEST  DS        0H
         LA        R1,1(,R1)           POINT AT NEXT CHARACTER
         B         NEXTWORD            GET NEXT PARM
*
*        SCAN OFF SYSPARM AND ITS LENGTH
*
ONSPARM  DS        0H
         CLI       0(R1),C'='          EQUAL DELIMITER .Q
         BE        ONSPARM1            BRANCH IF YES
         CLI       0(R1),C'('          PAREN DELIMITER .Q
         BNE       PARMERR             BRANCH TO ERROR IF NOT
ONSPARM1 DS        0H
         LA        R1,1(,R1)           BUMP INPUT POINTER
         ST        R1,L1ASPARM(,R9)    REMEMBER WHERE PARM STARTS
         ST        R1,PARMOFF          SAVE CURRENT PARM POINTER
         SR        R3,R3               ZERO LENGTH OF PARM
         SR        R4,R4               ZERO QUOTE BRACKET COUNTER
         CR        R1,R2               AT THE STRING END .Q
         BNL       SYSPDONE            BRANCH IF YES
*
         CLI       0(R1),C''''         DO QUOTES SURROUND PARM .Q
         BNE       SYSPBRAK            NO, CHECK FOR BRACKETS
SYSPQ1   DS        0H
         BCTR      R4,0                OUTSTANDING QUOTE
SYSPQ2   DS        0H
         BAL       R5,SYSPBUMP         BUMP POINTERS
         CLI       0(R1),C''''         A QUOTE .Q
         BNE       SYSPQ2              NO, GO BACK
         SR        R4,R4               NO OUTSTANDING QUOTE
         BAL       R5,SYSPBUMP         BUMP POINTERS
         CLI       0(R1),C''''         A DOUBLE QUOTE .Q
         BE        SYSPQ1              YES, GO BACK
         B         SYSPDONE            THAT'S IT
*
SYSPBRAK DS        0H
         TM        ERRSW1,ERRLPRN      PARENS AROUND PARM .Q
         BZ        SYSPB0              BRANCH IF NOT
         BCTR      R1,0                DECREMENT INPUT POINTER
*
SYSPB0   DS        0H
         CLI       0(R1),C'('          DO BRACKETS SURROUND PARM .Q
         BNE       SYSPORD             NO, ORDINARY COMMA CASE
SYSPB1   DS        0H
         LA        R4,1(,R4)           BUMP '(' COUNT
SYSPB2   DS        0H
         BAL       R5,SYSPBUMP         BUMP POINTERS
         CLI       0(R1),C'('          MORE '(' .Q
         BE        SYSPB1              YES, GO BACK AND BUMP COUNT
         CLI       0(R1),C')'          IS IT ')' .Q
         BNE       SYSPB2              NO, GO BACK AND PROCEED
         BCTR      R4,0                DECREMENT BRACKET COUNT
         LTR       R4,R4               DO BRACKETS MATCH .Q
         BNZ       SYSPB2              NOT YET, GO BACK
         TM        ERRSW1,ERRLPRN      LEFT PARENS AROUND PARM .Q
         BO        SYSPB3              BRANCH IF YES
         LA        R3,1(,R3)           ANTICIPATE END OF STRING
         BAL       R5,SYSPBUMP         BUMP POINTERS TO COMMA
         BCTR      R3,0                NO END OF STRING
         B         SYSPDONE            ALMOST READY TO GO BACK
SYSPB3   DS        0H
         BCTR      R3,0                DECREMENT LENGTH BY TRAILING ')'
         B         SYSPDONE            AND QUIT
*
SYSPORD  DS        0H
         CLI       0(R1),C','          TERMINATING COMMA .Q
         BE        SYSPDONE            YES, THAT'S ALL
         LA        R3,1(,R3)           ANTICIPATE END OF STRING
         BAL       R5,SYSPBUMP         BUMP POINTERS
         BCTR      R3,0                NO END OF STRING
         B         SYSPORD             TRY AGAIN
*
SYSPDONE DS        0H
         LTR       R4,R4               ANY OUTSTANDING ')' OR ',' .Q
         BNZ       PARMERR             IF SO, THEN AN ERROR
         STC       R3,L1ASPARM(,R9)    SAVE LENGTH OF PARM
         B         PNCMTEST            RETURN
*
SYSPBUMP DS        0H
         LA        R1,1(,R1)           BUMP PARM POINTER
         CR        R1,R2               TEST FOR END OF PARM FIELD
         BNL       SYSPDONE            NO PARM LEFT
         LA        R3,1(,R3)           BUMP LENGTH
         BR        R5                  NORMAL RETURN
         SPACE     2
ONSPACE  DS        0H
         CLI       0(R1),C'='          EQUAL DELIM .Q
         BE        ONSPACE2            YES
         CLI       0(R1),C'('          PAREN DELIMITER .Q
         BE        ONSPACE2            YES
ONSPACE1 DS        0H
         LA        R3,SPACEEQ          POINT TO SPACE=N
         B         FOUND               AND CONTINUE
ONSPACE2 DS        0H
         CLC       =C'MAX-',1(R1)      IS THIS IT
         BNE       ONSPACE3            BRANCH IF NOT
         LA        R1,5(,R1)           UP INPUT POINTER
         LA        R3,SPACEMM          POINT TO SPACE=MAX-
         B         FOUND               AND CONTINUE
ONSPACE3 DS        0H
         CLC       =C'MAX',1(R1)       IS THIS IT .Q
         BNE       ONSPACE4            BRANCH IF NOT
         LA        R1,4(,R1)           UP INPUT POINTER
         LA        R3,SPACEMX          POINT TO SPACE=MAX
         B         FOUND               AND CONTINUE
ONSPACE4 DS        0H
         LA        R1,1(,R1)           GET OVER DELIMITER
         B         ONSPACE1            SPACE999 ALL THAT'S LEFT
         SPACE     2
ONSXREF  DS        0H
         CLI       0(R1),C'='          EQUAL DELIMITER .Q
         BE        ONSXREFP            YES
         CLI       0(R1),C'('          PAREN DELIMITER .Q
         BE        ONSXREFP            YES
ONSXREFA DS        0H
         NI        PARBYT3,X'FF'-XREFFS  XREF(FULL)
         MVI       XREFSUFX,X'00'      SET SUFFIX LENGTH ZERO
         B         COMTEST             CHECK FOR COMMAS AND BLANKS
ONSXREFP DS        0H
         CLC       =C'FULL',1(R1)      XREF(FULL) .Q
         BNE       ONSXREFQ            BRANCH IF NO
         NI        PARBYT3,X'FF'-XREFFS  XREF(FULL)
         ST        R1,XREFSUFX         SAVE XREF SUFFIX ADDRESS
         MVI       XREFSUFX,X'04'      SET SUFFIX LENGTH
         LA        R1,5(,R1)           POINT AFTER FULL
         B         PNCMTEST            CHECK FOR DELIMS
ONSXREFQ DS        0H
         CLC       =C'SHORT',1(R1)     XREF(SHORT) .Q
         BNE       ONSXREFA            BRANCH IF NOT
         OI        PARBYT3,XREFFS      XREF(SHORT)
         ST        R1,XREFSUFX         SAVE XREF SUFFIX ADDRESS
         MVI       XREFSUFX,X'05'      SET SUFFIX LENGTH
         LA        R1,6(,R1)           POINT AFTER SHORT
         B         PNCMTEST            AND CONTINUE
         SPACE     2
PARMPACK PACK      DWORD(8),0(*-*,R4)  EX'ED INSTRUCTION
MOVEPARM MVC       LINE+L'OVERRIDE+1(*-*),2(R6)  EX'ED MOVE PARM INST
PARMERR  DS        0H
         OI        ERRSW1,ERRBDPM      SET PARM FIELD ERROR SW FOR F2
         SPACE     2
*        CHECK IF CONFLICTING SPACE PARAMETERS ARE IN EFFECT
*        IF SO TURN OFF ALL BUT ONE
*        LOWEST PRIORITY SHOULD BE GIVEN TO DEFAULT FORM
ENDSCN   DS        0H
         CLI       SPACEPOS+TAB3DEF,X'FF'  TEST FOR SPACE=N FORM
         BE        TRYMAX
         NI        PARBYT2,X'FF'-SPACEM  TURN OFF SPACE=MAX
OFFMAXN  DS        0H
         MVI       SPACENEG+TAB3DEF,X'FF'  TURN OFF SPACE=MAX-N
         B         OPEN
TRYMAX   DS        0H
         TM        PARBYT2,SPACEM      TEST FOR SPACE=MAX
         BO        OFFMAXN             BRANCH IF YES
         EJECT
OPEN     DS        0H
         LTR       R10,R10             BYPASS OPEN IF NOT 1ST F1 TIME
         BNE       HEADING             BRANCH TO PRINT HEADING
*
*        PICK UP BLKSIZES SPECIFIED BY USER ON UTILITY DD CARDS
         LM        R6,R8,=A(4,8,0)     INIT BXLE REGS
LOOPJFCB DS        0H
         L         R2,L1DCBADS+L1SUT1(R8,R9)  GET ADDRESS OF UT DCB
         MVC       IOSAVE+1(3),DCBEXLST(R2) SAVE UTILITY EXLST
         MVC       DCBEXLST(3,R2),=AL3(UTEXLST) POINTER FOR JFCB
         RDJFCB    ((R2))              GET DD CARD DATA
         MVC       L1DCBBLK(2,R2),UTJFCB+JFCBLKSI  SAVE USER'S BLKSIZE
         MVC       DCBEXLST(3,R2),IOSAVE+1 RESTORE UTILITY EXLST
         BXLE      R8,R6,LOOPJFCB      LOOP FOR ALL UTILITIES
         AIF       (NOT &SYSGO).NOSYSGO
*        CHECK IF SYSLIN OR SYSGO IS IN THE TIOT
         L         R8,L1DCBADS+L1SLIN(,R9)  SYSLIN DCB ADDRESS
         TM        DCBOFLGS(R8),X'10'  IS IT ALREADY OPEN .Q
         BO        OPENAWAY            BRANCH IF YES
         LA        R1,L1DDNAM+2*L1SLIN(,R9)  POINT AT SYSLIN DDNAME
         BAL       R14,SRCHTIOT        TEST IF IN TIOT
         BE        OPENAWAY            BR IF SO
         LA        R1,=CL8'SYSGO'      POINT AT NAME SYSGO
         BAL       R14,SRCHTIOT        TEST IF SYSGO IN TIOT
         BNE       OPENAWAY            BR IF NOT
         MVC       L1DDNAM+2*L1SLIN(8,R9),=CL8'SYSGO' NEW SYSLIN DDNAME
         MVC       DCBDDNAM(8,R8),=CL8'SYSGO' REPLACE NAME IN DCB
OPENAWAY DS        0H                  CARRY ON
.NOSYSGO ANOP
*        PICK UP THE DCB ADDRESS AND PUT THEM IN THE OPEN EXPANSION
         OC        OPADLIN(4*10),L1DCBADS(R9)  DCB ADDRESSES TO OPEN
*        TEST IF THE OPTIONAL DATASETS SHOULD BE OPENED
         TM        PARBYT,DECK         TEST DECK OPTION
         BO        *+10
         MVC       OPADPCH(3*4),OPADPCH+4 REMOVE SYSPUNCH ENTRY
         L         R8,L1DCBADS+L1SPRINT(,R9)  GET SYSPRINT DCB ADDRESS
         TM        DCBOFLGS(R8),X'10'  IS SYSPRINT ALREADY OPEN .Q
         BO        OPENUPDT            BRANCH IF YES
         TM        PARBYT3,PRT         IS PRINT ON .Q
         BZ        OPENDPRT            NO, DUMMY OPEN AND BR14 RETURN
         LA        R1,L1DDNAM+2*L1SPRINT(,R9)  POINT AT SYSPRINT DDNAME
         BAL       R14,SRCHTIOT        TEST IF SYSPRINT IN TIOT
         BE        OPENUPDT            PROCEED IF IT IS
         TM        PARBYT,LIST         IS NOLIST ON .Q
         BO        OPENUPDT            NO, TERMINATE FOR NO SYSPRINT
OPENDPRT DS        0H
         TM        PARBYT2,TERM        IS TERM ON .Q
         BZ        OPENUPDT            NO, TERMINATE FOR NO SYSPRINT
         MVC       OPADPRT(5*4),OPADPRT+4 REMOVE SYSPRINT ENTRY
         LA        R1,L1DPTRTN(,R9)    ADDRESS OF DUMMY PRINT ROUTINE
         ST        R1,DCBGET(,R8)      FAKE IN SYSPRINT PUT ADDRESS
         MVI       DCBOFLGS(R8),X'10'  MARK IT OPEN LOCKED
         NI        PARBYT0,X'FF'                           TURN
         NI        PARBYT1,X'FF'-FUPLIST-ESD-FLIST-FXREF   OFF
         NI        PARBYT,X'FF'-LIST-RLD-UPLIST-XREF       ANYTHING
         NI        PARBYT2,X'FF'-LREF                      THAT
         NI        PARBYT3,X'FF'-UMAP                      PRINTS
         NI        PARBYT4,X'FF'                           ANYTHING
OPENUPDT DS        0H                  CHECK SYSLIB IN TIOT
         L         R8,L1DCBADS+L1SLIB(,R9)   SYSLIB DCB ADDRESS
         LA        R1,L1DDNAM+2*L1SLIB(,R9)  POINT AT SYSLIB DDNAME
         MVC   DIRDCB+DCBDDNAM(8),0(R1)
         BAL       R14,SRCHTIOT        TEST IF SYSLIB PRESENT
         BE        OPENSYUP            BRANCH IF IT IS
         MVC       OPADLIB(6*4),OPADLIB+4 REMOVE SYSLIB ENTRY
OPENSYUP DS        0H                  NOW CHECK SYSUP
         TM        PARBYT2,UPDATE      TEST UPDATE OPTION
         BO        *+10
         MVC       OPADUP(7*4),OPADUP+4 REMOVE UPDATE ENTRY
         TM        PARBYT2,TERM        TEST TERM OPTION
         BO        *+10
         MVC       OPADTER(8*4),OPADTER+4 REMOVE SYSTERM ENTRY
         TM        PARBYT,LOAD         TEST LOAD OPTION
         BO        *+10
         MVC       OPADLIN(9*4),OPADLIN+4 REMOVE SYSLIN ENTRY
*        LOAD UP BRANCH ADDRESS FOR DUMMY EXLST ROUTINE IN ASM
         LA        R8,EXLST  SET BRANCH ADDRESS FOR EXLST ROUT. IN ASM
*        DO THE OPEN
         OPEN (*-*,(OUTPUT,REREAD),    SYSLIN                          X
               *-*,(OUTPUT,REREAD),    SYSTERM                         X
               *-*,(INPUT,REREAD),     SYSUP                           X
               *-*,(INPUT,REREAD),     SYSLIB                          X
               *-*,(INPUT,REREAD),     SYSIN                           X
               *-*,(OUTPUT,REREAD),    SYSPRINT                        X
               *-*,(OUTPUT,REREAD),    SYSPUNCH                        X
               *-*,(OUTIN,REREAD),     SYSUT1                          X
               *-*,(OUTIN,REREAD),     SYSUT2                          X
               *-*,(OUTIN,REREAD))     SYSUT3
*        ADDRESSES OF THE ADDRESSES IN THE OPEN PARAMETER LIST
OPADLIN  EQU       *-2-10*4            SYSLIN
OPADTER  EQU       *-2-9*4             SYSTERM
OPADUP   EQU       *-2-8*4             SYSUP
OPADLIB  EQU       *-2-7*4             SYSLIB
OPADPRT  EQU       *-2-5*4             SYSPRINT
OPADPCH  EQU       *-2-4*4             SYSPUNCH
*        OPEN ROUTINE ALL DONE
         LA        R1,L1OUTRTN(,R9)    GET OUT ROUTINE ADDRESS
         ST        R1,IOSAVE           SAVE IT
         LA        R2,OPADLIN-4        POINT AT OPEN ADDR LIST
PTCHLOOP DS        0H
         LA        R2,4(,R2)           POINT TO NEXT DCB ADDRESS
         L         R5,0(,R2)           GET NEXT DCB ADDRESS
         TM        L1DCBPAD(R5),X'08'  IS IT PUT MONITORED .Q
         BZ        PTCHARND            BRANCH IF NOT
         MVC       L1DCBPAD+1(3,R5),DCBGET+1(R5) SAVE REAL ADDRESS
         MVC       DCBGET+1(3,R5),IOSAVE+1       PUT IN DUMMY ADDRESS
PTCHARND DS        0H
         LTR       R5,R5               TEST FOR LAST DCB IN LIST
         BP        PTCHLOOP            BRANCH IF NOT LAST
         L         R1,L1DCBADS+L1SIN(,R9)  POINT AT SYSIN DCB
         MVC       L1DCBPAD+1(3,R1),DCBGET+1(R1)  SAVE REAL GET ADDRESS
         MVC       L1SINAD+5(3,R9),DCBGET+1(R1)   SAVE FOR SYSINMON
         MVC       DCBGET+1(3,R1),L1SINAD+1(R9)   INSERT SYSINMON ADDR
         B         HEADING             GO AND PROCESS HEADING
*
*        EXLST FOR UTILITIES WHILE READING THE JFCB
UTEXLST  DC        0F'0',X'87',AL3(UTJFCB) EXLST USED BY RDJFCB
*
         SPACE     2
*
*        THIS SUBROUTINE ATTEMPTS TO FIND A DDNAME IN THE TIOT
*        ENTER WITH R1 POINTING AT THE DDNAME AND R8 AT THE DCB.
*        ON RETURN, THE CONDITION CODE REFLECTS THE SEARCH'S
*        SUCCESS AND R15 AS THE ENTRY POINTER.
*
SRCHTIOT DS        0H
         TM        PARBYT3,CMS         ARE WE UNDER CMS .Q
         BO        TIOTCMS             YES, THEN THERE IS NO TIOT
         L         R15,CVTPTR          CVT POINTER
         L         R15,0(,R15)         TCB ADDRESS PAIR
         L         R15,4(,R15)         MY TCB
         L         R15,12(,R15)        MY TIOT
         LA        R15,24(,R15)        1ST ENTRY IN TIOT
         SR        R0,R0               CLEAR R0
TIOTLOOP DS        0H
         IC        R0,0(,R15)          PICK UP TIOT ENTRY LENGTH
         LTR       R0,R0               TEST FOR LAST
         BE        TIOTFAIL
         CLC       4(8,R15),0(R1)      COMPARE DD NAMES
         BCR       8,R14               RETURN IF FOUND
         AR        R15,R0              POINT AT NEXT ENTRY
         B         TIOTLOOP
TIOTFAIL DS        0H
         CLI       *,0                 SET CC
         BR        R14                 RETURN
TIOTCMS  DS        0H
         MVC       IOSAVE+1(3),DCBEXLST(R8)  SAVE DCB EXIT LIST ADDR
         MVC       DCBEXLST(3,R8),=AL3(UTEXLST)  SET MY EXIT LIST
         RDJFCB    ((R8))              GET SOME INFORMATION
         MVC       DCBEXLST(3,R8),IOSAVE+1   RESTORE ORIGINAL DCB EXLST
         CLC       UTJFCB+1(175),UTJFCB  ANY DATA PRESENT .Q
         BZ        TIOTFAIL            IF NONE, NO FILEDEF PRESENT
         SR        R0,R0               INDICATE SUCCESS
         BR        R14                 AND RETURN
         EJECT
*        EXLST ROUTINE
*        THIS ROUTINE ENTERED FOR ALL DCB'S BEING OPENED
*
EXLST    DS        0H
         STM       R14,R2,IOSAVE       MOVE SOME REGISTERS TO STORAGE
*        TEST IF UTILITY, AND IF SO SET THE BLKSIZE FROM THE DD CARD
         CLI       DCBRECFM(R1),X'C0'  TEST FOR UTILITY (RECFM = U)
         BNE       *+14                SKIP IF NOT
         MVC       DCBBLKSI(2,R1),L1DCBBLK(R1)  PLACE BLKSIZE FROM JFCB
         B         EXLSTEND            AND GO TO RETURN
*        FOR OTHER DATASETS FIND ENTRY IN DCBTAB AND PICK UP LRECL
         BAL       R8,DCBTABFI         CALL SUB. TO FIND DCBTAB ENTRY
         LH        R7,DCBLRECL(,R1)    PICK UP LRECL FROM DCB
         LA        R8,133              FOR SYSPRINT AND SYSTERM
         CH        R8,0(,R3)           IS IT SYSPRINT OR SYSTERM .Q
         BNE       FETBLKSI            BRANCH IF NOT
         CR        R8,R7               WAS 133 SPECIFIED .Q
         BE        FETBLKSI            BRANCH IF YES
         SH        R8,H12              MAKE IT 121 THEN
         LR        R7,R8               SET IT IN REGISTER
         STH       R7,DCBLRECL(,R1)    SET IT IN DCB
         STH       R7,0(,R3)           AND SET IT IN TABLE
FETBLKSI DS        0H
*        TEST BLKSIZE
         LH        R5,DCBBLKSI(,R1)    FETCH BLOCKSIZE
         LTR       R5,R5               TEST IF USER SPECIFIED
         BZ        DEFBLKSI
         SR        R4,R4
         DR        R4,R7               TEST BLKSIZE MULTIPLE OF LRECL
         LTR       R4,R4
         LH        R5,DCBBLKSI(,R1)    RESTORE BLKSIZE
         BZ        BLKEDTST
         OI        5(R3),X'40'         SET BLKSIZE ERROR SWITCH
DEFBLKSI DS        0H
         LH        R5,0(,R3)           DEFAULT BLKSIZE
         STH       R5,DCBBLKSI(,R1)
*        TEST IF BLOCKED
BLKEDTST DS        0H
         CR        R5,R7               SEE IF BLKSIZE .GT. LRECL
         BE        BUFNOCK
         OI        DCBRECFM(R1),X'10'  TURN ON B BIT
*        CHECK BUFNO
BUFNOCK  DS        0H
         CLI       DCBBUFNO(R1),X'00'  SEE IF USER SPECIFIED BUFNO
         BNE       EXLINST             YES, HE DID
         MVC       DCBBUFNO(1,R1),2(R3) SET DEFAULT BUFNO
*
*        DETERMINE IF SYSIN AND SYSLIN CAN SHARE BUFFERS
EXLINST  DS        0H
         C         R1,ADCBIN           IS THIS SYSIN .Q
         BNE       EXLSTEND            NO
         TM        PARBYT1,BATCH       TEST IF BATCH .Q
         BO        EXLSTEND            NO IT'S NOT
         TM        PARBYT2,EXECUTE     TEST IF EXECUTE .Q
         BO        EXLSTEND            YES, CAN'T SHARE BUFFERS
         TM        PARBYT3,CMS         TEST IF CMS .Q
         BO        EXLSTEND            YES, DON'T SHARE BUFFERS
*
*        DETERMINE THE LARGEST BLKSIZE AND BUFNO.  COMPUTE
*        THE SIZE OF A COMBINED BUFFER POOL VS TWO SIMPLE POOLS.
         SR        R4,R4               PREPARE REGISTER
         IC        R4,DCBBUFNO(,R1)    AND INSERT SYSIN BUFNO
         LR        R7,R4               TRANSFER IT
         MH        R7,DCBBLKSI(,R1)    APPROX SYSIN POOL SIZE
         L         R10,L1DCBADS+L1SLIN(,R9)  SYSLIN DCB ADDRESS
         SR        R6,R6               PREPARE REGISTER
         IC        R6,DCBBUFNO(,R10)   AND INSERT SYSLIN BUFNO
         CR        R4,R6               PICK LARGEST BUFNO
         BNL       *+6                 SYSIN WAS LARGER
         LR        R4,R6               SYSLIN WAS LARGER
         MH        R6,DCBBLKSI(,R10)   APPROX SYSLIN POOL SIZE
         AR        R7,R6               TOTAL FOR TWO SIMPLE POOLS
         LH        R6,DCBBLKSI(,R10)   SYSLIN BLKSIZE
         CR        R5,R6               PICK LARGEST BLKSIZE
         BNL       *+6                 SYSIN WAS LARGER
         LR        R5,R6               SYSLIN WAS LARGER
         LA        R5,4(,R5)           ADD 4 TO BLKSIZE FOR DUMMY PTRS
         LR        R9,R5               LOAD LARGEST BLKSIZE
         MR        R8,R4               COMPUTE COMBINED POOL SIZE
         CR        R9,R7               TEST IF COMBINED POOL SMALLEST
         BH        EXLSTEND            BR IF TWO SIMPLE POOLS SMALLER
*
*        GET A BUFFER POOL AND SET ITS ADDRESS IN DCBS
         LA        R0,8(,R9)           ADD 8 FOR BUFCB
         LR        R9,R1               SAVE SYSIN DCB ADDRESS
         GETMAIN   R,LV=(0)            GET THE CORE
         ST        R1,IOSAVE+4         BUFCB ADDR
         MVC       DCBBUFCB(3,R9),IOSAVE+5  IN SYSIN DCB
         MVC       DCBBUFCB(3,R10),IOSAVE+5 IN SYSLIN DCB
*
*        BUILD THE BUFFER CONTROL BLOCK AND BUFFER CHAINS
         LR        R7,R1               LOCATION TO PLACE 1ST BUFFER PTR
         LA        R6,12(,R1)          1ST DUMMY BUFFER LOCATION
         STH       R4,4(,R1)           NUMBER OF BUFFERS
         STH       R5,6(,R1)           BUFFER LENGTH
BUFAGAIN DS        0H
         LR        R8,R4               NUMBER OF BUFFERS IS LOOP INDEX
BUFCHAIN DS        0H
         ST        R6,0(,R7)           STORE BUFFER CHAIN ENTRY
         LR        R7,R6               CHAIN TO THE NEXT BUFFER
         AR        R6,R5               BUMP TO NEXT BUFFER
         BCT       R8,BUFCHAIN         LOOP FOR EACH BUFFER
         BC        *-*,BUFDONE         ONE TIME SWITCH
         MVI       *-3,X'F0'           TURN ON THE BRANCH
         LA        R6,8(,R1)           1ST REAL BUFFER POINTER
         B         BUFAGAIN            GO AND CHAIN THE REAL BUFFERS
BUFDONE  DS        0H
         SR        R0,R0               PREPARE REGISTER
         ST        R0,0(,R7)           AND ZERO END OF CHAIN
*
*        NOW WE RETURN TO OPEN TO LET IT USE OUR BUFFER POOL.
*        OPEN DOES NOT REALIZE THAT IT CONTAINS TWICE AS MANY
*        AS IT SHOULD.
*        THEREFORE, OPEN WILL PLACE BOTH THE SYSIN AND SYSLIN
*        BUFFERS IN THE SAME PLACE
EXLSTEND DS        0H
         LM        R14,R2,IOSAVE       RESTORE R14 ETC.
         BR        R14                 RETURN TO OPEN
         SPACE     4
*
*        THIS ROUTINE FINDS AN ENTRY IN DCBTAB
*
*        INPUT     R1  DCB ADDRESS
*                  R8  RETURN
*        OUTPUT    R3  ADDR OF ENTRY IN DCBTAB
*
DCBTABFI DS        0H
         SR        R3,R3               INIT INDEX REG
         LA        R1,0(,R1)           CLEAR TOP BYTE
         C         R1,L1DCBADS(R3,R9)  TEST IF INDEX POINTS AT DCB ADDR
         BE        *+12                  AT START OF LIST1 IN ASM
         LA        R3,4(,R3)           INCREMENT INDEX FOR NEXT DCB
         B         *-12                LOOP
         AR        R3,R3               CHANGE INDEX FROM 4* TO 8*
         LA        R3,DCBTAB(R3)       POINT AT PROPER ENTRY IN DCBTAB
         BR        R8                  RETURN
         EJECT
*        PRINT THE HEADING PAGE
*
HEADING  DS        0H
         BAL       R14,ZMONTH          GET TIME, DAY AND DATE NOW
         MVC       LINE,L1BLANKS(R9)   BLANK PRINT BUFFER
*        TEST IF SYSPRINT OPEN
         L         R5,L1DCBADS+L1STERM(,R9)  SYSTERM DCB ADDRESS
         TM        DCBOFLGS(R5),X'10'  IS SYSTERM OPEN .Q
         BO        HEADTERM            YES, PRIME SYSTERM BUFFER
         L         R1,L1DCBADS+L1SPRINT(,R9)  SYSPRINT DCB ADDRESS
         TM        DCBOFLGS(R1),X'10'  IS SYSPRINT OPEN .Q
         BO        HEADPRNT            YES, CONTINUE
         MVI       DCBTABTM+5,X'80'    MAKE SYSTERM READY FOR ABEND
         B         NOTOPEN             SYSTERM HAS FAILED
*
HEADTERM DS        0H
         TM        PARBYT3,CMS         DID USER SPECIFY CMS .Q
         BO        POSTTERM            DON'T PRIME SYSTERM IF SO
         LA        R1,L1DDNAM+2*L1STERM(,R9)  POINT TO SYSTERM DCBNAME
         BAL       R14,SRCHTIOT        FIND TIOT ENTRY FOR SYSTERM
         TM        3(R15),TIOTTERM     IS SYSTERM A TSO TERMINAL .Q
         BO        POSTTERM            DON'T PRIME IT IF SO
TIOTTERM EQU       X'20'               TSO - DEVICE IS A TERMINAL
PRETERM  DS        0H                  OTHERWISE PRIME BUFFERS FOR HASP
         OI        L1DCBCC(R5),X'C0'   SET FOR ASA CARRIAGE CONTROL
         MVI       LINE,C'1'           NEW PAGE
         PUT       (R5),LINE           PRINT THE LINE
POSTTERM DS        0H
         NI        L1DCBCC(R5),X'7F'   TURN OFF ASA
         OI        L1DCBCC(R5),X'40'   TURN ON NUMERIC
         L         R1,LCTBYT           GET ACTUAL LINE COUNT
         ST        R1,L1TRSAVE(,R9)    INITIALIZE SYSTERM LINE COUNT
*
HEADPRNT DS        0H
         L         R5,L1DCBADS+L1SPRINT(,R9)  SYSPRINT DCB ADDRESS
         TM        DCBOFLGS(R5),X'10'  TEST IF OPEN OR MARKED
         BZ        NOTOPEN             SYSPRINT HAS FAILED
*        PRINT FIRST HEADING LINE
         OI        L1DCBCC(R5),X'C0'   SET FOR ASA CARR CONTROL
         MVI       LINE,C'1'           NEW PAGE
         PUT       (R5),LINE           PUT OUT THE LINE
         NI        L1DCBCC(R5),X'7F'   TURN OFF ASA
         OI        L1DCBCC(R5),X'40'   TURN ON NUMERIC
         MVI       LINE,X'02'          LEAVE SOME SPACES
         MVC       LINE+52(16),HEADER  MOVE IN HEADER
         BAL       R14,SYSL1           PRINT FIRST LINE
*        PRINT SECOND HEADING LINE
         MVC       L1PRDATE(9,R9),ZDATE    STORE DATE IN LIST1 IN ASM
         MVC       L1PRTIME(8,R9),ZTIME    STORE TIME IN LIST1 IN ASM
         MVC       L1ASDATE+1(2,R9),ZDATE+7   PLACE YEAR IN ASMGASM
         MVC       L1ASDATE+3(3,R9),ZDATE+3   PLACE MONTH IN ASMGASM
         MVC       L1ASDATE+6(2,R9),ZDATE     PLACE DAY IN ASMGASM
         MVC       L1ASTIME(8,R9),ZTIME    TIME AGAIN ALSO
         TR        L1ASDATE(16,R9),TRSLTB  TRANSLATE TWO TO INTERNAL
         MVI       L1ASDATE(R9),X'07'      ASSUME DATE LENGTH IS 7
         CLI       ZDATE,C' '              IS IT LESS .Q
         BNE       *+14                    NO, BRANCH AROUND
         MVI       L1ASDATE(R9),X'06'      YES, MAKE LENGTH 6
         MVC       L1ASDATE+6(1,R9),L1ASDATE+7(R9)  SHIFT DAY OVER
         MVC       LINE+1(7),LEVEL         PLACE EVERYTHING IN LINE
         MVC       LINE+14(8),RELEASE
         MVC       LINE+22(7),L1RLSDTE(R9) GET ASSEMBLER RELEASE DATE
         MVC       LINE+35(L'SYSTEM),SYSTEM
         MVC       LINE+56(L'MODEL),MODEL  SET MODEL IDENTIFICATION
         MVC       LINE+70(5),TIME     SET TIME KEYWORD
         MVC       LINE+75(8),ZTIME    SET TIME OF DAY
         MVC       LINE+89(4),DAY      SET DAY KEYWORD
         MVC       LINE+93(9),ZDAY     SET DAY OF WEEK
         MVC       LINE+107(5),DATE    SET DATE KEYWORD
         MVC       LINE+112(9),ZDATE   SET TODAY'S DATE
         BAL       R14,SYSL1           PRINT SECOND LINE
*
*        PRINT OVERRIDING PARAMETER OPTIONS
*
         L         R6,L1CTLPRM(,R9)    GET PARM LIST ADDRESS
         L         R6,0(,R6)           POINT AT THE PARM
         LH        R2,0(,R6)           PICK UP PARM LENGTH
         LTR       R2,R2               TEST FOR NO PARM AT ALL
         BZ        ASSEMHD             BRANCH IF NONE
         MVC       LINE+1(L'OVERRIDE),OVERRIDE  PLACE HEADING
         LA        R1,100              ONLY PRINT FIRST 100 CHARS
         CR        R1,R2               COMPARE TO ACTUAL LENGTH
         BNL       OVERPRT             BRANCH IF LENGTH OK NOW
         LR        R2,R1               REPLACE ACTUAL LENGTH WITH 100
         MVC       LINE+L'OVERRIDE+101(3),=C'...' INDICATE SUSPENSION
OVERPRT  DS        0H
         BCTR      R2,0                DECREMENT LENGTH BY ONE
         EX        R2,MOVEPARM         MOVE PARM TO PRINT LINE
         BAL       R14,SYSL1           PRINT PARM LINE
         TM        ERRSW1,ERRBDPM      IS THERE A PARM ERROR .Q
         BZ        ASSEMHD             BRANCH IF NOT
         MVI       LINE,X'00'          SINGLE SPACE
         L         R2,L1CTLPRM(,R9)    GET PARM LIST ADDRESS
         L         R2,0(,R2)           POINT TO PARM
         LA        R2,2(,R2)           BUMP PAST LENGTH
         S         R2,PARMOFF          THE ERROR WAS HERE '*'
         LPR       R2,R2               MAKE IT POSITIVE
         LA        R1,100              LAST POSSIBLE PARM PRINTED
         CR        R1,R2               IS LAST LESS THAN ERROR OFFSET
         BL        ERRORIND            BRANCH IF YES
         LR        R1,R2               GET ERROR OFFSET
ERRORIND DS        0H
         LA        R0,C'*'             INSERT AN ASTERISK
         STC       R0,LINE+L'OVERRIDE+1(R1)  MARK START OF ERROR
         BAL       R14,SYSL1           NOTE LOCATION OF ERROR
*
*        PRINT ASSEMBLER OPTIONS
*
ASSEMHD  DS        0H
         MVC       LINE+1(18),OPTIONS  PLACE HEADING
         LA        R5,LINE+18          LINE POSITION-1
         LA        R7,OPTEST-OPTPEND   POINTER TO OPTION TABLE
OPTSEAR  DS        0H
         LA        R7,OPTPEND(,R7)     POINT AT NEXT NAME IN LIST
         CLI       OPTPSTR(R7),X'FF'   TEST FOR LAST ONE
         BE        OPTDONE             BRANCH IF AT THE END
         TM        OPTPFLGS(R7),X'80'  TEST FOR ABBREVIATION
         BO        OPTSEAR             FORGET IT IF YES
         IC        R15,OPTPFLGS(,R7)   PICK UP CONTROL BYTE
         N         R15,F15             KILL TOP HALF BYTE
         MVC       OPTWORK(6),PARBYT0  MOVE PARAM SWITCHES
         AR        R15,R15             DOUBLE INDEX VALUE
         LH        R15,OPTBTBL(R15)    GET ROUTINE OFFSET
         B         ASMGF1(R15)         DO WHAT CONTROL BYTE SAYS
OPTBTBL  DC        AL2(OPTN1N2-ASMGF1)   CONTROL BYTE =X'0'
         DC        AL2(OPTF1F2-ASMGF1)   CONTROL BYTE =X'1'
         DC        AL2(OPTF1N2-ASMGF1)   CONTROL BYTE =X'2'
         DC        AL2(OPTDIGIT-ASMGF1)  CONTROL BYTE =X'3'
         DC        AL2(OPTCPARM-ASMGF1)  CONTROL BYTE =X'4'
*        DO OPPOSITE OF WHAT PARM SCAN DOES
OPTN1N2  DS        0H
         NC        OPTWORK(6),OPTPBITS(R7)  KILL OTHER SWITCHES
         B         OPT2                TEST RESULTS
OPTF1F2  DS        0H
         OC        OPTWORK(6),OPTPBITS(R7)  FORCE SWITCHES
         B         OPT2                TEST RESULTS
OPTF1N2  DS        0H
         OC        OPTWORK(2),OPTPBITS(R7)  FORCE SOME SWITCHES
         NC        OPTWORK+2(4),OPTPBITS+2(R7)  KILL OTHERS
         B         OPT2                TEST RESULTS
OPTDIGIT DS        0H
         SR        R15,R15             ZERO OFFSET REGISTER
         IC        R15,OPTPBITS(,R7)   1ST HALF OFFSET INTO TAB3PARM
         SLL       R15,8               MOVE ONE BYTE OVER
         IC        R15,OPTPBITS+1(,R7) 2ND HALF OFFSET INTO TAB3PARM
         L         R2,TAB3PARM+TAB3DEF(R15)  PICK UP NUMBER
         LTR       R2,R2               IS IT NEGATIVE .Q
         BM        OPTSEAR             NEG MEANS OPTION NOT IN EFFECT
         LA        R15,1               SET NUMBER SWITCH
         B         OPTCHECK            SINCE R15 IS 1 NUMBER WILL BE   X
                                         COLLECTED AFTER NAME
OPTCPARM DS        0H
         SR        R15,R15             ZERO WORK REGISTER
         IC        R15,L1ASPARM(,R9)   PICK UP LENGTH OF SYSPARM
         LTR       R15,R15             IS IT NULL .Q
         BZ        OPTCHECK            YES, THEN NOTHING SPECIAL
         L         R3,L1ASPARM(,R9)    PICK UP ADDRESS OF SYSPARM
         LA        R2,9(R15,R5)        WILL SYSPARM FIT
         C         R2,ENDLINE            ON THIS LINE .Q
         BL        OPTPARMO            YES, PRESS ON
OPTLOOP  DS        0H
         BAL       R14,SYSL1           NO, PRINT CURRENT LINE
         MVI       LINE,X'00'          NO SKIP ON SUCCESSIVE LINE
         LA        R5,LINE+18          SET LINE POINTER
         CH        R15,H80             WILL REMAINDER NOW FIT .Q
         BL        OPTPARMO            YES, PROCEED
         LA        R2,80               NO, PRINT ONLY NEXT 80 THEN
         BAL       R14,OPTPARMP        GO DO IT
         SH        R15,H80             DECREASE LENGTH LEFT BY 80
         AH        R3,H80              INCREMENT POINTER BY 80
         B         OPTLOOP             DO IT AGAIN
OPTPARMO DS        0H
         LR        R2,R15              TRANSFER LENGTH TO MOVE
         LA        R14,OPT3            GO THERE WHEN DONE
OPTPARMP DS        0H
         MVC       1(8,R5),OPTPSTR(R7) MOVE IN SYSPARM=
         MVC       OPTPSTR(8,R7),LINE+1  AND BLANK IT FOR NEXT TIME
         BCTR      R2,0                DECREASE LENGTH FOR A MOVE
         EX        R2,OPTSPRM          MOVE PARM INTO LINE
         LA        R5,9(R15,R5)        INCREMENT LINE POINTER
         BR        R14                 RESUME
OPT2     DS        0H
         CLC       OPTWORK(6),OPTPBITS(R7)  TEST IF SWITCH IN EFFECT
         BNE       OPTSEAR
OPTCHECK DS        0H
         C         R5,ENDLINE          SEE IF LINE FULL
         BL        OPTNAM
         BAL       R14,SYSL1           PRINT THE LINE
         MVI       LINE,X'00'          NO SKIPS ON SUCCESSIVE LINES
         LA        R5,LINE+18          SET LINE POINTER
*        PLACE NAME ON LINE
OPTNAM   DS        0H
         IC        R4,OPTPLEN(,R7)     GET ACTUAL LENGTH-1
         N         R4,F15              AND PURIFY IT
         EX        R4,OPTMVC           MOVE NAME
         LA        R5,2(R4,R5)         INCREMENT LINE PT
         BCT       R15,OPT3  TEST NO NUMBER SWITCH
*        PLACE NUMBER ON LINE
         LTR       R14,R2              TEST FOR MULTIPLE OF 1024
         BZ        OPT9                ZERO IS 0 , NOT 0K
         N         R14,=X'FFFFFC00'
         CR        R2,R14
         BNE       OPT9
         LA        R15,1               CHANGE R15 FROM 0 TO 1
         SRL       R2,10               DIVIDE BY 1024
OPT9     DS        0H
         CVD       R2,DWORD            CONVERT TO PACKED DECIMAL
         MVC       OPTWORK(7),OPTEDIT  PREPARE TO FIND LENGTH & UNPACK
         LA        R1,OPTWORK+6        IN CASE NUM 0
         LA        R2,0(R1,R15)        PREPARE TO CALCULATE LENGTH
         EDMK      OPTWORK(7),DWORD+4  CHANGE TO CHARACTER
         SR        R2,R1               CALCULATE LENGTH-1
         EX        R2,OPTMNUM          PLACE NUM ON LINE
         LA        R5,1(R2,R5)         INCREMENT LINE PT
OPT3     DS        0H
         MVI       0(R5),C','          PLACE A COMMA
         TM        OPTPFLGS(R7),X'40'  SUFFIX FOR XREF .Q
         BZ        OPTSEAR             BRANCH IF NOT
         CLI       XREFSUFX,X'00'      ANY SUFFIX PRESENT .Q
         BE        OPTSEAR             BRANCH IF NOT
         L         R15,XREFSUFX        POINT ONE BEFORE SUFFIX
         SR        R2,R2               ZERO A WORK REG
         IC        R2,XREFSUFX         GET LENGTH OF SUFFIX
         BCTR      R2,0                GET LENGTH-1 OF SUFFIX
         MVI       0(R5),C'='          A DELIMITER
         EX        R2,OPTMVCSF         MOVE THE SUFFIX
         LA        R5,2(R2,R5)         NEXT OUTPUT COLUMN
         MVI       0(R5),C','          ADD A COMMA
         B         OPTSEAR             DO IT AGAIN
OPTMVCSF MVC       1(*-*,R5),1(R15)    EXECUTED MOVE
OPTDONE  DS        0H
         MVI       0(R5),C'.'          CLOBBER ',' WITH '.'
         LA        R14,PARMCHK         RETURN HERE AFTER PRINTING LINE
         B         SYSL1               PRINT LAST OPTION LINE
*
OPTSPRM  MVC       9(*-*,R5),0(R3)     EXECUTED MOVE PARM INTO LINE
OPTMVC   MVC       1(*-*,R5),OPTPSTR(R7)  EXECUTED MOVE NAME
OPTMNUM  MVC       0(*-*,R5),0(R1)     EXECUTED PLACE NUM ON LINE
         EJECT
*        CHECK IF THERE WAS A PARM ERROR
*
PARMCHK  DS        0H
         TM        ERRSW1,ERRBDPM      ANY PARM ERRORS .Q
         BZ        SETUPDAT            BRANCH IF NONE
         LA        R14,SETUPDAT        SET RETURN ADDRESS
         BAL       R0,ERROUT           BAL TO PRINT ERROR MESSAGE
         DC        C'255 ',AL1(L'MES255-1)
MES255   DC        C'ERROR IN PARM FIELD'
*
SETUPDAT DS        0H
         SR        R1,R1               ZERO A REGISTER
         ST        R1,L1PAGENO(,R9)    ZERO PAGE NUMBER FOR SYSPRINT
         MVC       L1UTLINO(4,R9),F1   SET UPDATE LINE COUNT
         LTR       R10,R10             ONLY CHECK OPENS 1ST F1 TIME
         BNE       GETHASH
*
*        SCAN THE DCB'S TO SEE IF THEY OPENED OK
*
         LA        R2,OPADLIN-4        POINT AT OPEN ADDRESS LIST
OPENCHK1 DS        0H
         LA        R2,4(,R2)           POINT AT NEXT DCB ADDRESS
         L         R5,0(,R2)           DCB ADDRESS
         TM        DCBOFLGS(R5),X'10'  TEST IF OPEN
         BO        OPENOK
NOTOPEN  DS        0H
         MVC       MES200+15(8),DCBDDNAM(R5) PLACE DDNAME IN ERROR
         LA        R0,MSG200           POINT AT ERROR MESSAGE
         CLI       DCBRECFM(R5),X'C0' TEST IF UTILITY (RECFM=U)
         BE        ASMABEND            ABEND ASSEMBLER IF SO
         LR        R1,R5               FIND DATASET'S ENTRY IN DCBTAB
         BAL       R8,DCBTABFI           BY CALLING THE LOOKUP ROUTINE
         TM        5(R3),X'80'         TEST THE ABEND SW
         BO        ASMABEND            ABEND THE ASSEMBLER IF SO
         BAL       R14,ERROUT          PRINT ERROR MESSAGE
         NC        PARBYT(2),3(R3)     TURN OFF OPTIONS MAYBE
         OC        L1SYNERR(1,R9),6(R3)  OR IN SEVERITY CODE FOR ASMGFD
*
OPENOK   DS        0H
         LTR       R5,R5               TEST FOR LAST DCB
         BNM       OPENCHK1            TRY NEXT DCB
         B         BLKCHK
*
MSG200   DC        C'200 ',AL1(L'MES200-1)
MES200   DC        C'UNABLE TO OPEN ********'
         EJECT
*        TEST FOR BLKSIZE ERRORS DURING OPEN
*
BLKCHK   DS        0H
         LM        R4,R6,=A(8,6*8,0)   INITIALIZE FOR SCAN
*        SCAN DCBTAB TO CHECK ALL DCB'S EXCEPT UTILITIES
BLKCHK1  DS        0H
         LA        R3,DCBTAB(R6)       POINT AT ENTRY IN DCBTAB
         TM        5(R3),X'40'         TEST FOR ERROR
         BZ        BLKOK
         LA        R1,L1DDNAM(R6,R9)   POINT AT DDNAME LIST IN LIST1
         BAL       R14,ERR201          PRINT ERROR
BLKOK    DS        0H
         BXLE      R6,R4,BLKCHK1       LOOP FOR ALL DD CARDS
         B         UPTEST
*
ERR201   DS        0H
         MVC       MES201+19(8),0(R1)  PLACE DD NAME IN MESSAGE
         OI        L1SYNERR(R9),X'02'  SET ERROR SWITCH FOR ASMGFD
         BAL       R0,ERROUT           PRINT IT
MSG201   DC        C'201 ',AL1(L'MES201-1)
MES201   DC        C'ILLEGAL BLKSIZE ON ********'
         EJECT
*        TEST UPDATE OPTION AND LOAD AND PATCH IN ASMGUP ROUTINE IF SO
*        MOVE PARBYTS TO ASM IN CASE OF UPDATE
*
UPTEST   DS        0H
         MVC       L1TIMELM(4,R9),EXTMWD   MOVE IN EXTIME
         MVC       L1COLCT(1,R9),COLCOUNT+3  MOVE COLUMN COUNT
         MVC       L1UPCOND(1,R9),UPCOND+3  MOVE UPDATE CONDITION CODE
         MVC       L1CALIGN(1,R9),CALIGN+3  MOVE COMMENT ALIGNMENT COL
         MVC       L1LINECT(2,R9),LCTBYT+2  MOVE LINECNT VALUE
         MVC       L1PBYT1(4,R9),PARBYT1    MOVE PARAMETER BITS
         TM        PARBYT1,EXTEN       IS EXTEN ON .Q
         BO        DEFLSETC            YES, TAKE LSETC SPECIFIED
         MVI       LSETCBYT+3,X'08'    NO, MAKE DEFAULT 8
DEFLSETC DS        0H
         MVC       L1LSETC(1,R9),LSETCBYT+3 MOVE DEFAULT LSETC
         TM        PARBYT2,UPDATE      TEST UPDATE OPTION
         BZ        SYSINIT             BRANCH IF OFF
         LOAD      EP=ASMGUP           LOAD THE UPDATE MODULE
         ST        R0,L1SINAD+4(,R9)   ADDR OF ASMGUP FOR ASMGASM
         LA        R8,EXLST            EXLST ROUTINE ADDR FOR ASMGASM
         SPACE     3
*        INITIALIZE THE SYSIN DCB
*
SYSINIT  DS        0H
*        DO AN INITIALIZATION GET TO PRIME SYSINMON'S BUFFER
         L         R1,ADCBIN           POINT TO SYSIN DCB
         GET       (1),LINE+20         USE AREA FOR SUBSEQUENT PRINTING
         EJECT
*        LOAD THE INSTRUCTION SET MODULE
*
         L         R0,ISBIN            CHANGE INSTSET NUMBER TO CHAR
         CVD       R0,DWORD            CHANGE TO PACKED DECIMAL
         UNPK      L1ISNAME+6(2,R9),DWORD+6(2) PUT ZONED IN LIST1 AREA
         OI        L1ISNAME+7(R9),X'F0'      MAKE SIGN PLUS
         LOAD      EPLOC=L1ISNAME(,R9) LOAD THE INSTSET MODULE
         ST        R0,L1ISADDR(,R9)    SAVE ADDRESS IN CASE BATCH
*        MOVE THE HASH TABLE INTO COMMON
GETHASH  DS        0H
         L         R1,L1ISADDR(,R9)    POINT AT INSTSET MODULE
         MVC       PHASHT(2*PASHL),4(R1) MOVE HASH TABLE
         L         R2,0(,R1)           LENGTH OF INIT GBL DICT
         ST        R2,PNDX
         ST        R2,ENDOPC
*        IF NON-BATCH WRITE INITIAL GLOBAL DICT ON A UTILITY
         LTR       R10,R10             TEST FOR 1ST F1 TIME
         BNZ       BUFTOTAL
         TM        PARBYT1,BATCH       TEST IF BATCH
         BO        GETMAIN
*        WRITE IT OUT ON SYSUT1
         LA        R5,2000             BLOCK LENGTH
         LA        R4,2*PASHL+4(,R1)   STARTING ADDRESS
         L         R3,L1DCBADS+L1SUT1(,R9)  SYSUT1 DCB ADDRESS
ISWRITE  DS        0H
         CR        R2,R5               TEST IF SHORT BLOCK
         BNM       WRITEIS
         LR        R5,R2
WRITEIS  DS        0H
         WRITE     DECB1,SF,(R3),(R4),(R5)
         CHECK     DECB1
         AR        R4,R5               ADDRESS OF NEXT BLOCK
         SR        R2,R5               REMAINING LENGTH
         BH        ISWRITE
*        REWIND THE UTILITY
         POINT     (R3),F1
*        DELETE THE MODULE
         DELETE    EPLOC=L1ISNAME(,R9) IT'S IN LIST1 IN ASMGASM
         SPACE     4
*        GET STORAGE AS SPECIFIED BY SPACE PARAMETER
*
GETMAIN  DS        0H
         L         R3,SPACEPOS         LOAD SPACEPOS
         LTR       R3,R3               TEST FOR SPACE=N OPTION
         BM        GETVAR              BRANCH IF NOT
*        DO ELEMENT CONDITIONAL GETMAIN FOR SPACE=N
         GETMAIN   EC,LV=(R3),A=GOTADDR
         BXH       R15,R15,ERROR998    TEST RETURN CODE
         ST        R3,GOTLEN           SAVE LENGTH GOTTEN
         B         SWSET
*
*        DO VARIABLE CONDITIONAL GETMAIN FOR SPACE=MAX OR SPACE=MAX-N
GETVAR   DS        0H
         GETMAIN   VC,LA=MINMAIN,A=GOTADDR
         BXH       R15,R15,ERROR998    TEST RETURN CODE
         L         R4,SPACENEG         GET MAX- VALUE
         LTR       R0,R4               TEST SPACE=MAX-N
         BM        SWSET               BRANCH IF NOT
*        DO FREEMAIN FOR SPACE=MAX-N
         LM        R1,R2,GOTADDR       LOAD ADDRESS AND LEN GOTTEN
         SR        R2,R4               LENGTH KEPT
         C         R2,MINMAIN          TEST SUFFICIENT STORAGE
         BL        ERROR998
         AR        R1,R4               ADDR OF KEPT CORE
         STM       R1,R2,GOTADDR       CHANGE ADDR AND LEN KEPT
         SR        R1,R4               ADDR TO FREE
         FREEMAIN  R,LV=(0),A=(1)
         AIF       (&NOTSTAT).NOCORE
*        PRINT AMOUNT OF CORE GOTTEN
         L         R0,GOTLEN           AMT
         SRL       R0,10               /1024
         CVD       R0,DWORD            DECIMAL
         ED        COREEDIT(4),DWORD+6 CHARS
         B         PRNTCORE            PRINT IT
CORELINE DC        CL50' '             BLANKS
         ORG       CORELINE
         DC        C'GETMAINED CORE='
COREEDIT DC        C' ',X'202120',C'K'
         ORG
PRNTCORE PRINTOUT  CORELINE,DCB=NO,CSECT=GAECT,TYPE=STAT
.NOCORE  ANOP
         B         SWSET
*
*        INSUFFICIENT SPACE ERROR
ERROR998 DS        0H
         BAL       R0,ASMABEND
         DC        C'998I',AL1(L'MES998-1)
MES998   DC        C'INSUFFICIENT MEMORY TO SATISFY SPACE REQUIREMENT'
*
*        ONCE ONE MEGABYTE WAS ENOUGH, I STILL DON'T BELIEVE IT
MINMAIN  DC        A(MINIMUM,8000*1024)
GOTADDR  DC        F'0'
GOTLEN   DC        F'0'
GOTEXTRA DC        2F'0'               NEEDED FOR IDIOT MVT
MIN1     EQU       3*4*100+24          MIN BUFF WILL INITIALIZE ON
MIN2     EQU       &MAXMAC*11+512      AMT MIKE NEEDS FOR MACRO DIRCTRY
MINIMUM  EQU       MIN1+MIN2           MIN GETCORE WE CAN TOLERATE
         SPACE     2
*        SET GOTMAINED ADDR AND LENGTH IN ASMGASM
SWSET    DS        0H
         MVC       L1FREEMN(8,R9),GOTADDR  FOR FREEMAIN IN ASMGASM
         EJECT
*        THIS SECTION HAS BEEN ADDED TO BUILD A CORE RESIDENT                  
*        NOTE LIST OF THE SYSLIB DIRECTORY IF ENOUGH CORE                      
*        IS AVAILABLE. IF THERE IS NOT ENOUGH CORE, WE                         
*        TERMINATE WITH A RETURN CODE OF 20 AFTER PRINTING                     
*        AN ERROR MESSAGE.                                                     
*                                                                              
*                                                                              
*                 R0                   WORK                                    
*                 R1                   WORK                                    
*                 R2                   POINTS TO SYSLIB DCB                    
*                 R3                   SUBROUTINE RETURN LINK                  
*                 R4                   WORK                                    
*                 R5                   POINTS TO NEXT INPUT BUFFER             
*                 R6                   POINTS TO CURRENT INPUT BUFFER          
*                 R7                   LENGTH OF USER DATA                     
*                 R8                   END ADDRESS IN BLOCK                    
*                 R9                   TABLE POINTER                           
*                 R10                  WORK REGISTER                           
*                 R11                  BASE REGISTER 1                         
*                 R12                  BASE REGISTER 2                         
*                 R13                  COMMON AND SAVE AREA POINTER            
*                 R14                  LINKAGE                                 
*                 R15                  REGISTERS                               
*                                                                              
*        ALTER DCB FOR READING DIRECTORIES                                     
*                                                                              
         OPEN  (DIRDCB,INPUT)                                                  
         LA    R2,DIRDCB           POINT TO DIRECTORY DCB                      
         EJECT                                                                 
*                                                                              
*        SET UP CORE POINTERS                                                  
*                                                                              
         L         R9,GOTADDR          ADDRESS OF CORE AREA                    
         LR        R4,R9               POINT TO END OF AREA                    
         A         R9,GOTLEN           ACQUIRED FROM OS                        
         ST        R9,MACLAST                                                  
         LR        R5,R9               TOP OF CORE                             
         S         R5,=A(&MAXMAC*12)   12 BYTES PER MACRO                      
         ST        R5,MACTABLS         =START OF TABLE                         
*                                                                              
*        CHECK IF SYSLIB IS OPEN                                               
         TM        DCBOFLGS(R2),X'10'  IS IT OPEN .Q                           
         BZ        MACROSIN            NO, QUIT.                               
         TM        PARBYT3,CMS         DID USER SPECIFY CMS .Q                 
         BO        MACROSIN            DON'T READ DIRECTORY IF SO              
         SPACE     2                                                           
*                                                                              
MACFIRST DS        0H                                                          
         GET       DIRDCB              READ A DIRECTORY BLOCK                  
         EJECT                                                                 
*                                                                              
*        LOGIC TO DO DOUBLE BUFFERED READING OF                                
*        SYSLIB DIRECTORY FROM DISK                                            
*                                                                              
SKIPPER  DS        0H                                                          
         NOP       MACFIRST            FOR SKIPPING EMPTY BLOCKS               
*                                                                              
*        PICK OFF THE NAME AND TTR FOR EACH MACRO                              
*                                                                              
         LH        R8,0(,R1)           LOAD LENGTH USED IN THIS BLOCK          
         BCTR      R8,0                DECREMENT                               
         LA        R8,0(R8,R1)         GET END ADDRESS OF THIS BLOCK           
         LA        R6,2(,R1)           POINT TO FIRST RECORD                   
DEBLOCK1 DS        0H                                                          
         CR        R6,R8               CHECK FOR END OF BLOCK                  
         BNL       MACFIRST            YES GET A NEW BLOCK                     
         CLI       0(R6),X'FF'         IS THIS LAST ENTRY .Q                   
         BE        NEWPDS              YES GET NEXT DIRECTORY                  
         SH        R9,=H'12'                                                   
         MVC       0(11,R9),0(R6)      STORE NAME & TTR                        
         MVC       11(1,R9),EXT#       AND CONCAT #                            
         C         R9,MACTABLS         END OF TABLE                            
         BL        MACABEND            YES QUIT                                
         IC        R4,11(,R6)          LOAD CONTROL BYTE                       
         N         R4,F31              MASK OFF GARBAGE                        
         AR        R4,R4               GET LENGTH IN BYTES                     
         LA        R6,12(R6,R4)        INCREMENT RECORD POINTER                
         B         DEBLOCK1            AND AROUND AGAIN.                       
         EJECT                                                                 
*                                                                              
*        INCREMENT EXTENT COUNT AND RESET SKIPPER FOR THE                      
*        NEXT DIRECTORY.                                                       
*                                                                              
NEWPDS   DS        0H                                                          
         OI    SKIPPER+1,X'F0'                                                 
         B     MACFIRST                                                        
         EJECT                                                                 
*                                                                              
*        MACRO DIRECTORY IS NOW IN CORE                                        
*                                                                              
MACROSIN DS        0H                                                          
         L         R1,ADLIST1          GET ADDRESS OF ASM LIST                 
         SH        R9,=H'12'           DROP DOWN BELOW DUMMY ENTRY             
         ST        R9,L1BOTMC(,R1)     POINT TO LAST ENTRY FOR LOOKUP          
         N         R9,=F'-8'           ALIGN TO DOUBLE WORD                    
         L         R4,MACLAST          GET END OF AREA ADDRESS                 
         ST        R4,L1TOPMC(,R1)     ADDRESS OF LOOKUP AREA                  
         SR        R4,R9               GET LENGTH REMAINING                    
         ST        R4,L1LENMC(,R1)     SAVE LENGTH FOR GROW IN ASMGF3          
         S         R9,GOTADDR          LENGTH REMAINING                        
         ST        R9,GOTLIST          GIVE TO BUFF                            
         MVC       GOTLIST+4(4),GOTADDR                                        
*                                                                              
*        RESTORE THE SYSLIB DCB TO IT'S VIRGIN STATE                           
*                                                                              
         TM    DIRDCB+48,X'10'     IS DIRECTORY OPEN ??                        
         BZ    NODIRDCB            NOPE ---                                    
         CLOSE     DIRDCB               CLOSE THE DIRECTORY                    
         FREEPOOL  DIRDCB               ABD RELEASE THE BUFFER POOL            
NODIRDCB DS    0H                                                              
*                                                                              
*        RESTORE R9 AS POINTER TO LIST1 IN ASM                                 
*                                                                              
         L         R9,ADLIST1          GET ADDRESS OF ASM LIST                 
*                                                                              
*        EXIT STAGE RIGHT WITH A SMILE                                         
*                                                                              
         WTO 'MACLIB DIR DONE',ROUTCDE=11                                      
         B         BUFFINIT                                                    
         SPACE     4                                                           
*                                                                              
*        THE FOOL DID NOT GIVE US ENOUGH CORE                                  
*                                                                              
*        FLIP THE 208 ERROR BIT IN L1SYNERR AND CONTINUE.                      
*        ASMGF2 WILL RECOGNIZE THE FACT THAT THE TABLE OVERFLOWED              
*        WHEN IT DOES A TABLE LOOKUP ON THE MEMBER NAME AND                    
*        WILL DO A CONVENTIONAL FIND IF THE MEMBER IS NOT IN THE TABLE         
*                                                                              
MACABEND DS        0H                                                          
         L         R1,ADLIST1          POINT TO LIST1 IN ASMGASM               
         OI        L1SYNERR(R1),X'08'  TURN ON INDICATION BIT                  
         AH        R9,=H'12'           GO BACK ONE IN TABLE                    
         B         MACROSIN            AND QUIT                                
         SPACE     5                                                           
*                                                                              
*        CONSTANTS AND DATA AREAS FOR MACRO DIRECTORY                          
*                                                                              
DIRDCB   DCB   DSORG=PS,MACRF=GL,DDNAME=SYSLIB,RECFM=F,BLKSIZE=256,    X       
               LRECL=256,EXLST=EXLNEW,EODAD=MACROSIN                           
EXLNEW   DS    0F                  NEW EXLST VALUE                             
         DC    X'86',AL3(NEWEXTNT)                                             
NEWEXTNT DS    0H                                                              
         USING *,R15                                                           
         ST    R1,NEWEXSAV         SAVE R1 FOR LATER RESTORE                   
         NI    SKIPPER+1,X'0F'     TURN OFF THE SKIPPER                        
         LA    R1,0                CLEAR IT OUT                                
         IC    R1,EXT#             INSERT EXTENT NUMBER                        
         LA    R1,1(,R1)           INCREMENT BY ONE                            
         STC   R1,EXT#             SAVE UPDATED VALUE                          
         L     R1,NEWEXSAV         RESTORE R1                                  
         BR    R14                 RETURN TO EOV                               
         DROP  R15                                                             
NEWEXSAV DC    F'0'                R1 SAVE AREA                                
EXT#     DC    AL1(0)              INITIAL EXTENT NUMBER                       
*                                                                              
MACTABLS DC        F'0'                START OF TABLE ADDRESS                  
*                                                                              
MACLAST  DC        F'0'                LAST TABLE ENTRY                        
*                                                                              
         EJECT
*        MAKE INITIALIZATION CALL TO BUFF ROUTINE
BUFFINIT DS        0H
         MVC       INITUTAD(12),L1DCBADS+L1SUT1(R9)  MOVE UT DCB ADDRS
         MVC       UBUFFWD(4),UTBUFF+TAB3DEF  SET UTBUFF= VALUE
         L         R1,BUFFENT          POINT AT BUFFENT
         CNOP      2,4
         BALR      R0,R1               GO TO BUFFENT
         DC        F'40'               ROUTINE NUMBER  INIT ROUTINE
GOTLIST  DC        A(0)                WILL HOLD AMT CORE GOT
         DC        A(0)                WILL HOLD CORE ADDR
         DC        F'3'                NUMBER OF UTILITIES
UBUFFWD  DC        F'3'                NUMBER BUFFERED
INITUTAD DC        3F'0'               DCB ADDRESSES
INITERAD DC        F'0'                ADDRESS OF ERROR EXIT ROUTINE
         SPACE     4
*        CHOOSE DEFAULT UTILITY BLOCK SIZES
*
         L         R1,MINBLK           MINIMUM BLOCKSIZE FOR UT1
         LR        R2,R1               ALSO UT2
         LR        R3,R1               ALSO UT3
         L         R0,GOTLEN           SPACE GOT
         S         R0,=A(48*K1)        SEE IF BLKSIZE CAN BE INCREASED
         BL        SEEDCB
         SRL       R0,3                DIVIDE BY EIGHT
         AR        R2,R0               INCREASE UT2 AND UT3 BLKSIZE
         AR        R3,R0
         SRL       R0,1                DIVIDE BY SIXTEEN
         AR        R1,R0               INCREASE UT1 BLKSIZE
         EJECT
*
*        CHECK IF BLKSIZE ALREADY SPECIFIED
SEEDCB   DS        0H
         STM       R1,R3,ZSAVE         SAVE DEFAULT BLKSIZES
         LA        R2,8                SET INDEX FOR LOOP
         L         R3,=F'-4'           FOR BXH
*        LOOP FOR EACH UTILITY DCB
UTLOOP   DS        0H
         L         R4,L1DCBADS+L1SUT1(R2,R9)  POINT AT UT DCB
         LA        R1,0(R2,R2)             DOUBLE THE OFFSET
         LA        R1,L1DDNAM+2*L1SUT1(R1,R9)  POINT AT UT DDNAME
         LH        R5,DCBBLKSI(,R4)    LOAD BLKSIZE
         LTR       R5,R5               TEST FOR ZERO
         BZ        DEVTYPE
         C         R5,MINBLK           TEST IF BELOW MINIMUM
         BNL       ROUND
         BAL       R14,ERR201          PRINT ERROR
*
*        ROUND DOWN DEFAULT BLKSIZE ACCORDING TO THE DEVICE
DEVTYPE  DS        0H
         DEVTYPE   (1),IOSAVE,DEVTAB   DO DEVTYPE MACRO
         SR        R0,R0               INITIALIZE RECORDS/TRK AT 1-1
DETB02   DS        0H
         BAL       R14,CMBFSZ          CALCULATE OPTIMUM RECORD SIZE
         C         R5,ZSAVE(R2)        GREATER THAN DEFAULT .Q
         BH        DETB02              GET NEXT LOWER IF YES
         C         R5,MINBLK           ARE WE BELOW MINIMUM .Q
         BNL       ROUND               BRANCH IF NOT
         L         R5,MINBLK           TAKE THE MINIMUM
ROUND    DS        0H
         N         R5,=F'-8'           ROUND DOWN TO DOUBLE WORDS LONG
         STH       R5,DCBBLKSI(,R4)    PLACE FINAL BLKSIZE IN DCB
         AIF       (&NOTSTAT).NOBLKSZ
*        PRINT BLKSIZE OF EACH UT
         CVD       R5,DWORD            DECIMAL
         MVC       BLKLINE(8),0(R1)    DDNAME
         MVC       BLKEDIT+1(5),=X'2020202120' INIT EDIT
         ED        BLKEDIT(6),DWORD+5  BLKSIZE IN CHAR
         B         PRNTBLK             PRINT IT
BLKLINE  DC        CL50' '             BLANKS
         ORG       BLKLINE
         DC        C'SYSUTN   BLKSIZE='
BLKEDIT  DC        C' ',X'2020202120'
         ORG
PRNTBLK  PRINTOUT  BLKLINE,DCB=NO,CSECT=GAECT,TYPE=STAT
.NOBLKSZ ANOP
         BXH       R2,R3,UTLOOP        LOOP FOR EACH UTILITY
         B         BUFTOTAL            GO SET UP BUFFERS AND DICTS
         EJECT
*
*        COMPUTE MAXIMUM BLKSIZE FOR N BLOCKS PER TRACK.
*        EQUATION FOR FOLLOWING COMPUTATION IS --
*             DL = (2**9(MB-(N-1)*BO))/2**9+(N-1)*TF
*        WHERE     DL = DATA LENGTH = BLKSIZE
*                  BO = BLOCK OVERHEAD
*                  TF = TOLERANCE FACTOR
*                  MB = MAXIMUM BLOCK = TRACK CAPACITY
*
*        INPUT     R0 IS (N-1) BLOCKS PER TRACK
*                  R14 IS RETURN REGISTER
*        OUTPUT    BLKSIZE IN R5
*
CMBFSZ   DS        0H
         LR        R5,R0               SAVE N-1
         A         R0,F1               N = N+1
         SR        R6,R6               ZERO WORK REGISTER
         LR        R7,R6               AND ANOTHER
         IC        R6,IOSAVE+14        LAST KEYED BLOCK OVERHEAD
         IC        R7,IOSAVE+16        LESS BLOCK OVERHEAD IF NOT KEYED
         TM        IOSAVE+17,ZEUS      IS IT 2305 .Q
         BZ        NOTZEUS             BRANCH IF NOT
         LH        R6,IOSAVE+14        2305 DRIVE OVERHEAD
NOTZEUS  DS        0H
         SR        R7,R6               COMPUTE BLOCK OVERHEAD
         MR        R6,R5               COMPUTE M*(-BO) PLUS THE
         A         R7,IOSAVE+4         MAXIMUM SIZE FOR UNKEYED BLOCK
         TM        IOSAVE+17,ZEUS      IS IT 2305 .Q
         BZ        NOZEUS              BRANCH IF NOT
         LH        R6,IOSAVE+14        LAST BLOCK OVERHEAD
         B         YEZEUS              AND CONTINUE
NOZEUS   DS        0H
         SR        R6,R6               ZERO WORK REGISTERS
         IC        R6,IOSAVE+15        LAST BLOCK OVERHEAD
YEZEUS   DS        0H
         SR        R7,R6               SUBTRACT LAST BLOCK OVERHEAD
         SR        R6,R6               ZERO WORK REGISTER
         IC        R6,IOSAVE+16        ADD KEY
         AR        R7,R6               OVERHEAD
         SLA       R7,9                TIMES 2**9
         TM        IOSAVE+17,X'01'     IS TOLERANCE FACTOR NEEDED .Q
         BZ        NOTF                BRANCH IF NOT
         MH        R5,IOSAVE+18        M*TF
NOTF1    DS        0H
         LA        R5,512(,R5)         ADD 2**9 TO IT
         SR        R6,R6               ZERO EVEN OF EVEN/ODD
         DR        R6,R5               COMPUTE OPTIMUM BLOCK
         LR        R5,R7               PASS BACK ANSWER
         BR        R14                 AND RETURN
NOTF     DS        0H
         SLA       R5,9                TIMES 2**9 ASSUME TF=512
         B         NOTF1               GO BACK
         SPACE     2
ZEUS     EQU       X'08'               2305 INDICATOR
         EJECT
*        COMPUTE TOTAL CORE REQUIREMENTS FOR F2 BUFFERS AND INIT DICTS
*
BUFTOTAL DS        0H
         LM        R1,R3,L1DCBADS+L1SUT1(R9)  THREE UTILITY DCB ADDRS
         LH        R1,DCBBLKSI(,R1)    UT1 BLKSIZE
         LH        R2,DCBBLKSI(,R2)    UT2 BLKSIZE
         LH        R3,DCBBLKSI(,R3)    UT3 BLKSIZE
         ST        R1,SSEG             SUBSETTED DICT SEGMENT LENGTH
         STH       R1,BWBLKS+BWBFSZ    LENGTH OF UT1 BUFFER
         STH       R3,BWBLKS+16+BWBFSZ LENGTH OF UT3 BUFFER
         ST        R3,INPLEN
         CR        R2,R3               PICK MIN(2,3) FOR OBSIZ
         BL        SP6
         LR        R2,R3
SP6      DS        0H
         ST        R2,OBSIZ            SET OBSIZE
         L         R2,ADCBLB           ADD MACLIB TO UT1 BLKSIZE
         AH        R1,DCBBLKSI(,R2)
         AH        R1,DCBBLKSI(,R2)    DOUBLE IT
         LA        R1,2*LBEND(,R1)     PLUS DECB PREFIX TO BUFFERS
         AR        R1,R3               ADD UT3 BLKSIZE
         A         R1,=A(6*BLKSZ)      ADD ON OTHER CORE REQ'D
         ST        R1,TOTLEN           SAVE FOR CALL TO ASMGBUFF
         SPACE     4
*********  GET CORE FROM ASMGBUFF  **********
*
         L         R1,BUFFENT          ADDR OF ASMGBUFF
         CNOP      2,4
         BALR      R0,R1
         DC        F'36'          CODE FOR A SHRINK OF BUFF SPACE
TOTLEN   DC        A(0)                WILL HOLD TOTAL CORE REQ'D
         DC        A(0)                BUFF WILL FILL IN ADDR OF CORE
         CLI       TOTLEN+4,X'FF'      CHECK ENOUGH CORE
         BNE       COMINIT
         BAL       R0,ASMABEND         POINT AT TERMINAL MESSAGE
         DC        C'993I',AL1(L'MES993-1)
MES993   DC        C'INSUFFICIENT MEMORY FOR PHASE F2 I/O BUFFERS'
ASMABEND DS        0H
         L         R1,ADLIST1          POINT TO LIST1 IN ASMGASM
         B         L1ABEND(,R1)        BRANCH TO ABEND ROUTINE
         EJECT
*
* INITIALIZE COMMON AREA
*
*
*
*        ASSIGN BUFFER LOCATIONS
*
COMINIT  DS        0H
         L         R4,TOTLEN+4         BOTTOM OF MY CORE
         ST        R4,BWBUF1            START OF BUFFER 1 ADDRESS (UT3)
         ST        R4,BWBLKS+16+BWBUFF
         AH        R4,BWBLKS+16+BWBFSZ  UT3 BUFFER ADDRESS + LENGTH IS
         ST        R4,BWBUF2            START OF BUFFER 2 ADDRESS (UT1)
         ST        R4,BWBLKS+BWBUFF
         AH        R4,BWBLKS+BWBFSZ    UT1 BUFFER PLUS LENGTH
         ST        R4,LBDECBAD         1ST SYSLIB DECB POINTER
         XC        0(LBEND,R4),0(R4)   CLEAR 1ST SYSLIB DECB/SUFFIX
         L         R1,ADCBLB           SYSLIB DCB ADDRESS
         LA        R5,LBEND(,R4)       1ST SYSLIB BUFFER ADDRESS
         ST        R1,LBDCBAD(,R4)     DCB ADDRESS IN 1ST DECB
         ST        R5,LBAREAAD(,R4)    BUFFER ADDRESS IN 1ST DECB
         AH        R5,DCBBLKSI(,R1)    PLUS BLKSIZE OF 1ST MACLIB BUFF
         ST        R5,LBDECBAD+4       IS 2ND SYSLIB DECB ADDRESS
         XC        0(LBEND,R5),0(R5)   CLEAR 2ND SYSLIB DECB/SUFFIX
         LA        R4,LBEND(,R5)       2ND SYSLIB BUFFER ADDRESS
         ST        R1,LBDCBAD(,R5)     DCB ADDRESS IN 2ND DECB
         ST        R4,LBAREAAD(,R5)    BUFFER ADDRESS IN 2ND DECB
*
*        SET UP GLOBAL DICTIONARY
*
         AH        R4,DCBBLKSI(,R1)    POINT AT GLOBAL DICT
         LR        R5,R4
         ST        R5,GDP              START OF GBL DICT +
         A         R5,=A(6*BLKSZ)       INIT DICT ALLOCATION -
         BCTR      R5,0                 1 = END OF DICT SPACE WHICH
         ST        R5,DEND               GOES TO DEND.
*
         EJECT
*        IF IN BATCH MODE GET THE INITIAL GLOBAL DICTIONARY FROM THE
*          ASMGISXX MODULE WHICH IS CORE RESIDENT.
*        IF NOT BATCH MODE, READ IT IN FROM SYSUT1.
*
*        R4 POINTS AT GLOBAL DICTIONARY ALLOCATED SPACE
         L         R2,PNDX             LENGTH OF DICT
         LR        R6,R4               SAVE GDP FOR DCINIT
*
         TM        PARBYT1,BATCH       TEST IF BATCH
         BZ        READGBL
*
         L         R1,L1ISADDR(,R9)    POINT AT INSTSET MODULE
         LA        R0,256              MVC LENGTH
MVC256   DS        0H
         SR        R2,R0               NUMBER OF BYTES GT 256 .Q
         BM        MVCLT256            BRANCH IF NOT
         MVC       0(256,R4),2*PASHL+4(R1)  MOVE 256 BYTES
         BZ        DCINIT              BRANCH IF MULT OF 256
         AR        R4,R0               INCREMENT 'TO' LOCATION
         AR        R1,R0               INCREMENT 'FROM' LOCATION
         B         MVC256              MOVE ANOTHER CHUNK
MVCLT256 DS        0H
         A         R2,F255             RESTORE REMAINING LENGTH-1
         EX        R2,MVCRT256         MOVE THE REST
         B         DCINIT              AND CONTINUE
MVCRT256 MVC       0(*-*,R4),2*PASHL+4(R1)  MOVE TAIL OF RECORD
*
*        READ GBL DICT FROM SYSUT1
READGBL  DS        0H
         L         R3,L1DCBADS+L1SUT1(,R9)  SYSUT1 DCB ADDRESS
         LA        R5,2000             BLOCK SIZE
READIS   READ      DECB2,SF,(R3),(R4),(R5)       READ GBLDICT BLOCK
         CHECK     DECB2
         AR        R4,R5               UP TO ADDRESS
         SR        R2,R5               DECREMENT TOTAL LENGTH
         BH        READIS              BR IF MORE BLOCKS
*
*        REWIND THE UTILITY
         POINT     (R3),F1
         EJECT
*
* INITIALIZATION FOR DICTIONARY MAINTENANCE
*
*        DICTIONARY CORE ALLOCATION-
*        DICTIONARIES FOLLOW BUFFERS IN GETMAIN SPACE.
*        BLOCK SIZE IS SPECIFIED IN 'BLKSZ'. FIRST 3 BLOCKS ARE INI-
*        TIALLY RESERVED FOR PERMANENT (GLOBAL) DICTIONARY. EACH
*        SUCCEEDING BLOCK CONTAINS ONE TRANSIENT (LOCAL) DICTIONARY.
*        BEGINNING OF THE FIRST TRANS DICT IS CALLED THE THRESHOLD.
*        END OF DICTIONARY IS COMPUTED DURING COMMON AREA INITIALIZA-
*        TION AND STORED AT 'DEND'.
*
*        R6 POINTS AT ALLOCATED SPACE FOR DICTS
*
DCINIT   DS        0H
         LA        R2,3*BLKSZ(,R6)     DICTIONARY START + 3 BLOCKS
         LR        R4,R2                 R4 = R2
         LA        R3,BLKSZ(,R2)       DICTIONARY START + 4 BLOCKS
         STM       R2,R4,HISTRY         SAVE THESE FOR PHASE F2A
*
*        ZERO THE START OF EACH TRANS DICT SO THEY APPEAR EMPTY
*
DCL8     DS        0H
         XC        0(7,R4),0(R4)        INSERT ZEROS
         LA        R4,BLKSZ(,R4)        STEP POINTER 1 BLOCK
         C         R4,DEND              LOOP UNTIL OUT
         BNH       DCL8                   OF DICTIONARY
         SPACE     5
*        IF IN BATCH & EXECUTE MODE READ AND PRINT THE $JOB CARD
*
*
         TM        L1PBYT1(R9),X'10'   WAS BATCH SPECIFIED .Q
         BZ        F2XCTL              BRANCH IF NOT
         TM        L1PBYT2(R9),X'20'   WAS EXECUTE SPECIFIED .Q
         BZ        F2XCTL              BRANCH IF NOT
         MVC       LINE,L1BLANKS(R9)   BLANK PRINT LINE FOR $JOB
         MVC       LINE+20(4),L1$JOB(R9)  MAYBE USER WON'T PROVIDE ONE
         TM        L1SINSW(R9),X'40'   WAS $JOB CARD FOUND IN INIT .Q
         BZ        NO$JOB              BRANCH IF NOT
         NI        L1SINSW(R9),X'FF'-X'40'  TURN OFF $JOB INDICATION
         L         R1,L1DCBADS+L1SIN(,R9)  POINT AT SYSIN DCB
         GET       (1),LINE+20         READ THE $JOB CARD
NO$JOB   DS        0H
         MVI       LINE,10             SKIP 10 LINES
         BAL       R14,SYSL1           PRINT IT
         EJECT
*
*        INITIALIZATION IS COMPLETE
*        XCTL TO F2 FOR PROCESSING
*
F2XCTL   DS        0H
         L         R10,BWBUF2          START OF BUFFER 2 ADDRESS (UT1)
         MVC       0(256,R10),F1F2STRT MOVE SHARED F1/F2 COMMON
         MVC       256(256,R10),F1F2STRT+256       ALL OF IT
         MVC       512(F1F2END-F1F2STRT-512,R10),F1F2STRT+512
         LA        R1,L1BLDL+2*L1LENBL(,R9)  ADDRESS OF ASMGF2 IN BLDL
         XCTL      ,DE=(R1)            TRANSFER CONTROL
         SPACE     2
*
*        THIS ROUTINE EXPANDS AND PRINTS ERROR MESSAGES
*
ERROUT   DS        0H
         STM       R14,R2,IOSAVE       SAVE REGS
         LR        R1,R0               R1 POINTS AT MESSAGE
         MVC       ER1+1(1),4(R1)      LENGTH FOR MVC
         MVC       LINE+3(4),ASMG      'ASMG' TO LINE
         MVC       LINE+7(4),0(R1)     ERROR NUMBER
ER1      MVC       LINE+14(*-*),5(R1)  PLACE MESSAGE
         L         R1,L1DCBADS+L1STERM(,R9) SYSTERM DCB ADDRESS
         TM        DCBOFLGS(R1),X'10'  IS SYSTERM OPEN .Q
         BZ        SYSL2               NO, GO PRINT ON SYSPRINT
         L         R2,L1TRSAVE(,R9)    GET SYSTERM LINE COUNT
         S         R2,F2               DECREMENT BY TWO
         BP        TERMPUT             BRANCH IF POSITIVE
         MVI       LINE,X'FF'          EJECT TO NEW PAGE
         L         R2,LCTBYT           RESTORE LINE COUNT
TERMPUT  DS        0H
         ST        R2,L1TRSAVE(,R9)    SAVE UPDATED LINE COUNT
         PUT       (1),LINE            PUT THE LINE
         MVI       LINE,X'02'          RESTORE CARRIAGE CONTROL
         B         SYSL2               GO PRINT ON SYSPRINT
ASMG     DC        C'ASMG'
         EJECT
************  P R I N T  R O U T I N E  **************
*
*  SYSTEM LIST SUBROUTINE  FOR ASSEMBLER G    PHASE F1
*
*    USE OF PRINT ROUTINE
*
*                  133 BYTE OUTPUT LINE AT LOCATION 'LINE'.
*                  NO. LINES TO BE SKIPPED IN FIRST BYTE OF LINE.
*
SYSL1    DS        0H
         STM       R14,R2,IOSAVE       SAVE VOLATILE REGISTERS
SYSL2    DS        0H
         L         R1,L1DCBADS+L1SPRINT(,R9)  GET SYSPRINT DCB ADDRESS
         PUT       (1),LINE            PRINT IT OUT
         MVC       LINE,L1BLANKS(R9)   CLEAR PRINT LINE
         MVI       LINE,X'02'          SET FOR TWO SPACES
         LM        R14,R2,IOSAVE       RESTORE CALLER'S REGS
         BR        R14                 AND RETURN
         EJECT
***********  DATE AND TIME ROUTINE  *************
*         THIS ROUTINE PLACES THE TIME IN CHARACTER IN LOCATION 'ZTIME'
*         IT IS IN FORMAT 'HH:MM:SS' WITH LEADING 0'S NOT SUPPRESSED
*         THE DATE IN CHARACTER IS PLACED IN LOCATION 'ZDATE'
*         IT IS IN FORMAT 'DD MON YY' WITH LEADING 0 SUPPRESSED
*
*        THE ROUTINE ALSO DETERMINES THE DAY OF THE WEEK AND PLACES IT
*        AT ZDAY.  IT ONLY WORKS FOR 1901 TO 1999.
*        THE DAY OF THE WEEK SECTION OF THIS ROUTINE WAS INSPIRED BY,
*        AND IS SOMEWHAT MODELLED AFTER, THE PROGRAM 'WEEKDAY' (TYPE 3,
*        NUMBER 360D-03.8.003, AUTHOR RICHARD L. CONNER, OCTOBER 15,
*        1966, IBM CONTRIBUTED PROGRAM LIBRARY).
*
*        CALLING SEQUENCE -    BAL      R14,ZMONTH
*        THE ROUTINE MUST BE COVERED BY A BASE, AND R13 SHOULD POINT AT
*             AN OS SAVE AREA.
*
*
ZMONTH   DS        0H
         STM       R14,R1,ZSAVE        SAVE SOME REGISTERS
         TIME      DEC                 GET TIME AND DATE
         ST        R0,ZWORK            STORE TIME
         UNPK      ZWORK(7),ZWORK(4)   CHANGE TO CHARACTER
         MVC       ZTIME(2),ZWORK      PLACE IN TIME
         MVC       ZTIME+3(2),ZWORK+2
         MVC       ZTIME+6(2),ZWORK+4
         SR        R0,R0               MAKE YR & DAY DBL WORD
         STM       R0,R1,ZWORK
         UNPK      L1JULDTE(5,R9),ZWORK+5(3)  SAVE JULIAN DATE FOR END
         UNPK      ZDATE+7(3),ZWORK+5(2) PLACE YR IN OUTPUT
         CVB       R1,ZWORK            YR & DAY DBL BINARY WORD
         D         R0,=F'1000'         YR IN R1, DAY IN R0
         BCTR      R1,0                YR-1
         LR        R15,R1              YR-1
         SRL       R15,2               (YR-1)/4
         N         R1,F3               (YR-1) MOD 4
         MH        R15,H5              (YR-1)/4*5
         AR        R15,R1              (YR-1)/4*5 + ((YR-1) MOD 4)
         AR        R15,R0              (YR-1)/4*5 + ((YR-1) MOD 4)+DAYS
         SR        R14,R14             DBL WORD LONG
         D         R14,F7              DAY OF WEEK IN R14
         MH        R14,H9              INDEX DAY NAME TABLE
         LA        R14,ZDAYTAB(R14)    GET THE DAY
         MVC       ZDAY,0(R14)
         IC        R1,ZFEBTAB(R1)      28 OR 29 DAYS IN FEB
         STC       R1,ZFEB
         LA        R1,ZTAB-4           POINT AT MONTH TABLE
         SR        R15,R15             CLEAR R15
ZLOOP    DS        0H
         LA        R1,4(,R1)           POINT AT NEXT MONTH
         IC        R15,0(,R1)          PICK UP NO DAYS IN MONTH
         SR        R0,R15              SUBTRACT NO. DAYS IN MONTH
         BH        ZLOOP               DONE IF 0 OR NEGATIVE
         AR        R0,R15              ADD BACK LAST MONTH
         CVD       R0,ZWORK            CHANGE DAY IN MONTH TO PACKED
         MVC       ZDATE-2(4),ZEDIT    EDIT DAY INTO OUTPUT
         ED        ZDATE-2(4),ZWORK+6
         MVC       ZDATE+3(3),1(R1)    MOVE NAME OF MONTH TO OUTPUT
         LM        R14,R1,ZSAVE        RESTORE REGISTERS
         BR        R14                 RETURN
ZTAB     DC        AL1(31),C'JAN'
ZFEB     DC        AL1(28),C'FEB'
         DC        AL1(31),C'MAR'
         DC        AL1(30),C'APR'
         DC        AL1(31),C'MAY'
         DC        AL1(30),C'JUN'
         DC        AL1(31),C'JUL'
         DC        AL1(31),C'AUG'
         DC        AL1(30),C'SEP'
         DC        AL1(31),C'OCT'
         DC        AL1(30),C'NOV'
         DC        AL1(255),C'DEC'
ZFEBTAB  DC        AL1(28,28,28,29)
ZDAYTAB  DC        C'MONDAY   '
         DC        C'TUESDAY  '
         DC        C'WEDNESDAY'
         DC        C'THURSDAY '
         DC        C'FRIDAY   '
         DC        C'SATURDAY '
         DC        C'SUNDAY   '
ZWORK    DC        D'0'
         DC        2X'00'
ZDATE    DC        C'XX XXX XX'        DO NOT MOVE THIS CARD
         DC        X'00'
ZTIME    DC        C'XX:XX:XX'
ZDAY     DC        CL9' '
ZSAVE    DC        4F'0'
ZEDIT    DC        C' ',X'202120'
         EJECT
         LTORG
         SPACE     2
K1       EQU       1024                ONE 'K'
*        INTERPRETATION OF CVTDCB FLAGS
SYSTAB   DC        C'MVT',AL1(K1*4/256)     B'X001XX0X'
         DC        C'VS2',AL1(K1*4/256)     B'X001XX1X'
         DC        C'MFT',AL1(K1*2/256)     B'X010XX0X'
         DC        C'VS1',AL1(K1*4/256)     B'X010XX1X'
         DC        C'***',AL1(K1*4/256)     UNUSED
         DC        C'***',AL1(K1*4/256)     UNUSED
         DC        C'PCP',AL1(K1*2/256)     B'X100XX0X'
         DC        C'CMS',AL1(K1*2/256)     CMS SAME AS PCP
         SPACE     2
DCTDVTAD DC        AL2(L1SLIN,L1STERM,L1SUP,L1SLIB)  INDIRECT
         DC        AL2(L1SIN,L1SPRINT,L1SPUNCH,L1SUT1) DCB
         DC        AL2(L1SUT2,L1SUT3,L1SLIN,L1STERM)   MAPPING
         SPACE     2
ENDLINE  DC        A(LINE+100)
MINBLK   DC        F'1608'             UT1, UT2, UT3 MINIMUM BLKSIZE
XREFSUFX DC        X'00',AL3(*-*)      XREF OPTION SUFFIX, IF ANY
LEVEL    DC        C'LEVEL=G'
RELEASE  DC        C'RELEASE='
OVERRIDE DC        C'OVERRIDING PARM='
SYSTEM   DC        C'SYSTEM=AAA 9999'
MODEL    DC        C'MODEL=   '
TIME     DC        C'TIME='
DAY      DC        C'DAY='
DATE     DC        C'DATE='
HEADER   DC        C'OS/360 '
OPTIONS  DC        C'ASSEMBLER OPTIONS='
OPTWORK  DC        7C' ',C'K'
OPTEDIT  DC        5X'20',X'2120'
         EJECT
*
*        DCBTAB
*
*     FORMAT.
*        DC        H'DEFAULT BLKSIZE'
*        DC        AL1(DEFAULT BUFNO)
*        DC        XL2'MASK FOR TURNING OFF OPTIONS IF NO OPEN'
*        DC        X'SWITCHES'
*                  X'80'               ABEND IF NO OPEN
*                  X'40'               BLKSIZE ERROR DETECTED
*        DC        X'NO OPEN SEVERITY CODE'   X'80' = 16,   X'40' = 4
*        DC        X'UNUSED'
*
DCBTAB   DC        H'3200',AL1(2),X'BFFF',X'00',X'80',X'00'   SYSLIN
DCBTABTM DC        H'0133',AL1(2),X'FFF7',X'00',X'40',X'00'   SYSTERM
         DC        H'0080',AL1(2),X'FFBF',X'00',X'80',X'00'   SYSUP
         DC        H'0080',AL1(0),X'FFFF',X'00',X'80',X'00'   SYSLIB
         DC        H'0080',AL1(2),X'FFFF',X'80',X'00',X'00'   SYSIN
         DC        H'0133',AL1(2),X'FFFF',X'80',X'00',X'00'   SYSPRINT
         DC        H'0080',AL1(3),X'7FFF',X'00',X'40',X'00'   SYSPUNCH
         SPACE     2
         EJECT
*                                      *PARBYT0
*        DS        0CL1                *         RESERVED
*        DS        0CL2                *         RESERVED
*        DS        0CL3                *         RESERVED
*        DS        0CL4                *         RESERVED
*        DS        0CL5                *         RESERVED
*        DS        0CL6                *         RESERVED
*        DS        0CL7                *         RESERVED
*        DS        0CL8                *         RESERVED
*
*                                      *PARBYT1
FUPLIST# DS        0CL9                *         FULLUPLIST
DOS#     DS        0CL10               *         DOS
ESD#     DS        0CL11               *         ESD
BATCH#   DS        0CL12               *         BATCH
FLIST#   DS        0CL13               *         FULLLIST
EXTEN#   DS        0CL14               *         EXTEN
FXREF#   DS        0CL15               *         FULLXREF
ALGN#    DS        0CL16               *         ALGN
*
*                                      *PARBYT
DECK#    DS        0CL17               *         DECK
LOAD#    DS        0CL18               *         LOAD
RENT#    DS        0CL19               *         RENT
LIST#    DS        0CL20               *         LIST
RLD#     DS        0CL21               *         RLD
UPLIST#  DS        0CL22               *         UPLIST
XREF#    DS        0CL23               *         XREF
TEST#    DS        0CL24               *         TESTRAN
*
*                                      *PARBYT2
LREF#    DS        0CL25               *         LREF
UPDATE#  DS        0CL26               *         UPDATE
EXECUTE# DS        0CL27               *         EXECUTE
SPACEM#  DS        0CL28               *         SPACE=MAX
TERM#    DS        0CL29               *         TERM
NUM#     DS        0CL30               *         NUM
STMT#    DS        0CL31               *         STMT
*        DS        0CL32               *         RESERVED
*
*                                      *PARBYT3
UMAP#    DS        0CL33               *         UMAP
CMS#     DS        0CL34               *         CMS
XREFFS#  DS        0CL35               *         XREF(FULL/SHORT)
PRT#     DS        0CL36               *         PRINTER
*        DS        0CL37               *         RESERVED
*        DS        0CL38               *         RESERVED
*        DS        0CL39               *         RESERVED
UNUSED#  DS        0CL40               *         UNUSED
*
*                                      *PARBYT4
*        DS        0CL41               *         RESERVED
*        DS        0CL42               *         RESERVED
*        DS        0CL43               *         RESERVED
*        DS        0CL44               *         RESERVED
*        DS        0CL45               *         RESERVED
*        DS        0CL46               *         RESERVED
*        DS        0CL47               *         RESERVED
*        DS        0CL48               *         RESERVED
         EJECT
*
*        ASSEMBLER OPTIONS
*
*        THE FOLLOWING TABLE IDENTIFIES EACH OPTION AND ITS FUNCTION
*
*        TWELVE CHARACTERS WITH TRAILING BLANKS IDENTIFYING THE PARM
*        BITS 0-3     ACTUAL LENGTH OF PARM
*        BITS 4-7     MINIMUM LENGTH OF PARM
*        BIT  0       ON IF THIS IS A SHORT FORM
*        BIT  1       ON IF THERE MAY BE A SUFFIX (XREF)
*        BITS 2-3     UNUSED
*        BITS 4-7     X'0'  OR OPTPBITS BYTES INTO SWITCHES
*                     X'1'  AND OPTPBITS BYTES INTO SWITCHES
*                     X'2'  OR 2 OPTPBITS, AND REST INTO SWITCHES
*                     X'3'  NEXT 2 IS OFFSET TO NUMBER CONTROL
*                     X'4'  SYSPARM ENTRY
*                     X'5'  SPACE ENTRY
*        X'FF' ENDS THE TABLE
         SPACE
OPTPSTR  EQU       0                   CHARACTERS WITH TRAILING BLANKS
OPTPLEN  EQU       OPTPSTR+12          ACTUAL AND MINIMUM LENGTHS
OPTPFLGS EQU       OPTPLEN+1           FLAGS AND CODES
OPTPBITS EQU       OPTPFLGS+1          SWITCHING BITS
OPTPEND  EQU       OPTPBITS+6          END OF ENTRY
         SPACE
OPTEST   DC        0F'0'               FOR STARTING ALIGNMENT
         APARM     ALIGN,MIN=3,ON=ALGN#,FORM=S
         APARM     ALGN,MIN=2,ON=ALGN#
         APARM     NOALIGN,MIN=5,OFF=ALGN#,FORM=S
         APARM     NOALGN,MIN=4,OFF=ALGN#
         APARM     BATCH,MIN=1,ON=BATCH#
         APARM     NOBATCH,MIN=3,OFF=BATCH#
         APARM     'CALIGN=',MIN=2,ADDR=CALIGN
         APARM     CMS,MIN=3,ON=CMS#
         APARM     'COLUMN=',MIN=2,ADDR=COLCOUNT
         APARM     DECK,MIN=1,ON=DECK#
         APARM     NODECK,MIN=3,OFF=DECK#
         APARM     DOS,MIN=3,ON=DOS#
         APARM     ESD,MIN=2,ON=ESD#
         APARM     NOESD,MIN=4,OFF=ESD#
         APARM     EXECUTE,MIN=4,ON=EXECUTE#
         APARM     NOEXECUTE,MIN=6,OFF=EXECUTE#
         APARM     EXTEN,MIN=2,ON=EXTEN#
         APARM     NOEXTEN,MIN=4,OFF=EXTEN#
         APARM     'EXTIME=',MIN=3,ADDR=EXTMWD
         APARM     'INSTSET=',MIN=4,ADDR=ISBIN
         APARM     'ISET=',MIN=2,ADDR=ISBIN,FORM=S
         APARM     'LINECOUNT=',MIN=4,ADDR=LCTBYT,FORM=S
         APARM     'LINECNT=',MIN=6,ADDR=LCTBYT
         APARM     FULLLIST,MIN=5,ON=(FLIST#,LIST#)
         APARM     FLIST,MIN=2,ON=(FLIST#,LIST#),FORM=S
         APARM     LIST,MIN=1,ON=LIST#,OFF=FLIST#
         APARM     NOLIST,MIN=3,OFF=(FLIST#,LIST#)
         APARM     LOAD,MIN=2,ON=LOAD#
         APARM     NOLOAD,MIN=4,OFF=LOAD#
         APARM     LREF,MIN=2,ON=LREF#
         APARM     NOLREF,MIN=4,OFF=LREF#
         APARM     'LSETC=',MIN=2,ADDR=LSETCBYT
         APARM     MULT,MIN=3,ON=BATCH#,FORM=S
         APARM     NOMULT,MIN=5,OFF=BATCH#,FORM=S
         APARM     NUMBER,MIN=1,ALEN=3,ON=NUM#
         APARM     NONUMBER,MIN=1,ALEN=5,OFF=NUM#
         APARM     OBJECT,MIN=3,ON=LOAD#,FORM=S
         APARM     NOOBJECT,MIN=5,OFF=LOAD#,FORM=S
         APARM     OS,MIN=2,OFF=DOS#
         APARM     PRINTER,MIN=2,ON=PRT#
         APARM     PRTER,MIN=3,ON=PRT#,FORM=S
         APARM     NOPRINTER,MIN=4,OFF=PRT#
         APARM     NOPRTER,MIN=5,OFF=PRT#,FORM=S
         APARM     PUNCH,MIN=3,ON=DECK#,FORM=S
         APARM     NOPUNCH,MIN=5,OFF=DECK#,FORM=S
         APARM     RENT,MIN=1,ON=RENT#
         APARM     NORENT,MIN=3,OFF=RENT#
         APARM     RLD,MIN=2,ON=RLD#
         APARM     NORLD,MIN=4,OFF=RLD#
         APARM     'SPACE=',MIN=2,ADDR=0,FORM=S,TYPE=5
SPACEEQ  APARM     'SPACE=',MIN=6,ADDR=SPACEPOS
SPACEMX  APARM     'SPACE=MAX',MIN=9,ON=SPACEM#
SPACEMM  APARM     'SPACE=MAX-',MIN=10,ADDR=SPACENEG
         APARM     STMT,MIN=2,ON=STMT#
         APARM     NOSTMT,MIN=4,OFF=STMT#
         APARM     'SYSPARM=',MIN=2,ADDR=0,TYPE=4
         APARM     TERMINAL,MIN=3,ALEN=4,ON=TERM#
         APARM     NOTERMINAL,MIN=5,ALEN=6,OFF=TERM#
         APARM     TESTRAN,MIN=3,ALEN=4,ON=TEST#
         APARM     NOTESTRAN,MIN=5,ALEN=6,OFF=TEST#
         APARM     UMAP,MIN=2,ON=UMAP#
         APARM     NOUMAP,MIN=4,OFF=UMAP#
         APARM     UNUSED,MIN=4,ON=UNUSED#
         APARM     'UPCOND=',MIN=3,ADDR=UPCOND
         APARM     UPDATE,MIN=3,ON=UPDATE#
         APARM     NOUPDATE,MIN=5,OFF=UPDATE#
         APARM     FULLUPLIST,MIN=5,ON=(FUPLIST#,UPLIST#)
         APARM     FUPLIST,MIN=2,ON=(FUPLIST#,UPLIST#),FORM=S
         APARM     UPLIST,MIN=3,ON=UPLIST#,OFF=FUPLIST#
         APARM     NOUPLIST,MIN=5,OFF=(FUPLIST#,UPLIST#)
         APARM     'UTBUFF=',MIN=2,ADDR=UTBUFF
         APARM     'UBUFF=',MIN=2,ADDR=UTBUFF,FORM=S
         APARM     FULLXREF,MIN=5,ON=(FXREF#,XREF#),SUFFIX=YES
         APARM     FXREF,MIN=2,ON=(FXREF#,XREF#),FORM=S,SUFFIX=YES
         APARM     XREF,MIN=1,ON=XREF#,OFF=FXREF#,SUFFIX=YES
         APARM     NOXREF,MIN=3,OFF=(FXREF#,XREF#),SUFFIX=YES
         DC        X'FF'               END OF THE TABLE
F1END    DC        0D'0'               END OF ASMGF1 ROUTINE
         EJECT
         COMMON    PHASE=ASMGF1
*
*        DCB SYMBOLIC DISPLACEMENTS
*
DCBKEYLE EQU       16
DCBBUFNO EQU       20
DCBBUFCB EQU       21
DCBEODAD EQU       32
DCBRECFM EQU       36
DCBEXLST EQU       37
DCBDDNAM EQU       40
DCBMACRF EQU       42
DCBDEBAD EQU       45
DCBOFLGS EQU       48
DCBGET   EQU       48
DCBBLKSI EQU       62
DCBLRECL EQU       82
*
JFCBLKSI EQU       102                 ONE JFCB DISPLACEMENT
*
CVTPTR   EQU       X'10'               ADDR OF CVT POINTER
CVTMDL   EQU       X'02'               MODEL ID FROM CVT PREFIX
CVTRELNO EQU       X'04'               RELEASE NUMBER FROM CVT PREFIX
CVTDCB   EQU       X'7C'               SYSTEM FLAGS FROM CVT PREFIX
*
         SPACE     2
         END       ASMGF1
./ ADD NAME=ASMGF2   0100-88357-88357-1252-04220-04220-00000-CHSY227
F2       TITLE     'ASMG     MACRO GENERATOR EDITING PHASE'
         ISEQ      73,78
*TITLE-'ASMGF2' (PHASE F2)
*FUNCTION/OPERATION
*   PROCESSES ALL SOURCE, COPY AND SYSTEM MACRO STATEMENTS INTO EDITED
*   TEXT. GENERATES A GLOBAL DICTIONARY, A LOCAL DICTIONARY FOR THE
*   SOURCE PROGRAM AND ONE LOCAL DICTIONARY FOR EACH MACRO DEFINITION
*   PROCESSED.
*ENTRY POINTS
*        ASMGF2     REACHED VIA XCTL FROM PHASE ASMGF1
*              *****THE FOLLOWING ENTRIES USED BY CO-MODULE ASMGF2A****
*        ABSERR     SERIOUS ERROR PROCESSING ROUTINE
*                             L    LINK,=V(ABSERR)
*                             BALR LINK,LINK
*                             DC   AL1(ERROR-CODE,ERROR-RECORD-TYPE)
*        ABS001     FLUSH REMAINING CARDS OF STATEMENT IN ERROR
*                             L    LINK,=V(ABS001)
*                             BR   LINK
*        DRIVER     PROCESS NEXT STATEMENT
*                             L    LINK,=V(DRIVER)
*                             BR   LINK
*        MEND1      SIMULATE 'MEND' WHEN EOD WHILE READING SYSTEM MACRO
*                             L    LINK,=V(MEND1)
*                             BR   LINK
*        NDOPR0     END OF STATEMENT PROCESSOR
*                             L    LINK,=V(NDOPR0)
*                             BALR LINK,LINK
*        SWICTL     SET STANDARD ICTL PARAMETERS FOR SYSLIB READ
*                             L    LINK,=V(SWICTL)
*                             BALR LINK,LINK
*        WRNERR     WARNING ERROR PROCESSING ROUTINE
*                             L    LINK,=V(WRNERR)
*                             BALR LINK,LINK
*                             DC   AL1(ERROR-CODE,ERROR-RECORD-TYPE)
*        FIND       DOES A POINT TO FIRST RECORD OF A MEMBER IN SYSLIB
*                             SEE COMMENTS PRECEEDING FIND ROUTINE
*INPUT
*   SYSIN -SOURCE PROGRAM STATEMENTS
*   SYSLIB -COPY CODE AND SYSTEM MACRO SOURCE STATEMENTS
*   F1 EXIT CONDITIONS INDICATED IN ERRSW1 BYTE -
*        ERRBDPM = '0' -- PARM FIELD OK
*        ERRBDPM = '1' -- ERROR IN PARM FIELD
*   REGISTER 10 POINTS TO F1/F2 SHARED COMMON AREA
*
*OUTPUT
*   SYSUT3 -SOURCE STATEMENTS AND ASSOCIATED EDITED TEXT AND ERROR
*           RECORDS
*   SYSUT1 -MACRO EDITED TEXT AND ASSOCIATED ERROR RECORDS AND MACRO
*           AND OPEN CODE DICTIONARIES
*EXTERNAL ROUTINES
*        ASMGBUFF   USED TO PERFORM I/O FUNCTIONS SUCH AS READ, WRITE,
*                   NOTE, POINT, ETC.
*              *****THE FOLLOWING ROUTINES ARE IN CO-MODULE ASMGF2A****
*        ASCAN      ATTRIBUTE GATHERER FOR DC/DS OPERANDS
*        BWFORC     UT1/UT3 OUTPUT BLOCKING ROUTINE    SIZE ENTRY
*./      DELETE    SEQ1=01020020,SEQ2=01020020
*        BWRITE     UT1/UT3 OUTPUT BLOCKING ROUTINE    TEXT ENTRY
*        DCLOSE     CLOSES OUT SOURCE PROGRAM AND MACRO LOCAL
*                   DICTIONARIES AND CREATES CORRESPONDING SUBSETTED
*                   DICTIONARIES FOR PHASE ASMGF3
*        DCLOS1     (SAME FUNCTION AS DCLOSE)
*        ENTDCT     CREATES ENTRIES IN THE GLOBAL AND LOCAL
*                   DICTIONARIES FOR SYMBOLS, MACRO NAMES, ETC.
*        EOFIN      PROCESSES EOD CONDITION ON SYSIN
*        EOFLIB     PROCESSES EOD CONDITION ON SYSLIB
*        GETSRC     SYSIN/SYSLIB INPUT PROCESSING ROUTINE
*        KLOSIT     END OF PHASE PROCESSOR
*        LIBCHK     CHECK SYSLIB READ - BEFORE COPY FROM MACRO
*
*
*        LIBRFND1  DOUBLE BUFFER READ INITIATE FROM SYSLIB
*        LIBWAIT   AWAIT COMPLETION OF ALL READS ON SYSLIB AND CLEAR
*                   DCB ERROR FLAGS
*        LOOKUP     PROCESS ANY NECESSARY DICTIONARY ENTRIES FOR STMT
*EXITS -NORMAL (FROM CO-MODULE ASMGF2A)
*       TO PHASE ASMGF3 VIA XCTL WHEN ALL INPUT HAS BEEN PROCESSED
*      -ERROR  (FROM CO-MODULE ASMGF2A)
*       ABEND 20 RETURN TO SYSTEM IF THE GLOBAL OR SOURCE PROGRAM
*        LOCAL DICTIONARY OVERFLOWS ITS AVAILABLE AREA
*TABLES/WORK AREAS
*        COMMON WORK AREA WAS ASSEMBLED AS PART OF ASMGF1 AS A CSECT.
*         COMMON AREA IS FORMATTED AS INDICATED BY THE DSECT 'COMMON'.
*        THE FOLLOWING WORK AREAS ARE IN A SEGMENT OF MEMORY OF MEMORY
*         AQUIRED FROM BUFF BY F1.
*         A SYSUT3 BUFFER POINTED AT BY WORD AT BWBLKS+16.
*         A SYSUT1 BUFFER POINTED AT BY WORD AT BWBLKS.
*         2 SYSLIB BUFFERS POINTED AT BY LIBBUFAD.
*         THE GLOBAL DICTIONARY POINTED AT BY GDP.
*ATTRIBUTES -N/A
         COPY      ASMGSET
         SPACE     1
ASMGF2   START
         SPACE     1
*./      DELETE    SEQ1=01780020,SEQ2=01800020
         EXTRN EOFIN
         EXTRN EOFLIB
*
         EXTRN LIBRFND1
         EXTRN LIBWAIT
         ENTRY ABSERR
         ENTRY DRIVER
         ENTRY NDOPR0
         ENTRY SWICTL
         ENTRY WRNERR
         ENTRY MEND1
         ENTRY ABS001
*
*        REGISTER DEFINITIONS
RQ       EQU   0
RA       EQU   1
RB       EQU   2
R8       EQU   8
B1       EQU   11        BASE
B2       EQU   12        BASE
CM       EQU   13        COMMON POINTER
L5       EQU   15        LINK
*
*
*        SET UP PHASE F2 BASES
         LR        R8,L5               TRANSFER BASE ADDRESS
         USING     ASMGF2,R8           TEMPORARY INITIAL BASE
         L         CM,COMMAD           ADDRESS OF COMMON AREA
         USING     COMMON,CM           AND TELL ASSEMBLER
         ENTRYOUT  F2
         LA        B1,USEBAS           1ST BASE REGISTER
         L         B2,USING1           2ND BASE REGISTER
         USING     USEBAS,B1,B2        AND TELL ASSEMBLER
*
*        INITIALIZE F1/F2 SHARED COMMON AREA
*
         MVC       F1F2STRT(256),0(AUXREG)    MOVE SHARED F1/F2 COMMON
         MVC       F1F2STRT+256(256),256(AUXREG)   ALL OF IT
         MVC       F1F2STRT+512(F1F2END-F1F2STRT-512),512(AUXREG)
*
*        SET UP DCBS AND BUFFERS
*
         USING     IHADCB,RB           DCB ADDRESSABILITY
         L         RB,ADCBIN           GET SYSIN DCB ADDRESS
         MVC       DCBEODAD+1(3),EOFINAD+1     PUT EOF INTO SYSIN DCB
         L         RB,ADCBLB           GET SYSLIB DCB ADDRESS
         MVC       DCBEODAD+1(3),EOFLIBAD+1    PUT EOF INTO SYSLIB DCB
         DROP      RB
*
*        TEST IF EXTEN OPTION SPECIFIED
*
         TM        PARBYT1,EXTEN       TEST EXTEN SWITCH
         BO        RDFRST              BRANCH IF ON
         OI        POPRINT,2           MAKE PRINT BAD IN MACROS
         OI        POMACRO,4           MAKE MACRO BAD IN COPY
         OI        POMEND,4            MAKE MEND BAD IN COPY
         MVI       POCOPY,X'04'        COPY BAD BETWEEN MACS, IN COPY
         NI        SWTCH5,X'FE'        TURN EXTEN SWITCH OFF
*
*        READ FIRST CARD FROM SYSIN
*
RDFRST   DS        0H
         L         LINK,GETAD          BRANCH TO GETSRC TO GET FIRST
         BALR      LINK,LINK           CARD INTO INPUT BUFFER
         DC        AL2(0)              (FOR GTSRC ENTRY)
         TM        ERRSW1,ERRBDPM      IS PARM FIELD OK .Q
         BZ        PARMOK              BRANCH IF YES
         BAL       LINK,WRNERR         ENTER ERROR
         DC        AL1(F1ERR1,ERRST)   ERROR CODE
F1ERR1   EQU       55                  ERROR IN PARAMETER FIELD OF EXEC
PARMOK   DS        0H
         L         INPTRS,INPUT        INITIALIZE INPUT POINTER
         LA        OUTPTR,OUTPUT       INITIALIZE OUTPUT POINTER
         LA        AUXREG,67(,INPTRS)  LAST POSITION ICTL CAN START
         CLI       0(INPTRS),BLANK     IS THERE A NAME FIELD .Q
         BNE       DRVER1              YES, ASSUME NOT ICTL
         BAL       LINK,SKPBLK         SCAN TO OPCODE FIELD
         CR        AUXREG,INPTRS       STILL ROOM FOR ICTL .Q
         BNH       DRVER1              NOT ICTL IF NOT
         CLC       XICTL,0(INPTRS)     TEST FOR ICTL
         BNE       DRVER1              BRANCH IF NOT
         LA        INPTRS,4(,INPTRS)   SKIP OVER OPCODE
         L         LINK,GETAD          GET CONTINUATIONS, IF ANY
         BALR      LINK,LINK           GO DO THE IO
         DC        AL2(2)              (FOR GTSRC1 ENTRY)
         BAL       LINK,SKPBLK         SCAN TO START OF OPERAND FIELD
         C         INPTRS,ENDCOL       CHECK IF NO OPERANDS
         BH        ICTL                BRANCH IF NONE
         NI        SWTCH1,X'F7'        INDICATE NO CONTINUES ALLOWED
         BAL       LINK,DECSCN         SCAN FIRST OPERAND
         B         ICTL                BRANCH IF BAD ICTL OPERAND
         LTR       RA,RA               VALUE GREATER THAN ZERO .Q
         BNH       ICTL                ERROR IF NOT
         CH        RA,H40              VALUE GREATER THAN FORTY .Q
         BH        ICTL                ERROR IF YES
         ST        RA,BEGCOL           NEW BEGIN COLUMN
         LA        RA,71               STANDARD END COLUMN
         CLI       0(INPTRS),COMMA     TEST TERMINATOR
         BNE       IC05                NOT COMMA, NO MORE OPERANDS
         BAL       LINK,DECSC1         SCAN SECOND OPERAND
         B         ICTL                BRANCH IF BAD ICTL OPERAND
         CH        RA,H40              VALUE GREATER THAN FORTY .Q
         BNH       ICTL                ERROR IF NOT
         CH        RA,H80              VALUE GREATER THAN EIGHTY .Q
         BH        ICTL                ERROR IF YES
         LR        RB,RA               END COL MUST BE .GE. BEG COL+5
         S         RB,BEGCOL           TO HAVE ROOM FOR 'END' OPCODE
         C         RB,F5               ON EOD CONDITION FOR SYSIN
         BL        ICTL                ERROR IF NOT
         ST        RA,ECOL             NEW END COLUMN
IC05     DS        0H
         S         RA,BEGCOL           COMPUTE STATEMENT LENGTH
         ST        RA,SRCLEN           AND SET LENGTH
         CLI       0(INPTRS),COMMA     TEST TERMINATOR
         BNE       IC10                NOT COMMA, NO MORE OPERANDS
         CLI       ECOL+3,80           CAN'T CONTINUE IF END=80
         BE        ICTL                ERROR IF YES
         BAL       LINK,DECSC1         SCAN THIRD OPERAND
         B         ICTL                BRANCH IF BAD ICTL OPERAND
         C         RA,BEGCOL           VALUE MUST BE BETWEEN BEGCOL+1
         BNH       ICTL                ERROR IF NOT
         CH        RA,H40              AND FORTY
         BH        ICTL                ERROR IF NOT
         ST        RA,BEGCNT           SET NEW CONTINUE COLUMN
         LCR       RA,RA               COMPUTE LENGTH OF
         A         RA,ECOL             CONTINUATION FIELD
         ST        RA,CONLEN           SET LENGTH INDICATION
         OI        SWTCH1,8            INDICATE CONTINUES ALLOWED
IC10     DS        0H
         CLI       0(INPTRS),BLANK     BLANK MUST TERMINATE
         BE        IC15                BRANCH IF YES
         C         INPTRS,ENDCOL       OR ELSE THE END COLUMN
         BNH       ICTL                ERROR
IC15     DS        0H
         L         RA,ECOL             COMPUTE CONTINUATION
         LA        RA,1(,RA)           INDICATOR COLUMN
         ST        RA,CNTCL1           AND SET IT
         L         LINK,GETAD          ADDRESS OF GETSRC
         BALR      LINK,LINK           GET NEXT SYSIN RECORD
         DC        AL2(0)              (FOR GTSRC ENTRY)
         B         DRVER1              CONTINUE AFTER ICTL
XICTL    DC        X'120C1D1532'       'ICTL ' IN INTERNAL CODE
         DROP      R8                  DROP TEMPORARY BASE
*
*        ADDRESSES FOR INITIALIZATION
*
COMMAD   DC        A(COMMON)           COMMON WORK AREA ADDRESS
*./      DELETE    SEQ1=02980020,SEQ2=03180020
         EJECT
* ERROR CODES
ERRR1    EQU   39        ILLEGAL TERMINATOR - INVALID DELIMITER
ERRR2    EQU   16        INVALID NAME
ERRR3    EQU   84        ILLEGAL OPERAND FIELD FORMAT
ERRR4    EQU   71        ILLEGAL OCCURRENCE OF LCL, GBL, OR ACTR
ERRR5    EQU   42        ILLEGAL TERMINATOR IN SETB
ERRR6    EQU   72        ILLEGAL ISEQ
ERRR7    EQU   73        ILLEGAL NAME FIELD
ERRR8    EQU   41        UNDECLARED VARIABLE SYMBOL
ERRR9    EQU   45        ILLEGAL USAGE OF VARIABLE SYMBOL
ERRR10   EQU   49        VARIABLE SYMBOL MATCHES A PARAMETER
ERRR11   EQU   51        MACRO DEFINITION PREVIOUSLY DEFINED
ERRR12   EQU   81        ILLEGAL FORMAT IN GBL OR LCL STATEMENT
ERRR13   EQU   86        ILLEGAL USAGE OF SYSTEM VARIABLE SYMBOL
ERRR14   EQU   89        ILLEGAL USAGE OF N' OR K'
ERRR15   EQU   43        SET SYMBOL PREVIOUSLY DEFINED
ERRR16   EQU   85        ILLEGAL LOGICAL OPERATOR
ERRR17   EQU   87        NO TERMINATING QUOTES
ERRR18   EQU   26        TOO MANY LEVELS OF PARENTHESIS
ERRR19   EQU   96        OPERAND .GT. 255 CHARACTERS
ERRR20   EQU   94        INVALID NAME OR OPERATION IN PROTOTYPE
ERRR21   EQU   93        UNBALANCED PARENTHESIS
ERRR22   EQU   99        POSITIONAL PARAMETER FOLLOWS KEYWORD
ERRR23   EQU   98        MORE THAN 200 PARAMETERS IN PROTOTYPE
ERRR24   EQU   75        ILLEGAL STATEMENT OUTSIDE MACRO DEFINITION.
ERRR25   EQU   73        ILLEGAL NAME FIELD OF ANOP.
ERRR26   EQU   102       ILLEGAL ICTL.
ERRR27   EQU   103       ILLEGAL NAME IN OPERAND OF COPY OP.
ERRR28   EQU   104       COPY CODE NOT FOUND.
ERRR29   EQU   101       UNEXPECTED EOF ON SYSIN.
ERRR30   EQU   74        ILLEGAL STATEMENT IN COPY CODE.
ERRR31   EQU   79        ILLEGAL OP IN MACRO DEFINITION.
ERRR32   EQU   74        ILLEGAL STATEMENT IN SYSTEM MACRO.
ERRR33   EQU   79        END CARD IN MACRO DEFINITION.
ERRR34   EQU   75        ILLEGAL STATEMENT IN OPEN CODE.
ERRR35   EQU   76        SEQUENCE ERROR.
ERRR36   EQU   77        ILLEGAL CONTINUATION CARD.
ERRR37   EQU   77        TOO MANY CONTINUATION CARDS.
ERRR38   EQU   105       EOD ON SYSLIB
ERRR39   EQU   34        OP-CODE NOT FOLLOWED BY BLANK
ERRR40   EQU   82        ILLEGAL DIMENSION SPECIFIED IN GBL OR LCL
ERRR41   EQU   90        INVALID SUBSCRIPT
ERRR42   EQU   91        INVALID SELF DEFINING TERM
ERRR43   EQU   92        INVALID FORMAT FOR VARIABLE SYMBOL
ERRR44   EQU   83        SET NAME FIELD NOT A VARIABLE SYMBOL
ERRR45   EQU   100       STATEMENT COMPLEXITY EXCEEDED
ERRR46   EQU   97        BAD PROTOTYPE FORMAT
ERRR47   EQU   48        SYMBOLIC PARAMETER PREVIOUSLY DEFINED
ERRR48   EQU   44        SET SYMBOL USAGE INCONSISTENT WITH DECLARATION
ERRR49   EQU   47        SEQUENCE SYMBOL PREVIOUSLY DEFINED
ERRR50   EQU   52        NAME FIELD CONTAINS ILLEGAL SET SYMBOL
ERRR51   EQU   50        INCONSISTANT GLOBAL DECLARATION
*./      DELETE    SEQ1=04260020,SEQ2=04280020
ERRR54   EQU   18        INVALID SYMBOL
ERRR55   EQU   88        UNDEFINED CODE
ERRR56   EQU   116       ILLEGAL OPSYN
ERRR108  EQU       108                 INVALID EQU ARGUMENTS
         EJECT
*ROUTINE 'DRIVER'
*FUNCTIONS-
*   ENTRY PT 'DRIVER'- INITIALIZE, GET NEW CARD, GO TO 'DRVER1'.
*   ENTRY PT 'DRVER1'- SCAN NAME AND OP FIELDS, EXIT ON ERRORS.
*     PROCESS * AND .* COMMENTS. PUT EDITED NAME AND OP FIELDS IN
*     OUTPUT BUFFER. EXIT TO OPERAND PROCESSOR DETERMINED BY TYPE
*     OF NAME AND OPERATION.
*ENTRY POINTS-
*        B     DRIVER    GET AND START PROCESSING NEW STATEMENT.
*        B     DRVER1    START PROCESSING.
*INPUT-
*   FOR DRVER1- INPUT RECORD IN INPUT BUFFER.
*EXTERNAL ROUTINES-
*   GETSRC- GET SOURCE CARDS TO INPUT BUFFER.
*   GETCMT- GET COMMENTS CONTINUATIONS.
*   EDT04-  EDIT COMMENTS TO OUTPUT.
*   NDSMT3- WRITE OUT OUTPUT BUFFER.
*   GSCAN-  CLASSIFY NAME AND OPERATION FIELDS.
*   PUTPUT- INSERT TEXT FLAGS IN OUTPUT BUFFER.
*   ENTDCT- CHECK IF OP IS ASSEMBLER OP.
*NORMAL EXITS- TO OPERAND PROCESSORS-
*        B     PROTO     PROTOTYPE IS EXPECTED.
*        B     TESTOV    NAME IS VAR SYM, NOT IN PROTOTYPE.
*        B     VALDOP    OP IS ASSEMBLER OP.
*        B     MCRINS    OP NOT RECOGNIZED, ASSUMED MACRO.
*ERROR EXITS- SYNTAX ERRORS IN NAME OR OP-
*   (ALL RETURN TO DRIVER TO START NEXT CARD.)
*        B     ILOP
*        B     BDPROT
*        BAL   LINK,ABSERR
*
ETSTRT   EQU   0
APTR     EQU   0                        'A' POINTER
EPTR     EQU   1
ZERORG   EQU   2
WORKRG   EQU   4
COMPGO   EQU   5
OPNDS    EQU   6                        PNTR WITHIN OPERAND FORMAT LIST
BLKSKP   EQU   7                        POINTER TO START OF FIELD
TEMPRG   EQU   8                        REGISTER ALWAYS AVAILABLE
DCTEMP   EQU   9                        TEMP REG FOR DICTIONARY LOOKUP
AUXREG   EQU   10
OUTPTR   EQU   14                       OUTPUT POINTER
INPTRS   EQU   15                       INPUT POINTER
INPTR    EQU   INPTRS
OPTR     EQU   OUTPTR
USEBAS   EQU   *                        AL'S PIVOT      DOIN'
USEADR   EQU   *                        HARVEY'S PIVOT   THE OLD
BASE     EQU   *                        EARL'S PIVOT      SOFT SHOE
USING1   DC    A(USEBAS+4096)           SECOND BASE ADDRESS IN B2
EOFINAD  DC    A(EOFIN)                 SYSIN EOD ADDRESS
EOFLIBAD DC    A(EOFLIB)                SYSLIB EOD ADDRESS
         AIF       (&NOTSTAT).DRIV     BEGINNING OF STATISTICS PHASE
DRIVER   ST        7,HOLDIT            SAVE OUR WORK REGISTER
         L         7,=V(CARDSW)        LOAD THE EXTERNAL ADDRESS
         TM        0(7),X'FF'          ARE WE TO COUNT THE CARDS?
         BO        MVI                 GUESS NOT SO FORGET IT
         L         7,BUMPER            GET LAST COUNT- 0 AT START
         A         7,=F'1'             BUMP HER UP BY ONE-SOURCE CARD
         ST        7,BUMPER            STORE YE OLDE COUNT FOR FUTURE
         L         7,HOLDIT            RELOAD WORK REGISTER
         B         MVI                 BRANCH BY WORK AREAS
HOLDIT   DS        F                   REGISTER 7 SAVE AREA
BUMPER   DC        F'0'                CONTAINS LATEST COUNT
         LTORG                         SAVE OUR LITERAL =1
         DS        0H                  REALIGNMENT
MVI      MVI       SWTCH3,X'00'
         ENTRY     BUMPER
          AGO      .NOW                SKIP EXTRA DRIVER STATEMENT
.DRIV    ANOP                          END OF STATISTICS PHASE
DRIVER   MVI   SWTCH3,X'00'             RESET GETSRC ENTRY INDICATORS
.NOW     ANOP
         NI    SWTCH4,X'FD'             RESET MACRO INDICATOR
         NI    SWTCH7,X'0F' TURN OFF PROC. SUBL.,CONC.,PROC. KW,ERR PR.
         TM        SWTCH7,X'02'        DID EOF OCCUR ON SYSIN  Q.
         BO        END2                YES- PROCESS AS END
         L     LINK,GETAD               BR TO GETSRC TO GET NEXT
         BALR  LINK,LINK                 CARD INTO INPUT BUFFER
         DC    AL2(0)                   (FOR GTSRC ENTRY)
*
* INITIALIZE FOR NEW STATEMENT
*
DRVER1   MVC   OUTPUT(10),PNCTAB        CLEAR TEXT PART OF OUTPUT BUFFR
         L     B2,USING1                RESTORE B2 AS 2ND BASE REG
         LA    OUTPTR,OUTPUT+10         POINT TO TEXT PART OF OUTPT BFR
         L     INPTRS,INPUT
         SR    ZERORG,ZERORG            CLEAR
         ST    ZERORG,IOPNDX            CLEAR
         MVC   TYPATR(5),TYPATI         SET DUMMY TYPE FOR NAME
         MVI   OUTPUT+3,X'40'           ASSUME PROCESS ONLY RECORD TYPE
         CLI   0(INPTR),STAR            TEST IF '*' COMMENTS
         BNE   DRV10                    BR IF NOT
         BAL   AUXREG,GETCMT            COLLECT ANY CONTINUATION
         TM    SWTCH1,64           IF NOT IN MACRO DEF,
         BZ    DRIVER              GET NEXT STATEMENT.
         LA    OPTR,OUTPUT+2            POINT TO OUTPUT FIELD TARGET
         LR    INPTR1,INPTR             TRANSFER START CHAR
         L     INPTR,ENDCOL             GET LAST CHAR PTR
         BAL   R2,EDT05                 ADD COMMENTS TO RECORD
         MVI   OUTPUT,X'08'             SET SAM'S RECORD TYPE
         MVI   OUTPUT+3,X'30'           SET ASSEMBLER'S RECORD TYPE
         BCTR  OPTR,0                   BACK UP THE OUTPUT POINTER AND
         BCT   OPTR,NDSMT3                GO OUTPUT THE RECORD
DRV10    CLC   0(2,INPTR),PERASK   TEST IF ' .* '
         BNE   DRV12                    BR IF NOT
         BAL   AUXREG,GETCMT       YES, COLLECT CONTINUATION.
         TM        SWTCH7,X'02'        DID EOF OCCUR ON SYSIN  Q.
         BO        END2                YES- ABORT PROCESSING
         TM    SWTCH1,64           TEST IF IN MACRO DEF.
         BO    DRIVER              IF YES, O.K.
         BAL   LINK,ABSERR         IF NO, OUTPUT ERR REC AND GET NEXT
         DC    AL1(ERRR24)         STATEMENT.
         DC    AL1(ERRST)
DRV12    TM    SWTCH1,64           TEST IF IN MACRO DEF.
         BZ    DRV20                    BR IF NOT
         MVI   OUTPUT+3,X'70'           PROCESS AND PRINT IF 'GEN' TYPE
*
* SCAN NAME FIELD AND SAVE RESULTS
*
DRV20    BAL   LINK,GSCAN               SCAN NAME FIELD
         MVC   NAMBYT(1),GSUMRY
         TM    NAMBYT,5                 IF NAME FIELD IS ORDINARY OR
         BZ    *+8                        SEQ SYMBOL, SET PT OF DEFN
         OI    OPNDL,8                    IND. IN OPNDL ENTRY
         CLI   NAMBYT,1                 TEST IF SEQ SYM OR BLANK
         BH    DRV25                    BR IF NOT
         MVC   OUTPUT+10(2),OMTFLD      ELSE GENERATE OMITTED FIELD TXT
         LA    OPTR,2(0,OPTR)
         B     DRV30
DRV25    TM    NAMBYT,128               IF NAME FIELD CONTAINS NO V.S.
         BO    DRV30
         L     R1,SVPTR                   CHANGE CHARACTER STRING FLAG
         MVI   0(R1),SPUT                 TO PUT FLAG
DRV30    BAL   LINK,SKPBLK              SPACE INPTR TO OP FIELD
*
* SCAN OPERATION FIELD AND SAVE RESULTS
*
         STM   OUTPTR,INPTRS,SAVOUT
         BAL   R1,PUTPUT+4              PUT END OF FIELD FLAG IN
         DC    AL2(ENDFLD)                EDITED TEXT
         MVC   SOPNDX(1),OPNDX          SAVE CURRENT OPNDX
         BAL   LINK,GSCAN               LINK TO GENERAL SCAN
         CLI   0(INPTRS),BLANK          BLANK MUST TERMINATE OP FIELD
         BNE   ILOP                     ILLEGAL OP-CODE FIELD
         BAL   R1,PUTPUT+4              PUT END OF FIELD FLAG IN
         DC    AL2(ENDFLD)                EDITED TEXT
         MVC   OPBYTE(1),GSUMRY         SAVE OP FIELD SCAN RESULTS
         BAL   LINK,SKPBLK              SPACE INPTR TO OPRND FIELD
         TM    OPBYTE,X'04'             TEST IF OP WAS NORMAL SYMBOL
         BZ    NONNOR                   BR IF NOT
*
* PROCESS NORMAL SYMBOL  OPERATION FIELD
*
         IC    ZERORG,OPNDX             SET BACK TO OP-CODE
         LA    WORKRG,OPNDL-4(ZERORG)   FIELD OPNDL ENTRY.
         NI    0(WORKRG),X'07'          ERASE ALL BUT LENGTH-1 IN FLAG
         MVC   OPNDX(1),SOPNDX          BACK UP OPNDX
         L     TEMPRG,SAVOUT+4          RESTORE INPTRS
         MVC   DCAREA+1(8),0(TEMPRG)    MOVE OP-CODE AND LENGTH-1 INTO
         MVC   DCAREA(1),0(WORKRG)       DICTIONARY WORK AREA
         MVI   DENTRY,X'00'             INDICATE POINT OF REFERENCE
         OI    DCAREA,24                ASSUME MACRO NAME IN G.D. FLAG
         TM    SWTCH1,MASK3
         BO    PROTO                    BR IF PROTOTYPE EXPECTED
         L     LINK,DUSING              LET ENTDCT CHECK IF IT IS AN
         BALR  LINK,LINK                 ASSEMBLER OP
         STH   APTR,LTTLA
         LTR   APTR,APTR                APTR=0 IF IT IS
         BZ    VALDOP                   BRANCH YES
         OI        SWTCH8,X'80'         PREVENT OPSYN
         B     MCRINS                   BRANCH TO MACRO INSTRUCTION
         SPACE 2
*
* BRANCH TO PROCESS PROTOTYPE NAME FIELD
*
PROTO    DS    0H                       FOR ADDRESSABILITY SAKE
         LA    LINK,PROTOA-GSCAN        GET OFFSET PAST GSCAN
         B     GSCAN(LINK)              BRANCH TO PROTOA
         EJECT
*./      DELETE    SEQ1=07680020,SEQ2=08460020
*
*        FORCE OUT UTILITY BUFFER IF NEARLY FULL TO TRY TO PREVENT
*          MACRO RECORDS FROM BEING SPLIT ACROSS TWO BLOCKS, THUS
*          REDUCING PERFORMANCE
*
MCRINS   LA        RQ,150              FORCING VALUE FOR 1-LINE MACRO
         TM        SWTCH4,X'40'        TEST IF CONTINUED
         BZ        *+8
         LA        RQ,350              FORCING VALUE FOR MULTI-LINE MAC
         LA        RA,8                SPECIFY UT3
         TM        SWTCH1,X'40'        TEST IF IN MACRO
         BZ        *+6                 SKIP IF NOT
         SR        RA,RA               SPECIFY UT1
         L         RR0,ADWS            ADDRESS OF BWFORC
         BALR      RR0,RR0             CALL IT
*
* PROCESS MACRO INSTRUCTION NAME FIELD
*
         MVI   TYPATR,MTYPE             SET TYPE ATTRIBUTE
         BAL   AUXREG,SMTSQ1            CHECK STATEMENT SEQUENCING
         ST    INPTRS,SAVPTR
         TM    NAMBYT,5                 BR IF NAME IS EITHER ORDINARY
         BM    BELOWW                    OR SEQ SYM, ELSE
         MVI   OPNDX,0                  RESET OP LIST POINTER INDEX
BELOWW   MVI   OUTPUT,N5                M-I FLAG
         MVC   OUTPUT+10(2),LTTLA       INSERT MACRO DEFN POINTER AND
         MVI   OUTPUT+12,POSFLG           POS. PAR. FLAG
         LA    OUTPTR,OUTPUT+13         POINT TO OUTPUT BUFF NAME FIELD
         CLI   NAMBYT,X'01'
         BH    PRCSNM                   NOT S.S. OR BLANK NAME FIELD
         MVC   0(4,OUTPTR),OMITOP       OMITTED OPERAND
         LA    OUTPTR,3(0,OUTPTR)       ADVANCE POINTER
GTOPCD   BAL   LINK,ENDOPR              WRITE OUT NAME FIELD
         L     INPTRS,SAVPTR            SET POINTER BACK TO OPERAND
         BAL   AUXREG,ISITFF            GET CONTINUATION IF NEEDED
         B     MISCAN                   AND GO EDIT OPERAND FIELD
*
PRCSNM   L     INPTRS,INPUT             SET POINTER TO NAME FIELD
         LR    INPTR1,INPTRS                 AND
         ST    INPTR,INTPTR              ALLOW DICT ENTRY IF SYMBOL
         BAL   LINKR,LEGOP0               GO EDIT NAME FIELD
         CLI   ERRCOD,0
         BNE   ILNAM                    INVALID NAME FIELD
         CLI   0(INPTRS),BLANK
         BNE   ILNAM                    ILLEGAL TERMINATOR IN NAME FLD
         MVI   0(OPTR),BLANK            NAME FIELD TERMINATOR
         B     GTOPCD
         EJECT
*
* PROCESS ASSEMBLER OP STATEMENT
*
* TEST IF MACHINE OPERATION OR PSEUDO OPERATION
*
VALDOP   IC    ZERORG,0(0,WORKRG)       LOAD 360 LENGTH OF OP SYMBOL
         LA    TEMPRG,2(EPTR,ZERORG)
*        TEMPRG NOW POINTS TO INTERNAL OP CODE+ASC FLAG IN GLOBAL DICT
         IC    ZERORG,0(0,TEMPRG)       FETCH OP-CODE FOR COMPUTD GO TO
         MVC   OUTPUT+5(2),0(TEMPRG)    INSERT OP-CODE, ASC FOR ASSMBLR
         TM    0(EPTR),X'18'            IS THE R1 MASK PRESENT .Q
         BZ    VAL1                     BIF NO
         MVC   OUTPUT+4(1),1(TEMPRG)    YES, SO MOVE IN R1 MASK AND
         MVC   OUTPUT+6(1),2(TEMPRG)    A.S.C. FOR PSEUDOS & XTND MNEM.
VAL1     EQU   *
         L     R1,SVPTR                 CHANGE CHARACTER STRING FLAG
         MVI   0(R1),SPUT                 TO PUT FLAG
         TM    0(EPTR),MASK4
         BO    PSDOPR                   BRANCH, PSEUDO OPERATION
*
* PROCESS MACHINE OPERATION (ENTIRE STATEMENT)
*
         BAL   AUXREG,SMTSQ1            CHECK STATEMENT SEQUENCING
         IC    ZERORG,0(TEMPRG)         RESTORE OP-CODE SMTSQ1 SMASHED
*./      DELETE    SEQ1=09620020,SEQ2=09660020
         OI    OUTPUT+4,MASK1           SET MACHINE INSTRUCTION
         OI        SWTCH8,X'80'         PREVENT OPSYN
         SRL   ZERORG,6                 DEVELOP LENGTH ATTRIBUTE IN
         LA    ZERORG,1(0,ZERORG)         CASE NAME FIELD IS A SYMBOL
         STH   ZERORG,LNGTAT
         OI    LNGTAT+1,1
         MVI   TYPATR,ITYPE             SET TYPE ATTRIBUTE
TESTOV   EQU   *
         L     LINK,GETAD               BR TO GETSRC TO GET ALL
         BALR  LINK,LINK                  CONTINUATIONS
         DC    AL2(2)
MCHINS   BAL   LINK,SKPBLK              INSURE INPTR AT OPERAND FIELD
         BAL   LINK,GSCAN               NOW SCAN IT
* IF GSCAN MADE AN OPNDL ENTRY FOR A NORMAL OR SEQ SYM, CANCEL IT
MCHIN1   TM    GSUMRY,5                 BRANCH IF OPERAND FIELD DOES
         BZ    ENDSMT                   NOT LOOK LIKE O.S. OR S.S.
         IC    ZERORG,OPNDX             .....OTHERWISE CANCEL ONE
         SH    ZERORG,H4
         STC   ZERORG,OPNDX
         B     ENDSMT
         EJECT
*
* PROCESS PSEUDO OPERATION
*
PSDOPR   OI    OUTPUT+4,MASK0           SET ASSEMBLER OPERATION IND.
         BAL   AUXREG,SMTSEQ            CHECK STATEMENT SEQUENCING
         L     LINK,GETAD               BR TO GETSRC TO GET ALL
         BALR  LINK,LINK                  CONTINUATIONS
         DC    AL2(2)
         BAL   LINK,SKPBLK              SPACE INPTR TO OPERAND FIELD
         CLI   0(TEMPRG),6              TEST IF GBL OR LCL DECLARATION
         BL    DCLRTN                   BR YES
         AR    ZERORG,ZERORG
         CLI   0(TEMPRG),8              TEST IF SET STATEMENT
         BNH   SETS                     BR YES
         L         COMPGO,ADBASE1
         LH    COMPGO,0(COMPGO,ZERORG)  ELSE DEVELOP BRANCH FROM OP CD
         B     BASE(COMPGO)
ADBASE1  DC        A(BASE1-18)
         EJECT
*
* DCLRTN- PROCESSES GLOBAL AND LOCAL DECLARATIONS.
* CHECKS SYNTAX, INCLUDING DIMENSIONING. ENTERS VAR SYMS INTO DICTS.
* SUPPRESSES EDITED TEXT OUTPUT.
* ON ENTRY, ZERORG MUST CONTAIN INTERNAL OP CODE =
* 00,01,02,03,04, OR 05 FOR GBLA,GBLB,GBLC,LCLA,LCLB, OR LCLC, RESP.
DCLRTN   CH    ZERORG,H2                TEST IF GBL
         BH    DCL10                    BR IF NOT
         TM    SWTCH5,16                TEST IF GBL  IS ALLOWABLE
         BZ    DCL15                    O.K., PRESS ON
****     ERROR...ILLEGAL DECLARATION,GENERATE DIAGNOSTIC
DCL05    EQU   *
         BAL   LINK,ABSERR
         DC    AL1(ERRR4)
         DC    AL1(ERRST)
DCL10    TM    SWTCH5,8                 TEST IF LCL IS ALLOWABLE
         BO    DCL05                    ILLEGAL LCL
         OI    SWTCH5,16                DISALLOW FUTURE GBL
DCL15    BAL   LINK,CKNAM1              NAME FIELD MUST BE BLANK
         IC    ZERORG,DCL60(ZERORG)     SET UP FLAG BYTE FOR G.D. ENTRY
         STC   ZERORG,DEFENT
         MVI   GCALL,1                  SET COMMA AS SCAN TERMINATOR
*        DIVERT EDITED TEXT INTO 'DBLWD'
DCL30    LA    OPTR,DBLWD               (OUTPUT EDITED TEXT IS DUMPED)
         MVC   SOPNDX(1),OPNDX          REMEMBER OPNDX
         BAL   LINK,GSCAN               SCAN TO TERMINATOR
         CLI   GSUMRY,128               RESULT MUST BE VARIABLE SYMBOL
         BE    DCL40
******** GENERATE DIAGNOSTIC -ILLEGAL FIELD IN DECLARATION
DCL35    EQU   *
         BAL   LINK,WRNERR
DCLER12  DC    AL1(ERRR12)
         DC    AL1(ERRST)
         MVC   OPNDX(1),SOPNDX          KILL ANY OPNDL NONSENSE
         B     DCL55
********
DCL40    IC    ZERORG,SOPNDX            GET ABS. LOC. OF OPNDL ENTRY
         LA    R2,OPNDL(ZERORG)           FOR THE VARIABLE SYMBOL
         TM    0(R2),64                 DON'T LET SYSLIST SLIP THROUGH
         BZ    DCL35
         MVC   2(2,R2),PNCTAB           INITIALIZE AS UNDIMENSIONED
         TM    0(R2),8                  TEST IF DIMENSIONED
         BZ    DCL55                    NO
*        EDITED SUBSCRIPT FORMAT MUST BE-
*        SUBSCR LPAREN FLAG/DSDT FLAG/3-BYTE DECIMAL DIMENSION/
*        RPAREN FLAG
         CLC   DBLWD+4(2),DCL65
         BNE   DCL35                    ILLEGAL
         CLI   DBLWD+9,SRPAR
         BNE   DCL35                    ILLEGAL
         LH    R8,DBLWD+6               FETCH DIMENSION
         SLL   R8,8                     MAKE ROOM FOR UNIT POSITION
         IC    R8,DBLWD+8               FETCH UNITS POSITION
         LTR   R8,R8                    IS DIMENSION 0 OR MINUS
         BNP   DCL44                    YES, GO LOG ERROR
         C     R8,SETXLIM               NO, IS DIMEN MORE THAN MAX
         BNH   DCL50                    NO, CONTINUE
         MVC   DBLWD+6(3),SETXLIM+1     YES, DEFAULT VALUE = MAX
         B     DCL45                    GO LOG ERROR
DCL44    MVC   DBLWD+6(3),F1+1          DEFAULT DIMENSION TO 1
******** GENERATE DIAGNOSTIC -ILLEGAL DIMENSION SPECIFICATION
DCL45    EQU   *
         BAL   LINK,WRNERR
         DC    AL1(ERRR40)
         DC    AL1(ERRST)
*./      DELETE    SEQ1=11600020,SEQ2=11600020
********
DCL50    MVC   2(2,R2),DBLWD+7          INSERT DIM. IN OPNDL ENTRY
DCL55    CLI   0(INPTR),COMMA           TEST FOR TERMINATING COMMA
*        IF END OF FIELD, SET RETURN TO 'DRIVER' AND EXIT TO 'LOOKUP'
*        TO ENTER OPERANDS IN DICTIONARY.
         LA    TEMPRG,DRIVER
         BNE   LOOKP                    NOT COMMA, SO END OF FIELD
*
         LA    INPTR,1(0,INPTR)         COMMA- PROCESS NEXT OPERAND
         B     DCL30
* THE SO-CALLED 'LOOKUP' ROUTINE SCANS THE OPNDL LIST AND MAKES ALL
* NECESSARY DICTIONARY ENTRIES FOR THE CORRESPONDING OPERANDS.
* (EXIT IS BR TEMPRG)
LOOKP    L     LINK,DLOOKUP
         BR    LINK
SETXLIM  DC    F'2500'                  SETX DIMENSION LIMIT
DCL60    DC    X'202830606870'          RESPECTIVE G.D. FLAGS
DCL65    DC    AL1(SUBSLP)
         DC    AL1(SDSDT)
         EJECT
*        PROCESS ACTR STATEMENT
ACTR1    BAL   LINK,CKNAM1              NAME FIELD MUST BE BLANK
         MVC   OUTPUT+10(4),ACT10       EDITED TEXT FOR TGD REFERENCE
         LA    OPTR,OUTPUT+14           SET UP THE OUTPUT POINTER
         MVC   MCALL(2),SB19            PROCESS JUST LIKE A SETA
         B     SB01
ACT10    DC    AL1(SSETA)
         DC    AL2(4)
         DC    AL1(0)
*        PROCESS AIF, AGO, SETA, SETB, SETC STATEMENTS
SETS     CLI   NAMBYT,128               NAME FIELD MUST BE V.S.
         BNE   ILSSNF
         LH    WORKRG,SB19-12(ZERORG)   SET UP PARAMETERS
         STH   WORKRG,MCALL
         L     OPTR,SAVOUT              RESET OPTR
SB01     MVI   OUTPUT,4                 SET STATEMENT TYPE
         BAL   R1,PUTPUT+4              SET A BLANK IN EDITED TEXT
         DC    AL2(BLANK)
         CLI   MCALL+1,SSETB            BRANCH IF SETB
         BE    SETB1
         CLI   MCALL+1,SSETA            IF SETA, PUT A.R.E. FLAG
         BNE   *+10                       IN TEXT
         BAL   R1,PUTPUT+4
         DC    AL2(SARE)
         BAL   LINK,METSCN              METSCN DOES ALL THE WORK
         CLI   0(INPTR),BLANK           IF BLANK DOESN'T TERMINATE.....
         BE    SB05
         C     INPTR,ENDCOL               THEN STATEMENT BOUNDARY MUST
         BNH   ILOPRF
SB05     BCT   INPTR,SB15
SETB1    MVC   0(5,OPTR),SB20           IF SETB OPERAND IS OF THE FORM
         CLI   0(INPTR),1               0 OR (0), OR 1 OR (1), EDIT
         BH    SB06                      IT AS A D.S.D.T. WITH VALUE
         BCTR  INPTR,0                   0 OR 1, RESPECTIVELY
         BCTR  INPTR,0
         BE    SB07
         B     SB08
SB06     CLC   0(3,INPTR),SB21
         BE    SB08
         CLC   0(3,INPTR),SB22
         BNE   SB10
SB07     MVI   4(OPTR),1
SB08     LA    INPTR,2(0,INPTR)
         LA    OPTR,5(0,OPTR)           SPACE OPTR OVER D.S.D.T. TEXT
         B     SB15
AIF      EQU   *
         MVI   OUTPUT,X'03'
         MVC   MCALL(2),PNCTAB          INDICATE AIF ENTRY
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK
         LA    OPTR,OUTPUT+10           BACK UP OUTPUT POINTER
SB10     CLI   0(INPTR),LPAREN          EXPRESSION MUST BEGIN WITH
         BNE   ILOPRF
         LA    INPTR,1(0,INPTR)         SPACE OVER L-PAREN
         BAL   LINK,METSCN
         CLI   0(INPTR),RPAREN          TERMINATOR MUST BE RIGHT
         BNE   ILOPRF
         CH    R3,H2                    EXPRESSION MUST BE SIMPLE OR
         BH    ILXPRB
         BE    SB15
         TM    0(R1),128                IF SIMPLE, MUST NOT BE SYSLIST
         BZ    ILXPRB
         OI    0(R1),32                 PUT SETB FLAG IN OPNDL ENTRY
SB15     BAL   R1,PUTPUT                GENERATE TERMINATING BLANK
         DC    AL2(BLANK)                 IN TEXT
         CLI   MCALL+1,0                BRANCH IF AIF
         BE    AGO2
         L     TEMPRG,DLOOKUP
         BALR  TEMPRG,TEMPRG
         CLC   OUTPUT+10(1),MCALL+1     NAME FIELD AND STATEMENT TYPES
         BE    NDSMT0                   DO MATCH.
         BAL   LINK,ABSERR              DO NOT MATCH.
         DC    AL1(ERRR50)
         DC    AL1(ERRST)
ILXPRB   BAL   LINK,ABSERR              ILLEGAL TERM IN BOOLEAN
         DC    AL1(ERRR5)                    EXPRESSION
         DC    AL1(ERRST)
AGO      DS    0H
         LA    OPTR,OUTPUT+11           BACK UP THE OUTPUT POINTER
         MVI   OUTPUT,2                 SET STATEMENT TYPE
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK
AGO2     MVI   GCALL,0                  USE GSCAN TO PROCESS OPERAND
         BAL   LINK,GSCAN                 FIELD SEQUENCE SYMBOL
         CLI   GSUMRY,1                 IF THAT'S WHAT WE GOT.....
         BE    *+10
ILOPRF   BAL   LINK,ABSERR              SEQUENCE SYMBOL MISSING IN
         DC    AL1(ERRR3)                  OPERAND FIELD OF AIF OR AGO
         DC    AL1(ERRST)
         LA    OPTR,2(0,OPTR)           ADVANCE OPTR
         B     NDSMT0
SB19     DC    AL2(32768+SSETA)         (MUST BE HALF-WORD ALIGNED)
         DC    AL2(0+SSETB)
         DC    AL2(16384+SSETC)
SB20     DC    AL1(SARE)
         DC    AL1(SDSDT)
         DC    X'000000'
SB21     DC    AL1(LPAREN,0,RPAREN)     INTERNAL CODE FOR (0)
SB22     DC    AL1(LPAREN,1,RPAREN)     INTERNAL CODE FOR (1)
         EJECT
         DS    0H
ANOP     EQU   *
         TM    NAMBYT,1            TEST IF NAME FIELD IS SEQ SYMB.
         BO    ANOPOK
         BAL   LINK,ABSERR
         DC    AL1(ERRR25)
         DC    AL1(ERRST)
ANOPOK   MVI   OUTPUT,9
         LA    OUTPTR,OUTPUT+3
         B     NDSMT0
MACRO    EQU   *
         BAL   LINK,CKNAM1              NAME FIELD MUST BE BLANK
         OI    SWTCH1,MASK13
         OI        SWTCH8,X'80'         PREVENT OPSYN
         B     DRIVER
*./      DELETE    SEQ1=14240020,SEQ2=14280020
MEXIT    EQU   *
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK
         MVI   OUTPUT,X'07'
         LA    OUTPTR,OUTPUT+3
         B     NDSMT0
MEND     EQU   *
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK
MEND1    MVI   OUTPUT,X'07'
         LA    OUTPTR,OUTPUT+3
         BAL   LINK,NDOPR0              OUTPUT RECORD
MEND2    LH    RQ,H32767                FORCE BLOCK TO OUTPUT MEDIUM
         SR    RA,RA                   ON UT1
         L         RR0,ADWS
         BALR  RR0,RR0                  BWFORCE
*./      DELETE    SEQ1=14580020,SEQ2=14600020
         B     END1                     CLOSE OUT MACRO DICTIONARY
ICTL     EQU   *
         BAL   LINK,WRNERR
         DC    AL1(ERRR26)
         DC    AL1(ERRST)
         MVI   INPUTBUF,BLANK      CLEAR TO INTERNAL BLANKS.
         MVC   INPUTBUF+1(70),INPUTBUF
         MVC   INPUTBUF+1(3),INTEND   INSERT END OP.
         MVI   INPUTBUF+71,X'FF'   END OF TEXT FLAG.
         BAL   LINK,SWICTL              SET UP STANDARD ICTL PARAMETERS
         B     DRVER1
INTEND   DC    X'0E170D'           END OP IN INTERNAL CODE.
         EJECT
COPY     BAL   LINK,CKNAM1         NAME FIELD MUST BE BLANK.
         STM   14,15,TEMP              SAVE TWO REGS.
         CLI   CPCUR,X'FF'             ANYTHING NESTED YET .Q
         BE    NOTSMD1                 BRANCH IF NOTHING
*
*   NOTE LOC IN SYSTEM MACRO.
*
         L     RA,ADCBLB               ADDRESS OF SYSLIB DCB
         USING IHADCB,RA               CHANGE EODAD ADDR IN DCB TO
         MVC   DCBEODAD+1(3),BACK7AD+1 POINT TO BACK7 FOR THIS CHECK.
         DROP  RA
*
         L     B2,DCLOS1AD              LOAD BASE
         L     L5,VCHECK                LOAD VECTOR
         BALR  LINK,L5                  AND GO TO IT.
BACK7    L     B2,USING1                RESTORE BASE
         L     RA,ADCBLB               ADDRESS OF SYSLIB DCB.
         USING IHADCB,RA               RESTORE PROPER EODAD EXIT
         MVC   DCBEODAD+1(3),EOFLIBAD+1  ADDRESS TO SYSLIB DCB
         DROP  RA
*
         L     14,LBDECBAD+4          2ND DECB ADDR
         L     15,LBDECBAD            1ST DECB ADDR
         STM   14,15,LBDECBAD         INTERCHANGE THE TWO
*
         B     NOTSMD                   OF BLOCK IN BUFFER.
*
BACK7AD  DC    A(BACK7)
*
NOTSMD1  L     B2,DCLOS1AD             LOAD BASE
         L     L5,VWAIT                AWAIT COMPLETION OF ANY READS
         BALR  RD1,L5                  BEFORE DOUBLE BUFFER COPY READ.
         L     B2,USING1               RESTORE BASE
RD1      EQU   5                        WAIT ROUTINE LINK REGISTER
*
NOTSMD   EQU   *
         LM    14,15,TEMP              RESTORE THE TWO REGS.
         ST    INPTR,SAVEIN        SAVE LOC OF BEG OF OPERAND.
         BAL   LINK,GSCAN
         TM    GSUMRY,X'04'        TEST IF NORM SYMBOL.
         BZ    NOCOPY
         LR    LREG,INPTR          END OF NAME.
         L     TEMPRG,SAVEIN       BEG OF NAME.
         SR    LREG,TEMPRG         SUB TO GET LENGTH.
         BCTR  LREG,0              TRUE LENGTH MINUS ONE.
         N     LREG,F255           ENSURE LOW ORDER BYTE ONLY.
         CL    LREG,F7             NAME CAN BE 8 BYTES MAX.
         BH    NOCOPY
         MVC   NAMBOX+1(8),NAMBOX  CLEAR TO BLANKS.
         EX    LREG,MCNM           MOVE NAME TO ALIGNED AREA.
         TR    NAMBOX+1(8),TRSLTB  TRANSLATE BACK TO EXTERNAL.
         MVC   COPYNAME,MACNAME    RETAIN MACRO NAME WITH COPY
*
*   EXECUTE FIND FUNCTION.
*
         LA    RM15,NAMBOX+1            POINT TO MEMBER NAME
         L     RM1,FINDAD               ADDRESS OF FIND ROUTINE
         BALR  RM0,RM1                  GO FIND MEMBER
         EJECT
*./      DELETE    SEQ1=16120020,SEQ2=17420020
*        RETURN FROM COPY FIND
*
TESTCOPY DS    0H
         BNZ   NFCOP                    ERROR IF COPY NOT FOUND
         L     RA,CPCUR                 CURRENT NESTING LEVEL
         A     RA,CPLEN                 PLUS ONE LEVEL
         C     RA,CPMAX                 COMPARE TO MAXIMUM
         BH    SEQ08                    BRANCH IF TOO BIG
         ST    RA,CPCUR                 UPDATE CURRENT NESTING
         LTR   RA,RA                    1ST LEVEL OF NESTING .Q
         BNZ   TCOPYB                   BRANCH IF NOT 1ST LEVEL
         MVC   COPYSV(40),SEQLEN        SAVE GTSRC PARAMS
         MVC   INFILS(1),TYPRED+1       SAVE INPUT FILE NUMBER
         MVC   SWTCH1X(1),SWTCH1        SAVE SWTCH1 SETTING
         BAL   LINK,SWICTL              SET UP FOR STANDARD ICTL
         TM    SWTCH5,X'20'             IN A SYSTEM MACRO NOW .Q
         BZ    TCOPYC                   BRANCH IF NOT, ONLY 1ST COPY
         A     RA,CPLEN                 BUMP BY ONE MORE LEVEL
         ST    RA,CPCUR                 UPDATE LEVEL COUNTER
TCOPYB   DS    0H
         S     RA,CPLEN                 RESTORE FORMER LEVEL FOR SAVE
         LA    RA,CPWORK(RA)            POINT TO SAVE WORK ENTRY
         L     L5,LBDECBAD              1ST DECB POINTER
         MVC   CPLIBNOT(16,RA),LBLIBNOT(L5)  SAVE BUFFER DATA
         NI    LBRDSW(L5),255-LBRDRS-LBRDOT  KILL READ SWITCHES
         L     L5,LBDECBAD+4            2ND DECB POINTER
         MVC   CPLIBNO2(8,RA),LBLIBNOT(L5)  SAVE 2ND FDAD
         NI    LBRDSW(L5),255-LBRDRS-LBRDOT  KILL READ SWITCHES
         MVC   CPCPNAME(8,RA),COPYNAME  SAVE MEMBER NAME
         L     RQ,LBDECBAD+4            GET SECOND DECB ADDRESS
         L     RA,LBDECBAD              GET FIRST DECB ADDRESS
         STM   RQ,RA,LBDECBAD           AND REVERSE THE TWO
TCOPYC   DS    0H
         MVI   TYPRED+1,MACLIB          SET TO SYSTEM LIBRARY
         OI    SWTCH7,X'01'             SET COPY CODE SWITCH
         L     B2,DCLOS1AD              LOAD BASE REGISTER
         L     L5,VLREAD                SET UP TO DOUBLE BUFFER
         BR    L5                       GO FILL BUFFERS
*
MCNM     MVC   NAMBOX+1(*-*),0(TEMPRG)  MOVE MEMBER NAME
*
*   ILLEGAL NAME IN OPERAND FIELD OF COPY OP.
*
NOCOPY   EQU   *
         BAL   LINK,ABS000         OUTPUT ERR REC AND GET NEXT REC.
         DC    AL1(ERRR27)
         DC    AL1(ERRST)
*
*   COPY CODE NOT FOUND.
*
NFCOP    DS    0H
         MVC   MACNAME(8),COPYNAME      RESTORE MACRO NAME
         BAL   LINK,ABS000              OUTPUT ERR REC AND GET NEXT
         DC    AL1(ERRR28)
         DC    AL1(ERRST)
*
MACLIB   EQU   16
         DC    X'32'               INTERNAL BLANK.
         DS    0F                  ALIGN
         ORG   *-1
NAMBOX   DC    X'32'
         DC    2F'0'
*
*        SET STANDARD INPUT CARD FORMAT
SWICTL   MVI   BEGCOL+3,1          BEGIN COL
         MVI   SRCLEN+3,70         SOURCE LENGTH MINUS ONE
         MVI   ECOL+3,71           END COL
         MVI   CNTCL1+3,72         CONT IND COL
         MVI   BEGCNT+3,16         CONT CARD BEGIN COL
         MVI   CONLEN+3,55         SOURCE LENGTH OF CONT CARD
         NI    SWTCH1,X'7F'        TURN OFF SEQUENCE CHECKING
         OI    SWTCH1,X'08'        ALLOW CONT CARDS.
         BR    LINK                RETURN
         EJECT
*        PROCESS ISEQ OPERAND FIELD
ISEQ     NI    SWTCH1,X'7F'        TURN OFF SEQUENCE CHECKING.
         OI    SWTCH8,X'80'        OPSYN NOW ILLEGAL
         BAL   LINK,CKNAM1         NAME FIELD MUST BE BLANK.
         CLC   0(2,INPTR),COMMABL  TEST IF OMITTED OPERAND.
         BE    DRIVER
         C     INPTR,ENDCOL
         BH    DRIVER
         BAL   LINK,DECSCN              SCAN FIRST OPERAND
         B     ISEQER                   BRANCH IF 1ST OPND ERROR
         CLI   0(INPTR),COMMA           COMMA MUST TERMINATE
         BNE   ISEQER
         LTR   RA,RA                    VALUE MUST BE AT LEAST 1
         BNH   ISEQER
         ST    RA,SEQCL1
         BAL   LINK,DECSC1              SCAN SECOND OPERAND
         B     ISEQER                   BRANCH IF 2ND OPND ERROR
         CLI   0(INPTR),BLANK      BLANK OR END COLUMN MUST TERMINATE.
         BE    *+12
         C     INPTR,ENDCOL
         BNH   ISEQER
         CH    RA,H80                   VALUE MUST NOT BE GREATER THAN
         BH    ISEQER
         C     RA,ECOL                  FIELD MUST LIE OUTSIDE OF
         BH    IS20                       STATEMENT BOUNDARIES
         C     RA,BEGCOL
         BNL   ISEQER
IS10     S     RA,SEQCL1                COMPUTE 360 FIELD LENGTH
         BM    ISEQER
         ST    RA,SEQLEN
         OI    SWTCH1,128               ALLOW SEQUENCE CHECKING
         XC    SEQVAL(40),SEQVAL        CLEAR SEQUENCE CHECK FIELD
         B     DRIVER
IS20     CLC   SEQCL1(4),ECOL           .....THE OTHER CASE FOR
         BH    IS10                       STATEMENT BOUNDARY CHECKING
ISEQER   BAL   LINK,ABSERR              ILLEGAL ISEQ OPERAND
         DC    AL1(ERRR6)
         DC    AL1(ERRST)
*
*        SUBROUTINE TO SCAN AND CONVERT DECIMAL OPERAND FOR ICTL/ISEQ
*
DECSC1   DS    0H
         LA    INPTR,1(,INPTR)          SPACE POINTER OVER COMMA
DECSCN   DS    0H
         LR    RB,INPTR                 REMEMBER STARTING POINTER
         SR    RA,RA                    CLEAR TARGET REGISTER
         SR    RQ,RQ                    CLEAR WORK REGISTER
DEC1     DS    0H
         CLI   0(INPTR),X'09'           IS THERE A DIGIT AT INPTR .Q
         BH    DEC2                     BRANCH IF NOT
         IC    RQ,0(,INPTR)             INSERT CURRENT DIGIT
         MH    RA,H10                   MULTIPLY PARTIAL SUM BY TEN
         AR    RA,RQ                    AND ADD IN CURRENT DIGIT
         LA    INPTR,1(,INPTR)          POINT ONE MORE DOWN STRING
         B     DEC1                     AND LOOP BACK
DEC2     DS    0H
         LR    RQ,INPTR                 TRANSFER CURRENT POINTER
         SR    RQ,RB                    LESS STARTING POINTER
         C     RQ,F8                    TEST FOR LENGTH .LE. EIGHT
         BNH   4(,LINK)                 EXIT IF HOKAY
         BR    LINK                     *** ERROR ***
COMMABL  DC    X'2B32'             'COMMA-BLANK' IN INTERNAL CODE.
         EJECT
REPRO    DS    0H
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLAN
         XC    SVPTR(4),SVPTR           PROCESS COMMENTS FIELD TO
         BAL   R2,EDTCMT                  EDITED TEXT
         L     LINK,GETAD               GET NEXT CARD
         BALR  LINK,LINK                IMAGE
         DC    AL2(8)
         L     INPTR,ENDCOL             BUILD THE FIFTH EDITED TEXT
         MVC   2(80,OPTR),1(INPTR)        FIELD ABOUT IT
         MVI   0(OPTR),SPUT
         MVI   1(OPTR),80
         MVI   82(OPTR),ENDFLD
         LA    OPTR,83(0,OPTR)          THUSLY DO WE EDIT 'REPRO' IN
         B     NDSMT0                     THE MIGHTY MACRO GENERATOR
         SPACE 3
TITLE    DS    0H
         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL
         OI    SWTCH3,MASK5             TELL GSCAN OPND IS TITLE'S
         TM    NAMBYT,4
         BZ    TESTOV                   GET CONTINUATION CARDS, IF ANY
         MVI   OPNDL,0
         B     TESTOV                   GET CONTINUATION CARDS, IF ANY
         SPACE 3
WXTRN    EQU   *                        FOR WEAK EXTERNAL REFERENCES
         TM    SWTCH5,X'41'             TEST OPEN CODE OR EXTEN PARM
         BZ    PSODSO                   BRANCH IF NO
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLAN
         STM   OPTR,INPTR,TEMP          SAVE INPUT AND OUTPUT POINTERS
         MVI   TYPATR,WETYPE            SET WEAK EXTERNAL SYMBOL TYPE
         B     EXT                      CONTINUE IN EXTRN ROUTINE
EXTRN    EQU   *
         TM    SWTCH5,X'41'            TEST OPEN CODE OR EXTEN PARM
         BZ    PSODSO
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLAN
         STM   OPTR,INPTR,TEMP          SAVE INPUT AND OUTPUT POINTERS
         MVI   TYPATR,TTYPE             SET EXTERNAL SYMBOL TYPE
EXT      EQU   *                        ENTRY FROM WXTRN
         MVI   GCALL,1                  SET COMMA AS SCAN TERMINATOR
         BCTR  INPTR,0
EXT05    LA    INPTR,1(0,INPTR)         ADVANCE INPUT POINTER
         L     OPTR,TEMP                (SCAN OUTPUT IS DUMPED)
         IC    ZERORG,OPNDX             REMEMBER OPNDX
         STC   ZERORG,SOPNDX            IN SOPNDX.
         BAL   LINK,GSCAN               SCAN ONE OPERAND
         CLI   GSUMRY,4                 IGNORE IF NOT AN O.S.
         BE    EXT10
         STC   ZERORG,OPNDX
         TM    GSUMRY,128               IF OPERAND CONTAINS NO V.S.,
         BZ    EXT15                      TERMINATE OPERAND SCAN.
EXT10    LA    WORKRG,OPNDL(ZERORG)     INDICATE POINT OF DEFINITION
         OI    0(WORKRG),8
         CLI   0(INPTR),COMMA           IF COMMA TERMINATED.....
         BE    EXT05                      PROCESS NEXT OPERAND
EXT15    MVC   SOPNDX(1),OPNDX          SAVE OPNDX IN CASE OF ERROR
         LM    OPTR,INPTR,TEMP          OTHERWISE RETURN TO SCAN ENTIRE
         MVI   GCALL,0                    OPERAND FIELD IN THE USUAL
         B     MCHINS                   MANNER
         SPACE 3
START    DS    0H
         MVI   OUTPUT,1                 SET STATEMENT TYPE
*DXD -NAME AND OPERAND REQUIRED.
DXD      EQU   *
         MVI   TYPATR,JTYPE             SET TYPE ATTRIBUTE
         B     MCHINS
         SPACE 3
COM      EQU       *
CSECT    EQU   *
DSECT    EQU   *
         MVI   TYPATR,JTYPE             SET TYPE ATTRIBUTE
         MVI   OUTPUT,1                 AND STATEMENT TYPE
         MVC   SVPTR(4),PNCTAB
         B     ENDSMT
         SPACE 3
*
* CXD - NAME OPTIONAL AND NO OPERAND ALLOWED.
CXD      MVI   TYPATR,ATYPE
         MVI   LNGTAT+1,3               DEFINE L' FOR CXD.
         B     LTORG
         SPACE 3
END      DS    0H
         TIMEOUT   'END CARD PROCESSED',DCB=NO
         BAL   LINK,CKNAME         NAME FIELD MUST BE S.S. OR BLANK.
         BAL   LINK,GSCAN               SCAN OPERAND FIELD
         OI    SWTCH1,MASK7
         BAL   LINK,MCHIN1
         L     LINK,DCLSE
         NI    SWTCH7,X'FE'        IN CASE WE WERE IN COPY CODE
         OI    POMACRO,4                MAKE MACRO BAD IN COPY
         OI    POMEND,4                 MAKE MEND BAD IN COPY
         TM    SWTCH7,X'02'        CHECK IF GENERATED END.
         BCR   8,LINK              NO, GO CLOSE OUT MAINLINE DICT.
END2     TM    SWTCH5,X'80'             PROGRAMMER MACRO STATE
         BO    SEQ35                    YES,INITIALIZE OPEN CODE
END22    BAL       LINK,WRNERR
         DC    AL1(ERRR29)
         DC    AL1(ERRST)
         NI    SWTCH7,X'FD'        RESET SWITCH.
END1     L     LINK,DCLSE
         BR    LINK
         EJECT
*
DC       EQU   *
         MVI   ACALL,0                  INDICATE DC
         B     DS1
DS       EQU   *
         MVI   ACALL,1                  INDICATE DS
DS1      ST    INPTR,TEMP               SAVE LOC. OF OPERAND START
         BAL   LINK,GSCAN               SCAN ENTIRE OPERAND FIELD
         TM    SWTCH5,X'41'             NO ATTRIBUTES IF NOT OPEN
         BZ    MCHIN1                        CODE OR EXTEN PARM
         TM    NAMBYT,4                 SKIP ATTRIBUTE SCAN IF NAME
         BZ    MCHIN1                     FIELD IS NOT O.S.
         ST    INPTR,TEMP+4             SAVE LOC. OF OPERAND TERMINATOR
         TM    GSUMRY,128               NO ATRRIBUTES AVAILABLE IF ANY
         BO    MCHIN1                     B.S. IN OPERAND
         L     INPTR,TEMP               OTHERWISE, UNLEASH THE
         L     LINKR,LASCAN               ATTRIBUTE SCANNER
         BALR  LINKR,LINKR
         B     DS2                      SHUCKS
         MVC   TYPATR(5),ATYP           OH BOY -WE GOT SOMETHING
DS2      L     INPTR,TEMP+4             RESTORE INPTR AND CONTINUE
         B     MCHIN1                     NORMAL STATEMENT PROCESSING
OPSYN    L     AUXREG,OPSLOC            SET TEMPORARY BASE
         BALR  LINK,AUXREG              GO PROCESS OPSYN
         OI    SWTCH6,4                 SUPPRESS LOOKUPS
         B     ENDSMT                   CLEAN UP GOOD OPSYN
LASCAN   DC    V(ASCAN)
DCLSE    DC    V(DCLOSE)
GETAD    DC    V(GETSRC)
DLOOKUP  DC    V(LOOKUP)
ADWS     DC    V(BWFORC)
*./      DELETE    SEQ1=21780020,SEQ2=21780020
ADWS2    DC    V(BWRITE)
*
*
VCHECK   DC    V(LIBCHK)
VLREAD   DC    A(LIBRFND1)
VWAIT    DC    A(LIBWAIT)
*./      DELETE    SEQ1=21920020,SEQ2=21940020
AKLOSIT  DC    V(KLOSIT)
OPSLOC   DC    A(OPSSIN)
CCW      EQU   *
         MVC   TYPATR(3),CCW1
         B     MCHINS
CCW1     DC    AL1(WTYPE)
         DC    X'0007'
         DC    C'0'
         DS    0H
PUNCH    EQU   *
MNOTA    EQU   *
         OI    SWTCH3,MASK5             GSCAN OPND IS OF MNOTE/PUNCH
DROP     EQU   *
USING    EQU   *
PRINT    EQU   *
SPACE    EQU   *
POP      EQU   *
PUSH     EQU   *
ENTRY    EQU   *
PSODSO   EQU   *
         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL
         BAL   LINK,CKNAME              NAME FIELD S.S. OR BLANK
         B     MCHINS
CNOP     EQU   *
ORG      EQU   *
         TM    PARBYT1,EXTEN            IS EXTEN ON .Q
         BZ    PSODSO                   BRANCH IF NOT
         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL
         B     MCHINS                   GO CHECK OPERAND
EJECT    EQU   *
         OI    SWTCH8,X'80'             OPSYN NOW ILLEGAL
         BAL   LINK,CKNAME              NAME FIELD MUST BE S.S. OR BLNK
LTORG    EQU   *
         XC    SVPTR(4),SVPTR           FOOL 'EDTCMT' ROUTINE
         B     ENDSMT
*CKNAME
*        SUBROUTINE LOOKS IF NAME FIELD IS SEQUENCE SYMBOL OR BLANK
*        IF NOT, THE MESS IS WIPED UP AND A DIAGNOSTIC ISSUED
*        BAL   LINK,CKNAME
*        (RETURN)
CKNAME   TM    NAMBYT,254               RETURN IMMEDIATELY IF S.S. OR
         BCR   8,LINK                     BLANK
CKNAM1   TM    NAMBYT,255               RETURN IMMEDIATELY IF BLANK
         BCR   8,LINK
*********GENERATE DIAGNOSTIC -ILLEGAL NAME FIELD (ERASED)
CKNAM3   DS    0H
         ST    LINK,SVLNKR
         BAL   LINK,WRNERR              INDICATE NAME FIELD
         DC    AL1(ERRR7)                WAS ERASED
         DC    AL1(WRNST)
         L     LINK,SVLNKR
         ST    TEMPRG,SVLNKR
         L     TEMPRG,SAVOUT            ERASE NAME FIELD IN
         MVC   OUTPUT+10(3),OMTFLD        EDITED TEXT
         MVC   OUTPUT+13(16),1(TEMPRG)
         MVI   NAMBYT,0
         CLI   OUTPUT,X'02'             IS THIS AN AGO STMT .Q
         BE    CKNAM4                   BRANCH IF YES, DON'T DECREMENT
         LA    ETSTRT,OUTPUT+12         PERFORM CALC. TO
         SR    TEMPRG,ETSTRT            BACK UP POINTER
         SR    OUTPTR,TEMPRG              ACCORDINGLY
CKNAM4   DS    0H                       BRANCH HERE FOR AGO WITH ERROR
         L     TEMPRG,SVLNKR
         MVC   IOPNDX(1),SOPNDX
         BR    LINK
         EJECT
*./      DELETE    SEQ1=23000020,SEQ2=23740020
*ROUTINES 'WRNERR' AND 'ABSERR'
*FUNCTION- PUTS OUT A 7-BYTE ERROR RECORD.
*   WRNERR RETURNS TO CALLER.
*   ABSERR TERMINATES CURRENT STATEMENT, EXITS TO 'DRIVER' FOR NEXT.
*ENTRY POINTS-
*        BAL   LINK,X         X IS EITHER WRNERR OR ABSERR
*        DC    AL1(ERRNO)          ERRNO EQU ERROR NUMBER
*        DC    X'TT'               TT = RECORD TYPE ID
*                                       AL1(WRNST) IF WARNING MESSAGE
*                                       AL1(ERRST) IF DIAGNOSTIC
*   ALSO SEE ENTRY POINTS AT 'ERROR BRANCHES' IN CODE BELOW.
*OUTPUT- ERROR RECORD WITH FORMAT TLLA0N0-
*        T = RECORD TYPE ID
*        LL = RECORD LENGTH (INSERTED BY ENDOPR)
*        A = FLAGA = X'10'
*        N = ERROR NUMBER
*EXTERNAL ROUTINES-
*   ENDOPR- OUTPUT ERROR RECORD
*   LOOKUP- ENTER PRECEDING VAR SYMS INTO DICT.
*   GETSRC- BYPASS CONTINUATION CARDS.
*EXITS-
*   FROM WRNERR-
*        B     2(0,LINK)      RETURN TO CALLER
*   FROM ABSERR-
*        B     NDPSCN         FOR MACRO INSTRUCTION (EXITS TO DRIVER)
*        B     NDSMT0         FOR EXTRN STATEMENT   (DITTO)
*        B     DRIVER         OTHERWISE
*
*./      DELETE    SEQ1=24320020,SEQ2=24320020
WRNERR   ST    OPTR,ERRSAV              SAVE CRITICAL REG AND
         STM   LINK,R8,ERRSAV+4           OUTPUT AREA
         MVC   TMPOUT(16),OUTPUT        SAVE MSG OVERLAY AREA
         MVC   ERRBUF+5(1),0(LINK)      INSERT ERROR NUMBER
         MVC   ERRBUF(1),1(LINK)        INSERT TYPE ID
*./      DELETE    SEQ1=24440020,SEQ2=24460020
         BAL   LINK,ERROPR              OUTPUT ERROR RECORD
         L     OPTR,ERRSAV              RESTORE VALUES
         LM    LINK,R8,ERRSAV+4
         MVC   OUTPUT(16),TMPOUT        RESTORE OUTPUT AREA
         B     2(,LINK)                 AND RETURN
*
ABS000   DS    0H
         CLI   CPCUR,X'FF'              ARE WE IN A NEST .Q
         BE    ABSERR                   BRANCH IF NOT
         L     RB,LBDECBAD              GET 1ST SYSLIB DECB
         L     RA,LBDECBAD+4            GET 2ND SYSLIB DECB
         STM   RA,RB,LBDECBAD           SWAP BUFFERS BACK
*
ABSERR   MVC   ERRBUF+5(1),0(LINK)      INSERT ERROR NUMBER
         MVC   ERRBUF(1),1(LINK)        INSERT TYPE ID
*./      DELETE    SEQ1=24640020,SEQ2=24660020
         TM        SWTCH1,MASK3        TEST IF PROTO
         BZ        ABS003              BR IF NOT
         OI        SWTCH5,X'04'        INDICATE SKIP TO MEND
         NI    SWTCH1,NMASK3            RESET PROTOTYPE EXPECTED SWITCH
ABS003   L     B2,USING1                RESTORE B2 AS 2ND BASE REG
         NI    SWTCH7,X'7F'             RESET PROC. SUBLIST SWITCH
*./      DELETE    SEQ1=24800020,SEQ2=24800020
         BAL   LINK,ERROPR              OUTPUT ERROR RECORD
*        CLEAN UP
         TM    SWTCH4,2                 M-I BEING PROCESSED
         BO    NDPSCN                   FINISHING TOUCH ON M-I
         MVC   OPNDX(1),SOPNDX          BACK UP OPNDX
         CLC   OUTPUT+4(2),EXTOP        WAS OP CODE 'EXTRN' .Q
         BE    ABS002                   BIF YES
         CLI   GCALL,1                  WAS THIS GBLX OR LCLX .Q
         BNE   ABS001                   BIF NO
         CLI   OPNDX,0                  ANYTHING IN 'OPNDL' .Q
         BE    ABS001                   BIF NO
         LA    TEMPRG,ABS001            YES, SO ENTER VAR SYMS IN DICT
         B     LOOKP                    UP TO POINT OF ERROR.
EXTOP    DC    X'861A'                  R1 MASK AND OP-CODE FOR EXTRN
ABS002   LA    OPTR,OUTPUT+10           WRITE OUT STMT UP TO POINT OF
         B     NDSMT0                     ERROR
ABS001   L     LINK,GETAD               BYPASS
         BALR  LINK,LINK                ANY CONTINUATION
         DC    AL2(6)                   CARDS.
         B     DRIVER                   GET NEXT STATEMENT
ERRBUF   DC    X'0D000010010000'        ERROR RECORD MASK
ERROR78  DC    X'0D000010014E00'        ERROR 78 RECORD
*./      DELETE    SEQ1=25240020,SEQ2=25260020
*
*          ERROR BRANCHES
*
ILTERM   BAL   LINK,ABSERR              ILLEGAL TERMINATOR
         DC    AL1(ERRR1)
         DC    AL1(ERRST)
*./      DELETE    SEQ1=25400020,SEQ2=25440020
ILNORK   BAL   LINK,ABSERR              ILLEGAL USAGE OF N' OR K'
         DC    AL1(ERRR14)
         DC    AL1(ERRST)
ILSYSL   BAL   LINK,ABSERR              INVALID USAGE OF SYSLIST
         DC    AL1(ERRR13)
         DC    AL1(ERRST)
NOBAL    BAL   LINK,ABSERR              UNBALANCED PARENTHESES
         DC    AL1(ERRR21)
         DC    AL1(ERRST)
ILOP     TM    SWTCH1,X'10'             IS PROTO EXPECTED SW ON
         BO    BDPROT                   YES, GO LOG BAD PROTO ERR
         BAL   LINK,ABSERR              ILLEGAL OP-CODE
         DC    AL1(ERRR39)
         DC    AL1(ERRST)
INVSUB   BAL   LINK,ABSERR              INVALID SUBSCRIPT
         DC    AL1(ERRR41)
         DC    AL1(ERRST)
ILSDTF   BAL   LINK,ABSERR              BAD SELF DEFINING TERM
         DC    AL1(ERRR42)
         DC    AL1(ERRST)
ILVSF    BAL   LINK,ABSERR              INVALID FORMAT FOR V.S.
         DC    AL1(ERRR43)
         DC    AL1(ERRST)
ILSSNF   BAL   LINK,ABSERR              SET NAME FIELD NOT A V.S.
         DC    AL1(ERRR44)
         DC    AL1(ERRST)
STCPEX   BAL   LINK,ABSERR              STATEMENT COMPLEXITY EXCEEDED
         DC    AL1(ERRR45)
         DC    AL1(ERRST)
ILNAM    BAL   LINK,ABSERR              INVALID NAME FIELD
         DC    AL1(ERRR2)
         DC    AL1(ERRST)
ILPROT   BAL   LINK,ABSERR              BAD PROTOTYPE FORMAT
         DC    AL1(ERRR46)
         DC    AL1(ERRST)
         EJECT
*
* PROCESS NON-NORMAL SYMBOL IN OPERATION FIELD
*
NONNOR   TM    SWTCH1,MASK3             TEST IF PROTO EXPECTED
         BO    BDPROT                   SHOULD HAVE BEEN PROTOTYPE
         TM    OPBYTE,128               ELSE ONLY VAR SYM ALLOWED
         BZ    ILOP
         BAL   AUXREG,SMTSQ1            FOR VALID STATEMENT HERE
         B     TESTOV                   PROCESS OPERAND AND COMMENTS
*
*
* CLOSED ROUTINE TO SKIP BLANKS
*
SKPBLK   DS        0H
         LA        1,FINBLANK          POINT AT TRT TABLE FOR BLANKS
         LR        0,2                 SAVE REGISTER TWO
         TRT       0(256,INPTR),0(1)   STOP ON FIRST NON-BLANK
         LR        2,0                 RESTORE REGISTER TWO
         LR        INPTR,1             SET RESULTING POINTER
         BR        LINK                AND RETURN
         EJECT
*
*        ERROR INTERFACE TO ENDOPR
*
*        OUTPUT WARNING MESSAGE IF THIS IS FIRST DIAGNOSTIC WHILE
*          EDITING MACROS
*
ERROPR   OI        SWTCH6,4            SUPPRESS LOOKUPS IN ENDOPR
         MVC       OUTPUT(7),ERRBUF    MOVE THE ERROR RECORD
         LA        OPTR,OUTPUT+6       POINT AT RECORD END FOR ENDOPR
         TM        SWTCH8,X'40'        1ST ERROR AFTER END CARD .Q
         BZ        ENDOPR              NO, NORMAL
         MVC       OUTPUT(7),ERROR78   PLACE WARNING ERROR RECORD
         MVI       NDERRBC1+1,X'F0'    FORCE ONTO UT3
         B         ENDOPR              GO AND OUTPUT THE ERRORS
         EJECT
*ROUTINE 'ENDOPR'
*FUNCTION- WRITES OUT EDITED RECORDS FROM OUTPUT BUFFER WHEN END OF
*   OPERAND OR STATEMENT IS ENCOUNTERED.
*   WRITES ON UT3 IF IN OPEN CODE, OR IF RECORD IS A WARNING MESSAGE
*   DURING A MACRO DEFN.
*   WRITES MACRO DEFNS ON UT1.
*   WRITES ERROR MESSAGES ON BOTH UT1 AND UT3 DURING MACRO DEFNS.
*   GETS NOTE/POINT DATA BEFORE EACH WRITE ON UT1.
*   MAKES ALL REMAINING DICTIONARY ENTRIES FROM OPNDL LIST, UNLESS
*   SUPPRESSED.
*   ('WRITE' MEANS MOVE TO I/O OUTPUT BUFFER)
*ENTRY POINTS-
*        BAL   LINK,NDOPR0    INSERT END-OF-STATEMENT FLAG IN OUTPUT
*                             BUFFER, GO TO ENDOPR.
*        BAL   LINK,ENDOPR    IF OPERAND IS IN A SUBLIST, RETURN TO
*                             CALLER IMMEDIATELY, ELSE GO TO NDSMT3.
*        BAL   LINK,NDOPR1    (EQUATED TO ENDOPR)
*        B     ENDSMT         EDIT COMMENTS TO OUTPUT BUFFER, GO TO
*                             NDSMT0.
*        B     NDSMT0         INSERT END-OF-STMT FLAG, GO TO NDSMT3.
*        B     NDSMT3         PERFORM FUNCTIONS DESCRIBED ABOVE.
*INPUT- EDITED RECORDS IN OUTPUT BUFFER.
*   SWITCH 'SWTCH6' BIT 5 = 0, PERMITS DICT ENTRIES FROM OPNDL LIST,
*                           1, SUPPRESSES SAME.
*EXTERNAL ROUTINES-
*   EDTCMT- EDITS COMMENTS TO OUTPUT BUFFER.
*   BWFORC- FORCE ROOM IN I/O OUTPUT BUFFER.
*   BWNOTE- GET NOTE/POINT DATA.
*   LOOKUP- MAKE DICTIONARY ENTRIES FROM OPNDL LIST.
*   BWRITE- MOVE RECORDS TO I/O OUTPUT BUFFER.
*EXITS-
*   IF ENTRY IS NDOPR0, ENDOPR, OR NDOPR1-
*        BR    LINK           RETURN TO CALLER.
*   OTHERWISE-
*        B     DRIVER         EXIT TO 'DRIVER' FOR NEXT STATEMENT.
*
NDOPR0   MVI   0(OUTPTR),X'FF'          SET END OF STATEMENT FLAG
NDOPR1   EQU   *
ENDOPR   EQU   *
         ST    LINK,SAVEM               SAVE FOR RETURN
         TM    SWTCH7,128
         BO    NOPUT                    PROCESSING SUBLIST
         OI    SWTCH1,MASK7             INDICATE RETURN TO CALLER
         B     NDSMT3
*        EXIT- NO OUTPUT
NOPUT    L     OPTR,INTOPT
         MVC   OPNDX(1),SOPNDX          RESTORE OPNDX
         BR    LINK                     QUICK RETURN
*
ENDSMT   ST    LINK,SAVEM
         BAL   R2,EDTCMT                EDIT COMMENTS
*
NDSMT0   MVI   0(OUTPTR),X'FF'          SET END OF STATEMENT FLAG
NDSMT3   S     OUTPTR,OBUFS             COMPUTE RECORD LENGTH TO BE
         LA    RQ,1(0,OUTPTR)           INSERTED IN FRONT OF RECORD
         STH   RQ,RLIHLF                  AND CALL TO BWFORCE
NDERR0   LA    RA,8                     WRITE ON UT3 IF OUTSIDE A MACRO
         TM    SWTCH1,64                TEST IF IN MACRO DEFN
NDERRBC1 BC        *-*+8,NDSMT6        BR NO USUALLY  (BZ OR BR SW)
         CLI   OUTPUT,ERRST             IS THIS AN ERROR RECORD .Q
         BNE   NDSMT7                   BIF NO
         CLI   OUTPUT+3,X'30'           IS IT A COMMENT .Q
         BE    NDSMT7                   BIF YES
         CLI   OUTPUT,X'08'             IS A SOURCE RECORD PRESENT .Q
         BE    NDSMT6                   BIF YES -ASSUME A WARNING MSGE.
NDSMT7   DS    0H
         SR    RA,RA                    OTHERWISE ON UT1
         B     NDSMT8                   GO DO IT
NDSMT6   DS    0H
         TM    SWTCH1,X'40'             IN A MACRO .Q
         BZ    NDSMT8                   BRANCH IF NOT
         TM    SWTCH5,X'20'             IN A SYSTEM MACRO TOO .Q
         BZ    NDSMT8                   BRANCH IF NOT
         TM    SWTCH8,X'40'             IS THIS ERROR 78 .Q
         BO    NDSMT8                   BRANCH IF YES
         TM    PARBYT1,FLIST            FULLLIST OPTION SPECIFIED .Q
         BO    NDSMT8                   NO EXTRA ERROR RECORDS IF SO
         CLC   DUMCMNT+L'DUMCMNT-8(8),MACNAME  SAME MACRO AS LAST .Q
         BE    NDSMT8                   YES, DON'T BOTHER WITH MESSAGE
         MVC   DUMCMNT+L'DUMCMNT-8(8),MACNAME  SET NEW MACRO NAME
         LA    RQ,L'DUMCMNT             ERROR COMMENT LENGTH
         L     RR0,ADWS                 GET BWFORCE ADDRESS
         BALR  RR0,RR0                  BWFORCE
         LA    RQ,DUMCMNT               POINT TO COMMENT
         L     RR0,ADWS2                GET BWRITE ADDRESS
         BALR  RR0,RR0                  BWRITE
         LH    RQ,RLIHLF                RESTORE RECORD LENGTH
NDSMT8   DS    0H
         ST    RA,TEMP                  SAVE FILE NO.
         TM    SWTCH1,X'40'             IN A MACRO .Q
         BZ    NDSMT9                   BRANCH IF NOT
         CLI   OUTPUT,ERRST             IS THIS AN ERROR RECORD .Q
         BNE   NDSMT9                   THEN DON'T OUTPUT SOURCE STMT
         TM    SWTCH8,X'40'             IS THIS ERROR 78 .Q
         BO    NDSMT9                   BRANCH IF YES
         TM    PARBYT1,FLIST            WAS FULLLIST SPECIFIED .Q
         BO    NDSMT9                   FORGET EXTRA ERROR STMT IF SO
         LTR   RA,RA                    WRITING A MACRO DEF'N .Q
         BNZ   NDSMT1                   BRANCH IF NOT
         TM    SWTCH5,X'10'             ARE GLOBALS STILL ALLOWED .Q
         BZ    NDSMT9                   BRANCH OUT IF YES
NDSMT1   DS    0H
         TM    SWTCH5,X'80'             IN A PROGRAMMER MACRO .Q
         BNO   NDSMT2                   BRANCH IF NOT
         LTR   RA,RA                    WRITING MACRO DEFINITION .Q
         BNZ   NDSMT9                   BRANCH IF NOT
NDSMT2   DS    0H
         LA    RQ,75                    GET FLAGS/SOURCE LENGTH-1
         L     RR0,ADWS                 GET BWFORCE ADDRESS
         BALR  RR0,RR0                  BWFORCE
         L     LINK,SRCBUF              RETAIN SOURCE RECORD FLAGS
         MVC   SRCBUF(4),COMPREF        MOVE SOURCE COMMENT FLAGS
         LA    RQ,SRCBUF                RECORD TO BE WRITTEN
         L     RR0,ADWS2                GET BWRITE ADDRESS
         BALR  RR0,RR0                  BWRITE
         ST    LINK,SRCBUF              RESTORE SOURCE RECORD FLAGS
         LH    RQ,RLIHLF                RESTORE BLKSIZE FOR BWFORCE
NDSMT9   DS    0H
         L     RR0,ADWS                 GET BWFORCE ADDRESS
         BALR  RR0,RR0                  BWFORCE
         CLI       TEMP+3,0             NOTE IF WRITING UT1
         BNZ   NDSMT4                   BR NO
*./      DELETE    SEQ1=27940020,SEQ2=27960020
         MVC   STNOTE(6),BWBLKS+BWFNOT  SAVE NOTE
NDSMT4   LA    TEMPRG,NDSMT5            SET RETURN FROM 'LOOKUP'
         TM    SWTCH6,4                 DICT ENTRIES SUPPRESSED .Q
         BZ    LOOKP                    NO- GO DO IT
NDSMT5   NI    SWTCH6,251               RESET 'SUPPRESS' INDIC
         MVC   OUTPUT+1(2),RLIHLF       INSERT RECORD LENGTH
         L     RA,TEMP                  'WRITE' (I.E. MOVE) EDITED TEXT
         LA    RQ,OUTPUT                  RECORD TO OUTPUT BLOCK
         L     RR0,ADWS2
         BALR  RR0,RR0                   BWRITE
         CLI   OUTPUT,X'0D'             IS AN ERROR RECORD PRESENT .Q
         BNE   NOOUT                    EXIT IF NO
         LH    RQ,RLIHLF                RESTORE BLOCKSIZE FOR BWFORC.
         TM        SWTCH8,X'40'        TEST IF ERROR 78 JUST OUTPUT
         BZ        NDERR1
         MVI       NDERRBC1+1,X'80'    RESTORE MUTILATED BE
         NI        SWTCH8,X'FF'-X'40'  TURN OFF ONE-TIME SWITCH
         OI        SWTCH6,X'04'        KEEP THOSE LOOKUPS SUPPRESSED
         MVC       OUTPUT(7),ERRBUF    RE-MOVE IN THE ORIGINAL ERROR
         B         NDERR0              GO OUTPUT IT
NDERR1   TM    SWTCH1,MASK1             ARE WE IN A MACRO .Q
         BZ    NOOUT                    EXIT IF NO
         CLI   TEMP+3,8                 DID WE JUST WRITE ON UT3 .Q
         BE    NOOUT                    BIF YES, (WROTE ON UT3 BEFORE)
         LA    RA,8                     NO, SO WRITE OUT SAME ERROR
*./      DELETE    SEQ1=28320020,SEQ2=28320020
         OI    SWTCH6,4                 DO NOT GO TO LOOKUP ON ERRORS
         B     NDSMT6                   MESSAGE ON UT3 FOR ALL MACROS
COMPREF  DC    X'08004B30'              SOURCE COMMENT FLAGS
* EXIT
NOOUT    EQU   *
         TM    SWTCH1,MASK7             TEST IF RETURN TO CALLER
         BZ    DRIVER                   NO- EXIT TO DRIVER
         NI    SWTCH1,NMASK7            RESET EXIT INDIC
         LA    OUTPTR,OUTPUT+10
         L     LINK,SAVEM               RETURN TO CALLER
         BR    LINK
RLIHLF   DS    H
         EJECT
*SMTSEQ
*        SUBROUTINE TO CHECK STATEMENT SEQUENCING AND TO INITIALIZE
*        OPEN CODE PROCESSING
*        ENTRY POINT SMTSEQ IS FOR PSEUDO-OPS ONLY (INTERNAL OP-CODE
*        IN ZERORG)
*        EVERYBODY ELSE HAS TO ENTER BY WAY OF SMTSQ1
*        BAL   AUXREG,SMTSEQ       OR        BAL   AUXREG,SMTSQ1
*        (LIKELY RETURN)                     (LIKELY RETURN)
*
SMTSQ1   LA    ZERORG,41                DUMMY IT UP
SMTSEQ   DS    0H
         IC    RQ,POBYTE(ZERORG)        INITIALIZE SWITCH BYTE
         STC   RQ,PSOPSW
         TM    SWTCH5,X'02'             SKIPPING TO END .Q
         BZ    SEQ02                    BIF NO
         TM    PSOPSW,X'80'             YES - IS THIS AN END CARD .Q
         BZ    DRIVER                   BIF NO
         L     B2,DCLOS1AD              YES -LOAD BASE FOR BRANCH
         L     LINK,AKLOSIT             TO ABORT
         BR    LINK                     ASSEMBLY.
SEQ02    TM    SWTCH5,X'04'             SKIPPING TO MEND .Q
         BZ    SEQ05                    BIF NO
         TM    PSOPSW,X'80'             YES -IS THIS AN END CARD .Q
         BO    SEQ04                    BIF YES
         TM    PSOPSW,X'40'             IS THIS A MEND CARD .Q
         BZ    ABS001                   BIF NO
         TM        SWTCH6,2            WILL DICT BE SUBSET .Q
         BZ        MEND2     NO, RESET OUTPUT BUFFER & CLOSE OUT DEFN
         B         MEND1                YES- PROCESS MEND
SEQ04    BAL       LINK,WRNERR         GO LOG ERROR
         DC        AL1(ERRR33)         END CARD IN MACRO
         DC        AL1(ERRST)          CLOSE OUT DEFINITION
         B         END1                CLOSE OUT PHASE
SEQ05    TM    SWTCH7,X'01'             ARE WE WITHIN COPY CODE.....
         BZ    SEQ10                    NO
         TM    PSOPSW,4                 YES -IS OP LEGAL IN COPY.....
         BO    SEQ08                    ERROR IF NOT
         TM    SWTCH5,X'20'             WITHIN SYSTEM MACRO DEFN .Q
         BZ    SEQ10                    BRANCH IF NOT
         TM    PSOPSW,X'60'             IS THIS A MACRO/MEND OP .Q
         BZ    SEQ10                    OK IF NOT
******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN COPY
SEQ08    DS    0H
         BAL   LINK,ABSERR
         DC    AL1(ERRR30)
         DC    AL1(ERRST)
********
SEQ10    TM    SWTCH1,64                ARE WE WITHIN A MACRO.....
         BZ    SEQ20                    NO
         TM    PSOPSW,2                 YES -IS OP LEGAL IN MACROS.....
         BZ    SEQ50                    YES
         TM    SWTCH5,32                NO -IS THIS A SYSTEM MACRO.....
         BO    SEQ30               YES
         TM    PSOPSW,128               NO -IS THIS END.....
         BO    OMY                 WELL,WELL - AN END CARD
         L     LINK,GETAD               GET PAST ANY
         BALR  LINK,LINK                   CONTINUATION CARDS
         DC    AL2(6)
******** GENERATE DIAGNOSTIC -OP ILLEGAL IN MACRO DEFINITIONS
********
         BAL   LINK,ABSERR
         DC    AL1(ERRR31)
         DC    AL1(ERRST)
SEQ20    TM    SWTCH5,128               PROCESSING PROGRAMMER MACROS...
         BZ    SEQ25                    NO
         CLI   NAMBYT,1                 YES -IF NAME FIELD IS S.S.
         BE    SEQ34                      GENERATE DIAGNOSTIC
         TM    PSOPSW,1                 IF OP IS LEGAL BETWEEN MACROS
         BCR   1,AUXREG                   EXIT
         B     SEQ35                    OTHERWISE, INITIALIZE MAIN-LINE
SEQ25    TM    SWTCH6,64                EXPECTING MACRO PSEUDO-OP.....
         BZ    SEQ40                    NO
         TM    PSOPSW,32                YES -IS THAT WHAT WE GOT.....
         BNZ       SEQ26               YES-
         OI        SWTCH5,X'04'        NO-MACRO ABORT ON
         NI        SWTCH6,X'FD'        SUBSET INDICATOR OFF
         B         END1                TO CLOSE OUT DICTIONARY
SEQ26    NI        SWTCH6,X'BF'        TURN OFF INDICATOR.
         BR    AUXREG                     AND EXIT
******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN SYSTEM MACRO
SEQ30    L     LINK,GETAD
         BALR  LINK,LINK           SKIP ANY CONTINUATION CARDS.
         DC    AL2(6)
         BAL   LINK,ABSERR
         DC    AL1(ERRR32)
         DC    AL1(ERRST)
OMY      DS    0H
         BAL   LINK,WRNERR
         DC    AL1(ERRR33)
         DC    AL1(ERRST)
*./      DELETE    SEQ1=30120020,SEQ2=30120020
         B     SEQ35
******** GENERATE DIAGNOSTIC -MEANINGLESS SEQUENCE SYMBOL -ERASED
********
SEQ34    BAL   LINK,CKNAM3
         CLI   OUTPUT+5,X'0B'           IS OPERATION ANOP .Q
         BNE   *+8                      BIF NO
         MVI   NAMBYT,1                 YES -FOOL ANOP, S.S. PRESENT
********
******** INITIALIZATION FOR OPEN CODE PROCESSING
SEQ35    XI    SWTCH5,192               FLIP INDICATORS
         TIMEOUT   'OPEN CODE STARTED ',DCB=NO
         L     LINK,HISTRY+8            ENTER A DUMMY ENTRY INTO BLOCK
         MVC   4(5,LINK),F1+1           ZERO OF THE OPEN CODE DICT-
         LA    LINK,9                   IONARY AND UP THE INDICES
         ST    LINK,VCR                 ACCORDINGLY. THIS IS NEC. DUE
         ST    LINK,TNDX                TO BLOCK NO. SEARCH ALGORITHM.
         TM    SWTCH7,X'02'             END CARD GENERATED
         BO    END22                    YES CONTINUE END PROCESSING
******** OF COURSE THERE'S MORE TO BE ADDED
SEQ40    TM    PSOPSW,16                IS OP MEXIT,MNOTE,MEND.....
         BO    SEQ45                    YES -A GOOF
         TM    PSOPSW,32                NO -IS OP MACRO.....
         BZ    SEQ50                    NO
SEQ45    L     LINK,GETAD               GET PAST ANY
         BALR  LINK,LINK                   CONTINUATION CARDS
         DC    AL2(6)
******** GENERATE DIAGNOSTIC -ILLEGAL STATEMENT IN OPEN CODE
         BAL   LINK,ABSERR
         DC    AL1(ERRR34)
         DC    AL1(ERRST)
********
SEQ50    TM    OUTPUT+4,MASK0           IS OP A PSEUDO-OP .Q
         BZ    SEQ52                    BIF NO
         TM    PSOPSW,8                 IS OP GBLX,LCLX.....
         BCR   1,AUXREG                 YES -EXIT
         CLI   OUTPUT+5,X'0C'           NO.. IS OP COPY
         BCR   8,AUXREG                 ALLOW COPY BEFORE DECLARATIONS
         CLI   OUTPUT+5,X'25'      IS OP ACTR.
         BE    SEQ55               YES -
         CLI   OUTPUT+5,X'2D'           NO.. IS OP OPSYN
         BCR   8,AUXREG                 ALLOW OPSYN BEFORE DECLNS
SEQ52    DS    0H
         TM    SWTCH5,X'01'             IS EXTEN ON .Q
         BO    SEQ53                    YES, BRANCH AROUND
         TM    SWTCH1,X'40'             ARE WE IN A MACRO .Q
         BO    SEQ54                    YES, DISABLE DECLARATIONS
SEQ53    DS    0H
         CLI   PSOPSW,X'01'             EJECT,PRINT,SPACE OR TITLE .Q
         BCR   8,AUXREG                 RETURN IF SO
SEQ54    DS    0H
         OI    SWTCH5,X'18'             DISABLE GBLX,LCLX AND ACTR
         BR    AUXREG                     AND EXIT
SEQ55    TM    SWTCH5,X'08'        IF LCLX HAS BEEN DISALLOWED,
         BZ    SEQ52
         B     DCL05               THIS ACTR IS OUT OF ORDER.
*./      DELETE    SEQ1=32100025,SEQ2=32110025
         EJECT
*
*EDTCMT
*        PROCESS COMMENTS FIELD TO EDITED TEXT
*        BAL   R2,EDTCMT
*        (RETURN)
EDTCMT   L     R1,SVPTR                 TEST IF TERMINAL CHARACTER
         LTR   R1,R1                      STRING EXISTS IN OPERAND
         BNE   EDT01                      FIELD
         MVC   0(2,OPTR),TRMOPN         NO, CREATE ONE
         LR    R1,OPTR
         LA    OPTR,2(0,OPTR)
EDT01    MVC   0(2,OPTR),TRMOPN+2       SET TERMINAL BLANK PLUS END OF
         IC    RB,1(0,R1)                 FIELD FLAG AFTER EDITED
         LA    RB,1(0,RB)                 OPERAND, THEN INCREASE STRING
         STC   RB,1(0,R1)                 LENGTH BY ONE AND ADJUST
         LA    OPTR,2(0,OPTR)             OUTPUT POINTER
         TM    GSUMRY,128               IF EDITTED OPERAND CONTAINS NO
         BO    EDT03                    VARIABLE SYMBOLS, CHANGE
         MVI   0(R1),SPUT               EDITED TEXT TO PUT STRING
EDT03    MVC   0(3,OPTR),OMTFLD         ASSUME NO COMMENTS
         LA    OPTR,3(0,OPTR)
         BAL   LINK,SKPBLK              SPACE TO START OF COMMENTS
         OC    OPBYTE(1),NAMBYT         IF ANY SUBSTITUTION IN
         OC    GSUMRY(1),OPBYTE           STATEMENT, SET PRINT IND. IN
         TM    GSUMRY,128                 EDITED TEXT RECORD
         BZ    EDT03A                   BRANCH IF NO SUBSTITUTION
         OI    OUTPUT+3,X'20'
         B     EDT04                    GO PROCESS THE COMMENT
EDT03A   TM    SWTCH5,X'40'             ARE WE IN OPEN CODE .Q
         BCR   1,R2                     (BOR) YES, FORGET COMMENT
EDT04    LR    INPTR1,INPTR
         L     INPTR,ENDCOL
         CR    INPTR1,INPTR             EXIT IF NO COMMENTS
         BCR   2,R2
         BCTR  INPTR1,0                 DECREMENT COMMENT POINTER
         L     R1,CALIGN                GET USERS OFFSET
         S     R1,F1                    DECREMENT BY ONE
         BNM   EDT04A                   BRANCH IF SOME VALID OFFSET
         LA    R1,1(,INPTR1)            ACTUAL COMMENT START ADDR
         S     R1,INPUT                 LESS START OF CARD(S)
EDT04A   DS    0H
         STC   R1,0(,INPTR1)            PREFACE COMMENT WITH ITS OFFSET
         S     OPTR,F3                  BACKUP OUTPUT FOR COMMENT E.T.
EDT05    CLI   0(INPTR),BLANK           DELIMIT COMMENTS FIELD FROM
         BNE   EDT10                      THE RIGHT
         BCT   INPTR,EDT05
EDT10    LA    INPTR,1(0,INPTR)         OUPUT COMMENTS
         BAL   R1,PUTSTR
         L     R1,SVPTR                 REPLACE CHARACTER EXPRESSION
         MVI   0(R1),SPUT                 FLAG BY PUT FLAG
         BAL   R1,PUTPUT+4              SET END OF FIELD FLAG IN TEXT
         DC    AL2(ENDFLD)
         BR    R2                       RETURN
*GETCMT
*        COLLECTS CONTINUATION CARDS FOR A COMMENTS STATEMENT AND
*        CHECKS THAT STATEMENT IS NOT BETWEEN MACRO AND PROTOTYPE
*
*        BAL   AUXREG,GETCMT
*        (RETURN)
GETCMT   L     LINK,GETAD
         BALR  LINK,LINK                BR TO GETSRC
         DC    AL2(2)                   (FOR GTSRC1 ENTRY)
         TM    SWTCH1,16
         BCR   8,AUXREG
*./      DELETE    SEQ1=33200020,SEQ2=33200020
*
BDPROT   BAL   LINK,ABSERR              BAD PROTOTYPE
         DC    AL1(ERRR20)
         DC    AL1(ERRST)
*ISITFF
*        FOR MACROS AND PROTOS. TRIES TO GET CONTINUATION IF END OF
*        CARD HAS BEEN REACHED.
ISITFF   OI    SWTCH4,2                 M-I BEING PROCESSED
         CLI   0(INPTRS),X'FF'          TEST FOR END OF CARD
         BCR   7,AUXREG                 (BNE) RETURN IF NOT
         L     LINK,GETAD               BR TO GETSRC FOR ONE
         BALR  LINK,LINK                  CONTINUATION CARD
         DC    AL2(4)
         CLI   0(INPTRS),X'FF'          SEE IF ANY WAS THERE
         BCR   7,AUXREG                 (BNE) RETURN IF YES
         BCTR  INPTRS,AUXREG            ELSE BACK UP POINTER, RTRN
*./      DELETE    SEQ1=33480020,SEQ2=33760020
         EJECT
*        REGISTER ASSIGNMENTS
R1       EQU   6
R2       EQU   7
R3       EQU   8                        MUST BE EVEN
R3A      EQU   R3+1                     EVEN-ODD REGISTER PAIR
R4       EQU   4
RREG     EQU   10                       RSTACK INDEX REG
LINKR    EQU   10
STPTR    EQU   5
INPTR1   EQU   STPTR
*
*        SAM'S TEXT FLAG CODES
SRPAR    EQU   1                        R-PAREN
SUBSLP   EQU   3                        SUBSCRIPT L-PAREN TEXT FLAG
SEQ      EQU   8
SNE      EQU   9
SLT      EQU   10
SGT      EQU   11
SLE      EQU   12
SGE      EQU   13
SNOT     EQU   14
SOR      EQU   15
SAND     EQU   16
*        (NOTE.  'S.D.T.' = 'SELF-DEFINING TERM')
SXSDT    EQU   34                       X.S.D.T. FLAG
SBSDT    EQU   35                       B.S.D.T. FLAG
SDSDT    EQU   36                       D.S.D.T. FLAG
SCSDT    EQU   37                       C.S.D.T. FLAG
SNULL    EQU   38                       NULL FLAG
*./      DELETE    SEQ1=34380020,SEQ2=34380020
SSETA    EQU   40                       SETA FLAG
SSETB    EQU   41                       SETB FLAG
SSETC    EQU   42                       SETC FLAG
SCOMMA   EQU   43
SSUBST   EQU   44                       SUBSTRING FLAG
SUBOPE   EQU   45                       SUBSTRING SUBSCRIPT L-PAREN
SUBCOM   EQU   46                       SUBSTRING SUBSCRIPT COMMA
SUBCLS   EQU   47                       SUBSTRING SUBSCRIPT R-PAREN
SARE     EQU   49                       A.R.E. FLAG
STATTR   EQU   51
SLATTR   EQU   52
SIATTR   EQU   53
SSATTR   EQU   54
*./      DELETE    SEQ1=34660020,SEQ2=34660020
SKATTR   EQU   56
SSPAR    EQU   57                       SYMBOLIC PARAMETER FLAG
SYSLST   EQU   58                       SYSLIST FLAG
SSYMB    EQU   250                      ORDINARY SYMBOL FLAG
*./      DELETE    SEQ1=34780025,SEQ2=35880025
         EJECT
*METSCN
*        AN INTERPRETIVE SCANNER FOR SETA, SETB AND SETC OPERANDS
*        CALLING SEQUENCE   -ENTRY CODE PRESET IN CELL MCALL
*        BAL   LINK,METSCN  128=SETA, 64=SETC, 0=WHAT-IS-IT
*        IF CONTROL EVER RETURNS HERE, REGISTER R3 CONTAINS EXIT CODE
*              =1  ENTRY CODE WAS 0 AND A VARIABLE SYMBOL WAS READ
*              =2  ENTRY CODE WAS 0 AND A SETB EXPRESSION WAS READ
*              =3  A SETA EXPRESSION WAS READ
*              =4  A SETC EXPRESSION WAS READ
*
METSCN   BAL   R1,ENTER                 CREATE RECURSION STACK ENTRY
         MVC   0(1,RREG),MCALL          SET UP FLAG BYTE
         LH    STPTR,MH1
*        TRANSITION TO NEW STATE
MS05     LA    STPTR,1(0,STPTR)         ADVANCE STPTR
MS10     L         R1,S1AD             POINT AT TRANSITION TABLE
         LA    R1,0(STPTR,R1)           CONVERT TO ABSOLUTE ADDRESS
         TM    0(R1),255                TEST FLAG BYTE
         BO    MS30                     PROCESS FOLLOWING ACTION LIST
         BM    MS15                     TEST SYNTACTIC CATEGORY
         BAL   LINK,TRTEST              TRANSLATE AND TEST STRING
         B     MS05                      AT INPTR
*        TEST IF TRT CATEGORY ADMISSIBLE FOR THIS PATH
MS15     IC    R3A,0(0,R1)              ISOLATE CATEGORY OF CURRENT
         N     R3A,F15                    ACTION LIST
         CR    R3A,2                    COMPARE AGAINST TRTEST CATEGORY
         BE    MS30                     SAME -EXECUTE ACTION LIST
*        TRY NEXT PATH
         IC    R3A,0(0,R1)              ISOLATE LENGTH OF CURRENT
         SRL   R3A,4                      ACTION LIST
         LA    STPTR,0(R3A,STPTR)       ADD TO STPTR AND THERE WE ARE
         B     MS10
*        EXECUTE PATH ACTION LIST
MS30     LA    STPTR,1(0,STPTR)         ADVANCE STPTR
MS35     L     R1,S1AD                  POINT AT TRANSITION TABLE
         IC    R3A,0(STPTR,R1)          ISOLATE ACTION NUMBER FOR A
         N     R3A,F31                    COMPUTED GO TO
         AR    R3A,R3A
         L         R1,MS40AD
         LH    R1,0(R3A,R1)
         B     USEBAS(R1)
MS40AD   DC        A(MS40-2)
*./      DELETE    SEQ1=36680020,SEQ2=37120020
S1AD     DC        A(S1)
*./      DELETE    SEQ1=37160020,SEQ2=41280020
TCOMP    EQU   MS05
         EJECT
*        RECURSIVE CALL TO METSCN BECAUSE OF LEFT PARENTHESIS
CSETBA   MVI   MCALL,128                SET ARITHMETIC ENTRY CODE
         B     CT10
CSETBE   MVC   MCALL(1),0(RREG)         SET ENTRY CODE SAME AS FOR
         NI    MCALL,128                  CURRENT LEVEL
         MVC   4(1,RREG),OPNDX          (FOR POSSIBLE MBOOL ACTION)
CT10     BAL   R1,APARCT                INCREMENT PARENTHESIS COUNT
         BAL   R1,PUTR3                 PUT L-PAREN IN TEXT
         BAL   LINK,METSCN
         CLI   0(INPTR),RPAREN          TEST TERMINATOR
         BNE   ILXPR                     MUST BE R-PAREN
         BAL   R1,DPARCT                DECREMENT PARENTHESIS COUNT
         BAL   R1,PUTPUT                PUT R-PAREN IN TEXT
         DC    AL2(SRPAR)
         AR    STPTR,R3                 EXECUTE TRANSITION TO STATE
         BCT   STPTR,NSTPTR               DEPENDENT ON METSCN EXIT CODE
*        IF ARITHMETIC ENTRY, EXECUTE IMMEDIATE STATE TRANSITION
TRANSA   TM    0(RREG),128
         B     TRANSC+4
*        IF C-EXPRESSION ENTRY, EXECUTE IMMEDIATE STATE TRANSITION
TRANSC   TM    0(RREG),64
         BO    NSTPTR
TRA1     LA    STPTR,2(0,STPTR)
         B     MS35                     RETURN TO ACTION PROCESSOR
*        IF BLANK AT INPTR, EXECUTE IMMEDIATE STATE TRANSITION
TBLANK   CLI   0(INPTR),BLANK
         BNE   TRA1
*        NON-SIGNIFICANT BLANK GOBBLER
SBLANK   LA    R3,1
         L     R3A,ENDCOL
         OI    0(RREG),32               MARK THE DIAGRAM COMPLEX
SL05     CLI   0(INPTR),BLANK
         BNE   NSTPTR
         BXLE  INPTR,R3,SL05
*        EXECUTE TRANSITION TO INDICATED STATE
NSTPTR   L         R1,S1AD             POINT AT THE TRANSITION TABLE
         IC    STPTR,1(STPTR,R1)
         B     MS10                     RETURN TO INTERPRETER
*        PROCESS VARIABLE SYMBOL
VSYMRK   MVC   4(1,RREG),OPNDX          SAVE OPNDX IN RSTACK
         BAL   R1,PUTPUT+4              SET A.R.E. FLAG IN TEXT
         DC    AL2(SARE)
VSYM     BAL   LINK,VARSYM
         CLI   8(RREG),128              UNSUBSCRIPTED SYSLIST IS ERROR
         BE    ILSYSL
         B     NSTPTR
*        WHAZZIT EXIT PROCESSOR
CEXITE   LA    R3,1                     ASSUME SIMPLE EXIT CODE
         IC    RB,4(0,RREG)             GET CURRENT OPNDX FROM RSTACK
         LA    R1,OPNDL(RB)
         TM    0(RREG),32               TEST IF SIMPLE SUPER-STATE
         BZ    EXIT                     YES -EXIT
         TM    0(R1),128                COMPLEX -ENTRY MUST NOT BE
         BZ    ILXPR                     SYSLIST
         OI    0(R1),32                 MARK AS BOOLEAN REQUIRED
         EJECT
*        COMPLEX (BOOLEAN) EXIT PROCESSOR
CEXITB   LA    R3,2                     SET COMPLEX EXIT CODE
         B     EXIT
*        SETC  EXIT PROCESSOR
CEXITC   LA    R3,4                     SET EXIT CODE
         B     CEXITA+4
*        ARITHMETIC EXIT PROCESSOR
CEXITA   LA    R3,3                     SET EXIT CODE
         TM    0(RREG),32               ERROR IF COMPLEX SUPER STATE
         BO    ILXPR
         B     EXIT
*        PROCESS ATTRIBUTE OPERATOR
ATTROP   LA    INPTR,1(0,INPTR)         PUT ATTRIBUTE OPERATOR IN
         BAL   R1,PUTR3                   TEXT
         STC   R3,5(0,RREG)             SAVE IT IN RECURSION ENTRY
         TM    SWTCH5,64                BRANCH IF PROCESSING MAINLINE
         BO    ATR10
         CLI   0(INPTR),AMPSND          MUST BE FOLLOWED BY AMPERSAND
         BNE   ILNORK
         MVC   4(1,RREG),OPNDX          SAVE OPNDX IN RSTACK
         BAL   LINK,VARSYM              PROCESS VARIABLE SYMBOL
         LA    R1,OPNDL(RB)             JUST IN CASE
         OI    0(R1),16                 SET SYMBOLIC PARAMETER FLAG IN
*                                         OPERAND LIST
         CLI   5(RREG),SNATTR           TEST IF N-ATTRIBUTE
         BNE   ATR05
         CLI   8(RREG),X'E0'              YES -MUST NOT BE DOUBLY
         BE    ILNORK                    SUBSCRIPTED SYSLIST
         TM    0(R1),216                  NOR SUBSCRIPTED V.S.
         BO    ILNORK
         B     NSTPTR
ATR05    CLI   8(RREG),X'80'            VARIABLE SYMBOL MUST NOT BE
         BE    ILNORK                   UNSUBSCRIPTED SYSLIST
         B     NSTPTR
ATR10    CH    R3,HSNATR                MUST NOT BE N OR K-QUOTE
         BNL   ILNORK
         BAL   LINK,ATR18               PROCESS SYMBOL
         B     ILNORK                     ERROR... INVALID SYMBOL
         B     NSTPTR                     O.K.     PRESS ON
ATR18    LA    R3,2
         ST    LINK,SDTEMP                SAVE LINK REGISTER
         BAL   LINK,TRTESN                LOOK AT STRING
         L     LINK,SDTEMP
         CH    2,H12                           MUST BE AN-STRING
         BCR   7,LINK                     NOT A VALID SYMBOL
         CH    R2,H8                      LENGTH MUST BE L.E. 8
         BCR   11,LINK                    NOT A VALID SYMBOL
         BAL   R1,PUTPUT+4              HOKAY -PUT SYMBOL FLAG IN TEXT
         DC    AL2(SSYMB)
         BAL   R1,EOPNDL                CREATE OPERAND LIST ENTRY
         LA    R1,128(0,R2)
         STC   R1,OPNDL(RB)
         LR    INPTR,1                  SPACE INPUT POINTER
         LA    OPTR,2(0,OPTR)             AND OUTPUT POINTER
         B     4(0,LINK)                RETURN WITH SYMBOL PROCESSED
*        SET BOOLEAN REQUIRED FLAG IN OPERAND LIST ENTRY
MBOOL    IC    RB,4(0,RREG)             GET CURRENT OPNDX FROM RSTACK
         LA    R1,OPNDL(RB)
         TM    0(R1),128                HOWEVER, MUST NOT BE SYSLIST
         BZ    ILSYSL
         OI    0(R1),32
*        PROCESS LOGICAL OPERATOR
BOOLOP   IC    RB,BOP15-14(R3)          TEST IF TYPE CORRESPONDS TO
         L     R1,S1AD                  POINT AT THE TRANSITION TABLE
         LA    R1,0(STPTR,R1)             CALLING SEQUENCE
         EX    RB,BOP10
         BNE   *+10
ILXPR    BAL   LINK,ABSERR              ILLEGAL LOGICAL OPERATOR
         DC    AL1(ERRR16)
         DC    AL1(ERRST)
*        PROCESS RELATIONAL OPERATOR
RELOP    BAL   R1,PUTR3+4               PUT OPERATOR IN TEXT
         LA    INPTR,1(R2,INPTR)
         B     SBLANK                   MARCH TO THE BLANK SCAVENGER
BOP10    TM    0(R1),0                  OUT-OF-LINE
BOP15    DC    X'804040'                NOT,OR,AND ACCEPTANCE MASKS
*        PROCESS ARITHMETIC OPERATOR
AROP     BAL   R1,PUTR3
         B     NSTPTR
         EJECT
*        PROCESS SETC CHARACTER EXPRESSION
CSETC    LR    RQ,OPTR                  MARK OUTPUT POINTER
         S     RQ,OBUFS
         STH   RQ,4(0,RREG)
         BAL   R1,PUTPUT+4              GENERATE DUMMY BYTE IN TEXT
         DC    AL2(SNULL)
CS02     LA    INPTR,1(0,INPTR)         SPACE OVER OPENING CHARACTER
CS05     L     R3A,ENDCOL               LOCATION OF THE END COLUMN
CS10     BAL   R1,PUTPUT+4              SET CHAR. STRING FLAG IN TEXT
         DC    AL2(SCEXPR)
         LR    R1,OPTR                  REMEMBER OPTR FOR STORING COUNT
         SR    R2,R2                    SET STRING LENGTH =0
         LA    R3,1                     SET BUMP FOR BXLE
         AR    OPTR,R3
CS15     LA    RA,2                     ASSUME A 2 BYTE MOVE
         CLI   0(INPTR),QUOTE           EXAMINE THE QUOTE SITUATION
         BNE   CS20
         CLI   1(INPTR),QUOTE
         BNE   CS35                     SINGLE
         BCT   RA,CS24                  DOUBLE -SQUASH TO A SINGLE
CS20     CLI   0(INPTR),AMPSND          EXAMINE THE AMPERSAND SITUATION
         BNE   CS27
         CLI   1(INPTR),AMPSND
         BNE   CS30                     SINGLE
CS24     AR    INPTR,R3                 ADVANCE INPUT POINTER
CS25     MVC   0(1,OPTR),0(INPTR)       TRANSFER CHARACTER TO OUTPUT
         AR    R2,R3                    INCREMENT STRING LENGTH
         AR    OPTR,R3                  ADVANCE OUTPUT POINTER
CS27     BCT   RA,CS25                  ITERATE ON COUNT
         BXLE  INPTR,R3,CS15            ADVANCE INPUT POINTER
NOQUOT   BAL   LINK,ABSERR              END OF LOGICAL CARD
         DC    AL1(ERRR17)              WHILE QUOTED STRING
         DC    AL1(ERRST)
CS30     STC   R2,0(0,R1)               SET STRING LENGTH IN TEXT
         BAL   LINK,VARSYM              PROCESS VARIABLE SYMBOL TO TEXT
         CLI   8(RREG),128              UNSUBSCRIPTED SYSLIST IS AN
         BE    ILSYSL                   ERROR
         CLI   0(INPTR),DOT             FORGET TERMINATING PERIOD
         BE    CS02
         B     CS05
CS35     STC   R2,0(0,R1)               SET STRING LENGTH IN TEXT
         AR    INPTR,R3                 ADVANCE INPTR
         CLI   0(INPTR),LPAREN          TEST FOR SUBSTRING NOTATION
         BNE   CS40
         BAL   R1,APARCT
         LH    R1,4(0,RREG)             SET SUBSTRING FLAG IN TEXT
         A     R1,OBUFS
         MVI   0(R1),SSUBST
         BAL   R1,PUTPUT                PUT SUBSTRING L-PAREN IN TEXT
         DC    AL2(SUBOPE)
         MVI   MCALL,128                PROCESS SUBSCRIPT-1
         BAL   LINK,METSCN
         CLI   0(INPTR),COMMA           COMMA MUST TERMINATE
         BNE   INVSUB
         BAL   R1,PUTPUT                PUT SUBSTRING COMMA IN TEXT
         DC    AL2(SUBCOM)
         BAL   LINK,METSCN              PROCESS SUBSCRIPT-2
         CLI   0(INPTR),RPAREN          R-PAREN MUST TERMINATE
         BNE   INVSUB
         BAL   R1,DPARCT
         BAL   R1,PUTPUT                PUT SUBSTRING R-PAREN IN TEXT
         DC    AL2(SUBCLS)
         CLI   0(INPTR),QUOTE           TEST FOR IMPLIED CONCATENATION
         BE    NSTPTR                   YES -RETURN TO THE INTERPRETER
CS40     CLI   0(INPTR),DOT             TEST FOR EXPLICIT CONCATENATION
         LA    STPTR,1(0,STPTR)
         BNE   NSTPTR                   NO
         LA    INPTR,1(0,INPTR)         YES -SPACE OVER THE PERIOD AND
         BCT   STPTR,NSTPTR               RETURN TO THE INTERPRETER
         EJECT
*        PROCESS ARITHMETIC TERM
ATERMA   TM    0(RREG),128              TEST IF ARITHMETIC ENTRY
         BO    ATERMB                   YES
         BAL   R1,PUTPUT+4              NO -PUT A.R.E. FLAG IN TEXT
         DC    AL2(SARE)
ATERMB   BAL   LINK,AT05
         B     ILSDTF
         B     NSTPTR
*        BRANCH TO APPROPRIATE PROCESSING ROUTINE
AT05     CH    2,H4
         BE    VSYM
         CH    2,H6
         BE    ATTROP
         CH    2,H7
         BE    AT20
         CH    2,H11
         BNE   ILXPR
*        INITIALIZATION FOR DECIMAL S.D.T.
AT18     LR    R3A,1                    SET SCAN LIMIT
         LA    R3,SDSDT                 GENERATE TYPE FLAG
         BCT   R3A,AT26
*        INITIALIZATION FOR HEX, BINARY AND CHARACTER S.D.T.
AT20     LA    INPTR,1(0,INPTR)         SKIP PAST SYNTACTIC HEAD
         BAL   R4,TESTND               *
         L     R3A,ENDCOL               SET SCAN LIMIT
AT26     IC    RB,AT70-SXSDT(R3)        SET MAX COUNT
         ST    RB,SDTEMP
         IC    RB,AT75-SXSDT(R3)        HIGH CHAR RANGE
         STH   RB,SDTEMP
         IC    RB,AT80-SXSDT(R3)        SHIFT AMOUNT
         STC   R3,0(0,OPTR)             PUT TYPE FLAG IN TEXT
         LA    R3,1                     SET UP BXLE BUMP
         SR    RA,RA                    CLEAR COUNT
         LR    R2,RA                    INITIALIZE RESULT REGISTER
         CLI   SDTEMP+1,255
         BNE   AT30
         L     R2,AT60
*        A SLOW BUT INDEFATIGABLE LOOP TO ASSEMBLE THE S.D.T.
AT30     SR    R1,R1                    PICK UP CURRENT INPUT BYTE
         IC    R1,0(0,INPTR)
         CLI   0(INPTR),QUOTE           TEST IF QUOTE
         BNE   AT35
         BAL   R4,TESTND               *
         L     R3A,ENDCOL              *
         CLI   SDTEMP+1,255             YES -IS THIS C.S.D.T.
         BNE   AT55                     NO -TERMINATES
         CLI   0(INPTR),QUOTE           PERHAPS A DOUBLE QUOTE
         BNE   AT55                     NO -TERMINATES
AT35     CH    R1,SDTEMP                TEST IF CHARACTER IN RANGE
         BCR   2,LINK                   NOT QUITE
         CLI   0(INPTR),AMPSND          DO WE HAVE AN AMPERSAND
         BNE   AT40
         BAL   R4,TESTND               *
         L     R3A,ENDCOL              *
         CLI   0(INPTR),AMPSND          THEN IT BETTER BE A DOUBLE
         BCR   7,LINK
AT40     CLI   SDTEMP+1,N9              TEST IF D.S.D.T.
         BNE   AT50
         LA    R1,0(R1,R2)              YES -ADJUST FOR CONVERSION
         ALR   R1,R2
AT50     SLL   R2,0(RB)                 SHIFT PARTIAL RESULT
         ALR   R2,R1                    ADD IN CURRENT (ADJUSTED) BYTE
         AR    RA,R3                    ADD 1 TO COUNT
         BXLE  INPTR,R3,AT30
*        SHOULD ONLY FALL THRU ON A D.S.D.T.
         CLI   SDTEMP+1,N9
         BE    AT51
*        OTHERWISE TEST IF A NEW CARD CAN BE ACQUIRED
         BAL   R4,TSTND1               *
         TM    MVBYTE,1                *
         BCR   8,LINK                  *NO -ERROR
         L     R3A,ENDCOL              *YES -SET NEW SCAN LIMIT
         B     AT30                    *  AND CONTINUE
AT51     C     R2,AT85                  TEST AGAINST MAX VALUE OF
         BCR   2,LINK                     (2**24)-1
*        STORE BINARY VALUE, CLEAN UP, AND GET THE HECK OUT OF HERE
AT55     LTR   RA,RA                    COUNT MUST BE IN BOUNDS
         BCR   8,LINK
         CH    RA,SDTEMP+2
         BCR   2,LINK
         ST    R2,SDTEMP
         MVC   1(3,OPTR),SDTEMP+1       (MODULO 2**24 IF D.S.D.T.)
         LA    OPTR,4(0,OPTR)
         B     4(0,LINK)
*        CONSTANTS, ETC.
         DS    0F                       FORCE FULL WORD ALIGNMENT
AT60     DC    C'0000'                  INITIAL VALUE FOR C.S.D.T.
AT70     DC    X'06180803'              MAX COUNT
AT75     DC    X'0F0109FF'              MAX CHAR VALUE
AT80     DC    X'04010308'              SHIFT VALUE
AT85     DC    X'00FFFFFF'              (2**24)-1
         EJECT
*VARSYM
*        RECURSIVE SUBROUTINE TO SCAN VARIABLE SYMBOLS
*        BAL   LINK,VARSYM
*
VARSYM   BAL   R1,ENTER                 CREATE RECURSION STACK ENTRY
         BAL   R1,EOPNDL                CREATE OPERAND LIST ENTRY
         STC   RB,4(0,RREG)             SAVE OPNDX IN RSTACK
         BAL   R4,TESTND                SPACE OVER INITIAL AMPERSAND
         LA    R3,2                     ISOLATE VARIABLE SYMBOL TAIL
         BAL   LINK,TRTESN
         CH    2,H12                    ERROR IF NOT AN-STRING
         BNE   ILVSF
         CH    R2,H6                    ERROR IF LENGTH G.T. 7
         BH    ILVSF
         IC    RB,4(0,RREG)             RECOVER OPNDX FROM RSTACK
*
         TM    SWTCH1,X'40'             TEST IF WITHIN MACRO DEFIN.
         BZ    V010                     NO-BR PAST SET OF SYSLIST SWTCH
         CLC   0(7,INPTR),SYSL          TEST FOR SYSLIST
         BNE   V010
         BAL   R1,PUTPUT+4              YES -GENERATE TEXT FLAG
         DC    AL2(SYSLST)
         OI    0(RREG),128              SET SYSLIST SWCH IN RSTACK FLAG
         B     V015
*
*        INDICATE V.S. IN OPNDL FLAG, AND ADD 1 TO LENGTH FOR THE &
V010     LA    RQ,193(0,R2)
         STC   RQ,OPNDL(RB)
         LA    OPTR,3(0,OPTR)           SKIP 3 BYTES IN OUTPUT TEXT,
         BAL   R1,PUTPUT+4                THEN INSERT NULL BYTE
         DC    AL2(SNULL)
V015     LA    INPTR,1(R2,INPTR)        SPACE OVER V.S. TAIL
*        SCAN OVER THE MAX LENGTH SPECIFICATION
         TM        SWTCH5,X'01'        TEST EXTEN OPTION
         BZ        V019                SKIP IF OFF
         CLI       OUTPUT+5,2          TEST IF GBLC
         BE        *+12
         CLI       OUTPUT+5,5          TEST IF LCLC
         BNE       V019
         CLI       0(INPTR),STAR       TEST FOR ASTERISK
         BNE       V019
         CLI       1(INPTR),N9         TEST AT LEAST 1 DIGIT
         LA        LINK,DCLER12        ERROR IF NOT
         BH        ABSERR
         LA        INPTR,1(,INPTR)     POINT AT NEXT CHAR
         CLI       0(INPTR),N9         TEST IF NUMERIC
         BNH       *-8                 LOOP OVER ALL NUMERICS
*        SCAN OFF THE SUBSCRIPT
V019     CLI   0(INPTR),LPAREN          TEST FOR SUBSCRIPT
         BNE   EXIT                     NO -EXECUTE RECURSIVE EXIT
         BAL   R1,APARCT                YES -ADVANCE PARENTHESIS COUNT
         BAL   R1,PUTPUT                PUT SUBSCRIPT L-PAREN IN TEXT
         DC    AL2(SUBSLP)
         MVI   MCALL,128                RECURSIVE CALL TO METSCN TO
         BAL   LINK,METSCN                PROCESS SUBSCRIPT
         CLI   0(INPTR),COMMA           IS TERMINATOR A COMMA.....
         BNE   V020
         TM    0(RREG),128              YES -TEST IF SYSLIST
         BZ    INVSUB
         BAL   R1,PUTPUT                YES -PUT COMMA IN TEXT
         DC    AL2(SCOMMA)
         BAL   LINK,METSCN              PROCESS SECOND SUBSCRIPT
         OI    0(RREG),32                 AND SET INDICATOR
V020     CLI   0(INPTR),RPAREN          IS TERMINATOR R-PAREN.....
         BNE   INVSUB
         BAL   R1,PUTPUT                YES -PUT IN OUTPUT TEXT
         DC    AL2(SRPAR)
         BAL   R1,DPARCT                DECREMENT PARENTHESIS COUNT
         IC    RB,4(0,RREG)             SET SUBSCRIPT INDICATOR IN
         LA    R1,OPNDL(RB)               OPERAND POINTER LIST
         OI    0(R1),8
         OI    0(RREG),64               AND IN RECURSION ENTRY
         B     EXIT
         EJECT
*ENTER
*        COMMON RECURSIVE ENTRY ROUTINE FOR SCANNERS
*        BAL   R1,ENTER
*        (RETURN)
ENTER    L     RREG,AVSP                GET LOCATION OF AVAILABLE SPACE
         LA    R3A,8(0,RREG)            COMPUTE LOCATION OF NEXT AND
         ST    R3A,AVSP                   SAVE
         ST    LINK,0(0,RREG)           SAVE LINK REG. IN CURRENT ENTRY
         MVI   0(RREG),0                CLEAR FLAG BYTE
         ST    STPTR,4(0,RREG)          SAVE CALLER'S STPTR
         BR    R1                       RETURN TO CALLER
*EXIT
*        COMMON RECURSIVE EXIT ROUTINE FOR SCANNERS
*        B     EXIT
EXIT     ST    RREG,AVSP                RESET AVAILABLE SPACE POINTER
         L     LINK,0(0,RREG)           RELOAD LINK REGISTER
         IC    STPTR,7(0,RREG)          RESTORE CALLER'S STPTR
         S     RREG,F8                  BACK UP RECURSION ENTRY POINTER
         BR    LINK                     RETURN TO CALLER'S CALLER
*APARCT
*        SUBROUTINE TO STEP PARENTHESIS COUNT -ERROR IF G.T. 5
*        BAL   R1,APARCT
APARCT   LH    RQ,PARLVL
         AH    RQ,H1
         CH    RQ,H5
         BNH   APARCS
         BAL   LINK,ABSERR              TOO MANY NESTS FOR THIS BIRD
         DC    AL1(ERRR18)
         DC    AL1(ERRST)
APARCS   STH   RQ,PARLVL
         BR    R1
*DPARCT
*        SUBROUTINE TO DECREMENT PARENTHESIS COUNT
*        BAL   R1,DPARCT
DPARCT   LH    RQ,PARLVL
         SH    RQ,H1
         STH   RQ,PARLVL
         BR    R1
*EOPNDL
*        CREATES OPERAND LIST ENTRY
*        BAL   R1,EOPNDL
*        (RETURN)
EOPNDL   IC    RB,OPNDX                 GET OPERAND ENTRY INDEX
         CH    RB,H200                  MAXIMUM 50 4-BYTE ENTRIES
         BNL   STCPEX                   ERROR- TOO MANY
         LR    R3A,OPTR                 SET CURRENT OUTPUT TEXT INDEX
         S     R3A,OBUFS                  INTO ENTRY
         STH   R3A,OPNDL+2(RB)
         LR    R3A,INPTR                DITTO FOR INPUT TEXT INDEX
         S     R3A,INPUT                LESS START OF INPUT BUFFER
         STH   R3A,OPNDL(RB)
         LA    R3A,4(0,RB)              UPDATE OPNDX
         STC   R3A,OPNDX
         BR    R1                       RETURN
         EJECT
*PUTPUT
*        SUBROUTINE TO PUT ONE BYTE IN TEXT AND ADVANCE INPTR AND OPTR
*        BAL   R1,PUTPUT
*        DC    X'00XX'   WHERE XX IS THE BYTE TO BE PUT
*        (RETURN)
PUTPUT   BAL   R4,TESTND               *ADVANCE INPUT POINTER
         MVC   0(1,OPTR),1(R1)          PUT ARGUMENT IN TEXT
         LA    OPTR,1(0,OPTR)           ADVANCE OUTPUT POINTER
         B     2(0,R1)                  RETURN TO CALLER
*PUTR3
*        SAME AS PUTPUT EXCEPT ARGUMENT IS IN R3
*        BAL   R1,PUTR3
*        (RETURN)
PUTR3    BAL   R4,TESTND               *ADVANCE INPUT POINTER
         STC   R3,0(0,OPTR)
         LA    OPTR,1(0,OPTR)
         BR    R1
         EJECT
*ROUTINE 'TRTEST'
*FUNCTIONS- DOES TRANSLATE&TEST ON FIELD INDICATED IN POINTER 'INPTR',
*   UP TO LOCATION 'ENDCOL', TESTING AGAINST TABLE 'PNCTAB'.
*   TRT STOPS ON FIRST SPECIAL OR NON-ASSEMBLER CHARACTER, AND INSERTS
*     ARGUMENT FROM PNCTAB INTO REG 2 AS CATEGORY NUMBER.
*   IF FIRST CHAR IN STRING IS SPECL CHAR, THEN TYPE NUMBER IS SELECTED
*     FROM TABLE NN16, AND EXIT.
*   IF FIRST CHAR IS NON-ASM CHAR, THEN SET CATEGORY=0, AND EXIT.
*   IF ENTRY POINT IS NOT TRTEST, AND THE STRING MATCHES AN ENTRY IN
*     THE SYNTACTIC STRING TABLES NN17A, NN17B, OR NN17C, THEN TYPE AND
*     CATEGORY ARE SELECTED FROM THESE TABLES, AND EXIT.
*   OTHERWISE, IF FIRST CHAR IS NUMERIC, THEN CATEGORY=11 (DECIMAL
*     STRING)--IF NOT, CATEGORY=12 (ALPHANUMERIC STRING)--AND EXIT.
*ENTRY POINTS-
*        BAL   LINK,TRTEST    PLACES STANDARD CATEGORY TABLE INTO
*                               PNCTAB, SKIPS SYNTACTIC STRING SEARCH.
*        BAL   LINK,TRTESN    PLACES STANDARD CATEGORY TABLE INTO
*                               PNCTAB, DOES SYNTACTIC STRING SEARCH.
*        BAL   LINK,TRTESN+6  ASSUMES USER HAS SET UP CATEGORIES IN
*                               PNCTAB, DOES SYNTACTIC STRING SEARCH.
*INPUT- FIELD POINTER IN 'INPTR'. FIELD MUST BE IN INTERNAL ASSEMBLER
*   CODE.
*OUTPUT-
*   IN REG 1- ADDRESS OF TERMINATING CHARACTER.
*   IN REG 2- CATEGORY NUMBER.
*   IN REG R2- STRING LENGTH (EXCLUDING TERMINATOR), MINUS ONE.
*              (NOT SET IF LENGTH = 0.)
*   IN REG R3- TYPE NUMBER (FOR SPECIAL CHARACTERS).
*
*   STANDARD TRTEST CATEGORIES-
*    0- 1ST CHAR IS NON-ASSEMBLER
*    1- 1ST CHAR IS ,=.) OR BLANK
*    2- 1ST CHAR IS (
*    3- 1ST CHAR IS '
*    4- 1ST CHAR IS &
*    5- 1ST CHAR IS +-* OR /
*    6- STRING IS L' S' I' N' OR K'
*    7- STRING IS C' X' OR B'
*    8- STRING IS T'
*    9- STRING IS AND NOT OR
*   10- STRING IS EQ NE LT GT LE GE
*   11- STRING IS DECIMAL (FIRST CHAR NUM)
*   12- STRING IS ALPHANUM (FIRST CHAR ALPHA)
*EXTERNAL ROUTINES-
*   TSTND2- IF NO TERMINATOR FOUND, AND THIS IS A MACRO OPERAND WITH
*           CONTINUATION, TSTND2 WILL GET IT.
*EXITS-  BR    LINK
*EXTERNAL TABLES- PNCTAB, TRSLTB
*
*
TRTEST   LA    R3,1                     ENTRY POINT INDICATOR
TRTESN   MVC   PNCTAB+39(12),NN15       SET UP STANDARD TERMINATORS
         SR    1,1
         LR    2,1
         L     R1,ENDCOL                R1 = LENGTH FROM CURRENT INPTR
         SR    R1,INPTR                   THRU THE END COLUMN
         BM    NN7A                     UNKNOWN CAT. SINCE PAST END-COL
*        IF LNTH GT 255, REDUCE IT TO 255.
         CH    R1,H255                  ONLY A MAD FIEND IN PRODUCT
         BNH   *+8                        TEST WOULD FORCE EXECUTION
         LH    R1,H255                    OF ***THIS*** INSTRUCTION
         EX    R1,NN14                  TRANSLATE&TEST AGAINST PNCTAB
         BNE   NN0                      BR IF AN ENTRY MATCHES
*        IF NO MATCH, SIMULATE ONE IN ENDCOL+1.
         LA    1,1(R1,INPTR)            REG 1=1+ENDCOL-INPTR+INPTR
         CH    R1,H255
         BE    NN0
         BAL   R4,TSTND2                TEST FOR MACRO OPERAND CONT.
         TM    MVBYTE,1                 REDO IF A NEW CARD ACQUIRED
         BO    TRTESN+6
*
*        TRT FINDS ANY CHAR IN CATEGORY TABLE OR ANY NON-ASM CHAR.
NN0      LR    R2,1                     COMPUTE TRUE LENGTH TO TERM.
         SR    R2,INPTR
         BZ    NN7                      BR IF FIRST CHAR TERMINATES
         CH    R2,H255                  CHECK OPERAND LENGTH
         BH    OUTIT+12                 BR IF GT 255
*        ONE-CHAR STRINGS ARE SIGNIFICANT HERE ONLY IF TERMINATED BY '
         BCT   R2,NN0A                  LENGTH-1. SKIP IF NOT 0.
         CLI   1(INPTR),QUOTE           TEST FOR QUOTE.
         BNE   NN3                      BR IF NOT
NN0A     C     R2,F2                    SKIP IF LENGTH GREATER THAN 3
         BH    NN3
         BCT   R3,NN3                   NO TESTS IF TRTEST ENTRY
*        SET UP BXLE LOOP TO TEST FOR BOOLEAN AND RELATIONAL OPS, ATTR.
*        OPERATORS, ETC.
NN1      LA    R3,3(0,R2)               THE BUMP = LENGTH+2
         SR    R3A,R3A
*        POINT R4 TO TABLE NN17A, NN17B, OR NN17C FOR LENGTH = 1, 2, OR
*        3, RESPECTIVELY.
         IC    R3A,NN18(R2)
         LA    R4,NN17A(R3A)
*        POINT R3A TO THE UPPER LIMIT OF THE SAME TABLE.
         IC    R3A,NN19(R2)
         AR    R3A,R4
NN2      EX    R2,NN14A                 LOOK FOR A MATCH
         BE    NN6                      BRANCH IF SYMBOL FOUND.
*        INCREMENT TABLE PTR BY LENGTH+2, AND LOOP TO NN2 IF TABLE END
*        HAS NOT BEEN REACHED.
         BXLE  R4,R3,NN2
*        STRING IS NOT IN TABLE
NN3      LA    2,12                     ASSUME AN-STRING CATEGORY (=12)
         CLI   0(INPTR),N9              TEST FOR INITIAL DIGIT
         BCR   3,LINK                   EXIT IF NO
         BCTR  2,LINK                   YES -SET D-STRING CATEGORY(=11)
*        RETURN AFTER FINDING ITEM IN SYNTAX TYPE TABLE
NN6      IC    R3,2(R2,R4)              PICK UP TYPE NUMBER AND
         IC    2,1(R2,R4)                 CATEGORY FROM TABLE
         BR    LINK
*        TRT TERMINATED AT STARTING BYTE
NN7      CLI   0(INPTR),HCHAR           TEST IF NON-ASM CHARACTER
         BNH   NN8                      BR IF NOT
NN7A     SR    2,2                      YES-SET CATEGORY UNKNOWN
         BR    LINK                       AND EXIT
NN8      IC    R3,0(0,INPTR)            SET TYPE NUMBER FROM NN16
         IC    R3,NN16-39(R3)
         BR    LINK                     EXIT
NN14     TRT   0(1,INPTR),PNCTAB        OUT-OF-LINE
NN14A    CLC   0(1,INPTR),0(R4)
*
*        CATEGORIES AND TYPES CORRESPONDING TO SPECIAL CHARACTERS
*        (NN15 IS USED AS STANDARD CATEGORY TABLE)
**               0 1 2 3 4 5 6 7 8 9 1011    INTERNAL CODE MINUS 39.
**               + - * / , = & . ( ) '       CHARACTER (LAST IS BLANK).
NN15     DC    X'050505050101040102010301'   CATEGORY NUMBERS
NN16     DC    X'040506072B00000002010032'   TYPE NUMBERS
*
*        SYNTACTIC STRING TABLES.
*        NN17A USED IF TERMINATOR IS ' AND LENGTH = 1.
*        NN17B,NN17C USED IF LENGTH = 2,3 RESPECTIVELY, FOR ANY TERMI-
*        NATOR.
*        ENTRY FORMAT IS SSSCT, WHERE SSS IS CHARACTER STRING (1,2, OR
*        3 BYTES), C IS CATEGORY AND T IS TYPE (1 BYTE EACH).
NN17A    DC    AL1(T)
         DC    AL1(08)
         DC    AL1(STATTR)
         DC    AL1(X)
         DC    AL1(07)
         DC    AL1(SXSDT)
         DC    AL1(B)
         DC    AL1(07)
         DC    AL1(SBSDT)
         DC    AL1(C)
         DC    AL1(07)
         DC    AL1(SCSDT)
         DC    AL1(L)
         DC    AL1(06)
         DC    AL1(SLATTR)
         DC    AL1(I)
         DC    AL1(06)
         DC    AL1(SIATTR)
         DC    AL1(S)
         DC    AL1(06)
         DC    AL1(SSATTR)
         DC    AL1(N)
         DC    AL1(06)
         DC    AL1(SNATTR)
         DC    AL1(K)
         DC    AL1(06)
         DC    AL1(SKATTR)
*
NN17B    DC    X'0E1A'                  EQ
         DC    AL1(10)
         DC    AL1(SEQ)
         DC    X'181B'                  OR
         DC    AL1(09)
         DC    AL1(SOR)
         DC    X'170E'                  NE
         DC    AL1(10)
         DC    AL1(SNE)
         DC    X'151D'                  LT
         DC    AL1(10)
         DC    AL1(SLT)
         DC    X'101D'                  GT
         DC    AL1(10)
         DC    AL1(SGT)
         DC    X'150E'                  LE
         DC    AL1(10)
         DC    AL1(SLE)
         DC    X'100E'                  GE
         DC    AL1(10)
         DC    AL1(SGE)
*
NN17C    DC    X'0A170D'                AND
         DC    AL1(9)
         DC    AL1(SAND)
         DC    X'17181D'                NOT
         DC    AL1(9)
         DC    AL1(SNOT)
NN17D    EQU   *
*        BXLE PARAMETERS FOR SYNTACTIC STRING LOOK-UP
NN18     DC    AL1(NN17A-NN17A)         TABLE ADDRESS FOR LENGTH = 1
         DC    AL1(NN17B-NN17A)         TABLE ADDRESS FOR LENGTH = 2
         DC    AL1(NN17C-NN17A)         TABLE ADDRESS FOR LENGTH = 3
NN19     DC    AL1(NN17B-NN17A-3)       TABLE END FOR LENGTH = 1
         DC    AL1(NN17C-NN17B-4)       TABLE END FOR LENGTH = 2
         DC    AL1(NN17D-NN17C-5)       TABLE END FOR LENGTH = 3
         EJECT
VSUB     EQU   X'F0'                    SUBLIST FLAG
SUBFLG   EQU   VSUB
VAVFLG   EQU   X'26'                    EVALUATE FLAG, NULL SYMBOL
EVAL     EQU   VAVFLG
*
POSFLG   EQU   X'FB'                    POSITIONAL PARAM FLAG
ATSIGN   EQU   X'26'
CONBIT   EQU   X'20'                    MASK TO TEST CONTINUATION INDIC
SMSPAR   EQU   X'0B'                    REC TYPE FLAG (MACRO/PROTO
*                                         OPERAND VALUE)
ENDSYM   EQU   X'0C'                    END OF M-I OR PROTO FLAG
KEYFLG   EQU   X'FC'                    KEY WORD PARAMETER FLAG
TYPEU    EQU   22                       'UNDEFINED' TYPE ATTR FLAG
WORK1    EQU   4
SBCFLG   EQU   X'F9'                    CONT. FLAG WITHIN SUBLIST
*
*
*
*   MACRO INSTRUCTION SCANNER...
*        THIS ROUTINE IS CALLED BY THE DRIVER TO PROCESS THE
*          OPERAND FIELD OF AN UNKNOWN OP CODE AS A MACRO INSTRUCTION
*        IT IS ALSO USED BY THE PROTOTYPE SCANNER TO PROCESS THE
*        NORMAL VALUE OF A KEY WORD PARAMETER
*
MISCAN   ST    INPTR,INTPTR             SAVE POINTER TO INPUT OPRND FLD
         SR    LINK,LINK                ZERO A TEMPORARY REGISTER
         STH   LINK,POSNO               INITIALIZE POSITIONAL COUNTER
         STH   LINK,NRKEY               INITIALIZE KEYWORD COUNTER
         CLI   0(INPTR),BLANK          TERMINATE SCAN IF INITIAL
         BE    NDPSCN                     CHARACTER IS BLANK
MISCAN2  BAL   LINK,NEXTOP              EDIT AN OPERAND
         B     *-4                      GET NEXT OPERAND
         EJECT
*
*        BEGIN NEW OPERAND
*
NEXTOP   DS    0H
         BAL   LINKR,UPPOS              UPDATE POSITIONAL COUNT
NXTOP0   DS    0H
         ST    INPTR,INTPTR             INITIALIZE FOR PROTO SCAN
         ST    LINK,SVNXT               BEGIN SCAN OF OPERAND
NXTOP1   ST    INPTR,FSTINP             SET FIRST CHAR. OF OP
         LR    INPTR1,INPTR
         CLI   0(INPTR),LPAREN          POSSIBLE SUBLIST
         BNE   NXTOP2
         CLI   1(INPTR),RPAREN
         BNE   PTSBHD                  LOOKS LIKE A SUBLIST
NXTOP2   MVI   0(OPTR),POSFLG           ASSUME POS PARAM, INSERT FLAG
         LA    OPTR,1(0,OPTR)
         MVC   NPRIME,H0                INITIALIZE SUBLIST COUNT
         BAL   LINKR,LEGOP              EDIT OPERAND
         CLI   ERRCOD,0
         BNE   ILTERM                   ILLEGAL OPERAND,TERMINATE SCAN
         CLI   0(INPTR),BLANK
         BE    RPUPFD                   WRAP UP OP. FIELD
         BAL   LINKR,RPUPOP             ELSE...JUST WRAP UP OPERAND
         B     MRETUR
*    INSERT END OF STATEMENT SYMBOL AND RETURN
RPUPFD   BAL   LINK,TSTPOS              POS. PARM. MUST PRECEDE K.W.
         MVI   0(OPTR),BLANK             ALL'S O.K.
         BAL   LINK,ENDOPR
NDPSCN   L     LINK,GETAD               GET PAST ANY
         BALR  LINK,LINK                   CONTINUATION CARDS
         DC    AL2(6)
         MVI   OUTPUT,ENDSYM             END OF PROTOTYPE STATEMENT
         LA    OPTR,OUTPUT+4             ALSO END OF M-I STATEMENT
         MVC   OUTPUT+3(2),NRKEY        KEYWORD COUNT
         BAL   LINK,ENDOPR             OUTPUT  END RECORD
         NI        SWTCH1,NMASK3       TURN OFF PROTO INDIC
         B     DRIVER                   GET NEXT STATEMENT
*   END OF OPERAND,NOT END OF STATEMENT
RPUPOP   BAL   LINK,TSTPOS              SAME TEST FOR OPERAND
         MVI   0(OPTR),COMMA
         BAL   LINK,OUTIT               CHECK OPERAND LENGTH ONLY
         BAL   LINK,NDOPR1              OUTPUT OPERAND
         BAL   LINK,OUTITA              UPDATE POINTERS.
         NI    SWTCH7,X'DF'             RESET K.W. INDICATOR
         BR    LINKR
*        TSTPOS      ...         THIS ROUTINE MAKES THE
*         FINAL TEST BEFORE OUTPUTTING THE OPERAND.
*        ... IF A POSITIONAL PARAMETER IS BEING PROCESSED, IT IS AN
*              ERROR IF ANY K.W. PARAMETERS PRECEDED IT
*            BAL      LINK,TSTPOS
*                      NORMAL RETURN
*
TSTPOS   CLC   NRKEY,H0                 ANY PRECEDING K.W.'S
         BCR   8,LINK                   NO...ALL'S WELL
         TM    SWTCH7,32                ARE WE OUTPUTTING A K.W.
         BZ    PPFLKW                   ERROR... BAIL OUT
         CLC   NPRIME,H0                IS A SUBLIST BEING PROCESSED .Q
         BCR   7,LINK                   BIF YES
         NI    SWTCH7,X'DF'             RESET K.W. INDICATOR
         BR    LINK                     AND RETURN
PPFLKW   DS    0H
         B     KEYPOS                   POSITIONAL PARAM FOLLOWS KW
*                                       RETURN IS TO LINK
*
*        THIS ROUTINE DOES THE FOLLOWING ...
*          IF THE OPERAND EXCEEDS 255 CHARACTERS AN ERROR MESSAGE
*          IS OUTPUTTED IN LIEU OF THE EDITED TEXT FOR THAT OPERAND
*
OUTIT    LR    WORK1,INPTR
         S     WORK1,FSTINP
         CH    WORK1,H255               DOES THE C.S. EXCEED 255 .Q
         BCR   13,LINK                  BIF NO
         BAL   LINK,ABSERR              YES, SO OUTPUT ERROR MESSAGE
         DC    AL1(ERRR19)              OPERAND EXCEEDS 255 CHARS.
         DC    AL1(ERRST)
*        THIS ROUTINE DOES THE FOLLOWING ...
*          THE OPERAND IS OUTPUTTED AND THE
*          OPERAND FIELD IS SHIFTED TO PERMIT THE NEXT OPERAND TO
*          FIT IN THE INTERMEDIATE BUFFER BEFORE EDITING
*        BAL   LINK,OUTITA
*              (RETURN)
*
OUTITA   L     WORK1,INPUT              MOVE OPERAND TO BEGINNING OF
         MVC   0(255,WORK1),0(INPTR)           INPUT BUFFER
         MVC   255(65,WORK1),255(INPTR)
         SR    INPTR,WORK1             LENGTH OF MOVE
         L     WORK1,ENDCOL
         SR    WORK1,INPTR             UPDATE POINTER TO END OF TEXT
         ST    WORK1,ENDCOL
         L     INPTR,INPUT
         LA    INPTR,1(0,INPTR)
OUTIT1   LR    INPTR1,INPTR
         ST    INPTR1,INTPTR
         BAL   R4,TSTND1                INSURE NOT PAST END COLUMN.
         BR    LINK
MRETUR   L     LINK,SVNXT               RETURN TO CALLER OF NEXTOP
         BR    LINK
         EJECT
*   OUTPUT STANDARD SUBLIST HEAD
PTSBHD   ST    OPTR,INTOPT              IN CASE OF BACK UP
         MVC   NPRIME,H0                INITIALIZE SUBLIST COUNT
         BAL   R1,PUTPUT                POS. PARAMETER FLAG
         DC    AL2(POSFLG)
         XI    SWTCH7,128               FLIP BIT 0
         MVI   1(OPTR),SUBFLG           LOOKS LIKE A SUBLIST...SO
         MVI   7(OPTR),LPAREN             INSERT HEADING NOW AND
         LA    OPTR,8(0,OPTR)             EDIT POTENTIAL SUBLIST
SUBNXT   LR    INPTR1,INPTR
         ST    INPTR,INTPTR              POINTERS
         MVC   SOPNDX(1),OPNDX          SAVE OPNDX
         LH    WORK1,NPRIME             GET CURRENT SUBLIST COUNT
         LA    WORK1,1(,WORK1)          UPDATE SUBLIST PARAM COUNTER
         STH   WORK1,NPRIME             SET NEW SUBLIST PARAM COUNT
         BAL   LINKR,LEGOP
         TM    ERRCOD,1                 RETURN FROM EDITOR
         BO    EXRPRN                   MUST BE EXCESSIVE RGT PAREN
         CLI   0(INPTR),COMMA
         BNE   ILTERM                   ILLEGAL TERMINATOR
         MVI   0(OPTR),COMMA           INSERT COMMA IN TEXT
         BAL   LINK,TSTPOS              INSURE P.P. BEFORE ANY K.W.P.
         BAL   LINK,ENDOPR             OUTPUT OPERAND
         BAL   R1,PUTPUT                ENTER SUB CONT. FLAG
         DC    AL2(SBCFLG)                INTO OUTPUT STREAM
         BAL   LINK,OUTIT      CHECK OPERAND LENGTH                8189
         B     SUBNXT                   GET NEXT OPERAND
*    IF   ERROR WAS EXCESSIVE RGT PAREN ...IT MAY BE ALL RIGHT
EXRPRN   CLI   0(INPTR),RPAREN
         BNE   ILTERM                   TOO BAD,ERROR IS LEGIT
         BAL   R4,TESTND
         CLI   0(INPTR),BLANK
         BE    ENDSUB                   END OF STATEMENT
         CLI   0(INPTR),COMMA           HOW ABOUT COMMA
         BE    MOREOP                   END OF OPERAND SUBLIST
         C     INPTR,ENDCOL             MAY BE END OF CARD
         BNH   WHOOPS                   NOT SUBLIST,SCAN FOR VALID TEXT
         B     ENDSUB
MOREOP   BAL   LINKR,LEGSUB             WRAP UP SUBLIST
         BAL   LINKR,RPUPOP
         B     MRETUR
*     WRAP UP SUBLIST
LEGSUB   MVI   0(OPTR),RPAREN
         MVC   1(1,OPTR),NPRIME+1       ENTER SUBLIST PARAMETER COUNT
         LA    OPTR,2(,OPTR)            BUMP OUTPUT POINTER
         TM    SWTCH7,128
         BCR   8,LINKR                  ALL HAS BEEN OUTPUTTED
         L     INPTR,FSTINP             RETURN TO LEFT PAREN
         L     LINK,SVNXT
         L     OPTR,INTOPT              RESET POINTERS
         MVI   OPNDX,0                  TO SCAN AGAIN
         B     NXTOP0                   AS A LEGIT SUBLIST
*    END OF SUBLIST AND STATEMENT
ENDSUB   BAL   LINKR,LEGSUB             SET END OF SUBLIST FLAGS
         B     RPUPFD                   END OF STATEMENT
*     NOT A VALID SUBLIST,BUT MAY BE LEGIT OPERAND
*      BACKUP AND  RESCAN INCLUDING INITIAL LEFT PAREN
WHOOPS   L     OPTR,INTOPT              RESET POINTERS
         L     INPTR,FSTINP             BACK TO LEFT PAREN
         LR    INPTR1,INPTR
         ST    INPTR,INTPTR             RESET POINTERS
         NI    SWTCH7,X'7F'             TURN OFF BYPASS
         MVI   OPNDX,0                  DESTROY OP. LST. ENTRIES
         B     NXTOP2                   START ALL OVER
         EJECT
*ROUTINE 'LEGOP'
*FUNCTIONS- EDITS MACRO INSTRUCTION OPERANDS TO OUTPUT BUFFER.
*   (ALSO ENTERED FROM PROSCN VIA NXTOP0 TO PROCESS KW IN PROTOTYPE.)
*   PROCESSES ONE OPERAND OR ONE SUBLIST.
*   CREATES OPNDL ENTRIES.
*   EVALUATES SELF-DEFINING TERMS (SDT).
*ENTRY POINTS-
*        BAL   LINKR,LEGOP0   FOR PROCESSING MACRO INST NAME FIELD
*        BAL   LINKR,LEGOP    FOR OPERAND FIELD
*EXTERNAL ROUTINES-
*   TRTEST- SCAN FOR TERMINATORS
*   PUTST1- MOVE INPUT TEXT TO OUTPUT BUFFER
*   DPARCT- DECREMENT PAREN LEVEL COUNT
*   GETSRC- GET NEXT CARD
*   APARCT- INCREMENT PAREN LEVEL COUNT
*   OUTIT-  CHECKS OPERAND LENGTH
*   VARSYM- CHECKS VAR SYM SYNTAX, CREATES OPNDL ENTRY
*   AT20-   EVALUATES X',B', OR C' SDT, MOVES TO OUTPUT
*   ATR18-  CHECKS ORD SYM SYNTAX, CREATES OPNDL ENTRY
*   AT18-   EVALUATES DEC SDT, MOVES TO OUTPUT
*   PUTPUT- INSERT FLAGS IN OUTPUT BUFFER
*   UPKEY-  INCREMENT KEYWORD COUNTER
*   WRNERR- WRITE OUT ERROR WARNING MESSAGE
*NORMAL EXITS-
*        B     BLNKOP         LAST OPERAND IN FIELD IS KEYWORD WITH
*                               OMITTED OPERAND
*        BR    LINKR          NORMAL RETURN AT END OF OPERAND OR SUBLST
*   EXIT CODES-
*        ERRCOD =1 FOR EXCESS RIGHT PAREN (PRESUMABLY END OF SUBLIST)
*               =0 OTHERWISE
*ERROR EXITS- TO ONE OF THESE ON SYNTAX ERRORS-
*   NOBAL
*   ILTERM
*   ILSYSL
*   NOQUOT
*
LEGOP    MVI   OUTPUT,SMSPAR            PUT PARAMETER FLAG
         MVI   MVBYTE,0
LEGOP0   ST    LINKR,SVLNKR
         NI    SWTCH7,X'BF'             SET FIRST TIME SWITCH FOR VARSM
         SR    WORK1,WORK1              INITIALIZE FOR NEXT OP.
         STH   WORK1,PARLVL             ZERO PAREN LEVELS
         MVI   ERRCOD,0
         CLI   0(INPTR),COMMA           IF FIRST CHARACTER A COMMA
         BE    NULOP                    YES...ENTER OMITTED OPERAND
         B     LEGP1A                   NO...PRESS ON
*      INTERNAL RETURN TO IGNORE CHARACTER
LEGOP1   BAL   R4,TESTND
*      CHARACTER WAS SIGNIFICANT - SDT CAN'T FOLLOW
LEGOP2   OI    MVBYTE,X'20'             DISALLOW S.D.T.
LEGP1A   C     INPTR,ENDCOL             END OF CARD TEST
         BH    CAT00A                   YES, PROCESS  AS SAME
         ST    INPTR,SAVEIN
         BAL   LINK,TRTEST               GET NEXT TERMINATOR
         LR    INPTR,1                  SET INPUT POINTER
         AR    2,2                      DEVELOP CORRECT BRANCH
         LH    WORK1,BRANCH(2)           ADDRESS DETERMINED BY
         B     USEADR(WORK1)            CATEG. NO. RETURNED IN REG. 2
*       BRANCH ON CATEGORY NUMBER                            CAT.
BRANCH   DC    AL2(LEGOP1-USEADR)       ILLEGAL CHAR.OR PAST END  0
         DC    AL2(CAT01-USEADR)        A FEW SPECIAL CHARACTERS  1
         DC    AL2(CAT02-USEADR)         LEFT PAREN
         DC    AL2(CAT03-USEADR)        QUOTE                     3
         DC    AL2(CAT04-USEADR)        AMPERSAND                 4
         DC    AL2(LEGOP1-USEADR)       ARITHMETIC OPERATOR +,-,*,/
         DC    AL2(CAT06-USEADR)        L'                        6
         DC    AL2(CAT07-USEADR)        POSSIBLE S.D.T            7
         DC    AL2(CAT03-USEADR)        T'                        8
         DC    AL2(CAT12A-USEADR)        RELATIONAL                9
         DC    AL2(CAT12A-USEADR)          OPERATORS              10
         DC    AL2(CAT11-USEADR)        DIGIT HEADED ALPHAMERIC  11
         DC    AL2(CAT12-USEADR)        LETTER HEADED ALPHAMERIC 12
* NORMAL RETURN TO CALLER
RETLEG   L     LINKR,SVLNKR
         BR    LINKR
*
         EJECT
*        END OF CARD
CAT00A   CLI   PARLVL+1,0
         BNE   NOBAL                    PARENS DO NOT BALANCE ..ERROR
         MVI   0(INPTR),BLANK           DUMMY END OF CARD
         BCTR      INPTR,0             POINT TO END COLUMN
         CLI       0(INPTR),COMMA      WAS END COLUMN A COMMA
         LA        INPTR,1(,INPTR)     RESET POINTER
         BE        NULOP               BRANCH IF COMMA
         B     CAT12                      AND PROCESS OPERAND
*       PRIVILEGED SPECIAL CHARACTER
COMVAL   DC    H'43'                    COMMA
CAT01    SR    WORK1,WORK1
         IC    WORK1,0(0,INPTR)         SET
         SH    WORK1,COMVAL              UP
         AR    WORK1,WORK1                BRANCH
         LH    WORK1,BRNCH1(WORK1)
         B     USEADR(WORK1)
BRNCH1   DC    AL2(COM01-USEADR)        COMMA
         DC    AL2(EQU01-USEADR)        EQUALS
         DC    AL2(CAT04-USEADR)        AMPERSAND
         DC    AL2(LEGOP1-USEADR)       PERIOD
         DC    AL2(CAT02-USEADR)        LEFT PAREN
         DC    AL2(RPAR01-USEADR)       RIGHT PAREN
         DC    AL2(CAT03-USEADR)        QUOTE
         DC    AL2(BLK01-USEADR)        BLANK
*    COMMA
COM01    CLI   PARLVL+1,0
         BNE   LEGOP1                   TREAT AS TEXT
         BCTR  INPTR,0                  BACK UP ONE
COM01A   CLI   0(INPTR),COMMA           WAS IT ALSO COMMA .Q
         LA    INPTR,1(0,INPTR)         RESET INPUT POINTER
         BE    NULOP                    OUTPUT OMITTED OPERAND IF YES
         BAL   R1,PUTST1                ELSE PUT OUT TEXT
         B     RETLEG                    AND RETURN
*   EQUALS
EQU01    CLI   PARLVL+1,0               IF BETWEEN PARENS, IT IS
         BNE   LEGOP1                   JUST A NORMAL SYMBOL
         C     INPTR,INTPTR             ONLY LEGIT IF FIRST CHAR.
         BE    LEGOP1                   TREAT AS TEXT
         CLC   NPRIME,H0                IF PROCESSING SUBLIST...BACK UP
         BE    ILTERM                    EQUALS SIGN NOT VALID HERE
         B     LEGOP1                   TREAT AS OKAY
*   RIGHT PARENTHESIS
RPAR01   BAL   R1,DPARCT                DECREMENT PAREN LEVEL
         BNL   LEGOP1                   BR IF NOT EXCESS R PAREN
         MVI   ERRCOD,1                 SIGNAL MAIN PROGRAM POS. ERROR
         BCT   INPTR,COM01A             BACK UP ONE, SET TO RETURN
*   BLANK
BLK01    BCTR  INPTR,0                  BACK UP ONE
         CLI   0(INPTR),COMMA           WAS IT COMMA BLANK
*   COMMA,BLANK ... POSSIBLE ALTERNATE FORMAT
         BNE   STRET                    NOT COMMA BLANK, WRAP IT UP
         CLI   PARLVL+1,0
         BNE   NOBAL                   UNBALENCED PARENS
         ST    INPTR,ENDCOL             PREPARE FOR NEXT CARD
         LA    INPTR,1(0,INPTR)         POINT TO CONTINUATION COL (73)
         TM    SWTCH4,CONBIT            IS CONTINUATION BIT ON
         BZ    NULOP                    OUTPUT OMITTED OPERAND IF NOT
         L     LINK,GETAD               GET NEXT
         BALR  LINK,LINK                 CARD
         DC    AL2(4)
         CLI   0(INPTR),BLANK           WAS LAST ONE CONTINUED .Q
         BNE   ALTFMT                   BR IF YES, ELSE
         B     NULOP                    OUTPUT OMITTED OPERAND
STRET    CLI   PARLVL+1,0
         BNE   NOBAL                    ERROR,PARENS DO NOT BALANCE
         LA    INPTR,1(0,INPTR)
         BAL   R1,PUTST1                      OUTPUT TEXT
         B     RETLEG                   ALL OK,PRESS ON
ALTFMT   CLC   NPRIME,H0                CHECK SUBLIST OPERAND COUNT
         BNE   SUBNXT              PROCESSING SUBLIST
         BCT   OPTR,NXTOP1         GET NEXT OPERAND
*   COMMA,COMMA OR COMMA,BLANK..OUTPUT OMITTED OPERAND
NULOP    MVC   0(3,OPTR),OMITOP         OUTPUT OPERAND
         LA    OPTR,3(0,OPTR)           UPDATE POINTER
         B     RETLEG
OMITOP   DC    AL1(O),X'270032'         OMITTED OPERAND
         EJECT
*    LEFT PARENTHESIS
CAT02    BAL   R1,APARCT                UP IT
         BAL   R4,TESTND                ADVANCE INPUT POINTER
         OI    MVBYTE,X'10'             INDICATE LEFT PAREN READ
         B     LEGP1A                   RETURN FOR NEXT STRING
*   FIRST CHARACTER IS A QUOTE
CAT03    OI    MVBYTE,2                 ENTER QUOTE MODE
         BAL   R4,TESTND                ADVANCE INPUT POINTER
         CLI   0(INPTR),QUOTE           TEST FOR SECOND QUOTE
         BNE   QUCAT5                   BR IF NOT
QURTRN   NI    MVBYTE,X'FD'             PAIRED QUOTES, IGNORE
         BAL   LINK,OUTIT               CHECK OPERAND LENGTH.
         B     LEGOP1                   LEAVE QUOTE MODE
*   ...BUT NOT PAIRED QUOTES- LOOK FOR AMPERSANDS AND NEXT QUOTE
QUCAT5   CLI   0(INPTR),AMPSND          ONLY OTHER SIGNIFICANT CHAR.
         BNE   QUCAT6                   IGNORE IT IF IT AIN'T
         BAL   R4,TESTND                ADVANCE INPUT POINTER
         CLI   0(INPTR),AMPSND          IF PAIRED AMPS,IGNORE
         BNE   GTVSYM                   ELSE.. PROCESS VARIABLE SYMBOL
QUCAT6   BAL   R4,TESTND                ADVANCE INPUT POINTER
         BAL   LINK,OUTIT               CHECK OPERAND LENGTH
QUCAT7   CLI   0(INPTR),QUOTE           KEEP LOOKING FOR QUOTE
         BE    QURTRN                   FOUND IT...LEAVE
         B     QUCAT5                   KEEP LOOKING
*        PROCESS  VARIABLE SYMBOL
GTVSYM   BAL   LINKR,ISVSYM
         LR    INPTR1,INPTR             RESET POINTER
         B     QUCAT7                   PRESS ON
*    OUTPUTS ANY TEXT PRECEDING VARIABLE SYMBOL
*        AND SWALLOWS EXPLICIT CONCAT. DOT IF IT EXISTS
*              BAL  LINKR,ISVSYM
ISVSYM   ST    LINKR,SVLNR1
         TM        SWTCH1,16           VAR SYM INVALID AS
         BO        ILPROT                PROTOTYPE KW PARM
         BCTR  INPTR,0                  POINT TO INITIAL AMPERSAND
         BAL   R1,PUTST1
         TM    SWTCH7,64                DOES THIS CONTINUE A CONCAT
         BO    ISVS1                      STRING .Q. BR IF YES
         MVI   0(OPTR),EVAL
         MVI   1(OPTR),EVAL             EVAL FLAG
         LA    OPTR,2(0,OPTR)
ISVS1    BAL   LINK,VARSYM              PROCESS V.S.
*        (ON RETURN, RREG POINTS TO RSTACK FLAG BYTE)
         CLI   8(RREG),X'80'            TEST FOR UNSUBSCRIPTED SYSLIST
         BE    ILSYSL                   ERROR
         OI    SWTCH7,64                NXT TIME ... NO EVAL FLAG
         L     LINKR,SVLNR1
         CLI   0(INPTR),DOT             TEST EXPLICIT CONCATENATION
         BCR   7,LINKR                  (BNE) NO- RETURN
         LA    INPTR,1(0,INPTR)         SWALLOW PERIOD
         BR    LINKR                   RETURN
         EJECT
*        INITIAL AMPERSAND
CAT04    BAL   R4,TESTND                ADVANCE INPUT POINTER
         CLI   0(INPTR),AMPSND          TEST FOR SECOND AMP
         BE    LEGOP1                   PAIRED AMPS...JUST TEXT
         BAL   LINKR,ISVSYM             PROCESS V.S.
         LR    INPTR1,INPTR             RESET INPUT POINTER
         B     LEGOP2
*
*
*     ONLY SIGNIFICANT STRING IS L'
CAT06    BCTR  INPTR,0                  BACK UP ONE
         CLI   0(INPTR),L               QUOTE PRECEDED BY LETTER..L
         LA    INPTR,1(0,INPTR)
         BNE   CAT03                    JUST A CHARACTER STRING
         BAL   R4,TESTND                GET NEXT CHARACTER
         BAL   R4,TSTLET                DOES A LETTER FOLLOW
         BCT   INPTR,CAT03              NO,..POINT TO QUOTE
         B     LEGOP2                   YES,TREAT AS TEXT
         EJECT
*   SCAN FOR POSSIBLE SELF DEFINING TERM
CAT07    BAL   LINK,TSTSDT              IS S.D.T. VALID NOW
         BNE   CAT03                    NO...JUST A CHARACTER STRING
         ST    OPTR,SVOPTR
         MVI   0(OPTR),N                STORE TYPE 'N'
         LA    OPTR,1(0,OPTR)
         BCTR  INPTR,0                  POINT TO LETTER
         BAL   LINK,AT20                PROCESS S.D.T.,IF VALID
         B     BKITUP                   NOT A LEGAL S.D.T,ONLY CHARS.
*    S.D.T MUST STAND ALONE, HENCE TERMINATOR MUST BE END OF OPERAND
         CLI   0(INPTR),COMMA           COMMA
         BE    LEGSDT
         CLI   0(INPTR),BLANK           BLANK
         BE    LEGSDT
         CLI   0(INPTR),RPAREN          RIGHT PAREN
         BNE   CAT07A                   GIVE IT ONE MORE CHANCE
         BAL   R1,DPARCT                REDUCE PAREN COUNT
         BNL   BKITUP                   NOT A SUBLIST
         OI    ERRCOD,1                 EXCESSIVE RGT. PAREN
LEGSDT   L     INPTR1,INTPTR            OUTPUT CHARACTER STRING
         BAL   R1,PUTSTR                OUTPUT CHARACTER STRING
         B     RETLEG                   END OF OPERAND
*
CAT07A   C     INPTR,ENDCOL             VALID STAND ALONE IF TRUE
         BNH   BKITUP                   S.D.T. DOES NOT STAND ALONE
         MVI   0(INPTR),BLANK           DUMMY UP END OF CARD
         B     LEGSDT                   AND PROCESS OPERAND
BKITUP   L     OPTR,SVOPTR              RESET POINTER
         L     INPTR,INTPTR              RESCAN TEXT
         LR    INPTR1,INPTR              AS CHARACTER STRING ONLY
         B     LEGOP1
*
         EJECT
*   ALPHAMERIC STRING HEADED BY A DIGIT
CAT11    CLI   0(INPTR),BLANK           IF IT DOESN'T STAND ALONE
         BE    BLK11                    TREAT IT JUST AS MORE TEXT
         CLI   0(INPTR),X'FF'           HAS END OF STMT BEEN REACHED .Q
         BE    LEGP1A                   BIF YES, LEGP1A-CAT00A-CAT12-11
         CLI   0(INPTR),COMMA            IN A CHARACTER STRING
         BE    COM11
         CLI   0(INPTR),RPAREN
         BE    RPAR11
         CLI   0(INPTR),LPAREN
         BE    CAT11A                   LEFT PAREN TERMINATED
         BH    LEGOP2                   TREAT STRING AS TEXT
CAT11A   BAL   LINK,TSTSDT              DETERMINE IF SYMBOL VALID HERE
         BE    CAT11B                   POSSIBLY
         B     LEGOP2                   NO -EDIT AS TEXT
CAT11B   CH    2,H24                    MUST HAVE COME HERE VIA CAT12
         BNE   LEGOP2                   NO -TREAT STRING AS TEXT
         ST    INPTR,SVLNR1             SAVE POINTERS FOR POSSIBLE
         ST    OPTR,SVOPTR                BACK UP
         L     INPTR,SAVEIN             POINT TO FIRST BYTE OF STRING
         LA    OPTR,1(0,OPTR)           GENERATE ONE DUMMY BYTE
         BAL   LINK,ATR18               TRY TO EDIT AS A SYMBOL
         B     CAT11C                   RETURNS HERE IF INVALID, ELSE
         LA    OPTR,3(0,OPTR)           CREATE THE DUMMY AND CONTINUE
         OI    MVBYTE,X'40'               PROCESSING THE OPERAND
         CLI   0(INPTR),RPAREN
         BE    LEGOP1
         B     LEGOP2
CAT11C   L     OPTR,SVOPTR              BACK UP POINTERS AND
         L     INPTR,SVLNR1
         B     LEGOP2                     PROCESS THE OPERAND AS TEXT
*   COMMA
COM11    CLI   PARLVL+1,0               IF PARENS DON'T BALANCE
         BNE   LEGOP1                   NOT SIGNIFICANT COMMA
*   BLANK
BLK11    CLI   PARLVL+1,0
         BNE   NOBAL                    ERROR
BLK11A   BAL   LINK,TSTSDT              IS S.D.T. LEGIT HERE
         BE    POSDSD                   RETURNS HERE IF YES, ELSE
BLK11B   BAL   R1,PUTST1                OUTPUT TEXT
         B     RETLEG                    AND RETURN
*RIGHT PAREN
RPAR11   BAL   R1,DPARCT                IF PAREN COUNT NOT NEG
         BNL   PAR11A                   CHECK ON PRECEDING TEXT
         OI    ERRCOD,1                SET EXCESSIVE RGT PAREN
         B     BLK11A
PAR11A   BAL   R4,TESTND                ADVANCE INPUT POINTER AND
         B     CAT11A                     CONTINUE TESTS
POSDSD   ST    INPTR,SVLNR1             SAVE POINTERS
         ST    OPTR,SVOPTR              FOR POSSIBLE BACKUP
         LR    INPTR,INPTR1             POINT TO FIRST CHAR.
         MVI   0(OPTR),N                TYPE 'N'
         LA    OPTR,1(0,OPTR)           UPDATE POINTER
         CH    2,H24               IF ENTERED FROM AN-STG BRANCH
         BE    POSSYM              YES... MAY BE SYMBOL
         BAL   LINK,AT18                PROCESS DSDT
         B     BKUP1                    BACKIT UP
         BAL   R1,PUTSTR
         B     RETLEG
BKUP1    L     OPTR,SVOPTR
         L     INPTR1,INTPTR            RESET POINTERS
         L     INPTR,SVLNR1
         B     BLK11B
POSDS1   BAL   R1,PUTSTR           OUTPUT STRING
         B     RETLEG
POSSYM   BAL   LINK,ATR18               TRY TO EDIT AS SYMBOL
         B     BKUP1                    NO, JUST A CHARACTER STRING
         LA   OPTR,3(0,OPTR)            YES, SYMBOL WAS TAKEN CARE OF
         B     POSDS1              FOLLOWED BY THE TEXT
H24      DC    H'24'
         EJECT
*    ALPHAMERIC STRING HEADED BY LETTER
CAT12A   LA    2,24                     DUMMY IT UP
CAT12    CLI   0(INPTR),EQUALS          POSSIBLE KEY WORD
         BNE   CAT11                     NOPE
         CLC   NPRIME,H0                CHECK SUBLIST COUNT
         BNE   EQU01                    PROCESSING SUBLIST
         BAL   LINK,TSTSD1              LAST CHECK FOR K.W.
         BNE   EQU01                    NO KEYWORD HERE
         TM    SWTCH7,32             IF ALREADY PROCESSING KEYWORD 6608
         BO    EQU01                   KILL IT                     6608
         BCTR  OPTR,0
         BAL   R1,PUTPUT                OUTPUT KEYWORD FLAG
         DC    AL2(KEYFLG)
         BAL   R1,PUTSTR                NOW THE NAME
         BAL   LINK,UPKEY               INCREMENT KEY COUNTER
         OI    SWTCH7,32                SET K.W. INDICATOR
         CLI   0(INPTR),BLANK
         BE    BLNKOP                   OMITTED OPERAND,END OF M-I
         C     INPTR,ENDCOL             MAY BE END OF CARD
         BH    BLNKOP                   OMITTED OPERAND
         BAL   LINK,NXTOP0         PROCESS NEXT OPERAND
         B         MISCAN2         HERE WE GO AGAIN
*
KEYPOS   DS    0H
         TM    PARBYT1,EXTEN            IS EXTEN ON .Q
         BCR   0,LINK    (WAS 1)        IGNORE ERROR IF YES (SOME DAY)
         ST    LINK,SAVEM+4             SAVE RETURN REGISTER
         BAL   LINK,WRNERR              SET ERROR MESSAGE, POSITIONAL
         DC    AL1(ERRR22)              PARAMETER FOLLOWS KEYWORD
         DC    AL1(ERRST)               PARAMETER
         L     LINK,SAVEM+4             RESTORE RETURN REGISTER
         BR    LINK                     AND RETURN
*TESTND    UPDATES THE INPUT POINTER AND BRINGS IN THE NEXT
*         CARD IF PAST ENDCOL
*        TSTND1 DOES NOT UPDATE INPUT POINTER
*                        BAL  R4,TESTND  OR  BAL R4,TSTND1
TESTND   LA    INPTR,1(0,INPTR)
TSTND1   C     INPTR,ENDCOL             TEST IF INPTR PAST END COLUMN
         BCR   13,R4                    NO...RETURN
TSTND2   NI    MVBYTE,X'FE'             TURN OFF NEW CARD INDICATOR
         TM    SWTCH4,X'02'             PROCESSING M-I .Q
         BO    WASMI                    PRESENTLY PROCESSING M-I
TSTRET   BR    R4                       RETURN
WASMI    TM    SWTCH4,CONBIT            IS IT CONTINUED
         BZ    TSTQUT                   END OF LOGICAL CARD - GO EXIT
         ST    LINK,SAVEM+4
         L     LINK,GETAD               GET NEXT
         BALR  LINK,LINK                 CARD
         DC    AL2(4)
         L     LINK,SAVEM+4
         OI    MVBYTE,1                 INDICATE NEW CARD READ
         BR    R4
TSTQUT   TM    MVBYTE,2
         BO    NOQUOT
         BR    R4                      RETURN TO CALLER
         EJECT
*  TSTLET    ...TEST FOR LEGITIMATE LETTER
*              CALLING SEQUENCE
*                 BAL  R4,TSTLET
*                     RETURNS TO 0(R4) IF NOT A LETTER
*                     RETURNS TO 4(R4) IF IT IS A LETTER
TSTLET   CLI   0(INPTR),ATSIGN
         BCR   2,R4                     OUTSIDE RANGE OF LETTERS
         CLI   0(INPTR),N9
         BCR   13,R4                    DIGIT IS NO GOOD
         B     4(R4)                    IS LEGIT
*     ROUTINE DETERMINES IF A SELF DEFINING TERM IS ALLOWED AT THIS
*        PARTICULAR POINT IN THE MACRO INSTRUCTION OPERAND
*              CALLING SEQUENCE IS    BAL  LINK,TSTSDT
*              RETURNS TO 0(LINK)..IF IT IS LEGIT W/C.C. SET TO 8
*              RETURNS TO 4(LINK) .. IF NOT ALLOWED         (FOR EQUAL)
TSTSDT   CH    2,H24
         BNE   TSTSD1                   NOT SYMBOL,MAY BE LEGIT SDT
         TM    SWTCH5,X'41'            MUST BE OPEN CODE OR EXTEN PARM
         BZ    4(0,LINK)                NOT MAINLINE CODE...RETURN
         TM    SWTCH1,MASK3             IS A PROTO EXPECTED .Q
         BO    4(0,LINK)                THEN NO SDT HERE
         TM    MVBYTE,X'20'             =1 IF SDT DISALLOWED HERE
         BCR   8,LINK                   (BZ) NO- RETURN
TSTSD1   TM    MVBYTE,X'30'             MUST NOT HAVE PRECEDING TEXT
         BCR   7,LINK                   (BNZ) TEXT PRECEDES THIS TERM
         C     INPTR1,INTPTR            WAS THIS FIRST ACTION
         BR    LINK                     PASSED INITIAL TEST WITH HONORS
         EJECT
*ROUTINE 'PROSCN'
*FUNCTION- CHECKS PROTOTYPE OPERAND FIELD SYNTAX AND EDITS TO OUTPUT
*   BUFFER.
*   ENTERS PARAMETERS INTO LOCAL DICTIONARY FOR THE MACRO.
*   WRITES OUT PROTOTYPE EDITED TEXT RECORD AND KEYWORD OPERAND
*   VALUE RECORDS.
*OPERATION- EACH PARAMETER IS ASSIGNED A PARAMETER NUMBER, STARTING
*   WITH POSNOINT  (0 - &SYSNDX, 1 - &SYSECT, 2 - &SYSDATE,
*   3 - &SYSTIME, 4 - &SYSTYP, 5 - &SYSPARM, 6 - THE NAME
*   FIELD BY THE 'PROTO' ROUTINE). ALL POSITIONAL PARAMETERS MUST
*   PRECEDE ALL KEYWORD PARAMETERS. THE VARIABLE SYMBOLS AND PARAMETER
*   NUMBERS ARE PLACED IN THE LOCAL DICTIONARY FOR THE MACRO. FOR
*   POSITIONAL PARAMETERS, THE ONLY EDITED OUTPUT IS THE TOTAL NUMBER
*   OF PP'S, INSERTED INTO THE PROTOTYPE EDITED TEXT RECORD. FOR
*   KEYWORDS, THE NAME AND OPERAND VALUE ARE PLACED IN AN EDITED TEXT
*   OPERAND VALUE RECORD.
*ENTRY POINT-
*        B     PROSCN
*EXTERNAL ROUTINES-
*   OUTIT1- ADJUSTS INPUT POINTERS.
*   TESTND- DITTO, AND GET NEXT CARD IF NEEDED.
*   TSTLET- TESTS IF CHARACTER IS ALPHABETIC.
*   TRTEST- SCANS FOR TERMINATORS.
*   OUTITA- SHIFTS INPUT BUFFER LEFT TO MAKE ROOM FOR MORE.
*   GETSRC- GETS CONTINUATION CARDS.
*   PUTSTR- MOVES KEYWORD NAMES TO OUTPUT BUFFER.
*   NXTOP0- PROCESSES OPERANDS OF KEYWORD PARAMETERS.
*   ENDOPR- WRITES OUT EDITED RECORDS.
*   ENTDCT- MAKES DICTIONARY ENTRIES.
*   WRNERR- WRITES OUT ERROR WARNING MESSAGES.
*NORMAL EXITS-
*   IF NO KEYWORD PARAMETERS,
*        B     NDPSCN
*   IF ANY KEYWORDS,
*        B     RPUPFD
*ERROR EXITS- ON SYNTAX ERRORS, TO ONE OF THE FOLLOWING-
*   ILPROT
*   ILSYSL
*   ABSERR
PROSCN   DS    0H
         SR    LINK,LINK                ZERO A WORK REGISTER
         STH   LINK,NRKEY               ZERO KEYWORD PARAMETER COUNT
         STH   LINK,POSNO               ZERO POSITIONAL PARAMS
         BAL   LINK,OUTIT1              SET INPUT POINTERS
PRSCN1   CLI   0(INPTR),AMPSND             MUST BE FIRST CHAR.
         BNE   PRBLK                    BETTER BE A BLANK
         BAL   R4,TESTND                STEP INPTR, GET CARD IF NEEDED
         BAL   R4,TSTLET                TEST FOR ALPHA
         BAL   LINK,ILVSWR1             ERROR...INVALID V.S. (WARNING)
         BAL   LINK,TRTEST              GET NEXT TERMINATOR
         LR    INPTR,1
         CLI   0(INPTR),COMMA
         BNE   NOTCOM                   NOT A COMMA
         BAL   R1,ISVALD                IF PARAMETER IS VALID,PROCESS
PRSCN2   BAL   LINK,OUTITA               MOVE TO BEGIN. OF INPUT
         B     PRSCN1                   GET NEXT PARAMETER
NOTCOM   CLI   0(INPTR),BLANK
         BE    NTCMA               VALID TERMINATOR
         C     INPTR,ENDCOL        MAY BE END OF CARD
         BNH   NTBORC              BETTER BE EQUALS
NTCMA    BAL   R1,ISVALD                IF ENDCOL, CHECK FOR VALID V.S.
NTCM1    BAL   LINKR,RPPFD1
         B     NDPSCN                   END OF PROTO STATEMENT- EXIT
*
PRBLK    CLI   0(INPTR),BLANK
         BNE   PRCOM                    BRANCH IF NOT TO CHECK COMMA
         BCTR  INPTR,0
         CLI   0(INPTR),COMMA
         BNE   NTCM1                    END OF PROTOTYPE
         TM    SWTCH4,CONBIT            ALTERNATE FMT IF CARD FOLLOWS
         BO    PRBLK1                   CONTINUATION IS PRESENT
         TM    PARBYT1,EXTEN            IS EXTEN ON .Q
         BZ    ILPROT                   NO, ERROR AS WITH (F)
         CLC   NRKEY,H0                 ANY KEYWORDS DONE YET .Q
         BNE   ILPROT                   TOO LATE NOW IF YES
         B     NTCM1                    OTHERWISE END OF PROTOTYPE
PRBLK1   DS    0H
         ST    INPTR,ENDCOL             PREPARE FOR NEXT CARD
         LA    INPTR,1(,INPTR)          BUMP PAST COMMA
         L     LINK,GETAD               BR TO GETSRC FOR NEXT CARD
         BALR  LINK,LINK
         DC    AL2(4)
         CLI   0(INPTR),BLANK
         BE    ILPROT                   ERROR...OMITTED OPERAND
         BCT   INPTR,PRSCN2             PNT TO COMMA,GET NEXT PARAM.
*  TERMINATOR IS NOT BLANK OR COMMA. CHECK IF KEYWORD.
NTBORC   CLI   0(INPTR),EQUALS
         BNE   ILPROT                   ILLEGAL TERMINATOR
         CLC   NRKEY,H0                 HAVE WE BEEN HERE BEFORE
         BNE   *+8                      YES
         BAL   LINKR,RPPFD1             NO- INITIALIZE FOR KEYWORDS
*
         L     INPTR1,INTPTR            BACK TO START OF KW
         BAL   R1,ISVLD1                ENTER KW NAME IN DICT, IF VALID
         BAL   LINK,UPKEY               INCREMENT KEY COUNTER
         MVI   0(OPTR),KEYFLG           KW FLAG TO OUTPUT BUFFER
         LA    OPTR,1(0,OPTR)
         LA    INPTR1,1(0,INPTR1)       GET PAST AMPERSAND
*        IF TERMINATOR ENDED CARD, LOOK FOR A CONTINUATION
         BAL   R4,TESTND
         BAL   R1,PUTSTR                KW NAME TO OUTPUT BUFFER
         OI    SWTCH7,32           SET K.W. INDICATOR
         CLI   0(INPTR),BLANK           IS OPERAND OMITTED
         BE    BLNKOP                   YES...END OF ALL OPERANDS
         C     INPTR,ENDCOL        MAY BE END OF CARD
         BH    BLNKOP              YES...OUTPUT OMITTED OPERAND
         BAL   LINK,NXTOP0              PROCESS OPERAND
         B     PRSCN1                   GET NEXT PARAMETER
*
PRCOM    DS    0H
         TM    PARBYT1,EXTEN            IS EXTEN ON .Q
         BZ    ILPROT                   INVALID TERMINATOR IF NOT
         CLI   0(INPTR),COMMA           NULL POSITIONAL OPERAND .Q
         BNE   ILPROT                   INVALID TERMINATOR IF NOT
         BAL   LINKR,UPPOS              INCREMENT POSITIONAL COUNT
         BAL   LINK,OUTITA              GET NEXT PARAMETER
         B     PRSCN1                   GET NEXT PARAMETER
*
BLNKOP   MVC   1(3,OPTR),OMITOP
         LA    OPTR,4(0,OPTR)           OUTPUT OMITTED OPERAND
         MVI   OUTPUT,SMSPAR            RECORD TYPE INTO FIRST BYTE
          B    RPUPFD                   TERMINATE PROTO. SCAN
*
*        WRAP UP POSITIONAL PARAMS
*
RPPFD1   DS    0H
         MVC   0(2,OPTR),POSNO         NUMBER OF POSITIONAL PARAMS
         LA    OPTR,1(,OPTR)           BUMP OUTPUT POINTER TO END
         OI    SWTCH6,4                FORCE LOOKUP BYPASS IN ENDOPR
         BAL   LINK,ENDOPR              WRITE PROTO EDITED TEXT RECORD
         BR    LINKR                    RETURN
*    ISVALD    VALIDATES  PARAM. AND MAKES DICTIONARY ENTRY
*              BAL  R1,ISVALD           FOR POSITIONAL PARAMETERS
*              BAL  R1,ISVLD1           FOR KEY WORD PARAMETERS
ISVALD   DS    0H
         CLC   NRKEY,H0                 ANY KEYWORD PARMS .Q
         BE    ISVLD1                   BRANCH IF NONE
         BAL   LINK,KEYPOS              ERROR PP FOLLOWS KW  (WARNING)
ISVLD1   DS    0H
         TM    SWTCH7,X'10'             IS PARAMETER ERROR SWITCH ON .Q
         BZ    *+10                     BIF NO
         NI    SWTCH7,X'EF'             YES, SO RESET IT
         BR    R1                       AND RETURN.
*
         CLC   1(7,INPTR1),SYSL
         BE    ILSYSL                   SYSLIST ILLEGAL PARAM
         CH    R2,H6                    360 LENGTH OF STRING
         LR    LINK,R1                  SET RETURN IF ERROR
         BH    ILVSWR                   TOO MANY CHARACTERS
         LA    R2,1(0,R2)               ONE FOR THE AMPERSAND
         EX    R2,MOV3                  MOVE TO ENTRY AREA FOR DICT
         STC   R2,DCAREA                STORE LENGTH
         OI    DCAREA,PSYM              FLAG BYTE
         BAL   LINKR,UPPOS              BUMP POSITIONAL COUNT
         AH    WORK1,POSNOINT           PLUS INITIAL DUMMIES
         STH   WORK1,DUMMY              SAVE RESULTS
         LA    WORK1,DCAREA+2(R2)       BUMP PAST SYMBOL
         MVC   0(2,WORK1),DUMMY         ENTER POSITIONAL SEQUENCE NO.
*./      DELETE    SEQ1=68420020,SEQ2=68520020
*    ALL SET  TO MAKE DICTIONARY ENTRY
         L     LINK,DUSING              ADDRESS OF DICTIONARY ROUT.
         BALR  LINK,LINK                MAKE DICTIONARY ENTRY
         CLI   DERR,0
         BCR   8,R1                     RETURN IF NO DUPLICATES
ISVLD2   BAL   LINK,WRNERR              DUPLICATE SYMBOLIC PARAMETER
         DC    AL1(ERRR47)
         DC    AL1(ERRST)
         BR    R1                       RETURN
PSYM     EQU   X'48'                    PARAMETER FLAG FOR DICT.
*
MOV3     MVC   DCAREA+1(*-*),0(INPTR1) ENTER PARAMETER NAME
ILVSWR1  OI    SWTCH7,X'10'             SET PARAMETER ERROR SWITCH
ILVSWR   ST    LINK,SAVEM+4             SAVE LINK
         BAL   LINK,WRNERR              INVALID FORMAT FOR V.S.
         DC    AL1(ERRR43)
         DC    AL1(ERRST)
         L     LINK,SAVEM+4             RESTORE LINK
         BR    LINK                     AND RETURN.
*
*          SUBROUTINE TO UPDATE KEYWORD PARAMETER COUNT
*           BAL     LINK,UPKEY
*
UPKEY    LH    WORK1,NRKEY
         LA    WORK1,1(,WORK1)          INCREMENT K.W. COUNT
         STH   WORK1,NRKEY
         BR    LINK
         SPACE 2
*
*        SUBROUTINE TO UPDATE AND CHECK POSITIONAL PARAM COUNT
*        BAL   LINKR,UPPOS
*        RETURNS WORK1 CONTAINS CURRENT UPDATED COUNT
*
UPPOS    DS    0H
         LH    WORK1,POSNO              GET CURRENT COUNT
         LA    WORK1,1(,WORK1)          UPDATE COUNT BY ONE
         STH   WORK1,POSNO              SET CURRENT NEW COUNT
         CH    WORK1,POSNOMAX           IS IT TOO BIG .Q
         BCR   13,LINKR                 (BNHR) RETURN IF NOT
MANYERR  DS    0H
         BAL   LINK,ABSERR              TOO MANY POSITIONAL
         DC    AL1(ERRR23)              PARAMETERS IN
         DC    AL1(ERRST)               MACRO PROTOTYPE
*PUTSTR
*        ROUTINE TO WRITE INPUT TEXT TO THE OUTPUT BUFFER
*        BAL   R1,PUTSTR
*        (RETURN)
PUTST1   C     INPTR1,INTPTR            OUTPUT TYPE BYTE ONLY IF
         BH    PUTSTR                   FIRST ELEMENT OF OPERAND
         TM    MVBYTE,X'40'               OR IF OPERAND HAS NOT BEEN
         BO    PUTSTR                     EDITED AS A SYMBOL
         LR    R4,INPTR
         SR    R4,INPTR1
         BCR   12,R1                    NO CHARACTERS TO MOVE
         MVI   0(OPTR),U                TYPE 'UNDEFINED'
         LA    OPTR,1(0,OPTR)
         B     PUTSTR+6                 OUTPUT TEXT
PUTSTR   LR    R4,INPTR
         SR    R4,INPTR1                R4 = TEXT LENGTH
         BCR   12,R1                    (BZ) EXIT IF NOTHING TO PUT
         ST    OPTR,SVPTR               SAVE LOCATION OF C.S. FLAG
         MVI   0(OPTR),SCEXPR           SET C.S. FLAG IN TEXT
         STC   R4,1(OPTR)               FOLLOWED BY TRUE LENGTH BYTE
         BCTR  R4,0                     FOLLOWED BY TEXT
         EX    R4,PU2
         LA    OPTR,3(R4,OPTR)          ADVANCE THE OUTPUT POINTER
         BR    R1                         AND EXIT
PU2      MVC   2(*-*,OPTR),0(INPTR1)    OUT-OF-LINE MOVE TEXT
         EJECT
LINK     EQU   3                        LINK FROM CALLER.
*./      DELETE    SEQ1=69640020,SEQ2=69640020
*./      DELETE    SEQ1=69660020,SEQ2=69820020
ATYPE    EQU   9
ITYPE    EQU   14
JTYPE    EQU   18
MTYPE    EQU   20
TTYPE    EQU   21
WTYPE    EQU   13
WETYPE   EQU   27
WRKREG   EQU   2                        WORK REGISTER
LREG     EQU   WRKREG
RR0      EQU   5                        LINK REGISTER
*./      DELETE    SEQ1=70020022,SEQ2=70020022
MASK0    EQU   X'80'
MASK1    EQU   X'40'
MASK2    EQU   X'20'
MASK3    EQU   X'10'
MASK4    EQU   X'08'
MASK5    EQU   X'40'
MASK7    EQU   X'01'
MASK13   EQU   X'50'
*      ILOPRF- ILLEGAL OPERAND FIELD FORMAT
NMASK3   EQU   X'EF'
NMASK7   EQU   X'FE'
         EJECT
*ROUTINE 'GSCAN'
*FUNCTIONS- GENERAL SCANNER TO CLASSIFY ALL INPUT TEXT EXCEPT SEQUENCE
*   SYMBOLS, SET OPERANDS, MACRO INSTRUCTION OPERANDS, AND COMMENTS.
*   SCAN RESULTS ARE RETURNED IN LOCATION GSUMRY.
*   INPUT TEXT IS EDITED TO OUTPUT BUFFER.
*   OPERAND LIST POINTER (OPNDL) ENTRIES ARE MADE FOR
*     1. VARIABLE SYMBOLS,
*     2. ONE SEQUENCE SYMBOL, IF IT IS NOT PRECEDED BY ANYTHING EXCEPT
*        NORMAL SYMBOLS,
*     3. ONE NORMAL SYMBOL, IF IT IS NOT PRECEDED BY ANYTHING EXCEPT
*        NORMAL SYMBOLS, BUT ONLY IF IT IS LAST OPERAND BEFORE EXIT.
*ENTRY POINT-
*        BAL   LINK,GSCAN
*INPUTS-
*   GCALL (BYTE)- SCAN EXTENT INDICATOR, SET BY CALLER-
*     =0 TO SCAN ENTIRE FIELD (EXIT ON BLANK OR END OF STATEMENT),
*     =1 TO SCAN ONE OPERAND (EXIT ON COMMA, BLANK, OR END OF STMT).
*   INPTR (REG)- POINT TO STRING IN INPUT BUFFER.
*   OPTR (REG)- POINT TO NEXT FREE LOC IN OUTPUT BUFFER.
*   RREG- POINT TO FLAG BYTE IN CURRENT OPNDL ENTRY.
*OUTPUTS-
*   GSUMRY (BYTE)- SCAN RESULTS...
*        BIT 0   =1 STRING CONTAINS VARIABLE SYMBOL
*            1   =1 STRING CONTAINS A QUOTED STRING
*            3   =1 VARIABLE SYMBOL IS CONCATENATED
*            4   =1 STRING IS UNCLASSIFIABLE AT THE META LEVEL
*            5   =1 STRING IS A NORMAL SYMBOL
*            6   =1 STRING IS A DECIMAL INTEGER
*            7   =1 STRING IS A SEQUENCE SYMBOL
*   OPNDL ENTRIES.
*   EDITED TEXT (IN PHASE F3 INPUT FORMAT) IN OUTPUT BUFFER.
*EXTERNAL ROUTINES-
*   TRTEST- ANALYZES OPERAND ELEMENTS. RETURNS CATEGORY AND TYPE NOS.
*   PUTSTR- MOVES OPERAND ELEMENTS TO OUTPUT BUFFER.
*   VARSYM- SCANS VARIABLE SYMBOLS.
*   EOPNDL- CREATES OPNDL ENTRIES.
*NORMAL EXIT-
*        BR    LINK
*ERROR EXITS-
*   GO TO ABSERR VIA...
*      ILSYSL- UNSUBSCRIPTED SYSLIST
*      NOQUOT- ODD QUOTE COUNT
*
GSCAN    STM   2,10,SAVREG
         LA    R3A,GSCAN-USEBAS-4096(,B2)  DEFINE THE BASE
         USING GSCAN,R3A                TELL IT TO THE ASSEMBLER
         XC    PARLVL(5),PARLVL         ZERO PAREN NESTS
         XC    SVPTR(4),SVPTR           ZERO SAVED OUTPUT POINTER
         LA    R1,RSTACK                RESET RECURSION STACK POINTER
         ST    R1,AVSP
GS03     LR    INPTR1,INPTR             SAVE INPUT POINTER
*        TRANSLATE AND TEST STRING AT INPTR
GS05     LA    LINK,GS10                SET RETURN LINKAGE
         TM    GSTAT,128                IF IN QUOTE MODE.....
         BZ    TRTEST                   (BR IF NOT)
         LA    R3,2                     ..STOP ONLY ON QUOTES
         MVC   PNCTAB+39(12),GS100        AND AMPERSANDS
         B     TRTESN+6
*        BRANCH TO PROCESSOR FOR TRT CATEGORY
*        (TRTEST REGISTER RESULTS-
*              REG 1- ADDRESS OF TERMINATING CHARACTER,
*              REG 2- CATEGORY NUMBER,
*              REG R2- LENGTH-1,
*              REG R3- TYPE NUMBER)
GS10     AR    2,2
         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE
         LH    R1,GS15(2)
         B     USEBAS(R1)
*                                 CATEGORIES...
GS15     DC    AL2(GS20-USEBAS)   0 1ST CHAR IS NON-ASM
         DC    AL2(GS45-USEBAS)   1             ,=.) OR BLANK
         DC    AL2(GS24-USEBAS)   2             (
         DC    AL2(GS30-USEBAS)   3             '
         DC    AL2(GS35-USEBAS)   4             &
         DC    AL2(GS24-USEBAS)   5             +-* OR /
         DC    AL2(GS40-USEBAS)   6 STRING IS L' S' I' N' OR K'
         DC    AL2(GS40-USEBAS)   7           C' X' OR B'
         DC    AL2(GS40-USEBAS)   8           T'
         DC    AL2(GS55-USEBAS)   9           AND NOT OR
         DC    AL2(GS55-USEBAS)  10           EQ NE LT GT LE GE
         DC    AL2(GS55-USEBAS)  11 DECIMAL (D) STRING - 1ST CHAR NUM
         DC    AL2(GS55-USEBAS)  12 ALPHANUM (AN) STRING - 1ST IS ALPHA
         EJECT
*        NON-ASSEMBLER CHARACTER
GS20     C     INPTR,ENDCOL             TEST IF PAST THE END COLUMN
         BH    GS70                     YES -EXIT
GS22     TM    GSTAT,128                IF NOT IN QUOTE MODE.....
         BO    GS25                     (BR IF YES)
GS24     OI    GSUMRY,8                 INDICATE THE IMPURITY
GS25     LA    INPTR,1(0,INPTR)         STEP INPUT POINTER AND TAKE
         B     GS05                       ANOTHER SHOT
*        AMPERSAND
GS35     LA    INPTR,1(0,INPTR)         ASSUME DOUBLE
         CLI   0(INPTR),AMPSND          VERIFY
         BE    GS22                     YES
         BCTR  INPTR,0                  C'EST LA VIE
         BAL   R1,PUTSTR                OUTPUT PRIOR TEXT
         BAL   LINK,VARSYM              SCAN VARIABLE SYMBOL
         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE
         CLI   8(RREG),128              UNSUBSCRIPTED SYSLIST IS
         BE    ILSYSL                    AN ERROR
         MVC   SVPTR(4),PNCTAB          ZERO SAVED OUTPUT POINTER
         TM    GSUMRY,255               SET CONCATENATION INDICATOR
         BZ    *+8                        IF APPLICABLE
         OI    GSUMRY,16
         OI    GSUMRY,128               SET V.S. INDICATOR
         CLI   0(INPTR),DOT             SWALLOW A TERMINATING PERIOD
         LA    INPTR,1(0,INPTR)
         BE    GS03
         BCT   INPTR,GS03
*        LETTER FOLLOWED BY QUOTE
GS40     CLI   0(INPTR),L               TEST FOR LEGITIMATE L-QUOTE
         LA    INPTR,1(0,INPTR)           CONSTRUCTION
         BNE   GS29                     BR IF NOT L
         CLI   1(INPTR),A
         BL    GS29                     BRANCH IF ' FOLLOWED BY DIGIT.
         CLI   1(INPTR),Z+3             IS IT L'ALPHA-NUMERIC STRING?
         BNH   GS24                     YES
         CLI   1(INPTR),STAR            (INCLUDING L'*)
         BE    GS24                     OH YES, OH MY, THRILLING
GS29     OI    GSUMRY,8                 NO
*        QUOTE
GS30     XI    GSTAT,128                FLIP THE INDICATOR
         OI    GSUMRY,64                TELL THE WORLD
         TM    GSTAT,MASK0              WAS IT AN ODD QUOTE .Q
         BO    GS25                     BRANCH IF YES
*        IF EVEN QUOTE - ARE WE PROCESSING PUNCH, MNOTE
         TM    SWTCH3,MASK5             OR TITLE
         BZ    GS25                     NO, WE ARE NOT
*        IF YES - TEST WHAT FOLLOWS EVEN QUOTE
         CLI   N1(INPTR),BLANK          BLANK FOLLOWS .Q
         BE    GS25                     YES, NO PROBLEMS
         CLI   N1(INPTR),QUOTE          ANOTHER QUOTE .Q
         BE    GS25                     YES, EVERYTHING OK
         C     INPTR,ENDCOL             IS IT ENDCOL .Q
         BE    GS25                     YES, EVERYTHING OK
         B     ILOPRF                   NOT PERMITTED CHARACTER
*                                          FOLLOWS AN EVEN QUOTE
*        ,=.) OR BLANK
GS45     CLI   0(INPTR),COMMA           WE ARE ONLY INTERESTED IN A
         BE    GS75                       SELECT FEW
         CLI   0(INPTR),BLANK
         BE    GS70
         CLI   0(INPTR),DOT
         BNE   GS24
         LA    INPTR,1(0,INPTR)         THE PERIOD MAKES A GREAT START
         LA    R3,2                       TOWARD A SEQUENCE SYMBOL
         BAL   LINK,TRTESN+6
         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE
         BCTR  INPTR,0
         CH    2,H12                    MUST BE .ALPHANUM STRING
         BNE   GS24                     TOO BAD
         LA    R2,1(0,R2)               ADD 1 BACK TO LENGTH FOR THE .
*
*        ALPHA-NUMERIC STRING
GS55     TM    GSUMRY,255               ANYTHING DONE YET
         BNE   GS85                     BR IF YES
         CH    R2,H8                    NO -TEST FOR LENGTH L.E. 8
         BNL   GS85
         CLI   0(1),BLANK               AND FOR PROPER TERMINATOR
         BE    GS57                     A BLANK IS ALWAYS GOOD
         CLI   0(1),COMMA               IF NOT BLANK OR COMMA, GO SEE
         BNE   GS83                       IF IT WAS ENDCOL
         CLI   GCALL,1                  COMMA- DOES CALLER WANT IT .Q
         BNE   GS85                     BR IF NOT
GS57     CLI   0(INPTR),N9              BRANCH IF DIGIT HEAD
         BNH   GS80
         BAL   R1,EOPNDL                NO -CREATE OPERAND LIST ENTRY
         LA    R3A,GSCAN-USEBAS-4096(,B2)  RE-DEFINE THE BASE
         LA    R1,128(0,R2)             SET UP FLAG BYTE FOR OPNDL
         MVI   GSUMRY,4                 ASSUME NORMAL SYMBOL
         CLI   0(INPTR),DOT
         BNE   GS60
         MVI   GSUMRY,1                 WRONG -IT IS A SEQUENCE SYMBOL
         LR    INPTR1,1                 ADVANCE SAVED PTR TO KILL OUTPT
         LA    R1,32(0,R1)              CHANGE OPNDL FLAG TO SEQ SYM
GS60     STC   R1,OPNDL(RB)             INSERT FLAG IN OPNDL
GS65     LR    INPTR,1                  ADVANCE INPUT POINTER
*
*        EXIT  GSCAN
GS70     TM    GSTAT,128                BOMB ON ODD QUOTE COUNT
         BO    NOQUOT
         BAL   R1,PUTSTR                OUTPUT PRIOR TEXT
         LM    2,10,SAVREG
         BR    LINK
*
*        MISCELLANY
*
GS75     CLI   GCALL,1                  IF INDICATED BY CALLER,
         BE    GS70                       EXIT ON A COMMA
         B     GS24
*
*        FOR LEADING DIGIT...
GS80     MVC   PNCTAB+10(29),TRSLTB     SET TO STOP TRT ON NON-NUMERIC
         EX    R2,NN14                  TRT OPERAND AGAINST PNCTAB
         MVC   PNCTAB+10(29),PNCTAB     CLEAR PNCTAB
         BNE   GS85                     BR IF ANY NON-NUMERIC
         MVI   GSUMRY,2                 INDICATE INTEGER AND EXIT
         B     GS65
*
GS83     C     1,ENDCOL
         BH    GS57
GS85     AR    INPTR,R2                 OTHERWISE, PLOD ONWARD
         B     GS24
*        TRT TABLE TO STOP ON AMPERSANDS AND QUOTES
GS100    DC    X'000000000000040000000300'
         DROP  R3A                      SAFETY FIRST
         SPACE 2
* OPSYN PROCESSOR
         SPACE 2
EREG     EQU   5                        ERROR CODE REGISTER
PREG     EQU   6                        OPND SYMBOL-TABLE PNTR
DREG     EQU   9                        ERROR LINK REG
         USING OPSSIN,AUXREG
OPSSIN   ST    LINK,OPS99               SAVE RETURN REG
         LA    DREG,OPS44               SET UP ERROR LINK
         MVI   DENTRY,0                 SET FOR OP-CODE LOOKUP
         LA    EREG,ERRR56
         TM        SWTCH8,X'80'         IS OPSYN LEGAL HERE?
         BCR   7,DREG                   NO (BNZR)
         TM    SWTCH5,MASK1             ARE WE INTO OPEN CODE .Q
         BCR   7,DREG                   YES, (BNZR) OPSYN NOT ALLOWED
         LA    EREG,ERRR7
         CLI   NAMBYT,0                 ANY NAME?
         BCR   8,DREG                   NO
         LA    EREG,ERRR2
         CLI   NAMBYT,4                 ORDINARY SYMBOL?
         BCR   7,DREG                   NO
         SR    PREG,PREG                CLEAR OPND POINTER
         C     INPTR,ENDCOL             OPERAND OMITTED?
         BH    OPS4                     YES
         CLC   0(2,INPTR),COMMABL
         BE    OPS4                     YES
         LR    TEMPRG,INPTR             SAVE OPERAND PNTR
         MVI   GCALL,1                  SET COMMA STOPPER
         BAL   LINK,GSCAN               SCAN OPERAND
         C     INPTR,ENDCOL             RECORD END?
         BH    OPS2                     YES
         LA    EREG,ERRR3
         CLI   0(INPTR),BLANK           BLANK DELIMITER?
         BCR   7,DREG                   NO
OPS2     LA    EREG,ERRR54
         CLI   GSUMRY,4                 ORDINARY SYMBOL?
         BCR   7,DREG                   NO
         NI    OPNDL+4,7                SAVE LENGTH - 1
         MVC   DCAREA+1(8),0(TEMPRG)    SET UP DICTIONARY
         MVC   DCAREA(1),OPNDL+4        WORK AREA
         L     LINK,DUSING              LOOKUP OPERAND
         BALR  LINK,LINK                AS MACHINE OP
         LTR   PREG,EPTR                FOUND?
         BCR   4,DREG                   NO
         LA    EREG,ERRR55
         BCR   8,DREG                   NO
         B     OPS22
OPS4     XC    SVPTR(4),SVPTR           FORCE BLANK OPERAND
OPS22    NI    OPNDL,7                  SAVE L - 1
         L     TEMPRG,INPUT             POINT TO NAME
         MVC   DCAREA+1(8),0(TEMPRG)    SET UP DICTIONARY
         MVC   DCAREA(1),OPNDL          WORK AREA
         L     LINK,DUSING              LOOKUP NAME
         BALR  LINK,LINK                AS MACHINE OP
         LA    EREG,ERRR2
         LTR   EPTR,EPTR                MACHINE OP?
         BCR   4,DREG                   NO
         BP    OPS6                     FOUND
         LA    EREG,ERRR55              NOT FOUND
         LTR   PREG,PREG                DELETION?
         BNZ   OPS55                    NO
OPS44    STC   EREG,OPS5                SET ERROR CODE
         BAL   LINK,ABSERR              FLAG AND SKIP EDITED TEXT
OPS5     DC    AL1(0),X'0D'
OPS6     LTR   PREG,PREG                DELETION?
         BNZ   OPS8                     NO
         MVI   1(EPTR),0                DELETE NAME
         B     OPSOUT                   EXIT
OPS8     TM    0(PREG),X'10'            OPND EXTENDED OP?
         BO    OPS33                    YES
OPS11    BAL   LINK,OPS69               CHANGE NAME OP
         B     OPSOUT                   EXIT
OPS33    TM    0(EPTR),X'10'            NAME EXTENDED OP?
         BO    OPS11                    YES
         MVI   1(EPTR),0                NO ROOM, DELETE NAME
OPS55    L     EPTR,DENTRY              POINT TO DCAREA
         BAL   LINK,OPS69               UPDATE NAME OP
         MVI   DENTRY,X'80'             FORCE DICTIONARY INSERT
         L     LINK,DUSING              GO ENTER NEW OP
         BALR  LINK,LINK
         MVC   ENDOPC(4),PNDX           UPDATE OP-CODES LIMIT
OPSOUT   L     LINK,OPS99               RETURN
         BR    LINK
OPS69    NI    0(EPTR),7                CLEAR EXTENDED OP FLAG
         IC    ZERORG,0(EPTR)           GET NAME L-1
         LA    WORKRG,2(EPTR,ZERORG)    ACCESS HEX CODE
         IC    ZERORG,0(PREG)           GET OPND FLAG BYTE
         N     ZERORG,F7                L-1
         LA    TEMPRG,2(PREG,ZERORG)    ACCESS HEX CODE
         MVC   0(2,WORKRG),0(TEMPRG)    MOVE HEX OP AND ASC/MASK
         TM    0(PREG),X'10'            OPND EXTENDED OP?
         BCR   8,LINK                   NO, RETURN
         OI    0(EPTR),X'10'            SET NAME EXTENDED
         MVC   2(1,WORKRG),2(TEMPRG)    MOVE ASC
         BR    LINK                     RETURN
*
         DROP  AUXREG                   SAFETY FIRST
         EJECT
BASE1    DC        0H'0'
         DC    AL2(AIF-BASE)
         DC    AL2(AGO-BASE)
         DC    AL2(ANOP-BASE)
         DC    AL2(COPY-BASE)
         DC    AL2(MACRO-BASE)
         DC    AL2(MNOTA-BASE)
         DC    AL2(MEXIT-BASE)
         DC    AL2(MEND-BASE)
         DC    AL2(ICTL-BASE)
         DC    AL2(ISEQ-BASE)
         DC    AL2(PRINT-BASE)
         DC    AL2(SPACE-BASE)
         DC    AL2(EJECT-BASE)
         DC    AL2(PUNCH-BASE)
         DC    AL2(REPRO-BASE)
         DC    AL2(TITLE-BASE)
         DC    AL2(ENTRY-BASE)
         DC    AL2(EXTRN-BASE)
         DC    AL2(START-BASE)
         DC    AL2(CSECT-BASE)
         DC    AL2(DSECT-BASE)
         DC    AL2(COM-BASE)
         DC    AL2(EQU-BASE)
         DC    AL2(ORG-BASE)
         DC    AL2(END-BASE)
         DC    AL2(LTORG-BASE)
         DC    AL2(USING-BASE)
         DC    AL2(DROP-BASE)
         DC    AL2(ACTR1-BASE)
         DC    AL2(DC-BASE)
         DC    AL2(DS-BASE)
         DC    AL2(CCW-BASE)
         DC    AL2(CNOP-BASE)
         DC    AL2(1)                   INVALID, OPCODE=2A
         DC    AL2(DXD-BASE)
         DC    AL2(CXD-BASE)
         DC    AL2(OPSYN-BASE)
         DC    AL2(WXTRN-BASE)
         DC    AL2(POP-BASE)
         DC    AL2(PUSH-BASE)
         DC    AL2(1)                   INVALID, OPCODE=31
*./      DELETE    SEQ1=74150025,SEQ2=74270025
         EJECT
*        TABLE USED BY SETA,SETB,SETC OPERAND SCANNER
         DS    0H                       ACTION ROUTINE NUMBERS
MS40     DC    AL2(AROP-USEBAS)          1
         DC    AL2(ATERMA-USEBAS)        2
         DC    AL2(ATERMB-USEBAS)        3
         DC    AL2(ATTROP-USEBAS)        4
         DC    AL2(BOOLOP-USEBAS)        5
         DC    AL2(ILOPRF-USEBAS)        6
         DC    AL2(CEXITA-USEBAS)        7
         DC    AL2(CEXITB-USEBAS)        8
         DC    AL2(CEXITC-USEBAS)        9
         DC    AL2(CEXITE-USEBAS)       10
         DC    AL2(CSETBA-USEBAS)       11
         DC    AL2(CSETBE-USEBAS)       12
         DC    AL2(TRANSC-USEBAS)       13
         DC    AL2(CSETC-USEBAS)        14
         DC    AL2(MBOOL-USEBAS)        15
         DC    AL2(RELOP-USEBAS)        16
         DC    AL2(VSYMRK-USEBAS)       17
         DC    AL2(TBLANK-USEBAS)       18
         DC    AL2(TCOMP-USEBAS)        19
         DC    AL2(TRANSA-USEBAS)       20
         DC    AL2(ILOPRF-USEBAS)       21
         DC    AL2(ILXPR-USEBAS)        22
         EJECT
*        STATE TRANSITION TABLE FOR METSCN ROUTINE
*
* METSCN IS DRIVEN BY THE STATE TRANSITION TABLE. STATE TABLE ENTRIES
* ARE INTERPRETED SEQUENTIALLY, UNLESS TRANSFER IS INDICATED BY AN 'SS'
* ENTRY, OR AN ACTION ROUTINE ALTERS THE SEQUENCE.
*
* STATE TABLE ENTRY FORMATS-
*
*  AL1(0)      TRANSLATE&TEST STRING AT INPTR.
*  AL1(255)    TRANSFER TO NEXT TABLE ENTRY.
*  AL1(128+X)  EXECUTE ACTION ROUTINE X. STRING MUST BE 'NOT' OPERATOR.
*  AL1(64+X)   EXECUTE ACTION ROUTINE X. STRING MUST BE 'AND' OR 'OR'.
*  AL1(X)      EXECUTE ACTION ROUTINE X.
*  AL1(SSX)    TRANSFER TO TABLE ENTRY SX.
*  AL1(X*16+Y) ACTION LIST HEADER. X = NUMBER OF BYTES IN THIS LIST
*                (INCLUDING THE HEADER). TRTEST CATEGORY MUST EQUAL Y
*                TO EXECUTE THIS LIST, OTHERWISE SKIP TO TABLE ENTRY
*                FOLLOWING THIS LIST.
         SPACE 3
*        STATE TRANSITION TABLE FOR METSCN
S1       DC    AL1(0)         TRT       TRANSLATE AND TEST
         DC    AL1(255)       TACT      TRANSFER INTO ACTION MODE
         DC    AL1(20)        TRANSA    IF SETA ENTRY,
         DC    AL1(SS4)                   TO S4
         DC    AL1(13)        TRANSC    IF SETC ENTRY,
         DC    AL1(SS16)                  TO S16
         DC    AL1(18)        TBLANK    SCAVENGE BLANKS, THEN TO
         DC    AL1(SS1)                   STATE S1, OTHERWISE
         DC    AL1(19)        TCOMP     TRANSFER INTO COMPARE MODE
         DC    AL1(4*16+9)    IF(BOOL)  IF BOOLEAN OPERATOR
         DC    AL1(128+5)     BOOLOP,NOT  PERFORM BOOLOP(NOT)
         DC    AL1(SS3)                   TO S3
S3       DC    AL1(0)         TRT
S4       DC    AL1(6*16+2)    IF(LPAR)  IF LEFT PARENTHESIS,
         DC    AL1(12)        CSETBE      PERFORM CSETBE
         DC    AL1(SS7)       RETURN-1  SIMPLE
         DC    AL1(SS21)      RETURN-2  COMPLEX
         DC    AL1(SS10)      RETURN-3  SETA EXPRESSION
         DC    AL1(SS97)      RETURN-4  SETC EXPRESSION (ERROR)
S6       DC    AL1(255)       TACT
         DC    AL1(20)        TRANSA
         DC    AL1(SS23)
         DC    AL1(19)        TCOMP
         DC    AL1(3*16+4)    IF(AMPSND)
         DC    AL1(17)        VSYMRK    PERFORM VSYMRK
         DC    AL1(SS7)                 TO SS7
S16      DC    AL1(6*16+8)    IF(TQUOTE)
         DC    AL1(4)         ATTROP
         DC    AL1(SS17)
S16A     DC    AL1(0)         TRT
         DC    AL1(6*16+3)    IF(QUOTE)
         DC    AL1(19)        TCOMP
         DC    AL1(6*16+3)    IF(QUOTE)
         DC    AL1(14)        CSETC
         DC    AL1(SS16A)               EXIT-1 (RE-ENTER CSETC)
         DC    AL1(SS17)                EXIT-2 (END OF CHAR. EXPR)
         DC    AL1(255)       TACT
         DC    AL1(6)         CERROR
S23      DC    AL1(255)       TACT
         DC    AL1(13)        TRANSC
         DC    AL1(SS98)
         DC    AL1(2)         ATERMA
         DC    AL1(SS10)
S7       DC    AL1(0)         TRT
         DC    AL1(3*16+10)   IF(RELOP)
         DC    AL1(16)        RELOP
         DC    AL1(SS12)
         DC    AL1(3*16+9)    IF(BOOL)
         DC    AL1(64+15)     MBOOL,BOOLOP(AND,OR)
         DC    AL1(SS22)
         DC    AL1(3*16+5)    IF(ARITH-OP)
         DC    AL1(1)         AROP
         DC    AL1(SS9)
         DC    AL1(4*16+1)    IF(TCHAR) IF A TERMINAL CHARACTER,
         DC    AL1(18)        TBLANK      CHECK FOR BLANK WHICH FORCES
         DC    AL1(SS8)                   TRANSITION TO STATE S8,
         DC    AL1(10)        CEXITE      OTHERWISE, EXIT THIS DIAGRAM
         DC    AL1(255)       TACT
         DC    AL1(10)        CEXITE
S8       DC    AL1(0)         TRT
         DC    AL1(3*16+10)   IF(RELOP)
         DC    AL1(16)        RELOP
         DC    AL1(SS12)
         DC    AL1(3*16+9)    IF(BOOL)
         DC    AL1(64+15)     MBOOL,BOOLOP(AND,OR)
         DC    AL1(SS22)
         DC    AL1(255)       TACT
         DC    AL1(10)        CEXITE
S9       DC    AL1(0)         TRT
         DC    AL1(6*16+2)    IF(LPAR)
         DC    AL1(11)        CSETBA
         DC    AL1(SS10)
         DC    AL1(SS99)
         DC    AL1(SS10)
         DC    AL1(SS99)
         DC    AL1(255)       TACT
         DC    AL1(3)         ATERMB
         DC    AL1(SS10)
S10      DC    AL1(0)         TRT
         DC    AL1(3*16+5)    IF(ARITH-OP)
         DC    AL1(1)         AROP
         DC    AL1(SS9)
         DC    AL1(255)       TACT
         DC    AL1(20)        TRANSA
         DC    AL1(SS10A)
         DC    AL1(19)        TCOMP
         DC    AL1(3*16+10)   IF(RELOP)
         DC    AL1(16)        RELOP
         DC    AL1(SS12)
         DC    AL1(4*16+1)    IF(TCHAR)
         DC    AL1(18)        TBLANK
         DC    AL1(SS11)
         DC    AL1(7)         CEXITA
S10A     DC    AL1(255)       TACT
         DC    AL1(7)         CEXITA
S11      DC    AL1(0)         TRT
         DC    AL1(3*16+10)   IF(RELOP)
         DC    AL1(16)        RELOP
         DC    AL1(SS12)
S97      DC    AL1(255)       TACT
         DC    AL1(21)        CERROR    RELATIONAL OPERATOR EXPECTED
S12      DC    AL1(0)         TRT
         DC    AL1(6*16+2)    IF(LPAR)
         DC    AL1(11)        CSETBA
         DC    AL1(SS13)
         DC    AL1(SS99)
         DC    AL1(SS13)
         DC    AL1(SS99)
         DC    AL1(255)       TACT
         DC    AL1(3)         ATERMB
         DC    AL1(SS13)
S13      DC    AL1(0)         TRT
         DC    AL1(4*16+5)    IF(ARITH-OP)
         DC    AL1(1)         AROP
         DC    AL1(SS12)
S21      DC    AL1(0)         TRT
         DC    AL1(3*16+9)    IF(BOOL)
         DC    AL1(64+5)      BOOLOP(AND,OR)
         DC    AL1(SS22)
         DC    AL1(4*16+1)    IF(TCHAR)
         DC    AL1(18)        TBLANK
         DC    AL1(SS14)
         DC    AL1(8)         CEXITB
         DC    AL1(255)       TACT
         DC    AL1(8)         CEXITB
S14      DC    AL1(0)         TRT
         DC    AL1(3*16+9)    IF(BOOL)
         DC    AL1(64+5)      BOOLOP(AND,OR)
         DC    AL1(SS22)
         DC    AL1(255)       TACT
         DC    AL1(8)         CEXITB
S17      DC    AL1(255)       TACT
         DC    AL1(13)        TRANSC
         DC    AL1(SS17A)
         DC    AL1(19)        TCOMP)
         DC    AL1(0)         TRT
         DC    AL1(3*16+10)   IF(RELOP)
         DC    AL1(16)        RELOP
         DC    AL1(SS19)
         DC    AL1(4*16+1)    IF(TCHAR)
         DC    AL1(18)        TBLANK
         DC    AL1(SS18)
         DC    AL1(9)         CEXITC
S17A     DC    AL1(255)       TACT
         DC    AL1(9)         CEXITC
S18      DC    AL1(0)         TRT
         DC    AL1(3*16+10)   IF(RELOP)
         DC    AL1(16)        RELOP
         DC    AL1(SS19)
         DC    AL1(255)       TACT
         DC    AL1(21)        CERROR    RELATIONAL OPERATOR EXPECTED
S19      DC    AL1(0)         TRT
         DC    AL1(4*16+8)    IF(TQUOTE)
         DC    AL1(4)         ATTROP
         DC    AL1(SS21)
S19A     DC    AL1(0)         TRT
         DC    AL1(4*16+3)    IF(QUOTE)
         DC    AL1(14)        CSETC
         DC    AL1(SS19A)
         DC    AL1(SS21)
S98      DC    AL1(255)       TACT
         DC    AL1(22)        CERROR    ILLEGAL OPERAND FIELD FORMAT
         SPACE     5
SS1      EQU   S1-S1
SS3      EQU   S3-S1
SS4      EQU   S4-S1
SS6      EQU   S6-S1
SS16     EQU   S16-S1
SS23     EQU   S23-S1
SS7      EQU   S7-S1
SS8      EQU   S8-S1
SS9      EQU   S9-S1
SS10     EQU   S10-S1
SS10A    EQU   S10A-S1
SS11     EQU   S11-S1
SS12     EQU   S12-S1
SS13     EQU   S13-S1
SS21     EQU   S21-S1
SS14     EQU   S14-S1
SS17     EQU   S17-S1
SS17A    EQU   S17A-S1
SS18     EQU   S18-S1
SS19     EQU   S19-S1
SS99     EQU   S98-S1
SS16A    EQU   S16A-S1
SS19A    EQU   S19A-S1
SS22     EQU   S1-S1
SS97     EQU   S97-S1
SS98     EQU   S98-S1
         EJECT
*
*        EXTENDED EQU PROCESSOR
         SPACE     2
EQU      DS        0H
         TM        PARBYT1,EXTEN       WAS EXTEN SPECIFIED .Q
         BZ        MCHINS              NO EXTENDED EQU IF NOT
         BALR      AUXREG,0            ADDRESSABILITY
         USING     *,AUXREG            AND TELL ASSEMBLER
         STM       OPTR,INPTR,TEMP     SAVE INPUT AND OUTPUT POINTERS
         MVI       GCALL,X'01'         SET COMMA AS SCAN TERMINATOR
         BAL       LINK,SKPBLK         SKIP TO OPERAND
         IC        ZERORG,OPNDX        RETAIN OPERAND INDEX
         STC       ZERORG,SOPNDX       IN SAVE OPNDX
         BAL       LINK,GSCAN          SCAN 1ST OPERAND
         MVI       GCALL,X'00'         RESET COMMA INDICATOR
         CLI       0(INPTR),BLANK      BLANK TERMINATOR .Q
         BE        MCHIN1              YES, THEN ALL DONE
         STC       ZERORG,OPNDX        BACKUP OPERAND INDEX
         CLI       0(INPTR),COMMA      COMMA DELIMITER .Q
         BNE       ILTERM              BAD TERMINATOR IF NOT
         LA        INPTR,1(,INPTR)     POINT TO START OF NEXT
         CLI       0(INPTR),COMMA      IS 2ND OPERAND NULL .Q
         BE        EQU1SET             BRANCH IF YES
         L         OPTR,TEMP           DUMP SCANNED OUTPUT
         BAL       LINK,TRTEST         DETERMINE TYPE
         STC       R3,EQUTYPE          SAVE TYPE OF S.D.T.
         LA        LINK,EQU1RET        LOAD RETURN ADDRESS
         CH        RB,H11              IS IT D.S.D.T. .Q
         BE        AT18                BRANCH IF YES
         CH        RB,H7               HEX, BIN, CHAR S.D.T. .Q
         BE        AT20                BRANCH IF YES
         MVI       GCALL,X'01'         SET COMMA AS SCAN TERMINATOR
         BAL       LINK,GSCAN          BUMP OVER NON-S.D.T. FOR NOW
         MVI       GCALL,X'00'         RESET COMMA TERMINATOR
         B         EQU1SET             GO SET DUMMY TYPE
EQU1RET  DS        0H
         B         ILEQUA              ILLEGAL S.D.T.
         CLI       EQUTYPE,SCSDT       IS IT C.S.D.T. .Q
         BNE       EQU1ARND            BRANCH IF NOT
         TR        SDTEMP(4),TRSLTB    TRANSLATE TO BINARY
EQU1ARND DS        0H
         L         R2,SDTEMP           GET VALUE
         C         R2,F65535           IS IT TOO BIG .Q
         BH        ILEQUA              ILLEGAL IF YES
         LTR       R2,R2               IS IT TOO SMALL .Q
         BM        ILEQUA              ILLEGAL IF YES
         BCTR      R2,0                DECREMENT LENGTH BY ONE
         STH       R2,LNGTAT           SET LENGTH OF EQU
EQU1SET  DS        0H
         MVI       SCLATR,X'80'        MARK AS EXTENDED EQU
         MVI       SCLATR+1,U          TYPE U AS DEFAULT
         CLI       0(INPTR),BLANK      IS IT A BLANK .Q
         BE        EQUEND              BRANCH IF YES
         CLI       0(INPTR),COMMA      A COMMA .Q
         BNE       ILTERM              BAD DELIMITER IF NOT
         LA        INPTR,1(,INPTR)     POINT TO NEXT CHAR
         L         OPTR,TEMP           SCAN OUTPUT TO BE DUMPED
         BAL       LINK,TRTEST         DETERMINE TYPE
         STC       R3,EQUTYPE          SAVE TYPE OF S.D.T.
         LA        LINK,EQU2RET        LOAD RETURN ADDRESS
         CH        RB,H11              IS IT D.S.D.T. .Q
         BE        AT18                BRANCH IF YES
         CH        RB,H7               HEX, BIN, CHAR S.D.T. .Q
         BE        AT20                BRANCH IF YES
EQU2RET  DS        0H
         B         ILEQUA              ILLEGAL S.D.T.
         CLI       EQUTYPE,SCSDT       IS IT C.S.D.T. .Q
         BNE       EQU2ARND            BRANCH IF NOT
         TR        SDTEMP(4),TRSLTB    TRANSLATE TO BINARY
EQU2ARND DS        0H
         L         R2,SDTEMP           SET VALUE
         C         R2,F255             TOO BIG .Q
         BH        ILEQUA              ILLEGAL IF YES
         LTR       R2,R2               TOO SMALL .Q
         BM        ILEQUA              ILLEGAL IF YES
         STC       R2,TYPATR           SET TYPE ATTRIBUTE
         TR        TYPATR(1),TRSLTB    TRANSLATE TO INTERNAL CODE
         MVC       SCLATR+1(1),TYPATR  AND RETAIN ACTUAL TYPE
         CLI       0(INPTR),BLANK      BLANK DELIMITER .Q
         BNE       ILTERM              BAD DELIMITER IF NOT
EQUEND   DS        0H
         LM        OPTR,INPTR,TEMP     RESET POINTERS
         MVC       OPNDX(1),SOPNDX     RESET OPERAND INDEX
         B         MCHINS              AND CONTINUE
         SPACE     2
ILEQUA   DS        0H
         BAL       LINK,ABSERR         LOG THE ERROR
         DC        AL1(ERRR108)        INVALID EQU ARGUMENT
         DC        AL1(ERRST)          ERROR INDICATION
         SPACE     2
         DROP      AUXREG              SAFETY FIRST
         EJECT
*
* PROCESS PROTOTYPE NAME FIELD
*
PROTOA   DS    0H
         LA    R3A,GSCAN                BASE ADDRESS
         USING GSCAN,R3A                AND TELL THE ASSEMBLER
         MVI   OUTPUT,X'06'             PROTO FLAG TO OUTPUT TEXT
         LA    OUTPTR,OUTPUT+10         RESET OUTPUT POINTER
         MVI   DENTRY,X'80'             POINT OF DEFN FOR DICT
* INSERT UT1 NOTE/POINT INTO MACRO LOCAL DICTIONARY TO POINT TO
* EDITED PROTOTYPE RECORD.
*
         IC    ZERORG,0(0,WORKRG)        MOVE NOTE INTO DICTIONARY
         LA    RR0,DCAREA+4(ZERORG)           ENTRY
         MVC   0(3,RR0),BWBLKS+BWFNOT
         L     LINK,DUSING              BR TO ENTDCT TO ENTER MACRO
         BALR  LINK,LINK                 NAME IN GLOBAL DICT
         TM    DERR,X'18'               TEST ENTDCT ERR INDIC
         BZ    PRTCHZ                   BR IF NONE
         BAL   LINK,ABSERR              MACRO NAME ALREADY IN DICT.
         DC    AL1(ERRR11)
         DC    AL1(ERRST)
PRTCHZ   BAL   AUXREG,ISITFF            GET CONTINUATION IF NEEDED
         OI        SWTCH6,2            MUST SUBSET DICTIONARY
         MVI   DEFENT,X'48'             INDICATE MACRO NAME
*        ENTER THE SYSTEM PARAMETERS INTO THE LOCAL DICTIONARY
         L         AUXREG,DUSING       BR ADDR FOR ENTDICT ROUTINE
         MVC       DCAREA(10),SYSNDX   SYSNDX
         BALR      LINK,AUXREG
         MVC       DCAREA+5(5),SYSECT  SYSECT
         BALR      LINK,AUXREG
         TM        SWTCH5,X'01'        TEST EXTEN OPTION
         BZ        PRONAM
         MVC       DCAREA(11),SYSDATE  SYSDATE
         BALR      LINK,AUXREG
         MVC       DCAREA+5(6),SYSTIME SYSTIME
         BALR      LINK,AUXREG
         MVC       DCAREA+5(6),SYSSTYP SYSSTYP
         BALR      LINK,AUXREG
         MVC       DCAREA+5(6),SYSPARM SYSPARM
         BALR      LINK,AUXREG
PRONAM   CLI   NAMBYT,X'00'             TEST IF NAME BLANK
         BE    PROSCN                   IF YES, GO PROCESS OPERAND
         CLI   NAMBYT,X'80'             TEST IF NAME IS VAR SYM
         BNE   BDPROT                   ERROR IF NOT
         IC    ZERORG,SOPNDX            POINT TO NAME FIELD OPNDL
         LA    WORKRG,OPNDL-4(ZERORG)     ENTRY
         TM    0(WORKRG),X'08'          TEST OPNDL FLAG
         BO    BDPROT                   BIF SUBSCRIPT
         TM    0(WORKRG),X'40'
         BZ    BDPROT                   BIF NOT A VARIABLE SYMBOL
         CLI   1(INPTR),N9              IS CHAR AFTER & NOT A LETTER .Q
         BNH   BDPROT                   BIF YES
         MVC   2(2,WORKRG),POSNOINT     PARAMETER NUMBER END OF DUMMIES
         L     TEMPRG,DLOOKUP           LOOKUP ENTERS NAME FIELD INTO
         BALR  TEMPRG,TEMPRG             LOCAL DICT AS PARAMETER 6
         B     PROSCN                   GO PROCESS OPERAND
         DROP  R3A                      SAFETY FIRST
*
*        SYSTEM PARAMETER CONSTANTS
*        FORMAT - FLAG BYTE, NAME IN INTERNAL CODE, PARAMETER NUMBER
SYSNDX   DC        X'4E2D1C221C170D210000'
SYSECT   DC                  X'0E0C1D0001'
SYSDATE  DC        X'4F2D1C221C0D0A1D0E0002'
SYSTIME  DC                  X'1D12160E0003'
SYSSTYP  DC                  X'1C1D22190004'
SYSPARM  DC                  X'190A1B160005'
         EJECT
*
*        IN DAYS OF OLD WHEN IBM WAS BOLD AND CORE WAS VERY PRECIOUS
*        THERE WAS A FIND MACRO HERE. NOW THE SYSLIB NOTE
*        LIST IS INCORE, (OR ELSE WE NEVER GOT HERE),SO LEAVE US
*        GO AND DO A TABLE LOOKUP TO SEE IF HIS OPCODE IS A
*        MACRO OR NOT.
*
*        AND IT CAME TO PASS THAT IN LATER YEARS MORE
*        AND MORE DEMANDS WERE PLACED UPON MACRO FACILITIES,
*        ESPECIALLY THE SYSGEN VARIETY THAT NOW INCLUDE
*        TSO FUNCTIONS.  SO NOW WE DO A TABLE LOOKUP
*        AND IF THE OPCODE IS NOT FOUND AND THE INCORE TABLE
*        IS FULL THEN ENTER THE FIND MACRO TO SAVE THE DAY.
*        NOTE --  UNDER THE CMS OPTION NO INCORE TABLE EXISTS.
*
*        FIRST A NOTE FROM OUR SPONSOR
*
RM0      EQU       0                   RETURN ADDRESS
RM1      EQU       1                   BASE ON ENTRY
RM2      EQU       2                   CONSTANT 11
RM3      EQU       3                   POINTER TO END OF NOTE LIST
RM4      EQU       4                   POINTER TO NAMES IN NOTE LIST
RM5      EQU       5                   BASE OF FIND ROUTINE
RM6      EQU       6                   POINTS TO LIST1 IN ASMGASM
RM7      EQU       7
RM8      EQU       8
RM9      EQU       9
RM10     EQU       10
RM11     EQU       11
RM12     EQU       12
RM13     EQU       13                  POINTS AT COMMON
RM14     EQU       14                  USED BY POINT
RM15     EQU       15                  POINTS TO NAME TO BE FOUND
*
*   WRITES MACRO NAME ONCE ON UT3 IF EDITING SYSTEM MACROS
*                  CALLING SEQUENCE
*                            LA       RM15,ADDRESS OF NAME
*                            L          RM1,=A(FIND)
*                            BALR       RM0,RM1
         EJECT
*
*        NOW LOOK FOR THE MACRO
*
FIND     DS        0H
         ENTRY     FIND
         STM       RM0,RM6,FINDSAVE    SAVE CALLER'S REGISTERS
         LR        RM5,RM1             TRANSFER BASE ADDRESS
         USING     FIND,RM5            AND USE IT
         MVC       MACNAME,0(RM15)     SAVE AWAY THE MACRO NAME
         TR        MACNAME,TRSLTB      IN INTERNAL FORMAT
         L         RM1,ADCBLB          POINT AT SYSLIB DCB
         TM        DCBOFLGS-IHADCB(RM1),X'10'  IS SYSLIB OPEN .Q
         BZ        DONEMAC             NO, THEN MEMBER NOT FOUND
         TM        PARBYT3,CMS         DID USER SPECIFY 'CMS' .Q
         BO        OSFIND              BRANCH IF YES
         L         RM6,ADLIST1         POINT AT LIST1 IN ASMGASM
         L         RM4,L1TOPMC(,RM6)   POINT AT LAST ENTRY IN DIRECTORY
         L         RM3,L1BOTMC(,RM6)   POINT TO FIRST ENTRY
         LA        RM2,12              SET ENTRY LENGTH
         MVC       0(8,RM3),0(RM15)    PLACE NAME TO BE FOUND AT END
         CNOP      0,8                 D ALIGN LOOP FOR MOD 75 PERFORM
LOOKMAC  DS        0H
         SR        RM4,RM2             POINT AT NEXT ENTRY
         CLC       0(8,RM15),0(RM4)    COMPARE NAME AGAINST TABLE
         BNE       LOOKMAC             AND AGAIN
         CR        RM4,RM3             IS THIS LAST ENTRY .Q
         BE        NOTINTAB            YES, CHECK FURTHER
*        MVC       DCBRELAD-IHADCB(3,RM1),8(RM4)  MOVE TTR TO DCB
*        MVI       DCBRELAD-IHADCB+3(RM1),X'00'   THE ZEROTH CONCAT
*        POINT     (1),DCBRELAD-IHADCB(RM1)       POINT TO IT
         FIND  (1),8(RM4),C
         SR        RM15,RM15           SET RETURN CODE
         B         DONEMAC             BRANCH TO FINISH
NOTINTAB DS        0H
         TM        L1SYNERR(RM6),X'08' DID MACRO TABLE OVERFLOW
         BZ        DONEMAC             ERROR IF NOT
         L         RM2,L1FINDCT(,RM6)  GET FIND COUNT
         A         RM2,F1              BUMP FIND COUNT BY ONE
         ST        RM2,L1FINDCT(,RM6)  UPDATE COUNT
         OI        L1SYNERR(RM6),X'04' INDICATE ERROR ASMG209
OSFIND   DS        0H
         FIND      (1),(RM15),D        CAN O/S FIND THE MACRO .Q
DONEMAC  DS        0H
         DROP      RM5                 DROP BASE ADDRESS
         LM        RM0,RM6,FINDSAVE    RESTORE CALLER'S REGISTERS
         LR        RM1,RM0             TRANSFER RETURN ADDRESS
         LTR       RM15,RM15           SET CONDITION CODE
         BR        RM1                 AND RETURN
         SPACE     2
F2END    DC        0D'0'               END OF ASMGF2
         TITLE     'COMMON - ASMGF2 COMMON COMMUNICATION AND WORK AREA'
         COMMON    PHASE=ASMGF2
         DCBD  DSORG=PS
         END       ASMGF2
./ ADD NAME=ASMGF2A  0102-88358-88358-0841-02836-02838-00002-CHSY227
F2A      TITLE     'ASMG     MACRO GENERATOR EDITING PHASE SUBROUTINES'
         ISEQ  73,78
         COPY      ASMGSET
         SPACE     1
ASMGF2A  START
         SPACE 2
*TITLE 'ASMGF2A'... SUBROUTINES FOR ASMGF2                            *
*FUNCTION/OPERATION
*   PROVIDES VARIOUS SUBROUTINES TO BE USED BY MODULE ASMGF2.
*ENTRY POINTS
*        ASCAN      SCANS DC AND DS OPERANDS FOR ATTRIBUTES.
*                             MVI  ACALL,0 (DC) OR MVI  ACALL,1 (DS)
*                             L    LINKR,=V(ASCAN)
*                             BALR LINKR,LINKR
*        BWFORC     INDICATE SIZE OF NEXT LOGICAL RECORD TO BE WRITTEN
*                   ON SYSUT1 OR SYSUT3.
*                             LA   1,0  (UT1)  OR  LA   1,8  (UT3)
*                             LA   0,RECORD-LENGTH
*                             L    RR0,=V(BWFORC)
*                             BALR RR0,RR0
*./      DELETE    SEQ1=00420020,SEQ2=00480020
*        BWRITE     MOVE LOGICAL RECORD INTO CURRENT BLOCK FOR SYSUT1
*                   OR SYSUT3.
*                             LA   1,0  (UT1)  OR  LA   1,8  (UT3)
*                             LA   0,RECORD
*                             L    RR0,=V(BWRITE)
*                             BALR RR0,RR0
*        DCLOSE,DCLOS1   CLOSE OUT SOURCE PROGRAM AND MACRO LOCAL
*                   DICTIONARIES AND CREATES CORRESPONDING SUBSETTED
*                   DICTIONARIES FOR PHASE ASMGF3. ENTRY POINT DCLOSE
*                   ESTABLISHES THE USING REGISTER FOR THE ROUTINE.
*                             L    LINK,=V(DCLOSE)
*                             BR   LINK
*        ENTDCT     GENERAL DICTIONARY ACCESS ROUTINE FOR THE GLOBAL
*                   AND LOCAL DICTIONARIES. AT ENTRY, WORD 'DENTRY'
*                   MUST POINT TO THE ITEM TO BE ACCESSED OR INSERTED
*                   IN THE DICTIONARY.
*                             L    LINK,=V(ENTDCT)
*                             BALR LINK,LINK
*        EOFIN      PROCESSES EOD CONDITION ON SYSIN.
*                             L    LINK,=V(EOFIN)
*                             BR   LINK
*        EOFLIB     PROCESSES EOD CONDITION ON SYSLIB.
*                             L    LINK,=V(EOFLIB)
*                             BR   LINK
*        GETSRC     SYSIN/SYSLIB INPUT PROCESSING ROUTINE
*                             L    LINK,=V(GETSRC)
*                             BALR LINK,LINK
*                             DC   AL2(ENTRY-CODE)
*        KLOSIT     GENERAL EXIT ROUTINE TO PHASE ASMGF3
*                             L    LINK,=V(KLOSIT)
*                             BR   LINK
*        LIBCHK     CHECKS SYSLIB READ
*                             L    LINK,=V(LIBCHK)
*                             BALR LINK,LINK
*        LIBRFND1   PERFORM SYSLIB READ - SET UP FOR DOUBLE BUFFERING
*                   --RETURNS TO DRIVER IN F2.
*                             L    L5,=V(LIBRFND1)
*                             BR   L5
*        LIBWAIT    AWAIT COMPLETION OF ANY READS ON MACLIB AND CLEAR
*                   ERROR FLAGS IN DCB.
*                             L    L5,=V(LIBWAIT)
*                             BALR RD1,L5
*./      DELETE    SEQ1=01340020,SEQ2=01380020
*        LOOKUP     PROCESSES ALL DICTIONARY ACTIONS TO BE PERFORMED
*                   FOR EACH STATEMENT
*                             L    TEMPRG,=V(LOOKUP)
*                             BALR TEMPRG,TEMPRG
*INPUT  (SEE ASMGF2 DESCRIPTION)
*OUTPUT (SEE ASMGF2 DESCRIPTION)
*EXTERNAL ROUTINES
*        ASMGBUFF   USED TO PERFORM I/O FUNCTIONS SUCH AS READ, WRITE,
*                   NOTE, POINT, ETC.
*              *****THE FOLLOWING ROUTINES ARE IN MODULE ASMGF2****
*        ABSERR     ERROR PROCESSING ROUTINE
*        ABS001     FLUSH REMAINING CARDS OF STATEMENT IN ERROR
*        DRIVER     PROCESS NEXT STATEMENT
*        MEND1      SIMULATE 'MEND' WHEN EOD WHILE READING SYSTEM MACRO
*        NDOPR0     END OF STATEMENT PROCESSOR
*        SWICTL     SET STANDARD ICTL PARAMETERS FOR SYSLIB READ
*        WRNERR     ERROR PROCESSING ROUTINE
*        FIND       POINTS TO 1ST RECORD OF A MEMBER IN SYSLIB
*EXITS  -NORMAL
*       TO PHASE ASMGF3 VIA XCTL WHEN ALL INPUT HAS BEEN PROCESSED
*       -ERROR
*       AN ABEND 20 TO THE SYSTEM IF THE GLOBAL OR SOURCE PROGRAM
*        LOCAL DICTIONARY OVERFLOWS ITS AVAILABLE AREA
*TABLES (SEE ASMGF2 DESCRIPTION)
*ATTRIBUTES -N/A
         SPACE 3
         ENTRY ASCAN
         ENTRY BWFORC
*./      DELETE    SEQ1=01960020,SEQ2=01960020
         ENTRY BWRITE
         ENTRY DCLOSE
         ENTRY DCLOS1
         ENTRY ENTDCT
         ENTRY EOFIN
         ENTRY EOFLIB
         ENTRY GETSRC
         ENTRY KLOSIT
         ENTRY LIBCHK
*
*
         ENTRY LIBRFND1
         ENTRY LIBWAIT
         ENTRY LOOKUP
         EXTRN ASMGF2
*
*        REGISTER DEFINITIONS
*
RQ       EQU   0
RA       EQU   1
RB       EQU   2
B1       EQU   11
B2       EQU   12                       BASE
CM       EQU   13                       COMMON AREA POINTER
L4       EQU   14                       LINK
L5       EQU   15                       LINK
*
         USING COMMON,CM
*
APTR     EQU   0                        'A' POINTER
EPTR     EQU   1
ZERORG   EQU   2
WORKRG   EQU   4
OPNDS    EQU   6                        PNTR WITHIN OPERAND FORMAT LIST
BLKSKP   EQU   7                        POINTER TO START OF FIELD
TEMPRG   EQU   8                        REGISTER ALWAYS AVAILABLE
DCTEMP   EQU   9                        TEMP REG FOR DICTIONARY LOOK-U
OUTPTR   EQU   14                       OUTPUT POINTER
INPTRS   EQU   15                       INPUT POINTER
ERRR5    EQU   42        ILLEGAL TERMINATOR IN SETB
ERRR8    EQU   41        UNDECLARED VARIABLE SYMBOL
ERRR9    EQU   45        ILLEGAL USAGE OF VARIABLE SYMBOL
ERRR10   EQU   49        VARIABLE SYMBOL MATCHES A PARAMETER
ERRR15   EQU   43        SET SYMBOL PREVIOUSLY DEFINED
ERRR35   EQU   76        SEQUENCE ERROR.
ERRR36   EQU   77        ILLEGAL CONTINUATION CARD.
ERRR37   EQU   77        TOO MANY CONTINUATION CARDS.
ERRR38   EQU   105       EOD ON SYSLIB
ERRR48   EQU   44        SET SYMBOL USAGE INCONSISTENT WITH DECLARATION
ERRR49   EQU   47        SEQUENCE SYMBOL PREVIOUSLY DEFINED
ERRR51   EQU   50        INCONSISTANT GLOBAL DECLARATION
*./      DELETE    SEQ1=03000020,SEQ2=03000020
ERRR57   EQU       68                  ILLEGAL LENGTH ON GBL OR LCL
MACLIB   EQU   16
R1       EQU   6
R2       EQU   7
R3       EQU   8                        MUST BE EVEN
R3A      EQU   R3+1                     EVEN-ODD REGISTER PAIR
LINKR    EQU   10
*./      DELETE    SEQ1=03160020,SEQ2=03160020
SSETA    EQU   40                       SETA FLAG
SSETB    EQU   41                       SETB FLAG
SSETC    EQU   42                       SETC FLAG
*./      DELETE    SEQ1=03240020,SEQ2=03240020
SSPAR    EQU   57                       SYMBOLIC PARAMETER FLAG
*./      DELETE    SEQ1=03300025,SEQ2=03600025
WORK1    EQU   4
         EJECT
*              REGISTER ASSIGNMENTS.
*
LINK     EQU   3                        LINK FROM CALLER.
CRA      EQU   8                        CURRENT BLOCK ORIGIN.
PPA      EQU   CRA+1                    PING-PONG BLOCK ORIGIN.
THLDA    EQU   PPA+1                    PERMANENT/TRANSIENT THRESHOLD.
CRNT     EQU   15                       CURRENT ENTRY IN A CHAIN.
PREV     EQU   14                       PREVIOUS ENTRY IN A CHAIN.
LARG     EQU   2                        LENGTH OF BCD ARGUMENT - 1.
RLNK     EQU   LINK                     SUBROUTINE LINK.
RS3      EQU   PREV
*
*              SCRATCH REGISTERS, ASSIGNED CONTIGUOUSLY.
*
RE1      EQU   4                        EVEN.
RD1      EQU   RE1+1                    ODD.
RE2      EQU   RD1+1                    EVEN.
RD2      EQU   RE2+1                    ODD.
*
*              EQUATED PARAMETERS.
*
NUL      EQU   1                        NULL LENGTH.
*./      DELETE    SEQ1=04140022,SEQ2=04160022
NPF      EQU   7                        POSITION OF N/P IN IOCTL.
*./      DELETE    SEQ1=04200020,SEQ2=04300020
UTYP     EQU   22                       TYPE 'U' FLAG.
*./      DELETE    SEQ1=04340020,SEQ2=04340020
JTYP     EQU   18
NPTW     EQU   3                        NOTE LENGTH.
*./      DELETE    SEQ1=04400020,SEQ2=04400020
         EJECT
*ROUTINE FOR CONDITIONAL PLACEMENT OF ENTRIES IN THE GENERAL DICTIONARY
*
*   GENERAL COMMENTS ON TRANSIENT DICTIONARY MANAGEMENT
*        - TRANSIENT DICTIONARY BLOCKS ARE CONTIGUOUS AND ORDERED
*        IN CORE.
*        - TRANSIENT DICTIONARIES ARE HELD IN CORE UNTIL COMPLETE,
*        SUBSETTED IMMEDIATELY (EVEN OPEN CODE), THEN WRITTEN TO UT1.
*        - BOTH TRANSIENT AND PERMANENT DICTIONARIES ARE DYNAMIC.
*        WHEN THE PERMANENT DICT. HAS TO EXPAND BY ONE BLOCK, THE
*        TRANSIENT DICT. MUST BE MOVED AHEAD ONE BLOCK IN CORE TO
*        PROVIDE SPACE. 'GETCRBLK' CALLS BUFF TO OBTAIN A BLOCK OF
*        CORE CONTIGUOUS ABOVE DEND.
*        - IF ENOUGH CORE IS NOT AVAILABLE FOR THE DICTIONARIES,
*        ASSEMBLY IS ABORTED.(SEE ABORTP).
*
*
         DS    0H
         USING *,B2
ENTDCT   EQU   *
         STM   RB,L5,SAVREG
         L     B2,DUSING
         LM    CRA,THLDA,HISTRY
         BAL   RLNK,HASH
*./      DELETE    SEQ1=04900020,SEQ2=04900020
         MVC   HSHA(1),0(RE1)
         NI    HSHA,X'38'               SAVE TYPE CODE.
         TM    0(RE1),X'40'             TEST IF ENTRY FOR PERM AREA.
         BZ    ENTD15                   BRANCH IF YES.
         L     RD1,HSHA
         SRL   RD1,26                   PREPARE TO FAN OUT.
         LH    RD1,ENTD5(RD1)
         B     ENTDCT(RD1)
ENTD5    DC    AL2(ENTSEQ-ENTDCT)       SEQUENCE SYMBOL.
         DC    AL2(ENTPAR-ENTDCT)       PARAMETER.
         DC    AL2(ENTSYM-ENTDCT)       ORDINARY SYMBOL.
         DC        AL2(*-ENTDCT)       ILLEGAL.  (FORCE INVALID OP)
         DC    AL2(ENTLCL-ENTDCT)       LOCAL SET VARIABLE.
         DC    AL2(ENTLCL-ENTDCT)       LOCAL SET VARIABLE.
         DC    AL2(ENTLCL-ENTDCT)       LOCAL SET VARIABLE.
         DC        AL2(*-ENTDCT)       ILLEGAL.  (FORCE INVALID OP)
*./      DELETE    SEQ1=05240020,SEQ2=05280020
ENTD15   TM    0(RE1),X'20'             TEST GLOBAL
         BO    ENTGBL                   YES
         TM    0(RE1),X'18'             TEST MACRO
         BO    ENTMAC                   YES
         EJECT
* ROUTINE TO FIND OR PLACE A MACHINE OP IN THE GLOBAL DICTIONARY
*
ENTOPR   BAL   LINK,FCHN                LOOK FOR MATCH
         B     ENTOP4                   FOUND IT
         L     RE1,DENTRY               POINT TO SEARCH ITEM
         SR    EPTR,EPTR                PRE-SET TO NOT FOUND
         LTR   RE1,RE1                  IS THIS A SEARCH ONLY?
         BNM   DEXIT                    YES, RETURN
         LA    RE2,4(0,LARG)            FORM EXTENDED OP LENGTH
         TM    0(RE1),X'10'             IS IT EXTENDED
         BO    ENTOP2                   YES
         BCTR  RE2,0                    REDUCE BY 1
ENTOP2   STH   RE2,ENTLN                SET LENGTH
         BAL   RLNK,ENTPRM              PLUG IT IN
         B     DEXIT                    AND RETURN PNTR IN EPTR
ENTOP4   LA    EPTR,2(0,CRNT)           POINT TO FLAG BYTE
         TM    0(EPTR),X'E8'            IS IT MACHINE OP?
         BZ    DEXIT                    YES, RETURN PNTR
         LCR   EPTR,EPTR                NO, RETURN ERROR FLAG
         B     DEXIT
         EJECT
*              ROUTINE TO PLACE A GLOBAL SET VARIABLE IN THE GD.
*
ENTGBL   BAL   LINK,BCHN                SEARCH FOR A MATCHING PARAMETER
         B     DBIT2                     YES, WE GOT TROUBLE.
         BAL   LINK,FCHN                SEARCH THE PGD FOR MATCHING GBL
         B     ENTD24                    YES, GO TEST IF ACTIVE.
         L     RE1,DENTRY               RESTORE RE1.
         LA    RD1,2(RE1,LARG)          SET POINTER TO 'A' SLOT.
         SR    RD2,RD2
         IC    RD2,2(0,RD1)             GET DIMENSION.
         SLL   RD2,8                    SHIFT THE HIGH ORDER BYTE &
         IC    RD2,3(,RD1)               INSERT LOW ORDER OF DIMEN
         CLI   HSHA,X'28'               TEST IF GBLB.
         BE    ENTG8
         LA    RE2,5(,LARG)            GBLA LENGTH
*./      DELETE    SEQ1=05640020,SEQ2=05640020
         CLI       HSHA,X'30'          TEST IF GBLC
         BNE       ENTD21
         LA        RE2,6(,LARG)        GBLC LENGTH
         B     ENTD21
ENTG8    LA    RE2,6(,LARG)             GBLB LENGTH
*./      DELETE    SEQ1=05700020,SEQ2=05700020
         LTR   RD2,RD2                  TEST DIMENSION.
         BC    6,ENTD21                 (BNZ) BRANCH IF DIMENSIONED.
         MVC   0(2,RD1),LTLAP+6         INSERT 'A'.
         MVC   4(1,RD1),BTNRP+3         INSERT BIT NUMBER
         L     APTR,LTLAP+4             GET POINTER TO BIT-BYTE.
         B     ENTD22
ENTD21   MVC   0(2,RD1),LTLAP+2         INSERT LITTLE 'A' IN ENTRY.
         L     APTR,LTLAP
ENTD22   STH   RE2,ENTLN                STORE GBLX LENGTH
         LM    RE1,RD1,LTLAP            PREPARE TO ENTER A SETV
         L     RE2,BTNRP
         BAL   RLNK,ENTPRM              (TRANSPARENT TO RE1-RD2)
         BAL   RLNK,ASETV               UPDATE LITTLE 'A' POINTERS.
         STM   RE1,RD1,LTLAP            SAVE BYTE & BIT-BYTE LIL A
*./      DELETE    SEQ1=06000020,SEQ2=06000020
         ST    RE2,BTNRP                SAVE BIT NUMBER
         B     DEXIT
ENTD24   TM    2(CRNT),X'80'            TEST FOR ACTIVE GLOBAL.
         BZ    DBITZ                    ERROR,ENTRY ALREADY ACTIVE.
         L     RE1,DENTRY               CHECK NEW DECLARATION.
         LA    RE2,4(LARG,RE1)          POINT TO DIMENSION.
         LA    RD2,6(LARG,CRNT)         POINT TO DIMENSION.
         CLC   0(2,RE2),0(RD2)          COMPARE DIMENSIONS
         BNE   DBIT6
         MVC   EVENX+3(1),2(CRNT)       GET FLAG BYTE.
         NI    EVENX+3,X'7F'            CLEAR INACTIVE BIT.
         CLC   EVENX+3(1),0(RE1)
         BNE   DBIT6
         TM        0(RE1),X'30'        TEST IF GBLC
         BNO       *+14                SKIP IF NOT
         CLC       2(1,RE2),2(RD2)     TEST LENGTHS CONSISTENT
         BNE       DBIT6               ERROR IF NOT
         XI    2(CRNT),X'80'            ACTIVATE THE ENTRY.
         IC    RE1,2(0,CRNT)            GET BCD LENGTH.
         N     RE1,HSH7                 RETAIN 3 BITS.
         LA    RE1,4(RE1,CRNT)          CHAIN POINTER + 2
         MVC   EVENX+2(2),0(RE1)        GET LITTLE 'A'
         L     APTR,EVENX
         LA    EPTR,2(0,CRNT)           POINT EPTR AT FLAG BYTE.
         BAL   RLNK,BCHN                SEARCH FOR A MATCHING PARAMETER
         B     DBIT2
*
DEXIT    EQU   *                        COMMON EXIT FROM GD MAINTENANCE
         MVI   DERR,0
DEXITR   EQU   *
         STM   CRA,THLDA,HISTRY         SAVE POINTERS.
         LM    RB,L5,SAVREG
         BR    LINK
*
         EJECT
*              ENTER MACRO NAME.
*
ENTMAC   BAL   RLNK,FCHN                SCAN THE PERM AREA.
         B     ENTM22                   MATCH.
         LA    RE1,NPTW+5(0,LARG)
         STH   RE1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.
         L     RD1,DENTRY               GET POINTER TO FLAG BYTE.
         LA    RD1,2(LARG,RD1)          POINTER TO 'A' FIELD.
         MVC   0(2,RD1),LTLAP+2         INSERT LITTLE 'A'.
         TM    DENTRY,X'80'
         BO    ENTM15                   BRANCH IF POINT OF DEFINITION.
         MVC   2(NPTW,RD1),FZRO         CLEAR N/P FIELD.
ENTM15   L     APTR,LTLAP
         LR    RE1,APTR                 INCREMENT 'A'.
         LA    RE1,NPTL(0,RE1)          BUMP BY NOTER, NOT NOTEW.
         ST    RE1,LTLAP
         BAL   RLNK,ENTPRM              PLACE ENTRY IN GD.
         LA    RE1,NPTW+4(LARG,EPTR)    POINT TO MACRO CHAIN POINTER.
         MVC   0(2,RE1),MACHN+2         PLACE ENTRY IN MACRO CHAIN.
         MVC   MACHN+2(2),0(CRNT)
         TM    DENTRY,X'80'
         BZ    DEXIT                    BRANCH IF POINT OF REFERENCE.
         ST    EPTR,EVENX+4             PLACE POINTER TO MACRO NAME
         MVC   1(3,CRA),EVENX+5         IN BLOCK 0.
         B     DEXIT
ENTM22   L     RE1,DENTRY               POINTER TO PROPOSED ENTRY.
         LTR   RE1,RE1                  TEST SIGN BIT.
         BP    ENTM25                   BRANCH IF POINT OF REFERENCE.
         TM    2(CRNT),X'18'            TEST IF ACTUALLY A MACRO.
         BC    12,DBIT3                 BRANCH IF OP-CODE.
         LA    RE2,6(LARG,CRNT)         POINT TO N/P FIELD.
         CLC   FZRO(NPTW),0(RE2)        TEST IF N/P FIELD IS ZERO.
         BNE   DBIT4                    MULTIPLY-DEFINED MACRO.
         LA    RD2,4(LARG,RE1)          POINT TO N/P IN PROPOSED ENTRY.
         MVC   0(NPTW,RE2),0(RD2)       INSERT N/P INTO GD ENTRY.
         LA    RE2,2(0,CRNT)            POINT TO FLAG BYTE.
         ST    RE2,EVENX+4              PLACE POINTER TO MACRO NAME
         MVC   1(3,CRA),EVENX+5         IN BLOCK 0.
ENTM23   LA    RE2,4(LARG,CRNT)         POINT TO 'A'.
         MVC   EVENX+2(2),0(RE2)
         L     APTR,EVENX
ENTM24   LA    EPTR,2(0,CRNT)
         B     DEXIT
ENTM25   TM    2(CRNT),X'18'
         BO    ENTM23                   BRANCH IF MACRO.
         SR    APTR,APTR                OP-CODE.
         B     ENTM24
*
         EJECT
*              ROUTINE TO PLACE A PARAMETER IN THE GD.
*
ENTPAR   EQU   *
ENTP2    BAL   RLNK,BCHN                SEARCH TRANSIENT AREA.
         B     DBIT2                    BCD MATCH.
         LA    RD1,3(0,LARG)            BCD+3.
         STH   RD1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.
         BAL   RLNK,ENTRAN              PLACE ENTRY IN TRANSIENT AREA.
         SR    APTR,APTR                NO LITTLE 'A' POINTER FOR
         B     DEXIT                    PARAMETERS.
*
         EJECT
*              ROUTINE TO PLACE A LOCAL SET VARIABLE IN THE GD.
*
ENTLCL   BAL   RLNK,FCHN                SEARCH PERMANENT AREA.
         B     ENTL22                   BCD MATCH.
ENTL5    BAL   RLNK,BCHN                SEARCH TRANSIENT AREA.
         B     ENTL18                   BCD MATCH.
         L     RE1,DENTRY               POINTER TO FLAG BYTE.
         LA    RD1,2(RE1,LARG)
         SR    RD2,RD2
         IC    RD2,2(0,RD1)             GET DIMENSION.
         SLL   RD2,8                    SHIFT THE HIGH ORDER BYTE &
         IC    RD2,3(,RD1)               INSERT LOW ORDER OF DIMEN
         CLI   HSHA,X'28'               TEST IF BOOLEAN.
         BE    ENTL8
         LA    RE2,5(,LARG)            LCLA LENGTH
*./      DELETE    SEQ1=08120020,SEQ2=08120020
         CLI       HSHA,X'30'          TEST IF LCLC
         BNE       ENTL9
         LA        RE2,6(,LARG)        LCLC LENGTH
         B     ENTL9
ENTL8    LA    RE2,6(,LARG)             LCLB LENGTH
*./      DELETE    SEQ1=08180020,SEQ2=08180020
         LTR   RD2,RD2
         BC    6,ENTL9                  (BNZ) BRANCH IF DIMENSIONED.
         MVC   0(2,RD1),LTLAT+6         INSERT 'A'.
         MVC   4(1,RD1),BTNRT+3         INSERT BIT NUMBER
         L     APTR,LTLAT+4             GET POINTER TO BIT-BYTE.
         B     ENTL12
ENTL9    MVC   0(2,RD1),LTLAT+2         LCLA, LCLC, OR DIMEN'D LCLB.
         L     APTR,LTLAT
ENTL12   STH   RE2,ENTLN                STORE ENTRY LENGTH
         LM    RE1,RD1,LTLAT            PREPARE TO ENTER A SETV
         L     RE2,BTNRT
         BAL   RLNK,ENTRAN
         BAL   RLNK,ASETV               UPDATE LITTLE 'A' COUNTERS.
         STM   RE1,RD1,LTLAT            SAVE BYTE & BIT-BYTE LIL A
*./      DELETE    SEQ1=08480020,SEQ2=08480020
         ST    RE2,BTNRT                SAVE BIT NUMBER
         B     DEXIT
ENTL18   TM    3(CRNT),X'48'            TEST IF GD ENTRY A PARAMETER.
         BO    DBIT2                    YES.
         B     DBIT1                    NO.
ENTL22   TM    2(CRNT),X'80'            TEST IF GLOBAL IS ACTIVE.
         BO    ENTL5                    BRANCH IF INACTIVE.
         B     DBITZ                    PROPOSED LCL MATCHES ACTIVE GBL
*
         EJECT
*              ROUTINE TO PLACE A SEQUENCE SYMBOL IN THE GD.
*
ENTSEQ   EQU   *
         L     RE1,DENTRY               SET POINTER TO PROPOSED ENTRY.
         LA    RD1,NPTW+5(0,LARG)       COMPUTE ENTRY LENGTH.
         STH   RD1,ENTLN
         LA    RD2,2(LARG,RE1)          POINT TO 'A' IN PROPOSED ENTRY.
         BAL   RLNK,BCHN                SEARCH THE GD.
         B     ENTS16                   BCD MATCH.
         LTR   RE1,RE1
         BP    ENTS5                    BRANCH IF POINT OF REFERENCE.
         SR    APTR,APTR                POINT OF DEFINITION.
         MVC   0(2,RD2),FZRO            CLEAR 'A' POINTER FIELD.
         B     ENTS18                   GO PLACE ENTRY IN THE GD.
ENTS5    MVC   2(NPTW+2,RD2),FZRO       POINT OF REFERENCE.
         B     ENTS23
ENTS16   LA    RE2,5(LARG,CRNT)         POINT TO 'A' FIELD IN GD ENTRY.
         CLC   FZRO(2),0(RE2)
         BE    ENTS21                   BRANCH IF NO 'A' IN GD.
         LTR   RE1,RE1
         MVC   EVENX+2(2),0(RE2)
         L     APTR,EVENX
         BP    DEXIT
         CLC   FZRO(NPTW+2),2(RE2)      PREVIOUSLY DEFINED...
         BNE   DBIT5                    BIF YES
         MVC   0(2,RD2),0(RE2)          MOVE 'A' FROM GD TO NEW ENTRY.
ENTS18   BAL   RLNK,ENTRAN              PLACE ENTRY IN THE GD.
         B     DEXIT
ENTS21   LTR   RE1,RE1
         BM    DBIT5                    BRANCH IF MULTIPLY-DEFINED.
         MVC   2(NPTW+2,RD2),2(RE2)     MOVE N/P + DELTA TO NEW ENTRY.
ENTS23   MVC   0(2,RD2),LTLAT+2
         L     RD2,LTLAT
         LR    APTR,RD2                 (APTR MAY EQU 0)
         LA    RD2,NPTW+2(0,RD2)        INCREMENT 'A'.
         ST    RD2,LTLAT
         B     ENTS18
*
         EJECT
*              ROUTINE TO PLACE AN ORDINARY SYMBOL INTO THE GD.
*
ENTSYM   LA    RE1,8(0,LARG)            COMPUTE ENTRY LENGTH.
         STH   RE1,ENTLN
         BAL   RLNK,BCHN                SEARCH THE TRANSIENT AREA.
         B     ENTY22                   BCD MATCH.
         BAL   RLNK,ENTRAN              PLACE THE ENTRY IN THE GD.
         LA    RD1,2(LARG,EPTR)         POINT TO LITTLE 'A' FIELD.
         TM    DENTRY,128
         BO    ENTY5                    BRANCH IF POINT OF DEFINITION.
         MVC   0(2,RD1),LTLAT+2         INSERT 'A' INTO THE GD.
         L     APTR,LTLAT
         LR    RE2,APTR                 INCREMENT 'A'.
         LA    RE2,5(0,RE2)
         ST    RE2,LTLAT
         B     DEXIT
ENTY5    SR    APTR,APTR                SET 'A' EQUAL ZERO.
         MVC   0(2,RD1),FZRO
         B     DEXIT
ENTY22   L     RE1,DENTRY
         LA    RD1,2(LARG,RE1)          POINT TO 'A' IN PROPOSED ENTRY.
         LA    RD2,5(LARG,CRNT)         POINT TO 'A' IN GD ENTRY.
         LTR   RE1,RE1
         BM    ENTY27                   BRANCH IF POINT OF DEFINITION.
         CLC   FZRO(2),0(RD2)           TEST 'A' IN GD ENTRY.
         BNE   ENTY35                   BRANCH IF PRESENT.
         MVC   0(2,RD1),LTLAT+2         INSERT 'A' INTO PROPOSED ENTRY.
         L     APTR,LTLAT
         LR    RE2,APTR
         LA    RE2,5(0,RE2)
         ST    RE2,LTLAT
         MVC   2(5,RD1),2(RD2)          MOVE ATTRIBUTES.
ENTY24   BAL   RLNK,ENTRAN
         B     DEXIT
ENTY27   CLI   2(RD2),DTYP              TEST IF OLD MULTIPLE DEFINITION
         BE    DEXIT                    IF SO, IGNORE.
         CLI   2(RD2),JTYP
         BE    DEXIT                    IGNORE MULTIPLE TYPE 'J'.
         CLI   2(RD2),UTYP              TEST IF GD ENTRY IS TYPE 'U'.
         BNE   ENTY37                   IF NOT, SET SPECIAL TYPE BYTE.
ENTY29   MVC   0(2,RD1),0(RD2)          MOVE  'A'.
         MVC   EVENX+2(2),0(RD2)
         L     APTR,EVENX
         B     ENTY24
ENTY35   MVC   EVENX+2(2),0(RD2)        GET 'A'.
         L     APTR,EVENX
         LA    EPTR,3(0,CRNT)
         B     DEXIT
ENTY37   MVI   2(RD1),DTYP
         B     ENTY29                   GO GET 'A', IF PRESENT.
*
         EJECT
*              ERROR EXITS.
*
* THE PROPOSED ENTRY MATCHES AN ACTIVE GLOBAL SET VARIABLE.
DBITZ    MVI   DERR,128
         SR    EPTR,EPTR
         B     DEXITR
*
* THE PROPOSED ENTRY MATCHES A LOCAL SET VARIABLE.
DBIT1    MVI   DERR,64
         B     DBITZ+4
*
* THE PROPOSED ENTRY MATCHES A PARAMETER.
DBIT2    MVI   DERR,32
         B     DBITZ+4
*
* A MACRO NAME MATCHES AN OP-CODE, EXTENDED MNEMONIC, OR PSEUDO-OP.
DBIT3    MVI   DERR,16
         B     DBITZ+4
*
* A MACRO NAME IS MULTIPY-DEFINED.
DBIT4    MVI   DERR,8
         B     DBITZ+4
*
* A SEQUENCE SYMBOL IS MULTIPLY-DEFINED.
DBIT5    MVI   DERR,4
         B     DBITZ+4
*
* A NEW GLOBAL DECLARATION IS INCONSISTENT WITH THE ORIGINAL ONE.
DBIT6    MVI   DERR,2
         B     DBITZ+4
         EJECT
*              SUBROUTINE TO UPDATE LITTLE 'A' VALUES.
*
* AT ENTRY,    HSHA  CONTAINS A TYPE CODE (BITS 1-4) FROM THE FLAG BYTE
*              RE1 CONTAINS THE FULL-BYTE LITTLE 'A' VALUE.
*              RD1 CONTAINS THE BIT-BYTE LITTLE 'A' VALUE.
*              RE2 CONTAINS THE BIT NUMBER (0-7).
*              RD2 CONTAINS THE DIMENSION.
*              RS3 CONTAINS MAX LENGTH IF SETC
* AT EXIT,     RE1,RD1 AND RE2 ARE UPDATED.  RD2 AND RB ARE DESTROYED.
*
ASETV    EQU   *
         CLI   HSHA,X'28'               TEST IF GBLB OR LCLB.
         BE    ASETB
         CLI   HSHA,X'30'               TEST IF SETC.
         BE    ASETC
         SLA   RD2,2                    4X, TURNS ON CC.
         LA    RE1,2(RD2,RE1)           ADD IN DIMENSION BYTE
         BCR   6,RLNK                   (BNZ) EXIT IF DIMENSIONED.
         LA    RE1,2(,RE1)              UNDIMENSIONED
         BR    RLNK
ASETC    LA    RS3,1(,RS3)              ADD 1 FOR LENGTH BYTE
         LTR   RD2,RD2                  TEST IF DIMENSIONED
         BZ    ASC1                     BRANCH IF NOT DIMENSIONED
         LR    RB,RE2                   REMEMBER BIT NUMBER
         MR    RE2,RS3                  COMPUTE SPACE NEEDED
         LR    RE2,RB                   RESTORE BIT NUMBER
         LA    RE1,3(RD2,RE1)           NEW LITTLE 'A' VALUE
         BR    RLNK                     RETURN
ASC1     LA    RE1,2(RS3,RE1)           NEW LITTLE 'A' FOR UNDIMENSIOND
         BR    RLNK
ASETB    LTR   RD2,RD2                  TEST DIMENSION.
         BZ    ASB5                     BRANCH IF NON-DIMENSIONED.
         LA    RD2,7(0,RD2)             BIAS THE DIVIDEND.
         SRL   RD2,3                    DIVIDE BY 8.
         LA    RE1,2(RD2,RE1)           ADD IN DIMENSION BYTE
         BR    RLNK
ASB5     C     RE2,HSH7                 TEST IF BIT NUMBER = 7.
         BE    ASB6
         LA    RE2,1(0,RE2)             NO, INCREMENT BIT NUMBER.
         BR    RLNK
ASB6     SR    RE2,RE2                  RESET BIT NUMBER.
         LR    RD1,RE1                  MOVE UP BIT-BYTE VALUE.
         LA    RE1,1(0,RE1)             BUMP FULL-BYTE VALUE.
         BR    RLNK
*
         EJECT
*              SUBROUTINE TO PLACE AN ENTRY IN THE PERMANENT GD.
*
* THIS PROGRAM IS TRANSPARENT TO THE SCRATCH REGISTERS, RE1,RD1,RE2,RD2
*
ENTPRM   STM   RE1,RD2,TREGS
         LH    RE1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.
         L     RD1,PNDX                 PERM AREA STORAGE INDEX, REL.
         AL    RD1,GDP                  MAKE ABSOLUTE.
         LA    RE2,3(RE1,RD1)           ADD ENTRY LENGTH.
         CLR   RE2,THLDA                COMPARE AGAINST THRESHOLD.
         BC    10,ENTP25                BRANCH IF RE2 HIGH OR EQUAL.
ENTP22   L     RD2,DENTRY
         EX    RE1,ENTP23               MOVE THE ENTRY INTO THE GD.
         MVC   0(2,RD1),FZRO            MOVE CHAIN POINTER INTO ENTRY.
         MVC   0(2,CRNT),PNDX+2         SET POINTER TO NEW ENTRY.
         SL    RE2,GDP                  RELATIVIZE NEW  STORAGE INDEX.
         ST    RE2,PNDX
         LA    EPTR,2(0,RD1)            SET ABSOLUTE POINTER TO ENTRY.
         SR        RS3,RS3             GET LENGTH IN CASE SETC
         IC        RS3,2(RE1,RD1)
         LM    RE1,RD2,TREGS
         BR    RLNK
ENTP23   MVC   2(NUL,RD1),0(RD2)
ENTP25   STM   RE1,RE2,SAVE3            SAVE REGS
         C     PPA,DEND                ANY CORE LEFT FOR DICT. .Q
         BL    MOVEM1                  BIF YES
         BAL   RD1,GETCRBLK            NO-GET ANOTHER BLOCK
*                  WE MUST MOVE ALL OF TRANSIENT DICT AHEAD ONE
*                  BLOCK TO ALLOW PERMANENT DICT TO GROW
MOVEM1   LR    RE1,CRA                 FROM ADDR
         LA    RD2,BLKSZ(0,RE1)        TO ADDR
         L     RD1,TNDX               NUM. CHAR. TO BE MOVED FIRST BLK
         BAL   RE2,MOVEM               BRANCH TO MOVE ROUTINE
         LR    RD1,CRA                 FIRST BLOCK WAS MOVED ALREADY
         LA    RD2,BLKSZ               LENGTH OF BLOCKS TO BE MOVED
MOVELOOP CR    RD1,THLDA               FINISHED MOVE YET .Q
         BNH   MOVEFINI                BIF YES
         SR    RD1,RD2                 POINT TO NEXT BLOCK DOWN
         MVC   BLKSZ(256,RD1),0(RD1)   PERFORM MOVE OF 1024 BYTES
         MVC   BLKSZ+256(256,RD1),256(RD1)     IN 4 MVC S
         MVC   BLKSZ+512(256,RD1),512(RD1)
         MVC   BLKSZ+768(256,RD1),768(RD1)
         B     MOVELOOP                GO MOVE THE REST OF THE BLOCKS
MOVEFINI LA    THLDA,BLKSZ(0,THLDA)    MOVE THLDA PTR.
         LA    PPA,BLKSZ(0,PPA)        MOVE PPA PTR
         LA    CRA,BLKSZ(0,CRA)        MOVE CRA PTR
         LM    RE1,RE2,SAVE3           RESTORE REGS
         B     ENTP22                  0.K. NOW WE CAN RESUME
*
SAVE3    DS    3F                      SAVE AREA FOR 3 REGS
*
*MV256 (MOVEM) MOVES CHARACTERS
*              REG RD1 - HOW MANY
*              REG RE1 - FROM WHERE
*              REG RD2 - TO WHERE
*              REG RE2 - RETURN REG
*
MV256    MVC   0(256,RD2),0(RE1)       MOVE 256 CHARACTERS
         LA    RD2,256(0,RD2)          UPDATE POINTERS
         LA    RE1,256(0,RE1)
MOVEM    SH    RD1,H256                TEST IF 256 CHARACTERS REMAIN
         BH    MV256                   TO BE MOVED. BIF IF YES
         LA    RD1,255(0,RD1)          SET UP FOR EX INST
         EX    RD1,MOVE1
         BR    RE2                     RETURN TO CALLER
MOVE1    MVC    0(0,RD2),0(RE1)        MOVE INST IS EXECUTED
*
*
         EJECT
*              SUBROUTINE TO PLACE AN ENTRY IN THE TRANSIENT GD.
* THIS PROGRAM IS TRANSPARENT TO THE SCRATCH REGISTERS, RE1,RD1,RE2,RD2
*
ENTRAN   STM   RE1,RD2,TREGS
         LH    RE1,ENTLN                ENTRY LENGTH - CHAIN PTR - 1.
         L     RD1,TNDX                 TRANSIENT BLOCK INDEX.
         LA    RD2,BLKSZ-4              NEED AT LEAST 4 FOR FLAG BYTE.
         CLR   RD1,RD2
         BH    ENTR15                   BRANCH IF NO ROOM FOR FLAG.
         LA    RE2,4(RE1,RD1)           INDEX PLUS ENTRY LENGTH.
         ST    RE2,TNDX
         LA    RD2,BLKSZ                INDEX END TEST VALUE.
         CLR   RE2,RD2                  SEE IF ROOM FOR ENTRY.
         LA    RD1,0(RD1,CRA)           RETAIN CONDITION CODE.
         MVI   3(RD1),0                 INSERT 0 IN FB FOR SUBSETTING.
         BH    ENTR15                   BRANCH IF NOT ENOUGH SPACE.
ENTR4    L     RD2,DENTRY
         EX    RE1,ENTR12               MOVE THE ENTRY INTO THE GD.
         LA    EPTR,3(0,RD1)
         MVC   0(3,RD1),0(PREV)         MOVE HT POINTER INTO ENTRY.
         L     RE2,VCR
         MVC       0(3,PREV),VCR+1      STORE VIRTUAL LOCATION IN HT.
         SR        RS3,RS3             GET MAX LENGTH IN CASE SETC
         IC        RS3,3(RE1,RD1)
         LA    RE2,4(RE2,RE1)           ADVANCE VIRTUAL STORAGE POINTER
         ST    RE2,VCR                  STORE NEW VALUE.
         LM    RE1,RD2,TREGS
         BR    RLNK
ENTR12   MVC   3(NUL,RD1),0(RD2)
*./      DELETE    SEQ1=13860020,SEQ2=13880020
ENTR15   C     PPA,DEND                DO WE NEED SOME MORE CORE FOR
         BL    RMLEFT                  DICTIONARY. BIF NO
         BAL   RD1,GETCRBLK            GO AND GET ANOTHER BLOCK OF CORE
*./      DELETE    SEQ1=13960020,SEQ2=14000020
RMLEFT   LA    CRA,BLKSZ(0,CRA)        INCREMENT CRA
         LA    PPA,BLKSZ(0,PPA)        AND PPA
         LA    RD1,5(0,RE1)             ENTRY LENGTH+1 IS
         ST    RD1,TNDX                 NEW INDEX FOR NEXT TIME.
         LA    RD1,1(0,CRA)             RESET FOR THIS TIME.
         LR        RE2,CRA             RESET VIRTUAL POINTER.
         SR        RE2,THLDA
         LA    RE2,1(0,RE2)
         ST    RE2,VCR
         B     ENTR4                    RETURN AND MAKE THE ENTRY.
*
*                  THE FOLLOWING CODING TRYS TO GET A BLOCK OF CORE
*                  FROM BUFF AND UPDATES POINTER DEND, AND ZEROES FIRST
*                  SEVEN BYTES OF BLOCK OBTAINED TO INITIALIZE IT IF
*                  SUCESSFUL. OTHERWISE IT BRANCHES TO ABORTP TO
*                  PRINT MESSAGE AND ABEND. RETURN REGISTER IS RD1.
*
R0       EQU   0                       MUST BE REG 0
GETCRBLK STM   R0,RA,SAVE0             SAVE REGS 1,0
         L     RA,BUFFENT              LOAD ADDRESS OF RENNIE S
         CNOP  2,4                     BUFFERING ROUTINE.
         BALR  R0,RA                   GO ASK HIM TO SHRINK
         DC    A(36)                   CODE FOR SHRINK
         DC    A(BLKSZ)                AMOUNT OF CORE REQUIRED
COREGOT  DS    F                       ADDR OF CORE GOT.(-1 IF CORE
         CLI   COREGOT,X'FF'           NOT AVAILABLE).WAS IT .Q
         BNE   GOBACK                  BIF WE GOT IT.
         B     ABORTP                  WE DID NOT GET IT. WE MUST ABEND
GOBACK   L     RA,DEND                 MOVE DEND
         LA    RA,BLKSZ(0,RA)          POINTER
         ST    RA,DEND
         L     RA,COREGOT              INITIALIZE DICT BLK--ZERO FIRST
         MVC   0(7,RA),FZRO            SEVEN BYTES
         LM    R0,RA,SAVE0             RESTORE REGS 1,0
         BR    RD1                     RETURN TO CALLER.
*
ABORTP   DS        0H
         L         L5,ALIBWAIT         ADDRESS OF SYSLIB WAIT ROUTINE
         BALR      RD1,L5              TERMINATE ANY SYSLIB ACTIVITY
         L         RA,ADLIST1          BRANCH TO ABORT ROUTINE IN ASM
         BAL       R0,L1ABEND(,RA)     POINT AT MESSAGE AND BRANCH
         DC        C'992I',AL1(L'MES992-1)
MES992   DC        C'INSUFFICIENT DICTIONARY SPACE FOR PHASE F2'
SAVE0    DC        2F'0'
ALIBWAIT DC        A(LIBWAIT)          LIBWAIT ENTRY ADDRESS
         EJECT
*              FORWARD CHAIN TRACING SUBROUTINE.
*
* THIS SUBROUTINE TRACES A PERMANENT AREA CHAIN UNTIL EITHER A BCD
* MATCH OR END OF CHAIN.  REGISTERS PREV AND CRNT ARE ABSOLUTE POINTERS
* TO PREVIOUS AND CURRENT ENTRIES IN A CHAIN.
* CALLING SEQUENCE...
*        BAL   RLNK,FCHN
*        B     (MATCH)
*              (END OF CHAIN)
*
FCHN     LH    PREV,HSHVAL              DEVELOP HASH INDEX.
         N     PREV,PHASHM
         LA    PREV,PHASHT(PREV)
         CLC   FZRO(2),0(PREV)          TEST FOR NO CHAIN AT ALL.
         LR    CRNT,PREV
         BE    4(0,RLNK)
FCH2     MVC   EVENX+2(2),0(PREV)       GET CHAIN POINTER.
         L     CRNT,EVENX
         AL    CRNT,GDP                 MAKE IT ABSOLUTE.
         IC    RE1,2(0,CRNT)            PICK UP FLAG BYTE OF GD ENTRY.
         N     RE1,HSH7                 EXPOSE LENGTH.
         CR    RE1,LARG                 COMPARE LENGTHS.
         BNE   FCH3
         L     RD1,DENTRY
         EX    RE1,FCH5                 COMPARE BCD NAMES.
         BCR   8,RLNK
FCH3     CLC   FZRO(2),0(CRNT)          TEST FOR END OF CHAIN.
         BE    4(0,RLNK)
         LR    PREV,CRNT                ADVANCE POINTERS.
         B     FCH2                     CONTINUE.
FCH5     CLC   1(NUL,RD1),3(CRNT)
*
         EJECT
*              BACKWARD CHAIN TRACING SUBROUTINE.
*
* AT ENTRY, REGISTER PREV POINTS ABSOLUTELY TO A HASH TABLE ENTRY.
* ALL CHAIN POINTERS ASSOCIATED WITH THE TRANSIENT AREA ARE RELATIVE TO
* THE THRESHOLD.
* AT EXIT, REGISTER PREV IS UNCHANGED. REGISTER CRNT POINTS TO THE
* MATCHING ENTRY IF FOUND. OTHERWISE CRNT'S CONTENTS ARE IRRELEVANT.
* CALLING SEQUENCE...
*        BAL   RLNK,BCHN
*        B     (MATCH)
*              (END OF CHAIN)
*
BCHN     EQU   *
         LH    PREV,HSHVAL              DEVELOP HASH INDEX.
         N     PREV,THASHM
         MH    PREV,H3
         LA    PREV,THASHT(PREV)
         CLC   FZRO(3),0(PREV)          TEST FOR NO CHAIN AT ALL.
         BE    4(0,RLNK)
         STM   RE1,RD2,TREGS
         MVC   EVENY+1(3),0(PREV)
BCH2     L     RA,EVENY                 SAVE POSITION IN CHAIN.
*./      DELETE    SEQ1=16160020,SEQ2=16300020
         LA    RD1,0(THLDA,RA)         ABSOLUTE ADDR. OF BLOCK
         IC    RE2,3(0,RD1)             GET FLAG BYTE OF GD ENTRY.
         N     RE2,HSH7                 ISOLATE BCD LENGTH.
         CR    RE2,LARG                 COMPARE LENGTHS.
         BNE   BCH55
         L     RE1,DENTRY
         EX    RE2,BCH76                COMPARE BCD NAMES.
         BE    BCH58
BCH55    CLC   FZRO(3),0(RD1)           TEST FOR END OF CHAIN.
         BE    BCH57
         MVC   EVENY+1(3),0(RD1)        GET POINTER TO NEXT ENTRY.
         B     BCH2
BCH57    LM    RE1,RD2,TREGS
         B     4(0,RLNK)
BCH58    LR    CRNT,RD1
         LM    RE1,RD2,TREGS
         BR    RLNK
BCH71    CLI   0(RD1),0                 BLOCK NUMBER COMPARE.
*./      DELETE    SEQ1=16680020,SEQ2=16680020
BCH76    CLC   1(NUL,RE1),4(RD1)        BCD NAME COMPARE.
*
         EJECT
*              BCD NAME HASHING SUBROUTINE.
*
* SUBROUTINE ALSO DETERMINES AND SAVES LENGTH OF BCD NAME OF ARGUMENT.
*
HASH     L     RE1,DENTRY
         SR    RE2,RE2                  CLEAR RE2 AND
         LR    RD2,RE2                  HASHING AREA.
         STM   RE2,RD2,HSHA
         IC    LARG,0(0,RE1)            GET ARGUMENT LENGTH.
         N     LARG,HSH7
         EX    LARG,HSHMV               MOVE.
         L     RD2,HSHA                 FOLD ONCE.
         AL    RD2,HSHA+4
         D     RE2,F65537               PRIME.
         STH   RE2,HSHVAL
         BR    RLNK
HSHMV    MVC   HSHA(NUL),1(RE1)
F65537   DC    F'8209'                  PRIME.
HSH7     DC    F'7'
*
         EJECT
*              ROUTINE FOR LOOKING UP A DICTIONARY ENTRY.
*
DLKUP    DS    0H
         STM   RB,L5,SAVREG
         L     B2,DUSING
         LM    CRA,THLDA,HISTRY
         BAL   RLNK,HASH                HASH THE ARGUMENT NAME.
         CLI   DENTRY,2                 TEST IF TRANSIENT AREA ONLY.
         BNE   DLK18                    BRANCH IF NOT.
DLK13    BAL   RLNK,BCHN                SEARCH TRANSIENT AREA.
         B     DLK25                    BCD MATCH.
DLK15    SR    EPTR,EPTR
         B     DLK29
DLK18    BAL   RLNK,FCHN                SEARCH PERMANENT AREA.
         B     DLK19                    BCD MATCH.
DLK20    CLI   DENTRY,1                 TEST FOR PA SEARCH ONLY.
         BE    DLK15                    BRANCH IF YES.
         B     DLK13                    GO SEARCH TRANSIENT AREA.
DLK25    LA    EPTR,3(0,CRNT)
DLK26    TM    0(EPTR),X'60'            TEST IF OP-CODE OR MACRO.
         BZ    DLK28                    BRANCH ON PROBABLE OP-CODE.
DLK27    LA    RE1,2(EPTR,LARG)         POINT TO LITTLE 'A' FIELD.
         MVC   EVENX+2(2),0(RE1)
         L     APTR,EVENX
         B     DEXIT
DLK28    TM    0(EPTR),X'18'            TEST IF MACRO.
         BO    DLK27                    BRANCH IF YES.
DLK29    SR    APTR,APTR                OP-CODE.
         B     DEXIT
DLK19    TM    2(CRNT),X'80'            IS GLOBAL INACTIVE .Q
         BO    DLK20                    BIF YES
         LA        EPTR,2(0,CRNT)       NO
         B         DLK26
*
         EJECT
*
*        REGISTERS AND EQU'S
*
REG1     EQU   4
REG2     EQU   5
REG3     EQU   6
XTRD     EQU   7               ABSOLUTE INDEX TO TRANSIENT DICT AREA
XMCD     EQU   8               ABSOLUTE INDEX TO MACRO DICT AREA
FLGBYT   EQU   9               FLAG BYTE STORAGE
LITTLA   EQU   10              LITTLE A STORAGE
SSFILE   EQU   0               MACRO DICTIONARIES ON SYSUT1
*
*        CONSTANTS
*
         DS    0F
FLGM1    DC    XL4'7'          FLAGBYTE MASK. 00000111
LAST     DC    XL4'FF'         LAST ENTRY SIGNAL. 11111111(AS FLAGBYTE)
ENDBLK   DC    F'0'            END OF BLOCK SIGNAL. 00000000(FLAGBYTE)
RNDMSK2  DC        X'FFFFFFF8'
         EJECT
*
*        SUBSETTING ROUTINE - TRANSIENT DICTIONARIES
*
*        THIS ROUTINE SUBSETS THE TRANSIENT DICTIONARY FOR EACH MACRO
*        IMMEDIATELY AFTER IT HAS BEEN CLOSED OUT.  THE SUBSETTED MACRO
*        DICTIONARY IS WRITTEN TO SYSUT1.  THE TRANSIENT DICTIONARY
*        FOR OPEN CODE IS SUBSETTED AND WRITTEN TO SYSUT1 ALSO.  IT'S
*        NOTE/POINT ADDRESS IS STORED IN 'NPMAIN' AND LATER PASSED
*        TO F3 IN REGISTER RB.
*
*        INPUT PARAMETERS FOR THIS ROUTINE ARE STORED IN COMMON AREA
*        AS FOLLOWS --- 'DEND' - ABSOLUTE ADDRESS OF END OF DICTIONARY
*        AREA, 'HISTRY'+8 - ABSOLUTE ADDRESS OF DICTIONARY THRESHOLD,
*        'SWTCH5' - BIT1 IS SET IF OPEN CODE IS BEING PROCESSED.
*
*        THE TRANSIENT DICTIONARY IS SUBSETTED INITIALLY INTO ONE
*        BLOCK (BLKSZ) OF CORE WHICH IS ZEROED. WHEN THIS BLOCK IS
*        FILLED, THE NEXT BLOCK (WHICH WAS UNSUBSETTED DICT. BEFORE)
*        IS ZEROED AND SUBSETTING CONTINUES IN THIS MANNER. IF A BLOCK
*        OF SUBSETTED DICT. IS GOING TO BE LARGER THAN THE UNSUBSETTED
*        BLOCK(I.E. IF DIMENSIONED SET SYMBOLS ARE USED),A NEW BLOCK OF
*        OF CORE MUST BE OBTAINED,THE T.D. MUST BE MOVED AHEAD 1 BLOCK,
*        AND THEN THE FREE BLOCK IS ZEROED AND SUBSETTING RESUMES.
*
*        CALLING SEQUENCE ... BAL   LINK,TSBSET
*
TSBSET   DS    0H
         STM   RQ,L5,SAVREG            THIS AGREES WITH EOFLIB ON NULL
*                                      MACROS
         L     B2,DUSING
*
*
*        SETUP INPUT AND SUBSETTING AREAS IN TRANSIENT DICTIONARY AREA
*
         MVI       SBSWCH,C'T'         NOTE SUBSETTING TRANS DICT
         L     REG1,HISTRY+4           FORMER PPA FOR TRANS DICT.
         CL    REG1,DEND               DO WE HAVE A SPARE EMPTY BLK LFT
         BL    *+8                     BIF YES
         BAL   REG2,GETCRBLK           GET ANOTHER BLOCK AT TOP OF DICT
         LA    REG2,BLKSZ              STORE INITIAL LENGTH OF
         ST    REG2,MCDSZ              SUBSETTING AREA
         A     REG2,HISTRY+8           COMPUTE END OF SUBSET
         ST    REG2,TRD                AREA=INPUT AREA=UNSUBSETTED DICT
         LR    XTRD,REG2
         LA    REG2,BLKSZ-1(0,REG2)    END OF FIRST BLOCK OF DICT.
         ST    REG2,ENDTRD
         L     REG2,HISTRY+8           THRESHOLD(THAT WAS) IS
         ST    REG2,MCD                NOW BEGINNING OF SUBSET AREA
         ST    REG2,MCD1               SAVE AT MCD1 TOO
*                  NOW MOVE WHOLE DICT AHEAD ONE BLOCK TO ALLOW ONE
*                  BLOCK OF INITIAL SUBSETTING AREA
*                  REG1 POINTS ALREADY TO START OF AREA TO MOVE TO
         LA    LINK,MOVEFIN            SET TO RETURN TO MOVEFIN
MOVE1024 LA    REG2,BLKSZ              SIZE OF MOVE
MOVELP1  CL    REG1,MCD1               MOVE FINISHED YET
         BCR   13,LINK                 BIF YES (BNH)
         SR    REG1,REG2               SET FOR NEXT MOVE
         MVC   BLKSZ(256,REG1),0(REG1) MOVE 1024 BYTES IN
         MVC   BLKSZ+256(256,REG1),256(REG1)     FOUR MOVES OF 256
         MVC   BLKSZ+512(256,REG1),512(REG1)
         MVC   BLKSZ+768(256,REG1),768(REG1)
         B     MOVELP1                 WE ARE NOT FINISHED YET
MOVEFIN  EQU   *
*
*        SAVE ADDRESS OF G.D. MACRO NAME ENTRY FOR LATER USE
*
         ST    XTRD,MCD1               BEGINNING OF INPUT BLOCK
         MVC   MACNAM(4),0(XTRD)  SAVE ADDRESS OF MACRO NAME ENTRY
         TM    SWTCH5,64               ARE WE IN OPEN CODE
         BNO   *+8                     BIF NO
         LA    XTRD,5(XTRD)            ADD 5 BYTES INCREMENT FOR O.C.
         LA    XTRD,4(XTRD)       INCREMENT INPUT AREA INDEX BY 4
*
*        MAKE INITIAL CALL TO DICTIONARY SUBSETTING ROUTINE
*
         BAL   LINK,SBSET              ZERO SUBSETTING AREA
         B     TSBST2
*                  SET UP ANOTHER DICT. BLOCK FOR SUBSETTING
TSBST1   L     XTRD,ENDTRD             FORMER END OF INPUT.AREA
         L         REG2,MCD1           FORMER START OF INPUT AREA
         XC        000(256,REG2),000(REG2) ZERO THE BLOCK
         XC        256(256,REG2),256(REG2)   EVEN THOUGH IF MAY NOT
         XC        512(256,REG2),512(REG2)   BE USED
         XC        768(256,REG2),768(REG2)
         LA        REG2,BLKSZ(,REG2)   UPDATE IT
         ST        REG2,MCD1           NEW START OF INPUT BLOCK
         L     REG2,MCDSZ              SIZE OF OUTPUT AREA
         LA    REG2,BLKSZ(0,REG2)      UPDATE IT
         ST    REG2,MCDSZ              AND SAVE NEW VALUE
         LA    REG2,BLKSZ(0,XTRD)      NEW END OF DICT. INP. AREA.
         ST    REG2,ENDTRD
         CL    REG2,DEND
         BH    ABORTP                  ERROR.
         LA    XTRD,2(0,XTRD)          POINT TO NEW INP AREA
*                  MAKE SUBSEQUENT CALL TO SUBSETTING ROUTINE
TSBST2   EQU   *
         BAL   LINK,SBSET1     CALL SUBSETTING ROUTINE
         B     TSBST1                  END OF INPUT BLOCK RETURN.
*        B     *+4              END OF DICTIONARY RETURN
*
*        STORE DICT SIZE IN SUBSETTED DICT AND OUTPUT PARAMETER LIST
*
         L     XMCD,MCD        SET SUBSETTED DICTIONARY INDEX
         MVC   18(2,XMCD),1(XTRD)  MOVE DICT SIZE FROM LAST INPUT
*
*        STORE STANDARD ACTR VALUE IN SUBSETTED DICTIONARY
*
         MVC   4(4,XMCD),ACTR
*
BNOTE    TM    SWTCH5,64               IN O.C. .Q
         BZ        CNOTE               BRANCH IF NOT
         MVC   NPMAIN(3),BWBLKS+BWFNOT N/P ADDRESS OF SUBSETTED O.C.
         B         ANOTE
*        STORE EDITED TEXT N/P ADDRESS IN DICTIONARY
*
CNOTE    L     REG3,MACNAM     RECOVER ADDRESS OF MACRO NAME ENTRY
         IC    REG2,0(0,REG3)  FIND LENGTH OF BCD MACRO NAME-1 AND ADD
         N     REG2,FLGM1       IT TO ADDRESS OF MACRO NAME ENTRY
         AR    REG3,REG2
         MVC   12(3,XMCD),4(REG3)  MV EDITED TEXT N/P TO SUBSETTED DICT
         MVC       4(3,REG3),BWBLKS+BWFNOT  STORE N/P OF SUBSETTED     X
                   MACRO DICT. IN GLOBAL DICT.
*
*        COMPUTE NO OF BLOCKS OF DICT AND STORE INTO DICTIONARY
*
ANOTE    LH    REG2,18(0,XMCD) GET DICTIONARY SIZE
         N     REG2,F65535              BE SURE DICT SIZE IS PLUS
         L     REG1,RECSZ      GET STANDARD BLOCK SIZE
         ST        REG1,WRLEN1 STORE BLOCK SIZE IN OUTPUT PARAMETER
         LR        L5,REG2     COMPUTE NUMBER OF BLOCKS OF DICT
         BCTR      L5,0
         SR        L4,L4
         DR        L4,REG1
         LA        L5,1(0,L5)
         STC     L5,17(0,XMCD) STORE NO OF BLOCKS INTO DICT
*./      DELETE    SEQ1=20500020,SEQ2=20500020
*
*              WRITE BLOCK OF DICTIONARY TO SYSUT1
*
TSBST0   C         REG2,RECSZ          TEST IF SHORT BLOCK CAN BE WRIT
         BNL       *+8
         ST        REG2,WRLEN1         YES  PLACE BLOCKSIZE
         L         L5,MCD              WRITE ADDRESS
         ST        L5,WRADD1
         L         RA,BUFFENT          DO THE WRITE
         CNOP      2,4
         BALR      RQ,RA
         DC        A(8,0)
WRADD1   DC        F'0'
WRLEN1   DC        F'0'
         L         RA,BUFFENT          DO A CHECK
         CNOP      2,4
         BALR      RQ,RA
         DC        A(28,0)
*./      DELETE    SEQ1=20680020,SEQ2=20900020
*        WRITE SUBSEQUENT BLOCKS OF DICT TO SYSUT1
*./      DELETE    SEQ1=20940020,SEQ2=20960020
         L     REG1,MCD
         A     REG1,RECSZ
         ST    REG1,MCD
         S         REG2,RECSZ
         BH        TSBST0              BRANCH IF MORE BLOCKS TO BE WRIT
*        DO A NOTE FOR COMPATIBILITY WITH TEXT WRITTING ROUTINES
         L         RA,BUFFENT
         CNOP      2,4
         BALR      RQ,RA
         DC        A(20,0)
NTNP1    DC        F'0'
         MVC       BWBLKS+BWFNOT(4),NTNP1
*
*        RETURN TO CALLING ROUTINE
*
*./      DELETE    SEQ1=21140020,SEQ2=21140020
         LM    RQ,L5,SAVREG
         BCR   15,LINK
*./      DELETE    SEQ1=21200020,SEQ2=21600020
         EJECT
*
*
*        SUBSETTING ROUTINE - PERMANENT DICTIONARY
*
*        THIS ROUTINE SUBSETS THE PERMANENT DICTIONARY.  INPUTS TO THE
*        ROUTINE ARE THE PERMANENT DICTIONARY IN CORE.
*
*        INPUT PARAMETERS FOR THIS ROUTINE ARE STORED IN THE COMMON
*        AREA AS FOLLOWS --- 'GDP' - ABSOLUTE ADDRESS OF DICTIONARY,
*        'DEND' - ABSOLUTE ADDRESS OF END OF DICTIONARY, 'ENDOPC' -
*        ADDRESS (RELATIVE TO GDP) OF FIRST PERMANENT DICTIONARY ENTRY
*        AFTER OP CODES, 'PNDX' - ADDRESS(RELATIVE TO GDP) OF NEXT
*        AVAILABLE LOCATION IN PERMANENT DICTIONARY, 'LTLAP' - LITTLE
*        A POINTER FOR PERMANENT DICTIONARY, 'ACTR' - STANDARD VALUE
*        FOR ACTR.
*
*        CALLING SEQUENCE ... BAL   LINK,PSBSET
*
PSBSET   DS    0H
         STM   RB,L5,SAVREG
         L     B2,DUSING
*
*
*        MOVE PERMANENT DICTIONARY TO BEGINNING OF DICTIONARY AREA
*
         MVI       SBSWCH,C'P'         NOTE SUBSETTING PERM. DICT
         L     REG1,PNDX
         L     REG2,GDP        BEGIN ADDRESS OF DICT AFTER MOVE IN REG2
         L     REG3,ENDOPC
         AR    REG1,REG2       END ADDRESS OF DICT AFTER MOVE IN REG1
         SR    REG1,REG3
         AR    REG3,REG2       BEGIN ADDR OF DICT BEFORE MOVE IN REG3
MVDIC1   MVC   0(256,REG2),0(REG3)
         LA    REG2,256(0,REG2)
         LA    REG3,256(0,REG3)
         CLR   REG2,REG1
         BNH       MVDIC1              GO MOVE REMAINING DICT.
*
*        SETUP TO SUBSET PERMANENT DICTIONARY
*
         ST    REG1,MCD        STORE BEGIN ADDRESS OF SUBSETTING AREA
         L     REG2,DEND       COMPUTE AND STORE SIZE OF SUBSET AREA
         LA    REG2,1(0,REG2)
         SR    REG2,REG1
         ST    REG2,MCDSZ
         L     XTRD,GDP        GET START ADDRESS OF PERMANENT DICT
         BCTR  REG1,0          GET AND STORE END ADDRESS OF PERMANENT
         ST    REG1,ENDTRD      DICTIONARY
         LM    REG1,REG2,LTLAP         GET SIZE OF SUBSETTED DICT  7953
         CLR   REG1,REG2                                           7953
         BC    2,*+6                                               7953
         LR    REG1,REG2                                           7953
         ST    REG1,LTTLAF                                         7953
*
*        CALL THE DICTIONARY SUBSETTING ROUTINE
*
         BAL   LINK,SBSET
         BAL   LINK,SBSET1
PSBIND   EQU   *         MUST FOLLOW BAL LINK,SBSET1
*
*        MOVE SUBSETTED PERMANENT DICTIONARY TO HEAD OF DICTIONARY AREA
*
         L     REG1,LTTLAF   GET SIZEOF SUBSETTED DICT             7953
CHKAGN1  CL    REG1,MCDSZ    IS IT TOO BIG FOR AREA
         BNH   AFINE         NO. IT'S O.K.
         BAL   LINK,HELP     GO GET SOME MORE CORE, ETC.
         B     CHKAGN1                  TRY AGAIN
AFINE    L     REG2,GDP        BEGIN ADDRESS OF DICT AFTER MOVE IN REG2
         L     REG3,MCD        BEGIN ADDR OF DICT BEFORE MOVE IN REG3
         AR    REG1,REG2       END ADDRESS OF DICT AFTER MOVE IN REG1
MVDIC2   MVC   0(256,REG2),0(REG3)
         LA    REG2,256(0,REG2)
         LA    REG3,256(0,REG3)
         CLR   REG2,REG1
         BNH       MVDIC2              GO MOVE REMAINING DICT.
*
*        SETUP INPUT AREA AND SUBSETTING AREA FOR F3.
*
         LA    REG3,8(0,REG1)  ROUND SUBSETTING ADDRESS UP TO DOUBLE
         N     REG3,RNDMSK2     WORD BOUNDRY AND STORE
         ST    REG3,MCD
         L     REG2,GDP
         ST    REG3,0(0,REG2)  ALSO STORE IN FIRST WORD OF PERM DICT
         L     REG1,DEND       GET AND STORE END ADDRESS OF INPUT AREA
         ST    REG1,ENDTRD
*./      DELETE    SEQ1=23240020,SEQ2=23300020
*
*        RETURN TO CALLER
*
         LM    RB,L5,SAVREG
         BCR   15,LINK
*
         EJECT
*
*        DICTIONARY SUBSETTING ROUTINE
*
*        THIS ROUTINE CLEARS THE SUBSETTING AREA TO ZEROS. IT REQUIRES
*        THE ADDRESS OF THE SUBSETTING AREA IN 'MCD' AND THE AREA
*        SIZE IN 'MCDSZ'.
*
*        CALLING SEQUENCE - - - - -
*        BAL   LINK,SBSET
*
SBSET    EQU   *
         L     REG1,MCD        CLEAR THE SUBSETTING AREA TO ZERO
         L     REG2,MCDSZ       CONTENTS OF MCD GIVES BEGINNING
SBSETB   AR    REG2,REG1        ADDRESS AND CONTENTS MCD + CONTENTS
*                  ENTER AT SBSETB WITH REG1 AND REG2 ALREADY DEFINED
         LA    REG3,256
         MVI   0(REG1),0           CLEAR FIRST BLOCK OF 256 BYTES
         MVC   1(255,REG1),0(REG1)
SBSETA   SR    REG2,REG3           CLEAR THE REST OF THE AREA BLOCK BY
         CR    REG2,REG1           BLOCK STARTING WITH LAST BLOCK AND
         BCR   12,LINK         WORKING BACKWARDS                   7869
         MVC   0(256,REG2),0(REG1)
         BC    15,SBSETA
*
*
*        THIS ROUTINE SUBSETS A DICTIONARY FROM AN AREA OF CORE WHOSE
*        ADDRESS IS IN 'TRD' AND WHOSE END ADDRESS IS IN 'ENDTRD' INTO
*        AN AREA OF CORE WHOSE ADDRESS IS IN 'MCD'. THIS ROUTINE WILL
*        RETURN TO THE CALLING ROUTINE AT THE ADDRESS IMMEDIATELY
*        FOLLOWING THE BAL INSTRUCTION IF END OF DICTIONARY IS REACHED.
*        IF A FLAGBYTE OF X'FF' IS ENCOUTNERED, RETURN IS MADE TO THE
*        ADDRESS+4 FOLLOWING THE BAL INSTRUCTION(END OF TRANSIENT DICT)
*
*        DICTIONARY SUBSETTING IS DYNAMIC IN TWO WAYS-
*             (1) TRANSIENT DICTIONARY SUBSETTING OCCURS ON TOP OF,
*             BUT ONE BLOCK BEHIND, THE UNSUBSETTED DICT. IN THIS WAY
*             WHEN SUBSETTING CORE IS REQUIRED, A BLOCK OF SUBSETTED
*             UNSUBSETTED DICT. SPACE CAN BE ZEROED, THEN USED; UNLESS
*             DIMENSIONED SET SYMBOLS CAUSE THE SUBSETTED DICT. BLOCK
*             TO BE LARGER THAN THE UNSUBSETTED DICT. BLOCK.
*             (2) PERMANENT DICTIONARY SUBSETTING TAKES PLACE IN THE
*             AREA FROM THE END OF THE UNSUBSETTED DICT. TO DEND.
*             IF IT RUNS OUT OF SPACE, MORE CORE IS REQUESTED FROM BUFF
*             AT 'GETCRBLK', AND THE SUBSETTING AREA IS EXPANDED, THE
*             NEW BLOCK IS ZEROED, AND THE SUBSETTING RESUMES.
*
*        CALLING SEQUENCE - - - - - -
*        BAL   LINK,SBSET1
*        RETURN FOR END OF PERM DICT OR END OF TRANS DICT.
*
SBSET1   EQU   *
         ST    LINK,SVLINK             SAVE THAT REGISTER
SBSET1A  LA    XTRD,2(0,XTRD)  INCREMENT TRANSIENT DICT INPUT AREA BY 2
         CLI       SBSWCH,C'P'         ARE WE SUBSETTING PERM .Q
         BE        SUBPERM             BR IF YES
         LA        XTRD,1(0,XTRD)      SUBSETTING TRANS
SUBPERM  C     XTRD,ENDTRD       EXIT IF END OF PRESENT BLOCK
         BCR   10,LINK                 OR END OF PERM. DICT.
         TM    0(XTRD),255     EXIT IF                             7869
         BCR   8,LINK                  END OF PRESENT DICT BLOCK
         BO    4(0,LINK)               OR END OF DICTIONARY        7869
         LR    FLGBYT,XTRD      SAVE FLAG BYTE ADDRESS             7869
         IC    REG2,0(0,XTRD)      ISOLATE LENGTH OF NAME IN ENTRY 7869
         N     REG2,FLGM1      INCREMENT TRANSIENT AREA INDEX BY LENGTH
         AR    XTRD,REG2        OF BCD NAME ENTRY PLUS 2 TO POSITION
         LA    XTRD,2(0,XTRD)   TO LITTLE A POINTER.
         SR    XMCD,XMCD       LOAD MACRO DICT AREA INDEX WITH LITTLE
         IC    XMCD,0(0,XTRD)   A POINTER PLUS ABSOLUTE ADDRESS OF
         SLL   XMCD,8           MACRO DICT AREA . SAVE LITTLE A IN
         IC    XMCD,1(0,XTRD)   ANOTHER REGISTER
         LR    LITTLA,XMCD
         A     XMCD,MCD
         LA    REG1,4(0,LITTLA)         TEST TO SEE IF SUBSETTING AREA
CHKAGAN  CL    REG1,MCDSZ       IS LARGE ENOUGH TO HOLD ENTRY
         BNH   OKBACK             YES..O.K.
         BAL   LINK,HELP               BIF NO.
         L     LINK,SVLINK             RESTORE REGISTER
         B     CHKAGAN             TRY AGAIN
OKBACK   CLC   LTTLAF,F65535   ABORT IF LITTLA
         BH    ABORTP                  OVERFLOWED TWO BYTES
         LA    XTRD,2(0,XTRD)  POSITION TRANS AREA INDEX BEYOND LITTLEA
         TM    0(FLGBYT),56    TEST BITS 2-4 OF FLAGBYTE WHICH SHOW
         BC    8,TAG              TYPE OF ENTRY. BRANCH TO APPROPRIATE
         TM    0(FLGBYT),X'30'  ROUTINE FOR THAT TYPE OF ENTRY.
         BC    8,SBSET1A
         BC    1,SETC
         TM    0(FLGBYT),X'28'
         BC    8,SYMB
         BC    1,SETB
         TM    0(FLGBYT),X'18'
         BC    1,MAC
SETA     LR    REG1,XTRD       GET SUBSCRIPT BYTE ADDRESS
         LA    XTRD,2(,XTRD)  SET TRANSIENT AREA INDEX TO NXT ENTRY
SETA1    C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO
         BC    8,SBSET1A         --YES, DONT STORE INTO SUBSETTED DICT
SETA2    CLC   0(2,REG1),F1       TEST IF ENTRY IS SUBSCRIPTED
         BC    8,SBSET1A         --NO, DONT STORE IN SUBSETTED DICT
         MVC   0(2,XMCD),0(REG1)  STORE SUBSCRIPT IN SUBSETTED DICT
         BC    15,SBSET1A
SETB     LR    REG1,XTRD       GET SUBSCRIPT BYTE ADDRESS
         LA    XTRD,3(,XTRD)  SET TRANSIENT AREA INDEX TO NXT ENTRY
         BC    15,SETA1
SETC     LR        REG1,XTRD           SUBSCRIPT BYTE ADDRESS
         LA        XTRD,3(,XTRD)       SET TRANS AREA INDEX TO NEXT
         C         LITTLA,ENDBLK       TEST IF LITTLE A PTR IS ZERO
         BE        SBSET1A             DON'T STORE IN SUBSETTED DICT
         MVC       0(1,XMCD),2(REG1)   PLACE MAX LENGTH IN SUBSET DICT
         MVC       2(1,XMCD),2(REG1)   PLACE HERE ALSO IN CASE DIMENS'D
         B         SETA2               GO MOVE DIMENSION
TAG      C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO
         BC    8,TAG1            --YES, DONT STORE INTO SUBSETTED DICT
*                              MOVE NOTE/POINT AND RELATIVE ADDRESSES
         MVC   0(5,XMCD),0(XTRD)  FROM TRANSIENT TO SUBSETTED DICT.
TAG1     LA    XTRD,5(0,XTRD)  SET TRANSIENT AREA INDEX TO NEXT ENTRY
         BC    15,SBSET1A
SYMB     C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO
         BC    8,SYMB1           --YES, DONT STORE INTO SUBSETTED DICT
         CLI   3(XTRD),X'80'            IS SYMBOL AN EXTENDED EQU .Q
         BNE   SYMBA                    BRANCH IF NOT
         MVC   0(1,XTRD),4(XTRD)        SET ACTUAL TYPE
         MVI   4(XTRD),X'00'            ZERO SAVED TYPE VALUE
         B     SYMBB                    AND GO SET IT
SYMBA    DS    0H
         IC    REG2,0(,XTRD)            GET WORKING TYPE
         IC    REG2,TYPETRAN(REG2)      GET ACTUAL TYPE
         STC   REG2,0(,XTRD)            SET ACTUAL TYPE
SYMBB    DS    0H
         MVC   0(5,XMCD),0(XTRD)
SYMB1    LA    XTRD,5(0,XTRD)
         BC    15,SBSET1A
MAC      C     LITTLA,ENDBLK   TEST IF LITTLE A POINTER IS ZERO
         BC    8,MAC1            --YES, DONT STORE INTO SUBSETTED DICT
         MVC   0(3,XMCD),0(XTRD)  MOVE NOTE/POINT TO SUBSETTED DICT
MAC1     LA    XTRD,5(0,XTRD)  SET DICT INDEX TO NEXT ENTRY
         BC    15,SBSET1A
TYPETRAN DC    AL1(P,Z,E,D,K,F,G,H,S,A)
         DC    AL1(V,Y,R,W,I,C,Q,B,J,X)
         DC    AL1(M,T,U,O,N,U,L,$)
*
* DICTIONARY SUBSET AREA IS TOO SMALL TO HOLD ENTRY. TRY TO EXPAND DICT
* AREA BY ONE BLOCK.  IF BUFF SAYS NO, PRINT ERROR MSG AND ABEND.
*
HELP     STM   LINK,REG3,SAVE2          SAVE SOME REGISTERS
         LA    REG1,PSBIND             FETCH PERM. SUBSET RETURN
         L     LINK,SVLINK             GET RETURN ADDR FROM SUBSET
         LA    LINK,0(0,LINK)           ZERO HIGH ORDERED BYTE
         CR    REG1,LINK                IS PERMANENT DICT. SUBSETTED .Q
         BE    CORGET                  BIF YES.
         L     REG3,HISTRY+4           END OF INPUT AREA(FORMER PPA)
         LA    REG3,BLKSZ(0,REG3)      DO WE NEED ANOTHER BLOCK
         CL    REG3,DEND               OF CORE
         BL    NOCORE                  BIF NO.
CORGET   BAL   REG2,GETCRBLK      WE NEED TO GET ANOTHER BLK OF CORE
NOCORE   CR    REG1,LINK               PERM. DICT. SUBSETTED?
         BE    ZEROIT                  BIF YES.
         LR    REG1,REG3
         ST    REG1,HISTRY+4           SAVE NEW VALUE
         BAL   LINK,MOVE1024           MOVE INP DICT AHEAD ONE BLOCK
         L     REG2,MCD1
         LA    REG2,BLKSZ(0,REG2)
         ST    REG2,MCD1               SAVE UPDATED VALUE
         LA    XTRD,BLKSZ(0,XTRD)      BUMP XTRD POINTER TOO.
         LA    FLGBYT,BLKSZ(0,FLGBYT)  BUMP PTR TO FLAG BYTE.
         L     REG2,ENDTRD             END OF CURRENT INP BLK.
         LA    REG2,BLKSZ(0,REG2)      INCREMENT IT
         ST    REG2,ENDTRD             SAVE NEW VALUE
ZEROIT   L     REG1,MCD                POINT REG1 TO BEGINNING
         A     REG1,MCDSZ              OF NEXT BLOCK
         LA    REG2,BLKSZ              REG2 HAS BLOCKLENGTH TO ZERO
         BAL   LINK,SBSETB        ZERO NEXT BLOCK OF SUBSETTING AREA.
         LA    REG1,BLKSZ
         A     REG1,MCDSZ              SET MCDSZ TO NEW VALUE
         ST    REG1,MCDSZ
         LM    LINK,REG3,SAVE2         RESTORE REGS.
         BR    LINK                    SUBSETTING AREA IS NOW BIGGER BY
*                                      BLKSZ BYTES - TRY AGAIN.
*
*
*
*
SBSWCH   DC        C'T'
         EJECT
*
* CLOSED ROUTINE TO DICTIONARY FOR OUTPUT OPERAND LIST FORMAT
*
LOOKUP   ST    B2,SAVEM+4               SAVE CALLER'S BASE REGISTER
         L     B2,DUSING                CONTINUE THE GAME
         IC    ZERORG,IOPNDX
         LA    OPNDS,OPNDL-4(ZERORG)
BEFORL   LA    OPNDS,4(0,OPNDS)         LOOK AT NEXT LIST ENTRY
         IC    ZERORG,OPNDX             CHECK IF END OF LIST
         LA    WORKRG,OPNDL(ZERORG)
         CR    WORKRG,OPNDS
         BH    CHKOUT
         MVI   OPNDX,X'00'
         MVI   IOPNDX,0
         L     B2,SAVEM+4               RESTORE THE BASE REGISTER
         BR    TEMPRG
CHKOUT   MVC   LSTFLG(4),0(OPNDS)       SAVE LIST WORD
         TM    LSTFLG,MASK0             DICTIONARY ACTION REQUIRED
         BZ    BEFORL
         NI    0(OPNDS),X'07'
         IC    ZERORG,1(0,OPNDS)        POINT TO INPUT BUFFER LOCATION
         L     RA,INPUT
         AR    RA,ZERORG
         MVC   DCAREA+1(8),0(RA)        EXTRACT BCD FROM INPUT AREA
         IC    ZERORG,0(0,OPNDS)        'LENGTH OF ENTRY' POINTER
         LH    DCTEMP,LSTFLG+2
         LA    DCTEMP,OUTPUT(DCTEMP)    POINTER TO OUTPUT
         LA    BLKSKP,DCAREA+2(ZERORG)  POINTER ONE PAST END OF BCD
         STC   ZERORG,DCAREA
         TM    LSTFLG,X'40'             TEST FOR VARIABLE SYMBOL
         BO    VARTYP
         TM    LSTFLG,8                 TEST IF REFERENCE TO O.S. OR
         BZ    SEQREF                     S.S.
         TM    LSTFLG,32                NO -TEST IF SEQUENCE SYMBOL
         BO    SEQDEF
         TM    SWTCH5,X'41'             O.S. DEFINITION -HOWEVER
         BZ    BEFORL                     NOT IN MACROS UNLESS EXTEN
         OI    DCAREA,80                NO -COMPLETE O.S. FLAG BYTE
         MVC   2(5,BLKSKP),TYPATR       MOVE IN TYPE, LENGTH, SCALE
         MVI   DENTRY,128               INDICATE POINT OF DEFINITION
         BAL   LINK,ENTDCT              FOR THE DICTIONARY MAN
         B     BEFORL                   THAT'S ALL
SEQREF   MVI   DENTRY,0                 INDICATE POINT OF REFERENCE
         OI    DCAREA,64
         TM    LSTFLG,32
         BO    *+12
         OI    DCAREA,16
         MVI   2(BLKSKP),UTYPE          DAVE'S SOP
         BAL   LINK,ENTDCT              MAKE THE ENTRY IN TH E DICT.
         BCT   DCTEMP,VART12            GO MOVE IN LIL'A
SEQDEF   MVI   DENTRY,128               INDICATE POINT OF DEFINITION
         OI    DCAREA,64                COMPLETE G.D. FLAG BYTE
         MVC   2(3,BLKSKP),STNOTE       MOVE 3 BYTE NOTE POINT PLUS
         MVC   5(2,BLKSKP),STNOTE+4       BUFFER INDEX TO ENTRY AREA
         B     VARD10
VARTYP   CLI   DEFENT,0                 TEST IF DECLARATION
         BNE   VARDEF                   YES
         MVI   DENTRY,3                 NO -LOOKUP
         BAL   LINK,DLKUP               GO GET SYMBOL
         LTR   EPTR,EPTR                UNDECLARED V.S. IS AN ERROR
         BNE   *+12                     ALL IS WELL
         L     LINK,VABSER              LOAD VECTOR
         BALR  LINK,LINK                V.S. NOT PREVIOUSLY
         DC    AL1(ERRR8)                DECLARED
         DC    AL1(ERRST)
         LA    WORKRG,4(ZERORG,EPTR)    POINT TO DIMENSION IN ENTRY
         TM    0(EPTR),40               IS ENTRY A SETB.....
         BO    VART15                   YES
         TM    LSTFLG,32                NO -IS ONE REQUIRED
         BO    ILSTBX                   YES...ERROR
         TM    0(EPTR),72               NO -IS IT A SYMBOLIC PARAMETER
         BO    VART17                   YES
VART04   MVI   3(DCTEMP),0              NO -CLEAR NULL BYTE IN TEXT
VART05   TM    LSTFLG,16                IS SYMBOLIC PARAMETER REQUIRED
         BZ    VART06                   NO... OK TO PROCEED
         TM    SWTCH5,X'01'             IS EXTEN ON .Q
         BZ    ILTYPE                   NO, THEN WE HAVE AN ERROR
         TM    0(EPTR),X'30'            AND IS ENTRY A SETC .Q
         BNO   ILTYPE                   NO, THEN AGAIN WE HAVE AN ERROR
         IC    ZERORG,1(,OPNDS)         GET DISP INTO BUFFER LOCATION
         A     ZERORG,INPUT             CHANGE TO ABSOLUTE ADDRESS
         S     ZERORG,F2                BACK OFF TWO CHARACTERS
         CLC   0(2,ZERORG),KQUOTE       IS OPERATOR K' .Q
         BNE   ILTYPE                   NO THEN WE HAVE AN ERROR
VART06   TM    0(EPTR),64               IS THIS A GLOBAL ENTRY .Q
         BO    *+8
         OI    3(DCTEMP),128            YES -SET GLOBAL FLAG IN TEXT
         CLC   0(2,WORKRG),F1           IF V.S. IS DIMENSIOND THEN
         BE    *+8                        TEXT OCCURENCE MUST BE
         XI    LSTFLG,8                   SUBSCRIPTED AND CONVERSELY
         TM    LSTFLG,8
         BO    ILUSS
VART10   IC    ZERORG,0(0,EPTR)         GENERATE TEXT FLAG BYTE
         SRL   ZERORG,3
         N     ZERORG,F7
         IC    ZERORG,VART20-1(ZERORG)
         STC   ZERORG,0(0,DCTEMP)
VART12   STH   APTR,DUMMY               MOVE LIL'A  OR PAR. NO. INTO
         MVC   1(2,DCTEMP),DUMMY          EDITED TEXT
         B     BEFORL                   WHEW
KQUOTE   DC    X'1431'                  K' INTERNAL CODE CHAR STRING
VART15   CLC   0(2,WORKRG),F1           BACK TO MAINLINE IF SETB
         BNE   VART04                     VARIABLE IS DIMENSIONED
         MVC   3(1,DCTEMP),2(WORKRG)    ELSE, SET BIT NUMBER IN TXT
         B     VART05
VART17   CH    APTR,H1                  BRANCH IF NOT SYSECT OR SYSNDX
         BH    VART10
         TM    LSTFLG,16                OTHERWISE, MUST NOT BE
         BZ    VART10                     EXPECTING AN S.P.
ILTYPE   L     LINK,VABSER              LOAD VECTOR
         BALR    LINK,LINK              ILLEGAL USAGE OF
         DC    AL1(ERRR9)               VARIABLE SYMBOL
         DC    AL1(ERRST)
VART20   DC    AL1(SSPAR)
         DC    AL1(0)
         DC    AL1(0)
         DC    AL1(SSETA)
         DC    AL1(SSETB)
         DC    AL1(SSETC)
VARDEF   DS        0H
         OC        DCAREA(1),DEFENT    FINISH UP FLAG BYTE
         CLI       DEFENT,72           IF SYMBOLIC PARAMETER THEN
         BE        VARD09              ENTER PARAMETER NUMBER
         LA        BLKSKP,2(,BLKSKP)   OTHERWISE DIMENSION
         MVC       2(1,BLKSKP),LSETCBYT+3  SET DEFAULT SETC LENGTH
         LA        RA,1(ZERORG,RA)     POINT PAST END OF NAME ON INPUT
         CLI       0(RA),STAR          TEST IF LENGTH SPECIFIED
         BNE       VARD09
         SR        LINK,LINK           ZERO ACCUMULATOR
VARD05   LA        RA,1(,RA)           POINT AT NEXT SOURCE CHAR
         CLI       0(RA),N9            TEST IF NUMERIC
         BH        VARD06
         IC        ZERORG,0(,RA)       PICK UP SOURCE CHAR
         MH        LINK,H10            SHIFT ACCUMULATOR
         AR        LINK,ZERORG         ADD IN NEW DIGIT
         B         VARD05              LOOP FOR MORE DIGITS
VARD06   LTR       LINK,LINK           TEST VALUE NOT ZERO
         BNH       VARD07
         C         LINK,F255           TEST NOT TOO BIG
         BNH       VARD08
VARD07   L         LINK,VWRNER1        OUTPUT WARNING
         BALR      LINK,LINK
         DC        AL1(ERRR57)         INCORRECT LENGTH SPECIFICATION
         DC        AL1(ERRST)
*./      DELETE    SEQ1=28351025,SEQ2=28351025
         IC        LINK,LSETCBYT+3     SET DEFAULT SETC LENGTH
VARD08   STC       LINK,2(BLKSKP)      PLACE MAX LENGTH BYTE
VARD09   MVC   0(2,BLKSKP),LSTFLG+2
VARD10   BAL   LINK,ENTDCT              MAKE THE ENTRY IN THE DICT.
         CLI   DERR,0                   NO DUPLICATES, PLEASE
         BE    BEFORL
         CLI   DERR,32                  WHAT DOES SYMBOL MATCH .Q
         BH    VARD11                   BIF IT MATCHES A SET SYMBOL
         BE    VARD12                   BIF IT MATCHES A PARAMETER
         CLI   DERR,2                   WAS GLOBAL INCONSISTANT .Q
         BE    VARD13                   BIF YES
         L     LINK,VABSER              LOAD VECTOR
         BALR  LINK,LINK                IF HERE, MUST MATCH A S.S.
         DC    AL1(ERRR49)
         DC    AL1(ERRST)
VARD11   L     LINK,VWRNER1             LOAD VECTOR
         BALR  LINK,LINK                SET SYMBOL PREVIOUSLY DEFINED
         DC    AL1(ERRR15)
         DC    AL1(ERRST)
         B     BEFORL                   PROCESS NEXT OPNDL ENTRY,IF ANY
VARD12   L     LINK,VWRNER1             LOAD VECTOR
         BALR  LINK,LINK                SET SYMBOL SAME AS A S.P.
         DC    AL1(ERRR10)
         DC    AL1(ERRST)
         B     BEFORL                   PROCESS NEXT OPNDL ENTRY,IF ANY
VARD13   L     LINK,VWRNER1             LOAD VECTOR
         BALR  LINK,LINK                INCONSISTANT GLOBAL DECLARATION
         DC    AL1(ERRR51)
         DC    AL1(ERRST)
         B     BEFORL                   PROCESS NEXT OPNDL ENTRY,IF ANY
ILUSS    L     LINK,VABSER              LOAD VECTOR
         BALR  LINK,LINK                S.S. USAGE INCON. WITH DECLR.
         DC    AL1(ERRR48)
         DC    AL1(ERRST)
ILSTBX   L     LINK,VABSER              LOAD VECTOR
         BALR  LINK,LINK                ILLEGAL SETB EXPRESSION
         DC    AL1(ERRR5)
         DC    AL1(ERRST)
*./      DELETE    SEQ1=29080020,SEQ2=29140020
VABSER   DC    V(ABSERR)
VWRNER1  DC    V(WRNERR)
VABS001  DC    V(ABS001)
         EJECT
ASCAN    ST    B2,SAVREG                MICKEY-MOUSE TO ESTABLISH
         DROP  B2                        INDEPENDENT ADDRESSABILITY
         BALR  B2,0
         USING *,B2
ASCAN1   BAL   LINK,ASC05
         SH    LINKR,H4
         L     B2,SAVREG
         B     4(0,LINKR)
ASC05    LA    R3,1                     SET UP A ONE'S REGISTER
         ST    R3,ASTAT                   AND INDICATORS
         LR    R3A,R3                   CLEAR HIGH ORDER GARBAGE
*        PROCESS DUPLICATION FACTOR
         CLI   0(INPTR),N9              TEST FOR INITIAL DIGIT
         BH    ASC10
         BAL   R1,DECBIN                CONVERT TO BINARY
         LTR   R2,R2                    IF LITERAL, CANNOT BE 0
         BNE   ASC10
         TM    ACALL,2
         BCR   1,LINK
*        PROCESS TYPE
ASC10    CLI   0(INPTR),Z               TEST FOR TYPE LETTER
         BCR   2,LINK                   NO
         IC    R3A,0(0,INPTR)           TEST FOR VALID TYPE
         IC    R3A,ASC198-A(R3A)
         LTR   R3A,R3A
         BCR   8,LINK                   NO
         LA    R1,ASC199(R3A)           YES -MOVE TABLE ENTRY FOR TYPE
         MVC   RSLTA(14),0(R1)            TO RESULT AREA
ASC15    AR    INPTR,R3                 ADVANCE INPUT POINTER
*        PROCESS LENGTH MODIFIER
         CLI   0(INPTR),L               TEST IF PRESENT
         BNE   ASC35
         AR    INPTR,R3                 YES
         OI    ASTAT,32                 SET EXPLICIT LENGTH INDICATOR
         CLI   0(INPTR),DOT             TEST IF BIT LENGTH
         BNE   ASC25
         CLI   ATYP,STYPE               YES -HOWEVER, NOT IN S-TYPE
         BCR   8,LINK                     CONSTANTS
         AR    INPTR,R3                 CONVERT TO BINARY
         BAL   R1,DECBIN
         LA    R2,7(0,R2)                 THENCE TO BYTE LENGTH
         SRA   R2,3
         B     ASC30
ASC25    BAL   R1,DECBIN
ASC30    BCT   R2,ASC32                 CONVERT TO 360 LENGTH
         CLI   ATYP,STYPE               ERROR IF S-TYPE AND LENGTH NOT
         BCR   8,LINK                     EQUAL TO 2
ASC32    CL    R2,F65535                ERROR IF LENGTH EXCEEDS
         BCR   2,LINK                   ABSOLUTE MAXIMUM OF 65536
         CH    R2,LMAX                  IF LENGTH EXCEEDS STANDARD
         BNH   ASC34                      MAXIMUM, TEST FOR C OR X TYPE
         TM    ACALL,1                    IN A DS
         BCR   8,LINK
         TM    AFLGS,48
         BCR   8,LINK
         CLI   ATYP,BTYPE
         BCR   8,LINK
ASC34    STH   R2,ALENG
*./      DELETE    SEQ1=30400020,SEQ2=30400020
         TM    AFLGS,4                  IF D OR E TYPE, SET MAX SCALE
         BZ    ASC37                    NOT D, E, L TYPE
         CLI   ATYP,LTYPE               IF L-TYPE,
         BNE   ASC38                     (NOT L)
         CLI   ALENG+1,9-1              AND IF LENGTH GT 8 BYTES,
         BL    ASC38                     (NOT GT)
         SR    R2,R3                    THEN ALLOW FOR LOW EXPON.
ASC38    AR    R2,R2                    DEVELOP MAX S-MOD
         STH   R2,SMAX
ASC37    MVC   ATYP(1),MAPTYP           REPLACE TYPE
*        PROCESS SCALE MODIFIER
ASC35    CLI   0(INPTR),S               TEST IF PRESENT
         BNE   ASC50
         TM    AFLGS,6                  TEST IF SCALE ALLOWED
         BCR   8,LINK                   NO
         AR    INPTR,R3                 ADVANCE INPUT POINTER
         CLI   0(INPTR),PLUS            CHECK FOR PLUS SIGN
         BE    ASC40
         CLI   0(INPTR),MINUS           CHECK FOR MINUS SIGN
         BNE   ASC42
         TM    AFLGS,4                  YES-NOT ALLOWED-D,E,L-CON
         BCR   1,LINK
         OI    ASTAT,16                 SET IND.
ASC40    TM    ACALL,2                  SIGNED SCALE NOT ALLOWED IN
         BCR   1,LINK                     LITERAL
         AR    INPTR,R3
ASC42    CLI   0(INPTR),N9              TEST FOR DIGIT
         BCR   3,LINK
         BAL   R1,DECBIN                YES -CONVERT SCALE TO BINARY
         TM    ASTAT,16                 SET NEGATIVE IF MINUS SIGN
         BZ    ASC45
         LCR   R2,R2
         CH    R2,MH187                 TEST AGAINST MINIMUM VALUE
         BCR   4,LINK                   UNDER
ASC45    CH    R2,SMAX                  TEST AGAINST MAXIMUM VALUE
         BCR   3,LINK                   OVER
         STH   R2,ASCAL
*        PROCESS EXPONENT MODIFIER
ASC50    CLI   0(INPTR),E               TEST IF PRESENT
         BNE   ASC60
         TM    AFLGS,6                  TEST IF ALLOWED
         BCR   8,LINK                   NO
         B     4(0,LINK)                YES
ASC60    CLI   0(INPTR),QUOTE           TEST FOR QUOTE
         BNE   ASC95
         TM    AFLGS,62                 YES -TEST IF VALID
         BCR   8,LINK
         AR    INPTR,R3                 YES -ADVANCE INPUT POINTER
         TM    AFLGS,56                 TEST IF IMPLIED LENGTH SCAN
         BZ    4(0,LINK)                NO -EXIT
ASC62    SR    R3A,R3A                  INITIALIZE FOR IMPLIED LENGTH
         LR    R2,R3A                     SCAN
*        DETERMINE IMPLIED LENGTH AND/OR SCALE
ASC65    CLI   0(INPTR),QUOTE           TEST FOR QUOTE
         BNE   ASC70
         TM    AFLGS,32                 YES -IS THIS C TYPE
         BZ    ASC90                    NO -FINISHED
         AR    INPTR,R3                 YES -ADVANCE INPTR AND TEST
         CLI   0(INPTR),QUOTE             FOR DOUBLE QUOTE
         BNE   ASC90                    NO -FINISHED
ASC70    CLC   0(1,INPTR),ACMAX         COMPARE AGAINST HIGH VALUE
         BNH   ASC80
         TM    AFLGS,16                 TEST IF X OR B TYPE
         BCR   1,LINK                   YES -ERROR
         CLI   0(INPTR),PLUS            TEST FOR PLUS SIGN
         BE    ASC75
         CLI   0(INPTR),MINUS             -OR MINUS
         BE    ASC75
         CLI   0(INPTR),DOT             NO -TEST IF DECIMAL POINT
         BE    ASC74
         CLI   0(INPTR),COMMA           NO -TEST FOR TERMINATING COMMA
         BCR   7,LINK                   NO -ERROR
ASC90    STC   R2,ASCAL+1               STORE SCALE
         LR    R1,R3                    COMPUTE IMPLIED LENGTH
         IC    R1,RFACT
         AR    R3A,R1
         IC    R1,SFACT
         SRL   R3A,0(R1)
         SR    R3A,R3
         BCR   4,LINK                   MUST BE AT LEAST 1
         CH    R3A,LMAX                 MAKE SURE L.E. MAXIMUM
         BCR   3,LINK                   NO -ERROR
         TM    ASTAT,32                 WAS THERE AN EXPLICIT LENGTH
         BO    4(0,LINK)                YES -EXIT
         STH   R3A,ALENG                NO -STORE IMPLIED
         B     4(0,LINK)                EXIT
ASC74    XI    ASTAT+1,1                ERROR IF DECIMAL POINT ALREADY
         BCR   8,LINK                     SCANNED
         B     ASC85
ASC75    XI    ASTAT+2,1                ERROR IF SIGN ALREADY SCANNED
         BCR   8,LINK
         BXH   INPTR,R3,ASC65
ASC80    CLI   0(INPTR),AMPSND          TEST FOR AMPERSAND
         BNE   *+6
         AR    INPTR,R3                 YES -MUST BE A DOUBLE
         AH    R2,ASTAT                 BUMP THE SCALE COUNTER
         AR    R3A,R3                   ADD ONE TO LENGTH COUNTER
ASC85    OI    ASTAT+2,1                DISALLOW SIGN
         BXH   INPTR,R3,ASC65
*        CONTINUE TESTS ON MODIFIER FIELD
ASC95    CLI   0(INPTR),LPAREN          TEST IF LEFT PARENTHESIS
         BNE   ASC100
         TM    AFLGS,192                YES -TEST IF ALLOWED
         BCR   8,LINK                   NO -ERROR
         B     4(0,LINK)                YES -EXIT
ASC100   CLI   0(INPTR),BLANK           TEST IF BLANK
         BE    ASC105
         CLI   0(INPTR),COMMA           NO -TEST IF COMMA
         BE    ASC105                   YES
         C     INPTR,ENDCOL             NO -LAST HOPE IS THE END COLUMN
         BCR   13,LINK                  NOPE
ASC105   TM    ACALL,1                  YES -TEST IF DS
         BO    4(0,LINK)                YES -EXIT
         TM    AFLGS,128                NO -TEST IF Q-TYPE
         BCR   8,LINK                   NO -ERROR
         B     4(0,LINK)                YES -EXIT
*DECBIN
*        SUBROUTINE TO CONVERT DIGIT STRING TO BINARY
*        BAL   R1,DECBIN
DECBIN   SR    R3A,R3A                  CLEAR PICK-UP AND VALUE
         LR    R2,R3A                     REGISTERS
DEC01    CLI   0(INPTR),N9              EXIT IF NOT DIGIT
         BCR   3,R1
         IC    R3A,0(0,INPTR)
         MH    R2,H10                   MULTIPLY PARTIAL VALUE BY 10
         AR    R2,R3A                     AND ADD IN CURRENT DIGIT
         BXH   INPTR,R3,DEC01
*        SAM'S TYPE FLAGS
*              OTHER FLAGS DEFINED FOR A,W,I,J,M,T AT TOP OF PHASE
ATYPE    EQU   9
BTYPE    EQU   17
CTYPE    EQU   15
DTYPE    EQU   3
ETYPE    EQU   2
FTYPE    EQU   5
GTYPE    EQU   6
HTYPE    EQU   7
ITYPE    EQU   14
JTYPE    EQU   18
KTYPE    EQU   4
LTYPE    EQU   26
MTYPE    EQU   20
NTYPE    EQU   24
OTYPE    EQU   23
PTYPE    EQU   0
QTYPE    EQU   16
RTYPE    EQU   12
STYPE    EQU   8
TTYPE    EQU   21
UTYPE    EQU   22
VTYPE    EQU   10
WTYPE    EQU   13
XTYPE    EQU   19
YTYPE    EQU   11
ZTYPE    EQU   1
ASC198   DC    AL1(ASC225-ASC199)       A
         DC    AL1(ASC210-ASC199)       B
         DC    AL1(ASC200-ASC199)       C
         DC    AL1(ASC250-ASC199)       D
         DC    AL1(ASC255-ASC199)       E
         DC    AL1(ASC260-ASC199)       F
         DC    AL1(0)                   G
         DC    AL1(ASC265-ASC199)       H
         DC    AL1(0)                   I
         DC    AL1(0)                   J
         DC    AL1(0)                   K
         DC    AL1(ASC270-ASC199)       L
         DC    AL1(0)                   M
         DC    AL1(0)                   N
         DC    AL1(0)                   O
         DC    AL1(ASC215-ASC199)       P
         DC    AL1(ASC245-ASC199)       Q
         DC    AL1(0)                   R
         DC    AL1(ASC230-ASC199)       S
         DC    AL1(0)                   T
         DC    AL1(0)                   U
         DC    AL1(ASC235-ASC199)       V
         DC    AL1(0)                   W
         DC    AL1(ASC205-ASC199)       X
         DC    AL1(ASC240-ASC199)       Y
ASC199   DC    AL1(ASC220-ASC199)       Z
ASC200   DC    AL1(32)       (AFLGS)    CTYPE
         DC    AL2(255)      (LMAX)
         DC    AL2(0)        (SMAX)
         DC    AL1(CTYPE)    (MAPTYP)
         DC    AL1(CTYPE)
         DC    AL2(0)        (ALENG)
         DC    AL2(0)        (ASCAL)
         DC    AL1(0)        (RFACT)
         DC    AL1(0)        (SFACT)
         DC    AL1(255)      (ACMAX)
ASC205   DC    AL1(16)                  XTYPE
         DC    AL2(255)
         DC    AL2(0)
         DC    AL1(XTYPE)
         DC    AL1(XTYPE)
         DC    AL2(0)
         DC    AL2(0)
         DC    AL1(1)
         DC    AL1(1)
         DC    AL1(15)
ASC210   DC    AL1(16)                  BTYPE
         DC    AL2(255)
         DC    AL2(0)
         DC    AL1(BTYPE)
         DC    AL1(BTYPE)
         DC    AL2(0)
         DC    AL2(0)
         DC    AL1(7)
         DC    AL1(3)
         DC    AL1(1)
ASC215   DC    AL1(8)                   PTYPE
         DC    AL2(15)
         DC    AL2(31)
         DC    AL1(PTYPE)
         DC    AL1(PTYPE)
         DC    AL2(0)
         DC    AL2(0)
         DC    AL1(2)
         DC    AL1(1)
         DC    AL1(9)
ASC220   DC    AL1(8)                   ZTYPE
         DC    AL2(15)
         DC    AL2(16)
         DC    AL1(ZTYPE)
         DC    AL1(ZTYPE)
         DC    AL2(0)
         DC    AL2(0)
         DC    AL1(0)
         DC    AL1(0)
         DC    AL1(9)
ASC225   DC    AL1(128)                 ATYPE
         DC    AL2(3)
         DC    AL2(0)
         DC    AL1(RTYPE)
         DC    AL1(ATYPE)
         DC    AL2(3)
         DC    AL2(0)
ASC230   DC    AL1(128)                 STYPE
         DC    AL2(1)
         DC    AL2(0)
         DC    AL1(RTYPE)
         DC    AL1(STYPE)
         DC    AL2(1)
         DC    AL2(0)
ASC235   DC    AL1(128)                 VTYPE
         DC    AL2(3)
         DC    AL2(0)
         DC    AL1(RTYPE)
         DC    AL1(VTYPE)
         DC    AL2(3)
         DC    AL2(0)
ASC240   DC    AL1(128)                 YTYPE
         DC    AL2(3)
         DC    AL2(0)
         DC    AL1(RTYPE)
         DC    AL1(YTYPE)
         DC    AL2(1)
         DC    AL2(0)
ASC245   DC    AL1(64)                  QTYPE
         DC    AL2(3)
         DC    AL2(0)
         DC    AL1(RTYPE)
         DC    AL1(QTYPE)
         DC    AL2(3)
         DC    AL2(0)
ASC250   DC    AL1(4)                   DTYPE
         DC    AL2(7)
         DC    AL2(14)
         DC    AL1(KTYPE)
         DC    AL1(DTYPE)
         DC    AL2(7)
         DC    AL2(0)
ASC255   DC    AL1(4)                   ETYPE
         DC    AL2(7)
         DC    AL2(6)
         DC    AL1(KTYPE)
         DC    AL1(ETYPE)
         DC    AL2(3)
         DC    AL2(0)
ASC260   DC    AL1(2)                   FTYPE
         DC    AL2(7)
         DC    AL2(346)
         DC    AL1(GTYPE)
         DC    AL1(FTYPE)
         DC    AL2(3)
         DC    AL2(0)
ASC265   DC    AL1(2)                   HTYPE
         DC    AL2(7)
         DC    AL2(346)
         DC    AL1(GTYPE)
         DC    AL1(HTYPE)
         DC    AL2(1)
         DC    AL2(0)
ASC270   DC    AL1(4)                   LTYPE     FLAGS
         DC    AL2(15)                       L MAX
         DC    AL2(28)                       MAX S-MOD IF IMP.LGH
         DC    AL1(KTYPE)                    TYPE IF LGH SPEC
         DC    AL1(LTYPE)                    TYPE IF IMPLIED LGH
         DC    AL2(15)                       IMPLIED LGH - 1
         DC    AL2(0)                        IMPLIED SCL MOD.
         EJECT
* TRANSIENT DICTIONARY CLOSEOUT AND RE-INITIALIZE CODE.
         DROP  B2
*
DCLOSE   BALR  B2,0
         USING *,B2                     FOR ADDRESSABILITY
DCLOS1   NI    SWTCH1,NMASK1            NO LONGER WITHIN A MACRO
         NI    SWTCH5,231               REALLOW GLOBAL AND LOCAL DECL.
         LA    RE1,PHASHT               RUNNING INDEX
         LA    RE2,2
         LA    RD2,PHASHT+PASHL1
DCLA     LR    CRNT,RE1
DCLB     MVC   EVENX+2(2),0(CRNT)
         L     CRNT,EVENX
         LTR   CRNT,CRNT
         BZ    DCLQ
         AL    CRNT,GDP
         TM    2(CRNT),X'20'
         BZ    DCLB
         OI    2(CRNT),X'80'
         B     DCLB                     CONTINUE.
DCLQ     BXLE  RE1,RE2,DCLA
         LM      CRA,THLDA,HISTRY
         L     RE1,TNDX
         LA    RD1,BLKSZ-5    MUST HAVE SIX BYTES IN LAST BLOCK
         CLR   RD1,RE1
         BL    DCL4                     BRANCH IF SPACE LESS THAN 6.
         LA    RS3,0(RE1,CRA)
         MVI   3(RS3),0
         BE    DCL4                                                7869
DCL3     MVI   3(RS3),X'FF'
         LM    RE2,RD2,LTLAT            GET LARGEST 'A'.
         CR    RE2,RD2
         BH    DCLT
         LR    RE2,RD2
DCLT     STH   RE2,EVENX+2
         MVC   4(2,RS3),EVENX+2         PLACE IN LAST BLOCK.
         ST    RE2,LTTLAF               SAVE FULL WORD LITTLA
*./      DELETE    SEQ1=36900020,SEQ2=37020020
         B     DCL6
DCL4     C     PPA,DEND    DO WE HAVE ENOUGH CORE LEFT FOR ANOTHER BLK
         BL    OKAYSTIL                BIF YES.
         ST    RD1,SAVE4               SAVE RD1
         L         B2,DUSING           ADDRESSABILITY FOR GETCRBLK
         USING     ENTDCT,B2
         BAL       RD1,GETCRBLK        GO GET ANOTHER BLOCK OF CORE
         L         B2,DCLOS1AD
         USING     DCLOS1,B2
         L     RD1,SAVE4                RESTORE RD1
*./      DELETE    SEQ1=37180020,SEQ2=37200020
OKAYSTIL LA    PPA,BLKSZ(0,PPA)        INCREMENT PPA POINTER
         LA    CRA,BLKSZ(0,CRA)        INCREMENT CRA POINTER,TOO.
         STM   CRA,THLDA,HISTRY        SAVE THEM POINTERS.
         LA    RS3,1(0,CRA)
*./      DELETE    SEQ1=37300020,SEQ2=37300020
         B     DCL3
*./      DELETE    SEQ1=37340020,SEQ2=37340020
SAVE4    DS    F
DCL6     MVI   THASHT,X'00'            SET TO CLEAR TA HASH TABLE
         MVC   THASHT+1(255),THASHT    ZERO IT. NOTE -  TASHL.EQ.128
         MVC   THASHT+256(3*TASHL-256),THASHT
         TM    SWTCH5,X'04'            SKIPPING TO MEND .Q
         BZ    DCL7A                   BIF NOT.
         TM    SWTCH6,2                MUST SUBSET .Q.
         BZ    DCL9                    BIF NOT.
DCL7A    L     LINK,DUSING              SUBSET THE MACRO DICTIONARY.
         BAL   LINK,TSBSET-ENTDCT(LINK)
DCL9     NI    SWTCH5,X'FB'             RESET MACRO ABORT CONDITION
         NI        SWTCH6,X'FD'        RESET DICT SUBSET INDIC
         LR    CRA,THLDA                RESET TA POINTERS.
         LA    PPA,BLKSZ(0,CRA)
         STM   CRA,PPA,HISTRY
DCL8     MVC   0(7,THLDA),FZRO          ZERO THE START OF EACH T.D.
         LA    THLDA,BLKSZ(0,THLDA)     BLOCK SUCH THAT 'EMPTY CORE'
         LA    RE1,BLKSZ-1                   COMPUTE
         S     RE1,DEND                      DEND+1
         LCR   RE1,RE1                       -BLKSZ.
         CR    THLDA,RE1                CAN NEVER APPEAR AS
         BNH   DCL8                     A TRANSIENT DICTIONARY BLOCK.
         LA    RE1,4                    RESET TA BLOCK INDEX FOR BLK 0.
         ST    RE1,VCR
         ST    RE1,TNDX
         LA    RE1,TBEG
         ST    RE1,LTLAT+4
         LA    RE1,1(0,RE1)
         ST    RE1,LTLAT
*./      DELETE    SEQ1=37920020,SEQ2=37920020
         TM    SWTCH5,128               BRANCH IF EDITING PGMR MACROS
         BO    DRVER                   BACK TO MAINLINE
         NI    SWTCH5,191               INDICATE SYSTEM MACRO EDITING
         OI    SWTCH5,32
*        DRIVER FOR SYSTEM MACRO EDITING
         SR    RE1,RE1             ZERO OUT REG.
         C     RE1,SVCHN           TEST IF FIRST TIME THROUGH.
         BNE   SMCH3               BRANCH IF NOT.
         C     RE1,MACHN           SEE IF ANY MACROS.
         BE        KLOSOWT
         MVI       TYPRED+1,MACLIB
         TM    PARBYT1,FLIST            WAS FULLLIST SPECIFIED .Q
         BO    FULLLIST                 BRANCH IF YES
         OI    SWTCH8,X'40'             FORCE ERROR 78 NEXT ERROR MSG
FULLLIST DS    0H
         L     LINK,VSWICL              LOAD VECTOR
         BALR  LINK,LINK           SET UP STANDARD ICTL SETTINGS.
         L     RE1,MACHN           GET RELATIVE MACRO CHAIN ORIGIN.
SMCH1    ST    RE1,SVCHN           SAVE ORIGIN.
SMCH2    AL    RE1,GDP             MAKE POINTER ABSOLUTE.
         LA    RE1,2(0,RE1)             MOVE PAST BIG 'A' POINTER TO
         IC    RD1,0(0,RE1)        GET FLAG BYTE.
         N     RD1,F7              KEEP ONLY BCD LENGTH.
         LA    RE2,4(RD1,RE1)      POINT TO N/P FIELD.
         CLC   0(NPTL,RE2),FZRO    UNDEFINED IF ZERO.
         BNE   SMCH4
         AIF       (&NOTSTAT).CONT
         ST        7,HOLDIT
         L         7,BUMPER2
         A         7,ADD
         ST        7,BUMPER2
         L         7,HOLDIT
         B         MVI
BUMPER2            DC                  F'0'
ADD      DC        F'1'
HOLDIT   DS        F
         DS        0H
MVI      MVI       DBLWD,BLANK
         AGO       .CONT1
.CONT    ANOP
         MVI   DBLWD,BLANK         SET DOUBLE WORD TO INTERNAL BLANKS.
.CONT1   ANOP
         MVC   DBLWD+1(7),DBLWD
         EX    RD1,SMNAMV          MOVE IN NAME.
         MVC       DUMTITL1+24(8),DBLWD PLACE NAME IN DUMMY TITLE STMT
         TR    DBLWD(8),TRSLTB     TRANSLATE TO EXTERNAL.
         LA        RD1,LIBRFND1        CHECK IF MACLIB READ IN PROGRESS
*
LIBWAIT  DS    0H
         L     RA,LBDECBAD+4            2ND SYSLIB  BUFFER READ
         TM    LBRDSW(RA),LBRDOT        ANY READS OUTSTANDING .Q
         BCR   8,RD1                    BRANCH IF NOT
         NI    LBRDSW(RA),255-LBRDOT    KILL OUTSTANDING READ
         WAIT  ECB=(RA)                 AWAIT COMPLETION OF ANY I/O
         L     RA,ADCBLB                ADDR OF SYSLIB DCB
         NI    DCBIFLGS-IHADCB(RA),255-X'C0'  AVOID SYNAD/EOV CHECKING
         NI    DCBOFLGS-IHADCB(RA),X'FF'-X'80'  TRK BAL NO LONGER VALID
         BR    RD1                      RETURN
*
LIBRFND1 EQU   *                        BY IOS.
         TM    SWTCH7,X'01'            COPY CODE TO BE READ .Q
         BO    INCOPY                  BIF YES--FIND ALREADY DONE.
*./      DELETE    SEQ1=39060020,SEQ2=39140020
         LA        L5,DBLWD            POINT AT NAME
         L         RA,FINDAD           CALL FIND SUBROUTINE
         BALR      RQ,RA
         BNE       SMCH4               TEST IF FOUND
         OI    SWTCH6,X'40'        IND 'MACRO' OP EXPECTED.
INCOPY   DS    0H
         L     RD1,LBDECBAD             DECB ADDR FOR 1ST SYSLIB BUFFER
*
*        NOTE AND READ FIRST SYSLIB BUFFER
         BAL   LINK,NOTREAD             READ INTO 1ST SYSLIB BUFFER
         BAL   LINK,NOTCHECK            CHECK 1ST READ
         OI    LBRDSW(RD1),LBRDRS       PROCESSING READS STARTED
         L     RA,LBRECPW(,RD1)         COMPUT END-OF BLOCK ADDR
         L     L5,LBDCBAD(,RD1)         FROM RESIDUAL LENGTH IN
         LH    L4,DCBBLKSI-IHADCB(,L5)  CSW, BLKSIZE IN DCB AND
         SH    L4,14(,RA)               BUFFER ADDRESS
         ST    L4,LBLIBEOB(,RD1)        SAVE EOB OFFSET
         SR    L4,L4                    ZERO WORK REGISTER
         ST    L4,LBLIBNTA(,RD1)        ZERO START BUFFER OFFSET
         L     RD1,LBDECBAD+4           2ND SYSLIB DECB
*
*        NOTE AND READ SECOND SYSLIB BUFFER
         BAL   LINK,NOTREAD             READ INTO 2ND SYSLIB BUFFER
         OI    LBRDSW(RD1),LBRDOT       OUTSTANDING READ
         TM    SWTCH7,X'01'             COPY CODE BEING READ .Q
         BO    DRVER                    BRANCH IF YES
         ST    RE2,SMRE2X               SAVE PTR TO N/P FIELD
         AIF       (&NOTSTAT).NEXT     BEGINNING OF STATISTICS PHASE
         MVI       CARDSW,X'00'        SET CARD SWITCH INDICATOR ON
         B         DRVER               BRANCH TO DRIVE ROUTINE
         ENTRY     CARDSW
CARDSW   DC        X'FF'               SET INITIALIZER FOR SOURCE IND.
         DS        0H                  REALIGNMENT
.NEXT    ANOP                          END OF STATISTICS OPTION
DRVER    L     LINK,VDRVER              LOAD VECTOR
         BR    LINK                      AND RETURN
SMCH3    L     RE2,SMRE2X          RELOAD POINTER.
SMCH4    CLC   NPTL(EPTL,RE2),TEMPH+4-EPTL
         BE    SMCH5               BRANCH IF AT END OF CHAIN.
         MVC   DBLWD(4),FZRO       ZERO OUT DBLWD.
         MVC   DBLWD+4-EPTL(EPTL),NPTL(RE2)
         L     RE1,DBLWD           GET RELATIVE POINTER TO NEXT ENTRY.
         B     SMCH2
SMCH5    L     RE1,MACHN                ANY NEW MACRO NAMES ADDED .Q
         CL    RE1,SVCHN
         BE    KLOSOWT             IF NOT, GET OUT.
         MVC   TEMPH,SVCHN         SAVE NEW CHAIN END INDICATOR.
         B     SMCH1
KLOSOWT  DS    0H
         L     LINK,DUSING              SUBSET
         BAL   LINK,PSBSET-ENTDCT(LINK)   PERMANENT GENERAL DICTIONARY
KLOSIT   EQU   *
         BAL       RD1,LIBWAIT         CHECK SYSLIB IF READ IN PROGRESS
         MVI   OUTPUT,X'0A'             GENERATE UT3 CLOSE OUT
         LA    OUTPTR,OUTPUT+3
         OI    SWTCH6,X'04'             SUPPRESS LOOKUP IN ENDOPR
         L     LINK,VNDOPR              LOAD VECTOR
         BALR  LINK,LINK                OUTPUT RECORD
         LH    RQ,H32767                FORCE BLOCK TO OUTPUT MEDIUM
         LA    RA,8
         BAL       RR0,BWFORC
*./      DELETE    SEQ1=40240020,SEQ2=40240020
*
*        CALL PHASE F3
*
*./      DELETE    SEQ1=40320020,SEQ2=40480020
         AIF       (&NOTSTAT).NO2
*   PRINTOUT  BEFORE  THE XCTL
         STM       7,8,SAVEREG         SAVE WORK REGISTERS
         L         7,BUMPER2           PLACE COUNTER IN REGISTER
         CVD       7,WORK              CHANGE MODE FOR PRINTING
         UNPK      WORK2(16),WORK      UNPACK FOR PRINTING
         OI        WORK2+15,X'F0'      CHANGE ZONE BIT FOR PRINTING
         MVC       YNOMACS,WORK2+11    MOVE TO THE OUTPUT AREA
         L         8,BUMPER1           GET THE EXTERNAL ADDRESS
         L         7,0(8)              LOAD EXTERNAL BUMPER
         CVD       7,WORK              CHANGE MODE FOR PRINTING
         UNPK      WORK2(16),WORK      UNPACK FOR PRINTING
         OI        WORK2+15,X'F0'      CHANGE ZONE BIT FOR PRINTING
         MVC       Z1,WORK2+11         MOVE TO OUTPUT AREA
         LM        7,8,SAVEREG         RELOAD THE WORK REGISTERS
         B         PRINTOUT            GET TO THE PRINT MACRO
SAVEREG  DS        2F                  SAVE REGISTER AREA
WORK     DS        D                   WORK AREA FOR CVD
WORK2    DS        4F                  WORK AREA FOR UNPK
PRINT    DC        C'SYSMACROS= '      START OF OUTPUT MESSAGE
YNOMACS  DS        CL5                 NO OF MACROS
         DC        C'  SOURCE CARDS IN SYSMACROS= '
Z1       DS        CL5                 NO OF SOURCE CARDS
BUMPER1  DC        V(BUMPER)
         DS        0H                  REALIGNMENT
PRINTOUT PRINTOUT  PRINT,DCB=YES,CSECT=GGECT,TYPE=STAT SYSMACRO INFO
.NO2     ANOP                          END OF STATISTICS CODE
*
*        PASS F3 THE FOLLOWING PARAMETERS IN THE REGISTERS
         L         11,NPMAIN       R11=N/P ADDR. OF SUBSETTED O.C.DICT.
         LM        1,3,GDP         R1=GDP, R2=DEND, R3=SSEG.
         L         4,BWBLKS+16+BWBUFF BOTTOM OF CORE GOTTEN FROM BUFF
         LM        5,6,INPLEN      R5=INPLEN, R6=OBSIZ.
         LM        7,8,BUFFENT     R7=BUFFENT, R8=ADLIST1.
         L         14,RETURN           RETURN ADDRESS TO ASM
         L         13,ASMSAVE          ADDRESS OF SAVE AREA IN ASM
*
*
         LA        9,L1BLDL+3*L1LENBL(8) GET ADDRESS OF F3 IN BLDL
         XCTL      ,DE=(9)            TABLE AND TRANSFER TO ASMGF3
*
*
*
SVCHN    DC    F'0'
TEMPH    DC    F'0'
SMRE2X   DS    F
SMNAMV   MVC       DBLWD(*-*),1(RE1)   EX'ED MOVE OF MACRO NAME
EPTL     EQU   2                   LENGTH OF MACRO NAME CHAIN POINTER.
         EJECT
*
*ROUTINE 'GETSRC'
*FUNCTIONS-
*   1. READS SOURCE, COPY, OR MACRO LIBRARY STATEMENTS INTO SOURCE
*      BUFFER.
*   2. SEQUENCE CHECKS, TRANSLATES, AND DOES CONTINUATION HOUSEKEEPING.
*   3. WRITES OUT SOURCE RECORDS.
*   4. BUILDS STATEMENTS IN INPUT BUFFER.
*ENTRY POINTS-
*   GTSRC- GET FIRST CARD OF A STATEMENT.
*        BAL   LINK,GETSRC
*        DC    AL2(0)
*   GTSRC1- GET ALL CONTINUATION CARDS.
*        BAL   LINK,GETSRC
*        DC    AL2(2)
*   GTSRC2- GET ONE CONTINUATION, WITH NO CHECK ON NUMBER OF CONTINU-
*           ATIONS (FOR MACRO INSTRUCTIONS).
*        BAL   LINK,GETSRC
*        DC    AL2(4)
*   GTSRC4- SKIP ALL CONTINUATION CARDS.
*        BAL   LINK,GETSRC
*        DC    AL2(6)
*   GTSRC5- GET ONE CARD, WITH NO SEQUENCE CHECK (FOR REPRO).
*./      DELETE    SEQ1=41880020,SEQ2=41880020
*        BAL   LINK,GETSRC
*        DC    AL2(8)
*
*
*                                       *******************************
*                                       * REGISTER DEFINITIONS        *
*                                       *******************************
WRKREG   EQU   2                        WORK REGISTER
SEQLTH   EQU   4                        SEQUENCE FIELD LENGTH MINUS ONE
LINKRR   EQU   SEQLTH                   FOR INTERNAL LINKAGE
WRKRG1   EQU   LINKRR
SEQPTR   EQU   5                        START OF SEQUENCE FIELD
ADJUST   EQU   6                        SOURCE BUFFER START
CNTCOL   EQU   7                        CONTINUATION CHARACTER COLUMN
SRCADR   EQU   8                        BEGIN OR CONTINUE COLUMN
INCRMN   EQU   9                        LENGTH OF SOURE MINUS ONE-
*                                         =END COL-BEG COL FOR FIRST,
*                                         =END COL-CONT COL FOR CONT.
TXTOUT   EQU   10                       INPUT BUFFER-1, OR LAST CHAR
*                                         PUT IN INPUT BUFFER
*                                       *******************************
*                                       * MAINLINE CODE               *
*                                       *******************************
*
*
*
*        INITIALIZE FOR FIRST CARD OF A STATEMENT.
*
GETSRC   STM   RQ,L5,SAVREG
         L     B2,DCLOS1AD              SET BASE REGISTER.
         LH    RA,0(0,LINK)             DEVELOP BRANCH ADDRESS
         LH    WORK1,JUMP(RA)           FOR PROPER ENTRY
         B     GETSRC(WORK1)            INTO GET TEXT ROUTINE
JUMP     DC    AL2(GTSRC-GETSRC)        GET FIRST CARD
         DC    AL2(GTSRC1-GETSRC)       GET ALL CONTINUATION CARDS
         DC    AL2(GTSRC2-GETSRC)       GET A SINGLE CONTINUATION CARD
         DC    AL2(GTSRC4-GETSRC)       BYPASS ANY CONTINUATION CARDS
         DC    AL2(GTSRC5-GETSRC)       GET ONE CARD
GTSRC    NI    SWTCH4,X'FC'
         NI    SWTCH4,NMK012            RESET LAST STATEMENT MASKS
         OI    SWTCH6,8                 SET FIRST CARD SWITCH
         LA    RA,8                     ENSURE SPACE ON UT3 BLOCK
         LA    RQ,84
         BAL   RR0,BWFORC
         LM    SEQLTH,TXTOUT,SEQLEN     LOAD REGISTERS WITH CONSTANTS
         MVI   ADDCNT,X'00'             RESET NO. OF LINES COUNTER
         B     CLSDRD              BRANCH TO READ.
*
*        SET ENTRY POINT INDICATORS.
*
GTSRC4   OI    SWTCH3,MASK34
GTSRC2   OI    SWTCH3,MASK2
GTSRC1   OI    SWTCH3,MASK1
*
*        RETURN IF PREVIOUS CARD SHOWED NO CONTINUATION.
*
         TM    SWTCH4,MASK2
         BZ    ZXIT
GTSRC5   OI    SWTCH3,MASK0
MAINLN   LA    RA,8
         LA    RQ,84
         BAL   RR0,BWFORC               ENSURE SPACE ON UT3 BLOCK.
*
*        INITIALIZE FOR CONTINUATION CARD.
*
         LM    SEQLTH,CNTCOL,SEQLEN
         LM    SRCADR,TXTOUT,BEGCNT     ''
*
*        READ ONE CARD INTO SOURCE BUFFER.
*
CLSDRD   EQU   *
         CLI   TYPRED+1,MACLIB          IS READ FROM MACLIB.
         BE    LIBREAD                  BRANCH IF YES
         LA        RQ,NMBFLG(0,ADJUST) ADDRESS OF READIN AREA
         L     RA,ADCBIN                ADDRESS OF SYSIN DCB
         ST        RQ,PARA
*./      DELETE    SEQ1=43420020,SEQ2=43420020
         GET   (1),(0)                  DO READ
         L         RA,ADCBIN            SYSIN DCB FOR RECORD COUNT
LIBRETRN EQU   *                        MACLIB READ RETURN POINT.
         IC    WRKREG,ADDCNT            INCREMENT LINE COUNT
         LA    WRKREG,1(0,WRKREG)       ''
         STC   WRKREG,ADDCNT            ''
         L     WRKREG,L1DCBRCT(,RA)     GET CURRENT RECORD COUNT
         A     WRKREG,F1                BUMP COUNT BY ONE
         ST    WRKREG,L1DCBRCT(,RA)     RESTORE NEW RECORD COUNT
         TM    SWTCH3,MASK01
         BM    TRNSLT                   IF GTSRC5
*
*        CHECK CONTINUATION COLUMN.
*
         TM    SWTCH1,MASK4             SKIP IF ICTL DOES NOT
         BZ    SEQNCE                     ALLOW CONTINUATIONS
         LA    WRKREG,NBFLM1(ADJUST,CNTCOL)
         CLI   0(WRKREG),ABLANK         CONTINUATION CHECK
         BE    SEQNCE                   BRANCH IF NOT CONTINUED
         OI    SWTCH4,MASK1             SET NEW CONTINUATION BIT
*
*        SEQUENCE CHECK.
*
SEQNCE   DS    0H
         LA    SEQPTR,NBFLM1(SEQPTR,ADJUST)  POINT TO SEQUENCE NUMBER
         TM    SWTCH1,MASK0             TEST IF SEQUENCE CHECK
         BZ    TRNSLT                   BRANCH IF NO SEQUENCE CHECK
         EX    SEQLTH,CMPFLD            SEQUENCE CHECK
         BH    SEQSAVE                  BRANCH IF SEQUENCE O.K.
         OI    SWTCH7,X'04'             SET ERROR INDICATOR
SEQSAVE  DS    0H
         EX    SEQLTH,SAVSEQ            SAVE NEW SEQUENCE VALUE
*
*        TRANSLATE TO INTERNAL ASSEMBLER CODE.
*
TRNSLT   TR        NMBFLG(80,ADJUST),TRSLTB  TRANSLATE SOURCE
         TM    SWTCH3,MASK01            WAS ENTRY POINT GTSRC5 .Q
         BM    PUTIN3                   BIF YES
         BAL   LINKRR,WRTAPER      GO WRITE OUT SOURCE.
         TM    SWTCH7,X'04'             SEQUENCE ERROR INDICATOR
         BZ    NOSEQR                   NO ERROR
         MVC       SWTCH7S1+1(1),SWTCH7 SAVE SWTCH7
         NI        SWTCH7,X'7F'        TURN OFF SUBLIST SWITCH
         L     LINK,VWRNER              SEQUENCE ERROR MESSAGE
         BALR  LINK,LINK
         DC    AL1(ERRR35)
         DC    AL1(WRNST)
SWTCH7S1 MVI       SWTCH7,*-*          RESTORE SWTCH7
         NI    SWTCH7,X'FB'        RESET SEQ ERR IND.
NOSEQR   EQU   *
         TM    SWTCH4,MASK2             TEST IF LAST CARD A CONTINUE
         BZ    SETUP                    BRANCH NO
         NI    SWTCH4,NMASK2            RESET PREVIOUS CONTINUE INDIC
*
*        CHECK THAT NAME AND OPERATION FIELDS ARE BLANK.
*
         LA    WRKRG1,NBFLM1(ADJUST,SRCADR) CONTINUE COLUMN
         L     WRKREG,BEGCOL
         LA    WRKREG,NBFLM1-1(ADJUST,WRKREG)  BEGIN COL MINUS ONE
*              CHECK BEGIN TO CONTINUE COLUMNS FOR BLANK.
BLNCHK   LA    WRKREG,1(0,WRKREG)       ''
         CR    WRKRG1,WRKREG            ''
         BE    SETUP                    ''
         CLI   0(WRKREG),BLANK          ''
         BE    BLNCHK                   ''
         MVC       SWTCH7S2+1(1),SWTCH7 SAVE SWTCH7
         NI        SWTCH7,X'7F'        TURN OFF SUBLIST SWITCH
         L     LINK,VWRNER              BAD CONTINUATION ERROR MESSAGE
         BALR      LINK,LINK
         DC    AL1(ERRR36)
         DC    AL1(WRNST)
SWTCH7S2 MVI       SWTCH7,*-*          RESTORE SWTCH7
SETUP    EQU   *
         BAL   LINKRR,ERRORS       CHECK NBR OF CONT CARDS.
*
*        IF GTSRC4 ENTRY, GO GET THE FOLLOWING CONTINUATION.
*
         TM    SWTCH3,MASK4             TEST GETSRC ENTRY POINT
         BZ    PUTIN2                   SKIP IF NOT GTSRC4
*
         TM    SWTCH4,MASK1             TEST IF CONTINUATION TO FOLLOW
         BZ    AXIT                     BR IF NOT
*        PREPARE FOR NEXT CARD BY CLEARING CONTINUE INDICATOR FOR
*        CURRENT CARD AND SETTING CONTINUATION EXPECTED INDICATOR.
         OI    SWTCH4,MASK2
         NI    SWTCH4,NMASK1
         B     MAINLN                   BRANCH TO READ COMPLETION OF ST
PUTIN2   TM    SWTCH4,MASK1
         BZ    PTTIN2
         NI    SWTCH4,NMASK1
         OI    SWTCH4,MASK2
*
*        MOVE CARD TO START OF INPUT BUFFER IF  GTSRC. MOVE OPERAND
*        FIELD TO NEXT SPACE IN INPUT BUFFER IF GTSRC1 OR GTSRC2.
*        DIFFERENCE IS DETERMINED BY CONTENTS OF REGISTERS SRCADR,
*        INCRMN, AND TXTOUT. (NOT USED BY GTSRC4 OR GTSRC5.)
*
PTTIN2   LA    WRKREG,NBFLM1(SRCADR,ADJUST)  LOC OF SOURCE FIELD
         LA    LINKRR,1(INCRMN,TXTOUT)  SAVE ADDRESS OF LAST PUT CHARAC
         EX    INCRMN,MVTOUT            EXECUTE MOVE TO INPUT BUFFER
         ST    LINKRR,ENDCOL            UPDATE INPUT BUFFER POINTER
         MVI   1(LINKRR),X'FF'          END-OF-STATEMENT CODE
*
*        IF GTSRC1, LOOP TO GTSRC1 . EXIT OTHERWISE.
AXIT     EQU   *
         TM    SWTCH3,MASK12            TEST IF GTSRC1
         BM    GTSRC1                   BRANCH YES
ZXIT     NI    SWTCH3,NMKALL            RESET ENTRY INDICATOR BIT
         LM    RQ,L5,SAVREG             RESTORE REGISTERS
         B     2(0,LINK)                RETURN TO CALLER
*
*        MOVE CARD TO INPUT BUFFER FOR GTSRC5.
*
PUTIN3   MVC   1(80,TXTOUT),NMBFLG(ADJUST)
         TM    SWTCH5,128
         BZ    AXIT                    EXIT IF NOT PROGRAMMER MACRO
         OI    SWTCH6,8                ELSE WRITE SOURCE
         BAL   LINKRR,WRTAPE
         B     AXIT
DUMTITLE DC        X'08005400',9X'32',X'1D121D150E323232323231',8X'29',X
               X'31',51X'32'
DUMTITL1 DC        X'00002740801800000000FD00F8FD051D121D150EF8FD0B31',X
               8X'29',X'3132F8FD00F8FF'
*
CMPFLD   CLC   0(0,SEQPTR),SEQVAL       OUT OF LINE SEQUENCE COMPARE
SAVSEQ   MVC   SEQVAL(0),0(SEQPTR)      OUT OF LINE SAVE SEQUENCE VALUE
MVTOUT   MVC   1(0,TXTOUT),0(WRKREG)    OUT OF LINE MOVE TO INPUT
*                                       *******************************
*                                       *******************************
*
*        CHECK IF MORE THAN 3 CARDS IN STATEMENT.
*
ERRORS   TM    SWTCH3,MASK2             TEST GETSRC ENTRY POINT
         BCR   1,LINKRR                 SKIP IF GTSRC2 OR GTSRC4 ENTRY
         CLI   ADDCNT,4                 CHECK COUNT
         BCR   4,LINKRR                 BR IF LESS THAN 4
         L     LINK,VWRNER              LOAD VECTOR
         BALR  LINK,LINK                TOO MANY CONTINUATIONS ERR MSG
         DC    AL1(ERRR37)
         DC    AL1(WRNST)
         OI    SWTCH3,X'78'             SIMULATE GTSRC4 ENTRY TO SKIP
*                                         ANY MORE CONTINUES
         BR    LINKRR
*
INEND    DC        X'0E170D'           'END' IN INTERNAL CODE
*
*        WRITE OUT SOURCE RECORDS.
*
WRTAPER  MVC   0(NMBFLG,ADJUST),SRCFLG  INITIALIZE SOURCE HEADER BYTES
         TM    SWTCH3,MASK7             WERE ANY ERRORS FOUND .Q
         BZ    SUTUP                    BIF NO
         OI    3(ADJUST),MASK5          SET ERROR RECORD FLAG
         TM    SWTCH4,MASK0             WERE COMMENTS CONTINUED .Q
         BO    SUTUP                    BIF YES
         OI    3(ADJUST),MASK3          SET RECORD TYPE AS ERROR
SUTUP    TM    SWTCH4,MASK2             IS THIS A CONTINUATION CARD .Q
         BZ    WRTAPE                   BIF NO
         OI    3(ADJUST),MASK6          SET CONTINUATION CARD FLAG
WRTAPE   DS        0H
         LA        RA,8                WRITE ON UT3
         TM        PARBYT1,FLIST       WAS FULLLIST SPECIFIED .Q
         BZ        REWTEST             BRANCH IF OFF
         TM        SWTCH6,X'40'        TEST IF THIS FIRST CARD
         BZ        REWRTP
*        OUTPUT A TITLE STATEMENT TO PREFIX THE MACRO
         LA        RQ,84+39            LENGTH OF SOURCE & INTERNAL RECS
         BAL       RR0,BWFORC
         LA        RQ,DUMTITLE         ADDR OF RECORDS
         BAL       RR0,BWRITE
         B         REWRTP              GO OUTPUT LINE
REWTEST  TM    SWTCH5,X'C0'             TEST FOR MAINLINE OR SYSTEM
         BZ    NOSYSM                      MACROS
REWRTP   LA    RQ,84                    SOURCE LENGTH IS 84
         BAL   RR0,BWFORC               ASSURE FIT INTO OUTPUT BLOCK
         TM    SWTCH5,64                BRANCH IF NOT MAINLINE
         BZ    REWRT1
         TM    SWTCH6,8                   OR IF NOT FIRST CARD
         BZ    REWRT1
         LA        RR0,0(RA,RA)         OTHERWISE PICK UP NOTE
         LA        RR0,BWBLKS(RR0)
         MVC       STNOTE(6),BWFNOT(RR0) AND SAVE
REWRT1   LR    RQ,ADJUST
         BAL   RR0,BWRITE
NOSYSM   NI    SWTCH6,247               CLEAR FIRST CARD SWITCH
         TM    SWTCH6,1                 IS THIS A NORMAL COMMENT WITHIN
         BZ    NOWRIT                      A MACRO
         NI    SWTCH6,X'FE'
         TM    SWTCH1,MASK1             ARE WE WITHIN A MACRO
         BZ    NOWRIT
         SR    RA,RA                    YES- WRITE ON SYSUT1 TOO
         B     REWRTP
NOWRIT   BR    LINKRR
         EJECT
*        CODE TO READ MACLIB/COPYLIB DOUBLE BUFFERED ALL THE WAY
*
LIBREAD  DS    0H
         STM   RE1,RD1,FINDSAVE         SAVE SOME WORK REGISTERS
         L     RE1,LBDECBAD             GET CURRENT SYSLIB DECB
         TM    LBRDSW(RE1),LBRDOT       OUTSTANDING READ .Q
         BZ    LIBRRDE2                 BRANCH IF NOT
         NI    LBRDSW(RE1),255-LBRDOT   TURN OFF READ OUTSTANDING
         LR    RD1,RE1                  DECB ADDRESS
         BAL   LINK,NOTCHECK            CHECK THE READ
         OI    LBRDSW(RE1),LBRDRS       PROCESSING READS STARTED
         L     RD1,LBRECPW(,RE1)        COMPUT END-OF-BLOCK ADDRESS
         L     RA,LBDCBAD(,RE1)         FROM RESIDUAL LENGTH IN
         LH    L4,DCBBLKSI-IHADCB(,RA)  CSW, BLKSIZE FROM DCB
         SH    L4,14(,RD1)              AND BUFFER ADDRESS
         ST    L4,LBLIBEOB(,RE1)        SAVE EOB OFFSET
         SR    L4,L4                    ZERO WORK REGISTER
         ST    L4,LBLIBNTA(,RE1)        ZERO START BUFFER OFFSET
LIBRRDE2 DS    0H
         L     RA,LBLIBNTA(,RE1)        MOVE LOGICAL RECORD TO WKAREA
         CL    RA,LBLIBEOB(,RE1)        TEST FOR END-OF-BLOCK
         BNL   CHECKEM                  END-OF-BLOCK, GET ANOTHER
         L     L4,LBAREAAD(,RE1)        GET START OF BUFFER ADDRESS
         AR    L4,RA                    PLUS BUFFER OFFSET
         MVC   NMBFLG(80,ADJUST),0(L4)  OK - TRANSFER ONE RECORD
         LA    RA,80(,RA)               UPDATE RECORD OFFSET
         ST    RA,LBLIBNTA(,RE1)        SAVE IT FOR LATER
         B     LIBRRDE3                 BRANCH TO RETURN
CHECKEM  DS    0H
         LR    RD1,RE1                  1ST SYSLIB DECB
         L     RE1,LBDECBAD+4           2ND SYSLIB DECB
         STM   RE1,RD1,LBDECBAD         SWITCH DECB POINTERS
         NI    LBRDSW(RE1),255-LBRDOT   TURN OFF OUTSTANDING READ
         LR    RD1,RE1                  DECB ADDR
         BAL   LINK,NOTCHECK            CHECK THE READ
         OI    LBRDSW(RE1),LBRDRS       PROCESSING READS STARTED
         L     RD1,LBRECPW(,RE1)        COMPUTE END-OF-BLOCK ADDRESS
         L     RA,LBDCBAD(,RE1)         FROM RESIDUAL LENGTH IN
         LH    L4,DCBBLKSI-IHADCB(,RA)  CSW, BLKSIZE FROM DCB
         SH    L4,14(,RD1)              AND BUFFER ADDRESS
         ST    L4,LBLIBEOB(,RE1)        SAVE EOB OFFSET
         SR    L4,L4                    ZERO WORK REGISTER
         ST    L4,LBLIBNTA(,RE1)        ZERO START BUFFER OFFSET
         L     RD1,LBDECBAD+4           2ND SYSLIB DECB ADDRESS
         OI    LBRDSW(RD1),LBRDOT       OUTSTANDING READ
*
*        NOTE AND READ NEXT BUFFER
         BAL   LINK,NOTREAD             START NEXT READ
         B     LIBRRDE2                 PEEL OFF NEXT RECORD
LIBRRDE3 DS    0H
         L     RA,LBDCBAD(,RE1)         SYSLIB DCB FOR RECORD COUNT
         LM    RE1,RD1,FINDSAVE         RESTORE WORK REGISTERS
         B     LIBRETRN                 AND RETURN
*./      DELETE    SEQ1=47680020,SEQ2=48000020
         EJECT
*./      DELETE    SEQ1=48040020,SEQ2=48080020
EOFIN    OI        SWTCH7,X'02'        SET ERROR IND.
         MVI       SWTCH4,X'00'        CLEANUP
         NI        SWTCH5,X'C1'        CLEANUP, PROG MACRO OR O.C. KEPT
         L     WORKRG,PARA         GET INPUT BUFFER  ADDRESS.
         MVI       0(WORKRG),X'32'     SET TO BLANKS
         MVC   1(79,WORKRG),0(WORKRG)
         A     WORKRG,BEGCOL            COMPUTE START OF OP-FIELD
         MVC       0(3,WORKRG),INEND   MOVE IN END OPERATION
*./      DELETE    SEQ1=48220020,SEQ2=48300020
         MVC       1(80,TXTOUT),NMBFLG(ADJUST) MOVE TO INPUT BUFFER
         B         ZXIT
*
*
LIBCHK   DS    0H
         STM   LINK,RD1,FINDSAVE        SAVE WORK REGISTERS
         L     RE1,LBDECBAD+4           2ND SYSLIB DECB
         L     RD1,LBDECBAD             1ST SYSLIB DECB
         STM   RE1,RD1,LBDECBAD         SWITCH DECB POINTERS
         LR    RD1,RE1                  THIS ONE HAS A READ
         NI    LBRDSW(RD1),255-LBRDOT   TURN OFF OUTSTANDING READ
         BAL   LINK,NOTCHECK            CHECK THE READ
         OI    LBRDSW(RD1),LBRDRS       PROCESSING READS STARTED
         LM    LINK,RD1,FINDSAVE        RESTORE WORK REGISTERS
         BR    LINK                     AND RETURN
*./      DELETE    SEQ1=48600020,SEQ2=48700020
*
*
EOFLIB   DS    0H
         LM    RQ,L5,SAVREG             RELOAD REGS AS IF EXIT FROM
         L     B2,DCLOS1AD              GETSRC, AND RESTORE BASE
         XI    SWTCH4,MASK5             RESET SWITCH FOR GETSRC PROCBUF
         L     RA,CPCUR                 GET CURRENT NESTING LEVEL
         LTR   RA,RA                    ALREADY NEGATIVE .Q
         BM    NOTCOP                   YES, EOF IN MACRO
         S     RA,CPLEN                 LESS ONE LEVEL
         ST    RA,CPCUR                 UPDATE NEW LEVEL
         BP    EOFLIBA                  BRANCH IF NESTED COPY
         BM    EOFLIBB                  BRANCH IF END OF NESTED COPY
         TM    SWTCH5,X'20'             IN SYSTEM MACRO .Q
         BZ    EOFLIBA                  BRANCH IF NOT, STILL COPY
         LR    RQ,RA                    TRANSFER CURRENT LEVEL
         S     RQ,CPLEN                 DOWN TO SYSTEM MACRO
         ST    RQ,CPCUR                 SET INITIAL CURRENT LEVEL
EOFLIBB  DS    0H
         NI    SWTCH1,X'50'             KEEP MACRO AND PROT SWITCH
         NI    SWTCH1X,255-X'50'        DESTROY MACRO AND PROT SWITCH
         OC    SWTCH1(1),SWTCH1X        RESET SWITCH1
         NI    SWTCH7,X'FE'             RESET COPY SWITCH
         MVC   TYPRED+1(1),INFILS  RESET INPUT FILE NBR.
         MVC   SEQLEN(40),COPYSV   RESET GTSRC PARAMS.
         L     RQ,BEGCOL                ENDCOLUMN=BEGIN COLUMN
         A     RQ,SRCLEN                $ PLUS SOURCE LENGTH
         ST    RQ,ECOL                  RESTORE END COLUMN
         TM    SWTCH5,X'20'             WITHIN A SYSTEM MACRO .Q
         BZ    DRVER                    RETURN IF NOT
*
*        WITHIN SYSTEM MACRO OR NESTED COPY, POINT TO PREVIOUS
*
EOFLIBA  DS    0H
         STM   RE1,RD1,FINDSAVE         SAVE WORK REGS
         L     RD1,LBDECBAD             1ST SYSLIB DECB POINTER
         LA    RA,CPWORK(RA)            POINT TO SAVED DATA
         MVC   MACNAME,CPCPNAME(RA)     RESTORE CALLER MEMBER NAME
         MVC   LBLIBNOT(LBRDSW-LBLIBNOT,RD1),CPLIBNOT(RA)  DECB SUFIX
         L     RE1,LBDCBAD(,RD1)        SYSLIB DCB ADDRESS
         TM    PARBYT3,CMS            CMS OPTION ON .Q
         BZ    EOFLIBC                BRANCH IF NOT
         LA    L5,DBLWD                 MACRO NAME GOES HERE
         MVC   0(8,L5),MACNAME          MACRO NAME IN INTERNAL
         TR    0(8,L5),TRSLTB           EXTERNAL FORM
         L     RA,FINDAD                FIND SUBROUTINE ADDRESS
         BALR  RQ,RA                    CALL FIND SUBROUTINE
         POINT (RE1),LBLIBNOT(RD1)      AND A POINT
         B     EOFLIBD                AND CONTINUE
*        POINT WOULD HAVE RESTORED FDAD IN DCB
EOFLIBC  DS    0H
         MVC   DCBFDAD-IHADCB(8,RE1),LBLIBNOT(RD1)  RESET DCB FDAD
         NI    DCBOFLGS-IHADCB(RE1),X'FF'-X'80' TRK BAL NO LONGER VALID
         NI    DCBIFLGS-IHADCB(RE1),X'FF'-X'C0' AVOID SYNAD/EOV CHECK
         NI    DCBCIND1-IHADCB(RE1),X'FF'-X'20' VOLUME FULL BIT
         L     RA,DCBIOBA-IHADCB(,RE1)  SYSLIB IOB ADDRESS
*        AND POINT WOULD HAVE RESTORED FDAD IN IOB
         MVC   IOBSEEK+8(8,RA),LBLIBNOT(RD1)  RESET IOB SEEK ADDRESS
EOFLIBD  DS    0H
         NI    LBRDSW(RD1),255-LBRDRS-LBRDOT  KILL READ SWITCHES
         BAL   LINK,NOTREAD             READ INTO 1ST SYSLIB BUFFER
         BAL   LINK,NOTCHECK            CHECK 1ST READ
         OI    LBRDSW(RD1),LBRDRS       PROCESSING READS STARTED
         L     RD1,LBDECBAD+4           2ND SYSLIB DECB
         NI    LBRDSW(RD1),255-LBRDRS-LBRDOT  KILL READ SWITCHES
         BAL   LINK,NOTREAD             READ INTO 2ND SYSLIB BUFFER
         OI    LBRDSW(RD1),LBRDOT       OUTSTANDING READ
         LM    RE1,RD1,FINDSAVE         RESTORE CALLER'S REGS
         B     DRVER                    AND CONTINUE
*
NOTCOP   EQU   *
         L     LINK,VWRNER              LOAD VECTOR
         BALR  LINK,LINK           OUTPUT ERROR RECORD AND GO TO DRIVER
         DC    AL1(ERRR38)
         DC    AL1(ERRST)
         TM    SWTCH6,X'40'             TEST IF MACRO OP EXPECTED
         BO    SMCH3                    MACRO MEMBER IS EMPTY
         L     LINK,VMEND1              LOAD VECTOR
         BR    LINK                     AND BRANCH.
LREG     EQU   WRKREG
VMEND1   DC    V(MEND1)
VWRNER   DC    V(WRNERR)
VSWICL   DC    V(SWICTL)
VNDOPR   DC    V(NDOPR0)
VDRVER   DC    V(DRIVER)
         SPACE 2
*
*        NOTE AND READ SYSLIB DATASET
*
*        (RD1) DECB ADDRESS
*        (LINK) RETURN ADDRESS
NOTREAD  DS    0H
         L     RA,LBDCBAD(,RD1)       SYSLIB DCB ADDRESS
         TM    PARBYT3,CMS            CMS OPTION ON .Q
         BO    NOTREAD1               BRANCH TO READ IF YES
         MVC   LBLIBNOT(8,RD1),DCBFDAD-IHADCB(RA)  SAVE DCB FDAD
NOTREAD1 DS    0H
         XC    0(4,RD1),0(RD1)
         READ  (RD1),SF,MF=E          READ INTO BUFFER
         BR    LINK                   AND RETURN
         SPACE 2
*
*        CHECK AND NOTE SYSLIB DATASET
*
*        (RD1) DECB ADDRESS
*        (LINK) RETURN ADDRESS
NOTCHECK DS    0H
         CHECK (RD1)                  CHECK OUTSTANDING READ
         TM    PARBYT3,CMS            CMS OPTION ON .Q
         BCR   8,LINK                 RETURN NOW IF NOT
         L     RA,LBDCBAD(,RD1)         SYSLIB DCB ADDRESS
         NOTE  (1)                    WHERE WERE WE .Q
         ST    RA,LBLIBNOT(,RD1)      SAVE TTRN INFO
         BR    LINK                   AND RETURN
         EJECT
*ROUTINES 'BWFORC' AND 'BWRITE'
*FUNCTION/OPERATION-
*    UT1 AND UT3 BLOCKED TEXT WRITE PACKAGE FOR SOURCE, EDITED, AND
*    ERROR RECORDS.
*
*    BWFORC CHECKS IF BUFFER HAS ROOM FOR NEXT RECORD. IF YES, RETURN.
*    IF NO, WRITES, CHECKS, AND NOTES BLOCK FROM BUFFER.
*    CALL TO BWFORC MUST PRECEDE EACH CALL TO BWRITE.
*
*    BWRITE TRANSFERS NEXT RECORD TO BUFFER, THEN GOES TO BWFORC.
*    IF RECORD FILLS BUFFER, BWFORC WILL WRITE IT.
*
*./      DELETE    SEQ1=49940020,SEQ2=49940020
*
*ENTRY POINTS-
*   BWFORC-   L     RQ,LENGTH           RECORD LENGTH
*             L     RA,FILENO           FILE NUMBER- 0=SYSUT1, 8=SYSUT3
*             BAL   RR0,BWFORC
*
*   BWRITE-   LA    RQ,RECORD           RECORD ADDRESS
*             L     RA,FILENO           FILE NUMBER
*             BAL   RR0,BWRITE
*
*./      DELETE    SEQ1=50160020,SEQ2=50180020
*
RR0      EQU   5                        LINK REGISTER
RR1      EQU   8                        POINTER TO FILE BLOCKS BWBLKS
RR2      EQU   9                        'FROM' POINTER FOR RECORD MOVE
RR3      EQU   10                       'TO' POINTER FOR RECORD MOVE
RR4      EQU   14                       LENGTH COUNTER FOR RECORD MOVE
*./      DELETE    SEQ1=50320020,SEQ2=50380020
*./      DELETE    SEQ1=50400022,SEQ2=50440022
*
BWFVAL   EQU   20                       FORCE VALUE AFTER BWRITE ENTRY
EOBFLG   EQU   254                      END-OF-BUFFER FLAG
BWFORC   STM   RR1,L5,BWSAVE            SAVE REGISTERS
         L     B2,DCLOS1AD              SET BASE REGISTER
         LA    RR1,0(RA,RA)             POINT RR1 TO BWBLKS FOR SYSUT1,
         LA    RR1,BWBLKS(RR1)            OR BWBLKS+16 FOR SYSUT3
         STH   RQ,BWRLTH(0,RR1)
*./      DELETE    SEQ1=50620020,SEQ2=50640020
BW05     AH    RQ,BWNDEX(0,RR1)         EXIT IF RECORD WILL FIT IN
         CH    RQ,BWBFSZ(0,RR1)           CURRENT BLOCK
         BL    BW010
*./      DELETE    SEQ1=50720020,SEQ2=50740020
         LH        RQ,BWNDEX(0,RR1)    ADD 1 TO COVER EOB FLAG
         A         RQ,F1               ADD THE ONE
         ST        RQ,WRLEN2           SET LENGTH
         ST        RA,WRUT2            SET UTILITY NUMBER
         ST        RA,CKUT2
         ST        RA,NTUT2
         L         L5,BWBUFF(0,RR1)    SET ADDRESS
         ST        L5,WRADD2
         MVC       0(4,L5),BWFNOT(RR1) SET N/P AT START OF BUFFER
         L         RA,BUFFENT          DO A WRITE
         CNOP      2,4
         BALR      RQ,RA
         DC        F'8'
WRUT2    DC        F'0'
WRADD2   DC        F'0'
WRLEN2   DC        F'0'
         L         RA,BUFFENT          DO A CHECK
         CNOP      2,4
         BALR      RQ,RA
         DC        F'28'
CKUT2    DC        F'0'
         L         RA,BUFFENT          DO A NOTE
         CNOP      2,4
         BALR      RQ,RA
         DC        F'20'
NTUT2    DC        F'0'
NTNP2    DC        F'0'
         MVC       BWFNOT(4,RR1),NTNP2 SAVE NOTE
         MVC       BWNDEX(2,RR1),H5    SET CURRENT BUFFER POSITION = 5
         L         RA,WRUT2            RESTORE RA
BW010    LM        RR1,L5,BWSAVE       RESTORE REGISTERS AND EXIT
         BR        RR0
         SPACE     2
BWRITE   STM   RR1,L5,BWSAVE            SAVE REGISTERS
         L     B2,DCLOS1AD              SET BASE REGISTER
         LR    RR2,RQ                   SAVE RECORD ADDRESS
*./      DELETE    SEQ1=51060020,SEQ2=51060020
         LA    RR1,0(RA,RA)             POINT RR1 TO BWBLKS FOR SYSUT1,
         LA    RR1,BWBLKS(RR1)            OR BWBLKS+16 FOR SYSUT3
*./      DELETE    SEQ1=51120020,SEQ2=51480020
         LH    L5,BWNDEX(0,RR1)
         L     RR3,BWBUFF(0,RR1)
         AR    RR3,L5                   ...ABSOLUTE BUFFER POSITION
         LH    RR4,BWRLTH(0,RR1)        LENGTH FROM PREVIOUS BWFORC
         AR    L5,RR4
         STH   L5,BWNDEX(0,RR1)         ...UPDATED BUFFER INDEX
         LA    L5,0(RR3,RR4)
         MVI   0(L5),EOBFLG             ...MOVE EOB FLAG AFTER RECORD
         B     BW035
BW030    MVC   0(256,RR3),0(RR2)        MOVE 256 BYTES AND UPDATE
         LA    RR2,256(0,RR2)             POINTERS
         LA    RR3,256(0,RR3)
BW035    SH    RR4,H256                 TEST IF A 256 BYTE MOVE CAN
         BH    BW030                      BE PERFORMED, AND DO IT
         LA    RR4,255(0,RR4)           NO -SO JUST MOVE WHAT'S LEFT
         EX    RR4,BW050
*./      DELETE    SEQ1=51820020,SEQ2=51820020
         LA    RQ,BWFVAL                EXECUTE BWFORC
         B     BW05
*./      DELETE    SEQ1=51880020,SEQ2=51940020
BW050    MVC   0(1,RR3),0(RR2)          OUT-OF-LINE
         LTORG
*                                       *******************************
*                                       * EQUATES                     *
*                                       *******************************
PUTFLG   EQU   X'FD'
NULL     EQU   X'00'
ONE      EQU   X'01'
MASK16   EQU   X'42'
MASKFA   EQU   X'FA'
MASKFB   EQU   X'FB'
MASKFF   EQU   X'FF'
MSK067   EQU   X'83'
MSK136   EQU   X'52'
MSK146   EQU   X'4A'
MK1467   EQU   X'4B'
N01234   EQU   X'07'
*./      DELETE    SEQ1=52300020,SEQ2=52300020
ZERO     EQU   X'00'                    CONSTANT ZERO
*./      DELETE    SEQ1=52340020,SEQ2=52340020
DIFFNC   EQU   X'54'                    BUFER ONE TO BUFFER 2WO  LENGTH
ABLANK   EQU   X'40'                    INPUT BLANK
*./      DELETE    SEQ1=52400020,SEQ2=52420020
MASK0    EQU   X'80'
MASK1    EQU   X'40'
MASK2    EQU   X'20'
MASK3    EQU   X'10'
MASK4    EQU   X'08'
MASK5    EQU   X'04'
MASK6    EQU   X'02'
MASK7    EQU   X'01'
MASK01   EQU   X'C0'
MASK02   EQU   X'A0'
MASK12   EQU   X'60'
MASK13   EQU   X'50'
MASK34   EQU   X'18'
MASK45   EQU   X'0C'
MASK67   EQU   X'03'
MSK012   EQU   X'E0'
MSK123   EQU   X'70'
MK0123   EQU   X'F0'
NMASK0   EQU   X'7F'
NMASK1   EQU   X'BF'
NMASK2   EQU   X'DF'
NMASK3   EQU   X'EF'
NMASK4   EQU   X'F7'
NMASK5   EQU   X'FB'
NMASK6   EQU   X'FD'
NMASK7   EQU   X'FE'
NMSK67   EQU   X'FC'
NMK012   EQU   X'1F'
NMK123   EQU   X'8F'
NMKALL   EQU   X'00'
NM0123   EQU   X'0F'
TWTYFR   EQU   X'18'                    TWENTY-FOUR
FIFTY4   EQU   X'54'
INPTR    EQU   INPTRS
OPTR     EQU   OUTPTR
F2AEND   DC        0D'0'               ALIGN END OF ASMGF2A
         EJECT
         COMMON    PHASE=ASMGF2A
*./      DELETE    SEQ1=53180020,SEQ2=62600020
         EJECT
IOBSEEK  EQU   32                      IOB SEEK ADDRESS DISPLACEMENT
         DCBD  DSORG=PS
         END       ASMGF2A
./ ADD NAME=ASMGF3
F3       TITLE     'ASMG     MACRO GENERATOR GENERATION PHASE'
         ISEQ      73,78
*TITLE   'ASMGF3'.. MACRO GENERATION                                  *
*FUNCTION/OPERATION                                                   *
*  ASMGF3 EVALUATES CONDITIONAL ASSEMBLY EXPRESSIONS,PERFORMS         *
*   CONDITIONAL ASSEMBLY STATEMENTS AND GENERATES ASSEMBLER EDITED    *
*   TEXT USING MACRO DEFINITIONS AND THE ASSOCIATED EDITED            *
*   INFORMATION IN THE GLOBAL AND RELATED LOCAL DICTIONARIES.         *
*                                                                     *
*ENTRY POINT- ASMGF3                                                  *
*   CALLED VIA                                                        *
*   XCTL  ,DE=(R9)         I.E. EP=ASMGF3                             *
*                                                                     *
*INPUT-                                                               *
*   SYSUT3                                                            *
*     INPUT EDITED TEXT FOR ALL SOURCE AND ASSEMBLY STATEMENTS        *
*   SYSUT1                                                            *
*     EDITED TEXT FOR ALL MACRO DEFINITIONS FOLLOWED BY THE           *
*     CORRESPONDING MACRO DICTIONARY SEGMENTS.                        *
*     ALSO CONTAINS OPEN CODE SUBSETTED DICTIONARY.                   *
*   PARAMETERS                                                        *
*        R11=N/P OF OPEN CODE SUBSETTED DICTIONARY ON SYSUT1.         *
*        R1=GDP    BEGINNING OF GLOBAL DICTIONARY IN CORE.            *
*        R2=DEND   THE END OF THE DICTIONARY AREA.                    *
*        R3=SSEG   THE SIZE OF THE DICTIONARY SEGMENTS ON SYSUT1.     *
*        R4=BOTGOT THE BOTTOM OF CORE UNDER THE ASSEMBLERS CONTROL.   *
*        R5=INPLEN THE SYSUT3 BLOCKSIZE.                              *
*        R6=OBSIZ  THE F3->F7->F8 BLOCKSIZE FOR SYSUT2 AND SYSUT3.    *
*        R7=BUFFENT ADDRESS OF I/O BUFFERING AND CORE MANAGEMENT ROUT.*
*        R8=ADLIST1 COMMON AREA 'LIST1' IN ASM.                       *
*                                                                     *
*OUTPUT                                                               *
*   SYSUT2..CONTAINS EDITED TEXT FOR ALL INPUT SOURCE STATEMENTS AS   *
*       WELL AS EDITED TEXT FOR ALL STATEMENTS CREATED DUE TO MACRO   *
*       GENERATION AND CONDITIONAL ASSEMBLY.  THIS WILL BE INPUT      *
*       FOR PHASE ASMGF7.                                             *
*   REGISTER R2 IS SET TO THE BLOCKSIZE OF THE OUTPUT FILE TO BE      *
*       PASSED TO THE ASSEMBLER PHASES.                               *
*                                                                     *
*EXTERNAL ROUTINES                                                    *
*  ASMGBUFF- USED TO PERFORM MOST I/O FUNCTIONS SUCH AS               *
*        READ,WRITE,NOTE,POINT,ETC.                                   *
*                                                                     *
*EXITS- NORMAL                                                        *
*        XCTL TO ASMGRTA VIA                                          *
*                XCTL   ,DE=(R9)     I.E. EP=ASMGRTA                  *
*                                                                     *
*       ERRORS                                                        *
*         THERE ARE FOUR SEVERITIES OF ERRORS WHICH MAY OCCUR DURING  *
*         MACRO GENERATION                                            *
*          1.ERRORS THAT ONLY AFFECT THE STATEMENT BEING PROCESSED    *
*             GENERATED STATEMENT TOO LONG                            *
*             INVALID ATTRIBUTE REFERENCE                             *
*             SYSLIST EXPRESSION NOT WITHIN RANGE                     *
*             INVALID OP CODE                                         *
*             MULTIPLY-DEFINED KEYWORD PARAMETER IN MACRO INSTRUCTION *
*             EXPRESSION EXCEEDS LENGTH OF SUBSTRING                  *
*             UNDEFINED SEQUENCE SYMBOL                               *
*             CHARACTER STRING USED IN AN ARITHMETIC RELATIONAL       *
*               EXPRESSION IS NOT AN INTEGER                          *
*             MACRO INSTRUCTION PARAMETER NOT A SELF DEFINING VALUE   *
*             OVERFLOW DUE TO ARITHMETIC OPERATION                    *
*             EXPRESSION TWO OF A SUBSTRING IS GREATER THAN 8         *
*          2. ERRORS THAT CAUSE THE CURRENT MACRO PROCESSING TO BE    *
*             ABANDONED.                                              *
*             ACTR (LOOP COUNTER) EXCEEDED AND PROCESSING OF MACRO IS *
*              SUSPENDED                                              *
*          3.IF THE LOOP COUNTER(ACTR)IS EXCEEDED WHILST PROCESSING   *
*             OPEN CODE,AN END CARD IS INSERTED IN THE OUTPUT STREAM  *
*             AND ASMGF3 INPUT IS TERMINATED.                         *
*          4.IF THERE IS NOT ENOUGH CORE FOR THE LOCAL DICTIONARIES   *
*             OF THE MACROS BEING PROCESSED THE ASSEMBLY IS ABORTED.  *
*TABLES/WORK AREAS                                                    *
*       BUFFCB- INPUT BUFFERS CONTROL BLOCK, USED TO DETERMINE WHEN   *
*                READING IS NOT NECESSARY DUE TO DATA ALREADY BEING IN*
*                A BUFFER.                                            *
*       INPLEN  BLOCKSIZE OF INPUT RECORDS                            *
*       OBSIZ -BLOCKING OF OUTPUT RECORDS                             *
*       L1,L2 -258 BYTE AREAS SET ASIDE FOR COMPARING CHARACTERS      *
*              STRINGS.                                               *
*                                                                     *
         EJECT
         COPY      ASMGSET
         EJECT
ASMGF3   CSECT
         USING     ASMGF3,R15,R14      WE WILL START WITH THESE
         STM       R13,R14,ASMSAVE     SAVE REGS TO PASS ON
         LR        R14,R15             INITIALIZE SECOND BASE REGISTER
         A         R14,F4096           SET UP SECOND BASE REGISTER
         LA        R13,F3SAVE          SET UP LAST BASE REGISTER
         USING     F3SAVE,R13          AND TELL THE ASSEMBLER
*
*    DICTIONARY - CORE ALLOCATION.
*
         ST        R11,DICTNP          OPEN CODE NOTE/POINT
         STM       R1,R8,GDP           SAVE OTHER PARAMETERS
*
*        MOVE ASMGASM PARBYTES TO ASMGF3
*
         MVC       PARBYT1(4),L1PBYT1(R8)  MOVE PARBYTES TO ASMGF3
*
*        DO A GROW TO RECLAIM MACRO DIRECTORY IF NOT BATCH
         TM        PARBYT1,X'10'       TEST BATCH OPTION
         BO        BATCHASM            BRANCH IF BATCH SPECIFIED
         L         R0,L1LENMC(,R8)     GET LENGTH OF MACRO DIRECTORY
         ST        R0,GRLEN1
         L         R1,L1BOTMC(,R8)     GET STARTING ADDRESS
         N         R1,LOW3             D ALIGN
         ST        R1,GRADD1
         L         R1,BUFFENT          DO THE GROW
         CNOP      2,4
         BALR      R0,R1
         DC        A(32)
GRLEN1   DS        F
GRADD1   DS        F
         SPACE     2
*        DETERMINE THE OPTIMUM USE OF THE WORKDS SPACE.
*        MAY NOT BE OPTIMAL IF &UT1BUFF>2 OR &UT3BUFF>1
*
*        R0        MIN WASTED CORE
*        R1        BEST BIT STRING YET
*        R2        BIT STRING BEING TESTED
*        R3        TOTAL LENGTH ACCUMULATOR (NEG)
*
*        INITIALIZATION
BATCHASM L         R0,LWORKDS          MAX WASTED CORE
         SR        R1,R1               BIT STRING FOR MAX WASTED CORE
         LA        R2,B'00011111'      STARTING BIT STRING
*
OPTLOOP  STC       R2,TMBYTE           PUT BIT STRING IN CORE
         SR        R3,R3               INIT ACC
*        TEST GBL DICT BIT
         TM        TMBYTE,B'00010000'
         BZ        OPT2
         L         R3,GDP              COMPUTE NEG LTH OF GBL DICT
         S         R3,0(0,R3)
*        TEST SYSUT2 BIT
OPT2     TM        TMBYTE,B'00001000'
         BZ        OPT3
         S         R3,OBSIZ            DECREMENT ACC
*        TEST SYSUT3 BIT
OPT3     TM        TMBYTE,B'0000100'
         BZ        OPT4
         S         R3,INPLEN           DECREMENT ACC
*        TEST SYSUT1 BITS
OPT4     TM        TMBYTE,B'00000010'
         BZ        OPT5
         S         R3,SSEG             DECREMENT ACC
OPT5     TM        TMBYTE,B'00000001'
         BZ        OPT6
         S         R3,SSEG             DECREMENT ACC
*        TEST IF THIS BEST ALLOCATION SO FAR
OPT6     A         R3,LWORKDS
         BL        OPT7                BR IF OVER-ALLOCATED
         CR        R0,R3               TEST IF BEST ALLOCATION
         BL        OPT7
         LR        R0,R3               THIS IS BEST
         LR        R1,R2               SAVE THIS BIT STRING
*        TEST FOR LAST COMBINATION
OPT7     BCT       R2,OPTLOOP          BR IF NOT LAST
         STC       R1,TMBYTE           SAVE BEST BIT STRING
         LA        R5,WORKDS           INITIALIZE WORKDS POINTER
*        TEST IF GBL DICT SHOULD RESIDE IN WORKDS
         TM        TMBYTE,B'00010000'
         BZ        GBLMOVE
*        MOVE GLOBAL DICTIONARY
         LR        R4,R5               MOVE IT INTO WORKDS
*        MOVE GLOBAL DICTIONARY DOWN TO BOTTOM OF MY CORE
GBLMOVE  L         R2,GDP              WHERE GBL DICT IS NOW
         ST        R4,GDP              NEW GLOBAL DICT LOCATION
         L         R0,0(0,R2)          POINTER TO WHERE IT ENDS NOW
MOVEGD   MVC       0(256,R4),0(R2)     MOVE 256 BYTES
         LA        R4,256(0,R4)        UP THE ADDRESSES
         LA        R2,256(0,R2)
         CR        R2,R0               HAS ENOUGH BEEN MOVED
         BL        MOVEGD
         SR        R2,R4               DETERMINE NEW END LOCATION
         SR        R0,R2
         TM        TMBYTE,B'00010000'  TEST IF IN WORKDS
         BZ        GIVE
         LR        R5,R0               SAVE WORKDS POINTER
         L         R0,BOTGOT           SET MY CORE POINTER
*        GIVE THE REST OF CORE TO BUFF
GIVE     ST        R0,GRADD2           ADDRESS
         ST        R0,WRREG+4          TEMPORARY SAVE
         L         R1,DEND             PRESENT END OF MY CORE
         LA        R1,1(0,R1)          BOTTOM OF BUFF'S CORE
         SR        R1,R0               LENGTH TO GIVE BUFF
         ST        R1,GRLEN2
         L         R1,BUFFENT          DO A GROW
         CNOP      2,4
         BALR      R0,R1
         DC        A(32)
GRLEN2   DS        F
GRADD2   DS        F
*        REWIND SYSUT1 AND SYSUT3
         L         R1,BUFFENT          REWIND SYSUT1
         CNOP      2,4
         BALR      R0,R1
         DC        A(24,0,1)
         L         R1,BUFFENT          REWIND SYSUT3
         CNOP      2,4
         BALR      R0,R1
         DC        A(24,8,1)
         ENTRYOUT  F3
*        CALCULATE AMOUNT OF CORE NEEDED FOR I/O BUFFERS + EXTRA TO    X
               START                   DICTIONARY AREA
         L         R2,SSEG             2 * SSEG FOR INIT DICT +
         LA        R1,56(R2,R2)        51 FOR DICT AREA (D ALGND) +
         TM        TMBYTE,B'00000001'
         BO        *+6
         AR        R1,R2               SSEG IF BUFFER NOT IN WORKDS +
         TM        TMBYTE,B'00000010'
         BO        *+6
         AR        R1,R2               SSEG IF BUFFER NOT IN WORKDS +
         AIF       (&UT1BUFF EQ 2).GO1
         MH        R2,=AL2(&UT1BUFF-2)
         AR        R1,R2               REST OF UT1 BUFFERS +
.GO1     TM        TMBYTE,B'00000100'
         BO        *+8
         A         R1,INPLEN           UT3 BUFFER IF NOT IN WORKDS +
         AIF       (&UT3BUFF EQ 1).GO2
         L         R2,INPLEN
         MH        R2,=AL2(&UT1BUFF-1)
         AR        R1,R2               REST OF UT3 BUFFERS +
.GO2     TM        TMBYTE,B'00001000'
         BO        *+8
         A         R1,OBSIZ            UT2 BUFFER IF NOT IN WORKDS
         ST        R1,GETLEN           DO A GETCORE FROM BUFF FOR IT
         BAL       R9,GETCORE
*
*    INITIALIZATION FOR OUTPUT BUFFER
         L         R2,OBSIZ            OUTPUT BUFFER SIZE
         ST        R2,WRREG            STORE OUTPUT BUFFER SIZE
         L         R6,WRREG+4          POINT AT SPACE IN GETMAIN AREA
         TM        TMBYTE,B'00001000'  TEST IN IN WORKDS
         BZ        *+12
         LR        R4,R5               SET IN WORKDS
         AR        R5,R2               BUMP WORKDS POINTER
         B         *+8
         LR        R4,R6               SET IN GETMAIN AREA
         AR        R6,R2               BUMP GETMAIN AREA POINTER
         ST        R4,WRREG+4
         ST        R4,WRREG+8
         ST        R4,WRADD
*
*    INITIALIZATION FOR INPUT BUFFERS
         TM        TMBYTE,B'00000100'  TEST IF UT3 BUFFER IN WORKDS
         BZ        *+14
         LR        R4,R5               SET IN WORKDS
         A         R5,INPLEN           BUMP WORKDS POINTER
         B         *+10
         LR        R4,R6               SET IN GETMAIN AREA
         A         R6,INPLEN           BUMP GETMAIN AREA POINTER
         ST        R4,BUFFCB           UT3 BUFFER POINTER
         MVC       0(4,R4),EIGHT       INITIALIZE OC INPUT BUFFER
&WORK    SETA      1
         AIF       (&UT3BUFF EQ 1).GO3
.OCBUFF  ST        R6,BUFFCB+&WORK*8   UT3 INPUT BUFFER
         MVC       0(4,R6),=F'8'       INITIALIZE OC INPUT BUFFER
         A         R6,INPLEN           OPEN CODE BUFFER LENGTH
&WORK    SETA      &WORK+1
         AIF       (&WORK LT &UT3BUFF).OCBUFF
.GO3     TM        TMBYTE,B'00000010'  TEST IF 1ST UT1 BUFF IN WORKDS
         BZ        *+14
         LR        R4,R5               SET IN WORKDS
         A         R5,SSEG             BUMP WORKDS POINTER
         B         *+10
         LR        R4,R6               SET IN GETMAIN AREA
         A         R6,SSEG             BUMP GETMAIN AREA POINTER
         ST        R4,BUFFCB+&WORK*8   UT1 BUFFER POINTER
&WORK    SETA      &WORK+1
         TM        TMBYTE,B'00000001'  TEST IF 2ND UT1 BUFF IN WORKDS
         BZ        *+14
         LR        R4,R5               SET IN WORKDS
         A         R5,SSEG             BUMP WORKDS POINTER
         B         *+10
         LR        R4,R6               SET IN GETMAIN AREA
         A         R6,SSEG             BUMP GETMAIN AREA POINTER
         ST        R4,BUFFCB+&WORK*8   UT1 BUFFER POINTER
&WORK    SETA      &WORK+1
         AIF       (&UT1BUFF EQ 2).GO4
.MACBUFF ST        R2,BUFFCB+&WORK*8   UT1 INPUT BUFFER
         A         R2,SSEG             MACRO BUFFER LENGTH
&WORK    SETA      &WORK+1
         AIF       (&WORK LT &UTBUFF).MACBUFF
.GO4     LR        R2,R6               SET R2 FOR MACIN
         LR        R7,R6               INITIALIZE R7
*        READ IN OPEN CODE DICTIONARY
         B         MACIN               GO AND READ IT
INIT1    MVI       MAC4+1,X'00'        CLEAR FIRST TIME BRANCH
         MVI       18(R7),X'80'        MAKE LOOK A LIKE PAR PTRS STORED
         N         R2,LOW3             DOUBLE ALIGN
         ST        R2,TLADR            INITIALIZE TLADR
         LA        R2,8(0,R2)          INITIALIZE LDICT1
         ST        R2,LDICT1
         L         R8,ADLIST1          POINT TO LIST1 IN ASMGASM
         TM        L1SYNERR+1(R8),X'01'  ARE WE TO QUIT IMMEDIATELY .Q
         BZ        START7              BRANCH IF NOT
         LA        R5,X'53'            LENGTH OF DUMMY COMMENT
         LA        R11,DUMCMNT         ADDRESS OF DUMMY COMMENT
         BAL       R8,WRTRL            WRITE OUT DUMMY RECORD
         OI        ERRBTS,MASK1        SET ERROR BIT
         BAL       R6,CHKERR           ENTER THE ERROR
         B         ENDGEN              AND QUIT
         SPACE     2
ASMSAVE  DS        2F                  ASMSAVE AREA AND RETURN ADDRESS
F4096    DC        F'4096'             DIFFERENCE TWIXT R15 AND R14
         EJECT
*
*   REGISTERS FOR DRIVER ROUTINE
*
R0       EQU       0
R1       EQU       1
R2       EQU       2
R3       EQU       3
R4       EQU       4
R5       EQU       5
R6       EQU       6
R7       EQU       7
R8       EQU       8
R9       EQU       9
R10      EQU       10
R11      EQU       11
R12      EQU       12
R13      EQU       13
R14      EQU       14
R15      EQU       15
*
FR0      EQU       0                   FLOATING REG 0
*
BO       EQU       1
BH       EQU       2
BP       EQU       2
BL       EQU       4
BM       EQU       4
BNE      EQU       7
BNZ      EQU       7
BE       EQU       8
BZ       EQU       8
BNL      EQU       11
BNH      EQU       13
TRUE     EQU       1
BLKHDR   EQU       5                   SIZE OF F3 INPUT BLOCK HEADER
         EJECT
START6   CLI       0(R10),EOB          TEST FOR END OF BLOCK
         BNE       BYREAD
START7   LA        R12,BUFFCB          POINT AT 1ST BUFFER CONT BLOCK
         BAL       R9,RDNEXT1          READ NEXT BLOCK
         LA        R10,BLKHDR(0,R1)    RESET INPUT POINTER
BYREAD   SR        R5,R5
         STH       R5,ERRBTS           INITIALIZE TO ZERO
         MVC       PARCNT,ZEROS        INITIALIZE TO ZERO
         MVI       SUBSW,X'01'
         MVC       SAVRL(2),1(R10)     SAVE R/L
         ST        R10,BEGADR          SAVE BEG. ADDR. OF RECORD
         LA        R11,1(0,R10)
*
*    COMPUTED GO TO ON STATEMENT TYPE
*
         IC        R5,0(0,R10)         FETCH STATEMENT TYPE
         STC       R5,STATYP           STORE STATEMENT FLAG
         LA        R10,FLGLEN(0,R10)   GET BY FLAG
         AR        R5,R5
         LH        R9,STTYPE(R5)
         B         ASMGF3(R9)          GO TO THE ROUTINE
*
STTYPE   DC        AL2(MACHOP-ASMGF3)  X'00'  MACHINE INSTRUCTION
         DC        AL2(CSECT-ASMGF3)   X'01'  CSECT, DSECT, ETC
         DC        AL2(AGOST-ASMGF3)   X'02'  AGO STATEMENT
         DC        AL2(AIFST-ASMGF3)   X'03'  AIF STATEMENT
         DC        AL2(SETST-ASMGF3)   X'04'  SET STATEMENT
         DC        AL2(MINSTR-ASMGF3)  X'05'  MACRO INSTRUCTION
         DC        AL2(DUMP-ASMGF3)    X'06'  SPACER
         DC        AL2(MENDST-ASMGF3)  X'07'  MEND OR MEXIT
         DC        AL2(SOURCE-ASMGF3)  X'08'  SOURCE STATEMENT
         DC        AL2(ANOP-ASMGF3)    X'09'  BYPASS STATEMENT
         DC        AL2(ENDST-ASMGF3)   X'0A'  END OF ASSEM. STATEMENT
         DC        AL2(PARAM-ASMGF3)   X'0B'  PARAMETER RECORD
         DC        AL2(ENDMI-ASMGF3)   X'0C'  END OF M-I RECORD
         DC        AL2(ERRORST-ASMGF3) X'0D'  ERROR STATEMENT
*
ENDST    BAL       R8,WREND            DUMP OUTPUT BUFFERS
*
*      LOAD REGISTER R2 WITH TEXT BLOCKSIZE TO BE PASSED TO THE
*         ASSEMBLER PHASE 'ASMGRTA'
*
         L         R2,OBSIZ
         L         R3,ADLIST1          PASS ADDRESS OF LIST1 TO RTA
*
*        REWIND UTILITY FILES
*
         L         R1,BUFFENT          REWIND SYSUT1
         CNOP      2,4
         BALR      R0,R1
         DC        A(24,0,1)
         L         R1,BUFFENT          REWIND SYSUT2
         CNOP      2,4
         BALR      R0,R1
         DC        A(24,4,1)
         L         R1,BUFFENT          REWIND SYSUT3
         CNOP      2,4
         BALR      R0,R1
         DC        A(24,8,1)
*
*        RELEASE CORE OBTAINED FOR G.D., BUFFERS, LCL DICTS TO BUFF
*
         L         R4,BOTGOT
         ST        R4,GRADD            SET GROW ADDRESS
         L         R0,DEND
         SR        R0,R4               AMOUNT OF CORE TO BE FREED
         ST        R0,GRLEN            SET GROW LENGTH
         L         R1,BUFFENT          DO THE GROW
         CNOP      2,4
         BALR      R0,R1
         DC        A(32)
GRLEN    DS        F
GRADD    DS        F
*
*
*        XCTL TO 'ASMGRTA'
*
         LM        R13,R14,ASMSAVE     SAVE AREA AND RETURN TO ASM
         LA        R9,L1BLDL+6*L1LENBL(R3) ADDRESS OF RTA IN BLDL TABLE
         XCTL      ,DE=(R9)            AND TRANSFER
         EJECT
EOB1     LA        R10,1(0,R10)        GET BY END OF STATEMENT FLAG
         B         START6
*
*  PROCESS END OF M-I RECORD.  USED ONLY ON PRELIM. PASS
*      TO OUTPUT SOURCE
*
ENDMI    S         R10,TEN
         MVC       NUMKW,3(R10)        STORE NO. OF KW  ...  M-I
         LA        R10,5(,R10)         BUMP INPUT POINTER
         MVC       MINOTE2(4),BUFFCB+4 SAVE NOTE & UT NUMBER
         LR        R12,R10
         S         R12,BUFFCB          M-I DELTA
         STH       R12,MINOTE2+4       STORE M-I DELTA
         L         R0,MINOTE1          READ FIRST OF M-I AGAIN
         LA        R12,BUFFCB
         BAL       R9,RDTEXT1
         AH        R1,MINOTE1+4        ADD M-I DELTA
         LA        R10,9(0,R1)         POINT TO BYTE BEFORE 'A' PTR
         OI        MISWIT,X'20'        MACRO INSTRUCT. SW
         B         BEGMAC
*
*    PROCESS CSECT, DSECT, START, COMMON
*
CSECT    LA        R5,8
         BAL       R8,WRTRL
         MVC       SECTNM(9),1(R10)    STORE LENGTH AND NAME
         SR        R11,R11             FIND THE OPCODE FIELD
         IC        R11,1(,R10)         BY JUMPING OVER THE NAME
         LA        R11,4(R11,R10)
         MVC       SECTYP(6),0(R11)    PLACE LEN AND OPCODE AS SECTYP
         CLI       0(R10),VPUT         IS IT PUT FLAG
         BE        SECT2
         BAL       R11,GOVAL           EVALUATE NAME FIELD
         MVC       SECTNM(9),L1+1      STORE LENGTH + NAME
         MVC       SECTYP(6),2(R10)    PLACE LEN AND OPCODE AS SECTYP
         B         MACH1
*
*    PROCESS MACHINE INSTRUCTION
*
MACHOP   LA        R5,8
         BAL       R8,WRTRL
MACH     SR        R5,R5               ZERO OUT LENGTH REG.
         CLI       0(R10),VPUT         IS IT PUT FLAG
         BE        SECT2
         CLI       0(R10),VEND         IS IT END OF STATEMENT
         BE        EOB1
         BAL       R11,GOVAL           EVALUATE
MACH1    SR        R5,R5               CLEAR REGISTER
         IC        R5,L1+1             FETCH LENGTH OF STRING
         LA        R11,L1+1
         LA        R5,1(0,R5)          INCLUDE LENGTH IN STRING
         BAL       R8,WRATXT
         LA        R10,1(0,R10)
         B         SECT3
SECT2    LA        R11,1(0,R10)        SET UP
         SR        R5,R5               CLEAR REGISTER
         IC        R5,1(0,R10)         WRITE PARAMETERS
         LA        R5,1(0,R5)          INCR. PARAMETER TO INCLUDE R/L
         BAL       R8,WRATXT
         LA        R10,2(R10,R5)       ADVANCE INPUT PTR.
SECT3    TM        ERRBTS,MASK0        WAS STATEMENT TOO LONG
         BZ        MACH                BRANCH IF O.K.
         STM       R2,R3,SAV2          SAVE REGS.
         BAL       R6,ERR1A            PUTOUT ERROR MESSAGE
         B         PARAM               BYPASS STATEMENT
*
*    PROCESS COMPRESSED SOURCE AND ERROR STATEMENTS
*
ERRORST  L         R8,4(,R7)           DIVIDE ACTR BY 2 FOR
         SRA       R8,1                EACH ERROR RECORD
         ST        R8,4(,R7)           SAVE IT BACK AGAIN
SOURCE   BAL       R9,OUTP             WRITE SOURCE RECORD
PARAM    L         R10,BEGADR
         AH        R10,SAVRL
         B         START6
*
*    PROCESS -AIF- AND -AGO- STATEMENTS
*
AIFST    BAL       R11,GOVAL           EVALUATE AIF EXPRESSION
         CLI       GTLIST+3,TRUE       IS EXPRESSION TRUE
         BNE       PROTO4
         B         AGOST1
*
AGOST    STM       R1,R6,SVREG         SAVE REGISTERS IN CASE OF
*                                       UNDEFINED SEQUENCE SYMBOL
*    SETUP TO READ TEXT AT SEQUENCE SYMBOL
AGOST1   L         R9,8(0,R7)          FETCH LOOP COUNT
         C         R9,4(0,R7)          DOES IT EXCEED ACTR
         BC        BE+BH,LOOPER
         LA        R9,1(0,R9)          INCREMENT LOOP COUNT
         ST        R9,8(0,R7)
         BAL       R8,BASONE
         CLC       0(5,R12),ZERO       IS SEQ. SYMBOL UNDEFINED
         BE        NOSEQ
         LA        R10,5(0,R10)        GET TO NEXT STATEMENT FLAG
         MVC       SAVNOTE(3),0(R12)   GET NOTE OF TARGET BLOCK
         MVC       FWRD+2(2),3(R12)    GET BLOCK DELTA
         L         R0,SAVNOTE          READ TARGET BLOCK
         IC        R0,BUFFCB+7         FILE TO READ FROM
         LA        R12,BUFFCB
         BAL       R9,RDTEXT1
         LR        R10,R1              SET NEW INPUT POINTER
         AH        R10,FWRD+2
         B         BYREAD
*
*    PROCESS SET STATEMENT
*
SETST    MVC       PARCNT(1),0(R10)    SAVE TYPE OF SET STATEMENT
         CLI       4(R10),SPAREN       IS IT SUBSCRIPTED
         BE        SETST1
         BAL       R9,METINT           GET RESULT ADDRESS
         B         SETST2
SETST1   BAL       R11,GOVAL           EVALUATE SUBSCRIPTED NAME
SETST2   MVC       SAVBIT(1),BITNO     STORE BIT NO.
         MVC       SETADR(4),SAVADR    SAVE SET VARIABLE ADDR.
         MVC       SETLEN(1),SAVLEN    SAVE MAX LENGTH OF SETC
         LA        R10,1(0,R10)
         BAL       R11,GOVAL           EVALUATE OPERAND
         L         R12,SETADR          FETCH SET VARIABLE ADDR.
         CLI       PARCNT,VSETB        TYPE OF STATEMENT
         BE        SETSTB
         BH        SETSTC
SETSTA   MVC       0(4,R12),GTLIST     STORE SETA VALUE
         B         PARAM
SETSTC   SR        R5,R5               GET MAX LENGTH OF SETC
         IC        R5,SETLEN
         CLC       SETLEN(1),L1+1      COMPARE AGAINST LENGTH OF R.H.S.
         BNH       *+8                 AND PICK MIN VALUE
         IC        R5,L1+1             GET LENGTH OF RIGHT HAND SIDE
         STC       R5,1(,R12)          SET CURRENT LENGTH OF SETC
         S         R5,ONE              DECREMENT FOR MVC
         BM        PARAM               EXIT IF NULL STRING
         EX        R5,SETMVC           MOVE R.H.S. TO SETC STORAGE
         B         PARAM               EXIT
SETMVC   MVC       2(*-*,R12),L1+2     EX'ED MVC
SETSTB   SR        R5,R5               CLEAR REGISTER
         IC        R5,SAVBIT           FETCH BIT NUMBER
         BAL       R9,FNDBIT
         CH        R8,GTLIST+2         DOES RESULT FLD NEED CHANGE
         BE        PARAM
         IC        R9,0(0,R12)         FETCH SETB BYTE
         XR        R9,R5               ALTER BIT
         STC       R9,0(0,R12)
         B         PARAM
ANOP     EQU       PARAM
*
*   PROCESS MEND OR MEXIT
*
MENDST   MVC       MINOTE2(6),12(R7)   RETURN POINT AT NEXT UP LEVEL
MENDST01 LR        R2,R7               SAVE LOCAL DICTIONARY POINTER
MEND     L         R0,MINOTE2          NOTE/PT PARAMETER
         LA        R12,BUFFCB          READ THE BLOCK
         BAL       R9,RDTEXT1
         LR        R10,R1              SET INPUT POINTER
         AH        R10,MINOTE2+4       INCREMENT BY M-I DELTA
         S         R2,EIGHT
         MVC       PAD(8),0(R2)        SETUP -PAD-, -PARADR-
         TM        MISWIT,X'02'        ABORT SW.
         BO        MEND4
         L         R7,0(0,R7)
MEND4    ST        R2,TLADR
         B         START6
*
*  PROCESS MACRO INSTRUCTION ***** (M-I)
*
*
*     PERFORM PRELIMINARY PASS ON M-I TO OUTPUT SOURCE
*
MINSTR   MVC       MINOTE1(4),BUFFCB+4 SAVE NOTE AND UT NUMBER
         L         R9,BEGADR
         S         R9,BUFFCB           COMPUTE M-I DELTA
         STH       R9,MINOTE1+4        STORE M-I DELTA
         B         PARAM
* SET UP FOR BUILDING PARAMETER TABLE
*
BEGMAC   L         R2,TLADR            AVAIL. DICT. LOCATION
         OI        BITNO,GLOBAL        FORCE GLOBAL FETCH
         BAL       R8,BASONE
         CLI       18(R7),X'80'        HAVE PAR. PTRS. BEEN STORED
         BE        NESTA
         LR        R5,R3               SAVE PARAM TABLE POINTER
         LA        R9,HIPTR-1
         SR        R5,R9               LESS THE START
         A         R5,TWO              ADD TWO BYTES FOR POS PAR COUNT
NEST0    DS        0H
         LA        R9,14(R2,R5)        WILL PARAM PTRS FIT IN DICT .Q
         C         R9,DEND
         BL        NEST1
         BAL       R9,GETCORE          GET MORE MEMORY
         B         NEST0
NEST1    A         R2,THREE
         N         R2,LOW2             NEAREST FULL WORD ALIGN.
         ST        R2,PAD              STORE CORRECT PARLST
         LA        R9,HIPTR            GET ADDR OF PARM PTR TBL
NEST2    LR        R8,R5               XRF LENGTH OF PARM PTR TABLE
         CH        R5,H255             IS PTR TABLE MORE THAN 255 .Q
         BNH       NEST2A              NO, STORE PARM PTR TABLE
         LA        R8,255              SET TO MOVE 256 BYTES
NEST2A   EX        R8,MOVPAR           MOVE PARM. PTR TABLE
         CR        R5,R8               IS PARM POINTER MOVE DONE .Q
         BNH       NEST3               YES, CONTINUE
         SH        R5,H256             ADJUST LENGTH TO BE MOVED
         LA        R2,1(R2,R8)         ADJUST
         LA        R9,1(R9,R8)         MOVE POINTERS
         B         NEST2               GO FINISH MOVING TABLE
NEST3    DS        0H
         LA        R2,1+7(R2,R5)       7 FOR ALIGNMENT
         N         R2,LOW3             NEAREST DOUBLE WORD ALIGNMENT
         MVC       0(8,R2),PAD         STORE LOCAL -PAD- , -PARADR-
         MVI       18(R7),X'80'        PAR. PTRS HAVE BEEN STORED
NESTA    LA        R2,8(0,R2)
         ST        R2,MHDR             STORE HDR. ADDR.
         CLC       0(3,R12),ZEROS      NOTE/PT ZERO .Q
         BE        MACERR
*        PUSH BUFFER STACK DOWN
&WORK    SETA      &UTBUFF
.LOOP    LD        FR0,BUFFCB+&WORK*8-8
         STD       FR0,BUFFCB+&WORK*8
&WORK    SETA      &WORK-1
         AIF       (&WORK GE 1).LOOP
         LA        R4,4(0,R10)         SET MI POINTER
*
*   READ IN MACRO DICTIONARY
*
         MVC       DICTNP(3),0(R12)    GET N/P
*
*        ROUTINE TO READ MACRO OR OPEN CODE DICTIONARY
*        ENTER WITH DICTNP CONTAINING NOTE/POINT OF 1ST SEGMENT
*
*        CHECK ENOUGH CORE FOR 1ST READ
MACIN    L         R11,SSEG            MAX SIZE OF INPUT RECORD
MAC0     LA        R9,0(R2,R11)        AMT. CORE THAT SHOULD BE THERE
         C         R9,DEND
         BL        MAC1                BR IF OK
         LA        R9,MAC0             RETURN ADDRESS FROM GETCORE
*        ROUTINE TO GET CORE FROM BUFF
GETCORE  STM       R0,R1,GETCSAV       SAVE R0 AND R1
         L         R1,BUFFENT          DO A SHRINK
         CNOP      2,4
         BALR      R0,R1
         DC        A(36)
GETLEN   DS        F                   USUALLY = SEG
GETANS   DS        F                   RETURNED ANSWER FROM BUFF
         L         R1,GETLEN           COMPUTE NEW END OF MY CORE
         AL        R1,GETANS           OVERFLOW IF -1 IS IN GETANS
         ST        R1,DEND             SET TOP OF CORE POINTER
         MVC       GETLEN(4),SSEG      RESET GETLEN
         LM        R0,R1,GETCSAV       RESTORE REGISTERS
         BCR       14,R9               BNOR   TEST IF ENOUGH CORE
         L         R1,ADLIST1          GO TO ABEND ROUTINE IN ASM
         BAL       R0,L1ABEND(,R1)     POINTING TO A MESSAGE
         DC        C'989I',AL1(L'MES989-1)
MES989   DC        C'INSUFFICIENT MEMORY FOR PHASE F3 DICTIONARIES'
GETCSAV  DS        2F
*
*        READ 1ST SEGMENT
MAC1     LA        R9,DICT1            RETURN ADDRESS
         ST        R2,DICTADD          READ ADDRESS
*
         L         R1,BUFFENT          POINT
         CNOP      2,4
         BALR      R0,R1
         DC        A(12,0)
DICTNP   DC        F'1'
DICTREAD L         R1,BUFFENT          READ
         CNOP      2,4
         BALR      R0,R1
         DC        A(0,0)
DICTADD  DC        F'0'
         L         R1,BUFFENT          CHECK
         CNOP      2,4
         BALR      R0,R1
         DC        A(28,0,0)
         BR        R9                  RETURN
*
DICT1    SR        R5,R5
         IC        R5,17(0,R2)         NO. OF SEGMENTS
*        TEST IF ENOUGH CORE FOR REMAINING SEGMENTS
         MVC       FWRD+2(2),18(R2)    FETCH SIZE OF DICTIONARY
         LR        R11,R2              POINTS TO WHERE EACH SEG IS READ
         L         R3,ADLIST1          POINT AT LIST1 IN ASM
         SR        R9,R9               ZERO ACCUMULATOR REGISTER
         IC        R9,L1ASPARM(,R3)    GET LENGTH OF SYSPARM
         A         R9,FWRD             PLUS SIZE NEEDED
         LA        R9,22+54(R2,R9)     TOP OF CORE NEEDED FOR
*                                      CURRENT ENTRY AND NEXT IS LAST
         S         R9,DEND             ADDITIONAL NEEDED
         BL        MAC3                BR IF NONE
*        GET ADDITIONAL CORE
         LA        R9,7(0,R9)          D ALIGN UP
         N         R9,LOW3
         ST        R9,GETLEN           PLACE AMT.
         BAL       R9,GETCORE
         B         MAC3
*        READ IN REMAINING SEGMENTS OF DICTIONARY
MAC2     A         R11,SSEG            COMPUTE ADDRESS FOR NEXT SEGMENT
         ST        R11,DICTADD         SET AS READ ADDRESS
         BAL       R9,DICTREAD         READ ANOTHER DICT SEGMENT
MAC3     BCT       R5,MAC2             LOOP FOR EACH SEGMENT
         MVC       SAVNOTE(3),12(R2)   SET NOTE OF FIRST PROTO BLOCK
         ST        R7,0(0,R2)
         A         R2,FWRD             COMPUTE 1ST PARAMETER ADDR
MAC4     BC        *-*+15,INIT1(*-*)   BRANCH IF OPEN CODE DICT
         ST        R2,PARSAV           STORE BEGIN OF PAR. TABLE ADDR.
*
* INITIALIZE PARAMETER TABLE WITH SYSNDX,SYSECT,SYSDATE,SYSTIME,
*                SYSSTYP AND SYSPARM
*  STORE MACRO INSTRUCTION
*
         L         R8,NDXCNT
         LA        R8,1(0,R8)          INCREMENT SYSNDX
         ST        R8,NDXCNT
         BAL       R9,ABCD             CONVERT TO DECIMAL
         MVC       0(3,R2),FOUR+1
         MVC       3(4,R2),UNPAKD+11   ENTER CHARACTERS IN PAR. TABLE
         MVC       7(4,R2),NDXCNT      ENTER BINARY IN PAR. TABLE
         MVC       11(2,R2),FLAGSVS    &SYSECT FLAG BYTES
         MVC       13(9,R2),SECTNM     STORE SECTION NAME IN PAR. TAB.
         MVC       22(2,R2),FLAGSVS    FLAGS FOR &SYSDATE
         L         R3,ADLIST1          POINT AT TABLE IN ASM
         MVC       24(8,R2),L1ASDATE(R3)  MOVE IN THE DATE
         MVC       32(3,R2),FLAGSVS    FLAGS & LENGTH FOR &SYSTIME
         MVC       35(8,R2),L1ASTIME(R3)  MOVE IN THE TIME
         MVC       43(2,R2),FLAGSVS    &SYSSTYP FLAG BYTES
         MVC       45(6,R2),SECTYP     SECTION TYPE
         CLC       46(5,R2),=X'1C1D0A1B1D'  TEST FOR 'START'
         BNE       MACPSET
         MVC       46(5,R2),=X'0C1C0E0C1D'  CHANGE TO 'CSECT'
MACPSET  MVC       51(2,R2),FLAGSVS    SYSPARM FLAG BYTES
         SR        R8,R8               ZERO A WORK REGISTER
         IC        R8,L1ASPARM(,R3)    GET LENGTH OF SYSPARM
         STC       R8,53(,R2)          PASS LENGTH ALONG
         L         R3,L1ASPARM(,R3)    GET ADDRESS OF SYSPARM
         LTR       R9,R8               IS SYSPARM NULL .Q
         BZ        SYSPARND            YES, BRANCH AROUND
         BCTR      R9,0                DECREASE LENGTH FOR A MOVE
         EX        R9,SYSPMOVE         MOVE IN SYSPARM
         EX        R9,SYSPTRAN         TRANSLATE TO INTERNAL CODE
SYSPARND LA        R8,54(,R8)          GET TOTAL DISP INTO PARAM TABLE
         STH       R8,PARLST+10        UPDATE LAST POINTER ENTRY
         LA        R2,0(R8,R2)         ADVANCE PARAM TABLE POINTER
         LA        R3,PARLST+10        POINT TO LAST POINTER ENTRY
         B         PROTO               CONTINUE
SYSPTRAN TR        54(*-*,R2),TRSLTB   TRANSLATE TO INTERNAL CODE
SYSPMOVE MVC       54(*-*,R2),0(R3)    PUT SYSPARM IN PARAM TABLE
*
*    HAVE ALL MACRO INSTRUCTION KEYWORDS BEEN REFERRED TO BY PROTOTYPE
*
CHKEND   L         R7,MHDR
         MVC       12(7,R7),MINOTE2    STORE N/P OF M-I AND INIT SW
         CLC       NUMKW,MACCNT        WERE THERE SURPLUS KEYWORDS .Q
         BNE       MIERR
         STM       R5,R7,STOREGS       SAVE AWAY REGISTERS
         MVC       R1SAVE+2(2),3(R10)  ALIGN NUMBER OF KEYWORDS
         LH        R6,R1SAVE+2         NUMBER OF KEYWORDS IN PROTOTYPE
         LH        R7,POSCTR           NUMBER OF POS PAR IN MACRO CALL
*
         AR        R6,R7               COMBINED TOGETHER
         AR        R6,R6               DOUBLE IT
         LA        R5,PARLST+12(R6)    POINT TO PARM TABLE
         STC       R7,0(0,R5)          ENTER NUM OF POSITIONALS IN CALL
         MVC       1(1,R5),POSCNT+1    ENTER NUM OF POSNLS IN PROTOTYPE
         LM        R5,R7,STOREGS       RESTORE REGISTERS
*
PROTO3   LH        R0,PARCNT
         L         R8,PARSAV           FETCH PAR. TABLE ADDR.
         STC       R0,0(0,R8)          SYSLIST PAR. COUNT
         ST        R8,PARADR           STORE NEW PAR. TABLE ADDR.
         LA        R9,HIPTR
         ST        R9,PAD              REINITIALIZE PAD
         LR        R8,R3
         SR        R8,R9
         A         R8,TWO              ADD 2 BYTES FOR POS PAR COUNTS
         STH       R8,HIPTR            LENGTH OF PARAM. PTR. TABLE
*        FREE THE SECOND BUFFER
         LD        FR0,BUFFCB+8
         MVC       BUFFCB+8(&UTBUFF*8-16),BUFFCB+16
         STD       FR0,BUFFCB+&UTBUFF*8-8
         LA        R10,1(,R10)         BUMP FOR END STATEMENT
PROTO4   LA        R10,4(0,R10)
         ST        R2,TLADR
         B         START6
*
*   PROCESS PROTOTYPE STATEMENT
*   'NOTE' PROTOTYPE SEGMENT FOR NEXT PROTOTYPE READ
*
PROTO    L         R0,SAVNOTE          READ PROTOTYPE
         LA        R12,BUFFCB
         LA        R1,BUFFCB+16
         BAL       R9,RDNEW
         LA        R10,BLKHDR(0,R1)    HEADER
         CLI       0(R10),X'06'        IS IT PROTOTYPE RECORD
         BNE       PUTERR              NO, IT'S AN ERROR RECORD
         MVC       POSCNT,10(R10)      ENTER NUMBER OF POSIT PARAMS
         MVC       FWRD+2(2),1(R10)    RECORD LENGTH
         AH        R10,FWRD+2          ADVANCE PROTOTYPE POINTER
         B         NAMPAR
*
PROTO1   CLI       0(R4),PARFLG
         BL        BYSRCE              SOURCE FLAG
         BE        PARPUT              PARAMETER RECORD FLAG
MIEOB    CLI       0(R4),ERRFLG        OPERAND ERROR
         BL        ALLPOS              END RECORD FLAG
         BH        CONTKY
ENT0D    L         R2,MHDR
         B         ABT
CONTKY   LA        R12,BUFFCB+8        READ NEXT M-I SEGMENT
         BAL       R9,RDNEXT2
*****************************************************************
         LA        R4,BLKHDR(0,R1)     INITIALIZE M-I PTR.
         B         PROTO1
BYSRCE   MVC       FWRD+2(2),1(R4)
         AH        R4,FWRD+2           GET BY M-I SOURCE
         B         PROTO1
PARPUT   CLI       10(R4),POSFLG       POSITIONAL PARAM.
         BH        ALLPOS
         BL        PARP                SUBLIST CONTINUE FLAG
         TM        MISWIT,X'40'        2ND PASS FOR KEYWORDS
         BZ        PARADV
PARP     MVC       FWRD+2(2),1(R4)     GET BY
         AH        R4,FWRD+2           POSITIONAL PARAMETER
         B         PROTO1
PARADV   LA        R4,10(0,R4)         INCR. R4 PAST PAR. REC.
         LH        R9,PARCNT
         LA        R9,1(0,R9)          COUNT POSITIONAL PARAMETERS
         STH       R9,PARCNT
         STH       R9,POSCTR           SAVE NUMBER OF POS PAR IN CALL
NAMPAR   ST        R10,SAVINP          SAVE INPUT PTR.
         OI        MISWIT,X'08'        SET USE M-I PARAM SW.
         LR        R1,R4
         BAL       R6,ENTRY            ENTER POSITIONAL PARAMETER
         LR        R4,R1
         L         R10,SAVINP          RESTORE INPUT PTR.
         B         PROTO1
ALLPOS   CLC       POSCNT,POSCTR       ARE THERE ANY OMITTED OPNDS
         BC        BE+BL,MERGE
         LA        R1,NULCON-1
         BAL       R6,ENTRY            ENTER NULL CHAR. STRING
         LH        R5,POSCTR           GET CURRENT POS PARAM COUNT
         LA        R5,1(0,R5)          INCREMENT PARAM. CTR
         STH       R5,POSCTR           UPDATE CURRENT POS PARAM COUNT
         B         ALLPOS
MERGE    CLI       0(R10),ENDREC       END OF PROTOTYPE
         BE        CHKEND
         CLI       0(R10),ERRFLG
         BL        MERGE1              KEYWORD FLAG
         BE        PUTERR              ERROR FLAG
         LA        R12,BUFFCB          READ NEXT PROTO. SEGMENT
         BAL       R9,RDNEXT2
*****************************************************************
         LA        R10,BLKHDR(0,R1)
         B         PROTO1
MERGE1   CLI       10(R10),X'F9'       IS IT CONT SUBLIST FLAG
         BNE       MERGE2
         MVC       FWRD+2(2),1(R10)
         AH        R10,FWRD+2
         B         MERGE
MERGE2   SR        R5,R5               CLEAR REGISTER
         IC        R5,12(,R10)         FETCH KEYWORD NAME LENGTH
         CLI       0(R4),ENDREC        END OF M-I
         BH        CONTKY              M-I CONTINUED
         BL        CHKKEY              PROCESS KEYWORD
         CLC       NUMKW,ZEROS         ARE THERE NO KEYWORDS IN M-I
         BE        USEPRO
         TM        MISWIT,X'40'        IS ITERATION ON - BIT 1
         BZ        RDAGN               BRANCH IF IT WAS OFF
USEPRO   NI        MISWIT,X'B7'        TURN ITERATION OFF - SET PROTO
         LA        R1,13(R10,R5)       GET TO VALUE -1 BYTE
         BAL       R6,ENTRY            ENTER KEYWORD PARAMETER
         LR        R10,R1              RESET INPUT PTR.
         B         PROTO1
PUTERR   LA        R11,1(0,R10)
         MVC       SAVRL(2),1(R10)
         BAL       R9,OUTP
         L         R2,MHDR
         B         ABT
*           READ INITIAL  M-I SEGMENT
RDAGN    L         R0,MINOTE1
         LA        R12,BUFFCB+8
         BAL       R9,RDTEXT2
         L         R4,BUFFCB+8
         AH        R4,MINOTE1+4        ADD M-I DELTA
         MVC       FWRD+2(2),1(R4)
         AH        R4,FWRD+2           GET BY FLAGS & NAME FLD.
         OI        MISWIT,X'40'        INITIALIZE TO -ON-
         B         PROTO1
CHKKEY   CLC       12(1,R4),12(R10)    ARE LENGTHS OF KEYWORD NAME EQ.
         BNE       PARP
CHKNAM   EX        R5,COMPR            COMPARE KEYWORD NAMES
         BNE       PARP
USEMI    LA        R1,13(R4,R5)        GET TO VALUE - 1 BYTE
         OI        MISWIT,X'08'        SET USE M-I PARAM. SW.
         ST        R10,SAVINP
         BAL       R6,ENTRY            ENTER PARAMETER
         L         R10,SAVINP
         LR        R4,R1
         LH        R9,MACCNT
         LA        R9,1(0,R9)          UP M-I KEYWORD CNTR.
         STH       R9,MACCNT
         MVC       FWRD+2(2),1(R10)
         AH        R10,FWRD+2          ADVANCE PROTOTYPE PTR.
         NI        MISWIT,X'BF'        INITIALIZE TO OFF
         B         PROTO1
*
*  ****  ENTRY  ****
*
*  FUNCTION.  1. EVALUATE PARAMETER
*             2. MAKE ENTRY IN PARAMETER TABLE
*
*  PARAMETERS.
*              R1 - CONTAINS ADDR. OF BYTE PRECEDING TYPE BYTE
*
*
ENTRY    LA        R9,HIPTR            ENSURE PARAMETER POINTER
         SR        R9,R3               TABLE WILL NOT OVERFLOW
         LCR       R9,R9
         CH        R9,HIPTRMXL
         BL        ENTRY00             NO OVERFLOW
         OI        ERRBTS+1,X'08'      OVERFLOW, SET UP DIAG
         MVI       RTNNO,3             AND TERMINATE THIS M-I
         L         R2,MHDR             RESTORE PARAM TABLE PTR
         B         ABT                 AND EXIT
ENTRY00  ST        R2,DELTA            STORE SUBLIST PTR. ADDR.
         MVC       SUBLEN(5),ZEROS     ZERO OUT
ENTRY1   ST        R2,TLADR            STORE SUBLIST PTR. ADDR.
         LA        R9,17(0,R2)
         C         R9,DEND
         BL        ENTRY0              BR IF ENOUGH CORE
         BAL       R9,GETCORE          GET SOME MORE CORE
         B         ENTRY1+4
ENTRY0   TM        MISWIT,X'10'        IS IT SUBLIST
         BZ        ENTRY2
ENTRY0A  DS        0H
         LA        R9,19(,R2)          WE NEED TWO MORE FOR SUBLIST
         C         R9,DEND             IS THERE SUFFICIENT ROOM .Q
         BL        ENTRY0B             BRANCH IF YES
         BAL       R9,GETCORE          GET SOME MORE CORE
         B         ENTRY0A             CHECK IF ENOUGH
ENTRY0B  DS        0H
         LA        R2,2(0,R2)          BYPASS PTR.
ENTRY2   CLI       SAVTYP,VSUB
         BNE       ENTRY3
         LA        R1,2(0,R1)
ENTRY3   MVC       0(17,R2),1(R1)      ENTER TYPE, FLAG, ETC.
         LA        R1,2(0,R1)          POINT TO FLAG
         CLI       1(R2),VSUB          IS IT SUBLIST
         BE        SBEVAL
         CLI       1(R2),VSYM          IS IT A SYMBOL
         BE        SYMENT
         CLI       1(R2),NULSYM
         BL        CSDENT
         BH        SIMPCH
*                                       EVALUATE
EVAL     MVI       0(R2),UTYPE         SET TYPE TO U
EVAL2    MVI       1(R2),VCHAR
EVAL1    LR        R10,R1
         BAL       R11,GOVAL           EVALUATION
ENTR9    TM        MODESW,CONCAT       WAS THERE CONCATENATION
         BZ        NOCAT
NOCAT2   LR        R1,R10              NEW SCAN PTR
         LA        R12,L1+1            L BYTE ADDR
         LA        R2,2(0,R2)
         B         PUTIN
NOCAT    L         R1,SUBADR
         LTR       R1,R1               SIMPLE CHAR. STRING
         BZ        NOCAT2
         TM        MISWIT,X'10'        IS IT SUBLIST
         BO        NOCAT2
         BCTR      R1,0                POINT TO BYTE BEFORE TYPE
         MVC       SAVTYP(1),2(R1)     SAVE FLAG OF PARAMETER
         B         ENTRY3
*                                       SUBLIST ENTRY
SBEVAL   MVI       0(R2),X'FF'         SW. - GET TYPE OF FIRST PAR.
         OI        MISWIT,X'10'        SET SUBLIST SW. ON - BIT 3
         LA        R2,8(0,R2)
         LA        R1,6(0,R1)          POINT TO (
         B         ENTRY1
*                                       CSD - HBD ENTRY
CSDENT   LA        R2,6(0,R2)
         LA        R1,5(0,R1)          POINT TO L BYTE
CSD1     SR        R5,R5               CLEAR REGISTER
         IC        R5,0(,R1)           FETCH LENGTH
         LR        R12,R1
         LA        R1,1(R1,R5)         ADV. TO END OF PARAMETER
         B         PUTIN
*                                       SYMBOL ENTRY
SYMENT   CLI       SAVTYP,X'00'
         BNE       SYMIN               BRANCH IF OUTER REFERENCE
         LR        R10,R1
         BAL       R8,BASONE           GET ADDR. OF ATTRIBUTE
         MVC       2(ATTLEN,R2),0(R12) ENTER ATTRIBUTES
         MVC       0(1,R2),0(R12)      STORE TYPE IN FIRST BYTE
         LA        R2,6(0,R2)
         LA        R1,6(0,R1)
         B         EVAL2
SYMIN    LA        R2,8(0,R2)
         LA        R1,7(0,R1)
         B         CSD1
*    IS IT A SIMPLE CHARACTER STRING
SIMPCH   LA        R12,1(0,R1)         FETCH ADDR. OF L BYTE
         SR        R5,R5               CLEAR REGISTER
         IC        R5,1(0,R1)
         LA        R9,2(R1,R5)         BYTE BEYOND STRING
         CLI       0(R9),NULSYM        TEST FOR EVAL. FLAG
         BE        EVAL1
         LA        R2,2(0,R2)
         CLI       1(R1),X'0E'         HAS IT ALL BEEN ENTERED
         LR        R1,R9
         BNH       PUTINC
PUTIN    SR        R5,R5               CLEAR REGISTER
         IC        R5,0(,R12)          STORE L
         LTR       R5,R5               IS IT NULL STRING
         BP        PUTINA
         MVI       0(R2),X'00'         NULL CHAR. STRING
PUTINA   LA        R9,1(R2,R5)
         C         R9,DEND             WILL ENTRY FIT
         BL        PUTIN1              BR IF ENOUGH CORE
         BAL       R9,GETCORE          GET SOME MORE CORE
         B         PUTINA
PUTIN1   EX        R5,ENTER            MAKE ENTRY
PUTINC   LA        R2,1(R2,R5)         ADV. TABLE PTR.
         MVI       0(R2),X'00'         AVOID SPURIOUS 'EVAL' FLAG
         LH        R9,SUBLEN
         AR        R9,R5               UP SUBLIST CTR.
         STH       R9,SUBLEN
         TM        MISWIT,X'10'        IS IT SUBLIST
         BO        ENT1
ENTA     CLI       SAVTYP,X'00'        IS IT OUTER PARAM. LOOKUP
         BE        ENT5
         LR        R1,R10              RESTORE R1
         B         ENT5
ENT1     LR        R8,R2
         L         R9,TLADR
         SR        R8,R9
         S         R8,TWO              COMPUTE OPND. PTR
         STH       R8,FWRD+2           STORE OPND. PTR
         MVC       0(2,R9),FWRD+2
ENT5     L         R12,DELTA           FETCH ENTRY ADDR.
         TM        MISWIT,X'10'        IS IT SUBLIST
         BO        ENT3
         LR        R9,R2
         SR        R9,R12
         STH       R9,FWRD+2           TOTAL LENGTH OF ENTRY
         AH        R9,0(0,R3)
         STH       R9,2(0,R3)          STORE NEW PTR.
         LA        R3,2(0,R3)
         CLI       1(R12),VSUB         IS IT SUBLIST
         BE        ENT22
         LA        R1,1(0,R1)
         BR        R6
ENT22    MVC       2(2,R12),FWRD+2     STORE TOTAL LENGTH IN PARAM.
         LA        R1,3(,R1)           BUMP PAST N ATTRIBUTE
         BR        R6
ENT3     MVC       0(2,R2),0(R1)       ENTER OPERAND TERMINATOR
         CLI       0(R12),X'FF'        TYPE OF SUBLIST UNKNOWN YET
         BNE       ENT5A
         MVC       0(1,R12),2(R9)      USE TYPE OF FIRST PARAMETER
ENT5A    CLI       0(R1),RPARVL        END OF SUBLIST
         BE        ENT4
         LA        R2,1(0,R2)
         CLI       1(R1),ERRFLG        TEST
         BH        ENT6A               END OF BLOCK, OR
         BE        ENT0D               ERROR RECORD
         CLI       SAVTYP,X'00'        IS IT PARAMETER REFERENCE
         BNE       ENTRY1              BRANCH IF IT IS
         LA        R1,11(0,R1)         POINT TO BYTE BEFORE TYPE
         B         ENTRY1
ENT6A    TM        MISWIT,X'08'
         BZ        ENT7
         LA        R12,BUFFCB+8        READ NEXT M-I SEGMENT
         BAL       R9,RDNEXT2
         LA        R9,BLKHDR(0,R1)
         B         ENT8
ENT7     LA        R12,BUFFCB          READ NEXT PROTO SEGMENT
         BAL       R9,RDNEXT2
         LA        R9,BLKHDR(0,R1)
ENT8     LA        R1,10(0,R9)
         B         ENTRY1
ENT4     LA        R2,2(0,R2)
         SR        R5,R5               CLEAR REGISTER
         IC        R5,1(,R1)           GET N ATTRIBUTE OF SUBLIST
         STC       R5,6(0,R12)         STORE N ATTRIB.
*                                       COMPUTE K ATTRIB
         LA        R8,1(0,R5)          N+1
         AH        R8,SUBLEN
         STH       R8,SUBLEN
         MVC       4(2,R12),SUBLEN     STORE K
         S         R10,TWO
         NI        MISWIT,X'EF'        TURN OFF SUBLIST SWITCH
         B         ENTA
********************** DRIVER SUBROUTINES *********************
OUTP     LH        R5,SAVRL
         BCTR      R5,0                GET ACTUAL LENGTH
         BAL       R8,WRTRL
         BR        R9
*
GOVAL    STM       R1,R6,SVREG         SAVE REGISTERS
         ST        R11,RTNVAL
         B         VALUAT              EVALUATE
VALRTN   L         R11,RTNVAL
         BR        R11
         EJECT
*
*        THE FOLLOWING ROUTINES READ THE INPUT TEXT FROM UT1 AND UT3
*        THEY MAINTAIN THE INPUT BUFFERS VIA THE BUFFCB
*        BLOCKS ARE READ ONLY AFTER IT HAS BEEN ASCERTAINED THAT THE
*          BLOCK IS NOT ALREADY IN A BUFFER
*
*        INPUT - R12 POINTS AT THE BUFFER CONTROL BLOCK ENTRY
*                  BUFFCB+8 FOR M-I INPUT DURING M-I/PROTO SCAN
*                  BUFFCB   FOR EVERYTHING ELSE
*                R9 IS RETURN ADDRESS
*                R0 CONTAINS NOTE/POINT OF BLOCK TO BE READ
*                R1 POINTS AT FIRST FREE BUFFER CONTROL BLOCK
*                   BUFFCB+16 DURING M-I/PROTO SCAN
*                   BUFFCB+8  AT ALL OTHER TIMES
*             NOTE - NOT ALL OF THE ABOVE REGISTERS ARE NEEDED AT ALL
*                    OF THE ENTRY POINTS
*
*        OUTPUT - R1 POINTS AT THE START OF THE BUFFER
*
*        READ A NEW BLOCK, 2 ACTIVE, R12,R9 AND R0 NEEDED
RDTEXT2  C         R0,4(0,R12)         SAME AS PRESENT BLOCK .Q
         BE        RET                 EXIT IF SO
         B         RDFREE2             GO FREE PRESENT BUFFER
*        READ A NEW BLOCK, 1 ACTIVE, R12,R9 AND R0 NEEDED
RDTEXT1  C         R0,4(0,R12)         SAME AS PRESENT BLOCK .Q
         BE        RET                 EXIT IF SO
         B         RDFREE1             GO FREE PRESENT BUFFER
*        READ NEXT BLOCK, 2 ACTIVE, R12 AND R9 NEEDED
RDNEXT2  L         R1,0(0,R12)         POINT AT PRESENT BUFFER
         L         R0,0(0,R1)          EXTRACT NEXT NOTE/POINT
RDFREE2  LA        R1,BUFFCB+16        SET 1ST FREE POINTER
         B         RDFREE              GO FREE THIS BUFFER
*        READ NEXT BLOCK, 1 ACTIVE, R12 AND R9 NEEDED
RDNEXT1  L         R1,0(0,R12)         POINT AT PRESENT BUFFER
         L         R0,0(0,R1)          EXTRACT NEXT NOTE/POINT
RDFREE1  LA        R1,BUFFCB+8         SET 1ST FREE POINTER
RDFREE   LD        FR0,0(0,R12)        FREE BUFFER BY PLACING AT BOTTOM
         STD       FR0,BUFFCB+&UTBUFF*8  OF BUFFCB
*        READ A NEW BLOCK WITHOUT FREEING A BUFFER,
*              R12,R9,R1 AND R0 NEEDED
RDNEW    ST        R1,R1SAVE           SAVE R1
LOOP     C         R0,4(0,R1)          TEST FOR CORRECT BLOCK
         BE        FOUND
         LA        R1,8(0,R1)          NEXT ENTRY
         CLI       0(R1),0             TEST FOR END OF LIST
         BE        LOOP
*        SET UP FOR READING
         ST        R0,PTNP             NOTE/POINT
         MVI       PTNP+3,X'01'        POINT + 1
         STC       R0,CLI1+1           UT NUMBER
         STC       R0,PTUTNO+3
         STC       R0,RDUTNO+3
         STC       R0,CKUTNO+3
         STC       R0,NTUTNO+3
         STC       R0,MVI1+1
*        FIND A FREE BUFFER FOR THIS UTILITY
         L         R1,R1SAVE           RESTORE R1
         MVI       RETSW+1,0           SET BRANCH TO NOP
CLI1     CLI       7(R1),*-*           TEST UTILITY NUMBER
         BE        FOUND
         LA        R1,8(0,R1)          NEXT ENTRY
         B         CLI1
*        PLACE FOUND BUFFER IN REQUESTED SPOT AND POP UP THOSE BELOW IT
FOUND    LD        FR0,0(0,R1)         PICK UP BUFF CONT BLOCK
         STD       FR0,0(0,R12)        AND STORE IT
         LA        R0,BUFFCB+&UTBUFF*8 CALCULATE MOVE LENGTH
         SR        R0,R1
         STC       R0,*+5              DO THE MOVE
         MVC       0(*-*,R1),8(R1)
RET      L         R1,0(0,R12)         SET R1 IN CASE SW IS TO BR
RETSW    BCR       *-*+15,R9           BR/NOP SWITCH
*
         MVI       RETSW+1,X'F0'+R9    RESET BRANCH
         L         R1,BUFFENT          POINT + 1
         CNOP      2,4
         BALR      R0,R1
         DC        F'12'
PTUTNO   DC        F'0'                UT NUMBER
PTNP     DC        F'1'                NOTE/POINT INFO
         L         R1,0(0,R12)         BUFFER ADDRESS
         ST        R1,RDADD
         L         R1,BUFFENT          READ & KEEP
         CNOP      2,4
         BALR      R0,R1
         DC        F'0'
RDUTNO   DC        F'0'                UT NUMBER
RDADD    DC        F'0'                ADDRESS
         L         R1,BUFFENT          CHECK
         CNOP      2,4
         BALR      R0,R1
         DC        F'28'
CKUTNO   DC        F'0'                UT NUMBER
         DC        F'0'                LENGTH (IGNORED)
         L         R1,BUFFENT          NOTE
         CNOP      2,4
         BALR      R0,R1
         DC        F'20'
NTUTNO   DC        F'0'                UT NUMBER
NTNP     DC        F'0'                NOTE/POINT
*        PLACE N/P OF THIS RECORD IN BUFFCB AND N/P FOR NEXT RECORD
*          AT START OF BUFFER
         L         R1,0(0,R12)         POINT AT BUFFER
         MVC       4(3,R12),0(R1)      N/P FOR THIS BLOCK
         MVC       0(3,R1),NTNP        N/P FOR NEXT BLOCK
MVI1     MVI       3(R1),*-*           UT NUMBER
         BR        R9                  RETURN
         EJECT
*
*   CHECK ERROR BITS ROUTINE
*
CHKERR   STM       R2,R3,SAV2
         CLI       STATYP,X'01'        IS IT CSECT OR MACH. INSTRUCT.
         BH        ERR1A
         LA        R11,ZEROS           PUTOUT FULL WORD - ZEROS
         LA        R5,4
         BAL       R8,WRATXT           WRITE
ERR1A    SR        R2,R2               ZERO ERRSTG COUNTER
         LA        R12,ERRBTS
ERR1     CLI       0(R12),X'00'        ERRORS IN FIRST BYTE
         BE        SECBYT
         SR        R4,R4               ZERO OUT REGISTER
ERR2     LR        R5,R4               STORE BIT NO.
         BAL       R9,FNDBIT           IS BIT SET
         LA        R4,1(0,R4)          INCREMENT BIT NO.
         LTR       R8,R8
         BP        ERR3                BRANCH IF ERROR BIT IS ON
ERR22    LA        R2,1(0,R2)          UP ERRSTG CNTR.
         C         R4,EIGHT            END OF BYTE
         BL        ERR2
SECBYT   LA        R3,ERRBTS+1         SECOND ERROR BYTE
         CR        R12,R3              HAS SECOND BYTE BEEN CHECKED
         BNE       ERR4
         LM        R2,R3,SAV2
         BR        R6
ERR4     IC        R2,EIGHTH+1
         LR        R12,R3
         B         ERR1
ERR3     IC        R5,ERRSTG(R2)       FETCH ERROR NO.
         STC       R5,ERRNO            MOVE TO PUT STRING
         LA        R5,6                LENGTH = 6
         LA        R11,ERRREC
         BAL       R8,WRTRL            PUTOUT ERROR RECORD
         L         R8,4(,R7)           DIVIDE ACTR BY 2 ON EACH ERROR
         SRA       R8,1
         ST        R8,4(,R7)           SAVE IT BACK AGAIN
         B         ERR22
ERRSTG   DC        X'2873393A3B3C3D3E3F40415842433845'  ERROR CODES
*
*
*
*
VALUAT   MVI       MODESW,CREMSK       INITIALIZE MODESW - CHAR. EXPR.
         LM        R2,R5,REGCON        INITIALIZE POINTERS
         MVI       OPTAB,DOT           INITIALIZE OPTAB
         ST        R5,GTLIST           INITIALIZE WITH ZERO RESULT
SYMBLA   STH       R5,L1               ZERO OUT L1
         STH       R5,L2               ZERO OUT L2
         ST        R5,SUBADR           ZERO OUT
         LA        R6,L1
         NI        MODESW,X'F7'        TURN OFF PUTST SW. - BIT 4
SYMBL    CLI       0(R10),HIOP         IS IT OUTSIDE OPERATOR RANGE
         BH        NOTOPR
*
*   CHECK OPERATOR FOR PARENTHESIS AND END OF EXPRESSION
*
CHFORC   CLI       0(R10),LPAREN       (
         BE        ADVOP
         CLI       0(R10),RPAREN       )
         BE        TSTOP1
TSTREL   CLI       0(R10),EQUAL        IS IT RELATIONAL OPR.
         BL        FORCE1
         CLI       0(R10),VNOT         OUTSIDE RELATIONAL OPR. RANGE .Q
         BH        FORCE               BRANCH IF .AND.  .OR.
         BE        ADVOP
RELINT   LA        R6,L2               INITIALIZE STRG2
         NI        MODESW,X'F7'        TURN OFF PUTST SW. - BIT 4
         B         FORCE1
*
*   DOES OPR. AT R10 FORCE THE LAST OPR. ENTRY IN OPLIST
*  I.E.   -  DOES IT HAVE A HIGHER RATING
*
FORCE    CLI       OPTAB,COMMA         END OF EXPRESSION
         BE        TSTOP1
FORCE1   SR        R9,R9               ZERO OUT REG
         SR        R5,R5               CLEAR REGISTER
         IC        R5,0(0,R10)         FETCH OPERATOR
         IC        R9,RATING(R5)       GET OPR. RATING OF INPPTR OPR.
         IC        R5,0(0,R4)
         IC        R5,RATING(R5)       GET OPR. RATING OF OPPTR OPR.
         CLR       R9,R5               DOES FORCING OCCUR
         BL        ADVOP
*
*    OPERATOR DOES FORCE
*
TSTOP1   CLI       0(R4),COMMA
         BE        TEMPEX
         CLI       0(R4),LPAREN        (
         BNE       CH1
         TM        SWITCH,X'01'        IS IT SBCLS, SBCOM
         BO        TEMPEX
         CLI       0(R10),RPAREN       )
         BNE       ADVOP
CANCEL   BCTR      R4,0                MOVE R4 BACK ONE
         CLI       OPTAB,COMMA
         BE        DOOPR
         B         ADVINP
CH1      CLI       0(R4),SPAREN        SPECIAL SUBSCRIPT (
         BNE       DOOPR
         CLI       0(R10),COMMA
         BE        ADVSYS
         CLI       0(R10),RPAREN       )
         BNE       ADVOP
*
*   PERFORM FUNCTION OF OPERATOR FORCED IN TABLE
*
DOOPR    TM        SWITCH,X'01'
         BZ        DOOPRX
         CLI       0(R4),EQUAL
         BC        BE+BH,TEMPEX
DOOPRX   BCTR      R4,0                MOVE BACK R4
         L         R12,0(0,R3)         LOAD ADDR. OF OPERAND B
         CLI       1(R4),VNOT
         BE        NOTOP
         S         R3,FOUR             MOVE BACK R3 POINTER
         L         R11,0(0,R3)         LOAD ADDR. OF OPERAND A
         CLI       1(R4),SPAREN        SPECIAL SUBSCRIPT (
         BE        SUBSC
         TM        MODESW,CREMSK       IS IT CHAR. EXPR. MODE
         BO        DOOPR1
         S         R2,FOUR             MOVE BACK GT POINTER
DOOPR1   CLI       1(R4),EQUAL         IS IT ARITHMETIC OPERATOR
         BL        ARITOP
         CLI       1(R4),VOR           RELAT. OR LOGICAL OPERATOR
         BL        RELAT
         BH        ANDOP
*
*    PROCESS OPERATORS- AND - OR - NOT
*
         OC        3(1,R11),3(R12)     'OR' CASE
         B         ANDOP1
ANDOP    NC        3(1,R11),3(R12)     'AND' CASE
ANDOP1   LA        R6,L1               ADDR OF STRING AREA 1
         NI        MODESW,X'F7'        TURN OFF PUTST SW. - BIT 4
         LR        R2,R11
         B         FORCE
NOTOP    XI        3(R12),TRUE         'NOT' CASE
         B         FORCE
*
*    PROCESS ARITHMETIC OPERATORS  + - * /
*
ARITOP   L         R1,0(0,R11)         GET CURRENT VALUE
         LA        R8,CONTIN
         CLI       1(R4),VMINUS
         BL        ADD                 OPR. IS +
         BE        SUBTR               OPR. IS -
         CLI       1(R4),VMULT
         BE        MULTY               OPR. IS *
DIV      SR        R0,R0               OPR. IS /
         CL        R0,0(0,R12)         IS DIVISOR ZERO .Q
         BNE       DIV1                BRANCH IF NOT
         SR        R1,R1               USE ZERO RESULT
         BR        R8
DIV1     LTR       R1,R1               IS DIVIDEND MINUS .Q
         BNM       DIV2                BRANCH IF NOT
         BCTR      R0,0                MAKE EVEN REGISTER -1
DIV2     D         R0,0(0,R12)         PERFORM DIVISION
         BR        R8
ADD      A         R1,0(0,R12)         PERFORM ADDITION
         BO        OVF                 BRANCH IF OVERFLOW
         BR        R8
SUBTR    S         R1,0(0,R12)         PERFORM SUBTRACTION
         BO        OVF                 BRANCH IF OVERFLOW
         BR        R8
MULTY    M         R0,0(0,R12)         PERFORM MULTIPLICATION
*
*  TEST   PRODUCT FOR EXCEEDING LIMITS
*
         LA        R9,OVF
         LTR       R0,R0
         BCR       BP,R9               EVEN REG. GREATER THAN ZERO
         BZ        POS                 EVEN REG. EQUALS ZERO
         A         R0,ONE
         BCR       BNZ,R9
         LTR       R1,R1
         BCR       BM,R8               BRANCH ON MINUS
         BR        R9
POS      LTR       R1,R1
         BCR       BM,R9
*
*
CONTIN   ST        R1,0(0,R11)         STORE RESULT
         B         FORCE
*
*   PROCESS RELATIONAL OPERATORS - EQ, NE, GT, LT, GE, LE
*
RELAT    SR        R5,R5               CLEAR REGISTER
         IC        R5,1(,R4)
         IC        R8,CONCD-8(R5)      FETCH CONDITION CODE.
         TM        MODESW,CREMSK       IS IT A CHARACTER RELATIONAL
         BO        CRE
*    RELATIONAL OPERATOR - ARITHMETIC EXESSION
         L         R9,0(0,R11)
         C         R9,0(0,R12)         COMPARE OPND A + B
EXEC1    EX        R8,BRANCH
         MVC       0(4,R2),ZERO        FALSE
         B         EXEC3
EXEC2    MVC       0(4,R2),ONE         TRUE CASE
EXEC3    SR        R5,R5
         ST        R2,0(0,R3)
         B         SYMBLA
*    RELATIONAL OPERATOR - CHARACTER EXPRESSION
CRE      LA        R2,GTLEN(0,R2)      UPDATE R2
         LH        R5,L1
         CH        R5,L2               COMPARE LENGTH OF STRING
         BNE       EXEC1
         LTR       R5,R5               IS LENGTH ZERO .Q
         BZ        EXEC1               BRANCH IF ZERO
         BCTR      R5,0                DECREMENT LENGTH BY ONE
         EX        R5,TRSLT1           OPND A - TRANSLATE TO ORIGINAL
         EX        R5,TRSLT2           OPND B - TRANSLATE TO ORIGINAL
         EX        R5,CLC1             COMPARE OPND A TO OPND B
         EX        R5,TRSLT1           TRANSLATE BACK TO INTERNAL
         EX        R5,TRSLT2           TRANSLATE BACK TO INTERNAL
         B         EXEC1
*
*    PROCESS SUBSCRIPTED SET VARIABLE - SPECIAL SUBSCRIPT (
*
SUBSC    LA        R10,1(0,R10)
         SR        R5,R5               ZERO R5
         IC        R5,SCPCTR
         S         R5,ONE
         STC       R5,SCPCTR
         BC        BP,SUB3
         OC        MODESW(1),SUBSW     RESTORE A.R.E.-C.R.E
         MVI       SUBSW,X'01'         INITIALIZE SUBSCRIPT SWITCH
SUB2     TM        MODESW,X'80'        IS IT SYSLIST MODE
         BZ        SUB3
         L         R5,0(0,R2)
         CH        R5,POSNOMAX         TOO MANY POS PARMS .Q
         BH        PARERR
         TM        MODESW,X'40'        WERE THERE 2 EXPRESSIONS
         BZ        ONEEXP              BRANCH IF ONE EXPR.
         S         R2,FOUR
         S         R3,FOUR
ONEEXP   L         R8,0(0,R2)
         CH        R8,POSNOMAX         TOO MANY POS PARMS .Q
         BH        PARERR
         A         R8,SIX              ADJUST FOR SYSTEM PARAMETERS
         STC       R8,3(0,R3)          STORE PAR. NO.
         ST        R5,0(0,R2)
SUB3     S         R3,FOUR
         S         R2,FOUR
         CLI       4(R3),VATRREF       TYPE ATTRIBUTE REFERENCE
         BL        SUB1
         SR        R5,R5               CLEAR REGISTER
         IC        R5,7(0,R3)          FETCH PARAMETER NO.
         BAL       R11,POSPAR          LOCATE PARAMETER IN TABLE
         CLI       4(R3),NATT          N ATTRIBUTE
         BE        SUB4
         BAL       R9,POSSUB           LOCATE SUBLIST OPERAND
         CLI       SCPCTR,X'00'
         BNE       GETVAL
SUB4     NI        MODESW,X'3F'        TURN OFF SYSLIST AND EXPR. SW
         B         GETVAL              GET VALUE FROM TABLE
*  GET   SUBSCRIPTED VALUE
SUB1     L         R12,4(0,R2)         FETCH SUBSCRIPT VALUE (N)
         S         R12,ONE             N-1
         BM        PARERR              TEST FOR 0 SUBSCRIPT
         SR        R5,R5               CLEAR REGISTER
         IC        R5,0(,R11)          PICK UP DECLARED
         SLL       R5,8                DIMENSION AND
         IC        R5,1(,R11)          TEST FOR SUBSCRIPT NOT
         CR        R12,R5              WITHIN DECLARATION RANGE
         BNL       PARERR              OUT OF RANGE, GO LOG ERROR
         MVC       SUBADR(4),ZEROS     POINTER TO SUBSCRIPT VALUE
         CLI       4(R3),VSETB         WHAT TYPE OF SET VAR.
         BE        SETB
         BH        SETC
SETA     SLL       R12,2               4*(N-1)
         LA        R12,2(R11,R12)      COMPUTE SUBSCRIPTED ADDRESS
         ST        R12,SAVADR          STORE RESULT ADDRESS
         B         META3
SETB     LPR       R5,R12
         N         R5,SEVEN            DIVIDE VALUE BY 8
*                                       REMAINDER IN R5
*                                       QUOTIENT IN R12
         SRL       R12,3
         STC       R5,BITNO            STORE BIT NO.
         LA        R12,2(R11,R12)      COMPUTE SUBSCRIPTED ADDRESS
         ST        R12,SAVADR          STORE RESULT ADDRESS
         B         METB3
SETC     SR        R5,R5               CLEAR WORK REGISTER
         IC        R5,2(,R11)          GET MAX LENGTH OF SETC'S
         LA        R5,1(0,R5)          ADD 1 FOR LENGTH BYTES
         ST        R5,FWRD             STORE FOR USE IN MH
         MH        R12,FWRD+2          MULTIPLY SUBSCRIPT BY MAX LEN+1
         LA        R12,2(R11,R12)      COMPUTE SUBSCRIPTED ADDRESS
         ST        R12,SAVADR          STORE RESULT ADDRESS
         MVC       SAVLEN(1),2(R11)    SAVE MAX LENGTH SPECIFICATION
KEXTEST  BC        *-*,KATT1           MOD IN KATTBT FOR EXTENDED K'
         B         METC1               PROCESS SETC VARIABLE
*
*    OPERATOR IN TABLE WAS NOT FORCED
*
NOFOR    IC        R5,SCPCTR
         LA        R5,1(0,R5)
         STC       R5,SCPCTR
         TM        SUBSW,X'02'         HAS A.R.E. FLAG BEEN SAVED
         BO        ADVOP
         NC        SUBSW(1),MODESW     SAVE ARE-CRE FLAG
         NI        MODESW,X'FE'        SET A.R.E. FLAG
         OI        SUBSW,X'02'
ADVOP    LA        R4,1(0,R4)          ADVANCE OPERATOR POINTER
         MVC       0(1,R4),0(R10)      ENTER OPERATOR INTO OP TABLE
         CLI       0(R10),VOR
         BL        ADVINP
         OI        MODESW,CREMSK
ADVINP   LA        R10,1(0,R10)        ADVANCE INPUT POINTER
         B         SYMBL
ADVSYS   OI        MODESW,X'40'        SET 2ND EXPR. SWITCH
ADVSS    MVI       OPTAB,DOT           RE-INITIALIZE
         NI        SWITCH,X'FE'
         B         ADVINP
*
*     EXIT FOR VALUAT ROUTINE
*
TEMPEX   CLI       0(R10),VSBCOM
         BE        SBCOM
         CLI       0(R10),VSBCLS
         BE        SBCLS
TEMPX    LM        R1,R6,SVREG
         MVI       KEXTEST+1,X'00'     IN CASE KATTBT NOT RETURNED TO
         CLC       ERRBTS(2),ZERO      ARE THERE EVALUATION ERRORS
         BE        VALRTN
         BAL       R6,CHKERR
         CLC       ERRBTS(2),WARNG     ONLY WARNING MESSAGES
         BC        BE+BL,VALRTN        BRANCH IF ONLY WARNING
ISITMI   TM        MISWIT,X'20'
         BZ        PARAM               BRANCH IF NOT M-I OR PROTOTYPE
         L         R7,MHDR             RESTORE DICTIONARY BASE
         B         MENDST01
*
*    COMPUTED GO TO - FOR APPROPRIATE VALUE ROUTINE
*
NOTOPR   CLI       0(R10),VDUMP        ABOVE RANGE
         BH        SETEND
         SR        R5,R5               CLEAR REGISTER
         IC        R5,0(0,R10)
         SH        R5,LOWLIM           REDUCE SYMBOL TO BASE 0
         AR        R5,R5               DOUBLE
         LH        R9,EVALBR(R5)       FETCH BRANCH OFFSET
         B         ASMGF3(R9)          GO TO THE ROUTINE
*
EVALBR   DC        AL2(DECINT-ASMGF3)  22 HEX. STRING
         DC        AL2(DECINT-ASMGF3)  23 BINARY STRING
         DC        AL2(DECINT-ASMGF3)  24 DECIMAL INTEGER
         DC        AL2(CSD-ASMGF3)     25 CHAR. SELF-DEF. VALUE
         DC        AL2(ADVINP-ASMGF3)  26 SKIP A NULL SYMBOL
         DC        AL2(CHARST-ASMGF3)  27 CHAR. STRING
         DC        AL2(META-ASMGF3)    28 SETA
         DC        AL2(METB-ASMGF3)    29 SETB
         DC        AL2(METC-ASMGF3)    2A SETC
         DC        AL2(SETEND-ASMGF3)  2B COMMA
         DC        AL2(BEGSUB-ASMGF3)  2C BEGIN SUBSTRING
         DC        AL2(SETARE-ASMGF3)  2D SUBSTRING LEFT PAREN
         DC        AL2(SBEND-ASMGF3)   2E CLOSING PAREN. OF EXPR.
         DC        AL2(SBEND-ASMGF3)   2F COMMA BETWEEN EXPR.
         DC        AL2(SETEND-ASMGF3)  30 ACTUAL ) VALUE
         DC        AL2(SETARE-ASMGF3)  31 A.R.E. FLAG
         DC        AL2(SETEND-ASMGF3)  32 BLANK
         DC        AL2(TATTBT-ASMGF3)  33 TYPE ATTRIBUTE
         DC        AL2(LATTBT-ASMGF3)  34 L ATTRIBUTE
         DC        AL2(IATTBT-ASMGF3)  35 I ATTRIBUTE
         DC        AL2(SATTBT-ASMGF3)  36 S ATTRIBUTE
         DC        AL2(ATTPAR-ASMGF3)  37 N ATTRIBUTE
         DC        AL2(ATTPAR-ASMGF3)  38 K ATTRIBUTE
         DC        AL2(PARMTR-ASMGF3)  39 PARAMETER
         DC        AL2(SYSLST-ASMGF3)  3A SYSLIST
         DC        AL2(DUMP-ASMGF3)    3B DUMP
DUMP     DC        X'0001'             FORCE DUMP OF CORE
*
*
SBEND    OI        SWITCH,X'01'        SET SBCOM, SBCLS SW.
SETEND   MVI       OPTAB,COMMA         SET END OPR. IN OPTAB
         B         TSTOP1
*
*
SETARE   NI        MODESW,X'FE'        SET MODE TO ARE
         B         ADVINP
*
*  GET   INTEGER ATTRIBUTE
*
IATTBT   BAL       R9,ATTPAR           CHECK FOR PARAMETER
IATT1    BAL       R9,INCPTR
         BAL       R9,GETSC            GET L' AND S'
         LCR       R9,R8               FETCH -S'
*
*
*    GO TO TYPE OF INTEGER
         CLI       0(R12),ETYPE        IS TYPE MORE THAN E .Q
         BNH       FLOAT               BRANCH IF D OR E
         CLI       0(R12),HTYPE        IS TYPE MORE THAN H .Q
         BNH       FIX                 BRANCH IF F, G OR H
         CLI       0(R12),LTYPE        IS TYPE MORE THAN L .Q
         BNH       EXTND               BRANCH IF K OR L
         CLI       0(R12),PTYPE        IS IT PACKED .Q
         BE        PACKED              BRANCH IF YES
         CLI       0(R12),ZTYPE        IS IT ZONED .Q
         BE        ZONED               BRANCH IF YES
         B         DUMP                SAFETY FIRST
*
*    COMPUTE  I (FLOATING) = 2(L-1)-S            -S-  SCALE
*    COMPUTE  I (EXT.FLTG) = 2(L-2)-S   L.GT.8   -L-  LENGTH
*    COMPUTE  I (PACKED)   = 2L-S-1              -I-  INTEGER
*
FLOAT    BCTR      R9,0                -S-1
PACKED   A         R9,0(0,R2)          ADD L
         A         R9,0(0,R2)          ADD L
PACK1    BCTR      R9,0                ADD -1
PACK2    ST        R9,0(0,R2)          STORE RESULT
PACK3    ST        R2,0(0,R3)
         B         SYMBL
*
* IF K TYPE, WE CAN'T TELL WHAT THE TYPE REALLY IS.  IF LENGTH
*  EXCEEDS 8 BYTES, ASSUME IT IS L-CON.
*
EXTND    CLC       2(2,R2),NINEH       IF LENGTH LT 9 BYTES,
         BL        FLOAT               USE USUAL FLOAT FORMULA
         BCTR      R9,0                ADJUST FOR
         BCTR      R9,0                LOW EXPONENT
         B         FLOAT               GO COMPLETE CALC
*
*    COMPUTE  I (ZONED) = L-S
*
ZONED    A         R9,0(0,R2)          L-S
         B         PACK2
*./      DELETE    SEQ1=28885023,SEQ2=28895023
*
*    COMPUTE I (FIXED) = 8L-S-1
*
FIX      L         R8,0(0,R2)          LOAD L
         SLL       R8,3                8L
         AR        R9,R8               8L-S
         B         PACK1
*
*  GET   LENGTH ATTRIBUTE
*
LATTBT   BAL       R9,ATTPAR           CHECK FOR PARAMETER
LATT1    BAL       R9,INCPTR           ADVANCE POINTERS
         BAL       R9,GETSL            GET ATTRIBUTES
         B         PACK3
*
*  GET   TYPE ATTRIBUTE
*
TATTBT   DS        0H
         BAL       R9,ATTPAR           CHECK FOR PARAMETER
*
TYPEA    DS        0H
         BCTR      R12,0               GET BYTE BEFORE TYPE CHAR
         LA        R5,1                SET THE LENGTH OF TYPE STRING
         B         CHST2
*
*  GET   SCALE ATTRIBUTE
*
SATTBT   BAL       R9,ATTPAR           CHECK FOR PARAMETER
SATT1    BAL       R9,INCPTR           READY POINTERS FOR ENTRY
         BAL       R9,GETSC            GET S'
         ST        R8,0(0,R2)          STORE SCALE ATTRIBUTE
         B         PACK3
*
*        GET K' (COUNT) ATTRIBUTE OF VARIABLE SETC SYMBOL
*
KATTBT   LA        R10,1(0,R10)        BUMP INPUT POINTER
         MVI       KEXTEST+1,X'F0'     NO SUBSCRIPT SETC IN ARITH MODE
         BAL       R9,METINT           FIND THE VARIABLE
KATT1    MVI       KEXTEST+1,X'00'     REVERT BRANCH TO A NOP
         SR        R8,R8               ZERO A WORK REGISTER FOR K'
         IC        R8,1(,R12)          INSERT K' (COUNT) WE WANT
         B         METB1               CONTINUE
*
*    PROCESS DECIMAL INTEGER OR CHAR. SELF-DEF. VALUE
*
CSD      TM        *,255               FORCE CC=1
**NOTE** DECINT USES CONDITION CODE AS SWITCH. CC=1 FOR CSDT.
DECINT   LA        R12,1(0,R10)
         LA        R10,4(0,R10)        ADVANCE R10
DECA     BAL       R9,INCPTR           READY POINTERS FOR ENTRY
         MVC       1(3,R2),0(R12)      STORE VALUE IN GT
         BNL       SYMBL               BR IF NOT CSDT
         TR        1(3,R2),TRSLTB      TRANSLATE BACK TO EBCDIC
         B         SYMBL
DECADENT SR        R9,R9               GET TYPE BYTE FROM PARAM
         IC        R9,1(0,R12)         TABLE
         LCR       R9,R9               SET CC=1 IF CSDT
         AH        R9,HX24
         LA        R12,2(0,R12)        POINT TO BINDARY VALUE
         B         DECA
*
*    PROCESS SETC VARIABLE
*
METC     BAL       R9,METINT
METC1    LA        R12,1(,R12)         POINT AT LENGTH BYTE
METC4    SR        R5,R5               ZERO REGISTER
         IC        R5,0(,R12)          FETCH LENGTH OF STRING
         TM        MODESW,CREMSK       IS IT C.R.E.
         BO        CHST1
*        PROCESS SETC VARIABLE IN ARITHMETIC MODE
         LA        R12,1(,R12)         POINT AT START OF STRING
         LTR       R5,R5               TEST IF NULL STRING
         BZ        SETCER              ERROR IF SO
         SR        R0,R0               CLEAR PICK-UP REG
         LR        R8,R0               CLEAR ACCUMULATOR
         CLI       0(R12),9            TEST IF DECIMAL
         BNH       METCD               BR IF SO
*        TEST EXTEN OPTION
         TM        PARBYT1,X'04'       WAS EXTEN SPECIFIED .Q
         BZ        SETCER              NO, THEN ONLY D.S.D.T VALID
*        ASSUME C, X, OR B SELF-DEFINING TERM
         S         R5,THREE            COMPUTE LENGTH OF DATA
         BNH       SETCER              ERROR IF NO CHARS
         CLI       1(R12),X'31'        CHECK QUOTE AT START
         BNE       SETCER              ERROR IF NOT
         LA        R9,2(R5,R12)        CHECK QUOTE AT END
         CLI       0(R9),X'31'
         BNE       SETCER              ERROR IF NOT
         LR        R9,R12              SAVE PTR TO SETC START
         LA        R12,2(,R12)         POINT TO START OF DATA
         CLI       0(R9),X'0C'         TEST IF TYPE C
         BE        METCC               BR IF SO
         CLI       0(R9),X'0B'         TEST IF TYPE B
         BE        METCB               BR IF SO
         CLI       0(R9),X'21'         TEST IF TYPE X
         BNE       SETCER              ERROR IF NOT
*        HEX SELF DEFINING TERM
         C         R5,EIGHT            TEST FOR TOO BIG
         BH        SETCER              ERROR IF SO
METCX1   IC        R0,0(,R12)          PICK UP CHAR
         C         R0,=F'15'           CHECK HEX CHAR
         BH        SETCER              ERROR IF NOT
         SLL       R8,4                SHIFT ACCUMULATOR
         AR        R8,R0               ADD CHAR TO ACCUMULATOR
         LA        R12,1(,R12)         POINT AT NEXT CHAR
         BCT       R5,METCX1           LOOP ALONG STRING
         B         METC9               DONE
*        BINARY SELF DEFINING TERM
METCB    C         R5,=F'32'           TEST FOR TOO BIG
         BH        SETCER              ERROR IF SO
METCB1   IC        R0,0(,R12)          PICK UP CHAR
         C         R0,ONE              TEST BINARY CHAR
         BH        SETCER              ERROR IF NOT
         SLL       R8,1                SHIFT ACCUMULATOR
         AR        R8,R0               ADD CHAR TO ACCUMULATOR
         LA        R12,1(,R12)         POINT AT NEXT CHAR
         BCT       R5,METCB1           LOOP ALONG STRING
         B         METC9               DONE
*        CHARACTER SELF DEFINING TERM
METCC    LR        R9,R0               CLEAR PICKUP REGISTER
METCC1   IC        R9,0(,R12)          PICK UP ONE CHAR
         CLI       0(R12),X'31'        TEST IF QUOTE
         BE        *+12
         CLI       0(R12),X'2D'        TEST IF AMPERSAND
         BNE       METCC2
         S         R5,ONE              DECREMENT LENGTH AGAIN
         BNH       SETCER              ERROR IF ZERO
         CLC       0(1,R12),1(R12)     CHECK QUOTE OR AMPERSAND DOUBLE
         BNE       SETCER              ERROR IF NOT
         LA        R12,1(,R12)         BUMP STRING PTR
METCC2   IC        R0,TRSLTB(R9)       GET EBCDIC VALUE
         CL        R8,=X'00FFFFFF'     TEST FOR OVERFLOW
         BH        SETCER              ERROR IF 4 CHARS ALREADY
         SLL       R8,8                SHIFT ACCUMULATOR
         AR        R8,R0               ADD CHAR TO ACCUMULATOR
         LA        R12,1(,R12)         POINT AT NEXT CHAR
         BCT       R5,METCC1           LOOP ALONG STRING
         B         METC9               DONE
*        DECIMAL SELF DEFINING TERM
METCD    IC        R0,0(,R12)          PICK UP CHAR
         C         R0,NINE             TEST DECIMAL
         BH        SETCER              ERROR IF NOT
         C         R8,=A((X'7FFFFF'*X'100'+X'FF')/10)  TEST OVERFLOW
         BH        SETCER              ERROR IF SHIFTING MAKES NEG
         MH        R8,TENH             SHIFT ACCUMULATOR BY 10
         AR        R8,R0               ADD CHAR TO ACCUMULATOR
         BO        SETCER              ERROR IF OVERFLOW
         LA        R12,1(,R12)         POINT AT NEXT INPUT CHAR
         BCT       R5,METCD            LOOP ALONG STRING
*        DONE PROCESSING SETC VARIABLE IN ARITHMETIC MODE
METC9    BAL       R9,INCPTR           INCREMENT POINTERS
         ST        R8,0(,R2)           STORE RESULT
         B         SYMBL               DONE
*
*    PROCESS SETA VARIABLE
*
META     BAL       R9,METINT
META3    TM        MODESW,CREMSK       IS IT C.R.E.
         BZ        META2
         MVC       SAV12(4),0(R12)     FETCH BINARY ENTRY
         L         R8,SAV12            LOAD BINARY WORD
META1    BAL       R9,ABCD             CONVERT TO DECIMAL
         B         CHST2
META2    BAL       R9,INCPTR           ADVANCE POINTERS
         MVC       0(GTLEN,R2),0(R12)  STORE VALUE IN GT
         B         SYMBL
*
*    PROCESS SETB VARIABLE
*
METB     BAL       R9,METINT
         IC        R5,BITNO            STORE BIT NO.
METB3    BAL       R9,FNDBIT           FIND SPECIFIED BIT
         TM        MODESW,CREMSK       IS IT C.R.E.
         BO        META1
METB1    BAL       R9,INCPTR           READY POINTERS FOR ENTRY
         ST        R8,0(0,R2)          STORE RESULT IN GTLIST
         B         SYMBL
*
*  PROCESS PARAMETER
*
PARMTR   MVC       5(3,R3),0(R10)
         MVI       4(R3),VPAR
         BCTR      R10,0               BACK UP INPUT PTR.
         B         ATTP
*
*   PROCESS N ATTRIBUTE
*
NATT1    LA        R10,2(0,R10)
         L         R8,PARADR           FETCH PAR. TABLE ADDR.
         IC        R5,0(0,R8)          FETCH N ATTRIB
         LR        R8,R5
         B         METB1
*
*    STORE CHARACTER STRING
*
CHARST   IC        R5,1(0,R10)         FETCH LENGTH OF STRING
         LA        R12,1(0,R10)        GET ADDR. OF BYTE BEFORE STRING
         LA        R10,2(R10,R5)       ADVANCE INPUT POINTER
CHST2    BAL       R9,PUTST
         B         SYMBL
CHST1    EQU       CHST2
*
*   PROCESS SYSLIST
*
SYSLST   MVI       4(R3),VPAR          SIMULATE PARAMETER
SYS1     OI        MODESW,X'80'        SET SYSLIST SWITCH
         LA        R10,1(0,R10)
         B         ATTP2
*
*    SUBROUTINES
*
*
PUTST    TM        MODESW,CREMSK
         BZ        SETCER
         LH        R8,0(0,R6)          STORE PRESENT LENGTH OF BUFFER
         TM        MODESW,STRGSW       IS THERE CONCATENATION
         BO        ADDS
         LA        R3,PTRLEN(0,R3)     PREPARE R3 FOR ENTRY
         ST        R6,0(0,R3)
         MVI       0(R3),VSETC
         OI        MODESW,STRGSW       SET FIRST TIME SWITCH
         B         ADDSTG
ADDS     OI        MODESW,CONCAT       SET CONCAT SWITCH
ADDSTG   LA        R11,2(R6,R8)        ADDR. FOR NEXT ENTRY
         AR        R8,R5
         LTR       R5,R5               IS IT NULL STRING
         BCR       BZ,R9
         TM        MODESW,X'04'        IS IT SUBSTRING MODE
         BO        ADDS1
         CH        R8,H255             STRING GREATER THAN 255
         BH        ERRST2
ADDS1    STH       R8,0(0,R6)
         BCTR      R5,0                TRUE L - 1
         EX        R5,STORE            MOVE STRING TO BUFFER
         BR        R9
*
*
*
*   ***  *  GETSL  ****
*
*  FUNCTION - GET SCALE AND LENGTH ATTRIBUTE
*  PARAMETERS-
*                R12 - POINTS TO TYPE BYTE OF DICTIONARY ENTRY
*    RESULTS-    SCALE - IN R8
*                LENGTH - IN SPECIFIC GT (ASSIGNED BY R2)
*
*        TYPES DEFGH,KL,P AND Z ALLOWED FOR I' AND S' ATTRIBUTE
GETSC    DS        0H
         CLI       3(R12),X'80'        IS THIS EXTENDED EQU .Q
         BE        SLIERR              YES, I' AND S' ARE MEANINGLESS
         CLI       0(R12),DTYPE        IS IT LESS THAN D .Q
         BL        SLIERR              ERROR IF SO
         CLI       0(R12),HTYPE        IS IT MORE THAN H .Q
         BNH       GETSL1              BRANCH IF D,E,F,G OR H
         CLI       0(R12),KTYPE        IS IT LESS THAN K .Q
         BL        SLIERR              ERROR IF SO
         CLI       0(R12),LTYPE        IS IT MORE THAN L .Q
         BNH       GETSL1              BRANCH IF K OR L
         CLI       0(R12),PTYPE        IS IT PACKED .Q
         BE        GETSL1              BRANCH IF P
         CLI       0(R12),ZTYPE        IS IT ZONED .Q
         BE        GETSL1              BRANCH IF Z
         B         SLIERR              ELSE NOT ALLOWED, ERROR
*
*        GENUINE TYPES M,N,O,T,U,$ NEVER SUPPORTED FOR L' ATTRIBUTE
*        ALL OTHERS A-Z SUPPORTED IF NOEXTEN
*        ALL OTHERS X'00'-X'FF' SUPPORTED IF EXTEN
GETSL    DS        0H
         CLI       0(R12),MTYPE        IS TYPE LESS THAN M .Q
         BL        GETSLOK             BRANCH IF YES
         CLI       0(R12),OTYPE        IS TYPE MORE THAN O .Q
         BNH       GETSLERR            POSSIBLE ERROR IF M,N OR O
         CLI       0(R12),TTYPE        IS TYPE LESS THAN T .Q
         BL        GETSLOK             BRANCH IF YES
         CLI       0(R12),UTYPE        IS TYPE MORE THAN U .Q
         BNH       GETSLERR            POSSIBLE ERROR IF T OR U
         CLI       0(R12),WETYPE       IS TYPE $ .Q
         BNE       GETSLOK             CONTINUE IF NOT
GETSLERR DS        0H
         CLI       3(R12),X'80'        IS THIS EXTENDED EQU .Q
         BNE       SLIERR              ERROR IF NOT
GETSLOK  DS        0H
         TM        PARBYT1,X'04'       IS EXTEN ON .Q
         BO        GETSL1              ALL ELSE OK IF YES
         CLI       0(R12),ATYPE        IS TYPE LESS THAN A .Q
         BL        SLIERR              ERROR IF YES
         CLI       0(R12),ZTYPE        IS TYPE MORE THAN Z .Q
         BH        SLIERR              ERROR IF YES
GETSL1   DS        0H
         MVC       FWRD+2(2),1(R12)    ALIGN L' - 2 BYTES
         LH        R8,FWRD+2           GET LENGTH-1
         A         R8,ONE              GET TRUE LENGTH
         ST        R8,0(0,R2)
         SR        R8,R8               ZERO POTENTIAL SCALE
         CLI       3(R1),X'80'         NO SCALE FOR EXTENDED EQU
         BCR       8,R9                RETURN NOW IF YES
         MVC       FWRD+2(2),3(R12)    STORE SCALE ATTRIBUTE
         LH        R8,FWRD+2           PROPAGATE SIGN
         BR        R9
*
*
*   ***  *  INCPTR  ****
*
*    FUNCTION-  1. ADVANCE R3 AND R2 FOR NEXT ENTRY
*               3. SET GT TO ZERO
*               4. STORE POINTER TO GT IN R3
*
INCPTR   LA        R3,PTRLEN(0,R3)     ADVANCE POINTER LIST
         LA        R2,GTLEN(0,R2)      ADVANCE GTLIST POINTER
         MVC       0(GTLEN,R2),ZERO    ZERO OUT GT
         ST        R2,0(0,R3)          STORE ADDRESS OF GT
         BR        R9
*
*   ***  *  FNDBIT  ****
*
*                 R5 - BIT NO. OF BOOLEAN VALUE
*                  R12  -  ADDR. OF BYTE
*  RESULT-
*              R8 - CONTAINS DECIMAL 0 OR 1 IN LOW-ORDER BIT
*
FNDBIT   SR        R8,R8               ZERO OUT REG.
         IC        R5,STG(R5)          STORE APPROPRIATE MASK
         EX        R5,TSTMSK
         BCR       BZ,R9
         LA        R8,1
         BR        R9
*
*
*   ***  *  ABCD   ****
*
*  FUNCTION-   CONVERT BINARY TO DECIMAL
*
*  PARAMETERS-
*                R8 - CONTAINS BINARY VALUE
*  RESULT-
*            R12 - ADDR. OF BYTE BEFORE STRING
*            R5 - LENGTH OF STRING
*
ABCD     CVD       R8,DBLWRD           CONVERT REGISTER
         UNPK      UNPAKD(15),DBLWRD(8)  AND UNPACK
         MVZ       UNPAKD(15),ZEROS    REMOVE ZONES
         STM       R1,R2,SAV12         SAVE REGISTERS R1 AND R2
         LA        R1,UNPAKD
         TRT       UNPAKD(15),FINDEC   LOCATE FIRST NON-ZERO BYTE
         BZ        ALLZER
         LCR       R5,R1
         LA        R5,UNPAKD+15(R5)    TRUE L
         CH        R5,H255             STRING GREATER THAN 255
         BH        ERRST2
ABCD1    LR        R12,R1
         BCTR      R12,0               ADDRESS BEFORE STRING
         LM        R1,R2,SAV12         RESTORE REGISTERS R1 AND R2
         BR        R9
ALLZER   LA        R5,1                LENGTH IS ONE
         B         ABCD1
*
*
*   ***  *  METINT  ****
*
*    FUNCTION-  1. INITIALIZE FOR SETA,  SETB, SETC, VALUES
*               2. CHECK FOR DIMENSIONED SET VARIABLES
*
METINT   MVC       BITNO(1),3(R10)     STORE BIT NUMBER
         BAL       R8,BASONE           COMPUTE TRUE ADDRESS
         ST        R12,SAVADR          STORE RESULT ADDRESS
         MVC       SAVLEN(1),0(R12)    SAVE MAX LENGTH SPEC FOR SETC
         IC        R5,1(0,R10)         STORE TYPE OF VARIABLE
         LA        R10,5(0,R10)        ADVANCE INPUT POINTER
         CLI       0(R10),SPAREN       IS IT DIMENSIONED SET VARIABLE
         BCR       BNE,R9              RETURN IF NOT DIMENSIONED
         LA        R3,PTRLEN(0,R3)     ADVANCE POINTER LIST
         ST        R12,0(0,R3)         STORE TRUE ADDR. AS POINTER
         STC       R5,0(0,R3)
         B         NOFOR
*
*
*    **  ** BASADR ****
*
*    FUNCTION-   OBTAIN TRUE ADDRESS OF  2-BYTE POINTER USING GDBASE
*          BASADR ENTRY-  2-BYTE POINTER AT 2(R10)
*
*    RESULT-
*          R12-  CONTAINS TRUE ADDRESS
*
BASONE   BCTR      R10,0
         L         R12,GDP             INITIALIZE W/ GLOBAL BASE
         TM        BITNO,GLOBAL        GLOBAL SET VARIABLE
         BO        BAS
BASADR   LR        R12,R7              FETCH LOCAL BASE
BAS      MVC       FWRD+2(2),2(R10)
         A         R12,FWRD            TRUE ADDR.
         NI        BITNO,BITSW         TURN OFF BIT SWITCH
         BR        R8
*
*   ****  POSPAR  ****
*
*  FUNCTION-   LOCATE PARAMETER ENTRY IN TABLE
*  PARAMETER-
*         R5 - CONTAINS PARAMETER NO.
*
* RESULT-
*         R12 - ADDR. OF PARAMETER ENTRY
*
POSPAR   ST        R1,STOREGS          SAVE AWAY REGISTERS
         STM       R6,R7,STOREGS+4
         ST        R9,STOREGS+12
         L         R9,PAD              GET CORRECT PARLIST
         LH        R6,0(0,R9)          LENGTH PARAMETER PTR TABLE
         S         R6,TWO              BYTES FOR POS PAR COUNTS
         LA        R9,0(R6,R9)         END PARAMETER PTR TABLE -2
         SR        R7,R7               ZERO POS PARS IN PROTOTYPE
         SR        R1,R1               ZERO POS PARS IN MACRO CALL
         IC        R7,1(0,R9)          NO OF POS PARS IN PROTOTYPE
         IC        R1,0(0,R9)          NO OF POS PARS IN MACRO CALL
         A         R7,SIX              SYSTEM SYMBOLS
         A         R1,SIX              SYS-NDX,ECT,DATE,TIME,STYP,PARM
         TM        MODESW,X'80'        TEST FOR SYSLIST MODE
         BO        SYSLPROC            GO PROCESS SYSLIST NO OF PARAM
         CR        R5,R7               COMP PAR NO TO NO POS IN PROTO
         BH        KYWDPROC            HIGH-PROCESS AS A KEYWORD
         CR        R5,R1               COMP PAR NO TO NO POS IN CALL
         BH        POSNULL             LO-NOT ENOUGH POS PAR IN CALL
         B         POSP                BR PAST KYWRDS PROCESS
KYWDPROC CR        R7,R1               SEE IF ENOUGH POS PAR IN CALL
         BH        POSP                NO-KEYWRD NO OK AS IS
         SR        R1,R7               EXCESS CALLED MINUS DEFINED POS
         AR        R5,R1               SET TO PROPER KYWRD PAR NO
         B         POSP
SYSLPROC C         R5,SIX              SYSLIST MUST BE PAST SYSTEM AND
         BL        PARERR0             LABEL PARAMETERS
         CR        R5,R1               SEE IF SYSLIST PAST POS CALLED
         BH        POSNULL             RETURN NULL STRING
POSP     L         R1,STOREGS          RESTORE REGISTERS
         LM        R6,R7,STOREGS+4
         L         R9,STOREGS+12
         L         R12,PARADR          BEGINNING ADDRESS OF PARAMETERS
         AR        R5,R5               DOUBLE PAR. NO.
         BCR       BZ,R11
         BM        PARERR
         L         R8,PAD              GET CORRECT PARLST
         LH        R9,0(R8,R5)
         A         R5,TWO              ADD TWO BYTES FOR POS PAR COUNT
         N         R9,H01              DROP POSSIBLE PROPAGATED SIGN
         AR        R12,R9
         CH        R5,0(R8)
         BL        POSP1
*                                       TO RETURN NULL STRING
POSNULL  L         R1,STOREGS          RESTORE REGISTERS
         LM        R6,R7,STOREGS+4
         L         R9,STOREGS+12
         LA        R12,NULCON          USE NULL CHAR. STRING
POSP1    ST        R12,SUBADR
         SR        R5,R5
         BR        R11
*
*   ****  POSSUB  ****
*
*  FUNCTION -   LOCATE POSITION OF SUBLIST OPERAND
*
*  PARAMETER-    R12 - ENTRY ADDR. OF PARAMETER
*
*  RESULT-    R12 - POINTS TO TYPE OF N-TH PARAMETER
*
POSSUB   TM        MODESW,X'C0'        SYSLIST W/ TWO EXPR.  BITS 0,1
         BO        POSS1
         BM        SUB4
         CLI       5(R3),VPAR          IS IT SUBSCRIPT. PARAM.
         BNE       SUB4
POSS1    L         R5,4(0,R2)
         LTR       R5,R5
         BNP       PARERR              BR IF SUBSCRIPT ZERO OR MINUS
         CLI       1(R12),VSUB         SUBLIST ENTRY
         BNE       POSS3
         SR        R8,R8               INITIALIZE COUNTER TO ZERO
         LA        R12,7(0,R12)        ADV. TO FIRST PAR. OF SUBLIST
POSS     LA        R8,1(0,R8)          INCREMENT COUNTER
         CR        R8,R5               IS IT SOUGHT PARAMETER
         BE        POSSEX
         MVC       FWRD+2(2),1(R12)
         LH        R11,FWRD+2          FETCH LENGTH
         LA        R12,3(R12,R11)      GET TO NEXT PARAMETER
         CLI       0(R12),X'30'        END OF PARAMETER ENTRY
         BNE       POSS
*
*   SUBLIST REQUEST GREATER THAN NO. OF OPERANDS
*   NULL STRING IS PRODUCED
*
POSS4    LA        R12,NULCON          USE NULL CHAR. STRING
         B         POSS2
POSSEX   LA        R12,3(0,R12)        ADV. TO TYPE BYTE
POSS2    ST        R12,SUBADR
         SR        R5,R5
         BR        R9
POSS3    C         R5,ONE
         BCR       BE,R9
         B         POSS4
*
*   ****  ATTPAR  ****
*
*  FUNCTION-   CHECK FOR PARAMETER
*      R10 - POINTS TO ATTRIBUTE FLAG
*
ATTPAR   MVC       4(4,R3),0(R10)      STORE FLAGS
         CLI       1(R10),VSYLST       IS IT SYSLIST
         BNE       ATPAR1
         CLI       0(R10),NATT         N ATTRIB
         BNE       ATPAR2
         CLI       2(R10),SPAREN
         BNE       NATT1
ATPAR2   LA        R10,1(0,R10)
         B         SYS1
ATPAR1   CLI       1(R10),VPAR         IS IT A SYMBOLIC REF .Q
         BE        ATTP
         CLI       1(R10),VSETC        IS IT EXTENDED K' .Q
         BE        KATTBT              YES, EVALUATE EXTENDED K'
         BAL       R8,BASADR
         LA        R10,4(0,R10)
         BR        R9
ATTP     LA        R10,5(0,R10)
         CLI       0(R10),SPAREN
         BNE       ATTP1
ATTP2    LA        R3,PTRLEN(0,R3)
         B         NOFOR
ATTP1    IC        R5,7(0,R3)          FETCH PAR. NO.
         BAL       R11,POSPAR
*
*   ****  GETVAL  ****
*
*  FUNCTION-   GET VALUE FROM PARAMETER TABLE
*
GETVAL   CLI       4(R3),VATRREF       TYPE ATTRIBUTE REFERENCE
         BE        TYPEA
         CLI       4(R3),NATT          N ATTRIBUTE
         BE        NFETCH
         BL        LSI
         CLI       4(R3),KATT          K ATTRIB
         BNE       PARCHK
KTEM     BAL       R9,POSK             POSITION FOR K ATTRIB
         B         METB1
PARCHK   CLI       7(R3),X'04'         IS IT A SYSTEM PARAMETER
         BH        PARCK3              BRANCH IF NOT
         CLI       7(R3),X'00'         IS IT PAR. 0 - SYSNDX
         BNE       PARCK1              BRANCH IF NOT
         TM        MODESW,CREMSK       IS IT C.R.E.
         BO        PARCK1
         LA        R12,7(0,R12)        POINT TO L BYTE  SYSNDX A.R.E.
         B         META2
PARCK1   LA        R12,2(0,R12)        POINT TO L BYTE  SYSNDX C.R.E.
         B         METC4               OR CSECT
PARCK3   CLI       1(R12),VSYM         SYMBOL ENTRY
         BNE       PARCK4
         TM        MODESW,CREMSK
         BZ        SETCER
         LA        R12,8(0,R12)        POINT TO L BYTE
         B         METC4
PARCK4   CLI       1(R12),VSUB         ENTRY A SUBLIST
         BE        SUBVAL
         CLI       1(R12),VCHAR        CHAR. ENTRY
         BE        PARCK1
         TM        MODESW,CREMSK
         BZ        DECADENT
         LA        R12,6(0,R12)
         B         METC4
SUBVAL   LA        R12,6(0,R12)        POINT TO N ATTRIB OF ENTRY
         MVC       SAV12(1),MODESW
SUBVL1   LA        R5,1
         BAL       R9,PUTST            PUTOUT CHARACTER
         CLI       1(R12),RPARVL       IS IT END OF SUBLIST
         BNE       SUBVL2
         NI        MODESW,X'DF'
         TM        SAV12,STRGSW
         BZ        SYMBL
         OI        MODESW,CONCAT
         B         SYMBL
SUBVL2   LA        R12,4(0,R12)
         BAL       R9,POSK             POSITION FOR NEXT OPERAND
         LR        R5,R8
         LTR       R5,R5
         BZ        SUBVL1
         BAL       R9,PUTST
*                  PUTST REDUCES R5 BY 1
         LA        R12,1(R12,R5)
         B         SUBVL1
LSI      CLI       1(R12),VSUB         PARAM. ENTRY A SUBLIST
         BNE       LSISYM
         LA        R12,10(0,R12)       POINT TO FIRST OPERAND
LSISYM   CLI       1(R12),VSYM         PARAM. ENTRY A SYMBOL
         BNE       SLIERR
         LA        R12,2(0,R12)        POINT TO TYPE ATTRIB
         CLI       4(R3),IATT          L I S ATTRIBUTE
         BE        IATT1
         BL        LATT1
         B         SATT1
NFETCH   SR        R8,R8               ZERO OUT REG.
         CLI       1(R12),VSUB         SUBLIST ENTRY
         BE        NSUB                BRANCH IF YES
         CLI       0(R12),OTYPE        TYPE - OMITTED .Q
         BE        METB1               N' EQUALS ZERO FOR OMITTED
         LA        R8,1                OTHERWISE N' EQUALS ONE
         B         METB1
NSUB     IC        R8,6(0,R12)         FETCH N ATTRIB.
         B         METB1
*
*   ****  POSK  ****
*
* FUNCTION-   GET POSITION FOR K ATTRIBUTE
*
*        R12 - CONTAINS ADDRESS
*        R8- CONTAINS VALUE
*
POSK     SR        R8,R8               ZERO THE EVENTUAL LENGTH
         CLI       1(R12),VSYM         ENTRY A SYMBOL
         BE        POSK2
         CLI       1(R12),VSUB         ENTRY A SUBLIST
         BE        POSK3
         CLI       1(R12),VCHAR        ENTRY A CHARACTER STRING
         BE        POSK1
         LA        R12,4(0,R12)
POSK1    LA        R12,2(0,R12)
POSK4    IC        R8,0(0,R12)
         BR        R9
POSK2    LA        R12,8(0,R12)
         B         POSK4
POSK3    MVC       FWRD+2(2),4(R12)
         LH        R8,FWRD+2
         LA        R12,4(0,R12)
         BR        R9
*
* WRITE TEXT ROUTINE
*
*  ENTRY POINT FOR ADDITIONAL TEXT.
*
WRATXT   LTR       R5,R5               IS IT ZERO LENGTH
         BCR       BZ,R8               RETURN IF ZERO
         STM       R5,R10,REGIST       SAVE CALLER'S REGISTERS
         LM        R6,R8,WRREG         RESTORE WRITE ROUTINE REGS
         BAL       R10,SIZET           GO CHECK MAX SIZE OF OUTPUT REC
FITST    LR        R9,R5
         BAL       R10,TXTMUV          MOVE IN TEXT
         SR        R6,R5               AVAILABLE POSITION LEFT
         LR        R1,R7               SAVE FIELD R/L PTR.
         AR        R7,R5               NEXT AVAIL POS.
         B         GOBAK               GO AND RETURN
WRT1     STC       R5,0(0,R1)          STORE TRUNCATED FIELD R/L
GOBAK    EQU       *
         STM       R6,R8,WRREG         SAVE WRITE ROUTINE REGISTERS
         LM        R5,R10,REGIST       RESTORE CALLER'S REGISTERS
         BR        R8                  RETURN TO CALLING ROUTINE.
TXTMUV   BCTR      R9,0                REDUCE COUNT FOR MOVE.
         EX        R9,EXMOVE           MOVE IN TEXT THAT WILL FIT.
         LA        R9,1(0,R9)
         AH        R9,RLCNT            UPDATE REC LENGTH COUNT.
         STH       R9,RLCNT
         MVC       0(2,R8),RLCNT       PUT REC LENGTH INTO RECORD
         BR        R10                 RETURN
*
*  ENTRY POINT FOR START OF RECORD.
*
WRTRL    STM       R5,R10,REGIST       SAVE CALLER'S REGISTERS
         LM        R6,R8,WRREG         RESTORE WRITE ROUTINE REGISTERS
         SR        R9,R9               CLEAR REG
         STH       R9,CURSIZ           ZERO OUT COUNT FOR NEW REC
         STH       R9,RLCNT            SET RL COUNT TO 0.
         BAL       R10,SIZET           GO CHECK MAX SIZE OF OUTPUT REC
         MVI       FLDSW+1,X'00'       SET TO ZERO
         CH        R6,H255             ENSURE RECORD WILL FIT THIS BUFF
         BNL       RUMAV               GO USE.
         OI        2(R8),X'08'         BREAK BIT
         BAL       R10,RYTO            WRITE BUFFER
         L         R7,WRADD            RESET BUFFER POINTER
         L         R6,OBSIZ            GET MAX BUF SIZE
RUMAV    LR        R8,R7               SET NEW RL ADD.
         B         FITST
*
*        WRITE ROUTINE
*
RYTO     L         R9,OBSIZ            COMPUTE REAL BLOCK LENGTH
         SR        R9,R6
         ST        R9,WRLEN
         L         R1,BUFFENT          WRITE
         CNOP      2,4
         BALR      R0,R1
         DC        A(8,4)
WRADD    DC        F'0'
WRLEN    DC        F'0'
         L         R1,BUFFENT
         CNOP      2,4
         BALR      R0,R1
         DC        A(28,4)
         BR        R10                 RETURN
*
*   ENTRY POINT FOR END OF FILE
*
WREND    STM       R5,R10,REGIST       SAVE CALLER'S REGISTERS
         LM        R6,R8,WRREG         LOAD ROUTINE VALUES
         OI        2(R8),X'80'         SET LAST RECORD FLAG
         BAL       R10,RYTO            OUTPUT CURRENT BUFFER
         LM        R5,R10,REGIST       RESTORE CALLER'S REGISTERS
         BR        R8                  RETURN
*
* *** CHECK MAXIMUM SIZE OF OUTPUT RECORD TO ASSEMBLER.
*
*     IF OVER MAX, CHOP OFF AND FORGET EXTRA.
*     SET RECORD LENGTH FOR MAXIMUM SIZE PLUS ONE BLANK,
*     WHICH IS ADDED.
*
SIZET    LH        R9,FLDSW
         LA        R9,1(0,R9)          INCREMENT FLDSW
         STH       R9,FLDSW
         LR        R9,R5               TRANSFER FIELD LENGTH
         AH        R9,CURSIZ           ADD OLD PARTIAL SUM TO NEW LENGT
         STH       R9,CURSIZ           AND RESTORE PARTIAL SUM
         CH        R9,MAXSIZ           CHECK AGAINST MAX
         BCR       BNH,R10             RETURN IF NOT OVER MAX
         SH        R9,MAXSIZ
         SR        R5,R9               REDUCE OUTPUT COUNT
         BP        SIZEX               OK IF POSITIVE
         LA        R5,1                PUTOUT R/L=0
SIZEX    OI        ERRBTS,MASK0        SET ERROR BIT
         LR        R9,R5               TRANSFER NEW FIELD LENGTH
         BCTR      R9,0                DECREMENT BY ONE
         STC       R9,0(,R11)          SET LENGTH OF FIELD
         CLI       FLDSW+1,X'04'       IS IT A COMMENT FIELD .Q
         BCR       8,R10               RETURN IF YES
         LA        R9,0(R9,R8)         POINT TO LAST OUTPUT CHARACTER
         MVI       0(R9),X'32'         REPLACE LAST CHAR WITH BLANK
         MVI       1(R9),X'00'         PLUS A ZERO TERMINATOR
         LA        R5,1(,R5)           BUMP FIELD LENGTH BY ONE
         BR        R10                 AND RETURN TO FITST
*
EXMOVE   MVC       0(*-*,R7),0(R11)
*
*
*   ***  *  SUBSTRING  ****
*
*  THIS IS A UNIQUE ROUTINE WHICH PROCESSES SUBSTRING OPTION
*    IT   CALLS ON THE -VALUAT- ROUTINE  FOR EXPRESSION VALUES
*
*
BEGSUB   MVC       ENDLEN(2),0(R6)     STORE LENGTH OF STRING IN BUFF.
         OI        MODESW,X'04'        SET SUBSTRING MODE
         B         ADVINP
*
*    CHECK VALUE OF EXPRESSION 1 FOR VALIDITY
*
SBCOM    LH        R11,0(0,R6)         FETCH LENGTH OF BUFFER
         SH        R11,ENDLEN          COMPUTE LENGTH OF STRING
         STH       R11,STGLEN          STORE TRUE LENGTH
         L         R9,0(0,R2)          FETCH VALUE1
         CR        R9,R11              IS VALUE1 GREATER THAN TRUE L
         BNH       SBCOM1
         OI        MODESW,NULLSW       SET NULL SWITCH
SBCOM1   S         R9,ONE              IS VAL1 MINUS OR 0
         BM        ERRST3
         STH       R9,VAL1             STORE VALUE1-1
         B         ADVSS               EVALUATE 2ND EXPR.
*
*    CHECK VALUE OF EXPRESSION 2 FOR VALIDITY
*
SBCLS    TM        MODESW,NULLSW       WAS VAL1 TOO LARGE
         BZ        SBCLS1
         MVC       0(2,R6),ENDLEN
         OI        ERRBTS+1,MASK13
         B         NOSTRG
SBCLS1   L         R5,0(0,R2)
         S         R5,ONE              VALUE2 - 1
         BM        ERRST4
         LH        R8,STGLEN
         SH        R8,VAL1             TRUE L - (VALUE1-1)
         LA        R11,254             MAX LENGTH-1 FOR EXTEN
         TM        PARBYT1,X'04'       WAS EXTEN SPECIFIED .Q
         BO        SBCLEX              BRANCH IF YES
         LA        R11,7               MAX LENGTH-1 FOR NOEXTEN
SBCLEX   DS        0H
         CR        R5,R11              TEST VALUE2 NOT TOO BIG
         BH        ERRST5
SBCLS2   CR        R5,R8               TRUE L - VALUE1 + 1  TEST
         BL        REMAIN
         LR        R5,R8               USE REMAINING CHAR.
         STH       R5,2(0,R2)
         BCTR      R5,0
*
REMAIN   LH        R8,ENDLEN
         LA        R11,2(R6,R8)        ADDR. OF BEGIN OF STRING
         LR        R12,R11
         AH        R12,VAL1
         BCTR      R12,0               ADDR. TO START SUBSTRING
         EX        R5,STORE            STORE STRING IN BUFFER
         AH        R8,2(0,R2)          ADD LENGTH OF SUBSTRING
         STH       R8,0(0,R6)          RESULTING TOTAL LENGTH
         CH        R8,H255
         BH        ERRST2
NOSTRG   MVC       ENDLEN(2),ZERO
         S         R2,EIGHT
         S         R3,EIGHT
         NI        MODESW,X'EB'        TURN OFF ERROR & SUBST. SW.
         OI        MODESW,CREMSK       SET C.R.E. MODE
         B         ADVSS
*
*
*    ****  ERROR ACTION  ****
*
*
*
*    STATEMENT TOO LONG  -   MASK0
*
*
ABT      OI        MISWIT,X'02'        SET ABORT SW.
         ST        R2,TLADR
         BAL       R6,CHKERR
         B         MEND
*
*    SYSLIST EXPRESSION GREATER THAN (POSNOMAX)
*         OR SUBSCRIPT NOT WITHIN ALLOWABLE RANGE
*
PARERR0  L         R1,STOREGS          RESTORE REGS
         LM        R6,R7,STOREGS+4
*
PARERR   OI        ERRBTS,MASK2
         B         TEMPX
*
*    SEQUENCE SYMBOL UNDEFINED
*
NOSEQ    OI        ERRBTS,MASK4
         B         TEMPX
*
* LENGTH, SCALE, INTEGER ATTRIBUTE  -  VALID TYPE
*          OR PARAMETER NOT A SYMBOL
*
SLIERR   OI        ERRBTS,MASK5
         B         TEMPX
*
*   LOOP COUNTER EXCEEDED
*
LOOPER   OI        ERRBTS,MASK6
         BAL       R6,CHKERR
         CLI       BUFFCB+7,8          INSIDE A MACRO .Q
         BE        ENDGEN              BRANCH IF IN OPEN CODE
         L         R7,LDICT1           ADDR. OF OUTSIDE MACRO DICT.
         B         MENDST
ENDGEN   LA        R5,16               LENGTH OF GEN. END RECORD
         LA        R11,GENEND
         BAL       R8,WRTRL            WRITE GEN. END RECORD
         B         ENDST
*
*    GENERATED STRING EXCEEDS 255 CHARACTERS
*
ERRST2   OI        ERRBTS,MASK7
         B         TEMPX
*
*  EXPR  .1 IS 0 OR MINUS
*
ERRST3   OI        ERRBTS+1,MASK8
         B         TEMPX
*
*  EXPR  .2 IS 0 OR MINUS
*
ERRST4   OI        ERRBTS+1,MASK9
         B         TEMPX
*
*   IN A.R.E. CHAR STRING NOT INTEGERS
*        OR PARAMETER NOT SELF-DEFINING TERM
*
SETCER   OI        ERRBTS+1,MASK10
         B         TEMPX
*
*    INVALID OP CODE  -  MACRO INSTRUCTION
*
MACERR   OI        ERRBTS+1,MASK11
         B         ABT
*
*    UNUSED OR MULTIPLY-DEFINED MACRO INSTRUCTION PARAMETER
*
MIERR    OI        ERRBTS+1,MASK12
         ST        R2,TLADR
         B         TEMPX
*
*    EXPR. EXCEEDS LENGTH OF CHAR. EXPR. - SUBSTRING.
*         MASK13
*
*  PRODUCT EXCEEDS LIMITS
*
OVF      OI        ERRBTS+1,MASK14
         B         CONTIN
*
*  EXPR  .2 GREATER THAN 8 - SUBSTRING
*
ERRST5   OI        ERRBTS+1,MASK15
         LA        R5,7                TRUE L - 1
         B         SBCLS2
MASK0    EQU       X'80'
MASK1    EQU       X'40'
MASK2    EQU       X'20'
MASK3    EQU       X'10'
MASK4    EQU       X'08'
MASK5    EQU       X'04'
MASK6    EQU       X'02'
MASK7    EQU       X'01'
MASK8    EQU       X'80'
MASK9    EQU       X'40'
MASK10   EQU       X'20'
MASK11   EQU       X'10'
MASK12   EQU       X'08'
MASK13   EQU       X'04'
MASK14   EQU       X'02'
MASK15   EQU       X'01'
*
*   ****  EXECUTED INSTRUCTIONS  ****
*
*
*
*    SUBSCRIPTED SET VARIABLES
*
STORE    MVC       0(*-*,R11),1(R12)   STORE CHARACTER STRING
*
*    RELATIONAL - ARITH. AND CHAR. EXPRESSIONS
*
BRANCH   BC        *-*,EXEC2           CONDITION CODE PRESET
TRSLT1   TR        2(*-*,R11),TRSLTB
TRSLT2   TR        2(*-*,R12),TRSLTB
CLC1     CLC       2(*-*,R11),2(R12)
*
*    SUBROUTINE - ** FNDBIT **
*
TSTMSK   TM        0(R12),*-*
*
*  MACRO INSTRUCTION
*
COMPR    CLC       12(*-*,R4),12(R10)
*
*        WORK - CONTAINS VALUE
*  MAKE PARAMETER ENRTY
*
ENTER    MVC       0(*-*,R2),0(R12)
*
*
*  STORE PARAMETER TABLE FOR INNER MACRO
*
MOVPAR   MVC       0(*-*,R2),0(R9)
*
*    STORE M-I IN INPUT3
*
MOVMI    MVC       0(*-*,R9),0(R10)    MOVE M-I
*
*   ***    DECLARATIONS  ***
*
DOT      EQU       0                   END OF OPERATOR TABLE SYMBOL
RPAREN   EQU       DOT+1
LPAREN   EQU       RPAREN+1
SPAREN   EQU       LPAREN+1            SUBSCRIPT LPAREN
VPLUS    EQU       SPAREN+1
VMINUS   EQU       VPLUS+1
VMULT    EQU       VMINUS+1
EQUAL    EQU       VMULT+2
VNOT     EQU       EQUAL+6
VOR      EQU       VNOT+1
VAND     EQU       VOR+1
HIOP     EQU       VAND                END OF OPERATORS
VSETA    EQU       DOT+40
VSETB    EQU       VSETA+1
VSETC    EQU       VSETB+1
COMMA    EQU       DOT+43
VSBCOM   EQU       DOT+46
VSBCLS   EQU       DOT+47
NULSYM   EQU       DOT+38
VCHAR    EQU       DOT+39              CHAR. FLAG
VATRREF  EQU       DOT+51
VPAR     EQU       DOT+57
KATT     EQU       DOT+56
IATT     EQU       DOT+53
NATT     EQU       DOT+55
VSYLST   EQU       DOT+58
VDUMP    EQU       DOT+59
CREMSK   EQU       1                   CONDITIONAL RELATION MASK
BITSW    EQU       X'7F'               TURNS OFF BITSW - BIT 0
         LIST1EQU
         EJECT
*
*        SAVE AREA FOR ASMGF3 AND BASE FOR FOLLOWING WORK AREA
*
F3SAVE   DC        18F'0'
         SPACE     2
*
*        PATCH AREA FOR ASMGF3
*
PATCH    DC        10S(*)
         SPACE     2
         LTORG
         SPACE     2
DUMCMNT  DC        X'005300292929320E1B1B181B32292929323232160A0C1B1832X
               0E21190A171C1218173219110A1C0E32191B0E160A1D1E1B0E152232X
               1D0E1B1612170A1D0E0D2E'
         DC        (X'53'-L'DUMCMNT)X'32'
STG      DC        X'8040201008040201'
NULCON   DC        AL1(OTYPE),X'2700'  NULL (OMITTED) CHARACTER STRING
GENEND   DC        X'001040802100000000030E170D013200'
TMBYTE   DC        X'00'               WORK SPACE FOR CORE ALLOCATION
ONE      DC        F'1'
ONEH     EQU       ONE+2
TWO      DC        F'2'
TWOH     EQU       TWO+2
THREE    DC        F'3'
THREEH   EQU       THREE+2
FOUR     DC        F'4'
FOURH    EQU       FOUR+2
SIX      DC        F'6'
SIXH     EQU       SIX+2
SEVEN    DC        F'7'
SEVENH   EQU       SEVEN+2
EIGHT    DC        F'8'
EIGHTH   EQU       EIGHT+2
NINE     DC        F'9'
NINEH    EQU       NINE+2
TEN      DC        F'10'
TENH     EQU       TEN+2
LOW2     DC        X'FFFFFFFC'
LOW3     DC        X'FFFFFFF8'
H01      DC        X'0000FFFF'
H255     DC        H'255'
H256     DC        H'256'
POSNOMAX DC        H'200'              MAX NUMBER OF POS PARMS
LOWLIM   DC        H'34'
WARNG    DC        H'7'                WARNING ERROR BITS ONLY
HX24     DC        H'36'
HIPTRMXL DC        H'416'              MAX BYTE LENGTH OF 'HIPTR' TABLE
ZEROS    DC        XL15'00'
ZERO     EQU       ZEROS
ATTLEN   EQU       5
NULLSW   EQU       X'10'               USE NULL STRING
GTFLAG   EQU       0                   PTRLST FLAG FOR GT
GTLEN    EQU       4                   LENGTH OF GT ENTRY
PTRLEN   EQU       4                   LENGTH OF PTRLST ENTRY
CONCAT   EQU       X'20'               CONCATENATION SWITCH
STRGSW   EQU       X'08'               PUTST SW.
FLAGSVS  DC        AL1(UTYPE),X'2708'  FLAGS FOR SYSTEM VARIABLE SYMBOL
*                                      THIRD BYTE IMPLIES LENGTH OF 8
         SPACE     2
         DS        0D                  ALIGN THE TRANSLATE TABLE
TRSLTB   DC        X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC        X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'
         DC        X'E6E7E8E95B7B7C4E605C616B7E504B4D'
         DC        X'5D7D40333435363738393A3B3C3D3E3F'
         DC        X'324142434445464748494A2E4C2F274F'
         DC        X'2D5152535455565758595A2429305E5F'
         DC        X'282A62636465666768696A2B6C6D6E6F'
         DC        X'707172737475767778797A2526312C7F'
         DC        X'808182838485868788898A8B8C8D8E8F'
         DC        X'909192939495969798999A9B9C9D9E9F'
         DC        X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC        X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC        X'C00A0B0C0D0E0F101112CACBCCCDCECF'
         DC        X'D0131415161718191A1BDADBDCDDDEDF'
         DC        X'E0E11C1D1E1F20212223EAEBECEDEEEF'
FINDEC   DC        X'00010203040506070809FAFBFCFDFEFF'
FLGLEN   EQU       10                  TO GET BY ASS'BLY FLAGS
GLOBAL   EQU       X'80'               GLOBAL SE VARIABLE SWITCH
RPARVL   EQU       X'30'               )
         SPACE     2
*
*        DEFINED AS LABELS FOR DC AND DS INSTRUCTIONS
ATYPE    EQU   X'0A'    A-TYPE, IMPLICIT LENGTH, ALIGNED AND CXD
BTYPE    EQU   X'0B'    BINARY CONSTANT
CTYPE    EQU   X'0C'    CHARACTER CONSTANT
DTYPE    EQU   X'0D'    LONG FLOATING-POINT, IMPLICIT LENGTH, ALIGNED
ETYPE    EQU   X'0E'    SHORT FLOATING-POINT, IMPLICIT LENGTH, ALIGNED
FTYPE    EQU   X'0F'    FULLWORD FIXED-POINT, IMPLICIT LENGTH, ALIGNED
GTYPE    EQU   X'10'    FIXED-POINT CONSTANT, EXPLICIT LENGTH
HTYPE    EQU   X'11'    HALFWORD FIXED-POINT, IMPLICIT LENGTH, ALIGNED
KTYPE    EQU   X'14'    FLOATING-POINT CONSTANT, EXPLICIT LENGTH
LTYPE    EQU   X'15'    EXTENDED FLOATING-POINT, IMPLICIT LEN, ALIGN
PTYPE    EQU   X'19'    PACKED DECIMAL CONSTANT
QTYPE    EQU   X'1A'    Q-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED
RTYPE    EQU   X'1B'    A-,S-,Q-,V- OR Y-TYPE ADDRESS, EXPLICIT LENGTH
STYPE    EQU   X'1C'    S-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED
VTYPE    EQU   X'1F'    V-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED
XTYPE    EQU   X'21'    HEXADECIMAL CONSTANT
YTYPE    EQU   X'22'    Y-TYPE ADDRESS, IMPLICIT LENGTH, ALIGNED
ZTYPE    EQU   X'23'    ZONED DECIMAL CONSTANT
*
*        DEFINED AS LABELS FOR ASSEMBLER STATEMENTS
ITYPE    EQU   X'12'    MACHINE INSTRUCTION
MTYPE    EQU   X'16'    MACRO INSTRUCTION
WTYPE    EQU   X'20'    CCW INSTRUCTION
*
JTYPE    EQU   X'13'    IDENTIFIED AS CONTROL SECTION NAME
*
TTYPE    EQU   X'1D'    IDENTIFIED AS EXTERNAL SYMBOL BY EXTRN
WETYPE   EQU   X'24'    IDENTIFIED AS EXTERNAL SYMBOL BY WXTRN
*
NTYPE    EQU   X'17'    SELF-DEFINING MACRO INSTRUCTION OPERAND
OTYPE    EQU   X'18'    OMITTED MACRO INSTRUCTION OPERAND
*
UTYPE    EQU   X'1E'    UNDEFINED
         SPACE     2
VEND     EQU       X'FF'               END OF STATEMENT FLAG
EOB      EQU       X'FE'               END OF BUFFER FLAG
CONSYM   EQU       EOB                 CONTINUE STATEMENT FLAG
VPUT     EQU       X'FD'               PUT OUT STRING FLAG
KEYFLG   EQU       X'FC'               KEYWORD PARAMETER FLAG
POSFLG   EQU       X'FB'               POSITIONAL PARAMETER FLAG
VSYM     EQU       X'FA'               SYMBOL FLAG
VSUB     EQU       X'F0'               SUBLIST FLAG
CONSUB   EQU       X'F9'               CONTINUE SUBLIST FLAG
EOFLD    EQU       X'F8'               END OF MACH. INSTR. FIELD
ENDREC   EQU       X'0C'               END OF MACRO OR PROTO. REC.
ERRFLG   EQU       X'0D'               ERROR STATEMENT FLAG
PARFLG   EQU       X'0B'
*
*    CONDITION CODES - LEFT JUSTIFIED IN BYTE
*
CONCD    DC        X'80'               EQ
         DC        X'70'               NE
         DC        X'40'               LT
         DC        X'20'               GT
         DC        X'D0'               LE
         DC        X'B0'               GE
*
*    FOLLOWING IS A RATING LIST OF THE OPERATORS
*    IN   THE HIERARCHY TABLE
*
RATING   DC        X'0A09080803030202'
         DC        6X'04'
         DC        X'050706'
*        PARM BYTES FROM ASMGASM
PARBYT1  DC        X'00'
PARBYT   DC        X'00'
PARBYT2  DC        X'00'
PARBYT3  DC        X'00'
         SPACE     2
*        OUTPUT BUFFER CONTROL BLOCK
WRREG    DC        F'0'                AVAILABLE POSITIONS LEFT
         DC        F'0'                NEXT AVAILABLE POSITION
         DC        F'0'                POINTER TO START OF THIS RECORD
*        INPUT BUFFER CONTROL BLOCKS
*        BYTE 0    X'00' ENTRY    X'80' END OF TABLE
*        BYTES 1-3 BUFFER ADDRESS
*        BYTES 4-6 N/P OF THIS RECORD
*        BYTE 7    UT NUMBER
*        THE 2ND BUFFCB ENTRY IS FOR M-I DURING M-I/PROTO PASS
*        THE 1ST BUFFCB ENTRY IS FOR ALL OTHER PURPOSES
BUFFCB   DC        0D'0'
         DC        &UT3BUFF.X'00000000FFFFFF08'
         DC        &UT1BUFF.X'00000000FFFFFF00'
         DC        X'80',7X'00',X'80'  END OF TABLE
R1SAVE   DC        F'0'
RLCNT    DC        H'0'                WORK AREA - HAS CURRENT REC LENG
MAXSIZ   DC        H'248'              MAX. SIZE  FOR ASSEMBLER REC
FWRD     DC        F'0'                2 HI-ORDER BYTES MUST BE ZERO
NDXCNT   DC        F'0'
SAVADR   DC        F'0'                SET STATEMENT RESULT ADDR.
SUBADR   DC        9X'00'
SUBLEN   EQU       SUBADR+4
SAVTYP   EQU       SUBADR+8
SAVBIT   DC        X'00'
SAVLEN   DC        AL1(0)              SETC VARIABLE MAXIMUM LENGTH
SETLEN   DC        AL1(0)              SETC STMT RESULT MAX LENGTH
STGLEN   DC        H'0'
PARCNT   DC        XL9'00'
MACCNT   EQU       PARCNT+2
SWITCH   EQU       PARCNT+4
MISWIT   EQU       PARCNT+5
POSCTR   EQU       PARCNT+6
SCPCTR   EQU       PARCNT+8
BITNO    DC        X'00'               SAVE BIT NO.
ERRREC   DC        X'0006'             R/L
         DC        X'10010000'
ERRNO    EQU       ERRREC+4
SUBSW    DC        X'01'               SUBSCRIPT MODE SWITCH
HIPTR    DC        H'0',AL2(11,22,32,43,51,*-*)  OFFSET OF SYSTEM PARMS
         DS        402C                CONTINUATION OF FIELD 'HIPTR'
         DS        2C                  SPACE FOR NO OF POSNL PARAMS
*                                      IN CALL AND PROTOTYPE
PARLST   EQU       HIPTR+2             ACTUAL BEGINNING OF LIST
         SPACE
STOREGS  DS        4F                  SAVE AREA FOR 4 REGISTERS
CURSIZ   DC        H'0'                CURRENT SIZE OF ASSEMBLER REC
*
*  LOAD   MULTIPLE CONSTANTS
REGCON   DC        A(GTLIST-4)
         DC        A(POINTR-4)
         DC        A(OPTAB)
         DC        F'0'
*
*        COMMON WORK AREA - DOESNT NEED TO BE INITIALIZED
GTLIST   DS        13F                 INTERMEDIATE RESULT AREAS
POINTR   DS        13F                 POINTER LIST
OPTAB    DS        20C                 OPERATOR LIST
DBLWRD   DS        3D
REGIST   EQU       DBLWRD
UNPAKD   EQU       DBLWRD+8
PAD      DS        2F                  PARAMETER PTR. ADDRESS
PARADR   EQU       PAD+4               ADDR. OF PARAMETER TABLE
PARSAV   DS        F
SVREG    DS        6F
SAV2     DS        2F
SAVINP   DS        F                   SAVE INPUT PTR.
RTNVAL   DS        F
SETADR   DS        F
DELTA    DS        F                   SAVE ENTRY ADDR.
MHDR     DS        F
BEGADR   DS        F
TLADR    DS        F
SAV12    DS        2F
LDICT1   DC        F'0'                ADDRESS OF 1ST MACRO DICT
MINOTE1  DC        F'0',H'0'           START OF M-I NOTE/POINT
MINOTE2  DC        F'0',H'0',X'00'     END OF M-I N/P AND SW INIT
SAVNOTE  DC        F'0'
ERRBTS   DC        H'0'                16 BITS - ERROR SWITCHES
SAVRL    DS        H
SECTNM   DC        9X'00'
SECTYP   DC        6X'00'
MODESW   DS        X'00'
STATYP   DS        C                   STATEMENT TYPE
POSCNT   DC        H'0'                NO. OF POSIT. PARAM. - PROTO.
NUMKW    DC        H'0'                NUMBER OF KW .... M-I
RTNNO    DS        C
ENDLEN   DS        H
VAL1     DS        H
*
INPBLK   DS        F
FLDSW    DC        H'0'                FIELD COUNTER
         SPACE     2
*
GDP      DC        A(0)                BEGINNING OF DICTIONARY
DEND     DC        A(0)                END OF DICTIONARY
SSEG     DC        A(0)                UT1 BLOCKSIZE
BOTGOT   DC        F'0'                BOTTOM OF CORE GOTTEN FROM BUFF
INPLEN   DS        F                   UT3 BLOCKSIZE
OBSIZ    DS        F                   SIZE OF OUTPUT 1 AREA
BUFFENT  DS        F                   ADDRESS OF BUFFERING ROUTINE
ADLIST1  DS        F                   ADDRESS OF LIST1 IN ASM
         SPACE     2
L1       DC        129H'0'             256 BYTES + 2
L2       DC        129H'0'             256 BYTES + 2
         SPACE     2
*        THE FOLLOWING DS IS USED TO MAKE F3 ABOUT THE SAME SIZE AS
*            THE OTHER PHASES.
*        THE AREA OCCUPIED BY THE DS IS ALLOCATED TO AN OPTIUM
*            COMBINATION OF I/O BUFFERS AND POSSIBLY THE GLOBAL
*            DICTIONARY BY PHASE F3 INITIALIZATION.
*
LWORKDS  DC        A(DUMLENF3)         LENGTH OF DUMMY WORK AREA
F3END    DC        0D'0'               ALIGN END OF ASMGF3
DUMLENF3 EQU       (24*1024-(F3END-ASMGF3))/256*256  MULT OF 256
WORKDS   DS        (DUMLENF3)X         DIFF IN SIZE TWIXT F1 AND F3.
         SPACE     2
         END       ASMGF3
./ ADD NAME=ASMGF7C
F7C      TITLE     'ASMG F7  MAIN LINE CONTROL'
         ISEQ  73,78
ASMGF7C  START
         SPACE
         PRINT      NOGEN
         FDIMEN
         SPACE 2
*TITLE   'ASMGF7C'  F7 MAIN LINE CONTROL                              *
*FUNCTION/OPERATION-                                                  *
*   PROCESS 'EDITED TEXT RECORDS' WRITTEN BY ASMGF3                   *
*   ADD APPENDED FIXED FIELD AND WORK BUCKETS (IF REQUIRED) TO EDITED *
*    TEXT RECORDS                                                     *
*   BUILD SYMBOL TABLE AND LITERAL TABLE                              *
*   BUILD EXTERNAL SYMBOL DICTIONARY (ESD)                            *
*   GENERATE CROSS-REFERENCE RECORDS                                  *
*   PROCESS LITERALS AND SELF-DEFINING TERMS IN EXPRESSIONS INVOLVING *
*    THE LOCATION COUNTER                                             *
*   MAINTAIN LOCATION COUNTER AND ASSIGN STORAGE LOCATIONS            *
*   DETECT AND LOG ERROR CONDITIONS                                   *
*   WRITE TEXT RECORDS FOR PROCESSING BY F8.                          *
*INPUT-                                                               *
*   REGISTER CRB- ADDRESS OF ASMGF7C                                  *
*   REGISTER ACT- ADDRESS OF ASSEMBLER CONTROL TABLE                  *
*ENTRY POINT-                                                         *
*  ASMGF7C                                                            *
*        CALLING SEQUENCE.                                            *
*        L     CRB,=A(ASMGF7C)                                        *
*        BR    CRB                                                    *
*OUTPUT_ NONE                                                         *
*EXTERNAL ROUTINES-                                                   *
*     NAME     ACT NAME  FUNCTION                                     *
*  ASMGF7N     CTESTR    GENERATE TESTRAN RECORD                      *
*  ASMGF7D     CDCVAL    EVALUATE LITERALS                            *
*  ASMGF7E     CEEVAL    EVALUATE EXPRESSIONS                         *
*  ASMGF7L     CLOGER    ERROR LOGGING                                *
*  ASMGF7I     CTXTIO    PROVIDE ACCESS TO SYSOUT, PUTLBT, AND PHCLS  *
*                        COMMON SUBROUTINES                           *
*  ASMGF7S               MAINTAIN AND EXAMINE SYMBOL TABLE            *
*  ASMGF7E               GENERATE ESD ENTRIES                         *
*EXIT_   BRANCH TO PHCLS (PHASE CLOSE) ROUTINE WITHIN ASMGF7I. PHCLS  *
*         TRANSFERS CONTROL TO ASMGFI (INTERLUDE)                     *
*TABLES_ AOPGO2...COMPUTED GO-TO VALUES FOR ASSEMBLER OP-CODES.       *
         SPACE   2
* BIT MASKS
         SPACE
BIT0     EQU   X'80'                    MASKS WHICH...
BIT1     EQU   X'40'                    ARE...
BIT2     EQU   X'20'                    USED TO...
BIT3     EQU   X'10'                    ACCESS...
BIT4     EQU   X'08'                    BITS WITHIN...
BIT5     EQU   X'04'                    A BYTE...
BIT6     EQU   X'02'                    BY A MEANINGFUL...
BIT7     EQU   X'01'                    NAME...
SETWX    EQU   X'02'                    INDICATES WXTRN
SETEXT   EQU   X'FD'                    PATTERN TO TURN OFF SETWX
         EJECT
*        ERRORS DETECTED BY F/7 MAIN-LINE CONTROL
         SPACE 2
ACER00   EQU   23                       MULTIPLY DEFINED NAME
ACER01   EQU   07                       LOCATION COUNTER WRAP-AROUND
         SPACE
*                                       CNOP
ACER10   EQU   39                       ILLEGAL DELIMITER
ACER11   EQU   30                       ILLEGAL VALUE
ACER12   EQU   25                       RELOCATABLE VALUE
         SPACE
*                                       EQU
ACER20   EQU   39                       ILLEGAL DELIMITER
ACER21   EQU   25                       COMPLEX RELOCATABLE VALUE
ACER22   EQU   108                      INVALID 2ND,3RD EQU ARGUMENTS
         SPACE
*                                       EXTRN, ENTRY
ACER30   EQU   39                       ILLEGAL DELIMITER
ACER31   EQU   18                       INVALID SYMBOL IN OPERAND
         SPACE
*                                       TITLE
ACER40   EQU   73                       NAME ON TITLE CARD AFTER FIRST
ACER41   EQU   16                       NAME FIELD EXCEEDS 4 CHARACTERS
ACER42   EQU   17                       OPERAND EXCEEDS 100 CHARACTERS
         SPACE
*                                       PUNCH, TITLE, MNOTE
ACER50   EQU   84                       OPERAND NOT ENCLOSED IN QUOTES
ACER51   EQU   87                       UNPAIRED QUOTE OR AMPERSAND
         SPACE
*                                       PUNCH
ACER60   EQU   17                       OPERAND EXCEEDS 80 CHARACTERS
         SPACE
*                                       MNOTE
ACER70   EQU   37                       MNOTE STATEMENT
ACER71   EQU   91                       SEVERITY CODE GR 255
ACER72   EQU   39                       ILLEGAL DELIMITER
ACER73   EQU   17                       OPERAND EXCEEDS 100 CHARACTERS
         SPACE
*                                       LTORG
ACER80   EQU   58                       DEFINED IN CSECT OR COM
         EJECT
* AC0 -
         SPACE 2
         USING     ASMGF7C,CRB
         SPACE
***********************************************************************
         SPACE
AC0      TM    CTTSTI(ACT),BIT7         CHECK TESTRAN OPTION
         BO    AC01                     ON, LEAVE TESTRAN GATE OPEN
         OI    AC1+1,X'F0'              OFF, MODIFY PROGRAM TO BYPASS
         OI    QUIT0+1,X'F0'            TESTRAN ROUTINE
         SPACE
AC01     TM    CTXRFI(ACT),BIT6         CHECK X-REF OPTION
         BO    AC02                     ON, LEAVE X-REF GATE OPEN
         OI    MOP2+1,X'F0'             OFF, MODIFY PROGRAM TO BYPASS
         OI    AOP30+1,X'F0'                 TYPE 2 X-REF ROUTINE
         MVI   MOP1D+1,X'00'            MODIFY INSTRUCTION MOP1D       X
                                        NOT TO TURN ON XREF BIT
         SPACE
AC02     B     AC2                      BYPASS TESTRAN FIRST TIME
*
         ORG       AC0
ACTEMP0  DS        F
ACTEMP1  DS        F
         ORG
         EJECT
*
         SPACE 2
AC1      BC    0,ACWRAP                 /MOD BY AC0/ BYPASS TESTRAN
*./      DELETE    SEQ1=02400020,SEQ2=02420020
         L     FRB,CTESTR(ACT)          GET ASMGF7N ADDRESS, AND...
         BALR  CRR,ACT                  BRANCH TO GENERATE TESTRAN REC.
         SPACE
ACWRAP   CLI   CTLOC+0(ACT),0           TEST FOR LOCATION COUNTER
         BE    AC2                                       WRAP-AROUND
         MVC   ACTEMP0,CTLOC(ACT)
         MVC   CTLOC(4,ACT),=X'00FFFFFF'     CALL ORG ROUTINE TO SET
         LA    GR1,=AL2(X'0100'+IBLANK)      HIGH LOC FOR THIS CSECT
         ST    GR1,CTXOFP(ACT)               EQ X'FFFFFF'
         L     GRX,CORG(ACT)                 IF CTLOC GQ X'1000000'
         BAL   CRR,CTLNK2(ACT)          BRANCH TO A.C.T. LINKAGE ALG'RM
         MVC   CTLOC(4,ACT),ACTEMP0          SET SEQ NO. IN CTWRAP7
         CLC   CTLOC+1(3,ACT),CTZERO(ACT)    IF CTLOC GR X'1000000'
         BE    AC2                      DON'T, IF EQ X'1000000'
         MVI   CTLOC+0(ACT),0           ZERO 1ST LOC COUNTER BYTE
         CLC   CTWRAP7(4,ACT),CTZERO(ACT)    IF NOT FIRST TIME HERE,
         BNE   AC2                      SKIP TO TXGET CALL
         MVC   CTWRAP7(4,ACT),CTSEQN(ACT)    ELSE, INSERT SEQ. NUMBER
         SPACE
AC2      L     FRB,CTXGET(ACT)          CALL TXGET TO GET NEXT STATEMNT
         NI    CTEXENSW(ACT),X'FB'      RESET ACT-SWITCH FOR SAF
         BALR  CRR,ACT                  TXGET=ASMGF7X
         SPACE
         TM    TXTO(GRA),BIT0
         BO    AOP                      TXTO EQ ASSEMBLER OP
*        B     MOP                      TXTO EQ MACHINE OP
         EJECT
*
         SPACE 2
MOP      BC    0,MOP1                   /UPC/ BYPASS P.C. TEST
         BAL   CRR,UPC                  TEST UNINITIATED PRIVATE CODE
         SPACE
MOP1     SR    SP1,SP1                  ALIGN LOC COUNTER TO HALF WORD
         LA    SP2,2                    AND SET CTLOC, TXLOC, TXALIN
         BAL   CRR,ALIGN
         CLI   TXHEX(GRA),X'B2'         POSSIBLY PTLB OR IPK .Q
         BNE   MOP0                     BRANCH IF NOT
         CLI   TXR1M(GRA),X'6B'         IS IT IPK .Q
         BE    MOP3                     NO ARGS AT ALL IF SO
         CLI   TXR1M(GRA),X'6D'         IS IT PTLB .Q
         BE    MOP3                     NO ARGS AT ALL IF SO
MOP0     DS    0H
         TM    TXESI(GRA),BIT6          TEST FOR LIT IN OPERAND
         BZ    MOP2                     NONE. SKIP LITERAL EVAL.
*./      DELETE    SEQ1=03180023,SEQ2=03220023
         BAL   CRR,XREF                 MAKE TYPE 2 XREF
         L     FRB,CDCVAL(ACT)          CALL DCEVAL TO EVALUATE LITERAL
         BALR  CRR,ACT                  FUNCT. ROUT. LINKAGE TO ASMGF7D
MOP1D    OI    CTXRFI(ACT),BIT6         RESET XREF BIT
         CLI       0(SP1),IBLANK       ARE WE AT END OF FIELD
         BE        MOP3                YES, DONT XREF
*
*        SET UP TO GO INTO MIDDLE OF XREF ROUTINE
*
         L         CRR,CTXOFP(0,ACT)   GET LAST BYTE OF
         SR        FRB,FRB               OPERAND INTO REGISTER
         IC        FRB,TXOPNL(0,CRR)       FRB FOR XREF
         AR        FRB,CRR
         BAL       CRR,XREF0           XREF TYPE TWO
         B         MOP3                CONTINUE ON
         SPACE
MOP2     BC    0,MOP3                   /AC0/ BYPASS X-REF
         BAL   CRR,XREF                 GENERATE TYPE 2 X-REF RECORDS
         SPACE
MOP3     LA    GRX,2                    TEST HEX CODE FOR OP LENGTH
         TM    TXHEX(GRA),BIT0+BIT1     LOOK AT FIRST TWO BITS
         BZ    AC5                      NO BITS, LEAVE OP. LENGTH TWO
         LR    GR1,GRX                  USE GR1 TO INCREMENT OP  LENGTH
         BM    MOP4                     ONLY ONE BIT, SKIP TO LAST INC.
         AR    GRX,GR1                  DO THIS ONLY FOR BOTH BITS ON
MOP4     AR    GRX,GR1                  GRX NOW HAS FOUR OR SIX
         SPACE
*        GO TO AC5 WITH OP LENGTH IN GRX
         EJECT
*
         SPACE
AC5      LR    GR0,GRX                  STEPLLOCATION COUNTER
         A     GR0,CTLOC(ACT)           WITH OP LENGTH CONTAINED IN GRX
         ST    GR0,CTLOC(ACT)
         SPACE
AC6      CLI   TXNAML(GRA),0            TEST NAME FOR S.T. ENTRY
         BE    AC1                      NONE, GO FINISH STATEMENT
         SPACE
         LTR   GRX,GRX                  SET LEGNTH ATTRIBUTE
         BZ    AC61                     FROM OP LENGTH CONTAINED IN GRX
         BCTR  GRX,0                    LEN ATTR. EQ LEN-1 IF LEN GR 0
AC61     STH   GRX,STLONG(ACT)
         MVC   STVALU+1(3,ACT),TXLOC(GRB)  SET VALUE ATTR FROM TXLOC
         SPACE
AC62     DS    0H
         MVC   ESDID(1,ACT),CESDID(ACT) SET ESDID EQ CURRENT ESD
         SPACE
         MVI   ADJCOD(ACT),7            SET ADJECTIVE CODE
         CLI   CTYPE(ACT),7                 EQ 7 IF CTYPE EQ 5 OR 7
         BE    AC7                          EQ 3 IF CTYPE NQ 5 OR 7
         CLI   CTYPE(ACT),5
         BE    AC7
         MVI   ADJCOD(ACT),3
         SPACE
AC7      DS    0H
         SPACE
AC8      L     SRB,CSTPUT(ACT)          SET SRB FOR S.T. ENTRY
         SPACE 2
AC9      TM    TXMDN(GRA),BIT3          IF MULT. DEFINED NAME FLAG SET,
         BO    AC1                      BYPASS S.T. ENTRY/CHECK
         SPACE
         CLI   TXHEX(GRA),X'1F'         IS OPERATION EQU .Q
         BE    AC91                     YES
         NI    CTEXENSW(ACT),X'FB'      NO, RESET SWITCH IN ACT
AC91     SR    SP2,SP2                  SET STPUT/STGET ENTRANCE PARAM
         IC    SP2,TXNAML(GRA)          SP2 EQ NAME FIELD LENGTH
         LA    SP1,TXNAME(GRA)          SP1 PT TO NAME IN NAME FIELD
         BALR  SRR,SRB                  CALL STPUT OR STGET
         NOP   0                        ABNORMAL EXIT /NOT USED BY MLC/
         LTR   SP1,SP1                  IF NAME NOT PREVIOUSLY DEFINED,
         BZ    AC1                      SP1 WILL BE SET TO ZERO
         SPACE
         OI    TXMDN(GRA),BIT3          MULTIPLY DEFINED, SET TXMDN,
         BAL   SRR,ERROR0               AND LOG ERROR
         DC    AL2(ACER00)
         B     AC1                      BACK TO FINISHING POINT
         EJECT
*
         SPACE 2
AOP      TM    TXASC(GRA),BIT0          TEST ASC FOR UPC CHECK
AOP0     BC    8,AOP2                   /MOD BY UPC/ BYPASS UPC CHECK
         BAL   CRR,UPC
         SPACE
AOP2     TM    TXASC(GRA),BIT2          TEST ASC FOR LOC COUNTER REF.
         BZ    AOP3
         MVC   TXLOC(3,GRB),CTLOC+1(ACT)  MOVE CURRENT LOC CTR TO TXLOC
         SPACE
AOP3     TM    TXASC(GRA),BIT3          TEST ASC
AOP30    BC    8,AOPGO                  /MOD BY AC0/ BYPASS X-REF
         BAL   CRR,XREF                 GENERATE TYPE 2 X-REF
         SPACE 2
*
         SPACE
AOPGO    SR    GR1,GR1                  USE HEX CODE TO CALC. DISPLCMNT
         IC    GR1,TXHEX(GRA)           OF POINTER TO ASSEMBLER OP RTN.
         SH    GR1,AOPGO2               HEX CODE LT X'OE', THEN...
         BM    AC2                      GO GET A NEW STATEMENT
         SLL   GR1,1                    MULT REMNANT BY 2
         LH    GR1,AOPGO2+2(GR1)        GET ADDRESS FROM TABLE
         B     AC0(GR1)                 BRANCH TO PROCESS OPERATION
         EJECT
* ASSEMBLER OP COMPUTED GO-TO DISPLACEMENT VALUES (ASSIGNMENT MODE)
         SPACE 2
AOPGO2   DC    X'000E'                  ASSIGNMENT MODE LOWER LIMIT
         SPACE
         DC    AL2(MNOTE-AC0)           HEX 0E    MNOTE
         DC    AL2(AC1-AC0)                 0F
         DC    AL2(AC1-AC0)                 10
         DC    AL2(AC1-AC0)                 11
         DC    AL2(AC1-AC0)                 12
         DC    AL2(AC1-AC0)                 13
         DC    AL2(AC1-AC0)                 14
         DC    AL2(AC1-AC0)                 15
         DC    AL2(PUNCH-AC0)               16    PUNCH
         DC    AL2(REPRO-AC0)               17    REPRO
         DC    AL2(TITLE-AC0)               18    TITLE
         DC    AL2(ENTRY-AC0)               19    ENTRY
         DC    AL2(EXTRN-AC0)               1A    EXTRN
         DC    AL2(START-AC0)               1B    START
         DC    AL2(CSECT-AC0)               1C    CSECT
         DC    AL2(DSECT-AC0)               1D    DSECT
         DC    AL2(COM-AC0)                 1E    COM
         DC    AL2(EQU-AC0)                 1F    EQU
         DC    AL2(ORG-AC0)                 20    ORG
         DC    AL2(END-AC0)                 21    END
         DC    AL2(LTORG-AC0)               22    LTORG
         DC    AL2(AC1-AC0)                 23    USING
         DC    AL2(AC1-AC0)                 24    DROP
         DC    AL2(DCDS-AC0)                25    LITR
         DC    AL2(DCDS-AC0)                26    DC
         DC    AL2(DCDS-AC0)                27    DS
         DC    AL2(CCW-AC0)                 28    CCW
         DC    AL2(CNOP-AC0)                29    CNOP
         DC    AL2(QUIT-AC0)                2A    QUIT
         DC    AL2(DXD-AC0)                 2B    DXD
         DC    AL2(CXD-AC0)                 2C    CXD
         DC    AL2(OPSYN-AC0)               2D    OPSYN
         DC    AL2(WXTRN-AC0)               2E    WXTRN
         DC    AL2(AC1-AC0)                 2F    POP
         DC    AL2(AC1-AC0)                 30    PUSH
         EJECT
* PROCESS TITLE STATEMENTS (ASSIGNMENT MODE ONLY)
         SPACE 2
TITLE    CLC   CTSEQN(4,ACT),=F'1'      TEST SEQUENCE NUMBER
         BNE   TITLE0                   IF FIRST CARD IS TITLE CARD,
         MVI   EJCTSW(ACT),X'00'        CLEAR F/8 EJECT SWITCH
         SPACE
TITLE0   CLI   TXNAML(GRA),0            TEST NAME FIELD LENGTH
         BE    TITLE4                   ZERO
         SPACE
TITLE1   BC    15,TITLE2                NOP /MOD BY TITLE4/ AFTER FIRST
         BAL   SRR,ERROR0               LOG ERROR IF NAME APPEARS ON
         DC    AL2(ACER40)              OTHER THAN FIRST TITLE CARD
         B     TITLE4                   AND DON'T PROCESS NAME
         SPACE
TITLE2   IC    GR1,TXNAML(GRA)          SAVE NAME LEN IN GR1
         CLI   TXNAML(GRA),4            TEST NAME LEN GR 4
         BNH   TITLE3                   NAME LEN LQ 4, O.K.
         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q
         BO    TITLE3                   YES, USE WITHOUT COMPLAINT
         BAL   SRR,ERROR0               NAME LEN GR 4, LOG ERROR
         DC    AL2(ACER41)                             AND USE FIRST
TITLE5   DS    0H
         LA    GR1,4                                   FOUR CHARACTERS
         SPACE
TITLE3   BCTR  GR1,0                    LENGTH MINUS ONE FOR MVC AND TR
         L     GR2,CTRTBP(ACT)          GR2 PTS TO TRANSLATE TABLE
         EX    GR1,TITLEM               MOVE NAME INTO CONTROL TABLE
         EX    GR1,TITLET               TRANSLATE TO EXTERNAL CODE
         SPACE
TITLE4   NI    TITLE1+1,X'0F'           MODIFY FOR SUBSEQUENT TITLES
         SPACE
         BAL   SRR,SQUASH               MOVE TITLE TO 2ND COMM FIELD
         CLI   0(GRY),100               TEST LENGTH
         BNH   AC1                      GO FINISH, IF NOT TOO LONG
         BAL   SRR,ERROR0               TOOOO BIG, LOG ERROR
         DC    AL2(ACER42)              'DATA ITEM TOO LARGE'
         B     ABORT                    WIPE UP THE MESS
         SPACE
TITLEM   MVC   CTITLE(0,ACT),TXNAME(GRA)
         SPACE
TITLET   TR    CTITLE(0,ACT),0(GR2)
         EJECT
* PROCESS PUNCH AND REPRO (ASSIGNMENT MODE ONLY)
         SPACE 2
PUNCH    BAL   SRR,SQUASH               ENTRY FOR PUNCH - CALL SQUASH
         B     PUNCH0                    SR TO MOVE AND COMPRESS OPND
         SPACE
REPRO    L     GRY,CTXABP(ACT)          ENTRY FOR REPRO - CALL SQUASH
         SR    GRX,GRX                   WITH POINTER TO 2ND COM IN GRY
         IC    GRX,0(GRY)                      LENGTH OF 2ND COM IN GRX
         BAL   SRR,SQUASH8               TO TRANSLATE TO EXTERNAL
         SPACE
         SPACE
         TM    TXERI(GRA),BIT5          TEST FOR PREV. LOGGED ERRORS
         BO    ABORT                    IF SO, ABORT PROCESSING
         L     GR1,CTSEQN(ACT)
         LA    GR1,1(GR1)
         ST    GR1,CTSEQN(ACT)          UPDATE THE SEQUENCE NUMBER
PUNCH0   CLI   0(GRY),80    TEST 2ND COM LENGTH
         BH    PUNCHERR     ERROR IF GR 80
         SPACE
         CLI   CESDID(ACT),0            TEST FOR F/7 PROCESSING
         BNE   AC1                      BYPASS IF CODE HAS BEEN GENERTD
         SPACE
         MVI   CTWORK+0(ACT),X'00'      MOVE CONTROL CHAR
         MVI   CTWORK+2(ACT),C' '       AND CARD IMAGE TO CTWORK
         MVC   CTWORK+3(78,ACT),CTWORK+2(ACT)
         EX    GRX,PUNCHMVC
         SPACE
         L     SRB,CTXTIO(ACT)          PUNCH CARD
         LA    SP1,CTWORK(ACT)
         BAL   SRR,SYSOUT(SRB)          COMMON SUBR. LINKAGE TO ASMGF7I
         SPACE
         B     TRUNCATE                 REMOVE 2ND COM FIELD
         SPACE
PUNCHMVC MVC   CTWORK+1(0,ACT),1(GRY)
         SPACE
PUNCHERR BAL   SRR,ERROR0               OPERAND EXCEEDS 80 CHAR
         DC    AL2(ACER60)              LOG ERROR
         B     ABORT                    AND ABORT PROCESSING
         EJECT
*  PROCESS MNOTE...COMPRESS OPERAND AND MOVE TO SPECIAL WORK BUCKET
    SPACE
MNOTE    L     SP1,CTXOFP(ACT)          FIND OPERAND LENGTH FIELD
         IC    GR1,TXOPNL(SP1)          PICK UP OP'ND LENGTH BYTE
         STC   GR1,MNOTEMV1+1           INSERT INTO 'MVC'
         NI    MNOTESC+1,X'0F'          OPEN GATE TO MNOTE LOGGING
         SR    SP2,SP2                  SEVERITY CODE STARTS AT ZERO
MNOTEMV1 MVC   0(0,GRB),0(SP1)          MOVE OPERAND TO SPECIAL W.B.
         MVI   CTWORK(ACT),IQUOTE       WORK AREA STARTS WITH QUOTE
         MVC   CTWORK+1(33,ACT),1(SP1)  PUT OPERAND IN BEHIND THAT
         CLI   1(SP1),IASTER            IF STARTS WITH *, COMMENT ONLY
         BNE   MNOTE1                   NO, GO CHECK FOR QUOTE
         LA    SP1,2(SP1)               STEP POINTER UP TO THE COMMA
         OI    MNOTESC+1,X'F0'          CLOSE ERROR LOGGING GATE
         B     MNOTE2                   GO TEST REST OF OPERAND
         SPACE
MNOTE1   CLI   1(SP1),IQUOTE            NOT *, MAYBE IT'S A QUOTE
         BE    MNOTE3                   YES, SEV. CODE OMITTED
         LA    SP1,1(SP1)               NO, STEP POINTER FORWARD
         LA    SP2,1                    SEV. CODE 1
         CLI   0(SP1),9                 FIRST BYTE MIGHT BE NUMBER
         BH    MNOTE2                   NO, GO CHECK FOR COMMA
         L     SRB,CEEVAL(ACT)          YES, EVALUATE SEV. CODE
         OI    CTSDVI(ACT),BIT0         SET SELF-DEFINING ERM IND.
         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE
         BNZ   ABORT                    F7V LEAVES CC=0 IF ABS TERM
MNOTE2   CLI   0(SP1),ICOMMA            WE LIKE COMMA AT END OF OP'ND
         BNE   MNOTERR                  AND OBJECT, IF WE NO GET 'EM
         CLI   1(SP1),IQUOTE            ALSO WANT QUOTE TO COME NEXT
         BNE   MNOTERR                  GO REGISTER OBJECTION
         S     SP1,CTXOFP(ACT)          FIND HOW MANY BYTES IN FIRST OP
         EX    SP1,MNOTEMV2             FIRST OP'ND TO SPEC.WRK BUCKET
MNOTE3   ST    SP2,ACTEMP0             PUT DOWN SEV. CODE
         CLC   ACTEMP0(3),CTZERO(ACT)   CHECK LESS THAN 256
         BE    MNOTE4                   OK, DON'T COMPLAIN
         BAL   SRR,ERROR0               BAD SHOW, LOG ERROR
         DC    AL2(ACER71)              'INVALID SELF-DEFINING TERM'
         B     ABORT                    DISGUSTING, GIVE UP
MNOTE4   ST    GRB,CTXOFP(ACT)          SET TO POINT TO NEW W.B.
         BAL   SRR,SQUASH               SQUEEZE THE WORK BUCKET
MNOTESC  BC    0,MNOTE6                 LOGGING GATE SET UP ABOVE
         CLC   ACTEMP0+3,CTSEVCOD(ACT)  LOOK FOR HIGHEST SEV. CODE
         BNH   MNOTE5                   NOT THIS ONE, SO SKIP
         MVC   CTSEVCOD(1,ACT),ACTEMP0+3  FOUND A HIGHER ONE, KEEP IT
MNOTE5   BAL   SRR,ERROR0               LOG ERROR RECORD
         DC    AL2(ACER70)              'MNOTE STATEMENT'
         NI    TXERI(GRA),X'FF'-BIT5    TURN OFF 'ERROR RECORD FOLLOWS'
MNOTE6   NI    TXRT(GRA),X'FF'-BIT3     SET TO PRINT, 'GEN' OR 'NOGEN'
         B     AC2                      GO BACK FOR NEXT STATEMENT
         SPACE
MNOTERR  BAL   SRR,ERROR                LOG ERROR
         DC    AL2(ACER72)              'INVALID DELIMITER'
         B     ABORT                    GIVE UP ON THIS STATEMENT
         SPACE
MNOTEMV2 MVC   1(0,GRB),CTWORK(ACT)     EXECUTED
         EJECT
*        SQUASH...ROUTINE TO REMOVE DOUBLE QUOTES AND AMPERSANDS
         SPACE
SQUASH   L     SP1,CTXOFP(ACT)          ADDRESS OF OPERAND-1
         SR    SP2,SP2                  MAKE ZERO
         IC    SP2,0(SP1)               LENGTH OF OPERAND
         AR    SP2,SP1                  END OF OPERAND, +1
SQUASH0  L     GRX,CTXABP(ACT)          ADDRESS OF SECOND COM FIELD
         LR    GRY,GRX                  ALSO IN GRY
         BCTR  SP2,0                    ADDRESS LAST OPERAND BYTE
         LA    SP1,1(SP1)               ADDRESS FIRST OPERAND BYTE
         CLI   0(SP1),IQUOTE            FIRST BYTE SHOULD BE QUOTE
         BNE   SQUASHE1                 NO, LOG ERROR
SQUASH01 CR    SP2,SP1                  OPND END SHOULD BE PAST START
         BNH   SQUASHE1                 NO, LOG ERROR
         CLI   0(SP2),IQUOTE            LAST BYTE MAY BE QUOTE
         BE    SQUASH2                  YES,START PROCESSING
         BCT   SP2,SQUASH01             NO, MOVE END POINTER AND REPEAT
         SPACE
SQUASHE1 BAL   SRR,ERROR                OPERAND NOT ENCLOSED IN QUOTES
         DC    AL2(ACER50)              LOG ERROR
         B     ABORT                    AND ABORT PROCESSING
         SPACE
SQUASH1  MVC   0(1,GRX),0(SP1)          MOVE BYTE FROM OPND TO 2ND COM
SQUASH2  LA    SP1,1(SP1)               STEP START POINTER
         CR    SP1,SP2                  MAY BE AT OPND END
         BNL   SQUASH4                  YES, GO SET LENGTH INDICATOR
         LA    GRX,1(GRX)               NO, POINT TO NEXT 2ND COM POS'N
         CLI   0(SP1),IQUOTE           MAY BE A QUOTE
         BE    SQUASH3                 YES, GO SEE IF NEXT ONE IS TOO
         CLI   0(SP1),IAMPSD            MAY BE AN AMPERSAND
         BNE   SQUASH1                  NO, GO MOVE THE BYTE
SQUASH3  CLC   0(1,SP1),1(SP1)          NEXT BYTE MAY BE THE SAME
         BNE   SQUASHE2                 NO, UNPAIRED SOMETHING
         LA    SP1,1(SP1)               YES, SKIP THAT BYTE
         CR    SP1,SP2                  CAREFUL ABOUT OPERAND END
         BL    SQUASH1                  OK, NOW MOVE ANOTHER BYTE
         SPACE
SQUASHE2 BCTR  SP1,0                    UNPAIRED QUOTE OR AMPSND
         BAL   SRR,ERROR                LOG ERROR
         DC    AL2(ACER51)              AND ABORT
         B     ABORT
         SPACE
SQUASH4  SR    GRX,GRY                  SET 2ND COM FIELD LENGTH
         BZ    SQUASHE2                 AND INC TXRL
         STC   GRX,0(GRY)
         LA    GR1,1(GRX,GRY)
         SR    GR1,GRA
         STH   GR1,TXRL(GRA)
         SPACE
SQUASH8  L     GR1,CTRTBP(ACT)          ENTRY FOR REPRO
         BCTR  GRX,0                    TRANSLATE 2ND COM FIELD
         EX    GRX,SQUASHTR             TO EXTERNAL CODE
         BR    SRR
         SPACE
SQUASHTR TR    1(0,GRY),0(GR1)
         EJECT
* PROCESS EQU STATEMENTS (ASSIGNMENT MODE)
         SPACE 2
EQU      L     SRB,CEEVAL(ACT)          CALL EXPRESSION EVAL SUBROUTINE
         L     SP1,CTXOFP(ACT)          WITH POINTER TO FIRST BYTE
         LA    SP1,1(SP1)               OF OPERAND IN SP1
         OI    CTPDSI(ACT),BIT2         SET PREVIOUSLY DEF SYMB REQ IND
         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE
         SPACE
         BC    8,EQUABS                 RETURN WITH CC EQ ABS
         BC    4,EQUREL                                   SIMPLY RELOC
         BC    1,EQUABORT                                 ERROR
         BAL   SRR,ERROR0               LOG ERROR         COMPLEX RELOC
         DC    AL2(ACER21)
         B     EQUABORT                 ABORT PROCESSING
         SPACE
EQUREL   MVC   ESDID(1,ACT),5(SP2)      SIMPLY RELOC, SET ESDID
         L     SP2,0(SP2)               SET VALUE IN SP2
         CLC   ESDID(1,ACT),CTNDID+1(ACT) SET ADJ CODE EQ 7
         BH    EQUDSC                     IF DEFINED IN DSECT OR COM
         CLC   ESDID(1,ACT),CTCMSW(ACT)
         BNE   EQUNDC
EQUDSC   LA    GR1,7
         B     EQUSET                   OTHERWISE, ADJ CODE EQ 3
         SPACE
EQUABS   MVI   ESDID(ACT),0             ABSOLUTE, SET ESDID EQ 0
         SPACE
EQUNDC   LA    GR1,3                    ADJCOD EQ 3 IF ABS OR NOT DSCCM
         SPACE
EQUSET   STC   GR1,ADJCOD(ACT)          SET ADJCODE FOR S.T. ENTRY
         ST    SP2,STVALU(ACT)          SET VALUE FOR S.T. ENTRY
*        MVC   TXLOC(3,GRB),STVALU+1(ACT) MOVCE VALUE TO TEXT
*        MVC   TXALIN(1,GRB),ESDID(ACT) MOVE ESDID TO TEXT
         SPACE
         CLI   0(SP1),IBLANK            TEST TERM CHAR EQ BLANK
         BE    AC8                      PUT IN SYMBOL TABLE
         SPACE
         TM    CTEXTENI(ACT),X'04'      WAS EXTEN SPECIFIED .Q
         BZ    EQUDLMER                 DELIM ERROR IF NOT
         CLI   0(SP1),ICOMMA            TEST TERM CHAR EQ COMMA
         BNE   EQUDLMER                 DELIM ERROR IF NOT
         LA    SP1,1(,SP1)              POINT TO NEXT CHAR
         CLI   0(SP1),ICOMMA            NULL SECOND OPND .Q
         BE    EQU3STRT                 LENGTH ONE IF YES
         MVC   STLONGSV,STLONG(ACT)     SAVE DEFAULT LENGTH
         L     SRB,CEEVAL(,ACT)         CALL EXPRESSION EVAL ROUTINE
         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE
         MVC   STLONG(2,ACT),STLONGSV   RESTORE DEFAULT LENGTH
         BNZ   EQUINVER                 BRANCH IF NOT ABSOLUTE
         LTR   SP2,SP2                  IS IT NEGATIVE .Q
         BM    EQUINVER                 ERROR IF YES
         C     SP2,F65535               IS IT TOO BIG .Q
         BH    EQUINVER                 ERROR IF YES
         BCTR  SP2,0                    DECREMENT LENGTH BY ONE
         STH   SP2,STLONG(,ACT)         SAVE RESULT
         SPACE
EQU3STRT DS    0H
         CLI   0(SP1),IBLANK            TEST TERM CHAR EQ BLANK
         BE    AC8                      PUT IN SYMBOL TABLE IF SO
         CLI   0(SP1),ICOMMA            TEST TERM CHAR EQ COMMA
         BNE   EQUDLMER                 DELIM ERROR IF NOT
         LA    SP1,1(,SP1)              POINT TO 3RD ARGUMENT
         MVC   STLONGSV,STLONG(ACT)     SAVE DEFAULT LENGTH
         L     SRB,CEEVAL(,ACT)         CALL EXPRESSION EVAL ROUTINE
         BALR  SRR,SRB                  TO F7V THROUGH ACT LINKAGE
         MVC   STLONG(2,ACT),STLONGSV   RESTORE LENGTH
         BNZ   EQUINVER                 BRANCH IF NOT ABSOLUTE
         LTR   SP2,SP2                  IS IT NEGATIVE .Q
         BM    EQUINVER                 ERROR IF YES
         C     SP2,F255                 IS IT TOO BIG .Q
         BH    EQUINVER                 ERROR IF TOO LARGE
         CLI   0(SP1),IBLANK            TEST TERM CHAR EQ BLANK
         BE    AC8                      YES, PUT IN SYMBOL TABLE
         B     EQUDLMER                 DELIM ERROR IF NOT BLANK
         SPACE
EQUINVER DS    0H
         BAL   SRR,ERROR                LOG ERROR
         DC    AL2(ACER22)              INVALID 2ND,3RD EQU ARGUMENT
         B     EQUABORT                 ABORT PROCESSING
         SPACE
EQUDLMER DS    0H
         BAL   SRR,ERROR                LOG ERROR
         DC    AL2(ACER20)              INVALID TERM DELIM
         B     EQUABORT                 ABORT PROCESSING
EQUABORT B     ABORT
         SPACE
F65535   DC    F'65535'                 MAX EQU ARG TWO
F255     DC    F'255'                   MAX EQU ARG THREE
STLONGSV DC    H'0'                     SAVE FOR EXTENDED EQU LENGTH
         SPACE
         EJECT
* PROCESS CNOP STATEMENTS (ASSIGNMENT MODE ONLY)
         SPACE 2
CNOP     L     SP1,CTXOFP(ACT)
         BAL   CRR,CNOPEVAL             EVALUATE B
         CLI   0(SP1),ICOMMA            TEST FIRST DELIMITER
         BNE   CNOPERR1                 NQ COMMA
         LR    FRB,SP2                  SAVE B VALUE IN FRB
         BAL   CRR,CNOPEVAL             EVALUATE W
         CLI   0(SP1),IBLANK            TEST SECOND DELIMITER
         BE    CNOPGOGO                 EQ BLANK
         SPACE
CNOPERR1 BAL   SRR,ERROR                LOG ERROR,
         DC    AL2(ACER10)              FIRST OR SECOND DELIMITER ERROR
         B     CNOPNOGO                 GO RESET AND GIVE UP
         SPACE
CNOPGOGO BC    0,CNOPNOGO               /ALTERED BY CNOPERRX/
         LA    CRR,CNOPEXIT             SET RETURN REGISTER
         LA    GR0,1                    GET ONE IN A REGISTER
         N     GR0,CTLOC(,ACT)          1 IF ODD, 0 IF EVEN
         A     GR0,CTLOC(,ACT)          HALF WORD ALIGNED LOCATION
         LR    SP1,FRB                  SAVE B VALUE
         N     FRB,=F'1'                FRB MODULO 2
         BNZ   CNOPERR2                 GO LOG ERROR...B MUST BE EVEN
         CLR   SP1,SP2                  B SHOULD BE LT W VALUE
         BNL   CNOPERR2                 OR ELSE, LOG ERROR
         LA    GR1,4                    GR1 GETS FULL-WORD VALUE
         CR    SP2,GR1                  IF IT LOOKS LIKE W VALUE...
         BE    ALIGN                    ALIGN CTLOC, TXLOC, TXALIN
         AR    GR1,GR1
         CR    SP2,GR1
         BE    ALIGN
         SPACE
CNOPERR2 BAL   SRR,ERROR0               LOG ERROR,
         DC    AL2(ACER11)              ILLEGAL VALUE FOR B OR W
         B     ABORT                    ABORT PROCESSING THIS STATEMENT
         SPACE
CNOPEVAL LA    SP1,1(SP1)               STEP TO NEXT BYTE
         ST    SP1,ACTEMP0              STORE ADDRESS FOR A WHILE
         OI    CTPDSI(ACT),BIT2         SET 'DEFINED SYMBOLS REQUIRED'
         L     SRB,CEEVAL(ACT)          READY TO GO TO ASMGF7V
         BALR  SRR,SRB                  AND GO, THROUGH ACT
         BCR   8,CRR                    ABSOLUTE VALUE, OK TO RETURN
         LR    SP2,SP1                  DELIMITER POINTER TO SP2
         BC    1,CNOPERRX               EVAL FOUND SYNTAX ERROR..LOG IT
         L     SP1,ACTEMP0              RESTORE EVAL START POINTER
         BAL   SRR,ERROR                LOG ERROR,
         DC    AL2(ACER12)              RELOCATABLE VALUE FOR B OR W
         SPACE
CNOPERRX OI    CNOPGOGO+1,X'F0'         SET SWITCH TO ABORT PROCESSING
         LTR   SP1,SP2
         BCR   7,CRR                    DELAYED ABORT
         SPACE
CNOPNOGO NI    CNOPGOGO+1,X'0F'         RESET SWITCH
         B     ABORT                    WITHOUT DELAY
         SPACE
CNOPEXIT DS    0H
         CLI   TXNAML(GRA),X'00'        IS THERE A CNOP LABEL .Q
         BE    AC1                      QUIT NOW IF NOT
         ST    GR0,STVALU(,ACT)         SET FORMER LOCATION FOR VALUE
         B     AC62                     GO SET SYMBOL TABLE ENTRY
         EJECT
* PROCESS DC,DS,LDC (ASSIGNMENT MODE)
         SPACE 2
DCDS     L     FRB,CDCVAL(ACT)          CALL DCEVAL
         BALR  CRR,ACT                  ASMGF7D THROUGH ACT
         SPACE
         B     DCDS1                    NORMAL RETURN
         SPACE
         BAL   CRR,SUBWB                ABNORMAL RETURN FOR VCON
         B     DCDS                     SUBSTITUTE IN ASSIGNMENT
         SPACE
DCDS1    L     GRX,CTLEN(ACT)           ASSIGNMENT, SAVE LEN IN GRX
         B     AC6                      AND MAKE S.T. ENTRY
         EJECT
* PROCESS CCW STATEMENTS (ASSIGNMENT MODE ONLY)
         SPACE 2
CCW      SR    SP1,SP1                  SET B EQ 0
         LA    SP2,8                    AND W EQ 8 FOR ALIGNMENT SUBR
         LR    GRX,SP2                  SAVE LENGTH IN GRX FOR INC.
         SPACE
         BAL   CRR,ALIGN                ALIGN LOC COUNTER TO DOUBLE WD.
         SPACE
         B     AC5                      MAKE S.T. ENTRY, INC CTLOC
         EJECT
* PROCESS LTORG STATEMENTS
         SPACE 2
LTORG    MVC   CTWORK(32,ACT),TXFAFL(GRB)   MOVE WORK BKTS TO WORK AREA
         CLI   TXURS(GRB),0             HAS THIS CARD BEEN PROCESSED
         BNE   LTORG1                   YES
         OI    TXURS(GRB),X'FF'         NO,
         LH    GR1,TXRL(GRA)            ADD 2 16 BYTE WORK BUCKETS
         LA    GR1,32(GR1)              TO TEXT AND INC REC LENGTH
         STH   GR1,TXRL(GRA)
         MVI   CTWORK(ACT),0            INITIALIZE WORK BUCKETS TO ZERO
         MVC   CTWORK+1(31,ACT),CTWORK(ACT)
         SPACE
LTORG1   SR    FRB,FRB                  USE FRB FOR TOTAL POOL LENGTH
         LA    GR1,12                   GR1 PTS TO LITA,LITB,WBKT ENTRY
         LA    GR0,4                    GR0 CONTAINS LOOP DEC, COMPARE
         SPACE
LTORG2   L     GR2,CTLITA(ACT,GR1)      CURRENT LENGTH OF LITPOOL STRNG
         ST    GR2,CTWORK(ACT,GR1)      PUT IT IN WORK BUCKET
         AR    FRB,GR2                  UPDATE TOTAL LENGTH, IN FRB
         L     GR2,CTWORK+16(ACT,GR1)   WRK BKT 2. POOL STRING COUNT
         ST    GR2,CTLITA(ACT,GR1)      TO 'LENGTHS' AREA
         A     GR2,CTLITB(ACT,GR1)      ADD CURRENT 1. POOL STRING CNT
         ST    GR2,CTWORK+16(ACT,GR1)   TO WRK BKT 'COUNTS' AREA
         SPACE
         CL    GR2,CTLITA(ACT,GR1)      ANY LITS IN THIS STRING?
         BE    LTORG3                   NO
         OI    TXESI(GRA),BIT6          YES, SET TXESI FOR F/8
         MVI   CTLIT2(ACT),1            SET LIT2 IND EQ GEN LDC
LTORG3   SR    GR1,GR0                  ALL FOUR STRINGS CHECKED?
         BNL   LTORG2                   NO
         CLI       CTLIT2(ACT),1       IF LIT GEN SWITCH
         BE        LTORGA                NOT ON,
         XC        CTLITA(32,ACT),CTLITA(ACT)    THEN ZERO CTLITA
         SPACE
LTORGA   MVC   TXFAFL(32,GRB),CTWORK(ACT)  MOVE WORK BKTS TO TEXT
         SPACE
         SR    SP1,SP1                  ASSIGNMENT MODE...
         LA    SP2,8                    SET FOR DOUBLE-WORD ALIGNMENT
         BAL   CRR,ALIGN                AND ALIGN LOC CNTR FOR LIT POOL
LTORG31  TM    TXESI(GRA),BIT6          LOOK FOR LITERAL IN OPERAND
         BZ    LTORG4                   NO, GO CLEAN UP
         L     SRB,CTXTIO(ACT)          YES, READY TO PUT LIT BASE TABL
         BAL   SRR,PUTLBT(SRB)          PUTLBT IS IN ASMGF7I
         MVC   0(1,SP1),CESDID(ACT)     ESDID TO LIT BASE TABLE BUFFER
         MVC   1(3,SP1),CTLOC+1(ACT)    RELATIVE ADDRESS OF 'LTORG'
         MVC   4(3,SP1),CTWORK+1(ACT)   LENGTH OF 8-BYTE STRING
         MVC   7(3,SP1),CTWORK+5(ACT)             4-BYTE STRING
         MVC  10(3,SP1),CTWORK+9(ACT)             2-BYTE STRING
         SPACE
LTORG4   SR    GRX,GRX                  CLEAR GRX...
         B     AC6                      GO TEST FOR S.T. ENTRY
         EJECT
* PROCESS ORG STATEMENTS (ASSIGNMENT MODE ONLY)
         SPACE 2
ORG      L     GRX,CORG(ACT)            CALL ORG/ESD/ ROUTINE
         MVC   TXLOC+5(3,GRB),CTLOC+1(ACT) SAVE PREVIOUS LOC CTR IN EXT
         BAL   CRR,CTLNK2(ACT)          ASMGF7E VIA FUNC. ROUT. LINKAGE
         SPACE
         MVC   TXLOC(3,GRB),CTLOC+1(ACT)  MOVE NEW LOC COUNTER TO TEXT
         SPACE
ORGEXIT  DS    0H
         CLI   TXNAML(GRA),X'00'        IS THERE AN ORG LABEL .Q
         BE    AC1                      QUIT NOW IF NOT
         MVC   STVALU+1(3,ACT),TXLOC+5(GRB)  TAKE PREVIOUS LOCATION
         B     AC62                     GO SET SYMBOL TABLE ENTRY
         EJECT
* PROCESS START, CSECT, DSECT, COM STATEMENTS
         SPACE
***********************************************************************
START    L     GRX,CSTART(ACT)          START (ASSIGNMENT MODE)
         B     ESDWB0                   GRX IS READY FOR JUMP AT ESDWB2
CSECT    L     GRX,CCSECT(ACT)          CSECT (ASSIGNMENT MODE)
         B     ESDWB0
DSECT    L     GRX,CDSECT(ACT)          DSECT (ASSIGNMENT MODE)
         B     ESDWB0
COM      L     GRX,CCOM(ACT)            COM   (ASSIGNMENT MODE)
*        B     ESDWB0
***********************************************************************
         SPACE
ESDWB0   LA    GR1,TXFAFL(GRB)          LOOK PAST APPENDED FIXED FIELD
         C     GR1,CTXWBP(ACT)          IF 1ST SYMB. WRK BKT IS THERE..
         BE    ESDWB1                   GO SET DSECT-COM INDICATOR
         ST    GR1,CTXWBP(ACT)          SET 1ST SYMB WRK BKT POINTER
         MVI   TXWTYP(GR1),BIT0+BIT4    SET W.B. TYPE 2
         MVC   1(5,GR1),CTZERO(ACT)     ZERO REST OF W.B.
         SR    GR1,GRA                  DISPLACEMENT OF WRK BKT...
         LA    GR1,6(GR1)               PLUS WRK BUCKET LENGTH...
         STH   GR1,TXRL(GRA)            IS TEXT RECORD LENGTH
         SPACE
ESDWB1   NI    CTDORCI(ACT),X'FF'-BIT3  SET CURRENTLY IN DSECT OR COM
         CLI   TXHEX(GRA),X'1D'         INDICATOR
         BL    ESDWB2                   OFF, IF CSECT OR START
         OI    CTDORCI(ACT),BIT3        ON, IF DSECT OR COM
         SPACE
ESDWB2   BAL   CRR,CTLNK2(ACT)         ASMGF7E VIA FUNC. ROUT. LINKAGE
         B     AC1                      GO FINISH STATEMENT
         EJECT
* PROCESS EXTRN, WXTRN AND ENTRY STATEMENTS
         SPACE
***********************************************************************
EXTRN    L     CRR,CEXTRN(ACT)          EXTRN (ASSIGNMENT MODE)
         NI    CTSWXT(ACT),SETEXT       SET SWITCH TO NOT WXTRN
         B     EXT
WXTRN    L     CRR,CEXTRN(,ACT)         WXTRN (ASSIGNMENT MODE)
         OI    CTSWXT(ACT),SETWX        SET SWITCH TO WXTRN
EXT      L     FRB,CTXWBP(,ACT)         POINTER TO FIRST SYMBOL WRK BKT
         LTR   FRB,FRB                  LOOK AT IT CLOSELY
         BNZ   EXTGO                    IF OK, SKIP SYMB. WRK BKT BUILD
         B     EXT0                     NOT YET, SO BUILD SWB
ENTRY    L     CRR,CENTRY(ACT)          ENTRY (ASSIGNMENT MODE)
*        B     EXT0
***********************************************************************
         SPACE
EXT0     LA    FRB,TXFAFL(GRB)
         ST    FRB,CTXWBP(ACT)
         SPACE
         MVC   CTWORK(IALPHA+1,ACT),CTWORK-1(ACT)  SET CTWORK FOR TRT
         MVI   CTWORK+IALPHA+1(ACT),X'FF'          ON NON A/N CHARACTER
         MVC   CTWORK+IALPHA+2(254-IALPHA,ACT),CTWORK+IALPHA+1(ACT)
         L     SP2,CTXOFP(ACT)          ADDRESS OF OPERAND-1
EXT1     MVC   1(5,FRB),CTZERO(ACT)     ZERO SYMB WRK BKT
         MVI   TXWTYP(FRB),BIT0         MAKE SWB TYPE 2
         LA    SP1,1(SP2)               ADDRESS OPERAND FIELD
         TRT   0(256,SP1),CTWORK(ACT)   TEST OPERAND
         LR    SP2,GR1                  GET ADDRESS OF DELIMITER
         SR    GR1,SP1                  RELATIVE TO OPND START
         BNH   EXTERR2                  FIRST NOT ALPHAMERIC, LOG ERROR
         STC   GR1,TXSBLN(FRB)          INSERT SYMBOL BYTE LENGTH
         CLI   TXSBLN(FRB),8            BEST BE LESS THAN 9
         BH    EXTERR1                  NO, LOG ERROR
         CLI   0(SP1),IA                YES, FIRST BYTE SHOULD BE ALPHA
         BC    10,EXT2                  OK, CONTINUE
EXTERR1  BAL   SRR,ERROR                BAD, LOG ERROR
         DC    AL2(ACER31)              'INVALID SYMBOL'
         B     EXT3                     GO LOOK FOR COMMA AT END
EXT2     S     SP1,CTXOFP(ACT)          FROM CTXOFP TO SP1...
         BCTR  SP1,0                    -1, = RELATIVE POS'N OF SYMBOL
         STC   SP1,TXSPTR(FRB)          SET POINTER TO SYMBOL IN OPND
         LA    FRB,6(FRB)               NEXT SYMB WK BKT ADDRESS...
         LR    GR1,FRB                  TO GR1, THEN...
         SR    GR1,GRA                  POS'N RELATIVE TO TEXT FBA...
         STH   GR1,TXRL(GRA)            BECOMES CURRENT TEXT REC. LNGTH
EXT3     CLI   0(SP2),ICOMMA            OPND MAY END WITH COMMA
         BE    EXT1                     YES, GO BACK, START ANOTHER SWB
         CLI   0(SP2),IBLANK            NO, LOOK FOR BLANK
         BE    EXT4                     BLANK, END OF OPND FIELD
         S     FRB,=F'6'                NOT BLANK OR COMMA, BACK UP FRB
         LH    GR1,TXRL(GRA)            ERASE LAST SYMB WK BKT...
         S     GR1,=F'6'                SHORTEN TEXT LENGTH...
         STH   GR1,TXRL(GRA)            AND RESTORE TO ACT
         LR    SP1,SP2                  POINT TO BAD CHARACTER WITH SP1
EXTERR2  BAL   SRR,ERROR                LOG ERROR
         DC    AL2(ACER30)              ILLEGAL DELIMITER
EXT4     LA    GR1,6                    MAKE A 6...
         SR    FRB,GR1                  SUBTRACT IT FROM SWB ADDRESS
         CR    FRB,GRB                  SEE IF ALL W.B.'S WERE ERASED
         BNH   AC2                      YES, GO PROCESS ANOTHER STATMNT
         OI    TXESI(GRA),BIT6          SET FLAG TO CALL ASMGF7E
         OI    TXSESL(FRB),BIT0         SET LAST ENTRY IN OPERAND
         SPACE
EXTGO    TM    TXESI(GRA),BIT6          LOOK AT ASMGF7E FLAG
         BZ    AC2                      OFF, RETURN TO GET NEXT STATMNT
         LR    GRX,CRR                  SET ROUTINE SELECTED BY ENTRY..
         BAL   CRR,CTLNK2(0,ACT)        TO ASMGF7E VIA FUNC. ROUT. LINK
         B     AC1                      RETURN TO FINISH STATEMENT
         EJECT
* PROCESS END STATEMENT
         SPACE 2
END      L     GR1,CTLITB+00(ACT)       CHECK LITERAL POOL
         A     GR1,CTLITB+04(ACT)       FOR ACTIVE ENTRIES
         A     GR1,CTLITB+08(ACT)
         A     GR1,CTLITB+12(ACT)
         BZ    AC1                      NONE, GO FINISH UP
         SPACE
         TM    TXESI(GRA),BIT6          HAS LTORG BEEN GENERATED
         BO    AC1                      YES, GO FINISH STATEMENT
         SPACE
         MVI   CTLIT2(ACT),4            NO, SET FLAG TO GENERATE LTORG
         OI    TXESI(GRA),BIT6          FLAG TO INDICATE LTORG GEN'D
         CLC   CTESRN(2,ACT),CTZERO(ACT) DO WE HAVE A CSECT .Q
         BNE   END1                     YES
         BAL   CRR,UPC1                 NO, WELL INITIATE ONE
END1     B     AC1                      GO FINISH STATEMENT
         EJECT
* PHASE 7 WRAP-UP (QUIT STATEMENT GENERATED BY EOF IN ASSIGNMENT MODE)
         SPACE 2
QUIT     OI    CTPH7C(ACT),BIT6         SET F/7 COMPLETE INDICATOR
         SPACE
         L     GRX,CQUIT(ACT)           CALL ESD WRAP-UP ROUTINE
         BAL   CRR,CTLNK2(0,ACT)        ASMGF7E VIA FUNC. ROUT. LINKAGE
         SPACE
QUIT0    BC    0,QUIT1                  /MOD BY AC0/
         L     FRB,CTESTR(ACT)          TO CALL TESTRAN ROUTINE
         BALR  CRR,ACT                  IF TESTRAN OPTION BIT IS ON
         SPACE
QUIT1    L     SRB,CTXTIO(ACT)          TRANSFER CONTROL TO NEXT PHASE
         B     PHCLS(SRB)               VIA PHASE CLOSE ROUTINE
         EJECT
* PROCESS DXD, CXD
         SPACE 2
DXD      MVC   ACTEMP0(4),CTLOC(ACT)    SAVE LOC'N COUNTER
         MVC   CTLOC(4,ACT),=F'1'       AND PUT BACK 1
         MVC   TXLOC(3,GRB),CTLOC+1(ACT) PUT THE 1 INTO TEXT RECORD TOO
         SPACE
DXDS     L     FRB,CDCVAL(0,ACT)       CALL ASMGF7D VIA FUNCTIONAL ROU-
         BALR  CRR,ACT                  TINE LINKAGE IN ACT
         B     DXD1                     NORMAL RETURN, CONTINUE PROC'NG
         BAL   CRR,SUBWB                ABNORMAL, ATTACH SYMB WK BKT...
         B     DXDS                     AND TRY AGAIN
         SPACE
DXD1     L     GRX,CDXD(0,ACT)          CALL ASMGF7E VIA...
         BAL   CRR,CTLNK2(ACT)          FUNC. ROUT. LINKAGE
         MVC   CTLOC(4,ACT),ACTEMP0     RESTORE LOC COUNTER
         B     AC1                      FINISH STATEMENT
         SPACE 2
CXD      SR    SP1,SP1                  SET PARAM REGS...SP1=0
         LA    SP2,4                    SP2=4
         LR    GRX,SP2                  GRX=4  FOR 0,4 ALIGNMENT
         BAL   CRR,ALIGN                ALIGN LOC CNTR
         B     AC5                      RETURN TO STEP LOC COUNTER
         EJECT
* PROCESS OPSYN
         SPACE 2
         EXTRN OPC04                    OP-TABLE ACCESS, F7X
         SPACE ,
OPSYN    L     SP1,CTXOFP(,ACT)         POINT TO OPND LENG FIELD
         SR    SP2,SP2
         IC    SP2,0(,SP1)              ADJUST LENGTH FOR BLANK
         BCTR  SP2,0
         SR    GRZ,GRZ                  PRE-SET TO ZERO
         CLI   TXOPN(SP1),IBLANK        CHECK OMITTED OPND
         BE    OPS02                    YES, BYPASS LOOKUP
         BAL   SRR,OPSLUP               NO, LOOK IT UP
         B     AC2                      NOT FOUND, OVERFLOWED
         LR    GRZ,SP2                  SAVE ATTRIBUTES PNTR
OPS02    LA    SP1,TXNAML(,GRA)         POINT TO NAME LENG FIELD
         SR    SP2,SP2
         IC    SP2,0(,SP1)              GET LENGTH
         BAL   SRR,OPSLUP               LOOK IT UP
         B     OPS06                    NOT FOUND
         LTR   GRZ,GRZ                  CHECK DELETE
         BNZ   OPS04                    NO
         MVI   0(SP1),0                 DELETE IT
         B     AC2                      EXIT
OPS04    MVC   0(3,SP2),0(GRZ)          CHANGE ATTRIBUTES
         B     AC2
OPS06    LTR   GRZ,GRZ                  CHECK DELETE
         BZ    AC2                      YES, OVERFLOWED
         EX    0,OPS04                  SET ATTRIBUTES
         SR    SP1,SP1
         IC    SP1,CTWORK(,ACT)         GET LENGTH
         LA    FRB,3(,SP1)              SAVE ITEM LENGTH - 1
         LA    SP1,7(,SP1)              FORM TOTAL NEEDED
         L     SRB,CSTROM(,ACT)         GO CHECK FOR ROOM
         BALR  SRR,SRB
         NOP       0                    THIS RETURN NEVER TAKEN
         L     GR1,CTSYMP(,ACT)         SYMBOL TABLE PNTR
         L     GR2,CFREEP(,ACT)         REL FREE PNTR
         LA    GRX,OPCPTR(,GR1)         OPSYN CHAIN PNTR
         ALR   GR1,GR2                  FULL FREE PNTR
         MVC   0(3,GR1),0(GRX)          BACK CHAIN NEW ITEM
         MVC   0(3,GRX),CFREEP+1(ACT)   NEW OPSYN CHAIN PNTR
         EX    FRB,OPMOVE               MOVE IN NEW ITEM
         LA    GR2,4(FRB,GR2)           UPDATE FREE PNTR
         ST    GR2,CFREEP(,ACT)
         B     AC2                      EXIT
OPMOVE   MVC   3(0,GR1),CTWORK(ACT)     DUMMY MOVE
         EJECT
* OP-CODE LOOKUP FOR OPSYN
* ENTRY-  SP1 POINTS TO LENGTH FIELD IN TEXT
*         SP2 CONTAINS TRUE SYMBOL LENGTH
* EXIT -  SP1 POINTS TO SYMBOL IN TABLE IF FOUND
*         SP2 POINTS 1 PAST SYMBOL IN TABLE OR IN WORK AREA
*        BR    SRR     - NOT FOUND RETURN
*        B     4(SRR)  - FOUND RETURN
         SPACE 2
OPSLUP   STC   SP2,CTWORK(,ACT)         SET UP LENGTH
         MVC   CTWORK+1(8,ACT),1(SP1)   AND SYMBOL
         LA    GR1,5
         CLR   SP2,GR1                  IF LONGER THAN 5
         BH    OPSL07                   SKIP OP TABLE SEARCH
         LR    GRY,SP2
         BCTR  GRY,0                    FORM L - 1
         STC   GRY,OPSL02+1             SET COMPARE
         SLL   GRY,2                    4(L-1)
         L     GR1,OPCAD                ACCESS 7X OPTABL POINTERS
         L     SP1,0(GRY,GR1)           SET START
         L     GRY,4(GRY,GR1)           SET LIMIT
         LA    GRX,3(,SP2)              SET INCREMENT
OPSL02   CLC   CTWORK+1(0,ACT),0(SP1)   COMPARE SYMBOL
         BH    OPSL06                   KEEP SEARCHING
         BL    OPSL07                   FAR ENOUGH, TRY OPSYN TAB
OPSL04   LA    SP2,0(SP2,SP1)           STEP OVER SYMBOL
         B     4(,SRR)                  FOUND RETURN
OPSL06   BXLE  SP1,GRX,OPSL02           CHECK NEXT IF ANY
OPSL07   MVI   CTWORK+16(ACT),0         SET UP CHAIN-LOADER
         L     GR1,CTSYMP(,ACT)         GET SYMBOL TABLE BASE
         LA    SP1,OPCPTR(,GR1)         ACCESS OPSYN CHAIN
         STC   SP2,OPSL09+1             SET COMPARE
OPSL08   MVC   CTWORK+17(3,ACT),0(SP1)  GET CHAIN POINTER
         L     SP1,CTWORK+16(,ACT)
         LTR   SP1,SP1                  IS THIS END OF CHAIN
         BZ    OPSL12                   YES, GIVE UP
         ALR   SP1,GR1                  FORM FULL POINTER
OPSL09   CLC   CTWORK(0,ACT),3(SP1)     COMPARE L AND SYMBOL
         BNE   OPSL08                   NO MATCH
         LA    SP1,4(,SP1)              STEP OVER POINTER AND L
         B     OPSL04                   TO FOUND EXIT
OPSL12   LA    SP2,CTWORK+1(SP2,ACT)    POINT PAST WORK SYMBOL
         BR    SRR                      NOT FOUND RETURN
OPCAD    DC    A(OPC04)                 OP TABLE POINTERS,FLAG
OPCPTR   EQU   28                       OPSYN CHAIN DISPLACEMENT
         EJECT
* ALIGN - SUBROUTINE TO ALIGN LOC COUNTER FOR MOP, CNOP, CCW AND LTORG
*         ENTER WITH SP1 EQ B, SP2 EQ W, CRR EQ RETURN ADDR
*         SET CTLOC, TXLOC AND TXALIN
         SPACE 2
ALIGN    LR    GR1,SP2                  W EQ 2,4 OR 8
         BCTR  GR1,0                    SET MASK Q  1,3 OR 7
         N     GR1,CTLOC(ACT)           MASK LOW 1,2 OR 3 BITS OF CTLOC
         CLR   GR1,SP1                  COMPARE WITH B
         BE    ALIGN3                   NO ALIGNMENT REQUIRED
         BL    ALIGN1                   B GR MASKED BITS
         LA    SP1,0(SP1,SP2)           B LS MASKED BITS, ADD W
ALIGN1   SR    SP1,GR1                  B MINUS MASKED BITS
         STC   SP1,ALIGN2+1             STORE NUMBER OF ALIGN BYTES
         A     SP1,CTLOC(ACT)           INC LOC COUNTER
         ST    SP1,CTLOC(ACT)
ALIGN2   OI    TXALIN(GRB),0            SET NUMBER OF ALIGN BYTES
ALIGN3   MVC   TXLOC(3,GRB),CTLOC+1(ACT)  MOVE ALIGNED LOC CTR TO TEXT
         BR    CRR                      RETURN
         EJECT
* UPC - UNINITIATED PRIVATE CODE TEST (CALLED ONCE FROM MOP AND AOP0)
         SPACE 2
UPC      OI    MOP+1,X'F0'              MODIFY MLC TO BYPASS UPC
         OI    AOP0+1,X'F0'
         SPACE
         CLI   CESDID(ACT),0            TEST CURRENT ESD ID
         BCR   7,CRR                    IF NOT ZERO, BYPASS UPC
         SPACE
UPC1     DS    0H
         L     GRX,CUPC(ACT)            IF ESDID EQ ZERO,
         B     CTLNK2(ACT)              CALL UNINITIATE P.C. ROUTINE
         EJECT
         SPACE 2
ERROR0   SR    SP1,SP1                  NO ERROR POINTER TO F7L
ERROR    L     SRB,CLOGER(ACT)          GET ADDRESS OF ERROR LOGGER...
         BR    SRB                      AND GO THERE
         SPACE 2
ABORT    NI    TXTO(GRA),X'3F'          SET OP TYPE 'UNCHECKED'
         SPACE
TRUNCATE L     GR1,CTXABP(ACT)          APPENDED FIXED FIELD POINTER
         MVI   0(GR1),0                 ZERO FIRST BYTE---
         SR    GR1,GRA                  CALCULATE DISTANCE TO
         LA    GR1,1(GR1)               LAST RECORD BYTE
*        STH   GR1,TXRL(GRA)            INSERT INTO TEXT RECORD LENGTH
         B     AC2                      GO GET NEXT STATEMENT
         EJECT
* XREF - SUBROUTINE CALLED BY ACMOP  AND  ACAOP
*        TO GENERATE TYPE 2 X-REF RECORDS
*        FOR STATEMENTS WHICH ARE NOT EVALUATED BY PHASE 7
         SPACE 2
XREF     L         SP1,CTXOFP(0,ACT)   SP1 POINTS TO OPERAND-1
         SR        FRB,FRB
         IC        FRB,TXOPNL(0,SP1)   FRB POINTS TO LAST BYTE
         AR        FRB,SP1               OF OPERAND
XREF0    MVC   ACTEMP0(4),CLOGER(ACT)   DISABLE EEVAL ERROR LOGGING
         MVC   ACTEMP1(4),CTXWBP(ACT)   KEEP POINTER TO 1ST SYMB WK BKT
         LA    GR1,XREFX                GET ERROR HANDLING ADDRESS...
         ST    GR1,CLOGER(ACT)          AND INSERT IN ACT
         SPACE
         L     SRB,CEEVAL(ACT)          SRB PTS TO EEVAL
         SPACE
XREF1    LA    SP1,1(SP1)               SP1 PTS TO NEXT EXPRESSION
         CLR   SP1,FRB
         BC    11,XREFEXIT              EXIT IF END OF OPERAND
         CLI   0(SP1),IALPHA            IF NEXT EXPRESSION STARTS ALPHA
         BNH   XREF2                    OK, MAKE XREF
         CLI   0(SP1),IEQUAL            NO, LOOK FOR EQUAL
         BE    XREFEXAT                 YES, TO RESET ERROR RETURN
         B     XREF3                    MORE CHECKS TO BE MADE
         SPACE
XREF2    DS    0H
         BALR  SRR,SRB                  SCAN NEXT EXPRESSION
         BO    XREF4                    BRANCH IF ERROR
XREF3    DS    0H
         TM    TXTO(GRA),BIT0           IS THIS AN ASSEMBLER OP .Q
         BNO   XREF1                    BRANCH TO NEXT EXPRESSION IF NO
         CLI   TXHEX(GRA),X'21'         IS THIS AN END STATEMENT .Q
         BNE   XREF1                    NO, CHECK NEXT EXPRESSION
         B     XREFEXIT                 YES, FORGET FURTHER OPERANDS
XREF4    DS    0H
         SPACE
         LTR   SP1,SP1                  ERROR,
         BNE   XREF1                    CONTINUE SCAN IF POSSIBLE
         SPACE
XREFEXIT MVC   CTXWBP(4,ACT),ACTEMP1
XREFEXAT MVC   CLOGER(4,ACT),ACTEMP0    RESTORE ASMGF7L ADDRESS
         BR    CRR                      RETURN
         SPACE
XREFX    B     2(SRR)                  SUBSTITUTED ASMGF7V ERROR RETURN
         EJECT
* SUBWB - S/R TO ATTACH AND FILL SYMBOL WORK BUCKETS
         SPACE 2
SUBWB    L     FRB,CTXWBP(ACT)          BYPASS SCAN IF WORK BUCKETS
         LTR   GRZ,FRB                  PREVIOUSLY ATTACHED
         BNZ   SUBWBA                   HAVE BUCKETS, WILL SKIP
         SPACE
         MVC   CTWORK(256,ACT),CTWORK-1(ACT)  INITIALIZE TRT TABLE
         MVI   CTWORK+IQUOTE(ACT),X'FF'
         LA    GRY,2                    GRY CONTAINS LPARN COUNT (=2)
         L     GR1,CTXOFP(ACT)          GR1 PTS TO NEXT OPND BYTE-1
         IC    GRZ,0(GR1)
         AR    GRZ,GR1
         SR    GRZ,GRY                  GRZ PTS TO FINAL OPND BYTE-2
         LH    FRB,TXRL(GRA)
         AR    FRB,GRA                  FRB PTS TO FIRST WORK BUCKET
         LR    GRX,FRB                  GRX PTS TO NEXT  WORK BUCKET
         SPACE
         LA    SRR,SUBWB2               READY THE RETURN REG
         TM    TXTO(GRA),BIT0           INSPECT OPERATION TYPE
         BO    SUBWB0                   ASSEMBLER OP, SKIP
         MVI   CTWORK+IEQUAL(ACT),X'FF' PUT CHECK FOR = INTO TABLE
         B     SUBWB2                   GO RESET ALPHA CHECK
SUBWB0   TM    TXASC(GRA),BIT4          CHECK FOR SUBSITUTION REQUIRED
         BCR   1,SRR                    YES, TO 'RETURN'
         LA    SRR,SUBWB1               NO, RESET 'RETURN' POINT
         SR    GRY,GRY                  MAKE A ZERO
         SPACE
SUBWB1   XI    CTWORK+ILPARN(ACT),X'FF' SET TRT TABLE FOR COMPARE
         XI    CTWORK+IRPARN(ACT),X'FF' ON PARENS (IF DC,DS,LDC OR DXD)
SUBWB2   XI    CTWORK+IA(ACT),X'FF'     AND ALPHA CHARACTERS
         MVC   CTWORK+IB(28,ACT),CTWORK+IA(ACT)
         SPACE
SUBWB3   LR    GR2,GRZ                  CALC NUMBER OF BYTES TO SCAN
         SR    GR2,GR1
         BM    SUBWB9                   NONE
         EX    GR2,SUBWBT               EXECUTE TRT FOR ALPHA OR DELIMS
         BZ    SUBWB9                   NONE
         SPACE
         CLI   0(GR1),IALPHA            IF ALPHA, TEST FOR SYMBOL
         BNH   SUBWB4
         CLI   0(GR1),IQUOTE            IF QUOTE, CHANGE TRT TABLE
         BCR   8,SRR                              AND RESUME SCAN
         CLI   0(GR1),IEQUAL            NOW TEST FOR EQUAL SIGN
         BNE   SUBWB300                 NO, GO LOOK FOR PAREN
         CLI   CTWORK+IA(ACT),0         YES, LOOK AT ALPHAS IN TRT TABL
         BE    SUBWB300                 NOT TESTED, GO LOOK FOR PAREN
SUBWB30  LA    GR1,1(GR1)               NEXT OPERAND BYTE
         CLI   1(GR1),IALPHA            TEST BYTE FOLLOWING FOR ALPHA
         BH    SUBWB3                   ALPHA, GO CALCULATE SCAN
         B     SUBWB30                  NUMERIC, TRY AGAIN
         SPACE
SUBWB300 CLI   0(GR1),ILPARN            IF PAREN, SET PAREN COUNTER
         BNE   SUBWB31                            AND RESUME SCAN
         LA    GRY,1(,GRY)              BUMP LEFT PAREN COUNT
         B     SUBWB3
SUBWB31  BCTR  GRY,0                    RIGHT PAREN--REDUCE PAREN COUNT
         B     SUBWB3                   RESUME SCAN
         SPACE
SUBWBT   TRT   1(0,GR1),CTWORK(ACT)     TRT USED BY SUBWB3
         EJECT
SUBWB4   LR    GR2,GR1                  ALPHA CHAR FOUND OUTSIDE QUOTES
SUBWB41  LA    GR1,1(GR1)               SCAN FOR NON A/N DELIMETER
         CLI   0(GR1),IALPHA
         BNH   SUBWB41
         CLI   0(GR1),IQUOTE
         BNE   SUBWB5                   DELIMITED BY NON-QUOTE, SYMBOL.
         CLI   0(GR2),IL                DELIMITED BY QUOTE,
         BCR   7,SRR                    RESET TRT TABLE IF NOT L-QUOTE
         SPACE
         LA    GR2,1(GR1)               L-QUOTE
SUBWB42  LA    GR1,1(GR1)               SCAN SYMBOL
         CLI   0(GR1),IALPHA            LOOK FOR ALPHAMERICS
         BNH   SUBWB42                  A-N, CONTINUE SCAN
         CR    GR1,GR2                  NOT ALPHA...IF FIRST BYTE...
         BE    SUBWB9                   SYNTAX ERROR...GO TO.SCAN COMPL
         MVC   0(6,GRX),CTZERO(ACT)     CLEAR WORK BUCKET
         MVI   TXSESD(GRX),X'FF'        SET ESDID
         B     SUBWB50                  GO ATTACH BUCKET
         SPACE
SUBWB5   LTR   GRY,GRY                  SYMBOL FOUND IF NOT IN DC
         BNP   SUBWB51                  OUTSIDE OF PARENS
         MVC   0(6,GRX),CTZERO(ACT)     ATTACH SYMBOL WORK BUCKET
SUBWB50  MVI   TXWTYP(GRX),BIT0         SET WK BKT TYPE 2
         LR    GR0,GR1                  SYMBOL END...
         SR    GR0,GR2                  - SYMBOL START...
         STC   GR0,TXSBLN(GRX)          BECOMES SYMBOL BYTE LENGTH
         S     GR2,CTXOFP(ACT)          SYMBOL START-OPND START...
         BCTR  GR2,0                    LESS ONE...
         STC   GR2,TXSPTR(GRX)          BECOMES POINTER TO SYMB IN OPND
         LA    GRX,6(GRX)               ADVANCE POINTER TO NEXT W.B.
SUBWB51  BCT   GR1,SUBWB3
         SPACE
SUBWB9   CR    GRX,FRB                  SCAN COMPLETE, TEST IF ANY WBS
         BCR   8,CRR                    NONE, EXIT
         LA    GR1,6                    DECREMENT BY 6
         SR    GRX,GR1                  ADDRESS LAST WORK BUCKET
         OI    TXSLAS(GRX),BIT4         SET 'LAST SYMBOL IN OPERAND'
         ST    FRB,CTXWBP(ACT)          SET SYMBOL W.B. POINTER IN ACT
         SR    GRX,GRA
         LA    GRX,6(GRX)
         STH   GRX,TXRL(GRA)            INC REC LENGTH
*        B     SUBWBA                   SUBSTITUTE VALUES IN WORK BKTS
         EJECT
SUBWBA   TM    TXSUBS(FRB),X'10'        TEST PREVIOUSLY SUBSTITUTED
         BO    SUBWBX                   YES, TEST END OF W.B.S
*
         SR    SP1,SP1                  NO, CALL STGET
         IC    SP1,TXSPTR(FRB)              WITH SP1 PT TO SYMB IN OPND
         A     SP1,CTXOFP(ACT)
         LA    SP1,1(SP1)
         SR    SP2,SP2                           SP2 EQ SYMB BYTE LEN
*        IC    SP2,TXSBLN(FRB)          FIND SYMBOL BYTE LENGTH
         L     SRB,CSTGET(,ACT)         CALL S.T. GET ROUTINE IN F7S
         BALR  SRR,SRB                  THROUGH COMMON SUBROUT. LINKAGE
*
         LTR   SP1,SP1                  RETURN WITH SP1 PT TO ST ENTRY
         BZ    SUBWBX                   OR ZERO INDICATES NOT IN ST
         CLI   TXSESD(FRB),0            LOOK FOR ESDID ZERO
         BE    SUBWBB                   FOUND, GO MOVE VALUE TO W.B.
         XI    TXSESD(FRB),0
         MVC   TXSVAL+1(2,FRB),6(SP1)   LENGTH, FROM S.T. TO W.B.
         B     SUBWBD                   GO MOVE ESDID TO W.B.
SUBWBB   NOP   0
*
         MVC   TXSVAL(3,FRB),3(SP1)     MOVE VALUE TO W.B.
         CLI   6(SP1),0                 SET TXSEXI IF LEN GR 256
         BE    SUBWBC                   NO, GO MOVE LENGTH TO W.B.
         OI    TXSEXI(FRB),X'04'        SET 'IMPL'D LENGTH OVER 256'
         B     SUBWBD                   GO MOVE ESDID
SUBWBC   MVC   TXSLEN(1,FRB),7(SP1)     MOVE LEN (LE 256) TO W.B.
SUBWBD   MVC   TXSESD(1,FRB),2(SP1)     MOVE ESD ID TO W.B.
         MVC   CTWORK(1,ACT),1(SP1)     SET TYPE FROM ADJ CODE
         NI    CTWORK(ACT),X'03'
         OC    TXSTPC(1,FRB),CTWORK(ACT)
         TM    1(SP1),X'04'             SET DSECT/COM IND. FROM ADJCOD
         BZ    SUBWBE                   GO SET VALUE SUBSTITUTED
         OI    TXSDOC(FRB),X'20'        SYMBOL DEFINED IN DSECT OR COM
*
SUBWBE   OI    TXSUBS(FRB),X'10'        SET VALUE SUBSTITUTED INDICATOR
*
SUBWBX   TM    TXSLAS(FRB),X'08'        TEST FOR LAST SYMBOL W.B.
         BCR   7,CRR                    RETURN TO CALLING ROUTINE
         LA    FRB,6(FRB)               INC POINTER TO NEXT SYMB W.B.
         B     SUBWBA                   PROCESS NEXT SYMB W.B.
         LTORG
         END   ASMGF7C
./ ADD NAME=ASMGF7D
F7D      TITLE     'ASMG F7  DC EVALUATION'
         ISEQ  73,78
ASMGF7D  START
         PRINT      NOGEN
         FDIMEN
         USING *,FRB
*                                                                     *
*TITLE 'ASMGF7D ' ...  DC EVALUATION                                  *
*FUNCTION/OPERATION-                                                  *
*   ASMGF7D PROCESSES DC'S, DS'S, DXD'S, LITERALS AND LITERAL DC'S, A *
*   COMPLETE SYNTAX CHECK IS DONE FOR ALL DC'S AND DS'S. A 15 BYTE    *
*   WORKBUCKET IS ATTACHED TO THE APPENDED FIXED FIELD FOR USE BY     *
*   ASMGF8D IN THE EVALUATION OF THE OPERAND. AN EXTERNAL SYMBOL ENTRY*
*   IS MADE FOR ALL VALID V-TYPE AND Q-TYPE DC'S.                     *
*ENTRY POINT- ASMGF7D                                                 *
*   ENTRY IS MADE VIA                                                 *
*        L     FRB,CDCVAL(ACT)          GET BASE/ENTRY ADDRESS        *
*        BALR  FRR,ACT                  CALL ASMGF7D                  *
*INPUT- NONE                                                          *
*OUTPUT- NONE                                                         *
*EXTERNAL ROUTINES-                                                   *
*   CVCON(ACT)      ESD PROCESSING OF V AND Q TYPE CONSTANTS          *
*   CLOGER(ACT)     LOG ERROR ROUTINE                                 *
*EXITS- NORMAL                                                        *
*   RETURNS TO CALLER VIA                                             *
*        B     CTRTRN(ACT)              RETURN                        *
*     - ERROR-- SAME AS NORMAL RETURN                                 *
*TABLES/WORKAREAS-                                                    *
*   ZRC01      ERROR ASSIGNMENT TABLE                                 *
*   TRTTAB     TYPE OF MODIFIERS FOR IEUF7D TO PROCESS                *
*   TYTABL     BRANCH TABLE FOR DC/DS MODIFIERS (SEE TEXT)            *
*   WFLAG      15 BYTE DC WORKBUCKET AREA                             *
*NOTES-                                                               *
*   THE FORMAT OF THE DC WORKBUCKET IS-                               *
*   LABEL  BYTE  BIT    CONTENTS                                      *
*                                                                     *
*   WFLAG    0    0     0 - TYPE 3 WORKBUCKET                         *
*            0    1     1 - WKBKT LENGTH = 15 BYTES                   *
*            0    2     DC PREVIOUSLY PROCESSED INDICATOR             *
*            0    3     LENGTH MODIFIER PRESENT INDICATOR             *
*            0    4     LAST OPERAND INDICATOR                        *
*   WTYP     1          TYPE (SEE TRTABL) 'FF' = ERROR                *
*   WTOTL   2-4         TOTAL LENGTH                                  *
*   WDUP    5-7         DUPLICATION FACTOR                            *
*   WCONS    8          NUMBER OF CONSTANTS                           *
*   WPTR1    9          RELATIVE POINTER FIRST BYTE OPERAND           *
*   WEXP    10          EXPONENT                                      *
*   WSCL    11   0-7    SCALE MODIFIER (11 BITS TOTAL)                *
*           12   0-2    PART OF ABOVE SCALE MODIFIER                  *
*           12    3     SYMBOL WORKBUCKET FLAG                        *
*           12   4-6    ALIGNMENT (BYTES)                             *
*           12    7     LENGTH MODIFIER TYPE (0=BYTE, 1= BIT)         *
*   WLMOD  13-14        LENGTH MODIFIER VALUE                         *
         EJECT
DCEVL    MVI   OPCOD,0                   RESET INTERNAL OP CODE
         MVI   DCBKT,0                  RESET DC WORKBUCKET COUNTER
         L         GR2,ADLIST1(,ACT)   GET BASE FOR LIST1 IN ASMGASM
*./      DELETE    SEQ1=01124025,SEQ2=01124025
         TM        L1PBYT1(GR2),X'40'  TEST DOS OPTION
         BZ        DCEVL0              BRANCH IF DOS OPTION OFF
         MVI       LCONPTR,X'FF'       MAKE L-CON'S INVALID
         MVI       QCONPTR,X'FF'       MAKE Q-CON'S INVALID
DCEVL0   MVC   SAVWBP,CTXWBP(ACT)       SAVE SYMBOL BUCKET POINTER
         TM    TXESI(GRA),2             TEST IF LIT. ENTRY (MACH OP)
         BO    LITVAL                   YES,GO TO LITERAL ROUTINE
         L     GR1,CTXABP(ACT)          PTR TO APPENDED FIXED FIELD
         MVC   OPCOD(1),TXHEX(GRA)      GET HEX OPERATION CODE
         CLI   VSCNSW,X'FF'             IF V-CON SWITCH IS ON,
         BE    INTOT                    BRANCH.
         CLI   OPCOD,X'25'              TRST IF LITERAL DC
         BE    INTOT                    YES,DON'T BULLDOG TXLOC
         MVC   TXLOC(3,GR1),CTLOC+1(ACT) SET LOC. CTR. IN TEXT RECORD
INTOT    MVC   TOTAL(4),CTLOC(ACT)      MOVE LOC. CTR. TO WORK AREA.
         LA    GRB,TXFAFL(GR1)          SAVE DC WORK BUCKET POINTER.
         L     GR1,CTXOFP(ACT)          GET OPERAND LENGTH POINTER.
         LA    GRA,1(GR1)               GET OPERAND FIELD POINTER.
         SR    GR2,GR2
         IC    GR2,0(GR1)               GET OPERAND FIELD LENGTH
         AR    GR2,GRA
         ST    GR2,FINADR               STORE PTR TO END OF OPND FIELD
LITENT   ST    GRA,SAVPTR               STORE PTR TO START OF OPND.
         XC    ERSW(FCONS+1-ERSW),ERSW
         MVI   BITREM+1,7               SET BIT REMAINDER = 7
         CLI   OPCOD,37                 STEP PAST
         BNE   INIT                     = SIGN IF
         LA    GRA,1(GRA)               A LITERAL DC
INIT     LA    GR1,1                    INITIALIZE DUPFAC AND
         ST    GR1,DUPFAC                NOCONS TO 1.
         STC   GR1,NOCONS
         XC    PZLNAT(FHEDSW-PZLNAT),PZLNAT
         SR    GRC,GRC                  ZERO SWITCHES AND GRC
         LA    GRD,1
         SPACE 2
* CHECK DUPLICATION FACTOR
         SPACE 1
         CLI   0(GRA),IA                TEST FOR NUMERIC.
         BL    DCEV1                    YES-EVALUATE DUPLICATION FACTOR
         CLI   0(GRA),ILPARN            CHECK FOR LEFT PAREN.
         BNE   NODUP                    NO,THEN NO DUP FACTOR PRESENT.
         CLI   LITSW,X'FF'              TEST FOR LITERAL.
         BE    ZRC01                    YES-DUP. FACTOR ERROR.
DCEV1    BAL   SRR,XPREV                TO EXPRESSION EVALUATION
         CL        SP2,=XL4'7FFFFF'    TEST FOR VALID BOUNDS
         BNH       DCEV1X              BRANCH IF OK
         L         SRB,CLOGER(,ACT)    ELSE GO AND-
         BALR      SRR,SRB               LOG THE-
         DC        AL2(1)                  STUPID ERROR
         SR        SP2,SP2             ZERO DUPLICATION FACTOR
DCEV1X   ST    SP2,DUPFAC               STORE DUPLICATION FACTOR
         TM    RSLT,X'30'
         BO    ZRC01                    DUPLICATION FACTOR ERROR
         BM    ZRC02                    RELOCATABLE DUPLICATION FACTOR
         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION
         BO    ZRC01                    YES - DUP FACTOR ERROR
         CLI   LITSW,X'FF'              TEST FOR LITERAL.
         BNE   NODUP                    NO, EVERYTHING OK.
         SR    GR1,GR1                  YES, DUP FACTOR ERROR
         CR    SP2,GR1                   IF DUP FACTOR = 0
         BE    ZRC01
         SPACE 2
* CHECK DC TYPE
         SPACE 1
NODUP    ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),I9                TEST TYPE FOR NUMERIC
         BC    12,ZRC31                 UNKNOWN TYPE
         CLI   0(GRA),IZ                TEST FOR ALPHABETIC
         BH    ZRC31                    UNKNOWN TYPE
         MVC   DCTYP,0(GRA)             FETCH DC TYPE FROM TEXT RECORD
         TR    DCTYP,TRTABL-10          TRANSLATE TYPE
         CLI   DCTYP,X'FF'              TEST FOR VALID TYPE
         BE    ZRC31                    UNKNOWN TYPE
         IC    WR1,DCTYP                BUILD
         SLL   WR1,2                    POINTER
         AH    WR1,DCTYP1
         AH    WR1,DCTYP1
         IC    WR2,TYTABL(WR1)          TO TYPE
         SRL   WR2,4                    TABLE
         IC    WR2,ILTABLE(WR2)         LENGTH CODE INTO LENGTH
         LA    GRA,1(GRA)               KICK TEXT POINTER
         SPACE 2
* CHECK LENGTH MODIFIER
         SPACE 1
LMSCAN   CLI   0(GRA),IL                TEST FOR LENGTH MODIFIER
         BE    LMS1
         ST    WR2,LLNG                 IMPLIED LENGTH TO L-MOD
         MVI   BITREM+1,X'07'           SET REMAINDER=7
         B     SMSCAN    TO SCALE MODIF SCAN
LMS1     MVI   LMSW,X'FF'      SET L-MOD SWITCH
         OI    WFLAG,X'10'              SET L-7OD PRESENT INDICATOR
         LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),IPRIOD            TEST FOR BIT LENGTH
         BE    LMS2
         MVI   BITREM+1,X'07'           SET REMAINDER=7
         B     LMS3
LMS2     LA    SAVE,TYTABL(WR1)
         TM    0(SAVE),X'04'            TEST IF BIT SPECS LEGAL
         BZ    ZRC03                    LENGTH ERROR.
         MVI   BITSW,X'01'              SET BIT SWITCH
         LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
LMS3     CLI   0(GRA),I9                TEST FOR NUMERIC
         BC    12,LMS4
         CLI   LITSW,X'FF'              LENGTH ERROR IF LIT. LENGTH
         BE    ZRC03                    MOD. NOT DEC. SELF-DEF. TERM.
         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.
         BNE   ZRC03                    LENGTH ERROR.
LMS4     BAL   SRR,XPREV                TO EXPRESSION EVALUATION
         ST    SP2,LLNG                 STORE LENGTH MODIFIER
         TM    RSLT,X'30'
         BO    ZRC03                    LENGTH ERROR
         BM    ZRC04                    RELOCATABLE LENGTH
         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION
         BO    ZRC03                    YES - LENGTH MODIFIER ERROR
         L     SAVE,LLNG
         CLI   BITSW,X'01'
         BNE   LMS5
         LA    SAVE,7(SAVE)
         SRL   SAVE,3
LMS5     IC    WR2,TYTABL+1(WR1)       TEST MIN L-MOD VALUE
         CR    SAVE,WR2
         BL    ZRC03                    LENGTH ERROR.
         IC    WR2,TYTABL+2(WR1)       TEST MAX L-MOD VALUE
         LA    WR2,1(WR2)               GET UPPER LIMIT
         CR    SAVE,WR2
         BH    LMS6
         B     SMSCAN
LMS6     CLI   OPCOD,DS
         BL    ZRC03                    LENGTH ERROR.
         CLI   DCTYP,1                  LENGTH ERROR IF NOT CHARACTER
         BH    ZRC03                     OR HEXADECIMAL DS.
LMS7     CL    SAVE,DSMAX              TEST MAX L-MOD VALUE FOR DS
         BH    ZRC03                    LENGTH ERROR.
         SPACE 2
* CHECK SCALE MODIFIER
         SPACE 1
SMSCAN   MVI   SIGN,X'00'               INITIALIZE SIGN TO PLUS
         CLI   0(GRA),IS                TEST FOR SCALE MODIFIER
         BNE   EMSCAN                   TO EXPONENT MODIFIER SCAN
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         LA    SAVE,TYTABL(WR1)
         TM    0(SAVE),X'02'            IS SCALE MODIFIER LEGAL
         BZ    ZRC11                    SCALE MODIFIER ERROR.
         LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),IPLUS             TEST FOR PLUS SIGN
         BE    SMS1
         CLI   0(GRA),IMINUS            TEST FOR MINUS SIGN
         BNE   SMS2
         CLI   DCTYP,X'07'              IF - TEST FOR D AND E TYPE
         BL    ZRC11                    SCALE MODIFIER ERROR.
         CLI   DCTYP,X'0E'              TEST FOR L-TYPE
         BE    ZRC11                    DIE IF L CON
         XI    SIGN,X'01'               SET SIGN MINUS
SMS1     LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
SMS2     CLI   0(GRA),IA                TEST FOR NUMERIC.
         BL    SMS3                     YES-EVALUATE SCALE MODIFIER.
         CLI   LITSW,X'FF'              IF LITERAL, SCALE MOD. MUST BE
         BE    ZRC11                    DECIMAL SELF DEFINING TERM.
         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.
         BNE   ZRC11                    NO-SCALE MODIFIER ERROR.
SMS3     BAL   SRR,XPREV                TO EXPRESSION EVALUATION
         LA    SAVE,0(SP2)              USE 3 BYTES ONLY
         TM    RSLT,X'30'               TEST CC FROM EEVAL
         BO    ZRC11                    CC=11, SCALE MODIFIER ERROR
         BM    ZRC12                    CC=10 OR 01, RELOC. SCALE MOD.
         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION
         BO    ZRC11                    YES - SCALE MODIFIER ERROR
         CLI   SIGN,1                   TEST SIGN
         BE    SMS4                     BRANCH IF MINUS
         CH    SAVE,=H'346'             CHECK SCALE MOD. AGAINST MAX.
         BH    ZRC11                    SCALE MODIFIER TOO LARGE
         B     SMS5
SMS4     LCR   SAVE,SAVE                COMPLEMENT SCALE MODIFIER
         CH    SAVE,=H'-187'            CHECK SCALE MOD. AGAINST MIN.
         BL    ZRC11                    SCALE MODIFIER TOO SMALL
SMS5     CLI   DCTYP,X'07'
         BE    SMS8                     BR IF F CON
         CLI   DCTYP,X'08'
         BE    SMS8                     BR IF H CON
         CH    SAVE,=H'30'              FLOATING--CHECK MAX SCALE
         BH    ZRC11                    FLOATING PT. SCALE TOO LARGE
SMS8     SLL   SAVE,5                   POSITION SCALE MODIFIER
         STH   SAVE,SCMODF              STORE AS HALF WORD
         SPACE 2
* CHECK EXTERNAL EXPONENT MODIFIER
         SPACE 1
EMSCAN   CLI   0(GRA),IE                TEST FOR EXT. EXP. MODIFIER
         BNE   CONSCN                   NO,GO TO SCAN CONSTANT
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         MVI   SIGN,X'00'               SET SIGN PLUS
         LA    SAVE,TYTABL(WR1)
         TM    0(SAVE),X'01'            IS EXPONENT MODIFIER LEGAL
         BZ    ZRC13                    EXOPNENT MODIFIER ERROR
         LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),IPLUS             TEST FOR PLUS SIGN
         BE    EMS1
         CLI   0(GRA),IMINUS            TEST FOR MINUS SIGN
         BNE   EMS2
         XI    SIGN,1                   SET SIGN SWITCH MINUS.
EMS1     LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
EMS2     CLI   0(GRA),IA                TEST FOR NUMERIC.
         BL    EMS3                     YES-EVALUATE EXPONENT MODIFIER
         CLI   LITSW,X'FF'              IF LITERAL, EXP.MOD. MUST BE
         BE    ZRC13                    DECIMAL SELF DEFINING TERM.
         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.
         BNE   ZRC13                    NO-EXPONENT MODIFIER ERROR.
EMS3     BAL   SRR,XPREV                TO EXPRESSION EVALUATION
         LA    SAVE,0(SP2)              USE 3 BYTES ONLY
         TM    RSLT,X'30'
         BO    ZRC13                    EXPONENT MODIFIER ERROR
         BM    ZRC14                    RELOCATABLE EXPONENT MODIFIER
         TM    CTLCRI(ACT),X'40'        WAS AN * IN THE EXPRESSION
         BO    ZRC13                    YES - EXPONENT MODIFIER ERROR
         CLI   SIGN,1                    TEST SIGN
         BE    EMS4                     BRANCH IF MINUS
         CH    SAVE,=H'75'              CHECK EXP. AGAINST MAX.
         BH    ZRC13                    EXPONENT TOO LARGE
         B     EMS5
EMS4     LCR   SAVE,SAVE                COMPLEMENT EXP. MODIFIER
         CH    SAVE,=H'-85'             CHECK EXP. AGAINST MIN.
         BL    ZRC13                    EXPONENT TOO SMALL
EMS5     STC   SAVE,EXMODF              EXPONENT JUST RIGHT
         SPACE 2
* CHECK VALIDITY OF LEFT DELIMETER, CALCULATE ALIGNMENT IF NECESSARY,
* AND EXECUTE A VARIABLE BRANCH BY TYPE FOR SYNTAX CHECKING.
         SPACE 1
CONSCN   LA    GRC,TYTABL+3(GRC)
         MVC   ALWRD+1(3),0(GRC)        GET ADDR OF VARIABLE BRANCH
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         MVI   FHEDSW,0                 INITIALIZE SWITCHES
         L     ODDR,ALWRD               SET VARIABLE BRANCH
         CLI   0(GRA),IQUOTE            TEST FOR QUOTE
         BE    CONS1
         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.
         BE    CONS2
         CLI   0(GRA),ICOMMA            TEST FOR COMMA
         BE    CONSDS                   YES-CHECK FOR DS
         CLI   0(GRA),IBLANK            TEST FOR BLANK
         BNE   ZRC107                   INVALID OPERAND
CONSDS   CLI   OPCOD,DS                 TEST FOR DS OPCODE
         BL    ZRC107                   NO-INVALID OPERAND
         BCTR  GRA,0                    ADJUST OPERAND POINTER
         CLI   LMSW,X'FF'               TEST IF LGTH MODIFIER PRESENT
         BE    ENOPND                   YES-END OF OPERAND, EXIT.
         BAL   SRR,ALIGN                NO-ALIGN PRIOR TO EXIT.
         B     ENOPND                   EXIT.
CONS1    CLI   DCTYP,I9                 IF QUOTE, TEST FOR VALID TYPES
         BL    CONS3
         CLI   DCTYP,X'0E'              IS THIS L CON
         BE    CONS3                    YES.  QUOTE IS JUST FINE.
         B     ZRC107                   INVALID OPER AND.
CONS2    CLI   DCTYP,I8     IF LEFT PAREN TEST VALID TYPES
         BNH   ZRC107                   INVALID OPERAND
         CLI   DCTYP,X'0E'              IS THIS L CON
         BE    ZRC107                   INVALID OPERAND
CONS3    S     GRA,SAVPTR               GET REL. PTR. TO 1ST BYTE OF
         STC   GRA,WPTR1                OPERAND AND PUT IT IN DC BKT.
         A     GRA,SAVPTR               RESTORE TEXT POINTER
         OI    WFLAG,2                  SET TEXT BIT
         CLI   LMSW,X'FF'               TEST FOR LENG MODIFIER
         BE    ZROSAV                   SKIP ALIGNMENT IF YES
         CLI   LITSW,X'FF'              TEST IF LITERAL SCAN
         BE    ZROSAV                   SKIP ALIGNMENT IF YES
         CLI   OPCOD,X'25'              TEST FOR LITERAL DC
         BE    ZROSAV                   YES, ALREADY ALIGNED
         CLI   VSCNSW,X'FF'             TEST FOR 2ND V-TYPE SCAN
         BE    ZROSAV                   YES, ALIGNMENT ALREADY DONE
         BAL   SRR,ALIGN                ALIGN LOCATION COUNTER
ZROSAV   SR    SAVE,SAVE
CONBR    BR    ODDR
         SPACE 2
* END OF OPERAND PROCESSING --- COMPUTE TOTAL LENGTH OF OPERAND IN
* BYTES, FORM 15 BYTE DC WORK-BUCKET AND MOVE IT INTO TEXT RECORD. EXIT
* IF NO MORE OPERANDS TO FOLLOW, OTHERWISE BRANCH TO PROCESS NEXT
* OPERAND.
         SPACE 1
ENOPND   L     GRY,LLNG                 COMPUTE LENGTH TIMES NUMBER
         MH    GRY,NOCON1                OF CONSTANTS.
         TM    FHEDSW,X'20'             TEST FOR P OR Z WITH NO LMV.
         BZ    ENOP1                    NO-BRANCH.
         L     GRY,PZLNAT               YES-LOAD ACCUMULATED LENGTH.
ENOP1    M     GRX,DUPFAC               MULTIPLY BY DUP FACTOR.
         L     GRC,LLNG                 FETCH LMV.
         CLI   BITSW,1                  TEST FOR BIT LENGTH.
         BNE   ENOP2                    NO-BRANCH.
         LA    GRC,7(GRC)               CONVERT LMV TO BIT LENGTH.
         SRL   GRC,3                    ---
         AH    GRY,BITREM               ADD BIT REMAINDER TO TOTAL LGTH
         LR    GRX,GRY                  SAVE RESULT.
         LA    GRZ,7                    COMPUTE NEW BIT REMAINDER.
         NR    GRX,GRZ                  ---
         STH   GRX,BITREM               ---
         SRL   GRY,3                    COMPUTE NO.OF ADDITIONAL BYTES
ENOP2    ST    GRY,OPRNLN               AND STORE IN TOTAL OPND.LGTH.
         LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   VSCNSW,X'FF'             TEST IF 1ST V-TYPE SCAN
         BE    PUTWB1                   NO,WBS WERE PUT IN 1ST SCAN
         A     ODDR,TOTAL
         ST    ODDR,TOTAL
         CLI   FOPND,0                  IS THIS 1ST OPERAND
         BNE   PUTWB
         ST    WR1,CTLEN(ACT)           SET LENGTH ATTRIBUTE FOR MLC
         MVI   FOPND,X'FF'              SET 1ST OPND. SWITCH.
         CLI   ERSW,X'FF'
         BE    EXIT1
PUTWB    CLI   DCBKT,32                 HAVE 32 OPNDS BEEN PROCESSED
         BE    ZRC100      YES - STATEMENT COMPLEXITY EXCEEDED ERROR
         OI    WFLAG,X'40'              SET DC WORKBUCKET INDICATOR
         MVC   WTYP,DCTYP               SET TRANSLATED TYPE
         MVC   WTOTL(3),OPRNLN+1        SET TOTAL OPERAND LENGTH
         MVC   WDUP(3),DUPFAC+1         SET DUP FACTOR
         MVC   WNCONS(1),NOCONS         SET NUMBER OF CONSTANTS
         MVC   WEXP(1),EXMODF           SET EXP MODF
         MVC   WSCL(2),SCMODF           SET SCL MODF
         OC    WSCL+1(1),ALBYS          SET ALIGNMENT
         OC    WSCL+1(1),BITSW          SET BIT-BYTE
         MVC   WLMOD(2),LLNG+2          EET LENGTH MODIFIER VALUE
         CLI   LITSW,X'FF'
         BE    LTVL1
         MVC   TXWTYP(15,WBPTR),WFLAG   MOVE WB INTO TEXT RECORD
         NI        TXWTYP(WBPTR),X'7F' SET AS A DC WORKBUCKET
         OI        TXWTYP(WBPTR),X'40'
         IC    GR1,DCBKT                INCREMENT DC WORKBUCKET CTR7000
         LA    GR1,1(GR1)               A MAXIMUM OF 32 IS ALLOWED PER
         STC   GR1,DCBKT                 DC/DS STATEMENT.
         CLI   OPCOD,X'25'              TEST FOR LITERAL DC.
         BE    PUTWB1                   YES-DONT INCREMENT REC.LGTH.
         L     GRC,CTEXTP(ACT)          FETCH POINTER TO TEXT RECORD.
         LH    GR1,TXRL(GRC)            FETCH RECORD LENGTH.
         LA    GR1,15(GR1)              ADD 15 AND
         STH   GR1,TXRL(GRC)            PLACE BACK IN TEXT RECORD.
         MVI   RLSW,X'FF'               SET REC LENG UPDATE SWITCH
PUTWB1   CLI   0(GRA),IBLANK            TEST FOR BLANK
         BE    DONE
         C     GRA,FINADR               TEST FOR END OF OPERAND
         BE    DONE
         CLI   0(GRA),ICOMMA            TEST FOR COMMA
         BNE   ZRC39                    INVALID DELIMITER
         LA    WBPTR,15(WBPTR)          UPDATE POINTER FOR NEXT WB
         LA    GRA,1(GRA)               KICK TEXT POINTER
         MVI   FCONS,0                  RESET FIRST CONSTANT SWITCH
         B     INIT
         SPACE 2
* CHECK CHARACTER TYPE DC'S.
         SPACE 1
CTYP     LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CL    GRA,FINADR               TEST FOR NO ENDING QUOTE
         BH    ZRC87                    BRANCH IF OPERAND DONE, NO '
         CH    SAVE,=H'256'             TEST IF MAX CHARACTERS HIT
         BH    ZRC107                   BRANCH IF MORE THAN 256
         CLI   0(GRA),IQUOTE            TEST FOR QUOTE
         BE    CTYP4                    IF FOUND TEST IF NEXT CHAR QUOT
         CLI   0(GRA),IAMPSD            TEST FOR AMPERSAND
         BNE   CTYP3
         LA    GRA,1(GRA)               KICK TEXT POINTER
         CLI   0(GRA),IAMPSD            TEST FOR PAIRED AMPERSAND
         BNE   ZRC107                   INVALID OPERAND
CTYP3    LA    SAVE,1(SAVE)             ADD 1 TO COUNT OF CHARACTERS
         B     CTYP                     CONTINUE SCAN
CTYP4    LA    GRA,1(GRA)               KICK TEXT POINTER
         CLI   0(GRA),IQUOTE            TEST FOR QUOTE
         BE    CTYP3                    2 QUOTES MEAN 1 QUOTE IN CONST
         BCTR  GRA,0                    SUB. 1 FROM TEST POINTER
         B     XTYP4
*./      DELETE    SEQ1=08120020,SEQ2=08140020
CTYP5    CLI   LMSW,X'FF'               TEST IF LENGTH SPECIFIED
         BC    8,ENOPND
         ST    SAVE,LLNG                STORE LENGTH OF CONSTANT
CEXIT    B     ENOPND                   TO END OPERAND
         SPACE 2
* CHECK HEXADECIMAL TYPE DC'S.
         SPACE 1
XTYPE    LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),X'0F'             TEST FOR VALID HEX DIGIT
         BH    XTYP3                    GO TO TEST FOR QUOTE IF NOT
         LA    SAVE,1(SAVE)             ADD 1 TO COUNT OF HEX DIGITS
         B     XTYPE                    CONTINUE SCAN
XTYP3    CLI   0(GRA),IQUOTE            TEST FOR QUOTE
         BNE   ZRC107                   INVALID OPERAND
         LA    SAVE,1(SAVE)             ADD 1 TO COUNT
         SRL   SAVE,1                   DIVIDE COUNT BY 2
XTYP4    LTR   SAVE,SAVE                TEST IF COUNT IS ZERO
         BZ    ZRC107                   INVALID OPERAND
         CH    SAVE,=H'256'             TEST IF BYTE LIMIT EXCEEDED
         BH    ZRC107                   BRANCH IF MORE THAN 256
         B     CTYP5                    TEST LENGTH AND RETURN DC MAIN
         SPACE 2
* CHECK BINARY TYPE DC'S.
         SPACE 1
BTYPE    LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),1                 TEST FOR VALID BINARY DIGIT
         BH    BTYP3                    NO,TEST FOR QUOTE
         LA    SAVE,1(SAVE)             ADD 1 TO COUNT
         B     BTYPE                    CONTINUE SCAN
BTYP3    CLI   0(GRA),IQUOTE            TEST FOR QUOTE
         BNE   ZRC39                    INVALID DELIMITER
         LA    SAVE,7(SAVE)             ADD 7 TO COUNT
         SRL   SAVE,3                   DIVIDE COUNT BY 8
         B     XTYP4                    TEST EXPLICIT LENG AND EXIT
         SPACE 2
* CHECK FIXED AND FLOATING POINT DC'S.
         SPACE 1
FHEDSCAN MVI   FHEDSW,0                 SET SIGN,EXP.,DOT SWITCHES = 0
FA       LA    GRA,1(GRA)               BUMP TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),IPLUS             IS 1ST CHAR. PLUS
         BE    FD                       YES
         CLI   0(GRA),IMINUS            IS 1ST CHAR. MINUS
         BE    FD                       YES
         CLI   0(GRA),IPRIOD            IS 1ST CHAR. DECIMAL POINT
         BE    FB                       YES
         CLI   0(GRA),I9                IS 1ST CHAR. NUMERIC
         BH    ZRC107                   NO, LOG INVALID OPERAND ERROR
FC       LA    GRA,1(GRA)               YES, BUMP TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),I9                IS NEXT CHAR NUMERIC
         BNH   FC                       YES, CONTINUE SCAN
         CLI   0(GRA),IPRIOD            IS NEXT CHAR. DECIMAL POINT
         BE    FB                       YES
         CLI   0(GRA),IE                CHECK FOR EXPONENT.
         BE    FE                       YES
         CLI   0(GRA),ICOMMA            IS NEXT CHAR. COMMA
         BE    FF                       YES, END OF CONSTANT
         CLI   0(GRA),IQUOTE            IS NEXT CHAR. QUOTE
         BE    ENOPND                   YES, END OF OPERAND---EXIT.
         B     ZRC107                   NO, LOG INVALID OPERAND ERROR.
FB       TM    FHEDSW,1                 IS DOT SWITCH ON
         BO    ZRC107                   YES, TOO MANY DECIMAL POINTS.
         OI    FHEDSW,1                 TURN ON DOT SWITCH
         B     FC                       CONTINUE SCAN
FD       TM    FHEDSW,4                 IS SIGN SWITCH ON
         BO    ZRC107                   YES, TOO MANY ALGEBRAIC SIGNS.
         OI    FHEDSW,4                 TURN ON SIGN SWITCH
         B     FA                       CONTINUE SCAN
FE       TM    FHEDSW,2                 IS EXP. SWITCH ON
         BO    ZRC107                   YES, TOO MANY EXPONENTS.
         OI    FHEDSW,3                 TURN ON EXP. AND DOT SWITCHES
         NI    FHEDSW,X'FB'             TURN OFF SIGN SWITCH
         B     FA                       DO EXPONENT SCAN.
FF       IC    GR14,NOCONS              ADD 1 TO NUMBER OF CONSTANTS
         LA    GR14,1(GR14)
         STC   GR14,NOCONS
         B     FHEDSCAN                 BEGIN SCANNING NEXT CONSTANT.
         SPACE 2
* CHECK PACKED AND ZONED DC'S.
         SPACE 1
PTYPE    LA    GRA,1(GRA)               STEP OPERAND POINTER.
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         CLI   0(GRA),IPLUS             TEST FOR PLUS SIGN.
         BE    PTYP3                    YES-BRANCH
         CLI   0(GRA),IMINUS            TEST FOR MINUS SIGN.
         BE    PTYP3                    YES-BRANCH
PTYP2    CLI   0(GRA),I9                TEST FOR NUMERIC.
         BH    PTYP4                    NO-BRANCH.
         LA    GRX,1(GRX)               ADD 1 TO LENGTH.
PTYP3    LA    GRA,1(GRA)               STEP OPERAND POINTER.
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         B     PTYP2                    BRANCH TO CONTINUE SCAN.
PTYP4    CLI   0(GRA),IPRIOD            TEST FOR DOT.
         BNE   PTYP5                    NO-BRANCH.
         TM    FHEDSW,8                 TEST DOT SWITCH.
         BO    ZRC107                   ON-TOO MANY DOTS IN CONSTANT.
         OI    FHEDSW,8                 OFF-TURN DOT SWITCH ON.
         B     PTYP3                    BRANCH TO CONTINUE SCAN.
PTYP5    CLI   0(GRA),IQUOTE            TEST FOR QUOTE.
         BE    PTYP6                    YES-BRANCH
         CLI   0(GRA),ICOMMA            TEST FOR COMMA.
         BNE   ZRC39                    NO-INVALID DELIMITER.
         IC    GRZ,NOCONS               ADD 1 TO NUMBER OF CONSTANTS.
         LA    GRZ,1(GRZ)               ---
         STC   GRZ,NOCONS               ---
PTYP6    LTR   GRX,GRX                  TEST FOR ZERO LENGTH.
         BZ    ZRC39                    YES-INVALID DELIMITER.
         CLI   DCTYP,4                  CHECK DC TYPE.
         BE    ZONED                    ZONED-BRANCH.
         LA    GRX,2(GRX)               PACKED-COMPUTE PACKED LENGTH.
         SRL   GRX,1                    ---
ZONED    CH    GRX,CON16                COMPARE LENGTH WITH MAXIMUM.
         BH    ZRC17                    DATA ITEM TOO LARGE-BRANCH.
         CLI   LMSW,X'FF'               TEST FOR LENGTH MODIFIER.
         BE    PTYP7                    YES-BRANCH.
         CLI   FCONS,0                  TEST FOR 1ST CONSTANT IN OPND.
         BNE   PTYP8                    NO-BRANCH.
         MVI   FCONS,X'FF'              SET 1ST CONSTANT SWITCH.
         OI    FHEDSW,X'20'             SET PZ, NO LMV SWITCH.
         ST    GRX,LLNG                 USE 1ST CONSTANT LGTH.FOR LMV.
PTYP8    A     GRX,PZLNAT               ACCUMULATE TOTAL LENGTH.
         ST    GRX,PZLNAT               ---
PTYP7    CLI   0(GRA),IQUOTE            TEST FOR QUOTE.
         BE    ENOPND                   YES-BRANCH.
         SR    GRX,GRX                  NO-SET LENGTH COUNTER TO ZERO.
         NI    FHEDSW,X'F7'             RESET DOT SWITCH.
         B     PTYPE                    BRANCH TO PROCESS NEXT CONSTANT
         SPACE 2
* CHECK A AND Y TYPE ADDRESS CONSTANTS.
         SPACE 1
ATYPE    LA    GRA,1(GRA)               KICK TEXT POINTER
         BAL   SRR,XPREVA               TO EXPRESSION EVALUATION
         CLI   LITSW,X'FF'              CHECK FOR LITERAL
         BNE   ATYP1                    NO, BRANCH
         TM    CTLCRI(ACT),X'40'        CHECK FOR LOC. CTR. REF.
         BZ    ATYP1                    NO, BRANCH
         MVI   LOCSW,X'FF'              YES, SET SWITCH
ATYP1    CLI   0(GRA),ICOMMA            TEST FOR COMMA
         BNE   ATYP3                    NO,GO TO TEST FOR RIGHT PAREN
         IC    SAVE,NOCONS
         LA    SAVE,1(SAVE)             ADD 1 TO NO OF CONSTANTS
         STC   SAVE,NOCONS
         B     ATYPE
ATYP3    CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.
         BNE   ZRC39                    INVALID DELIMITER
         B     ENOPND                   TO END OPERAND
         SPACE 2
* CHECK S TYPE ADDRESS CONSTANTS.
         SPACE 1
STYPE    CLI   LITSW,X'FF'
         BE    ZRC05                    ERROR-LITERAL IN S-CON.
STYP1    LA    GRA,1(GRA)               KICK TEXT POINTER
         BAL   SRR,XPREVA               TO EXPRESSION EVALUATION
         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.
         BNE   STYP3                    NO, BRANCH
         TM    FHEDSW,X'10'             LEFT PAREN SWITCH ON
         BO    ZRC107                    YES, TOO MANY LEFT PARENS
         OI    FHEDSW,X'10'             TURN ON LEFT PAREN SWITCH
         B     STYP1                    CHECK BASE REG. EXPRESSION.
STYP3    TM    FHEDSW,X'10'             TEST FOR BASE-DISP S-CON.
         BZ    STYP4                    NO-BRANCH
         CLI   0(GRA),IRPARN            YES-TEST FOR RT. PAREN DELIM.
         BNE   ZRC39                    NO-INVALID DELIMITER
         LA    GRA,1(GRA)               YES-STEP OVER RIGHT PAREN.
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
STYP4    CLI   0(GRA),IRPARN            TEST FOR RT. PAREN. DELIM.
         BE    ENOPND                   TO END OF OPERAND
         CLI   0(GRA),ICOMMA            TEST FOR COMMA
         BNE   ZRC39                    INVALID DELIMITER
         IC    SAVE,NOCONS              ADD
         LA    SAVE,1(SAVE)             1
         STC   SAVE,NOCONS              TO NUMBER OF CONSTANTS
         NI    FHEDSW,X'EF'             TURN OFF LEFT PAREN SWITCH
         B     STYP1                    CONTINUE SCAN
         SPACE 2
* CHECK Q AND V TYPE ADDRESS CONSTANTS, AND MAKE ESD ENTRY FOR EACH.
         SPACE 1
QTYPE    CLI   LITSW,X'FF'
         BE    ZRC15                    ERROR - QCON IN LITERAL.
         MVI   QFLAG,1                  SET QCON FLAG FOR ESD ROUTINE
         B     VQCOM
VTYPE    MVI   QFLAG,0                  SET VCON FLAG FOR ESD ROUTINE
VQCOM    CLI   LITSW,X'FF'              TEST IF LITERAL VCON OR QCON
         BE    SCAN1
VSCN1    CLI   VSCNSW,X'FF'             TEST IF 1ST SCAN
         BE    SCAN2                    NO,TO SCAN FOR ESD PROCESSING
         MVI   EXITSW,X'FF'             OTHERWISE,SET 1ST SCAN
SCAN1    LA    GRA,1(GRA)               KICK TEXT POINTER
         ST    GRA,ERRORPTR             USED ONLY FOR ERRORS.
         SR    GR2,GR2                  RESET SYMBOL CHAR. COUNTER
         CLI   0(GRA),I9                TEST FOR NUMERIC
         BC    12,ZRC107                INVALID OPERAND.
SCAN1A   CLI   0(GRA),ICOMMA            TEST FOR COMMA
         BE    SCAN1B
         CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.
         BE    SCAN3                    YES,CHECK VALIDITY LAST SYMBOL
         CLI   0(GRA),IAT
         BH    ZRC107                   INVALID OPERAND.
         LA    GR2,1(GR2)               KICK SYMBOL CHAR. COUNTER
         LA    GRA,1(GRA)               KICK TEXT POINTER
         B     SCAN1A                   CONTINUE SCAN
SCAN1B   IC    SAVE,NOCONS
         LA    SAVE,1(SAVE)
         STC   SAVE,NOCONS
SCAN3    CH    GR2,=H'8'                SYMBOL ERROR IF ANY V-CON IS
         BH    ZRC18                    MORE THAN 8 CHARACTERS LONG.
         LTR   GR2,GR2                  INVALID OPERAND IF ANY V-CON
         BZ    ZRC107                   IS MISSING - I.E. DC V()
         L     GR2,CTXWBP(ACT)          LOAD SYMBOL BUCKET POINTER
         LTR   GR2,GR2                  TEST FOR ZERO
         BZ    VW                       YES, BRANCH
         LA    GR2,6(GR2)               STEP SYMBOL BUCKET POINTER
         ST    GR2,CTXWBP(ACT)          STORE INCREMENTED BKT PTR.
VW       CLI   0(GRA),ICOMMA            IS DELIMITER A COMMA
         BE    SCAN1                    YES, CONTINUE SCAN
         B     ENOPND                   NO, END OF OPERAND.
SCAN2    TM    TXWTYP(WBPTR),4          TEST FOR ERROR
         BO    DONE2                    BRANCH IF YES
SCAN2AA  LA    SP1,1(GRA)               PTR TO 1ST BYTE OF CONSTANT
SCAN2A   LA    GRA,1(GRA)               KICK TEXT POINTER
         CLI   0(GRA),ICOMMA            TEST FOR COMMA
         BE    SCAN2B
         CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.
         BNE   SCAN2A                   CONTINUE TO SCAN CONST
SCAN2B   TM    WFLAG,2                  DOES DS CONTAIN TEXT
         BZ    ENOPND                   NO,SKIP ESD PROCESSING
         LR    SP2,GRA                  MAKE
         SR    SP2,SP1                  ESD
         BCTR  SP2,0                    ENTRY
         STM   GRA,GRY,REGSAV
         CLI   OPCOD,X'26'              SET COND. CODE FOR ESD PROCESS
         L     GR1,CVCON(ACT)           BRANCH TO DO ESD PROCESSING
         L     FRB,CBRNDA(ACT)           AND CROSS-REFERENCE.
         BALR  SRR,GR1
         USING *,SRR
QFLAG    DC    AL2(0)                   ESD ROUTINE FLAG -- 0=V --- 1=Q
         LM    GRA,GRY,REGSAV           RESTORE REGISTERS
         DROP  SRR
NOESD    L     GR1,CTXWBP(ACT)          INCREMENT
         LA    GR1,6(GR1)               SYMBOL WORK BUCKET
         ST    GR1,CTXWBP(ACT)          POINTER BY 6
         CLI   0(GRA),ICOMMA            TEST FOR COMMA
         BE    SCAN2AA                  YES, BRANCH.
         B     ENOPND
         SPACE 2
*        ROUTINE TO ALIGN LOCATION COUNTER TO CORRECT BOUNDARY
*        R1 IS WORK REGISTER,LNKR IS LINK REGIATER
         SPACE 1
ALIGN    L     R1,TOTAL                 GET LOCATION COUNTER
         SR    SAVE,SAVE                SET SAVE = ALL ONES
         BCTR  SAVE,0
         BCTR  WR2,0                    WR2 = ALIGNMENT
         N     WR2,=XL4'7'                MAXIMUM OF DBLWD
         AR    R1,WR2                        1=BYTE, 2=HALF WORD
         XR    WR2,SAVE                      4=FULL WORD, 8=DOUBLE WRD
         NR    R1,WR2                   R1 IS LOC CNT ALIGNED
         S     R1,TOTAL                 FIND NUMBER BYTES OF ALIGNMENT
         SLL   R1,1                     SHIFT
         STC   R1,ALBYS                 AND PUT IN
         SRL   R1,1
         A     R1,TOTAL                 SET THE NEW ALIGNED
         ST    R1,TOTAL                 LOCATION COUNTER
         CLI   FOPND,0                  IS THIS 1ST OPND.
         BCR   7,SRR                    NO, BRANCH
         CLI   VSCNSW,X'FF'
         BCR   8,SRR                    BRANCH IF 2ND V-TYPE SCAN.
         L     R1,CTXABP(ACT)           GET POINTER TO TEXT RECORD
         MVC   TXLOC(3,R1),TOTAL+1      SET ALIGNED LOC CTR IN TEXT
ALIGN1   BR    SRR                      RETURN FROM WHENCE THOU CAME
DONE     OI    TXWTYP(WBPTR),X'08'      SET LAST DC WB INDICATOR
DONE1    MVC   CTLOC(4,ACT),TOTAL  SET NEW LOC CTR IN CENTRAL TABLE
DONE2    CLI   EXITSW,X'FF'             TEST IF ABNORMAL RETURN TO MLC
         BE    ABNEXT                   YES,BRANCH
         MVI   VSCNSW,X'00'             NO,SET 1ST V-TYPE SCAN
         B     CTRTRN(ACT)              NORMAL RETURN TO MLC
ABNEXT   MVI   EXITSW,X'00'             SET NORMAL RETURN TO MLC
         MVI   VSCNSW,X'FF'             SET 2ND V-TYPE SCAN
         MVC   CTXWBP(4,ACT),SAVWBP     RESTORE SYMBOL BUCKET POINTER
         L     WR1,CTSAVE+12(ACT)       ABNORMAL
         LA    WR1,4(WR1)               RETURN
         ST    WR1,CTSAVE+12(ACT)       TO
         B     CTRTRN(ACT)              MLC
         SPACE 2
* ERROR EXIT ROUTINE. LOG ASSIGNED ERROR MESSAGE AND VAMOOSE.
         SPACE 1
EXIT     L     SP1,ERRORPTR             LOAD COLUMN POINTER FOR LOGERR
         CLI   LITSW,X'FF'              IS THIS A LITERAL
         BE    LOGERR                   YES, BRANCH.
         MVI   TXWTYP(GRB),X'4C'        SET ERROR INDICATOR IN DC BKT.
         CLI   RLSW,X'FF'               TESTREC LENG UPDATE SWITCH
         BNE   UPRECL                   BRANCH IF OFF
         L     WR1,TOTAL                SUBTRACT LENGTH
         S     WR1,OPRNLN               OF ERRONEOUS OPERAND FROM
         ST    WR1,TOTAL                TOTAL LENGTH OF STATEMENT
         B     LOGERR
UPRECL   L     WR1,CTEXTP(ACT)          POINTER TO TEXT RECORD
         LH    WR2,TXRL(WR1)            INCREMENT
         LA    WR2,15(WR2)              RECORD LENGTH
         STH   WR2,TXRL(WR1)            BY LENGTH OF WORK BUCKET
LOGERR   L     SRB,CLOGER(ACT)
         BALR  SRR,SRB
KAPUT    DC    AL2(0)                   DIAGNOSTIC NUMBER STORED HERE
         CLI   LITSW,X'FF'              IS THIS A LITERAL
         BE    LTVL3                    YES, BRANCH.
         CLI   FOPND,0                  IS THIS 1ST OPND.
         BNE   DONE1
         CLI   NOCONS,X'01'
         BNE   STERSW
EXIT1    L     GR1,CTXABP(ACT)     FETCH PTR TO APPENDED FIXED FIELD
         MVC   TOTAL+1(3),TXLOC(GR1)    GET LOC CNT
         L     GR2,TOTAL                IN GR2
         SR    WR1,WR1
         IC    WR1,ALBYS                GET NUMBER OF BYTES
         SRL   WR1,1                    TO ALIGN
         SR    GR2,WR1                  GET ORIGINAL LOC CNT
         ST    GR2,TOTAL                AND PUT BACK
         MVC   TXLOC(3,GR1),TOTAL+1       (IF ERROR, DONT ALIGN)
         CLI   ERSW,X'FF'
         BE    DONE1
         LA    GR1,1
         ST    GR1,CTLEN(ACT)
         B     DONE1
STERSW   MVI   ERSW,X'FF'
         B     ENOPND
         SPACE 2
* LITERAL EVALUATION AND PROCESSING ROUTINE.
         SPACE 1
LITVAL   L     1,CTXOFP(ACT)            GET OPRND LENGTH POINTER
         SR    GR2,GR2                  CLEAR WORK REGISTER
         IC    GR2,0(GR1)               GET OPERAND LENGTH
         AR    GR2,GR1                  GET END OF OPERAND POINTER
         ST    GR2,FINADR                    AND  SAVE
         LA        2,=X'32'            SET AS A BLANK
         ST        2,GRASAVE             IN CASE OF AN ERROR
         L     2,CTXABP(ACT)            GET PTR TO APPENDED FIXED FIELD
         SR    WR1,WR1
         IC    WR1,TXLSTG(2)            GET RELATIVE PTR TO = SIGN
         STH   GRC,RELEQL                AND SAVE IT.
         LA    GRA,2(GR1,GRC)           GET ABSOLUTE PTR. TO = SIGN+1
         MVI   LITSW,X'FF'              SET LITERAL SWITCH
         LR    WBPTR,2                  SAVE PTR TO WORK BUCKET
         TM    TXLEVI(GRB),2            LITERAL PREVIOUSLY EVALUATED
         BO    LTVL3A                   YES, BRANCH
         B     LITENT                   OTHERWISE GO TO EVALUATE
LTVL1    OI    TXLEVI(GRB),2            SET LITERAL EVALUATED INDICATOR
         ST        GRA,GRASAVE         SAVE POINTER
         SR    SAVE,SAVE
         TM    OPRNLN+3,X'07'           TEST LENGTH FOR MULTIPLE OF 8
         BZ    LTVL2
         LA    SAVE,4(SAVE)
         TM    OPRNLN+3,X'03'           TEST LENGTH FOR MULTIPLE OF 4
         BZ    LTVL2
         LA    SAVE,4(SAVE)
         TM    OPRNLN+3,X'01'           TEST LENGTH FOR MULTIPLE OF 2
         BZ    LTVL2
         LA    SAVE,4(SAVE)             OTHERWISE 7ULTIPLE OF 1
LTVL2    SR    SP1,SP1
         S     GRA,SAVPTR               GET DEFINITION LENGTH,
         BCTR  GRA,0                    SUBTRACT 1
         STC   GRA,DEFLEN               AND STORE.
         MVC   WLNAT(1),CTLEN+3(ACT)    SET LENGTH ATTRIBUTE
         SPACE 2
*  THE FOLLOWING IS SYMBOL TABLE LOOK-UP FOR LITERALS.ENTERS LITERALS
*  IN TABLE,IF NO DUPLICATES FOUND AND IF ROOM IN TABLE.
         SPACE 1
PUTLIT   IC    SP1,DEFLEN               GET DEFINITION LENGTH-1
         L     GRA,SAVPTR               GET PPINTER TO TEXT.
         L     WR1,CTSYMP(ACT)
         L     WR2,LITPTR(SAVE)         GET DISPLACEMENT OF POINTER
         AR    WR2,WR1
NEXENT   ST    WR2,PREPTR               FOR FORWARD THREADING
         MVC   ALWRD+1(3),0(WR2)
         L     WR2,ALWRD                GET NEXT POINTER
         LTR   WR2,WR2                  ZERO POINTER MEANS
         BZ    NOSAME                   END OF THREAD
         AR    WR2,WR1                  =ADDRESS OF ENTRY
         CLI   LOCSW,X'FF'              CHECK LITERAL-ASTERISK SWITCH
         BE    NEXENT                   BRANCH IF ON
         CLC   DEFLEN,3(WR2)            IF DEFINITION LENGTHS UNEQUAL
         BNE   NEXENT                   TRY NEXT ENTRY
         EX    SP1,LCOMP                EXECUTE COMPR WITH DEF LNG-1
         BNE   NEXENT
         TM    CTLREF(ACT),X'80'        IS LREF ON .Q
         BZ    DUPFOUND                 NO
         S     WR2,=F'6'                BACKUP ADDRESS TO PREFIX
         ST    WR2,ALWRD                STORE TO CREATE REF CHAIN
         LA    WR2,6(,WR2)              RESTORE LITERAL'S ADDRESS
DUPFOUND AR    WR2,SP1                  DUPLICATE FOUND
         MVC   WTOTL(3),8(WR2)          GET DISPLACEMENT FROM TABLE
         MVC   TXLDSP(3,WBPTR),8(WR2)   MOVE DISPLACEMENT IN WB
         B     SETWB1
NOSAME   LA    SP1,21(SP1)              DEFINITION LENGTH + FIXED INFO
         CLI   LOCSW,X'FF'              CHECK LITERAL-ASTERISK SWITCH
         BNE   PEG                      BRANCH IF OFF, OTHERWISE
         LA    SP1,4(SP1)               ALLOW FOR TXLOC AND CESDID
PEG      XC    SAVLEN(4),SAVLEN         SET SAVLEN = 0
         L     GR1,CTXWBP(ACT)          FETCH SYMBOL BUCKET POINTER
         LTR   GR1,GR1                  TEST FOR ZERO
         BZ    NOSYMBKT                 YES, NO SYMBOL BUCKETS TO MOVE.
         CLI   DCTYP,I9                 IS THIS AN ADCON LITERAL
         BL    NOSYMBKT                 NO, THEN DONT MOVE SYMBOL BKTS.
         L     GR2,CTEXTP(ACT)          FETCH PTR TO CURR. TEXT REC.
         AH    GR2,TXRL(GR2)            ADD RECORD LENGTH.
         SR    GR2,GR1                  COMPUTE LGTH OF ALL SYM. BKTS.
         BZ    NOSYMBKT                 IF 0, THEN THERE ARE NONE.
         LA    SP1,0(SP1,GR2)           ADD LENGTH OF SYMBOL BKTS.
         ST    GR2,SAVLEN               SAVE LENGTH OF SYMBOL BUCKETS.
         OI    WTYP,X'40'               SET SWITCH FOR DCGETR ROUTINE.
         TM    CTLREF(ACT),X'80'        IS LREF ON .Q
         BZ    NOSYMBKT                 NO
         LA    SP1,6(,SP1)              EXTRA 6 BYTES FOR LREF PREFIX
NOSYMBKT ST    SAVE,REGSAV
         L     SRB,CSTROM(ACT)          TEST IF ROOM
         BALR  SRR,SRB                  IN SYMBOL TABLE
         DS        2H
         L     SAVE,REGSAV              RETURN HERE IF ENOUGH ROOM
         TM    CTLREF(ACT),X'80'        IS LREF ON .Q
         BZ    NOCHANGE                 NO
         L     GR1,CFREEP(ACT)          GET DISPLACEMENT IN S. T.
         LR    GR2,GR1                  TRANSFER IT TO WORK REGISTER
         LA    GR2,6(,GR2)              INCREASE BY 6 BYTE PREFIX
         ST    GR2,CFREEP(ACT)          UPDATE WITH NEW DISPLACEMENT
         AR    GR1,WR1                  ABSOLUTE ADDRESS OF FREE CORE
         XC    0(3,GR1),0(GR1)          ZERO START OF LITERAL CHAIN
         ST    GR1,ALWRD                STORE FOR MOVE & REF CHAIN
         MVC   3(3,GR1),ALWRD+1         INITIALIZE END OF REF CHAIN
NOCHANGE L     WR2,PREPTR               RESTORE FOR FORWARD THREADING
         MVC   0(3,WR2),CFREEP+1(ACT)   THREAD NEW ENTRY
         L     WR2,CFREEP(ACT)
         AR    WR2,WR1                  = ADDRESS OF FREE STORAGE
         SR    WR1,WR1
         XC    0(3,WR2),0(WR2)          ZERO AS POINTER
         MVC   3(1,WR2),DEFLEN          MOVE IN DEFINITION LENGTH-1
         IC    WR1,DEFLEN               GET DEFINITION LENGTH-1
         EX    WR1,MOVTEX               FOR EXECUTED MOVE INSTRUCTION
         LA    WR2,5(WR1,WR2)           POINT PAST TEXT FORM
         LA    WR1,CTLITA(SAVE,ACT)
         MVC   WTOTL(3),1(WR1)
         MVC   0(16,WR2),WLNAT          MOVE FIXED INFO INTO TABLE
         CLI   LOCSW,X'FF'              CHECK LITERAL-ASTERISK SWITCH
         BNE   UPFREE                   BRANCH IF OFF
         MVI   LOCSW,0                  RESET LITERAL-ASTERISK SWITCH
         OI    2(WR2),X'80'              SET MOVE INDICATOR IN DC BKT.
         MVC   16(3,WR2),TXLOC(GRB)     MOVE TXLOC.
         MVC   19(1,WR2),CESDID(ACT)    MOVE CURRENT ESD-ID
         LA    WR2,4(WR2)               BUMP RECORD POINTER
         SPACE 2
* AT THIS POINT TEST IF WORK BUCKETS ATTATCHED. IF YES MOVE THEM IN.
         SPACE 1
UPFREE   LA    WR2,16(WR2)
         L     GR2,SAVLEN               FETCH TOTAL SYM.BKT. LENGTH
         LTR   GR2,GR2                  IF ZERO, THEN NO SYM.BKTS.
         BZ    IPA                       TO MOVE.
         L     GR1,CTXWBP(ACT)          FETCH SYMBOL BUCKET PTR.
         BCTR  GR2,0                    DECREMENT LENGTH AND EXECUTE
         EX    GR2,MVSYMBKT             A MOVE OF SYMBOL BUCKETS.
ALVISO   TM    0(GRD),X'10'             TEST VALUE SUBSTITUTED SWITCH
         BO    MILPITAS                 BRANCH IF ON
         SR    GRZ,GRZ
         IC    GRZ,TXSPTR(GRD)          COMPUTE RELATIVE PTR TO
         SH    GRZ,RELEQL               SYMBOL IN OPERAND FIELD.
         STC   GRZ,TXSPTR(GRD)
MILPITAS TM    0(GRD),8                 TEST LAST SYMBOL INDICATOR
         BO    SANJOSE                  BRANCH IF  LAST SYMBOL.
         LA    GRD,6(GRD)               KICK PTR TO NEXT SYMBOL BKT.
         B     ALVISO                   AND CONTINUE.
SANJOSE  LA    GRD,6(GRD)               KICK PTR PAST LAST SYM. BKT.
IPA      S     GRD,CTSYMP(ACT)          REDUCE POINTER TO
         ST    WR2,CFREEP(ACT)          A DISPLACEMENT AND STORE
         MVC   TXLDSP(3,WBPTR),1(WR1)   SET DISPLACEMENT IN WB
         L     WR2,0(WR1)
         A     WR2,OPRNLN               ADD CURRENT LENGTH TO
         ST    WR2,0(WR1)               APPROPRIATE STRING LENGTH
         L     WR2,CTLITB(SAVE,ACT)     ADD 1 TO LITERAL COUNT
         LA    WR2,1(WR2)               IN
         ST    WR2,CTLITB(SAVE,ACT)     APPROPRIATE STRING
SETWB1   OI    TXLASI(WBPTR),X'01'      SET LITERAL ASSIGNED INDICATOR
         STC   SAVE,TXLSTG(WBPTR)       SET LITERAL STRING NUMBER
         IC    SP1,CTLEN+3(ACT)
         BCTR  SP1,0
         STC   SP1,TXLLEN(WBPTR)
         TM    CTLREF(ACT),X'80'        IS LREF ON .Q
         BZ    LTVL3                    NO
         LA    SP1,5                    NEED 5 BYTES FOR LITERAL REF
         L     SRB,CSTROM(ACT)          TEST IF ROOM
         BALR  SRR,SRB                  IN SYMBOL TABLE
         DS    2H                       RETURN AFTER HERE IF ROOM
         L     GR1,CFREEP(ACT)          GET SYMBOL TABLE DISPLACEMENT
         LR    GR2,GR1                  TRANSFER IT TO WORK REGISTER
         LA    GR2,5(,GR2)              INCREASE DISPLACEMENT BY 5
         ST    GR2,CFREEP(ACT)          UPDATE S. T. DISPLACEMENT
         A     GR1,CTSYMP(ACT)          ABSOLUTE REFERENCE ADDRESS
         L     GR2,ALWRD                ABSOLUTE DEFINITION ADDRESS
         XC    0(3,GR1),0(GR1)          ZERO LAST REF CHAIN POINTER
         MVC   3(2,GR1),CTSEQN+2(ACT)   ENTER STATEMENT NUMBER
         MVC   ALWRD+1(3),3(GR2)        FORMER END OF REFERENCE CHAIN
         L     SP1,ALWRD                POINTS TO FORMER END OF CHAIN
         ST    GR1,ALWRD                STORE NEW END OF REF CHAIN
         MVC   0(3,SP1),ALWRD+1         NEW LAST LINK IN CHAIN
         MVC   3(3,GR2),ALWRD+1         DEF POINTS TO END OF CHAIN
LTVL3    MVI   LITSW,X'00'              RESET LITERAL SWITCH
         L         SP1,GRASAVE         RESTORE POINTER TO LAST CHAR
         B     CTRTRN(ACT)              BACK TO MAIN LINE
LTVL3A   TM    TXLASI(GRB),1
         BO    LTVL3
         B     LITENT
LCOMP    CLC   0(0,GRA),4(GRD)          EXECUTED COMPARE-SOURCE LITS.
MOVTEX   MVC   4(0,GRD),0(GRA)          EXECUTED MOVE-SOURCE LITS.
MVSYMBKT MVC   0(0,GRD),0(GR1)          EXEC. MOVE - SYMBOL BKTS.
         SPACE 2
* TABLES, CONSTANTS, AND SWITCHES, AND TEMPORARY STORAGE.
         SPACE 1
REGSAV   DC    12F'0'                   REGISTER SAVE AREA
LITPTR   DC    F'0'                     DISP FOR LITERAL POINTER
         DC    F'3'
         DC    F'6'
         DC    F'9'
PREPTR   DC    F'0'                     SAVE AREA FOR WR2
SAVPTR   DS    F                        POINTER TO BEGINNING OF FIELD
FINADR   DS    F                                   END OF FIELD
OPRNLN   DC    F'0'                     OPERAND LENGTH
DSMAX    DC    X'0000FFFF'              MAX LENGTH FOR DS
LOCSW    DC    X'00'                    SWITCH FOR LOCATION CNT REF
DUPFAC   DS    F                        DUPLICATION FACTOR
RSLT     DS    F                        SWITCH FOR ERRORS
LLNG     DS    F                        LENGTH
ERRORPTR DS    F                        COLUMN NUMBER OF ERROR
TOTAL    DS    F                        LOCATION COUNTER
SAVWBP   DS    F                        TEMP STORAGE FOR CTXWBP
GRASAVE  DS        F                   SAVE AREA FOR POINTER
DEFLEN   DC    X'00'                    DEFINITION LENGTH
SIGN     DC    X'00'                    SIGN OF CONSTANT
ALWRD    DC    F'0'                     NO. BYTES OF ALIGNMENT
CON16    DC    H'16'                    MAX LENGTH FOR ZONED
BITREM   DC    H'00'                    BIT REMAINDER
NOCON1   DC    X'00'                    NO. OF CONSTANTS - HALF WORD
NOCONS   DC    X'00'                                     - BYTE
LITSW    DC    X'00'                    SWITCH IF A LITERAL
OPCOD    DC    X'00'                    OPERATION
DCBKT    DS    C                        DC WORKBUCKET COUNTER
*./      DELETE    SEQ1=18130025,SEQ2=18130025
         SPACE 2
* ERROR ASSIGNMENT TABLE
         SPACE 1
ZRC01    MVI   KAPUT+1,1                DUPLICATION FACTOR ERROR.
         B     EXIT
ZRC02    MVI   KAPUT+1,2                RELOCATABLE DUPLICATION FACTOR
         B     EXIT
ZRC03    MVI   KAPUT+1,3                LENGTH ERROR
         B     EXIT
ZRC04    MVI   KAPUT+1,4                RELOCATABLE LENGTH
         B     EXIT
ZRC05    MVI   KAPUT+1,5                S-TYPE CONSTANT IN LITERAL
         B     EXIT
ZRC11    MVI   KAPUT+1,11               SCALE MODIFIER ERROR
         B     EXIT
ZRC12    MVI   KAPUT+1,12               RELOCATABLE SCALE MODIFIER
         B     EXIT
ZRC13    MVI   KAPUT+1,13               EXPONENT MODIFIER ERROR
         B     EXIT
ZRC14    MVI   KAPUT+1,14               RELOCATABLE EXPONENT MODIFIER
         B     EXIT
ZRC15    MVI   KAPUT+1,15               INVALID LITERAL USAGE.
         B     EXIT
ZRC17    MVI   KAPUT+1,17               DATA ITEM TOO LARGE
         B     EXIT
ZRC18    MVI   KAPUT+1,18               SYMBOL ERROR
         B     EXIT
ZRC31    MVI   KAPUT+1,31               UNKNOWN TYPE
         B     EXIT
ZRC39    MVI   KAPUT+1,39               INVALID DELIMITER
         B     EXIT
ZRC87    MVI   KAPUT+1,87               NO ENDING APOSTROPHE
         B     EXIT
ZRC100   MVI   KAPUT+1,100              STATEMENT COMPLEXITY EXCEEDED
         B     EXIT
ZRC107   MVI   KAPUT+1,107              INVALID OPERAND
         B     EXIT
         DS    0F
TRTABL   DC    X'09'                    A
         DC    X'02'                    B
         DC    X'00'                    C
         DC    X'05'
         DC    X'06'                    E
         DC    X'07'                    F
         DC    X'FF'                    G
         DC    X'08'                    H
         DC    X'FF'                    I
         DC    X'FF'                    J
         DC    X'FF'                    K
LCONPTR  DC    X'0E'                    L
         DC    X'FF'                    M
         DC    X'FF'                    N
         DC    X'FF'                    O
         DC    X'03'                    P
QCONPTR  DC    X'0D'                    Q
         DC    X'FF'                    R
         DC    X'0C'                    S
         DC    X'FF'                    T
         DC    X'FF'                    U
         DC    X'0B'                    V
         DC    X'FF'                    W
         DC    X'01'                    X
         DC    X'0A'                    Y
         DC    X'04'                    Z
         SPACE 2
* TYTABL CONTAINS ONE SIX-BYTE ENTRY FOR EACH DC/DS TYPE AS FOLLOWS---
*        BYTE 1 --- 0-3  IMPLIED LENGTH CODE - SEE ILTABLE
*                   4    SOMETHING TO DO WITH ADCONS
*                   5    BIT LENGTH LEGAL=1
*                   6    SCALE MODIFIER LEGAL=1
*                   7    EXPONENT MODIFIER LEGAL=1
*        BYTE 2 --- 0-7  MINIMUM LENGTH MODIFIER VALUE
*        BYTE 3 --- 0-7  MAXIMUM LENGTH MODIFIER VALUE MINUS ONE
*        BYTES 4-6       BRANCH ADDRESS FOR SCAN ROUTINE
         SPACE 1
TYTABL   DC    X'0401FF'                CHARACTER
         DC    AL3(CTYP)
         DC    X'0401FF'                HEXADECIMAL
         DC    AL3(XTYPE)
         DC    X'0401FF'                BINARY
         DC    AL3(BTYPE)
         DC    X'04010F'                PACKED
         DC    AL3(PTYPE)
         DC    X'04010F'                ZONED
         DC    AL3(PTYPE)
         DC    X'370107'                DBL. PRECISION FLT. PT.
         DC    AL3(FHEDSCAN)
         DC    X'270107'                SGL. PRECISION FLT. PT.
         DC    AL3(FHEDSCAN)
         DC    X'270107'                FULL WORD FIXED POINT
         DC    AL3(FHEDSCAN)
         DC    X'170107'                HALF WORD FIXED POINT
         DC    AL3(FHEDSCAN)
         DC    X'2C0103'                A-CON
         DC    AL3(ATYPE)
         DC    X'1C0101'                Y-CON
         DC    AL3(YTYPE)
         DC    X'280303'                V-CON
         DC    AL3(VTYPE)
         DC    X'180201'                S-CON
         DC    AL3(STYPE)
         DC    X'280103'                Q-CON
         DC    AL3(QTYPE)
         DC    X'47010F'                L-CON
         DC    AL3(FHEDSCAN)
         SPACE 2
* ILTABLE CONTAINS A ONE-BYTE ENTRY FOR EACH DIFFERENT IMPLIED
*        LENGTH CODE FROM BYTE 1, BITS 0-3, OF TYTABL.  ITS
*        PURPOSE IS CONSERVE BITS IN TYTABLE.  THIS TABLE YIELDS
*        ACTUAL VALUE OF THE IMPLIED LENGTH.
ILTABLE  DC    X'0102040810'            CODES 0 - 4
         SPACE 2
LNKSAV   DS    F                        DCEVAL BASE REGISTER
SAVLEN   DS    F                        LENGTH OF SYMBOL BUCKETS
RELEQL   DC    H'0'                     RELATIVE POINTER TO OPERAND
ADCSW    DC    X'00'                    ADDRESS CONSTANT SWITCH
VSCNSW   DC    X'00'                    V-TYPE CONSTANT SWITCH
EXITSW   DC    X'00'                    EXIT SWITCH FOR WHICH SCAN
ERSW     DS    X                        ERSW THRU FCONS INITIALIZED
FOPND    DS    X                         WITH ONE XC. DO NOT DISTURB.
FCONS    DS    X
PZLNAT   DS    F                        PZLNAT THRU WLMOD INITIALIZED
SCMODF   DS    H                         WITH ONE XC. DO NOT DISTURB
DCTYP1   DC    X'00'                    DC TYPE - HALF WORD
DCTYP    DS    X                                - BYTE
ALBYS    DS    X                        NO. BYTES FOR ALIGNMENT
RLSW     DS    X                        SWITCH TO UP-DATE RECORD LENGTH
LMSW     DS    X                        LENGTH MODIFIER PRESENT SWITCH
BITSW    DS    X                        BIT SWITCH
EXMODF   DS    X                        EXPONENT RIGHT ADJUSTED
WLNAT    DS    X                        WKBKT LENGTH ATTRIBUTE
WFLAG    DS    X                              FLAG
WTYP     DS    X                              TYPE
WTOTL    DS    XL3                            OPERAND LENGTH
WDUP     DS    XL3                            DUP FACTOR
WNCONS   DS    X                              NUMBER OF CONSTANTS
WPTR1    DS    X                              POINTER FIRST BYTE OPERND
WEXP     DS    X                              EXPONENT
WSCL     DS    XL2                            SCALE FACTOR
WLMOD    DS    XL2                            LENGTH MODIFIER
FHEDSW   DS    C                        SIGN, EXPONENT, POT SWITCH
         SPACE 2
* THIS IS A CONNECTOR TO THE EXPRESSION EVALUATION SUBROUTINE.
         SPACE 1
XPREVA   MVI   ADCSW,X'FF'              SET ADR CON SWITCH
         OI    F8YDC+1(ACT),1           SET EEVAL ADCON SWITCH
         B     XPREV2
XPREV    OI    CTPDSI(ACT),X'20'        SET PREV. DEF. SYMBOL SWITCH
         CLI   0(GRA),ILPARN            TEST FOR LEFT PAREN.
         BE    XPREV1
         CLI   0(GRA),I9                TEST FOR NUMERIC
         BH    XPREV2
         OI    CTSDVI(ACT),X'80'        SET SELF DEFINING VALUE SWITCH
         B     XPREV2
XPREV1   LA    GRA,1(GRA)               KICK TEXT POINTER
XPREV2   LR    SP1,GRA                  TEXT POINTER TO SP1 FOR EEVAL.
         ST    SP1,ERRORPTR             STORE COLUMN POINTER FOR LOGERR
         CLI   VSCNSW,X'FF'             TEST FOR SECOND SCAN
         BNE   FRSTSCN                  BRANCH IF FIRST SCAN.
         MVI   XREF+1,2                 SAVEXREF BIT FROM CENTRAL
         NC    XREF+1(1),CTXRFI(ACT)     TABLE AND THEN TURN IT OFF TO
         NI    CTXRFI(ACT),X'FD'         PREVENT DOUBLE XREF BY EEVAL.
FRSTSCN  ST    SRR,LNKSAV               SAVE DCEVAL BASE REGISTER.
         L     SRB,CEEVAL(ACT)
         BALR  SRR,SRB
         LR    GRA,SP1                  TEXT PTR FROM EEVAL TO GRA.
         BALR  GR1,0                    SAVE RIGHTMOST 32 BITS
         ST    GR1,RSLT                  OF PSW IN RSLT.
         NI    F8YDC+1(ACT),X'FE'       RESET EEVAL ADCON SWITCH
         CLI   0(GRA),IRPARN            TEST FOR RIGHT PAREN.
         BNE   XPREV3
         CLI   ADCSW,X'FF'              TEST ADDR CON SWITCH
         BE    XPREV3
         LA    GRA,1(GRA)               KICK TEXT POINTER
XPREV3   L     SRR,LNKSAV               LOAD RETURN REGISTER
         MVI   ADCSW,X'00'
         CLI   LITSW,X'FF'              TEST FOR LITERAL
         BNE   XPREV3A                  NO,BRANCH
         MVC   CTXWBP(4,ACT),SAVWBP     YES, RESTORE SYMBOL BKT PTR.
XPREV3A  CLI   VSCNSW,X'FF'             TEST FOR SECOND SCAN
         BCR   7,SRR                    RETURN NOW IF FIRST SCAN
XREF     OI    CTXRFI(ACT),0            RESTORE XREF BIT IN CENT. TBL.
         BR    SRR                      RETURN FROM WHENCE THOU CAME
WR1      EQU   GRC                      6
WR2      EQU   GRD                      7
EVENR    EQU   GRX                      14
ODDR     EQU   GRY                      15
R1       EQU   WR1
SAVE     EQU   GRX                      14
WBPTR    EQU   GRB                      5
DS       EQU   X'27'                    DS OP-CODE
GR14     EQU   14
YTYPE    EQU   ATYPE
         LTORG
         END   DCEVL
./ ADD NAME=ASMGF7E
F7E     TITLE      'ASMG F7  EXTERNAL SYMBOL DICTIONARY PROCESSOR'
         ISEQ  73,78
ASMGF7E  CSECT
         PRINT DATA,NOGEN
         FDIMEN
         USING *,FRB
 SPACE
*TITLE- ASMGF7E  EXTERNAL SYMBOL DICTIONARY PROCESSOR                 *
*FUNCTION/OPERATION-                                                  *
*   GENERATE EXTERNAL SYMBOL DICTIONARY ENTRIES                       *
*   UPDATE THE LOCATION COUNTER IN ESD ENTRIES                        *
*   GENERATE SYMBOL TABLE ENTRIES FOR NAMES IN THE NAME FIELD OF      *
*    STATEMENTS HANDLED BY ASMGF7E                                    *
*   SET AND MAINTAIN THE FOLLOWING ASSEMBLER CONTROL TABLE SWITCHES-  *
*        CBDNO...BLANK DSECT ESD NUMBER                               *
*        CBDSW...BLANK DSECT ID NUMBER                                *
*        CCMNO...COMMON ESD NUMBER                                    *
*        CESDID..CURRENT ESD ID NUMBER                                *
*        CESDNO..CURRENT ESD NUMBER                                   *
*        CNOESD..NUMBER OF ESD ENTRIES                                *
*        CPCNO...UNINITIATED PRIVATE CODE ESD NUMBER                  *
*        CTPCSW..PRIVATE CODE SWITCH                                  *
*        CSTVAL..VALUE FROM START CARD                                *
*        CSGCTR..ESD RESIDENT SEGMENT COUNTER                         *
*        CLASID..LAST ESD ID NUMBER                                   *
*        CNTDID..NEXT DSECT ID NUMBER                                 *
*        CTCMSW..COMMON SWITCH                                        *
*        CTESDP..ESD TABLE POINTER (FIRST BYTE)                       *
*        CTESRN..FIRST ESD NUMBER                                     *
*        CTESRP..ESD SEGMENT RESIDENCE TABLE ENTRY POINTER            *
*        CTFSTN..FIRST CSECT NAME                                     *
*        CTLOC...CURRENT LOCATION COUNTER                             *
*        CTYPE...CURRENT CSECT TYPE                                   *
*   DTECT AND LOG THE FOLLOWING ERRORS                                *
*        INVALID ORIGIN                                               *
*        EXTERNAL NAME ERROR                                          *
*        SYMBOL NOT PREVIOUSLY DEFINED                                *
*        ESD TABLE OVERFLOW                                           *
*        RELOCATABILITY ERROR                                         *
*        ALIGNMENT ERROR                                              *
*        ENTRY ERROR                                                  *
*        INVALID DELIMITER                                            *
*        ILLEGAL START CARD                                           *
*        ENTRY TABLE OVERFLOW                                         *
*ENTRY POINTS-                                                        *
*        UPC...PROCESS UNINITIATED PRIVATE CODE                       *
*        COM,START,CSECT,DSECT...PROCESS STATEMENTS OF SAME NAMES     *
*        ENTRY,EXTRN,WXTRN,ORG...PROCESS STATEMENTS OF SAME NAMES     *
*        QUIT...                                                      *
*        DXD...                                                       *
*        VCON...PROCESS VCON'S OR QCON'S                              *
*INPUT-  NONE                                                         *
*OUTPUT- NONE                                                         *
*   CALLING SEQUENCE-                                                 *
*        L     GRX,NAME(ACT)       NAME(ACT) CONTAINS DESIRED ADDRESS *
*        B     CTLNK2(ACT)         BRANCH TO LINKAGE CODE WITHIN ACT  *
*     CTLNK2(ACT) CONTAINS-                                           *
*        STM   GRA,GRD,SAVER                                          *
*        L     FRB,CBRNDA(ACT)     CBRNDA(ACT)CONTAINS ASMGF7E ADDRESS*
*        B     GRX                                                    *
*EXTERNAL ROUTINES-                                                   *
*  ASMGF7L (LOGERR)  RECORD ERRORS DETECTED                           *
*  ASMGF7V (EEVAL) OPERAND EVALUATION                                 *
*  ASMGF7I (STPUTR,STGETR,CRDESD,PUTXRF) PERFORM I/O FUNCTIONS        *
*EXIT-                                                                *
*   NORMAL-                                                           *
*        B     CTRTRN(ACT)         BRANCH TO RETURN LINKAGE OF ACT    *
*     CTRTRN(ACT) CONTAINS                                            *
*        LM    GRA,GRD,SAVER                                          *
*        BR    CRR                 RETURN TO CALLING PROGRAM          *
*   ERRORS-                                                           *
*        SAME SEQUENCE AS NORMAL RETURN                               *
*TABLES/WORK AREAS-                                                   *
*   ESD ENTRY WORK AREA...16 BYTES, STARTING AT LOCATION 'TYPE'       *
*NOTES-                                                               *
*                  THE  EXTERNAL SYMBOL DICTIONARY (ESD)  IS
*              SEGMENTED INTO BLOCKS OF 260 BYTES EACH, FULL
*              WORD ALIGNED.  THE FIRST BYTE OF EACH SEGMENT
*              IS SET TO X'03' TO IDENTIFY  THE BLOCK TO THE
*              I/O ROUTINES. 16 ITEMS,WORD-ALIGNED,OF LENGTH
*              16 BYTES EACH FILL THE SEGMENT,  BEGINNING AT
*              THE LAST (HIGHEST NUMBERED) BYTE.
  SPACE 2
*                   THE FORMAT OF EACH ITEM IS AS FOLLOWS
 SPACE
*             ************************************************
*             *                      *                       *
*             * ATTRIBUTES (8 BYTES) * NAME (8 BYTES,PADDED) *
*             *                      *                       *
*             ************************************************
 EJECT
*              THE ATTRIBUTE FIELD FORMAT IS ONE OF THE FOLLOWING
 SPACE
*                   CONTROL OR DUMMY SECTION (PC,CM,SD OR DS)
*
*       *********************************************************
*       *      *                    *      *                    *
*       * TYPE * CURRENT LOC. CTR.  *  ID  * HIGHEST LOC. CTR.  *
*       *      *                    *      *                    *
*       *********************************************************
*
*                   THE LOCATION COUNTERS ARE UPDATED BY THE
*              ROUTINES 'ORG' OR 'ESFIN' WHENEVER A CSECT,
*              DSECT,COM OR ORG INSTRUCTION IS ENCOUNTERED
*              IN ASSIGNMENT MODE.
  SPACE
*                   EXTERNAL SYMBOL (ER, WX OR VC)
*
*       *********************************************************
*       *      *                    *      *                    *
*       * TYPE *        ZERO        *  ID  *        ZERO        *
*       *      *                    *      *                    *
*       *********************************************************
 SPACE
*                   ENTRY LABEL DEFINITION (LD)
*
*       *********************************************************
*       *      *                    *      *                    *
*       * TYPE *      ADDRESS       * FLAG *    ZERO     * LDID *
*       *      *                    *      *                    *
*       *********************************************************
*
*                   THE FLAG IS SET TO ONE TO INDICATE THAT
*              THE ITEM IS COMPLETE. THE ADDRESS AND LDID
*              IDENTIFY THE RELATIVE LOCATION AND ESDID OF
*              THE SYMBOL REFERENCED
 SPACE
*                   EXTERNAL DUMMY SECTION (XD)
*
*       *********************************************************
*       *      *             *      *      *                    *
*       * TYPE *    ESDNO    *ALIGN *  ID  *       LENGTH       *
*       *      *             *      *      *                    *
*       *********************************************************
*
*                   THE ESDNO IS USED TO POINT TO THE  DSECT
*              REFERENCED BY THE CORRESPONDING Q-CON.  IT IS
*              ZERO,AND THE LENGTH FIELD SET, WHEN THE ITEM
*              WAS CREATED BY A DXD INSTRUCTION. ALIGN GIVES
*              THE ALIGNMENT.
         SPACE 2
*              PHASE 7 MAIN LINE PASSES CONTROL TO ONE OF THESE       *
*        ENTRY POINTS ON ANY STATEMENT WHICH AFFECTS THE EXTERNAL     *
*        SYMBOL DICTIONARY.  ITEMS ARE ENTERED IN THE DICTIONARY,     *
*        UPDATED WHEN NECESSARY,AND SYMBOL TABLE ENTRIES MADE.        *
*                                                                     *
 SPACE
         ENTRY UPC,COM,START,CSECT,DSECT,DXD
         ENTRY ENTRY,EXTRN,ORG,QUIT,VCON
         EJECT
***********************************************************************
***                 UNINITIATED PRIVATE CODE ROUTINE                ***
*    THE UNINITIATED PRIVATE CODE ROUTINE IS CALLED WHENEVER AN EQU,  *
*  ORG, LTORG, LITR, DC, DS, CCW, CNOP, OR MACHINE OP IS ENCOUNTERED  *
*  BEFORE THE FIRST CSECT, START, COMMON, OR DSECT.                   *
*                                                                     *
UPC      MVC   NAME(8),IBL2F            BLANK OUT NAME
         BAL   LEV3,FSTNR               PROCESS IF FIRST ONE
         MVI   TYPE,PCCON               SET TYPE = PC
         SR    ACC,ACC
         ST    ACC,CTLOC(ACT)           SET CURRENT LOC CTR = 0
         BAL   LEV2,SETESD              PUT IN ESD
         MVI   CTYPE(ACT),PCCON         SET TYPE = PC
         MVC   CTPCSW(1,ACT),CESDID(ACT)    PC SWITCH AND FIRST CONTROL
         MVC   CPCNO(2,ACT),CESDNO(ACT)
         STM   GRA,CRR,SAVEREG          SAVE REGISTERS
         L     GRB,CTEXTP(,ACT)         SAVE TEXT RECORD POINTER
         LA    GRA,TEXTREC              POINT TO SIMULATED CSECT
         ST    GRA,CTEXTP(,ACT)         AND TELL ACT
         L     FRB,CTESTR(,ACT)         ADDRESS FOR TESTRAN ENTRY
         BALR  CRR,FRB                  MAKE THE TESTRAN ENTRY
         ST    GRB,CTEXTP(,ACT)         RESTORE TEXT RECORD POINTER
         LM    GRA,CRR,SAVEREG          RESTORE REGISTERS
         B     CTRTRN(ACT)              EXIT
*                                                                     *
SAVEREG  DC    4F'0'                    REGISTER SAVE AREA
TEXTREC  DC    X'000000801B00000000'    SIMULATED CSECT RECORD
***********************************************************************
 SPACE 2
***********************************************************************
***                          COM ROUTINE                            ***
*                                                                     *
COM      MVI    TYPE,CMCON              SET TYPE = CM
         MVI       CTYPE(ACT),CMCON
         BAL       LEV3,GETNAME        IS IT NAMED COM ?
         B         COMBLANK            NO
         L         SRR,ADLIST1(,ACT)   YES, TEST EXTEN OPTION
         TM        L1PBYT1(SRR),X'04'  WAS EXTEN SPECIFIED .Q
         BO        DSECTCOM            ON - TREAT LIKE DSECT
         BAL       SRR,LOGERR          OFF - ILLEGAL NAME
         DC        AL2(ERR15)
         B         DSECTCOM            PROCESS ANYWAY
COMBLANK BAL    LEV1,ESFIN              FINISH PREVIOUS SECTION IF ANY
         MVC   CTLOC(4,ACT),CTZERO(ACT) SET CTLOC = 0
*./      DELETE    SEQ1=03520020,SEQ2=03520020
         CLI   CTCMSW(ACT),0            HAS COM BEEN PREVIOUSLY STARTED
         BC    7,CMCONT                   YES
 SPACE
         BAL   LEV2,SETESD                NO - SET ESD
*./      DELETE    SEQ1=03620020,SEQ2=03620020
CMCNTR   MVC   CTCMSW(1,ACT),CESDID(ACT)   COM SWITCH
         MVC   CCMNO(2,ACT),CESDNO(ACT)     COM ESD NO
         B     SETWBK                   CREATE WORKBUCKET
 SPACE 2
CMCONT   LH    SP2,CCMNO(ACT)
         STH   SP2,CESDNO(ACT)          SET CURR ESD NO FOR CM
         BAL   LEV2,PNTESD              POINT TO PREVIOUS ESD ITEM FOR
         MVC   ESDID(1,ACT),TID(SP1)      COM
         MVC   CESDID(1,ACT),TID(SP1)   SET ESDID -ASSIGNED AND CURRENT
         MVC   CTLOC+1(3,ACT),TADDR(SP1) SET CURR LOC CTR
         B     CMCNTR                   CONTINUE WITH ESD SET
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
***                            START ROUTINE                        ***
*                                                                     *
*                                                                     *
START    CLI   CESDID(ACT),0            IS THIS THE 1ST CONTROL SECTION
         BE    SRT1ST                   YES, CONTINUE
 SPACE
SRTERR   BAL   SRR,LOGERR               NO, ERROR - ILLEGAL START CARD
         DC    AL2(ERR01)
         B     CSECT                    TREAT AS CSECT
 SPACE 2
SRT1ST   L     SP1,CTXOFP(ACT)            YES - IS THE OPERAND PRESENT
         BAL   LEV3,ISOPF               IS THERE AN OPERAND FIELD
         BC    8,CSECT                  NO, TREAT AS CSECT
 SPACE
         LA    SP1,1(SP1)                   YES - POINT TO OPERAND
         ST    SP1,ERRPTR               SAVE OPERAND COLUMN POINTER
         OI    CTSDVI(ACT),ONSDVI        AND SET SELF-DEFINING VALUE
         L     SRB,CEEVAL(ACT)            INDICATOR ON
         BALR  SRR,SRB                  EVALUATE EXPRESSION
         TM    CTSDVI(ACT),ONSDVI       WAS SELF-DEFINING VALUE FOUND
         BZ    SRTABS                   YES, CONTINUE
 SPACE
         BAL   SRR,ELOGER               NO, ERROR - RELOCATION ERROR
         DC    AL2(ERR03)
         B     CSECT                    AND TREAT AS CSECT
 SPACE 2
SRTABS   CLI   0(SP1),IBLANK            IS NEXT CHARACTER A BLANK
         BE    SRTSET                   YES, CONTINUE
 SPACE
         BAL   SRR,LOGERP               NO, ERROR - INVALID DELIMITOR
         DC    AL2(ERR02)
         B     CSECT                    AND TREAT AS CSECT
 SPACE
SRTSET   ST    SP2,CSTVAL(ACT)            YES - SET START VALUE
         TM    CSTVAL+3(ACT),MOD8       IS START VALUE = 0 MOD 8
         BZ    CSECT                      YES - GO TO CSECT
 SPACE
         LA    SP2,7(SP2)                 NO - SET START VALUE TO NEXT
         N     SP2,=F'-8'                   MULTIPLE OF 8
         ST    SP2,CSTVAL(ACT)
         BAL   SRR,ELOGER               LOG IT AS ERROR - ALIGNMENT
         DC    AL2(ERR04)
*        B     CSECT                    AND GO ON
*                                                                     *
***********************************************************************
         EJECT                                                 MMM
***********************************************************************
***                          CSECT ROUTINE                          ***
CSECT    MVI   TYPE,SDCON               SET TYPE = SD
         MVI   CTYPE(ACT),SDCON
         BAL   LEV1,ESFIN               FINISH PREVIOUS SECTION IF ANY
 SPACE
         MVC   CTLOC(4,ACT),CTZERO(ACT) SET CURRENT LOC. CTR TO ZERO
         BAL   LEV3,GETNAME             GET THE NAME
         NOP   CSP3                     NAME BLANK
 SPACE
CSP3     BAL   LEV3,FSTNR               SET FIRST ESDNO IF FIRST TIME
         L     ACC,CTXABP(ACT)          IS WORKBUCKET FILLED
         CLI   WBKSW(ACC),FILLED
         BZ    CWBKFL                   YES, SKIP
 SPACE
         CLC   NAME(8),IBL2F            NO - IS NAME BLANK
         BZ    CSPC                         YES - PRIVATE CODE
 SPACE
         BAL   LEV3,STGET               GET SYMBOL
         LA    LEV2,SETWBK              IF ABSENT,
         BZ    SETESD                    SET ESD AND EXIT
 SPACE
         MVC   TEMPH(2),0(SP1)          SYMBOL FOUND IN ST - CHECK TYPE
         B     FNDTOG
 SPACE
CWBKFL   MVC   TEMPH(2),WBKNO(ACC)      IF WKBKT IS FULL
FNDTOG   L     SP2,TEMPF                  FIND ADJ CODE AND
         SRL   SP2,7                    ESDNO
         NI    ADJ,SDMSK
         CLI   ADJ,SDBITS               IS ADJ CODE = SD
         BNE   FNDERR                   NO, LOG ERROR
 SPACE 2
FNDENT   STH   SP2,CESDNO(ACT)          SET CURR ESD NO
         BAL   LEV2,PNTESD                POINT TO ESD
         IC    ACC,TID(SP1)             GET ID
         STC   ACC,ESDID(ACT)           SET ASSIGNED AND
         STC   ACC,CESDID(ACT)          CURRENT ESDID
         MVC   CTLOC+1(3,ACT),TADDR(SP1)    AND CURR LOC CTR
         BAL   LEV3,XREF1               REFERENCE
         B     SETWBK                   SET WKBKT AND EXIT
 EJECT
FNDERR   BAL   SRR,LOGERR               LOG ERROR - EXTERNAL NAME
         DC    AL2(ERR05)
         BAL   LEV3,XREF2               CROSS REFERANCE - DUPLICATE
         MVC   NAME(8),IBL2F            BLANK OUT NAME
CSPC     MVI   TYPE,PCCON               SET TYPE = PC
         MVI   CTYPE(ACT),PCCON
         LH    SP2,CPCNO(ACT)           IS PC INITIATED
         LTR   SP2,SP2
         BNZ   FNDENT                   YES, GO TO FNDENT
         BAL   LEV2,SETESD              NO, SET ESD
         MVC   CPCNO(2,ACT),CESDNO(ACT)  AND PCNO
*                                                                     *
*                                                                     *
SETWBK   L     ACC,CTXABP(ACT)          GET PLACE TO PUT WORK BUCKET
         MVC   WBKTYP(1,ACC),TYPE       SET TYPE IN WKBKT
         MVC   WBKID(1,ACC),ESDID(ACT)  SET ID IN WKBKT
         MVI   WBKSW(ACC),FILLED        SET SWITCH IN WKBKT = FILLED
         B     CTRTRN(ACT)              EXIT
*                                                                     *
LOGERR   SR    SP1,SP1                  LOG ERROR
LOGERP   L     SRB,CLOGER(ACT)
         BR    SRB                      AND QUIT
 SPACE
***********************************************************************
         EJECT
***********************************************************************
***                          DSECT ROUTINE  (ALSO NAMED COMMON)     ***
*                                                                     *
DSECT    MVI   TYPE,DSCON               SET TYPE = DS
         MVI   CTYPE(ACT),DSCON
DSECTCOM BAL   LEV1,ESFIN               FINISH PREVIOUS SECTION IF ANY
         MVC   CTLOC(4,ACT),CTZERO(ACT) SET CURRENT LOCATION CTR = 0
 SPACE
         BAL   LEV3,GETNAME             GET NAME
         B     DSBLNK                   NO NAME
 SPACE
         L     SP1,CTXABP(ACT)
         CLI   WBKSW(SP1),FILLED         IF WORKBUCKET IS FULL
         BE    DSWBKFL                  YES, GO TO DSWBKFL
 SPACE
         BAL   LEV3,STGET               GET SYMBOL
          LA   LEV2,SETWBK              SET ESD  AND EXIT
          BZ   SETESD
 SPACE
         MVC   TEMPH(2),0(SP1)          SYMBOL WAS FOUND
         B     DSFNDT
 SPACE
DSWBKFL  MVC   TEMPH(2),WBKNO(SP1)
DSFNDT   L     SP2,TEMPF                  FIND ADJ CODE AND
         SRA   SP2,7                    ESDNO
         TM    ADJ,SDMSK
         BO    DSERR                    ERROR IF NAME TYPE
         STH   SP2,CESDNO(ACT)             SET CURR ESDNO
         BAL   LEV2,PNTESD
         CLC       TTYPE(1,SP1),TYPE   SAME TYPE AS BEFORE ?
         BNE   DSERR
 SPACE
         MVC   CTLOC+1(3,ACT),TADDR(SP1)  SET CURRENT LOCATION COUNTER
         IC    ACC,TID(SP1)
         STC   ACC,ESDID(ACT)           SET ASSIGNED AND
         STC   ACC,CESDID(ACT)          CURRENT ESDID
         BAL   LEV3,XREF1               REFERENCE
          B    SETWBK                   EXIT
 EJECT
DSERR    BAL   SRR,LOGERR
         DC    AL2(ERR05)
         BAL   LEV3,XREF2               DUPLICATE
         MVC   NAME(8),IBL2F
DSBLNK   CLI   CBDSW(ACT),0             IS BLANK DSECT SWITCH = 0
         LA    LEV2,BDTYP               YES - SET ESD AND GO TO BDTYP
         BZ    SETESD
 SPACE
         LH    SP2,CBDNO(ACT)           NO
         STH   SP2,CESDNO(ACT)          SET CURRENT ESDNO
         BAL   LEV2,PNTESD              POINT TO ESD
         MVC   CESDID(1,ACT),TID(SP1)     SET CURRENT ESDID
         MVC   ESDID(1,ACT),TID(SP1)      SET ESDID
         MVC   CTLOC+1(3,ACT),TADDR(SP1)  SET CURRENT LOC CTR
BDTYP    MVC   CBDNO(2,ACT),CESDNO(ACT) SET CBDNO,CBDSW
         MVC   CBDSW(1,ACT),CESDID(ACT)
          B    SETWBK                   EXIT
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
DXD      MVI   TYPE,DXCON               SET TYPE = DX
         BAL   LEV3,GETNAME             GET THE NAME
         B     CTRTRN(ACT)              NO NAME, EXIT
 SPACE
         BAL   LEV3,STGET               GET SYMBOL
         BNZ   DXERR                    MULTIPLE DEFINITION
 SPACE
         L     TXPTR,CTXABP(ACT)        GET ALIGNMENT
         SR    ALN,ALN                   FROM TEXT
         IC    ALN,ALNBYTE(TXPTR)        WORKBUCKET
         N     ALN,=F'15'               AND SET ON
         SRL   ALN,1
         STC   ALN,ALIGN                ON
         L     LTH,CTLOC(ACT)
         CLC   CTLOC+1(3,ACT),TXLOC(TXPTR)   IF ZERO LENGTH
         BE    CTRTRN(ACT)              TREAT AS COMMENT
 SPACE
         SR    LTH,ALN                  COMPUTE LENGTH
         BCTR  LTH,0
         ST    LTH,ALTH-1
         BAL   LEV2,SETESD              SET ESD
         B     CTRTRN(ACT)              EXIT
 SPACE 2
DXERR    BAL   LEV3,XREF2               DUPLICATE
         BAL   SRR,LOGERR               LOG ERROR
         DC    AL2(ERR05)
         B     CTRTRN(ACT)              EXIT
 SPACE
***********************************************************************
         EJECT
***********************************************************************
***                        ENTRY ROUTINE                            ***
*                                                                     *
ENTRY    L     WBP,CTXWBP(ACT)          GET ADDRESS OF WKBKT
         BALR  ELOOPR,0                 LOOP REGISTER
         LH    ECT,ECTR                 COUNT DOWN TABLE
         BCT   ECT,ECTROK               REDUCE BY ONE
 SPACE
         BAL   LEV3,ENAMGET             SET COLUMN POINTER
         BAL   SRR,ELOGER               NONE LEFT, LOG ERROR
         DC    AL2(ERR08)
         B     CTRTRN(ACT)              END PROCESSING STATEMENT
 SPACE
ECTROK   STH   ECT,ECTR                 STORE UDDATED COUNTER
         TM    EWBCMP(WBP),ECMPLT       IS WKBKT COMPLETE
         BO    ENTEXX                   YES, EXIT
 SPACE
         BAL   LEV3,ENAMGET             GET NAME AND SYMBOL TABLE ITEM
         MVI   TYPE,LDCON               SET TYPE = LD
         BC    7,ENTFND                 BRANCH IF FOUND
 SPACE
         TM   EWBKSW(WBP),FULL          TEST WORKBUCKET SWITCH
         BO    ENTFUL                   IF ON - USE WORKBUCKET
 SPACE
         BAL   LEV3,ESCRBL               OFF - CREATE BLANK ESD ITEM
         MVC   EWBKNO(2,WBP),CNOESD(ACT) SET ESDNO IN BUCKET
         B     ENTEXX                   SEE IF MORE
 SPACE 2
ENTFUL   MVI   AID,1                    SET ID
         MVC   ADDR,EWBKVL(WBP)         MOVE IN ADDRESS
         MVC   ALTH+2(1),EWBKID(WBP)    AND LENGTH
         BAL   LEV3,ESCRBL              CREATE COMPLETE ESD ITEM
         B     ENTEX
 SPACE 2
ENTFND   TM    STADJ(SP1),ENTCMB        IF ENTRY COMPLETE,ER-O-
         BO    ENTERR
 SPACE
         BAL   LEV3,ENTESTS
         MVC   ADDR,SYMVAL(SP1)
         MVI   AID,1
         MVC   ALTH+2(1),STID(SP1)
         OI    STADJ(SP1),ENTCMB
         BAL   LEV3,ESCRBL              CREATE COMPLETE ESD ITEM
         B     ENTEX                    SET WKBKT COMPLETE & SEE IF MOR
 SPACE 2
ENTERR   BAL   SRR,ELOGER               LOG ERROR - ENTRY ERROR
         DC    AL2(ERR06)
         B     ENTEX                    AND SEE IF MORE
 EJECT
ENTESTS  CLI   STID(SP1),0              IS SYMBOL ABSOLUTE
         BE    ENTABS                   YES, LOG ERROR
         TM    STADJ(SP1),DSOCM           NO - WAS IT DEFINED IN DS,CM
         BO    ENTERR                       YES - ERROR
         TM    STADJ(SP1),SDBIT               NO - IS IT SECTION DEF
         BZ    ENTEX                    YES, ENTER WKBKT AND SEE IF MOR
         BM    ENTERR                   EXTRN OR DSECT, LOG ERROR
 SPACE
         MVC   TEMPH,EWBKNO(WBP)        GET ESDNO
         LH    SP2,TEMPH
         LTR   SP2,SP2
         BCR   8,LEV3                   RETURN IF ESDNO NOT SET
 SPACE
         LR    GRA,SP1                  FETCH INCOMPLETE ESD ITEM
         BAL   LEV2,PNTESD              POINT TO ESD
         MVC   TADDR(3,SP1),SYMVAL(GRA) COMPLETE IT
         MVC   TLTH+2(1,SP1),STID(GRA)
         MVI   TID(SP1),1
ENTEX    L     WBP,CTXWBP(ACT)
         OI    EWBCMP(WBP),ECMPLT       SET WORKBUCKET COMPLETE
EFULL    OI    EWBKSW(WBP),FULL         SET WORKBUCKET SWITCH
ENTEXX   TM   EWBKSW(WBP),LASTOP
         BO    CTRTRN(ACT)              EXIT IF LAST OPERAND
 SPACE
         LA    WBP,WBKLEN(WBP)          POINT TO NEXT WORKBUCKET
         ST    WBP,CTXWBP(ACT)
         BR    ELOOPR                   AND LOOP FOR NEXT OPERAND
 SPACE
ENTABS   BAL   SRR,ELOGER               LOG ERROR - RELOCATION
         DC    AL2(ERR13)
         B     ENTEX                    AND SEE IF MORE
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
***                      EXTRN/WXTRN ROUTINE                        ***
*                                                                     *
WXTRN    EQU   *
EXTRN    L     WBP,CTXWBP(ACT)          SET WORK BUCKET POINTER
         BALR  ELOOPR,0                 LOOP REGISTER
 SPACE
         MVI   TYPE,ERCON               SET TYPE = ER
         TM    CTSWXT(ACT),SETWX        EXTRN OR WXTRN .Q
         BZ    EXTRN2                   SKIP IF EXTRN
         MVI   TYPE,WXCONA              SET TYPE = WX
EXTRN2   TM    EWBKSW(WBP),FULL         IS WKBKT FULL .Q
         BO    EFULL                    YES, GO SEE IF MORE
 SPACE
         BAL   LEV3,ENAMGET             GET NAME AND SYMBOL TABLE ITEM
         BC    7,EXERR                   ERROR IF IN SYBBOL TABLE
 SPACE
         OI    VMATCH,X'F0'
         BAL   LEV2,SCHESD              WAS ESD ITEM FOUND
         LA    LEV2,EFULL                IF NOT FOUND,
         BNZ   SETESD                    GO TO SETESD AND EXEX
 SPACE
EXFND    CLI   TTYPE(BEGIN),VCCON       IS IT A V-TYPE
         BNE   EXERR                    NO, LOG ERROR
 SPACE
         MVI   TTYPE(BEGIN),ERCON       SET TYPE = ER
         TM    CTSWXT(ACT),SETWX        EXTRN OR WXTRN .Q
         BZ    EXTRN3                   SKIP IF EXTRN
         MVI   TTYPE(BEGIN),WXCONA      SET TYPE = WX
EXTRN3   MVC   ESDID(1,ACT),TID(BEGIN)
         MVI   ADJCOD(ACT),1
         LA    SP1,NAME
         SR    SP2,SP2
         L     SRB,STPUT(ACT)           PUT IN NAME IN SYMBOL TABLE
         BALR  SRR,SRB
         NOP   0                        IGNORE IF FOUND
EXEX     B     EFULL                    GO SEE IF MORE
 SPACE
EXERR    BAL   SRR,ELOGER               LOG ERROR - EXTERNAL NAME
         DC    AL2(ERR05)
         B     EXEX                     AND SEE IF MORE
 EJECT
***********************************************************************
 SPACE
***********************************************************************
*                                       LEVEL 3 - FIND IN SYMBOL TABLE*
ENAMGET  SR    SP1,SP1
         LR    SP2,SP1                  CLEAR PARAMETER REGISTERS
         IC    SP1,TXSPTR(WBP)
         A     SP1,CTXOFP(ACT)
         LA    SP1,1(SP1)               POINTER TO NEXT OPERAND
         IC    SP2,TXSBLN(WBP)
         N     SP2,=F'15'               NAME LENGTH
         MVC   NAME,IBL2F               BLANK NAME
         LR    ACC,SP2
         BCTR  ACC,0                    MACHINE CODE LENGTH
         EX    ACC,MVNMEV               MOVE IN NAME
         ST    SP1,ERRPTR               LOCATION FOR ERROR POINTER
         L     SRB,CSTGET(ACT)          LOAD BASE
         BALR  SRR,SRB                  SYMBOL TABLE GET
         LTR   SP1,SP1                  SET CONDITION CODE ON RESULT
         BR    LEV3                     RETURN
 SPACE
ELOGER   L     SP1,ERRPTR               CALL LOG ERROR
         L     SRB,CLOGER(ACT)
         BR    SRB                      EXIT
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
***                           ORG ROUTINE                           ***
*                                                                     *
ORG      LH    SP2,CESDNO(ACT)
         BAL   LEV2,PNTESD              POINT ESD
         CLC   CTLOC+1(3,ACT),TLTH(SP1) IS LOC CTR GTR TLTH
         BC    NOTHI,ORGEE              NO, GO AROUND
 SPACE
         MVC   TLTH(3,SP1),CTLOC+1(ACT)   YES - SET TLTH = LOC CTR
 SPACE
ORGEE    BAL   LEV3,ISOPF               IS THERE AN OPERAND FIELD
         BZ    ORGNOP                   NO, SET LOC CTN = TLTH
 SPACE
         OI    CTPDSI(ACT),PDSI         OPERAND MUST BE PREVIOUSLY DEF
         L     SP1,CTXOFP(ACT)
         LA    SP1,1(SP1)                 YES
         L     SRB,CEEVAL(ACT)             EVALUATE OPERAND
         BALR  SRR,SRB                  WHAT TYPE EXPRESSION
         BC    4,ORGID                  SIMPLE RELOCATABLE
         BC    10,ORGERR                COMPLEX OR ABSOLUTE - LOG ERROR
         L     ACC,CTEXTP(ACT)          EVALUATION IMPOSSIBLE
         NI    TXTO(ACC),X'3F'          LOG ERROR
         B     CTRTRN(ACT)              AND EXIT
 SPACE
ORGID    CLC   PARID(1,SP2),CESDID(ACT) CHECK CONTROL SECTION
         BNE   ORGERR                   NOT THE SAME, ERROR
 SPACE
         CLI   0(SP1),IBLANK            IS THERE ONLY ONE OPERAND
         BE    ORGLOC                   YES, CONTINUE
 SPACE
         BAL   SRR,LOGERP               NO, LOG ERROR
         DC    AL2(ERR02)               ONLY ONE OPERAND ALLOWED
         B     CTRTRN(ACT)              EXIT
 SPACE 2
ORGLOC   MVC   CTLOC+1(3,ACT),1(SP2)   SET LOCATION COUNTER
         B     CTRTRN(ACT)                   CTR TO VALUE AND EXIT
 SPACE 2
ORGNOP   MVC   CTLOC+1(3,ACT),TLTH(SP1) SET LOC CTR = TLTH
         B     CTRTRN(ACT)                AND EXIT
 SPACE 2
ORGERR   BAL   SRR,LOGERR               LOG ERROR - INVALID ORIGIN
         DC    AL2(ERR10)
         B     CTRTRN(ACT)              AND EXIT
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
***                          QUIT ROUTINE                           ***
*                                                                     *
QUIT     BAL   LEV1,ESFIN               FINISH PREVIOUS SECTION IF ANY
         B       CTRTRN(ACT)            NO, EXIT
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*        CALLED BY DC EVAL    0(SRR) IS FLAG  1=Q-TYPE, 0=V-TYPE
*                             2(SRR) IS RETURN ADDRESS
*
VCON     STM   SRR,SP1,VSAVE            SAVE LINK AND OPERAND POINTER
         L     WBP,CTXWBP(ACT)          POINT TO WORKBUCKET
         MVI   ESDID(ACT),0             ZERO ID
         MVI   TYPE,VCCON               SET TYPE = VC
         MVC   NAME(8),IBL2F            BLANK NAME
         EX    SP2,MVNMEV               GET NAME FROM TEXT
 SPACE
         TM    0(SRR),1                 IS IT A Q OR V-TYPE
         BO    QCON                     Q-TYPE
 SPACE 2
         TM    CTDORCI(ACT),BIT3        IS IN DSECT OR COM
         BO    VSHSET                   YES, EXIT
         TM    VSAVE,CCHIGH             IS IN DS OR DXD OPERAND
         BO    VSHSET                   YES, EXIT
 SPACE
         NI    VMATCH,X'0F'
         NI    DRTFIX,X'0F'             SET VCON RETURN
         BAL   LEV2,SCHESD              FIND ESD
         LA    LEV2,VCONDRT             SET ESD RETURN
         BC    7,SETESD                 IF NOT FOUND, BUILD ESD
 SPACE
         MVC   ESDID(1,ACT),TID(BEGIN)   ELSE COPY EXISTING ID
VCONDRT  OI    DRTFIX,X'F0'             UPSET VCON RETURN
VSHSET   MVC   TXSLEN(5,WBP),CTZERO(ACT)
         MVC   TXSESD(1,WBP),ESDID(ACT)
         NI    0(WBP),LASTWB+SDMSK      SET WORKBUCKET
         OI    0(WBP),FILLED
         L     SRR,VSAVE                RESTORE
         B     2(SRR)                   RETURN
 EJECT
QCON     BAL   LEV3,XREF1               REFERENCE
         TM    TXSUBS(WBP),X'10'        IS PREVIOUSLY DEFINED
         BZ    QCERRA                   NO, LOG ERROR
 SPACE
         TM    TXSTPC(WBP),DSBITS       IS A DSECT OR DXD
         BZ    QCERRB              NOT DNO, LOG ERROR
         TM    TXSTPC(WBP),SDMSK        IS A CSECT
         BO    QCERRB              NAME YES, LOG ERROR
 SPACE
         TM    CTDORCI(ACT),BIT3        IS CONSTANT DEFINED IN DSECT
         BO    VSHSET                   YES
         TM    VSAVE,CCHIGH             IS IN DS OR DXD OPERAND
         BO    VSHSET                   YES, EXIT
 SPACE
         MVC   ESDID(1,ACT),TXSESD(WBP) SET ESDID
         CLC   CTNDID+1(1,ACT),TXSESD(WBP)    COMPARE WITH NEXT DSECT
         BH    VSHSET              DEF AS DXD
 SPACE
         OI    VMATCH,X'F0'
         BAL   LEV2,SCHESD              SEARCH ESD FOR ITEM
         CLI   TTYPE(BEGIN),VCCON       IS IT A V-CON
         BE    SESLP                    YES, CONTINUE SEARCH
         CLI   TTYPE(BEGIN),DSCON       IS IT A DSECT
         BE    DXSET                    YES, UP-DATE DSECT
 SPACE
         MVC   ESDID(1,ACT),TID(BEGIN)  USE ID IF XD
         B     VSHSET                   EXIT
 SPACE 2
DXSET    MVC   TNAME(8,BEGIN),IBL2F     OBLITERATE DSECT NAME
         STH   SP1,TEMPH                SAVE ESDNO OF DSECT
         BAL   LEV2,SETESD              CREATE ESD ITEM
         MVC   TADDR(2,SP1),TEMPH       INSERT ESDNO OF DSECT
         MVI   TTYPE(SP1),DXCON         SET NEW TYPE FLAG IN ESD
         MVI   TALIGN(SP1),7            SET ALIGNMENT - DOUBLE WORD
         B     VSHSET                   EXIT
 SPACE 2
QCERRA   MVI   QERR,ERR11               LOG ERROR - SYMBOL NOT PREVIOUS
         B     QLGER                    DEFINED
QCERRB   MVI   QERR,ERR12               LOG ERROR - NOT DXD OR DSECT
QLGER    BAL   SRR,ELOGER
         DC    AL1(0)                   CALL LOG ERROR
QERR     DC    X'0'
         B      VSHSET                  EXIT
***********************************************************************
 EJECT
*              THERE ARE THREE LEVELS OF INTERNAL SUBROUTINES.        *
 SPACE 2
*                    LEVEL 1                                          *
 SPACE
*   ESFIN   -  UPDATES THE LOCATION COUNTER IN THE PREVIOUS CONTROL   *
*              SECTION.                                               *
  SPACE 2
*                    LEVEL 2                                          *
 SPACE
*   SETESD  -  ASSIGNS AN ESD ID TO ITEM,AND PUTS SYMBOL TABLE ENTRY. *
 SPACE
*   SCHESD  -  SEARCHES ESD FOR ITEM WITH GIVEN NAME,AND FINDS ESDNO. *
 SPACE
*   PNTESD  -  OBTAINS ESD ITEM WITH GIVEN ESDNO.                     *
 SPACE   2
*                    LEVEL 3                                          *
 SPACE
*   FSTNR   -  SETS ESDNO AND ADJECTIVE CODE OF FIRST SD OR PC TYPE   *
*              CONTROL SECTION IN CONTROL TABLE.USED FOR END LITERALS.*
 SPACE
*   STGET   -  INTERFACES WITH SYMBOL TABLE GET ROUTINE.              *
 SPACE
*   GETNAME -  GETS NAME FROM TEXT RECORD.                            *
 SPACE
*   ISOPF   -  SETS CONDITION CODE TO INDICATE PRESENCE OF OPERAND.   *
 SPACE
*   XREF1,2 -  MAKES REFERENCE OR DUPLICATE TYPE CROSS-REFERENCE.     *
 SPACE
*   ESCRBL  -  CREATES ESD ITEM.                                      *
    EJECT
*              LEVEL 1 ROUTINES
*        THESE CALL LEVEL 2 ROUTINES AND MODIFY LEV2,LEV3, ETC.
*        RETURN REGISTER IS LEV1
 SPACE
***********************************************************************
***                      ESD FINISH ROUTINE                         ***
 SPACE
ESFIN    CLI   CESDID(ACT),0            DOES CURRENT ESDID = 0
         BCR   8,LEV1                   YES, RETURN NONE TO FINISH
 SPACE
         LH    SP2,CESDNO(ACT)          NO -FINISH ESD FOR PREV SECTION
         BAL   LEV2,PNTESD              POINT TO THE LAST ESD ITEM
         MVC   TADDR(3,SP1),CTLOC+1(ACT)  SET TADDR = CURRENT LOC CTR
         CLC   CTLOC+1(3,ACT),TLTH(SP1)   IS CURR LOC CTR GTR TLTH
         BCR       13,LEV1              NO, DONT SET TLTH
 SPACE
         MVC   TLTH(3,SP1),CTLOC+1(ACT) SET TLTH = CURR LOC CTR AND
         BR    LEV1                     EXIT
*                                                                     *
***********************************************************************
 EJECT
*              LEVEL 2 ROUTINES
*        THESE CALL LEVEL 3 ROUTINES AND THEREFORE MODIFY LEV3
*        RETURN REGISTER IS LEV2
***********************************************************************
         SPACE 3
*   SETESD-  ASSIGN ESD IDENTIFICATION                                *
*FUNCTION-                                                            *
*   SETS ESD-ID TO EITHER-                                            *
*        NUMBER OF NEXT ESD, OR                                       *
*        NUMBER OF NEXT DSECT                                         *
*   UPDATES COUNT OF ESD'S OR DSECT'S, AS REQUIRED                    *
*   PUTS SYMBOL TABLE ENTRY, IF REQUIRED                              *
*                                                                     *
*INPUT-                                                               *
*   CLASID(ACT) CONTAINS ID NUMBER OF LAST ESD                        *
*   CTNDID(ACT) CONTAINS ID NUMBER OF NEXT DSECT                      *
*OUTPUT-                                                              *
*   CLASID(ACT) OR CTNDID(ACT) IS UPDATED                             *
*   ESDID(ACT) CONTAINS CURRENT ESD-ID                                *
*   ADJCOD(ACT) CONTAINS ADJECTIVE CODE FOR CORRESPONDING SYMBOL TABLE*
*    ENTRY                                                            *
*EXTERNAL ROUTINES-                                                   *
*  STPUTR (IN ASMGF7S) IS USED TO PUT ENTRY TO SYMBOL TABLE           *
*EXITS-                                                               *
*   NORMAL-    BR   LEV2                                              *
*   ERROR-                                                            *
*        EXIT FROM F7E,                                               *
*        OR RETURN TO VCONDRT (IN VCON SUBROUTINE) IF CALLED FROM VCON*
*NOTE-  VCON SUBROUTINE ALTERS ERROR RETURN                           *
*   DISCOVERS AND LOGS 'ESD TABLE OVERFLOW' ERROR IF ESD'S+DSECT'S=   *
*    MORE THAN 255                                                    *
         SPACE 2
SETESD   LH    ACC,CLASID(ACT)          GET LAST ID
         CH    ACC,CTNDID(ACT)          IS THIS = NEXT DSECT ID
         BE    STESDE                   YES, ERROR
         SPACE
         CLI   TYPE,DSCON               IS IT A DSECT
         BE    STADJD                   YES, PUT IN
 SPACE
         LA    ACC,1(ACC)
         STH   ACC,CLASID(ACT)          LAST ID = LAST ID +1
         STC   ACC,ESDID(ACT)           SET ID(ASSIGNED) = LAST ID
 SPACE
         CLI   TYPE,VCCON               IS IT A V-TYPE
         BE    ESIDX                    YES, PROCESS
         CLI   TYPE,ERCON               IS IT EXTERNAL
         BE    STADJX                   YES, PROCESS
         CLI   TYPE,WXCONA              IS IT WEAK EXTERNAL .Q
         BE    STADJX                   YES, PROCESS
         CLI   TYPE,DXCON               IS IT DUMMY EXTERNAL
         BE    STADJDX                  YES, PROCESS
 SPACE
         STC   ACC,CESDID(ACT)          SET ESD-ID OF CURRENT CONTROL
STADJSD  MVI   ADJCOD(ACT),SDBITS       IS CSECT, SET SD
         B     ESIDX                    CONTINUE
STADJX   MVI   ADJCOD(ACT),ERBITS       SET  EXTERNAL
         B     ESIDX                    CONTINUE
STADJDX  MVI   ADJCOD(ACT),DSBITS+DXDFLAG+DSOCM
         B     ESIDX                    SET FOR DUMMY EXTERNAL
 SPACE 2
STADJD   MVI   ADJCOD(ACT),DSBITS+DSOCM
DSCTID   LH    ACC,CTNDID(ACT)          SET ID(ASSIGNED) = NEXT DSECT
         STC   ACC,ESDID(ACT)             ID
         STC   ACC,CESDID(ACT)          SET ESD-ID OF CURRENT CONTROL
         BCTR  ACC,0                      SECTION = NEXT DSECT ID
         STH   ACC,CTNDID(ACT)          NEXT DSECT ID = NEXT DSECT ID-1
         SPACE 5
*                  BUILD THE ESD ITEM FORMAT
ESIDX    MVC   AID,ESDID(ACT)           GET ID
         MVC   SVSDNO,CESDNO(ACT)       SAVE CURRENT ESDNO
         BAL   LEV3,ESCRBL              BUILD ESD
         CLC   NAME(8),IBL2F            IF NAME IS NOT BLANK, PUT
         BCR   8,LEV2                   BLANK, RETURN
 SPACE
         LA    SP1,NAME                 NONE BLANK, SO PUT
         SR    SP2,SP2                  SYMBOL IN SYMBOL TABLE
         L     SRB,STPUT(ACT)           SYMBOL TABLE PUT
         BALR  SRR,SRB
         NOP   0
         CLI   TYPE,ERCON
         BE    RESDNO                   IF TYPE = DX OR ER
         CLI   TYPE,WXCONA              OR
         BE    RESDNO                   WEAK EXTERNAL
         CLI   TYPE,DXCON               DONT RETURN YET
         BCR   7,LEV2                   OTHER WISE RETURN
RESDNO   MVC   CESDNO(2,ACT),SVSDNO     RESTORE CURRENT ESDNO
         BR    LEV2                     NOW RETURN
 SPACE 2
STESDE   BAL   SRR,LOGERR
         DC    AL2(ERR14)               'ESD TABLE OVERFLOW'
DRTFIX   EQU   *+1                 ** BYTE IS ALTERED BY VCON **
         B     CTRTRN(ACT)              EXIT FROM THE FUNCTIONAL RTN.
         B     VCONDRT                  VCON RETURN
SVSDNO   DC    H'0'
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*        SEARCH FOR ESD ENTRY
*        ON EXIT   BEGIN POINTS AT ENTRY
*                  SP1 CONTAINS ESDNO
 SPACE
SCHESD   LH        END,CNOESD(0,ACT)   LOAD NUMBER OF ESD'S
         LA        END,1(0,END)        ADD 1 FOR DUMMY 1ST ENTRY
         L     SEGAD,CTESRB(ACT)         SET BEGIN AND END FOR IN CORE
         SR    SP1,SP1             ESDNO=0
         B         SES1
 SPACE
SES3     BCT   ITEMCT,SES2              REDUCE NO. IN BLOCK BY ONE
         LA        SEGAD,4(0,SEGAD)    POINT AT NEXT BLOCK
 SPACE
SES1     LA    ITEMCT,16                SET UP FOR NEXT BLOCK
         L         BEGIN,0(0,SEGAD)    POINT AT 1ST ENTRY IN BLOCK
 SPACE 2
*./      DELETE    SEQ1=16720020,SEQ2=16720020
SES2     CLC   NAME(8),TNAME(BEGIN)     SEE IF SAME NAME
         BC    7,SESLP                    NO - LOOP
 SPACE
VMATCH   EQU   *+1
         BR    LEV2                     YES, EXIT
 SPACE 2
         CLI   TTYPE(BEGIN),VCCON       IS TYPE = VCON
         BCR   8,LEV2                   YES, RETURN
         CLI   TTYPE(BEGIN),ERCON       IS TYPE = ER
         BCR   8,LEV2                   YES, RETURN
         CLI   TTYPE(BEGIN),WXCONA      IS TYPE = WX .Q
         BCR   8,LEV2                   YES, RETURN
         SPACE 2
SESLP    LA        BEGIN,16(0,BEGIN)   POINT AT NEXT ENTRY IN BLOCK
         LA        SP1,1(0,SP1)        ESDNO=ESDNO+1
         BCT       END,SES3            CHECK FOR NO MO ENTRIES
 SPACE 2
         LTR   ACT,ACT                  SET CC = 2 FOR NOT FOUND
         BR    LEV2                     AND EXIT
 SPACE
***********************************************************************
         EJECT
***********************************************************************
***                    POINT ESD ROUTINE                            ***
*    THIS ROUTINE POINTS AT THE ESD ITEM WHOSE NUMBER IS IN SP2,      *
*  WHETHER THIS ITEM IS IN CORE OR NOT.                               *
*                                                                     *
PNTESD   LA    SP1,15                   MASK
         NR    SP1,SP2                  FIND OUT WHICH BLOCK
         SR    SP2,SP1                  ESD NO. IS IN
         SRL   SP2,2
         A     SP2,CTESRB(ACT)            SR TABLE ITEM
 SPACE
         SLL   SP1,4                       SET SP1 TO POINT AT ESD ITEM
         A     SP1,0(0,SP2)
         BR    LEV2                     EXIT
*                                                                     *
***********************************************************************
 EJECT
*              LEVEL 3 ROUTINES
*        THESE MAY ONLY MODIFY THE VOLATILE AND PARAMETER REGISTRRS
*        RETURN REGISTER IS LEV3
 SPACE
***********************************************************************
*                                                                     *
*   FSTNR- SET FIRST ESD NUMBER                                       *
*FUNCTION-                                                            *
*   SETS THE FOLLOWING VARIABLES IN THE ACT-                          *
*        CTFSTNO..SET TO ESD NUMBER AND AJECTIVE CODE OF FIRST        *
*                 CONTROL SECTION                                     *
*        CTFSTN...RECEIVES EIGHT-BYTE NAME OF FIRST CONTROL SECTION   *
*   THESE VALUES ARE USED IN GENERATING SYMBOL TABLE ENTRIES FOR THE  *
*    LITERALS WHICH FOLLOW THE 'END' STATEMENT.                       *
         SPACE 2
FSTNR    CLC   CTFSTNO(2,ACT),CTZERO(ACT) IF ALREADY SET
         BCR   7,LEV3                    THEN RETURN
         LH    ACC,CNOESD(ACT)
         LA    ACC,1(ACC)               SET ESDNO AND ADJ CODE
         SLL   ACC,7                     OF FIRST CONTROL SECTION
         STH   ACC,CTFSTNO(ACT)          IN CENTRAL TABLE
         MVC   CTFSTN(8,ACT),NAME       MOVE FIRST NAME
CTFSTNO  EQU   CTESRN                   FIRST ESD NO
         BR    LEV3                     RETURN
*                                                                     *
***********************************************************************
 SPACE 2
***********************************************************************
*                                                                     *
*   STGET- SCAN SYMBOL TABLE                                          *
*FUNCTION-                                                            *
*   PROVIDES INTERFACE WITH STGETR ROUTINE (IN ASMGF7S)               *
*   FINDS (IF POSSIBLE) A REQUESTED SYMBOL IN THE SYMBOL TABLE        *
*INPUT-                                                               *
*   NAME CONTAINS THE DESIRED EIGHT-BYTE SYMBOL                       *
*OUTPUT-                                                              *
*   SP1 CONTAINS THE ADDRESS OF THE FIRST BYTE FOLLOWING THE NAME     *
*                FIELD OF THE DESIRED SYMBOL TABLE ENTRY,             *
*            OR  ZERO, IF THE SYMBOL CAN NOT BE FOUND                 *
*   CONDITION CODE.. 0= SYMBOL NOT FOUND                              *
*                    2= SYMBOL FOUND                                  *
         SPACE 2
STGET    LA    SP1,NAME                 POINT SP1 AT SYMBOL SOUGHT
         SR    SP2,SP2
         L     SRB,CSTGET(ACT)          USE ACT AND FDIMEN TO
         BALR  SRR,SRB                  GET TO STGETR IN ASMGF7S
         LTR   SP1,SP1                  SET CC TO SHOW RESULT
         BR    LEV3                     RETURN
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*   GETNAME-                                                          *
*FUNCTION-                                                            *
*   RETRIEVE NAME FIELD OF CURRENT INPUT TEXT RECORD                  *
*INPUT-                                                               *
*   CTEXTP(ACT) CONTAINS ADDRESS OF CURRENT INPUT TEXT RECORD         *
*OUTPUT-                                                              *
*   NAME CONTAINS SYMBOL IN THE TEXT NAME FIELD, OR BLANKS IF THE     *
*   SYMBOL HAS BEEN MULTIPLY-DEFINED                                  *
*EXITS-                                                               *
*   NORMAL...  B    4(LEV3)                                           *
*   IF NAME FIELD BLANK.. B LEV3                                      *
         SPACE
 SPACE
GETNAME  MVC   NAME(8),IBL2F            BLANK NAME
         L     ACC,CTEXTP(ACT)          ACC POINTS TO TEXT RECORD
         TM    TXMDN(ACC),BIT3
         BCR   1,LEV3                   ERROR IN NAME
 SPACE
         SR    TEMPR,TEMPR
         IC    TEMPR,TXNAML(ACC)        TEMPR HAS NAME LENGTH
         LTR   TEMPR,TEMPR              IS THERE AN ERROR IN NAME
         BCR   8,LEV3                   YES EXIT - NO NAME
 SPACE
         BCTR  TEMPR,0                  REDUCE BY ONE
         EX    TEMPR,MVNAME             MOVE NAME FROM TEXT TO BLNK FLD
         B     4(LEV3)                  NORMAL EXIT
         SPACE
***********************************************************************
 SPACE 2
***********************************************************************
*   ISOPF-   IS THERE AN OPERAND                                      *
*FUNCTION- DETERMINES WHETHER THE CURRENT INPUT TEXT RECORD CONTAINS  *
*     AN OPERAND.  THERE IS NO OPERAND IF THE FIRST CHARACTER OF THE  *
*     OPERAND FIELD CONTAINS A BLANK OR COMMA.                        *
*INPUT-                                                               *
*   CTXOFP(ACT) CONTAINS ADDRESS OF OPERAND FIELD,-1                  *
*OUTPUT-                                                              *
*   CONDITION CODE.. 0= NO OPERAND                                    *
*                    1= IS OPERAND                                    *
*                    2= IS OPERAND                                    *
         SPACE
ISOPF    L     ACC,CTXOFP(ACT)          FIND OPERAND FIELD
         CLI   1(ACC),IBLANK            IS IT A BLANK
         BCR   8,LEV3                   YES, RETURN
         CLI   1(ACC),ICOMMA            IS IT A COMMA
         BCR   7,LEV3                   NO, RETURN
         CLI   0(ACC),2                 SET CC NE 0
         BR    LEV3                     RETURN
***********************************************************************
 SPACE
***********************************************************************
 SPACE
*   XREF-  FORM CROSS-REFERENCE RECORDS                               *
*ENTRY POINTS-                                                        *
*   XREF1...FOR TYPE 2 CROSS-REFERENCE  (REFERENCE TO SYMBOL)         *
*   XREF2...FOR TYPE 3 CROSS-REFERENCE  (MULTIPLY DEFINED)            *
*INPUT-                                                               *
*   CTXRFI(ACT)...BIT 7... 1=CROSS REFERENCE DESIRED                  *
*OUTPUT-                                                              *
*FUNCTION-  WRITE XREF RECORD (VIA STREFR) AND FORM NEW XREF RECORD   *
*EXTERNAL ROUTINES-  STREFR(IN ASMGF7S) IS USED TO PERFORM RECORD OUT-*
*                    PUT AND BUFFER ALLOCATION.                       *
*NOTE-  STATEMENTS AT 'XREF1' AND 'XREF2' ALTER THE COMMAND AT XREF005*
         SPACE
XREF2    MVI       XREF005+3,CSTPUT    PUT FOR DUPLICATE
         B     XREF                     WORK STARTS AT XREF
XREF1    MVI       XREF005+3,CSTREF    REF FOR REFERENCE
XREF     TM    CTXRFI(ACT),X'02'        XREF BIT ON   Q.
         BCR   8,LEV3                   NO, SKIP IT
         CLI   NAME,IBLANK              NO XREF FOR BLANK NAMES, SO
         BCR   8,LEV3                   HERE'S ANOTHER CHANCE TO SKIP
         SPACE
         L     ACC,CTEXTP(ACT)         TEXT RECORD ADDRESS TO ACC  6822
         MVC   XREFWK(1),TXRT(ACC)     PICK OUT RECORD TYPE        6822
         NI    XREFWK,X'70'            STRIP OFF EXTRA BITS        6822
         BZ    XREF005                 SKIP, IF TYPE IS ZERO       6822
         XI    XREFWK,X'50'            SEE ABOUT TYPE 5            6822
         BCR   8,LEV3                  NO XREF FOR TYPE 5          6822
XREF005  L     SRB,*-*(0,ACT)          SELECT STREFR OR STPUTR
         LA        SP1,NAME            POINT AT NAME
         LA        SP2,8               SET LENGTH
         BALR  SRR,SRB                STPUTR   RETURNS NEW ENTRY IN SP1
         CLI       XREF005+3,CSTREF    IS THIS DUP DEFN ENTRY
         BCR       8,LEV3              RETURN IF NOT
         MVC    2(6,SP1),CTZERO(ACT)    CLEAR LENGTH, VALUE, ESDID FLDS
         BR    LEV3                     ALL DONE
         SPACE
XREFWK   DS    1C                      TEAR UP RECORD TYPE HERE    6822
         SPACE
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*   ESCRBL-  FORM ESD ENTRY                                           *
*                                                                     *
*FUNCTION-                                                            *
*   FINDS ROOM TO PLACE ESD ENTRY (VIA STROOM IN ASMGF7S)             *
*   UPDATES POINTERS IN CONTROL TABLE, TO INDICATE ESD ENTRY HAS BEEN *
*    MADE.                                                            *
*INPUT/OUTPUT PARAMETERS                                              *
*   CTDESP(ACT)...POINTER TO START OF ESD TABLE                       *
*   CSGCTR(ACT)...COUNT OF ESD ENTRIES IN CURRENT SEGMENT             *
*   CNOESD(ACT)...NUMBER OF ESD'S                                     *
*   CESDNO(ACT)...CURRENT ESD NUMBER                                  *
*   CTESRP(ACT)...POINTER TO RESIDENT ESD                             *
*EXTERNAL ROUTINES-                                                   *
*   STROOM..(IN ASMGF7S) USED TO CHECK SYMBOL-ESD TABLE FOR POSSIBLE  *
*    OVERFLOW                                                         *
*EXITS-                                                               *
*   IF TYPE IS VCON OR QCON,                                          *
*        BR    LEV2                                                   *
*   OTHERWISE,                                                        *
*        BR    LEV3                                                   *
         SPACE
ESCRBL   L     SP1,CTESDP(ACT)          POINTS TO START OF ESD
         LA        SP1,16(0,SP1)        CHANGE IT
         LH    ACC,CSGCTR(ACT)          NO, UPDATE CURRENT SEG. POINTER
         BCT       ACC,SETESP          TEST IF LAST IN BLOCK
 SPACE
         L         SRB,CSTROM(0,ACT)   FIND ROOM FOR ANOTHER BLOCK
         LA        SP1,259             MAX ROOM A BLOCK CAN TAKE
         BALR      SRR,SRB
         DS        2H
         L         SP1,CTSYMP(0,ACT)   CALCULATE ADDRESS IN SYM TAB
         A         SP1,CFREEP(0,ACT)
         LA        SP1,3(0,SP1)        ALIGN F
         N         SP1,=F'-4'
         L     GRZ,CTESRP(ACT)          POINT TO ESD RESIDENT SEGMENT
         LA    GRZ,4(GRZ)               SKIP IDENTIFIER
         ST    GRZ,CTESRP(ACT)          FRONT OF SEGMENT
         ST    SP1,0(GRZ)               POINTS TO PREVIOUS SEGMENT
         LA        ACC,256(0,SP1)      CALCULATE CFREEP
         S         ACC,CTSYMP(0,ACT)
         ST        ACC,CFREEP(0,ACT)
         LA        ACC,16              RESET NUMBER OF ENTRIES/BLOCK
SETESP   STH   ACC,CSGCTR(ACT)          NOW UPDATED
         ST    SP1,CTESDP(ACT)         REPLACE ESD POINTER
         MVC   TTYPE(16,SP1),TYPE       PUT ENTRY INTO ESD TABLE
         MVC   ADDR(7),CTZERO(ACT)      CLEAR WORK AREA
         LH    ACC,CNOESD(ACT)          UPDATE ESD COUNT
         LA    ACC,1(ACC)
         STH   ACC,CNOESD(ACT)          NOW UPDATED
         CLI   TYPE,LDCON               IF TYPE=LD,
         BCR   8,LEV3                   RETURN
         CLI   TYPE,VCCON               IF TYPE= VCON OR QCON,
         BCR   8,LEV2                   RETURN TO VCON CODE
         STH   ACC,CESDNO(ACT)          OTHERWISE, SET ESD NUMBER
         BR    LEV3                     AND RETURN
*                                                                     *
***********************************************************************
         EJECT
MVNAME   MVC   NAME(0),TXNAME(ACC)
MVNMEV   MVC   NAME(0),0(SP1)           EXECUTED
 SPACE
**                            AREAS NEEDED                           **
         DS    0F
TEMPF    DC    H'0'                     TEMPARY FULL WORD
TEMPH    DC    H'0'                             HALF WORD
ADJ      EQU   TEMPH+1                  ADJECTIVE CODE
ECTR     DC    H'101'                   ENTRY COUNTER
VSAVE    DC    F'0'                     V-CON SAVE AREA
ERRPTR   DC    F'0'                     ERROR POINTER TO COLUMN
TEMPZF   DC    F'0'                     FULL WORD ZERO
         DS    0F                        ESD ITEM FORMAT
TYPE     DC    X'0'                     *    TYPE
ADDR     DC    XL3'0'                   *    ADDRESS
ALIGN    EQU   ADDR+2                   *    ALIGNMENT
AID      DC    X'0'                     *    ESD/ID
ALTH     DC    XL3'0'                   *    LENGTH
NAME     DC    CL8'0'                   *    NAME
IBL2F    DC    8AL1(IBLANK)             8 BYTES OF BLANK
         LTORG
         EJECT
EWBKSW   EQU   TXSESL                   LAST OPERAND INDICATOR
EWBCMP   EQU   TXSPTR
STPUT    EQU   CSTPUT                   POINTER TO SYMBOL IN OPERAND
STADJ    EQU   1                        SYMBOL TABLE PUT ROUTINE
ADJCD    EQU   STADJ                    POSITION OF ADJECTIVE
ALNBYTE  EQU   17                       POSITION OF ALIGNMENT
DSOCM    EQU   4                        DS OR COM MASK
ESIOID   EQU   3                        ESD INDICATOR
ENTCMB   EQU   8                        ENTRY COMPLETE CODE
EWBKID   EQU   0                        POSITION OF WKBKT ID
EWBKVL   EQU   1                                         VALUE
EWBKNO   EQU   EWBKVL+1                 PISITION OF BLOCK NO.
MOD8     EQU   7                        MASK FOR DOUBLE WORD BOUNDARY
NOTHI    EQU   13                       NOT HIGH
PARID    EQU   5                        PARAMETER TABLE ID
STID     EQU   2                        POSITION OF ID
SYMVAL   EQU   3                                    SYMBOL VALUE
CCHIGH   EQU   X'20'                    MASK FOR DS OR DXD
ECMPLT   EQU   X'FF'                             WKBKT COMPLETE
FILLED   EQU   X'90'                    WKBKT COMPLETE INDICATOR
FULL     EQU   X'40'                    MASK FOR WKBKT FULL
LASTOP   EQU   X'80'                             LAST OPERAND
ONSDVI   EQU   X'80'                    INDICATOR FOR SELF DEFINE VALUE
LASTWB   EQU   X'08'                                  LAST WKBKT
PDSI     EQU   X'20'                                  PREVIOUSLY DEFINE
SDBIT    EQU   3                                      CSECT OR START
SDMSK    EQU   3                                      CSECT OR START
SDBITS   EQU   X'00'                                  CSECT OR START
ERBITS   EQU   X'01'                                  EXTERNAL
DSBITS   EQU   X'02'                                  DSECT
DXDFLAG  EQU   X'10'                                  DXD
BIT3     EQU   X'10'                    MASK FOR DSECT OR COMMON
WBKLEN   EQU   6                        WKBKT LENGTH
WBKSW    EQU   TXFAFL                   WKBKT SWITCH
WBKTYP   EQU   TXFAFL+1                       TYPE
WBKID    EQU   TXFAFL+TXSESD                  ESD/ID
WBKNO    EQU   TXFAFL+4                 ESDNO AND ADJ CODE
SETWX    EQU   X'02'                    INDICATES WXTRN
         SPACE
ERR01    EQU   80                       ILLEGAL START
ERR02    EQU   39                       INVALID DELIMITER
ERR03    EQU   25                       RELOCATABILITY
ERR04    EQU   33                       ALIGNMENT
ERR05    EQU   19                       EXTERNAL NAME
ERR06    EQU   38                       EXTRN
ERR08    EQU    95                      ENTRY TABLE OVERFLOW
ERR10    EQU     6                      INVALID ORIGIN
ERR11    EQU   21                       SYMBOL NOT PREVIOUSLY DEFINED
ERR12    EQU   106                      NOT NAME OF DXD OR DSECT
ERR13    EQU   25                       RELOCATABILITY
ERR14    EQU   22                       ESD TABLE OVERFLOW
ERR15    EQU       73                  ILLEGAL NAME FIELD
         EJECT
**                       FIELDS IN ESD ITEMS                         **
TTYPE    EQU   0                                  TYPE
TADDR    EQU   1                                  ADDRESS
TID      EQU   4                                  ESD/ID
TLTH     EQU   5                                  LENGTH
TNAME    EQU   8                                  NAME
TALIGN   EQU   TTYPE+3                            ALIGNMENT
         SPACE
**                            TYPE CONSTANTS                         **
SDCON    EQU   0                                  CSECT OR START
LDCON    EQU   1                                  ENTRY
ERCON    EQU   2                                  EXTERN
PCCON    EQU   4                                  PRIVATE CODE
CMCON    EQU   5                                  COMMON
DXCON    EQU   6                                  DXD
DSCON    EQU   7                                  DSECT
VCCON    EQU   8                                  V-TYPE CONSTANT
WXCONA   EQU   10                                 WEAK EXTERNAL
         SPACE
**                           REGISTER USAGE                          **
ACC      EQU   GRX                      ACCUMULATOR
TEMPR    EQU   GRY                      TEMPERARY
ECT      EQU   GRZ                      NUMBER OF ENTRIES
LTH      EQU   GRZ                      LENGTH
ALN      EQU   TEMPR                    ALIGNMENT
SEGAD    EQU   SP2                      SEGMENT (BLOCK)
BEGIN    EQU   TEMPR                    BEGINNING OF SEGMENT
END      EQU   ACC                      END OF SEGMENT
ITEMCT   EQU   GRD                      ITEMS IN SEGMENT
TXPTR    EQU   ACC                      POINTER TO TEXT
WBP      EQU   GRA                      POINTER TO WKBKT
LEV1     EQU   GRA                      RETURN LEVEL 1
LEV2     EQU   GRB                      RETURN LEVEL 2
LEV3     EQU   GRD                      RETURN LEVEL 3
ELOOPR   EQU   GRC                      LOOP ADDRESS
         SPACE
         END
./ ADD NAME=ASMGF7G
F7G      TITLE     'ASMG F7  LITERAL DC GENERATION SUBROUTINE (DCGETR)'
         ISEQ  73,78
ASMGF7G  START
         PRINT      NOGEN
         FDIMEN
         PRINT GEN
*                                                                     *
*TITLE 'ASMGF7G ' ... LITERAL DC GENERATION                           *
*FUNCTION/OPERATION-                                                  *
*  ASMGF7G BUILDS A LITERAL DC EDITED TEXT RECORD FOR A OUTSTANDING   *
*   LITERL ENTRY IN THE SYMBOL TABLE                                  *
*ENTRY POINTS- ASMGF7G                                                *
*   CALLING SEQUENCE                                                  *
*        L     SRB,CDCGET(ACT)          SET UP BASE                   *
*        BALR  SRR,SRB                  CALL ASMGF7G                  *
*INPUT- NONE                                                          *
*OUTPUT- NONE                                                         *
*EXTERNAL ROUTINES- NONE                                              *
*EXITS- NORMAL                                                        *
*       RETURNS TO CALLER VIA                                         *
*        BR    SRR                      EXIT                          *
*     - ERROR-- NONE                                                  *
*TABLES/WORKAREA-                                                     *
*   RL- FIXED FIELDS OF TEXT RECORD                                   *
*NOTES-                                                               *
*  ASMGF7G CREATES THE TEXT RECORD BY BUILDING IT AND/OR MOVING IT    *
*   FROM THE LITERAL DC RECORD AREA. GRZ POINTS TO THE FIELD IN THE   *
*   LITERAL DC RECORD AREA AND GRX POINTS TO THE TEXT RECORD.         *
*                                                                     *
         EJECT
         USING *,SRB
DCGTR    SR    GR1,GR1                  ZERO STRING COUNTER
         L     GRX,CTLDCP(ACT)          GET PTR TO LITERAL DC REC AREA
         ST    GRX,SAVPTR               SAVE IT
GETLIT   L     GRY,CTSYMP(ACT)          GET PTR TO 1ST BYTE OF SYM TBL
GTLIT1   MVC   ALWRD+1(3),0(GRY)
         L     GRZ,ALWRD                GET NEXT STRING POINTER
         LTR   GRZ,GRZ                  TEST IF POINTER IS ZERO
         BNE   GTLIT2                   NO MEANS MORE LITERALS
         LA    GR1,1(GR1)               ADD 1 TO STRING COUNTER
         LA    GRY,3(GRY)               POSITION TO NEXT STRING POINTER
         CH    GR1,CON4                 TEST IF 4 STRINGS PROCESSED
         BNE   GTLIT1                   NO,GO TO PROCESS NEXT STRING
EXIT     BR    SRR                      BACK TO MAIN LINE
GTLIT2   A     GRZ,CTSYMP(ACT)          GET PTR TO LITERAL ENTRY
         ST    GRZ,ALITSAVE             SAVE FOR POSSIBLE LREF
         MVC   0(3,GRY),0(GRZ)          MOVE CHAIN PTR TO STRING PTR
         IC    GR1,3(GRZ)               GET DEF LENG-1 OF SOURCE LITRL
         EX    GR1,MVSRCE               MOVE SOURCE INTO TEXT RECORD
         LA    GRZ,6(GRZ,GR1)           POINT TO WORK BUCKET IN TABLE
* AT THIS POINT MOVE WBS IN IF PRESENT
         LA    GR1,3(GR1)               GET TRUE LGTH OF OPND. FIELD
         STC   GR1,OPNL                 STORE IN OPRND FIELD LENGTH
         LA    GRX,14(GRX,GR1)          POINT PAST OPRND FIELD
* AT THIS POINT TXLOC SHOULD BE SET PROPERLY IN CASE OF *
         MVC   0(7,GRX),BLNK            MOVE IN BLANK AND APP FIXED FLD
         LA    GRX,2(GRX)               POINT TO APPENDED FIXED FIELD
         S     GRX,SAVPTR               GET PTR TO APPENDED FIXED FIELD
         STH   GRX,ABP                  STORE IT
         A     GRX,SAVPTR
         MVC   5(15,GRX),0(GRZ)         MOVE LDC WB FROM TABLE TO TEXT
         OI    5(GRX),X'08'             SET LAST OPERAND INDICATOR
         TM    6(GRX),X'80'             TEST IF LOC CTR IN TABLE ENTRY
         BZ    GTLIT3                   NO, BRANCH
         MVC   0(4,GRX),15(GRZ)         YES,MOVE IT INTO TEXT RECORD
         LA    GRZ,4(GRZ)
GTLIT3   NI    6(GRX),X'3F'             SET LOC CTN NOT IN TABLE ENTRY
         LA    GRX,20(GRX)              SET POINTER BEYOND LDC WKBKT
         TM    1(GRZ),X'40'             ARE THERE WKBKTS
         BZ    GETLIT6                  NO, PUT IN TEXT RECORD AS IS
         ST    GRX,CTXWBP(ACT)          SAVE POINTER TO WKBKT
         LA    GRZ,9(GRZ)
GETLIT4  LA    GRZ,6(GRZ)               UP TO BEGINNING OF WKBKT
         MVC   0(6,GRX),0(GRZ)          MOVE IN WKBKT
         LA    GRX,6(GRX)               UP POINTER PAST WKBKT JUST MOVE
         TM    TXSLAS(GRZ),X'08'        IS THIS LAST WKBKT
         BZ    GETLIT4                  NO, GET THE REST
GETLIT6  S     GRX,SAVPTR                GET RECORD LENGTH.
         STH   GRX,RL                   STORE IN FIXED BUILD AREA
         L     GRX,SAVPTR               POINT TO BEGINING OF RECORD
         MVC   0(16,GRX),RL             MOVE IN FIXED PART OF RECORD
         TM    CTLREF(ACT),X'80'        IS LREF ON .Q
         BZ    EXIT                     NO
         L     GRZ,ALITSAVE             POINT AGAIN TO LITERAL ENTRY
         MVC   0(3,GRZ),STLREF+1(ACT)   BUILD NEW CHAIN OF LITERALS
         ST    GRZ,STLREF(ACT)          UPDATE HEAD OF LITERAL CHAIN
         SR    GR1,GR1                  ZERO A WORK REGISTER
         IC    GR1,3(GRZ)               GET LENGTH-1 OF SOURCE LITERAL
         LA    GRZ,11(GRZ,GR1)          POINT TO NEW WORK AREA
         MVC   ALWRD+2(2),CTSEQN+2(ACT) ALIGN CURRENT SEQ NUMBER
         LH    GR1,ALWRD+2              LOAD SEQENCE NUMBER
         LA    GR1,1(GR1)               INCREASE BY ONE
         ST    GR1,ALWRD                MOVE TO WORK AREA
         MVC   0(2,GRZ),ALWRD+2         STOW STATEMENT NUMBER
         MVC   2(1,GRZ),CESDID(ACT)     STOW CURRENT ESDID
         MVC   3(3,GRZ),CTLOC+1(ACT)    STOW CURRENT LOCATION COUNTER
         B     EXIT
MVSRCE   MVC   16(0,GRX),4(GRZ)         EXECUTED MOVE OF SOURCE LITERAL
*FIXED FIELDS OF TEXT RECORD DEFINED INTERNAL TO THIS ROUTINE
RL       DC    H'0'                     RECORD LENGTH
RT       DC    X'60'                    REC TYPE=EDITED GENERATED
TO       DC    X'80'                    TYPE OF OPERATION=ASSEMBLER
HEXOP    DC    X'25'                    HEX OPERATION CODE=25(LITR)
ASC      DC    X'01'                    ASSEMBLER SWITCH CODES
ABP      DC    2X'00'                   APPENDED FIXED FIELD POINTER
NAML     DC    X'00'                    NAME FIELD LENGTH=0
OPL      DC    X'04'                    OPERATION FIELD LENGTH=4
OP       DC    4AL1(IBLANK)             OPERATION FIELD = BLANK
OPNL     DC    X'00'                    OPERAND FIELD LENGTH INCLUDING
*                                       ONE TRAILING BLANK
         DC    AL1(IEQUAL)              EQUAL SIGN IN OPERAND FIELD
BLNK     DC    AL1(IBLANK)
COML     DC    X'00'                    COMMENTS FIELD LENGTH=0
LOC      DC    3X'00'                   LOCATION COUNTER
URS      DC    X'00'                    UNRESOLVED SYMBOL COUNTER=0
LES      DC    X'00'
ALWRD    DC    F'0'                     TEMP FULL WORD
SAVPTR   DC    F'0'                     TEMP SAVE AREA FOR GRX
ALITSAVE DS    F                        ADDRESS OF CURRENT LIT IN S. T.
CON4     DC    H'4'                     NO. OF LIT DC IN SYMBOL TABLE
         END   DCGTR
./ ADD NAME=ASMGF7I
F7I      TITLE     'ASMG F7  INITIALIZATION AND I/O SUBROUTINES'
         ISEQ  73,78
*./      DELETE    SEQ1=00060020,SEQ2=00140020
         COPY      ASMGSET
ASMGF7I  START
         SPACE 1
*TITLE- ASMGF7I...PHASE F7 INITIALIZATION AND I/O ROUTINES            *
*FUNCTION/OPERATION-                                                  *
*   PERFORMS INITIALIZATION FOR F7.                                   *
*   CONTAINS I/O ROUTINES USED BY PHASE F7                            *
*ENTRY POINTS-                                                        *
*   ASMGF7... PERFORMS INITIALIZATION FUNCTIONS FOR PHASE F7          *
*   ASMGF7I..  PROVIDES ACCESS TO THE FOLLOWING SUBROUTINES-          *
*   ENTRY  NAME   FUNCTION                                            *
*   GTP  (GETPT) POINT ROUTINE FOR INPUT BUFFER                       *
*   GTM  (GETXTM) GET TEXT AND MOVE TO INPUT AREA                     *
*   PTX  (PUTXT)  PUT TEXT TO OUTPUT BUFFER                           *
*   CLT  (CLSTXT) CLOSE TEXT                                          *
*   RDE  (CRDESD) READ EXTERNAL SYMBOL DICTIONARY                     *
*   WTE  (CWRESD) WRITE EXTERNAL SYMBOL DICTIONARY                    *
*   PUTX (PUTXRF) PUT CROSS REFERENCE                                 *
*   PUTLB(PUTLBT) PUT LITERAL BASE TABLE                              *
*   SYSO (SYSOUT) SYSTEM OUTPUT                                       *
*   PHC  (PHCLS)  PHASE CLOSE, BRANCH TO ASMGFI                       *
*CALLING SEQUENCE-                                                    *
*   ASMGF7..                                                          *
*        LINK  DE=(SRR),MF=(E,(1))     I.E. EP=ASMGF7                 *
*   ASMGF7I ROUTINES..                                                *
*        L     SRB,CTXTIO(ACT)                                        *
*        BAL   SRR,NAME(SRB)                                          *
*              CTXTIO(ACT) CONTAINS THE ADDRESS OF ASMGF7I. 'NAME' IS *
*              EQUATED (IN FDIMEN MACRO) TO THE DISPLACEMENT, FROM    *
*              ASMGF7I, OF AN INSTRUCTION OF THE FORM-                *
*                        B    ENTRY                                   *
*              WHERE 'ENTRY' IS THE ENTRY POINT OF THE SUBROUTINE     *
*              SELECTED BY THE SELECTION OF A PARTICULAR 'NAME'.      *
*INPUT/OUTPUT PARAMETERS-  SEE INDIVIDUAL SUBROUTINES                 *
*EXTERNAL ROUTINES-                                                   *
*   THE ADDRESSES OF THE FOLLOWING EXTERNAL ROUTINES ARE PLACED IN THE*
*   ASSEMBLER CONTROL TABLE (ACT) FOR REFERENCE BY OTHER PHASE 7 ROUT-*
*   INES-                                                             *
*      (ROUTINE)        (DECK)         (ACT REFERENCE)                *
*        ASMGF7E        ASMGF7E         CBRNDA                        *
*        COM            ASMGF7E         CCOM                          *
*        CSECT          ASMGF7E         CCSECT                        *
*        DSECT          ASMGF7E         CDSECT                        *
*        ENTRY          ASMGF7E         CENTRY                        *
*        ENTRYS         ASMGF7E         CENTRS                        *
*        ESWBKR         ASMGF7E         CESWBK                        *
*        EXTRN          ASMGF7E         CEXTRN                        *
*        EXTRNS         ASMGF7E         CEXTRS                        *
*        ORG            ASMGF7E         CORG                          *
*        QUIT           ASMGF7E         CQUIT                         *
*        START          ASMGF7E         CSTART                        *
*        UPC            ASMGF7E         CUPC                          *
*        ASMGF7D        ASMGF7D         CDCVAL                        *
*        ASMGF7X        ASMGF7X         CTXGET                        *
*        ASMGF7N        ASMGF7N         CTESTR                        *
*        DXD            ASMGF7E         CDXD                          *
*        STGETR         ASMGF7S         CSTGET                        *
*        STPUTR         ASMGF7S         CSTPUT                        *
*        STREFR         ASMGF7S         CSTREF                        *
*        ASMGF7V        ASMGF7V         CEEVAL                        *
*        ASMGF7L        ASMGF7L         CLOGER                        *
*        ASMGF7G        ASMGF7G         CDCGET                        *
*        VCON           ASMGF7E         CVCDN                         *
*        STROOM         ASMGF7S         CSTROM                        *
*   THESE ROUTINES ARE SUBSEQUENTLY REFERENCED VIA THE ACT BY OTHER   *
*   PHASE F7 ROUTINES                                                 *
*EXITS-                                                               *
*   ASMGF7..BRANCH TO ASMGF7C                                         *
*   ASMGF7I.PHCLS BRANCH TO ASMGFI; OTHER SUBROUTINES RETURN TO CALL- *
*            ING PROGRAM.                                             *
*TABLES/WORK AREAS-                                                   *
*    ASSEMBLER CONTROL TABLE..(SEE ASMGRTA)                           *
*./      DELETE    SEQ1=01600020,SEQ2=01600020
*    F7CT2...FUNCTIONAL ROUTINE BASE/ENTRY ADDRESSES                  *
*    F7CT3...COMMON SUBROUTINE BASE/ENTRY ADDRESSES                   *
         EJECT
TEXTIO   EQU       ASMGF7I
         PRINT     NOGEN               SEE ASMGRTA FOR TABLE LISTING
         FDIMEN
         PRINT GEN
*   REGISTERS EQUATED TO VALUES DEFINED WITHIN FDIMEN
GR3      EQU   GRX                      VOLATILE REGISTER
GR4      EQU   GRY                      VOLATILE REGISTER
GR5      EQU   GRZ                      VOLATILE REGISTER
GR12     EQU   GRA                      GRA-GRD ARE USED BY FUNCTIONAL
GR13     EQU   GRB                      SUBROUTINES...NOT ALTERED BY
GR14     EQU   GRC                      COMMON SUBROUTINES...
GR15     EQU   GRD                      FOUR CONTIGUOUS REGISTERS
         ENTRY     ASMGF7
*        EXTRNS FOR F/7 FUNCTIONAL ROUTINES
         EXTRN ASMGF7E       ENTRIES IN EXTERNAL SYMBOL DICTIONARY...
         EXTRN COM                      'COM' STATEMENTS
         EXTRN CSECT                    'CSECT' STATEMENTS
         EXTRN DSECT                    'DSECT'
         EXTRN ENTRY                    'ENTRY', ASSIGNMENT MODE
         EXTRN EXTRN                    'EXTRN' STATEMENT, ASSIGNMENT
         EXTRN ORG                      'ORG'
         EXTRN QUIT                     'QUIT' (GENERATED AFTER 'END')
         EXTRN START                    'START'
         EXTRN UPC                      UNINITIATED PRIVATE CODE
         EXTRN ASMGF7D                  DC EVALUATION
         EXTRN ASMGF7X                  TEXT GET STATEMENT ROUTINE
         EXTRN ASMGF7N                  TESTRAN ENTRIES
         EXTRN DXD                      'DXD' STATEMENT
*
*
*      * EXTRNS FOR F/7 COMMON SUBROUTINES
*
         EXTRN ASMGF7S                  SYMBOL TABLE PROCESSOR
         EXTRN STGETR                   GET SYMBOL TABLE ENTRY
         EXTRN STPUTR                   PUT SYMBOL TABLE ENTRY
         EXTRN     STREFR               PUT SYMBOL TABLE REFERENCE
         EXTRN ASMGF7V                  EXPRESSION EVALUATION
         EXTRN ASMGF7L                  ERROR RECORD GENERATION
         EXTRN ASMGF7G                  GENERATE LITERAL DC RECORDS
         EXTRN VCON                     'VCON' PROCESSING
         EXTRN STROOM                   CHECK SYM TABLE FOR SPACE
         EXTRN ASMGF7C                  PHASE 7 MAIN LINE CONTROL
         EXTRN     F7ABEND             ABEND ROUTINE IN ASMGFI
         EXTRN     SYSO1               OBJECT OUTPUT IN ASMGFI
         EXTRN     ASMGFI              INTERLUDE PHASE
         EJECT
         USING *,SRB
*   THIS SERIES OF BRANCHES IS USED TO SELECT THE ENTRY POINT OF THE  *
*   DESIRED I/O SUBROUTINE.                                           *
*                                                                     *
         DC    X'FFFF'                  BASE REFERENCE
         B     GTP                      GET POINT SUBROUTINE       D2
         B     GTM                      GET TEXT AND MOVE          D6
         B     PTX                      PUT TEXT SUBROUTINE        D10
         DC        2H'0'                                           D14
         DS    2H                       PHASE INITIALIZATION       D18
         B     PHC                      PHASE CLOSE                D22
         DS        2H                                              D26
         DS        2H                                              D30
         B     PUTX                     PUTXRF                     D34
         B     PUTLB                    PUTLBT                     D38
         DS    2H                       PUTRLD F/8                 D42
         DS    2H                       GETLAT F/8                 D46
         DS    2H                       WTERR F/8                  D50
         DS    2H                       SYSLST F/8                 D54
         B     SYSO                     SYSOUT                     D58
         EJECT
*TITLE-  GETPT...GET POINT ROUTINE FOR F7                             *
*FUNCTION-  SUBROUTINE POINTS TO NEXT LOGICAL RECORD OF THE TEXT      *
*    STREAM IN THE INPUT BUFFER.                                      *
*INPUT-  NONE                                                         *
*OUTPUT-  SP1 CONTAINS POINTER TO FIRST (OR ONLY) TEXT SEGMENT,       *
*                  OR 0, IF END OF FILE WAS READ                      *
*./      DELETE    SEQ1=03140020,SEQ2=03160020
*         CONDITION CODE IS SET TO SP1                                *
*TABLES/WORK AREAS-                                                   *
*        IBUFCPT..POINTER TO CURRENT INPUT RECORD                     *
*        RD1...'NEED NEW DATA' SWITCH                                 *
*        CS1...'POINTER ADVANCED' SWITCH                              *
         SPACE 2
GTP      ST        GR12,SAVE            SAVE REG
         L         GR12,IBUFCPT         LOAD POINTER
         CLI   RD1,1                    NEW DATA SWITCH SET TO NO DATA
         BE    GT5                      IF YES GO TO GT5
         BH    GTA                      IF SET TO NEED-NEW-DATA  GO GTA
         MVC   RLI(2),0(GR12)           MOVE TO HALFWORD BOUNDARY
         AH    GR12,RLI
GT1      LR    SP1,GR12
         TM    2(GR12),X'08'            CONTINUATION BIT SET
         BO    GTB                      IF YES, GO GTB
*./      DELETE    SEQ1=03480020,SEQ2=03500020
         TM    2(GR12),X'80'            LAST REC BIT SET
         BNZ       GT4                 IF YES, GO GT4
*./      DELETE    SEQ1=03560020,SEQ2=03680020
GTX      MVI   CS1,1                    SET ADVANCED PTR SWITCH
         ST        GR12,IBUFCPT         UPDATE POINTER
         L         GR12,SAVE            RESTORE GEN REG
         LTR   SP1,SP1                  SET CONDITION CODE OF SP1
         BR    SRR                      EXIT TO USER
GT4      MVI   RD1,1                    SET ENTR SW TO NO-DATA
         B     GTX                      EXIT
GT5      SR    SP1,SP1                  EOF-NO DATA EXIT
         B     GTX                      EXIT
GTA      MVI   RD1,0                    RESET NEED DATA SWITCH
         BAL   GR4,TEXTIN               READ DATA FILE
         L         GR12,RDADD          RESET POINTER
         B         GT1                 CONTINUE
*./      DELETE    SEQ1=03960020,SEQ2=04480020
GTB      MVI       RD1,2               NEED MORE DATA SW
         B     GTX                      EXIT
         EJECT
*TITLE-  GETXTM...GET TEXT AND MOVE                                   *
*FUNCTION-  SUBROUTINE TRANSFERS A LOGICAL RECORD FROM THE INPUT TEXT *
*    STREAM TO AN AREA SPECIFIED BY THE USER.                         *
*INPUT-  SP1 CONTAINS POINTER TO USER'S WORK AREA                     *
*OUTPUT- SP1 REMAINS UNCHANGED, (IF A RECORD WAS AVAILABLE)           *
*    OR  SP1 CONTAINS 0, INDICATING END OF FILE HAS BEEN READ         *
*TABLES/WORK AREAS-                                                   *
*        ICT...INPUT CONTROL TABLE                                    *
*        CS1...'POINTER ADVANCED' SWITCH                              *
*        RD1...'NEED NEW DATA' SWITCH                                 *
         SPACE 2
GTM      CLI   CS1,0                    INPUT PTR ADVANCED
         BE    GTM7                     IF NO, TO GTM7
GTM1     ST        GR12,SAVE            SAVE GEN REG
         L         GR12,IBUFCPT         LOAD POINTER
         MVI   CS1,0                    RESET GETPT CNTRL SWITCH
         MVC   RLI(2),0(GR12)           MOVE TO HALFWORD BOUNDARY
         LH    GR3,RLI
*./      DELETE    SEQ1=04920020,SEQ2=05060020
         CLI   CS4,1                    DESTINATION OUTPUT BUFFER
         BE    GTM5                     IF YES, TO GTM5
         LR    GR2,SP1
GTM3     NI    2(GR12),X'77'            RESET CONT AND LAST FLAG
         LH    GR3,RLI                  RLI
         LR    GR1,GR12                 PTR
         BAL   GR4,MOVE                 MOVE TO (GR2)
*./      DELETE    SEQ1=05220020,SEQ2=05340020
         L         GR12,SAVE            RESTORE REG
         LTR   SP1,SP1                  SET SP1 CC
         BR    SRR                      EXIT
GTM5     BAL   GR5,OBM                  LOC ROOM IN OUTPUT BUFFER
         LR    SP1,GR2                  SET SP1 TO DEST PTR
         MVI   CS4,0                    RESET PUTEXT SWITCH
         B     GTM3                     RETURN TO MOVE DATA
GTM7     ST    SP1,DPT                  SAVE DEST PTR
         ST    SRR,RET                  SAVE RETURN POINTER
         BAL   SRR,GTP                  GET POINTER IN INPUT BUFF
         L     SRR,RET
         BCR   8,SRR                    EOF READ RETURN
         L     SP1,DPT                  RESTORE DEST PTR
         B     GTM1                     RETURN TO MOVE
         EJECT
*TITLE-  PUTXT... PUT TEXT                                            *
*FUNCTION-  SUBROUTINE MOVES A LOGICAL RECORD FROM THE INPUT BUFFERS  *
*   OR FROM AN AREA SPECIFIED BY THE USER, TO THE OUTPUT BUFFER       *
*INPUT-  SP1 CONTAINS EITHER A POINTER TO THE USER'S WORK AREA, OR 0, *
*   INDICATING THE RECORD IS CONTAINED IN AN INPUT BUFFER.            *
*OUTPUT-  SP1 CONTAINS POINTER TO USER'S WORK AREA (UNCHANGED),       *
*                  OR POINTER TO RECORD WITHIN OUTPUT BUFFER (IF      *
*                      ENTRY WAS WITH SP1=0)                          *
*                  OR 0, IF END OF FILE WAS READ                      *
*NOTE-                                                                *
*   USES OBM FOR OUTPUT BUFFER MANAGEMENT                             *
*   BRANCHES TO GTM IF THE RECORD TO BE MOVED IS CONTAINED IN AN INPUT*
*        BUFFER.                                                      *
         SPACE 2
PTX      LTR   SP1,SP1                  IS RECORD FROM INPUT BUFFER
         BZ    PT1                      IF YES, TO PT1
         MVC   RLI(2),0(SP1)            MOVE RLI TO HALFWORD BOUNDARY
         LH    GR3,RLI                  BYTE COUNT
         BAL   GR5,OBM                  OUTPUT BUFFER MANAGEMENT
         LR    GR1,SP1                  SOURCE PTR
         BAL   GR4,MOVE                 MOVE RECORD
         BR    SRR                      EXIT
PT1      MVI   CS4,1                    SET PUTXT CONTROL SWITCH
         B     GTM                      GO TO GTM
         EJECT
*TITLE-  CLSTXT...CLOSE TEXT FILE                                     *
*FUNCTIONS-                                                           *
*   'TCLOSE'S INPUT TEXT FILE                                         *
*   INSERTS END OF FILE SYMBOL INTO OUTPUT TEXT STREAM                *
*   'TCLOSE'S OUTPUT TEXT FILE                                        *
*INPUT-  NONE                                                         *
*OUTPUT- NONE                                                         *
*./      DELETE    SEQ1=06300020,SEQ2=06320020
*NOTE-                                                                *
*   BRANCHES TO OBM AND TEXTOT                                        *
         SPACE 2
CLT      L         GR3,BLKSIZE          BLOCK LENGTH
         BAL   GR5,OBM                  OUTPUT BUFFER MANAGEMENT
         MVC   0(4,GR2),EOF             EMBED AN EOF
*./      DELETE    SEQ1=06460020,SEQ2=06460020
         BAL   GR4,TEXTOT               TEXT OUTPUT SUBROUTINE
         SPACE 2
*TCLOSE TEXT FILE---BUFF INTERFACE
         SPACE
*./      DELETE    SEQ1=06560020,SEQ2=06560020
*./      DELETE    SEQ1=06580020,SEQ2=06640020
         L         GR1,BUFFPT(0,ACT)   TCLOSE INPUT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(24,4,1)
         L         GR1,BUFFPT(0,ACT)   TCLOSE OUTPUT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(24,8,1)
         BR    SRR                      EXIT
EOF      DC    4X'7F'                   END OF TEXT FLAG
         EJECT
*TITLE-  OBM...OUTPUT BUFFER MANAGEMENT                               *
*FUNCTION-                                                            *
*   WHEN THE BUFFER IS FILLED, IT IS WRITTEN OUT (BY TEXTOT).         *
*./      DELETE    SEQ1=06940020,SEQ2=06940020
*INPUT-  GR3 CONTAINS LENGTH OF CURRENT LOGICAL RECORD                *
*OUTPUT-  GR2 CONTAINS ADDRESS OF NEXT AVAILABLE BUFFER LOCATION      *
*./      DELETE    SEQ1=07000020,SEQ2=07000020
         SPACE 1
OBM      STM   GR12,GR14,OBSAVE
         LM    GR12,GR14,OBUFREM
         CR    GR3,GR12                 RLI LTE OCT+2
         BC    12,OB2                   YES TO OB2
         L         GR12,BLKSIZE         BLOCK BYTE COUNT TO GR12
         OI    2(GR13),X'80'            SET LAST RECORD BIT
*./      DELETE    SEQ1=07160020,SEQ2=07160020
         BAL   GR4,TEXTOT               WRITE UTILITY FILE
         L     GR14,WRADD              RESET NEXT RECORD POINTER
*./      DELETE    SEQ1=07220020,SEQ2=07240020
OB2      SR    GR12,GR3                 DEC BYTE COUNT BY RLI
         LR    GR13,GR14                NEXT OUTPUT LOCATION
         AR    GR14,GR3                 ADVANCE NEXT OUT PTR
         STM   GR12,GR14,OBUFREM        PUT AWAY RESULTS
         LR    GR2,GR13                 CALLER GETS NEXT RECORD POSIT'N
         LM    GR12,GR14,OBSAVE
         BR    GR5                      EXIT
         EJECT
* SUBROUTINE TO MOVE ANY SIZE BLOCK FROM (GR1) TO (GR2)
MOVE     SH    GR3,MAXCT                NO. OF BYTES GT 256
         BP    M1                       IF YES, TO M1
         LA    GR3,255(GR3)             DESCREASE LITERAL COUNT BY 1
         EX    GR3,M2                   EXECUTE MVC
         LA    GR3,1(GR3)               INC COUNT TO LITERAL COUNT
         AR    GR1,GR3                  ADVANCE SOURCE POINTER
         AR    GR2,GR3                  ADVANCE DESTINATION POINTER
         BR    GR4                      RETURN TO CALLER
M1       MVC   0(256,GR2),0(GR1)        MOVE 256 BYTES
         LA    GR1,256(GR1)             ADVANCE SOURCE PTR BY 256
         LA    GR2,256(GR2)             ADVANCE DESTINATION PTR BY 256
         B     MOVE                     RETURN TO MOVE
M2       MVC   0(0,GR2),0(GR1)
         EJECT
*TITLE-  PUTXRF...PUT CROSS-REFERENCE RECORD                          *
*FUNCTION-  SUBROUTINE PROVIDES AN ADDRESS AT WHICH A CROSS-REFERENCE *
*   RECORD MAY BE BUILT.  AS THE CROSS-REFERENCE BUFFER IS FILLED,    *
*   PUTXRF WRITES THE BUFFER ONTO THE OVERFLOW FILE.                  *
*INPUT-  NONE                                                         *
*OUTPUT-  SP1 CONTAINS THE ADDRESS AT WHICH THE NEXT RECORD MAY BE    *
*   BUILT.                                                            *
         SPACE 1
PUTX     L     SP1,XRFLRP               LAST LOGICAL REC POSITION
         LA    SP1,8(0,SP1)            ADVANCE PTR TO NEXT LOGICAL REC
         MVI   NULLXRF,0                TURN OFF NULL XRF SWITCH
         CL    SP1,XRFLBA               PTR EXCEED BUFFER
         BL    PUTX1                    NO TO PUTX1
         BAL   SP1,WROF                 WRITE OVERFLOW FILE
         LA    SP1,XRFBUF+1             BUFFER POINTER
PUTX1    ST    SP1,XRFLRP               SAVE PTR
         BR    SRR                      EXIT PUTX
XRFLRP   DC    A(XRFBUF+1-8)            XRF LOGICAL RECORD POINTER
XRFLBA   DC    A(XRFBUF+L'XRFBUF)       XRF LAST BYTE ADDRESS+1
NULLXRF  DC    X'FF'                    NULL XRF SWITCH
         EJECT
*TITLE-  PUTLBT...PUT LITERAL BASE TABLE                              *
*FUNCTION-  SUBROUTINE PROVIDES AN ADDRESS AT WHICH  LITERAL BASE     *
*   TABLE RECORD MAY BE BUILT.                                        *
*INPUT-NONE
*OUTPUT-  SP1 CONTAINS ADDRESS OF NEXT AVAILABLE LOCATION IN SYMBOL   *
*              TABLE.
PUTLB    ST        SRR,IOSAVE          SAVE RETURN ADDRESS
         LA        SP1,23              MAX LENGTH OF LBT/LAT ENTRY
         L         SRB,=A(STROOM)      CHECK ROOM IN SYMBOL TABLE
         DROP      SRB
         BALR      SRR,SRB
         USING     *,SRR
         DS        2H
         L         SRB,=A(TEXTIO)
         USING     TEXTIO,SRB
         DROP      SRR
         L         SP1,CTSYMP(0,ACT)   CALCULATE ADDRESS FOR ENTRY
         A         SP1,CFREEP(0,ACT)
         LA        SP1,3(0,SP1)        ALIGN F
         N         SP1,=F'-4'
         L         SRR,LBPTR           CHAIN TO LAST ENTRY
         ST        SP1,16(0,SRR)
         ST        SP1,LBPTR
         LA        SRR,20(0,SP1)       CALCULATE CFREEP
         S         SRR,CTSYMP(0,ACT)
         ST        SRR,CFREEP(0,ACT)
         LA        SP1,3(0,SP1)        GO PAST UNUSED PART
         L         SRR,IOSAVE          RESTORE RETURN ADDRESS
         BR        SRR                 RETURN
LBPTR    DS        F                   POINTS TO LAST LBT ENTRY
         EJECT
*TITLE-  SYSO...SYSTEM OUTPUT                                         *
*FUNCTION-  SUBROUTINE OUTPUTS 80-CHARACTER LOGICAL RECORDS TO SYSGO  *
*   AND/OR SYSPUNCH DATA SETS.
*INPUT-  SP1 CONTAINS ADDRESS OF 81-BYTE LOGICAL RECORD...THE FIRST   *
*   BYTE CONTAINS AN INTERNAL CONTROL CHARACTER.                      *
*   CTPCH1(ACT) CONTAINS PUNCH/LOAD OPTION BITS                       *
*OUTPUT- NONE                                                         *
         SPACE 1
SYSO     STM       SRR,FRB,IOSAVE      SAVE REGISTERS
         L         FRB,=A(SYSO1)       GO TO SYSO1 IN ASMGFI
         BALR      SRR,FRB
         LM        SRR,FRB,IOSAVE
         BR        SRR
         EJECT
*TITLE-  PHCLS...PHASE CLOSE                                          *
*FUNCTION-  SUBROUTINE CLOSES  SYSUT1 AND SYSUT2 DATA SETS.           *
*   END OF FILE LABELS ARE INSERTED INTO XREF STREAM AND THE BUFFER   *
*   IS WRITTEN ONTO THE OVERFLOW FILE.                                *
*         THE FOLLOWING PARAMETERS ARE INSERTED INTO THE I/O PORTION  *
*   OF THE ASSEMBLER CONTROL TABLE:                                   *
*       CTCXRF..COUNT OF XREF TABLE BLOCKS                            *
*       CTDNWP..POINTER TO NEXT SEQUENTIAL FILE POSITION ON SYSUT3    *
*EXIT- BRANCH TO ASMGFI (INTERLUDE)                                   *
         SPACE 1
PHC      BAL   SRR,CLT                  TCLOSE TEXT
         CLI   NULLXRF,0                CLOSE XRF FILE UNLESS
         BNE   PHC11                    NULL.
         BAL   SRR,PUTX                 PUT XRF
         MVC   0(4,SP1),EOF             EMBED EOF
         BAL   SP1,WROF                 WRITE OVERFLOW FILE
PHC11    MVC   CTCXRF(2,ACT),XRFCNT     XRF BLOCK COUNT
         L         SP1,LBPTR           PLACE END OF CHAIN MARKER
         SR        SP2,SP2
         ST        SP2,16(0,SP1)
         L         SRB,=A(ASMGFI)      GO TO ASMGFI
         BR        SRB
*./      DELETE    SEQ1=09480020,SEQ2=09800020
         EJECT
*   TEXT I/O INTERFACE WITH BUFF ROUTINE                              *
*ENTRY POINTS-                                                        *
*   TEXTOT...TEXT OUTPUT                                              *
*   TEXTIN...TEXT INPUT                                               *
*FUNCTION-  SUBROUTINE WRITES OR READS TEXT THROUGH BUFF ROUTINE.     *
*./      DELETE    SEQ1=09940020,SEQ2=09960020
         SPACE 1
TEXTOT   ST        GR0,IOSAVE          SAVE GR0
*./      DELETE    SEQ1=10020020,SEQ2=10140020
         L         GR1,BUFFPT(0,ACT)   DO A WRITE ON OUTPUT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(8,8)
WRADD    DS        F
WRLGTH   DS        F
         L         GR1,BUFFPT(0,ACT)   DO A CHECK ON OUTPUT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,8)
         L         GR0,IOSAVE          RESTORE GR0
         BR        GR4                 EXIT
*
TEXTIN   ST        GR0,IOSAVE          SAVE GR0
         L         GR1,BUFFPT(0,ACT)   DO A READ ON INPUT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(4,4)
RDADD    DS        F
         L         GR1,BUFFPT(0,ACT)   DO A CHECK ON INPUT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,4,0)
         L         GR0,IOSAVE          RESTORE GR0
         BR        GR4                 EXIT
*./      DELETE    SEQ1=10540020,SEQ2=10540020
*./      DELETE    SEQ1=10560020,SEQ2=10560020
         EJECT
*TITLE-  WROF...WRITE OVERFLOW FILE                                   *
*FUNCTION-  SUBROUTINE PERFORMS 'WRITE' AND 'CHECK'                   *
*   FUNCTIONS REQUIRED BY PUTXRF AND PHCLS SUBROUTINES                *
*INPUT-  GR1 CONTAINS ADDRESS OF OUTPUT TABLE                         *
*OUTPUT-  BLOCK COUNT IN XRFCNT UPDATED                               *
*./      DELETE    SEQ1=10700020,SEQ2=10700020
         SPACE 1
WROF     STM   GR0,GR1,IOSAVE
         L         GR1,BUFFPT(0,ACT)   DO A WRITE ON SYSUT1
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(8,0,XRFBUF,L'XRFBUF)
         L         GR1,BUFFPT(0,ACT)   CHECK IT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,0)
         LH     GR1,XRFCNT              BLOCK COUNT
         LA     GR1,1(GR1)              INCREMENT FOR LAST WRITE
         STH    GR1,XRFCNT              SAVE BLOCK COUNT
         LM    GR0,GR1,IOSAVE
         BR    SP1                      EXIT WROF
*
XRFCNT   DC        H'0'                NUMBER OF XREF BLOCKS
         EJECT
*        I/O ROUTINE COMMUNICATIONS FLAGS                             *
CS1      DC    X'00'               INPUT POINTER ADVANCED SWITCH
*                                  '00'=TEXT INPUT POINTER NOT READY
CS4      DC    X'00'               TEXT DESTINATION SWITCH
*                                  '01'=RECORD GOES TO OUTPUT BUFFER
RD1      DC    X'02'               NEW DATA SWITCH
*                                  '00'=RECORD IN CURRENT BUFFER
*                                  '01'=END OF DATA
*                                  '02'=NEED MORE DATA
*./      DELETE    SEQ1=11260020,SEQ2=11320020
MAXCT    DC    H'256'              MAX COUNT ALLOWED IN AN 'MVC'
  SPACE 5
         LTORG
         DROP  SRB
         DS    0D
         EJECT
*TITLE- ASMGF7...F7 INITIALIZATION                                    *
*FUNCTION-                                                            *
*   OBTAIN AND ALLOCATE MAIN STORAGE FOR TEXT I/O BUFFERS, SYMBOL     *
*   TABLE, ETC.                                                       *
*   MOVE EXTRN/ADCON POINTERS,DEFINED IN F7CT2 AND F7CT3 TABLES, INTO *
*   ASSEMBLER CONTROL TABLE
*ENTRY- TO ASMGF7, VIA 'LINK' FROM RTA                                *
*INPUT-  GEN. REG. ACT CONTAINS ADDRESS OF ASSEMBLER CONTROL TABLE    *
*OUTPUT-  GEN. REG. 'ACT' UNCHANGED FROM VALUE AT ENTRY               *
*        GEN. REG. CRB CONTAINS ADDRESS OF ASMGF7C (F7 MAIN-LINE CON- *
*        TROL)                                                        *
*EXIT-  BRANCH TO ASMGF7C                                             *
         SPACE 3
*BUFFERS WHICH OVERLAP VOLATILE INITIALIZATION LOGIC
         SPACE
XRFBUF   DS    XL(1+8*200)              XRF OUTPUT BUFFER
         SPACE     2
IBUFCPT  DS        F         INPUT BUFFER CURRENT RECORD POINTER
*./      DELETE    SEQ1=11820020,SEQ2=11920020
*./      DELETE    SEQ1=11940020,SEQ2=11980020
OBUFREM  DS        F         COUNT OF BYTES REMAINING IN OUTPUT BUFFER
OBUFCPT  DS        F         POINTER TO CURRENT LOGICAL REC IN OUT BUFF
OBUFNPT  DS        F         NEXT AVAILABLE OUTPUT BUFFER LOCATION
         SPACE 1
BLKSIZE  DS        F                   TEXT BLKSIZE
RLI      DS    1H                  RECORD LENGTH..ALIGNED FOR CALC'LTNS
*./      DELETE    SEQ1=12120020,SEQ2=12120020
RET      DS    1F                  RETURN REGISTER STORAGE
DPT      DS    1F                  GETXTM DESTINATION STORAGE
SAVE     DS        F               SUBROUTINE REGISTER SAVE AREA
*                                  GETPT AND GETXTM SAVE HERE
OBSAVE   DS    3F                  OBM ROUTINE REG. SAVE AREA
IOSAVE   DS        4F                   ASMGF7I I/O ROUTINES SAVE HERE
         ORG   XRFBUF             OVERLAP..CODE OK UNTIL BUFFERS FILL
         DC    X'07'                    XRF TYPE CODE.
         SPACE 10
ASMGF7   ST        14,CTMRSRTN(ACT)
         BALR  SRB,0
         USING *,SRB
         ENTRYOUT  F7
         L     SRB,=A(TEXTIO)
         USING TEXTIO,SRB
*./      DELETE    SEQ1=12440020,SEQ2=12580020
         MVI       CTLINECT+3(ACT),1   RESET LINE COUNTER.
         SPACE 5
         LA        GR2,CTLBTP-16(0,ACT) SET LBPTR
         ST        GR2,LBPTR
*COMPUTE MAIN STORAGE REQUIREMENTS AND ISSUE SHRINK.
*TEXT BLOCKSIZE IS THAT SET BY F1 AND PASSED ON BY F3.
         SPACE
PR13A    LH    GR2,CTXLEN(ACT)          FIND TEXT BLOCK SIZE
         LR        GR3,GR2
*./      DELETE    SEQ1=12780021,SEQ2=12780021
         LA        GR2,MIN(GR2,GR2)    BLOCK*2 + ADDITIONAL MIN REQ
         ST    GR2,STGREQ               TOTAL MINIMUM STORAGE REQUIRED
         L         GR1,BUFFPT(0,ACT)   ISSUE SHRINK CALL
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(36)
STGREQ   DS        F
STGOT    DS        F
         CLI       STGOT,X'FF'         TEST IF ENOUGH CORE
         L         FRB,=A(F7ABEND)     ABEND IF NOT
         BCR       8,FRB
         SPACE
*ALLOCATE BUFFERS COMMON TO F7,FI,F8.(SHRINK ACQUIRED)
*        INSERT POINTERS INTO ASSEMBLER CONTROL TABLE                 *
         SPACE
         L     GR1,STGOT                GETMAIN STORAGE PTR
         ST    GR1,CESIOA(0,ACT)       SAVE FOR F8 TO RELEASE
         ST        GR3,WRLGTH          BLOCKSIZE
         ST        GR3,BLKSIZE
         ST        GR1,WRADD           OUTPUT BUFFER ADDRESS
         ST        GR1,OBUFNPT         INITIALIZE POINTER FOR 1ST REC
*./      DELETE    SEQ1=13220020,SEQ2=13240020
         ST        GR3,OBUFREM         INITIALIZE NUMBER OF BYTES LEFT
         AR        GR1,GR3             INPUT BUFFER
         ST        GR1,RDADD            INPUT BUFFER ADDRESS
         ST    GR1,CTXIO1(,ACT)         I-O BUFFER 1 IN ACT
         AR    GR1,GR3                  STEP PAST SECOND BUFFER
         ST    GR1,CTFVEVAL(,ACT)       START OF F7V/F8V TERMS WORK
         LA    GR1,FVEVAL(,GR1)         END OF F7V/F8V TERMS WORK
         LA    SP2,24*2                 2*(MAX-1) NUMBER OF TERMS
         LA    CRB,10                   MAX-1 NUMBER OF LEVELS OF '('
         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q
         BO    EXTENEV                  BRANCH IF YES
         LA    SP2,15*2                 2*(MAX-1) NUMBER OF TERMS
         LA    CRB,4                    MAX-1 NUMBER OF LEVELS OF '('
EXTENEV  DS    0H
         STH   SP2,CTTERMC(,ACT)        PASS BACK NUMBER OF TERMS
         STH   CRB,CTPARENC(,ACT)       PASS BACK LEVEL OF PARENS
         ST    GR1,CTERRP(,ACT)         ERROR BUFFER PTR
         LA    GR1,ERRBUF(GR1)          55-BYTE ERROR BUFFER
         ST    GR1,CTESRP(ACT)          ESD SEGMENT RESIDENCE TABLE PTR
         ST    GR1,CTESRB(ACT)          WILL LATER GET ESD SEG RES BASE
         LA    GR1,ESDSEGR(GR1)         ROOM FOR ESD SEG RES TABLE
         ST    GR1,CTSYMP(ACT)          SYMBOL TABLE PTR
         LA        GR1,FASH(0,GR1)     TOP OF HASH TABLE
         ST    GR1,CTESDP(ACT)          ESD BUFFER PTR
         L     SP2,CTESRP(ACT)          FIND WHERE TO PUT ESD SEG RES..
         ST    GR1,0(SP2)               BASE, AND PUT IT THERE
         LA        GR1,ESDSEG+MINSYM(0,GR1) TOP OF GOTTEN CORE
         ST        GR1,CESIOB(0,ACT)
*        SET SYMBOL TABLE GROW INCREMENT
         L         GR1,=V(STSHLEN)     ADDRESS OF WORD TO HOLD LENGTH
         SRL       GR3,2               .25 * UT2&3 BLKSIZE
         N         GR3,=X'FFFFFFF8'    ROUND TO DOUBLE WORDS LONG
         ST        GR3,0(0,GR1)        PLACE IN ASMGF7S
         SPACE 4
* MOVE EXTRN/ADCON POINTERS TO CONTROL TABLE
*
         MVC   CT2(CT2C*4,ACT),F7CT2   FUNCTIONAL ROUTINES
         MVC   CT3(CT3C*4,ACT),F7CT3   COMMON SUBROUTINES
*
* CLEAR HASH TABLE AND FIRST ENTRY OF FIRST ESD SEGMENT.
*
         MVI       ESDSEGR(SP2),0
         MVC       ESDSEGR+1(255,SP2),ESDSEGR(SP2)
         MVC       ESDSEGR+256(256,SP2),ESDSEGR(SP2)
         MVC       ESDSEGR+512(256,SP2),ESDSEGR(SP2)
         MVC       ESDSEGR+768(200,SP2),ESDSEGR(SP2)
*
         L     CRB,=A(ASMGF7C)          PASS CONTROL TO AC7MLC
         BR    CRB                      AND TEXT PROCESSING WILL BEGIN
         SPACE 5
         LTORG
         SPACE
FVEVAL   EQU       224                 F7V/F8V TERM EVALUATION AREA
ERRBUF   EQU       56                  ERROR BUFFER
ESDSEGR  EQU       96                  ESD RESIDENT SEGMENT POINTER TAB
LASH     EQU       31                  LITERAL HASH (28) + OPSYN PTR
HASH     EQU       3*307+LASH          HASH TABLE
FASH     EQU       HASH/8*8+8          DOUBLE ALIGNED HASH
ESDSEG   EQU       256                 ESD SEGMENT
MINSYM   EQU       2048-ESDSEG         MIN SYMBOL TABLE SIZE
MIN      EQU       FVEVAL+ERRBUF+ESDSEGR+FASH+ESDSEG+MINSYM
         EJECT
*... ADCON DEFINITION FOR PHASE F7...THESE CONSTANTS ARE MOVED INTO   *
*    THE ASSEMBLER CONTROL TABLE DURING INITIALIZATION PORTION OF     *
*    ASMGF7I.                                                         *
*    CBRNDA, CCOM, CCSECT, ETC. ARE EQUATED (IN FDIMEN DECK, SEE LIST-*
*    ING IN ASMGRTA) TO DISPLACEMENT OF ADCONS RELATIVE TO ADDRESS OF *
*    ASSEMBLER CONTROL TABLE                                          *
         SPACE
******** F7CT2 - FUNCTIONAL ROUTINE BASE/ENTRY ADDRESSES **************
*
F7CT2    DS    0F
*
         ORG   F7CT2-CT2+CBRNDA    CBRNDA EQU CT2+00 IN FDIMEN
         DC    A(ASMGF7E)
         ORG   F7CT2-CT2+CCOM
         DC    A(COM)
         ORG   F7CT2-CT2+CCSECT
         DC    A(CSECT)
         ORG   F7CT2-CT2+CDSECT
         DC    A(DSECT)
         ORG   F7CT2-CT2+CENTRY
         DC    A(ENTRY)
         ORG   F7CT2-CT2+CEXTRN
         DC    A(EXTRN)
         ORG   F7CT2-CT2+CORG
         DC    A(ORG)
         ORG   F7CT2-CT2+CQUIT
         DC    A(QUIT)
         ORG   F7CT2-CT2+CSTART
         DC    A(START)
         ORG   F7CT2-CT2+CUPC
         DC    A(UPC)
         ORG   F7CT2-CT2+CDCVAL
         DC    A(ASMGF7D)
*./      DELETE    SEQ1=14880020,SEQ2=14900020
         ORG   F7CT2-CT2+CTXGET
         DC    A(ASMGF7X)
         ORG   F7CT2-CT2+CTESTR
         DC    A(ASMGF7N)
         ORG   F7CT2-CT2+CDXD
         DC    A(DXD)
*
         ORG   F7CT2+CT2C*4
         EJECT
******** F7CT3 - COMMON SUBROUTINE BASE/ENTRY ADDRESSES ***************
*
F7CT3    DS    0F
*
         ORG   F7CT3-CT3+CTXTIO
         DC    A(TEXTIO)
         ORG   F7CT3-CT3+CSTGET
         DC    A(STGETR)
         ORG   F7CT3-CT3+CSTPUT
         DC    A(STPUTR)
         ORG   F7CT3-CT3+CEEVAL
         DC    A(ASMGF7V)
         ORG   F7CT3-CT3+CLOGER
         DC    A(ASMGF7L)
         ORG   F7CT3-CT3+CDCGET
         DC    A(ASMGF7G)
         ORG   F7CT3-CT3+CVCON
         DC    A(VCON)
         ORG   F7CT3-CT3+CSTROM
         DC    A(STROOM)
         ORG   F7CT3-CT3+CSTREF
         DC    A(STREFR)
*
         ORG   F7CT3+CT3C*4
         ORG   ,
         SPACE
         END       ASMGF7
./ ADD NAME=ASMGF7L
F7L      TITLE     'ASMG F7  LOG ERROR SUBROUTINE (LOGERR)'
         ISEQ  73,78
ASMGF7L  START
         SPACE
         PRINT      NOGEN
         FDIMEN
         SPACE
***********************************************************************
*                                                                     *
* LOGERR IS CALLED BY   ASMGF7    TO BUILD ERROR RECORD OR ADD ERROR  *
* MESSAGE TO EXISTING ERROR RECORD.                                   *
*                                                                     *
* MODEL CALLING SEQUENCE ---                                          *
*                                                                     *
*       L     SRB,CLOGER(ACT)           LOGERR BASE/ENTRY ADDRESS     *
*       L     SP1,POINTER               ABS POINTER TO ERROR (OR ZERO)*
*       BALR  SRR,SRB                                                 *
*       DC    AL2(ERRORCODE)            ERRORCODE EQU ERROR MSSG NUMBR*
*                                                                     *
* LOGERR WILL RETURN TO CALLING ROUTINE WITH SP1,SP2 UNCHANGED.       *
* GR0-GR2, GRX, GRY, AND GRZ ARE VOLATILE.                            *
*                                                                     *
***********************************************************************
         SPACE
ERRMAX   EQU   16                       MAX NUMBER OF ERRORS/STATEMENT
         SPACE
         USING     ASMGF7L,SRB
         SPACE 2
         STM   SP1,SP2,SAVE2            ENTER LOGERR, SAVE REGS
         L     SP2,CTERRP(ACT)          POINTER TO ERROR REC WORK AREA
         S     SP1,CTXOFP(ACT)          CALC RELATIVE POINTER         *
         BP    GETERR                   POINTER PRESENT
         SR    SP1,SP1                  NOT PRESENT, CLEAR SP1
         EJECT
GETERR   CLI   ERSWH(ACT),X'FF'         TEST ERROR REC IN CORE SWITCH
         BE    ADDERR                   SET, ADD ERROR MESSAGE TO REC
         MVI   ERSWH(ACT),X'FF'         NOT SET, SET
         MVI   2(SP2),X'10'             INITIALIZE ERR REC IN WORK AREA
         MVI   3(SP2),X'00'             REC TYPE EQ 001, COUNT EQ ZERO
         L     GR1,CTEXTP(ACT)
         TM    TXERI(GR1),X'04'         TEST ERROR REC FOLLOWS IND
         BO    GETREC                   SET, GET ERROR REC FROM TEXT
         OI    TXERI(GR1),X'04'         NOT SET, SET IT
         B     ADDERR                   THEN ADD ERR MESSAGE TO NES REC
         SPACE
GETREC   STM   SRB,SP2,SAVE4            GET ERROR REC FROM TEXT FILE
         LR    SP1,SP2
         L     SRB,CTXTIO(ACT)
         BAL   SRR,GETXTM(SRB)
         USING *,SRR
         LM    SRB,SP2,SAVE4
         DROP  SRR
         SPACE
ADDERR   CLI   3(SP2),ERRMAX            TEST ERROR COUNT
         BE    RETURN                   EXIT IF MAX
         SPACE
         SR    GR1,GR1                  PUT ERROR COUNT IN GR1
         IC    GR1,3(SP2)
         LR    GR2,GR1                  POINT GR2 TO CURRENT MESSAGE-1
         SLL   GR2,1
         LA    GR2,0(GR2,SP2)
         SPACE
         STC   SP1,5(GR2)               PUT COL POINTER IN ERR MESSAGE
         MVC   4(1,GR2),1(SRR)          PUT ERROR CODE  IN ERR MESSAGE
         LH    SP1,4(GR2)               PUT ERROR MESSAGE IN SP1
         SPACE
CHECKERR CLR   GR2,SP2                  COMPARE CURRENT ERROR MESSAGE
         BE    COUNTERR                 AGAINST PRIOR MESSAGES
         CH    SP1,2(GR2)
         BE    RETURN                   IGNORE IF PREVIOUSLY LOGGED
         BCTR  GR2,0
         BCT   GR2,CHECKERR
         SPACE
COUNTERR LA    GR1,1(GR1)               INC ERROR COUNT
         STC   GR1,3(SP2)
         LA    GR1,4(GR1,GR1)           INC RECORD LENGTH
         STH   GR1,TXRL(SP2)
         SPACE
RETURN   LM    SP1,SP2,SAVE2            RESTORE REGS
         B     2(SRR)                   RETURN TO CALLING ROUTINE
         SPACE
SAVE2    DS    2F                       SP1,SP2 SAVE AREA
SAVE4    DS    4F                       SRB-SP2 SAVE AREA
         SPACE
         END   ASMGF7L
./ ADD NAME=ASMGF7N
F7N      TITLE     'ASMG F7  TESTRAN ROUTINE (TSTRAN)'
         ISEQ  73,78
ASMGF7N  START
         SPACE
         PRINT      NOGEN
         FDIMEN
         SPACE 2
*TITLE 'ASMGF7N ',    TESTRAN                                         *
*FUNCTION/OPERATION-                                                  *
*   WHEN THE TESTRAN OPTION IS USED,ASMGF7C TRANSFERS CONTROL HERE.   *
*   THIS ROUTINE PRODUCES CARD ON SYSPUNCH AND/OR SYSGO DATA SETS.    *
*   THESE CARDS ARE TO BE USED IN SUBSEQUENT EXECUTION OF THE OBJECT  *
*   DECK WHEN EXECUTED IN THE TESTRAN. THIS DECK IS ESSENTIALLY AS    *
*   STORAGE MRP OF THE PROGRAM.                                       *
*ENTRY POINT- ASMGF7N                                                 *
*   CALLED BY ASMGF7C VIA                                             *
*        L     FRB,CTESTR(ACT)          GET ENTRY POINT               *
*        BALR  CRR,ACT                  CALL ASMGF7N                  *
*INPUT- NONE                                                          *
*OUTPUT-                                                              *
*   TESTRAN 'SYM' CARDS ARE PUT OUT ON SYSPUNCH AND/OR SYSGO. THE     *
*   FORMAT OF THE TESTRAN 'SYM' CARD IS-                              *
*       COLUMN      CONTENTS                                          *
*         1         T29 PUNCH                                         *
*         2-4       'SYM'                                             *
*         5-10      BLANK                                             *
*        11-12      NUMBER OF BYTES OF TEXT                           *
*        13-16      BLANK                                             *
*        17-72      VARIABLE FIELD                                    *
*        73-80      BLANK                                             *
*   THE GENERAL FORMAT IN ORDER OF AN INDIVIDUAL ITEM IS-             *
*      LENGTH(BYTES)  CONTENTS                                        *
*         1    ORGINIZATIONAL BYTE                                    *
*         3    ADDRESS-DISP FROM BASE OF CONTROL SECTION              *
*        0-8   SYMBOLIC NAME                                          *
*         1    DATA TYPE                                              *
*         1    LENGTH                                                 *
*         3    MULTIPLICITY                                           *
*         2    SCALE                                                  *
*EXTERNAL ROUTINES-                                                   *
*   SYSOUT- USED TO PUT OUT THE TESTRAN 'SYM' CARD. THIS ROUTINE IS IN*
*          ASMGF7I AND IS CALLED AS FOLLOWS-                          *
*                        LA   SP1,TEBFR      LOAD ADDRESS OF CRD IMAGE*
*                        L    SRB,CTXTIO(ACT)  BASE OF I/O ROUTINE    *
*                        BAL  SRR,SYSOUT(SRB)  CALL SYSOUT            *
*EXITS- NORMAL                                                        *
*   RETURNS TO CALLING ROUTINE VIA                                    *
*        BR    CRR                      RETURN                        *
*     - ERROR-- NONE                                                  *
*TABLES/WORKAREAS-                                                    *
*        NAME       FUNCTION                                          *
*        SAVMWD     SAVE AREA                                         *
*        TTN        OUTPUT CARD IMAGE BUFFER                          *
*        TBLHEX     DECIMAL TO HEX TRANSLATE TABLE                    *
         SPACE 3
GR8      EQU   SRB
GR9      EQU   SRR
         SPACE
         USING *,FRB
         EJECT
TESYM    STM   GRA,GRD,SAVMWD           SAVE REGISTERS
         TM    CTPH7C(ACT),X'02'        IS PHASE COMPLETE
         BO    WRILST                   YES
         LA    PTR,WKAREA               INITIALIZE WORK AREA POINTER
         MVI   FOPN,X'00'
TSTALN   L     GRA,CTEXTP(ACT)          SET POINTER TO TEXT RECORD
         L     GRB,CTXABP(ACT)          SET POINTER TO WORK BUCKETS
         MVC   LOCCTR+1(3),TXLOC(GRB)
         XC    REMSV(4),REMSV           CLEAR REMAINDER SAVE AREA
         MVI   BLDATA,0
         MVI   STPFLG,0
         TM    TXTO(GRA),X'40'          TEST FOR MACHINE OP ENTRY
         BO    OPALN                    BRANCH IF BITS ON
         CLI   TXHEX(GRA),X'26'         CHECK INSTRUCTION TYPE FOR A DC
         BE    CALNDC                   BRANCH IF EQUAL TO CHECK ALIGN
         CLI   TXHEX(GRA),X'27'         CHECK INSTRUCTION TYPE FOR A DS
         BE    CALNDC                   BRANCH IF EQUAL TO CHECK ALIGN-
*                                       MENT AS DC-DS.
         CLI   TXHEX(GRA),X'22'         IS TEXT A LTORG
         BE    OPALN                    YES
         CLI   TXHEX(GRA),X'25'         IS TEXT A LITERAL
         BNE   ALRTN                    NO
         MVC   LOCCTR(4),CTLOC(ACT)     YES, GET LOCATION COUNTER FOR
*                                       LITERALS
         LA    GRB,5(GRB)
         MVC   SAVWD+1(3),TXDLEN(GRB)
         L     GR8,LOCCTR
         MVI   SAVWD,0
         MVI   ORBYT,X'08'             INITIALIZE OR BYTE
         S     GR8,SAVWD
         ST    GR8,LOCCTR
         B     TEDC
OPALN    TM    TXALIN(GRB),X'07'        TEST FOR ALIGNMENT BITS ON -OP-
         BZ    ALRTN                    BRANCH TO PROCESS ENTRY IF ZERO
         IC    GRY,TXALIN(GRB)          GET ALIGNMENT BITS
         B     TEALEN                   BRANCH TO MAKE ALIGNMENT ENTRY
*
CALNDC   TM    FOPN,X'FF'               CHECK WORK AREA POINTER SWITCH
         BO    TEDUDP                   IF ON, BRANCH
         LA    GRB,5(GRB)
TEDUDP   TM    TXDALN(GRB),X'0E'        TEST FOR ALIGNMENT BITS ON -DC-
         BZ    ALRTN                    BRANCH TO PROCESS ENTRY IF ZERO
         IC    GRY,TXDALN(GRB)          GET ALIGNMENT BITS
         SRL   GRY,1                    ADJUST BITS TO REGISTER BOUNDRY
         TM    FOPN,X'FF'               IS THIS THE FIRST OPERAND
         BZ    TEALEN                   YES
         LA    GR8,7                    NO, LOAD MASK
         NR    GR8,GRY                  MASK ALIGNMENT BITS
         A     GR8,LOCCTR               ADD LOCATION COUNTER
         ST    GR8,LOCCTR               STORE AS NEW LOCATION
TEALEN   MVI   ORBYT,X'08'              INITIALIZE OR BYTE TO SPACE
         LA    GR8,7                    SET MASK TO CLEAR UNWANTED BITS
         NR    GRY,GR8                  CLEAR UNWANTED BITS
         L     GR8,LOCCTR               LOAD LOCATION COUNTER
         SR    GR8,GRY                  REDUCE ADDRESS BY BYTES SKIPPED
         ST    GR8,SAVWD                MOVE ADDRESS OF SPACE TO WORK
         MVC   ADDRES(3),SAVWD+1        AREA
         STC   GRY,0(PTR)               STORE NO. BYTES SKIPPED AS LENG
         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA
         BAL   GRY,STEN                 BRANCH TO STORE ENTRY
ALRTN    MVI   ORBYT,X'00'              INITIALIZE OR BYTE
         TM    FOPN,X'FF'               TEST THIS FOR FIRST OPERAND
         BO    NONAM                    BRANCH IF FLAG ON TO NO NAME.
         TM    TXNAML(GRA),X'FF'        CHECK NAME LENGTH INDICATOR
         BZ    NONAM                    BRANCH ON LENGTH ZERO TO NONAM
         SR    GRY,GRY
         IC    GRY,TXNAML(GRA)          GET NAME LENGTH
         AR    PTR,GRY                  STEP WORK AREA POINTER
         BCTR  GRY,0
         L     SP2,CTRTBP(ACT)          LOAD TRANSLATE TABLE LOCATION
         EX    GRY,MVNAM                MOVE TRANSLATED NAME TO WORK
*                                       AREA
         EX    GRY,TRANS                TRANSLATE NAME FOR SYMBOL TABLE
         EX    GRY,ORBOR                OR NAME LENGTH INTO OR BYTE
         B     NMRTN
NONAM    MVI   ORBYT,X'08'              INDICATE NO NAME PRESENT
***********************************************
*  TEST FOR MACHINE OP OR ASSEMBLER OP ENTRY  *
***********************************************
NMRTN    TM    TXTO(GRA),X'80'          TEST FOR DC-DS ENTRY
         BO    TEDCCT                   YES, BRANCH
         TM    TXTO(GRA),X'40'          TEST FOR ASSEMBLER OP ENTRY
         BO    TEOPS                    YES, BRANCH
         B     RETURN                   NO, RETURN TO MAINLINE
***********************************************************************
*  THE FOLLOWING IS A TEST FOR TYPE OF ENTRY. DC AND DS ENTRIES HAVE  *
*  THE HEX CODES 26 AND 27. ANYTHING ELSE WITH A HEX CODE OF 28 OR    *
*  LESS IS A CONTROL SECTION ENTRY.                                   *
***********************************************************************
TEDCCT   CLI   TXHEX(GRA),X'26'         TEST FOR DESIRED ENTRY
         BE    TEDC                     YES, BRANCH
         CLI   TXHEX(GRA),X'27'
         BNE   TECTLS                   NOT DC-DS ENTRY, BRANCH
*
TEDC     CLI   TXDTYP(GRB),X'03'        IS ENTRY TYPE P
         BE    PZCOD                    BRANCH IF CODE IS P
         CLI   TXDTYP(GRB),X'04'        CHECK FOR Z CODE
         BNE   LMPRS                    BRANCH IF CODE NOT Z
*
PZCOD    MVI   PZSWH,X'00'              ZERO P-Z SWITCH
         TM    TXDLMP(GRB),X'10'        TEST FOR LENGTH MODIFIER PRES.
         BC    5,LMPRS                  YES, BRANCH
         CLI   TXDCON(GRB),X'01'
         BE    LMPRS                    YES, BRANCH
*
NOLNM    MVI   PZSWH,X'FF'              SET P-Z SWITCH ON
*
LMPRS    OI    ORBYT,X'80'              INDICATE DATA ENTRY IN OR BYTE
         MVC   ADDRES(3),LOCCTR+1       MOVE ADDRESS TO WORK AREA
*
         MVC   0(1,PTR),TXDTYP(GRB)     MOVE HEX TYPE TO WORK AREA
         TR    0(1,PTR),TBLHEX          TRANSLATE TO PROPER CODE
         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA
         MVI   BCXIND,0
*
CFBC     CLI   TXDTYP(GRB),X'02'        CHECK FOR B CODE
         BH    BLNTST                   BRANCH IF CODE HIGH
*
SFBCX    MVI   BCXIND,X'FF'             SET B, C OR X CODE FLAG ON
BLNTST   TM    TXDLMD(GRB),X'01'        TEST FOR BIT LENGTH CONSTANTS
         BO    BITLGN                   YES, BRANCH
*
         TM    BCXIND,X'FF'             TEST B, C OR X FLAG
         BO    BCORX                    BRANCH IF ON TO MOVE BCX LENGTH
         TM    PZSWH,X'FF'              TEST P-Z FLAG
         BO    PZCLR                    BRANCH IF ON TO MOVE P-Z LENGTH
*
         SR    GRX,GRX                  PUT CONSTANT LENGTH
         IC    GRX,TXDLNM+1(GRB)
         BCTR  GRX,0
         STC   GRX,0(PTR)
         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA
         B     DUPTST                   BRANCH TO TEST DUPLICATION
*
BCORX    MVC   CTWORK(2,ACT),TXDLNM(GRB) MOVE LENGTH MODIFIER TO ARRY
         LH    GRX,CTWORK(ACT)
         BCTR  GRX,0
         STH   GRX,CTWORK(ACT)
         MVC   0(2,PTR),CTWORK(ACT)
         LA    PTR,2(PTR)               STEP POINTER TO WORK ARRY
*
DUPTST   MVC   SAVWD+1(3),TXDUPL(GRB)   ALIGN DUPLICATION FACTOR IN
         L     GRY,SAVWD                FULL WORD AND LOAD IN REGISTER
         LA    GRY,0(GRY)
         C     GRY,ONE                  IS DUPLICATION GREATER THAN ONE
         BNE   CKNOP                    YES, BRANCH
*
         TM    TXDCON(GRB),X'FE'        IS NO. OF CONSTANTS GREATER
         BE    CKXOB                    THAN ONE.  NO, BRANCH
*
         SR    GRY,GRY
         IC    GRY,TXDCON(GRB)          GET NO. OF CONSTANTS
         ST    GRY,SAVWD                BRANCH TO STORE AS MULTIPLICITY
         B     MVMLT
*
CKNOP    TM    TXDCON(GRB),X'FF'        TEST NO. CONSTANTS.
         BZ    NOZRO                    NONE, BRANCH
*
         SR    GR9,GR9                  GET NO CONSTANTS AND ZERO HIGH
         IC    GR9,TXDCON(GRB)          ORDER BYTES OF REGISTER.
         MR    GR8,GRY                  NO. CONSTANTS X DUPLICATION
         ST    GR9,SAVWD
MVMLT    MVC   0(3,PTR),SAVWD+1         STORE AS MULTIPLICITY FACTOR
         LA    PTR,3(PTR)               STEP POINTER TO WORK AREA
*
         OI    ORBYT,X'40'              INDICATE MULT. IN OR BYTE
         B     CKXOB
*
NOZRO    ST    GRY,SAVWD                STORE DUP. FACTOR AS MULT. NO.
         B     MVMLT                    OF CONSTANTS IS ZERO.
*
CKXOB    TM    BCXIND,X'FF'             CHECK B, C OR X INDICATOR.
         BO    STDCEN                   ON, BRANCH
*
         MVC   SAVWD+2(2),TXDSCM(GRB)   GET SCALE MODIFIER AND ALIGN IT
         LH    GR8,SAVWD+2              IN A REGISTER.
         MVC   SAVWD+2(2),TXDSCM(GRB)
         LH    GR8,SAVWD+2
         SRA   GR8,5
         LTR   GR8,GR8                  TEST FOR MODIFIER
         BZ    STDCEN                   IF NONE, BRANCH
NOSOSM   ST    GR8,SAVWD                PUT SCALE MODIFIER
         MVC   0(2,PTR),SAVWD+2
*
         OI    ORBYT,X'10'              UPDATE ORBYT TO INDICATE SCALE
*                                       MODIFIER PRESENT
         LA    PTR,2(PTR)
*
STDCEN   BAL   GRY,STEN                 BRANCH TO STORE ENTRY
TSTNBK   MVC   SAVWD+1(3),TXDLEN(GRB)   GET OPERAND LENGTH
         TM    TXDLAS(GRB),X'08'        IS THIS THE LAST WORK BUCKET
         BO    RETURN                   YES, RETURN
         LA    GRB,15(GRB)
         TM    TXWTYP(GRB),X'40'        TEST FOR ANOTHER OPERAND WORK
*                                       BUCKET
         BZ    RETURN                   RETURN IF NOT FOUND
         TM    BLDATA,X'FF'
         BZ    STPLC1                   BRANCH IF SWITCH OFF
         TM    TXDLMD(GRB),X'01'        TEST FOR BIT LENGTH CONSTANTS
         BZ    STPLC1                   NO, BRANCH
         L     GR1,STEPER
         B     STPLC2
STPLC1   L     GR1,SAVWD
STPLC2   A     GR1,LOCCTR
         ST    GR1,LOCCTR
         MVI   FOPN,X'FF'               SET SWITCH THIS NOT FIRST OPND
         B     CALNDC                   BRANCH TO PROCESS NEXT OPERAND
*
*
BITLGN   SR    GR9,GR9
         OI    BLDATA,X'FF'
         MVC   SAVWD+2(2),TXDLNM(GRB)   GET LENGTH MODIFIER
         LH    GR8,SAVWD+2
         N     GR8,=A(X'FFFF')
         A     GR8,REMSV                ADD REMAINING BITS FM LAST OPND
         SRDL  GR8,3                    DIVID BY 8 FOR NO. OF WORDS
         LTR   GR8,GR8                  TEST FOR BIT LENGTH LESS THAN 8
         BZ    BOTCD                    YES, BRANCH
*
         LTR   GR9,GR9                  TEST FOR REMAINDER
         BC    6,BOTCD                  YES, BRANCH
*
         BCTR  GR8,0                    DECREASE LENGTH INDICATOR BY 1
*
BOTCD    TM    BCXIND,X'FF'             TEST B-C-X TYPE CODE FLAG
         BO    MLTB                     FLAG OFF, BRANCH
         STC   GR8,0(PTR)               STORE LENGTH-1 IN WORK AREA
         LA    PTR,1(PTR)               STEP POINTER TO WORK AREA BY 1
*
SETSTP   XC    SAVWD(2),SAVWD           ZERO FIRST 2 BYTES
         MVC   SAVWD+2(2),TXDLEN(GRB)   GET CONSTANT LEN
         L     GR9,SAVWD
         MVC   SAVWD+1(3),TXDUPL(GRB)   GET DUP FACTOR
         M     GR8,SAVWD                LEN X DFP FACTOR
         IC    GR8,TXDCON(GR8)          GET NO. CONSTANTS IN OPND
         MR    GR8,GR8                  LEN X DUP X NO. CONSTANTS
         LR    GR8,GR9
         A     GR8,REMSV
         SRDL  GR8,3
         ST    GR8,STEPER
         SR    GR8,GR8
         SLDL  GR8,3
         ST    GR8,REMSV
         B     DUPTST
*
MLTB     STH   GR8,SAVWD+2              STORE LENGTH MODIFIER AS 2 BYTE
         MVC   0(2,PTR),SAVWD+2
         LA    PTR,2(PTR)               STEP POINTER TO WORK AREA BY 2
         B     SETSTP
*
*
STEN     ST    GRY,STSAV                SAVE RETURN ADD-ESS
         LA    GR9,56                   LOAD NO. BYTE OF VARIABLE INFO.
         LA    GR8,ORBYT                GET ENTRY LOCATION
         SR    PTR,GR8                  FIND THE NO. OF BYTES IN ENTRY
         S     GR9,NOLEFT               GET NO. OF BYTES USED IN BUFFER
         LA    GRX,TEBFR+17(GR9)        GET PTR TO NEXT BYTE
         C     PTR,NOLEFT               COMPARE NO. LEFT TO NO.IN ENTRY
         BP    CHAREB                   BRANCH IF ANY LEFT
MCLN     BCTR  PTR,0                    REDUCE NO. OF CHARS. FOR MOVE
         EX    PTR,MOVEN                EXECUTE MOVE
         LA    PTR,1(PTR)               STEP NO. OF CHARS. BY 1
         L     GR9,NOLEFT               GET NO. BYTE LEFT IN BUFFER.
         SR    GR9,PTR                  REDUCE BY NO. CHARS. MOVED
         BZ    RESET                    IF NO. LEFT = 0 BRANCH TO RESET
*
         ST    GR9,NOLEFT               STORE NO. LEFT FOR NEXT ENTRY
STRTN    LA    PTR,WKAREA               RESET POINTER TO WORK AREA
         L     GRY,STSAV                RESTORE RETURN ADDRESS
         BR    GRY                      RETURN
*
CHAREB   L     GR9,NOLEFT               GET NO. LEFT
         BCTR  GR9,0
         EX    GR9,MOVEN                MOVE NO. CHARS. LEFT TO BUFFER.
         MVI   NLF,X'FF'                SET CHARS. LEFT FLAG
*
OUTSYM   TM    FPSWH,X'FF'              TEST FIRST PASS SWITCH
         BO    PUNOUT                   BRANCH IF ON
         MVI   FPSWH,X'FF'              TURN ON FIRST PASS SWITCH
         MVC   TTLSEQ(4),CTITLE(ACT)    MOVE TITLE TO BE PUNCHED IN
*                                       OUTPUT CARDS
         SR    GR2,GR2
         ST    GR2,CCRDCT(ACT)          INITIALIZE CARD COUNT
PUNOUT   L     GR1,CCRDCT(ACT)          GET CARD SEQUENCE NUMBER
         LA    GR1,1(GR1)               ADD 1
         ST    GR1,CCRDCT(ACT)          STORE
         CVD   GR1,DBLWD                CONVERT SEQUENCE NO. TO DECIMAL
         UNPK  TTLSEQ+4(4),DBLWD+5(3)   UNPACK LOW ORDER 4 DIGITS
         OI    TTLSEQ+7,X'F0'           MASK SIGN
         STM   SRB,SRR,DBLWD            SAVE REGISTERS
         STM   0,15,CTWORK(ACT)         ********TEMP FIX***************
         LA    SP1,TEBFR                LOAD I/O OUTPUT PARAMETER
         L     SRB,CTXTIO(ACT)          LOAD I/O ROUTINE ADDRESS
         BAL   SRR,SYSOUT(SRB)          BRANCH TO OUTPUT SYMBOL CARD
         LM    SRB,SRR,DBLWD            RESTORE REGISTERS
         LM    0,15,CTWORK(ACT)         ********TEMP FIX***************
*
         MVC   TEBFR+17(56),TEBFR+16    BLANK OUTPUT BUFFER
         LA    GRX,TEBFR+17             RESET BUFFER POINTER
         LA    GRY,56                   RESET NO. LEFT INDICATOR
         ST    GRY,NOLEFT
         TM    NLF,X'FF'                TEST IF ANY CHARS LEFT TO ENTER
         BZ    STRTN                    BRANCH IF NONE.
         LA    GR9,1(GR9)
*
         SR    PTR,GR9                  SET POINTERS TO MOVE REMAINING
         AR    GR8,GR9                  CHARSACTERS.
         MVI   NLF,X'00'                RESET ADDITIONAL CHARACTERS
*                                       FLAG
         B     MCLN
*
RESET    LA    GR9,56                   RESET NOLEFT
         B     OUTSYM
*
TEOPS    TM    8(GRA),X'FF'             CHECK FOR NAME PRESENT
         BZ    RETURN                   RETURN TO MAIN LINE IF NO NAME
*
         OI    ORBYT,X'40'              UPDATE OR BYTE
         MVC   ADDRES(3),LOCCTR+1       MOVE INSTR. LOC. TO WORK AREA
*
         BAL   GRY,STEN                 BRANCH TO STORE ENTRY
         B     RETURN                   RETURN TO MAIN LINE
*
*   START, CSECT, DSECT, CCW OR COM CODE ENTRY
*
TECTLS   CLI   TXHEX(GRA),X'1B'         CHECK FOR TYPE OF CODE
         BE    CSECT                    CSECT CODE, BRANCH
         BL    RETURN                   RETURN IF LOW
         CLI   TXHEX(GRA),X'1D'         CHECK CODE FOR DSECT
         BL    CSECT                    IF IT IS A CSECT, BRANCH
         BE    DSECT                    BRANCH ON EQUAL TO DSECT
*
         CLI   TXHEX(GRA),X'1E'         CHECK FOR COM CODE
         BE    COM                      YES, BRANCH
*
         CLI   TXHEX(GRA),X'28'         CHECK FOR CCW CODE
         BNE   RETURN                   RETURN IF NOT ONE OF THE ABOVE
*                                       CODES.
         OI    ORBYT,X'50'              RESET OR BYTE TO INDICATE CCW
MDSO     MVC   ADDRES(3),LOCCTR+1       MOVE LOCATION CTR AS ADDRESS
*
         BAL   GRY,STEN                 BRANCH TO STORE ENTRY.
         B     RETURN                   RETURN TO MAIN LINE
*
CSECT    OI    ORBYT,X'10'              RESET OR BYTE TO INDICATE CSECT
         B     MDSO
*
DSECT    OI    ORBYT,X'20'              RESET OR BYTE TO INDICATE DSECT
         B     MDSO
*
COM      DS    0H
         CLI   TXNAML(GRA),X'00'        IS THERE A LABEL FIELD .Q
         BNE   COMEXT                   BRANCH IF YES
         OI    ORBYT,X'38'              RESET OR BYTE TO UNLABELLED COM
         LA    PTR,WKAREA
         B     MDSO
COMEXT   DS    0H
         OI    ORBYT,X'30'              RESET OR BYTE TO LABELLED COM
         B     MDSO                     AND CONTINUE
*
*
* PUT LAST TESTRAN SYMBOL CARD
*
*
WRILST   LA    GR8,56                   GET MAX. NO. BYTES IN VAR. TEXT
         C     GR8,NOLEFT               COMPARE WITH NO. LEFT
         BE    RETURN                   RETURN IF EQUAL
         S     GR8,NOLEFT               DETERMINE THE NO. OF BYTES IN
*                                       THE LAST CARD
         STH   GR8,SAVWD                MOVE NO. OF BYTES IN LAST CARD
         MVC   NCL(2),SAVWD
*
         LA    GRY,RETURN               SET RETURN ADDRESS
         ST    GRY,STSAV                SAVE RETURN ADDRESS
         B     OUTSYM
*
RETURN   LM    GRA,GRD,SAVMWD           RESTORE REGISTERS
         BR    CRR                      RETURN
***********************************************************************
*  CLUSTER ENTRIES FOR P-Z TYPE CODE
***********************************************************************
*
*
PZCLR    MVC   PZLOC(4),LOCCTR          SAVE LOCATION COUNTER
         MVI   SCFCN,IZERO              ZERO FIRST CONSTANT FLAG
         SR    GR8,GR8                  SAVE CLUSTER FIELD ENTRY
         IC    GR8,TXDLEN+2(GRB)
         BCTR  GR8,0
         STC   GR8,0(PTR)
         MVC   1(3,PTR),TXDUPL(GRB)
         LA    PTR,4(PTR)
         OI    ORBYT,X'60'
         BAL   GRY,STEN
*
SCANPZ   SR    GR8,GR8                  ZERO COUNTERS
         STH   GR8,SCTTL
         STH   GR8,SCWHOL
         TM    SCFCN,X'FF'              TEST FIRST CONSTANT FLAG
         BO    SC12                     BRANCH IF ON
*
         STH   GR8,PLENG                ZERO OPERAND LENGTH INDICATOR
*                                       OPERAND
         SR    GRD,GRD
         IC    GRD,TXDPTR(GRB)          GET POINTER TO OPERAND
         L     GR9,CTXOFP(ACT)
         LA    GRD,1(GRD,GR9)           ADD POINTER TO BEGIN OF OPERAND
SC10     CLI   0(GRD),IQUOTE            IS CHAR A QUOTE
         BE    SC12                     YES, GO SCAN CONSTANT
         CLI   0(GRD),IBLANK            IS CHAR A BLANK
         BE    TSTNBK                   YES GET OUT
         LA    GRD,1(GRD)               STEP PTR TO NEXT CHAR
         B     SC10                     TEST NEXT CHAR
SC12     LA    GRD,1(GRD)               STEP POINTER BY 1
*
         CLI   0(GRD),IMINUS            IS CHARACTER A MINUS SIGN
         BE    SC14                     YES
         CLI   0(GRD),IPLUS             NO, IS CHARACTER A PLUS SIGN
         BE    SC14                     YES
*
SC13     CLI   0(GRD),I9                NO, IS CHARACTER NUMERIC
         BH    SC15                     NO
         LA    GR8,1(GR8)               YES, STEP COUNTER BY 1
SC14     LA    GRD,1(GRD)               STEP POINTER BY 1
         B     SC13                     LOOP BACK TO CHECK NEXT CHAR-
*                                       ACTER.
SC15     CLI   0(GRD),IPRIOD            IS CHARACTER A PERIOD
         BNE   SC16                     NO
         LA    GR8,1(GRB)
         STH   GR8,SCWHOL               YES, SAVE COUNT IN WHOLE
         SR    GR8,GR8                  ZERO COUNTER
         B     SC14                     LOOP BACK TO CHECK NEXT CHAR-
*                                       ACTER.
SC16     LH    GR9,SCWHOL               LOAD NO. CHARS. BEFORE PERIOD
         LTR   GR9,GR9                  CHECK FOR NONE
         BZ    SC161                    IF NONE, BRANCH
         BCTR  GR9,0                    DECREMENT
SC161    AR    GR9,GR8                  ADD COUNT
         CLI   TXDTYP(GRB),X'04'        IS ENTRY Z TYPE DC-DS
         BE    SC18                     YES
*
*
SC17     SRL   GR9,1                    DIVIDE TOTAL BY 2
         LA    GR9,1(GR9)               NO, ADD 1 TO TOTAL
SC18     STH   GR9,SCTTL                STORE TOTAL
         LA    GR9,16
         CR    GR8,GR9                  IS COUNT GREATER THAN 16
         BH    SC19                     YES
         CLI   SCTTL,X'10'              NO, IS TOTAL GREATER THAN 16
         BH    SC20                     YES
*
         B     PZ10                     NO, BRANCH TO OUTPUT CONSTANT
*                                       DATA
SC19     SR    GR8,GR8                  ZERO COUNT
SC20     MVI   SCTTL+1,X'10'            RESET TOTAL TO 16
*
PZ10     MVI   ORBYT,X'A8'              INITIALIZE OR BYTE
         MVC   ADDRES(3),PZLOC+1        MOVE ENTRY ADDRESS TO WORK AREA
         L     GR9,PZLOC                LOAD LOCATION COUNTER
         AH    GR9,SCTTL                ADD LENGTH OF CURRENT CONSTANT
         ST    GR9,PZLOC                STORE AS NEXT ENTRY ADDRESS
*
         LH    GR9,PLENG                GET OPERAND LENGTH COUNTER
         AH    GR9,SCTTL                ADD LENGTH OF CURRENT CONSTANT
         STH   GR9,PLENG                STORE NEW LENGTH
         MVI   WKAREA,X'30'             MOVE DATA TYPE TO WORK AREA
         CLI   TXDTYP(GRB),X'03'        IS ENTRY TYPE P
         BE    PZ11                     YES
*
         OI    WKAREA,X'04'             NO, UPDATE DATA TYPE
PZ11     LA    PTR,WKAREA+2             SET POINTER TO WORK AREA
         LH    GR9,SCTTL                GET CONSTANT LENGTH
         BCTR  GR9,0                    REDUCE BY 1
         STC   GR9,WKAREA+1             STORE LENGTH-1 IN WORK AREA
*
         LTR   GR8,GR8                  IS COUNT ZERO
         BZ    PZ12                     YES
         CLI   SCWHOL+1,X'00'           NO, IS WHOLE ZERO
         BE    PZ12                     YES
*
         STH   GR8,SCWHOL               STORE IN ALIGNED WORD
         MVC   WKAREA+2(2),SCWHOL       MOVE TO WORK AREA AS SCALING
         LA    PTR,2(PTR)               STEP WORK AREA POINTER BY 2
         OI    ORBYT,X'10'              UPDATE OR BYTE TO INDICATE
*                                       SCALING
*
PZ12     BAL   GRY,STEN                 BRANCH TO STORE ENTRY
         MVI   SCFCN,X'FF'              SET FIRST CONSTANT FLAG ON
         CLI   0(GRD),ICOMMA            TEST FOR LAST CONSTANT IN
*                                       THE OPERAND
         BE    SCANPZ                   BRANCH IF EQUAL
         MVI   PZSWH,0                  TURN OFF P-Z SWITCH
         B     TSTNBK                   BRANCH TO NEXT OPERAND
*
TRANS    TR    WKAREA(0),0(SP2)         TRANSLATE INSTRUCTION TO TRANS-
*                                       LATE NAME FOR SYMBOL TABLE
*                                       SYMBOL MOVE.
MVNAM    MVC   WKAREA(0),TXNAME(GRA)    MOVE INSTRUCTION EXECUTED ABOVE
*                                       TO MOVE NAME TO WORK AREA
ORBOR    OI    ORBYT,X'00'              OR INSTR TO OR LENGTH SYMBOL
*                                       LENGTH INTO OR BYTE
*
MOVEN    MVC   0(0,GRX),0(GR8)          MOVE INSTR. EXECUTED ELSE WHERE
DBLWD    DC    D'0'                     TEMPORARY STORAGE AREA
STSAV    DC    F'0'                     RETURN ADDRESS SAVE AREA
PZLOC    DC    F'0'                     LOCATION COUNTER SAVE AREA
SVOBN    DC    12F'0'
SAVMWD   DC    4F'0'                    SAVE AREA FOR GRA THROUGH GRD
REMSV    DC    F'0'                     STORE REMNDER FROM LAST OPERAND
STEPER   DC    F'0'
ONE      DC    F'1'                     CONSTANT OF 'ONE'
NOLEFT   DC    F'56'                    NUMBER OF TEXT BYTES LEFT
SAVWD    DC    F'0'                     WORK AREA
LNGCTR   DC    F'0'
BITREM   DC    F'0'
LOCCTR   DC    F'0'                     LOCATION COUNTER
SCTTL    DC    H'0'                     SCAN COUNTER
SCWHOL   DC    H'0'                     WHOLE ZERO COUNTER
PLENG    DC    H'0'                     OPERAND LENGTH COUNTER
BLDATA   DC    X'0'                     SWITCH
STPFLG   DC    X'0'                     SWITCH
TTN      DC    X'00'                    OUTPUT BUFFER AREA
         DC    X'02'
         DC    C'SYM'
         DC    6C' '
NCL      DC    X'0038'
         DC    4C' '
         DC    56C' '
TTLSEQ   DC    8C' '                    OUTPUT BUFFER TITLE AREA
ORBYT    DC    X'00'                    OP CODE INDICATOR BYTE
ADDRES   DC    3X'00'                   WORK AREA--ADDRESS STORAGE
WKAREA   DC    16C' '                   WORK AREA FOR TRANSLATE
FPSWH    DC    X'00'                    FIRST PASS SWITCH
FOPN     DC    X'00'                    WORK AREA POINTER SWITCH
PZSWH    DC    X'00'                    P-Z SWITCH
BCXIND   DC    X'00'                    BCX CODE FLAG
PZLEN    DC    X'00'
NLF      DC    X'00'                    CHARACTERS LEFT FLAG
BLANK    DC    X'40'
SCFCN    DC    X'00'                    FIRST CONSTANT FLAG
TBLHEX   DC    X'00'                    TRANSLATE TABLE
         DC    X'04'
         DC    X'08'
         DC    X'30'
         DC    X'34'
         DC    X'1C'
         DC    X'18'
         DC    X'10'
         DC    X'14'
         DC    X'20'
         DC    X'24'
         DC    X'2C'
         DC    X'28'
         DC    X'20'
         DC    X'38'                    GARBAGE BYTE FOR L'CONS
TEBFR    EQU   TTN
PTR      EQU   GRZ
         LTORG
         END   ASMGF7N
./ ADD NAME=ASMGF7S
F7S      TITLE     'ASMG F7  SYMBOL TABLE PROCESSOR'
         ISEQ  73,78
ASMGF7S  START
         PRINT        NOGEN
         FDIMEN
         PRINT      GEN
         SPACE 2
*                                                                     *
*TITLE 'ASMGF7S ' ...  SYMBOL TABLE PROCESSOR                         *
*FUNCTION/OPERATION-                                                  *
*  ASMGF7S IS TO MAINTAIN THE SYMBOL TABLE. IT PUTS SYMBOLS INTO THE  *
*   TABLE, RETRIEVES SYMBOLS FROM THE TABLE, AND TESTS IF ROOM EXISTS *
*   FOR ANOTHER SYMBOL. BOTH THE SYMBOL TABLE AND EXTERNAL SYMBOL     *
*   DICTIONARY (ESD) AND LBT/LAT SHARE THE SAME AREA OF STORAGE.      *
*   CROSS REFERENCES TYPE 1 (BASE) , TYPE 2 (REFERENCE) AND TYPE 3    *
*   (DUPLICATE DEFN) ARE MADE.                                        *
*ENTRY POINTS-                                                        *
*   NAME   EXT NAME      FUNCTION                                     *
*   STGETR CSTGET(ACT)   GETS AN ITEM FROM THE SYMBOL TABLE           *
*   STPUTR CSTOUT(ACT)   PUTS AN ITEM INTO THE SYMBOL TABLE           *
*   STREFR CSTREF(ACT)   OUTPUTS CROSS REFERENCE TYPE 2 RECORDS       *
*                      INPUT PARAMETERS FOR STGETR,STREFR & STPUTR ARE*
*                             SP1- POINTS TO THE SYMBOL               *
*                             SP2- CONTAINS ZERO OR LENGTH OF SYMBOL  *
*                             SRB- CONTAINS BASE/ENTRY                *
*                             SRR- CONTAINS RETURN ADDRESS            *
*   STROOM CSTROM(ACT)   SEES IF ROOM LEFT IN SYMBOL TABLE            *
*                             SP1- NO. OF BYTES WANTED IN SYMBOL TABLE*
*                             SRB- CONTAINS BASE/ENTRY                *
*                             SRR- CONTAINS RETURN ADDRESS            *
*INPUT- NONE                                                          *
*OUTPUT- NONE                                                         *
*EXTERNAL ROUTINES-                                                   *
*   PUTXRF(ACT)     PUTS OUT CROSS REFERENCE                          *
*EXITS-                                                               *
*   STGETR                                                            *
*        B     0(SRR)    SP1=VALUE      SYMBOL FOUND                  *
*                        SP1=0          SYMBOL NOT FOUND              *
*                        SP2=  LENGTH OF SYMBOL - 1                   *
*   STREFR                                                            *
*        B     0(SRR)                                                 *
*   STPUTR                                                            *
*        B     0(SRR)    SP1=VALUE      SYMBOL FOUND                  *
*        B     4(SRR)    SP1=0          SYMBOL PUT IN                 *
*   STROOM                                                            *
*        B     4(SRR)    SP1=0          ENOUGH ROOM                   *
         EJECT
*NOTES-                                                               *
*   SYMBOL TABLE LAYOUT AND ASSOCIATED POINTERS-                      *
         SPACE 2
*   *  HASH     *          *                  NO SYMBOL ENTRIES     * *
*   *--POINTER--*--SYMBOL--*                  MAY BE MADE PAST      * *
*   *  TABLES   *  ENTRIES *                  THIS POINT            * *
*   *           *          *                  *                     * *
*   *-----------*----------*------//------*---*---------------------* *
*   *                      *                  *                     * *
*   *--------CFREEP--------*                  *----28---------------* *
*   *                                             BYTES             * *
*   CTSYMP                                                     CESIOB *
*                                                                     *
*        CTSYMP+CFREEP =                                              *
*          START OF NEXT SYMBOL ENTRY                                 *
*                                                                     *
*        THE FIRST FOUR ENTRIES IN                                    *
*        THE HASH TABLE ARE FOR                                       *
*        DC ENTRIES                                                   *
*        THE FIFTH ITEM IS FOR OPSYN                                  *
         EJECT
*                THE SYMBOL TABLE IS A SERIES OF ITEMS OF THE
*              FORM DESCRIBED BELOW.  THESE ARE ACCESSED BY MEANS
*              OF A HASH TABLE OF 3-BYTE ADDRESS POINTERS.  ITEMS
*              WITH THE SAME HASH VALUE ARE CONNECTED BY BACKWARD
*              CHAINING.  THUS THE FIRST SYNONYM ENTERED HAS NO
*              CHAIN POINTER,THE SECOND POINTS TO IT,AND SO ON
*              UNTIL THE LAST OR MOST RECENT,TO WHICH THE HASH
*              TABLE ADDRESS POINTS.
 SPACE 3
*                   SYMBOL TABLE ITEM FORMAT
 SPACE
*       ***************************************************************
*       *                                   .                         *
*       *            SQUISHED   SYMBOL      .  ATTRIBUTES (SEE BELOW) *
*       *                                   .                         *
*       ***************************************************************
*
* LENGTH              6 BYTES                             11 BYTES
 SPACE 2
*                     ATTRIBUTE FIELD FORMAT
 SPACE
*       ***************************************************************
*       *        .                .        .        .        .        *
*       * ESD NO . ADJECTIVE CODE . ESD ID .  VALUE . LENGTH . CHAIN  *
*       *        .                .        .        .        .        *
*       ***************************************************************
*
* LENGTH= 9 BITS .      7 BITS    . 1 BYTE ,3 BYTES ,2 BYTES ,3 BYTES
 SPACE
* ESD NO       USED FOR POINTING TO ESD ITEM
* ESD ID       USED TO IDENTIFY CONTROL SECTION
* VALUE        ADDRESS RELATIVE TO CONTROL SECTION.
* LENGTH       LENGTH ATTRIBUTE OF SYMBOL.MINUS ONE.
*                        VALUE AND LENGTH VALID ONLY FOR NAME ITEMS
* CHAIN        POINTER TO PREVIOUS ITEM  WITH GIVEN HASH
*                        CHAIN = 0 MEANS END OF CHAIN
* ADJECTIVE CODE - BITS.  MASK , MEANING
*                   1    X'40'    SYMBOL IN ENTRY EQU-D TO EXT SYMBOL
*                   2    X'20'    SYMBOL REFERENCED BUT NOT YET DEFINED
*                   3    X'10'   'ENTRY'ITEM COMPLETED (INTERLUDE)
*                   4    X'08'   'ENTRY'ITEM COMPLETED (PHASES 7,8)
*                   5    X'04'    DEFINED IN DSECT,COM OR DXD
*                  6,7   X'03'   * 00 - CSECT OR START
*                                * 01 - EXTRN
*                                * 10 - DSECT OR DXD
*                                * 11 - NAME ITEM
*
 EJECT
         ENTRY STGETR         GETS AN ITEM FROM THE SYMBOL TABLE
         ENTRY STPUTR         PUTS AN ITEM INTO THE SYMBOL TABLE
         ENTRY STROOM         CONTROLS END OF SYMBOL TABLE STORAGE
         ENTRY     STREFR              OUTPUTS REF RECORDS
         ENTRY     STSHLEN   LENGTH OF SHRINK REQUEST WHEN SYM TAB FULL
         EXTRN     F7ABEND             ABEND ROUTINE IN ASMGFI
         SPACE 3
FR0      EQU       0                   FLOATING REGISTER 0
*        *     SYMBOLIC DISPLACEMENTS
*
UNDEF    EQU       32                  UNDEFINED ENTRY
LASH     EQU       31                  LTH OF LITERAL HASH (28) + OPSYN
ISYM     EQU       0                               Y+0
ADJ      EQU       7                               Y+7
IEPTR    EQU       6                               Y+6
IESDID   EQU       8                              Y+8
IVALUE   EQU       9                              Y+9
ILENGT   EQU       12                             Y+12
ICHAIN   EQU       14                             Y+14
 EJECT
         USING *,SRB
STREFR   MVI   FLAGS,REFSW              SET IN REF MODE
         BAL   SRB,STGETR+8             SET UP BASE
 SPACE
         USING *,SRB
STGETR   MVI   FLAGS,GETSW              SET IN GET MODE
         MVI       SETLEN+3,0          IN CASE NOT SYMBOL
         BAL   SRB,STPUTR+4             SET UP BASE
 SPACE
         USING *,SRB
STPUTR   MVI   FLAGS,PUTSW             SET IN PUT MODE
         LTR   SP2,SP2                  IF PARAMETER SP2 WAS GIVEN,
         BP    KNOWN LENGTH SYMBOL.     BRANCH IF LENGTH IS KNOWN
         CLI   0(SP1),IALPHA            IS FIRST CHAR A SYMBOL
         BH    GETOUT                   NO, RETURN NOT FOUND
 SPACE
         LR    SP2,SP1                  SP2 = BEGINNING OF SYMBOL
SCAN     LA    SP2,1(SP2)               SET AT NEXT CHAR
         CLI   0(SP2),IALPHA            IS THIS CHAR PART OF SYMBOL
         BNH   SCAN                     YES, LOOP
 SPACE
         SR    SP2,SP1                  =LENGTH OF SYMBOL
KNOWN    C         SP2,=F'8'           TEST IF LENGTH GREATER THAN 8
         BCTR  SP2,0                    REDUCE BY ONE FOR MOVE
         STC       SP2,SETLEN+3        SET LENGTH FOR GET EXIT
         BH      GETOUT                 SET 'NOT FOUND' AND EXIT.
 SPACE
         STC       SP2,MOVSYM+1        PUT LENGTH-1 IN MOVE INST
         STC       SP2,TRSYM+1           AND IN TRANSLATE INST
         SDR       FR0,FR0             CLEAR WORK BENCH
         STD       FR0,BENCH
MOVSYM   MVC       BENCH(*-*),0(SP1)   MOVE SYMBOL TO BENCH
TRSYM    TR        BENCH(*-*),CODE2    TRANSLATE TO 2ND INTERNAL CODE
         L         SP1,BENCH+4         PACK THE SYMBOL TO 6 BYTES
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         ST        SP2,BENCH+4
         L         SP1,BENCH
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6+8
         ST        SP2,BENCH
 SPACE
         X            SP2,BENCH+4      FOLD SYMBOL INTO FULLWORD.
         SR      SP1,SP1                CLEAR 4 BYTES OF DIVIDEND.
         D       SP1,CPRIME(0,ACT)      PRIME IS HASH DIMENSION.
         LA     SP2,0(SP1,SP1)          MULTIPLY BY
         AR     SP2,SP1                 THREE BYTES/POINTER.
         L      SP1,CTSYMP(0,ACT)       FIND SYMBOL TABLE BASE
         LA     SP2,LASH-ICHAIN(SP2,SP1) LASH = LENGTH OF LITERAL HASH.
         ST     SP2,SAVER               SAVE HASH TABLE ENTRY
         MVC    SETADJ+1(1),ADJCOD(ACT) INITIALIZE ADJ SET INST
         MVI       SKNAME+1,X'00'       INITIALIZE BRANCH SWITCH
 SPACE
FOLLOW   MVC   F0XXX+1(3),ICHAIN(SP2)   POINTER TO BOUNDARY
         L     SP2,F0XXX                POINTER TO REGISTER
         LTR   SP2,SP2                  IF POINTER IS ZERO,NO SYNONYMS.
         BZ    NOFIND
 SPACE
         CLC       BENCH+1(6),ISYM(SP2) COMPARE SYMBOLS.
         BNE       FOLLOW              IF SYMBOLS ARE NOT EQUAL
 EJECT
DUPCHK   CLI   FLAGS,REFSW              ARE WE IN REF MODE
         BE        REFOUT               YES, CREATE REF RECORD
         TM        ADJ(SP2),UNDEF      TEST IF THIS SYMBOL NOT DEF YET
         BNO       FOUND               IF DEFINED THEN FOUND
         CLI       FLAGS,PUTSW         IS THIS DEF FOR PREVIOUS UNDEF
         BNE       GETOUT              IF NOT EXIT FOR UNSUCCESSFUL GET
         MVI       SKNAME+1,X'F0'      ALTER UNDEF ENTRY TO DEF
         TM        CTXRFI(ACT),X'02'   TEST FOR XREF
         BZ        SETENTRY
         S         SP2,=F'2'           SET DEFN LINE NUMBER
         MVC       0(2,SP2),CTSEQN+2(ACT)
         LA        SP2,2(0,SP2)
         B         SETENTRY
 SPACE
FOUND    CLI       FLAGS,GETSW         TEST FOR SUCCESSFUL GET
         BE        FOUNDGO
         ST        SRR,SAVE3           DUPLICATE PUT. CREATE NEW DEFN
         MVC       SAVER+1(3),DUMMY    NEW DEFN IS NOT CHAINED TO HASH
         BAL       SRR,CRENTRY         GO CREATE ENTRY
         DS        2H
         L         SRR,SAVE3           RESTORE REGS
         B         FOUNDGO             EXIT POINTING TO DUP DEFN
 SPACE
GETOUT   L         SP2,=F'-6'          FORCE SP1=0
FOUNDGO  LA        SP1,6(0,SP2)        SET SP1 PAST SYMBOL NAME
SETLEN   LA        SP2,*-*             SET SP2 TO LENGTH OF SYMBOL - 1
         BR        SRR                 RETURN
 SPACE
NOFIND   CLI       FLAGS,REFSW         TEST FOR REF TO UNKNOWN SYMBOL
         BNE       NOFIND2
         MVI       SETADJ+1,UNDEF      CREATE AN UNDEFINED ENTRY
         ST        SRR,SAVE3
         BAL       SRR,CRENTRY         GO AND CREATE THE ENTRY
         DS        2H
         L         SRR,SAVE3           RESTORE RETURN REG
 SPACE
REFOUT   S         SP2,=F'4'           POINT AT REF COUNT FIELD
         LH        SP1,0(0,SP2)        INCREMENT IT BY 1
         LA        SP1,1(0,SP1)
         STH       SP1,0(0,SP2)
         ST        SRR,SAVESR
         L         SRB,CTXTIO(0,ACT)   GO TO XREF WRITTING ROUTINE F7I
         DROP      SRB
         BAL       SRR,PUTXRF(0,SRB)
         USING     *,SRR
         MVC       0(6,SP1),BENCH+1    PLACE NAME IN XREF ENTRY
         MVC       6(2,SP1),CTSEQN+2(ACT) AND PRESENT LINE NUMBER
         L         SRR,SAVESR          RESTORE RET REG
         DROP      SRR
         BR        SRR                 RETURN
 SPACE
         USING     STPUTR,SRB
NOFIND2  CLI       FLAGS,GETSW         TEST IF GET OF UNKNOWN SYMBOL
         BE        GETOUT              EXIT UNSUCCESSFULLY IF SO
 EJECT
CRENTRY  L     SP2,CFREEP(0,ACT)        GET FREE STORAGE POINTER.
         AR    SP2,SP1                  GET ACTUAL CORE LOCATION
         TM        CTXRFI(ACT),X'02'   TEST FOR XREF
         BNO       NOXREF
         L         SP1,CHAINPT(0,ACT)  POINT AT LAST ENTRY PLACED
         MVC       MVI+1(1),0(SP1)     SAVE OVERLAPED TOP BYTE
         LA        SP2,2(0,SP2)        F ALIGN THE NEW ENTRY
         N         SP2,=F'-4'           (MAY OVERLAP LAST ENTRY BY 1)
         ST        SP2,0(0,SP1)        FOREWARD CHAIN ALL ENTRIES
         ST        SP2,CHAINPT(0,ACT)
MVI      MVI       0(SP1),*-*          RESTORE OVERLAPED TOP BYTE
         L         SP1,CTSEQN(0,ACT)   SET NO. REFS = 0 AND
         ST        SP1,4(0,SP2)         DEFN LINE NUMBER
         LA        SP2,8(0,SP2)        POINT PAST XREF PREFIX
NOXREF   MVC       ISYM(6,SP2),BENCH+1  MOVE SYMBOL
 SPACE
SETENTRY LH    SP1,CESDNO(ACT)          ESD ITEM POINTER
         SLL   SP1,7
         ST        SP1,SAVESR
SETADJ   OI        SAVESR+3,*-*        SET ADJ BITS
         TM        CTEXENSW(ACT),X'04' IS OPERAND CONT EXTERN SYMBOL
         BZ        SETADJ1             NO
         OI        SAVESR+3,X'40'      YES, SET SWITCH TO TELL ENTRY
         NI        CTEXENSW(ACT),X'FB' RESET SWITCH IN ACT
SETADJ1  MVC   IEPTR(2,SP2),SAVESR+2   PUT ESD NO AND ADJ IN ENTRY
         MVC   IESDID(1,SP2),ESDID(ACT) ESD-ID TO TABLE ITEM.
         MVC   IVALUE(3,SP2),STVALU+1(ACT) MEANINGFUL ONLY
         MVC   ILENGT(2,SP2),STLONG(ACT) IN NAME ITEMS.
SKNAME   BC        *-*,STNX            BRANCH IF DEFN OF PREVIOUS UNDEF
         L     SP1,SAVER                FIND HASH POINTER.
         MVC       ICHAIN(3,SP2),ICHAIN(SP1) BACKWARD CHAIN TO HASH
         ST        SP2,SAVER
         MVC       ICHAIN(3,SP1),SAVER+1
 SPACE
         LA        SP1,ICHAIN+3(0,SP2) POINT PAST NEW ENTRY
         S         SP1,CTSYMP(0,ACT)   CALCULATE NEW CFREEP
         ST        SP1,CFREEP(0,ACT)
         SR    SP1,SP1                  NO BYTES REQUIRED FOR ROOM
         BALR  SRB,0                    RESET BASE AND CHECK FOR ROOM
 EJECT
*                STROOM IS CALLED WHEN SYMBOL TABLE SPACE IS
*              NEEDED.  THE NUMBER OF BYTES REQUIRED IS PUT
*              IN SP1 BY THE CALLER.
*                         IF USE OF THE REQUESTED SPACE WILL
*              LEAVE INSUFFICIENT SPACE FOR THE LARGEST
*              POSSIBLE SYMBOL TABLE ITEM THEN A SHRINK IS
*              DONE.  IF THE SHRINK IS UNSUCCESSFULL THE
*              THE ASSEMBLY IS ABENDED.
         SPACE 2
         USING *,SRB
STROOM   L       SRB,=A(STPUTR)        SET UP NORMAL BASE
         USING     STPUTR,SRB
         A     SP1,CTSYMP(ACT)
         A     SP1,CFREEP(ACT)          SET SP1 = LAST OF ST + MAX SYMB
         LA    SP1,MAXSYM(0,SP1)          + REQUESTED BYTES = NEW POS
         C         SP1,CESIOB(0,ACT)    COMPARE
         BNH   STNX                     BRANCH, ENOUGH ROOM
 SPACE
         L         SP1,CESIOB(0,ACT)   RESET TOP OF CORE
         A         SP1,STSHLEN
         ST        SP1,CESIOB(0,ACT)
         STM       GR0,GR1,SAVESR      SAVE R0 AND R1
         L         GR1,BUFFPT(0,ACT)   ISSUE A SHRINK CALL
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(36)               CODE FOR SHRINK
STSHLEN  DC        A(*-*)              LENGTH SET BY ASMGF7I
SHANS    DS        F
         LM        GR0,GR1,SAVESR      UNSAVE REGISTERS
         CLI       SHANS,X'FF'         TEST FOR NO MO CORE
         BNE       STNX
         L         FRB,=A(F7ABEND)     KILL THE JOB
         BR        FRB
         DROP      SRB
 SPACE
STNX     SR    SP1,SP1                  YES
         B     4(SRR)                   NORMAL EXIT
         EJECT
MAXSYM   EQU       28                   MAXIMUM SYMBOL LENGTH
 SPACE
SAVESR   DS        F                    SUBROUTINE REGISTER SAVE AREA
SAVER    DS        F                    SAVE AREA FOR SRR
SAVE3    DS        F
 SPACE
BENCH    DS    D
F0XXX    DC        F'0'
DUMMY    DC        AL3(SAVER-ICHAIN)   CAUSE SAVER TO CHAIN TO ITSELF
         LTORG
 SPACE
*                  THIS CODE HAS THE FOLLOWING PROPERTIES.
*                  1. IT ONLY USES THE BOTTOM 6 BITS OF EACH BYTE
*                  2. IT HAS THE SAME COLLATING SEQUENCE AS EBCDIC
CODE2    DC        X'30313233343536373839'       NUMBERS
         DC        X'101112131415161718191A1B1C' LETTERS
         DC        X'1D1E1F20212223242526272829' LETTERS
         DC        X'0A0B0C'                     FUNNY LETTERS $ # @
         DC        X'000000000000000000000000'   BLANK
 SPACE
FLAGS    DC    X'00'                    FLAG FOR FOLLOWIN INDICATORS
GETSW    EQU   X'0F'                         GET MODE
REFSW    EQU   X'F0'                         REF MODE
PUTSW    EQU   X'00'                         PUT MODE
         END   STGETR
./ ADD NAME=ASMGF7V
F7V      TITLE     'ASMG F7  EVALUATION ROUTINE'
         ISEQ  73,78
ASMGF7V  START
EEVAL    EQU   ASMGF7V
         PRINT     NOGEN
         FDIMEN
         PRINT     GEN
* SP1 AT ENTRY CONTAINS A POINTER TO THE FIRST CHARACTER OF THE
* EXPRESSION TO BE EVALUATED.
* SP1 AT EXIT CONTAINS A POINTER TO THE CHARACTER FOLLOWING THE
* EXPRESSION WHICH CAUSED EEVAL TO TERMINATE.
* THE TERMINATING CHARACTER WILL ALWAYS BE A LEFT OR RIGHT PARENTHESIS
* OR A BLANK OR A COMMA, UNLESS THERE WAS A SYNTACTICAL ERROR.
* SP1 WILL CONTAIN ZERO IF A SYNTACTICAL ERROR IN THE EXPRESSION WAS
* FOUND.
*
*
* BIT 0 OF CTSDVI(ACT) IS USED AS AN INPUT PARAMETER TO EEVAL.
*  IF THIS BIT IS 0, THERE IS NO EFFECT ON EEVAL.  HOWEVER, IF THIS
*  BIT IS 1, AND THE FIRST (OR ONLY) TERM IN THE EXPRESSION IS A SELF-
*  DEFINING VALUE,THE BIT IS THEN SET BACK TO 0, THE VALUE OF THE SELF-
*  DEFINING VALUE IS PLACED IN SP2, THE CONDITION CODE IS SET TO 0, AND
*  EEVAL EXITS TO THE CALLING ROUTINE.
*
*
* BIT 2 OF CTSDVI(ACT) IS ALSO USED AS AN INPUT PARAMETER TO EEVAL;
* THIS BIT(CTPDSI) IS USED AS A SWITCH TO INDICATE A PREVIOUSLY
* DEFINED SYMBOL ERROR.
*
* SP2 AT EXIT CONTAINS THE RESULT, IF THE EXPRESSION WAS ABSOLUTE.
* SP2 AT EXIT CONTAINS A POINTER TO THE RESULTS, IF THE EXPRESSION WAS
* RELOCATABLE, AS FOLLOWS.
* ONE FULL-WORD CONTAINING THE VALUE OF THE EXPRESSION, FOLLOWED BY
* 25 HALF-WORDS,ONE FOR EACH POSSIBLE TERM IN AN EXPRESSION, WITH THE
*               FOLLOWING MEANING.
*               BOTH BYTES ZERO INDICATES AN ABSOLUTE TERM OR A
*               PAIRED RELOCATABLE TERM.  OTHERWISE, THE FIRST BYTE
*               INDICATES THE SIGN OF THE RELOCATABLE TERM (1 FOR +,
*               AND 2 FOR -), AND THE SECOND BYTE CONTAINS ITS
*               ESD-ID.
* A SIMPLY RELOCATABLE EXPRESSION WILL HAVE A + SIGN AND THE ESD-ID
*               OF ITS UNPAIRED POSITIVE TERM IN THE FIRST HALF-WORD.
*               THE REMAINING HALF-WORDS WILL CONTAIN ZEROS.
* A COMPLEXLY RELOCATABLE EXPRESSION WILL HAVE A NON-ZERO HALF-WORD
*               FOR EACH UNPAIRED RELATIVE TERM. IN GENERAL, THE
*               NON-ZERO HALF-WORDS WILL BE SCATTERED IN THIS LIST,
*               NECESSITATING A SCAN FOR NON-ZERO HALF-WORDS WHEN
*               THE EXPRESSION IS COMPLEXLY RELOCATABLE.
*
* THE RESULT WILL ALWAYS BE A 3-BYTE VALUE (1ST BYTE ZERO) UNLESS
* F8YDC(ACT) IS SET, IN WHICH CASE, THE RESULT WILL BE 4 BYTES
*
* UPON EXIT FROM EEVAL, THE CONDITION CODE HAS THE FOLLOWING MEANING.
*               ABSOLUTE EXPRESSION                 CC = 0
*               SIMPLY RELOCATABLE EXPRESSION       CC = 1
*               COMPLEXLY RELOCATABLE EXPRESSION    CC = 2
*               EVALUATION IMPOSSIBLE (ERROR)       CC = 3
*
*
* THE FOLLOWING ERRORS ARE LOGGED.
*                   RELOCATABILITY ERROR
*                   SELF-DEFINING VALUE TOO LARGE
*                   ARITHMETIC ERROR
*                   SYMBOL NOT PREVIOUSLY DEFINED
*                   TWO TERMS NOT SEPARATE
*                   ILLEGAL CHARACTER
*                   TOO MANY TERMS
*                   TWO OPERATORS ILLEGALLY COUPLED
*                   TOO MANY LEVELS OF PARENS
*                   EXPRESSION END PREMATURE
*                   INVALID SYMBOL
*               EXP. VALUE EXCEEDS RANGE
* THE ERRORS ARE LOGGED IN ALL CASES.
*
* NORMAL PROCESSING IS CONTINUED AFTER LOGGING
* EXP. VALUE EXCEEDS RANGE, EYMBOL-
* NOT-PREVIOUSLY DEFINED,ARITHMETIC,RELOCATABILITY,OR SELF-DEFINING-
* VALUE-TOO-LARGE ERRORS. FOR THESE ERRORS,SP1 WILL POINT TO THE
* TERMINATING CHARACTER,SP2 WILL BE ZERO,AND THE CONDITION CODE WILL BE
* 3 UPON EXIT FROM EVAL.
*
* THE OTHER ERRORS CAUSE IMMEDIATE EXIT FROM EEVAL WITH SP1 AND SP2 SET
* TO ZERO,AND THE CONDITION CODE 3.
* THE CONDITION CODE WILL NOT BE 3 FOR EXP. VALUE EXCEEDS RANGE
*
*  SYMBOLS ARE FIRST LOOKED FOR IN THE WORK BUCKETS, AND IF NOT THERE,
*  THEN IN THE SYMBOL TABLE.
*
*
* TYPE 1 CROSS REFERENCES ARE MADE FOR EACH SYMBOL
*
*
*  THE LENGTH ATTRIBUTE OF THE FIRST TERM IN THE EXPRESSION IS PLACED
*  IN STLONG(ACT).
*
*
* IF THERE WAS REFERENCE TO THE LOCATION COUNTER (I.E. AN ASTERISK) IN
*  THE EXPRESSION, BIT 1 IN CTLRCI(ACT) IS SET TO 1.  IF NOT, THIS
*  BIT IS SET TO 0.
*
*
*  GRD USED FOR BASE OF TERMS WORK AREA
*  GRX USED FOR POINTER TO TERMS LIST
*  GRY USED FOR POINTER TO OPRNS LIST
*  GRZ USED FOR POINTER TO NTRMS LIST
*  GR2 USED FOR POINTER TO RLIST LIST
* GR0,GR1,GRA, AND GRB USED AS WORK REGISTERS
         EJECT
         USING *,SRB                    USING SRB
*
*  INITIALIZE
*
         STM   GRA,GRD,REGSAV           SAVE SOME VOLATILE REGS
         L     GRD,CTFVEVAL(,ACT)       GET ADDR OF TERMS WORK AREA
         USING TERMSWK,GRD              AND SET THE BASE
         SR    GR0,GR0                  ZERO A WORK REGISTER
         STH   GR0,STLONG(,ACT)         ZERO TO STLONG(ACT)
         MVI   TERMS,X'00'              ZERO TO TERMS
         MVC   TERMS+1(TERMSLEN-1),TERMS  ZERO ALL OF TERM WORK AREA
         NI    CTLCRI(ACT),X'BF'        SET BIT FOR LOC. CNTR. REF. OFF
         LA    GRZ,NTRMS                GET ADDRESS OF NTRMS
         LA    GRX,TERMS                GET ADDRESS OF TERMS
         LA    GRY,OPRNS                GET ADDRESS OF OPRNS
         LA    GR2,RLIST                GET ADDRESS OF RLIST
         ST    SP1,FTXPPT              SAV PT TO FIRST BYTE OF EXP
*
*  SCAN OF THE EXPRESSION FOR TERMS OR OPERATORS
*
LOOK     CLI   0(SP1),IALPHA            IS CHAR. ALPHANUMERIC
         BH    NOTAM
         ST    SP1,ERRPT               SAV PT TO FIRST BYTE OF TERM
         STM   GRZ,GRY,SAVE             SAVE 3 WORK REGISTERS
         CLI   0(SP1),IA                IS CHAR. A NUMBER
         BL    DEC
         CLI   1(SP1),IQUOTE            IS NEXT CHAR. A QUOTE
         BE    NEXTQ
*
*  SYMBOL IN THE EXPRESSION
*
SYM      DS    0H
         CLI   COND,CONDE               TWO TERMS IN A ROW .Q
         BNL   ERR10                    ERROR IF YES
         SR    GR0,GR0
         ST    GR0,0(GRX)               ZERO TO TERMS LIST
         CLI   LREF,0                  IS L'SYMBOL
         BE    TRYSWB                  NO
         CLI   0(SP1),IMULT            IS L'*
         BNE   TRYSWB                  NO
         MVI   3(GRX),1                1 TO TERMS LIST
         MVI   LREF,0                  CLEAR LREF
         MVN   LREF(1),F8INST+15(ACT)  MOVE IN LENGTH ATTRIBUTE
         CLI   LREF,2
         BL    ATTR1                   0,1 = VALUE OF 1
         CLI   LREF,8
         BH    ATTR1                   GTR 8 = VALUE OF 1
         MVC   3(1,GRX),LREF           PUT L'* VALUE IN TERMS LIST
ATTR1    LA    SP1,1(SP1)              POSITION SP1 TO CHAR. AFTER *
         B     LSTAR
*
*  LOOK FOR SYMBOL VALUE IN WORK BUCKET
*
*
* CTXWBP(ACT), FULL WORD ALIGNED, POINTS TO 'NEXT' SYMBOL WORK BUCKET.
* WHEN ZERO, THERE IS NO 'NEXT' SYMBOL WORK BUCKET.
*
TRYSWB   L     SP2,CTXWBP(ACT)         POINTER TO NEXT SYM. WK-BUCKET
         LTR   SP2,SP2                  IS THERE A NEXT SYM. WK-BUCKET
         BZ    TRYST
         LR    GR1,SP2
         LA    GR1,6(GR1)               BUMP POINTER TO SYM. WK-BUCKET
         ST    GR1,CTXWBP(ACT)                    BY 6
         TM    TXSUBS(SP2),X'10'        IS VALUE IN WORK-BUCKET
         BO    WBFND
*
*  LOOK FOR SYMBOL VALUE IN SYMBOL TABLE
*
TRYST    STM   SRB,SP2,NCOMP
         SR    SP2,SP2                  SET LENGTH UNKNOWN
         L     SRB,CSTGET(ACT)
         BALR  SRR,SRB                  TO STGET ROUTINE
         DROP  SRB
         USING *,SRR
         LTR   GR1,SP1                  POINTER TO GR1 AND TEST
         LR    GR0,SP2                  LENGTH OF SYMBOL TO GR0
         LM    SRB,SP2,NCOMP
         DROP  SRR
         USING EEVAL,SRB
         BC    7,FOUND                  HAS SYMBOL BEEN FOUND
*
*  SYMBOL NOT FOUND IN EITHER A WORK BUCKET OR THE SYMBOL TABLE
*
         MVI   TERMS,0
         MVC   TERMS+1(RCNTR-TERMS),TERMS  ZERO TERMS, RLIST AND RCNTR
         LA    GR1,X'08'
         CLR   GR0,GR1                  TEST SYMBOL LENGTH
         BNL   ERR3                     MORE THAN 8 CHARACTERS
         STM   SRB,GR2,NCOMP            1-8 CHARACTERS IN SYM, SAVE REC
         LR    FRB,GR0
         BAL   GR2,XREF                 LOG CROSS-REF
         LM    FRB,GR2,NCOMP+16        RESTORE REGS
         B     ERR15                    SYMBOL NOT FOUND
SCANE    LA    SP1,1(SP1)               SCAN TO END OF SYMBOL
COND3    EQU   SCANE
         CLI   0(SP1),IPLUS
         BL    SCANE
         B     COMPT4
*
*  SYMBOL VALUE FOUND IN SYMBOL TABLE
*
FOUND    STM   SRB,GR2,NCOMP            SAVE REGS
         LR    FRB,GR0
         BAL   GR2,XREF                 LOG CROSS-REF.
         LM    FRB,GR2,NCOMP+16        RESTORE REGS
         AR    SP1,GR0                  ADD SYMBOL LENGTH TO POINTER
         LA    SP1,1(SP1)
         CLI   LREF,0                   IS L'SYMBOL
         BH    LSYM
         TM    1(GR1),3                 IS THIS A NAME
         BC    14,ESDMV                NO
         CLI   SYMBL,0                  IS THIS THE FIRST TERM
         BH    MOVE
         MVC   STLONG(2,ACT),6(GR1)     LENGTH TO STLONG
MOVE     MVC   1(3,GRX),3(GR1)          VALUE TO TERMS LIST
         CLI   2(GR1),0                 IS ABSOLUTE TERM
         BE    COMPT4
ESDMV    TM    1(GR1),X'03'             IS SYMBOL EXTERNAL .Q
         BNM   ESDMV1                   BRANCH IF NOT MIXED
         OI    CTEXENSW(ACT),X'04'      SET SWITCH TO TELL ENTRY
ESDMV1   MVC   1(1,GR2),2(GR1)          ESD-ID TO RLIST
*
OUT      DS    0H
         MVI   COND,CONDF               SET RELOCATABLE TERM
         MVI   0(GR2),1                 CODE FOR + SIGN = 1 TO RLIST
         IC    GR1,RCNTR                BUMP RCNTR BY 1 (RELOCATABLE)
         LA    GR1,1(GR1)
         STC   GR1,RCNTR
         B     COMPT
*
*  SYMBOL VALUE FOUND IN WORK BUCKET
*
WBFND    SR    GRA,GRA
         STM   SRB,GR2,NCOMP           SAVE REGS
WBFNDX   LA    SP1,1(SP1)               SCAN TO END OF SYMBOL
         LA    GRA,1(GRA)              CNTR FOR LENGTH OF SYM MINUS 1
         CLI   0(SP1),IPLUS
         BL    WBFNDX
         BCTR    GRA,0                 DECREMENT SYMBOL LENGTH BY 1
         ST    SP1,REGSAV1             SAVE PTR TO END OF SYMBOL
         LR    FRB,GRA
         BAL   GR2,XREF                 LOG CROSS-REF
         L     SP1,REGSAV1             RESTORE PTR TO END OF SYMBOL
         LM    FRB,GR2,NCOMP+16        RESTORE REGS
         CLI   LREF,0                   IS L'SYMBOL
         BH    LSYMWB
         TM    TXSTPC(SP2),X'03'       IS THIS A NAME
         BC    14,WBESDMV              NO
         CLI   SYMBL,0                  IS THIS THE FIRST TERM
         BH    WBFNDY
         MVC   STLONG+1(1,ACT),TXSLEN(SP2)
         TM    TXSEXI(SP2),X'04'        IS LENGTH GR THAN 256
         BZ    WBFNDY
         MVI   STLONG(ACT),255          SET FIRST BYTE OF STLONG =255
WBFNDY   MVC   1(3,GRX),TXSVAL(SP2)     VALUE TO TERMS LIST
         CLI   TXSESD(SP2),0           IS ABSOLUTE TERM
         BE    COMPT4
WBESDMV  MVC   1(1,GR2),TXSESD(SP2)    ESD-ID TO RLIST
         B     OUT
*
* BUILD TYPE 2  CROSS-REFERENCE RECORD
*
XREF     TM    CTXRFI(ACT),X'02'       X-REF OPTION?
         BZ    NOXREF                  OFF
         LA        SP2,1(0,FRB)        PUT SYMBOL LENGTH IN SP2
         L     SRB,CSTREF(ACT)         OUTPUT THE REF RECORD
         BALR  SRR,SRB
         DROP  SRB
         USING *,SRR
         LM    SRB,SP2,NCOMP
*                                               GRX,GRY,GR0
         DROP  SRR
         USING EEVAL,SRB
NOXREF   LM    SRB,SP2,NCOMP
         BR    GR2
*
*  L'SYMBOL VALUE FOUND IN SYMBOL TABLE
*
LSYM     TM    1(GR1),3                 IS THIS A NAME
         BC    14,UPLSYM
MOVEL    MVC   2(2,GRX),6(GR1)          LENGTH TO TERMS LIST
         B     UPLSYM
*
*  L'SYMBOL VALUE FOUND IN WORK BUCKET
*
LSYMWB   MVC   3(1,GRX),TXSLEN(SP2)    LENGTH TO TERMS LIST
UPLSYM   L     GR1,0(GRX)
         LA    GR1,1(GR1)
         ST    GR1,0(GRX)               BUMP VALUE OF L'SYMBOL BY 1
LSTAR    MVI   LREF,0                  SET LREF TO ZERO
         B     COMPT4
*
*  DECIMAL SELF-DEFINING VALUE IN THE EXPRESSION
*
DEC      LA    SHFR,3                   DEC. TYPE INDICATOR TO SHFR
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,8                    MAX. NO. OF CHAR. TO GR0
         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS
         ST    VALR,0(GRX)              VALUE TO TERMS LIST
         CLI   0(GRX),0                 IS FIRST BYTE ZERO
         BH    ERR0
         B     ABSD
*
*  1ST CHARACTER IS ALPHABETIC AND 2ND IS A QUOTE
*
NEXTQ    CLI   0(SP1),IB                IS BINARY SELF-DEF. VALUE
         BE    BINRY
         CLI   0(SP1),IC                IS CHARACTER SELF-DEF. VALUE
         BE    CHARS
         CLI   0(SP1),IX                IS HEXADECIMAL SELF-DEF. VALUE
         BE    HEX
         CLI   0(SP1),IL                IS L'SYMBOL
         BNE   ERR9
*
*  L'SYMBOL IN THE EXPRESSION
*
         LA    SP1,2(SP1)               POINT SP1 TO 1ST CHAR. OF SYM.
         MVI   LREF,X'FF'               SET L'SYMBOL FLAG NON-ZERO
         CLI   0(SP1),IALPHA           IS CHAR. ALPHANUMERIC
         BNH   ALPHA                   YES
MAYLCNTR CLI   0(SP1),IMULT            IS CHAR. *
         BNE   ERR9                    NO
ALPHA    CLI   0(SP1),IA               IS CHAR. ALPHABETIC
         BL    ERR9                    NO
*
* IN WORK BUCKET, VALUE = LENGTH.
* IN SYMBOL TABLE, PICK UP LENGTH ATTRIBUTE PART OF SYMBOL.
*
         B     SYM
*
*  BINARY SELF-DEFINING VALUE IN THE EXPRESSION
*
BINRY    LA    SHFR,1                   BINARY TYPE INDICATOR TO SHFR
         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,24                   MAX. NO. OF CHAR. TO GR0
         B     LM
*
*  CHARACTER SELF-DEFINING VALUE IN THE EXPRESSION
*
CHARS    LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.
         LA    SHFR,8                   CHAR. TYPE INDICATOR TO SHFR
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,3                    MAX. NO. OF CHAR. TO GR0
         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS
         ST    VALR,0(GRX)              VALUE TO TERMS LIST
         L     SP2,CTRTBP(ACT)          POINTER TO TRANSLATE TABLE
         TR    0(4,GRX),0(SP2)          TRANSLATE CHAR. VALUE
         B     CKQ
*
*  HEXADECIMAL SELF-DEFINING VALUE IN THE EXPRESSION
*
HEX      LA    SHFR,4                   HEX TYPE INDICATOR TO SHFR
         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,6                    MAX. NO. OF CHAR. TO GR0
LM       LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS
         ST    VALR,0(GRX)              VALUE TO TERMS LIST
CKQ      CLI   0(SP1),IQUOTE            IS ENDING CHAR. A QUOTE
         BNE   ERR9
         LA    SP1,1(SP1)               POSITION SP1 TO CHAR. AFTER '
         LTR   CNTR,CNTR                IS CNTR ZERO
         BZ    ERR9
ABSD     CLR   CNTR,GR0                 IS CNTR GR THAN MAX.
         BH    ERR0
         CLI   COND,CONDA               IS COND UNCHANGED .Q
         BH    ABSCK
         TM    CTSDVI(ACT),X'80'        IS BIT FOR SELF-DEF. VALUE ON
         BZ    ABSCK+8
         NI    CTSDVI(ACT),X'7F'        SET THE BIT OFF
         B     FINIS
ABSCK    DS    0H
         CLI   COND,CONDE               TWO TERMS IN A ROW .Q
         BNL   ERR10                    ERROR IF YES
COMPT4   DS    0H
         MVI   COND,CONDE               SET ABSOLUTE TERM
COMPT    DS    0H
         LA    GR0,RLIST                START OF RELOC LIST
         LR    GRB,GR2                  THIS IS WHERE WE'RE AT
         SR    GRB,GR0                  THIS IS THE DIFFERENCE
         CH    GRB,CTTERMC(,ACT)        TOO MANY TERMS .Q
         LA    GRB,MNYERR               DIAGNOSTIC IF SO
         BH    FATLER1
         OI    SYMBL,1                  OR SYMBL WITH 1
         MVI   0(GRZ),2                 2 TO NTRMS LIST
         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS)
         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS)
         LA    GR2,2(GR2)               BUMP GR2 BY 2 (FOR RLIST)
         B     LOOK
*
*  1ST CHARACTER IS NOT ALPHANUMERIC
*
NOTAM    CLI   0(SP1),ICOMMA            IS CHAR. A COMMA
         BL    LTCOM
         BE    BLCOM
         CLI   0(SP1),ILPARN            IS CHAR. A LEFT PAREN.
         BE    LPAR
         BL    ERR9
         CLI   0(SP1),IQUOTE            IS CHAR. A ' OR ( OR BLANK
         BL    RPAR
         BH    BLCOM
         B     ERR9               ' IS ILLEGAL FIRST CHAR.
*
*  RIGHT PARENTHESIS IN THE EXPRESSION
*
RPAR     DS    0H
         CLI   COND,CONDE               DOES RIGHT PAREN FOLLOW TERM .Q
         BL    ERR12                    ERROR IF NOT
         MVI   COND,CONDE               SET RIGHT PAREN COND
         CLI   PCNTR,0                  IS PCNTR =0
         BH    NOEND
         B     ENDNG
*
*  1ST CHARACTER IS EITHER +,-,*, OR /.
*
LTCOM    CLI   0(SP1),IASTER            IS CHAR. AN ASTERISK
         BE    STAR
         BH    SLASH
*
*  + OR - IN THE EXPRESSION
*
PLMIN    DS    0H
         CLI   COND,CONDE               WAS LAST ENTRY A TERM .Q
         BNL   PLMIN3                   BRANCH IF YES
         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q
         BZ    ERR12                    NO UNARY +,- IF NOT
         CLI   COND,CONDA               1ST OPERATOR/TERM .Q
         BE    COMPT4                   ENTER ZERO OPERAND IF YES
         MVI   COND,CONDC               UNARY OPERATOR
PLMIN2   DS    0H
         LA    GR0,IALPHA-2             BUMP OPERATOR BY TWO
         B     SET1                     AND ENTER SAME
PLMIN3   DS    0H
         MVI   COND,CONDB               BINARY + OR -
SET      DS    0H
         LA    GR0,IALPHA
SET1     DS    0H
         IC    GR1,0(SP1)
         SR    GR1,GR0
         STC   GR1,NEWOP                HIERARCHY CODE TO NEWOP
*
*  MAIN LOOP TO PERFORM ARITHMETIC
*
LOOP     DS    0H
         LA    GR1,OPRNS                POINT TO FIRST OPERATOR ENTRY
         CR    GRY,GR1                  ARE THERE PREVIOUS OPERATORS .Q
         BH    ONZ
         CLI   ENDOE,0                  IS ENDOE=0
         BH    FINIS
PUT      MVC   0(1,GRY),NEWOP           NEWOP TO OPRNS LIST
BUMPY    LA    GRY,1(GRY)               BUMP GRY BY 1 (FOR OPRNS)
BUMPR    LA    SP1,1(SP1)               BUMP SP1 BY 1 (FOR NON-ALFNUM)
         B     LOOK
ONZ      BCTR  GRY,0                    POINT GRY TO PREVIOUS OPERATOR
         CLC   0(1,GRY),NEWOP           IS NEW HIERARCHY LT-EQ PREVIOUS
         BNL   LE
         CLI   NEWOP,OPSLASH            TEST NEW OP /
         BNE   STEPUP                   NO
         CLI   0(GRY),OPSTAR            TEST PREV OP *
         BE    WORK                     YES, DO * FIRST
STEPUP   LA    GRY,1(GRY)               ADD 1 BACK TO GRY
         B     PUT
LE       DS    0H
         CLI   NEWOP,OPUMINUS           IS THIS UNARY - .Q
         BE    STEPUP                   JUST ENTER IT IF YES
         CLI   NEWOP,OPUPLUS            IS THIS UNARY + .Q
         BE    STEPUP                   JUST ENTER IF YES
         CLI   0(GRY),OPEND             IS OLD HIERARCHY ZERO .Q
         BH    WORK
         IC    GR1,PCNTR                SUBTRACT 1 FROM PCNTR
         BCTR  GR1,0
         STC   GR1,PCNTR
         B     BUMPR
*
*  LEFT PARENTHESIS IN THE EXPRESSION
*
LPAR     DS    0H
         CLI   COND,CONDE               WAS A TERM LAST ENTRY .Q
         BNL   LPEND                    POSSIBLE END OF EXP IF YES
         MVI   COND,CONDB               SET LEFT PAREN COND
         SR    GR1,GR1                  ZERO WORK REGISTER
         IC    GR1,PCNTR                GET CURRENT LEVEL OF PARENS
         CH    GR1,CTPARENC(,ACT)       ARE THERE TOO MANY LEFT PARENS
         LA    GRB,PARERR               TOO MANY LEVELS OF PARENS
         BH    FATLER2                  BRANCH IF TOO MANY
         LA    GR1,1(,GR1)              INCREMENT LEVEL OF PARENS
         STC   GR1,PCNTR
         MVI   0(GRY),0                 ZERO TO OPRNS LIST
         B     BUMPY
*
*  ASTERISK IN THE EXPRESSION
*
STAR     DS    0H
         CLI   COND,CONDD               FORMER STAR OR SLASH .Q
         BE    ERR12                    ERROR IF YES
         BL    LCNTR                    BRANCH IF LOC CNTR REFERENCE
*
*  ASTERISK IS MULTIPLICATION OPERATOR
*
FORD1    DS    0H
         MVI   COND,CONDD               SET MULT/DIV COND
         B     PLMIN2                   GO ADJUST OPERATION
*
*  SLASH IN THE EXPRESSION
*
SLASH    DS    0H
         CLI   COND,CONDE               DOES A TERM PRECEDE .Q
         BL    ERR12                    ERROR IF NOT
         B     FORD1                    ENTER THE SLASH
*
*  BLANK OR COMMA IN THE EXPRESSION
*
BLCOM    DS    0H
         CLI   COND,CONDE               TERM PRECEDE BLANK OR COMMA .Q
         BL    ERR17                    ERROR IF NOT
*
*  LEFT PARENTHESIS END CONDITION
*
LPEND    CLI   PCNTR,0                  IS PCNTR =0
         BH    ERR17
ENDNG    MVI   ENDOE,15                 SET ENDOE NON-ZERO
NOEND    DS    0H
         MVI   NEWOP,OPEND              SET NEWOP ZERO
         B     LOOP
*
*  ASTERISK IS LOCATION COUNTER
*
LCNTR    OI    CTLCRI(ACT),X'40'        SET BIT FOR LOC. CNTR. REF. ON
         LA    SP1,1(SP1)               POSITION SP1 TO NEXT CHAR.
         L     SP2,CTXABP(ACT)          POINTER TO LOC. CNTR.
         MVC   1(3,GRX),TXLOC(SP2)      LOC. CNTR VALUE TO TERMS LIST
         MVI   0(GRX),0
         CLI   SYMBL,0                 IS THIS THE FIRST TERM
         BH    LCNTR2                  NO
         MVN   LREF(1),F8INST+15(ACT)  MOVE IMPLIED EXPRESSION LENGTH
         CLI   LREF,0                  DONT DECREMENT LREF IF ZERO
         BZ    LCNTR1
         IC    GR1,LREF                TO TEMP LOC
         BCTR  GR1,0                   DECREMENT BY 1
         STC   GR1,LREF                AND MOVE
LCNTR1   MVC   STLONG+1(1,ACT),LREF         TO STLONG
         MVI   LREF,0                  SET LREF TO ZERO
LCNTR2   MVC   1(1,GR2),CESDID(ACT)    CURRENT ESD-ID TO RLIST
         B     OUT
*
*  PERFORM ARITHMETIC AND RELOCATABILITY WORK
*
WORK     ST    GR2,NCOMP                STORE GR2 IN NCOMP
         LA    GR0,8                    POINT GRX TO 1ST OF THE 2
         SR    GRX,GR0                       TERMS ENTRIES
         LA    GR0,2                    POINT GRZ TO 1ST OF THE 2
         SR    GRZ,GR0                       NTRMS ENTRIES
         IC    GR0,1(GRZ)               2ND NTRMS  ENTRY TO GR0
         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2
         SR    GR1,GR1                  ZERO A WORK REGISTER
         IC    GR1,0(,GRY)              GET OPERATOR FUNCTION
         AR    GR1,GR1                  DOUBLE IT
         LH    GR1,OPBRANCH(GR1)        GET INDEX BRANCH VALUE
         B     ASMGF7V(GR1)             THE APPROPRIATE ROUTINE
OPBRANCH DC    H'1'                     ZERO ERROR
         DC    AL2(OPPLS-ASMGF7V)       BINARY PLUS
         DC    AL2(OPMINS-ASMGF7V)      BINARY MINUS
         DC    AL2(OPUPLS-ASMGF7V)      UNARY PLUS
         DC    AL2(OPUMINS-ASMGF7V)     UNARY MINUS
         DC    AL2(MULDV-ASMGF7V)       MULTIPLICATION
         DC    AL2(MULDV-ASMGF7V)       DIVISION
*
*  OPERATOR IS SUBTRACTION.  COMPLEMENT 2ND VALUE AND CHANGE THE
*  RELOCATION SIGN BYTE OF THE TERMS IN THE 2ND VALUE.
*
OPUMINS  DS    0H
         CLI   0(GR2),OPPLUS            IS SIGN BYTE + .Q
         BL    NOCHGU                   BRANCH IF ABSOLUTE
         BE    PLCHGU                   BRANCH IF SIGN +
         MVI   0(GR2),OPPLUS            CHANGE - SIGN TO +
         B     NOCHGU                   AND CONTINUE
PLCHGU   DS    0H
         MVI   0(GR2),OPMINUS           CHANGE + SIGN TO -
NOCHGU   DS    0H
         L     GR1,4(,GRX)              GET CURRENT VALUE
         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY
OPUSET   DS    0H
         LA    GRX,4(,GRX)              BUMP OPND POINTER
         L     GR2,NCOMP                RESTORE RLIST POINTER
         LA    GRZ,1(,GRZ)              UNARY HAS BUT ONE TERM
         B     STORE                    AND CONTINUE
OPUPLS   DS    0H
         L     GR1,4(,GRX)              GET CURRENT VALUE
         B     OPUSET                   AND REENTER IT
*
OPMINS   DS    0H
         L     GR1,4(,GRX)              GET 2ND TERMS LIST ENTRY
         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY
         ST    GR1,4(GRX)
CHG      DS    0H
         CLI   0(GR2),OPPLUS            TEST SIGN BYTE IN 2ND RLIST
         BL    NOCHG                    BRANCH IF ABS. VALUE
         BE    PLCHG                    BRANCH IF SIGN +
         MVI   0(GR2),OPPLUS            CHANGE SIGN TO +
         B     NOCHG
PLCHG    DS    0H
         MVI   0(GR2),OPMINUS           CHANGE SIGN TO -
NOCHG    DS    0H
         LA    GR2,2(,GR2)              POINT GR2 TO NEXT ENTRY
         CL    GR2,NCOMP
         BL    CHG                      BRANCH BACK IF MORE ENTRIES
         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2
*
*  OPERATION IS ADDITION OR SUBTRACTION.  SCRATCH ENTRIES IN THE
*  RELOCATION LIST WHERE POSSIBLE.
*
OPPLS    IC    GR0,0(GRZ)               1ST NTRMS  ENTRY TO GR0
         LR    GR1,GR2                  POINT GR1 TO 2ND NTRMS LIST
         SR    GR2,GR0                  POINT GR2 TO 1ST NTRMS LIST
         LR    SP2,GR1                  SAVE GR1 IN SP2
BCOMP    DS    0H
         CLI   0(GR2),OPPLUS            IS FIRST SIGN +
         BL    NSCR                     BRANCH IF ABS. VALUE (CODE =0)
         BH    F2MIN                    BRANCH IF FIRST SIGN -
         CLI   0(GR1),OPMINUS           IS SECOND SIGN -
         BL    NSCR                     BRANCH IF SIGN NOT -
OPP      CLC   1(1,GR2),1(GR1)          COMPARE FIRST TO SECOND ESD-ID
         BNE   NSCR                     BRANCH IF NOT THE SAME
         MVI   0(GR2),0                 ZERO TO FIRST SIGN
         MVI   1(GR2),0                 ZERO TO FIRST ESD-ID
         MVC   0(2,GR1),0(GR2)          ZERO TO 2ND SIGN AND ESD-ID
         IC    GR0,RCNTR                SUBTRACT 2 FROM RCNTR
         BCTR  GR0,0
         BCTR  GR0,0
         STC   GR0,RCNTR
         B     NSCR
F2MIN    DS    0H
         CLI   0(GR1),OPPLUS            IS SECOND SIGN +
         BE    OPP
NSCR     LA    GR1,2(GR1)               POINT GR1 TO NEXT IN 2ND RLIST
         CL    GR1,NCOMP
         BL    BCOMP                    BRANCH BACK IF MORE IN 2ND LIST
         LA    GR2,2(GR2)               POINT GR2 TO NEXT IN 1ST LIST
         LR    GR1,SP2                  START OF 2ND LIST BACK TO GR1
         CLR   GR1,GR2
         BH    BCOMP                    BRANCH BACK IF MORE IN 1ST LIST
         L     GR2,NCOMP                NCOMP BACK TO GR2
         LCR   GR1,GR1                  COMPLEMENT GR1
         AR    GR1,GR2                  2ND NTRMS ENTRY TO GR1
         IC    GR0,0(GRZ)               1ST NTRMS ENTRY TO GR0
         AR    GR1,GR0                  ADD THE 2 NTRMS ENTRIES
         STC   GR1,0(GRZ)               SUM TO POSITION OF THE 1ST
*
*  PERFORM ADDITION
*
         L     GR1,0(GRX)               1ST TERMS LIST ENTRY TO GR1
         A     GR1,4(GRX)               ADD 2ND ENTRY
         BO    ERR13             -DUMMY-APPROP. OVERFLOW ROUTINE TO SYS
STORE    ST    GR1,0(GRX)               RESULT TO 1ST TERMS LIST ENTRY
         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS LIST)
         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS LIST)
         B     LOOP
*
*  OPERATOR IS MULTIPLICATION OR DIVISION.  CHECK THAT NO RELOCATABLE
*  TERMS REMAIN IN THE 2 VALUES.
*
MULDV    SR    GR1,GR1                  CLEAR GR1
         IC    GR1,0(GRZ)               1ST NTERMS ENTRY TO GR1
         AR    GR0,GR1                  ADD THE 2 NTRMS ENTRIES
         STC   GR0,0(GRZ)               SUM TO 1ST ENTRY LOCATION
         SR    GR2,GR1                  SUBT. 1ST NTRMS ENTRY FROM GR2
         LA    GR0,2                    2 TO GR0
         L     GR1,NCOMP
         SR    GR1,GR0                  C(NCOMP)-2 TO GR1
MORE     CLI   0(GR2),0
         BH    ERR11
MORE1    BXLE  GR2,GR0,MORE
         SR    GR1,GR1                  ZERO GR1
         C     GR1,4(GRX)
         BE    STORE                    BRANCH IF 2ND TERMS ENTRY =0
         L     GR0,0(GRX)               1ST TERMS ENTRY TO GR0
         SRDA  GR0,32                   PROPAGATE SIGN BIT
         CLI   0(GRY),OPSTAR            IS OPERATOR * OR /
         BH    DIV                      BRANCH IF /
*
*  PERFORM MULTIPLICATION
*
         M     GR0,4(GRX)               MULTIPLY BY 2ND TERMS ENTRY
         LTR   GR1,GR1
         BNL   CHK0                     BRANCH IF LOW-ORDER NON-NEG
         LCR   GR0,GR0                  COMPLEMENT HIGH-ORDER
         BCTR  GR0,0                    SUBTRACT 1 FROM THE COMPLEMENT
CHK0     LTR   GR0,GR0
         BC    7,ERR13                  ERROR  IF HIGH-ORDER NOW NOT=0
         B     STORE
*
*  PERFORM DIVISION
*
DIV      D     GR0,4(GRX)               DIVIDE 1ST BY 2ND TERMS ENTRY
         B     STORE
*
*  END OF EXPRESSION FOUND
*
FINIS    TM    F8YDC+1(ACT),X'01'       IS THIS ADCON
         BO    NOTST                    YES,ADCON MAY BE 4 BYTES
         BAL   GRZ,DATATST              RESULT MUST NOT EXCEED 3 BYTES
NOTST    DS    0H
         L     SP2,TERMS                MOVE RESULT TO SP2
         ST    SP2,RLIST-4              RESULT TO HEAD RLIST
         NI    CTPDSI(ACT),X'DF'        TURN OFF
         CLI   ERROR,0
         BH    SETE
         CLI   RCNTR,0
         BE    SETRET                   RETURN WITH CC=0 (ABSOLUTE EXP)
         LA    SP2,RLIST-4              POINTER TO RESULT TO SP2
         CLI   RCNTR,1
         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)
         LA    GR1,RLIST-2              FIND FIRST AND ONLY RLIST ENTRY
FIND     LA    GR1,2(GR1)                    WHERE SIGN BYTE NON-ZERO
         CLI   0(GR1),1
         BL    FIND
         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)
         MVC   RLIST(2),0(GR1)          MOVE ENTRY TO TOP OF LIST
         CLI   0(GR1),2
         B     SETRET                   RETURN WITH CC=1 (SIMPLY REL.)
*
DATATST  TM    TERMS,X'FF'              VALUE EXCEEDS 3 BYTES
         BCR   11,GRZ                   (BNM) NO
         STM   SRB,GR2,NCOMP
         L     SP1,FTXPPT               SET COL PTR TO 1ST BYTE
         L     SRB,CLOGER(ACT)          TO LOGERR
         BALR  SRR,SRB
         DROP  SRB
         USING *,SRR
         DC    AL2(VALTOLG)             ERROR CODE
         LM    SRB,GR2,NCOMP
         DROP  SRR
         USING EEVAL,SRB
DATAOK   MVI   TERMS,0                  ZERO 1ST BYTE OF RESULT
         BR    GRZ
*
*
*  ERROR FOUND
*
* TABLE OF ERROR CODES USED IN EEVAL
INVALID  EQU   18                       INVALID SYMBOL
RELERR   EQU   25                  RELOCATABILITY ERROR
SELFDEF  EQU   91                  SELF-DEF. VALUE TOO LARGE
ARITHER  EQU   56                  ARITHMETIC ERROR-OVERFLOW
PDSERR   EQU   21                  SYMBOL MUST BE PREVIOUSLY DEFINED
ILORDER  EQU   85                  TWO TERMS NOT SEPARATE
ILLCHAR  EQU   85                  ILLEGAL CHARACTER
MNYERR   EQU   27                  EXP. CONTAINS MORE THAN CTTERMC TRMS
OPERR    EQU   85                  TWO OPERATORS ILLEGALLY COUPLED
PARERR   EQU   26                  TOO MANY LEVELS OF PARENS
ENDERR   EQU   39                  EXP. END PREMATURE-UNPAIRED PAREN
VALTOLG  EQU   110              VALUE EXCEEDS RANGE
* NON-FATAL ERROR FOUND
* LOG ERROR, CONTINUE NORMAL PROCESSING
*
*  ERROR IS RELOCATABLE TERM INVOLVED IN A MULT. OR DIV. OPERATION
*
ERR11    LA    GRA,MORE1
         TM    CTPDSI(ACT),X'20'       PREV.DEF. SYM. SWITCH ON
         BO    ERR11A                  YES
         BR    GRA                     NO, DONT LOG ERROR
ERR11A   LA    GRB,RELERR              RELOCATABILILTY ERROR
         B     NFATLER1
*
*  ERROR IS SELF-DEFINING VALUE TOO LARGE
*
ERR0     LA    GRA,ABSD+6
         LA    GRB,SELFDEF         SELF-DEF. VALUE TOO LARGE
         B     NFATLER2
*
* ERROR IS SYMBOL LENGTH
*
ERR3     LA    GRA,SCANE
         LA    GRB,INVALID              SYMBOL TOO LONG
         B     ERRXXX
*
*
*  ERROR IS ARITHMETIC
*
ERR13    LA    GRA,STORE
         LA    GRB,ARITHER         ARITHMETIC ERROR
         B     NFATLER1
*
* ERROR IS SYMBOL NOT FOUND OR SYMBOL MUST BE PREVIOUSLY DEFINED
*
ERR15    LA    GRA,SCANE
         TM    CTPDSI(ACT),X'20'        YES,PREV.-DEF. SYM. SWITCH ON ?
         BO    ERR15C                  YES
         BR    GRA                 NO,DONT LOG ERROR
ERR15C   LA    GRB,PDSERR          SYMBOL MUST BE PREVIOUSLY DEFINED
         B     ERRXXX
*
*
NFATLER1 MVC   ERRPT(4),FTXPPT         SET COL PTR TO 1ST BYTE
NFATLER2 STM   SRB,GR2,NCOMP
         L     SP1,ERRPT
         B     ERRXX
*
* FATAL ERROR FOUND
* LOG ERROR, EXIT FROM EEVAL WITH SP1 AND SP2 EQUAL 0
*
*
*ERROR IS ILLEGAL CHARACTER
*
ERR9     LA    GRB,ILLCHAR         ILLEGAL CHARACTER
         B     FATLER2
*
* ERROR IS TWO CONSECUTIVE OPERATORS
*
ERR12    LA    GRB,OPERR           ILLEGAL ORDER OF OPERATORS
         B     FATLER2
*
*ERROR IS ILLEGAL END OF EXPRESSION OR UNPAIRED PARENS
*
ERR17    LA    GRB,ENDERR          EXPRESSION END PREMATURE
         B     FATLER2
*
* ERROR IS TWO CONSECUTIVE TERMS
*
ERR10    LA    GRB,ILORDER         ILLEGAL ORDER OF TERMS
*
FATLER1  STM   SRB,GR2,NCOMP
         L     SP1,ERRPT               PT TO 1ST OF TERM OR EXP.
         LA    GRA,EXERR
         B     ERRXX
FATLER2   LA   GRA,EXERR
*
*
ERRXXX   STM   SRB,GR2,NCOMP
ERRXX    STH   GRB,ERCODE
         MVI   ERROR,X'FF'         TURN ON ERROR SWITCH
ERRLOG   L     SRB,CLOGER(ACT)
         BALR  SRR,SRB             TO LOGERR
         DROP  SRB
         USING *,SRR
ERCODE   DS    AL2                 ERROR CODE
         LM    SRB,GR2,NCOMP
         DROP  SRR
         USING EEVAL,SRB
         BR    GRA                 NO,CONTINUE PROCESSING EXPRESSION
EXERR    SR    SP1,SP1               SET SP1 TO ZERO
SETE     SR    SP2,SP2             SET SP2 TO ZERO
         NI    CTPDSI(ACT),X'DF'        TURN OFF
         TM    ERROR,X'FF'              SET CC=3 FOR ERROR CONDITION
SETRET   DS    0H
         LM    GRA,GRD,REGSAV           RESTORE VOLATILE REGISTERS
         BR    SRR                      RETURN TO CALLER
         EJECT
*
* CONVERT SELF-DEFINING VALUES - FENDALL
* ENTER WITH REGISTER COLR POINTING TO 1ST CHARACTER OF CONSTANT.
* LOAD REGISTER SHFR WITH CONSTANT TYPE INDICATOR-
*        1 = BINARY
*        3 = DECIMAL
*        4 = HEX
*        8 = CHARACTER
* BRANCH WITH RETURN REGISTER RTNR.
* RETURNS WITH CONVERTED VALUE IN REGISTER VALR, RIGHT JUSTIFIED,
* SIGNIFICANT CHARACTER COUNT IN REGISTER CNTR, COLR AT 1ST
* NON-CONSTANT CHARACTER.
* REGISTERS SAVR AND CHAR ARE SCRATCHED.
* SINGLE + CAUSES IMMEDIATE RETURN WITH CNTR = 0 AND COLR AT +.
* LEADING BITS MAY BE LOST IF VALUE TOO LARGE.
RETR     EQU    GRZ
COLR     EQU    SP1
SHFR     EQU   GRX
VALR     EQU   SP2
SAVR     EQU    GRY
CHAR     EQU    GR0
CNTR     EQU    GR1
SDVCF    SR    VALR,VALR                CLEAR VALUE
         LR    CHAR,VALR                CLEAR CHAR
         LR    CNTR,VALR                CLEAR COUNT
         STC   SHFR,SDV08+1             STORE SHIFT
         CLI   SDV08+1,8                TEST FOR C-CONSTANT
         BNE   SDV01                    NO
         L     VALR,SDV09               YES, LOAD EXTERNAL ZEROES
SDV01    LA    SAVR,SDV08-1(SHFR)       TEST CHAR RANGE
         CLC   0(1,COLR),0(SAVR)
         BH    SDV07                    EXIT ON TOO HIGH
         IC    CHAR,0(COLR)
         LR    SAVR,VALR                SAVE CUMULATIVE VALUE
         CLI   SDV08+1,8                TEST FOR C-CONSTANT
         BNE   SDV04                    NO, TO SHIFT
         CLI   0(COLR),IQUOTE           TEST '
         BNE   SDV02                    NO
         CLI   1(COLR),IQUOTE           TEST ''
         BE    SDV03                    YES, TO SKIP
         B     SDV07                    NO, EXIT
SDV02    CLI   0(COLR),IAMPSD           TEST +
         BNE   SDV04                    NO, TO SHIFT
         CLI   1(COLR),IAMPSD           TEST ++
         BNE   SDV06                    NO, ERROR
SDV03    LA    COLR,1(COLR)             SKIP ' OR +
SDV04    SLL   VALR,0(SHFR)             SHIFT VALUE
         CLI   SDV08+1,3                TEST FOR DEC CONSTANT
         BNE   SDV05                    NO
         ALR   VALR,SAVR                YES, ADJUST VALUE
         ALR   VALR,SAVR
SDV05    ALR   VALR,CHAR                CHAR TO VALUE
         LA    CNTR,1(CNTR)             STEP COUNT
         LA    COLR,1(COLR)             STEP COLUMN POINTER
         B     SDV01                    TO NEXT CHAR
SDV06    SR    CNTR,CNTR                CLEAR COUNT FOR ERROR
SDV07    BR    RETR                     EXIT
*
*
SDV08    DC    X'0100090F000000FF'      LIMITS
         DS    0F
SDV09    DC    X'F0F0F0F0'              EBCDIC ZEROES
REGSAV   DS    4F                       SAVE AREA FOR F7V VOLATILE REGS
REGSAV1   DS   F
ERRPT    DS    F                       SAV AREA FOR COL PTR
FTXPPT   DS    F                       SAV AREA FOR PTR TO 1ST BYTE
OTHERR   DC    X'00'                   SWITH FOR ERR PATH,0-OFF,1-ON
FATAL    DC    X'00'               FATAL ERR SWH (0=NON-FATAL,1=FATAL)
*        START OF TERMS WORK AREA
TERMSWK  DSECT
TERMS    DS    25F                      LIST OF VALUES
RLIST    DS    25H                      RELOCATABILITY LIST
RCNTR    DS    C                        COUNTER OF RELOCATABLE TERMS
ERROR    DS    C                        ON(1), OFF(0)
PCNTR    DS    C                        COUNTER OF LEVEL OF '('
SYMBL    DS    C         0=SYM 1ST TERM,1=NOT 1ST TERM,255=SYM NOT FND
NTRMS    DS    25C                      NUMBER OF TERMS PER TERMS ENTRY
OPRNS    DS    40C                      LIST OF OPERATIONS
COND     DS    C                        VALIDITY INDICATOR
ENDOE    DS    C                        END EXPRESSION FLAG
NEWOP    DS    C                        LATEST OPERATION FOUND
LREF     DS    C                        L'SYM REF  ON(1) OFF(0)
TERMSLEN EQU   *-TERMS                  LENGTH OF TERMS WORK AREA
ASMGF7V  CSECT                          AS YOU WERE
NCOMP    DS    11F
SAVE     EQU   NCOMP
         EJECT
***********************************************************************
*         *PREVIOUS*                                                  *
*  CHAR   *  COND  *     ACTION                                       *
***********************************************************************
* START   *   --   * SET COND = 0
***********************************************************************
*  (      *0/1/2/3 * SET COND = 1
*         *4/5     * IF PCNTR GT CTTERMC, LOG ASMG026
***********************************************************************
*  )      *0/1/2/3 * LOG ASMG085
*         *4/5     * SET COND = 4, IF PCNTR=0 END EXPRESSION
***********************************************************************
*  +-     *0       * SET INITIAL ZERO TERM
*         *1/2/3   * SET COND = 2
*         *4/5     * SET COND = 1
***********************************************************************
*  *      *0/1/2   * SET COND = 5, * IS LOCATION COUNTER
*         *3       * LOG ASMG085
*         *4       * SET COND = 3, * IS MULT
*         *5       * LOG ASMG025
***********************************************************************
*  /      *0/1/2/3 * LOG ASMG085
*         *4       * SET COND =3
*         *5       * LOG ASMG025
***********************************************************************
*ABSOLUTE *0/1/2/3 * SET COND = 4
*TERM     *4/5     * LOG ASMG085
***********************************************************************
*RELOCAT- *0/1/2   * SET COND = 5
*ABLE TERM*3       * LOG ASMG025
*         *4/5     * LOG ASMG085
***********************************************************************
*,OR BLANK*0/1/2/3 * LOG ASMG039
*         *4/5     * IF PCNTR GT 0, LOG ASMG039
***********************************************************************
*
CONDA    EQU   0                        INITIAL COND SETTING
CONDB    EQU   1                        LEFT PAREN, BINARY + OR -
CONDC    EQU   2                        UNARY + OR -
CONDD    EQU   3                        ASTERISK OR SLASH
CONDE    EQU   4                        ABSOLUTE TERM OR RIGHT PAREN
CONDF    EQU   5                        RELOCATABLE TERM
*
*        HEIRARCHY CODES FOR OPRNS
OPEND    EQU   0                        BLANK OR COMMA
OPPLUS   EQU   1                        BINARY PLUS
OPMINUS  EQU   2                        BINARY MINUS
OPUPLUS  EQU   3                        UNARY PLUS
OPUMINUS EQU   4                        UNARY MINUS
OPSTAR   EQU   5                        MULTIPLICATION
OPSLASH  EQU   6                        DIVISION
*
         END
./ ADD NAME=ASMGF7X
F7X      TITLE     'ASMG F7  GET STATEMENT ROUTINE (TXGET)'
         ISEQ  73,78
         MACRO
&LABEL   OPCD  &OP=XX,                                                 X
               &TYPE=MACH,             ASSEM,EXTEN,                    X
               &ILLGEN=NO,             YES,                            X
               &NAME=,                 YES,NO,                         X
               &OPND=,                 YES,NO,                         X
               &IS=,                                                   X
               &MASK=,                 ONLY IF EXTEN,                  X
               &ALIGN=C,               H,F,D,               *          X
               &CLASS=,                0,1,2,3,             *          X
               &EVEN=NO,               YES,DOUBLE,          *ONLY      X
               &FLOAT=NO,              YES,                 *FOR       X
               &LIT1=NO,               YES,                 *MACHINE   X
               &LIT23=NO,              YES                  *TYPES     X
               &F7XREF=NO,             YES,       *ONLY                X
               &F8UPC=NO,              YES,       *FOR                 X
               &LCR=NO,                YES,       *ASSEM               X
               &STE=NO,                YES,       *TYPES               X
               &SUB=NO,                YES,       *                    X
               &UPC=NO                 YES        *
         GBLA      &VALUE,&GLENLAB(400),&GTXTO(400),&GTXASC(400)
         GBLA      &GDIM,&ERROR,&FIRST
         GBLB      &RPQ67,&SYM370
         GBLC      &CHAR,&LASTLAB
         GBLC      &GLABEL(400),&GOP(400)
         LCLA      &S1,&TDIM,&W1
         LCLC      &WC
.*                 CHECK IF THIS IS FIRST TIME IN
         AIF       (&FIRST NE 0).SKIP01
         DEFCHAR
&FIRST   SETA      1
.SKIP01  ANOP
&WC      SETC      '&LABEL'.'       '
         AIF       ('&WC' GT '&LASTLAB').SKIP02
         MNOTE     1,'OPCD -- OPCODE LABEL &LABEL OUT OF ALPHA ORDER'
.SKIP02  ANOP
&LASTLAB SETC      '&WC'
.*                 DETERMINE IF OPCODE IN THIS SET
         AIF       ('&IS' EQ '').OPOK
&W1      SETA      N'&IS
         AIF       (&W1 EQ 1).SINGTST
.SKIP03  AIF       ('&IS(&W1)' NE '67').TST70
         AIF       (&RPQ67).OPOK
         AGO       .TSTEND
.TST70   AIF       ('&IS(&W1)' NE '70').OPOK
         AIF       (&SYM370).OPOK
.TSTEND  ANOP
&W1      SETA      &W1-1
         AIF       (&W1 GT 0).SKIP03
         AGO       .NOTGEND
.SINGTST ANOP
.*                 TEST IF MOD 67 RPQ INSTRUCTION
         AIF       (('&IS' EQ '67') AND (NOT &RPQ67)).NOTGEND
.*                 TEST IF 370 INSTRUCTION
         AIF       (('&IS' EQ '70') AND (NOT &SYM370)).NOTGEND
.OPOK    ANOP
.*                 SET LABEL AND OPCODE
&TDIM    SETA      &GDIM+1
&W1      SETA      K'&LABEL
         AIF       (&W1 EQ 0).MNOTE1
&GLENLAB(&TDIM) SETA &W1
&GLABEL(&TDIM) SETC '&LABEL'
         AIF       ('&OP' EQ 'XX').MNOTE5
&GOP(&TDIM) SETC '&OP'
.*                 CHECK THE INSTRUCTION TYPE
         AIF       ('&TYPE' NE 'ASSEM').TXTO1
&S1      SETA      X'80'
         AGO       .TXTOF
.TXTO1   AIF       ('&TYPE' NE 'MACH').TXTO2
&S1      SETA      X'40'
         AGO       .TXTOF
.TXTO2   AIF       ('&TYPE' NE 'EXTEN').MNOTE2
&S1      SETA      X'60'
.TXTOF   ANOP
.*                 IS OPCODE ILLEGAL IF GENNED .Q
         AIF       ('&ILLGEN' EQ 'NO').TXRM0
         AIF       ('&TYPE' NE 'ASSEM').MNOTE9
&S1      SETA      &S1+X'20'
.*                 NAME REQUIRED OR NOT ALLOWED
.TXRM0   AIF       ('&TYPE' EQ 'EXTEN').TXRM7
         AIF       ('&NAME' EQ '').TXRM3
         AIF       ('&NAME' NE 'YES').TXRM2
&S1      SETA      &S1+X'08'
         AGO       .TXRM3
.TXRM2   AIF       ('&NAME' NE 'NO').MNOTE3
&S1      SETA      &S1+X'04'
.*                 OPERAND REQUIRED OR NOT ALLOWED
.TXRM3   AIF       ('&OPND' EQ '').TXRM8
         AIF       ('&OPND' NE 'YES').TXRM5
&S1      SETA      &S1+X'02'
         AGO       .TXRM8
.TXRM5   AIF       ('&OPND' NE 'NO').MNOTE4
&S1      SETA      &S1+X'01'
         AGO       .TXRM8
.*                 SET EXTEN MASK
.TXRM7   ANOP
         AIF       ('&MASK' EQ '').MNOTE6
&W1      SETA      K'&MASK
&CHAR    SETC      '&MASK'(&W1,1)
         TRANSLAT
&S1      SETA      &S1+&VALUE
.TXRM8   ANOP
&GTXTO(&TDIM) SETA &S1
.*                 TEST IF ASSEM OR NOT
&S1      SETA      0
         AIF       ('&TYPE' NE 'ASSEM').MACH1
         AIF       ('&UPC' EQ 'NO').ASSEM1
&S1      SETA      &S1+X'80'
.ASSEM1  AIF       ('&STE' EQ 'NO').ASSEM2
&S1      SETA      &S1+X'40'
.ASSEM2  AIF       ('&LCR' EQ 'NO').ASSEM3
&S1      SETA      &S1+X'20'
.ASSEM3  AIF       ('&F7XREF' EQ 'NO').ASSEM4
&S1      SETA      &S1+X'10'
.ASSEM4  AIF       ('&SUB' EQ 'NO').ASSEM5
&S1      SETA      &S1+X'08'
.ASSEM5  AIF       ('&F8UPC' EQ 'NO').SET1
&S1      SETA      &S1+X'01'
         AGO       .SET1
.*                 MACHINE OR EXTEN INSTRUCTION
.MACH1   AIF       ('&FLOAT' EQ 'NO').MACH2
&S1      SETA      &S1+X'80'
.MACH2   AIF       ('&EVEN' EQ 'NO').MACH3
         AIF       ('&EVEN' EQ 'DOUBLE').MACH3
&S1      SETA      &S1+X'40'
.MACH3   AIF       ('&ALIGN' EQ 'C').MACH6
         AIF       ('&ALIGN' NE 'H').MACH4
&S1      SETA      &S1+X'10'
         AGO       .MACH6
.MACH4   AIF       ('&ALIGN' NE 'F').MACH5
&S1      SETA      &S1+X'20'
         AGO       .MACH6
.MACH5   AIF       ('&ALIGN' NE 'D').MNOTE7
&S1      SETA      &S1+X'30'
.MACH6   ANOP
         AIF       ('&CLASS' EQ '').MNOTE8
&W1      SETA      &CLASS
         AIF       (&W1 GT 3 OR &W1 LT 0).MNOTE8
&S1      SETA      &S1+&W1*4
         AIF       ('&LIT23' EQ 'NO').MACH7
&S1      SETA      &S1+X'02'
.MACH7   AIF       ('&LIT1' EQ 'NO').SET1
&S1      SETA      &S1+X'01'
.*                 SET TXASC BYTE
.SET1    ANOP
&GTXASC(&TDIM) SETA &S1
&GDIM    SETA      &GDIM+1
         MEXIT
.NOTGEND MNOTE     *,'OPCD  --  OPCODE NOT GENERATED IS= &IS'
         AGO       .MEND
.*                 THESE ARE THE ERRORS
.MNOTE1  MNOTE     4,'OPCD -- MISSING LABEL'
         AGO       .MENDERR
.MNOTE2  MNOTE     4,'OPCD -- INVALID TYPE=&TYPE'
         AGO       .MENDERR
.MNOTE3  MNOTE     4,'OPCD -- INVALID NAME=&NAME'
         AGO       .MENDERR
.MNOTE4  MNOTE     4,'OPCD -- INVALID OPND=&OPND'
         AGO       .MENDERR
.MNOTE5  MNOTE     4,'OPCD -- MISSING &&OP KEYWORD'
         AGO       .MENDERR
.MNOTE6  MNOTE     4,'OPCD -- MISSING &&MASK FOR EXTEN'
         AGO       .MENDERR
.MNOTE7  MNOTE     4,'OPCD -- INVALID ALIGN=&ALIGN'
         AGO       .MENDERR
.MNOTE8  MNOTE     4,'OPCD -- INVALID CLASS=&CLASS'
         AGO       .MENDERR
.MNOTE9  MNOTE     4,'OPCD  --  ILLGEN=&ILLGEN INVALID WITH TYPE=&TYPE'
         AGO       .MENDERR
.MENDERR ANOP
&ERROR   SETA      &ERROR+1
.MEND    MEND
         SPACE     2
         MACRO
         OPCDGEN
         GBLA      &GLENLAB(400),&GTXTO(400),&GTXASC(400)
         GBLA      &GDIM,&ERROR,&FIRST,&VALUE
         GBLC      &GLABEL(400),&GOP(400),&CHAR
         LCLA      &I,&J,&W,&OPLX,&OPPT(400)
         LCLC      &C(8),&WC
         ACTR      100000
         AIF       (&FIRST EQ 0 OR &GDIM LE 1 OR &ERROR GT 0).MNOTE1
.LOOP0   ANOP
&I       SETA      &I+1
&OPPT(&I) SETA     &I
         AIF       (&I LT &GDIM).LOOP0
&I       SETA      0
.*                 BUBBLE SORT OPCODES BY NAME AND LENGTH
.LOOP1   ANOP
&I       SETA      &I+1
&J       SETA      &I
.LOOP2   ANOP
&J       SETA      &J+1
         AIF       ('&GLABEL(&I)' LT '&GLABEL(&J)').LOOP3
&W       SETA      &OPPT(&I)
&WC      SETC      '&GLABEL(&I)'
&OPPT(&I) SETA     &OPPT(&J)
&GLABEL(&I) SETC   '&GLABEL(&J)'
&OPPT(&J) SETA     &W
&GLABEL(&J) SETC   '&WC'
.LOOP3   AIF       (&J LT &GDIM).LOOP2
         AIF       (&I LT (&GDIM-1)).LOOP1
.*                 OUTPUT RESULTS
&I       SETA      0
.OUTLP1  ANOP
&I       SETA      &I+1
&J       SETA      &OPPT(&I)
&W       SETA      0
         AIF       (&GLENLAB(&J) EQ &OPLX).OUTLP2
&OPLX    SETA      &GLENLAB(&J)
OPL&OPLX EQU       *
.*                 TRANSLATE OPCODE TO INTERNAL CODE
.OUTLP2  ANOP
&W       SETA      &W+1
&CHAR    SETC      '&GLABEL(&I)'(&W,1)
&C(&W)   SETC      'I&CHAR,'
         AIF       (&W LT &OPLX).OUTLP2
&WC      SETC      '##'.'&GLABEL(&I)'
&WC      DC        AL1(&C(1)&C(2)&C(3)&C(4)&C(5)&C(6)&C(7)&C(8)&GTXTO(&*
               J)),X'&GOP(&J)',AL1(&GTXASC(&J))
         AIF       (&I LT &GDIM).OUTLP1
OPFN     EQU       *
         AGO       .MEND
.MNOTE1  MNOTE     8,'OPCDGEN -- OPCD MACROS FAILED'
         MNOTE     8,'OPCDGEN -- YOU LOSE ...... AGAIN'
.MEND    MEND
         SPACE     2
         COPY  ASMGSET
         EJECT
ASMGF7X  START
         SPACE
         PRINT DATA,NOGEN
         FDIMEN
         PRINT     ON,GEN
         SPACE 2
*                                                                     *
*TITLE ASMGF7X  F7 GET STATEMENT ROUTINE                              *
*FUNCTION/OPERATION-                                                  *
*   MOVE EDITED TEXT RECORDS FROM TEXT INPUT STREAM TO TEXT WORK AREA *
*   INSERT PROCESSED RECORDS FROM WORK AREA INTO TEXT STREAM          *
*   INSERT ERROR RECORDS INTO TEXT STREAM                             *
*   MOVE LITERAL RECORDS INTO WORK AREA, FROM SYMBOL TABLE            *
*   CONVERT 'EDITED-GENERATED' TYPE RECORDS TO FORM SUITABLE FOR F7   *
*   PROCESSING                                                        *
*   SET POINTERS TO THE OPERAND FIELD AND SYMBOL WORK BUCKETS         *
*   APPEND FIXED FIELD TO TEXT RECORD                                 *
*   APPEND LITERAL WORK BUCKETS FOR LITERALS IN OPERAND               *
*   TEST LEGALITY OF STATEMENT FIELDS-                                *
*        NAME FIELD IS TESTED FOR LEGAL CHARACTERS, TOO MANY CHAR-    *
*         ACTERS, AND LEADING CHARACTER ALPHABETIC                    *
*        ASSEMBLER OPERATIONS ARE TESTED FOR NAME FIELD AND/OR OPERAND*
*         FIELD REQUIRED OR NOT ALLOWED                               *
*ENTRY POINT-                                                         *
*   ASMGF7X...FIRST CALL ONLY                                         *
*   TXGET1...AFTER FIRST CALL                                         *
*        CALLING SEQUENCE-                                            *
*        L     FRB,CTXGET(ACT)                                        *
*        BALR  CRR,ACT                                                *
*   THE CODE AT ENTRY POINT ASMGF7X INSERTS THE ADDRESS OF TXGET1 INTO*
*    CTXGET (ACT)...SUBSEQUENT CALLS ENTER AT TXGET1                  *
*INPUT-                                                               *
*   REGISTER ACT CONTAINS ADDRESS OF ASSEMBLER CONTROL TABLE          *
*   TEXT WORK AREA CONTAINS PROCESSED RECORD                          *
*OUTPUT-                                                              *
*   REGISTER GRA CONTAINS FBA OF TEXT RECORD                          *
*   REGISTER GRB CONTAINS ADDRESS OF TEXT APPENDED FIXED FIELD        *
*   REGISTER GRC CONTAINS ADDRESS OF TEXT OPERAND LENGTH FIELD        *
*EXTERNAL ROUTINES-                                                   *
*   PUTXT...IN ASMGF7I..PUT OUT TEXT RECORD                           *
*   GETPT...IN ASMGF7I..GET POINTER TO NEXT TEXT RECORD               *
*   CLSTXT..IN ASMGF7I..TCLOSE TEXT FILES                             *
*   GETXTM..IN ASMGF7I..GET TEXT AND MOVE RECORD                      *
*   CLOGER..IN ASMGF7I..GENERATE, OR ADD TO, ERROR RECORDS            *
*EXIT-                                                                *
*   BRANCH TO CTRTRN(ACT), RETURN LINKAGE ALGORITHM IN ASSEMBLER      *
*    CONTROL TABLE                                                    *
*                                                                     *
         ENTRY OPC04                    FOR OPSYN REFERENCE
         EJECT
         USING TXGET0,FRB               BASE FOR FIRST ENTRY
         SPACE
TXGET0   L     GRA,CTXWAP(ACT)          FIND TEXT WORK AREA
         ST    GRA,CTEXTP(ACT)          SET TEXT POINTER
         ST    GRA,CTSAVE(ACT)          IN ASSMBLR CNTRL TABLE, TOO
         LA    FRB,TXGET1-TXGET0(FRB)   INCREMENT BASE REGISTER...
         ST    FRB,CTXGET(ACT)          AND ALTER ENTRY ADDRESS IN ACT
         USING TXGET1,FRB               CHANGE OF BASE
         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q
         BO    TXGET3                   YES, FIRST TIME SO DON'T 'PUT'
         OI    ##CNOP+4,BIT5            CNOP LABEL INVALID
         OI    ##COM+3,BIT5             COM LABEL INVALID
         OI    ##DROP+4,BIT6            DROP OPERAND REQUIRED
         OI    ##DSECT+5,BIT4           DSECT LABEL REQUIRED
         OI    ##ORG+3,BIT5             ORG LABEL INVALID
         B     TXGET3                   FIRST TIME, DONT 'PUT'
         SPACE 2
* ERRORS DETECTED BY TXGET
         SPACE
TXGERR00 EQU   84                       GENERATED OPERAND FORMAT ERROR
         SPACE
TXGERR12 EQU   34                       OP CODE INVALID
TXGERR13 EQU   32                               ILLEGAL IF GEN.
TXGERR14 EQU   88                               UNDEFINED
         SPACE
TXGERR20 EQU   73                       AOP NAME REQUIRED
TXGERR21 EQU   73                           NAME NOT ALLOWED
TXGERR22 EQU   39                       OPERAND REQUIRED
TXGERR23 EQU   36                           OPERAND NOT ALLOWED
         SPACE
TXGERR30 EQU   16                       INVALID NAME
         SPACE 2
* BIT MASKS
         SPACE
BIT0     EQU   X'80'                    MASKS USED...
BIT1     EQU   X'40'                    TO TEST...
BIT2     EQU   X'20'                    OR SET...
BIT3     EQU   X'10'                    INDIVIDUAL...
BIT4     EQU   X'08'                    BITS...
BIT5     EQU   X'04'                    WITHIN...
BIT6     EQU   X'02'                    A...
BIT7     EQU   X'01'                    BYTE...
         EJECT
* ENTER FROM MAIN-LINE WITH PROCESSED RECORD IN TEXT WORK AREA
         SPACE 2
TXGET1   DS    0H
         LR    SP1,GRA                  PUT RECORD FROM TEXT WORK AREA
         SPACE
TXGET2   DS    0H
         SR    SP2,SP2                  PUT RECORD ONTO TEXT-OUT BUFFER
         L     SRB,CTXTIO(ACT)          FROM TEXT WORK AREA, TEXT-IN,
         BAL   SRR,PUTXT(SRB)           OR ERROR RECORD BUILD AREA
         SPACE
         CLI   ERSWH(ACT),0             TEST ERROR SWITCH
         BE    TXGET3                   OFF
         MVI   ERSWH(ACT),0             IF ERROR SWITCH SET,
         L     SP1,CTERRP(ACT)          CLEAR SWITCH,
         B     TXGET2                   AND PUT REC FROM ERROR WRK AREA
         SPACE
TXGET3   DS    0H
         CLI   CTLIT2(ACT),0            TEST LIT GEN SWITCH
         BE    TXGET4                   OFF
         BAL   GRD,TXGLIT               ON, GET NEXT REC FROM LIT POOL
         B     TXGETA                   THEN GO TEST TYPE OF OPERATION
         SPACE
TXGET4   DS    0H
         L     SRB,CTXTIO(,ACT)         GET POINTER TO NEXT TEXT RECORD
         BAL   SRR,GETPT(SRB)
         BNZ   TXGET5                   NOT EOF
         SPACE
*********EOF***********************************************************
         MVC   0(L'TXGQUIT,GRA),TXGQUIT  EOF, MOVE QUIT REC TO WRK AREA
         B         TXGETA
         SPACE
TXGQUIT  DS    0CL18
         DC    AL2(TXGQUIT0-*),X'50802A00',AL2(TXGQUIT0-TXGQUIT-TXFAFL)
         DC    X'000001',AL1(IBLANK),(TXFAFL+1)X'00'
TXGQUIT0 EQU   *
***********************************************************************
         SPACE
TXGET5   DS    0H
         L     GR1,CTSEQN(ACT)
         LA    GR1,1(GR1)
         TM    TXRT(SP1),BIT1           TEST RECORD TYPE
         BO    TXGET10                  EDITTED
         SPACE
         TM    TXRT(SP1),BIT2           NOT EDITTED,
         BO    TXGET6                   STEP SEQUENCE NUMBER
         TM    TXRT(SP1),BIT3           IF TXRT EQ 000, 010 OR 011
         BO    TXGET7                   AND CONTINUATION BIT NOT SET
TXGET6   DS    0H
         TM    2(SP1),BIT6
         BO    TXGET7
         ST    GR1,CTSEQN(ACT)
         SPACE
TXGET7   DS    0H
         SR    SP1,SP1                  PUT RECORD FROM INPUT BUFFER
         B     TXGET2                   GO PUT RECORD OUT
         EJECT
* PROCESS EDITTED TEXT RECORD
         SPACE 2
TXGET10  DS    0H
         TM    TXRT(SP1),BIT2+BIT3      STEP SEQUENCE NUMBER
         BC    14,TXGET11               IF TXRT EQ 111
         ST    GR1,CTSEQN(ACT)
         SPACE
TXGET11  DS    0H
         L     SRB,CTXTIO(,ACT)         MOVE EDITED RECORD
         LR    SP1,GRA                  TO TEXT WORK AREA
         BAL   SRR,GETXTM(SRB)          ASMGF7I GET TEXT AND MOVE
         SPACE
         SPACE
         BAL   SRR,TXGETSET             SET FIELD POINTERS
         SPACE
         LR    GR1,GRB                  SET TXABP,
         SR    GR1,GRA                  INC REC LENGTH,
         STH   GR1,TXABP(GRA)           CLEAR APPENDED FIXED FIELD
         LH    GR1,TXRL(GRA)
         LA    GR2,0(GRA,GR1)
         MVI   0(GR2),0
         MVC   1(11,GR2),0(GR2)
         LA    GR1,TXFAFL(GR1)
         STH   GR1,TXRL(GRA)
         SPACE
         TM    TXRT(GRA),BIT2           TEST FOR SUBSTITUTED FIELDS
         BZ    TXGET13                  IF RECORD TYPE EQ 110 OR 111
         BAL   GRD,TXGEDIT              EDIT SUBSTITUTED FIELDS
         TM    TXTO(GRA),BIT0+BIT1      SEE IF AOP OR MACH OP ALREADY
         BNZ   TXGET13                  YES, NOT 'UNCHECKED', TEST NAME
         BAL   GRD,OPCCF                CONVERT OP CODE
         SPACE
TXGET13  DS    0H
         BAL   GRD,TXGNAME              TEST FOR LEGAL NAME FIELD
         TM    TXTO(GRA),BIT1           MAYBE MACH OP
         BO    TXGET14                  YES, GO TEST FOR LITERAL
         BAL   GRD,TXGOPND              IF ASSEMBLER OP, TEST OPERAND
         CLI   TXHEX(GRA),X'20'         TEST IF ORG
         BNE   TXGETRTN                 BRANCH IF NOT
         LH    GR1,TXRL(,GRA)           GET RECORD LENGTH
         LA    GR1,3(,GR1)              EXTEND BY 3 BYTES
         STH   GR1,TXRL(,GRA)           SAVE IT BACK AGAIN
         B     TXGETRTN                 GO SET OPERAND POINTERS
         SPACE
TXGET14  DS    0H
         BAL   GRD,SCANLIT              IF MACHINE OP, TEST FOR LITERAL
         SPACE
TXGETRTN DS    0H
         ST    GRC,CTXOFP(,ACT)         SET POINTERS TO OPERAND
         ST    GRB,CTXABP(ACT)          AND APPENDED FIXED FIELD
         ST    GRB,CTSAVE+4(ACT)        IN CONTROL TABLE
         B     CTRTRN(ACT)              RETURN TO MAIN-LINE
         EJECT
*
         SPACE 2
TXGETA   DS    0H
         TM    TXTO(GRA),BIT0+BIT1      TEST TYPE OF OPERATION
         BZ    TXGET1                   BYPASS IF ZERO
         SPACE
         BAL   SRR,TXGETSET             SET FIELD POINTERS
         SPACE
         LR    GR1,GRA                  FBA OF TEXT RECORD PLUS...
         AH    GR1,TXRL(GRA)            RECORD LENGTH, IS END OF RECORD
         LA    GR2,TXFAFL(GRB)          LOOK PAST APPENDED FIXED FIELD
TXGETB   DS    0H
         CLR   GR2,GR1                  THAT MAY BE END OF RECORD
         BNL   TXGETRTN                 YES, GO SET POINTERS TO OPND
         TM    TXWTYP(GR2),BIT0         NO, HAVE WB...CHECK TYPE
         BO    TXGETD                   SYMB WB, GO SET POINTER IN ACT
         TM    TXWLEN(GR2),BIT1         TEST WB LENGTH
         BZ    TXGETC                   LENGTH 6, SKIP THE 9-BUMP
         LA    GR2,9(,GR2)              STEP WB POINTER AS MUCH...
TXGETC   DS    0H
         LA    GR2,6(,GR2)              AS NEEDED TO GET PAST THIS WB
         B     TXGETB                   GO SEE IF THERE IS ANOTHER WB
TXGETD   DS    0H
         ST    GR2,CTXWBP(,ACT)         SET POINTER TO FIRST SYMB WB
         B     TXGETRTN                 GO SET OPERAND POINTERS
         EJECT
* SUBROUTINE TO SET FIELD POINTERS
*  GRA CONTAINS FIRST BYTE ADDRESS OF TEXT RECORD
         SPACE 2
TXGETSET DS    0H
         SR    GR1,GR1                  ZERO WORK REGISTER
         ST    GR1,CTXWBP(ACT)          CLEAR WORK BUCKET POINTER
         IC    GR1,TXNAML(GRA)          NAME FIELD LENGTH PLUS...
         LA    GRC,TXNAME(GR1,GRA)      NAME FIELD DISPLACEMENT PLUS...
         IC    GR1,TXOPL(GRC)           OPERATION LENGTH, PLUS OP...
         LA    GRC,TXOP(GR1,GRC)        DISP= OPERAND DISP-1 IN GRC
         IC    GR1,TXOPNL(GRC)          GET OPERAND LENGTH PLUS...
         LA    GRB,TXOPN(GR1,GRC)       OPERAND DISP (FROM GRC)...
         IC    GR1,TXCOML(GRB)          ADD COMMENT LENGTH AND DISP...
         LA    GRB,TXCOM(GR1,GRB)       TO LEAVE GRB AT APPNDED FIX FLD
         BR    SRR                     RETURN
         EJECT
* SCAN MACHINE OP FOR LITERAL IN OPERAND
         SPACE 2
SCANLIT  DS    0H
         MVC   CTWORK(256,ACT),CTWORK-1(ACT) CLEAR THE TRT TABLE
         MVI   CTWORK+IQUOTE(ACT),X'FF'       STOPPER FOR QUOTES
         SR    GRX,GRX                  GET READY TO COUNT
         IC    GRX,TXOPNL(GRC)          PICK UP OPERAND LENGTH
         LA    GRX,TXOPNL(GRC,GRX)      ADDRESS OF LAST OPERAND BYTE...
         BCTR  GRX,0                    MINUS ONE
         LR    GR1,GRC                  ADDRESS OF FIRST OPND BYTE-1
         SPACE
SCANLIT1 DS    0H
         XI    CTWORK+IEQUAL(ACT),X'FF'      RESET STOPPER FOR EQUAL
         SPACE
SCANLIT2 DS    0H
         LR    GR2,GRX                  END OPERAND-1
         SR    GR2,GR1                  FIND HOW FAR TO END OF OPND FLD
         BCR   4,GRD                    DONE, RETURN TO CALLING ROUT.
         EX    GR2,SCANLITT             GR2 IS ONE LOW, FOR TRT USE
         BCR   8,GRD                    NO STOPPER, RETURN TO CALLER
         CLI   0(GR1),IEQUAL            SEE IF STOPPED ON EQUAL SIGN...
         BE    SCANLITF                 YES, GO WORK ON LITERAL...
         CLI   CTWORK+IEQUAL(ACT),0     NO, SEE IF WE COULD HAVE
         BE    SCANLIT1                 NO, END OF QUOTE STRING..RESET
         LR    GR2,GR1                  ADDRESS OF QUOTE
         BCTR  GR2,0                    BACK ONE BYTE
         CLR   GR2,GRC                  MAY HAVE STOPPED ON FIRST BYTE
         BE    SCANLIT1                 YES, START OF QUOTE-STRING
         CLI   0(GR2),IL                MAY BE L-QUOTE
         BNE   SCANLIT1                 NO, START OF QUOTE-STRING
         B     SCANLIT2                 YES, QUOTE UNPAIRED...NO RESET
         SPACE
SCANLITF DS    0H
         LH    GR2,TXRL(,GRA)           INCREMENT REC LENGTH
         LA    GR2,6(GR2)
         STH   GR2,TXRL(GRA)
         MVC   TXFAFL(6,GRB),CTZERO(ACT) CLEAR LITERAL WORK BUCKET
         SPACE
         SR    GR1,GRC                  SET RELATIVE POINTER TO EQ SIGN
         BCTR  GR1,0                    MAKE UP FOR OFFSET
         STC   GR1,TXLSTG(GRB)          LEAVE IT IN WRK BKT
         CLI   TXLSTG(GRB),0            SEE IF = WAS FIRST BYTE
         BE    SCANLITG                 YES, GO SET EQUAL SIGN IND
         AR    GR1,GRC                  NO, GET ADDRESS OF PREVIOUS BYT
         CLI   0(GR1),ICOMMA            MAYBE WAS COMMA
         BCR   7,GRD                    NO, RETURN
         SPACE
SCANLITG DS    0H
         OI    TXESI(GRA),BIT6          SET EQUAL SIGN INDICATOR
         BR    GRD                      RETURN
         SPACE
SCANLITT TRT   1(*-*,GR1),CTWORK(ACT)
         EJECT
* SUBROUTINE TO TEST FOR LEGAL AND VALID NAME FIELD
         SPACE 2
TXGNAME  DS    0H
         TM    TXTO(GRA),BIT0           IS THIS TYPE ASSEM .Q
         BZ    TXGNAME2                 BRANCH IF NOT
         LA    SRR,TXGNONE              LOAD BRANCHING ADDRESS
         CLI   TXHEX(GRA),X'29'         IS THIS CNOP .Q
         BE    TXGCNOP                  BRANCH IF YES
         CLI   TXHEX(GRA),X'1E'         IS THIS COM .Q
         BE    TXGCOM                   BRANCH IF YES
         CLI   TXHEX(GRA),X'24'         IS THIS DROP .Q
         BE    TXGDROP                  BRANCH IF YES
         CLI   TXHEX(GRA),X'1D'         IS THIS DSECT .Q
         BE    TXGDSECT                 BRANCH IF YES
         CLI   TXHEX(GRA),X'20'         IS THIS ORG .Q
         BCR   7,SRR                    THAT'S ALL IF NOT
         MVN   TXR1M(1,GRA),##ORG+3     RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGDSECT DS    0H
         MVN   TXR1M(1,GRA),##DSECT+5   RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGDROP  DS    0H
         MVN   TXR1M(1,GRA),##DROP+4    RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGCOM   DS    0H
         MVN   TXR1M(1,GRA),##COM+3     RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGCNOP  DS    0H
         MVN   TXR1M(1,GRA),##CNOP+4    RESET SPECIAL SWITCHES
TXGNONE  DS    0H
         CLI   TXNAML(GRA),0            AOP, MAY HAVE NAME
         BE    TXGNAME0                 NO, GO SEE IF REQUIRED
         SPACE
         TM    TXR1M(GRA),BIT5          NAME PRESENT, TEST IF ALLOWED
         BO    TXGNAME1                 NOT ALLOWED, LOG ERROR
         CLI   TXHEX(GRA),X'18'         IS AOP 'TITLE'
         BNE   TXGNAME3                 NO, GO TEST NAME VALIDITY
         BR    GRD                      YES, RETURN
         SPACE
TXGNAME0 DS    0H
         TM   TXR1M(GRA),BIT4           NAME MISSING, TEST IF REQUIRED
         BCR   8,GRD                    NOT REQUIRED
         SPACE
TXGNAME1 DS    0H
         BAL   SRR,ERROR0               LOG ERROR
         DC    AL2(TXGERR20)            'ILLEGAL NAME FIELD'
         B     TXGNAME6                 SET BAD NAME INDICATOR
         SPACE 2
TXGNAME2 DS    0H
         CLI   TXNAML(GRA),0            TEST VALID NAME
         BCR   8,GRD                    NO NAME, RETURN
         SPACE
TXGNAME3 DS    0H
         CLI   TXNAML(GRA),8            TOO MANY CHARACTERS, NON A/N,
         BH    TXGNAME5                 NON ALPHA FIRST CHARACTER
         SPACE
         SR    GR1,GR1                  READY TO COUNT
         IC    GR1,TXNAML(GRA)          GET NAME FIELD LENGTH
TXGNAME4 DS    0H
         LA    GR2,TXNAML(GRA,GR1)      START AT END OF NAME
         CLI   0(GR2),IALPHA            CHECK FOR ALPHA-NUMERICS
         BH    TXGNAME5                 SPECIAL CHARACTER, GO LOG ERROR
         BCT   GR1,TXGNAME4             REPEAT, WORKING TO FIRST BYTE
         CLI   TXNAME(GRA),9            SEE IF FIRST BYTE IS ALPHA
         BCR   2,GRD                    YES, OK TO RETURN
         SPACE
TXGNAME5 DS    0H
         BAL   SRR,ERROR0               LOG ERROR (INVALID NAME)
         DC    AL2(TXGERR30)            'INVALID NAME'
         SPACE
TXGNAME6 DS    0H
         OI    TXMDN(GRA),BIT3          SET BAD NAME INDICATOR
         BR    GRD                      AND RETURN
         EJECT
* SUBROUTINE TO TEST FOR LEGAL OPERAND FIELDS
         SPACE 2
TXGOPND  DS    0H
         TM    TXR1M(GRA),BIT6+BIT7     SEE IF OPERAND IS OPTIONAL
         BCR   8,GRD                    YES, MAY AS WELL RETURN
         CLI   TXOPN(GRC),IBLANK        LOOK FOR END OF OPND FIELD
         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND
         CLI   TXOPN(GRC),ICOMMA        MAY BE OMITTED OPERAND
         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND
         CLI   TXOPNL(GRC),0            ANOTHER WAY TO OMIT OPND
         BNE   TXGOPND1                 HAVE OPND, SEE IF THAT'S OK
         SPACE
TXGOPND0 DS    0H
         TM    TXR1M(GRA),BIT6          OPERAND MISSING
         BCR   8,GRD                    LOG ERROR IF REQUIRED
         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE
         DC    AL2(TXGERR22)            'INVALID DELIMITER'
         B     ABORT                    ABORT PROCESSING
         SPACE
TXGOPND1 DS    0H
         TM    TXR1M(GRA),BIT7          OPERAND PRESENT
         BCR   8,GRD                    LOG ERROR IF NOT ALLOWED
         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE
         DC    AL2(TXGERR23)            'OPERAND FIELD MUST BE BLANK'
         BR    GRD                      RETURN
         EJECT
* EDIT SUBSTITUTED FIELDS
         SPACE 2
TXGEDIT  DS    0H
         SR    GRZ,GRZ                  START FRESH...COUNTS BLANKS
         LH    GRY,TXRL(GRA)            LET TXGEDL MOVE ALL OF RECORD
         LR    SP1,GRC                  POINT TO OPND LENGTH FIELD
         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPND
         SPACE
         SR    SP1,SP1                  READY TO COUNT
         IC    SP1,TXNAML(GRA)          USE LENGTH OF NAME FIELD...
         LA    SP1,TXNAME(GRA,SP1)      TO POINT TO OPERATION LENGTH
         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF OPER'N
         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPERAT'N
         SPACE
         LA    SP1,TXNAML(GRA)          POINT TO NAME LENGTH FIELD
         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF NAME
         LTR   GRZ,GRZ                  TEST THE 'BLANK' COUNTER
         BZ    TXGEDITA                 NONE REMOVED, GO TEST IMBEDDED
         SR    GRY,GRZ                  ADJUST REC. LENGTH FOR BLANKS
         STH   GRY,TXRL(GRA)            AND UPDATE TXRL
         BAL   SRR,TXGETSET             THEN RESET THE FIELD POINTERS
         LR    GR1,GRB                  ADDRESS OF APP. FIXED FIELD
         SR    GR1,GRA                  LESS ADDRESS OF TEXT BEGIN
         STH   GR1,TXABP(GRA)           RELATIVE POS'N OF APP. FIXED F
         SPACE
TXGEDITA DS    0H
         LR    SP1,GRC                  GET OPND LENGTH FIELD ADDRESS
         SR    SP2,SP2                  READY
         IC    SP2,TXOPNL(SP1)          OPND LENGTH TO SP2
         LTR   GRX,SP2                  MIGHT NOT BE ANY OPERAND
         BCR   8,GRD                    IF NONE, RETURN
         SPACE
TXGEDITB DS    0H
         LA    SP1,1(,SP1)              CHOOSE AN OPERAND BYTE
         CLI   0(SP1),IBLANK            SEE IF IT'S BLANK
         SPACE
TXGEDITC BC    (8),TXGEDITD             /ALTERED/ BLANK CHECK GATE
         CLI   0(SP1),IQUOTE            NO, MAYBE IT'S A QUOTE
         BE    TXGEDITQ                 QUOTE, GO SEE IF PAIRED
         SPACE
TXGEDITG DS    0H
         BCT   SP2,TXGEDITB             BACK TO CHECK REST OF OPERAND
         OI    TXGEDITC+1,X'80'         SET GATE TO CHECK FOR BLANKS
         B     TXGEDITE                 LOG ERROR IN OPND FIELD
         SPACE
TXGEDITF DS    0H
         LA    SP1,1(,SP1)              STEP TO NEXT BYTE
         CLI   0(SP1),IBLANK            SEE IF IT'S A BLANK, TOO
         BNE   TXGEDITX                 NO, GO SEE IF IT CAN BE FIXED
         SPACE
TXGEDITD DS    0H
         BCT   SP2,TXGEDITF             TEST REST OF OPERAND
         SR    SP1,GRC                  OPERAND LENGTH COUNTED
         CR    SP1,GRX                  SHOULD BE SAME AS ORIGINAL
         BCR   8,GRD                    YES, CAN RETURN
         SPACE
TXGEDITE DS    0H
         BAL   SRR,ERROR0               LOG ERROR IN OPERAND
         DC    AL2(TXGERR00)            'ILLEGAL OPERAND FIELD FORMAT'
         BR    GRD                      AND RETURN
         SPACE
TXGEDITQ DS    0H
         TM    TXGEDITC+1,X'80'         SEE IF WE WERE CHECKING BLANKS
         BZ    TXGEDITR                 NO, WERE INSIDE QUOTE STRING
         LR    GR1,SP1                  YES, GET ADDRESS OF QUOTE
         BCTR  GR1,0                    BACK UP ONE
         CR    GR1,GRC                  MIGHT BE FIRST OPND BYTE
         BE    TXGEDITR                 YES, GO TURN OF TEST FOR BLANKS
         CLI   0(GR1),IL                WAS IT AN L-QUOTE
         BNE   TXGEDITR                 NO, GO TO QUOTE MODE
         CLI   1(SP1),IA                DOES NUMBER FOLLOW L'
         BL    TXGEDITR                 YES, GO START QUOTE MODE
         CLI   1(SP1),IALPHA            IS IT A LETTER
         BNH   TXGEDITG                 YES, IT IS L ATTR
         CLI   1(SP1),IASTER            TEST FOR L'*
         BE    TXGEDITG                 BRANCH IF YES
         SPACE
TXGEDITR DS    0H
         XI    TXGEDITC+1,X'80'         NO, RESET THE BLANK TEST SWITCH
         B     TXGEDITG                 AND KEEP TESTING
         SPACE
TXGEDITX DS    0H
         TM    CTEXTENI(ACT),X'04'      WAS 'EXTEN' SPECIFIED .Q
         BZ    TXGEDITE                 NO, LOG 'OPND FIELD ERROR'
         LA    SP1,TXOPN(GRX,GRC)       POINT TO COMMENT LENGTH
         SR    GR1,GR1                  ZERO A WORK REGISTER
         IC    GR1,TXCOML(,SP1)         GET COMMENTS LENGTH
         AR    GR1,SP2                  UPDATED COMMENTS LENGTH
         CH    GR1,H255                 HOW LONG WILL IT BE .Q
         BH    TXGEDITE                 BRANCH IF TOO LONG
         SR    GRX,SP2                  DECREMENT OPND LENGTH
         STC   GRX,TXOPNL(,GRC)         SAVE NEW LENGTH BACK
TXGEDITY DS    0H
         BCTR  SP1,0                    POINT BACK IN OPND
         IC    GR0,TXCOM-1(,SP1)        GET A BYTE
         STC   GR0,TXCOM+1(,SP1)        PUT A BYTE
         BCT   SP2,TXGEDITY             LOOP TILL ALL IS DONE
         L     SP2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM
         STC   GR1,TXCOML(,SP1)         SET NEW COMMENT LENGTH
         MVC   TXCOM(1,SP1),L1CALIGN(SP2)  ENTER DEFAULT COMMENT OFFSET
         CLI   TXCOM(SP1),X'00'         IS THE DEFAULT ZERO .Q
         BCR   7,GRD                    RETURN IF NOT
         MVI   TXCOM(SP1),X'01'         SET TO ONE FOR FORMATTING
         BR    GRD                      AND RETURN
H255     DC    H'255'                   FOR COMPARISON PURPOSES
         EJECT
* EDIT TRAILING BLANKS
         SPACE 2
TXGEDT   DS    0H
         SR    GRX,GRX                  CLEAR WORKING REG.
         IC    GRX,0(SP1)               PICK UP FIELD LENGTH FROM REC.
         LTR   GR2,GRX                  ALSO TO GR2
         BCR   8,SRR                    ZERO LENGTH MEANS WE RETURN
         SPACE
TXGEDT1  DS    0H
         LA    GR1,0(SP1,GR2)           CHOOSE A BYTE AT END OF THE FLD
         CLI   0(GR1),IBLANK            MAYBE IS'S A BLANK
         BNE   TXGEDT2                  NO, GET READY TO RETURN
         BCT   GR2,TXGEDT1              YES, TEST REST OF FIELD
         BCTR  GR1,0                    ALL BLANKS,
         SPACE
TXGEDT2  DS    0H
         LA    SP2,1(GRX,SP1)           END OF ORIGINAL FIELD
         SR    GRX,GR2                  SEE HOW MANY TRAILING BLANKS-
         BCR   8,SRR                    NO BLANKS, RETURN
         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD
         AR    GRZ,GRX                  GRZ GETS TOTAL OF BLANKS
         EX    GRY,TXGEDTM              MOVE RECORD OVER  GRY=TXRL
         BR    SRR                      RETURN
TXGEDTM  MVC   1(*-*,GR1),0(SP2)        EXECUTED MOVE
*                                                                     *
*        GR1 CONTAINS ADDRESS OF LAST NON-BLANK BYTE
*        SP2 CONTAINS ADDRESS OF ORIGINAL FIELD END+1
         EJECT
* EDIT LEADING BLANKS
         SPACE 2
*INPUT-  SP1 CONTAINS ADDRESS OF FIELD LENGTH BYTE IN TEXT RECORD     *
*        GRY CONTAINS LENGTH OF TEXT RECORD                           *
*        GRZ CONTAINS THE NUMBER OF BLANKS PREVIOUSLY DELETED         *
*OUTPUT- FIELD LENGTH BYTE IS UPDATED                                 *
*        GRX CONTAINS NUMBER OF BLANKS DELETED                        *
*        GRZ CONTAINS NEW TOTAL NUMBER OF BLANKS DELETED              *
*        GR1 CONTAINS ADDRESS OF FIRST NON-BLANK CHARACTER DISCOVERED *
*                                                                     *
TXGEDL   DS    0H
         SR    GRX,GRX                  GET READY
         IC    GRX,0(SP1)               FIND FIELD LENGTH
         LTR   GR2,GRX                  ALSO IN GR2
         BCR   8,SRR                    LENGTH ZERO, WE GO BACK
         LR    GR1,SP1                  POINT JUST IN FRONT OF FIELD
         SPACE
TXGEDL1  DS    0H
         CLI   1(GR1),IBLANK            CHECK FOR A BLANK
         BNE   TXGEDL2                  NO, GET READY TO LEAVE
         LA    GR1,1(GR1)               YES, POINT TO NEXT BYTE
         BCT   GR2,TXGEDL1              AND CONTINUE ACROSS THE FIELD
         CR    SP1,GRC                  ALL BLANKS, SEE IF OPND FIELD
         BNE   TXGEDL2                  NO, GET READY TO RETURN
         BCTR  GR1,0                    OPERAND, ADJUST MOVE POINTER...
         LA    GR2,1(GR2)
         SPACE
TXGEDL2  DS    0H
         SR    GRX,GR2                  FIND HOW MANY BLANKS DELETED
         BCR   8,SRR                    NONE, DO NO MORE...RETURN
         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD
         AR    GRZ,GRX                  GRZ GETS TOTAL BLANKS
         EX    GRY,TXGEDLM              GRY CONTAINS TEXT RECORD LENGTH
         BR    SRR                      ALL DONE, RETURN
         SPACE
TXGEDLM  MVC   1(*-*,SP1),1(GR1)        MOVE 'EM OVER
*        SP1 POINTS JUST IN FRONT OF ORIGINAL FIELD
*        GR1 POINTS TO FIRST NON-BLANK BYTE
         EJECT
* GET LITERALS FROM SYMBOL TABLE AND GENERATE LDC RECORDS
*        COME HERE WHEN CTLIT2(ACT) IS NON-ZERO                       *
*        CTLIT2(ACT) IS SET =1 WHEN ASMGF7C PROCESSES 'LTORG'         *
*                           =4 WHEN ASMGF7C PROCESSES 'END'           *
         SPACE 2
TXGLIT   DS    0H
         CLI   CTLIT2(ACT),2            TEST CTLIT2
         BL    TXGLITA                  EQ 1, GET LIT DC FROM SYM. TAB.
         LA    GR1,TXGLIT2              ADDR. OF DUMMY 'LTORG'
         BE    TXGLIT1                  CTLIT2 EQ 2, LTORG
         LA    GR1,TXGLIT3              ADDR. OF DUMMY 'ORG'
         CLI   CTLIT2(ACT),3            LOOK AT LIT SWITCH AGAIN
         BE    TXGLIT1                  EQ 3, ORG
         SPACE
         MVC   TXGLIT4W+4(2),CTESRN(ACT)     EQ 4, CSECT
         MVC   TXGLIT4+TXNAME(8),CTFSTN(ACT) USE FIRST CSECT NAME, NUM.
         LA    GR0,8                         EDIT TRAILING BLANKS FROM
         LR    GR1,GR0                       NAME FIELD AND CORRECT
TXGLIT0  DS    0H
         LA    GR2,TXGLIT4+TXNAML(GR1)       FIELD COUNT
         CLI   0(GR2),IBLANK            CHECK END OF NAME FOR BLANK
         BNE   TXGLIT00                 NON-BLANK, GO ON
         BCT   GR1,TXGLIT0              STEP POINTER AND GO CHECK NEXT
         SPACE
TXGLIT00 DS    0H
         STC   GR1,TXGLIT4+TXNAML       INSERT NAME LENGTH IN REC.
         SR    GR0,GR1                  FIND NUMBER OF TRAILING BLANKS
         STC   GR0,TXGLIT4+TXNAME(GR1)  INSERT IN OPERATION LENGTH FLD
         LA    GR1,TXGLIT4              GET READY TO MOVE DUMMY CSECT
         SPACE
TXGLIT1  DS    0H
         MVC   0(TXGLIT5-TXGLIT4,GRA),0(GR1)  MOVE CSECT, ORG OR LTORG
         IC    GR1,CTLIT2(ACT)                INTO TEXT WORK AREA
         BCTR  GR1,0                          REDUCE CTLIT2 BY ONE
         STC   GR1,CTLIT2(ACT)
         BR    GRD                            RETURN
         SPACE
TXGLIT2  DC    AL2(TXGLIT3-*),X'50802200',AL2(TXGLIT3-TXGLIT2-TXFAFL)
         DC    X'000001',AL1(IBLANK),6X'00'                   **LTORG**
         SPACE
TXGLIT3  DC    AL2(TXGLIT4-*),X'50802000',AL2(TXGLIT4-TXGLIT3-TXFAFL)
         DC    X'000001',AL1(IBLANK),6X'00'                   **ORG**
         SPACE
TXGLIT4  DC    AL2(TXGLIT5-*),X'50801C00',AL2(TXGLIT4W-TXGLIT4-TXFAFL)
         DC    X'08',8AL1(IBLANK),X'0001',AL1(IBLANK),6X'00'  **CSECT**
TXGLIT4W DC    X'90000000FFFF'   **CSECT WORK BUCKET FOR ESD NUMBER**
         SPACE
TXGLIT5  EQU   *
         EJECT
*
*        GET   LITERAL DC FROM SYMBOL TABLE                           *
* LITERALS ARE SEPARATED INTO FOUR STRINGS...LITERALS WHOSE LENGTHS   *
*   ARE MULTIPLES OF 8 GO IN THE 8-BYTE STRING.  4,2, AND 1-BYTE      *
*   STRINGS ARE FORMED ACCORDINGLY.                                   *
* CTLITA(ACT)  CONTAINS FOUR ENTRIES GIVING THE NUMBER OF LITERALS IN *
*   EACH STRING, FOR WHICH TEXT RECORDS HAVE BEEN GENERATED.          *
* CTLITB(ACT)  CONTAINS THE NUMBER OF LITERALS IN EACH STRING, FOR    *
*   WHICH TEXT RECORDS HAVE NOT BEEN GENERATED.                       *
         SPACE 1
TXGLITA  DS    0H
         SR    GR1,GR1                  GR1 SET FOR 8-BYTE STRING
         SPACE
TXGLITB  DS    0H
         L     GR2,CTLITA(ACT,GR1)      GET COUNT OF STRING 'IN TEXT'
         LTR   GR2,GR2                  LOOK CLOSELY
         BZ    TXGLITC                  STRING DONE, GO LOOK IN SYM TAB
         BCTR  GR2,0                    NOT DONE, REDUCE STRING COUNT
         ST    GR2,CTLITA(ACT,GR1)      PUT BACK IN 'INTEXT' AREA
         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER
         LA    GR1,1(GR1)               UPDATE IT
         ST    GR1,CTSEQN(ACT)          AND RESTORE
         B     4(GRD)                   RETURN TO GETTING TEXT RECORD
         SPACE
TXGLITC  DS    0H
         L     GR2,CTLITB(ACT,GR1)      GET COUNT OF STRING 'IN SY TAB'
         LTR   GR2,GR2                  EXAMINE
         BZ    TXGLITD                  NONE IN SYM TAB, TRY NEXT STRNG
         BCTR  GR2,0                    FOUND ONE, REDUCE COUNT
         ST    GR2,CTLITB(ACT,GR1)      PUT BACK IN 'IN SYMB TABLE'
         L     SRB,CDCGET(ACT)          DCGET TURNS SYM TABLE ENTRIES
         BALR  SRR,SRB                  TO LDC TEXT REC'S...ASMGF7G
         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER
         LA    GR1,1(GR1)               STEP IT
         ST    GR1,CTSEQN(ACT)          REPLACE
         BR    GRD                      RETURN WITH RECORD 'GOT'
         SPACE
TXGLITD  DS    0H
         LA    GR1,4(,GR1)              STEP TO NEXT STRING
         CH    GR1,H16                  ONLY FOUR STRINGS ALLOWED
         BL    TXGLITB                  MORE LEFT, LOOK IN TEXT FIRST
         MVI   CTLIT2(ACT),0            CLEAR LIT GEN SWITCH
         B     4(GRD)                   RETURN, TO GET NEXT RECORD
H16      DC    H'16'                    HALFWORD SIXTEEN
         SPACE 2
ERROR0   DS    0H
         SR    SP1,SP1                  PARAMETER REG FOR ASMGF7L
ERROR    DS    0H
         L     SRB,CLOGER(,ACT)         CLOGER BUILDS ERROR MESS. REC'D
         BR    SRB                      TO ASMGF7L
         SPACE
ABORT    DS    0H
         NI    TXTO(GRA),X'FF'-(BIT0+BIT1) SET TYPE OPERATION UNCHCKD
         B     TXGET1                   FLUSH RECORD, GET ANOTHER
         EJECT
* OP CODE CONVERSION S/R FOR GENERATED RECORDS
         SPACE 2
REGP     EQU   GR1                      WORKING REGISTER
COLR     EQU   GRA                      POINTS TO TEXT RECORD BEGIN
RTNR     EQU   GRD                      RETURN REG.
LREG     EQU   GR2                      LENGTH OP CODE-1
TABR     EQU   GRZ                      TABLE POINTER
INCR     EQU   GRX                      STEP THROUGH TABLE
LIMR     EQU   GRY                      LIMIT OF SEARCH
OPINC    EQU   28                       OPSYN CHAIN PTR ST INCRMT
OPTR     EQU   CTWORK+16                POINTER SLOT
         SPACE
OPCCF    DS    0H
         SR    REGP,REGP                GET READY
         IC    REGP,TXNAML(COLR)        GET NAME FIELD LENGTH
         LA    REGP,TXNAME(COLR,REGP)   POINT TO OP LENGTH FIELD
         SR    LREG,LREG                GET OP LENGTH
         IC    LREG,TXOPL(REGP)
         CLI   TXOP(REGP),I9            IF 1ST CHAR. DIGIT
         BNH   OPCERR3                  LOG ERROR
         CLI   TXOPL(REGP),8            IF LONGER THAN 8
         BH    OPCERR3                  LOG ERROR
         CLI   TXOPL(REGP),5            IF LONGER THAN 5
         BH    OPC08                    CHECK OPSYN TABLE
         BCTR  LREG,0
         LTR   TABR,LREG
         BM    OPCERR2                       TEST OP LEN EQ 0
         STC   LREG,OPC02+1             /ALTERS LENGTH IN CLC INSTR./
         SLL   TABR,2                        4(L-1) ADDRESS TABLE ACCES
         LA    INCR,4(LREG)                  L+3 INCREMENT
         L     LIMR,OPC04+4(TABR)       SET LIMIT
         L     TABR,OPC04(TABR)         SET START
         SPACE 2
OPC02    CLC   TXOP(*-*,REGP),0(TABR)   /LENGTH INSERTED ABOVE/
         BH    OPC01                    TRY NEXT
         BL    OPC05                    NOT FOUND, TRY OPSYN TABL
         LA    TABR,1(TABR,LREG)        FOUND
OPC03    DS    0H
         MVC   3(3,COLR),0(TABR)        TYPE, HEX OP, ASC TO TEXT
         TM    TXTO(COLR),BIT0          TEST LEGAL IF GEN IF AOP
         BCR   8,RTNR                   OK, RETURN
         TM    TXEMF(COLR),BIT2         CHECK FOR EXTENDED MNEMONIC
         BCR   8,RTNR                   OK, RETURN
OPCERR1  DS    0H
         BAL   SRR,ERROR0               OP CODE ILLEGAL IF GEN
         DC    AL2(TXGERR13)            'OP CODE NOT ALLOWED TO BE GEN'
         B     ABORT                    GIVE UP THIS STATEMENT
OPCERR2  DS    0H
         BAL   SRR,ERROR0               OP LEN EQ ZERO
         DC    AL2(TXGERR12)            'INVALID OP.CODE'
         B     ABORT                    GIVE UP
OPCERR3  EQU   OPCERR2                  OP LEN GR 8
OPCERR4  DS    0H
         BAL   SRR,ERROR0               OP NOT FOUND
         DC    AL2(TXGERR14)            'OP CODE UNDEFINED'
         B     ABORT                    GIVE UP
OPC01    DS    0H
         BXLE  TABR,INCR,OPC02          CHECK NEXT IF ANY
OPC05    DS    0H
         LA    LREG,1(,LREG)            FORM FULL LENGTH
OPC08    DS    0H
         STC   LREG,CTWORK(,ACT)        SET UP SEARCH ARGUMENT
         MVC   CTWORK+1(8,ACT),TXOP(REGP)
         MVI   OPTR(ACT),0
         L     REGP,CTSYMP(,ACT)        ACCESS SYMBOL TABLE
         LA    TABR,OPINC(,REGP)        OPSYN CHAIN POINTER
         STC   LREG,OPC07+1
OPC06    DS    0H
         MVC   OPTR+1(3,ACT),0(TABR)    GET NEXT POINTER
         L     TABR,OPTR(,ACT)
         LTR   TABR,TABR                CHECK END OF CHAIN
         BZ    OPCERR4                  YES, UNDEFINED
         ALR   TABR,REGP                FORM FULL POINTER
OPC07    CLC   CTWORK(*-*,ACT),3(TABR)  COMPARE L AND SYMBOL
         BNE   OPC06                    NOPE, KEEP SEARCHING
         LA    TABR,4(TABR,LREG)        STEP PAST PTR, L, NAME
         B     OPC03                    TO FOUND
         EJECT
*        OP-CODE TABLE DELIMITERS...BY OP-CODE LENGTH                 *
         SPACE
OPC04    DC    A(OPL1)                  START OF 1-BYTE OP-CODES
         DC    A(OPL2)                  START OF 2-BYTE OP-CODES
         DC    A(OPL3)                  START OF 3-BYTE OP-CODES
         DC    A(OPL4)                  START OF 4-BYTE OP-CODES
         DC    A(OPL5)                  START OF 5-BYTE OP-CODES
         DC    A(OPFN)                  END OF OP-CODE TABLE
         SPACE
* TABLE OF SYMBOLIC OP CODES (INTERNAL CODE) BY LENGTH,
* WITH TYPE FLAG AND HEX CODES - FENDALL
         SPACE
*                                                                     *
* TABLE ENTRIES CONSIST OF-                                           *
*        OP-CODE, IN ASSEMBLER INTERNAL CODE...ONE TO FIVE BYTES      *
*        SECOND BYTE OF FLAGA... ONE BYTE, BITS USED AS FOLLOWS       *
*                TXTO   .O - OPERATION TYPE ON IF TYPE=ASSEM          *
*                       .1 - OP TYPE, ON IF TYPE=MACH OR EXTEN        *
*                TXEMF  .2 - EXTENDED MNEMONIC FLAG...ILLEGAL IF GEN'D*
*                TXMDN  .3 - MULTIPLY DEFINE NAME INDICATOR           *
*                 TXR1M .4 - NAME REQUIRED
*                       .5 - NAME NOT ALLOWED
*                       .6 - OPERAND REQUIRED
*                       .7 - OPERAND NOT ALLOWED
*        TXHEX... ONE BYTE, MACH. OP CODE OR INTERNAL ASSMBLR OP CODE *
*        TXASC...ONE BYTE, ASSEMBLER SWITCH CODE..BITS USED THUSLY... *
*                 TXASC .0 - UNINITIATED PRIVATE CODE
*                       .1 - POSSIBLE SYMBOL TABLE ENTRY
*                       .2 - LOCATION COUNTER REFERENCE
*                       .3 - SPECIAL PHASE 7 X-REFERENCE
*                       .4 - SUBSTITUTION REQUIRED
*                       .5 -
*                       .6 -
*                       .7 - PHASE 8 UNINITIATED PRIVATE CODE
*
*             ...OR THUSLY FOR MACHINE OPERATION CODES
*                       .0   0 - NO FLOATING REGISTER
*                            1 - FLOATING REGISTER REQURIED
*                       .1   0 - NO EVEN REGISTER
*                            1 - EVEN REGISTER REQUIRED
*                       .23  00- NO BOUNDARY ALIGNMENT
*                            01- HALF WORD ALIGNMENT
*                            10- FULL WORD ALIGNMENT
*                            11- DOUBLE WORD ALIGNMENT
*                       .45  XX- TYPE OF CLASS WITHIN INST (XX+1)
*                       .6   1 - LITERAL PERMITTED IN 2ND & 3RD OPERAND
*                       .7   1 - LITERAL PERMITTED IN 1ST OPERAND
*
*
*        THE FOLLOWING IS AN EXPLANATION OF THE PARMS ON THE OPCD MACRO
*
*        0P=XX     OPCODE (MACHINE OR ASSEMBLER INTERNAL) IN HEX
*        TYPE=ASSEM     ASSEMBLER OP-CODE  EXAMPLE START,DC,ACTR
*        TYPE=MACH      MACHINE OP-CODE    EXAMPLE BC,LTR,BXLE
*        TYPE=EXTEN     EXTENDED MNEMONIC  EXAMPLE BE,NOPR,BM
*                       ALSO SI EX. INSTS  EXAMPLE HDV,SCK,STIDP
*        ILLGEN=NO/YES      OPCODE ILLEGAL IF GENERATED
*        NAME=NULL/YES/NO   IF NAME FIELD OPTIONAL/MANDATORY/ILLEGAL
*        OPND=NULL/YES/NO   IF OPERAND FIELD OPTIONAL/MANDATORY/ILLEGAL
*        IS=XX     TO IDENTIFY AN OPCODE FOR GIVEN INSTRUCTION SET(S)
*        MASK=XX   MASK BYTE NEEDED ONLY FOR ASSEM OR EXTEN OPS
******  FOLLOWING PARAMETERS NEEDED ONLY FOR MACH OR EXTEN OPS
*        ALIGN=C/H/F/D  CHARACTER,HALFWORD,FULLWORD,DOUBLEWORD ALIGN
*        CLASS=(0,1,2,3)     TOGETHER WITH OP= DETERMINES OPERAND TYPES
*                            OP   CLASS          OPERAND FORMAT
*                            --   -----          --------------
*                            RR     0       AR    R1,R2
*                                   1       SPM   R1
*                                   2       SVC   I
*                                   3       BR    R2
*                            RX     0       D     R1,ADDRX
*                                   1       B     ADDRX
*                            RS/SI  0       LM    R1,R3,ADDR
*                                   1       SRDA  R1,ADDR
*                                   2       CLI   ADDR,I
*                                   3       HIO   ADDR
*                            SS     0       AP    ADDR1(L1),ADDR2(L2)
*                                   1       MVC   ADDR1(L),ADDR2
*                                   2       XIO   ADDR1(I),ADDR2
*                                   3       SRP   ADDR1(L1),ADDR2,I3
*        EVEN=YES/NO    IF REGISTER SPECS MUST BE EVEN  EXAMPLE M,D
*            =DOUBLE    IF REGISTER MUST BE 0 OR 4 (ONLY FOR FLOATING)
*        FLOAT=YES/NO   IF REGISTER SPECS MUST BE .LE. 6
*        LIT1=YES/NO    IF FIRST OPERAND MAY BE A LITERAL
*        LIT23=YES/NO   IF SECOND AND THIRD OPERANDS MAY BE LITERALS
******  FOLLOWING PARAMATERS NEEDED ONLY FOR ASSEM OPS
*        F7XREF=YES/NO  SPECIAL PHASE F7 CROSS-REFERENCE
*        F8UPC=YES/NO   PHASE F8 UNINITIATED PRIVATE CODE
*        LCR=YES/NO     LOCATION COUNTER REFERENCE
*        STE=YES/NO     POSSIBLE SYMBOL TABLE ENTRY
*        SUB=YES/NO     SUBSTITUTION REQUIRED
*        UPC=YES/NO     UNINITIATED PRIVATE CODE
*
***********************************************************************
*
*                  IMPORTANT NOTE
*
*        TO ADD A NEW INSTRUCTION TO THE ASSEMBLER YOU
*        MUST NOT ONLY ADD AN NEW INST TO AN ASMGISXX MODULE,
*        BUT YOU SHOULD ALSO ADD THE NEW INSTRUCTION TO THE TABLE
*        HERE AT THE END OF DECK ASMGF7X.
***********************************************************************
         EJECT
A        OPCD      OP=5A,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
ACTR     OPCD      OP=25,TYPE=ASSEM,                                   *
               ILLGEN=YES
AD       OPCD      OP=6A,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
ADD      OPCD      OP=66,TYPE=MACH,IS=67,                              *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
ADDR     OPCD      OP=26,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
ADR      OPCD      OP=2A,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AE       OPCD      OP=7A,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AER      OPCD      OP=3A,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AGO      OPCD      OP=0A,TYPE=ASSEM,                                   *
               ILLGEN=YES
AGOB     OPCD      OP=0A,TYPE=ASSEM,                                   *
               ILLGEN=YES
AH       OPCD      OP=4A,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
AIF      OPCD      OP=09,TYPE=ASSEM,                                   *
               ILLGEN=YES
AIFB     OPCD      OP=09,TYPE=ASSEM,                                   *
               ILLGEN=YES
AL       OPCD      OP=5E,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
ALR      OPCD      OP=1E,TYPE=MACH,                                    *
               CLASS=0
ANOP     OPCD      OP=0B,TYPE=ASSEM,                                   *
               ILLGEN=YES
AP       OPCD      OP=FA,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
AR       OPCD      OP=1A,TYPE=MACH,                                    *
               CLASS=0
AU       OPCD      OP=7E,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AUR      OPCD      OP=3E,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AW       OPCD      OP=6E,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AWR      OPCD      OP=2E,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AX       OPCD      OP=76,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AXR      OPCD      OP=36,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
B        OPCD      OP=47,TYPE=EXTEN,MASK=F,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BAL      OPCD      OP=45,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BALR     OPCD      OP=05,TYPE=MACH,                                    *
               CLASS=0
BAS      OPCD      OP=4D,TYPE=MACH,IS=(20,67),                         *
               ALIGN=H,CLASS=0,LIT23=YES
BASR     OPCD      OP=0D,TYPE=MACH,IS=(20,67),                         *
               CLASS=0
BC       OPCD      OP=47,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BCR      OPCD      OP=07,TYPE=MACH,                                    *
               CLASS=0
BCT      OPCD      OP=46,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BCTR     OPCD      OP=06,TYPE=MACH,                                    *
               CLASS=0
BE       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BER      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *
               CLASS=3
BH       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BHR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *
               CLASS=3
BL       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BLR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *
               CLASS=3
BM       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BMR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *
               CLASS=3
BNE      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNER     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *
               CLASS=3
BNH      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNHR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *
               CLASS=3
BNL      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNLR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *
               CLASS=3
BNM      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNMR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *
               CLASS=3
BNO      OPCD      OP=47,TYPE=EXTEN,MASK=E,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNOR     OPCD      OP=07,TYPE=EXTEN,MASK=E,                            *
               CLASS=3
BNP      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNPR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *
               CLASS=3
BNZ      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNZR     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *
               CLASS=3
BO       OPCD      OP=47,TYPE=EXTEN,MASK=1,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BOR      OPCD      OP=07,TYPE=EXTEN,MASK=1,                            *
               CLASS=3
BP       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BPR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *
               CLASS=3
BR       OPCD      OP=07,TYPE=EXTEN,MASK=F,                            *
               CLASS=3
BXH      OPCD      OP=86,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BXLE     OPCD      OP=87,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BZ       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BZR      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *
               CLASS=3
C        OPCD      OP=59,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
CCW      OPCD      OP=28,TYPE=ASSEM,                                   *
               F7XREF=YES,F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES
CD       OPCD      OP=69,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
CDR      OPCD      OP=29,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
CDS      OPCD      OP=BB,TYPE=MACH,IS=70,                              *
               ALIGN=D,CLASS=0
CE       OPCD      OP=79,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
CER      OPCD      OP=39,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
CH       OPCD      OP=49,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
CHPM     OPCD      OP=B3,TYPE=MACH,IS=44,                              *
               ALIGN=F,CLASS=2,LIT1=YES
CIO      OPCD      OP=9B,TYPE=MACH,IS=20,                              *
               ALIGN=C,CLASS=2
CL       OPCD      OP=55,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
CLC      OPCD      OP=D5,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES
CLCL     OPCD      OP=0F,TYPE=MACH,IS=70,                              *
               CLASS=0,EVEN=YES
CLI      OPCD      OP=95,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2,LIT1=YES
CLM      OPCD      OP=BD,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0,LIT23=YES
CLR      OPCD      OP=15,TYPE=MACH,                                    *
               CLASS=0
CLRIO    OPCD      OP=9D,TYPE=EXTEN,IS=70,MASK=1,                      *
               ALIGN=C,CLASS=3
CNOP     OPCD      OP=29,TYPE=ASSEM,ILLGEN=YES,OPND=YES,               *
               F8UPC=YES,LCR=YES,SUB=YES,UPC=YES
COM      OPCD      OP=1E,TYPE=ASSEM,                                   *
               STE=YES,F8UPC=YES
COPY     OPCD      OP=0C,TYPE=ASSEM,                                   *
               ILLGEN=YES
CP       OPCD      OP=F9,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT1=YES,LIT23=YES
CR       OPCD      OP=19,TYPE=MACH,                                    *
               CLASS=0
CS       OPCD      OP=BA,TYPE=MACH,IS=70,                              *
               ALIGN=F,CLASS=0
CSECT    OPCD      OP=1C,TYPE=ASSEM,ILLGEN=YES,                        *
               F8UPC=YES,STE=YES
CVB      OPCD      OP=4F,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,LIT23=YES
CVD      OPCD      OP=4E,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0
CXD      OPCD      OP=2C,TYPE=ASSEM,OPND=NO,                           *
               F8UPC=YES,STE=YES,UPC=YES
D        OPCD      OP=5D,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES
DC       OPCD      OP=26,TYPE=ASSEM,OPND=YES,                          *
               F8UPC=YES,LCR=YES,STE=YES,UPC=YES
DD       OPCD      OP=6D,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
DDR      OPCD      OP=2D,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
DE       OPCD      OP=7D,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
DER      OPCD      OP=3D,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
DP       OPCD      OP=FD,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
DR       OPCD      OP=1D,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES
DROP     OPCD      OP=24,TYPE=ASSEM,NAME=NO,                           *
               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES
DS       OPCD      OP=27,TYPE=ASSEM,OPND=YES,                          *
               F8UPC=YES,LCR=YES,STE=YES,UPC=YES
DSECT    OPCD      OP=1D,TYPE=ASSEM,ILLGEN=YES,                        *
               F8UPC=YES,STE=YES
DX       OPCD      OP=73,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
DXD      OPCD      OP=2B,TYPE=ASSEM,NAME=YES,OPND=YES,                 *
               STE=YES,F8UPC=YES
ED       OPCD      OP=DE,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
EDMK     OPCD      OP=DF,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
EJECT    OPCD      OP=15,TYPE=ASSEM,                                   *
               NAME=NO
END      OPCD      OP=21,TYPE=ASSEM,ILLGEN=YES,NAME=NO,                *
               F7XREF=YES,LCR=YES,SUB=YES
ENTRY    OPCD      OP=19,TYPE=ASSEM,NAME=NO,OPND=YES,                  *
               F7XREF=YES,LCR=YES
EQU      OPCD      OP=1F,TYPE=ASSEM,NAME=YES,OPND=YES,                 *
               LCR=YES,STE=YES,SUB=YES,UPC=YES
EX       OPCD      OP=44,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
EXTRN    OPCD      OP=1A,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
GBLA     OPCD      OP=00,TYPE=ASSEM,                                   *
               ILLGEN=YES
GBLB     OPCD      OP=01,TYPE=ASSEM,                                   *
               ILLGEN=YES
GBLC     OPCD      OP=02,TYPE=ASSEM,                                   *
               ILLGEN=YES
HDR      OPCD      OP=24,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
HDV      OPCD      OP=9E,TYPE=EXTEN,MASK=1,                            *
               ALIGN=C,CLASS=3
HER      OPCD      OP=34,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
HIO      OPCD      OP=9E,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
HPR      OPCD      OP=99,TYPE=MACH,IS=20,                              *
               CLASS=2
HVC      OPCD      OP=83,TYPE=MACH,IS=71,                              *
               ALIGN=F,CLASS=0
IC       OPCD      OP=43,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
ICM      OPCD      OP=BF,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0,LIT23=YES
ICTL     OPCD      OP=11,TYPE=ASSEM,                                   *
               ILLGEN=YES
IPK      OPCD      OP=B2,TYPE=EXTEN,MASK=B,                            *
               ALIGN=C,CLASS=3
ISEQ     OPCD      OP=12,TYPE=ASSEM,                                   *
               ILLGEN=YES
ISK      OPCD      OP=09,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0
L        OPCD      OP=58,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
LA       OPCD      OP=41,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
LCDR     OPCD      OP=23,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LCER     OPCD      OP=33,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LCLA     OPCD      OP=03,TYPE=ASSEM,                                   *
               ILLGEN=YES
LCLB     OPCD      OP=04,TYPE=ASSEM,                                   *
               ILLGEN=YES
LCLC     OPCD      OP=05,TYPE=ASSEM,                                   *
               ILLGEN=YES
LCR      OPCD      OP=13,TYPE=MACH,                                    *
               CLASS=0
LCTL     OPCD      OP=B7,TYPE=MACH,IS=70,                              *
               ALIGN=F,CLASS=0,LIT23=YES
LD       OPCD      OP=68,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
LDR      OPCD      OP=28,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LE       OPCD      OP=78,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
LER      OPCD      OP=38,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LH       OPCD      OP=48,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
LM       OPCD      OP=98,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
LMC      OPCD      OP=B8,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,LIT23=YES
LNDR     OPCD      OP=21,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LNER     OPCD      OP=31,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LNR      OPCD      OP=11,TYPE=MACH,                                    *
               CLASS=0
LPDR     OPCD      OP=20,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LPER     OPCD      OP=30,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LPR      OPCD      OP=10,TYPE=MACH,                                    *
               CLASS=0
LPSW     OPCD      OP=82,TYPE=MACH,                                    *
               ALIGN=D,CLASS=3,LIT1=YES
LPSX     OPCD      OP=B2,TYPE=MACH,IS=44,                              *
               ALIGN=D,CLASS=3,LIT1=YES
LR       OPCD      OP=18,TYPE=MACH,                                    *
               CLASS=0
LRA      OPCD      OP=B1,TYPE=MACH,IS=(67,70),                         *
               ALIGN=C,CLASS=0,LIT23=YES
LRDR     OPCD      OP=25,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LRER     OPCD      OP=35,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LTDR     OPCD      OP=22,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LTER     OPCD      OP=32,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LTORG    OPCD      OP=22,TYPE=ASSEM,                                   *
               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES
LTR      OPCD      OP=12,TYPE=MACH,                                    *
               CLASS=0
LX       OPCD      OP=74,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
M        OPCD      OP=5C,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES
MACRO    OPCD      OP=0D,TYPE=ASSEM,                                   *
               ILLGEN=YES
MC       OPCD      OP=AF,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=2,LIT1=YES
MD       OPCD      OP=6C,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
MDD      OPCD      OP=65,TYPE=MACH,IS=67,                              *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
MDDR     OPCD      OP=25,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
MDR      OPCD      OP=2C,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
ME       OPCD      OP=7C,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
MEND     OPCD      OP=10,TYPE=ASSEM,                                   *
               ILLGEN=YES
MER      OPCD      OP=3C,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
MEXIT    OPCD      OP=0F,TYPE=ASSEM,                                   *
               ILLGEN=YES
MH       OPCD      OP=4C,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
MNOTE    OPCD      OP=0E,                                              *
               TYPE=ASSEM
MP       OPCD      OP=FC,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
MR       OPCD      OP=1C,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES
MVC      OPCD      OP=D2,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
MVCL     OPCD      OP=0E,TYPE=MACH,IS=70,                              *
               CLASS=0,EVEN=YES
MVI      OPCD      OP=92,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
MVN      OPCD      OP=D1,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
MVO      OPCD      OP=F1,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
MVZ      OPCD      OP=D3,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
MX       OPCD      OP=72,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
MXD      OPCD      OP=67,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
MXDR     OPCD      OP=27,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
MXR      OPCD      OP=26,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
N        OPCD      OP=54,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
NC       OPCD      OP=D4,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
NI       OPCD      OP=94,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
NOP      OPCD      OP=47,TYPE=EXTEN,MASK=0,                            *
               ALIGN=H,CLASS=1,LIT23=YES
NOPR     OPCD      OP=07,TYPE=EXTEN,                                   *
               CLASS=3,MASK=0
NR       OPCD      OP=14,TYPE=MACH,                                    *
               CLASS=0
O        OPCD      OP=56,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
OC       OPCD      OP=D6,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
OI       OPCD      OP=96,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
OPSYN    OPCD      OP=2D,TYPE=ASSEM,                                   *
               ILLGEN=YES,NAME=YES
OR       OPCD      OP=16,TYPE=MACH,                                    *
               CLASS=0
ORG      OPCD      OP=20,TYPE=ASSEM,                                   *
               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES
PACK     OPCD      OP=F2,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
POP      OPCD      OP=2F,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
PRINT    OPCD      OP=13,TYPE=ASSEM,                                   *
               NAME=NO
PTLB     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=D,                      *
               ALIGN=C,CLASS=3
PUNCH    OPCD      OP=16,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
PUSH     OPCD      OP=30,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
RDD      OPCD      OP=85,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
RDDW     OPCD      OP=B5,TYPE=MACH,IS=44,                              *
               ALIGN=F,CLASS=2
REPRO    OPCD      OP=17,TYPE=ASSEM,                                   *
               ILLGEN=YES,NAME=NO
RRB      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=3,                      *
               ALIGN=C,CLASS=3
S        OPCD      OP=5B,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
SCK      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=4,                      *
               ALIGN=C,CLASS=3,LIT1=YES
SCKC     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=6,                      *
               ALIGN=D,CLASS=3,LIT1=YES
SD       OPCD      OP=6B,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SDD      OPCD      OP=67,TYPE=MACH,IS=67,                              *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
SDDR     OPCD      OP=27,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
SDR      OPCD      OP=2B,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SE       OPCD      OP=7B,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SER      OPCD      OP=3B,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SETA     OPCD      OP=06,TYPE=ASSEM,                                   *
               ILLGEN=YES
SETB     OPCD      OP=07,TYPE=ASSEM,                                   *
               ILLGEN=YES
SETC     OPCD      OP=08,TYPE=ASSEM,                                   *
               ILLGEN=YES
SH       OPCD      OP=4B,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
SIGP     OPCD      OP=AE,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0
SIO      OPCD      OP=9C,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
SIOF     OPCD      OP=9C,TYPE=EXTEN,MASK=1,                            *
               ALIGN=C,CLASS=3
SL       OPCD      OP=5F,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
SLA      OPCD      OP=8B,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SLDA     OPCD      OP=8F,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
SLDL     OPCD      OP=8D,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
SLL      OPCD      OP=89,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SLR      OPCD      OP=1F,TYPE=MACH,                                    *
               CLASS=0
SLT      OPCD      OP=A2,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0
SP       OPCD      OP=FB,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
SPACE    OPCD      OP=14,TYPE=ASSEM,                                   *
               NAME=NO
SPKA     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=A,                      *
               ALIGN=C,CLASS=3
SPM      OPCD      OP=04,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SPSW     OPCD      OP=81,TYPE=MACH,IS=20,                              *
               ALIGN=H,CLASS=3,LIT1=YES
SPT      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=8,                      *
               ALIGN=D,CLASS=3,LIT1=YES
SPX      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=0,                      *
               ALIGN=F,CLASS=3,LIT23=YES
SR       OPCD      OP=1B,TYPE=MACH,                                    *
               CLASS=0
SRA      OPCD      OP=8A,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SRDA     OPCD      OP=8E,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
SRDL     OPCD      OP=8C,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
SRL      OPCD      OP=88,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SRP      OPCD      OP=F0,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
SSK      OPCD      OP=08,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0
SSM      OPCD      OP=80,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3,LIT1=YES
ST       OPCD      OP=50,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0
STAP     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=2,                      *
               ALIGN=H,CLASS=3
START    OPCD      OP=1B,TYPE=ASSEM,ILLGEN=YES,                        *
               F8UPC=YES
STC      OPCD      OP=42,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0
STCK     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=5,                      *
               ALIGN=C,CLASS=3
STCKC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=7,                      *
               ALIGN=D,CLASS=3
STCM     OPCD      OP=BE,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0
STCTL    OPCD      OP=B6,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0
STD      OPCD      OP=60,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES
STE      OPCD      OP=70,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES
STH      OPCD      OP=40,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0
STIDC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=3,                      *
               ALIGN=C,CLASS=3
STIDP    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=2,                      *
               ALIGN=C,CLASS=3
STM      OPCD      OP=90,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0
STMC     OPCD      OP=B0,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0
STNSM    OPCD      OP=AC,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
STOSM    OPCD      OP=AD,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
STPT     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=9,                      *
               ALIGN=D,CLASS=3
STPX     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=1,                      *
               ALIGN=F,CLASS=3
SU       OPCD      OP=7F,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SUR      OPCD      OP=3F,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SVC      OPCD      OP=0A,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
SW       OPCD      OP=6F,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SWPR     OPCD      OP=A3,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=YES
SWR      OPCD      OP=2F,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SX       OPCD      OP=77,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SXR      OPCD      OP=37,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
TCH      OPCD      OP=9F,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
TIO      OPCD      OP=9D,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
TIOB     OPCD      OP=9A,TYPE=MACH,IS=20,                              *
               ALIGN=H,CLASS=2,LIT1=YES
TITLE    OPCD      OP=18,                                              *
               TYPE=ASSEM
TM       OPCD      OP=91,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2,LIT1=YES
TR       OPCD      OP=DC,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
TRT      OPCD      OP=DD,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES
TS       OPCD      OP=93,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
UNPK     OPCD      OP=F3,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
USING    OPCD      OP=23,TYPE=ASSEM,NAME=NO,OPND=YES,                  *
               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES
WRD      OPCD      OP=84,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2,LIT1=YES
WRDW     OPCD      OP=B4,TYPE=MACH,IS=44,                              *
               ALIGN=F,CLASS=2,LIT1=YES
WXTRN    OPCD      OP=2E,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
X        OPCD      OP=57,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
XC       OPCD      OP=D7,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
XI       OPCD      OP=97,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
XIO      OPCD      OP=D0,TYPE=MACH,IS=20,                              *
               ALIGN=C,CLASS=2
XR       OPCD      OP=17,TYPE=MACH,                                    *
               CLASS=0
ZAP      OPCD      OP=F8,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
         EJECT
         OPCDGEN
         SPACE     2
         END       ASMGF7X
./ ADD NAME=ASMGF7Y  0103-88330-88334-0733-01688-01687-00411-CHSY227
F7X      TITLE     'ASMG F7  GET STATEMENT ROUTINE (TXGET)'
         ISEQ  73,78
         MACRO
         TRANSLAT
         GBLA      &EBDIC(64),&NUMCHAR,&VALUE
         GBLC      &CHARSET(64),&CHAR
         LCLA      &I
&I       SETA      0
.ADDR10  ANOP
&I       SETA      &I+1
         AIF   ('&CHAR'(1,1) EQ '&CHARSET(&I)'(1,1)).ADDR20
         AIF       (&I LT &NUMCHAR).ADDR10
&VALUE   SETA      0
         AGO       .END
.ADDR20  ANOP
&VALUE   SETA      &EBDIC(&I)
.END     MEND
         MACRO
&LABEL   OPCD  &OP=XX,                                                 X
               &TYPE=MACH,             ASSEM,EXTEN,                    X
               &ILLGEN=NO,             YES,                            X
               &NAME=,                 YES,NO,                         X
               &OPND=,                 YES,NO,                         X
               &IS=,                                                   X
               &MASK=,                 ONLY IF EXTEN,                  X
               &ALIGN=C,               H,F,D,               *          X
               &CLASS=,                0,1,2,3,             *          X
               &EVEN=NO,               YES,DOUBLE,          *ONLY      X
               &FLOAT=NO,              YES,                 *FOR       X
               &LIT1=NO,               YES,                 *MACHINE   X
               &LIT23=NO,              YES                  *TYPES     X
               &F7XREF=NO,             YES,       *ONLY                X
               &F8UPC=NO,              YES,       *FOR                 X
               &LCR=NO,                YES,       *ASSEM               X
               &STE=NO,                YES,       *TYPES               X
               &SUB=NO,                YES,       *                    X
               &UPC=NO                 YES        *
         GBLA      &VALUE,&GLENLAB(400),&GTXTO(400),&GTXASC(400)
         GBLA      &GDIM,&ERROR,&FIRST
         GBLB      &RPQ67,&SYM370
         GBLC      &CHAR,&LASTLAB
         GBLC      &GLABEL(400),&GOP(400)
         LCLA      &S1,&TDIM,&W1
         LCLC      &WC
.*                 CHECK IF THIS IS FIRST TIME IN
         AIF       (&FIRST NE 0).SKIP01
         DEFCHAR
&FIRST   SETA      1
.SKIP01  ANOP
&WC      SETC      '&LABEL'.'       '(1,8)
         MNOTE *,'WC = ''&WC'''
         AIF       ('&WC' GT '&LASTLAB').SKIP02
         MNOTE     1,'OPCD -- OPCODE LABEL &LABEL OUT OF ALPHA ORDER'
.SKIP02  ANOP
&LASTLAB SETC      '&WC'
.*                 DETERMINE IF OPCODE IN THIS SET
         AIF       ('&IS' EQ '').OPOK
&W1      SETA      N'&IS
         AIF       (&W1 EQ 1).SINGTST
.SKIP03  AIF       ('&IS(&W1)' NE '67').TST70
         AIF       (&RPQ67).OPOK
         AGO       .TSTEND
.TST70   AIF       ('&IS(&W1)' NE '70').OPOK
         AIF       (&SYM370).OPOK
.TSTEND  ANOP
&W1      SETA      &W1-1
         AIF       (&W1 GT 0).SKIP03
         AGO       .NOTGEND
.SINGTST ANOP
.*                 TEST IF MOD 67 RPQ INSTRUCTION
         AIF       (('&IS' EQ '67') AND (NOT &RPQ67)).NOTGEND
.*                 TEST IF 370 INSTRUCTION
         AIF       (('&IS' EQ '70') AND (NOT &SYM370)).NOTGEND
.OPOK    ANOP
.*                 SET LABEL AND OPCODE
&TDIM    SETA      &GDIM+1
&W1      SETA      K'&LABEL
         AIF       (&W1 EQ 0).MNOTE1
&GLENLAB(&TDIM) SETA &W1
&GLABEL(&TDIM) SETC '&LABEL'
         AIF       ('&OP' EQ 'XX').MNOTE5
&GOP(&TDIM) SETC '&OP'
.*                 CHECK THE INSTRUCTION TYPE
         AIF       ('&TYPE' NE 'ASSEM').TXTO1
&S1      SETA      X'80'
         AGO       .TXTOF
.TXTO1   AIF       ('&TYPE' NE 'MACH').TXTO2
&S1      SETA      X'40'
         AGO       .TXTOF
.TXTO2   AIF       ('&TYPE' NE 'EXTEN').MNOTE2
&S1      SETA      X'60'
.TXTOF   ANOP
.*                 IS OPCODE ILLEGAL IF GENNED .Q
         AIF       ('&ILLGEN' EQ 'NO').TXRM0
         AIF       ('&TYPE' NE 'ASSEM').MNOTE9
&S1      SETA      &S1+X'20'
.*                 NAME REQUIRED OR NOT ALLOWED
.TXRM0   AIF       ('&TYPE' EQ 'EXTEN').TXRM7
         AIF       ('&NAME' EQ '').TXRM3
         AIF       ('&NAME' NE 'YES').TXRM2
&S1      SETA      &S1+X'08'
         AGO       .TXRM3
.TXRM2   AIF       ('&NAME' NE 'NO').MNOTE3
&S1      SETA      &S1+X'04'
.*                 OPERAND REQUIRED OR NOT ALLOWED
.TXRM3   AIF       ('&OPND' EQ '').TXRM8
         AIF       ('&OPND' NE 'YES').TXRM5
&S1      SETA      &S1+X'02'
         AGO       .TXRM8
.TXRM5   AIF       ('&OPND' NE 'NO').MNOTE4
&S1      SETA      &S1+X'01'
         AGO       .TXRM8
.*                 SET EXTEN MASK
.TXRM7   ANOP
         AIF       ('&MASK' EQ '').MNOTE6
&W1      SETA      K'&MASK
&CHAR    SETC      '&MASK'(&W1,1)
         TRANSLAT
&S1      SETA      &S1+&VALUE
.TXRM8   ANOP
&GTXTO(&TDIM) SETA &S1
.*                 TEST IF ASSEM OR NOT
&S1      SETA      0
         AIF       ('&TYPE' NE 'ASSEM').MACH1
         AIF       ('&UPC' EQ 'NO').ASSEM1
&S1      SETA      &S1+X'80'
.ASSEM1  AIF       ('&STE' EQ 'NO').ASSEM2
&S1      SETA      &S1+X'40'
.ASSEM2  AIF       ('&LCR' EQ 'NO').ASSEM3
&S1      SETA      &S1+X'20'
.ASSEM3  AIF       ('&F7XREF' EQ 'NO').ASSEM4
&S1      SETA      &S1+X'10'
.ASSEM4  AIF       ('&SUB' EQ 'NO').ASSEM5
&S1      SETA      &S1+X'08'
.ASSEM5  AIF       ('&F8UPC' EQ 'NO').SET1
&S1      SETA      &S1+X'01'
         AGO       .SET1
.*                 MACHINE OR EXTEN INSTRUCTION
.MACH1   AIF       ('&FLOAT' EQ 'NO').MACH2
&S1      SETA      &S1+X'80'
.MACH2   AIF       ('&EVEN' EQ 'NO').MACH3
         AIF       ('&EVEN' EQ 'DOUBLE').MACH3
&S1      SETA      &S1+X'40'
.MACH3   AIF       ('&ALIGN' EQ 'C').MACH6
         AIF       ('&ALIGN' NE 'H').MACH4
&S1      SETA      &S1+X'10'
         AGO       .MACH6
.MACH4   AIF       ('&ALIGN' NE 'F').MACH5
&S1      SETA      &S1+X'20'
         AGO       .MACH6
.MACH5   AIF       ('&ALIGN' NE 'D').MNOTE7
&S1      SETA      &S1+X'30'
.MACH6   ANOP
         AIF       ('&CLASS' EQ '').MNOTE8
&W1      SETA      &CLASS
         AIF       (&W1 GT 3 OR &W1 LT 0).MNOTE8
&S1      SETA      &S1+&W1*4
         AIF       ('&LIT23' EQ 'NO').MACH7
&S1      SETA      &S1+X'02'
.MACH7   AIF       ('&LIT1' EQ 'NO').SET1
&S1      SETA      &S1+X'01'
.*                 SET TXASC BYTE
.SET1    ANOP
&GTXASC(&TDIM) SETA &S1
&GDIM    SETA      &GDIM+1
         MEXIT
.NOTGEND MNOTE     *,'OPCD  --  OPCODE NOT GENERATED IS= &IS'
         AGO       .MEND
.*                 THESE ARE THE ERRORS
.MNOTE1  MNOTE     4,'OPCD -- MISSING LABEL'
         AGO       .MENDERR
.MNOTE2  MNOTE     4,'OPCD -- INVALID TYPE=&TYPE'
         AGO       .MENDERR
.MNOTE3  MNOTE     4,'OPCD -- INVALID NAME=&NAME'
         AGO       .MENDERR
.MNOTE4  MNOTE     4,'OPCD -- INVALID OPND=&OPND'
         AGO       .MENDERR
.MNOTE5  MNOTE     4,'OPCD -- MISSING &&OP KEYWORD'
         AGO       .MENDERR
.MNOTE6  MNOTE     4,'OPCD -- MISSING &&MASK FOR EXTEN'
         AGO       .MENDERR
.MNOTE7  MNOTE     4,'OPCD -- INVALID ALIGN=&ALIGN'
         AGO       .MENDERR
.MNOTE8  MNOTE     4,'OPCD -- INVALID CLASS=&CLASS'
         AGO       .MENDERR
.MNOTE9  MNOTE     4,'OPCD  --  ILLGEN=&ILLGEN INVALID WITH TYPE=&TYPE'
         AGO       .MENDERR
.MENDERR ANOP
&ERROR   SETA      &ERROR+1
.MEND    MEND
         SPACE     2
         MACRO
         OPCDGEN
         GBLA      &GLENLAB(400),&GTXTO(400),&GTXASC(400)
         GBLA      &GDIM,&ERROR,&FIRST,&VALUE
         GBLC      &GLABEL(400),&GOP(400),&CHAR
         LCLA      &I,&J,&W,&OPLX,&OPPT(400)
         LCLC      &C(8),&WC
         ACTR      100000
         AIF       (&FIRST EQ 0 OR &GDIM LE 1 OR &ERROR GT 0).MNOTE1
.LOOP0   ANOP
&I       SETA      &I+1
&OPPT(&I) SETA     &I
         AIF       (&I LT &GDIM).LOOP0
&I       SETA      0
.*                 BUBBLE SORT OPCODES BY NAME AND LENGTH
.LOOP1   ANOP
&I       SETA      &I+1
&J       SETA      &I
.LOOP2   ANOP
&J       SETA      &J+1
         AIF       ('&GLABEL(&I)' LT '&GLABEL(&J)').LOOP3
&W       SETA      &OPPT(&I)
&WC      SETC      '&GLABEL(&I)'
&OPPT(&I) SETA     &OPPT(&J)
&GLABEL(&I) SETC   '&GLABEL(&J)'
&OPPT(&J) SETA     &W
&GLABEL(&J) SETC   '&WC'
.LOOP3   AIF       (&J LT &GDIM).LOOP2
         AIF       (&I LT (&GDIM-1)).LOOP1
.*                 OUTPUT RESULTS
&I       SETA      0
.OUTLP1  ANOP
&I       SETA      &I+1
&J       SETA      &OPPT(&I)
&W       SETA      0
         AIF       (&GLENLAB(&J) EQ &OPLX).OUTLP2
&OPLX    SETA      &GLENLAB(&J)
OPL&OPLX EQU       *
.*                 TRANSLATE OPCODE TO INTERNAL CODE
.OUTLP2  ANOP
&W       SETA      &W+1
&CHAR    SETC      '&GLABEL(&I)'(&W,1)
&C(&W)   SETC      'I&CHAR,'
         AIF       (&W LT &OPLX).OUTLP2
&WC      SETC      '##'.'&GLABEL(&I)'
&WC      DC        AL1(&C(1)&C(2)&C(3)&C(4)&C(5)&C(6)&C(7)&C(8)&GTXTO(&*
               J)),X'&GOP(&J)',AL1(&GTXASC(&J))
         AIF       (&I LT &GDIM).OUTLP1
OPFN     EQU       *
         AGO       .MEND
.MNOTE1  MNOTE     8,'OPCDGEN -- OPCD MACROS FAILED'
         MNOTE     8,'OPCDGEN -- YOU LOSE ...... AGAIN'
.MEND    MEND
         SPACE     2
         COPY  ASMGSET
         EJECT
ASMGF7X  START
         SPACE
         PRINT DATA,NOGEN
         FDIMEN
         PRINT     ON,GEN
         SPACE 2
*                                                                     *
*TITLE ASMGF7X  F7 GET STATEMENT ROUTINE                              *
*FUNCTION/OPERATION-                                                  *
*   MOVE EDITED TEXT RECORDS FROM TEXT INPUT STREAM TO TEXT WORK AREA *
*   INSERT PROCESSED RECORDS FROM WORK AREA INTO TEXT STREAM          *
*   INSERT ERROR RECORDS INTO TEXT STREAM                             *
*   MOVE LITERAL RECORDS INTO WORK AREA, FROM SYMBOL TABLE            *
*   CONVERT 'EDITED-GENERATED' TYPE RECORDS TO FORM SUITABLE FOR F7   *
*   PROCESSING                                                        *
*   SET POINTERS TO THE OPERAND FIELD AND SYMBOL WORK BUCKETS         *
*   APPEND FIXED FIELD TO TEXT RECORD                                 *
*   APPEND LITERAL WORK BUCKETS FOR LITERALS IN OPERAND               *
*   TEST LEGALITY OF STATEMENT FIELDS-                                *
*        NAME FIELD IS TESTED FOR LEGAL CHARACTERS, TOO MANY CHAR-    *
*         ACTERS, AND LEADING CHARACTER ALPHABETIC                    *
*        ASSEMBLER OPERATIONS ARE TESTED FOR NAME FIELD AND/OR OPERAND*
*         FIELD REQUIRED OR NOT ALLOWED                               *
*ENTRY POINT-                                                         *
*   ASMGF7X...FIRST CALL ONLY                                         *
*   TXGET1...AFTER FIRST CALL                                         *
*        CALLING SEQUENCE-                                            *
*        L     FRB,CTXGET(ACT)                                        *
*        BALR  CRR,ACT                                                *
*   THE CODE AT ENTRY POINT ASMGF7X INSERTS THE ADDRESS OF TXGET1 INTO*
*    CTXGET (ACT)...SUBSEQUENT CALLS ENTER AT TXGET1                  *
*INPUT-                                                               *
*   REGISTER ACT CONTAINS ADDRESS OF ASSEMBLER CONTROL TABLE          *
*   TEXT WORK AREA CONTAINS PROCESSED RECORD                          *
*OUTPUT-                                                              *
*   REGISTER GRA CONTAINS FBA OF TEXT RECORD                          *
*   REGISTER GRB CONTAINS ADDRESS OF TEXT APPENDED FIXED FIELD        *
*   REGISTER GRC CONTAINS ADDRESS OF TEXT OPERAND LENGTH FIELD        *
*EXTERNAL ROUTINES-                                                   *
*   PUTXT...IN ASMGF7I..PUT OUT TEXT RECORD                           *
*   GETPT...IN ASMGF7I..GET POINTER TO NEXT TEXT RECORD               *
*   CLSTXT..IN ASMGF7I..TCLOSE TEXT FILES                             *
*   GETXTM..IN ASMGF7I..GET TEXT AND MOVE RECORD                      *
*   CLOGER..IN ASMGF7I..GENERATE, OR ADD TO, ERROR RECORDS            *
*EXIT-                                                                *
*   BRANCH TO CTRTRN(ACT), RETURN LINKAGE ALGORITHM IN ASSEMBLER      *
*    CONTROL TABLE                                                    *
*                                                                     *
         ENTRY OPC04                    FOR OPSYN REFERENCE
         EJECT
         USING TXGET0,FRB               BASE FOR FIRST ENTRY
         SPACE
TXGET0   L     GRA,CTXWAP(ACT)          FIND TEXT WORK AREA
         ST    GRA,CTEXTP(ACT)          SET TEXT POINTER
         ST    GRA,CTSAVE(ACT)          IN ASSMBLR CNTRL TABLE, TOO
         LA    FRB,TXGET1-TXGET0(FRB)   INCREMENT BASE REGISTER...
         ST    FRB,CTXGET(ACT)          AND ALTER ENTRY ADDRESS IN ACT
         USING TXGET1,FRB               CHANGE OF BASE
         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q
         BO    TXGET3                   YES, FIRST TIME SO DON'T 'PUT'
         OI    ##CNOP+4,BIT5            CNOP LABEL INVALID
         OI    ##COM+3,BIT5             COM LABEL INVALID
         OI    ##DROP+4,BIT6            DROP OPERAND REQUIRED
         OI    ##DSECT+5,BIT4           DSECT LABEL REQUIRED
         OI    ##ORG+3,BIT5             ORG LABEL INVALID
         B     TXGET3                   FIRST TIME, DONT 'PUT'
         SPACE 2
* ERRORS DETECTED BY TXGET
         SPACE
TXGERR00 EQU   84                       GENERATED OPERAND FORMAT ERROR
         SPACE
TXGERR12 EQU   34                       OP CODE INVALID
TXGERR13 EQU   32                               ILLEGAL IF GEN.
TXGERR14 EQU   88                               UNDEFINED
         SPACE
TXGERR20 EQU   73                       AOP NAME REQUIRED
TXGERR21 EQU   73                           NAME NOT ALLOWED
TXGERR22 EQU   39                       OPERAND REQUIRED
TXGERR23 EQU   36                           OPERAND NOT ALLOWED
         SPACE
TXGERR30 EQU   16                       INVALID NAME
         SPACE 2
* BIT MASKS
         SPACE
BIT0     EQU   X'80'                    MASKS USED...
BIT1     EQU   X'40'                    TO TEST...
BIT2     EQU   X'20'                    OR SET...
BIT3     EQU   X'10'                    INDIVIDUAL...
BIT4     EQU   X'08'                    BITS...
BIT5     EQU   X'04'                    WITHIN...
BIT6     EQU   X'02'                    A...
BIT7     EQU   X'01'                    BYTE...
         EJECT
* ENTER FROM MAIN-LINE WITH PROCESSED RECORD IN TEXT WORK AREA
         SPACE 2
TXGET1   DS    0H
         LR    SP1,GRA                  PUT RECORD FROM TEXT WORK AREA
         SPACE
TXGET2   DS    0H
         SR    SP2,SP2                  PUT RECORD ONTO TEXT-OUT BUFFER
         L     SRB,CTXTIO(ACT)          FROM TEXT WORK AREA, TEXT-IN,
         BAL   SRR,PUTXT(SRB)           OR ERROR RECORD BUILD AREA
         SPACE
         CLI   ERSWH(ACT),0             TEST ERROR SWITCH
         BE    TXGET3                   OFF
         MVI   ERSWH(ACT),0             IF ERROR SWITCH SET,
         L     SP1,CTERRP(ACT)          CLEAR SWITCH,
         B     TXGET2                   AND PUT REC FROM ERROR WRK AREA
         SPACE
TXGET3   DS    0H
         CLI   CTLIT2(ACT),0            TEST LIT GEN SWITCH
         BE    TXGET4                   OFF
         BAL   GRD,TXGLIT               ON, GET NEXT REC FROM LIT POOL
         B     TXGETA                   THEN GO TEST TYPE OF OPERATION
         SPACE
TXGET4   DS    0H
         L     SRB,CTXTIO(,ACT)         GET POINTER TO NEXT TEXT RECORD
         BAL   SRR,GETPT(SRB)
         BNZ   TXGET5                   NOT EOF
         SPACE
*********EOF***********************************************************
         MVC   0(L'TXGQUIT,GRA),TXGQUIT  EOF, MOVE QUIT REC TO WRK AREA
         B         TXGETA
         SPACE
TXGQUIT  DS    0CL18
         DC    AL2(TXGQUIT0-*),X'50802A00',AL2(TXGQUIT0-TXGQUIT-TXFAFL)
         DC    X'000001',AL1(IBLANK),(TXFAFL+1)X'00'
TXGQUIT0 EQU   *
***********************************************************************
         SPACE
TXGET5   DS    0H
         L     GR1,CTSEQN(ACT)
         LA    GR1,1(GR1)
         TM    TXRT(SP1),BIT1           TEST RECORD TYPE
         BO    TXGET10                  EDITTED
         SPACE
         TM    TXRT(SP1),BIT2           NOT EDITTED,
         BO    TXGET6                   STEP SEQUENCE NUMBER
         TM    TXRT(SP1),BIT3           IF TXRT EQ 000, 010 OR 011
         BO    TXGET7                   AND CONTINUATION BIT NOT SET
TXGET6   DS    0H
         TM    2(SP1),BIT6
         BO    TXGET7
         ST    GR1,CTSEQN(ACT)
         SPACE
TXGET7   DS    0H
         SR    SP1,SP1                  PUT RECORD FROM INPUT BUFFER
         B     TXGET2                   GO PUT RECORD OUT
         EJECT
* PROCESS EDITTED TEXT RECORD
         SPACE 2
TXGET10  DS    0H
         TM    TXRT(SP1),BIT2+BIT3      STEP SEQUENCE NUMBER
         BC    14,TXGET11               IF TXRT EQ 111
         ST    GR1,CTSEQN(ACT)
         SPACE
TXGET11  DS    0H
         L     SRB,CTXTIO(,ACT)         MOVE EDITED RECORD
         LR    SP1,GRA                  TO TEXT WORK AREA
         BAL   SRR,GETXTM(SRB)          ASMGF7I GET TEXT AND MOVE
         SPACE
         SPACE
         BAL   SRR,TXGETSET             SET FIELD POINTERS
         SPACE
         LR    GR1,GRB                  SET TXABP,
         SR    GR1,GRA                  INC REC LENGTH,
         STH   GR1,TXABP(GRA)           CLEAR APPENDED FIXED FIELD
         LH    GR1,TXRL(GRA)
         LA    GR2,0(GRA,GR1)
         MVI   0(GR2),0
         MVC   1(11,GR2),0(GR2)
         LA    GR1,TXFAFL(GR1)
         STH   GR1,TXRL(GRA)
         SPACE
         TM    TXRT(GRA),BIT2           TEST FOR SUBSTITUTED FIELDS
         BZ    TXGET13                  IF RECORD TYPE EQ 110 OR 111
         BAL   GRD,TXGEDIT              EDIT SUBSTITUTED FIELDS
         TM    TXTO(GRA),BIT0+BIT1      SEE IF AOP OR MACH OP ALREADY
         BNZ   TXGET13                  YES, NOT 'UNCHECKED', TEST NAME
         BAL   GRD,OPCCF                CONVERT OP CODE
         SPACE
TXGET13  DS    0H
         BAL   GRD,TXGNAME              TEST FOR LEGAL NAME FIELD
         TM    TXTO(GRA),BIT1           MAYBE MACH OP
         BO    TXGET14                  YES, GO TEST FOR LITERAL
         BAL   GRD,TXGOPND              IF ASSEMBLER OP, TEST OPERAND
         CLI   TXHEX(GRA),X'20'         TEST IF ORG
         BNE   TXGETRTN                 BRANCH IF NOT
         LH    GR1,TXRL(,GRA)           GET RECORD LENGTH
         LA    GR1,3(,GR1)              EXTEND BY 3 BYTES
         STH   GR1,TXRL(,GRA)           SAVE IT BACK AGAIN
         B     TXGETRTN                 GO SET OPERAND POINTERS
         SPACE
TXGET14  DS    0H
         BAL   GRD,SCANLIT              IF MACHINE OP, TEST FOR LITERAL
         SPACE
TXGETRTN DS    0H
         ST    GRC,CTXOFP(,ACT)         SET POINTERS TO OPERAND
         ST    GRB,CTXABP(ACT)          AND APPENDED FIXED FIELD
         ST    GRB,CTSAVE+4(ACT)        IN CONTROL TABLE
         B     CTRTRN(ACT)              RETURN TO MAIN-LINE
         EJECT
*
         SPACE 2
TXGETA   DS    0H
         TM    TXTO(GRA),BIT0+BIT1      TEST TYPE OF OPERATION
         BZ    TXGET1                   BYPASS IF ZERO
         SPACE
         BAL   SRR,TXGETSET             SET FIELD POINTERS
         SPACE
         LR    GR1,GRA                  FBA OF TEXT RECORD PLUS...
         AH    GR1,TXRL(GRA)            RECORD LENGTH, IS END OF RECORD
         LA    GR2,TXFAFL(GRB)          LOOK PAST APPENDED FIXED FIELD
TXGETB   DS    0H
         CLR   GR2,GR1                  THAT MAY BE END OF RECORD
         BNL   TXGETRTN                 YES, GO SET POINTERS TO OPND
         TM    TXWTYP(GR2),BIT0         NO, HAVE WB...CHECK TYPE
         BO    TXGETD                   SYMB WB, GO SET POINTER IN ACT
         TM    TXWLEN(GR2),BIT1         TEST WB LENGTH
         BZ    TXGETC                   LENGTH 6, SKIP THE 9-BUMP
         LA    GR2,9(,GR2)              STEP WB POINTER AS MUCH...
TXGETC   DS    0H
         LA    GR2,6(,GR2)              AS NEEDED TO GET PAST THIS WB
         B     TXGETB                   GO SEE IF THERE IS ANOTHER WB
TXGETD   DS    0H
         ST    GR2,CTXWBP(,ACT)         SET POINTER TO FIRST SYMB WB
         B     TXGETRTN                 GO SET OPERAND POINTERS
         EJECT
* SUBROUTINE TO SET FIELD POINTERS
*  GRA CONTAINS FIRST BYTE ADDRESS OF TEXT RECORD
         SPACE 2
TXGETSET DS    0H
         SR    GR1,GR1                  ZERO WORK REGISTER
         ST    GR1,CTXWBP(ACT)          CLEAR WORK BUCKET POINTER
         IC    GR1,TXNAML(GRA)          NAME FIELD LENGTH PLUS...
         LA    GRC,TXNAME(GR1,GRA)      NAME FIELD DISPLACEMENT PLUS...
         IC    GR1,TXOPL(GRC)           OPERATION LENGTH, PLUS OP...
         LA    GRC,TXOP(GR1,GRC)        DISP= OPERAND DISP-1 IN GRC
         IC    GR1,TXOPNL(GRC)          GET OPERAND LENGTH PLUS...
         LA    GRB,TXOPN(GR1,GRC)       OPERAND DISP (FROM GRC)...
         IC    GR1,TXCOML(GRB)          ADD COMMENT LENGTH AND DISP...
         LA    GRB,TXCOM(GR1,GRB)       TO LEAVE GRB AT APPNDED FIX FLD
         BR    SRR                     RETURN
         EJECT
* SCAN MACHINE OP FOR LITERAL IN OPERAND
         SPACE 2
SCANLIT  DS    0H
         MVC   CTWORK(256,ACT),CTWORK-1(ACT) CLEAR THE TRT TABLE
         MVI   CTWORK+IQUOTE(ACT),X'FF'       STOPPER FOR QUOTES
         SR    GRX,GRX                  GET READY TO COUNT
         IC    GRX,TXOPNL(GRC)          PICK UP OPERAND LENGTH
         LA    GRX,TXOPNL(GRC,GRX)      ADDRESS OF LAST OPERAND BYTE...
         BCTR  GRX,0                    MINUS ONE
         LR    GR1,GRC                  ADDRESS OF FIRST OPND BYTE-1
         SPACE
SCANLIT1 DS    0H
         XI    CTWORK+IEQUAL(ACT),X'FF'      RESET STOPPER FOR EQUAL
         SPACE
SCANLIT2 DS    0H
         LR    GR2,GRX                  END OPERAND-1
         SR    GR2,GR1                  FIND HOW FAR TO END OF OPND FLD
         BCR   4,GRD                    DONE, RETURN TO CALLING ROUT.
         EX    GR2,SCANLITT             GR2 IS ONE LOW, FOR TRT USE
         BCR   8,GRD                    NO STOPPER, RETURN TO CALLER
         CLI   0(GR1),IEQUAL            SEE IF STOPPED ON EQUAL SIGN...
         BE    SCANLITF                 YES, GO WORK ON LITERAL...
         CLI   CTWORK+IEQUAL(ACT),0     NO, SEE IF WE COULD HAVE
         BE    SCANLIT1                 NO, END OF QUOTE STRING..RESET
         LR    GR2,GR1                  ADDRESS OF QUOTE
         BCTR  GR2,0                    BACK ONE BYTE
         CLR   GR2,GRC                  MAY HAVE STOPPED ON FIRST BYTE
         BE    SCANLIT1                 YES, START OF QUOTE-STRING
         CLI   0(GR2),IL                MAY BE L-QUOTE
         BNE   SCANLIT1                 NO, START OF QUOTE-STRING
         B     SCANLIT2                 YES, QUOTE UNPAIRED...NO RESET
         SPACE
SCANLITF DS    0H
         LH    GR2,TXRL(,GRA)           INCREMENT REC LENGTH
         LA    GR2,6(GR2)
         STH   GR2,TXRL(GRA)
         MVC   TXFAFL(6,GRB),CTZERO(ACT) CLEAR LITERAL WORK BUCKET
         SPACE
         SR    GR1,GRC                  SET RELATIVE POINTER TO EQ SIGN
         BCTR  GR1,0                    MAKE UP FOR OFFSET
         STC   GR1,TXLSTG(GRB)          LEAVE IT IN WRK BKT
         CLI   TXLSTG(GRB),0            SEE IF = WAS FIRST BYTE
         BE    SCANLITG                 YES, GO SET EQUAL SIGN IND
         AR    GR1,GRC                  NO, GET ADDRESS OF PREVIOUS BYT
         CLI   0(GR1),ICOMMA            MAYBE WAS COMMA
         BCR   7,GRD                    NO, RETURN
         SPACE
SCANLITG DS    0H
         OI    TXESI(GRA),BIT6          SET EQUAL SIGN INDICATOR
         BR    GRD                      RETURN
         SPACE
SCANLITT TRT   1(*-*,GR1),CTWORK(ACT)
         EJECT
* SUBROUTINE TO TEST FOR LEGAL AND VALID NAME FIELD
         SPACE 2
TXGNAME  DS    0H
         TM    TXTO(GRA),BIT0           IS THIS TYPE ASSEM .Q
         BZ    TXGNAME2                 BRANCH IF NOT
         LA    SRR,TXGNONE              LOAD BRANCHING ADDRESS
         CLI   TXHEX(GRA),X'29'         IS THIS CNOP .Q
         BE    TXGCNOP                  BRANCH IF YES
         CLI   TXHEX(GRA),X'1E'         IS THIS COM .Q
         BE    TXGCOM                   BRANCH IF YES
         CLI   TXHEX(GRA),X'24'         IS THIS DROP .Q
         BE    TXGDROP                  BRANCH IF YES
         CLI   TXHEX(GRA),X'1D'         IS THIS DSECT .Q
         BE    TXGDSECT                 BRANCH IF YES
         CLI   TXHEX(GRA),X'20'         IS THIS ORG .Q
         BCR   7,SRR                    THAT'S ALL IF NOT
         MVN   TXR1M(1,GRA),##ORG+3     RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGDSECT DS    0H
         MVN   TXR1M(1,GRA),##DSECT+5   RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGDROP  DS    0H
         MVN   TXR1M(1,GRA),##DROP+4    RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGCOM   DS    0H
         MVN   TXR1M(1,GRA),##COM+3     RESET SPECIAL SWITCHES
         BR    SRR                      AND CONTINUE
TXGCNOP  DS    0H
         MVN   TXR1M(1,GRA),##CNOP+4    RESET SPECIAL SWITCHES
TXGNONE  DS    0H
         CLI   TXNAML(GRA),0            AOP, MAY HAVE NAME
         BE    TXGNAME0                 NO, GO SEE IF REQUIRED
         SPACE
         TM    TXR1M(GRA),BIT5          NAME PRESENT, TEST IF ALLOWED
         BO    TXGNAME1                 NOT ALLOWED, LOG ERROR
         CLI   TXHEX(GRA),X'18'         IS AOP 'TITLE'
         BNE   TXGNAME3                 NO, GO TEST NAME VALIDITY
         BR    GRD                      YES, RETURN
         SPACE
TXGNAME0 DS    0H
         TM   TXR1M(GRA),BIT4           NAME MISSING, TEST IF REQUIRED
         BCR   8,GRD                    NOT REQUIRED
         SPACE
TXGNAME1 DS    0H
         BAL   SRR,ERROR0               LOG ERROR
         DC    AL2(TXGERR20)            'ILLEGAL NAME FIELD'
         B     TXGNAME6                 SET BAD NAME INDICATOR
         SPACE 2
TXGNAME2 DS    0H
         CLI   TXNAML(GRA),0            TEST VALID NAME
         BCR   8,GRD                    NO NAME, RETURN
         SPACE
TXGNAME3 DS    0H
         CLI   TXNAML(GRA),8            TOO MANY CHARACTERS, NON A/N,
         BH    TXGNAME5                 NON ALPHA FIRST CHARACTER
         SPACE
         SR    GR1,GR1                  READY TO COUNT
         IC    GR1,TXNAML(GRA)          GET NAME FIELD LENGTH
TXGNAME4 DS    0H
         LA    GR2,TXNAML(GRA,GR1)      START AT END OF NAME
         CLI   0(GR2),IALPHA            CHECK FOR ALPHA-NUMERICS
         BH    TXGNAME5                 SPECIAL CHARACTER, GO LOG ERROR
         BCT   GR1,TXGNAME4             REPEAT, WORKING TO FIRST BYTE
         CLI   TXNAME(GRA),9            SEE IF FIRST BYTE IS ALPHA
         BCR   2,GRD                    YES, OK TO RETURN
         SPACE
TXGNAME5 DS    0H
         BAL   SRR,ERROR0               LOG ERROR (INVALID NAME)
         DC    AL2(TXGERR30)            'INVALID NAME'
         SPACE
TXGNAME6 DS    0H
         OI    TXMDN(GRA),BIT3          SET BAD NAME INDICATOR
         BR    GRD                      AND RETURN
         EJECT
* SUBROUTINE TO TEST FOR LEGAL OPERAND FIELDS
         SPACE 2
TXGOPND  DS    0H
         TM    TXR1M(GRA),BIT6+BIT7     SEE IF OPERAND IS OPTIONAL
         BCR   8,GRD                    YES, MAY AS WELL RETURN
         CLI   TXOPN(GRC),IBLANK        LOOK FOR END OF OPND FIELD
         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND
         CLI   TXOPN(GRC),ICOMMA        MAY BE OMITTED OPERAND
         BE    TXGOPND0                 YES, GO SEE IF WE NEED OPND
         CLI   TXOPNL(GRC),0            ANOTHER WAY TO OMIT OPND
         BNE   TXGOPND1                 HAVE OPND, SEE IF THAT'S OK
         SPACE
TXGOPND0 DS    0H
         TM    TXR1M(GRA),BIT6          OPERAND MISSING
         BCR   8,GRD                    LOG ERROR IF REQUIRED
         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE
         DC    AL2(TXGERR22)            'INVALID DELIMITER'
         B     ABORT                    ABORT PROCESSING
         SPACE
TXGOPND1 DS    0H
         TM    TXR1M(GRA),BIT7          OPERAND PRESENT
         BCR   8,GRD                    LOG ERROR IF NOT ALLOWED
         BAL   SRR,ERROR0               TO ERROR LOGGING ROUTINE
         DC    AL2(TXGERR23)            'OPERAND FIELD MUST BE BLANK'
         BR    GRD                      RETURN
         EJECT
* EDIT SUBSTITUTED FIELDS
         SPACE 2
TXGEDIT  DS    0H
         SR    GRZ,GRZ                  START FRESH...COUNTS BLANKS
         LH    GRY,TXRL(GRA)            LET TXGEDL MOVE ALL OF RECORD
         LR    SP1,GRC                  POINT TO OPND LENGTH FIELD
         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPND
         SPACE
         SR    SP1,SP1                  READY TO COUNT
         IC    SP1,TXNAML(GRA)          USE LENGTH OF NAME FIELD...
         LA    SP1,TXNAME(GRA,SP1)      TO POINT TO OPERATION LENGTH
         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF OPER'N
         BAL   SRR,TXGEDL               EDIT LEADING BLANKS OF OPERAT'N
         SPACE
         LA    SP1,TXNAML(GRA)          POINT TO NAME LENGTH FIELD
         BAL   SRR,TXGEDT               EDIT TRAILING BLANKS OF NAME
         LTR   GRZ,GRZ                  TEST THE 'BLANK' COUNTER
         BZ    TXGEDITA                 NONE REMOVED, GO TEST IMBEDDED
         SR    GRY,GRZ                  ADJUST REC. LENGTH FOR BLANKS
         STH   GRY,TXRL(GRA)            AND UPDATE TXRL
         BAL   SRR,TXGETSET             THEN RESET THE FIELD POINTERS
         LR    GR1,GRB                  ADDRESS OF APP. FIXED FIELD
         SR    GR1,GRA                  LESS ADDRESS OF TEXT BEGIN
         STH   GR1,TXABP(GRA)           RELATIVE POS'N OF APP. FIXED F
         SPACE
TXGEDITA DS    0H
         LR    SP1,GRC                  GET OPND LENGTH FIELD ADDRESS
         SR    SP2,SP2                  READY
         IC    SP2,TXOPNL(SP1)          OPND LENGTH TO SP2
         LTR   GRX,SP2                  MIGHT NOT BE ANY OPERAND
         BCR   8,GRD                    IF NONE, RETURN
         SPACE
TXGEDITB DS    0H
         LA    SP1,1(,SP1)              CHOOSE AN OPERAND BYTE
         CLI   0(SP1),IBLANK            SEE IF IT'S BLANK
         SPACE
TXGEDITC BC    (8),TXGEDITD             /ALTERED/ BLANK CHECK GATE
         CLI   0(SP1),IQUOTE            NO, MAYBE IT'S A QUOTE
         BE    TXGEDITQ                 QUOTE, GO SEE IF PAIRED
         SPACE
TXGEDITG DS    0H
         BCT   SP2,TXGEDITB             BACK TO CHECK REST OF OPERAND
         OI    TXGEDITC+1,X'80'         SET GATE TO CHECK FOR BLANKS
         B     TXGEDITE                 LOG ERROR IN OPND FIELD
         SPACE
TXGEDITF DS    0H
         LA    SP1,1(,SP1)              STEP TO NEXT BYTE
         CLI   0(SP1),IBLANK            SEE IF IT'S A BLANK, TOO
         BNE   TXGEDITX                 NO, GO SEE IF IT CAN BE FIXED
         SPACE
TXGEDITD DS    0H
         BCT   SP2,TXGEDITF             TEST REST OF OPERAND
         SR    SP1,GRC                  OPERAND LENGTH COUNTED
         CR    SP1,GRX                  SHOULD BE SAME AS ORIGINAL
         BCR   8,GRD                    YES, CAN RETURN
         SPACE
TXGEDITE DS    0H
         BAL   SRR,ERROR0               LOG ERROR IN OPERAND
         DC    AL2(TXGERR00)            'ILLEGAL OPERAND FIELD FORMAT'
         BR    GRD                      AND RETURN
         SPACE
TXGEDITQ DS    0H
         TM    TXGEDITC+1,X'80'         SEE IF WE WERE CHECKING BLANKS
         BZ    TXGEDITR                 NO, WERE INSIDE QUOTE STRING
         LR    GR1,SP1                  YES, GET ADDRESS OF QUOTE
         BCTR  GR1,0                    BACK UP ONE
         CR    GR1,GRC                  MIGHT BE FIRST OPND BYTE
         BE    TXGEDITR                 YES, GO TURN OF TEST FOR BLANKS
         CLI   0(GR1),IL                WAS IT AN L-QUOTE
         BNE   TXGEDITR                 NO, GO TO QUOTE MODE
         CLI   1(SP1),IA                DOES NUMBER FOLLOW L'
         BL    TXGEDITR                 YES, GO START QUOTE MODE
         CLI   1(SP1),IALPHA            IS IT A LETTER
         BNH   TXGEDITG                 YES, IT IS L ATTR
         CLI   1(SP1),IASTER            TEST FOR L'*
         BE    TXGEDITG                 BRANCH IF YES
         SPACE
TXGEDITR DS    0H
         XI    TXGEDITC+1,X'80'         NO, RESET THE BLANK TEST SWITCH
         B     TXGEDITG                 AND KEEP TESTING
         SPACE
TXGEDITX DS    0H
         TM    CTEXTENI(ACT),X'04'      WAS 'EXTEN' SPECIFIED .Q
         BZ    TXGEDITE                 NO, LOG 'OPND FIELD ERROR'
         LA    SP1,TXOPN(GRX,GRC)       POINT TO COMMENT LENGTH
         SR    GR1,GR1                  ZERO A WORK REGISTER
         IC    GR1,TXCOML(,SP1)         GET COMMENTS LENGTH
         AR    GR1,SP2                  UPDATED COMMENTS LENGTH
         CH    GR1,H255                 HOW LONG WILL IT BE .Q
         BH    TXGEDITE                 BRANCH IF TOO LONG
         SR    GRX,SP2                  DECREMENT OPND LENGTH
         STC   GRX,TXOPNL(,GRC)         SAVE NEW LENGTH BACK
TXGEDITY DS    0H
         BCTR  SP1,0                    POINT BACK IN OPND
         IC    GR0,TXCOM-1(,SP1)        GET A BYTE
         STC   GR0,TXCOM+1(,SP1)        PUT A BYTE
         BCT   SP2,TXGEDITY             LOOP TILL ALL IS DONE
         L     SP2,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM
         STC   GR1,TXCOML(,SP1)         SET NEW COMMENT LENGTH
         MVC   TXCOM(1,SP1),L1CALIGN(SP2)  ENTER DEFAULT COMMENT OFFSET
         CLI   TXCOM(SP1),X'00'         IS THE DEFAULT ZERO .Q
         BCR   7,GRD                    RETURN IF NOT
         MVI   TXCOM(SP1),X'01'         SET TO ONE FOR FORMATTING
         BR    GRD                      AND RETURN
H255     DC    H'255'                   FOR COMPARISON PURPOSES
         EJECT
* EDIT TRAILING BLANKS
         SPACE 2
TXGEDT   DS    0H
         SR    GRX,GRX                  CLEAR WORKING REG.
         IC    GRX,0(SP1)               PICK UP FIELD LENGTH FROM REC.
         LTR   GR2,GRX                  ALSO TO GR2
         BCR   8,SRR                    ZERO LENGTH MEANS WE RETURN
         SPACE
TXGEDT1  DS    0H
         LA    GR1,0(SP1,GR2)           CHOOSE A BYTE AT END OF THE FLD
         CLI   0(GR1),IBLANK            MAYBE IS'S A BLANK
         BNE   TXGEDT2                  NO, GET READY TO RETURN
         BCT   GR2,TXGEDT1              YES, TEST REST OF FIELD
         BCTR  GR1,0                    ALL BLANKS,
         SPACE
TXGEDT2  DS    0H
         LA    SP2,1(GRX,SP1)           END OF ORIGINAL FIELD
         SR    GRX,GR2                  SEE HOW MANY TRAILING BLANKS-
         BCR   8,SRR                    NO BLANKS, RETURN
         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD
         AR    GRZ,GRX                  GRZ GETS TOTAL OF BLANKS
         EX    GRY,TXGEDTM              MOVE RECORD OVER  GRY=TXRL
         BR    SRR                      RETURN
TXGEDTM  MVC   1(*-*,GR1),0(SP2)        EXECUTED MOVE
*                                                                     *
*        GR1 CONTAINS ADDRESS OF LAST NON-BLANK BYTE
*        SP2 CONTAINS ADDRESS OF ORIGINAL FIELD END+1
         EJECT
* EDIT LEADING BLANKS
         SPACE 2
*INPUT-  SP1 CONTAINS ADDRESS OF FIELD LENGTH BYTE IN TEXT RECORD     *
*        GRY CONTAINS LENGTH OF TEXT RECORD                           *
*        GRZ CONTAINS THE NUMBER OF BLANKS PREVIOUSLY DELETED         *
*OUTPUT- FIELD LENGTH BYTE IS UPDATED                                 *
*        GRX CONTAINS NUMBER OF BLANKS DELETED                        *
*        GRZ CONTAINS NEW TOTAL NUMBER OF BLANKS DELETED              *
*        GR1 CONTAINS ADDRESS OF FIRST NON-BLANK CHARACTER DISCOVERED *
*                                                                     *
TXGEDL   DS    0H
         SR    GRX,GRX                  GET READY
         IC    GRX,0(SP1)               FIND FIELD LENGTH
         LTR   GR2,GRX                  ALSO IN GR2
         BCR   8,SRR                    LENGTH ZERO, WE GO BACK
         LR    GR1,SP1                  POINT JUST IN FRONT OF FIELD
         SPACE
TXGEDL1  DS    0H
         CLI   1(GR1),IBLANK            CHECK FOR A BLANK
         BNE   TXGEDL2                  NO, GET READY TO LEAVE
         LA    GR1,1(GR1)               YES, POINT TO NEXT BYTE
         BCT   GR2,TXGEDL1              AND CONTINUE ACROSS THE FIELD
         CR    SP1,GRC                  ALL BLANKS, SEE IF OPND FIELD
         BNE   TXGEDL2                  NO, GET READY TO RETURN
         BCTR  GR1,0                    OPERAND, ADJUST MOVE POINTER...
         LA    GR2,1(GR2)
         SPACE
TXGEDL2  DS    0H
         SR    GRX,GR2                  FIND HOW MANY BLANKS DELETED
         BCR   8,SRR                    NONE, DO NO MORE...RETURN
         STC   GR2,0(SP1)               UPDATE FIELD LENGTH IN RECORD
         AR    GRZ,GRX                  GRZ GETS TOTAL BLANKS
         EX    GRY,TXGEDLM              GRY CONTAINS TEXT RECORD LENGTH
         BR    SRR                      ALL DONE, RETURN
         SPACE
TXGEDLM  MVC   1(*-*,SP1),1(GR1)        MOVE 'EM OVER
*        SP1 POINTS JUST IN FRONT OF ORIGINAL FIELD
*        GR1 POINTS TO FIRST NON-BLANK BYTE
         EJECT
* GET LITERALS FROM SYMBOL TABLE AND GENERATE LDC RECORDS
*        COME HERE WHEN CTLIT2(ACT) IS NON-ZERO                       *
*        CTLIT2(ACT) IS SET =1 WHEN ASMGF7C PROCESSES 'LTORG'         *
*                           =4 WHEN ASMGF7C PROCESSES 'END'           *
         SPACE 2
TXGLIT   DS    0H
         CLI   CTLIT2(ACT),2            TEST CTLIT2
         BL    TXGLITA                  EQ 1, GET LIT DC FROM SYM. TAB.
         LA    GR1,TXGLIT2              ADDR. OF DUMMY 'LTORG'
         BE    TXGLIT1                  CTLIT2 EQ 2, LTORG
         LA    GR1,TXGLIT3              ADDR. OF DUMMY 'ORG'
         CLI   CTLIT2(ACT),3            LOOK AT LIT SWITCH AGAIN
         BE    TXGLIT1                  EQ 3, ORG
         SPACE
         MVC   TXGLIT4W+4(2),CTESRN(ACT)     EQ 4, CSECT
         MVC   TXGLIT4+TXNAME(8),CTFSTN(ACT) USE FIRST CSECT NAME, NUM.
         LA    GR0,8                         EDIT TRAILING BLANKS FROM
         LR    GR1,GR0                       NAME FIELD AND CORRECT
TXGLIT0  DS    0H
         LA    GR2,TXGLIT4+TXNAML(GR1)       FIELD COUNT
         CLI   0(GR2),IBLANK            CHECK END OF NAME FOR BLANK
         BNE   TXGLIT00                 NON-BLANK, GO ON
         BCT   GR1,TXGLIT0              STEP POINTER AND GO CHECK NEXT
         SPACE
TXGLIT00 DS    0H
         STC   GR1,TXGLIT4+TXNAML       INSERT NAME LENGTH IN REC.
         SR    GR0,GR1                  FIND NUMBER OF TRAILING BLANKS
         STC   GR0,TXGLIT4+TXNAME(GR1)  INSERT IN OPERATION LENGTH FLD
         LA    GR1,TXGLIT4              GET READY TO MOVE DUMMY CSECT
         SPACE
TXGLIT1  DS    0H
         MVC   0(TXGLIT5-TXGLIT4,GRA),0(GR1)  MOVE CSECT, ORG OR LTORG
         IC    GR1,CTLIT2(ACT)                INTO TEXT WORK AREA
         BCTR  GR1,0                          REDUCE CTLIT2 BY ONE
         STC   GR1,CTLIT2(ACT)
         BR    GRD                            RETURN
         SPACE
TXGLIT2  DC    AL2(TXGLIT3-*),X'50802200',AL2(TXGLIT3-TXGLIT2-TXFAFL)
         DC    X'000001',AL1(IBLANK),6X'00'                   **LTORG**
         SPACE
TXGLIT3  DC    AL2(TXGLIT4-*),X'50802000',AL2(TXGLIT4-TXGLIT3-TXFAFL)
         DC    X'000001',AL1(IBLANK),6X'00'                   **ORG**
         SPACE
TXGLIT4  DC    AL2(TXGLIT5-*),X'50801C00',AL2(TXGLIT4W-TXGLIT4-TXFAFL)
         DC    X'08',8AL1(IBLANK),X'0001',AL1(IBLANK),6X'00'  **CSECT**
TXGLIT4W DC    X'90000000FFFF'   **CSECT WORK BUCKET FOR ESD NUMBER**
         SPACE
TXGLIT5  EQU   *
         EJECT
*
*        GET   LITERAL DC FROM SYMBOL TABLE                           *
* LITERALS ARE SEPARATED INTO FOUR STRINGS...LITERALS WHOSE LENGTHS   *
*   ARE MULTIPLES OF 8 GO IN THE 8-BYTE STRING.  4,2, AND 1-BYTE      *
*   STRINGS ARE FORMED ACCORDINGLY.                                   *
* CTLITA(ACT)  CONTAINS FOUR ENTRIES GIVING THE NUMBER OF LITERALS IN *
*   EACH STRING, FOR WHICH TEXT RECORDS HAVE BEEN GENERATED.          *
* CTLITB(ACT)  CONTAINS THE NUMBER OF LITERALS IN EACH STRING, FOR    *
*   WHICH TEXT RECORDS HAVE NOT BEEN GENERATED.                       *
         SPACE 1
TXGLITA  DS    0H
         SR    GR1,GR1                  GR1 SET FOR 8-BYTE STRING
         SPACE
TXGLITB  DS    0H
         L     GR2,CTLITA(ACT,GR1)      GET COUNT OF STRING 'IN TEXT'
         LTR   GR2,GR2                  LOOK CLOSELY
         BZ    TXGLITC                  STRING DONE, GO LOOK IN SYM TAB
         BCTR  GR2,0                    NOT DONE, REDUCE STRING COUNT
         ST    GR2,CTLITA(ACT,GR1)      PUT BACK IN 'INTEXT' AREA
         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER
         LA    GR1,1(GR1)               UPDATE IT
         ST    GR1,CTSEQN(ACT)          AND RESTORE
         B     4(GRD)                   RETURN TO GETTING TEXT RECORD
         SPACE
TXGLITC  DS    0H
         L     GR2,CTLITB(ACT,GR1)      GET COUNT OF STRING 'IN SY TAB'
         LTR   GR2,GR2                  EXAMINE
         BZ    TXGLITD                  NONE IN SYM TAB, TRY NEXT STRNG
         BCTR  GR2,0                    FOUND ONE, REDUCE COUNT
         ST    GR2,CTLITB(ACT,GR1)      PUT BACK IN 'IN SYMB TABLE'
         L     SRB,CDCGET(ACT)          DCGET TURNS SYM TABLE ENTRIES
         BALR  SRR,SRB                  TO LDC TEXT REC'S...ASMGF7G
         L     GR1,CTSEQN(ACT)          GET SEQUENCE NUMBER
         LA    GR1,1(GR1)               STEP IT
         ST    GR1,CTSEQN(ACT)          REPLACE
         BR    GRD                      RETURN WITH RECORD 'GOT'
         SPACE
TXGLITD  DS    0H
         LA    GR1,4(,GR1)              STEP TO NEXT STRING
         CH    GR1,H16                  ONLY FOUR STRINGS ALLOWED
         BL    TXGLITB                  MORE LEFT, LOOK IN TEXT FIRST
         MVI   CTLIT2(ACT),0            CLEAR LIT GEN SWITCH
         B     4(GRD)                   RETURN, TO GET NEXT RECORD
H16      DC    H'16'                    HALFWORD SIXTEEN
         SPACE 2
ERROR0   DS    0H
         SR    SP1,SP1                  PARAMETER REG FOR ASMGF7L
ERROR    DS    0H
         L     SRB,CLOGER(,ACT)         CLOGER BUILDS ERROR MESS. REC'D
         BR    SRB                      TO ASMGF7L
         SPACE
ABORT    DS    0H
         NI    TXTO(GRA),X'FF'-(BIT0+BIT1) SET TYPE OPERATION UNCHCKD
         B     TXGET1                   FLUSH RECORD, GET ANOTHER
         EJECT
* OP CODE CONVERSION S/R FOR GENERATED RECORDS
         SPACE 2
REGP     EQU   GR1                      WORKING REGISTER
COLR     EQU   GRA                      POINTS TO TEXT RECORD BEGIN
RTNR     EQU   GRD                      RETURN REG.
LREG     EQU   GR2                      LENGTH OP CODE-1
TABR     EQU   GRZ                      TABLE POINTER
INCR     EQU   GRX                      STEP THROUGH TABLE
LIMR     EQU   GRY                      LIMIT OF SEARCH
OPINC    EQU   28                       OPSYN CHAIN PTR ST INCRMT
OPTR     EQU   CTWORK+16                POINTER SLOT
         SPACE
OPCCF    DS    0H
         SR    REGP,REGP                GET READY
         IC    REGP,TXNAML(COLR)        GET NAME FIELD LENGTH
         LA    REGP,TXNAME(COLR,REGP)   POINT TO OP LENGTH FIELD
         SR    LREG,LREG                GET OP LENGTH
         IC    LREG,TXOPL(REGP)
         CLI   TXOP(REGP),I9            IF 1ST CHAR. DIGIT
         BNH   OPCERR3                  LOG ERROR
         CLI   TXOPL(REGP),8            IF LONGER THAN 8
         BH    OPCERR3                  LOG ERROR
         CLI   TXOPL(REGP),5            IF LONGER THAN 5
         BH    OPC08                    CHECK OPSYN TABLE
         BCTR  LREG,0
         LTR   TABR,LREG
         BM    OPCERR2                       TEST OP LEN EQ 0
         STC   LREG,OPC02+1             /ALTERS LENGTH IN CLC INSTR./
         SLL   TABR,2                        4(L-1) ADDRESS TABLE ACCES
         LA    INCR,4(LREG)                  L+3 INCREMENT
         L     LIMR,OPC04+4(TABR)       SET LIMIT
         L     TABR,OPC04(TABR)         SET START
         SPACE 2
OPC02    CLC   TXOP(*-*,REGP),0(TABR)   /LENGTH INSERTED ABOVE/
         BH    OPC01                    TRY NEXT
         BL    OPC05                    NOT FOUND, TRY OPSYN TABL
         LA    TABR,1(TABR,LREG)        FOUND
OPC03    DS    0H
         MVC   3(3,COLR),0(TABR)        TYPE, HEX OP, ASC TO TEXT
         TM    TXTO(COLR),BIT0          TEST LEGAL IF GEN IF AOP
         BCR   8,RTNR                   OK, RETURN
         TM    TXEMF(COLR),BIT2         CHECK FOR EXTENDED MNEMONIC
         BCR   8,RTNR                   OK, RETURN
OPCERR1  DS    0H
         BAL   SRR,ERROR0               OP CODE ILLEGAL IF GEN
         DC    AL2(TXGERR13)            'OP CODE NOT ALLOWED TO BE GEN'
         B     ABORT                    GIVE UP THIS STATEMENT
OPCERR2  DS    0H
         BAL   SRR,ERROR0               OP LEN EQ ZERO
         DC    AL2(TXGERR12)            'INVALID OP.CODE'
         B     ABORT                    GIVE UP
OPCERR3  EQU   OPCERR2                  OP LEN GR 8
OPCERR4  DS    0H
         BAL   SRR,ERROR0               OP NOT FOUND
         DC    AL2(TXGERR14)            'OP CODE UNDEFINED'
         B     ABORT                    GIVE UP
OPC01    DS    0H
         BXLE  TABR,INCR,OPC02          CHECK NEXT IF ANY
OPC05    DS    0H
         LA    LREG,1(,LREG)            FORM FULL LENGTH
OPC08    DS    0H
         STC   LREG,CTWORK(,ACT)        SET UP SEARCH ARGUMENT
         MVC   CTWORK+1(8,ACT),TXOP(REGP)
         MVI   OPTR(ACT),0
         L     REGP,CTSYMP(,ACT)        ACCESS SYMBOL TABLE
         LA    TABR,OPINC(,REGP)        OPSYN CHAIN POINTER
         STC   LREG,OPC07+1
OPC06    DS    0H
         MVC   OPTR+1(3,ACT),0(TABR)    GET NEXT POINTER
         L     TABR,OPTR(,ACT)
         LTR   TABR,TABR                CHECK END OF CHAIN
         BZ    OPCERR4                  YES, UNDEFINED
         ALR   TABR,REGP                FORM FULL POINTER
OPC07    CLC   CTWORK(*-*,ACT),3(TABR)  COMPARE L AND SYMBOL
         BNE   OPC06                    NOPE, KEEP SEARCHING
         LA    TABR,4(TABR,LREG)        STEP PAST PTR, L, NAME
         B     OPC03                    TO FOUND
         EJECT
*        OP-CODE TABLE DELIMITERS...BY OP-CODE LENGTH                 *
         SPACE
OPC04    DC    A(OPL1)                  START OF 1-BYTE OP-CODES
         DC    A(OPL2)                  START OF 2-BYTE OP-CODES
         DC    A(OPL3)                  START OF 3-BYTE OP-CODES
         DC    A(OPL4)                  START OF 4-BYTE OP-CODES
         DC    A(OPL5)                  START OF 5-BYTE OP-CODES
         DC    A(OPFN)                  END OF OP-CODE TABLE
         SPACE
* TABLE OF SYMBOLIC OP CODES (INTERNAL CODE) BY LENGTH,
* WITH TYPE FLAG AND HEX CODES - FENDALL
         SPACE
*                                                                     *
* TABLE ENTRIES CONSIST OF-                                           *
*        OP-CODE, IN ASSEMBLER INTERNAL CODE...ONE TO FIVE BYTES      *
*        SECOND BYTE OF FLAGA... ONE BYTE, BITS USED AS FOLLOWS       *
*                TXTO   .O - OPERATION TYPE ON IF TYPE=ASSEM          *
*                       .1 - OP TYPE, ON IF TYPE=MACH OR EXTEN        *
*                TXEMF  .2 - EXTENDED MNEMONIC FLAG...ILLEGAL IF GEN'D*
*                TXMDN  .3 - MULTIPLY DEFINE NAME INDICATOR           *
*                 TXR1M .4 - NAME REQUIRED
*                       .5 - NAME NOT ALLOWED
*                       .6 - OPERAND REQUIRED
*                       .7 - OPERAND NOT ALLOWED
*        TXHEX... ONE BYTE, MACH. OP CODE OR INTERNAL ASSMBLR OP CODE *
*        TXASC...ONE BYTE, ASSEMBLER SWITCH CODE..BITS USED THUSLY... *
*                 TXASC .0 - UNINITIATED PRIVATE CODE
*                       .1 - POSSIBLE SYMBOL TABLE ENTRY
*                       .2 - LOCATION COUNTER REFERENCE
*                       .3 - SPECIAL PHASE 7 X-REFERENCE
*                       .4 - SUBSTITUTION REQUIRED
*                       .5 -
*                       .6 -
*                       .7 - PHASE 8 UNINITIATED PRIVATE CODE
*
*             ...OR THUSLY FOR MACHINE OPERATION CODES
*                       .0   0 - NO FLOATING REGISTER
*                            1 - FLOATING REGISTER REQURIED
*                       .1   0 - NO EVEN REGISTER
*                            1 - EVEN REGISTER REQUIRED
*                       .23  00- NO BOUNDARY ALIGNMENT
*                            01- HALF WORD ALIGNMENT
*                            10- FULL WORD ALIGNMENT
*                            11- DOUBLE WORD ALIGNMENT
*                       .45  XX- TYPE OF CLASS WITHIN INST (XX+1)
*                       .6   1 - LITERAL PERMITTED IN 2ND & 3RD OPERAND
*                       .7   1 - LITERAL PERMITTED IN 1ST OPERAND
*
*
*        THE FOLLOWING IS AN EXPLANATION OF THE PARMS ON THE OPCD MACRO
*
*        0P=XX     OPCODE (MACHINE OR ASSEMBLER INTERNAL) IN HEX
*        TYPE=ASSEM     ASSEMBLER OP-CODE  EXAMPLE START,DC,ACTR
*        TYPE=MACH      MACHINE OP-CODE    EXAMPLE BC,LTR,BXLE
*        TYPE=EXTEN     EXTENDED MNEMONIC  EXAMPLE BE,NOPR,BM
*                       ALSO SI EX. INSTS  EXAMPLE HDV,SCK,STIDP
*        ILLGEN=NO/YES      OPCODE ILLEGAL IF GENERATED
*        NAME=NULL/YES/NO   IF NAME FIELD OPTIONAL/MANDATORY/ILLEGAL
*        OPND=NULL/YES/NO   IF OPERAND FIELD OPTIONAL/MANDATORY/ILLEGAL
*        IS=XX     TO IDENTIFY AN OPCODE FOR GIVEN INSTRUCTION SET(S)
*        MASK=XX   MASK BYTE NEEDED ONLY FOR ASSEM OR EXTEN OPS
******  FOLLOWING PARAMETERS NEEDED ONLY FOR MACH OR EXTEN OPS
*        ALIGN=C/H/F/D  CHARACTER,HALFWORD,FULLWORD,DOUBLEWORD ALIGN
*        CLASS=(0,1,2,3)     TOGETHER WITH OP= DETERMINES OPERAND TYPES
*                            OP   CLASS          OPERAND FORMAT
*                            --   -----          --------------
*                            RR     0       AR    R1,R2
*                                   1       SPM   R1
*                                   2       SVC   I
*                                   3       BR    R2
*                            RX     0       D     R1,ADDRX
*                                   1       B     ADDRX
*                            RS/SI  0       LM    R1,R3,ADDR
*                                   1       SRDA  R1,ADDR
*                                   2       CLI   ADDR,I
*                                   3       HIO   ADDR
*                            SS     0       AP    ADDR1(L1),ADDR2(L2)
*                                   1       MVC   ADDR1(L),ADDR2
*                                   2       XIO   ADDR1(I),ADDR2
*                                   3       SRP   ADDR1(L1),ADDR2,I3
*        EVEN=YES/NO    IF REGISTER SPECS MUST BE EVEN  EXAMPLE M,D
*            =DOUBLE    IF REGISTER MUST BE 0 OR 4 (ONLY FOR FLOATING)
*        FLOAT=YES/NO   IF REGISTER SPECS MUST BE .LE. 6
*        LIT1=YES/NO    IF FIRST OPERAND MAY BE A LITERAL
*        LIT23=YES/NO   IF SECOND AND THIRD OPERANDS MAY BE LITERALS
******  FOLLOWING PARAMATERS NEEDED ONLY FOR ASSEM OPS
*        F7XREF=YES/NO  SPECIAL PHASE F7 CROSS-REFERENCE
*        F8UPC=YES/NO   PHASE F8 UNINITIATED PRIVATE CODE
*        LCR=YES/NO     LOCATION COUNTER REFERENCE
*        STE=YES/NO     POSSIBLE SYMBOL TABLE ENTRY
*        SUB=YES/NO     SUBSTITUTION REQUIRED
*        UPC=YES/NO     UNINITIATED PRIVATE CODE
*
***********************************************************************
*
*                  IMPORTANT NOTE
*
*        TO ADD A NEW INSTRUCTION TO THE ASSEMBLER YOU
*        MUST NOT ONLY ADD AN NEW INST TO AN ASMGISXX MODULE,
*        BUT YOU SHOULD ALSO ADD THE NEW INSTRUCTION TO THE TABLE
*        HERE AT THE END OF DECK ASMGF7X.
***********************************************************************
         EJECT
A        OPCD      OP=5A,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
B        OPCD      OP=47,TYPE=EXTEN,MASK=F,                            *
               ALIGN=H,CLASS=1,LIT23=YES
C        OPCD      OP=59,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
D        OPCD      OP=5D,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES
L        OPCD      OP=58,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
M        OPCD      OP=5C,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,LIT23=YES
N        OPCD      OP=54,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
O        OPCD      OP=56,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
S        OPCD      OP=5B,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
X        OPCD      OP=57,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
AD       OPCD      OP=6A,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AE       OPCD      OP=7A,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AH       OPCD      OP=4A,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
AL       OPCD      OP=5E,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
AP       OPCD      OP=FA,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
AR       OPCD      OP=1A,TYPE=MACH,                                    *
               CLASS=0
AU       OPCD      OP=7E,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AW       OPCD      OP=6E,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
AX       OPCD      OP=76,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
BC       OPCD      OP=47,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BE       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BH       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BL       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BM       OPCD      OP=47,TYPE=EXTEN,MASK=4,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BO       OPCD      OP=47,TYPE=EXTEN,MASK=1,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BP       OPCD      OP=47,TYPE=EXTEN,MASK=2,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BR       OPCD      OP=07,TYPE=EXTEN,MASK=F,                            *
               CLASS=3
BZ       OPCD      OP=47,TYPE=EXTEN,MASK=8,                            *
               ALIGN=H,CLASS=1,LIT23=YES
CD       OPCD      OP=69,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
CE       OPCD      OP=79,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
CH       OPCD      OP=49,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
CL       OPCD      OP=55,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
CP       OPCD      OP=F9,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT1=YES,LIT23=YES
CR       OPCD      OP=19,TYPE=MACH,                                    *
               CLASS=0
CS       OPCD      OP=BA,TYPE=MACH,IS=70,                              *
               ALIGN=F,CLASS=0
DC       OPCD      OP=26,TYPE=ASSEM,OPND=YES,                          *
               F8UPC=YES,LCR=YES,STE=YES,UPC=YES
DD       OPCD      OP=6D,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
DE       OPCD      OP=7D,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
DP       OPCD      OP=FD,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
DR       OPCD      OP=1D,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES
DS       OPCD      OP=27,TYPE=ASSEM,OPND=YES,                          *
               F8UPC=YES,LCR=YES,STE=YES,UPC=YES
DX       OPCD      OP=73,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
ED       OPCD      OP=DE,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
EX       OPCD      OP=44,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
IC       OPCD      OP=43,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
LA       OPCD      OP=41,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
LD       OPCD      OP=68,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
LE       OPCD      OP=78,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
LH       OPCD      OP=48,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
LM       OPCD      OP=98,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
LR       OPCD      OP=18,TYPE=MACH,                                    *
               CLASS=0
LX       OPCD      OP=74,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
MC       OPCD      OP=AF,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=2,LIT1=YES
MD       OPCD      OP=6C,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
ME       OPCD      OP=7C,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
MH       OPCD      OP=4C,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
MP       OPCD      OP=FC,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
MR       OPCD      OP=1C,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES
MX       OPCD      OP=72,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
NC       OPCD      OP=D4,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
NI       OPCD      OP=94,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
NR       OPCD      OP=14,TYPE=MACH,                                    *
               CLASS=0
OC       OPCD      OP=D6,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
OI       OPCD      OP=96,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
OR       OPCD      OP=16,TYPE=MACH,                                    *
               CLASS=0
SD       OPCD      OP=6B,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SE       OPCD      OP=7B,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SH       OPCD      OP=4B,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
SL       OPCD      OP=5F,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,LIT23=YES
SP       OPCD      OP=FB,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
SR       OPCD      OP=1B,TYPE=MACH,                                    *
               CLASS=0
ST       OPCD      OP=50,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0
SU       OPCD      OP=7F,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SW       OPCD      OP=6F,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
SX       OPCD      OP=77,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES,LIT23=YES
TM       OPCD      OP=91,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2,LIT1=YES
TR       OPCD      OP=DC,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
TS       OPCD      OP=93,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
XC       OPCD      OP=D7,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
XI       OPCD      OP=97,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
XR       OPCD      OP=17,TYPE=MACH,                                    *
               CLASS=0
ADD      OPCD      OP=66,TYPE=MACH,IS=67,                              *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
ADR      OPCD      OP=2A,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AER      OPCD      OP=3A,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AGO      OPCD      OP=0A,TYPE=ASSEM,                                   *
               ILLGEN=YES
AIF      OPCD      OP=09,TYPE=ASSEM,                                   *
               ILLGEN=YES
ALR      OPCD      OP=1E,TYPE=MACH,                                    *
               CLASS=0
AUR      OPCD      OP=3E,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AWR      OPCD      OP=2E,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
AXR      OPCD      OP=36,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
BAL      OPCD      OP=45,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BAS      OPCD      OP=4D,TYPE=MACH,IS=(20,67),                         *
               ALIGN=H,CLASS=0,LIT23=YES
BCR      OPCD      OP=07,TYPE=MACH,                                    *
               CLASS=0
BCT      OPCD      OP=46,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BER      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *
               CLASS=3
BHR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *
               CLASS=3
BLR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *
               CLASS=3
BMR      OPCD      OP=07,TYPE=EXTEN,MASK=4,                            *
               CLASS=3
BNE      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNH      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNL      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNM      OPCD      OP=47,TYPE=EXTEN,MASK=B,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNO      OPCD      OP=47,TYPE=EXTEN,MASK=E,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNP      OPCD      OP=47,TYPE=EXTEN,MASK=D,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BNZ      OPCD      OP=47,TYPE=EXTEN,MASK=7,                            *
               ALIGN=H,CLASS=1,LIT23=YES
BOR      OPCD      OP=07,TYPE=EXTEN,MASK=1,                            *
               CLASS=3
BPR      OPCD      OP=07,TYPE=EXTEN,MASK=2,                            *
               CLASS=3
BXH      OPCD      OP=86,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
BZR      OPCD      OP=07,TYPE=EXTEN,MASK=8,                            *
               CLASS=3
CCW      OPCD      OP=28,TYPE=ASSEM,                                   *
               F7XREF=YES,F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES
CDR      OPCD      OP=29,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
CDS      OPCD      OP=BB,TYPE=MACH,IS=70,                              *
               ALIGN=D,CLASS=0
CER      OPCD      OP=39,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
CIO      OPCD      OP=9B,TYPE=MACH,IS=20,                              *
               ALIGN=C,CLASS=2
CLC      OPCD      OP=D5,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES
CLI      OPCD      OP=95,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2,LIT1=YES
CLM      OPCD      OP=BD,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0,LIT23=YES
CLR      OPCD      OP=15,TYPE=MACH,                                    *
               CLASS=0
COM      OPCD      OP=1E,TYPE=ASSEM,                                   *
               STE=YES,F8UPC=YES
CVB      OPCD      OP=4F,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,LIT23=YES
CVD      OPCD      OP=4E,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0
CXD      OPCD      OP=2C,TYPE=ASSEM,OPND=NO,                           *
               F8UPC=YES,STE=YES,UPC=YES
DDR      OPCD      OP=2D,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
DER      OPCD      OP=3D,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
DXD      OPCD      OP=2B,TYPE=ASSEM,NAME=YES,OPND=YES,                 *
               STE=YES,F8UPC=YES
END      OPCD      OP=21,TYPE=ASSEM,ILLGEN=YES,NAME=NO,                *
               F7XREF=YES,LCR=YES,SUB=YES
EQU      OPCD      OP=1F,TYPE=ASSEM,NAME=YES,OPND=YES,                 *
               LCR=YES,STE=YES,SUB=YES,UPC=YES
HDR      OPCD      OP=24,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
HDV      OPCD      OP=9E,TYPE=EXTEN,MASK=1,                            *
               ALIGN=C,CLASS=3
HER      OPCD      OP=34,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
HIO      OPCD      OP=9E,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
HPR      OPCD      OP=99,TYPE=MACH,IS=20,                              *
               CLASS=2
HVC      OPCD      OP=83,TYPE=MACH,IS=71,                              *
               ALIGN=F,CLASS=0
ICM      OPCD      OP=BF,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0,LIT23=YES
IPK      OPCD      OP=B2,TYPE=EXTEN,MASK=B,                            *
               ALIGN=C,CLASS=3
ISK      OPCD      OP=09,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0
LCR      OPCD      OP=13,TYPE=MACH,                                    *
               CLASS=0
LDR      OPCD      OP=28,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LER      OPCD      OP=38,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LMC      OPCD      OP=B8,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0,LIT23=YES
LNR      OPCD      OP=11,TYPE=MACH,                                    *
               CLASS=0
LPR      OPCD      OP=10,TYPE=MACH,                                    *
               CLASS=0
LRA      OPCD      OP=B1,TYPE=MACH,IS=(67,70),                         *
               ALIGN=C,CLASS=0,LIT23=YES
LTR      OPCD      OP=12,TYPE=MACH,                                    *
               CLASS=0
MDD      OPCD      OP=65,TYPE=MACH,IS=67,                              *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
MDR      OPCD      OP=2C,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
MER      OPCD      OP=3C,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
MVC      OPCD      OP=D2,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
MVI      OPCD      OP=92,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
MVN      OPCD      OP=D1,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
MVO      OPCD      OP=F1,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
MVZ      OPCD      OP=D3,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
MXD      OPCD      OP=67,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
MXR      OPCD      OP=26,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
NOP      OPCD      OP=47,TYPE=EXTEN,MASK=0,                            *
               ALIGN=H,CLASS=1,LIT23=YES
ORG      OPCD      OP=20,TYPE=ASSEM,                                   *
               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES
POP      OPCD      OP=2F,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
RDD      OPCD      OP=85,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
RRB      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=3,                      *
               ALIGN=C,CLASS=3
SCK      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=4,                      *
               ALIGN=C,CLASS=3,LIT1=YES
SDD      OPCD      OP=67,TYPE=MACH,IS=67,                              *
               ALIGN=D,CLASS=0,EVEN=DOUBLE,FLOAT=YES,LIT23=YES
SDR      OPCD      OP=2B,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SER      OPCD      OP=3B,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SIO      OPCD      OP=9C,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
SLA      OPCD      OP=8B,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SLL      OPCD      OP=89,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SLR      OPCD      OP=1F,TYPE=MACH,                                    *
               CLASS=0
SLT      OPCD      OP=A2,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0
SPM      OPCD      OP=04,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SPT      OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=8,                      *
               ALIGN=D,CLASS=3,LIT1=YES
SPX      OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=0,                      *
               ALIGN=F,CLASS=3,LIT23=YES
SRA      OPCD      OP=8A,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SRL      OPCD      OP=88,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1
SRP      OPCD      OP=F0,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
SSK      OPCD      OP=08,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0
SSM      OPCD      OP=80,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3,LIT1=YES
STC      OPCD      OP=42,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0
STD      OPCD      OP=60,TYPE=MACH,                                    *
               ALIGN=D,CLASS=0,EVEN=YES,FLOAT=YES
STE      OPCD      OP=70,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0,EVEN=YES,FLOAT=YES
STH      OPCD      OP=40,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0
STM      OPCD      OP=90,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0
SUR      OPCD      OP=3F,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SVC      OPCD      OP=0A,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
SWR      OPCD      OP=2F,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
SXR      OPCD      OP=37,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
TCH      OPCD      OP=9F,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
TIO      OPCD      OP=9D,TYPE=MACH,                                    *
               ALIGN=C,CLASS=3
TRT      OPCD      OP=DD,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT1=YES,LIT23=YES
WRD      OPCD      OP=84,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2,LIT1=YES
XIO      OPCD      OP=D0,TYPE=MACH,IS=20,                              *
               ALIGN=C,CLASS=2
ZAP      OPCD      OP=F8,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
ACTR     OPCD      OP=25,TYPE=ASSEM,                                   *
               ILLGEN=YES
ADDR     OPCD      OP=26,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
AGOB     OPCD      OP=0A,TYPE=ASSEM,                                   *
               ILLGEN=YES
AIFB     OPCD      OP=09,TYPE=ASSEM,                                   *
               ILLGEN=YES
ANOP     OPCD      OP=0B,TYPE=ASSEM,                                   *
               ILLGEN=YES
BALR     OPCD      OP=05,TYPE=MACH,                                    *
               CLASS=0
BASR     OPCD      OP=0D,TYPE=MACH,IS=(20,67),                         *
               CLASS=0
BCTR     OPCD      OP=06,TYPE=MACH,                                    *
               CLASS=0
BNER     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *
               CLASS=3
BNHR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *
               CLASS=3
BNLR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *
               CLASS=3
BNMR     OPCD      OP=07,TYPE=EXTEN,MASK=B,                            *
               CLASS=3
BNOR     OPCD      OP=07,TYPE=EXTEN,MASK=E,                            *
               CLASS=3
BNPR     OPCD      OP=07,TYPE=EXTEN,MASK=D,                            *
               CLASS=3
BNZR     OPCD      OP=07,TYPE=EXTEN,MASK=7,                            *
               CLASS=3
BXLE     OPCD      OP=87,TYPE=MACH,                                    *
               ALIGN=H,CLASS=0,LIT23=YES
CHPM     OPCD      OP=B3,TYPE=MACH,IS=44,                              *
               ALIGN=F,CLASS=2,LIT1=YES
CLCL     OPCD      OP=0F,TYPE=MACH,IS=70,                              *
               CLASS=0,EVEN=YES
CNOP     OPCD      OP=29,TYPE=ASSEM,ILLGEN=YES,OPND=YES,               *
               F8UPC=YES,LCR=YES,SUB=YES,UPC=YES
COPY     OPCD      OP=0C,TYPE=ASSEM,                                   *
               ILLGEN=YES
DROP     OPCD      OP=24,TYPE=ASSEM,NAME=NO,                           *
               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES
EDMK     OPCD      OP=DF,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,LIT23=YES
GBLA     OPCD      OP=00,TYPE=ASSEM,                                   *
               ILLGEN=YES
GBLB     OPCD      OP=01,TYPE=ASSEM,                                   *
               ILLGEN=YES
GBLC     OPCD      OP=02,TYPE=ASSEM,                                   *
               ILLGEN=YES
ICTL     OPCD      OP=11,TYPE=ASSEM,                                   *
               ILLGEN=YES
ISEQ     OPCD      OP=12,TYPE=ASSEM,                                   *
               ILLGEN=YES
LCDR     OPCD      OP=23,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LCER     OPCD      OP=33,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LCLA     OPCD      OP=03,TYPE=ASSEM,                                   *
               ILLGEN=YES
LCLB     OPCD      OP=04,TYPE=ASSEM,                                   *
               ILLGEN=YES
LCLC     OPCD      OP=05,TYPE=ASSEM,                                   *
               ILLGEN=YES
LCTL     OPCD      OP=B7,TYPE=MACH,IS=70,                              *
               ALIGN=F,CLASS=0,LIT23=YES
LNDR     OPCD      OP=21,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LNER     OPCD      OP=31,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LPDR     OPCD      OP=20,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LPER     OPCD      OP=30,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LPSW     OPCD      OP=82,TYPE=MACH,                                    *
               ALIGN=D,CLASS=3,LIT1=YES
LPSX     OPCD      OP=B2,TYPE=MACH,IS=44,                              *
               ALIGN=D,CLASS=3,LIT1=YES
LRDR     OPCD      OP=25,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LRER     OPCD      OP=35,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LTDR     OPCD      OP=22,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
LTER     OPCD      OP=32,TYPE=MACH,                                    *
               CLASS=0,EVEN=YES,FLOAT=YES
MDDR     OPCD      OP=25,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
MEND     OPCD      OP=10,TYPE=ASSEM,                                   *
               ILLGEN=YES
MVCL     OPCD      OP=0E,TYPE=MACH,IS=70,                              *
               CLASS=0,EVEN=YES
MXDR     OPCD      OP=27,TYPE=MACH,                                    *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
NOPR     OPCD      OP=07,TYPE=EXTEN,                                   *
               CLASS=3,MASK=0
PACK     OPCD      OP=F2,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
PTLB     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=D,                      *
               ALIGN=C,CLASS=3
PUSH     OPCD      OP=30,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
RDDW     OPCD      OP=B5,TYPE=MACH,IS=44,                              *
               ALIGN=F,CLASS=2
SCKC     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=6,                      *
               ALIGN=D,CLASS=3,LIT1=YES
SDDR     OPCD      OP=27,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=DOUBLE,FLOAT=YES
SETA     OPCD      OP=06,TYPE=ASSEM,                                   *
               ILLGEN=YES
SETB     OPCD      OP=07,TYPE=ASSEM,                                   *
               ILLGEN=YES
SETC     OPCD      OP=08,TYPE=ASSEM,                                   *
               ILLGEN=YES
SIGP     OPCD      OP=AE,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0
SIOF     OPCD      OP=9C,TYPE=EXTEN,MASK=1,                            *
               ALIGN=C,CLASS=3
SLDA     OPCD      OP=8F,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
SLDL     OPCD      OP=8D,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
SPKA     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=A,                      *
               ALIGN=C,CLASS=3
SPSW     OPCD      OP=81,TYPE=MACH,IS=20,                              *
               ALIGN=H,CLASS=3,LIT1=YES
SRDA     OPCD      OP=8E,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
SRDL     OPCD      OP=8C,TYPE=MACH,                                    *
               ALIGN=C,CLASS=1,EVEN=YES
STAP     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=2,                      *
               ALIGN=H,CLASS=3
STCK     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=5,                      *
               ALIGN=C,CLASS=3
STCM     OPCD      OP=BE,TYPE=MACH,IS=70,                              *
               ALIGN=C,CLASS=0
STMC     OPCD      OP=B0,TYPE=MACH,IS=67,                              *
               ALIGN=F,CLASS=0
STPT     OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=9,                      *
               ALIGN=D,CLASS=3
STPX     OPCD      OP=B3,TYPE=EXTEN,IS=70,MASK=1,                      *
               ALIGN=F,CLASS=3
SWPR     OPCD      OP=A3,TYPE=MACH,IS=67,                              *
               CLASS=0,EVEN=YES
TIOB     OPCD      OP=9A,TYPE=MACH,IS=20,                              *
               ALIGN=H,CLASS=2,LIT1=YES
UNPK     OPCD      OP=F3,TYPE=MACH,                                    *
               ALIGN=C,CLASS=0,LIT23=YES
WRDW     OPCD      OP=B4,TYPE=MACH,IS=44,                              *
               ALIGN=F,CLASS=2,LIT1=YES
CLRIO    OPCD      OP=9D,TYPE=EXTEN,IS=70,MASK=1,                      *
               ALIGN=C,CLASS=3
CSECT    OPCD      OP=1C,TYPE=ASSEM,ILLGEN=YES,                        *
               F8UPC=YES,STE=YES
DSECT    OPCD      OP=1D,TYPE=ASSEM,ILLGEN=YES,                        *
               F8UPC=YES,STE=YES
EJECT    OPCD      OP=15,TYPE=ASSEM,                                   *
               NAME=NO
ENTRY    OPCD      OP=19,TYPE=ASSEM,NAME=NO,OPND=YES,                  *
               F7XREF=YES,LCR=YES
EXTRN    OPCD      OP=1A,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
LTORG    OPCD      OP=22,TYPE=ASSEM,                                   *
               F8UPC=YES,LCR=YES,STE=YES,SUB=YES,UPC=YES
MACRO    OPCD      OP=0D,TYPE=ASSEM,                                   *
               ILLGEN=YES
MEXIT    OPCD      OP=0F,TYPE=ASSEM,                                   *
               ILLGEN=YES
MNOTE    OPCD      OP=0E,                                              *
               TYPE=ASSEM
OPSYN    OPCD      OP=2D,TYPE=ASSEM,                                   *
               ILLGEN=YES,NAME=YES
PRINT    OPCD      OP=13,TYPE=ASSEM,                                   *
               NAME=NO
PUNCH    OPCD      OP=16,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
REPRO    OPCD      OP=17,TYPE=ASSEM,                                   *
               ILLGEN=YES,NAME=NO
SPACE    OPCD      OP=14,TYPE=ASSEM,                                   *
               NAME=NO
START    OPCD      OP=1B,TYPE=ASSEM,ILLGEN=YES,                        *
               F8UPC=YES
STCKC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=7,                      *
               ALIGN=D,CLASS=3
STCTL    OPCD      OP=B6,TYPE=MACH,                                    *
               ALIGN=F,CLASS=0
STIDC    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=3,                      *
               ALIGN=C,CLASS=3
STIDP    OPCD      OP=B2,TYPE=EXTEN,IS=70,MASK=2,                      *
               ALIGN=C,CLASS=3
STNSM    OPCD      OP=AC,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
STOSM    OPCD      OP=AD,TYPE=MACH,                                    *
               ALIGN=C,CLASS=2
TITLE    OPCD      OP=18,                                              *
               TYPE=ASSEM
USING    OPCD      OP=23,TYPE=ASSEM,NAME=NO,OPND=YES,                  *
               F7XREF=YES,F8UPC=YES,LCR=YES,SUB=YES,UPC=YES
WXTRN    OPCD      OP=2E,TYPE=ASSEM,                                   *
               NAME=NO,OPND=YES
         EJECT
         OPCDGEN
         SPACE     2
         END       ASMGF7X
./ ADD NAME=ASMGF8A
F8A      TITLE     'ASMG F8  ASSEMBLER OPERATOR PROCESSOR (F8AOP)'
         ISEQ  73,78
ASMGF8A  START     ,                   ASSEMBLER OP PROCESSOR
         PRINT     NOGEN
         FDIMEN
         PRINT      GEN
*                                                                     *
*TITLE 'ASMGF8A ' ...  ASSEMBLER OPERATION PROCESSOR                  *
*FUNCTION/OPERATION-                                                  *
*  ASMGF8A PROCESSES THE FOLLOWING ASSEMBLER OPERATIONS- PRINT, SPACE,*
*   EJECT, MNOTE, PUNCH, REPRO, TITLE, ENTRY, EXTERN, START, CSECT,   *
*   DSECT, COMMON, EQU, ORG, LITORG, USING, DROP, CNOP, DXD, CXD, CCW,*
*   LITERAL DC, DC, AND DS. IT IS CALLED BY ASMGF8C AND USES DC EVAL  *
*   TO EVALUATE EXPRESSIONS, AND DCVAL TO EVALUATE DC STATEMENTS. THE *
*   FOLLOWING ERRORS ARE FOUND AND LOGGED-                            *
*        LOCATION COUNTER               WRAP AROUND                   *
*        EXPRESSION TOO LARGE           REGISTER SPECIFICATION        *
*        UNDEFINED SYMBOL               RELOCATABILITY                *
*        REGISTER NOT USED              CCW ERRORS                    *
*        ALIGNMENT                      ENTRY ERRORS                  *
*        OPERAND TOO COMPLEX            LENGTH                        *
*        INVALID DELIMITER              PRINT PARAMETER ERRORS        *
*ENTRY POINTS                                                         *
*  ASMGF8A   ASOPRO(ACT)      PROCESS ASSEMBLER OPERATIONS            *
*     CALLING SEQUENCE-                                               *
*        L     FRB,ASOPRO(ACT)          LOAD BASE/ENTRY               *
*        BALR  CRR,ACT                  CALL ASMGF8A                  *
*   SETSEC                    SETS CURRENT ADJUSTMENT BASE- INTERNAL  *
*   SECSET   F8STSC(ACT)      SETS CURRENT ADJUSTMENT BASE- EXTERNAL  *
*     CALLING SEQUENCE                                                *
*        L     FRB,ASOPRO(ACT)          LOAD BASE                     *
*        L     GR1,F8STSC(ACT)          LOAD ENTRY                    *
*        BALR  SRR,GR1                  CALL SET ADJUSTMENT           *
*INPUT- RECORDS TYPE 4, 6, AND 7                                      *
*OUTPUT-ASMGF8P IS CALLED TO PRINT OUT THE LISTING AND CARDS WHEN     *
*        NECESSARY                                                    *
*EXTERNAL ROUTINES-                                                   *
*   NAME           ROUTINE    USE                                     *
*   PRNT(ACT)      ASMGF8P    TO PRINT AND/OR PUNCH                   *
*   CEEVAL(ACT)    ASMGF8E    EXPRESSION EVALUATION                   *
*   CSTGER(ACT)    ASMGF8C    FIND SYMBOL IN SYMBOL TABLE             *
*   GETLAT(ACT)    ASMGF8I    GET LITERAL ADDRESS TABLE               *
*   CDCVAL(ACT)    ASMGF8D    DC EVALUATION                           *
*   CLOGER(ACT)    ASMGF8L    LOG ERROR                               *
*   RLDRTN         ASMGF8D    RLD PROCESSING                          *
*   STLOC          ASMGF8D    FOR CCW RLD PROCESSING                  *
*EXITS- NORMAL AND ERROR                                              *
*   RETURN FROM ASMGF8A VIA                                           *
*        B     CTRTRN(ACT)              EXIT                          *
*   RETURN FROM SECSET VIA                                            *
*        BR    SRR                      EXIT                          *
*TABLES/WORKAREAS                                                     *
*   ASMOPR- TRANSFER TABLE FOR ASSEMBLER OP-CODES                     *
*   F8REGS- SAVE AREA FOR REGISTER IN SECSET                          *
*   ERRREGS- SAVE AREA FOR REGISTER ON ERRORS                         *
*NOTES                                                                *
***   F8AOP   ***
*ASSEMBLER OP PROCESSOR
* THIS ROUTINE PROCESSES THE ASSEMBLY OPS WHICH HAVE NOT BEEN
* PREVIOUSLY COMPLETELY PROCESSED.
*                                                                     *
         EJECT
         USING *,FRB
         SR    GRZ,GRZ
         L     GRX,CTWRAPX(ACT)         LOCATION COUNTER ADJUSTED VALUE
         ST    GRZ,CTWRAPX(ACT)         ZERO OUT ADJUSTED LOC CTR
         IC    GRZ,F8WORK+4(ACT)        GET HEX CODE
         MVI   F8INST+15(ACT),X'0F'     DONT PRINT LEFT HAND SIDE
         MVI   ERRSW,X'00'              INITIALIZE ERROR SWITCH
         S     GRZ,NINEEN               SET DISP OF INST RELATIVE TO 0
         BM    MNOTST                   MINUS, PROCESS MNOTE
         OC    PYRSW(1,ACT),F8WORK+5(ACT)  GET ASSEMBLER SWITCH CODE
         SR    GRY,GRY                  ZERO INDEX
         AR    GRZ,GRZ                  FIX FOR HALF WORD GET
         LH    GRZ,ASMOPR(GRZ)          GET RELATIVE ADDRESS
         B     AOPTBL(GRZ)             INDEXED BRANCH TO INSTRUCTION
MNOTST   CLI   F8WORK+4(ACT),KMNOTE     IS THIS RECORD AN MNOTE
         BNE   CTRTRN(ACT)              IF NOT, EXIT
         MVI   REPSW(ACT),X'0F'         SET FOR MNOTE
         B     CTRTRN(ACT)              RETURN
***********************************************************************
***   ASMOPR   ***
*TABLE OF ASSEMBLER OPS TO BE USED IN COMPUTED GO TO
***********************************************************************
ASMOPR   DS    0H
         DC    AL2(PRINTB-AOPTBL)       PRINT DISPLACEMENT
         DC    AL2(SPACE-AOPTBL)        SPACE DISPLACEMENT
         DC    AL2(EJECT-AOPTBL)        EJECT DISPLACEMENT
         DC    AL2(PUNCHB-AOPTBL)       PUNCH DISPLACEMENT
         DC    AL2(REPRO-AOPTBL)        REPRO DISPLACEMENT
         DC    AL2(TITLEB-AOPTBL)       TITLE DISPLACEMENT
         DC    AL2(ENTRYB-AOPTBL)       ENTRY DISPLACEMENT
         DC    AL2(EXTRNB-AOPTBL)       EXTERN DISPLACEMENT
         DC    AL2(STARTB-AOPTBL)       START DISPLACEMENT
         DC    AL2(CSECTB-AOPTBL)       CSECT DISPLACEMENT
         DC    AL2(DSECTB-AOPTBL)       DSECT DISPLACEMENT
         DC    AL2(COMB-AOPTBL)         COMMON DISPLACEMENT
         DC    AL2(EQUB-AOPTBL)         EQUIVALENCE DISPLACE,ENT
         DC    AL2(ORGB-AOPTBL)         ORIGIN DISPLACEMENT
         DC    AL2(ENDB-AOPTBL)         END DISPLACEMENT
         DC    AL2(LTORGB-AOPTBL)       LITORG DISPLACEMENT
         DC    AL2(USINGB-AOPTBL)       USING DISPLACEMENT
         DC    AL2(DROPB-AOPTBL)        DROP DISPLACEMENT
         DC    AL2(LITERB-AOPTBL)       LITERAL DISPLACEMENT
         DC    AL2(DCB-AOPTBL)          DC DISPLACEMENT
         DC    AL2(DSB-AOPTBL)          DS DISPLACEMENT
         DC    AL2(CCWB-AOPTBL)         CCW DISPLACEMENT
         DC    AL2(CNOPB-AOPTBL)        CNOP DISPLACEMENT
         DC    AL2(ASERRB-AOPTBL)       QUIT EXIT  2A
         DC    AL2(DSB-AOPTBL)          DXD  2B
         DC    AL2(DCDSLT-AOPTBL)       CXD   2C
         DC    AL2(RETURN-AOPTBL)       OPSYN 2D
         DC    AL2(EXTRNB-AOPTBL)       WXTRN DISPLACEMENT
         DC    AL2(POPB-AOPTBL)         POP 2F
         DC    AL2(PSHB-AOPTBL)         PUSH 30
         DC    AL2(ASERRB-AOPTBL)      ASSEMBLY ERROR DISPLACEMENT
         DC    AL2(RETURN-AOPTBL)       RETURN TO MAIN LINE CONTROL
AOPTBL   DS    0H                       1ST ASSEMBLER OP LOCATION
***********************************************************************
***   PRINTB   ***
*THIS ROUTINE SCANS THE OPERAND FIELD OF ALL PRINT STATEMENTS AND SETS
* SWITCHES TO BE USED BY THE PRINT AND PUNCH PORTION OF F8OP.
***********************************************************************
PRINTB   MVI   F8INST+15(ACT),X'0F'     DONT PRINT LOCATION COUNTER
         MVC   PNTSAV(12),F8PON(ACT)    SAVE OLD SETTINGS
         MVI   PRNTFLAG,X'00'           TURN ALL FLAGS OFF
         ST    ACT,F8TEMP               SAVE ACT REG.
         L     FRB,PRNT(ACT)            LOAD F8OP BASE REG.
         BALR  SRR,FRB                  CALL PRINT
         L     FRB,ASOPRO(ACT)     LOAD F8AOP BASE REG.
         L     ACT,F8TEMP              RESTORE ACT REG.
         LA    GRY,3                   INITIALIZE PARAMETER COUNT
         SR    GRX,GRX                  ZERO CELL
         L     SP1,F8OPRN(ACT)          OPERAND POINTER
PRNTB1   CLC   0(2,SP1),ONC
         BE    DON                      IF OPERAND 'ON'
         CLC   0(3,SP1),OFFC
         BE    DOFF                     IF OPERAND 'OFF'
         CLC   0(3,SP1),GENC
         BE    DGEN                     IF OPERAND 'GEN'
         CLC   0(5,SP1),NOGENC
         BE    DNOGEN                   IF OPERAND 'NOGEN'
         CLC   0(4,SP1),DATAC
         BE    DDATA                    IF OPERAND 'DATA'
         CLC   0(6,SP1),NDATAC
         BE    DNDATA                   IF OPERAND 'NODATA'
         BAL   SRR,ERRZRO               LOG AN ERRORSWITCH SETTINGS
         DC    AL2(ERRPNT)              UNRECOGNIZABLE PRINT PRAMTR
         MVC   F8PON(12,ACT),PNTSAV     RESTORE OLD SETTINGS
RETURN   B     CTRTRN(ACT)              EXIT
DON      LA    SP2,F8PON(ACT)           SWITCH LOCATION FOR ON
         SR    GRX,GRX                  SET ON
         LA    SP1,2(SP1)               BUMP OPERAND POINTER BY 2
         TM    PRNTFLAG,X'02'           OFF
         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS
         OI    PRNTFLAG,X'01'           ON
         B     CPRNTB                   BRANCH TO COMMON POINT
DOFF     LA    SP2,F8PON(ACT)
         LA    GRX,255                  SET OFF
         LA    SP1,3(SP1)
         TM    PRNTFLAG,X'01'           ON
         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS
         OI    PRNTFLAG,X'02'           OFF
         B     CPRNTB
DGEN     LA    SP2,F8PGEN(ACT)
         SR    GRX,GRX                  SET ON
         LA    SP1,3(SP1)
         TM    PRNTFLAG,X'08'           NOGEN
         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS
         OI    PRNTFLAG,X'04'           GEN
         B     CPRNTB
DNOGEN   LA    SP2,F8PGEN(ACT)         ADDRESS OF GEN SWOTCH
         LA    GRX,255                  SET OFF
         LA    SP1,5(SP1)
         TM    PRNTFLAG,X'04'           GEN
         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS
         OI    PRNTFLAG,X'08'           NOGEN
         B     CPRNTB
DDATA    LA    SP2,F8PDAT(ACT)
         SR    GRX,GRX                  SET ON
         LA    SP1,4(SP1)
         TM    PRNTFLAG,X'20'           NODATA
         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS
         OI    PRNTFLAG,X'10'           DATA
         B     CPRNTB
         LA    SP1,1(SP1)               BUMP PAST FIRST QUOTE
DNDATA   LA    SP2,F8PDAT(ACT)
         LA    GRX,255                  SET OFF
         LA    SP1,6(SP1)
         TM    PRNTFLAG,X'10'           DATA
         BO    PNTOPNER                 CONFLICTING PRINT OPERANDS
         OI    PRNTFLAG,X'20'           NODATA
         B     CPRNTB
PNTOPNER BAL   SRR,ERRZRO               LOG ERROR ETC
         DC    AL2(ERRPNT)              ILLEGAL PRINT OPERAND
         MVC   F8PON(12,ACT),PNTSAV     RESTORE OLD SETTINGS
         B     CTRTRN(ACT)              PRINT NOW FOOL (}) PROOF
CPRNTB   CLI   0(SP1),ICOMMA            IF COMMA, OK
         BE    PDELOK
         CLI   0(SP1),IBLANK            IF BLANK,OK
         BNE   DLMERR                   IF NOT, SYNTAX ERROR
PDELOK   STC   GRX,0(SP2)               SET APPROPRIATE FLAG IN APP LOC
         CLI   0(SP1),ICOMMA            IF COMMA, MORE
         BNE   CTRTRN(ACT)              IF NOT COMMA RETURN TO MLC
         LA    SP1,1(SP1)               IF COMMA BUMP OPERAND POINTER
         BCT   GRY,PRNTB1              IF NOT 3, CONTINUE
         MVC   F8PON(12,ACT),PNTSAV     RESTORE OLD SETTINGS
         B     DLMERR                  3 IS ERROR
***********************************************************************
***   SPACE   ***
*THIS ROUTINE SETS A SWITCH TO BE USED IN THE PRINT PORTION OF F8OP.
***********************************************************************
SPACE    TM    F8PON(ACT),X'FF'         IS PRINT SWITCH ON
         BNZ   SPAC03                   IF NON ZERO, OFF
         TM    F8PGEN(ACT),X'FF'        IS GEN SWITCH ON
         BZ    SPACE00                  YES
         TM    F8WORK+2(ACT),X'10'      IS THIS A GENERATED STATEMENT
         BZ    SPACE00                  NO
SPAC03   SR    SP2,SP2                  ZERO REGISTER
         B     SPAC02                   SET TO SPACE 0 TIMES
SPACE00  CLI   0(SP1),ICOMMA            IS OPERAND BLANK
         BE    SPAC01                   IF COMMA SET TO DO 1 SPACE
         CLI   0(SP1),IBLANK            IF OPERAND BLANK SET TO DO 1
         BE    SPAC01                   BRANCH TO DO 1 SPACE
         CLI   0(SP1),I9                TEST FIRST CHAR FOR DECIMAL
         BH    OPNERR                   IF NOT DECIMAL ERROR
         MVI   CTSDVI(ACT),X'80'        TURN SELF DEFINING SWITCH ON
         L     SRB,CEEVAL(ACT)          BASE FOR EXPRESSION EV ALUATIO
         BALR  SRR,SRB                  EXIT TO EXPRESSION EVALUATION
         BC    1,SPACER                 BRANCH IF ERR IN EVAL
         CLI   0(SP1),IBLANK            IS EXPRESSION DELIMETER BLANK
         BE    SPAC02                   IF YES, SKIP ERROR ROUTINE
         MVI   SPACSW(ACT),X'AA'        TURN SPACE SWITCH HALF ON ERR
         B     DLMERR                   EXIT TO DELIMETER ERROR RTN
SPAC01   LA    SP2,1                    SER TO SPACE ONCE
SPAC02   MVI   SPACSW(ACT),X'FF'        TURN SPACE SWITCH ON
         B     CTRTRN(ACT)              EXIT FROM F8AOP
OPNERR   BAL   SRR,ERRZRO               GO TO LOG ERROR
         DC    AL2(ERROPN)              OPERAND ERROR CODE
SPACER   MVI   SPACSW(ACT),X'AA'        SET SPACE SWITCH FOR ERROR
         XC    F8INST(3,ACT),F8INST(ACT)   ZERO INSTRUCTION COUNTER
         MVI   F8INST+15(ACT),X'00'     PRINT LEFT HALF
         SR    SP2,SP2                  SET TO NOT SPACE
         B     CTRTRN(ACT)              EXIT FROM F8AOP
***********************************************************************
***   EJECT   ***
*THIS ROUTINE SETS A SWITCH TO BE USED IN THE PRINT PORTION OF F8OP.
***********************************************************************
EJECT    TM    F8PGEN(ACT),X'FF'        IS GEN SWITCH ON
         BZ    EJECT01                  IF ZERO DO EJECT
         TM    F8WORK+2(ACT),X'10'      IS THIS A GENERATED STATEMENT
         BNZ   EJECT02                  ITS GENERATED DONT EJECT
EJECT01  MVI   EJCTSW(ACT),X'FF'        SET TO EJECT
EJECT02  B     CTRTRN(ACT)              EXIT TO MAIN LINE CONTROL
***********************************************************************
***   PUNCHB   ***
*THIS ROUTINE SETS A SWITCH TO BE USED IN F8OP.
***********************************************************************
PUNCHB   MVI   REPSW(ACT),X'01'         TURN ON PUNCH
         B     CTRTRN(ACT)              EXIT
***********************************************************************
***   REPRO   ***
*THIS ROUTINE SETS A SWITCH TO BE USED IN F8OP.
***********************************************************************
REPRO    MVI   REPSW(ACT),X'03'         TURN ON REPRO
         B     CTRTRN(ACT)              EXIT
***********************************************************************
***   TITLEB   ***
*THIS ROUTINE CHANGES THE TITLE TO BE PRINTED AT THE TOP OF EACH PAGE
* AND THEN CALLS THE EJECT ROUTINE
***********************************************************************
TITLEB   MVI   REPSW(ACT),X'07'         SET TITLE SWITCH
         TM        F8PGEN(ACT),X'FF'   IS GEN SW ON
         BZ        EJECT01             BRANCH IF NOT
         TM        F8WORK+2(ACT),X'10' IS THIS A GENERATED RECORD
         BNO       EJECT01             BRANCH IF NOT
         LH        SP2,CTSEQ8+2(,ACT)  GET STMT CTR
         BCTR      SP2,0               DECREMENT IT
         STH       SP2,CTSEQ8+2(,ACT)  STORE UPDATED STMT COUNTER
         B         CTRTRN(,ACT)        RETURN
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
***      ENTRYB   ***
*THIS ROUTINE ONLY MAKES A VALIDITY CHECK OF THE OPERAND FIELD OF ALL
* ENTRY STATEMENTS, OTHER PROCESSING WAS COMPLETED IN INTERLUDE
***********************************************************************
ENTRYB   MVC   WKBKPT(4,ACT),CTXWBP(ACT) SET WORK BUCKET POINTER
ENTRYC   L     ACC,WKBKPT(ACT)          CURRENT WORK BUCKER POINTER
         LTR   ACC,ACC                  IS THERE A BUCKET
         BZ    CTRTRN(ACT)              IF ZERO, NO BUCKET
         CLI   TXSPTR(ACC),ECMPLT       IS WORKBUCKET COMPLETE
         BE    ENSEX                    YES - IGNORE
         SR    SP1,SP1                  NO, ZERO LENGTH
         LR    SP2,SP1                  AND PREPARE FOR ADDRESS OF NAME
         IC    SP1,TXSPTR(ACC)          GET
         A     SP1,F8OPRN(ACT)           NAME POINTER
         ST    SP1,ENTSAVE              SAVE POINTER
         IC    SP2,TXSESL(ACC)          GET
         N     SP2,LENMSK                NAME LENGTH
         L     SRB,CSTGET(ACT)          GET SYMBOL ATTRIBUTES
         BALR  SRR,SRB                  CALL STGETR - ASMGF8S
         LTR   SP1,SP1                  WAS SYMBOL FOUND
         BZ    ENSER1                   NO, LOG ERROR
         TM    ADJCD(SP1),X'40'         IS SYM EQUATED TO EXTRN .Q
         BO    ENSER3                   YES, ENTRY ERROR
         CLI   STID(SP1),0              IS SYMBOL ABSOLUTE
         BE    ENSER2                   YES, LOG ERROR
         TM    ADJCD(SP1),DSOCM         DEFINED IN DSECT OR COM
         BO    ENSER3                   YES, LOB ERROR
         TM    ADJCD(SP1),ENTCMB        IS ENTRY COMPLETE
         BO    ENSER3                   YES, LOG ERROR
         OI    ADJCD(SP1),ENTCMB         SET ADJ CODE COMPLETE
         TM    ADJCD(SP1),SDBIT         IS ADJ CODE = SD
         BM    ENSER3                   ERROR IF DSECT OR EXTRN
ENSEX    L     ACC,WKBKPT(ACT)
         TM    EWBKSW(ACC),LASTOP       IS THIS THE LAST OPERAND
         BO    CTRTRN(ACT)              YES - EXIT
         LA    ACC,WBKLEN(ACC)          SET FOR NEXT WKBKT
         ST    ACC,WKBKPT(ACT)          SAVE POINTER
         B     ENTRYC                   TRY FOR NEXT
ENSER1   L     SP1,ENTSAVE              LOAD OPERAND POINTER
         BAL   SRR,ERRNO0               LOG ERROR
         DC    AL2(ERRUDF)             UNDEFINED SYMBOL
         B     ENSEX                    LOOK FOR OPERANDS
ENSER2   L     SP1,ENTSAVE              LOAD OPERAND POINTER
         BAL   SRR,ERRNO0               LOG ERROR
         DC    AL2(ERRLOC)              EXTERNAL NAME ERROR
         B     ENSEX                    LOOK FOR MORE OPERANDS
ENSER3   L     SP1,ENTSAVE              LOAD OPERAND POINTER
         BAL   SRR,ERRNO0               LOG ERROR
         DC    AL2(ERRNTY)             ENTRY ERROR
         B     ENSEX                    LOOK FOR MORE OPERANDS
ACC      EQU   GRX                      ACCUMULATOR
ADJCD    EQU   1                        POSITION OF ADJECTIVE CODE
DSOCM    EQU   4                        DSECT OR COMMON MASK
ECMPLT   EQU   X'FF'                    WORKBUCKET COMPLETE FLAG
ENTCMB   EQU   X'08'                    ENTRY COMPLETE FLAG
EWBKSW   EQU   TXSESL                   SYMBOL LENGTH POINTER
LASTOP   EQU   X'80'                    LAST OPERAND MASK
SDBIT    EQU   3                        CSECT MASK
STID     EQU   2                        POSITION OF SYMBOL ID
WBKLEN   EQU   6                        LENGTH OF WORKBUCKETS
         DS    0F
LENMSK   DC    X'0000000F'              MASK FOR MAX LENGTH OF SYMBOL
***********************************************************************
***   EXTRNB   ***
*THIS ROUTINE RETURNS TO F8MLC, PROCESSING WAS DONE IN INTERLUDE
***********************************************************************
EXTRNB   B     CTRTRN(ACT)              EXIT
***********************************************************************
***   STARTB   ***
*THIS ROUTINE SETS CURRENT TYPE, CURRENT ESD-ID, CURRENT ADJUSTMENT
* BASE (BY CALLING SETSEC)
***********************************************************************
STARTB   TM    CTPCSW(ACT),X'FF'
         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION
         BNZ   CSECTB                   PROCESS AS CSECT
         L     SP2,WKBKPT(ACT)          WORK BUCKET POINTER
START01  MVC   CTYPE(1,ACT),1(SP2)     WK BKT TO CURRENT TYPE CELL
         SR    GRY,GRY                  ZERO CELL
         IC    GRY,2(SP2)               CURRENT ESD-ID FROM WORK BUCKET
         STC   GRY,CESDID(ACT)          TO TABLE
         STC   GRY,CESDIDPS(ACT)        SET ESDID SW ON
         L     SP1,CADJBS(ACT)          ADJUSTMENT TABLE BASE
         LR    SP2,GRY
         BAL   SRR,SETSEC               CSECT SETTING ROUTINE
         B     CTRTRN(ACT)              EXIT
***********************************************************************
***   CSECTB   ***
*THIS ROUTINE SETS CURRENT TYPE, CURRENT ESD-ID AND CURRENT ADJUSTMENT
* BASE (VIA SETSEC ROUTINE)
***********************************************************************
CSECTB   MVC   TSTYPE(1),F8WORK+2(ACT)  MOVE TYPE OF OP FOR ALTERATION
         NI    TSTYPE,X'70'             KEEP JUST TYPE OF OPERATION
         CLI   TSTYPE,X'50'             IS THIS AFTER END CARD
         BE    CSECT2                   IF EQUAL SET FLAG FF
         MVI   F8INST+15(ACT),X'00'     JUST EJECT CARD AND PRINT LOC
CSECT2   OI    F8INST+15(ACT),X'F0'     SET FLAG TO EJECT CARD
         L     SP2,WKBKPT(ACT)          WORK BUCKET POINTER
         CLC   2(1,SP2),CESDID(ACT)     WORK BUCKET ESD-ID VS CURRENT
         BNE   START01                 COMMON CODE FOR START AND CSECT
         B     CTRTRN(ACT)             IF CSECT SAME NO ACTION NEEDED
***********************************************************************
***   DSECTB   ***
*THIS ROUTINE SETS CURRENT TYPE, CURRENT ESD-ID AND SETS CURRENT
* ADJUSTMENT BASE EQUAL TO ZERO.
***********************************************************************
DSECTB   L     SP2,WKBKPT(ACT)          WORK BUCKET POINTER
         MVI   F8INST+15(ACT),X'F0'     START A NEW CARD
         MVI   CESDIDPS(ACT),X'00'      SET ESDID FLAG OFF
         CLC   2(1,SP2),CESDID(ACT)     WORK BUCKET ESD-ID VS CURRENT
         BE    CTRTRN(ACT)              RETURN TO MAIN LINE CONTROL
         SR    GRY,GRY                  ZERO CELL
         IC    GRY,1(SP2)               CURRENT TYPE FROM WORK BUCKET
         STC   GRY,CTYPE(ACT)           TO CURRENT TYPE CELL
         IC    GRY,2(SP2)
         STC   GRY,CESDID(ACT)          CURRENT ESD-ID
         SR    SP2,SP2
         ST    SP2,F8CADJ(ACT)
         MVC   F8INST(3,ACT),F8CADJ(ACT)  ZERO TO LOCATION
*./      DELETE    SEQ1=07720020,SEQ2=07720020
         B     CTRTRN(ACT)              EXIT
***********************************************************************
***   COMB   ***
*SEE DSECT, THE FUNCTIONS ARE THE SAME
***********************************************************************
COMB     EQU   DSECTB                   COMMON IS HANDLED LIKE DSECT
***********************************************************************
***   EQUB   ***
*THIS ROUTINE PUTS THE EQUATED VALUE FOR PRINTING, IF THE VALUE IS
* NOT ABSOLUTE, IT IS COMPUTED VIA F8AREX.
***********************************************************************
EQUB     L     GRZ,CTXABP(ACT)          GET FIRST BYTE OF TEXT APPENDED
         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION
         MVC   F8INST(3,ACT),0(GRZ)     EQUATED VALUE TO ADDR FLD
*        TM    4(GRZ),X'FF'             IS IT ABSOLUTE
*        BZ    CTRTRN(ACT)              YES, RETURN
         BAL   SRR,F8AREX               NO, EVALUATE
         TM    EVLERF,X'FF'             IS EXPRESSION EVAL ERROR ON
         BO    EQUERR                   YES, LOG ERROR
         MVC   F8INST(3,ACT),VALUEB+1   MOVE IN INSTRUCTION COUNTER
         MVI   F8INST+3(ACT),X'32'      BLANK OUT REST OF LINE
         MVC   F8INST+4(11,ACT),F8INST+3(ACT)
         B     CTRTRN(ACT)              RETURN TO MAIN LINE
***********************************************************************
***   ORGB   ***
*THIS ROUTINE SETS A SPECIAL FLAG FOR F8OP ROUTINE.
***********************************************************************
ORGB     MVC   TSTYPE(1),F8WORK+2(ACT)  MOVE TYPE OF OP FOR ALTERATION
         ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOCATION CTR
         L     GRX,CTXABP(,ACT)         POINT AT EXTENDED INT RECORD
         MVC   ALIGNT+1(3),5(GRX)       ALIGN PREV RELATIVE LOCATION
         MVI   ALIGNT,X'00'             ZERO IN FIRST BYTE
         L     GRZ,ALIGNT               LOAD RELATIVE LOCATION
         A     GRZ,F8CADJ(,ACT)         CURRENT ESD-ID ADJUSTMENT
         ST    GRZ,ALIGNT               STORE ABSOLUTE LOCATION
         MVC   F8INST(3,ACT),ALIGNT+1   PLACE PREV LOC CTR FROM REC
         MVC   F8INST+3(3,ACT),CTWRAPX+1(ACT) PRINT NEW LOC COUNTER
         NI    TSTYPE,X'70'             KEEP JUST TYPE OF OPERATION
         CLI   TSTYPE,X'50'             IS THIS AFTER END CARD
         BE    ORG1                     YES, DONT PRINT LOC
         MVI   F8INST+15(ACT),X'00'     JUST EJECT CARD AND PRINT LOC
ORG1     OI    F8INST+15(ACT),X'F0'     SET FLAG TO EJECT CARD
         SR    SP1,SP1                  LOG ERROR WITHOUT COL PTR
         TM    CTWRAPX(ACT),X'FF'       TEST FOR ORG ERROR
         BC    5,ORGERR                 IF MIXED, ORG ERROR
         B     CTRTRN(ACT)              EXIT
ORGERR   BAL   SRR,ERRZRO               LOG ORG ERROR
         DC    AL2(ERRORG)              ORG ERROR CODE
*./      DELETE    SEQ1=08540020,SEQ2=08540020
         LA    GR0,1
         ST    GR0,CTWRAPX(ACT)         FIX SO DECREMENT WONT HURT
         B     CTRTRN(ACT)              RETURN TO MAIN LONE CONTROL
***********************************************************************
***   ENDB   ***
*THIS ROUTINE TURNS ON THE END SWITCH AND PUTS THE ADDRESS IN THE
* OPERAND FIELD OF THE END CARD
***********************************************************************
ENDB     MVI   CTIDR(ACT),C'1'          SET 1 IDR FIELD
         CLI   0(SP1),IBLANK            IS DELIMETER BLANK .Q
         MVI       CTENDSW(ACT),X'FF'  TURN ON END SWITCH
         BNE   END04                    NO, TRY A COMMA
END00    XC    ENDSWH(4,ACT),ENDSWH(ACT)  YES, ZERO TO ESD-ID & COUNT
         MVI   F8INST+15(ACT),X'0F'     SUPPRESS PRINTIOG OF LOC CTR
         B     CTRTRN(ACT)              EXIT
END01    BAL   SRR,F8AREX               EVALUATE EXPRESSION
         TM    SREXP,X'01'              IS IT SIMPLY RELOCATABLE
         BNZ   END02                    IF NOT, ERROR
         CLC   CTNDID+1(1,ACT),VALUEB+5 NEXT DSECT ESDID VS THIS ESDID
         BL    END02                    IF NOT LOWER, CSECT OR COMMON
END03    CLC   CTCMSW(1,ACT),VALUEB+5   IS THIS COMMON
         BE    END02                    IF COMMOM, ERROR
         MVC   ENDSWH(4,ACT),0(SP2)     IF YES, SET VALUE
         MVC   ENDSWH(1,ACT),5(SP2)     ESD-ID TO FIRST BYTE
         MVC   F8INST(3,ACT),1(SP2)     SET CORRECT LOC FOR LISTING
         TM    F8INST+2(ACT),X'01'      IS END ALIGNED CORRECTLY
         BZ    END05                    IF ZERO, YES
         BAL   SRR,ERRNO0               LOG ALIGNMENT ERROR
         DC    AL2(ERRLIN)              ALIGNMENT ERROR
END05    CLI   0(SP1),IBLANK            IS DELIMETER A BLANK
         BE    END06                    YES, 2ND FIELD OMITTED
         CLI   0(SP1),ICOMMA            COMMA FOLLOWS .Q
         BNE   DLMERR                   NO, THEN ERROR
         B     END07                    YES, SCAN 2ND FIELD
END06    MVI   F8INST+15(ACT),X'00'     ZERO TO PRINT LOCATION COUNTER
         B     AOPRTN                   NORMAL EXIT
END04    CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   END01                    IF NOT, EVALUATE EXPRESSION
         CLI   1(SP1),IBLANK            IS COMMA FOLLOWED BY BLANK
         MVI   F8INST+15(ACT),X'0F'     SUPPRESS PRINTING OF LOC CTR
         BNE   END075                   IF NOT, GET OPERAND
         B     END00                   TREAT AS BLANK END CARD
END02    BAL   SRR,ERRNO0               LOG ERROR
         DC    AL2(ERRLOC)              RELOCATABILITY ERROR
         B     AOPRTN                  ZERO LOCATION
END07    MVI   F8INST+15(ACT),X'00'     ZERO TO PRINT LOC CTR
END075   CLI   1(SP1),ILPARN            LPAREN SHOULD FOLLOW
         BE    END077                   PROCESS IF SO
         CLI   1(SP1),IBLANK            ALSO OK IF BLANK FOLLOWS
         BNE   DLMERR                   ANY OTHER CHAR IS ERROR
         B     END06                    GO PRINT
END077   LA    SP1,2(,SP1)              STEP PAST DELIMITERS
         LA    GRZ,10                   1ST SUBFIELD MAX OF 10 BYTES
         LR    GRY,ACT                  INIT TO MOVE FIELD
END08    CLI   0(SP1),ICOMMA            HAVE WE FOUND A COMMA .Q
         BE    END09                    BRANCH AT END OF FIRST
         MVC   CT2IDR(1,GRY),0(SP1)     SAVE BYTE FOR END CARD
         LA    GRY,1(,GRY)              BUMP CT2IDR POINTER
         LA    SP1,1(,SP1)              AND CARD POINTER
         BCT   GRZ,END08                BRANCH IF STILL POSITIVE
         CLI   0(SP1),ICOMMA            COMMA SHOULD DELIMIT
         BNE   DLMERR                   ERROR IF NOT
         LTR   GRZ,GRZ                  WAS IT EXACTLY 10 CHARS .Q
         BZ    END10                    BRANCH IF YES
END09    MVI   CT2IDR(GRY),IBLANK       NO, FILL FIELD WITH BLANKS
         LA    GRY,1(,GRY)              BUMP C2IDR POINTER
         BCT   GRZ,END09                BRANCH IF STILL POSITIVE
END10    MVC   CT2IDR(4,GRY),1(SP1)     SAVE VLML FOR END CARD
         CLI   5(SP1),ICOMMA            SHOULD BE A COMMA
         BNE   DLMERR                   ERROR IF NOT
         LA    GRY,4(,GRY)              UPDATE CT2IDR POINTER
         LA    SP1,6(,SP1)              UPDATE CARD POINTER
         MVC   CT2IDR(5,GRY),0(SP1)     SAVE JULIAN DATE FOR END CARD
         CLI   5(SP1),IRPARN            SHOULD END WITH RPAREN
         BNE   DLMERR                   ERROR IF NOT
         MVI   CTIDR(ACT),C'2'          INDICATE 2 IDR'S IN END CARD
         L     GRZ,CTRTBP(,ACT)         LOAD TRANSLATE TABLE POINTER
         TR    CT2IDR(19,ACT),0(GRZ)    TRANSLATE TO EXTERNAL CODE
         CLI   F8INST+15(ACT),X'00'     PRINT LOC CTR .Q
         BNE   END00                    BRANCH IF NOT
         B     AOPRTN                   OTHERWISE, YES
***********************************************************************
***   LTORGB   ***
*THIS ROUTINE TESTS TO SEE IF ANY LITERALS NEED BE OUTPUT. IF LITERALS
* ARE TO BE OUTPUT, THE ADJUSTED LOCATION OF THE FIRST LITERAL IS
* PUT FOR OUTPUT IN THE LOCATION FIELD. IF NO LITERALS ARE TO BE OUTPUT
* CONTROL IS RETURNED TO F-, MAIN LINE CONTROL. LOCATION COUNTER
* REMAINS CURRENT LOCATION COUNTER.
***********************************************************************
LTORGB   MVC   TSTYPE(1),F8WORK+2(ACT)  MOVE TYPE OF OP FOR ALTERATION
         ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOCATION CTR
         NI    TSTYPE,X'70'             KEEP JUST TYPE OF OPERATION
         CLI   TSTYPE,X'50'             IS THIS AFTER END CARD
         BE    LTORG0                   YES, DONT PRINT LOC
         MVI   F8INST+15(ACT),X'00'     JUST EJECT CARD AND PRINT LOC
LTORG0   OI    F8INST+15(ACT),X'F0'     SET FLAG TO EJECT CARD
         TM    TXESI(GRA),LITQ          DOES LAT HAVE TO BE READ IN
         BZ    LTORG1                   NO
         L     SRB,CTXTIO(ACT)            YES - GET NEXT LIT ADJ TABLE
         BAL   SRR,GETLAT(SRB)          CALL LAT GET
         ST    SP1,LATP(ACT)            SAVE POINTER
LTORG1   L     ACC,CTXABP(ACT)
         MVC   TEMPF+1(3),TXLOC(ACC)    GET LOC CTR FROM TEXT
         L     ACC,TEMPF
         A     ACC,F8CADJ(ACT)            ADJUST
         ST    ACC,CTLOC(ACT)           SET CURRENT LOC CNT
         B     CTRTRN(ACT)              EXIT
LITQ     EQU   2
TEMPF    DC    F'0'                     FULL WORD FOR ALIGNMENT
***********************************************************************
***   USINGB   ***
*THIS ROUTINE SETS AN INDICATOR FLAG TO INDICATE A REGISTER MAY BE USED
* AS A BASE REGISTER.  THE VALUE FOR DECOMPOSITION IS HELD IN THE THREE
* LOW ORDER BYTES AND THE ESD-ID IS LOGICALLY ADDED INTO THE HIGH ORDER
* BYTE.
***********************************************************************
USINGB   MVI   BUSING,X'00'             TURN USING OFF
         MVI   USINGR0,X'00'            SET 1ST TIME V REG SWITCH TO 0
         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION
         LA    GRB,16                  PROCESS ONLY 16 REGISTERS
         SR    GRD,GRD                 ZERO ESD-ID REGISTER
         L     SRB,CEEVAL(ACT)          EEVAL ENTRY AND BASE
         BALR  SRR,SRB                  EVALUATE EXPRESSION
         BC    8,VALUEK                 ABSOLUTE EXPRESSION
         BC    4,SIMREL                 SIMPLY RELOCATABLE EXPR
         BC    2,ERRUSG                 COMPLEXLY RELOCATABLE EXPR
         BC    1,EREVL                  EXPRESSION EVALUATION ERROR
SIMREL   CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   DLMERR                   IF NOT COMMA, SYNTAX ERROR
         LR    GRY,SP2
         IC    GRD,5(SP2)              ESD-ID
         L     GRX,0(SP2)              VALUE
         B     US01
VALUEK   LR    GRX,SP2                  ABSOLUTE VALUES
         SR    GRD,GRD                  ZERO GRD FOR ESD-ID
US01     CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   DLMERR                   NO, ERROR
         STC   GRD,ESDUSG               TEMP STORE ESD-ID
         ST    GRX,VALUEB               VALUE TO VALUEB
         MVI   BUSING,X'FF'             TURN USING OFF
         MVI   USGFLG,X'FF'             FF INDICATES USING, NOT DROP
         MVC   F8INST(3,ACT),VALUEB+1   VALUE TO F8INST
         LA    SP1,1(SP1)               POINT AT NEXT OPRN ARG
US02     ST    GRX,F8TEMP               STORE LOC FOR USING
USIROP   BAL   SRR,F8AREX               EXPRESSION SEIVE
         IC    GRZ,BUSING
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BE    DELOKB                   IF COMMA,OK
         CLI   0(SP1),IBLANK            IS DELIMETER BLANK
         BNE   DLMERR                   IF NOT BLANK, OR COMMA, ABORT
DELOKB   TM    AEXP1,X'01'              SIZE AND ABLOLUTE TEST
         BZ    QUANOKQ                  IF 0, QUANTITY OK, CHECK REG 0
         B     ERQNDU                   REGISTER ERROR
QUANOKT  TM    USGFLG,X'FF'             IS THIS USING STMNT
         BZ    QUANOK                   IF ZERO, ITS A DROP
         CLI   VALUEB+3,X'00'           IS REGISTER ZERO
         BE    ERQNDU                   IF ZERO REGISTER ERROR
         B     QUANOK                   BRANCH OK
QUANOKQ  OC    USINGR0(1),VALUEB+3      CURRENT REGISTER V 1ST TIME SW
         TM    USINGR0,X'FF'            IS THIS 1ST TIME & REG 0
         BNZ   QUANOKT                  IF NON-ZERO TEST REGISTER
         TM    ESDUSG,X'FF'             IS THIS ABSOLUTE
         BNZ   QUANOO                   IF NOT, DONT CHECK FURTHER
         L     GR0,F8TEMP               VALUE FOR USING
         LTR   GR0,GR0                  IS IT ABSOLUTE ZERO
         BNZ   ERQNDU                   IF NOT, ERROR
QUANOO   SR    GR0,GR0                  ZERO TO REGISTER 0
         ST    GR0,F8TEMP               REG 0 VALUE ALWAYS 0
QUANOK   L     GRY,VALUEB               QUANTITY (REG)
         L     GRC,USNGPP(ACT)
         TM    USGFLG,X'FF'             IS THIS USING, OR DROP
         BO    USGSKP                   IF 1, IT IS USING
         LA    GR1,0(GRY,GRC)           ADDR OF THIS USING TBL FLAG
         TM    0(GR1),X'FF'             IS THIS BEING USED
         BO    USGSKP                   YES
         BAL   SRR,ERRZRO               ERROR ROUTINE BRANCH
         DC    AL2(ERDROP)              REGISTER TO BE DROPED NOT USED
USGSKP   STC   GRZ,0(GRY,GRC)           STORE FLAG IN USING POINTER
         SLL   GRY,2
         L     GRX,F8TEMP               PICK UP SUMMED VALUE AND ESDID
         L     GR2,USNGTP(ACT)
         ST    GRX,0(GRY,GR2)           VALUE TO USING TABLE
         IC    GRD,ESDUSG               ESD-ID THIS VALUE
         STC   GRD,0(GRY,GR2)          ESD-ID TO 1ST BYTE OF VALUE
         BAL   SRB,USDPTBL              SET UMAP ENTRY
TESNDU   CLI   0(SP1),IBLANK            IS IT A BLANK
         MVI   USINGR0,X'FF'            SET FIRST TIME SWITCH OFF
         BE    CTRTRN(ACT)              IF BLANK, EXIT
         LA    SP1,1(SP1)               NO
         AL    GRX,K4096                BUMP TO NEXT AVAILABEL
         BCT   GRB,US03                 DO 16 TIMES
LNGERR   BAL   SRR,ERRZRO               CALL LOG ERROR
         DC    AL2(ERRLNG)             OPERAND LENGTH ERROR
         MVI   F8INST+15(ACT),X'0F'     DONT PRINT LOCATION COUNTER
         B     CTRTRN(ACT)              EXIT
ERRUSG   BAL   SRR,ERRZRO               ERROR ROUTINE BRANCH
         DC    AL2(ERRLOC)              RELOCATABILITY ERROR
         MVI   F8INST+15(ACT),X'0F'     DONT PRINT LOCATION COUNTER
         B     CTRTRN(ACT)              EXIT
US03     ST    GRX,F8TEMP               PUT FOR FUTURE USE
US04     NI    F8TEMP,X'00'             ZERO TO BYTE
         B     USIROP                   DO NEXT REGISTER
***********************************************************************
***   DROPB   ***
*THIS ROUTINE SETS AN INDICATOR FLAG TO INDICATE A REGISTER MAY NOT BE
* USED AS A BASE REGISTER.
***********************************************************************
DROPB    MVI   USGFLG,X'00'             TURN USING FLAG OFF
         MVI   BUSING,X'00'             USING POINTER FLAG TO 0
         LA    GRB,16                  PROCESS ONLY 16 REGISTERS
         SR    GRD,GRD                 ZERO ESD-ID REGISTER
         SR    GRX,GRX                 ZERO VALUE
         STC   GRD,ESDUSG               ZERO ESD-ID FOR ABSOLUTE
         TM    CTEXTENI(ACT),X'04'      IS 'EXTEN' ON .Q
         BNO   US02                     COMMON ENTRY IF NOT
         CLI   0(SP1),IBLANK            IS OPND A BLANK .Q
         BE    DROPB1                   EXTENDED DROP IF YES
         CLI   0(SP1),ICOMMA            IS OPND A COMMA .Q
         BNE   US02                     NO EXTENDED DROP IF NOT
DROPB1   DS    0H
         BAL   SRR,DROPEX               DO ALL APPROPRIATE DROPS
         B     CTRTRN(,ACT)             AND EXIT
DROPEX   DS    0H
         L     GRC,USNGPP(,ACT)         USING STATUS TABLE POINTER
         SR    GRB,GRB                  START WITH REGISTER ZERO
DROPEX1  DS    0H
         LA    GR1,0(GRB,GRC)           USING TABLE STATUS ENTRY
         CLI   0(GR1),X'FF'             IS REGISTER IN USE .Q
         BNE   DROPEX2                  BRANCH IF NOT
         ST    GRB,VALUEB               PASS ON THE REGISTER
         BAL   SRB,USDPTBL              SET UMAP ENTRY
         MVI   0(GR1),X'00'             DROP THE REGISTER
         L     GR2,USNGTP(,ACT)         USING TABLE POINTER
         LR    GRY,GRB                  REGISTER JUST DROPPED
         SLL   GRY,2                    4 BYTES PER ENTRY
         ST    GRX,0(GRY,GR2)           ZERO ESD-ID, DISPLACEMENT
DROPEX2  DS    0H
         LA    GRB,1(,GRB)              NEXT REGISTER
         C     GRB,K16                  ALL DONE REGISTERS .Q
         BL    DROPEX1                  AGAIN IF NOT DONE
         BR    SRR                      EXIT WHEN DONE
***********************************************************************
***   POP   ***
* THIS ROUTINE SCANS THE OPERAND FIELD OF ALL POP STATEMENTS
* AND RESTORES ANY APPROPRIATE VALUES.
***********************************************************************
POPB     DS    0H
         MVI   F8INST+15(ACT),X'0F'     DON'T PRINT LOCATION COUNTER
         L     SP1,F8OPRN(,ACT)         OPERAND POINTER
POPB1    DS    0H
         CLC   PRINTC,0(SP1)            IS OPERAND 'PRINT' .Q
         BE    POPPRINT                 BRANCH IF YES
         CLC   USINGC,0(SP1)            IS OPERAND 'USING' .Q
         BE    POPUSING                 BRANCH IF YES
         BAL   SRR,ERRZRO               LOG AN ERROR
         DC    AL2(ERRPOP)              UNRECOGNIZABLE POP OPERAND
         B     CTRTRN(,ACT)             AND EXIT
POPPRINT DS    0H
         LH    GR1,CTPRPP(,ACT)         CURRENT PRINT PUSH/POP COUNT
         BCTR  GR1,0                    DECREMENT BY ONE
         LTR   GR1,GR1                  IS IT NON-NEGATIVE .Q
         BM    DBALERR                  BRANCH IF NEGATIVE
         STH   GR1,CTPRPP(,ACT)         SET NEW PRINT PUSH/POP COUNT
         MH    GR1,LENPNTSK             TIMES LENGTH OF ONE ENTRY
         LA    GR1,PNTSTAK(GR1)         ADDR OF SAVED PRINT STATUS
         MVC   F8PON(L'PNTSTAK,ACT),0(GR1)  RESTORE OLD SETTINGS
         LA    SP1,L'PRINTC(,SP1)       POINT PAST ARGUMENT
         B     CPOPB                    AND CONTINUE
POPUSING DS    0H
         MVI   USGFLG,X'00'             TURN USING FLAG OFF
         SR    GRX,GRX                  ZERO VALUE
         LH    GR1,CTUSPP(,ACT)         CURRENT USING PUSH/POP COUNT
         BCTR  GR1,0                    DECREMENT BY ONE
         LTR   GR1,GR1                  IS IT NON NEGATIVE .Q
         BM    DBALERR                  BRANCH IF NEGATIVE
         STH   GR1,CTUSPP(,ACT)         SET NEW PUSH/POP COUNT
         BAL   SRR,DROPEX               DO ALL APPROPRIATE DROPS
         LH    GR1,CTUSPP(,ACT)         RESTORE USING PUSH/POP COUNT
         SLL   GR1,L'USGSTAK/4          TIMES LENGTH USING STATUS
         LA    GRB,USGSTAK(GR1)         ADDR OF USING STATUS BYTES
         L     GRC,USNGPP(,ACT)         USING STATUS TABLE
         MVC   0(L'USGSTAK,GRC),0(GRB)  RESTORE USING STATUS INFO
         SLL   GR1,2                    NOW UP TO 64 TIMES
         LA    GRB,USGAREA(GR1,ACT)     POINT TO USING SAVED AREA
         L     GRC,USNGTP(,ACT)         USING TABLE ADDRESS
         MVC   0(64,GRC),0(GRB)         RESTORE USING TABLE
         MVI   USGFLG,X'FF'             TURN USING FLAG ON
         L     GRC,USNGPP(,ACT)         USING STATUS TABLE
         SR    GRB,GRB                  START WITH REGISTER ZERO
POPUS1   DS    0H
         LA    GR1,0(GRB,GRC)           USING TABLE STATUS ENTRY
         CLI   0(GR1),X'FF'             IS REGISTER IN USE
         BNE   POPUS2                   BRANCH IF NOT
         ST    GRB,VALUEB               PASS ON REGISTER
         BAL   SRB,USDPTBL              SET UMAP ENTRY
POPUS2   DS    0H
         LA    GRB,1(,GRB)              NEXT REGISTER
         C     GRB,K16                  ALL DONE REGISTERS .Q
         BL    POPUS1                   AGAIN IF NOT DONE
         LA    SP1,L'USINGC(,SP1)       POINT PAST ARGUMENT
CPOPB    DS    0H
         CLI   0(SP1),ICOMMA            IS A COMMA NEXT .Q
         BE    POPDELOK                 BRANCH IF YES
         CLI   0(SP1),IBLANK            IS A BLANK NEXT .Q
         BE    CTRTRN(,ACT)             RETURN IF SO
         B     DLMERR                   OTHERWISE, SYNTAX ERROR
POPDELOK DS    0H
         LA    SP1,1(,SP1)              BUMP TO NEXT OPND
         B     POPB1                    AND CONTINUE
***********************************************************************
***   PUSH   ***
* THIS ROUTINE SCANS THE OPERAND FIELD OF ALL PUSH
* STATEMENTS AND STACKS APPROPRIATE TABLES.
***********************************************************************
PSHB     DS    0H
         MVI   F8INST+15(ACT),X'0F'     DON'T PRINT LOCATION COUNTER
         L     SP1,F8OPRN(,ACT)         OPERAND POINTER
PSHB1    DS    0H
         CLC   PRINTC,0(SP1)            IS OPERAND 'PRINT' .Q
         BE    PSHPRINT                 BRANCH IF YES
         CLC   USINGC,0(SP1)            IS OPERAND 'USING' .Q
         BE    PSHUSING                 BRANCH IF YES
         BAL   SRR,ERRZRO               LOG AN ERROR
         DC    AL2(ERRPSH)              UNRECOGNIZABLE PUSH OPND
         B     CTRTRN(,ACT)             AND EXIT
PSHPRINT DS    0H
         LH    GR1,CTPRPP(,ACT)         CURRENT PRINT PUSH/POP COUNT
         LA    GR1,1(,GR1)              BUMP BY ONE
         C     GR1,NESTPSPO             IS NESTING LEVEL OK .Q
         BH    DBALERR                  BRANCH IF NOT
         STH   GR1,CTPRPP(,ACT)         SET NEW PRINT PUSH/POP COUNT
         MH    GR1,LENPNTSK             TIMES LENGTH OF ONE ENTRY (12)
         LA    GR1,PNTSTAK-L'PNTSTAK(GR1)  ADDR OF SAVE PRINT AREA
         MVC   0(L'PNTSTAK,GR1),F8PON(ACT)  SAVE OLD SETTINGS
         LA    SP1,L'PRINTC(,SP1)       POINT PAST ARGUMENT
         B     CPSHB                    AND CONTINUE
DBALERR  DS    0H
         BAL   SRR,ERRZRO               LOG THE ERROR
         DC    AL2(ERRPSPO)             UNBALANCED PUSH/POP REQUESTS
         B     CTRTRN(,ACT)             AND RETURN
PSHUSING DS    0H
         LH    GR1,CTUSPP(,ACT)         CURRENT USING PUSH/POP COUNT
         LA    GR1,1(,GR1)              BUMP BY ONE
         C     GR1,NESTPSPO             IS NESTING OK .Q
         BH    DBALERR                  BRANCH IF NOT
         STH   GR1,CTUSPP(,ACT)         SET NEW USING PUSH/POP COUNT
         SLL   GR1,L'USGSTAK/4          TIMES LENGTH OF USING SAVE
         LA    GRB,USGSTAK-L'USGSTAK(GR1)  ADDR OF USING STATUS SAVE
         L     GRC,USNGPP(,ACT)         USING STATUS TABLE
         MVC   0(L'USGSTAK,GRB),0(GRC)  SAVE USING STATUS
         SLL   GR1,2                    NOW UP TO 64 TIMES
         LA    GRB,USGAREA-64(GR1,ACT)  POINT TO USING SAVE AREA
         L     GRC,USNGTP(,ACT)         USING TABLE ADDRESS
         MVC   0(64,GRB),0(GRC)         SAVE USING TABLE
         LA    SP1,L'USINGC(,SP1)       POINT PAST ARGUMENT
CPSHB    DS    0H
         CLI   0(SP1),ICOMMA            IS A COMMA NEXT .Q
         BE    PSHDELOK                 BRANCH IF YES
         CLI   0(SP1),IBLANK            IS A BLANK NEXT .Q
         BE    CTRTRN(,ACT)             RETURN IF SO
         B     DLMERR                   OTHERWISE, SYNTAX ERROR
PSHDELOK DS    0H
         LA    SP1,1(,SP1)              BUMP TO NEXT OPND
         B     PSHB1                    AND CONTINUE
USDPTBL  DS    0H
*                  USGFLG   --   X'FF' IF USING
*                           --   X'00' IF DROP
*                  VALUEB   --   REGISTER BEING ALTERED
         TM    CTUMAPI(ACT),X'80'       WAS UMAP SPECIFIED .Q
         BCR   8,SRB                    RETURN IMMEDIATELY IF NOT
         STM   SP2,SP1,F8REGS           SAVE ALL REGISTERS
         LA    SP2,STUMAP(,ACT)         POINT TO START OF USING CHAIN
         L     SP1,STUMAP(,ACT)         GET START OF CHAIN
         LTR   SP1,SP1                  IS IT THE FIRST TIME .Q
         BZ    USDPDRPT                 BRANCH IF YES
         USING USNGMAP,SP1              FOR A BASE
USDPREGZ DS    0H
         CLC   USNGREG,VALUEB+3         IS THIS THE REGISTER .Q
         BNE   USDPPTRZ                 BRANCH IF NOT
         OC    USNGDROP,USNGDROP        IS REGISTER ALREADY DROPPED .Q
         BNZ   USDPPTRZ                 BRANCH IF YES
         MVC   USNGDROP,CTSEQ8+2(ACT)   SET STATEMENT DROPPED
USDPPTRZ DS    0H
         LR    SP2,SP1                  REMEMBER LAST AREA
         L     SP1,USNGCHN              GET NEXT AREA
         LA    SP1,0(,SP1)              CLEAR HIGH BYTE
         LTR   SP1,SP1                  IS CHAIN PTR ZERO .Q
         BNZ   USDPREGZ                 BRANCH IF NOT
USDPDRPT DS    0H
         CLI   USGFLG,X'00'             IS THIS A DROP .Q
         BE    USDPRETN                 RETURN NOW IF YES
         BAL   SRR,USDPBLKG             GET NEXT USING BLOCK
         O     SP1,USNGCHN-USNGMAP(,SP2)  OR IN LAST REGISTER NUMBER
         ST    SP1,USNGCHN-USNGMAP(,SP2)  CHAIN THE LAST USING BLOCK
         XC    USNGMAP(USNGLEN),USNGMAP CLEAR NEW USING BLOCK
         L     GR1,VALUEB               GET REGISTER NUMBER
         STC   GR1,USNGREG              PUT IN USING MAP BLOCK
         SLL   GR1,2                    FOUR BYTES PER ENTRY
         A     GR1,USNGTP(,ACT)         PLUS BASE OF USING TABLE
         MVC   USNGDISP+1(3),1(GR1)     ENTER RESOLVED DISPLACEMENT
         MVC   USNGSTRT(2),CTSEQ8+2(ACT)  USING STATEMENT NUMBER
USDPRETN DS    0H
         LM    SP2,SP1,F8REGS           RESTORE CALLER'S REGS
         BR    SRB                      AND RETURN
         DROP  SP1                      NO USE FOR USING MAP BLOCK
USDPBLKG DS    0H
         L     GR1,ABLKOFF              CURRENT BLOCK OFFSET
         C     GR1,USDPLEN              ANY LEFT .Q
         BL    USDPAVIL                 BRANCH IF YES
         L    GR1,BUFFPT(,ACT)          POINT TO BUFF IN ASM
         CNOP  2,4                      ALIGN OPERANDS
         BALR  GR0,GR1                  DO THE SHRINK
         DC    A(36)                    SHRINK CODE
USDPLEN  DC    A(USNGLEN*USNGDUP)       LENGTH OF ONE UMAP AREA
USDPADDR DC    A(0)                     RETURNED ADDRESS
         CLI   USDPADDR,X'FF'           DID WE GET CORE .Q
         BE    USNGABND                 ABEND IF NOT
         SR    GR1,GR1                  USE 1ST USING MAP BLOCK
USDPAVIL DS    0H
         LR    SP1,GR1                  TRANSFER USABLE OFFSET
         A     SP1,USDPADDR             PLUS BASE
         LA    GR1,USNGLEN(,GR1)        POINT TO NEXT OFFSET AREA
         ST    GR1,ABLKOFF              SAVE IT BACK
         BR    SRR                      AND RETURN
USNGABND DS    0H
         L     GR1,BUFFPT(,ACT)         POINT TO BUFF IN ASM
         BAL   GR0,L1ABEND(,GR1)        AND ABEND IN ASM
         DC    C'997I',AL1(L'MES997-1)
MES997   DC    C'INSUFFICIENT MEMORY FOR USING MAP'
***********************************************************************
***   LITERB   ***
* THIS ROUTINE PLACES THE ADDRESS OF THE LITERAL FOR OUTPUT AND
* BRANCHES TO A COMMON EXIT FOR LITERAL, DC AND DS.
***********************************************************************
LITERB   DS    0H
         MVC   F8INST(3,ACT),CTLOC+1(ACT)  PUT IN LOCATION COUNTER
         LA    GRZ,10                   MIXED VALUE
         B     DCDSLT                   COMMON EXIT
***********************************************************************
***   DSB   ***
*THIS ROUTINE SETS GRZ TO ZERO CONTINUES WITH COMMON ROUTINE TO LITERAL
* DC AND DS.
***********************************************************************
DSB      SR    GRZ,GRZ                 SET DS FLAG
DCDSLT   L     SRB,CDCVAL(ACT)          GET BASE/ENTRY OF DC EVAL
         ST    GRX,CTWRAPX(ACT)         PUT BACK ADUSTED LOC CTR
         MVI   F8INST+15(ACT),X'00'     PRINT LOCATION COUNTER
         BALR  SRR,SRB                  CALL DC EVAL ASMGF8D
         B     CTRTRN(ACT)              EXIT
SAVER    EQU   206
***********************************************************************
***   DCB   ***
*THIS ROUTINE STARTS AT THE COMMON BRANCH FOR LITERAL, DC, AND DS.  GRZ
* WILL ALWAYS CONTAIN A NON-ZERO VALUE.
***********************************************************************
DCB      LA    GRZ,255                  ALL BITS
         B     DCDSLT                   GO TO COMMON EXIT
***********************************************************************
***   CCWB   ***
*THIS ROUTINE PROCESS THE OPERAND FIELD OF A CCW STATEMENT.  DATA IS
* SET FOR THE F8OP ROUTINE TO OUTPUT.  RLD ENTRIES ARE MADE IF
* NECESSARY
***********************************************************************
CCWB     ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOC CTR
         L     GRX,CTXABP(ACT)          GET APPENDED FIXED FIELD PTR
         LA    GR0,8                    CCW LENGTH FOR WRAP TEST
         ST    GR0,CTF8LNGT(ACT)        LENGTH FOR WRAP TEST
CCWB0A   MVI   F8INST+15(ACT),X'48'     SET DC AND LENGTH OF 8
         LA    GR0,8
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         CLI   0(SP1),IBLANK           IS OPERAND BLANK
         BE    DLMERR                   IF SO, DELIMETER ERROR
         CLI   0(SP1),IEQUAL            IS NEXT CHAR EQUAL
         BE    DLMERR                   IF SO, DELIMETER ERROR
         BAL   SRR,F8AREX               PROCESS EXPRESSION
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   DLMERR                   DELIMETER ERROR, ABORT
         TM    ERRSW,X'FF'               WAS EXPRESSION IN ERROR
         BO    CCW02                     IF SO SKIP FIRST OPERAND
         TM    AEXP2,X'01'              IS ABSOLUTE AND SIZE OK
         BZ    CCW01                    YES, CONTINUE
         TM    AEXP3,X'01'              IS THIS RELOCATABILITY ERROR
         BZ    CCWR01                   IF ZERO, NO
         BAL   SRR,ERRZRO               LOG ERROR AND ZERO INSTRUCTION
         DC    AL2(ERRLOC)              RELOCATABILITY ERROR
         B     CCW02                    SCAN NEXT OPERAND FIELD
CCWR01   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRLAR)              TOO LARGE EXPRESSION
         B     CCW02                    SCAN NEXT OPERAND FIELD
CCW01    STC   SP2,F8INST+3(ACT)        MACHINE OP CCW
CCW02    LA    SP1,1(SP1)               LOOK AT NEXT CHAR
         CLI   0(SP1),IEQUAL            IS DELIMETER EQUAL
         BE    DLMERR                   DELIMETER ERROR
         CLI   0(SP1),IBLANK            IS NEXT OPERAND CHARACTER BLANK
         BE    DLMERR                   IF SO, DELIMETER ERROR
         BAL   SRR,F8AREX               PROCESS 2ND EXPRESSION
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   DLMERR                   NO, ERROR
         TM    AEXP3,X'01'              IS ABSOLUTE AND SIZE OK
         BZ    CCW03                    YES, OK
         TM    SREXP,X'01'              IS IT RELOCATABLE
         BZ    RLDRTN00                 YES, RELOCATE
         TM    CREXP,X'01'              IS IT COMPLEX RELOCATABLE
         BZ    RLDRTN00                 YES, RELOCATE
         TM    VALUEB,X'FF'             SIZE CHECK
         BZ    CCW03                    OK, CONTINUE
         BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRLAR)              EXPRESSION TOO LARGE
         B     CCW04                    SKIP RLD ENTRY RTN FOR ABSOLUTE
CCW03    MVC   F8INST+4(3,ACT),VALUEB+1 DATA ADDRESS FOR CCW
         B     CCW04                    SKIP RLD ENTRY RTN FOR ABSOLUTE
*                                                                     *
***                   RLD ROUTINE                                   ***
*                                                                     *
RLDRTN00 MVC   F8INST+4(3,ACT),VALUEB+1 DATA ADDRESS FOR CCW
         STM   SP2,SP1,F8REGS           OPERAND REGISTERS FOR LATER
         L     SRB,STLOCADR             ADDRESS OF DC STLOC DATA
         MVC   1(3,SRB),F8INST(ACT)     MOVE CURRENT LOCATION COUNTER/
         OI    3(SRB),X'01'             OR IN LOW ORDER BIY FOR RLD
         LR    SP1,SP2                  POINTER TO VALUE & TABLE OF ESD
         LA    SP2,X'08'                SET FOR THREE
         L     SRB,CDCVAL(ACT)          DCEVAL BASE
         L     GR1,RLDRTNAD             RLD ROUTINE ADDRESS
         BALR  SRR,GR1                  PROCESS RLD
         LM    SP2,SP1,F8REGS           GET BACK REGISTERS
CCW04    LA    SP1,1(SP1)               LOOK AT NEXT CHAR
         CLI   0(SP1),IBLANK            IS NEXT OPERAND CHARACTER BLANK
         BE    DLMERR                   IF SO, DELIMETER ERROR
         CLI   0(SP1),IEQUAL            IS NEXT CHAR EQUAL
         BE    DLMERR                   IF SO, DELIMETER ERROR
         BAL   SRR,F8AREX               PROCESS 3RD EXPRESSION
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   DLMERR                   NO, LOG ERROR
         TM    AEXP2,X'01'              SIZE AND ABSOLUTE TEST
          BO   CCW04A                    IF 1, ERROR
         TM    VALUEB+3,X'07'           BOTTOM 3 BITS CHECK
         BZ    CCW06                    OK
CCW05    BAL   SRR,ERRNO0               LOG ERROR
         DC    AL2(ERRCCW)              CCW ERROR
         B     CCW06                    PUT IN FLAGS ANYWAY
CCW04A   TM    AEXP3,X'01'              IS THIS RELOCATABILITY ERROR
         BZ    CCWR02                   IF ZERO, NO
         BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRLOC)              RELOCATABILITY ERROR
         B     CCW07                    SCAN NEXT OPERAND FIELD
CCWR02   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRLAR)              EXPRESSION TO LARGE
         B     CCW07                    SCAN NEXT OPERAND FIELD
CCW06    MVC   F8INST+7(1,ACT),VALUEB+3 FLAGS FOR CCW
CCW07    LA    SP1,1(SP1)               LOOK AT NEXT CHAR
         CLI   0(SP1),IBLANK            IS NEXT OPERAND CHARACTER BLANK
         BE    DLMERR                   IF SO, DELIMETER ERROR
         CLI   0(SP1),IEQUAL            IS NEXT CHAR EQUAL
         BE    DLMERR                   IF SO, DELIMETER ERROR
         BAL   SRR,F8AREX               PROCESS 4TH EXPRESSION
         CLI   0(SP1),IBLANK            IS DELIMETER BLANK
         BNE   DLMERR                   NO, ERROR
         TM    AEXP3,X'01'              ABSOLUTE CHECK
         BO    CCW08                    NOT, ERROR
          CLC  VALUEB(2),KX0000          CHECK IF SIZE IS RIGNT
         BNE   CCWR03                   ERROR
        MVC   F8INST+9(2,ACT),VALUEB+2 COUNT FOR CCW
         B     AOPRTN                   EXIT FROM AOP RTN
CCWR03   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRLAR)              EXPRESSION TOO LARGE
         B     AOPRTN                   RETURN TO MAIN LINE
CCW08    BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRLOC)              RELOCATABILITY ERROR
         B     AOPRTN                   EXIT FROM AOP RTN
***********************************************************************
***   CNOPB   ***
*THIS ROUTINE OUTPUTS A VARIABLE NUMBER OF BC 0,0 INSTRUCTIONS.
***********************************************************************
CNOPB    ST    GRX,CTWRAPX(ACT)         REPLACE ADJUSTED LOCATION CTR
         L     GRX,CTXABP(ACT)          APPENDED FIXED FIELD POINTER
         MVI   F8INST+15(ACT),X'00'     FIX FOR NO OUTPUT
         TM    4(GRX),X'06'             IF ZERO, NO BCT OUTPUT
         BZ    CTRTRN(ACT)              EXIT TO MLC
         LA    GRY,6                    MASK TO REGISTER
         IC    GRZ,4(GRX)               ALIGNMENT TO REGISTER
         NR    GRY,GRZ                  KEEP JUST EVEN ALIGNMENT
         STC   GRY,F8INST+15(ACT)       PUT NUMBER OF BYTES FOR OUTPUT
         OI    F8INST+15(ACT),X'40'     PUT OUT AS DC
         MVC   ALIGNT+1(3),F8INST(ACT)  REPLACE LOCATION
         MVI   ALIGNT,X'00'             ZERO FIRST BYTE
         L     GRZ,ALIGNT               GET LOCATION IN REGISTER
         SR    GRZ,GRY                  BACK UP TO LOCATION
         ST    GRZ,ALIGNT               REPLACE
         MVC   F8INST(3,ACT),ALIGNT+1   PUT FOR OUTPUT
         EX    GRY,BCTRMV               BCR TO OUTPUT AREA
         B     CTRTRN(ACT)              RETURN TO MAIN LINE CONTROL
BCTRMV   MVC   F8INST+3(0,ACT),BCTROP   INDEXED MOVE, THRU EXECUTE
***********************************************************************
***   SETSEC   ***
*THIS ROUTINE SETS CURRENT ADJUSTMENT BASE BY USING CURRENT ESD-ID FOR
* TABLE SEARCH OF ADJUSTMENT TABLE ENTRIES.
***********************************************************************
SECSET   STM   GRB,GRA,F8REGS           STUFF ALL REGISTERS
         BAL   SRR,SETSEC               GO TO SET SECTION NUMBER
         LM    GRB,GRA,F8REGS           RESTORE REGISTERS
         BR    SRR                      RETURN TO MAIN PROGRAM
SETSEC   STC   SP2,*+9                  CURRENT ESD-ID
         L     GRX,CTADJEND(0,ACT)      END OF TABLE + 1
         CLI             0(SP1),*-*     COMP. TO ADJ TABLE ENTRIES
         BE    SECFND                   FOUND, SET FOUND
         LA    SP1,4(SP1)               NOT FOUND, BUMP BY 4
         CR    SP1,GRX                  IS TABLE EXHAUSTED
         BL    SETSEC+8                 EXIT WHEN TABLE EXHAUSTED
         L     SP2,CTZERO(ACT)          ZERO CELL TO SHOW ERROR
         B     SECFNX                    ERR O
SECFND   L     SP2,0(0,SP1)
         LA    SP2,0(0,SP2)             EXTRACT CSECT ORG
SECFNX   ST    SP2,F8CADJ(ACT)          STORE
         MVC   F8INST(3,ACT),F8CADJ+1(ACT)
         BR    SRR                      RETURN
***********************************************************************
***   F8AREX   ***
*THIS ROUTINE IN AOP USES EEVAL FOR GETTING VALUES.  A CHECK IS MADE
* FOR SIZE.  IF SIZE IS OK BIT 7 IS SET TO ZERO IN PROPER FLAG WORD.
***********************************************************************
F8AREX  L      GRZ,ALBITS
         ST    SRR,HLDSRR               SAVE RETURN ADDRESS
        ST     GRZ,EXFLGS               SET EXPRESION FLAGS ONES
         MVI   CREXP,X'FF'              TURN OFF COMPLEXLY RELOCATABLE
         XC    VALUEB(6),VALUEB         ZERO VALUE AND SIGN AND ESD-ID
         MVI   EVLERF,X'00'             TURN EVAL ERR FLAG OFF
        L      SRB,CEEVAL(ACT)          GET BASE/ENTRY OF EVAL
         BALR  SRR,SRB                  CALL EVAL - ASMGF8V
        BC     8,AEXP                   ABSOLUTE EXPRESSION
        BC     4,JSREXP                 SIMPLE RELOCATABLE
         BC    2,JCREXP                 COMPLEXLY RELOCATABLE
        BC     1,EREVAL                 COULD NOT EVALUATE
         B     ASERRB                   STATEMENT TOO COMPLEX
AEXP     LTR   GRY,SP2                  CURRENT EXP VALUE TEST NEGATIVE
        ST     GRY,VALUEB               SAVE VALUE
         TM    VALUEB,X'FF'             TEST FOR WRAP AROUND
         BM    EXWRAP                   IF MIXED, WRAP AROUND OCCURRED
         MVI   VALUEB,X'00'             ZERO FIRST BYTE OF VALUE
         SL    GRY,K16                  IF LESS THAN +16, OK
        BM     SEXP1                    OK
         L     GRY,VALUEB               RESTORE VALUE TO GRY
         SL    GRY,K256                 IF LESS THAN 256, OK
        BM     SEXP2                    OK
         B     SEXP3                    SET ABSOLUTE OK
EXWRAP   BAL   SRR,ERRZRO               ZERO INSTRUCTION AND LOG ERROR
         DC    AL2(ERRWRP)              WRAP AROUND ERROR CODE
         XC    VALUEB(4),VALUEB         ZERO VALUE
         B     SEXP3                    SET ABSOLUTE
JCREXP   MVI   CREXP,X'00'              TURN ON COMPLEXLY RELOCATABLE
         MVC   VALUEB(4),0(SP2)         VALUE TO VALUEB
         B     PASSRE                   EXIT
JSREXP   NI    SREXP,X'FE'              SET SIMPLY RELOC SWTCH
         MVC   VALUEB(6),0(SP2)         EXPRESSION VALUE, SIGN & ESD-ID
        B      PASSRE                   EXIT
SEXP1    NI    AEXP1,X'FE'               ET ABS. < 16 OK
SEXP2    NI    AEXP2,X'FE'               SET ABS. < 256 OK
SEXP3    NI    AEXP3,X'FE'               SET ABSOLUTE EXP OK
PASSRE   L     SRR,HLDSRR               GET SUBROUTINE RETURN
        BR     SRR                      RETURN
EREVAL   SR    GR0,GR0                 ZERO A REGISTER
         ST    GR0,EXFLGS               TURN OTHER ERRORS OFF
         LTR   SP1,SP1                 IF ZERO, ABORT
         MVI   ERRSW,X'FF'              TURN ON LOCAL ERROR SWITCH
         BZ    AOPRTN                  IF ZERO BRANCH
         MVI   EVLERF,X'FF'             TURN EVAL ERR FLAG ON
         L     SRR,HLDSRR               GET SUBROUTINE RETURN
         BR    SRR                      EXIT F8AREX
ASERRB   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRASM)              STATEMENT COMPLEXITY EXCEEDED
         B     AOPRTN                   EXIT
ERQNDU   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRREG)              REGISTER ERROR
         LM    GR0,GRY,ERRREGS          PICK UP ALL REGISTERS
         B     TESNDU                   GO BACK FOR MORE
DLMERR   BAL   SRR,ERRZRO               DELIMETER ERROR
         DC    AL2(ERRDLM)              LOG ERROR
ZEROINST MVI   ERRSW,X'FF'             TURN ON ERROR SWITCH
AOPRTN   TM    ERRSW,X'FF'              ASSEMBLER OP PROCESSOR RETURN
         BZ    DNTZRO                   NO ERROR, SKIP
         XC    F8INST+3(12,ACT),F8INST+3(ACT) ZERO INSTRUCTION
         SR    SP2,SP2                  ZERO SP2 FOR NO SPACING
DNTZRO   B     CTRTRN(ACT)              DONT ZERO INSTRUCTION
ERRZRO   MVI   ERRSW,X'FF'              SET ERROR SWITCH ON
ERRNO0   L     SRB,CLOGER(ACT)          LOAD LOGERR BASE AND ENTRY
         STM   GR0,GRY,ERRREGS          SAVE ALL REGISTERS
         BR    SRB                      EXIT TO LOGERR
         ENTRY SECSET                   SETS CURRENT ADJUSTMENT BASE SV
         ENTRY SETSEC                   SAME AS ABOVE BUT DOESNT SAVE
FWORD    DS    2D                       2 DOUBLE WORDS TEMP
DWORD    DS    D                        DOUBLE WORD TEMP
RLDRTNAD DC    V(RLDRTN)                EXTERNAL ADDRESS OF DC RLD RTN
STLOCADR DC    V(STLOC)                 LOCATION ADDRESSED IN DC RTN
PNTSAV   DC    3F'0'                    THREE PRINT SWITCH SETTINGS
FOURB    DC    F'4'                     CONSTANT FOUR
NESTPSPO EQU   FOURB                    MAX PUSH/POP NESTING LEVEL
ENTSAVE  DC    F'0'                     ENTRY ERROR OPERAND POINTER
ABLKOFF  DC    A(USNGLEN*USNGDUP)       OFFSET IN USING MAP AREA (FULL)
F8TEMP   DS    F                        HOLE FOR TEMP STORAGE
F8REGS   DS    16F                      SAVE AREA FOR SECSET
ERRREGS  DS    16F                      SAVE REGISTERS ON ERRORS
VALUEB   DS    F                        EVALUATED VALUE FROM F8AREX
EXPESD   DC    X'0000'                  EXPRESSION SIGN AND ESD-ID
BCTROP   DC    X'070007000700'          THREE BCR COMMANDS
NDATAC   DC    X'17180D0A1D0A'          NODATA
DATAC    DC    X'0D0A1D0A'              DATA
NOGENC   DC    X'1718100E17'            NOGEN
GENC     DC    X'100E17'                GEN
OFFC     DC    X'180F0F'                OFF
ONC      DC    X'1817'                  ON
PRINTC   DC    X'191B12171D'            TRANSLATED PRINT
USINGC   DC    X'1E1C121710'            TRANSLATED USING
RLDFLG   DC    X'08'                    INDICATES 2 WHICH MEANS 3
EQUAL    DC    X'2C'                    HEX FOR EQU AL SIGN
NINEEN   DC    F'19'                    CONSTANT OF 19
K16     DC     F'16'                    DECIMAL 16
K256     DC    F'256'                   DECIMAL 265
K4096    DC    F'4096'                  DECIMAL 4096
LENPNTSK DC    AL2(L'PNTSTAK)           LENGTH OF ONE PRINT SAVE AREA
KX0000    DC    X'0000'                  TWO BYTES OF ZERO
ZEROM    DC    F'0'                     FULL WORD OF ZERO
ALBITS   DC    X'FFFFFFFF'              FULL WORD OF BITS
ALIGNM   DC    F'0'                     FOR ALIGNING HALF AND FULL WORD
ALIGNT   DS    F                        FOR ALIGNMENT HALF AND FULL WRD
TOOBIG   DC    X'00003000'              *
HLDSRR   DS    F                        RETURN ADDRESS FOR F8AREX
CREXPC   DS    F                        COMPLEXLY RELOCATABLE SWITCH
EXFLGS   DS    0F                       EXPRESSION FLAGS
AEXP1    DC    X'00'                    FLAG- ABSOLUTE LT 16
AEXP2    DC    X'00'                    FLAG- ABSOLUTE LT 256
AEXP3    DC    X'00'                    FLAG- ABSOLUTE LT 4096
SREXP    DC    X'00'                    FLAG- SIMPLE RELOCATABLE
CREXP    DC    X'00'                    COMPLEX RELOCATABLE FLAG
EVLERF   DC    X'00'                    F8AREX ERROR FLAG
BUSING   DC    X'00'                    USING SWITCH
BIT6     DC    X'02'                    BIT 6
BIT7     DC    X'01'                    BIT 7
TEN      DC    X'0A'                    10
BITS45   DC    X'0C'                    BITS 4 AND 5
USINGR0  DC    X'FF'                    SWITCH FOR USING REGISTER 0
USGFLG   DC    X'00'                   USING FLAG
ESDUSG   DC    X'00'                    ESD-ID USED IN USING STATEMENT
ERRSW    DC    X'00'                   ERROR SWITCH
PRNTFLAG DC    X'00'                    FLAG FOR DUPLICATE PRNT SWITCH
ABSRX    DS    C                        ABSOLUTE FLAG
FRSTIM   DS    C                        FIRST TIME SWITCH FOR F8AREX
TSTYPE   DC    X'00'                    TYPE OF OPERATION SLOT
USNGPP   EQU   CTXIO3                   I/O BUFFER 3
USNGTP   EQU   CTXIO4                   I/O BUFFER 4
QUOTE    EQU   X'31'                    TRANSLATED QUOTE
WKBKPT   EQU   CTXOFP                   PHASE 8 WORK BUCKET POINTER
LATP     EQU   CTXWAP                   LITERAL ADDRESS TABLE POINTER
SIGN     EQU   0                        SIGN
PID      EQU   0                        POSITION ID
RID      EQU   1                        RELOCATION ID (PARAM TABLE)
VAL      EQU   2                        V OR A, LENGTH INDICATOR
ADDR     EQU   3                        ADDRESS
RELID    EQU   1                        RELOCATION ID (RLD)
PLSCON   EQU   1                        PLUS CONSTANT
PNEXT    EQU   2
ERRORG   EQU   6                        ERROREOUS ORG STATEMENT FLAG
ERRWRP   EQU   7                        WRAP AROUND ERROR CODE
ERRDIS   EQU   8                        EXPRESSION TOO LARGE
ERRREG   EQU   10                       REGISTER SPECIFICATION ERROR
ERRLAR   EQU   17                       EXPRESSION TOO LARGE
ERRUDF   EQU   24                       UNDEFINED SYMBOL
ERRLOC   EQU   25                       RELOCATABILITY ERRORS
ERDROP   EQU   28                       REGISTER NOT USED
ERRCCW   EQU   29                       BITS 37-39 OF CCW NON-ZERO
ERRLIN   EQU   33                       ERROR CODE FOR ALIGNMENT ERROR
ERRNTY   EQU   38                       ENTRY ERROR
ERRDLM   EQU   39                       INVALID DELIMITER
ERRLNG   EQU   98                       LENGTH ERROR
ERRASM   EQU   100                     OPERAND TOO COMPLES(ASSEMBLER ER
ERROPN   EQU   107                      OPERAND ERROR
ERRPSH   EQU   111                      UNRECOGNIZABLE PUSH PARAMETER
ERRPOP   EQU   111                      UNRECOGNIZABLE POP PARAMETER
ERRPSPO  EQU   112                      UNBALANCED PUSH/POP REQUEST
ERRPNT   EQU   111                      UNRECOGNIZABLE PRINT PARAMETER
EREVL    EQU   AOPRTN                   EXPRESSION EVALUATION ERROR
EQUERR   EQU   ASERRB                   STATEMENT TOO COMPLEX ERROR
PPTR     EQU   GRA                      PARAMETER TABLE POINTER
RLDPTR   EQU   SP1                      RLD POINTER
COUNT    EQU   GRB                      COUNTER REGISTER
KMNOTE   EQU   X'0E'                   HEXOP FOR MNOTE
PNTSTAK  DC    4XL12'00'                PRINT PUSH/POP STACK
USGSTAK  DC    4XL16'00'                USING PUSH/POP STATUS STACK
USGAREA  EQU   CTWORK                   USING PUSH/POP ESDID/DISP STACK
         SPACE 2
USNGMAP  DSECT
USNGREG  DS    0AL1                     REGISTER NUMBER
USNGCHN  DS    A                        CHAIN OF USING BLOCKS
USNGSTRT DS    H                        START USING STATEMENT NUMBER
USNGDROP DS    H                        DROP USING STATEMENT NUMBER
USNGFILL DS    F                        FILLER
USNGESD  DS    0XL1                     ESD-ID OF USING LOCATION
USNGDISP DS    F                        OFFSET OF USING LOCATION
USNGLEN  EQU   *-USNGMAP                LENGTH OF CONTROL BLOCK
USNGDUP  EQU   5                        NUM USING MAP BLOCKS PER AREA
         SPACE 2
         END   ASMGF8A
./ ADD NAME=ASMGF8C
F8C      TITLE     'ASMG F8  MAIN LINE CONTROL (F8MLC)'
         ISEQ  73,78
ASMGF8C  START     ,                    MAIN LINE CONTROL PHASE 8
         PRINT        NOGEN
         FDIMEN
         PRINT      GEN
*                                                                     *
*TITLE 'ASMGF8C ' ... PHASE F8,MAIN LINE CONTROL                      *
*FUNCTION/OPERATION-                                                  *
*   PROCESS EDITED TEXT RECORDS FROM ASMGF7. CONTROL THE CALLING OF   *
*  ASMGF8 ROUTINES FOR THE FINAL PROCESSING OF THE ASSEMBLY.          *
*ENTRY POINTS-                                                        *
*  ASMGF8C- MAIN LINE CONTROL                                         *
*     INVOKED BY ASMGF8I BY                                           *
*        B     CTRTRN(ACT)              CALL MAIN LINE CONTROL        *
*   SRLINE- ALIGNMENT ROUTINE                                         *
*     CALLED INTERNALLY BY                                            *
*        BAL   SRR,SRLIGN               ALIGN                         *
*INPUT- NONE                                                          *
*OUTPUT- NONE                                                         *
*EXTERNAL ROUTINES-                                                   *
*        NAME     ROUTINE     FUNCTION                                *
*                                                                     *
*        ASOPRO   ASMGF8A     PROCESS ASSEMBLER INSTRUCTIONS          *
*        GETXTM   ASMGF8I     GET TEXT AND MOVE                       *
*        PHCLS    ASMGF8I     PHASE 8 CLOSE                           *
*        CLOGER   ASMGF8L     LOG ERROR                               *
*        MACHOP   ASMGF8M     PROCESS MACHINE OPERATIONS              *
*        BLDIMG   ASMGF8P     BUILD SOURCE IMAGE                      *
*        PRNT     ASMGF8P     PRINT ROUTINE                           *
*EXITS- NORMAL--                                                      *
*   AT END OF PROCESSING, CONTROL IS RETURN TO ASMGF8I VIA            *
*        L     SRB,CTXTIO(ACT)          SET UP BASE                   *
*        BAL   SRR,PHCLS(SRB)           CLOSE PHASE 8                 *
*     - ERROR-- NONE                                                  *
*TABLES/WORKAREAS-                                                    *
*   F8REGS- SAVE AREA FOR ALL REGISTERS                               *
*                                                                     *
         EJECT
         USING *,CRB                    CONTROL ROUTINE BASE
F8NTRY   MVI   CTEMERR(ACT),X'FF'     SET MNOTE ERR FLAG OFF
F8NTRY1  XC    F8INST(16,ACT),F8INST(ACT)  ZERO INST. BLDG. AREA
         MVI   REPSW(ACT),X'00'         TURN OFF TITLE,REPRO,PUNCH,MNOT
         CLI       CTENDSW(ACT),X'FF'  TEST IF END PROCESSED
         BNE       *+8
         MVI       F8PON(ACT),X'00'    TURN ON PRINT SW IN CASE FULLLST
         CLI   ERSWH(ACT),X'FF'
         BE    ERLOD8                   IF ERROR, SKIP
         LA    SP1,F8WORK(ACT)          MOVE RECORD TO WORK AREA
         L     SRB,CTXTIO(ACT)          I/O BASE ADDRESS
         BAL   SRR,GETXTM(SRB)          GET TEXT AND MOVE
         BZ    ENDOFF
F8OPND   LA    SP1,F8WORK(ACT)          RELOAD SP1 FOR TESTS
         TM    TXRT(SP1),PCGREC         PROCESS & CONSTRUCT IF GEN 7
         BO    PC001
         TM    TXRT(SP1),PCREC          PROCESS & CONSTRUCT 6
         BO    PC001
         TM    TXRT(SP1),PROCREC        PROCESS ONLY 4
         BO    SETWBP
         B     PRINTE                  GO TO PRINTE FOR ALL OTHERS
*
PC001    ST    ACT,ACTREG              SAVE ACT REGISTER
         L     FRB,PRNT(ACT)            PRINT ROUTINE BALE
         L     GRX,ADBLDMG             F8PRINT BLDIMG
         BALR  SRR,GRX                  BRANCH TO BUILD IMMAGE
         L     ACT,ACTREG              LOAD ACT REGISTER
* SETWBP - SET CTXWBP(ACT) PT TO FIRST SYMBOL WORK BUCKET
*                                IN CURRENT TEXT RECORD
*          ENTER WITH GRA PT TO TXRL, USE GRY, GRZ
*
SETWBP   LA    GRA,F8WORK(ACT)          RECORD WORK AREA ADDRESS
         LR    GRY,GRA                  SET GRY PT TO 1ST BYTE FOLLOWNG
         AH    GRY,TXABP(GRA)                      APPENDED FIXED FIELD
         LA    GRY,TXFAFL(GRY)
         LR    GRZ,GRA                  SET GRZ PT TO BYTE FOLLOWING
         AH    GRZ,TXRL(GRA)                       LAST BYTE OF TEST
SETWB1   CLR   GRY,GRZ                  END OF REC
         BC    10,SETWB3                CLEAR CTXWBP
         TM    TXWTYP(GRY),X'80'        W.B. TYPE EQ SYMBOL
         BO    SETWB4                   SET CTXWBP PT TO 1ST SYMBOL WB
         TM    TXWLEN(GRY),X'40'        W.B. LEN
         BZ    SETWB2                        EQ 6
         LA    GRY,9(GRY)                    EQ 15
SETWB2   LA    GRY,6(GRY)               STEP W.B. PTR
         B     SETWB1                   THEN CHECK NEXT W.B.
SETWB3   SR    GRY,GRY                  NO XYMBOL W.B. SET CTXWBP EQ 0
SETWB4   ST    GRY,CTXWBP(ACT)          SET CTXWBP PT TO 1ST SYMBOL W.B
         SR    SP2,SP2
         SR    GRZ,GRZ                  ZERO REGISTER
         LA    SP2,8(SP2)               BUMP 8
         IC    GRZ,F8WORK(SP2,ACT)      INPUT NAME LENGTH
         AR    SP2,GRZ                  ADD TO 8
         LA    SP2,1(SP2)               BUMP BY 1
         IC    GRZ,F8WORK(SP2,ACT)      INPUT OPERATOR LENGTH
         AR    SP2,GRZ                  SUM
         LA    SP2,2(SP2)               BUMP BY 2
         LA    SP2,F8WORK(SP2,ACT)      OPERAND POINTER
         ST    SP2,F8OPRN(ACT)          SAVE OPERAND POINTER
F8WBPC   MVC   ALIGNT(2),6(GRA)         APPENDED FIXED FIELD POINTER
         LH    SP1,ALIGNT               LOAD POINTER
         LA    GRX,F8WORK(SP1,ACT)      TXLOC POINTER
         ST    GRX,CTXABP(ACT)          APPENDED FIXED FIELD POINTER
         LA    SP1,F8WORK+5(SP1,ACT)
         ST    SP1,WKBKPT(ACT)
         MVC   ALIGNT+1(3),0(GRX)       ALIGN RELATIVE LOCATION
         L     GRZ,BYTES3               ZERO IN FIRST BYTE
         N     GRZ,ALIGNT               THREE BYTE LOC
       A     GRZ,F8CADJ(ACT)          CURRENT ESD-ID ADJUSTMENT VALUE
         ST    GRZ,CTWRAPX(ACT)         STORE ADJUSTED LOCATION CTR
         ST    GRZ,ALIGNT               PUT FOR MOVE TO UNALIGNED
         MVC   0(3,GRB),ALIGNT+1        CURRENT ADJUSTED LOCATION
MOPALN   TM    TXTO(GRA),X'C0'          IS STATEMENT VALID STMNT
         BZ    PPRNT                    IF ZERO, NOT VALID
         L     GRX,CTXABP(ACT)          POINTER TO APPENDED FIXED FIELD
         TM    4(GRX),X'07'
         BZ    MOPTST                   IF ZERO, ALIGNMENT
         TM    F8WORK+3(ACT),X'40'      IS THIS A MACHINE OPERATION
         BO    MLC01                    IF 1, IT IS A MACINE OP
         CLI   F8WORK+4(ACT),LITRHEX    NO HXOP BELO LITRL NEED ALIGNMN
         BL    MOPTST
MLC01    NC    4(1,GRX),F8SEVN          JUST KEEP ALIGNMENT BITS
         SR    GRY,GRY
         IC    GRY,4(GRX)               BYTES TO ALIGN
         SR    GRZ,GRY
         ST    GRZ,ALIGNT               ZERO THE BYTES TO ALIGN
         MVC   ALIGNM(7),F8INST(ACT)    ADDRESS AND HEXOP
         STM   GRA,GRD,CTSAVE(ACT)      SAVE MLC REGISTERS
         CLI   F8WORK+4(ACT),X'29'      HEX FOR CNOP
         BE    CNOPRE                   EF EQUAL SPECIAL ALIGNMENT
         BAL   SRR,SRLIGN
         MVC   F8INST(7,ACT),ALIGNM     ALIGNED LOC AND HEXOP
MOPTST   TM    F8WORK+3(ACT),X'80'
         L     SP1,F8OPRN(ACT)          ADDRESS OF OPERAND FIELD
         BZ    MOPROC                   IF ZERO, PROCESS MACHINE OPS
         L     FRB,ASOPRO(ACT)          ASSEMBLY INSTRUCTION PROCESSOR
         MVI   EJCTSW(ACT),X'57'       SET LEFT HALF RECORD FLAG ON
         BALR  CRR,ACT
         CLI   F8WORK+4(ACT),X'0E'      IS THIS A MNOTE
         BE    MPRNT       YES, DONT PRINT
         CLI   F8WORK+4(ACT),X'13'     IS THIS A PRINT STATEMENT
         BE    PPRNT                   IF SO, DONT PRINT
         CLI   F8WORK+4(ACT),X'25'
         BL    PRINT              IS LESS THAN 25 PRINT
         CLI   F8WORK+4(ACT),X'28'     IF LITR(25), DC(26),
         BL    PPRNT              DS(27) SKIP PRINTING
         CLI   F8WORK+4(ACT),X'29'      IF ABOVE CNOP, DONT GO TO PRINT
         BH    PPRNT                    IF HI, CHECK WRAP AROUND
PRINT    L     FRB,PRNT(ACT)            PRINT ROUTINE USES FRB
         ST    ACT,ACTREG              SAVE ACT REGISTER
         BALR  SRR,FRB
         L     ACT,ACTREG              LOAD ACT REGISTER
         B     PPRNT                    CHECK WRAP AROUND
PRINTE   L     FRB,PRNT(ACT)            PRINT ROUTINE BASE
         L     GRX,CTCOMT(ACT)         F8PRINT SOURCE AND COMMENT ENTRY
         ST    ACT,ACTREG               SAVE ACT TABLE POINTER
         BALR  SRR,GRX
         L     ACT,ACTREG               LOAD ACT TABLE POINTER
        B     PPRNT
CNOPRE   TM    4(GRX),X'01'             IF NOT 1, NO ALIGNMENT
         BZ    MOPTST                   BYPASS ALIGNMENT FOR CNOP
         LA    GRY,1                    ALIGN ONLY ONE BYTE
         XI    4(GRX),X'01'             DROP LOW BIT
         BAL   SRR,SRLIGN               PUT OUT ALIGNMENT BYTE
         MVC   F8INST(7,ACT),ALIGNM     KEEP OLD LOCATION
         B     MOPTST                   RETURN POST ALIGNMENT
ENDOFF   L     FRB,PRNT(ACT)           BASE FOR PRINT ROUTINE
         MVI   F8PGEN(ACT),X'00'       SET TO PRINT ANY ERRORS
         MVC       F8WORK(4,ACT),DUMMYCOM PLACE A DUMMY COMMENT RECORD
         L         GRX,CTCOMT(ACT)     CALL PRINT ROUTINE TO FLUSH LAST
         BALR  SRR,GRX                 EXECUTE PRINT ROUTINE
         L     SRB,CTXTIO(ACT)         I/O BASE ADDRESS
         BAL   SRR,PHCLS(SRB)           CLASE PHASE 8
MOPROC   TM    F8WORK+3(ACT),X'40'
         BO    MOPOK                   OK TO CONTINUE IF 1
        B     PPRNT                     PRINT RECORD
MOPOK    L     FRB,MACHOP(ACT)
         MVI   EJCTSW(ACT),X'57'       SET LEFT HALF RECORD FLAG ON
         BALR  CRR,ACT
         B     PRINT                    GO TO COMMON EXIT THRU PRNT
ERLOD8   L     SP2,CTERRP(ACT)          ERROR WORK AREA ADDRESS
         MVC   F8WORK(36,ACT),0(SP2)    MOVE 36 ERROR REC CHARACTERS
         MVI   ERSWH(ACT),X'00'         TURN OFF ERROR WITCH
         B     F8OPND                   BYPASS TAPE INPUT
SRLIGN   LM    GRA,GRD,CTSAVE(ACT)
         STM   GRB,GRA,F8REGS
         STC   GRY,F8INST+15(ACT)
         OI    F8INST+15(ACT),X'C0'     ALIGNMENT AND DC FORMAT BITS
         MVC   F8INST(3,ACT),ALIGNT+1   UNALIGNED ADDRESS
         XC    F8INST+3(12,ACT),F8INST+3(ACT) XERO FOR ALIGNMENT
         L     FRB,PRNT(ACT)
         BALR  SRR,FRB
         LM    GRB,GRA,F8REGS
         BR    SRR
PPRNT    TM    WRAPT,X'FF'              WAS THERE WRAP AROUND
         BM    MLC10                    IF MIXED, WRAP AROUND OCCURRED
         TM    CTWRAPX(ACT),X'FF'       CHECK FOR WRAPAROUND
         BM    MLC10                    BRANCH IF NOT MIXED
         L         GR0,CTSEQ8(0,ACT)   TEST FOR STATEMENT 0
         LTR       GR0,GR0
         BZ        F8NTRY
         C         GR0,CTWRAP7(0,ACT)  DID THIS WRAP IN F7
         BNE   MLC11                    IF IT DID LOG AN ERROR
MLC10   L     SRB,CLOGER(ACT)          IF SO, LOG AN ERROR
         LA    SP1,0
        BALR  SRR,SRB                  BRANCH TO LOGERROR
        DC    AL2(ERRWRP)              WRAP AROUND ERROR
        MVC   PPRNT(4),WRAPBLOT        DONT TEST ANY MORE WRAP AROUND
WRAPBLOT B    F8NTRY                   TRY NEXT RECORD
MLC11    L     GR0,CTWRAPX(ACT)         CURRENT LOCATION COUNTER
         LTR   GR0,GR0                  TEST CTWRAPX FOR ZERO
         BZ    F8NTRY                   IF CTWRAPX ZERO, OK
         BCTR  GR0,0                    DID IT WRAP THIS TIME
         A     GR0,CTF8LNGT(ACT)        CURRENT INSTRUCTION LENGTH
         ST    GR0,CTWRAPX(ACT)         STORE FOR WRAP AROUND TEST
         TM    CTWRAPX(ACT),X'FF'       TEST HI ORDER BYTE
        BM    MLC10                    IF MIXED, WRAP AROUND ERROR
         LA    GR0,1(GR0)               WILL IT WRAP NEXT TIME
         ST    GR0,WRAPT                STORE TO TEST ON NEXT RECORD
        XC    CTF8LNGT(4,ACT),CTF8LNGT(ACT) ZERO INSTRUCTION LENGTH
        B     F8NTRY                   PROCESS NEXT RECORD
WRAPT    DC    F'0'                     LOCAL WRAP AROUND HOLDER
WRAPVALU DC   F'0'
DUMMYCOM DC        X'00040029'         DUMMY COMMENT RECORD
ACTREG   DC    F'0'                    SAVE HOLE FOR ACT REGISTER
ALIGNT   DC    F'0'                     FOR ALLIGNMENT
SECORG   DC    F'0'                     ORIGIN OF SECTION
WORDBB   DC    F'0'
BYTES3   DC    X'00FFFFFF'             THREE BYTE MASK
F8SEVN   DC    X'07'                    LOW THREE BITS OR SEVEN
F8REGS   DS    16F                      SAVE AREA FOR ALL 16 REGISTERS
ALIGNM   DS    2F                       TWO FULL WDS FOR LIGNMENT
*./      DELETE    SEQ1=04500020,SEQ2=04500020
         ENTRY SRLINE                   ALIGNMENT ROUTINE
WKBKPT   EQU   CTXOFP                   PHASE 8 WORK BUCKET POINTER
SRLINE   EQU   SRLIGN             EQUATE INTERNAL/EXTERNAL NAMES
MPRNT    EQU   F8NTRY1
ERRREC   EQU   X'10'                   ERROR RECORD TYPE 1
COMREC   EQU   X'20'                   COMMENT RECORD TYPE 2
COMGREC  EQU   X'30'                   GENERATED COMMENT RECORD TYPE 3
PROCREC  EQU   X'40'                   PROCESS ONLY RECORD TYPE 4
PCREC    EQU   X'60'                    TYPE 2 AND 4 RECORDS
PCGREC   EQU   X'70'                    TYPE 1,2,AND 3 RECORDS
SOURCE   EQU   X'70'                    SOURCE RECORDS
LITRHEX  EQU   X'25'                    HEX OP FOR LITRAL
ERRWRP  EQU   7                         LOCATION COUNTER ERROR
ADBLDMG  DC    V(BLDIMG)               ADDR OF BUILD IMAGE IN F8PRINT
         END   ASMGF8C
./ ADD NAME=ASMGF8D
F8D      TITLE     'ASMG F8  DC AND DS EVALUATION (DCEVAL)'
         ISEQ  73,78
ASMGF8D  START     ,                    START OF DCEVAL FOR F8
         PRINT      NOGEN
         FDIMEN
         PRINT GEN
*                                                                     *
*TITLE 'ASMGF8D ' ...  DC AND DS EVALUATION                           *
*FUNCTION/OPERATION-                                                  *
*  ASMGF8D PROCESSES DC'S, DS'S, CXD'S, AND LITERAL DC'S. IT PROCESSES*
*   THE ENTIRE STATEMENT AND CALLS ASMGF8P TO PUT OUT THE RESULTS AS  *
*   MANY TIMES AS NECESSARY. ASMGF8D PROCESSES MULTIPLE CONSTANTS FOR *
*   ALL OPERANDS EXCEPT 'C', 'H', AND 'B'. RELOCATION DICTIONARY (RLD)*
*   ENTRIES ARE MADE FOR 'A', 'Y', 'V', AND 'Q' TYPE RELOCATABLE      *
*   CONSTANTS. THE FOLLOWING ERRORS ARE FOUND AND LOGGED-             *
*              INVALID DISPLACEMENT          INVALID REGISTER         *
*              DATA ITEM TOO LARGE           RELOCATABILITY           *
*              INVALID DELIMITER                                      *
*ENTRY POINTS-                                                        *
*  ASMGF8D- DC EVALUATION. CALLED VIA-                                *
*        L     SRB,CDCVAL(ACT)                                        *
*        BALR  SRR,SRB                                                *
*   RLDRTN- ENTER INTO RLD DICTIONARY. CALLED VIA-                    *
*        L     SRB,CDCVAL(ACT)                                        *
*        L     GR1,=V(RLDRTN)                                         *
*        BALR  SRR,GR1                                                *
*   STLOC- CONTAINS THE LOCATION COUNTER WHEN RLDRTN IS CALLED        *
*INPUT-                                                               *
*  FOR ASMGF8D, THE RIGHTMOST BYTE OF REGISTER GRZ IS SET AS FOLLOWS- *
*           00 = DS ---- FF = DC ---- MIXED = LITERAL DC              *
*           BYTES 0,1, AND 2 OF THE 16 WORD OUTPUT BUFFER, F8INST(ACT)*
*           CONTAINS THE CURRENT ALIGNED LOCATION COUNTER.            *
*   FOR RLDRTN- SEE THE RLD ROUTINE.                                  *
*OUTPUT- DONE BY ASMGF8P(PRNT) AND ASMGF8I(PUTRLD).                   *
*EXTERNAL ROUTINES-                                                   *
*   NAME         ROUTINE      USE                                     *
*   CEEVAL(ACT)  ASMGF8V      EXPRESSION EVALUATION                   *
*   CTRRTN(ACT)  ASMGRTA      RETURN                                  *
*   PRNT(ACT)    ASMGF8P      PRINT AND/OR PUNCH                      *
*   F8DCMP(ACT)  ASMGF8M      DE-COMPILE ROUTINE                      *
*   CCONV(ACT)   ASMGF8N      FIXED-FLOATING POINT CONVERSION         *
*   PUTRLD(ACT)  ASMGF8I      PUT OUT RELOCATION DICTIONARY           *
*   CLOGER(ACT)  ASMGF8L      LOG ERROR                               *
*EXITS- NORMAL                                                        *
*  FROM ASMGF8D VIA  B  CTRTRN(ACT)                                   *
*   FROM RLDRTN VIA  BR SRR                                           *
*   -ERROR-- NONE                                                     *
*TABLES/WORKAREAS-                                                    *
*   DCBRANCH   BRANCH TABLE TO PROCESS THE TYPE DC                    *
*   TEMP       RLD TABLE                                              *
*NOTES-                                                               *
*   IN THE GENERAL FLOW, ASMGF8D IS CALLED BY ASMGF8M AND RETURNS TO  *
*   ASMGF8C.                                                          *
*
* DCEVAL WILL PROCESS AN ENTIRE DC STATEMENT EACH PASS. THE PRINT
* ROUTINE, F8PRNT WILL BE CALLED BY DCEVAL AS MANY TIMES AS NECESSARY.
* THERE WILL BE ONE DC WORKBUCKET PER OPERAND IN THE STATEMENT AND EACH
* OPERAND MAY CONTAIN ONE OR MORE CONSTANTS. EXCEPTIONS ARE C,X, AND B
* TYPE DC'S WHICH MAY CONTAIN ONLY ONE CONSTANT PER OPERAND.
*
* RLD ENTRIES ARE REQUIRED FOR A,Y, AND V TYPE RELOCATABLE CONSTANTS.
* HOWEVER, NO RLD ENTRIES ARE MADE FOR ADCONS WITHIN A DSECT OR COMMON
* OR FOR ADCONS WHOSE OPERAND ADDRESS IS WITHIN A DSECT. RLD ENTRIES
* ARE NOT MADE FOR A AND V TYPE CONSTANTS WITH A LENGTH MODIFIER
* LESS THAN 3 BYTES, NOR FOR Y TYPE CONSTANTS WITH A LENGTH MODIFIER
* LESS THAN 2 BYTES. BIT LENGTHS ARE NOT ALLOWED WITH RELOCATABLE
* ADCONS.
*
         EJECT
         USING ENTER,SRB
         SPACE 2
         ENTRY RLDRTN                   TO ALLOW FOR CCW ENTRIES
         ENTRY STLOC                       TO ALLOW FOR CCW ENTRIES
         SPACE 2
R0       EQU   0                        REGISTER EQUATES
R1       EQU   1                        THE REGISTER RXX IS EQUATED
R2       EQU   2                        TO THE ACTUAL REGISTER XX
R3       EQU   ACT                      SOME ARE FOR FUTURE USE
R4       EQU   GRA
R5       EQU   GRB
R6       EQU   GRC
R7       EQU   GRD
R8       EQU   SRB
R9       EQU   SRR
R10      EQU   SP1
R11      EQU   SP2
R12      EQU   FRB
R13      EQU   GRZ
R14      EQU   GRX
R15      EQU   GRY
INVDPERR EQU   8                        INVALID DISPLACEMENT ERROR
INVRGERR EQU   10                       INVALID REGISTER SPECIFICATION
TOOBIGER EQU   17                       DATA ITEM TOO LARGE.
RELOCERR EQU   25                       RELOCATABILITY ERROR
ADDRERR  EQU   35                       ADDRESSABILITY ERROR
INVDELIM EQU   39                       INVALID DELIMITER ERROR
         EJECT
ENTER    XC    BIT(5),BIT               SET BIT,BYTE,SW TO ZERO.
         MVI   RR+1,7                   SET BIT REMAINDER = 7
         LA    GRC,F8INST(ACT)          SET O/P PTR TO LOC CTR
         MVC   STLOC+1(3),0(GRC)        MOVE LOC CTR TO WORK AREA
         LA    GRC,3(GRC)               SET O/P PTR TO DATA BUFFER
         L     R1,CTEXTP(ACT)            GET PTR TO CURRENT TEXT RECORD
         CLI   4(R1),X'2C'               IS THIS A CXD INSTRUCTION
         BNE   NOCXD                     NO-BRANCH TO PROC. DC,DS OR LT
         LA    SP2,X'3C'                 SET RLD FLAG FOR CXD.
         XC    TEMP(36),TEMP             SET UP 4-BYTE VALUE AND 16
         MVI   TEMP+4,1                  2-BYTE PAIRS FOR RLD ROUTINE.
         MVI   TEMP+5,1
         L     SP1,ADTEMP               LOAD POINTER TO VALUE
         BAL   SRR,RLDRTN                MAKE RLD ENTRY
         LTR   R1,R1                     WAS RLD ENTRY MADE
         BZ    *+8                       NO, BRANCH
         MVI   1(R1),0                   YES, SET REL-ID = 0
         MVI   LMV+3,32                  SET LMV = 32 BITS.
         BAL   FRB,KZERO                 MOVE LMV BITS TO O/P BUFF
         B     ZWEI25                    BRANCH TO DO O/P AND EXIT.
NOCXD    L     SP1,CTXOFP(ACT)           LOAD PTR TO 1ST DC BUCKET
         TM    0(SP1),4                  DOES 1ST OPND CONTAIN AN ERROR
         BO    CTRTRN(ACT)               YES, EXIT.
         STC   GRZ,BYTEX                 00=DS FF=DC MIXED=LITERAL
         OI    F8YDC+1(ACT),1           SET EEVAL ADCON SWITCH.
         BAL   GRA,HSKP                 ALIGN DATA FROM DC BUCKET.
         TM    BYTEX,X'FF'
         BZ    DSCHECK                  BRANCH IF DS STATEMENT
         IC    R1,12(SP1)                GET ALIGN. FROM DC BUCKET
         SRL   R1,1                      POSITION ALIGNMENT BITS.
         N     R1,MASK3                  MASK ALIGNMENT BITS.
         LTR   R1,R1
         BZ    EIN8                     BRANCH IF NO ALIGNMENT
         L     R2,STLOC                 SUBTRACT ALIGNMENT FROM
         SR    R2,R1                     LOCATION COUNTER AND STORE
         ST    R2,STLOC                   RESULT.
         LA    GRC,F8INST(ACT)          RESET O/P POINTER.
AL2      MVC   0(3,GRC),STLOC+1         ALIGNMENT LOC CTR TO O/P BUFFER
         XC    3(7,GRC),3(GRC)          SET BYTES 4-10 OF O/P TO ZERO
         STC   R1,15(GRC)               NO. ALIGN. BYTES TO O/P BUFFER
         OI    15(GRC),X'80'            SET ALIGNMENT FLAG
         AR    R2,R1                    RESTORE ALIGNED
         ST    R2,STLOC                  LOCATION COUNTER
         BAL   SRR,TSBPRT               PRINT ALIGNMENT LINE
         EX    R0,AL2                   ALIGNED LOC CTR TO O/P BUFFER
         LA    GRC,3(GRC)               SET O/P PTR TO DATA AREA.
EIN8     TM    12(SP1),1                TEST LENGTH MODIFIER TYPE
         BO    EIN19                    BRANCH IF BIT LENGTH
         TM    SW,1                     TEST 1ST OPERAND SWITCH
         BZ    EIN15                    BRANCH IF 1ST OPERAND
         CLI   RR+1,7
         BE    EIN15                    BRANCH IF R = 7
         BAL   R13,SUB1                 FILL O/P BYTE
         MVI   RR+1,7                   SET R=7
EIN15    L     R0,LMV                   CONVERT BYTE LENGTH TO BIT
         SLL   R0,3                     LENGTH
         ST    R0,LMV
         ST    R0,LMV+4
EIN19    MVC   SAVWBP(4),CTXWBP(ACT)   UPDATE SYMBOL BKT PTR
         CLC   DUP(3),DUP+1            IS DUP. FACTOR INITIALLY ZERO
         BNE   EIN20                    NO
         OI    SW,X'10'                 YES, SET ZERO DUP FAC SWITCH
         B     DSCHECK                  BRANCH TO DS ERROR CK. ROUTINE
EIN20    L     R1,LMV
         M     R0,NN                    COMPUTE NEW R = (DNL+R)/8
         M     R0,DUP                    AND STORE RESULT.
         AH    R1,RR
         LA    R2,7
         NR    R1,R2
         STC   R1,RR+1
GETLMV   MVC   LMV(4),LMV+4             RESTORE LENGTH MODIFIER.
         SR    GRB,GRB
         IC    GRB,9(SP1)               RELATIVE POINTER TO GRB
         A     GRB,F8OPRN(ACT)          ADD OPERAND POINTER
         L     R1,CTXWBP(ACT)           FETCH SYMBOL BUCKET POINTER.
         LTR   R1,R1                    ARE THERE ANY SYMBOL BUCKETS
         BZ    PTROK1                   NO, BRANCH.
         SPACE 1
* THIS ROUTINE USES EXPRESSION EVALUATION TO ADVANCE THE SYMBOL BUCKET
* POINTER PAST ALL MODIFIER SYMBOL BUCKETS IF THERE ARE ANY.
         SPACE 1
         STM   SRB,SP1,SRBGRY           SAVE DCEVAL BASE & DCBKT PTR.
         L     SP1,F8OPRN(ACT)          FETCH OPERAND POINTER.
         NI        DURHAM1+1,X'0F'     SET LOOK FOR QUOTE=YES
RALEIGH  CR    SP1,GRB                  COMPARE OPND. PTR. TO ADJ. PTR.
         BE    PTROK                    BRANCH IF EQUAL.
         CLI       0(SP1),IQUOTE       IS IT A QUOTE
         BE        DURHAM3             YES REVERSE SEARCH FOR QUOTE
DURHAM1  BC        0,DURHAM4           IF LOOK FOR QUOTE=NO,BRANCH
         CLI       0(SP1),ILPARN       IS IT A LEFT PARN
         BNE       DURHAM4             NO, CONTINUE SCAN
DURHAM2  LA        SP1,1(0,SP1)        SKIP OVER DELIMITER
         ST        GRX,SAV14           SAVE R14 FOR BIT LENGTHS
         L         SRB,CEEVAL(0,ACT)   LOAD EVAL BASE
         BALR      SRR,SRB             CALL EVAL
         USING     *,SRR               SET UP A TEMP BASE
         L         SRB,SRBGRY          RESTORE OUR BASE
         DROP      SRR                 NO LONGER NEED SRR AS A BASE
         L         GRX,SAV14           RESTORE R14
         CLI       0(SP1),IRPARN       IS IT A RIGHT PARN
         BNE       DURHAM2             NO, CALL EVAL AGAIN
         B         RALEIGH             YES, CONTINUE SCAN
DURHAM3  XI        DURHAM1+1,X'F0'     REVERSE LOOK FOR QUOTE
DURHAM4  LA        SP1,1(0,SP1)        STEP OPERAND POINTER
         B         RALEIGH             CONTINUE SCAN
         SPACE 1
PTROK    L     SP1,SRBGRY+8             RESTORE DCBKT POINTER.
PTROK1   LA    GRB,1(GRB)               STEP PAST LEFT DELIMITER.
         ST    GRB,POINT                STORE INCREMENTED POINTER
         NI    1(SP1),X'0F'             MASK 2ND BYTE OF DC BUCKET
         SR    R1,R1
         IC    R1,1(SP1)                CODED DC TYPE TO R1
         AR    R1,R1                    MULTIPLY BY 2
         LH    FRB,DCBRANCH(R1)         LOAD OFFSET RELATIVE TO CT
         BAL   SRR,CT(FRB)              BRANCH TO PROCESS DC BY TYPE
         OI    SW,1                     SET 1ST OPERAND SWITCH.
         TM    BYTEX,X'FF'
         BZ    ZWEI3                    BRANCH IF DS.
         L     R1,DUP
         BCTR  R1,0                     DECREMENT DUP FACTOR
         ST    R1,DUP
         LTR   R1,R1                    ITER ATE UNTIL DUP FACTOR = 0
         MVC   CTXWBP(4,ACT),SAVWBP     RESTORE SYMBOL BUCKET POINTER.
         BNZ   GETLMV                  BRANCH IF DUP FACTOR NOT ZERO
ZWEI3    TM    0(SP1),X'48'             ANOTHER OPERAND TO FOLLOW
         BO    ZWEI4                    NO
         LA    SP1,15(SP1)              YES, GET POINTER TO NEXT BUCKET
         TM    0(SP1),4                 DOES NEXT OPND HAVE AN ERROR
         BO    ZWEI4                    YES, PREPARE TO EXIT
         BAL   GRA,HSKP                 ALIGN DATA FROM DC BUCKET
         TM    BYTEX,X'FF'              IF DS STATEMENT, BRANCH TO DO
         BZ    DSCHECK                  DS PROCESSING. OTHERWISE,
         NI    SW,X'FD'                 ENABLE PRINT SWITCH.
         TM    12(SP1),X'0E'            TEST ALIGNMENT
         BZ    EIN8                     BRANCH IF ZERO
         CLI   RR+1,7                   FILL NEEDED
         BE    ZWEI19                   NO, BRANCH
         BAL   R13,SUB1                 YES, FILL O/P BYTE
         MVI   RR+1,7                   SET R=7
ZWEI19   IC    GRY,12(SP1)              FETCH ALIGNMENT FROM DC BUCKET
         SRL   GRY,1                    RIGHT JUSTIFY
         N     GRY,MASK3                MASK
         SR    R14,R14                  SET WORKING BYTE TO ZERO
ZWEI20   BAL   R13,SUB2                 ONE ALIGNMENT BYTE TO O/P.
         BCT   GRY,ZWEI20               CONTINUE UNTIL DONE
         B     EIN15                    PROCESS NEXT OPERAND
ZWEI4    TM    BYTEX,X'FF'              IS THIS A DS STATEMENT
         BZ    DSPROC                   YES
         TM    SW,X'10'                 WAS DUP FACTOR INITIALLY ZERO
         BO    DUPZERO                  YES, BRANCH.
         CLI   RR+1,7                   DOES LAST BYTE NEED FILL
         BE    ZWEI25                   NO
         BAL   R13,SUB1                 FILL LAST BYTE
ZWEI25   LA    GRC,F8INST(ACT)          RESET O/P POINTER
         MVC   15(1,GRC),BYTE+1         MOVE BYTE COUNT TO O/P BUFFER
         L     R1,CTEXTP(ACT)           FETCH PTR TO CURRENT TEXT REC.
         CLI   4(R1),X'2B'              IS THIS A DXD INSTRUCTION.
         BNE   NODXD                    NO-BRANCH
         MVI   15(GRC),X'0F'            YES-DONT PRINT LOCATION CTR.
NODXD    BAL   SRR,TSBPRT               PRINT O/P BUFFER.
         NI    F8YDC+1(ACT),X'FE'     RESET EEVAL ADCON SWITCH.
         MVC   CTLOC(4,ACT),STLOC       UPDATE CTLOC TO CURRENT VALUE
         B     CTRTRN(ACT)              EXIT FROM DCEVAL.
HSKP     MVC   DUP+1(3),5(SP1)          MOVE DUP FACTOR,NUMBER OF
         MVC   NN+3(1),8(SP1)            CONSTANTS, AND LENGTH MODIFIER
         MVC   LMV+2(2),13(SP1)           VALUE FROM DC WORK BUCKET TO
         MVC   LMV+6(2),13(SP1)            ALIGNED LOCATIONS AND
         BR    GRA                          RETURN TO USER.
         EJECT
* THIS ROUTINE PROCESSES ALL OPERANDS IN A DS STATEMENT AND IN DC
* STATEMENTS WITH INITIAL DUP. FACTOR EQUAL ZERO. ERROR CHECKING IS
* DONE ONLY ON F,H,E,D,A,Y, AND S TYPE OPERANDS WHICH CONTAIN TEXT.
* ALL OTHER NECESSARY ERROR CHECKING HAS BEEN DONE IN PRIOR PHASES.
         SPACE 1
DSCHECK  OI    SW,2                     SET SWITCH TO DISABLE PRINT
         TM    SW,1                     IS THIS 1ST OPERAND
         BO    DSCHECK1                 NO, BRANCH
         MVC   HOLDLCTR(3),F8INST(ACT)  SAVE ALIGNED LOCATION COUNTER
DSCHECK1 TM    0(SP1),2                 DOES DS CONTAIN TEXT
         BZ    ZWEI3                    NO, LOOK FOR NEXT OPERAND.
         CLI   1(SP1),5                 IS THIS F,H,E,D,A,Y,V,OR S
         BL    ZWEI3                    NO, LOOK FOR NEXT OPERAND
         CLI   1(SP1),11                IS THIS A V-CON
         BE    ZWEI3                    YES, LOOK FOR NEXT OPERAND
         TM    SW,X'10'                 IS THIS DC WITH DUP FAC = 0
         BZ    EIN8                     NO, BRANCH TO ERROR CHECK DS.
         MVI   DUP+3,1                  SET DUP FACTOR = 1
         B     GETLMV                   BRANCH TO CHECK DC, DUP FAC = 0
DSPROC   MVI   BYTE+1,X'F0'              SET DS FLAG FOR PRINT ROUTINE
         MVC   F8INST(3,ACT),HOLDLCTR   RESTORE ALIGNED LOCATION CTR.
DUPZERO  NI    SW,X'FD'                  ENABLE PRINT SWITCH
         B     ZWEI25                   BRANCH TO TERMINATE DS PROC.
         EJECT
* PRINT ONE LINE AND RETURN ONLY IF THE PRINT SWITCH IS ENABLED.
         SPACE 1
TSBPRT   TM    SW,2                     IS PRINT SWITCH ENABLED
         BCR   1,SRR                    NO, RETURN IMMEDIATELY.
         STM   SRB,GRY,SRBGRY           SAVE REGISTERS 8 THRU 15
         OI    15(GRC),X'40'            THIS IS A DC STATEMENT
         L     FRB,PRNT(ACT)            PRINT ROUTINE USES BASE FRB
         BALR  SRR,FRB                  AND RETURNS VIA SRR.
         USING *,SRR                    USE SRR AS BASE UNTIL
         LM    SRB,GRY,SRBGRY           WE CAN RESTORE OUR BASE
         DROP  SRR                      NO LONGER NEED SRR AS BASE
         BR    SRR                      EXIT
         EJECT
* THIS SUBROUTINE MOVES ONE WORK BYTE TO THE OUTPUT BUFFER. IF THE
* OUTPUT BUFFER IS ALREADY FULL, IT IS PRINTED FIRST, AND THE SUBJECT
* BYTE STARTS TO FILL THE OUTPUT BUFFER AGAIN. SUB1 IS SELF-EXPLANATORY
*
SUB1     LA    R1,7                7 TO R1
         SH    R1,RR                    7-R
         SLL   R14,0(R1)           PAD WORK BYTE WITH (7-R) ZERO BITS
SUB2     ST    SRR,TSBSRR               TO KEEP FROM GETTING LOST.
         CLI   BYTE+1,8                 IS OUTPUT BUFFER FULL
         BE    ZWEI8               YES - BRANCH
ZWEI11   STC   R14,0(GRC)          WORK BYTE TO OUTPUT BUFFER
         LA    GRC,1(GRC)          INCREMENT OUTPUT POINTER
         IC    R2,BYTE+1                INCREMENT BYTE COUNT
         LA    R2,1(R2)
         STC   R2,BYTE+1                SAVE BYTES IN F8INST
         L     R2,STLOC                 ADD 1 TO INTERNAL LOC. COUNTER
         LA    R2,1(R2)
         ST    R2,STLOC                 SAVE INTERNAL LOCATION COUNTER
         L     SRR,TSBSRR               RESTORE SRR
DIXON    MVI   BIT+1,0                  SET BIT COUNT = 0
         SR    R14,R14                  SET WORKING BYTE = 0
         BR    R13                      VAMOOSE ***********************
ZWEI8    LA    GRC,F8INST(ACT)          RESET OUTPUT POINTER
         MVI   15(GRC),8           8 TO OUTPUT COUNT
         BAL   SRR,TSBPRT               PRINT OUTPUT BUFFER
         EX    R0,AL2                   LOC. CTR. TO O/P BUFFER
         LA    GRC,3(GRC)          ADD 3 TO OUTPUT COUNT
         MVI   BYTE+1,0                 SET BYTE COUNT=0
         B     ZWEI11                   CONTINUE PUTTING IN BYTE
         EJECT
* THE KZERO SUBROUTINE CREATES OUTPUT FROM THE REVISED EDITED TEXT
* TRUNCATION HAS ALREADY BEEN DONE.
*
KZERO    TM    SW,2                     TEST PRINT SWITCH
         BCR   1,FRB                    BRANCH IF ON.
KKZERO   LA    GRB,TEMP                 FETCH POINTER TO TEMP BUFFER.
SVN02    MVC   FULL(4),0(GRB)           ALIGN NEXT FOUR WORDS OF OPND
         L     R15,FULL                 FULL WORD TO ODD REGISTER
         XC    TSHIFT(2),TSHIFT         SET TOTAL SHIFT = 0
SVN03    LA    GRB,4(GRB)               ADD 4 TO TEMP POINTER.
SVN04    LA    R11,8               IS (8-BIT- GREATER THAN
         SH    R11,BIT              OR EQUAL TO LMV
         L     R1,LMV
         CR    R11,R1
         BL    SVN10                    NO,BRANCH
SVN05    SLDL  R14,0(R1)           YES, SHIFT LMV BITS TO WORK BYTE
         AH    R1,BIT                   LMV+BIT
         STH   R1,BIT                   STORE NEW BIT COUNT
         CLI   BIT+1,8                  DOES BIT COUNT=8
         BNE   SVN09                    NO,BRANCH
         BAL   R13,SUB2                 PUT IN BYTE
SVN09    BR    FRB                      EXIT FROM OUTPUT ALGORITHM*****
SVN10    SLDL  R14,0(R11)          SHIFT (8-BIT) BITS TO WORK BYTE
         SR    R1,R11              LMV-(8-BIT)
         ST    R1,LMV                   STORE NEW LMV
         AH    R11,TSHIFT          TSHIFT+(8-BIT)
         STH   R11,TSHIFT          STORE NEW TOTAL SHIFT
         BAL   R13,SUB2                 PUT IN BYTE
         LA    R2,32                    (32-TSHIFT) GREATER THAN OR
         SH    R2,TSHIFT                 EQUAL TO 8
         LA    R1,8
         CR    R2,R1
         BNL   SVN04                    YES,BRANCH
         L     R1,LMV                   NO,(32-TSHIFT) GREATER THAN OR
         CR    R2,R1                     EQUAL TO LMV
         BNL   SVN05                    YES,BRANCH
         SLDL  R14,0(R2)           NO,SHIFT (32-TSHIFT) BITS
         SR    R1,R2                    LMV-(32-TSHIFT)
         ST    R1,LMV                   STORE NEW LMV
         AH    R2,BIT                   (32-TSHIFT)+BIT
         STH   R2,BIT                   STORE NEW BIT COUNT
         B     SVN02                    AND CONTINUE PROCESSING
         EJECT
* THE KNEG SUBROUTINE TRUNCATES THE REVISED EDITED TEXT **ON THE LEFT**
* IF NEEDED AND BRANCHES TO KZERO.
*
KNEG     TM    SW,2                     TEST PRINT SWITCH.
         BCR   1,FRB                    BRANCH IF ON.
         STM   R6,R7,SAV2               SAVE
         LH    R6,KX               KX TO EVEN REGISTER
         LPR   R6,R6               SET KX POSITIVE
         SRDL  R6,3                DIVIDE BY 8, REMAINDER TO R7
         LA    GRB,TEMP                 SET OPERAND POINTER
         AR    GRB,R6                   TRUNCATE OPERAND KX/8 BYTES
         SR    R6,R6                    CLEAR KX/8
         SLDL  R6,3                     SHIFT IN REMAINDER
         EX    R0,SVN02                 FULL WORD TO ODD REGISTER
         L     R15,FULL                 FULL WORD TO ODD REGISTER
         SLL   R15,0(R6)           TRUNCATE BY KX/8 REMAINDER
         STC   R6,TSHIFT+1              TSHIFT=NO. OF TRUNC. BITS
         LM    R6,R7,SAV2               RESTORE
         MVI   TSHIFT,0                 FIX FOR THE PHANTOM BULLDOGGER
         B     SVN03                    BRANCH TO CONTINUE PROCESSING.
         SPACE 3
* THE KPOS SUBROUTINE PADS THE REVISED EDITED TEXT **ON THE LEFT**
* IF NEEDED AND BRANCHES TO KZERO.
*
KPOS     TM    SW,2                     TEST PRINT SWITCH
         BCR   1,FRB                    BRANCH IF ON.
         LH    GRA,KX                   LOAD NUMBER OF BITS TO PAD.
         LA    R1,8
         SH    R1,BIT
         CR    R1,GRA                   IS KX LESS THAN (8-BIT)
         BNL   NINE04                   YES, BRANCH
         SLL   R14,0(R1)                SHIFT WORK BYTE LEFT (8-BIT)
         SR    GRA,R1                   SUBTRACT AMT OF SHIFT FROM KX
         STH   GRA,KX                   STORE DECREMENTED KX
         L     R2,LMV                   SUBTRACT AMT OF SHIFT FROM LMV
         SR    R2,R1
         ST    R2,LMV                   STORE DECREMENTED LMV
         BAL   R13,SUB2                 WORK BYTE TO TEMP BUFFER
         B     KPOS                     BRANCH TO CONTINUE PADDING
NINE04   SLL   R14,0(GRA)               SHIFT WORK BYTE LEFT KX BITS
         L     R2,LMV                   SUBTRACT AMT OF SHIFT FROM LMV
         SR    R2,GRA
         ST    R2,LMV                   STORE DECREMENTED LMV
         AH    GRA,BIT                  ADD AMT OF SHIFT TO BIT COUNT
         STH   GRA,BIT                  STORE INCREMENTED BIT COUNT
         CLI   BIT+1,8                  DOES BIT COUNT = 8
         BNE   KKZERO                   NO,LEFT SIDE PADDING COMPLETE
         BAL   R13,SUB2                 YES, WORK BYTE TO TEMP BUFFER
         B     KKZERO                   BRANCH TO CONTINUE PROCESSING.
         EJECT
* THIS SUBROUTINE PROCESSES CHARACTER TYPE DC STATEMENTS***************
*
CT       LA    GRA,HEXBIN               COLLAPSE, TRANSLATE CHAR STRING
CLPSE    LA    GRD,TEMP                 LOAD PTR. TO TEMP BUFFER
TEN02    CLI   0(GRB),IQUOTE            IS 1ST CHAR. QUOTE
         BNE   AMP                      NO
         CLI   1(GRB),IQUOTE            YES,IS 2ND CHAR. QUOTE
         BNE   LVN00                    NO, END OF CHARACTER STRING.
STOCH    MVC   0(1,GRD),0(GRB)          MOVE OPND. CHAR. TO TEMP BUFFER
         LA    GRB,2(GRB)               ADD 2 TO OPND. PTR.
TEN05    LA    GRD,1(GRD)               ADD 1 TO TEMP BUFFER PTR.
         B     TEN02                    LOOK AT NEXT CHAR. OF OPND.
AMP      CLI   0(GRB),IAMPSD            IS 1ST CHAR. AMPERSAND
         BE    STOCH                    YES, ASSUME 2ND AND CONTINUE.
NOAMP    EX    R0,STOCH                 STORE CHAR. NOT AMP. OR QUOTE
         LA    GRB,1(GRB)               ADD 1 TO OPND. PTR.
         B     TEN05                    BRANCH TO LOOK AT NEXT CHAR.
LVN00    ST    GRD,TPOINT               SAVE TEMP POINTER
         S     GRD,ADTEMP               GET TOTAL LENGTH
         LR    R1,GRD                   SAVE TOTAL LENGTH
         SLL   GRD,3                    MULTIPLY BY 8
         L     R11,LMV             COMPUTE LMV-8(TOTAL LENGTH) = KX
         SR    R11,GRD
         STH   R11,KX                   KEEP KX
         BP    LVN05               BRANCH TO PAD
TRNSLT   BCTR  R1,0                     DECR. TOTAL LENGTH TO TRANSLATE
         L     R2,CTRTBP(ACT)           LOAD POINTER TO TRANSLATE TABLE
         EX    R1,INTEXT                TRANSLATE TEMP BUFFER
         BR    GRA                      EXIT CLPSE SUBROUTINE**********
LVN05    LA    R11,7(R11)               ADD 7 TO KX
         SRL   R11,3                    DIVIDE BY 8
         L     GRD,TPOINT               LOAD TEMP POINTER
LOOPC    MVI   0(GRD),IBLANK            PAD TEMP BUFFER ON RIGHT SIDE
         LA    GRD,1(GRD)               WITH BLANKS
         BCT   R11,LOOPC                LOOP TO COMPLETE PAD
         S     GRD,ADTEMP               GET TOTAL LENGTH
         LR    R1,GRD                   PADDED LENGTH TO REG. 1
         B     TRNSLT                   BRANCH TO TRANSLATE
INTEXT   TR    TEMP(0),0(R2)            INTERNAL TO EXTERNAL EBCDIC
         EJECT
* THIS SUBROUTINE PROCESSES HEXADECIMAL TYPE DC STATEMENTS ************
*
XT       LA    GRD,TEMP                 LOAD PTR. TO TEMP BUFFER
SIX00    CLI   0(GRB),IQUOTE            END QUOTE
         BE    SVN00                    YES, BRANCH
         SR    R0,R0                    CLEAR R0
         IC    R0,0(GRB)                SOURCE CHAR. TO R0
         SLL   R0,4                     SHIFT LEFT 4
         CLI   1(GRB),IQUOTE            NEXT CHAR. END QUOTE
         BE    SIX10                    YES, BRANCH
         IC    R1,1(GRB)                LOGICAL OR
         OR    R0,R1                     WITH PREVIOUS CHARACTER
         STC   R0,0(GRD)                STORE 2 HEX CHARS.
         LA    GRB,2(GRB)               ADD 2 TO SOURCE POINTER
         LA    GRD,1(GRD)               ADD 1 TO EDITED HEX. POINTER
         B     SIX00                    LOOP UNTIL OPERAND EXHAUSTED
SIX10    STC   R0,0(GRD)                STORE 1 HEX CHAR.
         LA    GRB,1(GRB)               ADD 1 TO SOURCE POINTER
SVN00    S     GRB,POINT                COMPUTE SOURCE LENGTH
         SLL   GRB,2                    MULTIPLY BY 4
COMPKX   L     R11,LMV                   COMPUTE KX
         SR    R11,GRB
         STH   R11,KX
         BP    NINE00                   KX IS PLUS, PAD
         BM    SVN18                    KX IS MINUS, TRUNCATE
HEXBIN   BAL   FRB,KZERO                 NO PADDING OR TRUNCATION
         BR    SRR                      EXIT HEXADECIMAL SUBROUTINE****
SVN18    BAL   FRB,KNEG                 NEGATIVE, TRUNCATE
         BR    SRR                      EXIT***************************
NINE00   BAL   FRB,KPOS                 POSITIVE, PAD
         BR    SRR                      EXIT***************************
         EJECT
* THIS SUBROUTINE PROCESSES BINARY TYPE DC STATEMENTS
*
BT       LA    GRD,TEMP                 LOAD PTR. TO TEMP BUFFER
         SR    GRA,GRA                  SET BIT COUNTER = 0
SEARCH   CLI   0(GRB),IQUOTE            SEARCH OPERAND FOR END QUOTE
         BE    FOUND                    BRANCH WHEN FOUND
         CH    GRA,=H'8'                DOES BIT COUNT = 8
         BNE   FVE05                    NO
         STC   R0,0(GRD)                YES, STORE WKBYTE IN TEMP BUFF.
         LA    GRD,1(GRD)               INCREMENT TEMP BUFFER PTR.
         SR    R0,R0                    SET WORKING BYTE = 0
         SR    GRA,GRA                  SET BIT COUNTER = 0
FVE05    SLL   R0,1                     SHIFT WKBYTE LEFT 1
         IC    R1,0(GRB)                LOGICAL OR OPERAND CHARACTER
         OR    R0,R1                    TO WORKING BYTE
         LA    GRB,1(GRB)               INCREMENT OPERAND PTR.
         LA    GRA,1(GRA)               INCREMENT BIT COUNTER
         B     SEARCH                   GET NEXT CHARACTER
FOUND    LCR   GRA,GRA                  LEFT JUSTIFY WORKING BYTE
         SLL   R0,8(GRA)
         STC   R0,0(GRD)                STORE LAST BYTE IN TEMP
         S     GRB,POINT                COMPUTE LENGTH OF OPERAND
         B     COMPKX                   REST OF BINARY ROUTINE
*                                       SAME AS HEX ROUTINE
         EJECT
* THIS SUBROUTINE PROCESSES PACKED AND ZONED TYPE DC STATEMENTS
*
PZ       NI    SW,X'F7'                 SET LAST CONSTANT SWITCH = 0
TWV00    L     GRD,=A(TEMP+20)          LOAD POINTER
         MVI   CHTEMP+1,0               RESET PACKING SWITCH
         CLI   0(GRB),IPLUS             IS CHAR. +
         BE    TWV04                    YES
         CLI   0(GRB),IMINUS            NO, IS CHAR. -
         BE    TWV04                    YES
         B     TWV03                    NO
TWV04    LA    GRB,1(GRB)               INCREMENT OPERAND PTR.
TWV03    CLI   0(GRB),IPRIOD            IS CHAR. DECIMAL POINT
         BNE   TWV06                    NO
         LA    GRB,1(GRB)               YES, IGNORE IT
TWV06    CLI   0(GRB),IQUOTE            IS CHAR. QUOTE
         BE    TWV09                    YES
         CLI   0(GRB),ICOMMA            NO, IS CHAR. COMMA
         BE    TWV10                    YES
         MVC   0(1,GRD),0(GRB)          NO, MOVE CHAR. TO TEMP BUFFER
         LA    GRD,1(GRD)               INCREMENT TEMP BUFFER PTR.
         B     TWV04                    LOOP TO END OF CONSTANT.
TWV09    OI    SW,8                     SET LAST CONSTANT SWITCH = 1
TWV10    LA    GRB,1(GRB)               SET OP.PTR. TO START NEXT CONST
         L     GRA,POINT                LOAD PRESENT OPERAND PTR.
         ST    GRB,POINT                SAVE NEXT PTR.
         CLI   1(SP1),I3                IS THIS DC PACKED OR ZONED
         BNE   ZONED                    BRANCH IF ZONED
         SPACE 2
* PROCESS PACKED DC. COLLAPSED TEXT STARTS AT TEMP+20
* AND GETS PACKED INTO TEMP THRU TEMP+15.
         SPACE 2
         BCTR  GRD,0                    DECR. TEMP PTR. TO STORE SIGN
         BAL   FRB,TWV12                SET PROPER SIGN
         S     GRD,=A(TEMP+20)          UNPACKED LENGTH - 1
         LA    GRD,1(GRD)               ADD 1
         LA    GRA,15                   IS UNPACKED LENGTH > 15?
         CR    GRD,GRA
         BNH   WEEP                     NO, BRANCH.
         STC   GRD,CHTEMP+2             YES, SAVE TOTAL LENGTH,
         SR    GRD,GRA                  COMPUTE TL - 15,
         STC   GRD,CHTEMP+1             AND STORE.
WEEP     LR    GRA,GRD                  SAVE LENGTH TO BE PACKED FIRST
         LA    GRD,2(GRD)               PACKED LENGTH =
         SRL   GRD,1                    (UNPACKED LENGTH+2)/2
         STC   GRD,CHTEMP               SAVE PACKED LENGTH
         BCTR  GRD,0                    PACKED LENGTH-1
         BCTR  GRA,0                    UNPACKED LENGTH-1
         SLL   GRD,4                    POSITION PACKED LENGTH
         OR    GRA,GRD                  LOGICAL OR TWO LENGTHS
         LA    GRD,TEMP                 PTR. TO TEMP BUFFER
         CLI   CHTEMP+1,0               IS SOURCE LENGTH > 15?
         BNE   BIGPACK                  YES, BRANCH TO PACK IT.
         EX    GRA,PACK                 NO, PACK FROM TEMP+20 TO TEMP.
         B     THTN00
BIGPACK  MVI   TEMP,0                   SET TEMP = 0
         EX    GRA,PACKA                PACK FROM TEMP+20 TO TEMP+1
         IC    GRA,CHTEMP               FETCH LENGTH ALREADY PACKED
         LR    GRD,GRA                  SET UP LENGTHS FOR EXECUTING
         SLL   GRD,4                    MVO INSTRUCTION.
         OR    GRA,GRD
         EX    GRA,OFFSET               MOVE WITH OFFSET TEMP TO TEMP+1
         SR    GRA,GRA                  ZERO BOTH REGISTERS SO
         SR    GRD,GRD                    CHARACTER CAN BE INSERTED
         IC    GRD,CHTEMP               GET READY TO PACK REMAINING
         A     GRD,ADTEMP               15 SOURCE BYTES
         IC    GRA,CHTEMP+1
         A     GRA,=A(TEMP+20)
         PACK  1(8,GRD),0(15,GRA)       PACK REMAINING 15 BYTES
         SR    R2,R2
         IC    R2,CHTEMP+2              COMPUTE TOTAL PACKED LENGTH
         LA    R2,2(R2)                  AND STORE FOR FUTURE
         SRL   R2,1                     REFERENCE BY
         STC   R2,CHTEMP                PACKING ROUTINE.
MOVAGAIN MVC   TEMP(17),TEMP+1          IF LENGTH OF 1ST PACK IS ODD,
         TM    CHTEMP+1,1               MOVE O/P DATA FROM TEMP+1 TO
         BO    THTN00                   TEMP. IF EVEN, MOVE O/P DATA
         EX    R0,MOVAGAIN              FROM TEMP+2 TO TEMP.
THTN00   TM    0(SP1),X'10'             DOES TEXT CONTAIN LMV
         BZ    THTN03                   NO
         SR    R2,R2                    YES, COMPUTE KX,LMV-8(TL)
         IC    R2,CHTEMP
         SLL   R2,3
         L     R1,LMV
         SR    R1,R2                    R1 NOW = KX
         STH   R1,KX
         BM    THTN05                   BRANCH TO TRUNCATE ON LEFT
         BP    THTN06                   BRANCH TO PAD ON LEFT
THTN04   BAL   FRB,KZERO                NO PADDING OR TRUNCATION
THTN07   TM    SW,8                     IS DELIMITER QUOTE
         BCR   1,SRR                    YES, EXIT PZ ROUTINE***********
         L     GRB,POINT                NO,LOAD PTR. TO NEXT CONSTANT
         EX    R0,GETLMV                RESTORE LENGTH MODIFIER.
         B     TWV00                    BRANCH TO PROCESS NEXT CONSTANT
THTN03   SR    GRD,GRD
         IC    GRD,CHTEMP               SET LMV = TOTAL LENGTH IN BITS
         SLL   GRD,3                              FOR PACKED DC
         ST    GRD,LMV                  KEEP LENGTH OF MOVE
         B     THTN04                   BRANCH TO OUTPUT PACKED DC.
THTN05   BAL   FRB,KNEG                 GO TO LEFT TRUNCATION ROUTINE
         B     THTN07                   GO BACK TO MAIN FLOW
THTN06   BAL   FRB,KPOS                 GO TO LEFT PADDING ROUTINE
         B     THTN07                   GO BACK TO MAIN FLOW
TWV12    CLI   0(GRA),IMINUS            IS SIGN MINUS
         BE    TWV14                    YES
         OI    0(GRD),X'C0'             NO, SET SIGN PLUS
         BR    FRB                      RETURN
TWV14    OI    0(GRD),X'D0'             SET SIGN MINUS
         BR    FRB                      RETURN
PACK     PACK  0(0,GRD),20(0,GRD)       VARIABLE LENGTH PACK
PACKA    PACK  1(0,GRD),20(0,GRD)       VARIABLE LENGTH PACK
OFFSET   MVO   TEMP+1(0),TEMP(0)      VARIABLE LENGTH MOVE WITH OFFSET
         SPACE 2
* PROCESS ZONED DC. COLLAPSED TEXT STARTS AT TEMP+20.
         SPACE 2
ZONED    XC    TEMP(16),TEMP            SET 1ST 16 BYTES OF TEMP = 0
         S     GRD,=A(TEMP+20)          COMPUTE AND STORE TOTAL
         ST    GRD,LAST                 LENGTH FOR ZONED DC.
         LCR   R2,GRD
          LA   R2,TEMP+16(R2)            RIGHT JUSTIFY ZONED DATA IN
         BCTR  GRD,0                    1ST 16 BYTES OF TEMP BUFFER.
         EX    GRD,MOVEX
         L     GRD,CTRTBP(ACT)          POINTER TO TRANSLATE TABLE
         TR    TEMP(16),0(GRD)          TRANSLATE 1ST 16 BYTES OF TEMP
         LA    GRD,TEMP+15
         NI    0(GRD),X'0F'             SET PROPER SIGN FOR ZONED DC.
         BAL   FRB,TWV12                PUT IN SIGN
         TM    0(SP1),X'10'             DOES TEXT CONTAIN LMV
         BO    THTN08                   YES,BRANCH
         L     GRD,LAST                 NO,SET LMV = TOTAL LENGTH IN
         SLL   GRD,3                    BITS FOR ZONED DC.
         ST    GRD,LMV
THTN08   LA    R1,128                   TRUNCATE LMV-128 BITS OF 1ST
         L     GRD,LMV                  16 BYTES OF TEMP BUFFER AND
         SR    GRD,R1                   OUTPUT REMAINDER.
         STH   GRD,KX
         BZ    THTN04                   NO PADDING OR TRUNCATION
         B     THTN05                   TRUNCATE
MOVEX    MVC   0(0,R2),TEMP+20          VARIABLE LENGTH MOVE
         EJECT
*        THIS SUBROUTINE PROCESSES A AND Y TYPE ADDRESS CONSTANTS
*
*                         -SPECIFICATIONS-
*
*                                             A               Y
*
* IMPLIED LENGTH (BYTES)                4               2
* ALIGNMENT                             WORD            HALF WORD
* LENGTH MODIFIER RANGE (RELOCATABLE)   3-4             2-4
* LENGTH MODIFIER RANGE (ABSOLUTE)      .1-4            .1-4
* SPECIFIED BY                          ANY EXPRESSION  ANY EXPRESSION
* NUMBER OF CONSTANTS PER OPERAND       MULTIPLE        MULTIPLE
* TRUNCATION SIDE (NO PADDING ALLOWED)  LEFT            LEFT
*
AY       STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10.
         LR    SP1,GRB                  SET SP1 = PTR. TO 1ST CHAR.
AYE2     ST    SP1,ERRORPTR             SAVE PTR TO CONSTANT
         BAL   GRY,EXPRES               EVALUATE EXPRESSION.
         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL
         BC    1,AYK1                   BRANCH IF CC=3 (EEVAL ERROR)
         BC    8,AYC3                   BRANCH IF CC=0 (ABS. EXP.)
         TM    ACONPT,X'20'            BRANCH IF EXPRESSION IS
         BC    1,AYE3                   COMPLEXLY RELOCATABLE
          XC   6(30,SP2),6(SP2)         SIMP.RELOC.,ZERO 2-16 RLD LIST
AYE3     L     SP1,SAVSP1               FETCH POINTER TO DC BUCKET.
         TM    12(SP1),1                EXPRESSION IS RELOCATABLE
         BO    AYA5                     BRANCH TO ERROR IF BIT LENGTH
AYD4     CLI   1(SP1),I9                IS THIS AN A-TYPE CONSTANT.
         BNE   AYC4                     NO, BRANCH TO Y-TYPE LOGIC.
         CLI   14(SP1),I3                YES, LOG ERROR IF LENGTH
         BL    AYC5                     MODIFIER LESS THAN 3 BYTES.
AYD5     SR    SP2,SP2                  PREPARE ARGUMENTS FOR RLD ENTRY
         IC    SP2,14(SP1)              GET LENGTH
         BCTR  SP2,0                      MINUS ONE
         SLL   SP2,2                      AND SHIFT OVER 2 BITS FOR RLD
         L     SP1,SPEVAL+4             POINTER TO PARAMETER TABLE
         BAL   SRR,RLDRTN               MAKE RLD ENTRY
AYD6     LM    SP1,SP2,SPEVAL           RESTORE INFO FROM EEVAL
         L     SP2,0(SP2)               RELOC. VALUE TO SP2
AYC3     ST    SP2,TEMP                 ABS. OR RELOC. VALUE TO TEMP
         L     R2,SAVSP1                FETCH POINTER TO DC BUCKET.
         CLI   1(R2),I9                 IF THIS IS AN A-CON, DON'T
         BE    AYC2                      DARE FLAG IT. FLAG Y-CONS ONLY
         SLA   SP2,16                     IF LARGER THAN + OR -
         BC    14,AYC2                     HEX 7FFF.
         MVI   XY+1,TOOBIGER            GOD HELP THE MAN WHO ACCIDENT-
         BAL   SRR,ERRLOG                LY GETS AN A-CON TRUNCATED.
AYC2     L     R2,LMV                   COMPUTE KX=LMV-32
         SH    R2,XXXII
         STH   R2,KX                    STORE KX
         BM    AYE4                     PADDING NOT POSSIBLE FOR ADCONS
         BAL   FRB,KZERO                NO TRUNCATION
         B     AYK2                     BRANCH TO NEXT CONSTANT OR EXIT
AYE4     BAL   FRB,KNEG                 TRUNCATE
         B     AYK2                     BRANCH TO NEXT CONSTANT OR EXIT
AYK1     SR    R1,R1                    PLACE LMV ZERO BITS IN
         ST    R1,TEMP                   OUTPUT STREAM.
         BAL   FRB,KZERO
AYK2     CLI   0(SP1),ICOMMA            IS DELIMITER A COMMA
         BNE   AYK3                     NO, BRANCH TO EXIT
         LA    SP1,1(SP1)               YES, ADD 1 TO OPND PTR
         EX    R0,GETLMV                RESTORE LMV.
         B     AYE2                     GO TO PROCESS NEXT CONSTANT.
AYA5     MVI   XY+1,RELOCERR            RELOCATABLE ADCON SPECIFIED BY
         BAL   SRR,ERRLOG               BIT LENGTH, LOG RELOC. ERROR
         B     AYK1                     ZERO BITS TO OUTPUT.
AYC5     MVI   XY+1,RELOCERR            LMV TOO SMALL FOR RELOCATABLE
         BAL   SRR,ERRLOG               ADCON, LOG RELOC. ERROR AND
         B     AYD6                     SKIP RLD ENTRY.
AYC4     MVI   F8YDC(ACT),X'FF'         SET RELOCATABLE Y-CON IND.
         CLI   14(SP1),I2               PROCESS Y-TYPE RELOC. DC.
         BL    AYC5                      LOG AN ERROR MESSAGE AND SKIP
         B     AYD5                     RLD ENTRY IIF LMV LESS THAN 2.
AYK3     LM    SRR,SP1,SAVSRR           RESTORE REGISTERS 9 AND 10.
         BR    SRR                      EXIT AY ROUTINE****************
         EJECT
* THIS SUBROUTINE PROCESSES V AND Q TYPE ADDRESS CONSTANTS
*
VT       STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10
         LR    SP1,GRB                  SET SP1 = PTR. TO 1ST. CHAR.
VT1      ST    SP1,ERRORPTR             SAVE PTR TO NEXT CONSTANT
         BAL   GRY,EXPRES               EVALUATE EXPRESSION
         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL
         BC    8,VT2                    TO PREVENT RLD FOR INVALID QCON
         SPACE 1
* PREPARE ARGUMENTS FOR RLD ENTRY
         SPACE 1
         L     R2,SAVSP1                RESTORE PTR. TO DC BUCKET
         LR    SP1,SP2                  PTR TO VALUE TO SP1
         SR    SP2,SP2
         IC    SP2,14(R2)               GET LENGTH FROM DC BKT.
         BCTR  SP2,0                    SUBTRACT 1
         CLI   1(R2),13                 TEST FOR QCON.
         LA    R1,4                     SET FLAG = 1 = VCON
         BNE   VCONRLD                  VCON, SO EXIT
         LA    R1,8                     SET FLAG = 2 = QCON
VCONRLD  OR    SP2,R1                   COMBINE TYPE & LENGTH
         SLL   SP2,2                    POSITION RLD FLAG
         BAL   SRR,RLDRTN               MAKE RLD ENTRY
VT2      XC    TEMP(4),TEMP             SET 1ST 4 BYTES OF TEMP = 0
         BAL   FRB,KZERO                OUTPUT LMV ZERO BITS
         L     SP1,SPEVAL               RESTORE DELIMITER POINTER
         CLI   0(SP1),ICOMMA            IS DELIMITER A COMMA
         BNE   VT4                      NO, PREPARE TO EXIT
         LA    SP1,1(SP1)               YES, STEP OVER COMMA
         EX    R0,GETLMV                RESTORE LENGTH MODIFIER.
         B     VT1                       AND PROCESS NEXT CONSTANT.
VT4      LM    SRR,SP1,SAVSRR
         BR    SRR                      EXIT VT ROUTINE****************
         EJECT
*              THIS SUBROUTINE PROCESSES S TYPE ADDRESS CONSTANTS
*
*                               -SPECIFICATIONS-
*
*                   IMPLIED LENGTH (BYTES)     2
*                   ALIGNMENT              HALF WORD
*                   LENGTH MODIFIER RANGE  2 ONLY
*                   SPECIFIED BY           ONE ABSOLUTE OR RELOCATABLE
*                                          EXPRESSION, OR TWO ABSOLUTE
*                                          EXPRESSIONS
*                   # CONSTANTS PER OPND   MULTIPLE
*                   PADDING AND TRUNCATION NOT ALLOWED
*
ST       STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10.
         LR    SP1,GRB                  SET SP1 = PTR TO 1ST EXPRESSION
STD2     ST    SP1,ERRORPTR             SAVE EXPRESSION POINTER
         BAL   GRY,EXPRES               EVALUATE EXPRESSION
         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL
         BC    9,STA5                   BRANCH IF ABSOLUTE OR ERROR
         TM    ACONPT,X'20'
         BC    8,STA3                   BRANCH IF SIMPLY RELOCATABLE
         MVI   XY+1,RELOCERR            LOG RELOCATABILITY ERROR
         BAL   SRR,ERRLOG
         XC    TEMP(2),TEMP             SET 1ST 2 BYTES OF TEMP = 0.
         CLI   0(SP1),ILPARN            IS DELIMETER A LEFT PAREN
         BNE   STC4                     NO, ZERO TWO O/P BYTES NOW.
         SR    SP2,SP2                  YES, SET DISP=0, AND BRANCH TO
         B     STJ2                     PROCESS BASE-DISP. S-CON.
         SPACE 2
* PROCESS ABSOLUTE S-CON.
         SPACE 2
STA5     CLI   0(SP1),ILPARN            IF LEFT PAREN DELIMETER, ABS.
         BE    STJ2                     S-CON IS IN BASE-DISP FORM.
         SR    SP1,SP1                  IF NOT, ABS. S-CON MUST BE
         B     STB3                     DECOMPOSED.
         SPACE 2
* PROCESS SIMPLY RELOCATABLE S-CON.
         SPACE 2
STA3     CLI   0(SP1),ILPARN            IF RELOC. S-CON DELIMITED BY
         BE    STJ3                      LEFT PAREN, BRANCH.
         LA    SP1,1                    SP1=1,RELOC---SP1=0,ABSOLUTE
STB3     STM   GRC,R14,TEMP             SAVE REGISTERS
         OI    CTSCON(ACT),X'08'        INDICATE S-CON CALL TO DECOMP
         L     GRY,ERRORPTR             FETCH COLUMN PTR FOR DCMPSE.
         L     FRB,MACHOP(ACT)          PREPARE TO ENTER DECOMPOSITION
         L     SRB,F8DCMP(ACT)          ROUTINE.
         BALR  SRR,SRB                  DECOMPOSE EXPRESSION
         USING *,SRR
         LR    R1,SP2                   SAVE DECOMPOSED VALUE
         LM    GRC,R14,TEMP             RESTORE REGISTERS
         DROP  SRR
         LR    SP2,R1                   DECOMPOSED VALUE TO SP2
         TM    CTSCON(ACT),X'04'        IS ADDR ERROR INDICATED .Q
         BZ    STC2                     BRANCH IF NOT
         SR    SP2,SP2                  ZERO OUT DECOMP VALUE
         MVI   XY+1,ADDRERR             SET ERROR NUMBER
         BAL   SRR,ERRLOG               ADDRESSABILITY ERROR
STC2     NI    CTSCON(ACT),X'F3'        RESET S-CON SWITCH
STC3     STH   SP2,TEMP                 STORE IN TEMP BUFFER
STC4     BAL   FRB,KZERO                TEMP BUFFER TO O/P.
         L     SP1,SPEVAL               LOAD TEXT PTR. FROM EEVAL
STD3     CLI   0(SP1),ICOMMA            IS DELIMETER A COMMA
         BNE   STE4                     NO, PREPARE TO EXIT
         LA    SP1,1(SP1)               YES, STEP OVER COMMA, RESTORE
         EX    R0,GETLMV                 LMV AND BRANCH TO PROCESS
         B     STD2                       NEXT CONSTANT.
STE4     LM    SRR,SP1,SAVSRR           RESTORE REGISTERS 9 AND 10 AND
         BR    SRR                       EXIT S-CON ROUTINE************
         SPACE 2
* PROCESS S-CON WITH BASE-DISPLACEMENT SOURCE FORMAT.
         SPACE 2
STJ2     CL    SP2,=F'4095'             COMPARE DISPLACEMENT WITH MAX.
         BNH   STF2                     BRANCH IF OK.
STJ3     MVI   XY+1,INVDPERR            OTHERWISE, LOG INVALID DIS-
         BAL   SRR,ERRLOG                PLACEMENT ERROR AND SET
         SR    SP2,SP2                    DISPLACEMENT=0.
STF2     ST    SP2,TEMP+100             SAVE DISPLACEMENT
         L     SP1,SPEVAL               LOAD TEXT POINTER FROM EEVAL.
         LA    SP1,1(SP1)               STEP OVER LEFT PAREN DELIMETER
         ST    SP1,ERRORPTR             SAVE TEXT POINTER.
         BAL   GRY,EXPRES               EVALUATE BASE REG. EXPRESSION
         TM    ACONPT,X'30'             TEST CONDITION CODE FROM EEVAL
         BC    8,STF1                   BRANCH IF BASE REG. ABSOLUTE.
         MVI   XY+1,INVRGERR            OTHERWISE LOG INVALID REGISTER
         BAL   SRR,ERRLOG                SPECIFICATION ERROR AND SET
         XC    SPEVAL+4(4),SPEVAL+4       REGISTER = 0.
STF1     L     SP1,SPEVAL               LOAD TEXT POINTER FROM EEVAL.
         LA    SP1,1(SP1)               STEP OVER RIGHT PAREN.
         ST    SP1,SPEVAL               STORE TEXT POINTER
         L     SP2,SPEVAL+4             LOAD EVALUATED BASE REG. VALUE
         CL    SP2,=F'15'               COMPARE WITH MAXIMUM
         BNH   STB5                     BRANCH IF OK.
         MVI   XY+1,INVRGERR            OTHERWISE LOG INVALID REGISTER
         BAL   SRR,ERRLOG                SPECIFICATION ERROR
         SR    SP2,SP2                    AND SET BASE = 0.
STB5     SLL   SP2,12                   POSITION BASE AND
         O     SP2,TEMP+100             LOGICAL OR WITH DISPLACEMENT
         B     STC3                     BRANCH TO O/P VALUE.
         EJECT
* THIS SUBROUTINE PROCESSES ALL FIXED AND FLOATING POINT CONSTANTS
*
FHED     STM   SRR,SP1,SAVSRR           SAVE REGISTERS 9 AND 10
         LR    R1,GRB                   SET R1 = PTR TO 1ST CHARACTER
FHED01   ST    R1,ERRORPTR              SAVE TEXT POINTER
         STM   GRC,SRB,SRBGRY           SAVE BASE
         L     SRB,CCONV(ACT)           LOAD CONVERSION RTN. BASE REG.
         BALR  SRR,SRB                  BRANCH TO CONVERSION ROUTINE
         USING *,SRR                    USE SRR AS BASE UNTIL
         LM    GRC,SRB,SRBGRY             SRB CAN BE RESTORED
         DROP  SRR                      SRB NOW RESTORED, DROP SRR BASE
         ST    R1,ACONPT                SAVE TEXT POINTER
         TM    0(GRZ),X'FF'             ERROR FLAG SET
         BZ    FHED02                   NO
         MVC   XY+1(1),0(GRZ)           YES, MOVE ERROR FLAG, SAVE PTR.
         ST    SP2,TEMP                 TO CONVERTED VALUE, AND BRANCH
         BAL   SRR,ERRLOG               TO ERROR ROUTINE.
         L     SP2,TEMP                 RESTORE PTR. TO CONVERTED VALUE
FHED02   MVC   TEMP(16),0(SP2)          MOVE CVT'D VALUE TO TEMP
         LA    R2,128                   SET KX TO TRUNCATE CVT'D
         S     R2,LMV                   VALUE ON THE LEFT.
         LCR   R2,R2
         STH   R2,KX
         BAL   FRB,KNEG                 TRUNCATE AND OUTPUT VALUE.
         L     R1,ACONPT                RESTORE TEXT POINTER
         CLI   0(R1),ICOMMA             IS DELIMETER A COMMA
         BNE   FHED03                   NO, PREPARE TO EXIT.
         LA    R1,1(R1)                 YES, STEP OVER COMMA.
         EX    R0,GETLMV                RESTORE LMV.
         L     SP1,SAVSP1               RESTORE PTR TO DC BUCKET
         B     FHED01                   PROCESS NEXT CONSTANT.
FHED03   LM    SRR,SP1,SAVSRR           RESTORE REGISTERS 9 AND 10.
         BR    SRR                      EXIT FHED ROUTINE**************
         EJECT
*                                                                     *
***                   RLD ROUTINE                                   ***
*                                                                     *
* SP1 = POINTER TO PARAMETER TABLE CREATED BY EXPRESSION EVALUATION   *
**      WHICH CONTAINS 16 2-BYTE ENTRIES AS FOLLOWS,                 **
***         BYTES 0-3   ABSOLUTE VALUE OF RELOCATABLE EXPRESSION,   ***
****                    FULL WORD ALIGNED SIGNED INTEGER, FOLLOWED ****
*****                   BY ONE 2-BYTE ENTRY FOR EACH RELOCATABLE  *****
****                    VALUE, CONTAINING                          ****
***                         BYTE 0 = SIGN                           ***
**                          BYTE 1 = ESD ID                          **
* SP2 = 00XXLL00 WHERE XX = 00 FOR A & Y TYPE DC'S & CCW'S
*                         = 01 FOR V TYPE DC'S
**                        = 10 FOR Q TYPE DC'S
***                       = 11 FOR CXD'S                            ***
**                 AND LL = LENGTH OF CONSTANT MINUS ONE (IN BYTES)  **
*                                                                     *
RLDRTN   CLC   CESDID(1,ACT),CTNDID+1(ACT)   IS DATA IN A DSECT
         BCR   2,SRR                          YES, RETURN NOW.
         CLC   CTCMSW(1,ACT),CESDID(ACT)    IS DATA IN COMMON
         BCR   8,SRR                          YES, RETURN NOW.
         TM    SW,2                     IS PRINT SWITCH ENABLED
         BCR   1,SRR                    NO, RETURN NOW.
         STM   GRA,SP2,TEMP+100         SAVE REGISTERS 4 THRU 11
         LA    GRA,4(SP1)   ADJ PTR TO 16 PAIRS OF VALUES,MOVE TO GRA
         LA    GRB,16                   SET COUNT FOR LOOP
RLOOP    SR    GRC,GRC
         CLI   1(GRA),0                 IS THIS ITEM TO BE IGNORED
         BE    RLOOPS                     YES
         CLC   1(1,GRA),CTNDID+1(ACT)   IS ESD-ID IN A DSECT
         BH    RLDGOOF                       YES, LOG ERROR AND EXIT.
         L     SRB,CTXTIO(ACT)
         BAL   SRR,PUTRLD(SRB)          CALL PUTRLD FOR RLDPTR
         USING *,SRR
         L     SRB,TEMP+116             RESTORE DCEVAL BASE REGISTER
         DROP  SRR
ESDOK    MVC   0(1,SP1),CESDID(ACT)     SET POS.ID = CURRENT ID
ESDAOK   MVC   3(3,SP1),STLOC+1         SET RLD ADDR. = CURRENT LOC.CTR
         MVC   2(1,SP1),TEMP+131        SET FLAG IN RLD ENTRY
         CLI   0(GRA),1                  IS SIGN PLUS
         BE    SKIP2                     YES
         OI    2(SP1),2                 NO - SET MINUS INDICATOR
SKIP2    MVC   1(1,SP1),1(GRA)          SET REL ID(RLD) = REL ID(PAR)
RLOOPS   LA    GRA,2(GRA)               SET PAR PTR TO NEXT PAIR VALUES
         BCT   GRB,RLOOP                BRANCH TO PROCESS NEXT PAIR
         LR    R1,SP1                    RLD POINTER TO REG 1.
RLDEXIT  LM    GRA,SP2,TEMP+100         RESTORE REGISTERS 4 THRU 11
         BR    SRR                      EXIT RLD ROUTINE***************
RLDGOOF   MVI   XY+1,RELOCERR            LOG RELOCATABILITY ERROR, SET
         BAL   SRR,ERRLOG                 R1 TO ZERO, AND EXIT.
         LA    R1,0                      R1=0 MEANS NO RLD ENTRY.
         B     RLDEXIT
         EJECT
* THIS IS A COMMON LINKAGE TO THE ERROR ROUTINE, LOGERR.
         SPACE 2
ERRLOG   STM   SRB,SP1,SDW
         L     SP1,ERRORPTR             LOAD POINTER TO ERROR
         L     SRB,CLOGER(ACT)          LOAD LOGERR BASE REGISTER
         BALR  SRR,SRB
XY       DC    AL2(0)                   ARGUMENT CONTAINING ERROR NO.
         USING XY,SRR
         LM    SRB,SP1,SDW
         DROP  SRR
         BR    SRR                      RETURN TO LOGERR USER.
         SPACE 2
* THIS IS A COMMON LINKAGE TO THE EXPRESSION EVALUATION ROUTINE, EEVAL.
* CURRENT ESD-ID AND LITERAL ADJUSTMENT VALUE ARE ADJUSTED FOR LITERAL
* DC'S CONTAINING REFERENCE TO THE LOCATION COUNTER.
         SPACE 2
EXPRES   ST    SRB,SRBGRY               SAVE REGISTERS
         STM   GRX,GRY,TEMP
         TM        BYTEX,X'FF'         WHAT TYPE OPERATOR
         BZ        NOLITDC             DS STATEMENT
         L         GRD,CTXABP(0,ACT)   GET POINTER TO APPENDED FLD
         BM        LITDC               LITERAL DC
*        A DC STATEMENT... CHANGE TXLOC SO EXPRESSION EVALUATION
*        WILL USE CORRECT VALUE FOR REFERENCES TO THE LOCATION
*        COUNTER WHEN EVALUATING ADCONS.
         L         GRD,STLOC           GET ADJUSTED VALUE OF *
         S         GRD,F8CADJ(0,ACT)   REDUCE SO IT IS NOT ADJUST
         ST        GRD,ASTERISK        SAVE IT SO CAN MOVE IN
         L         GRD,CTXABP(0,ACT)   GET POINTER TO TXLOC
         MVC       0(3,GRD),ASTERISK+1 PUT IN CORRECT TXLOC
         B         NOLITDC             CONTINUE
*
LITDC    CLI       3(GRD),0            DOES LIT HAVE AN *
         BE    NOLITDC                  NO, BRANCH.
         MVC   CADJSAV(4),F8CADJ(ACT)     SAVE CUR. LIT. ADJ. VAL.
         MVC   F8CADJ(4,ACT),CTZERO(ACT)  SET IT TO ZERO.
         MVC   ESDIDSAV(1),CESDID(ACT)    SAVE CURRENT ESD-ID.
         MVC   CESDID(1,ACT),3(GRD)     SET CESDID = ESDID OF LITERAL
         L     R2,CADJBS(ACT)           SET CURRENT ADJUSTMENT VALUE
MCKAY    C     R2,CTADJEND(0,ACT)        EQUAL ADJUSTMENT VALUE FOR
         BNL   NOLITDC                    ASTERISK'S ESD.
         CLC   0(1,R2),CESDID(ACT)      IS THIS THE RIGHT ESD
         BE    MCKAYY                   YES, CONTINUE
         LA    R2,4(R2)                 NO, LOOK AT NEXT ONE
         B     MCKAY                    BY LOOPING
MCKAYY   MVC   F8CADJ+1(3,ACT),1(R2)    MOVE IN ESD BASE
NOLITDC  L     SRB,CEEVAL(ACT)          LOAD EEVAL BASE REGISTER AND
         BALR  SRR,SRB                  BRANCH TO EVALUATE EXPRESSION.
         USING *,SRR                    USE AS TEMP. BASE
         STM   SP1,SP2,SPEVAL           SAVE INFO FROM EEVAL.
         L     SRB,SRBGRY               RESTORE BASE
         LM    GRX,GRY,TEMP             RESTORE REGISTER
         DROP  SRR                      DROP TEMP. BASE, SRB RESTORED
         BALR  R1,R0                    SAVE CONDITION CODE FROM
         ST    R1,ACONPT                 EEVAL.
         TM    BYTEX,X'FF'              IS THIS A LITERAL DC.
         BCR   11,GRY                   NO, RETURN NOW.
         CLI   3(GRD),0                 YES,DOES LIT. HAVE AN ASTERISK
         BCR   8,GRY                    NO, RETURN NOW.
         MVC   CESDID(1,ACT),ESDIDSAV   YES, RESTORE CURRENT ESD-ID
         MVC   F8CADJ(4,ACT),CADJSAV    AND ADJUSTMENT VALUE.
         BR    GRY                      RETURN TO USER.
         EJECT
DCBRANCH DC    AL2(CT-CT)               CHARACTER DC.
         DC    AL2(XT-CT)               HEXADECIMAL DC.
         DC    AL2(BT-CT)                BINARY DC.
         DC    AL2(PZ-CT)                PACKED DC.
         DC    AL2(PZ-CT)               ZONED DC.
         DC    AL2(FHED-CT)             DBL. PRECISION FLT. PT.
         DC    AL2(FHED-CT)             SNG. PRECISION FLT. PT.
         DC    AL2(FHED-CT)             FULL WORD DC.
         DC    AL2(FHED-CT)             HALF WORD DC.
         DC    AL2(AY-CT)               A-CON DC.
         DC    AL2(AY-CT)               Y-CON DC.
         DC    AL2(VT-CT)               V-CON DC.
         DC    AL2(ST-CT)               S-CON DC.
         DC    AL2(VT-CT)               Q-CON DC.
         DC    AL2(FHED-CT)             EXTENDED FLT.PT L-CON
DUP      DC    F'0'           DUPLICATION FACTOR
NN       DC    F'0'                     NUMBER OF CONSTANTS
LMV      DC    2F'0'                    LENGTH IN BITS
ACONPT   DC    F'0'                     CONDITION CODE RETURNED - EVAL
STLOC    DC    F'0'                     LOCATION COUNTER FOR CCW RLD
POINT    DS    F                        PRESENT PNTER TO START OF OPRND
TPOINT   DC    F'0'                     TEMPARY POINTER SAVE AREA
ERRORPTR DC    F'0'                     POINTER TO ERRONEOUS EXPRESS.
ASTERISK DC    F'0'                     USED FOR INCREMENTING TXLOC.
CADJSAV  DS    F                        SAVE AREA FOR F8CADJ(ACT)
TEMP     DS    256C                     TEMPARY AREA - RLD TABLE
ADTEMP   DC    A(TEMP)                  ADDRESS OF TEMPARY AREA
MASK3    DC    F'7'                     MASK WITH 3 LOW ORDER BITS ON
TSBSRR   DS    F                        SUB1 AND SUB2 SAVE AREA FOR SRR
SDW      DS    2F                       SAVE AREA FOR ERROR LOG
FULL     DS    F                        FOR FULL WORD ALIGNMENT
SAV2     DS    2F                       RNEG REGISTER SAVE AREA
SRBGRY   DS    8F                       SAVE AREA FOR SRB THROUGH GRY
SAVSRR   DS    F                        SAVE AREA FOR RETURN
SAVSP1   DS    F                        SAVE AREA FOR POINTER
SAV14    DS    F                        SAVE AREA FOR REGISTER 14
LAST     DC    F'0'                     LENGTH FOR ZONED DC
SPEVAL   DS    2F                       RESULTS FROM EVAL
SAVWBP   DS    F                        SYMBOL BUCKET PTR. SAVE AREA
KX       DS    H                        LENGTH - 8 TIMES TOTAL LENGTH
TSHIFT   DC    H'0'                     NO. OF POSITIONS TO SHIFT
XXXII    DC    H'32'                    CONSTANT OF 32
EIGHT    DC    H'8'                     CONSTANT OF 8
RR       DC    H'0'                     BIT POSITION FOR NEXT BITS
BIT      DS    H                        BIT POSITION COUNTER
BYTE     DS    H                        BYTE POSITION COUNTER
SW       DC    X'00'                    GENERAL SWITCH
*                                            01=FIRST OPERAND
*                                            02=DONT PRINT
*                                            08=NOT LAST CONSTANT
*                                            10=ZERO DUP FACTOR
CHTEMP   DS    CL3                      PACKING SWITCH
HOLDLCTR DS    CL3                      ALIGNED LOCATION COUNTER
BYTEX    DS    C                        00=DS, FF= DC, MIXED= LITERAL
ESDIDSAV DS    C                        SAVE AREA FOR CESDID(ACT)
         LTORG
         END   ASMGF8D
./ ADD NAME=ASMGF8I
F8I      TITLE     'ASMG F8  INITIALIZATION AND I/O'
         ISEQ      73,78
*./      DELETE    SEQ1=00040020,SEQ2=00120020
         COPY      ASMGSET
ASMGF8I  START
TEXTIO   EQU       ASMGF8I
         PRINT NOGEN
         FDIMEN
         PRINT GEN
*TITLE- 'ASMGF8I '..PHASE F8 INITIALIZATION AND I/O ROUTINES          *
*FUNCTION/OPERATION                                                   *
*   PERFORMS INITIALIZATION FOR PHASE F8                              *
*   CONTAINS I/O ROUTINES FOR PHASE F8                                *
*ENTRY POINTS-                                                        *
*  ASMGF8....PERFORMS INITIALIZATION FUNCTIONS FOR PHASE F8           *
*  ASMGF8I...PROVIDES ACCESS TO THE FOLLOWING SUBROUTINES             *
*       (ENTRY) (NAME) (FUNCTION)                                     *
*        GTM   GETXTM   GET TEXT AND MOVE FOR F8                      *
*        GTP   GETP    POINT ROUTINE FOR INPUT BUFFER                 *
*        GETLA GETLAT   GET LITERAL ADJUSTMENT TABLE                  *
*        PUTRL PUTRLT   PUT RELOCATION TABLE                          *
*        PUTER PUTERR   PUT LOGICAL ERROR RECORD                      *
*        SYSL  SYSLIST  SYSTEM LIST FOR F8                            *
*        SYSO  SYSOUT   SYSTEM OUTPUT OF SYSPUNCH AND SYSGO           *
*        PHC   PHCLS    PHASE F8 CLOSE                                *
*    CALLING SEQUENCE FOR ASMGF8                                      *
*        XCTL  ,DE=(SRR)     I.E. EP=ASMGF8     CALL PHASE F8         *
*    CALLING SEQUENCE FOR ASMGF8I ROUTINES                            *
*        L     SRB,CTXIO(ACT)           SET UP BASE                   *
*        BAL   SRR,NAME(SRB)            CALL ROUTINE 'NAME'           *
*                                                                     *
*              CTXIO(ACT) CONTAINS THE ADDRESS OF ASMGF8I.'NAME' IS   *
*              EQUATED (IN FDIMEN MACRO) TO A DISPLACEMENT FROM IEUF8I*
*              AT THIS DISPLACEMENT IS A BRANCH INSTRUCTION TO THE    *
*              PARTICULAR ROUTINE IMPLIED BY THE 'NAME                *
*INPUT/OUTPUT PARAMETERS- SEE INDIVIDUAL ROUTINES                     *
*EXTERNAL ROUTINES-                                                   *
*   THE ADDRESSES OF THE FOLLOWING ROUTINES ARE PLACED IN THE         *
*   ASSEMBLER CONTROL TABLE (ACT)                                     *
*        (ROUTINE)   (DECK)         (ACT REFERENCE)                   *
*         ASMGF8D    ASMGF8D         CDVAL                            *
*         ASMGF8A    ASMGF8A         ASOPRO                           *
*         ASMGF8M    ASMGF8M         MACHOP                           *
*         ASMGF8P    ASMGF8P         PRNT                             *
*         TEXTIO     ASMGF8I         CTXTIO                           *
*         ASMGF8S    ASMGF8S         CSTGET                           *
*         ASMGF8V    ASMGF8V         CEEVAL                           *
*         ASMGF8L    ASMGF8L         CLOGER                           *
*         SRLINE     ASMGF8C         F8LIGN                           *
*         DCCOMP     ASMGF8D         F8DCMP                           *
*         F8AREX     ASMGF8M         F8EXPX                           *
*         SECSET     ASMGF8A         F8STSC                           *
*         ASMGF8N    ASMGF8N         CCONV                            *
*         COMMENT    ASMGF8P         CTCOMT                           *
*         BLDIMG     ASMGF8P         CTBLDG                           *
*EXITS-                                                               *
*  ASMGF8...BRANCHES TO MAIN LINE CONTROL ASMGF8C                     *
*   PGCLS...XCTL  ,DE=(SRR)    I.E. EP=ASMGFPP  GO TO POST PROCESSOR  *
*   ALL OTHERS... RETURN CONTROL TO CALLER                            *
*TABLES/WORKAREAS-                                                    *
*        ASSEMBLER CONTROL TABLE  (SEE ASMGRTA)                       *
*        RLDTAB,ERRTAB... I/O DEVICES TABLE AREA                      *
*        F8CT2...FUNCTIONAL ROUTINE BASE/ENTRY ADDRESSES              *
*        F8CT3...COMMON SUBROUTINE BASE/ENTRY ADDRESSES               *
*                                                                     *
         EJECT
         ENTRY     ASMGF8              MAIN ENTRY TO F8
         EXTRN ASMGF8C                  MAIN LINE CONTROL
         EXTRN ASMGF8M                  MACHINE OP-CODE
         EXTRN ASMGF8A                  ASSEMBLER OP-CODE
         EXTRN ASMGF8P                  PRINT
         EXTRN ASMGF8D                  DC EVALUATION
         EXTRN ASMGF8S                  SYMBOL TABLE
         EXTRN ASMGF8V                  EXPRESSION EVALUATION
         EXTRN ASMGF8L                  LOG ERROR
         EXTRN SRLINE                   ALIGNMENT SUBROUTINE
         EXTRN DCCOMP                   DECOMPOSITION SUBROUTINE
         EXTRN F8AREX                   ABSOLUTE AND RELOCATABLE EVAL
         EXTRN SECSET                   SET SECTION NUMBER ROUTINE
         EXTRN ASMGF8N                  FLOATING POINT DECIMAL CONVERT
         EXTRN COMMENT                  PRINT COMMENTS
         EXTRN BLDIMG                   BUILD PRINT IMAGE
*./      DELETE    SEQ1=01720020,SEQ2=01820020
*
L3C      EQU   3                        INCREMENT FOR GRA
L4A      EQU   4                        OFFSET IN AN AREA
L2       EQU   2                        NUMBER OF BYTES TO MOVE
L3D      EQU   3                        OFFSET IN AN AREA
L2A      EQU   2                        NUMBER OF BYTES TO MOVE
MKH      EQU   X'0F'                    MNOTE MASK
MKI      EQU   X'80'                    LAST RECORD MASK
L1       EQU   1                        OFFSET IN AN AREA
L4B      EQU   4                        NUMBER OF BYTES TO MOVE
L2B      EQU   2                        NUMBER OF BYTES TO MOVE
L1A      EQU   1                        INCREMENT FOR GR1
L3E      EQU   3                        INCREMENT FOR GR1
INCR     EQU   516                      INCREMENT FOR GR1
L2C      EQU   2                        NUMBER OF BYTES TO MOVE
L8B      EQU   8                        RECORD I.D.
L0       EQU   0                        RECORD ERROR I.D.
         EJECT
         USING *,SRB
         DC    H'0'                     BASE REFERENCE
         B     GTP                      GET POINT SUBROUTINE
         B     GTM                      GET TEXT AND MOVE SUBROUTINE
         B     PUTX                     PUT SOURCE IN TERM BUFFER
         DS    2H                       DUMMY DISPLACEMENT FOR F/8
         DS    2H                       DUMMY DISPLACEMENT
         BC    15,PHC                   PHASE FINALIZATION
         DS    2H                       DUMMY DISPLACEMENT
         DS    2H                       DUMMY DISPLACEMENT
         DS    2H                       DUMMY DISPLACEMENT
         DS    2H                       DUMMY DISPLACEMENT
         B     PUTRL                    PUT RLD
         B     GETLA                    GET LAT
         B     PUTER                    PUT ERROR
         B     SYSL                     SYSLIST D54
         B     SYSO                     SYSOUT  D58
         EJECT
*  GETXTM-GET TEXT AND MOVE FOR F/8
*        SUBROUTINE RETRIEVES LOGICAL RECORD FROM INPUT
*         TEXT STREAM AND STORES IN AREA SPECIFIED BY USER.
*        ENTER WITH FBA OF WORK AREA IN SP1
*        EXIT WITH SP1 ZERO IF EOF READ
         SPACE 2
GTM      STM       GRA,GRC,SAVE        SAVE REGISTERS
         L         GRA,IBUFCPT         POINTER
         BAL   GRZ,GTP                  GET POINT IN INPUT BUFFER
         BC    8,GTMX+2                 EOF READ RETURN
         MVC   RLI(2),0(GRA)            MOVE TO HALFWORD BOUNDARY
         LR    GR2,SP1
         LH    GRB,RLI                  FIRST SEG RLI
         LR    GR1,GRA                  PTR
         BAL   GRC,MOVE                 MOVE TO (GR2)
GTMX     LTR   SP1,SP1                  SET EOF CC
         ST        GRA,IBUFCPT
         LM        GRA,GRC,SAVE         RESTORE REGISTERS
         BR    SRR                      EXIT
         EJECT
*  GETPT-GET POINT FOR F/8
*        SUBROUTINE POINTS TO NEXT LOGICAL RECORD OF THE TEXT
*                  STREAM IN THE INPUT BUFFER.
GTP      CLI   RD1,1                    NO DATA SW SET
         BE    GT5                      IF YES, GO TO GT5
         BH    GTA                      IF SET TO NEED-NEW-DATA TO GTA
         MVC   RLI(2),0(GRA)            MOVE TO HALFWORD BOUND
         AH    GRA,RLI
GT1      TM    2(GRA),X'80'             LAST RECORD BIT SET
         BZ    GTX                      IF NO, TO GTX
         MVI   RD1,2                    SET FOR NEED-NEW-DATA ON NXT E
GTX      LTR   GRA,GRA                  SET EOF CC
         BR    GRZ                      EXIT
*./      DELETE    SEQ1=02880020,SEQ2=02940020
GT5      SR    GRA,GRA        EOF NO DATA EXIT
         BR    GRZ                      EXIT
GTA      MVI   RD1,0                    CLEAR NEED DATA SW
         BAL   GRC,TEXTIN               READ TEXT
         L     GRA,RDADD               RESET POINTER
         CLC   0(4,GRA),EOF             HAS EOF BEEN READ
         BE    GT10                     IF YES, GO TO GT10
         B     GT1                      RETURN FOR NXPT
*./      DELETE    SEQ1=03120020,SEQ2=03520020
GT10     MVI   RD1,1                    SET NO-DATA ENTRANCE SWITCH
         B     GT5                      EXIT
*./      DELETE    SEQ1=03580020,SEQ2=03620020
         EJECT
* SUBROUTINE TO MOVE ANY SIZE BLOCK FROM (GR1) TO (GR2)
MOVE     S     GRB,=F'256'              NUMBER OF BYTES GT 256 .Q
         BP    M1                       IF YES, GO TO M1
         LA    GRB,255(,GRB)            DESCREASE LITERAL COUNT BY 1
         EX    GRB,M2                   EXECUTE MVC
         LA    GRB,1(,GRB)              INC COUNT TO LITERAL COUNT
         AR    GR1,GRB                  ADVANCE SOURCE POINTER
         AR    GR2,GRB                  ADVANCE DESTINATION POINTER
         BR    GRC                      RETURN TO CALLER
M1       MVC   0(256,GR2),0(GR1)        MOVE 256 BYTES
         LA    GR1,256(,GR1)            ADVANCE SOURCE PTR BY 256
         LA    GR2,256(,GR2)            ADVANCE DESTINATION PTR BY 256
         B     MOVE                     RETURN TO MOVE
M2       MVC   0(*-*,GR2),0(GR1)        EXECUTED MOVE
         EJECT
* GET LITERAL ADJUSTMENT TABLE-PHASE F/8
GETLA    L     SP1,LABPTR               LAT LOGICAL REC PTR
         L         SP1,16(0,SP1)       POINT AT NEXT LAT ENTRY
         LTR       SP1,SP1
         BCR       8,SRR                EOF EXIT
         ST    SP1,LABPTR
         BR    SRR                      EXIT
         EJECT
* PUT RELOCATION DICTIONARY-PHASE F/8
PUTRL    L     SP1,RLDPTR               RLD LOGICAL RECORD POINTER
         CL    SP1,RLDLBA               PTR EXCEED BUFFER
         BL    PUTRL2                   NO TO PUTRL1
         LA    GR1,RLDTAB               RLD IO PARAMETER TABLE
         BAL   SP2,WROF                 WRITE OVERFLOW FILE
         L     SP1,RLDTAB+4             BUFFER PTR
         LA    SP1,1(SP1)               FIRST LOGICAL RECORD
PUTRL2   LR    GR1,SP1
         LA    GR1,6(GR1)               ADVANCE TO NEXT LOGICAL REC
         ST    GR1,RLDPTR
         BR    SRR                      EXIT
RLDTAB   DC    F'0'                     FIRST BLOCK PTR
         DC    A(RLDBUF)                BUFFER ADDRESS
         DC    F'121'                   LENGTH
         DC    H'0'                     BLOCK COUNT
         DC    X'1'                     FIRST TIME SWITCH
         EJECT
* PUTX IS USED IF TERM OPTION IS SPECIFIED
* TERM BUFFER IS PLACED IN CORE
* CONTROL IS GIVEN TO WROF WHEN THE BUFFER IS FILLED (6 RECORDS)
* AND NO ERROR RECORD FOUND
* WHEN ERROR RECORD FOUND, CONTROL GOES FROM F8P
* TO WROF VIA PUTER
* SP1 CONTAINS POINTER TO SOURCE RECORD
* SP2 CONTAINS FLAGA BYTE VALUE
*
GEN      EQU   X'30'                    POSITION IN FLAGA
CONT     EQU   X'02'                    POSITION IN FLAGA
TERM     EQU   X'08'                    POSITION IN L1PARBYT2
SRCLN    EQU   86                       STMT(5)+GEN/BLANK(1)+SOURCE(80)
PUTX     TM    CTTRMI(ACT),TERM         TERM OPTION REQUIRED
         BCR   8,SRR                    NO, THEN RETURN
         STM   GRA,GRC,SAVE             YES, SOURCE TXT IN BUFFER
         STH   SP2,FLAGA                TYPE OF RECORD INDICATOR
         LM    GRA,GRC,TRPARM           GET FORMER INFORMATION
         TM    FLAGA,CONT               IS CONTINUATION BIT ON .Q
         BO    PUTX5                    YES, CHECK IF ENOUGH ROOM
         TM    TSTSW,NOPRT              IS BUFFER WRITTEN .Q
         BZ    PUTX2                    YES, ERROR HAS OCCURRED
         TM    TSTSW,NSTMT              ERRORS IN PRECEEDING STMT .Q
         BO    PUTX2                    NO, IGNORE STMT (1 BFR)
         TM    TSTSW,NALL               LAST BUFFER WRITTEN .Q
         BZ    PUTX1                    NO, WRITE BUFFER NOW
         OI    TSTSW,POINT              YES, SCRATCH WRITTEN STMT
         B     PUTX2                    CONTINUE
*
PUTX1    BAL   GR2,PUTX7                WRITE BUFFER
PUTX2    OI    TSTSW,NSTMT+NALL         INDICATE NEW STMT
         NI    TSTSW,ALL-CONTB          RESET SWITCHES
PUTX3    L     GRA,TRMTAB               SET UP BUFFER BASES
         LA    GRA,L3C(,GRA)            BUMP POINTER
         SR    GRB,GRB                  LENGTH OF ALREADY MOVED SOURCE
         MVC   L4A(L2,GRC),CTSEQ8+2(ACT)  PICK UP STATEMENT NUMBER
         XC    0(L2,GRC),0(GRC)         SET ERLI TO ZERO
         TM    TSTSW,CONTB              CONT IF MORE THAN 6 RECORDS
         BO    PUTX4                    YES, FILL FROM BEGINNING
         TM    FLAGA,GEN                IS SOURCE GENERATED .Q
         BZ    PUTX9                    NO, IS IT MNOTE
PUTX3A   TM    TSTSW,MSAVE+CBGEN        RESTORE FIRST SRC RECORD .Q
         BZ    PUTX3B                   NO, NOT NECESSARY
         MVC   0(SRCLN,GRA),TEMPBUF     YES, RESTORE IT FROM TEMPBUF
PUTX3B   LA    GRA,SRCLN(,GRA)          GEN SOURCE AFTER FIRST
*                                       MACRO INSTRUCTION CARD
         LA    GRB,SRCLN                TRLI WILL COVER 1ST CARD
PUTX4    MVC   0(SRCLN,GRA),0(SP1)      MOVE SOURCE TO BUFFER
         LA    GRA,SRCLN(,GRA)          NEXT AVAILABLE LOCATION
         LA    GRB,SRCLN(,GRB)          TRLI
         OI    TSTSW,NOPRT              YES, INDICATE THIS
         STM   GRA,GRB,TRPARM           POINTERS OF TERM BUFFER
         LM    GRA,GRC,SAVE             RESTORE FORMER REGISTERS
         BR    SRR                      EXIT
         SPACE 1
PUTX5    CR    GRC,GRA                  BUFFER FILLED .Q
         BE    PUTX6                    YES, CHECK IF BUFFER WAS PRTD
         TM    TSTSW,NOPRT              BUFFER WRITTEN .Q
         BO    PUTX4                    NO, THEN MOVE RECORD
         B     PUTX8                    YES, THEN NEW BUFFER
PUTX6    TM    TSTSW,NOPRT              BUFFER WRITTEN .Q
         BZ    PUTX8                    YES, INDICATE CONTINUE BUFFER
         BAL   GR2,PUTX7                WRITE BUFFER
PUTX8    OI    TSTSW,CONTB              INDICATE CONTINUED BUFFER
         TM    TSTSW,NSTMT              IS IT THE FIRST BUFFER .Q
         BZ    PUTX3                    NO, MOVE SOURCE TO BEG OF BFR
         NI    TSTSW,ALL-NSTMT          NOW FIRST CONTINUED BUFFER
         TM    FLAGA,GEN                IS STMT GENERATED .Q
         BZ    PUTX8A                   NO
         OI    TSTSW,CBGEN              YES, SET GEN CONT BUFFER
         B     PUTX3                    AND MOVE SOURCE TO BEGINNING
PUTX8A   OI    TSTSW,MSAVE              FIRST SOURCE RCD IS SAVED
         L     GRA,TRMTAB               BUFFER AREA
         MVC   TEMPBUF(SRCLN),L3D(GRA)  SAVE SOURCE RECORD
         B     PUTX3                    START TO FILL CONTINUE BUFFER
         SPACE 1
PUTX7    L     GR1,TRMTAB               TERM BUFFER ADDRESS
         MVC   1(L2A,GR1),TRPARM+6      TRLI
         LA    GR1,ERRTAB               NO ERROR RECORD
         LR    SP2,GR2                  RETURN TO GR2
         B     WROF                     WRITE BUFFER
         SPACE 1
PUTX9    TM    REPSW(ACT),MKH           IS IT A MNOTE .Q
         BO    PUTX3A                   YES, TREAT IT AS GENERATED
         NI    TSTSW,ALL-MSAVE-CBGEN    RESET INDICATION OF LONG STMTS
         B     PUTX4                    NO, THEN MOVE SOURCE
         SPACE 1
TRPARM   DC    A(0)                     NEXT AVAILABLE LOCATION
         DC    A(0)                     TRLI
         DC    A(0)                     AVAILABLE BYTES
TRMTAB   DC    A(0)                     BUFFER ADDRESS
         EJECT
* PUT ERROR LOGICAL RECORD
* ENTER WITH FBA OF ERROR RECORD IN SP1
PUTER    STM   GRA,GRC,SAVE             PUT ERROR RECORD
         LM    GRA,GRC,ERPARM           ERROR PTR LIST
         MVC   RLI(2),0(SP1)            RLI OF ERROR RECORD
         LH    GR1,RLI
PUTE     CR    GR1,GRC                  DOES IT FIT
         BNH   PUTE1                    YES TO PUTE1
PUTE0    OI    2(GRB),MKI               SET LAST RECORD BIT OF PREVIOUS
         NI    TSTSW,ALL-NALL           ERROR FOUND IN THIS STMT
         LA    GR1,ERRTAB               ERROR IO PARAM TABLE
         BAL   SP2,WROF                 WRITE OVERFLOW FILE
         LH    GRC,EBUFLN               AVAILABLE BUFFER LENGTH
         BCTR  GRC,0                    DECREMENT BY 1
         TM    CTTRMI(ACT),TERM         IS TERM SPECIFIED .Q
         BO    PUTE3                    YES, RETURN AFTER 1 ERR RECORD
         L     GRA,ERRTAB+4             BUFFER ADDRESS
         LA    GRA,1(GRA)               FIRST LOG REC PTR
         LH    GR1,RLI                  ERR RLI
PUTE1    SR    GRC,GR1                  DEC AVAILABLE BYTE COUNT
         BCTR  GR1,0
         EX    GR1,PUTE2                EXECUTE MOVE OF ERROR RECORD
         NI    2(GRA),255-X'80'         RESET SPURIOUS LAST RECORD BIT
         LR    GRB,GRA                  ERR REC TO LAST REC PTR
         TM    CTTRMI(ACT),TERM         TERM OPTION .Q
         BO    PUTE4                    YES, PUT SOURCE/ERROR RECORD
         AR    GRA,GR1                  UPDATE AVAILABLE LOC
         LA    GRA,1(GRA)
PUTE3    STM   GRA,GRC,ERPARM           SAVE PARAM
         LM    GRA,GRC,SAVE             RESTORE
         BR    SRR                      EXIT
PUTE4    L     GR2,TRMTAB               BUFFER ADDRESS
         MVC   1(L2A,GR2),TRPARM+6      TRLI TO TERM BUFFER
         B     PUTE0                    EXIT
PUTE2    MVC   0(0,GRA),0(SP1)          MOVE C FROM SP1 TO GRA,GR1 BYTE
ERPARM   DC    A(ERRBUF+1)              AVAILABLE LOC
         DC    A(0)                     LAST REC PTR
         DC    A(L'ERRBUF-1)            AVAILABLE BYTES
ERRTAB   DC    A(0)                     FIRST BLOCK PTR
         DC    A(ERRBUF)                BUFFER ADDRESS
* IF TERM OPTION, ADDRESS OF TERM BUFFER IN CORE
         DC    A(L'ERRBUF)              LENGTH
* IF TERM OPTION  DC  AL(L'TRRBUF)      TERM BUFFER
         DC    H'0'                     BLOCK COUNT
         DC    X'1'                     FIRST TIME SW
         EJECT
* SYSTEM LIST SUBROUTINE G ASSEMBLER
SYSL     TM    CTLSTI(ACT),X'10'        BYPASS IF NOLIST
         BCR   8,SRR                    NO PRINT, EXIT
         STM   GRZ,GR1,IOSAVE           SAVE 13-01
         LA    GRZ,IOSAVE+20            O/S SAVE AREA
         L     GR1,LSTDCB(,ACT)         GET SYSPRINT DCB ADDRESS
         PUT   (1),(SP1)                PUT OUT RECORD
         LM    GRZ,GR1,IOSAVE           RESTORE 13-01
         BR    SRR                      AND RETURN
*./      DELETE    SEQ1=05360020,SEQ2=06060020
         EJECT
* SYSTEM OUTPUT SUBROUTINE G ASSEMBLER
SYSO     LA    SP1,1(SP1)               BYPASS CTL CHAR.
         STM   13,1,IOSAVE              SAVE REGISTERS
         LA    13,IOSAVE+20             SET UP SAVE AREA FOR OS/360
         TM    CTPCHI(ACT),X'80'        PUNCH OPTION BIT
         BZ    PCHI                     NO PUNCH, SKIP PUNCH PART
         L     1,PCHDCB(ACT)
         PUT   (1),(SP1)                OUTPUT TO SYSPUNCH
PCHI     TM    CTCGOI(ACT),X'40'        WAS NOLOAD OPTION SPECIFIED .Q
         BZ    PCHX                     IF NOLOAD SKIP SYSLIN
         L     1,GODCB(,ACT)            GET SYSLIN DCB ADDRESS
         PUT   (1),(SP1)                OUTPUT TO SYSLIN
PCHX     BC        *-*+15,PCHX1        EXECUTE OPTION SWITCH
         ST        SP1,PCHAD           PUT DATA ADDRESS IN WRITE CALL
         L         GR1,BUFFPT(0,ACT)   WRITE CARD ON SYSUT2
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(8,4)
PCHAD    DS        F
         DC        A(80)
         L         GR1,BUFFPT(0,ACT)             CHECK IT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,4)
PCHX1    LM    13,1,IOSAVE              RESTORE
         BR    SRR                      RETURN
         EJECT
* PHCLS-PHASE F/8 CLOSE
PHC      L     SP1,CTLDCP(ACT)          PCH BUFFER PTR
         LTR   SP1,SP1                  SUPPRESS PUNCH OF EMPTY BUFFER.
         BZ    *+12                     IF EMPTY, SKIP
         L     SRB,CTXTIO(ACT)
         BAL   SRR,SYSOUT(SRB)          PUNCH CARD
         LH    1,CCRDCT(ACT)            CONVERT CARD SEQ. NO. BACK FROM
         CVD   1,DWORD                  HALF-WORD BINARY TO FOUR
         UNPK  CCRDCT(4,ACT),DWORD      ZONED DIGITS.
         OI    CCRDCT+3(ACT),C'0'
         CLI   RLDTAB+14,0        CHECK IF ANY RLD ENTRIES EXIST
         BE    *+16               (IE. BUFFER NOT EMPTY
         LA    SP1,RLDBUF+1       OR 'FIRST TIME SWITCH' RESET)
         CL    SP1,RLDPTR
         BE    PHC3                     NO RLD ENTRIES
         BAL   SRR,PUTRL                PUT RLD
         MVC   0(4,SP1),EOF             EMBED EOF LABEL
         LA    GR1,RLDTAB               RLD IO PARAMETER TABLE
         BAL   SP2,WROF                 WRITE OVERFLOW FILE
PHC3     L     GR1,ERPARM+4
         LTR   GR1,GR1                  ERROR RECORD ENTRIES
         BZ    PHC4                     NO TO PHC4
         TM    CTTRMI(ACT),TERM         IS TERM OPTION REQ .Q
         BZ    PHC3A                    NO, CONTINUE
         TM    TSTSW,NOPRT+CONTB        IS LAST BUFFER WRITTEN .Q
         BNO   PHC33                    YES
         TM    TSTSW,NALL               LAST LONG STMT ERROR FREE .Q
         BZ    PHC32                    NO, THEN WRITE LAST BUFFER
         OI    TSTSW,POINT              SCRATCH LAST STATEMENT
         B     PHC33
PHC32    L     GRC,TRPARM+8             PT TO ERROR RECORD IF TERM
         BAL   GR2,PUTX7                WRITE TERM BUFFER
PHC33    L     GRA,TRMTAB               GET TERM BUFFER ADDRESS
         MVC   L1(L4B,GRA),EOF          SET END OF DATA SET
         B     PHC3B                    PUT END OF DATA SET
PHC3A    LM    GRA,GRC,ERPARM           ERROR BUFFER POINTERS
         LA    GR1,4                    RLI OF 4
         STH   GR1,RLI
         LA    SP1,EOF                  EOF INDICATOR
         BAL   SRR,PUTE                 EMBED EOF
PHC3B    LA    GR1,ERRTAB               ERR IO PARAMETER TABLE
         BAL   SP2,WROF                 WRITE OVERFLOW FILE
PHC4A    EQU   *
         MVC   CTCRLD(L2B,ACT),RLDTAB+12  RLD BLOCK COUNT
         MVC   CTCERR(2,ACT),ERRTAB+12  ERR BLOCK COUNT
         MVC   CTRRLD(4,ACT),RLDTAB     RLD FIRST BLK PTR
         MVC   CTRERR(4,ACT),ERRTAB     ERR FIRST BLK PTR
PHC6     EQU       *
         L         GR1,BUFFPT(0,ACT)    REWIND SYSUT1
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(24,0,1)
         L         GR1,BUFFPT(0,ACT)    REWIND SYSUT3
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(24,8,1)
         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASM
         LA    SRR,L1BLDL(,SRR)         POINT TO FPP IN BLDL TABLE
         XCTL  ,DE=(SRR)                GO TO POST PROCESSOR ASMGFPP
PHC4     STH   GR1,ERRTAB+12            MAKE SURE BLOCK COUNT
         B     PHC4A                    IS ZERO (REQ IF TERM)
         EJECT
* TEXT I/O CALLING SEQUENCE
*./      DELETE    SEQ1=07540020,SEQ2=07540020
*       BAL  GRC,TEXTIN
TEXTIN   STM   GR0,GR1,IOSAVE           SAVE REGISTERS
*./      DELETE    SEQ1=07600020,SEQ2=07600020
         L         GR1,BUFFPT(0,ACT)    READ TEXT INPUT FILE
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(4,8)
RDADD    DS        F
*./      DELETE    SEQ1=07720020,SEQ2=07800020
         L         GR1,BUFFPT(0,ACT)   CHECK CALL
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,8,0)
         LM    GR0,GR1,IOSAVE           RESTORE
         BR    GRC                      RETURN
         EJECT
* OVERFLOW I/O INTERFACE WITH BUFFERING ROUTINE IN ASMGASM
*       ENTER WITH WRITE I/O PARAMETER TABLE ADDRESS IN GR1
*       CALLING SEQUENCE
*       LA     GR1,XXXTAB
*       BAL    SP2,WROF
*
*
* WRITE OVERFLOW FILE INTERFACE WITH BUFF ROUTINE
*
*
WROF     STM   GR0,GR1,IOSAVE           SAVE
WRF2     TM    TSTSW,POINT              IS PREVIOUS STMT VALID .Q
         BZ    WRF5                     NO, THEN OK
         NI    TSTSW,ALL-POINT          YES, SCRATCH STMT
         L     GR1,BUFFPT(,ACT)         POINT TO FORMER ERROR RECORD
         MVC   WRPOINT(4),NASAVE        POINT ADDRESS
         CNOP  2,4                      ALIGN ARGUMENTS
         BALR  GR0,GR1                  GO DO THE POINTW
         DC    A(16,0)
WRPOINT  DS    F
         LH    GR1,BLCNT                FETCH BLOCK COUNT
         LH    GR2,ERRTAB+12            ADJUST BLOCK COUNT
         SR    GR2,GR1
         STH   GR2,ERRTAB+12            REPLACE THE BLOCK COUNT
         SR    GR1,GR1                  SET TEMPORARY BLOCK
         STH   GR1,BLCNT                COUNTER TO ZERO
         L     GR1,IOSAVE+4             RESTORE IO TABLE ADDRESS
WRF5     LM        GR0,GR1,4(GR1)      GET ADDRESS AND LENGTH
         STM       GR0,GR1,WRADL       PASS ADDR AND LENGTH ON TO BUFF
         L         GR1,BUFFPT(0,ACT)   WRITE ON SYSUT1
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(8,0)
WRADL    DS        2F
         L         GR1,BUFFPT(0,ACT)   CHECK IT
         CNOP      2,4
         BALR      GR0,GR1
         DC        A(28,0)
         L     GR2,IOSAVE+4             IO TABLE PTR
         LH    GR1,12(,GR2)             BLOCK COUNT
         LA    GR1,1(,GR1)              INCREMENT FOR LAST WRITE
         STH   GR1,12(,GR2)             SAVE BLOCK COUNT
         L     GR1,BUFFPT(,ACT)         DO A NOTE ON SYSUT1
         CNOP  2,4                      TO ALIGN ARGUMENTS
         BALR  GR0,GR1                  GO DO THE NOTE
         DC    A(20,0)
WRNOTE   DS    F
         CLI   14(GR2),0                FIRST TIME SWITCH SET .Q
         BE    WRF3                     NO, GO TO WRF3
         MVI   14(GR2),0                CLEAR FIRST TIME SWITCH
         MVC   0(4,GR2),WRNOTE          PUT NOTE IN I/O TABLE
WRF3     TM    TSTSW,NSTMT+NALL         NEW STATEMENT PROBABLY
         BNO   WRF6                     WITHOUT ERRORS .Q  YES
         MVC   NASAVE(4),WRNOTE         NO, NOTE ADDRESS FOR NEW STMT
         SR    GR2,GR2                  ZERO A REGISTER AND
         STH   GR2,BLCNT                ZERO TEMPORARY BLOCK COUNT
WRF6     NI    TSTSW,ALL-NOPRT          SET WRITTEN BUFFER
         LH    GR1,BLCNT                GET CURRENT BLOCK COUNT
         LA    GR1,L1A(,GR1)            INCREASE TEMP BLOCK COUNT
         STH   GR1,BLCNT                RESTORE THE BLOCK COUNT
         SR    GR1,GR1                  ZERO A WORK REGISTER
         ST    GR1,TRPARM+4             AND SET TRLI TO ZERO
         BR    SP2                      EXIT WROF
*
*
DWORD    DC    D'0'                     DOUBLE WORD FOR CVD
         LTORG
         DROP  SRB
         EJECT
***BUFFERS WHICH OVERLAP PHASE INITIALISATION LOGIC***
BUFORG   DS    0F                       BUFFER FBA
*
IOSAVE   DS    23F                IO REGISTR SAVE AREA--OS INTERFACE
IBUFCPT  DS        F                   INPUT RECORD POINTER
SAVE     DS    4F                       SAVE AREA FIRST LEVEL
USINGP   DS    4F                       I/O BUFFER 3
USINGT   DS    16F                      I/O BUFFER 4
         CNOP  6,8                      D ALIGN ERRBUF AND TRRBUF
RLI      DS    1H                       TEMPERARY FOR HALF WORD ALIGN
ERRBUF   DS    0XL133                   ERROR BUFFER
TRRBUF   DS    XL557                    TERMINAL ERROR BUFFER
TEMPBUF  DS    CL(SRCLN)                TEMPORARY TERMINAL BUFFER
EBUFLN   DC    H'133'                   ERROR BUFFER LENGTH, NOTERM
TBUFLN   DC    H'557'                   SOURCE/ERROR BUFFER LEN, TERM
         DS        0D                  PUT RLDBUF ON D BOUNDRY
RLDBUF   DS    XL121              RLD  BUFFER
         ORG   BUFORG             OVERLAP BUFFERS/VOLATILE LOGIC
         SPACE 5
*ADDRESS CONSTANTS FOR CONTROL TABLE INITIALISATION
F8CT2    DS    0F
         ORG   F8CT2-CT2+CDCVAL
         DC    A(ASMGF8D)               DC EVALUATION
         ORG   F8CT2-CT2+ASOPRO
         DC    A(ASMGF8A)               ASSEMBLER OP-CODE
         ORG   F8CT2-CT2+MACHOP
         DC    A(ASMGF8M)               MACHINE OP-CODE
         ORG   F8CT2-CT2+PRNT
         DC    A(ASMGF8P)               PRINT
         ORG       F8CT2+CT2C*4
F8CT3    DS    0F
         ORG   F8CT3-CT3+CTXTIO         I/O BASE
         DC    A(TEXTIO)
         ORG   F8CT3-CT3+CSTGET         SYMBOL TABLE
         DC    A(ASMGF8S)
         ORG   F8CT3-CT3+CEEVAL         EXPRESSION EVALUATION
         DC    A(ASMGF8V)
         ORG   F8CT3-CT3+CLOGER         LOG ERROR
         DC    A(ASMGF8L)
         ORG   F8CT3-CT3+F8LIGN         ALIGNMENT
         DC    A(SRLINE)
         ORG   F8CT3-CT3+F8DCMP
         DC    A(DCCOMP)
         ORG   F8CT3-CT3+F8EXPX
         DC    A(F8AREX)
         ORG   F8CT3-CT3+F8STSC
         DC    A(SECSET)
         ORG   F8CT3-CT3+CCONV          DC-FT.PT. CONVERSION
         DC    A(ASMGF8N)
         ORG   F8CT3-CT3+CTCOMT         PROCESS COMMENTS
         DC    A(COMMENT)
         ORG   F8CT3-CT3+CTBLDG         BUILD PRINT IMAGE
         DC    A(BLDIMG)
         SPACE 5
* F8I- PHASE F/8 INPUT INITIALIZATION
ASMGF8   BALR      12,0
         USING     *,12
         ENTRYOUT  F8
         L          SRB,=A(TEXTIO)     SET REAL BASE
         USING TEXTIO,SRB
         DROP      12
         L     GR1,CTLBTP(0,ACT)       SET LAT POINTER
         ST    GR1,LABPTR               LAT FIRST LOG RECORD PTR
         ST    GR1,CTXWAP(0,ACT)       SET LAT POINTER
         MVI   CESDIDPS(ACT),X'01'      PSEUDO-CURRENT ESD/ID
         MVI   CTEMERR(ACT),X'FF'       SET MNOTE INDICATOR
         MVC   CT2(CT2C*4,ACT),F8CT2    INITIALIZE F/8 FUNC ROUT PTR
         MVC   CT3(CT3C*4,ACT),F8CT3    INITIALIZE F/8 COMMON S/R PTR
         XC    CTUSPP(4,ACT),CTUSPP(ACT)  ZERO PUSH/POP NEST VALUES
         XC    STUMAP(4,ACT),STUMAP(ACT)  ZERO START OF UMAP CHAIN
         LA    SP2,USINGP               SAVE ADDRESS OF
         ST    SP2,CTXIO3(ACT)          I/O BUFFER 3
         LA    SP2,USINGT
         ST    SP2,CTXIO4(ACT)          I/O BUFFER 4
         LA    GRA,F8WORK(ACT)
         LA    GRB,F8INST(ACT)
         ST    GRA,CTSAVE(ACT)          TEXT RECORD POINTER
         ST    GRB,CTSAVE+4(ACT)        INSTRUCTION BLDG AREA POINTER
         PACK  DWORD,CCRDCT(4,ACT)      CONVERT CARD SEQ. NO. FROM
         CVB   1,DWORD                  ZONED TO HALF-WORD BINARY.
         STH   1,CCRDCT(ACT)            PUT IN CURRENT CARD NO.
         XC    CTLDCP(4,ACT),CTLDCP(ACT)     ZERO LITERAL WORK AREA
         MVC   CTSEQN(4,ACT),=C'0000'   START SEQUENCE AT ZERO
         MVI   F8PON(ACT),X'00'         SET PRINT OPTION - ON
         MVI   F8PGEN(ACT),X'00'        GEN OPTION - ON
         MVI   F8PDAT(ACT),X'FF'        DATA OPTION - OFF
         L     CRB,=A(ASMGF8C)          SET RETURN
         ST    CRB,CTSAVE+8(ACT)        TO GO TO ASMGF8C
         ST    CRB,CTSAVE+12(ACT)
*./      DELETE    SEQ1=10480020,SEQ2=10520020
*./      DELETE    SEQ1=10540022,SEQ2=10540022
         TM        CTEXEC(ACT),X'20'   WAS EXECUTE SPECIFIED .Q
         BZ        GEMORRA             BRANCH IF NOT
         MVI       PCHX+1,0            NOP THE SWITCH
         B     GEMORRA             DON'T LOOK BACK
         SPACE 6
*THE FOLLOWING LOGIC DESTROYS PRECEDING LOGIC BY BUFFER
*UTILIZATION, BUT IS ITSELF SAFE SINCE THE FOLLOWING LOGIC
*DOES NOT CAUSE MODIFICATION OF RLDBUF.
         SPACE
Q        DS    0C
         DS    XL(RLDBUF-Q)        POSITION LOGIC TO RLDBUF
         DC    X'08'               RLD TYPE
         SPACE 3
*
GEMORRA  DS    0H
         TM    CTTRMI(ACT),TERM         TERM OPTION ON .Q
         BZ    PCHSIM                   NO, DON'T CHANGE
*                                       ERROR TAB VALUES
         LA    GR1,TRRBUF               GET TERM BUFFER ADDRESS
         ST    GR1,TRMTAB               STORE TERM BUFFER ADDRESS
         ST    GR1,ERRTAB+4             FOR WROF ROUTINE
         MVI   0(GR1),X'00'             TERM RECORD I.D.
         LA    GR1,L3E(,GR1)            BUMP RECORD POINTER TO
         ST    GR1,TRPARM               FIRST AVAILABLE SOURCE LOC
         LA    GR1,INCR(,GR1)           BUMP OVER SOURCE
         ST    GR1,TRPARM+8             ERROR MSG ADDR OF TERM BUFFER
         ST    GR1,ERPARM
         MVC   ERRTAB+10(2),TBUFLN      SET NEW TERM BUFFER LENGTH
PCHSIM   XC    USINGP(80),USINGP        CLEAR USING TABLES
         L     GR1,CTXIO1(ACT)          INPUT BUFFER
         ST    GR1,RDADD
         MVI   RLDBUF,L8B               RECORD I.D.
         MVI   ERRBUF,L0                ERROR RECORD I.D.
         TM    CTPCSW(ACT),X'FF'        TEST IF PRIVATE CODE IS SET
         BZ    CTRTRN(ACT)              PRIVATE CODE NOT SET, SKIP
         LA    GRY,PCCON                PRIVATE CODE INDICATOR (4)
         STC   GRY,CTYPE(ACT)           CURRENT TYPE CELL
         IC    GRY,CTPCSW(ACT)
         STC   GRY,CESDID(ACT)          CURRENT ESD - ID
         L     SP1,CADJBS(ACT)          ADJUSTMENT TABLE BASE
         LR    SP2,GRY
         L     FRB,ASOPRO(ACT)    SET ASAOP ADDRESSING BASE
         L     GRY,F8STSC(ACT)          CSECT SETTING ROUTINE
         BALR  SRR,GRY
         B     CTRTRN(ACT)              EXIT TO MAIN LINE CONTROL
         LTORG
         ORG   ,                  END OF VOLATILE LOGIC
         EJECT
*NON-VOLATILE CONSTANTS AND SWITCHES
         SPACE
ICS      DC    X'00'
RD1      DC    X'02'                    BUFFER ONE SWITCHES
*./      DELETE    SEQ1=11360020,SEQ2=11360020
OSW      DC    X'00'
EOF      DC    4X'7F'                   EOF FOR LAT
LABPTR   DS        F                    POINTER IN LAT
LALBA    DC    F'0'                     LAT LBA
RLDPTR   DC    A(RLDBUF+1)              POINTER IN RLD
RLDLBA   DC    A(RLDBUF+121)            END OF RLD BUFFER
BLCNT    DS    H                        CURRENT BLOCK COUNT
FLAGA    DS    H
NASAVE   DS    F
TSTSW    DC    X'40'  SWITCH BYTE TO CONTROL OUTPUT ON UT1(TERM)
ALL      EQU   X'FF'
NSTMT    EQU   X'80'  NEW STATEMENT IN BUFFER
NALL     EQU   X'40'   ALL CARDS VALID SO FAR (SAME STATEMENT)
CONTB    EQU   X'20'  BUFFER CONTAINING ONLY CONTINUATUON CARDS
NOPRT    EQU   X'10'  BUFFER NOT WRITTEN
POINT    EQU   X'08'  SCRATCH VALID STATEMENT ON UT1
MSAVE    EQU   X'04'  FIRST NOT GEN SOURCE RECORD IS SAVED
CBGEN    EQU   X'02'  CONTB FOR GEN EXISTS WITHIN SAME MACRO
PCCON    EQU   4                        PRIVATE CODE INDICATOR
*
         END       ASMGF8
./ ADD NAME=ASMGF8L
F8L      TITLE     'ASMG F8  LOG ERROR SUBROUTINE'
         ISEQ  73,78
ASMGF8L  START
         SPACE
         PRINT      NOGEN
         FDIMEN
         SPACE
*TITLE 'ASMGF8L ' ... LOG ERROR                                       *
*FUNCTION/OPERATION-                                                  *
*  ASMGF8L ATTACHES THE ERROR MESSAGE TO AN EDITED TEXT RECORD. IF THE*
*   ERROR RECORD IS ALREADY PRESENT, LOGERR CHECKS FOR DUPLICATION AND*
*   A MAXIMUM OF 16 ERRORS, IF EITHER OF THESE CONDITIONS IS MET, THE *
*   ERROR IS NOT LOGGED. IF BOTH OF THE CONDITIONS ARE NOT MET, THE   *
*   ERROR IS LOGGED. IF THE ERROR RECORD IS NOT PRESENT, THE ERROR IS *
*   LOGGED AND A BIT IS SET IN TXERI SO THAT AN ERROR RECORD WILL BE  *
*   CREATED.                                                          *
*ENTRY POINT- ASMGF8L                                                 *
*     CALLING SEQUENCE--                                              *
*                                                                     *
*       L     SRB,CLOGER(ACT)           LOGERR BASE/ENTRY ADDRESS     *
*       L     SP1,POINTER               ABS POINTER TO ERROR (OR ZERO)*
*       BALR  SRR,SRB                                                 *
*       DC    AL2(ERRORCODE)            ERRORCODE EQU ERROR MSSG NUMBR*
*                                                                     *
* LOGERR WILL RETURN TO CALLING ROUTINE WITH SP1,SP2 UNCHANGED.       *
* GR0-GR2, GRX, GRY, AND GRZ ARE VOLATILE.                            *
*                                                                     *
*INPUT- NONE                                                          *
*OUTPUT- NONE                                                         *
*EXTERNAL ROUTINES-                                                   *
*   GETXTM- GET TEXT AND MOVE, CALLED IF AN ERROR RECORD IS PRESENT   *
*EXITS- NORMAL                                                        *
*   RETURNS TO CALLER VIA                                             *
*        BR    2(SRR)                   EXIT                          *
*   --- ERROR- NONE                                                   *
*TABLES/WORKAREAS-                                                    *
*   CTERRP(ACT)- POINTS TO THE ERROR RECORD WORK AREA                 *
*                                                                     *
         EJECT
ERRMAX   EQU   16                       MAX NUMBER OF ERRORS/STATEMENT
         SPACE
         USING     ASMGF8L,SRB
         SPACE 2
         STM   SP1,SP2,SAVE2            ENTER LOGERR, SAVE REGS
         L     SP2,CTERRP(ACT)          POINTER TO ERROR REC WORK AREA
         SPACE
         LA    SP1,1(SP1)               CALC RELATIVE POINTER         *
         S     SP1,F8OPRN(ACT)                                        *
         SPACE
         BP    GETERR                   POINTER PRESENT
         SR    SP1,SP1                  NOT PRESENT, CLEAR SP1
         EJECT
GETERR   CLI   ERSWH(ACT),X'FF'         TEST ERROR REC IN CORE SWITCH
         MVI       CTERRSW(ACT),X'FF'  SET ERROR SW FOR F8P
         BE    ADDERR                   SET, ADD ERROR MESSAGE TO REC
         MVI   ERSWH(ACT),X'FF'         NOT SET, SET
         MVI   2(SP2),X'10'             INITIALIZE ERR REC IN WORK AREA
         MVI   3(SP2),X'00'             REC TYPE EQ 001, COUNT EQ ZERO
         L     GR1,CTEXTP(ACT)
         TM    TXERI(GR1),X'04'         TEST ERROR REC FOLLOWS IND
         BO    GETREC                   SET, GET ERROR REC FROM TEXT
         OI    TXERI(GR1),X'04'         NOT SET, SET IT
         B     ADDERR                   THEN ADD ERR MESSAGE TO NES REC
         SPACE
GETREC   STM   SRB,SP2,SAVE4            SAVE REGISTERS
         LR    SP1,SP2                  PUT RECORD IN ERROR WK AREA
         L     SRB,CTXTIO(ACT)          LOAD BASE
         BAL   SRR,GETXTM(SRB)          GET ERROR REC FROM TEXT FILE
         USING *,SRR                    GETXTM DESTROYED OUR BASE
         LM    SRB,SP2,SAVE4            SO RESTORE OUR BASE USING SRR
         DROP  SRR                      NO MORE NEED FOR SRR, SO DROP
         SPACE
ADDERR   CLI   3(SP2),ERRMAX            TEST ERROR COUNT
         BE    RETURN                   EXIT IF MAX
         SPACE
         SR    GR1,GR1                  PUT ERROR COUNT IN GR1
         IC    GR1,3(SP2)
         LR    GR2,GR1                  POINT GR2 TO CURRENT MESSAGE-1
         SLL   GR2,1
         LA    GR2,0(GR2,SP2)
         SPACE
         STC   SP1,5(GR2)               PUT COL POINTER IN ERR MESSAGE
         MVC   4(1,GR2),1(SRR)          PUT ERROR CODE  IN ERR MESSAGE
         LH    SP1,4(GR2)               PUT ERROR MESSAGE IN SP1
         SPACE
CHECKERR CLR   GR2,SP2                  COMPARE CURRENT ERROR MESSAGE
         BE    COUNTERR                 AGAINST PRIOR MESSAGES
         CH    SP1,2(GR2)
         BE    RETURN                   IGNORE IF PREVIOUSLY LOGGED
         BCTR  GR2,0
         BCT   GR2,CHECKERR             LOOP TO COMPARE ALL
         SPACE
COUNTERR LA    GR1,1(GR1)               INC ERROR COUNT
         STC   GR1,3(SP2)
         LA    GR1,4(GR1,GR1)           INC RECORD LENGTH
         STH   GR1,TXRL(SP2)
         SPACE
RETURN   LM    SP1,SP2,SAVE2            RESTORE REGS
         B     2(SRR)                   RETURN TO CALLING ROUTINE
         SPACE
SAVE2    DS    2F                       SP1,SP2 SAVE AREA
SAVE4    DS    4F                       SRB-SP2 SAVE AREA
         SPACE
         END   ASMGF8L
./ ADD NAME=ASMGF8M
F8M      TITLE     'ASMG F8  MACHINE OPERATOR PROCESSOR (F8MOP)'
         ISEQ  73,78
*./      DELETE    SEQ1=00050023,SEQ2=00055023
         COPY      ASMGSET
ASMGF8M  START     ,                    MACHINE OP PROCESSOR
         PRINT        NOGEN
         FDIMEN
         PRINT      GEN
         SPACE 2
*                                                                     *
*TITLE 'ASMGF8M ' ...  MACHINE OPERATOR PROCESSOR                     *
*FUNCTION/OPERATION-                                                  *
*  ASMGF8M PROCESSES THE OPERAND FIELDS OF EACH MACHINE INSTRUCTION.  *
*   IT SCANS THE OPERAND, CHECKS FOR SYNTAX ERRORS, FINDS THE CORRECT *
*   BASE, AND BUILDS 'F8INST' FOR PRINTING AND PUNCHING BY ASMGF8P.THE*
*   FOLLOWING ERRORS ARE DETECTED AND FLAGGED-                        *
*        IMMEDIATE FIELD           INVALID DELIMITER                  *
*        ALIGNMENT                 INCORRECT REGISTER                 *
*        LENGTH                    INVALID LITERAL USAGE              *
*        NON-REENTERANT            RELOCABILITY                       *
*        INVALID DISPLACEMENT      LOCATION COUNTER                   *
*        ILLEGAL START CARD        ADDRESSABILITY                     *
*ENTRY POINTS-                                                        *
*  ASMGF8M     MACHINE OPERAND PROCESSOR. CALLED VIA-                 *
*        L     FRB,MACHOP(ACT)          LOAD BASE/ENTRY               *
*        BALR  CRR,ACT                  CALL ASMGF8M                  *
*   F8AREX     RELOCATABLE EXPRESSION EVALUATOR. CALLED VIA-          *
*        L     FRB,MACHOP(ACT)          LOAD BASE                     *
*        L     GR1,F8EXPX(ACT)          LOAD ENTRY                    *
*        BALR  SRR,GR1                  CALL F8AREX                   *
*   DCCOMP     DE COMPILE. CALLED VIA-                                *
*        L     FRB,MACHOP(ACT)          LOAD BASE                     *
*        L     GR1,F8DCMP(ACT)          LOAD ENTRY                    *
*        BALR  SRR,GR1                  CALL DE COMPILE               *
*INPUT-                                                               *
*   SP2 POINTS TO THE OPERAND                                         *
*   GRA POINTS TO F8WORK(ACT)                                         *
*   F8WORK(ACT) CONTAINS RECORD TYPES 4, 6, OR 7                      *
*OUTPUT-                                                              *
*   F8INST(ACT) IS PRODUCED FOR PRINTING AND/OR PUNCHING BY ASMGF8P   *
*EXTERNAL ROUTINES-                                                   *
*   NAME            ROUTINE   USE                                     *
*   CEEVAL(ACT)     ASMGF8V   EXPRESSION EVALUATION                   *
*   CLOGER(ACT)     ASMGF8L   LOG ERROR                               *
*EXITS- NORMAL--                                                      *
*  ASMGF8M RETURNS TO CALLER VIA-                                     *
*        B     CTRTRN(ACT)              EXIT                          *
*   F8AREX AND DCCOMP RETURN TO CALLER VIA-                           *
*        BR    SRR                      EXIT                          *
*   ERRORS- NONE                                                      *
*TABLES/WORKAREAS-                                                    *
*   MOPTBL -   TRANSFER TABLE FOR TYPE OF INSTRUCTION                 *
*   EXFLGS -   FLAGS SET BY F8AREX. SEE F8AREX FOR MEANING            *
*   VALUEB -   RESULTS OF F8AREX                                      *
*   F8AREGS -  SAVE AREA FOR DCCOMP                                   *
*   USNGPP -   USING TABLE POINTER. 1X16 BYTES, FF=REGISTER USED      *
*                                               00=REGISTER NOT USED  *
*   USNGTP -   USING TABLE. 4X16 BYTES, BYTE 1= ESD/ID                *
*                                       BYTES 2-4 = VALUE             *
*NOTES-                                                               *
*   TO GET THE INDEX IN THE BRANCH TABLE 'MOPTBL', A FOUR BIT INDEX IS*
*   USED. THE FIRST 2 BITS COME FROM BITS 4-5 OF THE TXASC CODE (TYPE *
*   CLASS WITHIN INSTRUCTION) AND THE LAST 2 BITS COME FROM THE FIRST *
*   2 BITS OF THE MACHINE CODE (LENGTH).                              *
*                                                                     *
         EJECT
         USING *,FRB
         SR    GRZ,GRZ
         MVI   RR2SWH(ACT),X'00'        SET TYPE 2 FLAG OFF
         MVI   ABSRX,X'00'              ZERO ABSOLUTE WITCH
         MVI   ERRSW,X'00'             TURN OFF STATEMENT ERROR SWITCH
         MVI   LITRLTWO,X'00'           ZERO MULT. LIT SWITCH
         MVI       LDECSW+1,X'80'      SET BZ
         MVI       K257256+3,257-256   SET TEST FOR 256
         LR    SP1,SP2                  OPERAND POINTER TO SP1
         IC    GRZ,F8WORK+4(ACT)        HEXOP
         STC   GRZ,F8INST+3(ACT)        TO INSTRUCTION
         SR    GRY,GRY
         IC    GRY,BITS45               BITS 4 AND 5
         MVC   ALIGNT+3(1),5(GRA)
         N     GRY,ALIGNT
         SRL   GRZ,6                    BITS 0 AND 1 TO 6 AND 7
         OR    GRZ,GRY                  16 WAY BRANCH TO MACHINE OPS
         AR    GRZ,GRZ                 DOUBLE FOR TABLE RECOVERY
         LH    GRZ,MOPTBL(GRZ)         GET RELATIVE ENTRY POIMT
         B     MOPROC(GRZ)             BRANCH TO PROPER PROCESSOR
MOPTBL   DS    0H                      START OF DISPLACEMENT TABLE
         DC    AL2(RR1-MOPROC)          REGISTER - REGISTER      TYPE 1
         DC    AL2(RX1-MOPROC)          REGISTER - INDEX STORAGE TYPE 1
         DC    AL2(RS1-MOPROC)          REGISTER - STORAGE       TYPE 1
         DC    AL2(SS1-MOPROC)          STORAGE - STORAGE        TYPE 1
         DC    AL2(RR2-MOPROC)          REGISTER - REGISTER      TYPE 2
         DC    AL2(RX2-MOPROC)          REGISTER - INDEX STORAGE TYPE 2
         DC    AL2(RS2-MOPROC)          REGISTER - STORAGE       TYPE 2
         DC    AL2(SS2-MOPROC)          STORAGE - STORAGE        TYPE 2
         DC    AL2(RR3-MOPROC)          REGISTER - REGISTER      TYPE 3
         DC    AL2(PROCER-MOPROC)       PROCEDURE ERROR          ******
         DC    AL2(SI3-MOPROC)          STORAGE - IMMEDIATE      TYPE 3
         DC    AL2(SS3-MOPROC)          STORAGE-STORAGE  XIO     TYPE 3
         DC    AL2(RR4-MOPROC)          REGISTER - REGISTER      TYPE 4
         DC    AL2(PROCER-MOPROC)       PROCEDURE ERROR          ******
         DC    AL2(SI4-MOPROC)          STORAGE - IMMEDIATE      TYPE 4
         AIF       (&SYM370).SS4
         DC    AL2(PROCER-MOPROC)       PROCEDURE ERROR          ******
         AGO       .NOSS4
.SS4     ANOP
         DC    AL2(SS4-MOPROC)          STORAGE - STORAGE  SRP   TYPE 4
.NOSS4   ANOP
MOPROC   DS    0H                      RELATIVE ENTRY ZERO
***********************************************************************
***   RR1   ***
*REGISTER TO REGISTER INSTRUCTION TYPE 1 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THOSE REGISTER TO
* REGISTER INSTRUCTIONS WHICH NAME BOTH REGISTERS EXPLICITLY.
***********************************************************************
RR1      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES
         LA    GR0,2
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,R1PROC               PROCESS R1
         BNE   DLMERR
         LA    SP1,1(SP1)               SET POINTER TO NEXT CHAR
RR1A     BAL   SRR,R2PROC               PROCESS R2
RRXT     CLI   0(SP1),IBLANK            IS NEXT CHAR A BLANK
         BNE   DLMERR                   NO, LOG ERROR
         B     MOPRTN                   RETURN
***********************************************************************
***   RR2   ***
*REGISTER TO REGISTER INSTRUCTION TYPE 2 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE SPM INSTRUCTION.
***********************************************************************
RR2      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES
         LA    GR0,2
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
RR2A     BAL   SRR,R1PROC               PROCESS R1
         B     RRXT                     GO SEE IF NEXT CHAR A BLANK
***********************************************************************
***   RR3   ***
*REGISTER TO REGISTER INSTRUCTION TYPE 3 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE SVC INSTRUCTION.
***********************************************************************
RR3      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES
         LA    GR0,2
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,IPROC                REGISTER BRANCH FOR TRAIL ONLY
***********************************************************************
***   RR4   ***
*REGISTER TO REGISTER INSTRUCTION TYPE 4 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF EXTENDED MNEMONIC
*REGISTER TO REGISTER INSTRUCTIONS.  R1 IS SET WITH AN IMPLICITLY
*DEFINED VALUE AND R2 RECEIVES THE EXPLICITLY DEFINED VALUE.
***********************************************************************
RR4      MVI   F8INST+15(ACT),X'02'     LENGTH IS 2 BYTES
         LA    GR0,2
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         MVO   F8INST+4(1,ACT),F8WORK+3(1,ACT)    MOVE IN EXTENDED MNEM
         B     RR1A                     CONTINUE AS THOUGH RR1
***********************************************************************
***   RX1   ***
*REGISTER-INDEXABLE STORAGE INSTRUCTION TYPE 1 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF REGISTER-INDEXABLE
* STORAGE INSTRUCTIONS IN WHICH BOTH OPERANDS ARE EXPLICITLY DEFINED.
***********************************************************************
RX1      MVI   F8INST+15(ACT),X'14'     PUT OUT EA2
         LA    GR0,4                    LENGTH IS 4 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,R1PROC               PROCESS R1
         BNE   DLMERR                   IF ERROR BRANCH
         LA    SP1,1(SP1)               UP TO NEXT CHAR
RX2A     BAL   SRR,S2D2A                GET DISPLACEMENT
         BE    MOPRTN                   BRANCH IF END OF FIELD
         CLI   0(SP1),ILPARN            IS NEXT CHAR A LEFT PARN
         BNE   DLMERR                   DELIMETER NOT LEFT PAREN
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS NEXT CHARACTER COMMA
         BE    RX1B                     YES, SKIP INDEX
RX1A     BAL   SRR,X2PROC               PROCESS X2 FIELD
         BE    RX1B                     IF COMMA, PROCESS B2
         CLI   0(SP1),IRPARN            IF NOT, IS DELIMETER RIGHT PARN
         BNE   DLMERR                   IF NOT, DELIMETER ERROR
         B     RX1C                     CHECK BLANK AND EXIT TO CALLER
RX1B     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B2A                  PROCESS B2
RX1C     CLI   1(SP1),IBLANK           IS DELIMETER BLANK
         BE    MOPRTN                   COMMON RETURN
         B     DLMERR                   DELIMETER ERROR
***********************************************************************
***   RX2   ***
*REGISTER-INDEXABLE STORAGE INSTRUCTION TYPE 2 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF REGISTER-INDEXABLE
* STORAGE INSTRUCTIONS IN WHICH R1 IS SET WITH AN IMPLICITLY DEFINED
* VALUE AND THE INDEXABLE VALUE IS SPECIFIED.
***********************************************************************
RX2      MVI   F8INST+15(ACT),X'14'     OUTPUT FLAG TO INSTRUCTION
         LA    GR0,4                    LENGTH IS 4 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         MVO   F8INST+4(1,ACT),F8WORK+3(1,ACT) R1 MASK TO INSTRUCTION
         B     RX2A                     COMMON RX1 AND RX2 PART
***********************************************************************
***   RS1   ***
*REGISTER-STORAGE INSTRUCTION TYPE 1 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF REGISTER-STORAGE
* INSTRUCTIONS IN WHICH R1,R3, AND STORAGE ARE SPECIFIED
***********************************************************************
RS1      MVI   F8INST+15(ACT),X'14'     OUTPUT FLAG TO INSTRUCTION
         LA    GR0,4                    LENGTH IS 4 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,R1PROC               PROCESS R1
         BNE   DLMERR                   DELIMETER ERROR IF NOT COMMA
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI       F8INST+3(ACT),X'B1' TEST FOR LRA
         BE        RX2A                LRA IS REALLY RX, NOT RS OR SI
         AIF       (NOT &RPQ67).RPQ67#1
         CLI       F8INST+3(ACT),X'A3' TEST FOR SWPR
         BE        SWAP
         CLI       F8INST+3(ACT),X'A2' TEST FOR SLT
         BE        SEARCH
.RPQ67#1 ANOP
         BAL   SRR,R3PROC               PROCESS R3
RS1A     BNE   DLMERR                   DELIMETER ERROR IF NOT COMMA
RS2A     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,S2D2A                PROCESS S2 OR D2
         BE    MOPRTN                   EXIT
         CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN
         BNE   DLMERR                   NO, DELIMETER ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B2A                  PROCESS B2A
         CLI   1(SP1),IBLANK           IS DELIMETER BLANK
         BE    MOPRTN                   YES, EXIT
         B     DLMERR                   NO, DELIMETER ERROR
         AIF       (NOT &RPQ67).RPQ67#2
*
SEARCH   BAL       SRR,WEIRDLEN        PROCESS SLT LENGTH
         MVN       F8INST+4(1,ACT),VALUEB+3 INSERT LENGTH
         B         RS1A                CONTINUE
*
SWAP     OI        TXASC+F8WORK(ACT),X'C0' CHANGE APPROPRIATE BITS
         B         RR1A                CONTINUE WITH RR FORMAT
.RPQ67#2 ANOP
***********************************************************************
***   RS2   ***
*REGISTER-STORAGE INSTRUCTION TYPE 2 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF ALL SHIFT INSTRUCTIONS
***********************************************************************
RS2      MVI   F8INST+15(ACT),X'14'     SET OUTPUT FLAGS IN INSTRUCTION
         LA    GR0,4                    LENGTH IS 4 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,R1PROC               PROCESS R1
         BNE   DLMERR                   IF DELIMETER NOT COMMA, ERROR
         B     RS2A                     BRANCH TO COMMON RS1 RS2 RTN
***********************************************************************
***   SI3   ***
*STORAGE-IMMEDIATE INSTRUCTION TYPE 3 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF ALL STORAGE-IMMEDIATE
* INSTRUCTIONS EXCEPT LPSW,SSM,HIO,SIO,TIO,TCH, AND TS
***********************************************************************
SI3      MVI   F8INST+15(ACT),X'24'     SET OUTPUT FLAGS IN INSTRUCTION
         LA    GR0,4                    LENGTH IS 4 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,S1D1                 PROCESS S1 D1
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BE    SI3A                     IF COMMA PROCESS I
         CLI   0(SP1),ILPARN            DELIMETER LEFT PAREN TEST
         BNE   DLMERR                   DELIMETER ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B1                   PROCESS B1
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA           IS DELIMETER COMMA
         BNE   DLMERR                   DELIMETER ERROR
SI3A     LA    SP1,1(SP1)              BUMP OPERAND POINTER BY ONE
         BAL   SRR,IPROC               PROCESS IMMEDIATE FIELD
***********************************************************************
***   SI4   ***
*STORAGE-IMMEDIATE INSTRUCTION TYPE 4 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE-IMMEDIATE
* INSTRUCTIONS LPSW,SSM,HIO,SIO,TIO,TCH, AND TS
***********************************************************************
SI4      MVI   F8INST+15(ACT),X'24'     SET OUTPUT FLAGS IN INSTRUCTION
         LA    GR0,4                    LENGTH IS 4 BYTES
         TM    F8WORK+3(ACT),X'20'      IS EXTEN ON .Q
         BZ    SI4A                     NO EXTENDED OP CODE
         MVN   F8INST+4(1,ACT),F8WORK+3(ACT)  INSERT EXTEN MASK OFFSET
         TR    F8INST+4(1,ACT),TASTABLE GET 2ND BYTE OF OPCODE
         CLC   F8INST+3(2,ACT),=X'B20B' IS IT INSERT PSW KEY (IPK) .Q
         BE    SI4B                     BRANCH IF YES
         CLC   F8INST+3(2,ACT),=X'B20D' IS IT PTLB .Q
         BNE   SI4A                     BRANCH IF NOT
SI4B     DS    0H
         CLI   0(SP1),IBLANK            IS OPERAND NULL .Q
         BE    MOPRTA                   EXIT NOW IF SO
         CLI   0(SP1),ICOMMA            OR SPECIFIC NULL .Q
         BE    MOPRTA                   EXIT NOW IF SO
         B     MOPRTA                   FOOLISHLY IGNORE THE OPND ERROR
SI4A     DS    0H
         CLI   F8INST+3(ACT),X'B3'      A DUMMY 'B21X' OPCODE .Q
         BNE   SI4C                     BRANCH IF NOT
         NI    F8INST+3(ACT),X'FE'      ALTER FIRST BYTE OF OPCODE
         OI    F8INST+4(ACT),X'10'      ALTER SECOND BYTE OF OPCODE
SI4C     DS    0H
         ST    GR0,CTF8LNGT(,ACT)       SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,S1D1                 PROCESS S1 OR D1
         BE    MOPRTN                   IF DELIMETER BLANK, EXIT
         CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN
         BNE   DLMERR                   NO, DELIMETER ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B1                   PROCESS B1
         CLI   1(SP1),IBLANK            DELIMETER AFTER PAREN BLANK
         BE    MOPRTN                   YES, EXIT
         B     DLMERR                   NO, ERROR
TASTABLE DS    0XL16                    TRANSLATE TABLE FOR 2 BYTE OPS
*                                           2ND BYTE 0X     2ND BYTE 1X
         DC    X'00'                        ---             SPX
         DC    X'01'                        HDV,SIOF,CLRIO  STPX
         DC    X'02'                        STIDP           STAP
         DC    X'03'                        STIDC           RRB
         DC    X'04'                        SCK             ---
         DC    X'05'                        STCK            ---
         DC    X'06'                        SCKC            ---
         DC    X'07'                        STCKC           ---
         DC    X'08'                        SPT             ---
         DC    X'09'                        STPT            ---
         DC    X'0A'                        SPKA            ---
         DC    X'0B'                        IPK             ---
         DC    X'0C'                        ---             ---
         DC    X'0D'                        PTLB            ---
         DC    X'0E'                        ---             ---
         DC    X'0F'                        ---             ---
***********************************************************************
***   SS1   ***
*STORAGE TO STORAGE INSTRUCTION TYPE 1 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE TO STORAGE
* INSTRUCTIONS REQUIRING BOTH L1 AND L2 EITHER EXPLICIT OR IMPLICIT
***********************************************************************
SS1      MVI   F8INST+15(ACT),X'36'     SET OUTPUT FLAGS IN INSTRUCTION
         LA    GR0,6                    LENGTH IS 6 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,S1D1                 PROCESS S1 OR D1
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   SS1A                     NO, SKIP IMPLIED LENGTH 1
         BAL   SRR,IMPLL1               INSERT INPLIED LENGTH 1
SS12ND   LA    SP1,1(SP1)               SECOND OPERAND ENTRY
         BAL   SRR,S2D2B                PROCESS S2 OR D2, IS DELIM BLNK
         BNE   SS1N                     NO, SKIP IMPMPLIED LENGTH
         BAL   SRR,IMPLL2               INSERT INPLIED LENGTH 2
         B     MOPRTN                   MACHINE OP EXIT
IMPLL1   CLI   STLONG+1(ACT),15         IF LARGER THAN 15, TOO BIG
         BH    LENERR                   ERROR EXIT
         CLI   STLONG(ACT),0            IF LARGER THAN 15, TOO BIG
         BH    LENERR                   ERROR EXIT
         MVO   F8INST+4(1,ACT),STLONG+1(1,ACT)  IMPLIED LENGTH TO INST
         BR    SRR                              RETURN TO CALLER
IMPLL2   CLI   STLONG+1(ACT),15         IF LARGER THAN 15, TOO BIG
         BH    LENERR                   ERROR EXIT
         CLI   STLONG(ACT),0            IF LARGER THAN 15, ERROR
         BH    LENERR                   ERROR EXIT
         MVN   F8INST+4(1,ACT),STLONG+1(ACT)
         BR    SRR                              RETURN TO CALLER
SS1A     CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN
         BNE   DLMERR                   NO, ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   SS1B                     IF NO, PROCESS LENGTH
         BAL   SRR,IMPLL1               IMPLIED LENGTH 1 TO INSTRUCTION
         B     SS1E                     PROCESS BASE 1
SS1B     BAL   SRR,L1PROC               PROCESS L1
         MVO   F8INST+4(1,ACT),VALUEB+3(1) L1 VALUE TO INSTRUCTION
         BNE   SS1D                     IF DELIMETER NOT COMMA, SKIP B1
SS1E     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B1                   PROCESS B1
SS1C     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS DELIMETER AFTER PAREN COMMA
         BE    SS12ND                   IF YES, DO SECOND OPERAND
         B     DLMERR                   IF NO, DELIMETER ERROR
SS1N     CLI   0(SP1),ILPARN           IS DELIMERT LEFT PAREN
         BNE   DLMERR                   NO, ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   SS1P                     IF NO, PROCESS LENGTH
         BAL   SRR,IMPLL2               IMPLIED LENGTH 2 TO INSTRUCTION
         B     SS1S                     PROCESS BASE 2
SS1P     BAL   SRR,L2PROC               PROCESS L2
         MVN   F8INST+4(1,ACT),VALUEB+3 MOVE L2 VALUE TO INSTRUCTION
         BNE   SS1R                     IF DELIMETER NOT COMMA, SKIP B2
SS1S     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B2B                  PROCESS B2
SS1Q     CLI   1(SP1),IBLANK            IS DELIEETER AFTER PAREN BLANK
         BE    MOPRTN                   IF YES, EXIT MACHINE OP PROCESS
         B     DLMERR                   IF NO, DELIMETER ERROR
SS1D     CLI   0(SP1),IRPARN            IS DELIMETER RIGHT PAREN
         BE    SS1C                     CHECK NEXT DELIMETER
         B     DLMERR                   IF NO, DELIMETER ERROR
SS1R     CLI   0(SP1),IRPARN            IS DELIMETER RIGHT PAREN
         BE    SS1Q                     CHECK NEXT DELIMETER
         B     DLMERR                   IF NO, DELIMETER ERROR
***********************************************************************
***   SS2   ***
*STORAGE TO STORAGE INSTRUCTION TYPE 2 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE TO STORAGE
* INSTRUCTIONS REQUIRING ONLY ONE MOVE LENGTH
***********************************************************************
SS2      MVI   F8INST+15(ACT),X'36'     SET OUTPUT FLAGS IN INSTRUCTION
         LA    GR0,6                    LENGTH IS 6 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,S1D1                 PROCESS S1 OR D1
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA
         BNE   SS2A                     NO, SKIP IMPLIED LENGTH
         BAL   SRR,IMPLL                INSERT IMPLIED LENGTH
SS22ND   LA    SP1,1(SP1)               SECOND OPERAND ENTRY
         BAL   SRR,S2D2B                PROCESS S2 OR D2, IS DELIM BLNK
         BNE   SS2N                     NO, PROCESS BASE
         B     MOPRTN                   MACHINE OP EXIT
SS2A     CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN
         BNE   DLMERR                   IF NO, DELIMETER ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS NEXT DELIMETER COMMA
         BNE   SS2B                     IF NOT, PROCESS LENGTH
         BAL   SRR,IMPLL                IF COMMA, IMPLIED LENGTH TO INS
         B     SS2E                     PROCESS B1
SS2B     BAL   SRR,LPROC                PROCESS LENGTH
         MVC   F8INST+4(1,ACT),VALUEB+3 LENGTH VALUE TO INSTRUCTION
         BNE   SS2D                     IF NOT COMMA, TRY RIGHT PAREN
SS2E     LA    SP1,1(SP1)               IF DELIMETER COMMA, BUMP OPRN
         BAL   SRR,B1                   PROCESS B1
SS2C     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS NEXT DELIMETER COMMA
         BE    SS22ND                   YES, DO 2ND OPERAND
         B     DLMERR                   NO, DELIMETER ERROR
IMPLL    CLI   STLONG(ACT),0            IS LENGTH GREATER THAN 255
         BH    LENERR                   IF HIGH, TOO BIG
         MVC   F8INST+4(1,ACT),STLONG+1(ACT) IMPLIED LENGTH TO INST
         BR    SRR                           RETURN TO CALLING RTN
SS2N     CLI   0(SP1),ILPARN                 IS DELIMETER LEFT PAREN
         BNE   DLMERR                        NO, DELIMETER ERROR
         B     SS2S                          PROCESS B2
SS2S     EQU   SS1S
SS2D     CLI   0(SP1),IRPARN                 IS DELIMETER LEFT PAREN
         BE    SS2C                          IF EQUAL TEST FUTHER
         B     DLMERR                        IF NOT, DELIMETER ERROR
*
*        SS3
*              SAME AS SS2 EXCEPT LENGTH FIELD NOT DECREMENTED BY
*               ONE IF GIVEN EXPLICITLY.
*
SS3      MVI       LDECSW+1,X'F0'      SO EXPLICIT LENGTH NOT DECREMENT
         MVI       K257256+3,256-256   SET TEST FOR 255
         B         SS2
         AIF       (NOT &SYM370).NOSS4A
***********************************************************************
***   SS4   ***
*STORAGE TO STORAGE INSTRUCTION TYPE 4 PROCESSOR
* THIS ROUTINE PROCESSES THE OPERAND FIELD OF THE STORAGE TO STORAGE
* INSTRUCTIONS REQUIRING ONE MOVE LENGTH AND A MASK
***********************************************************************
SS4      MVI   F8INST+15(ACT),X'36'     SET OUTPUT FLAGS IN INSTRUCTION
         LA    GR0,6                    LENGTH IS 6 BYTES
         ST    GR0,CTF8LNGT(ACT)        SET LENGTH FOR WRAP AROUND TEST
         BAL   SRR,S1D1                 PROCESS S1 OR D1
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q
         BNE   SS4A                     NO, SKIP IMPLIED LENGTH1
         BAL   SRR,IMPLL1               INSERT IMPLIED LENGTH1
SS42ND   LA    SP1,1(SP1)               SECOND OPERAND ENTRY
         BAL   SRR,S2D2B                PROCESS S2 OR D2
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q
         BE    SS43RD                   PROCESS MASK
         CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN .Q
         BNE   DLMERR                   NO, DELIMETER ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B2B                  PROCESS B2
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q
         BNE   DLMERR                   NO, DELIMETER ERROR
SS43RD   LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,F8ARGX               MASK EXPRESSION EVALUATION
         TM    AEXP1,X'01'              TEST IF MASK GT 15
         BNZ   I4ERR                    BRANCH IF YES
         CLI   VALUEB+3,10              IS VALUE A DECIMAL DIGIT .Q
         BL    M1PR1                    YES, FILL IT IN INSTRUCTION
I4ERR    BAL   SRR,ERRNO0               REPORT THE MASK ERROR
         DC    AL2(ERRIMM)              IMMEDIATE FIELD ERROR
         B     SS4EXIT                  GO AND TERMINATE
M1PR1    MVN   F8INST+4(1,ACT),VALUEB+3 PUT M INTO INSTRUCTION
SS4EXIT  CLI   0(SP1),IBLANK            IS DELIMITER BLANK .Q
         BE    MOPRTN                   YES, EXIT
         B     DLMERR                   NO, ERROR
SS4A     CLI   0(SP1),ILPARN            IS DELIMETER LEFT PAREN .Q
         BNE   DLMERR                   NO, ERROR
         LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS DELIMETER COMMA .Q
         BNE   SS4B                     IF NO, PROCESS LENGTH
         BAL   SRR,IMPLL1               IMPLIED LENGTH 1 TO INSTRUCTION
         B     SS4E                     PROCESS BASE 1
SS4B     BAL   SRR,L1PROC               PROCESS L1
         MVO   F8INST+4(1,ACT),VALUEB+3(1) L1 VALUE TO INSTRUCTION
         BNE   SS4D                     IF DELIMETER NOT COMMA, SKIP B1
SS4E     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         BAL   SRR,B1                   PROCESS B1
SS4C     LA    SP1,1(SP1)               BUMP OPERAND POINTER
         CLI   0(SP1),ICOMMA            IS DELIMETER AFTER PAREN COMMA
         BE    SS42ND                   IF YES, DO SECOND OPERAND
         B     DLMERR                   IF NO, DELIMETER ERROR
SS4D     CLI   0(SP1),IRPARN            IS DELIMETER RIGHT PAREN .Q
         BE    SS4C                     CHECK NEXT DELIMETER
         B     DLMERR                   IF NO, DELIMETER ERROR
.NOSS4A  ANOP
         SPACE     2
R1PROC   ST    SRR,RRHOLD               R1 PROCESSOR ENTRY, STORE EXIT
         BAL   SRR,F8ARGX               REGISTER EXPRESSION EVALUATION
         TM    AEXP1,X'03'              REGISTER REQUIREMENTS AND SIZE
         BZ    R1PR1                    IF 0, OK
         BAL   SRR,REGERR               REGISTER ERROR ROUTINE
R1PR1    MVO   F8INST+4(1,ACT),VALUEB+3(1) PUT R1 INTO INSTRUCTION
         CLI   0(SP1),ICOMMA            IS ENDING DELIMETER COMMA
         L     SRR,RRHOLD               LOAD EXIT
         BR    SRR                      EXIT TO CALLER
R2PROC   ST    SRR,RRHOLD               R2 PROCESSOR ENTRY,STORE EXIT
         CLI   TXHEX(GRA),X'25'         CHECK LRDR OP
         BNE   R2CHEK                   NO
         NI    TXASC(GRA),X'BF'         YES, MAKE R2 0-4 REQMENT
R2CHEK   CLI   TXHEX(GRA),X'27'         CHECK MXDR OP
         BNE   R2VAL                    NO
         OI    TXASC(GRA),X'40'         YES, MAKE R2 EVEN REQMENT
R2VAL    BAL   SRR,F8ARGX               REGISTER EXPRESSION EVAL
         TM    AEXP1,X'03'              REGISTER & SIZE REQUIREMENT
         BZ    R2PR1                    IF 0, OK
         BAL   SRR,REGERR               REGISTER ERROR ROUTINE
R2PR1    OC    F8INST+4(1,ACT),VALUEB+3 R2 (OR R3) TO INSTRUCTION
         CLI   0(SP1),ICOMMA            IS ENDING DELIMETER COMMA
         L     SRR,RRHOLD               LOAD EXIT
         BR    SRR                      EXIT TO CALLER
R3PROC   ST    SRR,RRHOLD               R2 PROCESSOR ENTRY, STORE EXIT
         BAL   SRR,F8ARGX               REGISTER EXPRESSION EVALUATION
         TM    AEXP1,X'01'              SIZE REQUIREMENT ONLY
         BZ    R2PR1                    IF 0, OK
         BAL   SRR,REGERR               REGISTER ERROR ROUTINE
         B     R2PR1                    FINISH SCAN ETC
IPROC    ST    SRR,RRHOLD               I PROCESSOR ENTRY, STORE EXIT
         BAL   SRR,F8AREX               EVALUATE IMMEDIATE EXPRESSION
         AIF       (NOT &SYM370).MCNOTOK
         CLI   F8INST+3(ACT),X'AF'      IS IT MC (MONITOR CALL) .Q
         BNE   NOT#MC                   NO, CHECK AGAINST 255
         TM    AEXP1,X'01'              IS SIZE 15 OR LESS .Q
         BZ    IPR1                     YES, GO AHEAD
         B     IMMERR                   NO, GO LOG OUT ERROR
NOT#MC   DS    0H                       NOT A 370 MC INSTRUCTION
.MCNOTOK ANOP
         TM    AEXP2,X'01'              IS SIZE OK
         BZ    IPR1                     IF 0, OK
IMMERR   BAL   SRR,ERRZRO               IMMEDIATE ERROR
         DC    AL2(ERRIMM)              IMMEDIATE FIELD ERROR
IPR1     MVC   F8INST+4(1,ACT),VALUEB+3 IMMEDIATE VALUE TO INSTRUCTION
         CLI   0(SP1),IBLANK            IS BLANK TERMINATING DELIMETER
         BE    MOPRTN                   IF YES, OK EXIT TO MLC
         B     DLMERR                   IF NOT, DELIMETER ERROR
X2PROC   ST    SRR,RRHOLD               X2 PROCESSOR ENTRY
         BAL   SRR,F8AREX               EVALUATE INDEX EXPRESSION
         TM    AEXP1,X'01'              IS SIZE OK
         BZ    X2PR1                    YES
         BAL   SRR,REGERR               NO, LOG REGISTER ERROR
X2PR1    TM    VALUEB+3,X'FF'           TEST IF DEFINED REGISTER
         BZ    X2PR1A                   IS NON-ZERO
         NI    ALIGNERR,X'FE'           YES, DON'T GIVE ALIGN ERROR
X2PR1A   OC    F8INST+4(1,ACT),VALUEB+3 INDEX VALUE TO INSTRUCTION
         CLI   0(SP1),ICOMMA            IS ENDING DELIMETER COMMA
         L     SRR,RRHOLD               LOAD EXIT
         BR    SRR                      EXIT TO CALLER
L1PROC   ST    SRR,RRHOLD               TEMP STORE EXIT
         BAL   SRR,F8AREX               EVALUATE L1
         TM    AEXP2,X'01'              IS THIS ABSOLUTE EXPRESSION & +
         BO    LLNERR                   IF 1, LENGTH ERROR
         L     GRY,VALUEB               EXPRESSION VALUE TO GRY
         S     GRY,K17                  TEST AGAINST LIMIT OF 16
L1L2L    BC    11,LLNERR                BRANCH ON ALL BUT NEGATIVE
         L     GRY,VALUEB               EXPRESSION VALUE TO GRY
         LTR   GRY,GRY                  TEST FOR ZERO
LDECSW   BC        *-*,L1PR1(*-*)      IF SS2 BR ON 0.  IF SS3 BR.
         BCTR  GRY,0                    IF NOT 0, DECREMENT BY 1
DONTZAP  ST    GRY,VALUEB               PUT BACK IN VALUE B
L1PR1    L     SRR,RRHOLD               LOAD EXIT
         CLI   0(SP1),ICOMMA            IS EXPRESSION DELIMETER COMMA
         BR    SRR                      EXIT TO CALLER
L2PROC   EQU   L1PROC                   L2 PROCESSOR SAME AS L1
         AIF       (NOT &RPQ67).RPQ67#3
*
WEIRDLEN ST        SRR,RRHOLD          SAVE RETURN ADDRESS
         BAL       SRR,F8AREX          EVALUATE THE LENGTH
         TM        AEXP1,X'01'         IS IT < 16 AND > 0 ?
         BO        LLNERR              NO
         L         GRY,VALUEB          PUT LENGTH IN GRY
         S         GRY,=F'5'           IS IT LESS THAN 5 ?
         BNM       LLNERR              IF NOT, LENGTH ERROR
         A         GRY,=F'4'           RESTORE TO IBM LENGTH
         BNM       DONTZAP             IF > 0, DON'T ZERO VALUE
         SR        GRY,GRY             OTHERWISE LEAVE TRUE ZERO
         B         DONTZAP
.RPQ67#3 ANOP
LPROC    ST    SRR,RRHOLD               L PROCESSOR, TEMP STORE EXIT
         BAL   SRR,F8AREX               EVALUATE L EXPRESSION
         TM    AEXP3,X'01'              IS THIS ABSOLUTE EXPRESSION & +
         BO    LLNERR                   IF 1, LENGTH ERROR
         L     GRY,VALUEB               EXPRESSION VALUE TO GRY
         S         GRY,K257256          TEST FOR LIMIT OF 256 OR 255
         B     L1L2L                    BRANCH TO COMMON PART LENGTH
S2D2A    ST    SRR,RRHOLD               S1 OR S2 OR D1 OR D2 ENTRY
         BAL   SRR,F8AREX               EVALUATE S OR D EXPRESSION
         TM    SREXP,X'01'              IS IT SIMPLY RELOCATABLE
         BO    S2D2AA                   IF ONE, TRY ABSOLUTE BRANCH
         BAL   SRR,DECOMP               YES, SIMPLY RELOCATABLE
*./      DELETE    SEQ1=09120020,SEQ2=09120020
         MVI   ABSFLG,X'00'            TURN ABSOLUTE FLAG OFF
         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2
         MVC   F8INST+5(2,ACT),BSTVAL+2  SET BASE AND DISPLACEMENT 2
         TM    SREXP,X'2D'              ANY ERROR TRAIL LEFT
         BZ    S2D2XT                   IF 0, NO
         BAL   SRR,S2ERR                IF YES, HUNT DOWN ERROR
S2D2XT   CLI   0(SP1),IBLANK            IS EXPRESSION DELIMETER BLANK
         L     SRR,RRHOLD               LOAD EXIT
         BR    SRR                      EXIT TO CALLER
S2D2AA   TM    AEXP3,X'01'               IS THIS ABSOLUTE
         BO    SSERRTST                HANDLE ERROR
         BAL   SRR,DECOMP              DECOMPOSE EXPRESSION VALUE
*./      DELETE    SEQ1=09380020,SEQ2=09380020
         MVI   ABSFLG,X'FF'            TURN ABSOLUTE FLAG ON
         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2
         MVC   F8INST+5(2,ACT),BSTVAL+2  SET B2 AND D2 IN INSTRUCTION
         TM    AEXP3,X'2D'              ANY ERROR TRAIL LEFT
         BZ    S2D2XT                   NO, SKIP TO COMMON ROUTINE
         BAL   SRR,D2ERR                YES, HUNT DOWN ERROR
         B     S2D2XT                   BRANCH TO COMMON ROUTINE
S1D1     ST    SRR,RRHOLD               TEMP STORE RETURN
         BAL   SRR,F8AREX               EVALUATE S1 OR D1
         TM    SREXP,X'01'              IS IT SIMPLY RELOCATABLE
         BO    S1D1AB                   NO
         BAL   SRR,DECOMP               DECOMPOSE EXPRESSION VALUE
*./      DELETE    SEQ1=09640020,SEQ2=09640020
         MVI   ABSFLG,X'00'            TURN ABSOLUTE FLAG OFF
         MVC   F8INST+9(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 1
         MVC   F8INST+5(2,ACT),BSTVAL+2 SET B1 AND D1 IN INSTRUCTION
         TM    SREXP,X'55'              ANY ERROR TRAIL LEFT
         BZ    S2D2XT                   NO, SKIP TO COMMON ROUTINE
         BAL   SRR,S1ERR                YES, HUNT DOWN ERROR
         B     S2D2XT                   BRANCH TO COMMON ROUTINE
S1D1AB   TM    AEXP3,X'01'               IS THIS ABSOLUTE
         BO    SSERRTST                HANDLE ERROR
         BAL   SRR,DECOMP              DECOMPOSE EXPRESSION VALUE
*./      DELETE    SEQ1=09860020,SEQ2=09860020
         MVI   ABSFLG,X'FF'             ABSOLUTE FLAG
         MVC   F8INST+9(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 1
         MVC   F8INST+5(2,ACT),BSTVAL+2 SET B1 AND D1 IN INSTRUCTION
         TM    AEXP3,X'55'              ANY ERROR TRAIL LEFT
         BZ    S2D2XT                   IF NONE, COMMON EXIT
SSERRTST BAL   SRR,D1ERR               IF ERROR, HUNT IT DOWN
         B     S2D2XT                   BRANCH TO COMMON EXIT
S2D2B    ST    SRR,RRHOLD               TEMP STORE EXIT
         BAL   SRR,F8AREX               EVALUATE S2 OR D2
         TM    SREXP,X'01'              IS THIS EXPRESSION SIMPLY RELOC
         BO    S2D2AB                   NO, TRY ABSOLUTE
         BAL   SRR,DECOMP               DECOMPOSE EXPRESSION VALUE
*./      DELETE    SEQ1=10120020,SEQ2=10120020
         MVI   ABSFLG,X'00'             ABSOLUTE FLAG
         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2
         MVC   F8INST+7(2,ACT),BSTVAL+2 SET B2 AND D2 IN INSTRUCTION
         TM    SREXP,X'2D'              ANY ERROR TRAIL LEFT
         BZ    S2D2XT                   NO, EXIT TO COMMON EXIT
         BAL   SRR,S2ERR                YES, HUNT ERROR
         B     S2D2XT                   EXIT TO COMMON EXIT
S2D2AB   TM    AEXP3,X'01'               IS THIS ABSOLUTE
         BO    SSERRTST                 IF NOT ABSOLUTE HANDLE ERROR
         BAL   SRR,DECOMP               DECOMPOSE EXPRESSION VALUE
*./      DELETE    SEQ1=10340020,SEQ2=10340020
         MVI   ABSFLG,X'FF'             ABSOLUTE FLAG
         MVC   F8INST+12(3,ACT),VALUEB+1 SET ABSOLUTE OPERAND 2
         MVC   F8INST+7(2,ACT),BSTVAL+2 SET B2 AND D2 IN INSTRUCTION
         TM    AEXP3,X'2D'              ANY ERROR TRAIL LEFT
         BZ    S2D2XT                   NO, GO TO COMMON EXIT
         BAL   SRR,D2ERR                YES, HUNT ERROR
         B     S2D2XT                   NOW GO TO COMMON EXIT
B1       ST    SRR,RRHOLD               SAVE RETURN
         BAL   SRR,F8AREX               EVALUATE EXPRESSION
         BAL   SRR,BXTEST               SEE IF LEGAL BASE
         MVC   F8INST+5(2,ACT),VALUEE+2 NON-DECOMPOSED ABS DISPLACEMENT
         MVO   F8INST+5(1,ACT),VALUEB+3(1) B1 VALUE TO INSTRUCTION
BXIT     L     SRR,RRHOLD               RESTORE RETURN ADDRESS
         CLI   0(SP1),IRPARN            IS NEXT CHAR A RIGHT PARN
         BNE   DLMERR                   NO, ERROR
         BR    SRR                      YES, EXIT
B2A      EQU   B1                       B2A AND B1 ARE DONE THE SAME
B2B      ST    SRR,RRHOLD               SAVE EXIT ADDRESS
         BAL   SRR,F8AREX               EVALUATE EXPRESSION
B2B1     BAL   SRR,BXTEST               SEE IF LEGAL BASE
         MVC   F8INST+7(2,ACT),VALUEE+2 NON-DECOMPOSED ABS DISPLACEMENT
         MVO   F8INST+7(1,ACT),VALUEB+3(1)   MOVE IN VALUE
         B     BXIT                     EXIT
***********************************************************************
***   F8AREX   ***
*ABSOLUTE AND SIMPLY RELOCATABLE EXPRESSION EVALUATOR AND CHECK
* THIS ROUTINE CALLS ON THE EXPRESSION EVALUATION SUBROUTINE (EEVAL)
* TO ACTUALLY EVALUATE THE EXPRESSION.  ONCE THE EXPRESSION IS
* EVALUATED, CHECKS ARE MADE FOR CERTAIN POTENTIAL ERRORS.  IF A
* POTENTIAL ERROR EXISTS, THAT BIT OF A TEST FLAG REMAINS ONE. IF
* A POTENTIAL ERROR IS ELIMINATED, THAT BIT OF A GIVEN TEST FLAG IS
* SET TO ZERO.
* TEST FLAGS ARE AS FOLLOWS.
*  AEXP1 REPRESENTS ABSOLUTE EXPRESSION OF VALUE LESS THAN   16
*  AEXP2 REPRESENTS ABSOLUTE EXPRESSION OF VALUE LESS THAN  256
*  AEXP3 REPRESENTS ABSOLUTE EXPRESSION OF VALUE LESS THAN 4096
*  SREXP REPRESENTS SIMPLY RELOCATABLE EXPRESSION
* BITS WITHIN FLAGS ARE AS FOLLOWS.
*  BIT7 = 0, VALID VALUE
*  BIT6 = 0, REGISTER REQUIREMENT MET
*  BIT5 = 0, ALIGNMENT CORRECT
*  BIT4 = 0, LITERAL IN SECOND OPERAND REQUIREMENT OK
*  BIT3 = 0, LITERAL IN FIRST OPERAND REQUIREMENT OK
*  BIT2      SPARE LATER TO BE USED FOR REENTRANT CHECK
*  BIT1      SPARE
*  BIT0      SPARE
***********************************************************************
F8AREX   MVI   EXFLGS,X'7F'             BIT 1 = 0, DONT CHECK REG
         B     F8RREX                   CHECK REGISTER VALIDITY
F8ARGX   MVI   EXFLGS,X'FF'             BIT 1 SET TO 1
F8RREX   MVC   EXFLGS+1(3),EXFLGS       INITIALIZE ABS AND RELOC FLAGS
         MVI   CREXPC,X'FF'        INITIALIZE COMPLEX OFF
         MVI   LTVLSW,X'00'             INITIALIZE LITERAL SWITCH
         XC    VALUEB(6),VALUEB         ZERO VALUE AND SIGN AND ESD-ID
         ST    SRR,HLDSRR               SAVE EXIT
         CLI   0(SP1),IEQUAL            CHECK FOR LITERAL
         BE    LTVL                     DO LITERAL EVALUATION
         SR    SP2,SP2
         L     SRB,CEEVAL(ACT)          EEVAL TABLE ADDRESS
         BALR  SRR,SRB                  DO EXPRESSION EVALUATION
LTVLXT   BC    8,AEXP                   IF ZERO, ABSOLUTE VALUE
         BC    4,JSREXP                 IF 1, SIMPLY RELOCATABLE EXPR
         BC    2,CREXP                  IF 2, COMPLEXLY RELOC EXPR
         BC    1,EREVAL                 IF 3, EXPRESSION ERROR
AEXP     LTR   GRY,SP2                  CURRENT EXP VALUE TEST NEGATIVE
         ST    GRY,VALUEB               EXPRESSION VALUE TO VALUEB
         TM    VALUEB,X'FF'             TEST FOR WRAP AROUND
         BM    EXWRAP                   IF MIXED, WRAP AROUND OCCURRED
         MVI   VALUEB,X'00'             ZERO FIRST BYTE OF VALUE
         SL    GRY,K16                  IF LESS THAN +16, OK
         BM    SEXP1
         L     GRY,VALUEB               EXPRESSION VALUE TO GRY
         SL    GRY,K256                 IS VALUE LESS THAN +256
         BM    SEXP2
         B     SEXP3                    ABSOLUTE EXPRESSION
EXWRAP   BAL   SRR,ERRZRO               ZERO INSTRUCTION AND LOG ERROR
         DC    AL2(ERRWRP)              WRAP AROUND ERROR CODE
         XC    VALUEB(4),VALUEB         ZERO VALUE
         B     SEXP3                    SET ABSOLUTE
JSREXP   NI    SREXP,X'FE'              SHUT OFF SIMPLY RELOC BIT
         MVC   VALUEB(6),0(SP2)         EXPRESSION VALUE, SIGN & ESD-ID
         B     PASSRE                   BRANCH PAST ABSOLUTE SETTINGS
SEXP1    NI    AEXP1,X'FE'              15 OK
SEXP2    NI    AEXP2,X'FE'              255 OK
SEXP3    NI    AEXP3,X'9E'              VALUE AND REENTRANT BITS OFF
         NI    SREXP,X'9F'              REENTRANT BITS OFF
PASSRE   LA    GRA,F8WORK(ACT)          ADDRESS OF FIRST BYTE OF TEXT
         TM    AEXP1,X'80'              IF BIT 1 IS ZERO,
         BZ    NONREG                   NO REGISTER TEST REQUIRED
         TM    TXASC(GRA),X'80'         TEST ASSEMBLER SWITCH CODE
         BZ    NOTFLT                   IF ZERO, NOT FLOATING POINT
         TM    TXASC(GRA),X'40'         TEST ASSEMBLER SWITCH CODE
         BO    TS0246                   IF ZERO, ONLY 0 OR 4 ALLOWED
         AIF       (NOT &RPQ67).RPQ67#4
         OI        TXASC(GRA),X'40'    NEXT REGISTER CAN BE 2 OR 6
.RPQ67#4 ANOP
         TM    VALUEB+3,X'FB'           TEST VALUE FOR OTHER THAN 4
         BZ    SET106                   IF ZERO, VALUE IS 0 OR 4
         B     DNTSET                   IF NOT, DONT SET
TS0246   L     GRZ,VALUEB               CURRENT EXPRESSION VALUE
*./      DELETE    SEQ1=12260020,SEQ2=12360020
         N         GRZ,FLOTMASK        TEST FOR 0, 2, 4, OR 6
         BZ        SET106              IF SO, OK
         B     DNTSET                   IF NONE OF THESE, DONT SET
NOTFLT   TM    TXASC(GRA),X'40'        CHECK IF EVEN REGISTER NEEDED
         BZ    SET106                   IF ZERO, EVEN NOT NECESSARY
         AIF       (NOT &SYM370).STAY1
         CLI   F8INST+3(ACT),X'0F'      IS IT MVCL OR CLCL
         BNH   DBLEVEN                  YES, DON'T RESET EVEN REGISTER
.STAY1   ANOP
         NI    TXASC(GRA),X'BF'         EVEN REGISTER ONLY IN 1 ST OPND
         AIF       (NOT &SYM370).STAY2
DBLEVEN  DS    0H
.STAY2   ANOP
         TM    VALUEB+3,X'01'           CHECK IF EXPRESSION VALUE EVEN
         BO    DNTSET                   IF 1, VALUE IS NOT EVEN
SET106   NI    AEXP1,X'FD'              SET REGISTER CHECK OK
DNTSET   L     SRR,HLDSRR               LOAD EXIT ADDRESS
         BR    SRR                      EXIT
NONREG   TM    TXASC(GRA),X'30'        TEST FOR ALIGNMENT NECESSARY
         BZ    WORDAL                   IF 0, ALIGNMENT UNNECESSARY
         BO    DWALIN                   BOTH 1, DOUBLE WORD ALIGNMENT
         TM    TXASC(GRA),X'20'        IF 1, WORD ALIGNMENT NECESSARY
         BZ    HWALIN                   IF 0, HALF WORD ALIGNMENT NEEDD
FWALIN   TM    VALUEB+3,X'03'           TEST LOW TWO BITS OF VALUE
         BZ    WORDAL                   IF ZERO, WORD ALIGNED
         B     LITTST                   IF NOT ALIGNED, ERROR
DWALIN   TM    VALUEB+3,X'07'           TEST LOW THREE BITS OF VALUE
         BZ    WORDAL                   IF ZERO, DOUBLE WORD ALIGNED
         B     LITTST                   IF NOT ALIGNED, ERROR
HWALIN   TM    VALUEB+3,X'01'           TEST LOW BIT OF VALUE
         BZ    WORDAL                   IF ZERO, HALF WORD ALIGNED
         B     LITTST                   IF NOT ALIGNED, ERROR
WORDAL   NI    SREXP,X'FB'              ALIGNMENT OK
         NI    AEXP3,X'FB'              ALIGNMENT OK
LITTST   TM    TXASC(GRA),X'02'        IS LITERAL OK IN 2ND OPND
         BZ    SAX04                    IF ZERO, LITERAL NOT PERMITTED
SAX00    NI    SREXP,X'D7'              REENTRANT AND LITERAL OK 2ND
         NI    AEXP3,X'D7'              REENTRANT AND LITERAL OK 2ND
SAX01    TM    TXASC(GRA),X'01'        IS LITERAL OK IN 1ST OPND
         BZ    SAX05                    IF ZERO, LITERAL NOT PERMITTED
SAX02    NI    SREXP,X'AF'              REENTRANT AND LITERAL OK 1ST
         NI    AEXP3,X'AF'              REENTRANT AND LITERAL OK 1ST
         B     DNTSET                   EXIT
SAX04    TM    CTRENTI(ACT),X'20'       IS RE-ENTRANT CHECK NEEDED .Q
         BZ    SAX040                   IF ZERO, NO
         CLC   CTNDID+1(1,ACT),VALUEB+5 NEXT DSECT ESD-ID VS THIS ESD
         BNL   SAX04A                   IF NOT LOWER, CSECT OR COMMON
SAX040   NI    AEXP3,X'9F'              IF HI, REENTRANT
         NI    SREXP,X'9F'              IF HI REENTRANT
SAX04A   TM    LTVLSW,X'FF'             IS THIS A LITERAL
         BNE   SAX04B                   IF NOT 0, LITERAL SKIP SETTING
         NI    SREXP,X'F7'              IF 0, NO LITERAL, TURN OFF ERR
SAX04B   B     SAX01                    CHECK FOR 1ST OPERAND
SAX05    TM    CTRENTI(ACT),X'20'       IS RE-ENTRANT CHECK REQUIRED .Q
         BZ    SAX050                   IF ZERO, NO
         CLC   CTNDID+1(1,ACT),VALUEB+5 NEXT DSECT ESD-ID VS THIS ESD-I
         BNL   SAX05A                  IF NOT LOWER, CSECT OR COOMMON
SAX050   NI    AEXP3,X'9F'              IF HIGH, REENTRANT
         NI    SREXP,X'9F'              IF HI, REENTRANT
SAX05A   TM    LTVLSW,X'FF'             IS THIS A LITERAL
         BNE   SAX05B                   YES, SKIP SETTING
         NI    SREXP,X'EF'              NO, TURN ERROR BIT OFF
SAX05B   B     DNTSET                   EXIT
CREXP    SR    GRZ,GRZ                  SET THE
         ST    GRZ,VALUEB               VALUE ZERO
         ST    GRZ,CREXPC               AND SET COMPLEX ON
         MVI   AEXP1,1                  JUST RELOCATABILITY ERROR
         MVI   AEXP2,1                  JUST RELOCATABILITY ERROR
         MVI   AEXP3,1                  JUST RELOCATABILITY ERROR
         MVI   SREXP,1                  JUST RELOCATABILITY ERROR
         B     DNTSET
***********************************************************************
***   DCCOMP   ***
* THIS IS THE ENTRY TO DECOMP ROUTINE WHEN ENTERED FROM OTHER CONTROL
* SECTIONS
***********************************************************************
DCCOMP   STM   SRB,SRR,F8REGS           STUFF RETURN AND RETURN BASE
         STC   SP1,AEXP3                STORE ABSOLUTE, RELOCATABLE FLG
         LR    SP1,GRY
         TM    AEXP3,X'01'              TEST IT
         BNE   DCCM01                   IF ONE RELOCATABLE
         ST    SP2,VALUEE               PUT ABSOLUTE VALUE
         LA    SP2,VALUEE               PICK UP ITS ADDRESS
DCCM01   MVC   VALUEB(6),0(SP2)         EXPRESSION VALUE, SIGN & ESD-ID
         BAL   SRR,DECOMP               GO TO DECOMPOSE ROUTINE
         L     SP2,BSTVAL               DECOMPOSED VALUE TO SP2
         LM    SRB,SRR,F8REGS           RESTORE RETURN AND RETURN BASE
         BR    SRR                      RETURN TO EXTERNAL PROGRAM
***********************************************************************
***   DECOMP   ***
* THIS ROUTINE DECOMPOSES BOTH ABSOLUTE AND RELOCATABLE VALUES WHENEVER
* POSSIBLE.  WHEN NOT POSSIBLE A RELOCATABILITY ERROR IS NOTED.
***********************************************************************
DECOMP   SR    GRZ,GRZ                  ZERO REGISTER
         MVI   DCMPSW,X'00'             SET NO REGISTER SWITCH
         MVC   TEMVAL(4),VALUEB        SAVE VALUE FOR FUTURE USE
         L     GRC,USNGPP(ACT)         USING TABLE FLAGS POINTER
         L     GR2,USNGTP(ACT)         USING TABLE POINTER
         STC   GRZ,BSTREG               ZERO BEST REGISTER
         TM    AEXP3,X'01'
         BZ    DCMP01                   IF ZERO, ESD-ID IS ZERO
         IC    GRZ,5(SP2)               IF NOT, FETCH ESD-ID
         STC   GRZ,VALUEB              ESD-ID TO FIRST BYTE
         MVC   VALUEE(4),VALUEB         VALUE AND ESD-ID
         MVC   BSTVAL(4),BYTES3         HIGHST POSSIBLE RELOC VAL
         B     DCMP0A                   BRANCH AROUND ABSOLUTE SETTING
DCMP01   L     GRZ,VALUEB              ESD-ID AND VALUE
         ST    GRZ,VALUEE
         LR    GRY,GRZ                 ESDID AND VALUE
         N     GRY,BYTES3               DROP LEADING BYTE
         ST    GRY,BSTVAL               FOR INITIAL VALUE
DCMP0A   LA    GRA,16                   COUNTER
         SR    GRB,GRB                  USINGP INDEX
         SR    GR1,GR1
DCMP02   SR    GRD,GRD                  ZERO REGISTER
         L     GRC,USNGPP(ACT)          ADDR OF USNG TABLE POINTERS
         IC    GRD,0(GRB,GRC)           ONE OF 16 USING TABLE INDICATOR
         LTR   GRD,GRD                  IS THIS REGESTER BEING USED
         BZ    DCMP03                   IF ZERO, NOT USING
         IC    GRD,0(GR1,GR2)          INPUT USING ESD-ID
         SR    GR0,GR0                  ZERO REGISTER ZERO TO LOSE JUNK
         IC    GR0,VALUEB               ESD-ID THIS VALUE
         SR    GRD,GR0                  USING ESD VS THIS ESD
         BNE   DCMP03                  IF NOT EQUAL, SKIP IT
         L     GRZ,VALUEE
         L     GRC,LITWRK               WITHIN LITERAL POOL
         L     GR2,USNGTP(ACT)
         SL    GRZ,0(GR1,GR2)           VALUE & ESD-ID IN USING TABLE
         N     GRZ,BYTES3               DROP LEADING BYTE
         CL    GRZ,BSTVAL               SEE IF THIS IS THE BEST VALUE
         BH    DCMP03                   IF HI, NO GOOD
         OI    DCMPSW,X'FF'             SET REGISTER POSSIBILITY
         ST    GRZ,BSTVAL               IF NOT, KEEP BEST VALUE
         STC   GRB,BSTREG               KEEP AS BEST REGISTER
DCMP03   BCT   GRA,DCMP06
         TM    DCMPSW,X'FF'             HAS A POSSIBLE REGISTER FOUND
         BZ    DCMP09                   CHECK FOR ABSOLUTE
DCMP04   L     GRZ,BSTVAL               TAKE BEST VALUE TO DATE
         SL    GRZ,FOR096               1 TOO BIG FOR DISPLACEMENT
         BM    DCMP05                   IF NEGATIVE GO TO ENDOFF
DCMPER   SR    GRZ,GRZ                  IF NOT, ERROR
         ST    GRZ,BSTVAL               ZERO BEST VALUE
         STC   GRZ,BSTREG               ZERO BEST REGISTER
         TM    CTSCON(ACT),X'08'        IS IT S-CON CALL TO DECOMP .Q
         BZ    DCMPER1                  BRANCH IF NOT
         OI    CTSCON(ACT),X'04'        YES, INDICATE ADDRESSING ERROR
         B     DCMP05                   FOR S-CON ROUTINE
DCMPER1  ST    SRR,HLDSRR               SAVE RETURN
         BAL   SRR,ERRZRO              ADDRESSABILITY ERROR
         DC    AL2(ERRADR)             ADDRESSABILITY ERROR
         L     SRR,HLDSRR               RESTORE RETURN ADDRESS
DCMP05   IC    GRZ,BSTREG               REGISTER
         SLL   GRZ,4                    POSITION FOR MERGE
         STC   GRZ,BSTREG
         OC    BSTVAL+2(1),BSTREG       COMBINE BASE AND REGISTER
         MVC   VALUEB(4),TEMVAL        RESTORE VALUE TO VALUEB
         BR    SRR                      ERROR EXIT FROM SUBROUTINE
DCMP06   LA    GRB,1(GRB)              NEXT USINGP
         LA    GR1,4(GR1)               NEXT USING VALUE
         B     DCMP02                   DO NEXT
DCMP09  TM    VALUEB,X'FF'             IS VALUE ABSOLUTE
         BNE   DCMPER                   IF NOT 0, DECOMP ERROR
         L     GRZ,BSTVAL               BEST VALUE TO REGISTER
         S     GRZ,FOR096               CHECK SIZE OF ABLOLUTE
         BM    DCMP05                   IF OK CONTINUE
DESPER   SR    GRZ,GRZ                  DELPLACEMENT ERROR
         ST    GRZ,BSTVAL               ZERO BEST VALUE
         STC   GRZ,BSTREG               ZERO BEST REGISTER
         ST    SRR,HLDSRR               SAVE RETURN REGISTER
         BAL   SRR,ERRZRO               LOG DISPLACEMENT ERROR
         DC    AL2(ERRDIS)              VALUE FOR DISPLACEMENT
         L     SRR,HLDSRR               LOAD RETURN ADDRESS
         B     DCMP05                   FINISH OFF ROUTINE
***********************************************************************
***************LITERAL EVALUATION ROUTINE******************************
***** THIS ROUTINE MERELY SCANS FOR NEXT OPERAND.  LEAVING SP1 POINTING
******AT THE DELIMETER IF ANY.  IT DOES A SYNTACTICAL ERROR SCAN AND
******FETCHES THE VALUE OF THE LITERAL AND ITS LENGTH.*****************
***********************************************************************
FAKE     B     2(SRR)                   SKIP AROUND LOG ERROR NUMBER
FAKEIT   DC    A(FAKE,FAKE)             CHANGED SO WE DONT LOG ERROR
LTVL     MVI   QUOTFLAG,X'00'           SET QUOTE FLAG EVEN
         TM    LITRLTWO,X'FF'           ANY PREVIOUS LITERAL THIS OPRND
         BNZ   LTVL13                   IF NOT 0, YES -- ERROR
         MVI   LITRLTWO,X'FF'           SET LITRL ENCOUNTERED SWITCH ON
         SR    GRB,GRB                  SET PAREN FLAG BALANCED
         L     GRC,F8OPRN(ACT)          ADDR OF OPRN
         SR    GRD,GRD                  ZERO REGISTER
         BCTR  GRC,0                    POINTER TO OPRN LENGTH
         IC    GRD,0(GRC)               INPUT PPRN LENGTH
         A     GRD,F8OPRN(ACT)          COMPUTE END OF OPRN
         LR    GRX,GRD                  TEMP SAVE
LTVL01   SR    GRD,SP1                  IS POINTER AT END
         BM    LTVLERR                  IF NEGATIVE, YES, ERROR
         CLI   0(SP1),ILPARN            IS THIS CHAR A LEFT PAREN
         BE    LTVLP2                   IF YES, PROCESS THAT TYPE LITR
         CLI   0(SP1),IQUOTE            IS THIS CHAR A QUOTE
         BE    LTVLQ1                   IF COMMA, PROC THAT KIND LITR
         LA    SP1,1(SP1)               IF NOT POINT AT NEXT CHAR
         LR    GRD,GRX                  GET END OF OPERAND ADDRESS
         B     LTVL01                   TRY AGAIN
LTVLP2   LA    SP1,1(SP1)               POINT AT CHAR AFTER LEFT PAREN
         MVC   FAKEIT,CLOGER(ACT)       CHANGE SO LOG ERROR DOESNT
         MVC   CLOGER(4,ACT),FAKEIT+4     LOG ERROR BUT JUST RETURNS
         L     SRB,CEEVAL(ACT)          ADDRESS OF EXPRESSION EVAL RTN
         BALR  SRR,SRB                  EVALUATE EXPRESSION
         MVC   CLOGER(4,ACT),FAKEIT     RESTORE LOG ERROR EXIT
         LTR   SP1,SP1                  HAS CATASTROPHIC ERROR OCCURRED
         BZ    CTRTRN(ACT)              IF ZERO ALL THRU
         CLI   0(SP1),ICOMMA            DID EXPRESSION END WITH COMMA
         BE    LTVLP2                   IF SO, DO AGAIN
         CLI   0(SP1),IRPARN            DID EXPRESSION END WITH RT PARN
         BNE   DLMERR                   IF NOT, DELIMETER ERROR
LTVLCOMN LA    SP1,1(SP1)               COMMON EXIT, BUMP OPERAND PTR
         CLI   0(SP1),ICOMMA            IS LITERAL DELIMETER COMMA
         BE    LTVL10                   IF SO, OK TO EXIT
         CLI   0(SP1),IBLANK            IS LITERAL DELIMETER A BLANE
         BE    LTVL10                   IF SO, OK TO EXIT
         B     DLMERR                   IF NOT, DELIMETER ERROR
LTVLQ1   XI    QUOTFLAG,X'FF'           TURN ON QUOTFLAG
         B     LTVLQ5                   CHECK NEXT CHARACTER
LTVLQ2   CLI   1(SP1),IQUOTE            IS DOUBLE QUOTE PRESENT
         BE    LTVLQ3                   IF SO, UP OPRN POINTER
         XI    QUOTFLAG,X'FF'           FLIP ODD QUOTE FLAG
         B     LTVLQ4                   DONT SKIP OVER QUOTE
LTVLQ3   LA    SP1,1(SP1)               SKIP OVER QUOTE
LTVLQ4   TM    QUOTFLAG,X'FF'           IS QUOTE STRING ENDED
         BZ    LTVLCOMN                 IF ZERO, ENDED
LTVLQ5   LA    SP1,1(SP1)               IF NOT BUMP TO NEXT CHARACTER
         LR    GRD,GRX                  ADDRESS OF END OF OPERAND
         SR    GRD,SP1                  HAVE WE GONE TOOO FAR
         BM    LTVLERR                  IF NEGATIVE, YES
         CLI   0(SP1),IQUOTE            IF POSITIVE, IN NEXT CHAR QUOTE
         BE    LTVLQ2                   IF SO, CHECK FOR DOUBLES AGAIN
         B     LTVLQ5                   IF NOT, TRY NEXT CHARACTER
LTVLERR  SR    SP1,SP1                  ZERO OPERAND POINTER
         TM    *+1,X'FF'                SET CONDITION CODE FOR ERROR
         B     LTVLXT                   EXIT TO F8AREX
LTVL10   L     GRB,CTXABP(ACT)          PTR TO APPEND FIXED FIELD
*./      DELETE    SEQ1=16940020,SEQ2=16940020
         MVC   LITWRK+1(3),TXLDSP(GRB)  GET LITERAL DISPLACEMENT
         L     GRC,LITWRK               WITHIN LITERAL POOL
         SR    GRD,GRD
         IC    GRD,TXLSTG(GRB)          GET LITERAL STRING NO
         L         SP2,LATP(ACT)       POINT TO LAT
         LTR       SP2,SP2             IF NO TABLE, NO LITERALS
         BZ        LTVLERR
         AR        GRD,SP2             POINT AT LITERAL STRING
         MVC   LITWRK+1(3),1(GRD)       GET ADJUSTMENT
         MVC   LITID(1),0(GRD)          SET ESD
         A     GRC,LITWRK               GET ADJUSTED ADDRESS
         ST    GRC,LITWRK               FOR MAIN LINE
         LA    SP2,LITWRK               POINTER TO VALUE FOR MAIN LINE
         SR    GRC,GRC
         IC    GRC,TXLLEN(GRB)          GET EENGTH ATTRIBUTE
         STH   GRC,STLONG(ACT)          SET LENGTH ATTRIBUTE FOR MLC
LTVL12   LCR   GRC,GRC                  SET CC=4 FOR MAIN LINE
         MVI   LTVLSW,X'FF'             SET LITERAL SWITCH FOR MLC
         B     JSREXP                   TAKE SIMPLY RELOCATABLE BRANCH
LTVL13   BAL   SRR,ERRZRO               LOG AN ERROR
         DC    AL2(ERRLIT)              INVALID LITERAL USAGE
         B     LTVLERR                  EXIT
LITWRK   DC    F'0'                     FULL WORD ALIGNED FOR
         DC    X'0'                        LITERAL WORK AREA
LITID    DC    X'0'                     LITERAL ESD/ID
SETSEC   STC   SP2,WORDBB               CURRENT ESD-ID
         CLC   WORDBB(1),0(SP1)         COMP. TO ADJ TABLE ENTRIES
         BE    SECFND                   FOUND, BRANCH OUT
         LA    SP1,4(SP1)               NOT FOUND, BUMP BY 4
         L     GRX,CTADJEND(0,ACT)      END OF TABLE + 1
         CR    GRX,SP1                  IS TABLE EXHAUSTED
         BNH   SETSEC                   EXIT WHEN TABLE EXHAUSTED
         L     SP2,CTZERO(ACT)          ZERO CELL TO SHOW ERROR
         BR    SRR                      ERR O
SECFND   L     SP2,BYTES3               0FFF FOR MASK
         N     SP2,0(SP1)               EXTRACT CSECT ORG
         ST    SP2,F8CADJ(ACT)          STORE
         MVC   F8INST(3,ACT),F8CADJ+1(ACT)
         BR    SRR                      RETURN
DLMERR   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRDLM)             DELIMETER ERROR
MOPRTN   TM    ALIGNERR,X'03'           TEST IF ANY ALIGN ERROR
         BNO   MOPRTA                   BRANCH IF NO
         MVI   ALIGNERR,X'01'           RESET ALIGN ERROR
         BAL   SRR,ERRNO0               ALIGNMENT ERROR
         DC    AL2(ERRLIN)              ALIGNMENT ERROR
MOPRTA   TM    ERRSW,X'FF'              CHECK FOR ANY ERROR FLAG
         BZ    DNTZRO                   IF ERRSW NOT ZERO, BYPASS
         XC    F8INST+3(12,ACT),F8INST+3(ACT) ZERO INST BLDG AREA
DNTZRO   B     CTRTRN(ACT)              RETURN TO MAIN LINE CONTROL
ERRZRO   MVI   ERRSW,X'FF'              SET SWITCH TO ZERO INSTRUCTION
ERRNO0   L     SRB,CLOGER(ACT)          LOGERR BASE AND ENTRY
         BR    SRB                      ENTER LOGERR
PROCER   BAL   SRR,ERRZRO              PROCEDURE ERROR
         DC    AL2(ERPROC)             PROCEDURE ERROR
         B     MOPRTN                  MACHINE OP PROCESSOR EXIT
EREVAL   MVI   ERRSW,X'FF'              EXPRESSION EVALUATION ERROR
         SR    GR0,GR0                  ZERO A REGISTER
         ST    GR0,EXFLGS               TURN OTHER ERRORS OFF
         LTR   SP1,SP1                  IS IT CATASTROPHIC
         BZ    MOPRTN                  IF ZERO,YES, ABORT
         B     DNTSET                   IF NO, CONTINUE
REGERR   ST    SRR,HOLDER               REGISTER ERROR, STORE RETURN
         BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRREG)             REGISTER ERROR
         L     SRR,HOLDER               RESTORE RETURN ADDRESS
         BR    SRR                      AND EXIT
LLNERR   BAL   SRR,ERRZRO               LENGTH ERROR
         DC    AL2(ERRLLN)             LENGTH ERROR
         B     L1PR1                    EXIT
S2ERR    ST    SRR,HOLDER               ERROR FLAGGED IN S2
S2LITR   TM    SREXP,X'08'              IS THERE A LITERAL IN 2ND OPERD
         BZ    S2RENT                   NO, OK
         MVI   LITRLTWO,X'00'           RESET 'ONE LIT ALREADY' SWITCH
         BAL   SRR,ERRZRO               ERROR
         DC    AL2(ERRLIT)             LITERAL ERROR
S2RENT   TM    SREXP,X'20'              REENTRANT CHECK
         BZ    SXRLOC                   OK, GO ON
SXRENT   BAL   SRR,ERRNO0               REENTRANT ERROR
         DC    AL2(ERRENT)             REENTRANT ERROR
SXRLOC   TM    SREXP,X'01'              RELOCATABILITY ERROR
         BZ    TERORL                   IF ZERO, RELOCATABILITY OK
         BAL   SRR,ERRZRO               NOT, LOG ERROR
         DC    AL2(ERRDIS)              DISPLACEMENT ERROR
TERORL   TM    AEXP3,X'04'              IS ALIGNMENT OK
         BZ    S2ERXT                   YES, GO ON
         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM
         TM    L1PBYT1(SRR),X'01'       IS ALIGN OPTION ON .Q
         BO    ERORL                    YES, GO LOG IT
         LA    SRR,ALBEG                GET ALIGN OP-TABLE START
         LA    GR1,ALEND-ALBEG          GET TABLE LENGTH
         LA    GRA,F8WORK(ACT)          RESTORE GRA
         IC    GR2,TXHEX(,GRA)          GET HEX OP-CODE
ALEX     EX    GR2,ALCOMP               DOES OP REQUIRE ALIGNMENT
         BE    ERORL                    YES, GO LOG IT
         LA    SRR,1(,SRR)              STEP TO NEXT OP
         BCT   GR1,ALEX                 LOOP UNTIL TABLE SCANNED
         B     S2ERXT                   EXIT IF NO ALIGN REQUIRED
ALCOMP   CLI   0(SRR),0                 DUMMY COMPARE
*./      DELETE    SEQ1=18500020,SEQ2=18520020
ERORL    MVI   ALIGNERR,X'03'           POSSIBLE ALIGNMENT ERROR
S2ERXT   L     SRR,HOLDER               S2 ERROR EXIT
         BR    SRR                      RETURN
S1ERR    ST    SRR,HOLDER               ERROR FLAGGED IN S1
S1LITR   TM    SREXP,X'10'              IS A LITERAL IN 1ST OPERAND OK
         BZ    S1RENT                   YES, CONTINUE
         MVI   LITRLTWO,X'00'           RESET 'ONE LIT ALREADY' SWITCH
         BAL   SRR,ERRZRO               LITERAL ERROR
         DC    AL2(ERRLIT)             LITERAL ERROR
S1RENT   TM    SREXP,X'40'              REENTRANT CHECK
         BZ    SXRLOC                   OK
         B     SXRENT                   LOG ERROR
D2ERR    ST    SRR,HOLDER               DISPLACEMENT IN 2ND OPERAND CHK
D2RENT   TM    AEXP3,X'20'              REENTRANT CHECK
DXRENT   BZ    D2RLOC                   OK
         BAL   SRR,ERRNO0               REENTRANT ERROR
         DC    AL2(ERRENT)             REENTRANT ERROR
D2RLOC   TM    AEXP3,X'01'              ABSOLUTE VALUE CHECK
         BZ    TERORL                   IF ZERO, ABSOLUTE VALUE OK
         BAL   SRR,ERRZRO               NOT LOG ERROR
         DC    AL2(ERRDIS)              DISPLACEMENT ERROR
         TM    CREXPC,X'FF'             IS THIS COMPLEXLY RELOCATABLE
         BNZ   TERORL                   IF NOT COMPLEXLY RELOC, NOT ERR
         BAL   SRR,ERRZRO               LOG THE ERROR
         DC    AL2(ERRLOC)              RELOCATABILITY ERROR
         B     TERORL                   TRY NEXT ERROR TEST
D1ERR    ST    SRR,HOLDER               DISPLACEMENT IN 1ST OPERAND CHK
         TM    AEXP3,X'40'              REENTRANT CHECK
         B     DXRENT
BXTEST   ST    SRR,HOLDER               BASE TEST ... SAVE RETURN
         TM    AEXP1,X'01'              IS IT VALID VALUE .LT. 16
         BO    BXERR2                   IF NOT 0, ERROR
         TM    VALUEB+3,X'FF'           TEST IF DEFINED REGISTER
         BZ    GOON1                    IS NON-ZERO
         NI    ALIGNERR,X'FE'           YES, DON'T GIVE ALIGN ERROR
GOON1    CLI   ABSFLG,X'FF'             IS IT ABSOLUTE .Q
         BNE   BXERR1                   IF NOT ABSOLUTE, ERROR
         L     SRR,VALUEE               GET VALUE
         C     SRR,K4096                SET CC DEPENDING UPON SIZE
         BL    BXEXIT                   SCRAM IF OK
*./      DELETE    SEQ1=19240020,SEQ2=19280020
         TM        ERRSW,X'FF'         WAS THERE AN EXPRESSION EVAL ERR
         BO        BXEXIT              OMIT THIS ERROR MESSAGE IF SO
BXERR1   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRDIS)              DISPLACEMENT ERROR
         B     BXEXIT                   EXIT
BXERR2   BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRREG)             REGISTER ERROR
BXEXIT   L     SRR,HOLDER               RESTORE EXIT ADDRESS
         BR    SRR                      AND EXIT
LENERR   DS    0H
         CLC   BYTES2(2),STLONG(ACT)    WAS IMPLIED LENGTH ZERO .Q
         BCR   8,SRR                    USE ZERO IF SO
         ST    SRR,HOLDER               SAVE RETURN ADDRESS
         BAL   SRR,ERRZRO               LOG ERROR
         DC    AL2(ERRLEN)              IMPLIED LENGTH ERROR
         L     SRR,HOLDER               RESTORE RETURN ADDRESS
         BR    SRR                      AND EXIT
*./      DELETE    SEQ1=19540020,SEQ2=19580020
         ENTRY DCCOMP                   DE COMPILE - EXTERNAL
         ENTRY DECOMP                   DE COMPILE - INTERNAL
         ENTRY F8AREX                   EVALUATE EXPRESSION
KTWO     DC    F'2'                     CONSTANTS - 2
K16      DC    F'16'                               16
K17      DC    F'17'                    SEVENTEEN FOR LENGTH COMPARE
K240     DC    F'240'                             240
K256     DC    F'256'                   FULL WORD VALUE 256
K257256  DC        A(256+*-*)          257 OR 256
K4095    DC    F'4095'                           4095
K4096    DC    F'4096'                 CONSTANT DECIMAL 4096
BYTES3   DC    X'00FFFFFF'             THREE BYTE MALK
BYTES2   EQU       BYTES3+2             SIXTEEN BINARY ONES
FLOTMASK DC        X'FFFFFFF9'         MASK FOR FLOAT REG TEST
F8REGS   DS    16F                      SAVE AREA FOR DCCOMP
WORDBB   DC    F'0'                     SAVE FOR CURRENT ESD
HLDSRR   DC    F'0'                     SAVE AREA FOR RETURN
HOLDER   DC    F'0'                     SAVE AREA FOR ERROR RETURN
RRHOLD   DC    F'0'                     SAVE AREA FOR RETURN
*./      DELETE    SEQ1=19940020,SEQ2=19940020
CREXPC   DC    F'0'                     COMPLEX SWITCH
DCMPSW   DC    X'00'                    DECOMPOSABILITY SWITCH
ALIGNT   DS    F                        TEMP FOR ALIGNMENT
BSTVAL   DS    F                        BEST VALUE FOR BASE
VALUEE   DS    F                       TEMPORARY VALUE AND ESD-ID
VALUEZ   DS    F
TEMVAL   DC    F'0'                    TEMPORARY STORAGE SLAQUE
EXFLGS   DS    0F                       FLAGS FOR F8AREX
AEXP1    DC    X'00'                      SEE F8AREX FOR THE
AEXP2    DC    X'00'                        MEANING OF THESE FLAGS
AEXP3    DC    X'00'                          AND THE MEANING OF THE
SREXP    DC    X'00'                            BITS WITHIN THE FLAGS
VALUEB   DC    F'0'                    EXPRESSION VALUE
EXPESD   DC    X'0000'                  EXPRESSION SIGN AND ESD-ID
ABSFLG   DC    X'00'                    ABSOLUTE FLAG
LTVLSW   DC    X'00'                    LITERAL SWITCH
BITS45   DC    X'0C'                    BITS 4 AND 5
F8FF     DC    X'FF'                    ONE BYTE OF ONES
RENTERR  DC    X'00'                    REENTRANT ERROR FLAG
RENTRANT DC    X'FF'                    REENTRANT FLAG
QUOTFLAG DC    X'00'                    QUOTE FLAG 0 = EVEN
BSTREG   DS    C                        BEST BASE REG FOR LOWEST DISP
ABSRX    DS    C                        ABSOLUTE SWITCH
ERRSW    DC    X'00'                   ERROR SWITCH FOR ZEROING INST
LITRLTWO DC    X'00'                    MULITPLE LITERAL SWITCH
ALIGNERR DC    X'01'                    BIT7=1  NO REGISTER SPECIFIED
*                                       BIT6=1  ALIGN ERROR PENDING
ALBEG    EQU   *                        START REQUIRED ALGN TABLE
         DC    X'47'                    BC
         DC    X'45'                    BAL
         DC    X'46'                    BCT
         DC    X'44'                    EX
         DC    X'86'                    BXH
         DC    X'87'                    BXLE
         DC    X'82'                    LPSW
ALEND    EQU   *                        END REQUIRED ALIGN TABLE
ERRIMM   EQU   20                      IMMEDIATE FIELD ERROR
ERRDLM   EQU   39                       INVALID DELIMITER
ERRLIN  EQU   33                        ALIGNMENT ERROR
ERRREG   EQU   10                       INCORRECT REGISTER
ERRLLN   EQU   3                        LENGTH ERROR
ERRLIT  EQU   15                        INVALID LITERAL USAGE
ERRENT   EQU       58                  RE-ENTRANCY VIOLATION
ERRLOC   EQU   25                       RELOCATABILITY
ERRDIS  EQU   8                         INVALID DISPLACEMENT
ERRLEN   EQU   3                        LENGTH
ERRWRP   EQU   7                        WRAP AROUND ERROR CODE
LATP     EQU   CTXWAP                   POINTER TO LITERAL ADDRESS TABL
USNGPP   EQU   CTXIO3                   I/O BUFFER 3
USNGTP   EQU   CTXIO4                   I/O BUFFER 4
ERPROC   EQU   80                       ILLEGAL START CARD
ERRADR   EQU   35                       ADDRESSABILITY
SXTEEN   EQU   K16                      CONSTANT OF 16
FOR095   EQU   K4095                    CONSTANT OF 4095
FOR096   EQU   K4096                    CONSTANT OF 4096
         LTORG
         END   ASMGF8M
./ ADD NAME=ASMGF8N
F8N      TITLE     'ASMG F8  FLOATING-FIXED POINT CONVERSION'
         ISEQ      73,78
ASMGF8N  START     ,                    DECIMAL CONVERSION ROUTINE
         PRINT      NOGEN
         FDIMEN
         PRINT GEN
*                                                                     *
*TITLE 'ASMGF8N ' ...  FIXED-FLOATING POINT CONVERSION                *
*FUNCTION/OPERATION-                                                  *
*   TO DO ALL FIXED OR FLOATING POINT CONVERSION FOR DC STATEMENTS. IT*
*   IS CALLED BY ASMGF8D ONCE FOR EACH CONSTANT TO BE CONVERTED.      *
*ENTRY POINT- ASMGF8N                                                 *
*  ASMGF8N IS CALLED VIA                                              *
*        L     SRB,CCONV(ACT)           GET BASE/ENTRY                *
*        BALR  SRR,SRB                  CALL ASMGF8N                  *
*INPUT- TWO REGISTERS ARE USE FOR INPUT                               *
*   (1)  ZWRB  POINTS TO FIRST CHAR OF STRING TO BE CONVERTED         *
*   (A)  SP1   POINTS TO DC WORKBUCKET                                *
*OUTPUT- THREE REGISTERS ARE USED FOR OUTPUT                          *
*   (1)  ZWRB  POINTS TO CHAR TERMINATING FIELD                       *
*   (B)  SP2   POINTS TO BINARY CONVERTED VALUE                       *
*   (D)  GRZ   POINTS TO BYTE CONTAINING ERROR NUMBER                 *
*                  0 - NO ERROR                                       *
*                 11 - SCALE MODIFIER                                 *
*                 13 - EXPONENT MODIFIER                              *
*                 17 - TRUNCATION                                     *
*                 39 - INVALID DELIMITER                              *
*                 70 - FLOATING POINT CHARACTERISTIC OUT OF RANGE     *
*                109 - PRECISION LOST                                 *
*EXTERNAL ROUTINES- NONE                                              *
*EXITS- NORMAL AND ERROR                                              *
*    RETURN VIA                                                       *
*        BR    SRR                      EXIT                          *
*TABLES/WORKAREA                                                      *
*   ZWSVRG- SAVE AREA FOR REGISTERS B THROUGH E                       *
*   DCVW-   CONTAINS RESULTS OF CONVERSION                            *
*   HOLD-   CONTAINS PACKED NUMBER TO BE CONVERTED                    *
         EJECT
         USING *,SRB
*
*    INITIALIZATION
*
DCNVRT1  MVI   DCSW,0                   ZERO SWITCHES
         MVI   DCXPON,X'00'             SET SIGN POSITIVE
         MVC   DCXPON+1(5),TXDEXP(SP1)  GET EXP AND SCL MODF
         LH    GR2,DCSCAL               GET SCALE MODIFIER
CNV1     SRL   GR2,5                    SHIFT EXTRANEOUS BITS
         STH   GR2,DCSCAL               SAVE IN SCALE MODIFIER
         TM    TXDEXP(SP1),X'80'        TEST SIGN OF EXPONENT MODIFIER
         BZ    CNV2                     BRANCH IF PLUS
         MVI   DCXPON,X'FF'             SET SIGN NEGATIVE
CNV2     LH    GR2,DCVW                 GET LENGTH MODIFIER
         TM    TXDLMD(SP1),X'01'        IS LENGTH MODIFIER BITS
         BO    CNV3                     YES
         SLL   GR2,3                    NO,BYTES, SO SHIFT FOR BITS
CNV3     BCTR  GR2,0                    DECREMENT BY ONE
         STH   GR2,DCLNG+2              SAVE LENGTH MODIFIER
         CLI   TXDTYP(SP1),X'07'        TEST IF FIXED OR FLOATING
         BL    ZWFLCV                   BRANCH IF FLOATING
         CLI   TXDTYP(SP1),X'0E'        IS THIS L-CON
         BNE   ZWFXCV                     NO.  FIXED.
         MVI   ZWSW,X'09'                 YES. SET INDICATOR
         B     ZWA2                     GO INITIALIZE
*A
*A MOVE SCALE FACTOR AND EXPO MOD TO WORK AREA.CHECK RANGE OF FORMER
*A SAVE REGISTERS 11,13,14.INIT CONTROL SWITCHES(ZWSW) AND ACCUMULATOR
*A
ZWFLCV   MVI   ZWSW,X'01'          SET SWITCH FOR FLOATING POINT
ZWA2     SR    ZWRD,ZWRD           LOWER LIMIT SCALE FACTOR
         LA    ZWRE,30             UPPER LIMIT SCALE FACTOR
         B     ZWA1                     SKIP FIXED POINT SET UP
ZWFXCV   MVI   ZWSW,0              SET SWITCH FOR FIXED POINT
         LA    ZWRD,187            LOWER
         LCR   ZWRD,ZWRD             LIMIT SCALE FACTOR
         LA    ZWRE,346            UPPER LIMIT SF
ZWA1     LH    ZWRA,DCSCAL         SCALE FACTOR
         LH    ZWRH,DCXPON         EXPONENT MODIFIER
         STM   ZWRI,ZWRB,ZWSVRG    SAVE ABOVE,REGS 11-13,AND RETURN ADD
         XC    ZWACC,ZWACC         CLEAR ACCUMULATOR
         SR    ZWRL,ZWRL           PREPARE TO MARK DECIMAL POINT
         LR    ZWRF,ZWRB           SET UP FOR NO EXP DIGITS TEST
         LR    ZWRI,ZWRH           SAVE EXPONENT MODIFIER
*B
*B SCAN TEXT MARKING DECIMAL,END OF VALUE,FIRST TERMINATOR.
*B CONVERT EXPONENT IF ANY AND MODIFY.
*B
ZWB1     LR    ZWRJ,ZWRB           MARK END OF VALUE FIELD
         CLI   0(ZWRB),IE               BRANCH
         BNE   ZWB3                     IF CHARACTER NOT E
         LA    ZWRB,1(ZWRB)             STEP OVER E
         BAL   ZWRG,ZWS1           STEP OVER SIGN IF PRESENT
         BAL   ZWRG,DECON          CONVERT EXPONENT
         CLI   1(ZWRJ),IMINUS      BRANCH
         BNE   ZWB2                     UNLESS EXP NEGATIVE
         LCR   ZWRH,ZWRH           COMPLEMENT EXPONENT
ZWB2     AR    ZWRI,ZWRH           ADD TO EXP MODIFIER
         ST    ZWRI,ZWDE           STORE MODIFIED EXP
ZWB3     CLI   0(ZWRB),ICOMMA           BRANCH OUT
         BE    ZWC1                     IF CHAR COMMA
         CLI   0(ZWRB),IQUOTE           BRANCH OUT
         BE    ZWC1                     IF CHAR QUOTE
         CLI   0(ZWRB),IPRIOD           BRANCH
         BNE   ZWB4                     UNLESS CHAR DECIMAL POINT
         LR    ZWRL,ZWRB           MARK DECIMAL POINT
ZWB4     LA    ZWRB,1(ZWRB)             ADVANCE TEXT POINTER
         B     ZWB1                     CONTINUE LOOP
*C
*C SAVE POINTER TO TERMINATOR.CHECK EXPONENT AND SCALE FACTOR RANGE AND
*C CHECK FOR NO EXPONENT DIGITS. SET UP TO SCAN VALUE.
*C
ZWC1     ST    ZWRB,ZWAUXT              SAVE PTR TO TERMINATING CHAR
         LA    ZWRH,ZRCD13              SET NO. FOR EXP RANGE ERROR
         AH    ZWRI,=H'5'          MAKE RANGE SYMMETRIC
         LPR   ZWRI,ZWRI           TAKE MAGNITUDE
         CH    ZWRI,=H'80'         BRANCH
         BH    ZWZ3                     IF EXPONENT OUTSIDE RANGE
         LA    ZWRH,ZRCD11              SET NO. FOR SCL FAC RANGE ERROR
         CR    ZWRA,ZWRD           BRANCH
         BL    ZWZ3                     IF SF TOO SMALL
         CR    ZWRA,ZWRE           BRANCH
         BH    ZWZ3                     IF SF TOO LARGE
         CR    ZWRB,ZWRF           BRANCH TO ERROR ROUTINE
         BE    ZWZ4                     IF NO EXP DIGIT OR TEXT
         L     ZWRB,ZWTXPT         RESET TEXT POINT TO BEGINNING VALUE
         BAL   ZWRG,ZWS1           STEP OVER VALUE SIGN IF PRESENT
         LTR   ZWRL,ZWRL           IF NO DECIMAL
         BNZ   ZWD1                  SET MARK TO
         LR    ZWRL,ZWRJ             END OF VALUE
*D
*D STEP OVER DECIMAL POINT. CHECK FOR END OF VALUE.
*D
ZWD1     CR    ZWRB,ZWRL           IF NEXT CHAR
         BNE   ZWD2                     DECIMAL POINT
         LA    ZWRB,1(ZWRB)             ADVANCE VALUE POINTER
         LR    ZWRL,ZWRB             AND DECIMAL MARKER
ZWD2     CR    ZWRB,ZWRJ           IF END OF VALUE
         BNL   ZWM1                  BRANCH
         EJECT
*E
*E CONVERT PIECE OF VALUE.CHECK FOR ZERO.COMPUTE ADJUSTED EXP FOR PIECE
*E
ZWE1     BAL   ZWRG,DECON          CONVERT PIECE OF VALUE
         TM    VASCTL,X'C0'        IF ONE OR MORE DIGITS CONVERTED
         BZ    ZWE2                     AND NON-DIGIT REACHED, BRANCH
         TM    VASCTL,X'80'        IF NO DIGITS FOUND
         BO    ZWZ4                     BRANCH TO INVALID TERM. MESSAGE
         LA    ZWRB,9(ZWRF)        CORRECT VALUE POINTER
ZWE2     OI    ZWSW,X'02'          SET VALUE FOUND SWITCH
         LTR   ZWRD,ZWRH           COPY AND TEST VALUE
         BZ    ZWD1                     BRANCH IF ZERO
         LR    ZWRG,ZWRL           LOCATION DECIMAL
         SR    ZWRG,ZWRB             MINUS LOCATION CHAR AFTER FLD CNVT
         A     ZWRG,ZWDE             PLUS EXP GIVES ADJ EXP FOR THIS
*                                    PIECE OF VALUE
         TM    ZWSW,X'05'          BRANCH UNLESS FIRST NON-ZERO
         BNM   ZWG1                  PIECE FLOATING VALUE
*F
*F IF FLOATING PT COMPUTE WORKING SCALE FACTOR.
*F
         LCR   ZWRC,ZWRG           COMPLEMENT ADJ EXP
         MH    ZWRC,=HS13'3.322'   MULT BY LOG 10 BASE 2 (3.527 HEX)
         SRA   ZWRC,13             SCALE PRODUCT
ZWF1     BCTR  ZWRC,0              COUNT NUMBER BITS
         SRA   ZWRD,1                AND SUBTRACT
         BP    ZWF1                     FROM PRODUCT
         SRA   ZWRC,2              ROUND DOWN TO MULTIPLE OF 4
         SLA   ZWRC,2
         AH    ZWRC,=H'124'          AND ADD 124
         ST    ZWRC,ZWSF           STORE WORKING SCALE FACTOR
         OI    ZWSW,X'04'          SET FL PT INIT SWITCH
         LPR   ZWRF,ZWRC           IF WORKING SCALE FACTOR WILL
         CH    ZWRF,=H'400'          PRODUCE INVALID CHARACTERISTIC
         BH    ZWQ7                     BRANCH TO INVALID EXP MSG
*G
*G COMPUTE AMT OF BINARY SHIFT. SPLIT INTO WORD INDEX AND BIT SHIFT.
*G RESET WORKING AREA. TEST SIGN OF ADJ EXPONENT.
*G
ZWG1     LA    ZWRC,32             32
         AR    ZWRC,ZWRG             PLUS ADJ EXP
         A     ZWRC,ZWSF           PLUS SCALE FACTOR GIVES BIN SHIFT
* NOTE - ZWSF HAS S-MODIFIER VALUE IF F-, H-CON,
*             OR THE WORKING SCALE FACTOR IF L-, D-, OR E-CON.
         SRDA  ZWRC,5              SEPARATE INTO BIT AND WORD SHIFTS
         SRL   ZWRD,27             POSITION BIT SHIFT
         SLL   ZWRC,2              POSITION WORD SHIFT
         XC    ZWW1,ZWW1           CLEAR WORK AREA
         LTR   ZWRG,ZWRG           TEST ADJ EXP
         BNP   ZWI1                BRANCH IF ZERO OR NEG
         EJECT
*H
*H ADJ EXP IS PLUS.  MULTIPLY VALUE BY 5 TO THE GIVEN POWER.
*H
         ST    ZWRH,ZWW2           STORE VALUE
         LR    ZWRA,ZWRC           WORD SHIFT IN BYTES
         SH    ZWRA,=H'16'           LESS 16 = LEFT LIMIT OF WORK AREA
         BP    ZWJ8                     BRANCH IF LIMIT DEFINES NO WORK
ZWH1     SR    ZWRI,ZWRI           RESET WORK AREA POINTER
         SR    ZWRH,ZWRH           CLEAR CARRY REG
ZWH2     L     ZWRF,ZWW2(ZWRI)     LOAD PART OF VALUE
         M     ZWRE,=F'5'          TIMES 5
         ALR   ZWRF,ZWRH           ADD CARRY
         BC    12,ZWH3             PROPAGATE
         AH    ZWRE,=H'1'            CARRY
ZWH3     LTR   ZWRH,ZWRE           SAVE CARRY AND TEST SIGN
         BNM   ZWH4                  IF NEGATIVE
         AH    ZWRH,=H'5'            CORRECT
ZWH4     ST    ZWRF,ZWW2(ZWRI)     STORE PARTIAL PRODUCT
         SH    ZWRI,=H'4'          STEP AREA POINTER LEFT
         CR    ZWRI,ZWRA           IF LEFT LIMIT NOT REACHED
         BNL   ZWH2                  BRANCH
         LTR   ZWRH,ZWRH           TEST FINAL CARRY
         BZ    ZWH5                     IF NOT ZERO
         OI    DCSW,DCTRUN           SET TRUNCATION INDICATOR
ZWH5     BCT   ZWRG,ZWH1           DECREMENT ADJ EXP AND CLOSE LOOP
         B     ZWJ1                     SHIFT VALUE
*I
*I ADJ EXP IS NOT PLUS. SHIFT VALUE AS INDICATED BY THE WORD INDEX AND
*I DIVIDE BY 5 TO THE MAGNITUDE OF THE GIVEN POWER. RESET WORD INDEX
*I
ZWI1     LCR   ZWRC,ZWRC           COMPLEMENT WORD SHIFT GIVES LEFT
*                                    LIMIT WORK AREA
         BP    ZWD1                     BRANCH IF LIMIT DEFINES NO WORK
         ST    ZWRH,ZWW2(ZWRC)     STORE VALUE IN WORK AREA SHIFTED
         LCR   ZWRG,ZWRG           COMPLEMENT AND TEST ADJ EXP GIVES
*                                    COUNT FOR NUMBER TIMES TO DIVIDE
         BZ    ZWI5                     BRANCH IF ZERO
ZWI2     LR    ZWRI,ZWRC           SET WORKING POINTER TO LEFT LIMIT
         SR    ZWRE,ZWRE           CLEAR UPPER DIVIDEND REG
ZWI3     L     ZWRF,ZWW2(ZWRI)     LOAD PART OF DIVIDEND
         D     ZWRE,=F'10'         DIVIDE
         SLL   ZWRF,1                BY 5
         CH    ZWRE,=H'5'          IF REMAINDER
         BL    ZWI4                     TOO LARGE
         SH    ZWRE,=H'5'            CORRECT REMAINDER
         AH    ZWRF,=H'1'            AND DIVIDEND
ZWI4     ST    ZWRF,ZWW2(ZWRI)     STORE PARTIAL QUOTIENT
         AH    ZWRI,=H'4'          STEP WORKING POINTER RIGHT
         BNP   ZWI3                REPEAT UNTIL RIGHT LIMIT REACHED
         BCT   ZWRG,ZWI2           REDUCE COUNT AND CLOSE LOOP
ZWI5     SR    ZWRC,ZWRC           CLEAR WORD SHIFT
         OC    ZWW1(L'ZWW1-L'ZWACC),ZWW1  TEST HI PART OF WORK AREA
         BE    ZWJ1                     IF NOT ZERO
         OI    DCSW,DCTRUN           SET TRUNCATION INDICATOR
*J
*J SHIFT VALUE PER WORD SHIFT AND BIT SHIFT. TRUNCATE TO 160
*J BITS AND ADD TO ACCUMULATOR.
*J
ZWJ1     SR    ZWRG,ZWRG           RESET CARRY REG
         LA    ZWRH,16             INIT ACCUMULATOR POINTER
ZWJ2     SR    ZWRE,ZWRE           RESET WORKING REGISTERS
         SR    ZWRF,ZWRF
         LTR   ZWRC,ZWRC           TEST WORD INDEX
         BP    ZWJ4                     IF PLUS LEAVE WORK AREA CLEAR
         BZ    ZWJ3                     IF ZERO FETCH ONE WORD OF RESLT
         L     ZWRF,ZWW2+4(ZWRC)   FETCH LO WORD OF RESULT
ZWJ3     L     ZWRE,ZWW2(ZWRC)     FETCH HI WORD OF RESULT
ZWJ4     SLDL  ZWRE,0(ZWRD)        BIT SHIFT
         ALR   ZWRE,ZWRG           ADD IN CARRY
         BC    3,ZWJ5              BRANCH IF CARRY LEAVING ONE IN ZWRG
         SR    ZWRG,ZWRG           RESET CARRY
ZWJ5     LTR   ZWRH,ZWRH           END OF ACCU
         BM    ZWJ7                     YES, BRANCH
         AL    ZWRE,ZWACC(ZWRH)    ADD IN PIECE FROM ACCUMULATOR
         BC    12,ZWJ6             BRANCH IF NO CARRY
         LA    ZWRG,1              SET CARRY
ZWJ6     ST    ZWRE,ZWACC(ZWRH)    STEP WORKAREA PT
         SH    ZWRC,=H'4'          STEP ACCU PT
         SH    ZWRH,=H'4'          REPEAT FOR EACH WORD OF ACCU
         B     ZWJ2                     LOOP
ZWJ7     LTR   ZWRE,ZWRE           TEST CARRY
         BZ    ZWD1                     IF ON
ZWJ8     OI    DCSW,DCTRUN           SET TRUNCATION INDICATOR
         B     ZWD1                     STEP OVER DECIMAL POINT
*M
*M SET UP TO FORMAT RESULT. BRANCH TO APPROPRIATE ROUTINE.
*M
ZWM1     LM    ZWRL,ZWRJ,ZWSF      GET SCALE FACTOR AND TEXT POINTER,
         L     ZWRC,DCLNG               GET BIT LENGTH
         LCR   ZWRC,ZWRC             AND COMPLEMENT
         TM    ZWSW,X'06'          WHAT FORMAT REQUIRED
         BZ    ZWZ4                     BRANCH IF TEXT TRIVIAL
         BO    ZWP1                     BRANCH IF FLOAT PT AND NON-ZERO
         EJECT
*N
*N FORMAT FIXED POINT RESULT.
*N
ZWN1     TM    ZWACC+L'ZWACC-4,X'80'    TEST DROPPED BIT
         BZ    ZWN2                       NO ROUND NEEDED
         LA    ZWRI,L'ZWACC-4           LOAD INDEX REG
ZWN3     LA    ZWRA,1                   LOAD ROUND/CARRY BIT
         AL    ZWRA,ZWACC-4(ZWRI)       ADD IN PIECE OF VALUE
         ST    ZWRA,ZWACC-4(ZWRI)
         BC    12,ZWN2                  IF NO CARRY, GO QUIT
         SH    ZWRI,=H'4'                 ELSE PROPAGATE CARRY
         BP    ZWN3                         THRU ALL OF ZWACC
         OI    DCSW,DCTRUN              IF CARRY OUT SET TRUNC.INDIC.
ZWN2     CLI   0(ZWRJ),IMINUS           IF VALUE SIGN IS NEGATIVE
         BE    ZWN4                       GO DO NEG. OUTPUT
* VALUE IS POSITIVE.  MOVE INTACT TO OUTPUT.
         LM    ZWRG,ZWRB,ZWACC
         STM   ZWRG,ZWRB,DCVW           STORE IN OUTPUT AREA
* TEST FOR TRUNCATION OF HIGH-ORDER BITS (POSITIVE DATA)
         CH    ZWRC,=H'-63'             IS LENGTH OVER 2 WORDS
         BL    ZWN6                       YES.  GO DO HI 2 WORDS
         OR    ZWRG,ZWRH                TEST HI 2 WORDS FIRST
         BNZ   ZWN8                     SHOULD BE ZERO
         SLDA  ZWRA,63(ZWRC)            TEST TRUN. IN BITS OF LO
*                                       2 WDS
         B     ZWN6+L'ZWN6                THEN GO TEST
ZWN6     SLDA  ZWRG,127(ZWRC)           TEST TRUN. IN BITS OF HI
*                                       2 WDS
         BC    10,ZWZ5                  IF OKAY GO PUT IT OUT
         B     ZWN8                     ELSE GO LOG ERROR
* VALUE IS NEGATIVE.  COMPLIMENT IT AND PUT IN OUTPUT.
ZWN4     LA    ZWRI,L'ZWACC-4           LOAD UP INDEX
         SR    ZWRA,ZWRA                CLEAR REDUCTION BIT
ZWN5     L     ZWRB,ZWACC-4(ZWRI)       PICK UP A WORD
         LCR   ZWRB,ZWRB                COMPLIMENT IT, 2'S COMP
         SLR   ZWRB,ZWRA                REDUCE TO 1'S COMP IF ABOVE    X
                                            FIRST NON-ZERO WORD
         BC    2,ZWN0                   BRANCH IF VALUE IS STILL ZERO
* BRANCH GOES WRONG IF ZERO IS DEVELOPED ABOVE 1ST NON-ZERO. BUT THAT'S
*  OKAY, AS, ONCE ZWRA IS = 1, RELOADING IT DOESN'T MATTER ANYWAY.
         LA    ZWRA,1                   BEGIN 1'S COMPLIMENT NEXT WORD
ZWN0     ST    ZWRB,DCVW-4(ZWRI)        STORE IN OUTPUT AREA
         SH    ZWRI,=H'4'               NEXT
         BP    ZWN5                       WORD
* TEST FOR TRUNCATION OF HIGH-ORDER BITS (NEGATIVE DATA)
         LM    ZWRG,ZWRB,DCVW           PICK UP COMP. VALUE
         CH    ZWRC,=H'-63'             IS LENGTH OVER 2 WORDS
         BL    ZWN7                       YES.  GO DO HI 2 WORDS
         SLDA  ZWRG,63                  TEST HI 2 WORDS FIRST
         BC    3,ZWN8                   SHOULD BE MAX NEG OR ZERO
         SLDA  ZWRA,63(ZWRC)            TEST TRUN. IN BITS OF LO 2 WDS
         B     ZWN7+L'ZWN7                THEN GO TEST
ZWN7     SLDA  ZWRG,127(ZWRC)           TEST TRUN. IN BITS OF HI 2 WDS
         BC    12,ZWZ5                  IF OKAY GO PUT IT OUT
* SET TRUNCATION INDICATOR AND GO PUT OUT VALUE
ZWN8     OI    DCSW,DCTRUN                ELSE SET TRUNCATION SW,
         B     ZWZ5                         THEN GO PUT IT OUT.
         EJECT
*P
*P NORMALIZE FLOATING POINT RESULT
*P
ZWP1     LH    ZWRD,DCSCAL              GET S-MODIFIER
         CLI   ZWACC,X'10'              IS HIGH HEX DIGIT GT 0
         BNL   ZWP2                     -YES.
* VALUE NEEDS NORMALIZATION.            -NO.
         MVC   ZWW1(L'ZWACC),ZWACC      PUT IN TEMP STORAGE
         MVO   ZWACC+10(10),ZWW1+10(10) SHIFT VALUE LEFT 4 BITS
         MVO   ZWACC+00(11),ZWW1+00(11)
         AH    ZWRL,=H'4'               ADJUST WORKING SCALE FACTOR
         B     ZWP1                     RETEST NORMALIZATION
* ROUND VALUE TO LENGTH
*   CALCULATE LEFT SHIFT FOR ROUNDING-BIT
ZWP2     LR    ZWRE,ZWRD                GRAB S-MOD (HEX BYTES)
         SLA   ZWRE,2                     MAKE INTO BITS
         TM    ZWSW,X'08'               IS THIS AN L-CON
         BZ    ZWP3                       NO. GO TO  D-,E- FORMULA
         CH    ZWRC,=H'-63'               YES. IS LENGTH .GT. 64 BITS
         BNL   ZWP3                         NO. USE D,E-CON FORMULA
         CH    ZWRC,=H'-71'                 YES. IS LENGTH .GT. 72
         BL    ZWP4                           YES. USE LONG L FORMULA
         SH    ZWRE,=H'-71'                   NO. SPECIAL L FORMULA,
         B     ZWP5                             GO SHIFT
ZWP4     AH    ZWRE,=H'8'               LONG L-CON FORM.
ZWP3     AH    ZWRE,=H'134'             SHORT L-CON, D-E-CON.
         AR    ZWRE,ZWRC                SUBTRACT LENGTH-1
*
ZWP5     CH    ZWRE,=H'127'             WILL ANY OF VALUE BE RETAINED
         BH    ZWQ1                       NO.  SKIP ROUNDING.
         SRDL  ZWRE,5                   SPLIT SHIFT INTO
         SRL   ZWRF,32-5                  BITS AND
         SLL   ZWRE,2                     WORDS  (IN BYTE TERMS).
         LCR   ZWRE,ZWRE
         LA    ZWRI,L'ZWACC-4(,ZWRE)    INIT INDEX WORD-SHIFT ADJUSTED
         LA    ZWRA,1                   LOAD ROUND BIT
         SLL   ZWRA,0(ZWRF)             POSITION IT
ZWP6     AL    ZWRA,ZWACC-4(ZWRI)       ADD IN PIECE OF VALUE
         ST    ZWRA,ZWACC-4(ZWRI)
         BC    12,ZWQ1                  IF NO CARRY, GO QUIT
         LA    ZWRA,1                     ELSE LOAD CARRY REGISTER,
         SH    ZWRI,=H'4'
         BP    ZWP6                       GO PROPAGATE CARRY
*OVERFLOW ON ROUNDING. NUTS.
         MVI   ZWACC,X'10'              PUT CORRECTED VALUE
         SH    ZWRL,=H'4'  (ART'S FIX)  ADJUST WORKING SCALE FACTOR
         EJECT
*Q
*Q SHIFT RIGHT PER SCALE MOD., PLACE EXPONENT(S), POSITION FOR OUTPUT
*Q
ZWQ1     LR    ZWRB,ZWRD                GET S-MOD
         AH    ZWRB,=H'1'               BUMP TO MOVE EXTRA BYTE IF     X
                                          S-MOD IS ODD
         SRA   ZWRB,1                   MAKE INTO BYTES
         XC    ZWW1(L'ZWACC-3),ZWW1     CLEAR NEW HIGH BYTES
         LA    ZWRI,ZWW1+1(ZWRB)        INDEX MOVE. ADD 1 FOR EXP.
         MVC   0(L'ZWACC-5,ZWRI),ZWACC  MOVE AND SHIFT BY BYTES
         TM    DCSCAL+1,X'1'            WAS S-MOD ODD
         BZ    ZWQ2                       NO. LET IT SIT
         MVO   ZWW1+1(16),ZWW1+1(16)    SHIFT BACK 1 HEX DIGIT
ZWQ2     MVC   ZWACC(L'ZWACC-3),ZWW1    BRING IT HOME
*VALUE IN ZWW1 USED LATER IN LOST PRECISION TEST
*
*CALCULATE EXPONENT BYTE AND INSERT IT IN VALUE
         LA    ZWRB,384                 FORM
         SR    ZWRB,ZWRL                  CHARACTERISTIC
         SRA   ZWRB,2
         AR    ZWRB,ZWRD                ADJUST FOR S-MODIFIER
         LR    ZWRA,ZWRB
         SRA   ZWRA,7                   TEST FOR
ZWQ7     LA    ZWRH,ZRCD70              CHARACTERISTIC
         BNZ   ZWZ3                       OUT OF BOUNDS
         CLI   0(ZWRJ),IMINUS           IF VALUE IS NEGATIVE
         BNE   *+8                        NOT NEG
         LA    ZWRB,X'80'(,ZWRB)          PUT - SIGN
         STC   ZWRB,ZWACC               PLUG IN EXPONENT
         TM    ZWSW,X'08'               IS THIS A L-CON
         BZ    ZWQ3                       NO.  GO DO FINALS.
*THIS IS AN L-CON, PROCESS LOWER EXPONENT
         LM    ZWRE,ZWRF,ZWACC+8        PICK LOW 2 WORDS
         SRDL  ZWRE,8                   MAKE ROOM FOR EXPONENT
         STM   ZWRE,ZWRF,ZWACC+8
         STM   ZWRE,ZWRF,ZWW1+8         SAVE FOR LATER TEST
         SH    ZWRB,=H'14'              LOWER EXPONENT IS 14 LESS
         STC   ZWRB,ZWACC+8             PLUG IT IN
* IF LOW EXPONENT UNDERFLOWED, THE SIGN BIT WILL BE WRONG.
*  CORRECT FOR THAT POSSIBILITY.
         NI    ZWACC+8,B'01111111'      KILL WHATEVER SIGN BIT
         CLI   0(ZWRJ),IMINUS           IS VALUE NEGATIVE
         BNE   *+8                      BIF NO
         OI    ZWACC+8,B'10000000'      YES, PUT - SIGN
* CLODDY LOOP TO SHIFT VALUE FROM ZWACC TO DCVW, AND ALSO MOVE
* TEST VALUE FROM ZWW1 TO LOW ZWW1.
ZWQ3     AH    ZWRC,=H'127'             COMPUTE SHIFT
         SRDL  ZWRC,5
         SRL   ZWRD,32-5                BIT SHIFT
         SLL   ZWRC,2                   WORD SHIFT IN BYTES
         XC    DCVW(12),DCVW            CLEAR RECEIVING AREA
         XC    ZWW1+16(12),ZWW1+16      CLEAR RECIEVING AREA
         SR    ZWRI,ZWRI                CLEAR LOOP INDEX
         SR    ZWRG,ZWRG                CLEAR CARRY REG
         SR    ZWRH,ZWRH                CLEAR CARRY REG
ZWQ4     L     ZWRE,ZWACC(ZWRI)         PICK UP WORD
         L     ZWRL,ZWW1(ZWRI)          PICK UP WORD
         SR    ZWRF,ZWRF                CLEAR RH WORD
         SR    ZWRJ,ZWRJ                CLEAR RH WORD
         SRDL  ZWRE,0(ZWRD)             SHIFT PER BIT SHIFT
         SRDL  ZWRL,0(ZWRD)             SHIFT PER BIT SHIFT
         OR    ZWRE,ZWRG                PUT IN BIT FROM PREVIOUS WORD
         OR    ZWRL,ZWRH                PUT IN BIT FROM PREVIOUS WORD
         LR    ZWRG,ZWRF                SAVE OUTSHIFT FOR NEXT WORD
         LR    ZWRH,ZWRJ                SAVE OUTSHIFT FOR NEXT WORD
         LA    ZWRB,0(ZWRI,ZWRC)        ADD 2 INDEX REGS TOGETHER
         ST    ZWRE,DCVW(ZWRB)          PUT WORD OFFSET PER WD SHIFT
         ST    ZWRL,ZWW1+16(ZWRB)       PUT WORD OFFSET PER WD SHIFT
         AH    ZWRI,=H'4'               BUMP INDEX
         CH    ZWRB,=H'12'              TEST WHERE LATEST WD STORED
         BL    ZWQ4                       BR IF NOT LAST WORD
* TEST THE VALUE AT ZWW1+4 FOR LOST PRECISION
         OC    ZWW1+16(16),ZWW1+16      ZERO IF SHIFTED OUT ALL BITS
         BNZ   ZWZ5                       IF BIT, GO OUTPUT
         LA    ZWRH,ZRCD109
         BAL   ZWRG,MERROR              POST ERROR MESSAGE, THEN
         B     ZWZ5                       GO OUTPUT
         EJECT
*S1
*S1 STEP OVER SIGN.
*S1
ZWS1     CLI   0(ZWRB),IPLUS            IF CHAR IS +
         BE    ZWS11                    BRANCH
         CLI   0(ZWRB),IMINUS           IF CHAR
         BCR   7,ZWRG                IS - RETURN
ZWS11    LA    ZWRB,1(ZWRB)        STEP TEXT POINTER
         BR    ZWRG                     RETURN
*Z
*Z ERROR ROUTINE  AND RETURN ROUTINE.
*Z
ZWZ4     LA    ZWRH,ZRCD39              LOAD ERROR NUMBER
ZWZ3     BAL   ZWRG,MERROR         STORE ERROR MESSAGE
         XC    DCVW,DCVW           CLEAR OUTPUT AREA
ZWZ5     LM    ZWRI,ZWRG,ZWSVRG    RESTORE REG 11, 13, AND LINK ADDRESS
         L     ZWRB,ZWAUXT              RESTORE TEXT POINTER
         LA    SP2,DCVW
         LA    GRZ,DCSW
         BR    SRR                      RETURN
*
MERROR   STC   ZWRH,DCSW                SET ERROR
         BR    ZWRG                     AND RETURN
         SPACE 2
*DECON- CONVERT A PIECE OF THE VALUE
*       INPUT- CONDEX POINTS TO FIRST CHAR
*       OUTPUT-BINVAL CONTAINS CONVERTED VALUE
*              CONDEX TO TERMINATING CHAR
*              ZWRF POINTS TO FIRST CHAR OF FIELD
*              DECSW CONTAINS 1 IF TERMINATING CHAR COMMA
*                             2 IF TERMINATING CHAR QUOTE
*              VASCTL CONTAINS X'00'  NO ERRORS
*                              X'40'  TOO LONG
*                              X'80'  NO CHAR TO CONVERT
         SPACE 2
DECON    BCTR  CONDEX,0                 SEE IT BACK ONE
GETMOD   MVI   SIGN,X'0C'               SET SIGN PLUS
         SR    CNT,CNT                  ZERO COUNTER
         NI    VASCTL,X'00'             AND FLAG
         ST    CONDEX,AFIRST            SAVE POINTER TO BEGINNING-1
ADDIT    LA    CONDEX,1(CONDEX)         UP TO NEXT CHAR
         CLI   0(CONDEX),I9             IS CHAR NUMERIC
         BH    SETUP                    NO, BRANCH
         LA    CNT,1(CNT)               YES, UP COUNTER
         B     ADDIT                    LOOP, LOOKING FOR NON-NUMERIC
SETUP    ST    CONDEX,SAVEAD            SAVE END POINTER
         CLI   0(CONDEX),IQUOTE         IS IT A QUOTE
         BNE   COM                      NO
         OI    DECSW,2                  YES, SET AS QUOTE AND CONTINUE
         B      BACK
COM      CLI   0(CONDEX),ICOMMA         IS IT A COMMA
         BNE   BACK                     NO, CONTINUE
         ST     CONDEX,COMADD           YES, SAVE POINTER TO COMMA
         OI    DECSW,1                  SET AS COMMA
BACK     L     CONDEX,AFIRST            BEGIN AT BEGINNING
         LA    CONDEX,1(CONDEX)
SET1     LTR   CNT,CNT                  ARE THERE CHAR TO CONVERT
         BZ    ZNONE                    NO, RETURN
         CH    CNT,=H'10'               YES, IS IT GREATER THAN MAX
         BH    GTTEN                    YES, TRY TO GET DOWN TO NINE
         BL    GOTOIT                   NO, OK
         CLC   0(10,CONDEX),=X'02010407040803060407'  =10 CHARS, IS IT X
                                                        .GT. 2**31-1
         BNH   GOTOIT                   NO, CONVERT
ZLONG    OI    VASCTL,X'40'             YES, SET FLAG
         LA    CNT,9                    AND CONVERT 9
GOTOIT   BCTR  CNT,0                    DECREMENT FOR MOVE
         EX    CNT,PACKIT               PACK VALUE INTO HOLD
         OC    HOLD+7(1),SIGN           SET POSITIVE SIGN
         CVB   BINVAL,HOLD              CONVERT HOLD TO BINARY
LEAVE    LR    ZWRF,CONDEX              SET TO FIRST CHAR
         L     CONDEX,SAVEAD            SET TO TERMINATOR
         BR    REG                      RETURN
ZNONE    OI    VASCTL,X'80'             SET CODE, NONE TO CONVERT
         B     LEAVE                    AND EXIT
GTTEN    CLI   0(CONDEX),IZERO          IS FIRST CHAR A ZERO
         BNE   ZLONG                    NO, TOO LONG
         LA    CONDEX,1(CONDEX)         YES, IGNORE ZERO
         BCTR  CNT,0                    AND SEE IF IT IS
         B     SET1                     NOW SHORT ENOUGH
PACKIT   PACK  HOLD(8),0(00,CONDEX)     EXECUTED PACK TO PACK HOLD
         EJECT
* ZWSVRG THRU ZWACC ARE STORED AND LOADED BY MULTIPLE OPS
* AND MUST BE IN GIVEN SEQUENCE.
ZWSVRG   DS    4F                  SAVE R11, R13, AND RETURN ADDR.
ZWDE     DS    F                   DECIMAL EXPONENT
ZWSF     DS    F                   FIXED PT SCALE AND FLOATING PT EXPON
ZWTXPT   DS    F                   SAVE TEXT POINTER
         DS    0F                  ENSURE WORD ALIGNMENT OF ZWACC
ZWACC    DS    XL20                ACCUMULATOR
ZWAUXT   DS    F                        PTR TO CHAR TERMINATING FIELD
ZWSW     DS    C                   CONTROL SWITCHES AND VALUE SIGN
*                             BIT 7 X'01' = FLOATING POINT  (ELSE FIXD)
*                                 6    2  = VALUE FOUND (MAYBE ZERO)
*                                 5    4  = FLT.PT IS INITIALIZED (WSF)
*                                 4    8  = FLT.PT IS L-CON
*
         DS    0F                  SET PROPER ALIGNMENT FOR ZWW1
ZWW1     DS    XL56                WORK AREA
ZWW2     EQU   ZWW1+L'ZWW1-4       LOW WORD OF WORK AREA
*
DCLNG    DC    F'0'                     LENGTH MODIFIER
* DCXPON THRU DCVW ARE LOADED SERIALLY BY MVC AND MUST BE TOGETHER
         DC    0F'0'               ENSURE ALIGNMENT OF DCVW
DCXPON   DC    H'00'                    EXPONENT
DCSCAL   DC    H'00'                    SCALE
DCVW     DC    XL16'0'             OUTPUT AREA  (WORD ALIGNED)
HOLD     DC    D'0'                     DOUBLE WORD FOR CVB INST
AFIRST   DC    F'0'                     SAVE AREA FOR BEGINNING POINTER
SAVEAD   DC    F'0'                     SAVE AREA FOR ENDING POINTER
COMADD   DC    F'0'                     HOLD
VASCTL   DC    X'00'                    DECON FLAG
DCSW     DC    X'00'                    ERROR FLAG
SIGN     DC    X'0'                     SIGN FOR PACKED
DECSW    DC    X'0'                     FLAG - 1=COMMA, 2=QUOTE
         LTORG
*
ZWRA     EQU   0                        REGISTERS- SCALE FACTOR
ZWRB     EQU   1                                   POINTER TO SCAN CHAR
ZWRC     EQU   GRC                                 WORKING SCALE FACTOR
ZWRD     EQU   GRD                                 LOWER LIMIT SCALE
ZWRE     EQU   4                                   UPPER LIMIT SCALE
ZWRF     EQU   5                                   LOW WORD OF RESULT
ZWRG     EQU   14                                  ADJECTIVE EXPONENT
ZWRH     EQU   15                                  BINARY RESULT
ZWRI     EQU   11                                  EXPONENT MODIFIER
ZWRJ     EQU   13                                  END POINTER
ZWRL     EQU   12                                  POSITION OF DEC PONT
CONDEX   EQU   ZWRB                     POINTER TO SCAN CHAR
CNT      EQU   ZWRF                     COUNTER FOR CHAR TO CONVERT
BINVAL   EQU   ZWRH                     BINARY VALUE-DECON
REG      EQU   ZWRG                     RETURN REGISTER-DECON
ZRCD11   EQU   11                       SCALE MODIFIER ERROR
ZRCD13   EQU   13                       EXPONENT MODIFIER ERROR
DCTRUN   EQU   17                       TRUNCATION ERROR
ZRCD39   EQU   39                       INVALID DELIMITER
ZRCD70   EQU   70           FLOATING POINT CHARACTERISTIC OUT OF RANGE
ZRCD109  EQU   109                      PRECISION LOST
         END   DCNVRT1
./ ADD NAME=ASMGF8P
F8P      TITLE     'ASMG F8  OUTPUT FORMATTING ROUTINE (F8PRNT)'
         ISEQ  73,78
ASMGF8P  START
         USING RECORD,GRA
         USING MAINLN,FRB               FRB IS PRIMARY BASE REGISTER
         PRINT        NOGEN
         FDIMEN
         PRINT      GEN
*                                                                     *
*TITLE 'ASMGF8P ' ...  PRINT                                          *
*FUNCTION/OPERATION-                                                  *
*  ASMGF8P IS TO PRODUCE THE LISTING AND THE OBJECT DECK. TO DO THIS  *
*  ASMGF8P HAS FOUR ENTRY POINTS-                                     *
*        PRNT-      PROCESS EDITED TEXT RECORD (LEFT HALF)  TYPE 100  *
*        BLDIMG     BUILDS SOURCE IMAGE (RIGHT HALF)        TYPE 110  *
*                                                                111  *
*        COMMENT    MOVES IN SOURCE IMAGE (RIGHT HALF)      TYPE 000  *
*                                                                010  *
*                                                                011  *
*                   PUTS OUT ERROR LINE                          001  *
*        LOADRA     PRINTS ERROR LINE                       TYPE 001  *
*ENTRY POINTS- SEE INDIVIDUAL ROUTINE                                 *
*INPUT- SEE INDIVIDUAL ROUTINE                                        *
*OUTPUT- SEE INDIVIDUAL ROUTINE                                       *
*EXTERNAL ROUTINES-                                                   *
*        NAME           ROUTINE    USE                                *
*        SYSP(SRB)      ASMGF8I    PUNCH ON SYSLIN AND/OR SYSPUNCH    *
*        WTERR(SRB)     ASMGF8I    WRITE ERROR RECORD                 *
*        SYSL(SRB)      ASMGF8I    PRINT ON SYSPRINT                  *
*             BEFORE THE ABOVE ROUTINES ARE CALLED, SRB IS LOADED     *
*             FROM CTXTIO(ACT).                                       *
*EXITS- ALL ROUTINE EXIT VIA-  BR  SRR                                *
*TABLES/WORKAREAS-                                                    *
*   LIST-     PUSH-DOWN POP-UP SAVE AREA                              *
*   H1-       HEADING ONE                                             *
*   H2-       HEADING TWO                                             *
*   DETAIL-   PRINT OUTPUT BUFFER                                     *
*   DUMOUT-   PRINT DUMMY OUTPUT BUFFER                               *
*   TXTOUT-   PUNCH OUTPUT BUFFER                                     *
*   LFTHLF-   LEFT HALF OF DETAIL RECORD                              *
*   SOURCE-   RIGHT HALF OF DETAIL RECORD                             *
*./      DELETE    SEQ1=00840020,SEQ2=00840020
*   INPUT-    INPUT SOURCE RECORD                                     *
*   ERREC     INPUT/OUTPUT ERROR RECORD                               *
*                                                                     *
         EJECT
*                                                                     *
*TITLE 'PRNT' ... PROCESS EDITED TEXT RECORDS (LOAD LEFT HALF AND     *
*                 PRINT)                                              *
*ENTRY POINT-  PRNT(ACT)   CALLED VIA-                                *
*        L     SRB,PRNT(ACT)            LOAD BASE/ENTRY               *
*        BALR  SRR,SRB                  CALL PRNT                     *
*INPUT-  F8WORK(ACT)   INPUT RECORD                                   *
*        F8INST(ACT)   LEFT HALF TO BE PRINTED                        *
*OUTPUT- DETAIL        PRINT IMAGE FOR SYSL(SRB)                      *
*        TXTOUT        PUNCH IMAGE FOR SYSP(SRB)                      *
*                                                                     *
         SPACE 2
MAINLN   EQU   *
* ENTRY FOR LEFT HAND SIDE
PRNT00   BAL   GRX,CALLCF               SAVE REGISTERS
         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD
         TM    REPSW(ACT),X'0F'         IS IT PUNCH,REPRO, MNOTE OR TTL
         BZ    PRNT01                   NO, SKIP
*        **************************************************************
TSTAOP   MVC   RLI(2),F8WORK+6(ACT)    POINTER
         LH    GRX,RLI      TO 2ND
         LA    GR2,F8WORK(GRX,ACT)        OPERAND FIELD
         MVC   RLIF+1(1),0(GR2)   MOVE 2ND OPND LENGTH TO ALIGNED CELL
         LH    GR1,RLIF
         LTR   GR1,GR1                  IS 2ND OPRN LENGTH 0
         BNE   TSTAOP1                 NO
         TM    REPSW(ACT),X'06'         IS THIS A REPRO
         BC    11,RETNCF               NO
REPROF7  NI    REPSW(ACT),X'FE'        TURN SWITCH TO 2 FOR F7 REPRO
         LA    GR1,80                  LENGTH OF REPRO
TSTAOP1  BCTR  GR1,0                   REDUCE FOR MOVE
         LA    GR2,1(GR2)               IF NOT BUMP BY 1
         LR    SP2,GR2
         TM    REPSW(ACT),X'0C'         TEST MNOTE AND TITLE BITS
         BO    MNOTE00                 IF ONES, MNOTE
         BM    TITLE00                 IF MIXED, TITLE
         TM    REPSW(ACT),X'02'
         BO    REPRO00                IF 3, REPRO
         B     PUNCH00                  IF 1, PUNCH
MNOTE00  LA    GR1,1(GR1)               2ND OPRN LENGTH
MNOTE01  DS        0H
         LA        GRZ,SOURCE+C        SET PRINT LINE PTR TO CONTIN
         LA        GRB,E+1-C           MAX NUMBER OF BYTES PER LINE
         MVI       LOC,XBLANK          BLANK OUT ENTIRE LINE
         MVC       LOC+1(L'DETAIL-2),LOC  INCLUDING CONTINUE COLUMN
         MVI       SOURCE-1,C'+'       AN MNOTE IS GENERATED
         TM        FLAGA,X'02'         TEST IF CONTINUATION
         BO        MNOTE03             SKIP IF SO
         CLI       0(GR2),X'5C'        TEST IF COMMENT
         BE        MNOTE02             SKIP IF SO
         MVC       LOC+9(13),MNOMSG    PLACE ***MNOTE*** MESSAGE
MNOTE02  DS        0H
         LA        GRZ,SOURCE+B        RESET PRINT LINE POINTER
         LA        GRB,E+1             RESET LENGTH OF FIRST LINE
MNOTE03  DS    0H
         CR    GR1,GRB
         BNH   NOCONT                   NO CONT. LINES NEEDED
* MORE BYTES REMAINING THAN WILL FIT ON ONE LINE
         MVI   SOURCE+E+1,X'E7'         SET CONT. MARK ON
         SR    GR1,GRB                  DETERMINE OVERHANG
         STH   GR1,K                    SAVE FOR NEXT LINE
         LR    GR1,GRB                  MOVE MAX NO. OF BYTES
NOCONT   BCTR  GR1,0                    REDUCE FOR MOVE
*./      DELETE    SEQ1=01980020,SEQ2=02000020
         EX    GR1,MOVES                MOVE
         STM   GR1,GR2,SRRGRY          SAVE ADDR. OF 2ND OPRN
         BAL   SRR,MNOTE04              PUT OUT MNOTE
*
         TM    SOURCE+E+1,XNOTBL        ARE BYTES REMAINING
         BZ    RETNCF                   NO,EXIT TO USER
* CONTINUATIONS FOR MNOTE
         MVI   PUNSWH,X'FF'             TURN OFF PUNCH
         BAL   SRR,CHKSWJ               PRINT MNOTE LINE
         LM    GR1,GR2,SRRGRY          RESTORE PTR TO 2ND OPRN
         LA    GR2,1(GR2,GR1)           ADJUST TEXT RECORD PTR
         LH    GR1,K                    PICK UP REMAINING BYTE COUNT
         OI    FLAGA,X'02'              SET CONTINUATION 'ON'
         B     MNOTE01                  RETURN FOR ANOTHER LINE
*
MNOTE04  BAL   GRX,CALLCF               SAVE REGISTERS
         B     LOADRK                   LOAD RIGHT HALF
TITLE00  MVI   HEADNG,XBLANK            EXTERNAL BLANK TO HEADING
         MVC   HEADNG+1(99),HEADNG      BLANK MOST OF HEADING
         LA    GRZ,HEADNG              ADDR. FOR MOVE
         EX    GR1,MOVES                MOVE
         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD
         B     INLCPL
REPRO00  ST    GR2,SRRGRY             SAVE ADDR OF 2ND OPERAND
         MVI   PUNSWH,X'FF'               TURN OFF PUNCH
         MVC       DWORD(1),SOURCE-1   SAVE PRINT POSITION 40
         CLI       SOURCE-1,XBLANK     WAS THIS STATEMENT GENERATED
         BE        REPRO01             NO, PRINT IT
         CLI       F8PGEN,X'FF'        DO WE PRINT GEN STATEMENT
         BNE       REPRO01             YES, PRINT IT
         MVI       PRNTSW,MKX          SET NOT TO PRINT
REPRO01  BAL   SRR,CHKSWH             PRINT 'REPRO'
         MVC       SOURCE-1(1),DWORD   RESTORE PRINT POSITION 40
         L     GR2,SRRGRY             RESTORE PTR TO 2ND OPND
         LA    GRZ,SOURCE
         EX    GR1,MOVES
         LA    GRX,CTSEQ8+2(ACT)       UPDATE STATEMENT NO.
         BAL   SRR,CNVRT                    AND
         MVC   DSTMNT,DWORD             MOVE TO PRINT LINE
         BAL   SRR,CHKSWH             PRINT REPRO LINE
         MVI   LSTRCD,X'40'            RESET LAST RECORD TYPE
         TM    REPSW(ACT),X'03'        IS THIS F8 REPRO
         BM    RETNCF                  NO
PUNCH00  BAL   GRB,DUMP           DUMP PUNCH BUFFER IF NEEDED
         LA    GRZ,DUMOUT+1       ADDR FOR MOVE
         EX    GR1,MOVES
         LA    SP1,DUMOUT         ADDR FOR PUNCH
         L     SRB,CTXTIO(ACT)          TEXT I/O BASE
         BAL   SRR,SYSP(SRB)            ENTRY POINT TO PUNCH RTN
         MVI   DUMOUT+1,XBLANK    BLANK ENTIRE DUMOUT
         MVC   DUMOUT+2(L'DETAIL-2),DUMOUT+1
         B     RETNCF
MOVES    MVC   0(*-*,GRZ),0(GR2)        MOVE
*        **************************************************************
PRNT01   MVC   LFTHLF(4),CONSR             MOVE IN FLI AND FLAG
         MVC   XESDID(1),CESDID(ACT)    MOVE IN CURRENT ESD-ID
         MVC   LOCCTR(16),F8INST(ACT)   MOVE IN LEFT HAND SIDE
         MVC   FLAGA(1),F8WORK+2(ACT)
INLCPL   DS    0H
         TM    FLAGA,X'70'              IS THIS SOURCE RECORD .Q
         BNZ   INLCNSRC                 BRANCH IF NOT
         MVI   LOCLSTRD,X'00'           SET SOURCE LAST RECORD TYPE
INLCNSRC DS    0H
         TM    SPACSW(ACT),X'FF'        IS SPACE SWITCH ON
         BZ    PRINT1                   NO, SKIP
         BM    SPACERR                  SPACE ERROR
         STC   SP2,BLKBLK               SPACE ON AND OK
         B     PRINT6                   NORMAL SPACE ROUTINE
SPACERR  MVI   SPACSW(ACT),X'00'       TURN SPACE SWITCH OFF
         B     INLCPL
PRINT1   CLI   EJCTSW(ACT),X'FF'        IS EJECT SWITCH ON
         BE    PRINT7                   YES, EJECT
* ANTICIPATE NEEDING LOCAL PRINT SWITCH ON AND LOCAL PUNCH SWITCH OFF
         MVI   PRNTSW,MKY               NO, SET SWITCHES
         MVI   PUNSWH,X'FF'
         MVI   ALGSWH,X'FF'             SET ALIGNMENT SWITCH OFF
*
         TM    FLAGA,X'40'              LEFT HAND SIDE
         BO    PRINT3                     YES
         TM    FLAGA,X'20'                NO -- IS THIS AN ERROR REC
         BO    PRINT2                       NO -- CONTINUE
         TM    FLAGA,X'10'                  MAYBE -- LOOK AGAIN
         BO    PRINT4                         YES -- ERROR RECORD
* RECORD TYPE 000, 010 OR 011
PRINT2   TM    LSTRCD,X'40'        IS THERE A LINE TO BE PRINTED
         BO    PRNT2B                   NO -- CONTINUE
         CLI       CTERRSW(ACT),X'FF'  TEST FOR ERROR ON LAST LINE
         BE        PRNT2A              PRINT IT IF SO
         TM    LSTRCD,X'10'             MAYBE -- GEN SWITCH INVOLVED
         BZ    PRNT2A                   NO, GO AHEAD AND PRINT
         CLI   F8PGEN(ACT),X'FF'          YES - IS GEN SWITCH OFF
         BNE   PRNT2A                   ON -- PRINT
         MVI   PRNTSW,MKX               OFF -- BLANK THE LINE
PRNT2A   BAL   SRR,CHKSWH               PRINT LINE
         MVI   PRNTSW,MKY               TURN PRINT SWITCH ON
PRNT2B   B     LOADRERR               NOW LOAD THIS RIGHT HALF
* RECORD TYPE 100,110 OR 111
PRINT3   MVI   PUNSWH,0                 TURN PUNCH SWITCH ON
         MVN   LLTH+1(1),FLAG           SEPARATE BYTE COUNTS FROM IND'S
         TM    FLAGA,X'10'              SHOULD GEN. SWITCH BE CHECKED
         BZ    PRNT3A                    NO
         CLI   F8PGEN(ACT),X'FF'        YES, IS GEN SWITCH OFF
         BNE   PRNT3A                   NO -- GEN SWITCH IS ON
         LA    GRX,PRNT3B               FINAL TARGET ADDRESS
         CLI   LOCLSTRD,X'00'           WAS LAST RECORD SOURCE .Q
         BCR   7,GRX                    BRANCH IF NOT
         CLI   F8PON(ACT),X'FF'         IS PRINT 'OFF' .Q
         BCR   8,GRX                    YES -- TURN PRINT SWITCH OFF
         TM    CTLSTI(ACT),X'10'        IS 'LIST' OPTION ON .Q
         BCR   8,GRX                    BRANCH IF NOT
         TM    CTLSTI(ACT),X'10'        WAS 'LIST' OPTION SPECIFIED .Q
         BCR   8,GRX                    BRANCH IF NOT
         CLI   LLTH+1,X'0F'             SHOULD LOCCTR BE BLANK
         BCR   8,GRX                    BRANCH IF YES
         CLI   F8WORK+4(ACT),EQUX       IS THIS AN EQU RECORD .Q
         BCR   8,GRX                    YES, LOCATION COUNTER USELESS
         CLI   F8WORK+4(ACT),USINGX     IS THIS A USING RECORD .Q
         BCR   8,GRX                    YES, LOCATION COUNTER USELESS
         L     SRR,LSTDCB(,ACT)         SYSPRINT DCB ADDRESS
         L     SRR,L1DCBLPT(,SRR)       LAST RECORD POINTER
         LTR   SRR,SRR                  IS THERE A LAST POINTER .Q
         BZ    LOCSARND                 BRANCH IF NOT
         CLI   1(SRR),XBLANK            IS LOC FIELD BLANK .Q
         BNE   LOCSARND                 BRANCH IF NOT
         UNPK  WORK(7),LOCCTR(4)        1ST SIX DIGITS OF LOC FIELD
         MVZ   WORK(6),WORK-1           CLEAR ZONE BITS
         L     GRB,CTRTBP(,ACT)         POINT TO TRANSLATE TABLE
         TR    WORK(6),0(GRB)           TRANSLATE TO PRINTABLE
         MVC   1(6,SRR),WORK            ADD LOCATION COUNTER TO CALL
LOCSARND DS    0H
         MVI   LOCLSTRD,X'FF'           REMEMBER NON SOURCE TYPE NOW
         BR    GRX                      TURN OFF PRINT SWITCH
PRNT3A   DS    0H
         TM    LSTRCD,X'40'             WAS LAST RECORD LEFT HLF SIDE
         BZ    PRNT3C                     NO
         CLI   F8PDAT(ACT),X'00'        DO WE PRINT DATA
         BE    PRNT3C                       YES -- LOAD LEFT HALF
PRNT3B   MVI   PRNTSW,MKX                   NO -- TURN PRINT SW OFF
*
PRNT3C   BAL   SRR,LOADLH               NOW LOAD LEFT HALF
         CLI   ALGSWH,X'FF'        WAS ALIGNMENT DATA JUST PROCESSED
         BE    EXIT1                 NO
         B     EXIT2                 YES
* ERROR RECORD
PRINT4   MVC       CTERRSW(1,ACT),CTEMERR(ACT) SET F8P ERROR SWITCH
         MVC   ERREC(4),F8WORK(ACT)    MOVE ERLI,EFLAG,NERR TO INPUT
         MVC   ESTMNT(2),CTSEQ8+2(ACT) INSERT STATEMENT NO.
         LH    GRX,ERLI                UP REC LENGTH BY 2
         LA    GRX,2(GRX)
         STH   GRX,ERLI
         LA    GR1,7
         SR    GRX,GR1                 NO. REMAINING BYTES MINUS ONE
         BM    PRNT4A                   IF MINUS DONT MOVE
         EX    GRX,MVERCD              MOVE REMAINDER OF ERR REC
PRNT4A   LA    SP1,ERREC                LOAD ADDR. OF REFORMATTED REC
         L     SRB,CTXTIO(ACT)          LOAD BASE
         BAL   SRR,WTERR(SRB)          PUR ERR REC IN TEXT STREAM
         B     RETNCF                  AND RETURN
MVERCD   MVC   ERR1(*-*),F8WORK+4(ACT)  EXECUTED MOVE
* SPACE RECORD
*
PRINT6   MVI   SPACSW(ACT),X'00'        TURN OFF SPACE SWITCH
         IC    GRY,BLKCNT               ACCUMULATE BLANK LINE COUNT
         IC    GR1,BLKBLK              FOR SUCCESSIVE 'SPACE'OPS
         AR    GRY,GR1                    (CALLCF HAS JUST USED GRY AND
         STC   GRY,BLKCNT               BLANK LINE COUNTER
         B     PRNT7B                   CONTINUE
* EJECT RECORD
*
PRINT7   CLC   BLKCNT,LCNT+1            IS THERE A LARGE SPACE WAITING
         BNH   PRNT7A                      NO
         BAL   SRR,PGEHED                 YES -- EJECT FOR BIG SPACE
PRNT7A   BAL   SRR,PGEHED              EJECT TO A NEW PAGE
         MVI   EJCTSW(ACT),X'00'        TURN EJECT SWITCH OFF
         MVI   BLKCNT,X'01'                 SET BLANK LINE CNT FOR 1ST
PRNT7B   MVI   DETAIL+1,XBLANK          BLANK OUT ENTIRE
         MVC   DETAIL+2(L'DETAIL-2),DETAIL+1   DETAIL LINE
         MVI   LSTRCD,X'40'             SET LAST RECORD LEFT HALF
         B     RETNCF                   RETURN TO CALLER
         EJECT
*./      DELETE    SEQ1=04860020,SEQ2=05020020
*        **************************************************************
*        LOAD RIGHT HALF OF OUTPUT PAGE
*        **************************************************************
*./      DELETE    SEQ1=05100020,SEQ2=05180020
LOADRERR CLI       CTERRSW(ACT),X'FF'  IS PRINT ERROR MSG SWITCH ON
         BNE   LOADRI                NO -- CONTINUE WITH LOAD RGT HLF
*./      DELETE    SEQ1=05240020,SEQ2=05300020
* PRINT ERROR MESSAGE
         CLC   CTSEQ8+2(2,ACT),HZERO    IS ERROR BEFORE FIRST STMT
         BE    LOADRH                   YES,DO NOT PRINT *ERROR*
         MVC   DUMOUT+10(13),ERRMSG     USE DUMOUT AREA
         LA    GRB,DUMOUT                 FOR PRINT BUFFER
         MVI       BLKCNT,0            IGNORE SPACE COMMANDS
         CLI   LCNT+1,X'00'             ENOUGH ROOM ON THIS PAGE
         BH    LOADRF                     YES
         MVI   LCNT+1,X'01'               NO -- WELL, MAKE ROOM
LOADRF   BAL   SRR,DMPIT                PRINT THE LINE OUT
LOADRH   MVI       CTERRSW(ACT),X'00'  RESET PRINT ERROR MSG SWITCH
LOADRI   TM    REPSW(ACT),X'0F'    IS THIS MNOTE
         BO    TSTAOP            YES
         SR    GRB,GRB                  MOVE 1, 2, ... 80 BYTE
         IC    GRB,1(GRA)                 SOURCE IMAGE
         LA     GRB,252(GRB)            DECREASE LOW BYTE OF GRB BY 4
         EX     GRB,MOVCRD                BY ADDING COMPLEMENT OF 4
         L     GRC,CTRTBP(ACT)         ADDRESS OF TRANSLATE TABLE
         EX    GRB,TRANS                   MOVE AND TRANSLATE
         MVI   CTEMERR(ACT),X'FF'       TURN ON MNOTE
LOADRK   TM    FLAGA,X'10'              WAS THIS SOURCE REC GENERATED
         BZ    LOADRJ                     NO
          MVI  SOURCE-1,C'+'              YES - PLACE A '+' IN LISTING
LOADRJ   TM    FLAGA,X'02'             CONTINUATION BIT ON
         BO    EXIT                    YES - LEAVE STMNT. NO. BLANK
         TM    FLAGA,X'30'                NO -- TYPE 110, NON-LITR
         BM    EXIT                    YES - SKIP STMNT. NO.
         LA    GRX,CTSEQ8+2(ACT)       PICK UP STATEMENT NO., INCREASE
         BAL   SRR,CNVRT                  BY 1, CONVERT TO EXTERNAL
         MVC   DSTMNT,DWORD                 AND MOVE TO DETAIL LINE
EXIT     LH    SP2,FLAGA                PASS FLAGA TO PUTER
         LA    SP1,DSTMNT               SOURCE IN TERM BUFFER
         L     SRB,CTXTIO(,ACT)         LOAD BASE
         BAL   SRR,PUTXT(,SRB)          SOURCE IN BUFFER FOR UT1
EXIT1    MVC   LSTRCD,FLAGA             CURRENT TYPE TO LAST RECORD
EXIT2    MVI   FLAG,X'00'               RESET F8PRNT WORKAREA FLAG
         B     RETNCF                       AND EXIT
MOVCRD   MVC   SOURCE(*-*),CARD         EXECUTED MOVE
TRANS    TR    SOURCE(*-*),0(GRC)       EXECUTED TRANSLATE
*        **************************************************************
*        LOAD LEFT HALF OF OUTPUT PAGE
*        **************************************************************
LOADLH   UNPK  WORK(15),LOCCTR(8)       1ST 14 HEX DIGITS + 1 HEX JUNK
         UNPK  WORK+14(15),SSB2D2(8)    15TH THROUGH 29TH
         MVC   WORK+29(1),EA2+2         30TH
*./      DELETE    SEQ1=06080020,SEQ2=06160020
         MVZ   WORK(32),WORK-1         REMOVE ZONE BITS
         L     GRB,CTRTBP(ACT)         ADDRESS OF TRANSLATE TABLE
         TR    WORK(30),0(GRB)          TRANSLATE ALL 30 EXPANDED BYTES
         CLI   LLTH+1,X'0F'             SHOULD LOCCTR COLUMN BE BLANK
         BNE   LOADLX                     NO
         MVI   LLTH+1,X'00'               YES -- RESET BYTE COUNT
         B     CHKSWH                       AND CHECK PRINT/NO PRINT
LOADLX   DS    0H
         TM    F8WORK+3(ACT),X'80'      IS THIS AN ASSEMBLER OP .Q
         BZ    NOTASOP                  IF ZERO, NOT ASSEMBLER OP
         CLI   F8WORK+4(ACT),EQUX       TEST IF 'EQU' RECORD
         BE    EQUY                     BRANCH IF YES
         CLI   F8WORK+4(ACT),USINGX     TEST IF 'USING' RECORD
         BE    EQUY                     BRANCH IF YES
         CLI   F8WORK+4(ACT),ORGX       TEST IF 'ORG' RECORD
         BE    ORGY                     BRANCH IF YES
NOTASOP  DS    0H
         MVC   LOC(6),WORK              MOVE LOCATION COUNTER
         TM    FLAG,X'F0'              IS THIS A DS STATEMENT
         BO    CHKSWH                   YES -- JUMP TO PRINT ROUTINE
         TM    FLAG,X'80'               NO --- IS THIS ALIGNMENT DATA
         BO    ALIGN                     YES -- GO TO ALIGNMENT ROUTINE
         TM    FLAG,X'40'                NO --- TEST FOR DC
         BO    DCLH                       YES -- GO TO DC/DS SECTION
         LA    GRX,CHKSWH                 NO --- TREAT AS MACH INSTR
         CLI   FLAG,X'00'               FIRST -- CHECK IF BYTE COUNT 0
         BCR   8,GRX                      YES -- JUMP TO CHKSWH
         TM    FLAG,X'30'                 NO --- DETERMINE SYLLABLE CNT
         BZ    BYTE2                        CNT = 2 -- SKIP LAST 2 SYLL
         BM    BYTE4                        CNT = 4 -- SKIP LAST SYLL
BYTE6    MVC   LOC+17(4),WORK+14            CNT = 6 -- MOVE ALL 3 SYLL
BYTE4    MVC   LOC+12(4),WORK+10         MOVE 2ND SYLLABLE
BYTE2    MVC   LOC+7(4),WORK+6           MOVE 1ST SYLLABLE
* CHECK FOR PRESENCE OF EFFECTIVE ADDRESS 1
CHKEA1   TM    FLAG,X'20'              EFFECTIVE ADDRESS 1 PRESENT
         BZ    CHKEA2                    NO --- GO CHECK FOR EA2
         MVC   LOC+21(6),WORK+18         YES -- MOVE IT
         CLI   LOC+21,X'F0'             DOES EA1 HAVE LEADING ZERO
         BNE   CHKEA2                    NO --- LEAVE IT AS IS
         MVI   LOC+21,XBLANK              YES -- REPLACE BY BBLANK
* CHECK FOR PRESENCE OF EFFECTIVE ADDRESS 2
CHKEA2   TM    FLAG,X'10'              EFFECTIVE ADDRESS 2 PRESENT
         BCR   8,GRX                     NO --- SKIP TO CHKSWH
         MVC   LOC+27(6),WORK+24         YES -- MOVE IT
         CLI   LOC+27,X'F0'             DOES EA2 HAVE LEADING ZERO
         BCR   7,GRX                     NO
         MVI   LOC+27,XBLANK              YES -- REPLACE BY BLANK
         BCR   15,GRX                   TO CKSWH
*        PRINT EXTRA ADDRESS FOR 'ORG'
ORGY     DS    0H
         MVC   LOC(6),WORK              PLACE OLD LOCATION ON LINE
         MVC   LOC+27(6),WORK+6         PLACE NEW LOCATION ON LINE
         B     CHLDZERO                 CHECK FOR LEADING ZERO
*
EQUY     DS    0H
         MVC   LOC+27(6),WORK           MOVE EQU ARGUMENT TO ADDR2 FLD
CHLDZERO DS    0H
         CLI   LOC+27,X'F0'             IS THERE A LEADING ZERO .Q
         BNE   CHKSWH                   TO CHKSWH IF NOT
         MVI   LOC+27,XBLANK            REMOVE LEADING ZERO
         B     CHKSWH                   TO CHKSWH
*
ALIGN    MVI   ALGSWH,X'00'             TURN ALIGNMENT DATA SWITCH ON
         MVI   PUNSWH,X'00'               TURN PUNCH SWITCH ON
         MVC   DUMOUT+1(6),WORK         MOVE LOCATION COUNTER
         LA    GRB,DUMOUT               LOAD ADDRESS OF DUMMY LINE
         LH    GRX,LLTH                 PICK UP BYTE COUNT,
         AR    GRX,GRX                    DOUBLE IT,
         BZ    CHKSWH                     (SKIP MOVE IF 0 ALIGN BYTES)
         BCTR  GRX,0                        REDUCE BY 1 AND
         EX    GRX,MOVALG                     MOVE ALIGNMENT DATA
         B     CHKSWHX                  PRINT ALIGNMENT IF PRINT SW ON
*
MOVALG   MVC   DUMOUT+8(*-*),WORK+6     MOVE ALIGNMENT BYTES
MOVDC    MVC   LOC+7(*-*),WORK+6        MOVE DC BYTES
*
DCLH     LH    GR1,LLTH                 GET DC LENGTH
         AR    GR1,GR1                  DOUBLE DC LENGTH
         BZ    CHKSWH                   SKIP MOVE IF NO DC BYTES
         BCTR  GR1,0                    REDUCE BY ONE FOR EXECUTED MOVE
         EX    GR1,MOVDC                GO MOVE DC TO OUTPUT
*        **************************************************************
*        PRINT ROUTINE
*        **************************************************************
CHKSWH   LA    GRB,DETAIL               PICK UP POINTER TO DETAIL LINE
CHKSWHX  CLI       CTERRSW(ACT),X'FF'  TEST IF ERROR SW ON
         BE        DMPIT               PRINT IRREGARDLESS IF SO
         CLI   PRNTSW,MKX               IS PRINT SWITCH ON .Q
         BE    CLEAR                      NO -- CLEAR LINE
         B     DMPLIN                     YES, PRINT LINE
*
CHKSWJ   LA    GRB,DETAIL                LOAD ADDRESS OF DETAIL LINE
*
DMPLIN   CLI   F8PON(ACT),X'FF'         PRINTS = X'00' IF PRINT ASSEM
         BE    CLEAR                      OP IS ON, = X'FF' IF OFF
DMPIT    SR    GRD,GRD                  ZERO SO CAN INSERT CHAR
         ST    SRR,REGHLD               STORE RETURN REGISTER
         IC    GRD,BLKCNT               PICK UP BLANK LINE COUNT
         CH    GRD,LCNT                 TEST IF THERE IS ENOUGH ROOM
         BL    DMPLNB                     YES -- CONTINUE TO DMPLNB
         BAL   SRR,PGEHEDIT               NO --- PRINT HEADING
         LA    GRD,1                        AND SET BLANK LINE COUNT 1
DMPLNB   STC   GRD,0(GRB)               ONE BLANK LINE AFTER HEADING
         LR    SP1,GRB                  PICK UP LOCATION OF LINE
         L     SRB,CTXTIO(ACT)          LOAD BASE
         BAL   SRR,SYSL(SRB)            CALL SYSLIST
         LH    GRX,LCNT                 ADJUST
         SR    GRX,GRD                    LCNT
         BNP       DMPEXIT             DON'T LET LCNT GET NEGATIVE
         BCTR  GRX,0                        FOR LINE
         STH   GRX,LCNT                       JUST PRINTED
DMPEXIT  L     SRR,REGHLD               RESTORE SRR NOW
         MVI   BLKCNT,X'00'             RESET BLANK LINE COUNT
* CLEAR DETAIL OR DUMMY LINE NOW WHETHER PRINTING TOOK PLACE OR NOT
CLEAR    MVI   1(GRB),XBLANK            CLEAR FIRST POSITION TO BLANK
         MVC   2(L'DETAIL-2,GRB),1(GRB)   CLEAR NEXT 131
*
         CLI   PUNSWH,X'00'             TEST LOCAL PUNCH SWITCH
         BE    GOTXT                      ON --- GO TO PUNCH ROUTINE
         BR    SRR                        OFF -- RETURN TO USER NOW
*        **************************************************************
*        PAGE HEADING ROUTINE
*        **************************************************************
PGEHED   CLI   F8PON(ACT),X'FF'         PRINTS = X'00' IF PRINT ASSEM
         BCR   8,SRR                      OP IS 'ON', = X'FF' IF 'OFF'
PGEHEDIT DS    0H
         TM    CTLSTI(ACT),X'10'        WAS 'NOLIST' SPECIFIED .Q
         BCR   8,SRR                    BRANCH NOW IF YES
         ST    SRR,REGHLD+4             STORE RETURN REGISTER
         L     SRR,ADLIST1(,ACT)        POINT TO LIST1 IN ASMGASM
         L     GRZ,L1PAGENO(,SRR)       GET CURRENT PAGE NUMBER
         LA    GRZ,1(,GRZ)              BUMP BY ONE
         ST    GRZ,L1PAGENO(,SRR)       AND RESTORE FOR THE FUTURE
         BAL   SRR,CNVRTX               CONVERT TO CHARACTER AND
         MVC   PCNT,DWORD+1             STORE IN PRIMARY HEADER LINE
         MVC   DECKNM(8),CTITLE(ACT)    MOVE PROGRAM I.D. TO HEADER
         LA    SP1,H1                    NOW EJECT AND PRINT
         MVI   H1SPC,X'FF'                    PRIMARY HEADING LINE
         L     SRB,CTXTIO(ACT)          LOAD BASE
         BAL   SRR,SYSL(SRB)            CALL SYSLIST
         SR    GRX,GRX                  PREPARE FOR NEW LINE COUNT
         IC    GRX,CTPGLNCT(,ACT)       GET PAGE LINE COUNT
         LTR   GRX,GRX                  TEST FOR LINECNT=0
         BNZ   *+8                      NO, IT'S NOT ZERO
         LH    GRX,H32766               YES IT IS SO MAKE IT HUGE
         LA    GRX,1(,GRX)              ADD ONE ON
         STH   GRX,LCNT                 RESTORE DETAIL LINE COUNT
         MVC   DATE(9),CTDATE(ACT)      CURRENT DATE TO HEADING LINE
         LA    SP1,H2                   LOAD ADDRESS OF HEADING LINE 2
         MVI   H2SPC,X'02'              DOUBLE SPACE
         BAL   SRR,SYSL(SRB)           PRINT SECONDARY HEADING
         L     SRR,REGHLD+4             GET RETURN ADDRESS
         BR    SRR                      RETURN TO USER
*        **************************************************************
*        UPDATE STATEMENT, PAGE AND CARD SEQUENCE NUMBERS
*        **************************************************************
CNVRT    LH    GRZ,0(,GRX)              GET BINARY NUMBER
         N     GRZ,MASK2                ZAP TOP HALF OF WORD
         LA    GRZ,1(,GRZ)              INCREASE NUMBER AND
         STH   GRZ,0(,GRX)              SAVE IT IN BINARY
CNVRTX   CVD   GRZ,DWORD                CONVERT TO DECIMAL
         UNPK      DWORD(5),DWORD+5(3) UNPACK
         OI        DWORD+4,X'F0'       AND GET RID OF SIGN
         MVC       SAVSEQ,DWORD+1      SAVE NUMBER WITH LEADING ZEROS
* REPLACE LEADING ZEROS OF 4 BYTE WORD AT DWORD WITH BLANKS
*   BUT FIRST MOVE RAW NUMBER (LEADING ZEROS AND ALL) TO LOCATION SEQ
         LA    GRY,DWORD                GET ADDRESS OF DWORD
SUPR     TM    0(GRY),X'0F'             IS CHAR A ZERO
         BCR   4,SRR                    NO, EXIT
         MVI   0(GRY),X'40'             YES, REPLACE WITH BLANK
         LA    GRY,1(GRY)               UP TO NEXT CHAR
         B     SUPR                     LOOP FOR ALL LEADING ZEROES
*        **************************************************************
*        PUNCH ROUTINE
*        **************************************************************
GOTXT    TM        FLAG,X'F0'          IS THIS A DS STATEMENT
         BCR       1,SRR               RETURN IF SO
         CLI       LLTH+1,0            IS THERE ANY DATA TO OUTPUT
         BCR       8,SRR               RETURN IF NOT
         TM        CESDIDPS(ACT),X'FF' IS THIS DSECT OR COM
         BCR       8,SRR               RETURN IF SO
         BAL       GRX,CALLCF          SAVE THE REGS
         LH        GRA,BYTCNT          TEST IF PRIOR DATA ON TXT CARD
         LTR       GRA,GRA
         BZ        NEWCARD             START NEW CARD IF NOT
         CLC       ESDIDX,CESDID(ACT)  TEST IF THIS DATA FOR SAME ESDID
         BNE       DUMPIT              PUNCH CARD AND START NEW IF NOT
         A         GRA,ADDR-1          COMPUTE LOC LAST DATA ENDS AT
         L         GRB,LOCCTR-1        GET LOC THIS DATA STARTS AT
         LA        GRA,0(,GRA)         CLEAR TOP BYTES
         LA        GRB,0(,GRB)
         CR        GRA,GRB             TEST IF THIS DATA FOLLOWS DIRECT
         BE        NFRST               CONTINUE PRESENT CARD IF SO
DUMPIT   BAL       GRB,DUMP            PUNCH OUT LAST CARD
NEWCARD  MVC       ADDR,LOCCTR         INIT NEW CARD   PLACE ADDRESS
         MVC   ESDIDX,CESDID(ACT)       CHANGE TO CURRENT ESD/ID
         LA    GRX,CCRDCT(ACT)         UPDATE DACK SEQ NO.
         BAL   SRR,CNVRT                CONVERT IT TO DECIMAL
         MVC   SEQ,SAVSEQ               MOVE IN WITH LEADING ZEROES
         MVC   IDRH(4),CTITLE(ACT)      MOVE IN DECK NAME
         LA    GRX,TXTOUT-1       SAVE ADDR. OF CARD IMAGE
         ST    GRX,CTLDCP(ACT)                   IN ACT TABLE
         LA    GRA,INS                  O/P AND SET O/P PTR TO COL. 17
         B     NFRSTB                   SKIP
NFRST    L     GRA,OUTPOI               PICK UP DYNAMIC O/P PTR.
NFRSTB   LA    GRC,OPCODE               LOAD PTR TO 1ST BYTE TO PUNCH
         LH    GRD,LLTH                 LOAD NUMBER OF BYTES TO PUNCH.
         LH    SRB,BYTCNT               LOAD DYNAMIC BYTE COUNT.
LOOPA    MVC   0(1,GRA),0(GRC)          MOVE ONE BYTE TO PUNCH BUFFER.
         LA    GRC,1(GRC)               KICK SENDING POINTER.
         LA    GRA,1(GRA)               KICK RECEIVING POINTER.
         LA    SRB,1(SRB)               KICK BYTE COUNT
         LA    GR1,56                   FOR COMPARE
         CR    SRB,GR1                  DOES BYTE COUNT = 56
         BNE   MORTXT                   NO, BRANCH TO LOOP CONTROL.
         STH   SRB,BYTCNT               YES, STORE BYTE COUNT IN O/P.
         BAL   GRB,DUMP                 DUMP PUNCH BUFFER.
         LA    GR1,1                    FOR COMPARE
         CR    GRD,GR1            MORE LLTH BYTES TO MOVE?
         BE    NOMORE                  NO
         LA    GRX,CCRDCT(ACT)         UPDATE DECK SEQ. NO.
         BAL   SRR,CNVRT                CONVERT TO DECIMAL
         MVC   SEQ,SAVSEQ               MOVE IN NUMBER
         LA    GRX,TXTOUT-1        SAVE ADDR. OF CARD IMAGE
         ST    GRX,CTLDCP(ACT)         IN ACT TABLE
NOMORE   LA    GR1,56                  KICK LOADING ADDRESS IN
         A     GR1,TXTOUT+4             PUNCH BUFFER BY 56.
         ST    GR1,TXTOUT+4
         LA    GRA,INS                  RESET O/P POINTER TO COL. 17
         SR    SRB,SRB                  SET REGISTER BYTE COUNT = 0.
MORTXT   BCT   GRD,LOOPA                LOOP UNTIL LLTH BYTES MOVED.
         STH   SRB,BYTCNT               STORE DYNAMIC BYTE COUNT
         ST    GRA,OUTPOI               STORE DYNAMIC O/P POINTER.
         B     RETNCF                   EXIT PUNCH ROUTINE.
* DUMP PUNCH BUFFER
DUMP     CLI   BYTCNT+1,0               DOES BYTE COUNT = 0.
         BCR   8,GRB                    YES, RETURN TO LOCAL USER.
         ST    GRB,REGHLD              SAVE REGS
         STM   GR1,GR2,REGHLD+4         ALL OF THEM
         LA    SP1,TXTOUT-1             PICK UP ADDR OF CARD IMAGE AND
         L     SRB,CTXTIO(ACT)          LOAD BASE
         BAL   SRR,SYSP(SRB)            CALL SYSPUNCH
         L     GRB,REGHLD
         LM    GR1,GR2,REGHLD+4        RESTORE REGS
         SR    GRX,GRX              SET TO ZERO WHEN
         ST    GRX,CTLDCP(ACT)                  PUNCH BUFFER EMPTY
         MVI   INS,X'40'                  CLEAR CARD AREA
         MVC   INS+1(55),INS                  AND
         MVI   BYTCNT+1,0               RESET DYNAMIC BYTE COUNT TO 0.
         BR    GRB                              RETURN TO LOCAL USER
         TITLE 'ASMG F8  GENERATED OUTPUT FORMATTING ROUTINE (F8PRNT)'
*                                                                     *
*TITLE- 'BLDIMG' ...  BUILD RIGHT HALF                                *
*ENTRY- BLDIMG  CALLED VIA-                                           *
*        EXTERN  BLDIMG                                               *
*        L     FRB,PRNT(ACT)            LOAD BASE                     *
*        L     GRX,=A(BLDIMG)           LOAD ENTRY                    *
*        BALR  SRR,GRX                  CALL BLDIMG                   *
*INPUT-  F8WORK(ACT)     INPUT RECORD                                 *
*OUTPUT- SOURCE          BUILT CARD IMAGE                             *
*NOTES-                                                               *
*   BLDIMG BUILDS THE RIGHT HALF OF THE OUTPUT LINE (DETAIL) FROM THE *
*   EDITED TEXT RECORD FOR RECORD TYPES 6 (LITERALS, CONDITIONAL      *
*   ASSEMBLY) AND 7 (TEXT AND MNOTE GENERATED BY MACRO EXPANSION).    *
*                                                                     *
         SPACE 2
BLDIMG   BAL   GRX,CALLCF               SAVE REGISTERS
         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD
         TM    F8WORK+3(ACT),X'80'     IS THIS AN ASSEMBLER OP
         BZ    BLDIMG0                 IF ZERO,NOT ASSEMBLRT OP
         CLI   F8WORK+4(ACT),MNOTEX     IS RECORD MNOTE
         BNE   BLDIMG0                 IF NOT EQUAL BUILD IMAGE
         MVC   RLI(2),F8WORK+6(ACT)    POINT TO
         LH    GRX,RLI                      1ST CHARACTER
         LA    GR2,F8WORK(GRX,ACT)               IN 2ND COMMENT FIELD
         LA    GR2,1(GR2)               LOOK AT NEXT CHAR
         CLI   0(GR2),X'5C'            IS THIS *
         BE    MNOTERR                 YES
MNOTEOP  MVI   CTEMERR(ACT),X'00'        SET MNOTE ERROR 37 FLAG
MNOTERR  MVI   FLAGA,X'00'        MAKE STMNT LOOK LIKE SOURCE
         MVI   REPSW(ACT),X'0F'            SET MNOTE
         B     INLCPL                   PROCESS MNOTE
BLDIMG0  MVC   FLAGA(1),F8WORK+2(ACT)   PICK UP EDITED REC FLAG
BLDIMG2  MVC   RLIX(2),RLIC             INITIALIZE 1ST 2 BYTES OF REC
         NI    FLAGA,X'34'              IF EDITED RECORD TYPE IS '111',
         TM    F8WORK+2(ACT),X'70'           MAKE GENERATED RECORD TYPE
         BO    BLDXX       '011'.  IF GENERATED REC
         TM    F8WORK+3(ACT),X'40'           TYPE IS '110',MAKE GENERA-
         BO    BLDXX                        TED TYPE '010' UNLESS ED
         CLI   F8WORK+4(ACT),KLITR            REC IS LITR--IF SO,
         BNE   BLDXX                          MAKE GENERATED REC TYPE
         NI    FLAGA,X'DF'                     '000'
*
*        START WITH NAME FIELD AND WORK FORWARD
*
BLDXX    DS    0H
         BAL   SRR,CLEARA               CLEAR CARD IMAGE
         SR    GRB,GRB                  ZERO LENGTH REGISTER
         ST    GRB,CUROFF               ZERO CURRENT OFFSET POINTER
         LA    GRD,CARD+B               INITIAL CARD LOCATION
         ST    GRD,CURPTR               SET THIS AS INITIAL CARD POSN
         IC    GRB,F8WORK+8(,ACT)       PICK UP LENGTH OF NAME FIELD
         LA    GRC,F8WORK+9(,ACT)       'FROM' ADDRESS OF NAME FIELD
         LA    GRD,B                    'TO' OFFSET FOR NAME
         BAL   SRR,SETSEG               ENTER LABEL SEGMENT
         LA    GRD,9                    'TO' OFFSET FOR OPCODE
         BAL   SRR,SETSEG               ENTER OPCODE SEGMENT
         LA    GRD,C                    'TO' ADDRESS FOR OPERAND
         BAL   SRR,SETSEG               ENTER OPERAND SEGMENT
         LTR   GRB,GRB                  ANY COMMENTS .Q
         BZ    BLDPUT                   BRANCH IF NOT
         BCTR  GRB,0                    DECREMENT COMMENT LENGTH
         SR    GRD,GRD                  ZERO REGISTER
         IC    GRD,0(,GRC)              COMMENT OFFSET
         LA    GRC,1(,GRC)              START OF COMMENT
BLDPUT   DS    0H
         BAL   SRR,SETSEG               ENTER COMMENT SEGMENT
         L     GRA,RECADDR              INPUT RECORD ADDRESS
         BAL   SRR,OUTSV                OUTPUT THE IMAGE
         B     RETNCF                   EXIT AFTER LAST LINE
         SPACE     2
*
*        ENTER SEGMENT OF PRINT LINE CARD IMAGE
*
*  INPUT           GRB -- NUMBER OF BYTES TO BE ADDED
*                  GRC -- 'FROM' ADDRESS OF STRING
*                  GRD -- DESIRED 'TO' OFFSET IN CARD
*                  SRR -- RETURN REGISTER
*
SETSEG   DS    0H
         ST    SRR,SEGRTN               SAVE CALLER'S RETURN ADDRESS
         STM   GRB,GRC,SEGALEN          ACTUAL SEGMENT LENGTH/ADDR
         LTR   GRB,GRB                  IS SEGMENT NULL .Q
         BNP   SETDONE                  EXIT IF SO
SETDEC   DS    0H
         S     GRB,F1                   LENGTH-1 OF STRING SEGMENT
         BZ    SETPOSTS                 BRANCH IF NOW ZERO
         LA    GR1,0(GRB,GRC)           LAST CHAR OF STRING
         CLI   0(GR1),IBLANK            IS LAST CHAR BLANK .Q
         BE    SETDEC                   AGAIN IF YES
SETPOSTS DS    0H
         C     GRD,CUROFF               IS DESIRED OFFSET OK .Q
         BP    SETPOSOK                 BRANCH IF YES
         LTR   GRD,GRD                  IS THIS THE LABEL FIELD .Q
         BZ    SETPOSOK                 BRANCH IF YES
         L     GRD,CUROFF               BUMP TO 1ST AVAILABLE SLOT
         A     GRD,F1                   LEAVE ONE BLANK
SETPOSOK DS    0H
         LR    GR2,GRD                  DESIRED OFFSET TO START
         S     GR2,CUROFF               NUMBER OF BLANKS
SETBLKOK DS    0H
         LR    GR1,GR2                  NUMBER OF BLANKS
         A     GR1,CURPTR               POTENTIAL END OF LINE
         LA    GR0,CARD+E+1             ACTUAL END OF LINE
         SR    GR1,GR0                  WILL BLANKS FIT .Q
         BNP   SETBLKFN                 BRANCH IF YES
         LR    GR2,GR1                  LENGTH REMAINING
         MVI   CARD+E+1,IX              SET CONTINUATION
         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD
         BAL   SRR,OUTSV                PUT OUT PARTIAL LINE
         BAL   SRR,CLEARA               CLEAR CARD IMAGE
         OI    FLAGA,X'02'              SET CONTINUATION ON
         LA    GR0,CARD+C               CONTINUATION COLUMN
         ST    GR0,CURPTR               SET IT AS CURRENT POINTER
         B     SETBLKOK                 GO PROCESS MORE BLANKS
SETBLKFN DS    0H
         LR    GR1,GR2                  CURRENT CARD OFFSET
         A     GR1,CURPTR               CURRENT CARD POSN
         ST    GR1,CURPTR               SET CURRENT CARD POSN
         LA    GRD,1(GRB,GRD)           UPDATE OFFSET AFTER SEGMENT
         ST    GRD,CUROFF               UPDATE CURRENT OFFSET
         L     GRD,CURPTR               GET CURRENT CARD POINTER
SETCOMOK DS    0H
         LA    GR1,0(GRD,GRB)           END OF CARD PTR
         LA    GR0,CARD+E               ACTUAL END-1 OF CARD
         SR    GR1,GR0                  WILL IT FIT .Q
         BNP   SETFINOK                 BRANCH IF YES
         SR    GRB,GR1                  DECREMENT BY EXCESS
         BM    SETCOMZR                 THE BOUNDARY CASE
         EX    GRB,SEGMVC               MOVE IN SEGMENT
         LA    GRC,1(GRB,GRC)           UPDATE INPUT POINTER
SETCOMZR DS    0H
         LR    GRB,GR1                  SET LENGTH REMAINING
         BCTR  GRB,0                    SET LENGTH-1
         MVI   CARD+E+1,IX              SET CONTINUATION
         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD
         BAL   SRR,OUTSV                PUT OUT PARTIAL LINE
         BAL   SRR,CLEARA               CLEAR CARD IMAGE
         OI    FLAGA,X'02'              SET CONTINUATION ON
         LA    GRD,CARD+C               CONTINUATION COLUMN
         ST    GRD,CURPTR               SET IT AS CURRENT POINTER
         B     SETCOMOK                 GO PROCESS NEXT PART
SETFINOK DS    0H
         EX    GRB,SEGMVC               MOVE IN REMAINING SEGMENT
         LA    GRD,1(GRB,GRD)           NEXT POSSIBLE 'TO' ADDRESS
         ST    GRD,CURPTR               REMEMBER THAT
SETDONE  DS    0H
         L     GRC,SEGALEN              CURRENT SEGMENT LENGTH
         A     GRC,SEGALEN+4            PLUS STARTING ADDRESS
         IC    GRB,0(,GRC)              LENGTH OF NEXT FIELD
         LA    GRC,1(,GRC)              'FROM' ADDR OF NEXT FIELD
         L     SRR,SEGRTN               RESTORE RETURN ADDRESS
         BR    SRR                      AND RETURN
*
*        CLEAR 80 BYTE AREA
*
CLEARA   DS    0H
         MVI   CARD,IBLANK              PUT BLANK IN COLUMN ONE
         MVC   CARD+1(79),CARD          AND PROPAGATE DOWN CARD
         BR    SRR                      AND RETURN
*
*        OUTPUT RIGHT HALF IN PRINT BUFFER
*
OUTSV    DS    0H
         BAL   GRX,CALLCF               SAVE REGISTERS
         BAL   SRR,INLCPL               GO TO LOAD RIGHT HALF
*./      DELETE    SEQ1=12400020,SEQ2=13340020
         TITLE 'F8PRINT COMMENTS PROCESSOR V -II'
*                                                                     *
*TITLE 'COMMENT' ...  MOVE IN RIGHT HALF                              *
*ENTRY- COMMENT  CALLED VIA-                                          *
*        L     FRB,PRNT(ACT)            LOAD BASE                     *
*        L     GRX,CTCOMT(ACT)          LOAD ENTRY                    *
*        BALR  SRR,GRX                  CALL COMMENT                  *
*INPUT-  F8WORK(ACT)     INPUT IMAGE                                  *
*OUTPUT- SOURCE          PART OF PRINT IMAGE                          *
*                                                                     *
         SPACE 2
COMMENT  BAL   GRX,CALLCF               SAVE REGISTERS
         LA    SP1,F8WORK(ACT)          ADDRESS OF INPUT AREA
         L     GRA,RECADDR              LOAD ADDRESS OF INPUT RECORD
*./      DELETE    SEQ1=13640020,SEQ2=13680020
         MVC   RLI,0(SP1)               RECORD LENGTH INDICATOR
         LH    GRX,RLI                  PUT IT IN A REGISTER FOR MOVE
         TM    2(SP1),X'30'             TEST FOR TYPE 011
         BO    OUTPUT2                  BRANCH IF YES
OUTPUT1  EX    GRX,MOVOUT               MOVE RECORD FOR OUTPUT
         BAL   SRR,INLCPL              GO TO PRINT ROUTINE
         B     RETNCF                   RETURN AND RESTORE REGISTERS
OUTPUT2  CH    GRX,H74                  IS CONTINUATION NEEDED
         BNH   OUTPUT1                  IF NO GO BACK
         LA    GRX,E+5                  LENGTH OF RECORD
         EX    GRX,MOVOUT               MOVE RECORD
         STH   GRX,0(GRA)               STORE LENGTH IN MOVED REC
         MVI   74(GRA),IX               MOVE IN CONTINUATION BYTE
         BAL   SRR,OUTPUT3              TO PRINT RTNE VIA OUTPUT3
         LA    SP1,F8WORK(ACT)          ADDRESS OF INPUTAREA
         OI    2(SP1),X'02'             SET CONTINUATION BIT
         MVI   3(SP1),IBLANK            BLANK OUT COLUMN
         MVC   4(14,SP1),3(SP1)         1 TO 15
         LH    GRX,RLI                  LOAD RECORD LENGTH
         SH    GRX,H74                  CALCULATE LENGTH OF PART
         EX    GRX,MOV                  TO OVERLAY OLD PART
         LH    GRX,RLI                  LOAD RECORD LENGTH
         SH    GRX,H56                  CALCULATE NEW RECORD LNGTH
         STH   GRX,RLI                  STORE IN RLI
         STH   GRX,0(SP1)               AND IN INPUT AREA
         B     OUTPUT2
OUTPUT3  BAL   GRX,CALLCF               SAVE REGISTERS
         BAL   SRR,INLCPL               GO TO PRINT ROUTINE
         B     RETNCF                   RETURN AND RESTORE REGS
H74      DC    H'74'
H56      DC    H'56'
MOV      MVC   18(*-*,SP1),74(SP1)      EXECUTED
*./      DELETE    SEQ1=13800020,SEQ2=13800020
MOVOUT   MVC   0(*-*,GRA),0(SP1)        EXECUTED MOVE RECORD
*
***
         ENTRY BLDIMG                   BUILD IMAGE ENTRY
         ENTRY COMMENT                  PRINT COMMENT ENTRY
*./      DELETE    SEQ1=13920020,SEQ2=13920020
         TITLE 'PUSH DOWN, POP UP ROUTINE -- SAVES GRA, GRB, ... SRR'
         USING LIST,GRY                 FOR PUSH-DOWN POP-UP LIST
CALLCF   L     GRY,PUSHDN               GET PRIOR LEVEL POINTER
         LA    GRY,24(GRY)              OBTAIN POINTER TO NEW LEVEL
         ST    GRY,PUSHDN               SAVE POINTER TO LATEST LEVEL
         STM   GRA,SRR,LIST             SAVE GRA, GRB, GRC, GRD, SRB
         BR    GRX                        AND SRR AND RETURN TO CALLER
*
RETNCF   LM    GRY,GR1,PUSHDN           PICK UP CURRENT LEVEL POINTER
         BXLE  GRY,GR0,*+4                POP UP TO PRIOR LEVEL
         ST    GRY,PUSHDN                 PUSHDOWNS
         LM    GRA,SRR,LIST+24          RESTORE REGISTERS SAVED
         BR    SRR                      EXIT
         DROP  GRY                      NO LONGER USE LIST
*
PUSHDN   DC    A(LIST-24)               POSITION IN LIST
POPUP    DC    F'-24'                   POP UP COUNTER
LIST     DC    30F'0'                   5 LEVEL PUSH DOWN STORAGE
*
         TITLE 'F8PRINT CONSTANTS FOR V - II'
***
***
* FULL WORD DC'S, DS'S AND ADCON'S, FORCED FULL WORD ALIGNMENTS, ETC
***
         DS    0F                       FULL WORD ALIGN
RLIC     DC    FL2'83'                  LOGICAL RECORD LENGTH
RECADDR  DC    A(RECORD)                ADDRESS OF INPUT RECORD
CURPTR   DC    A(0)                     CURRENT CARD POINTER
CUROFF   DC    A(0)                     CURRENT CARD OFFSET
F1       DC    F'1'                     CONSTANT ONE
SEGRTN   DC    A(0)                     RETURN ADDRESS SAVE AREA
SEGALEN  DC    2A(0)                    ACTUAL SEGMENT LENGTH/ADDR
SEGMVC   MVC   0(*-*,GRD),0(GRC)        EXECUTED MOVE SEGMENT
SVMNTE   DS    2F                       BYTES FOR NEXT LINE
SRRGRY   DS    2F                      TWO REGISTERS SAVED
*./      DELETE    SEQ1=14580020,SEQ2=14580020
OUTPOI   DS    F                        DYNAMIC O/P PTR
*./      DELETE    SEQ1=14620020,SEQ2=14620020
REGHLD   DS    4F                       WORK REG HOLD AREA
FFOUR    DC    F'4'                     FULLWORD CONSTANT FOUR
HZERO    EQU   FFOUR                    HALFWORD CONSTANT ZERO
***
* HALF WORD CONSTANTS AND DS'S
***
RLI      DS    1H                       POINTER TO SECOND OPERAND
RLIF     DC    H'0'                     RECORD LENGTH INDICATOR
LLTH     DC    H'0'                     LEFT HAND SIDE BYTE COUNT
LCNT     DC    H'0'                     LINE COUNT
BCNT     DC    H'0'                     PUNCH AREA BYTE COUNT
*./      DELETE    SEQ1=14820020,SEQ2=14820020
H32766   DC    H'32766'                 LARGEST +VE HALF WORD LESS ONE
***
* HEX CONSTANTS
***
FRST     DC    X'00'                    FIRST PASS SWITCH
BLKCNT   DC    X'00'                    BLANK LINE COUNT
BLKBLK   DC    X'00'                   NO. OF SPACES IN SPACE STMNT.
         DC    X'0F'                    MASK WITH ZERO ZONE BEFORE WORK
WORK     DC    XL32'00'                 WORK AREA FOR UNPACK
MASK2    DC    0F'0',XL4'FFFF'          MASK FOR LOAD LOGICAL HALFWORD
PRNTSW   DC    X'00'                    LOCAL PRINT SWITCH
PUNSWH   DC    X'FF'                    LOCAL PUNCH SWITCH
LSTRCD   DC    X'40'                    LAST RECORD IN INDICATOR
LOCLSTRD DC    X'00'                    LAST RECORD TYPE READ
ALGSWH   DC    X'FF'                    ALIGNMENT DATA PROCESSED SWITCH
RECTYP   DC    X'40'                    SUBSTITUTED TYPE FOR X'57' REC
CONSR    DC    X'00144700'             CONSTANT PART OF RECORD
***
* CHARACTER CONSTANTS
***
SAVSEQ   DC    C'0000'             SAVE AREA FOR DECK SEQ. NO.
ERRMSG   DC    C'*** ERROR ***'
MNOMSG   DC    C'*** MNOTE ***'
*
DWORD    DS    D                        RESULTS OF CNVRT
*        **************************************************************
* NORMAL CARD FORMAT PARAMETERS
B        EQU   0                        BEGIN -1
E        EQU   70                       END -1
C        EQU   15                       CONTINUE - 1
***
SYSL     EQU   SYSLST                   SYSLIST
SYSP     EQU   SYSOUT                   SYSPUNCH
*./      DELETE    SEQ1=15440020,SEQ2=15440020
K        EQU   SVMNTE                   BYTES LEFT
*
*
XNOTBL   EQU   X'01'                    LOGICAL INT X AND NOT INT BLNK
BLNK     EQU   X'32'                    INTERNAL BLANK
KBLANK   EQU   BLNK                     INTERNAL BLANK
KLITR    EQU   X'25'                    LITERAL RECORD
*
XBLANK   EQU   X'40'                    EXTERNAL BLANK
*
USINGX   EQU   X'23'                    USING RECORD
ORGX     EQU   X'20'                    ORG RECORD
TITLEX   EQU   X'18'                    TITLE RECORD
REPROX   EQU   X'17'                    REPRODUCE RECORD
PUNCHX   EQU   X'16'                    PUNCH RECORD
EQUX     EQU   X'1F'                    EQU RECORD
MNOTEX   EQU   X'0E'                    MNOTE RECORD
*
MKY      EQU   X'00'                    PRINT ON SWITCH MASK
MKX      EQU   X'FF'                    PRINT OFF SWITCH MASK
         SPACE 3
* HEADING DATA
H1       DS    0CL133                   HEADING CODE
H1SPC    DC    X'FF'                    PAGE EJECT
DECKNM   DC    C'STUVWXYZ'              PROGRAM IDENTIFICATION
         DC    C' '                     ONE BLANK
HEADNG   DS    0CL100                   PROGRAMMER HDG FROM TITLE STMNT
         DC    C'                                                  '
         DC    C'                                                  '
         DC    C'  PAGE '               2 BLANKS, 'PAGE', 1 BLANK
PCNT     DC    C'WXYZ'                  PAGE NUMBER
         DC    12C' '
* SECONDARY HEADER LINE
H2       DS    0CL133                   HEADING TWO
H2SPC    DC    X'02'
         DC    C'  LOC  OBJECT CODE    ADDR1 ADDR2  STMT   SOURCE STAT'
         DC    C'EMENT                                            '
         DC        9C' '
DATE     DC        CL9'DD MMM YY'
         DC    12C' '
* WORKAREA FOR RUN-OF-MILL DETAIL LINE
DETAIL   DS    0CL133                   DETAIL LINE
DETSPC   DC    X'00'                    SPACES
LOC      DS    0CL40                    LEFT HALF
         DC        C'                                  ' 34 BLANKS
DSTMNT   DC        C'07080'            DETAIL LINE STATEMENT NUMBER
         DC    X'40'
SOURCE   DS    CL80                     RIGHT HALF
         DC    12C' '
* DUMMY LINE -- FOR ALIGNMENT, ERROR LINE, PUNCH, REPRO
         CNOP      6,8                 PUT DUMOUT ON D BOUNDRY
         DS        C
DUMOUT   DC    X'00'
         DC    C'                        '
         DC    C'                        '
         DC    C'                        '
         DC    C'                        '
         DC    C'                        '
         DC    CL12' '
         DC    X'00'
***
* PUNCH BUFFER
***
         DS    0D                      ON D BOUNDRY
TXTOUT   DS    0CL80
         DC    X'02'                    CARD COL 1
         DC    C'TXT '                  COLS 2 - 5
ADDR     DC    C'000'                   COLS 6 - 8
         DC    C'  '                    COLS 9, 10
BYTCNT   DC    X'0000'                  COLS 11, 12
         DC    X'404000'                COLS 13 - 15
ESDIDX   DC    X'01'                    COL 16
INS      DS    0CL56                    COLS 17 - 72
         DC    C'        '
         DC    C'        '
         DC    C'        '
         DC    C'        '
         DC    C'        '
         DC    C'        '
         DC    C'        '
IDRH     DC    C'ABCD'                  COLS 73 - 76
SEQ      DC    C'0000'                  COLS 77 - 80
         EJECT
* RECORDS OF VARIOUS SORTS
*
         DS    0F
         DC    X'00'
LFTHLF   DS    0CL20                    LEFT HALF IMAGE
RLIB     DC    FL2'20'                  LENGTH
FLAGB    DC    X'57'                    FLAG FOR LEFT HALF WORKAREA
XESDID   DC    X'01'                    CURRENT ESDID
LOCCTR   DS    CL3                      LOCATION COUNTER
OPCODE   DS    CL1                      OP CODE
RRR1     DS    CL1                      REGISTER SPECIFICATION
RXB2D2   DS    CL2                      2ND INSTRUCTION BYTE
SSB2D2   DS    CL2                      3RD INSTRUCTION BYTE
EA1      DS    CL3                      EFFECTIVE ADDRESS 1
EA2      DS    CL3                      EFFECTIVE ADDRESS 2
FLAG     DS    CL1                      BYTE COUNT
*
         SPACE 3
*
* F8PRINT INPUT AREAS
RECORD   CSECT
         DS    0F                       WORD ALIGNED
INPUT    DS    CL400                    400 BYTES FOR RECORD
* FORMAT OF SOURCE RECORD
RLIA     EQU   INPUT                    LENGTH
FLAGA    EQU   INPUT+2                  FLAG
CARD     EQU   INPUT+3                  CARD IMAGE
* FORMAT OF ERROR RECORD
ERREC    EQU   INPUT                    INTERNAL NAME
ERLI     EQU   INPUT                    LENGTH VARIES FROM 8 - 38 BYTES
EFLAG    EQU   INPUT+2                  FLAG FOR ERROR RECORDS
NERR     EQU   INPUT+3                 NUMBER OF ERRORAS
ESTMNT   EQU   INPUT+4                  STATEMENT NUMBER
ERR1     EQU   INPUT+6                 1-16 ERR CODES AND PTRS
RGTHLF   EQU   INPUT                    RIGHT HALF
RLIX     EQU   RLIA                     LENGTH
         SPACE 2
         END
./ ADD NAME=ASMGF8S
F8S      TITLE     'ASMG F8  SYMBOL TABLE GET'
         ISEQ  73,78
ASMGF8S  CSECT
 SPACE
         PRINT        NOGEN
         FDIMEN
*                                                                     *
*TITLE 'ASMGF8S ' ... SYMBOL TABLE GET                                *
*FUNCTION/OPERATION-                                                  *
*  ASMGF8S LOOKS UP THE SYMBOL IN THE SYMBOL TABLE AND RETURNS        *
*   WITH EITHER THE VALUE OR A NOT FOUND INDICATOR                    *
*ENTRY POINT- STGETR                                                  *
*   CALLING SEQUENCE                                                  *
*        LA    SP1,SYMBOL               POINT TO SYMBOL               *
*        L     SRB,CSTGET(ACT)          GET BASE/ENTRY                *
*        BALR  SRR,SRB                  CALL ASMGF8S                  *
*INPUT-  SP1   POINTS TO SYMBOL                                       *
*        SP2   CONTAINS LENGTH OF SYMBOL OR ZERO                      *
*OUTPUT- SP1   POINTS TO ATTRIBUTES IF FOUND                          *
*              IS ZERO IF NOT FOUND                                   *
*        SP2   CONTAINS LENGTH OF SYMBOL-1                            *
*EXTERNAL ROUTINES- NONE                                              *
*EXITS- NORMAL                                                        *
*   RETURNS VIA                                                       *
*        BR    SRR                      EXIT                          *
*     - ERROR -- NONE                                                 *
*NOTES- SEE NOTES FOR ASMGF7S                                         *
         EJECT
         ENTRY STGETR
 SPACE
FR0      EQU       0                   FLOATING REGISTER 0
*        *     SYMBOLIC DISPLACEMENTS
*
UNDEF    EQU   32                      UNDEFINED SYMBOL FLAG
LASH     EQU   31                      LTH OF LITERAL HASH (28) + OPSYN
ISYM     EQU   0                                   Y+0
ADJ      EQU   7                                   Y+7
ICHAIN   EQU   14                                  Y+14
 EJECT
         USING *,SRB
STGETR   LTR   SP2,SP2                  IF PARAMETER SP2 WAS GIVEN,
         BP    KNOWN LENGTH SYMBOL.     LENGTH IS KNOWN, BRANCH
         MVI       SETLEN+3,0          IN CASE NOT SYMBOL
         CLI   0(SP1),IALPHA            IS FIRST CHAR PART OF SYMBOL
         BH    GETOUT                   NO, RETURN NOT FOUND
 SPACE
         LR    SP2,SP1                  SP2= BEGINNING OF NAME
SCAN     LA    SP2,1(SP2)               SET AT NEXT CHAR
         CLI   0(SP2),IALPHA            IS THIS CHAR PART OF SYMBOL
         BNH   SCAN                     YES, LOOP
 SPACE
         SR    SP2,SP1                  =LENGTH OF SYMBOL
KNOWN    C         SP2,=F'8'           TEST FOR SYMBOL TOO BIG
         BCTR  SP2,0                    REDUCE BY ONE FOR COMPARE
         STC       SP2,SETLEN+3        SET LENGTH ON EXIT
         BH      GETOUT                 SET 'NOT FOUND' AND EXIT.
 SPACE
         STC       SP2,MOVSYM+1        PUT LENGTH-1 IN MOVE INST
         STC       SP2,TRSYM+1           AND IN TRANSLATE INST
         SDR       FR0,FR0             CLEAR WORK BENCH
         STD       FR0,BENCH
MOVSYM   MVC       BENCH(*-*),0(SP1)   MOVE SYMBOL TO BENCH
TRSYM    TR        BENCH(*-*),CODE2    TRANSLATE TO 2ND INTERNAL CODE
         L         SP1,BENCH+4         PACK THE SYMBOL TO 6 BYTES
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         ST        SP2,BENCH+4
         L         SP1,BENCH
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6
         SRL       SP1,2
         SRDL      SP1,6+8
         ST        SP2,BENCH
         X         SP2,BENCH+4          FOLD SYMBOL INTO FULLWORD.
         SR        SP1,SP1              CLEAR 4 BYTES OF DIVIDEND.
         D       SP1,CPRIME(0,ACT)      PRIME IS HASH DIMENSION.
         LA     SP2,0(SP1,SP1)          MULTIPLY BY
         AR     SP2,SP1                 THREE BYTES/POINTER.
         L      SP1,CTSYMP(0,ACT)       FIND SYMBOL TABLE BASE
         LA     SP2,LASH-ICHAIN(SP2,SP1) LASH = LENGTH OF LITERAL HASH.
 SPACE
FOLLOW   MVC   F0XXX+1(3),ICHAIN(SP2)   POINTER TO BOUNDARY
         L     SP2,F0XXX                POINTER TO REGISTER
         LTR   SP2,SP2
         BZ        GETOUT
         CLC       BENCH+1(6),ISYM(SP2) COMPARE SYMBOLS.
         BNE      FOLLOW                BRANCH NOT CORRECT SYMBOL
 SPACE
         TM    ADJ(SP2),UNDEF          TEST FOR UNDEFINED ENTRY
         BZ        FOUND               NO  THIS IS OK
 SPACE 2
GETOUT   L         SP2,=F'-6'          SET PARAM 'NOT FOUND'.
FOUND    LA    SP1,6(0,SP2)             SET SP1 TO POINT TO ATTRIBUTE
SETLEN   LA        SP2,*-*             SET LENGTH OF SYMBOL IN SP2
         BCR   15,SRR                  EXIT.
 SPACE 4
BENCH    DS        D                    WORK BENCH
F0XXX    DC        F'0'
 SPACE
CODE2 DC X'30313233343536373839101112131415161718191A1B1C1D1E1F'
      DC X'202122232425262728290A0B0C000000000000000000000000'
 SPACE
         LTORG
 SPACE
         END   STGETR
./ ADD NAME=ASMGF8V
F8V      TITLE     'ASMG F8  EVALUATION ROUTINE'
         ISEQ      73,78
ASMGF8V  START
EEVAL    EQU   ASMGF8V
         PRINT        NOGEN
         FDIMEN
         PRINT      GEN
*                                                                     *
*TITLE 'ASMGF8V ' ...  EXPRESSION EVALUATION                          *
*FUNCTION/OPERATION-                                                  *
*  ASMGF8V EVALUATES EXPRESSIONS AND CONVERTS SELF-DEFINED TERMS TO   *
*   THEIR PROPER VALUES. THE FOLLOWING ERRORS ARE DETECTED AND LOGGED-*
*              RELOCATABILITY      SELF DEFINING VALUE TOO LARGE      *
*              ARITHMETIC OVERFLOW TWO CONSECUTIVE TERMS              *
*              UNDEFINED SYMBOL    TWO CONSECUTIVE OPERATORS          *
*              ILLEGAL CHARACTER   TWO OPERATORS ILLEGALLY COMBINED   *
*              TOO MANY TERMS      TOO MANY LEVELS OF PARENTHESES     *
*              INVALID SYMBOL      PREMATURE END OF EXPRESSION        *
*              EXPRESSION VALUE TOO LARGE                             *
*ENTRY POINT-  ASMGF8V                                                *
*   CALLING SEQUENCE                                                  *
*        L     SRB,CEEVAL(ACT)    PICK UP ASMGF8V ADDRESS FROM ACT    *
*        BALR  SRR,SRB                                                *
*        CEEVAL(ACT) IS LOADED BY ASMGF8I WITH ADDRESS OF ASMGF8V     *
*INPUT-                                                               *
*   REGISTERS-                                                        *
*        SP1 CONTAINS ADDRESS OF FIRST CHARACTER OF THE EXPRESSION TO *
*        BE EVALUATED                                                 *
*   PARAMETERS-                                                       *
*        CTSDVI(ACT)- HIGH-ORDER BIT (BIT 0)                          *
*            0=NO EFFECT UPON ASMGF8V                                 *
*            1=IF THE FIRST (OR ONLY) TERM OF THE EXPRESSION IS A     *
*              SELF-DEFINING TERM, THEN-                              *
*                  THE BIT IS RESET TO 0                              *
*                  THE VALUE OF THE S.D.T. IS PLACED IN REG. SP1      *
*                  CONDITION CODE IS SET TO 0                         *
*                  ASMGF8V EXITS TO CALLING ROUTINE                   *
*        CTSDVI(ACT)- BIT 2                                           *
*            1='PREVIOUSLY DEFINED SYMBOL' ERROR                      *
*        F8YDC+1(ACT)                                                 *
*            X'01'=RESULT IS AN ADCON, MAY BE FOUR BYTES LONG         *
*OUTPUT-                                                              *
*   REGISTERS-                                                        *
*        SP1 CONTAINS ADDRESS OF THE CHARACTER FOLLOWING THE CHARACTER*
*                     WHICH TERMINATED THE EXPRESSION                 *
*                  OR ZERO, IF A SYNTACTICAL ERROR WAS DISCOVERED IN  *
*                     THE EXPRESSION   (FATAL ERROR)                  *
*        SP2 CONTAINS THE VALUE OF THE EXPRESSION, IF THE EXPRESSION  *
*                     WAS ABSOLUTE
*                  OR A POINTER TO AN OUTPUT PARAMETER LIST (RLIST),  *
*                     IF THE EXPRESSION WAS RELOCATABLE.              *
*   CONDITION CODE-                                                   *
*        CC=0   ABSOLUTE EXPRESSION                                   *
*        CC=1   SIMPLY RELOCATABLE EXPRESSION                         *
*        CC=2   COMPLEXLY RELOCATABLE EXPRESSION                      *
*        CC=3   EVALUATION IMPOSSIBLE (ERROR)                         *
*   PARAMETERS-                                                       *
*        LIST POINTED TO BY SP1-                                      *
*             ONE FULL WORD CONTAINING THE VALUE OF THE EXPRESSION    *
*             25 HALF-WORDS, ONE FOR EACH POSSIBLE TERM IN EXPR.      *
*                  ABSOLUTE TERM ENTRIES...BOTH BYTES 0               *
*                  PAIRED RELOCATABLE TERM ENTRIES...BOTH BYTES 0     *
*                  RELOCATABLE TERM ENTRIES...FIRST BYTE=SIGN         *
*                       (1=+,2=-),SECOND BYTE=ESD-ID                  *
*             A SIMPLY RELOCATABLE EXPRESSION WILL HAVE A TERM ENTRY  *
*             IN ONLY THE FIRST HALF-WORD.  THE REMAINING 15 HALF     *
*             WORDS WILL CONTAIN ZEROES.  A COMPLEXLY RELOCATABLE     *
*             EXPRESSION WILL HAVE A NON-ZERO ENTRY FOR EACH UNPAIRED *
*             RELOCATABLE TERM. THESE ENTRIES MAY BE SCATTERED THROUGH*
*             THE PARAMETER LIST.                                     *
*        CTLRCI(ACT), BIT 1                                           *
*            0= NO REFERENCE TO LOCATION COUNTER (*) IN EXPRESSION    *
*            1=REFERENCE TO LOC. CNTR WAS MADE IN EXPRESSION          *
*        STLONG(ACT) CONTAINS LENGTH ATTRIBUTE OF FIRST TERM IN EXPR. *
*EXTERNAL ROUTINES-                                                   *
*        NAME           ROUTINE    USE                                *
*        CSTGET(ACT)    ASMGF8S    FIND SYMBOL IN SYMBOL TABLE        *
*        CLOGER(ACT)    ASMGF8L    LOG ERROR                          *
*EXITS- NORMAL-                                                       *
*        RETURN TO CALLING PROGRAM VIA-                               *
*        BR    SRR                                                    *
*       ERRORS-                                                       *
*          PROCESSING OF EXPRESSION IS COMPLETED AND NORMAL EXIT      *
*          OCCURS IF THESE ERRORS ARE ENCOUNTERED-  (NON-FATAL ERRORS)*
*             EXPRESSION VALUE TOO LARGE                              *
*             SYMBOL NOT PREVIOUSLY DEFINED                           *
*             ARITHMETIC ERROR                                        *
*             RELOCATABILITY ERROR                                    *
*             SELF-DEFINING TERM VALUE TOO LARGE                      *
*                  OR ZERO, IF AN ERROR WAS DISCOVERED IN THE EXPRES'N*
*             THE CONDITION CODE WILL NOT BE 3 FOR 'EXPR. VALUE ECEEDS*
*             RANGE'                                                  *
*          EXPRESSION PROCESSING IS DISCONTINUED, SP1 AND SP2 ARE SET *
*          TO ZERO, AND ASMGF8V RETURNS TO THE CALLING ROUTINE, IF THE*
*          FOLLOWING SYNTACTICAL ERRORS ARE ENCOUNTERED. (FATAL ERR'S)*
*             TWO TERMS NOT SEPARATED                                 *
*             ILLEGAL CHARACTER                                       *
*             TOO MANY TERMS                                          *
*             TWO OPERATORS ILLEGALLY COMBINED                        *
*             TOO MANY LEVELS OF PARENTHESES                          *
*             EXPRESSION END PREMATURE                                *
*             INVALID SYMBOL                                          *
*          IN ALL CASES, THE ERRORS ARE LOGGED.                       *
*TABLES/WORK AREAS-                                                   *
*   TERMS- AN ENTRY IS MADE FOR EACH TERM IN EXPRESSION ... AT END    *
*          OF EVALUATION, FIRST ENTRY CONTAINS RESULT VALUE.          *
*   RLIST- TERM ENTRY PORTION OF OUTPUT PARAMETER LIST.               *
*   NTRMS- AT END OF EVALUATION, FIRST BYTE CONTAINS 2*NUMBER OF      *
*          TERMS.                                                     *
*   OPRNS- AN ENTRY IS MADE FOR EACH OPERATOR IN EXPRESSION.          *
*NOTE-  SEARCH FOR SYMBOLS BEGINS WITH WORK BUCKETS. IF SYMBOL IS NOT *
*       FOUND, SEARCH CONTINUES IN THE SYMBOL TABLE                   *
*   THE TERMINATING CHARACTER WILL ALWAYS BE A LEFT OR RIGHT PARN. OR *
*   A BLANK OR A COMMA, UNLESS THERE WAS A SYNTACTICAL ERROR.         *
*                                                                     *
*  GRD USED FOR BASE OF TERMS WORK AREA
*  GRX USED FOR POINTER TO TERMS LIST
*  GRY USED FOR POINTER TO OPRNS LIST
*  GRZ USED FOR POINTER TO NTRMS LIST
*  GR2 USED FOR POINTER TO RLIST LIST
* GR0,GR1,GRA, AND GRB USED AS WORK REGISTERS
         EJECT
         USING *,SRB                    USING SRB
*
*  INITIALIZE
*
         STM   GRA,GRD,REGSAV           SAVE SOME VOLATILE REGISTERS
         L     GRD,CTFVEVAL(,ACT)       GET ADDR OF TERMS WORK AREA
         USING TERMSWK,GRD              AND SET THE BASE
         SR    GR0,GR0                  ZERO A WORK REGISTER
         STH   GR0,STLONG(,ACT)         ZERO TO STLONG(ACT)
         MVI   TERMS,X'00'              ZERO TO TERMS
         MVC   TERMS+1(TERMSLEN-1),TERMS  ZERO ALL OF TERM WORK AREA
         NI    CTLCRI(ACT),X'BF'        SET BIT FOR LOC. CNTR. REF. OFF
         LA    GRZ,NTRMS                GET ADDRESS OF NTRMS
         LA    GRX,TERMS                GET ADDRESS OF TERMS
         LA    GRY,OPRNS                GET ADDRESS OF OPRNS
         LA    GR2,RLIST                GET ADDRESS OF RLIST
         ST    SP1,FTXPPT              SAV PT TO FIRST BYTE OF EXP
*
*  SCAN OF THE EXPRESSION FOR TERMS OR OPERATORS
*
LOOK     CLI   0(SP1),IALPHA            IS CHAR. ALPHANUMERIC
         BH    NOTAM                    NO, GO LOOK FOR SPECIAL CHAR
         ST    SP1,ERRPT               SAV PT TO FIRST BYTE OF TERM
         STM   GRZ,GRY,SAVE             SAVE 3 WORK REGISTERS
         CLI   0(SP1),IA                IS CHAR. A NUMBER
         BL    DEC                      YES, GO TREAT AS DECIMAL S.D.T.
         CLI   1(SP1),IQUOTE            IS NEXT CHAR. A QUOTE
         BE    NEXTQ                    YES, GO LOOK AT FOLLOWIN CHAR
*
*  SYMBOL IN THE EXPRESSION
*
SYM      DS    0H
         CLI   COND,CONDE               TWO TERMS IN A ROW .Q
         BNL   ERR10                    BAD SHOW, TWO CONSECUTIVE TERMS
         SR    GR0,GR0                  FORM A ZERO AND
         ST    GR0,0(GRX)               ZERO TO TERMS LIST
         CLI   LREF,0                  IS L'SYMBOL
         BE    TRYSWB                  NO
         CLI   0(SP1),IMULT            IS L'*
         BNE   TRYSWB                  NO
         MVI   3(GRX),1                1 TO TERMS LIST
         MVI   LREF,0                  CLEAR LREF
         MVN   LREF(1),F8INST+15(ACT)  MOVE IN LENGTH ATTRIBUTE
         CLI   LREF,2                   IS IT A ZERO OR A ONE
         BL    ATTR1                   0YES, GIVE VALUE OF ONE
         CLI   LREF,8                   IS IT .GT. 8
         BH    ATTR1                   GYES, SET VALUE OF ONE
         MVC   3(1,GRX),LREF           PUT L'* VALUE IN TERMS LIST
ATTR1    LA    SP1,1(SP1)              POSITION SP1 TO CHAR. AFTER *
         B     LSTAR
*
*  LOOK FOR SYMBOL VALUE IN WORK BUCKET
*
*
* CTXWBP(ACT), FULL WORD ALIGNED, POINTS TO 'NEXT' SYMBOL WORK BUCKET.
* WHEN ZERO, THERE IS NO 'NEXT' SYMBOL WORK BUCKET.
*
TRYSWB   L     SP2,CTXWBP(ACT)         POINTER TO NEXT SYM. WK-BUCKET
         LTR   SP2,SP2                  IS THERE A NEXT SYM. WK-BUCKET
         BZ    TRYST
         LR    GR1,SP2                  YES, LOAD WORK BUCKET POINTER
         LA    GR1,6(GR1)               BUMP POINTER TO SYM. WK-BUCKET
         ST    GR1,CTXWBP(ACT)                    BY 6
         TM    TXSUBS(SP2),X'10'        IS VALUE IN WORK-BUCKET
         BO    WBFNDX                   YES, DONT SEARCH SYMBOL TABLE
*
*  LOOK FOR SYMBOL VALUE IN SYMBOL TABLE
*
TRYST    STM   SRB,SP2,NCOMP            SAVE OUR BASE
         SR    SP2,SP2                  SET LENGTH UNKNOWN
         L     SRB,CSTGET(ACT)          LOAD BASE/ENTRY
         BALR  SRR,SRB                  TO STGET ROUTINE
         DROP  SRB                      SRB DESTROYED BY STGET, SO
         USING *,SRR                    USE TEMP. BASE OF SRR
         LTR   GR1,SP1                  POINTER TO GR1 AND TEST
         LR    GR0,SP2                  LENGTH OF SYMBOL TO GR0
         LM    SRB,SP2,NCOMP            RESTORE OUR BASE
         DROP  SRR                      BASE SRB RESTORED, DROP TEMP.
         USING EEVAL,SRB                SRR AND START USING OUR BASE
         BC    7,FOUND                  HAS SYMBOL BEEN FOUND
*
*  SYMBOL NOT FOUND IN EITHER A WORK BUCKET OR THE SYMBOL TABLE
*
         MVI   TERMS,0
         MVC   TERMS+1(RCNTR-TERMS),TERMS  ZERO TERMS, RLIST AND RCNTR
         C     GR0,FSEVEN               IF SYMBOL LEN-1 GT SEVEN
         BH    ERR3                     LOG ERROR /INVALID SYMBOL/
         B     ERR15                    SYMBOL NOT FOUND
SCANE    LA    SP1,1(SP1)               SCAN TO END OF SYMBOL
COND3    EQU   SCANE
         CLI   0(SP1),IPLUS             SEE IF AT END OF SYMBOL
         BL    SCANE                    NO, LOOP FOR NEXT CHAR
         B     COMPT4                   YES, START AGAIN
*
*  SYMBOL VALUE FOUND IN SYMBOL TABLE
*
FOUND    AR    SP1,GR0                  ADD SYMBOL LENGTH TO PTR
         LA    SP1,1(SP1)               UP TO NEXT CHAR
         CLI   LREF,0                   IS L'SYMBOL
         BH    LSYM                     YES, PROCESS
         TM    1(GR1),3                 IS THIS A NAME
         BC    14,ESDMV                NO
         CLI   SYMBL,0                  IS THIS THE FIRST TERM
         BH    MOVE                     NO, BRANCH
         MVC   STLONG(2,ACT),6(GR1)     LENGTH TO STLONG
MOVE     MVC   1(3,GRX),3(GR1)          VALUE TO TERMS LIST
         CLI   2(GR1),0                 IS ABSOLUTE TERM
         BE    COMPT4                   YES, BRANCH
ESDMV    MVC   1(1,GR2),2(GR1)          ESD-ID TO RLIST
         TM    1(GR1),X'04'             IS DSECT-COM BIT ON (BIT5)
         BC    7,OUT
         TM    1(GR1),X'03'            IS EXTRN(01) OR DSECT(10)
         BM    OUT              YES
*
*  LOOK FOR ADJUSTMENT VALUE FOR RELOCATABLE SYMBOL
*
SUCH     CLC   1(1,GR2),CESDID(ACT)     IS THIS THE CURRENT ESD-ID
         BE    OUTL                     YES, GET OUT OF LOOP
         L     SP2,CTADJEND(0,ACT)      ADDRESS OF END OF ADJ TABLE
         L     GR1,CADJBS(ACT)          ADDRESS OF START OF ADJ TABLE
FINDA    CLC   1(1,GR2),0(GR1)          IS THIS THE ESD-ID
         BE    ADDV                     YES, GET OUT
         LA    GR1,4(GR1)               BUMP GR1 BY 4 (FOR ADJ TABLE)
         CLR   GR1,SP2                  HAVE REACHED END OF ADJ TABLE
         BL    FINDA                    NO, LOOP
         B     OUT                      YES, QUIT
ADDV     MVC   NCOMP+1(3),1(GR1)        ADJ VALUE TO NCOMP
         MVI   NCOMP,0
         L     GR1,NCOMP                ADJ VALUE TO GR1
ADDADJ   A     GR1,0(GRX)               ADD ADJ VALUE TO S. T. VALUE
         ST    GR1,0(GRX)
         MVI   0(GRX),X'00'            ZERO 1ST BYTE
OUT      DS    0H
         MVI   COND,CONDF               SET RELOCATABLE TERM
         MVI   0(GR2),1                 CODE FOR + SIGN = 1 TO RLIST
         IC    GR1,RCNTR                BUMP RCNTR BY 1 (RELOCATABLE)
         LA    GR1,1(GR1)
         STC   GR1,RCNTR
         B     COMPT                    CONTINUE
*
*  SYMBOL VALUE FOUND IN WORK BUCKET
*
WBFNDX   LA    SP1,1(SP1)               SCAN TO END OF SYMBOL
         CLI   0(SP1),IPLUS             IS IT STILL PART OF SYMBOL
         BL    WBFNDX                   YES, CONTINUE SCAN
         CLI   LREF,0                   IS L'SYMBOL
         BH    LSYMWB                   YES, PROCESS
         TM    TXSTPC(SP2),X'03'       IS THIS A NAME
         BC    14,WBESDMV              NO
         CLI   SYMBL,0                  IS THIS THE FIRST TERM
         BH    WBFNDY                   NO, SKIP FIRST TERM PROCESSING
         MVC   STLONG+1(1,ACT),TXSLEN(SP2)
         TM    TXSEXI(SP2),X'04'        IS LENGTH GR THAN 256
         BZ    WBFNDY                   NO, LEAVE AS IS
         MVI   STLONG(ACT),255          SET FIRST BYTE OF STLONG =255
WBFNDY   MVC   1(3,GRX),TXSVAL(SP2)     VALUE TO TERMS LIST
         CLI   TXSESD(SP2),0           IS ABSOLUTE TERM
         BE    COMPT4                   YES
WBESDMV  MVC   1(1,GR2),TXSESD(SP2)    ESD-ID TO RLIST
         TM    TXSDOC(SP2),X'20'        IS DSECT-COM BIT ON (BIT 2)
         BC    7,OUT                    YES
         TM    TXSTPC(SP2),X'03'       IS EXTRN(01) OR DSECT(10)
         BM    OUT              YES
         B     SUCH                     NO, LOOK FOR ADJUSTMENT VALUE
*
*  L'SYMBOL VALUE FOUND IN SYMBOL TABLE
*
LSYM     TM    1(GR1),3                 IS THIS A NAME
         BC    14,UPLSYM                NO
MOVEL    MVC   2(2,GRX),6(GR1)          LENGTH TO TERMS LIST
         B     UPLSYM                   CONTINUE
*
*  L'SYMBOL VALUE FOUND IN WORK BUCKET
*
LSYMWB   MVC   1(3,GRX),TXSVAL(SP2)    LENGTH TO TERMS LIST        6822
UPLSYM   L     GR1,0(GRX)
         LA    GR1,1(GR1)
         ST    GR1,0(GRX)               BUMP VALUE OF L'SYMBOL BY 1
LSTAR    MVI   LREF,0                  SET LREF TO ZERO
         B     COMPT4                   GO ON
*
*  DECIMAL SELF-DEFINING VALUE IN THE EXPRESSION
*
DEC      LA    SHFR,3                   DEC. TYPE INDICATOR TO SHFR
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,8                    MAX. NO. OF CHAR. TO GR0
         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS
         ST    VALR,0(GRX)              VALUE TO TERMS LIST
         CLI   0(GRX),0                 IS FIRST BYTE ZERO
         BH    ERR0                     NO, ERROR - TOO LARGE
         B     ABSD                     GO ON
*
*  1ST CHARACTER IS ALPHABETIC AND 2ND IS A QUOTE
*
NEXTQ    CLI   0(SP1),IB                IS BINARY SELF-DEF. VALUE
         BE    BINRY                    YES, BINARY CONVERT
         CLI   0(SP1),IC                IS CHARACTER SELF-DEF. VALUE
         BE    CHARS                    YES, CHARACTER CONVERT
         CLI   0(SP1),IX                IS HEXADECIMAL SELF-DEF. VALUE
         BE    HEX                      YES, HEXADECIMAL CONVERT
         CLI   0(SP1),IL                IS L'SYMBOL
         BNE   ERR9                     NO, ERROR - ILLEGAL CHAR
*
*  L'SYMBOL IN THE EXPRESSION
*
         LA    SP1,2(SP1)               POINT SP1 TO 1ST CHAR. OF SYM.
         MVI   LREF,X'FF'               SET L'SYMBOL FLAG NON-ZERO
         CLI   0(SP1),IALPHA           IS CHAR. ALPHANUMERIC
         BNH   ALPHA                   YES
MAYLCNTR CLI   0(SP1),IMULT            IS CHAR. *
         BNE   ERR9                    NO
ALPHA    CLI   0(SP1),IA               IS CHAR. ALPHABETIC
         BL    ERR9                    NO
*
* IN WORK BUCKET, VALUE = LENGTH.
* IN SYMBOL TABLE, PICK UP LENGTH ATTRIBUTE PART OF SYMBOL.
*
         B     SYM                      SYMBOL IN EXPRESSION
*
*  BINARY SELF-DEFINING VALUE IN THE EXPRESSION
*
BINRY    LA    SHFR,1                   BINARY TYPE INDICATOR TO SHFR
         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,24                   MAX. NO. OF CHAR. TO GR0
         B     LM                       CONTINUE
*
*  CHARACTER SELF-DEFINING VALUE IN THE EXPRESSION
*
CHARS    LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.
         LA    SHFR,8                   CHAR. TYPE INDICATOR TO SHFR
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,3                    MAX. NO. OF CHAR. TO GR0
         LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS
         ST    VALR,0(GRX)              VALUE TO TERMS LIST
         L     SP2,CTRTBP(ACT)          POINTER TO TRANSLATE TABLE
         TR    0(4,GRX),0(SP2)          TRANSLATE CHAR. VALUE
         B     CKQ                      CONTINUE
*
*  HEXADECIMAL SELF-DEFINING VALUE IN THE EXPRESSION
*
HEX      LA    SHFR,4                   HEX TYPE INDICATOR TO SHFR
         LA    SP1,2(SP1)               POSITION SP1 TO FIRST CHAR.
         BAL   RETR,SDVCF               TO SELF-DEFINING VALUE ROUTINE
         LA    GR0,6                    MAX. NO. OF CHAR. TO GR0
LM       LM    GRZ,GRY,SAVE             RE-LOAD SAVED REGISTERS
         ST    VALR,0(GRX)              VALUE TO TERMS LIST
CKQ      CLI   0(SP1),IQUOTE            IS ENDING CHAR. A QUOTE
         BNE   ERR9                     NO, ERROR - ILLEGAL CHAR
         LA    SP1,1(SP1)               POSITION SP1 TO CHAR. AFTER '
         LTR   CNTR,CNTR                IS CNTR ZERO
         BZ    ERR9                     YES, ERROR - ILLEGAL CHAR
ABSD     CLR   CNTR,GR0                 IS CNTR GR THAN MAX.
         BH    ERR0                     YES, ERROR - TOO MUCH
         CLI   COND,CONDA               IS COND UNCHANGED .Q
         BH    ABSCK                    NO, TEST FOR .GT. 2
         TM    CTSDVI(ACT),X'80'        IS BIT FOR SELF-DEF. VALUE ON
         BZ    ABSCK+8                  NO
         NI    CTSDVI(ACT),X'7F'        SET THE BIT OFF
         B     FINIS
ABSCK    DS    0H
         CLI   COND,CONDE               TWO TERMS IN A ROW .Q
         BNL   ERR10                    ERROR IF YES
COMPT4   DS    0H
         MVI   COND,CONDE               SET ABSOLUTE TERM
COMPT    DS    0H
         LA    GR0,RLIST                START OF RELOC LIST
         LR    GRB,GR2                  THIS IS WHERE WE'RE AT
         SR    GRB,GR0                  THIS IS THE DIFFERENCE
         CH    GRB,CTTERMC(,ACT)        TOO MANY TERMS .Q
         LA    GRB,MNYERR               DIAGNOSTIC IF SO
         BH    FATLER1
         OI    SYMBL,1                  OR SYMBL WITH 1
         MVI   0(GRZ),2                 2 TO NTRMS LIST
         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS)
         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS)
         LA    GR2,2(GR2)               BUMP GR2 BY 2 (FOR RLIST)
         B     LOOK                     GO ON IN STRING
*
*  1ST CHARACTER IS NOT ALPHANUMERIC
*
NOTAM    CLI   0(SP1),ICOMMA            IS CHAR. A COMMA
         BL    LTCOM                    NO, IS A +,-,*, OR /
         BE    BLCOM                    YES, GO TO BLANK OR COMMA
         CLI   0(SP1),ILPARN            IS CHAR. A LEFT PAREN.
         BE    LPAR                     YES
         BL    ERR9                     NO, ERROR - ILLEGAL CHAR
         CLI   0(SP1),IQUOTE            IS CHAR A ' OR ) OR BLANK
         BL    RPAR                     RIGHT PARN
         BH    BLCOM                    BLANK
         B     ERR9               ' IS ILLEGAL FIRST CHAR.
*
*  RIGHT PARENTHESIS IN THE EXPRESSION
*
RPAR     DS    0H
         CLI   COND,CONDE               DOES RIGHT PAREN FOLLOW TERM .Q
         BL    ERR12                    NO, ERROR - TWO CONSECUTIVE OPS
         MVI   COND,CONDE               SET RIGHT PAREN COND
         CLI   PCNTR,0                  IS PCNTR =0
         BH    NOEND                    NO
         B     ENDNG                    YES
*
*  1ST CHARACTER IS EITHER +,-,*, OR /.
*
LTCOM    CLI   0(SP1),IASTER            IS CHAR. AN ASTERISK
         BE    STAR                     YES
         BH    SLASH                    BRANCH IF /
*
*  + OR - IN THE EXPRESSION
*
PLMIN    DS    0H
         CLI   COND,CONDE               WAS LAST ENTRY A TERM .Q
         BNL   PLMIN3                   BRANCH IF YES
         TM    CTEXTENI(ACT),X'04'      IS EXTEN ON .Q
         BZ    ERR12                    NO UNARY +,- IF NOT
         CLI   COND,CONDA               1ST OPERATOR/TERM .Q
         BE    COMPT4                   ENTER ZERO OPERAND IF YES
         MVI   COND,CONDC               UNARY OPERATOR
PLMIN2   DS    0H
         LA    GR0,IALPHA-2             BUMP OPERATOR BY TWO
         B     SET1                     AND ENTER SAME
PLMIN3   DS    0H
         MVI   COND,CONDB               BINARY + OR -
SET      DS    0H
         LA    GR0,IALPHA               TO CALCULATE NEWOP
SET1     DS    0H
         IC    GR1,0(SP1)               GET THIS CHAR
         SR    GR1,GR0
         STC   GR1,NEWOP                HIERARCHY CODE TO NEWOP
*
*  MAIN LOOP TO PERFORM ARITHMETIC
*
LOOP     DS    0H
         LA    GR1,OPRNS                POINT TO FIRST OPERATOR ENTRY
         CR    GRY,GR1                  ARE THERE PREVIOUS OPERATORS .Q
         BH    ONZ                      YES
         CLI   ENDOE,0                  IS ENDOE=0
         BH    FINIS                    NO
PUT      MVC   0(1,GRY),NEWOP           NEWOP TO OPRNS LIST
BUMPY    LA    GRY,1(GRY)               BUMP GRY BY 1 (FOR OPRNS)
BUMPR    LA    SP1,1(SP1)               BUMP SP1 BY 1 (FOR NON-ALFNUM)
         B     LOOK                     CONTINUE IN STRING
ONZ      BCTR  GRY,0                    POINT GRY TO PREVIOUS OPERATOR
         CLC   0(1,GRY),NEWOP           IS NEW HIERARCHY LT-EQ PREVIOUS
         BNL   LE                       YES
         CLI   NEWOP,OPSLASH            TEST NEW OP /
         BNE   STEPUP                   NO
         CLI   0(GRY),OPSTAR            TEST PREV OP *
         BE    WORK                     YES, DO * FIRST
STEPUP   LA    GRY,1(GRY)               ADD 1 BACK TO GRY
         B     PUT
LE       DS    0H
         CLI   NEWOP,OPUMINUS           IS THIS UNARY - .Q
         BE    STEPUP                   JUST ENTER IT IF YES
         CLI   NEWOP,OPUPLUS            IS THIS UNARY + .Q
         BE    STEPUP                   JUST ENTER IT IF YES
         CLI   0(GRY),OPEND             IS OLD HIERARCHY ZERO .Q
         BH    WORK                     NO
         IC    GR1,PCNTR                SUBTRACT 1 FROM PCNTR
         BCTR  GR1,0
         STC   GR1,PCNTR
         B     BUMPR                    CONTINUE LOOP
*
*  LEFT PARENTHESIS IN THE EXPRESSION
*
LPAR     DS    0H
         CLI   COND,CONDE               WAS A TERM LAST ENTRY .Q
         BNL   LPEND                    YES, PROCESS END
         MVI   COND,CONDB               SET LEFT PAREN COND
         SR    GR1,GR1                  ZERO WORK REGISTER
         IC    GR1,PCNTR                GET CURRENT PAREN COUNT
         CH    GR1,CTPARENC(,ACT)       TOO MANY LEVELS OF PARENS .Q
         LA    GRB,PARERR               DIAGNOSTIC IF SO
         BH    FATLER2                  BRANCH IF PAREN ERROR
         LA    GR1,1(,GR1)              BUMP PCNTR BY ONE
         STC   GR1,PCNTR
         MVI   0(GRY),0                 ZERO TO OPRNS LIST
         B     BUMPY                    RETURN TO PERFORM ARITHMETIC
*
*  ASTERISK IN THE EXPRESSION
*
STAR     DS    0H
         CLI   COND,CONDD               FORMER STAR OR SLASH .Q
         BE    ERR12                    YES, ERROR - 2 CONSECUTIVE OPS
         BL    LCNTR                    BRANCH IF LOC CNTR REFERENCE
*
*  ASTERISK IS MULTIPLICATION OPERATOR
*
FORD1    DS    0H
         MVI   COND,CONDD               SET MULT/DIV COND
         B     PLMIN2                   GO ADJUST OPERATION
*
*  SLASH IN THE EXPRESSION
*
SLASH    DS    0H
         CLI   COND,CONDE               DOES A TERM PRECEDE
         BL    ERR12                    ERROR IF NOT
         B     FORD1                    CONTINUE AS THOUGH MULTIPLICATN
*
*  BLANK OR COMMA IN THE EXPRESSION
*
BLCOM    DS    0H
         CLI   COND,CONDE               TERM PRECEDE BLANK OR COMMA .Q
         BL    ERR17                    ERROR IF NOT
*
*  LEFT PARENTHESIS END CONDITION
*
LPEND    CLI   PCNTR,0                  IS PCNTR =0
         BH    ERR17                    NO, ERROR
ENDNG    MVI   ENDOE,15                 SET ENDOE NON-ZERO
NOEND    DS    0H
         MVI   NEWOP,OPEND              SET NEWOP ZERO
         B     LOOP                     MAIN ARITH LOOP
*
*  ASTERISK IS LOCATION COUNTER
*
LCNTR    OI    CTLCRI(ACT),X'40'        SET BIT FOR LOC. CNTR. REF. ON
         LA    SP1,1(SP1)               POSITION SP1 TO NEXT CHAR.
         L     SP2,CTXABP(ACT)          POINTER TO LOC. CNTR.
         MVC   1(3,GRX),TXLOC(SP2)      LOC. CNTR VALUE TO TERMS LIST
         MVI   0(GRX),0
         CLI   SYMBL,0                 IS THIS THE FIRST TERM
         BH    LCNTR2                  NO
         MVN   LREF(1),F8INST+15(ACT)  MOVE IMPLIED EXPRESSION LENGTH
         CLI   LREF,0                  DONT DECREMENT LREF IF ZERO
         BE    LCNTR1                   ZERO, SO DONT
         IC    GR1,LREF                TO TEMP LOC
         BCTR  GR1,0                   DECREMENT BY 1
         STC   GR1,LREF                AND MOVE
LCNTR1   MVC   STLONG+1(1,ACT),LREF         TO STLONG
         MVI   LREF,0                  SET LREF TO ZERO
LCNTR2   MVC   1(1,GR2),CESDID(ACT)    CURRENT ESD-ID TO RLIST
OUTL     L     GR1,F8CADJ(ACT)          CURRENT ADJ VALUE TO GR1
         B     ADDADJ                   PROCESS END OF ADJUSTMENT
*
*  PERFORM ARITHMETIC AND RELOCATABILITY WORK
*
WORK     ST    GR2,NCOMP                STORE GR2 IN NCOMP
         LA    GR0,8                    POINT GRX TO 1ST OF THE 2
         SR    GRX,GR0                       TERMS ENTRIES
         LA    GR0,2                    POINT GRZ TO 1ST OF THE 2
         SR    GRZ,GR0                       NTRMS ENTRIES
         IC    GR0,1(GRZ)               2ND NTRMS  ENTRY TO GR0
         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2
         SR    GR1,GR1                  ZERO A WORK REGISTER
         IC    GR1,0(,GRY)              GET OPERATOR FUNCTION
         AR    GR1,GR1                  DOUBLE IT
         LH    GR1,OPBRANCH(GR1)        GET INDEX BRANCH VALUE
         B     ASMGF8V(GR1)             THE APPROPRIATE ROUTINE
OPBRANCH DC    H'1'                     ZERO ERROR
         DC    AL2(OPPLS-ASMGF8V)       BINARY PLUS
         DC    AL2(OPMINS-ASMGF8V)      BINARY MINUS
         DC    AL2(OPUPLS-ASMGF8V)      UNARY PLUS
         DC    AL2(OPUMINS-ASMGF8V)     UNARY MINUS
         DC    AL2(MULDV-ASMGF8V)       MULTIPLICATION
         DC    AL2(MULDV-ASMGF8V)       DIVISION
*
*  OPERATOR IS SUBTRACTION.  COMPLEMENT 2ND VALUE AND CHANGE THE
*  RELOCATION SIGN BYTE OF THE TERMS IN THE 2ND VALUE.
*
OPUMINS  DS    0H
         CLI   0(GR2),OPPLUS            IS SIGN BYTE + .Q
         BL    NOCHGU                   BRANCH IF ABSOLUTE
         BE    PLCHGU                   BRANCH IF SIGN +
         MVI   0(GR2),OPPLUS            CHANGE - SIGN TO +
         B     NOCHGU                   AND CONTINUE
PLCHGU   DS    0H
         MVI   0(GR2),OPMINUS           CHANGE + SIGN TO -
NOCHGU   DS    0H
         L     GR1,4(,GRX)              GET CURRENT VALUE
         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY
OPUSET   DS    0H
         LA    GRX,4(,GRX)              BUMP OPND POINTER
         L     GR2,NCOMP                RESTORE RLIST POINTER
         LA    GRZ,1(,GRZ)              UNARY HAS BUT ONE TERM
         B     STORE                    AND CONTINUE
OPUPLS   DS    0H
         L     GR1,4(,GRX)              GET CURRENT VALUE
         B     OPUSET                   AND REENTER IT
*
OPMINS   DS    0H
         L     GR1,4(,GRX)              GET 2ND TERMS LIST ENTRY
         LCR   GR1,GR1                  COMPLEMENT 2ND TERMS LIST ENTRY
         ST    GR1,4(GRX)
CHG      DS    0H
         CLI   0(GR2),OPPLUS            TEST SIGN BYTE IN 2ND RLIST
         BL    NOCHG                    BRANCH IF ABS. VALUE
         BE    PLCHG                    BRANCH IF SIGN +
         MVI   0(GR2),OPPLUS            CHANGE SIGN TO +
         B     NOCHG
PLCHG    DS    0H
         MVI   0(GR2),OPMINUS           CHANGE SIGN TO -
NOCHG    DS    0H
         LA    GR2,2(,GR2)              POINT GR2 TO NEXT ENTRY
         CL    GR2,NCOMP                ARE THERE MORE ENTRIES
         BL    CHG                      BRANCH BACK IF MORE ENTRIES
         SR    GR2,GR0                  SUBT. 2ND NTERMS ENTRY FRM GR2
*
*  OPERATION IS ADDITION OR SUBTRACTION.  SCRATCH ENTRIES IN THE
*  RELOCATION LIST WHERE POSSIBLE.
*
OPPLS    IC    GR0,0(GRZ)               1ST NTRMS  ENTRY TO GR0
         LR    GR1,GR2                  POINT GR1 TO 2ND NTRMS LIST
         SR    GR2,GR0                  POINT GR2 TO 1ST NTRMS LIST
         LR    SP2,GR1                  SAVE GR1 IN SP2
BCOMP    DS    0H
         CLI   0(GR2),OPPLUS            IS FIRST SIGN + (CODE =1)
         BL    NSCR                     BRANCH IF ABS. VALUE (CODE =0)
         BH    F2MIN                    BRANCH IF FIRST SIGN -
         CLI   0(GR1),OPMINUS           IS SECOND SIGN -
         BL    NSCR                     BRANCH IF SIGN NOT -
OPP      CLC   1(1,GR2),1(GR1)          COMPARE FIRST TO SECOND ESD-ID
         BNE   NSCR                     BRANCH IF NOT THE SAME
         MVI   0(GR2),0                 ZERO TO FIRST SIGN
         MVI   1(GR2),0                 ZERO TO FIRST ESD-ID
         MVC   0(2,GR1),0(GR2)          ZERO TO 2ND SIGN AND ESD-ID
         IC    GR0,RCNTR                SUBTRACT 2 FROM RCNTR
         BCTR  GR0,0                    MINUS 1
         BCTR  GR0,0                      MINUS 1 MORE
         STC   GR0,RCNTR                     SAVE
         B     NSCR
F2MIN    DS    0H
         CLI   0(GR1),OPPLUS            IS SECOND SIGN +
         BE    OPP                      YES
NSCR     LA    GR1,2(GR1)               POINT GR1 TO NEXT IN 2ND RLIST
         CL    GR1,NCOMP
         BL    BCOMP                    BRANCH BACK IF MORE IN 2ND LIST
         LA    GR2,2(GR2)               POINT GR2 TO NEXT IN 1ST LIST
         LR    GR1,SP2                  START OF 2ND LIST BACK TO GR1
         CLR   GR1,GR2
         BH    BCOMP                    BRANCH BACK IF MORE IN 1ST LIST
         L     GR2,NCOMP                NCOMP BACK TO GR2
         LCR   GR1,GR1                  COMPLEMENT GR1
         AR    GR1,GR2                  2ND NTRMS ENTRY TO GR1
         IC    GR0,0(GRZ)               1ST NTRMS ENTRY TO GR0
         AR    GR1,GR0                  ADD THE 2 NTRMS ENTRIES
         STC   GR1,0(GRZ)               SUM TO POSITION OF THE 1ST
*
*  PERFORM ADDITION
*
         L     GR1,0(GRX)               1ST TERMS LIST ENTRY TO GR1
         A     GR1,4(GRX)               ADD 2ND ENTRY
         BO    ERR13             -DUMMY-APPROP. OVERFLOW ROUTINE TO SYS
STORE    ST    GR1,0(GRX)               RESULT TO 1ST TERMS LIST ENTRY
         LA    GRX,4(GRX)               BUMP GRX BY 4 (FOR TERMS LIST)
         LA    GRZ,1(GRZ)               BUMP GRZ BY 1 (FOR NTRMS LIST)
         B     LOOP                     CONTINUE IN ARITH LOOP
*
*  OPERATOR IS MULTIPLICATION OR DIVISION.  CHECK THAT NO RELOCATABLE
*  TERMS REMAIN IN THE 2 VALUES.
*
MULDV    SR    GR1,GR1                  CLEAR GR1
         IC    GR1,0(GRZ)               1ST NTERMS ENTRY TO GR1
         AR    GR0,GR1                  ADD THE 2 NTRMS ENTRIES
         STC   GR0,0(GRZ)               SUM TO 1ST ENTRY LOCATION
         SR    GR2,GR1                  SUBT. 1ST NTRMS ENTRY FROM GR2
         LA    GR0,2                    2 TO GR0
         L     GR1,NCOMP
         SR    GR1,GR0                  C(NCOMP)-2 TO GR1
MORE     CLI   0(GR2),0                 IS IT A RELOCATABLE VALUE
         BH    ERR11                    YES, ERROR
MORE1    BXLE  GR2,GR0,MORE
         SR    GR1,GR1                  ZERO GR1
         C     GR1,4(GRX)
         BE    STORE                    BRANCH IF 2ND TERMS ENTRY =0
         L     GR0,0(GRX)               1ST TERMS ENTRY TO GR0
         SRDA  GR0,32                   PROPAGATE SIGN BIT
         CLI   0(GRY),OPSTAR            IS OPERATOR * OR /
         BH    DIV                      BRANCH IF /
*
*  PERFORM MULTIPLICATION
*
         M     GR0,4(GRX)               MULTIPLY BY 2ND TERMS ENTRY
         LTR   GR1,GR1
         BNL   CHK0                     BRANCH IF LOW-ORDER NON-NEG
         LCR   GR0,GR0                  COMPLEMENT HIGH-ORDER
         BCTR  GR0,0                    SUBTRACT 1 FROM THE COMPLEMENT
CHK0     LTR   GR0,GR0                  SEE IF ZERO
         BNZ   ERR13                    ERROR IF HIGH-ORDER NOW NOT=0
         B     STORE                    SAVE RESULT
*
*  PERFORM DIVISION
*
DIV      D     GR0,4(GRX)               DIVIDE 1ST BY 2ND TERMS ENTRY
         B     STORE                    SAVE RESULT
*
*  END OF EXPRESSION FOUND
*
FINIS    TM    F8YDC+1(ACT),X'01'       IS THIS ADCON
         BO    NOTST                    YES,ADCON MAY BE 4 BYTES
         BAL   GRZ,DATATST              RESULT MUST NOT EXCEED 3 BYTES
NOTST    DS    0H
         L     SP2,TERMS                MOVE RESULT TO SP2
         ST    SP2,RLIST-4              RESULT TO HEAD RLIST
         CLI   ERROR,0                  WERE THERE ERRORS
         BH    SETE                     YES
         CLI   RCNTR,0                  IS IT RELOCATABLE
         BE    SETRET                   RETURN WITH CC=0 (ABSOLUTE EXP)
         LA    SP2,RLIST-4              POINTER TO RESULT TO SP2
         CLI   RCNTR,1                  IS IT COMPLEX RELOCATABLE
         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)
         LA    GR1,RLIST-2              FIND FIRST AND ONLY RLIST ENTRY
FIND     LA    GR1,2(GR1)                    WHERE SIGN BYTE NON-ZERO
         CLI   0(GR1),1                 IS THIS IT
         BL    FIND                     NO, KEEP LOOKING
         BH    SETRET                   RETURN WITH CC=2 (COMPLX REL.)
         MVC   RLIST(2),0(GR1)          MOVE ENTRY TO TOP OF LIST
         XC        RLIST+2(30),RLIST+2 ZERO REST OF LIST
         CLI   0(GR1),2                 SET CC = 1
         B     SETRET                   RETURN WITH CC=1 (SIMPLY REL.)
*
DATATST  TM    TERMS,X'FF'              VALUE EXCEEDS 3 BYTES
         BCR   11,GRZ                   (BNM) NO
         STM   SRB,GR2,NCOMP
         L     SP1,FTXPPT               SET COL PTR TO 1ST BYTE
         L     SRB,CLOGER(ACT)          TO LOGERR
         BALR  SRR,SRB
         DROP  SRB                      SAME THING CONCERNING OUR BASE
         USING *,SRR                    SO USE TEMP. UNTIL RESTORED
         DC    AL2(VALTOLG)             ERROR CODE
         LM    SRB,GR2,NCOMP            RESTORE
         DROP  SRR                      DROP TEMP.
         USING EEVAL,SRB                AND USE OURS
DATAOK   MVI   TERMS,0                  ZERO 1ST BYTE OF RESULT
         BR    GRZ
         EJECT
*
*
*  ERROR FOUND
*
* TABLE OF ERROR CODES USED IN EEVAL
INVALID  EQU   18                       INVALID SYMBOL
RELERR   EQU   25                  RELOCATABILITY ERROR
SELFDEF  EQU   91                  SELF-DEF. VALUE TOO LARGE
ARITHER  EQU   56                  ARITHMETIC ERROR-OVERFLOW
UDSERR   EQU   24                  UNDEFINED SYMBOL
ILORDER  EQU   85                  TWO TERMS NOT SEPARATE
ILLCHAR  EQU   85                  ILLEGAL CHARACTER
MNYERR   EQU   27                  EXP. CONTAINS MORE THAN CTTERMC TRMS
OPERR    EQU   85                  TWO OPERATORS ILLEGALLY COUPLED
PARERR   EQU   26                  TOO MANY LEVELS OF PARENS
ENDERR   EQU   39                  EXP. END PREMATURE-UNPAIRED PAREN
VALTOLG  EQU   110              VALUE EXCEEDS RANGE
* NON-FATAL ERROR FOUND
* LOG ERROR, CONTINUE NORMAL PROCESSING
*
*  ERROR IS RELOCATABLE TERM INVOLVED IN A MULT. OR DIV. OPERATION
*
ERR11    LA    GRA,MORE1                RETURN ADDRESS
         LA    GRB,RELERR          RELOCATABILITY ERROR
         B     NFATLER1
*
*  ERROR IS SELF-DEFINING VALUE TOO LARGE
*
ERR0     LA    GRA,ABSD+6               RETURN ADDRESS
         LA    GRB,SELFDEF         SELF-DEF. VALUE TOO LARGE
         B     NFATLER2
*
* ERROR IS SYMBOL LENGTH
*
ERR3     LA    GRA,SCANE                RETURN ADDRESS
         LA    GRB,INVALID              SYMBOL TOO LONG
         B     ERRXXX
*
*
*  ERROR IS ARITHMETIC
*
ERR13    LA    GRA,STORE                RETURN ADDRESS
         LA    GRB,ARITHER         ARITHMETIC ERROR
         B     NFATLER1
*
* ERROR IS SYMBOL NOT FOUND OR SYMBOL MUST BE PREVIOUSLY DEFINED
*
ERR15    LA    GRA,SCANE                RETURN ADDRESS
ERR15B   LA    GRB,UDSERR          UNDEFINED SYMBOL
         B     ERRXXX
*
NFATLER1 MVC   ERRPT(4),FTXPPT         SET COL PTR TO 1ST BYTE
NFATLER2 STM   SRB,GR2,NCOMP            SAVE
         L     SP1,ERRPT                ERROR POSITION
         B     ERRXX
*
* FATAL ERROR FOUND
* LOG ERROR, EXIT FROM EEVAL WITH SP1 AND SP2 EQUAL 0
*
*
*ERROR IS ILLEGAL CHARACTER
*
ERR9     LA    GRB,ILLCHAR         ILLEGAL CHARACTER
         B     FATLER2
*
* ERROR IS TWO CONSECUTIVE OPERATORS
*
ERR12    LA    GRB,OPERR           ILLEGAL ORDER OF OPERATORS
         B     FATLER2
*
*ERROR IS ILLEGAL END OF EXPRESSION OR UNPAIRED PARENS
*
ERR17    LA    GRB,ENDERR          EXPRESSION END PREMATURE
         B     FATLER2
*
* ERROR IS TWO CONSECUTIVE TERMS
*
ERR10    LA    GRB,ILORDER         ILLEGAL ORDER OF TERMS
*
FATLER1  STM   SRB,GR2,NCOMP            SAVE
         L     SP1,ERRPT               PT TO 1ST OF TERM OR EXP.
         LA    GRA,EXERR                FATAL ERROR EXIT
         B     ERRXX
FATLER2   LA   GRA,EXERR                FATAL ERROR EXIT
*
*
ERRXXX   STM   SRB,GR2,NCOMP            SAVE
ERRXX    STH   GRB,ERCODE               PUT IN ERROR CODE
         MVI   ERROR,X'FF'         TURN ON ERROR SWITCH
ERRLOG   L     SRB,CLOGER(ACT)          LOAD BASE/ENTRY
         BALR  SRR,SRB             TO LOGERR
         DROP  SRB                      THE SAME BIT ABOUT
         USING *,SRR                    BASE REGISTER TROUBLE
ERCODE   DS    AL2                 ERROR CODE
         LM    SRB,GR2,NCOMP            RESTORE BASE
         DROP  SRR                      SET UP AS WAS BEFORE
         USING EEVAL,SRB                BASE REGISTER SWITCHING
         BR    GRA                 NO,CONTINUE PROCESSING EXPRESSION
EXERR    SR    SP1,SP1               SET SP1 TO ZERO
SETE     SR    SP2,SP2             SET SP2 TO ZERO
         TM    ERROR,X'FF'         SET CC=3 FOR ERROR CONDITION
SETRET   DS    0H
         LM    GRA,GRD,REGSAV           RESTORE VOLATILE REGISTERS
         BR    SRR                      EXIT
         EJECT
* CONVERT SELF-DEFINING VALUES
* ENTER WITH REGISTER COLR POINTING TO 1ST CHARACTER OF CONSTANT.
* LOAD REGISTER SHFR WITH CONSTANT TYPE INDICATOR-
*        1 = BINARY
*        3 = DECIMAL
*        4 = HEX
*        8 = CHARACTER
* BRANCH WITH RETURN REGISTER RTNR.
* RETURNS WITH CONVERTED VALUE IN REGISTER VALR, RIGHT JUSTIFIED,
* SIGNIFICANT CHARACTER COUNT IN REGISTER CNTR, COLR AT 1ST
* NON-CONSTANT CHARACTER.
* REGISTERS SAVR AND CHAR ARE SCRATCHED.
* SINGLE + CAUSES IMMEDIATE RETURN WITH CNTR = 0 AND COLR AT +.
* LEADING BITS MAY BE LOST IF VALUE TOO LARGE.
RETR     EQU    GRZ                     RETURN ADDRESS
COLR     EQU    SP1                     POINTER TO CHAR
SHFR     EQU   GRX                      SHIFT COUNTER
VALR     EQU   SP2                      VALUE
SAVR     EQU    GRY                     SAVE FOR VALUE
CHAR     EQU    GR0                     CHARACTER
CNTR     EQU    GR1                     COUNTER
SDVCF    SR    VALR,VALR                CLEAR VALUE
         LR    CHAR,VALR                CLEAR CHAR
         LR    CNTR,VALR                CLEAR COUNT
         STC   SHFR,SDV08+1             STORE SHIFT
         CLI   SDV08+1,8                TEST FOR C-CONSTANT
         BNE   SDV01                    NO
         L     VALR,SDV09               YES, LOAD EXTERNAL ZEROES
SDV01    LA    SAVR,SDV08-1(SHFR)       TEST CHAR RANGE
         CLC   0(1,COLR),0(SAVR)
         BH    SDV07                    EXIT ON TOO HIGH
         IC    CHAR,0(COLR)
         LR    SAVR,VALR                SAVE CUMULATIVE VALUE
         CLI   SDV08+1,8                TEST FOR C-CONSTANT
         BNE   SDV04                    NO, TO SHIFT
         CLI   0(COLR),IQUOTE           TEST '
         BNE   SDV02                    NO
         CLI   1(COLR),IQUOTE           TEST ''
         BE    SDV03                    YES, TO SKIP
         B     SDV07                    NO, EXIT
SDV02    CLI   0(COLR),IAMPSD           TEST +
         BNE   SDV04                    NO, TO SHIFT
         CLI   1(COLR),IAMPSD           TEST ++
         BNE   SDV06                    NO, ERROR
SDV03    LA    COLR,1(COLR)             SKIP ' OR +
SDV04    SLL   VALR,0(SHFR)             SHIFT VALUE
         CLI   SDV08+1,3                TEST FOR DEC CONSTANT
         BNE   SDV05                    NO
         ALR   VALR,SAVR                YES, ADJUST VALUE
         ALR   VALR,SAVR
SDV05    ALR   VALR,CHAR                CHAR TO VALUE
         LA    CNTR,1(CNTR)             STEP COUNT
         LA    COLR,1(COLR)             STEP COLUMN POINTER
         B     SDV01                    TO NEXT CHAR
SDV06    SR    CNTR,CNTR                CLEAR COUNT FOR ERROR
SDV07    BR    RETR                     EXIT
*
*
SDV08    DC    X'0100090F000000FF'      LIMITS
         DS    0F
SDV09    DC    X'F0F0F0F0'              EBCDIC ZEROES
FSEVEN   DC    F'7'                     FULLWORD CONSTANT
REGSAV   DS    4F                       SAVE AREA FOR F8V VOLATILE REGS
REGSAV1   DS   F
ERRPT    DS    F                       SAV AREA FOR COL PTR
FTXPPT   DS    F                       SAV AREA FOR PTR TO 1ST BYTE
OTHERR   DC    X'00'                   SWITH FOR ERR PATH,0-OFF,1-ON
FATAL    DC    X'00'               FATAL ERR SWH (0=NON-FATAL,1=FATAL)
*        START OF TERMS WORK AREA
TERMSWK  DSECT
TERMS    DS    25F                      LIST OF VALUES
RLIST    DS    25H                      RELOCATABILITY LIST
RCNTR    DS    C                        COUNTER OF RELOCATABLE TERMS
ERROR    DS    C                        ON(1), OFF(0)
PCNTR    DS    C                        COUNTER OF LEVEL OF '('
SYMBL    DS    C         0=SYM 1ST TERM,1=NOT 1ST TERM,255=SYM NOT FND
NTRMS    DS    25C                      NUMBER OF TERMS PER TERMS ENTRY
OPRNS    DS    40C                      LIST OF OPERATIONS
COND     DS    C                        VALIDITY INDICATOR
ENDOE    DS    C                        END EXPRESSION FLAG
NEWOP    DS    C                        LATEST OPERATION FOUND
LREF     DS    C                        L'SYM REF  ON(1) OFF(0)
TERMSLEN EQU   *-TERMS                  LENGTH OF TERMS WORK AREA
ASMGF8V  CSECT                          AS YOU WERE
NCOMP    DS    11F                      GENERAL SAVE AREA
SAVE     EQU   NCOMP
         EJECT
***********************************************************************
*         *PREVIOUS*                                                  *
*  CHAR   *  COND  *     ACTION                                       *
***********************************************************************
* START   *   --   * SET COND = 0
***********************************************************************
*  (      *0/1/2/3 * SET COND = 1
*         *4/5     * IF PCNTR GT CTTERMC, LOG ASMG026
***********************************************************************
*  )      *0/1/2/3 * LOG ASMG085
*         *4/5     * SET COND = 4, IF PCNTR=0 END EXPRESSION
***********************************************************************
*  +-     *0       * SET INITIAL ZERO TERM
*         *1/2/3   * SET COND = 2
*         *4/5     * SET COND = 1
***********************************************************************
*  *      *0/1/2   * SET COND = 5, * IS LOCATION COUNTER
*         *3       * LOG ASMG085
*         *4       * SET COND = 3, * IS MULT
*         *5       * LOG ASMG025
***********************************************************************
*  /      *0/1/2/3 * LOG ASMG085
*         *4       * SET COND =3
*         *5       * LOG ASMG025
***********************************************************************
*ABSOLUTE *0/1/2/3 * SET COND = 4
*TERM     *4/5     * LOG ASMG085
***********************************************************************
*RELOCAT- *0/1/2   * SET COND = 5
*ABLE TERM*3       * LOG ASMG025
*         *4/5     * LOG ASMG085
***********************************************************************
*,OR BLANK*0/1/2/3 * LOG ASMG039
*         *4/5     * IF PCNTR GT 0, LOG ASMG039
***********************************************************************
*
CONDA    EQU   0                        INITIAL COND SETTING
CONDB    EQU   1                        LEFT PAREN, BINARY + OR -
CONDC    EQU   2                        UNARY + OR -
CONDD    EQU   3                        ASTERISK OR SLASH
CONDE    EQU   4                        ABSOLUTE TERM OR RIGHT PAREN
CONDF    EQU   5                        RELOCATABLE TERM
*
*        HEIRARCHY CODES FOR OPRNS
OPEND    EQU   0                        BLANK OR COMMA
OPPLUS   EQU   1                        BINARY PLUS
OPMINUS  EQU   2                        BINARY MINUS
OPUPLUS  EQU   3                        UNARY PLUS
OPUMINUS EQU   4                        UNARY MINUS
OPSTAR   EQU   5                        MULTIPLICATION
OPSLASH  EQU   6                        DIVISION
*
         END
./ ADD NAME=ASMGIS00
IS00     TITLE     'INSTRUCTION SET COMPATIBLE WITH ASSEMBLER (F)'
         ISEQ      73,78
ASMGIS00 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CS       INST  OP=BA,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
ED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MC       INST  OP=AF,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
NC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CDS      INST  OP=BB,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLM      INST  OP=BD,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=YES
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,
               CLASS=3,LIT1=NO,LIT23=NO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ICM      INST  OP=BF,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=YES
IPK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2B
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=YES
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=YES
MXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
RDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
RRB      INST  OP=B3,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,  *OP=B2*     ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23
SCK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=YES,LIT23=NO,MASK=24
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPT      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=YES,LIT23=NO,MASK=28
SPX      INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=F,LIT1=NO,LIT23=YES,MASK=20
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRP      INST  OP=F0,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=3,               ,
               ALIGN=C,LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
WRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
ZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CLCL     INST  OP=0F,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,
               ALIGN=C,LIT1=NO,LIT23=NO
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
EDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCTL     INST  OP=B7,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=F,LIT1=NO,LIT23=YES
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MVCL     INST  OP=0E,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,
               ALIGN=C,LIT1=NO,LIT23=NO
MXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
PTLB     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2D
SCKC     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=YES,LIT23=NO,MASK=26
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SIGP     INST  OP=AE,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
SIOF     INST  OP=9C,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SPKA     INST  OP=B2,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2A
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
STAP     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=H,LIT1=NO,LIT23=NO,MASK=22
STCK     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=25
STCM     INST  OP=BE,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=NO
STPT     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=NO,LIT23=NO,MASK=29
STPX     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=F,LIT1=NO,LIT23=NO,MASK=21
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CLRIO    INST  OP=9D,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
OPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=08
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
STCKC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=NO,LIT23=NO,MASK=27
STCTL    INST  OP=B6,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=F,LIT1=NO,LIT23=NO
STIDC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23
STIDP    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=22
STNSM    INST  OP=AC,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STOSM    INST  OP=AD,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS02
IS02     TITLE     'RESTRICTED INSTRUCTION SET FOR SYSTEM 360 MACHINES'
         ISEQ      73,78
*
         COPY      ASMGSET
ASMGIS02 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
NC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
BHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=21
BPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,
               CLASS=3,LIT1=NO,LIT23=NO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
POP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
RDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
WRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2E
BNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
PUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS09
IS09     TITLE     'INSTRUCTION SET FOR 360 DOS'
         ISEQ      73,78
ASMGIS09 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
ED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
NC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,
               CLASS=3,LIT1=NO,LIT23=NO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
RDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
WRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
ZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
EDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS11
IS11     TITLE     'RESTRICTED INSTRUCTION SET FOR MACRO EXPANSIONS'
         ISEQ      73,78
*
         COPY      ASMGSET
ASMGIS11 INSTSET
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS20
IS20     TITLE     'INSTRUCTION SET FOR A 360 MODEL 20'
         ISEQ      73,78
ASMGIS20 INSTSET
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
ED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BAS      INST  OP=4D,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
BHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=21
BPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CIO      INST  OP=9B,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HPR      INST  OP=99,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
POP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XIO      INST  OP=D0,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BASR     INST  OP=0D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2E
BNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
PUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SPSW     INST  OP=81,TYPE=MACH,CLASS=3,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TIOB     INST  OP=9A,TYPE=MACH,CLASS=2,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
OPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=08
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=YES,F8UPC=YES,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS44
IS44     TITLE     'INSTRUCTION SET FOR A 360 MODEL 44'
         ISEQ      73,78
ASMGIS44 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
BHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=21
BPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,
               CLASS=3,LIT1=NO,LIT23=NO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
POP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2E
BNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CHPM     INST  OP=B3,TYPE=MACH,CLASS=2,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LPSX     INST  OP=B2,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
RDDW     INST  OP=B5,TYPE=MACH,CLASS=2,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
WRDW     INST  OP=B4,TYPE=MACH,CLASS=2,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
OPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=08
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=YES,F8UPC=YES,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS60
IS60     TITLE     'INSTRUCTION SET FOR SYSTEM 360 MACHINES'
         ISEQ      73,78
*
         COPY      ASMGSET
ASMGIS60 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
ED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
NC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
BHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=21
BPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,
               CLASS=3,LIT1=NO,LIT23=NO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=YES
MXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
POP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
RDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
WRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
ZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2E
BNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
EDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
PUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
OPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=08
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS67
IS67     TITLE     'INSTRUCTION SET FOR A 360 MODEL 67'
         ISEQ      73,78
*
         COPY      ASMGSET
ASMGIS67 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AX       INST  OP=76,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES,RPQ67=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DX       INST  OP=73,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES,RPQ67=YES
ED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LX       INST  OP=74,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES,RPQ67=YES
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
MX       INST  OP=72,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES,RPQ67=YES
NC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SX       INST  OP=77,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES,RPQ67=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADD      INST  OP=66,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=YES,RPQ67=YES
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BAS      INST  OP=4D,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
BHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=21
BPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST   OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,             ,
               CLASS=3,LIT1=NO,LIT23=MO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LMC      INST  OP=B8,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDD      INST  OP=65,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=YES,RPQ67=YES
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
POP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
RDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SDD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=YES,RPQ67=YES
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLT      INST  OP=A2,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO,RPQ67=YES
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
WRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
ZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ADDR     INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO,RPQ67=YES
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BASR     INST  OP=0D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2E
BNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
EDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MDDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO,RPQ67=YES
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
PUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
SDDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO,RPQ67=YES
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
STMC     INST  OP=B0,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWPR     INST  OP=A3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO,RPQ67=YES
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
OPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=08
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,LCR=NO,F7XREF=NO,               ,
               SUB=YES,F8UPC=YES,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS70
IS70     TITLE     'INSTRUCTION SET FOR SYSTEM 370 MACHINES'
         ISEQ      73,78
*
         COPY      ASMGSET
ASMGIS70 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CS       INST  OP=BA,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
ED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MC       INST  OP=AF,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
NC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
BHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=21
BPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CDS      INST  OP=BB,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLM      INST  OP=BD,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=YES
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,
               CLASS=3,LIT1=NO,LIT23=NO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ICM      INST  OP=BF,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=YES
IPK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2B
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=YES
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=YES
MXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
POP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
RDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
RRB      INST  OP=B3,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,  *OP=B2*     ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23
SCK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=YES,LIT23=NO,MASK=24
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPT      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=YES,LIT23=NO,MASK=28
SPX      INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=F,LIT1=NO,LIT23=YES,MASK=20
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRP      INST  OP=F0,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=3,               ,
               ALIGN=C,LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
WRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
ZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2E
BNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CLCL     INST  OP=0F,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,
               ALIGN=C,LIT1=NO,LIT23=NO
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
EDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCTL     INST  OP=B7,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=F,LIT1=NO,LIT23=YES
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MVCL     INST  OP=0E,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,
               ALIGN=C,LIT1=NO,LIT23=NO
MXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
PTLB     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2D
PUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
SCKC     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=YES,LIT23=NO,MASK=26
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SIGP     INST  OP=AE,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
SIOF     INST  OP=9C,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SPKA     INST  OP=B2,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2A
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
STAP     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=H,LIT1=NO,LIT23=NO,MASK=22
STCK     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=25
STCM     INST  OP=BE,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=NO
STPT     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=NO,LIT23=NO,MASK=29
STPX     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=F,LIT1=NO,LIT23=NO,MASK=21
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CLRIO    INST  OP=9D,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
OPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=08
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
STCKC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=NO,LIT23=NO,MASK=27
STCTL    INST  OP=B6,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=F,LIT1=NO,LIT23=NO
STIDC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23
STIDP    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=22
STNSM    INST  OP=AC,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STOSM    INST  OP=AD,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
GLDEND   EQU       *
         END
./ ADD NAME=ASMGIS71
IS71     TITLE     'INSTRUCTION SET FOR SYSTEM 370 CMS MACHINES'
         ISEQ      73,78
*
         COPY      ASMGSET
ASMGIS71 INSTSET
A        INST  OP=5A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
B        INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2F
C        INST  OP=59,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
D        INST  OP=5D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
L        INST  OP=58,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
M        INST  OP=5C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=YES
N        INST  OP=54,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
O        INST  OP=56,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
S        INST  OP=5B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
X        INST  OP=57,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AD       INST  OP=6A,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AE       INST  OP=7A,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AH       INST  OP=4A,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AL       INST  OP=5E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AP       INST  OP=FA,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AR       INST  OP=1A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AU       INST  OP=7E,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
AW       INST  OP=6E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
BC       INST  OP=47,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BE       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
BH       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BL       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BM       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=24
BO       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=21
BP       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=22
BR       INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2F
BZ       INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=28
CD       INST  OP=69,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CE       INST  OP=79,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
CH       INST  OP=49,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CL       INST  OP=55,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CP       INST  OP=F9,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CR       INST  OP=19,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CS       INST  OP=BA,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
DC       INST  OP=26,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
DD       INST  OP=6D,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DE       INST  OP=7D,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
DP       INST  OP=FD,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
DR       INST  OP=1D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
DS       INST  OP=27,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=NO,F8UPC=YES,MASK=02
ED       INST  OP=DE,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
EX       INST  OP=44,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
IC       INST  OP=43,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LA       INST  OP=41,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LD       INST  OP=68,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LE       INST  OP=78,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
LH       INST  OP=48,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LM       INST  OP=98,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
LR       INST  OP=18,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MC       INST  OP=AF,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
MD       INST  OP=6C,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
ME       INST  OP=7C,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
MH       INST  OP=4C,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MP       INST  OP=FC,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MR       INST  OP=1C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
NC       INST  OP=D4,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
NI       INST  OP=94,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
NR       INST  OP=14,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OC       INST  OP=D6,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
OI       INST  OP=96,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
OR       INST  OP=16,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SD       INST  OP=6B,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SE       INST  OP=7B,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SH       INST  OP=4B,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SL       INST  OP=5F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SP       INST  OP=FB,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
SR       INST  OP=1B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ST       INST  OP=50,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SU       INST  OP=7F,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
SW       INST  OP=6F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=YES
TM       INST  OP=91,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
TR       INST  OP=DC,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
TS       INST  OP=93,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XC       INST  OP=D7,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
XI       INST  OP=97,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
XR       INST  OP=17,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
ADR      INST  OP=2A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AER      INST  OP=3A,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AGO      INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AIF      INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ALR      INST  OP=1E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
AUR      INST  OP=3E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AWR      INST  OP=2E,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
AXR      INST  OP=36,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
BAL      INST  OP=45,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BCR      INST  OP=07,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCT      INST  OP=46,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BER      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
BHR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BLR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BMR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=24
BNE      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BNH      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNL      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNM      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2B
BNO      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2E
BNP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=2D
BNZ      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=27
BOR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=21
BPR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=22
BXH      INST  OP=86,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
BZR      INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=28
CCW      INST  OP=28,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=YES,    ,
               SUB=YES,F8UPC=YES,MASK=00
CDR      INST  OP=29,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CDS      INST  OP=BB,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
CER      INST  OP=39,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
CLC      INST  OP=D5,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
CLI      INST  OP=95,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
CLM      INST  OP=BD,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=YES
CLR      INST  OP=15,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
COM      INST  OP=1E,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
CVB      INST  OP=4F,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CVD      INST  OP=4E,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
CXD      INST  OP=2C,TYPE=ASSEM,UPC=YES,STE=YES,LCR=NO,F7XREF=NO,      ,
               SUB=NO,F8UPC=YES,MASK=00
DDR      INST  OP=2D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DER      INST  OP=3D,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
DXD      INST  OP=2B,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=0A
END      INST  OP=21,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=YES,F8UPC=NO,MASK=04
EQU      INST  OP=1F,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=NO,MASK=0A
HDR      INST  OP=24,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HDV      INST  OP=9E,TYPE=EXTEN,FLOAT=NO,EVEN=NO,ALIGN=C,              ,
               CLASS=3,LIT1=NO,LIT23=NO,MASK=21
HER      INST  OP=34,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
HIO      INST  OP=9E,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
HVC      INST  OP=83,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
ICM      INST  OP=BF,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=YES
IPK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2B
ISK      INST  OP=09,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LCR      INST  OP=13,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LDR      INST  OP=28,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LER      INST  OP=38,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNR      INST  OP=11,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LPR      INST  OP=10,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
LRA      INST  OP=B1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=YES
LTR      INST  OP=12,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MDR      INST  OP=2C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MER      INST  OP=3C,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MVC      INST  OP=D2,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVI      INST  OP=92,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
MVN      INST  OP=D1,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVO      INST  OP=F1,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MVZ      INST  OP=D3,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
MXD      INST  OP=67,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=YES
MXR      INST  OP=26,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOP      INST  OP=47,TYPE=EXTEN,CLASS=1,ALIGN=H,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=YES,MASK=20
ORG      INST  OP=20,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=04
POP      INST  OP=2F,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
RDD      INST  OP=85,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
RRB      INST  OP=B3,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,  *OP=B2*     ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23
SCK      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=YES,LIT23=NO,MASK=24
SDR      INST  OP=2B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SER      INST  OP=3B,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SIO      INST  OP=9C,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLA      INST  OP=8B,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLL      INST  OP=89,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SLR      INST  OP=1F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPM      INST  OP=04,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SPT      INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=YES,LIT23=NO,MASK=28
SPX      INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=F,LIT1=NO,LIT23=YES,MASK=20
SRA      INST  OP=8A,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRL      INST  OP=88,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SRP      INST  OP=F0,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=3,               ,
               ALIGN=C,LIT1=NO,LIT23=NO
SSK      INST  OP=08,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SSM      INST  OP=80,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
STC      INST  OP=42,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STD      INST  OP=60,TYPE=MACH,CLASS=0,ALIGN=D,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STE      INST  OP=70,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
STH      INST  OP=40,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STM      INST  OP=90,TYPE=MACH,CLASS=0,ALIGN=F,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SUR      INST  OP=3F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SVC      INST  OP=0A,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
SWR      INST  OP=2F,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
SXR      INST  OP=37,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
TCH      INST  OP=9F,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TIO      INST  OP=9D,TYPE=MACH,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TRT      INST  OP=DD,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=YES
WRD      INST  OP=84,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
ZAP      INST  OP=F8,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
ACTR     INST  OP=25,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ANOP     INST  OP=0B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
BALR     INST  OP=05,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BCTR     INST  OP=06,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
BNER     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BNHR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNLR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNMR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2B
BNOR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2E
BNPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=2D
BNZR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=27
BXLE     INST  OP=87,TYPE=MACH,CLASS=0,ALIGN=H,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
CLCL     INST  OP=0F,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,
               ALIGN=C,LIT1=NO,LIT23=NO
CNOP     INST  OP=29,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=NO,      ,
               SUB=YES,F8UPC=YES,MASK=06
COPY     INST  OP=0C,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
DROP     INST  OP=24,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
EDMK     INST  OP=DF,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
GBLA     INST  OP=00,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLB     INST  OP=01,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
GBLC     INST  OP=02,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ICTL     INST  OP=11,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
ISEQ     INST  OP=12,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCDR     INST  OP=23,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCER     INST  OP=33,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LCLA     INST  OP=03,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLB     INST  OP=04,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCLC     INST  OP=05,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
LCTL     INST  OP=B7,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=F,LIT1=NO,LIT23=YES
LNDR     INST  OP=21,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LNER     INST  OP=31,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPDR     INST  OP=20,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPER     INST  OP=30,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LPSW     INST  OP=82,TYPE=MACH,CLASS=3,ALIGN=D,FLOAT=NO,EVEN=NO,       ,
               LIT1=YES,LIT23=NO
LRDR     INST  OP=25,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LRER     INST  OP=35,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTDR     INST  OP=22,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
LTER     INST  OP=32,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=YES,     ,
               LIT1=NO,LIT23=NO
MEND     INST  OP=10,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MVCL     INST  OP=0E,TYPE=MACH,FLOAT=NO,EVEN=YES,CLASS=0,              ,
               ALIGN=C,LIT1=NO,LIT23=NO
MXDR     INST  OP=27,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=YES,EVEN=DOUBLE,  ,
               LIT1=NO,LIT23=NO
NOPR     INST  OP=07,TYPE=EXTEN,CLASS=3,ALIGN=C,FLOAT=NO,EVEN=NO,      ,
               LIT1=NO,LIT23=NO,MASK=20
PACK     INST  OP=F2,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
PTLB     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2D
PUSH     INST  OP=30,TYPE=ASSEM,UPC=NO,STE=NO,F7XREF=NO,               ,
               SUB=NO,F8UPC=NO,MASK=06
SCKC     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=YES,LIT23=NO,MASK=26
SETA     INST  OP=06,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETB     INST  OP=07,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SETC     INST  OP=08,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
SIGP     INST  OP=AE,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,               ,
               EVEN=NO,LIT1=NO,LIT23=NO
SIOF     INST  OP=9C,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21
SLDA     INST  OP=8F,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SLDL     INST  OP=8D,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SPKA     INST  OP=B2,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=2A
SRDA     INST  OP=8E,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
SRDL     INST  OP=8C,TYPE=MACH,CLASS=1,ALIGN=C,FLOAT=NO,EVEN=YES,      ,
               LIT1=NO,LIT23=NO
STAP     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=H,LIT1=NO,LIT23=NO,MASK=22
STCK     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=25
STCM     INST  OP=BE,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=C,LIT1=NO,LIT23=NO
STPT     INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=NO,LIT23=NO,MASK=29
STPX     INST  OP=B3,TYPE=EXTEN,CLASS=3,FLOAT=NO,EVEN=NO,  *OP=B2*     ,
               ALIGN=F,LIT1=NO,LIT23=NO,MASK=21
UNPK     INST  OP=F3,TYPE=MACH,CLASS=0,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=YES
AIFB     INST  OP=09,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
AGOB     INST  OP=0A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
CLRIO    INST  OP=9D,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=21
CSECT    INST  OP=1C,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=00
DSECT    INST  OP=1D,TYPE=ASSEM,UPC=NO,STE=YES,LCR=NO,F7XREF=NO,       ,
               SUB=NO,F8UPC=YES,MASK=08
EJECT    INST  OP=15,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
ENTRY    INST  OP=19,TYPE=ASSEM,UPC=NO,STE=NO,LCR=YES,F7XREF=YES,      ,
               SUB=NO,F8UPC=NO,MASK=06
EXTRN    INST  OP=1A,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
LTORG    INST  OP=22,TYPE=ASSEM,UPC=YES,STE=YES,LCR=YES,F7XREF=NO,     ,
               SUB=YES,F8UPC=YES,MASK=00
MACRO    INST  OP=0D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MEXIT    INST  OP=0F,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
MNOTE    INST  OP=0E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
OPSYN    INST  OP=2D,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=08
PRINT    INST  OP=13,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
PUNCH    INST  OP=16,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
REPRO    INST  OP=17,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
SPACE    INST  OP=14,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=04
START    INST  OP=1B,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=YES,MASK=00
STCKC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=D,LIT1=NO,LIT23=NO,MASK=27
STCTL    INST  OP=B6,TYPE=MACH,FLOAT=NO,EVEN=NO,CLASS=0,               ,
               ALIGN=F,LIT1=NO,LIT23=NO
STIDC    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=23
STIDP    INST  OP=B2,TYPE=EXTEN,FLOAT=NO,EVEN=NO,CLASS=3,              ,
               ALIGN=C,LIT1=NO,LIT23=NO,MASK=22
STNSM    INST  OP=AC,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
STOSM    INST  OP=AD,TYPE=MACH,CLASS=2,ALIGN=C,FLOAT=NO,EVEN=NO,       ,
               LIT1=NO,LIT23=NO
TITLE    INST  OP=18,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=00
USING    INST  OP=23,TYPE=ASSEM,UPC=YES,STE=NO,LCR=YES,F7XREF=YES,     ,
               SUB=YES,F8UPC=YES,MASK=06
WXTRN    INST  OP=2E,TYPE=ASSEM,UPC=NO,STE=NO,LCR=NO,F7XREF=NO,        ,
               SUB=NO,F8UPC=NO,MASK=06
GLDEND   EQU       *
         ORG       ASMGIS71+X'1000'    FOR CMS PAGING
         END
./ ADD NAME=ASMGMACP
MACP     TITLE     'ASMG     ASSEMBLER (G7) MACRO POST PROCESSOR'
         ISEQ      73,78
*                                                                     *
*        SET GLOBAL SWITCHES                                          *
         COPY      ASMGSET
ASMGMACP CSECT
         PRINT     NOGEN
         FDIMEN
         PRINT     GEN
         SPACE     2
***********************************************************************
*                                                                     *
*        ENTERED FROM ASMGRTA AFTER ASMGF3, THE END OF MACRO          *
*        PROCESSING.                                                  *
*                                                                     *
*        INPUT -   R3 POINTS TO FDIMEN COMMUNICATIONS AREA            *
*                                                                     *
***********************************************************************
         SPACE     2
         ST        R14,CTMRSRTN(,R3)   SAVE RETURN ADDRESS
         LR        R12,R15             TRANSFER ENTRY ADDRESS
         USING     ASMGMACP,R12        AND USE THAT AS A BASE
         LA        R13,SAVE            THIS IS MY SAVE AREA
         USING     SAVE,R13            AND USE THAT AS WORK AREA BASE
         L         R9,ADLIST1(,R3)     POINTER TO LIST1 IN ASMGASM
         IC        R1,L1ASPARM(,R9)    PICK UP LENGTH OF SYSPARM
         LTR       R1,R1               IS IT NULL .Q
         BZ        ABEND952            YES, WE DIE
         LA        R1,ESTART           FOR MESSAGE ADDRESSABILITY
         MVC       E0115-ESTART+1(1,R1),L1UPCOND(R9)  SET UPCOND SEV
         L         R2,L1ASPARM(,R9)    PICK UP ADDRESS OF SYSPARM
         CLC       =C'ASM',0(R2)       IS IT 'ASM' .Q
         BNE       TSTPDP              BRANCH IF NOT
SETASM   DS        0H
         OI        POSTSW,ASM          SET ASM BIT
         MVI       COMCHAR,C'*'        SET ASSEMBLER COMMENT IND
         B         DONEPARM            ALL DONE THIS PART
TSTPDP   DS        0H
         CLC       =C'PDP',0(R2)       IS IT 'PDP' .Q
         BNE       TSTCC70             BRANCH IF NOT
         OI        POSTSW,PDP          SET PDP BIT
         MVI       COMCHAR,C';'        SET PDP ASSEMBLER COMMENT IND
         OI        E0034+1-ESTART(R1),NOPERR  KILL INVALID OPCODES
         OI        E0088+1-ESTART(R1),NOPERR  KILL UNDEFINED OPCODES
         OI        E0101+1-ESTART(R1),NOPERR  KILL EOD ON SYSIN
         B         DONEPARM            ALL DONE THIS PART
TSTCC70  DS        0H
         CLC       =C'CC70',0(R2)      IS IT 'CC70' .Q
         BNE       TSTFORT             BRANCH IF NOT
         OI        POSTSW,CC70         SET CC70 BIT
         MVI       COMCHAR,C'*'        SET CC70 COMMENT IND
         OI        E0034+1-ESTART(R1),NOPERR  KILL INVALID OPCODES
         OI        E0088+1-ESTART(R1),NOPERR  KILL UNDEFINED OPCODES
         B         DONEPARM            ALL DONE THIS PART
TSTFORT  DS        0H
         CLC       =C'FORT',0(R2)      IS IT 'FORT' .Q
         BNE       TSTNEXT             BRANCH IF NOT
         OI        POSTSW,FORT         SET FORTRAN BIT
         MVI       COMCHAR,C'C'        SET COMMENT CHARACTER
         OI        E0034+1-ESTART(R1),NOPERR  KILL INVALID OPCODES
         OI        E0088+1-ESTART(R1),NOPERR  KILL UNDEFINED OPCODES
         B         DONEPARM            ALL DONE THIS PART
TSTNEXT  DS        0H
ABEND952 DS        0H
         BAL       R0,ASMABEND         ERROR, WE QUIT NOW
         DC        C'952I',AL1(L'MES952-1)
MES952   DC        C'INVALID SYSPARM SPECIFIED FOR MACRO PROCESSING.'
DONEPARM DS        0H
         MVC       HDECKID(4),CTITLE(R3) MOVE DECK I.D. TO HEADER
         MVC       HDATE(9),CTDATE(R3) MOVE DATE INTO HEADER
         LA        R1,1                LOAD ONE IN A REGISTER
         ST        R1,YLCNT            INITIALIZE LINES FOR NEW PAGE
         TM        L1PBYT(R9),LIST     WAS LIST OPTION SPECIFIED .Q
         BO        LISTYES             BRANCH IF YES
         OI        MACROSW,NOPRINT     TURN ON NO PRINT SWITCH
LISTYES  DS        0H
         LH        R1,CTXLEN(,R3)      GET BUFFER FROM ASMG
         AR        R1,R1               DOUBLE IT
         A         R1,MACTBLM          PLUS MACRO TABLE SIZE
         ST        R1,SPREQ            SAVE IT FOR A SHRINK
         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF
         CNOP      2,4                 FOR ALIGNMENT
         BALR      R0,R1               GO DO THE SHRINK
         DC        A(36)               SHRINK CALL
SPREQ    DS        F                   ASKED FOR
SPGOT    DS        F                   AND GOT
         CLI       SPGOT,ON            DID WE
         BE        NOCORE              BRANCH IF FAILED
         L         R1,SPGOT            ADDRESS OF CORE GOT
         ST        R1,MACTBLA          SAVE MACRO TABLE ADDRESS
         A         R1,MACTBLM          PLUS SIZE OF MACRO TABLE
         ST        R1,IBUF             REMEMBER BUFFER ADDRESS
         TM        L1PBYT1(R9),BATCH   ARE WE IN 'BATCH' MODE .Q
         BO        READ                BRANCH IF YES
         LOAD      EPLOC=L1ISNAME(,R9) LOAD VARIABLE INSTRUCTION SET
         ST        R0,L1ISADDR(,R9)    SAVE LOADED ADDRESS IN LIST1
READ     DS        0H
         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF
         CNOP      2,4                 FOR ALIGNMENT
         BALR      R0,R1               GO AND DO THE READ
         DC        F'4'                READ REQUEST
         DC        F'4'                SYSUT2
IBUF     DS        F                   ADDRESS OF BUFFER
         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF
         CNOP      2,4                 FOR ALIGNMENT
         BALR      R0,R1               GO AND DO THE CHECK
         DC        F'28'               CHECK
         DC        F'4'                SYSUT2
UT2LEN   DS        F                   DATA LENGTH
         L         R2,IBUF             GET START OF BUFFER
         MVC       UT2REML,UT2LEN      SET INITIAL BUFFER LENGTH
DEBLOCK  DS        0H
         MVC       LENWORD+2(2),0(R2)  RECORD LENGTH
         LH        R1,LENWORD+2        GET RECORD LENGTH
         LTR       R1,R1               CHECK ITS VALUE
         BNP       READ                GET NEXT BLOCK IF INVALID
         TITLE     'SNAPDATA'
*                                                                     *
*        FORMAT RECORD JUST READ IN CHARACTER AND HEX                 *
*                                                                     *
         TM        L1PBYT3(R9),UNUSED  WAS 'UNUSED' SPECIFIED .Q
         BZ        SNAPARND            BRANCH IF NOT
         STM       R0,R15,SNAPSAVE     SAVE ALL REGISTERS
         LR        R1,R2               TRANSFER AREA TO BE DUMPED
         A         R1,LENWORD          ADD LENGTH
         BCTR      R1,0                POINT TO LAST USED BYTE
         ST        R1,ENDWORD          REMEMBER THAT INSTEAD
         LR        R1,R2               START OF AREA TO BE DUMPED
         MVC       SNAPCARR(133),L1BLANKS(R9) BLANK OUTPUT AREA
         LA        R10,SNAPCARR        POINT TO BLANK LINE
         BAL       R14,WRLST           AND PRINT IT
         MVI       SNAPAREA+86,C'*'    BEFORE AND
         MVI       SNAPAREA+119,C'*'   AFTER CHARACTER EQUIV
SNAPLOOP DS        0H
         C         R1,ENDWORD          ARE WE DONE .Q
         BH        SNAPDONE            BRANCH TO EXIT IF SO
         ST        R1,SNAPWORK         STORE ADDRESS
         UNPK      SNAPAREA(7),SNAPWORK+1(4) MAKE IT PRINTABLE
         MVC       SNAPAREA+6(78),L1BLANKS+1(R9) BLANK HEX AREA
         TR        SNAPAREA(6),SNAPHEX RENDER INTO HEXADECIMAL
         MVC       SNAPAREA+87(32),0(R1) PUT IN CHARACTERS
         TR        SNAPAREA+87(32),SNAPTRAN TRANS INTO ANGLAIS
         LA        R2,SNAPAREA+9       POINT TO 1ST BUFFER POS'N
         LA        R6,2                2 TIMES THRU, 16 BYTES EACH
SNAPHALF DS        0H
         LA        R7,4                4 WORDS PER HALF LINE
SNAPWORD DS        0H
         C         R1,ENDWORD          ARE WE DONE .Q
         BH        SNAPOUT             GET OUT IF SO
         MVC       SNAPWORK(4),0(R1)   GET NEXT WORD FOR OUTPUT
         UNPK      0(9,R2),SNAPWORK(5) UNPACK INTO BUFFER
         MVI       8(R2),BLANK         BLANK DUMMY DIGIT
         TR        0(8,R2),SNAPHEX     MAKE IT PRINTABLE
         LA        R2,9(,R2)           BUMP TO NEXT OUTPUT AREA
         LA        R1,4(,R1)           POINT TO NEXT WORD
         BCT       R7,SNAPWORD         GO BACK UNLESS FINISHED HALF
         LA        R2,3(,R2)           SKIP 3 PRINT POS'NS
         BCT       R6,SNAPHALF         GO BACK IF ONLY HALF DONE
SNAPOUT  DS        0H
         LA        R10,SNAPCARR        AREA TO BE PRINTED
         BAL       R14,WRLST           GO PRINT IT
         B         SNAPLOOP            GO CHECK NEXT LINE
SNAPDONE DS        0H
         LM        R0,R15,SNAPSAVE     RESTORE REGISTERS
SNAPARND DS        0H
         TITLE     'GET RECORD TYPE AND JUMP ACCORDINGLY'
         ST        R2,PROCPTR          REMEMBER WHERE IT STARTED
         IC        R4,2(,R2)           GET RECORD FLAGS
         N         R4,=X'00000070'     ONLY GET RECORD TYPE
         SRA       R4,2                ONTO FULL WORD INDEX
         B         *+4(R4)             JUMP ON CODE
         B         NOEDIT              SOURCE AS IS                X000
         B         ML01A               ERROR RECORD                X001
         B         NOEDIT              CONSTRUCT FOR PRINT         X010
         B         GNOEDIT             IF GENERATED                X011
         B         SKIP                PROCESS ONLY                X100
         B         SKIP                ILLEGAL                     X101
         B         CONDCESS            PROCESS AND CONSTRUCT       X110
         B         PROCESS             IF GENED                    X111
         SPACE     2
CONDCESS DS        0H
         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER
         TM        LASTTYPE,X'70'      WAS LAST TYPE SOURCE .Q
         BNZ       PROCESS             BRANCH IF NOT
         TM        MACROSW,NOPRINT     ARE WE LISTING LINES .Q
         BO        PNCHCESS            BRANCH IF NOT
         L         R1,L1DCBADS+L1SPRINT(,R9)  GET SYSPRINT DCB ADDR
         L         R1,L1DCBLPT(,R1)    GET LAST RECORD POINTER
         LTR       R1,R1               IS IT NULL .Q
         BZ        PNCHCESS            BRANCH IF YES
*                                                                     *
*        NOTE --  THIS LOOKBACK ON SYSPRINT FAILS IF 'UNUSED'         *
*                 OR IF CONTINUATION ON SYSIN                         *
*                                                                     *
         MVC       BCMNT-BUFR(15,R1),=C'***GENERATOR***'
         MVC       BOUTPUT-BUFR(1,R1),COMCHAR  MAKE IT A COMMENT
PNCHCESS DS        0H
         L         R1,L1DCBADS+L1SPUNCH(,R9)  GET SYSPUNCH DCB ADDR
         L         R1,L1DCBLPT(,R1)    GET LAST RECORD POINTER
         LTR       R1,R1               IS IT NULL .Q
         BZ        SLINCESS            BRANCH IF YES
         MVC       0(1,R1),COMCHAR     MAKE IT A COMMENT
SLINCESS DS        0H
         L         R1,L1DCBADS+L1SLIN(,R9)  GET SYSLIN DCB ADDR
         L         R1,L1DCBLPT(,R1)    GET FORMER RECORD POINTER
         LTR       R1,R1               IS IT NULL .Q
         BZ        PROCESS             BRANCH IF YES
         MVC       0(1,R1),COMCHAR     MAKE IT A COMMENT
PROCESS  DS        0H
         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER
         LA        R2,8(,R2)           POINT TO LABEL FIELD
         LA        R1,BOUTPUT          CURRENT POSITION IN OUTPUT
         MVI       BGENNED,GEN         MARK LINE GENERATED
         CNOP      0,4
         BAL       R14,SETSEG          MOVE IN LABEL
         DC        A(BOUTPUT)          TARGET FOR LABEL
         CLI       COMCHAR,C'*'        IS COMMENT AN ASTERISK .Q
         BE        PROPCD              BRANCH IF YES
         CLI       BOUTPUT,C'*'        IS THIS A MACRO COMMENT .Q
         BNE       PROPCD              BRANCH IF NOT
         MVC       BOUTPUT(1),COMCHAR  SET USER'S TYPE OF COMMENT
         MVC       BCMNT(19),=C'***MACRO COMMENT***'
PROPCD   DS        0H
         CNOP      0,4
         BAL       R14,SETSEG          MOVE IN OPCODE
         DC        A(BOUTPUT+9)        TARGET FOR OPCODE
         CLC       =C'MNOTE ',0(R4)    WAS OPCODE 'MNOTE' .Q
         BNE       COMMNTS             BRANCH IF NOT
         MVI       BGENNED,GEN         MARK LINE GENERATED
         MVC       BOUTPUT(80),L1BLANKS(R9)  CLEAR OPCODE
         CNOP      0,4                 ALIGN ARGUMENT
         BAL       R14,SETSEG          ENTER THE MNOTE OPERAND
         DC        A(BOUTPUT+1)        START IN COLUMN TWO
         MVC       BOUTPUT(1),COMCHAR  COMMENT THE RECORD
         MVC       BCMNT(11),=C'***MNOTE***'
         B         PUT                 PRINT OUT THE RESULT
COMMNTS  DS        0H
         CNOP      0,4
         BAL       R14,SETSEG          MOVE IN OPERAND
         DC        A(BOUTPUT+15)       TARGET FOR OPERAND
         SR        R5,R5               ZERO WORK REGISTER
         IC        R5,0(,R2)           GET LENGTH OF COMMENT
         LTR       R5,R5               ANY COMMENT THERE .Q
         BZ        PUT                 BRANCH OUT IF NOT
         SR        R4,R4               ZERO ANOTHER WORK
         IC        R4,1(,R2)           GET COMMENT OFFSET
         LA        R4,BOUTPUT(R4)      GET COMMENT ADDRESS
         ST        R4,CMNTADDR         SET THE ADDRESS
         BCTR      R5,0                LESS LENGTH FOR OFFSET
         STC       R5,1(,R2)           REPLACE LENGTH
         LA        R2,1(,R2)           BUMP COMMENT POINTER
         CNOP      0,4
         BAL       R14,SETSEG          MOVE IN COMMENT
CMNTADDR DC        A(*-*)              TARGET FOR COMMENT
         B         PUT                 PRINT OUT THE RESULT
         TITLE     'PROCESS GENERATED COMMENT RECORD'
GNOEDIT  DS        0H
         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER
         LA        R1,BOUTPUT          START OF OUTPUT FIELD
         LA        R2,2(,R2)           POINT TO RECORD FLAG BYTE
         L         R4,LENWORD          GET LENGTH OF SEGMENT
         S         R4,=F'3'            LESS RECORD OVERHEAD
SETNELP  DS        0H
         LA        R6,0(R1,R4)         POINT TO END OF LINE
         S         R6,=A(BLINENO)      WILL IT FIT .Q
         BNP       SETNEOK             BRANCH IF YES
         SR        R4,R6               DECREMENT LENGTH BY EXCESS
         LR        R5,R6               REMEMBER THE EXCESS
         BCTR      R4,0                DECREMENT LENGTH BY ONE
         EX        R4,SETMVC           MOVE IN SEGMENT
         L         R6,CTRTBP(,R3)      POINT TO TRANSLATION TABLE
         EX        R4,SETTRAN          CONVERT TO EBCDIC
         LA        R2,1(R4,R2)         BUMP POINTER IN STRING
         LR        R4,R5               CONTINUE WITH THE EXCESS LENGTH
         MVC       BOUTPUT(1),COMCHAR  COMMENT THE RECORD
         MVI       BGENNED,GEN         MARK IT GENERATED
         TM        MACROSW,MACCALL     IS THIS A CONTINUATION .Q
         BO        SETNEREC            BRANCH IF YES
         BAL       R14,STMTBUMP        BUMP STATEMENT COUNTER
SETNEREC DS        0H
         LA        R10,BUFR            POINT TO PRINT BUFFER
         BAL       R14,WRLST           PRINT THE RECORD
         LA        R10,BOUTPUT         POINT TO RECORD
         BAL       R14,WRPCH           AND PUNCH IT
         OI        MACROSW,MACCALL     SET CONTINUE SWITCH
         MVC       LASTREC,BOUTPUT     SAVE LAST RECORD
         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER
         LA        R1,BOUTPUT+15       POINT TO CONTINUATION COLUMN
         B         SETNELP             LOOP BACK FOR MORE
SETNEOK  DS        0H
         BCTR      R4,0                DECREMENT LENGTH BY ONE
         EX        R4,SETMVC           MOVE IN RECORD SEGMENT
         L         R6,CTRTBP(,R3)      POINT TO TRANSLATE TABLE
         EX        R4,SETTRAN          CONVERT SEGMENT TO EBCDIC
         MVC       BOUTPUT(1),COMCHAR  SET COMMENT CHARACTER
         MVI       BGENNED,GEN         SET RECORD AS GENERATED
         B         PUT                 GO WRITE RECORD OUT
         TITLE     'SCAN AND ENTER ONE GENERATED FIELD AT A TIME'
SETSEG   DS        0H
         SR        R5,R5               ZERO WORK LENGTH
         IC        R5,0(,R2)           GET LENGTH OF SEGMENT
         LTR       R4,R5               IS IT NULL .Q
         BZ        SEGDONE             EXIT IF SO
         C         R1,0(,R14)          IS OUT POINTER OK .Q
         BH        SETPOSOK            BRANCH IF YES
         L         R1,0(,R14)          BUMP OUT POINTER
SETPOSOK DS        0H
         LA        R6,0(R1,R4)         POINT TO END IN LINE
         S         R6,=A(BLINENO)      WILL IT FIT .Q
         BNP       SETFINOK            BRANCH IF YES
         LR        R0,R14              SAVE RETURN ADDRESS
         SR        R4,R6               DECREMENT LENGTH BY EXCESS
         BCTR      R4,0                DECREMENT LENGTH BY ONE
         EX        R4,SETMVC           MOVE IN SEGMENT
         STC       R6,1(R4,R2)         SAVE LENGTH REMAINING
         LA        R2,1(R4,R2)         POINT TO IT
         L         R6,CTRTBP(,R3)      POINT TO TRANSLATION TABLE
         EX        R4,SETTRAN          CONVERT TO EBCDIC
         MVI       BOUTPUT+71,C'X'     SET CONTINUATION
         CLI       LASTREC+71,BLANK    IS THIS CONTINUATION .Q
         BNE       SETLREC             BRANCH IF YES
         BAL       R14,STMTBUMP        BUMP STATEMENT COUNTER
SETLREC  DS        0H
         MVC       LASTREC,BOUTPUT     SAVE LAST RECORD
         LA        R10,BUFR            POINT TO BUFFER
         BAL       R14,WRLST           PRINT IT
         LA        R10,BOUTPUT         POINT TO RECORD
         BAL       R14,WRPCH           PUNCH IT
         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER
         MVI       BGENNED,GEN         MARK LINE GENERATED
         SR        R1,R1               ZERO CURRENT POINTER
         LR        R14,R0              RESTORE RETURN ADDRESS
         B         SETSEG              AND CONTINUE
SETFINOK DS        0H
         BCTR      R4,0                DECREMENT LENGTH BY ONE
         EX        R4,SETMVC           MOVE IN SEGMENT
         L         R6,CTRTBP(,R3)      POINT TO TRANSLATE TABLE
         EX        R4,SETTRAN          CONVERT SEGMENT TO EBCDIC
SEGDONE  DS        0H
         LA        R2,1(R2,R5)         POINT TO NEXT SEGMENT
         LR        R0,R1               REMEMBER OUTPUT ADDRESS
         LA        R1,1(R1,R4)         NEXT POSSIBLE OUTPUT ADDR
         LR        R4,R0               TRANSFER START ADDR
         B         4(,R14)             RETURN
SETMVC   MVC       0(*-*,R1),1(R2)     EXECUTED MOVE SEGMENT
SETTRAN  TR        0(*-*,R1),0(R6)     EXECUTED TRANSLATE
         TITLE     '80 - 80 RECORD PROCESSING AND OUTPUT'
NOEDIT   DS        0H
         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER
         L         R1,LENWORD          GET SOURCE LENGTH
         LA        R0,1+3              ONE PLUS LENGTH/FLAG OVERHEAD
         SR        R1,R0               DECREMENT TOTAL LENGTH
         EX        R1,SRCMOVE          MOVE SOURCE RECORD TO OUTPUT
         L         R2,CTRTBP(,R3)      POINT TO TRANSLATE TABLE
         EX        R1,SRCTRAN          TRANSLATE TO EBCDIC
         B         PUT                 GO WRITE IT OUT
SRCMOVE  MVC       BOUTPUT(*-*),3(R2)  EXECUTED MOVE SOURCE RECORD
SRCTRAN  TR        BOUTPUT(*-*),0(R2)  EXECUTED TRANSLATE SOURCE RECORD
         SPACE     2
PUT      DS        0H
         L         R2,PROCPTR          RESTORE WHERE WE STARTED
         TM        2(R2),X'10'         IF GENNED, NO MACROS
         BO        PUTO                BRANCH IF GENNED
         CLC       BOUTPUT(1),COMCHAR  COMMENT CARD .Q
         BE        PUTO                BRANCH IF YES
         CLI       BOUTPUT,C'*'        IS THIS ASSEMBLER COMMENT .Q
         BE        PUTO                BRANCH IF YES
         TM        2(R2),X'02'         CONTINUATION CARD .Q
         BO        PUTO                BRANCH IF YES
         LA        R1,BOUTPUT          START OF RECORD
SCNB     DS        0H
         CLI       0(R1),BLANK         FIND 1ST BLANK
         BE        SCNOP               BRANCH IF FOUND
         LA        R1,1(,R1)           BUMP ALONG LABEL
         B         SCNB                CONTINUE SEARCH
SCNOP    DS        0H
         LA        R1,1(,R1)           BUMP PAST BLANK
         CLI       0(R1),BLANK         NOW GO FOR OPCODE
         BE        SCNOP               TRY AGAIN
         LR        R10,R1              REMEMBER WHERE NAME STARTED
SCND     DS        0H
         LA        R1,1(,R1)           POINT TO NEXT OPCODE
         CLI       0(R1),BLANK         END OF OPCODE .Q
         BNE       SCND                NOT YET
         SR        R1,R10              GET LENGTH OF OPCODE
         C         R1,=F'8'            GREATER THAN EIGHT .Q
         BNH       STNAME              BRANCH IF NOT
         MVC       BCMNT(25),=C'OPCODE TOO LONG FOR MACRO'
         B         PUTO                AND PRINT IT
STNAME   DS        0H
         BCTR      R1,0                BACK OFF LENGTH BY ONE
         MVC       NAME(8),L1BLANKS+1(R9) BLANK TARGET
         EX        R1,MNM              MOVE IN MACRO NAME
         ST        R1,NAMELEN          SAVE NAME ENTRY LENGTH-1
         CLC       =C'MEND ',NAME      IS IT 'MEND' .Q
         BNE       NOTMEND             BRANCH IF NOT
         TM        MACROSW,INMAC       IN A MACRO NOW .Q
         BNO       MENDERR             BRANCH IF NOT
         MVC       BCMNT(10),=C'***MEND***'
         OI        MACROSW,NOPUNCH     BUT DON'T PUNCH IT
         NI        MACROSW,ON-(INMAC+MACPROT)  OUT OF MACRO
         B         PUTO                GO PRINT IT
MNM      MVC       NAME(*-*),0(R10)    EXECUTED MOVE MACRO NAME
MENDERR  DS        0H
         MVC       ERBUFR,L1BLANKS(R9) CLEAR ERROR BUFFER AREA
         MVC       MSGBG(17),=C'MEND OUT OF ORDER'
         LA        R10,ERBUFR          POINT TO IT
         BAL       R14,WRLST           WRITE OUT ERROR
         B         PUTO                PRINT IT
NOTMEND  DS        0H
         CLC       =C'MACRO ',NAME     IS IT 'MACRO' .Q
         BNE       NOTMACRO            BRANCH IF NOT
         TM        MACROSW,INMAC       IN A MACRO NOW .Q
         BO        MACROERR            BRANCH IF YES
         MVC       BCMNT(11),=C'***MACRO***'
         OI        MACROSW,INMAC+NOPUNCH+MACPROT  SET MACRO FLAGS
         B         PUTO                CONTINUE
MACROERR DS        0H
         MVC       ERBUFR,L1BLANKS(R9) CLEAR BUFFER AREA
         MVC       MSGBG(18),=C'MACRO OUT OF ORDER'
         LA        R10,ERBUFR          POINT TO IT
         BAL       R14,WRLST           WRITE OUT ERROR
         B         PUTO                PRINT IT
NOTMACRO DS        0H
         TM        MACROSW,INMAC       IN A MACRO NOW .Q
         BO        MENDSKIP            BRANCH IF YES
         CLC       =C'COPY ',NAME      'COPY' OPCODE .Q
         BNE       NOTCOPY             BRANCH IF NOT
         MVC       BCMNT(10),=C'***COPY***'
         MVC       BOUTPUT(1),COMCHAR  MAKE IT A COMMENT
         B         PUTO                AND PRINT IT
NOTCOPY  DS        0H
         MVC       TRNAME,NAME         MOVE OPCODE NAME
         L         R1,CTRTBP(,R3)      POINT TO TRANSLATE TABLE
         TR        TRNAME,0(R1)        TRANSLATE OPCODE TO INTERNAL
         SR        R1,R1               ZERO WORK LENGTH-1 REGISTER
         L         R14,L1ISADDR(,R9)   POINT TO INSTRUCTION SET
         LA        R4,X'85'            OPCODES START HERE
OPCDLOOP DS        0H
         C         R4,0(,R14)          PAST END OF OPCODE TABLE .Q
         BNL       CKBATCH             BRANCH IF YES
         LA        R15,0(R4,R14)       POINT TO OPCODE ENTRY
         IC        R1,2(,R15)          GET LENGTH-1 OF OPCODE
         N         R1,=F'7'            PURIFY THE LENGTH-1
         C         R1,NAMELEN          IS THE LENGTH-1 CORRECT .Q
         BL        OPCDNE              BRANCH ON IF NOT
         BH        CKBATCH             QUIT NOW IF TOO BIG
         EX        R1,OPCDCLC          IS THIS IT .Q
         BE        OPCDFOND            BRANCH IF YES
OPCDNE   DS        0H
         TM        2(R15),X'18'        IS TYPE EXTEN OR ASSEM .Q
         BNZ       OPCDEXAS            BRANCH IF YES
         LA        R4,6(R1,R4)         POINT TO NEXT ENTRY
         B         OPCDLOOP            LOOP BACK AND TRY AGAIN
OPCDEXAS DS        0H
         LA        R4,7(R1,R4)         POINT TO NEXT ENTRY
         B         OPCDLOOP            LOOP BACK AND TRY AGAIN
OPCDCLC  CLC       3(*-*,R15),TRNAME   EXECUTED COMPARE OPCODES
OPCDFOND DS        0H
         TM        2(R15),X'08'        IS OPCODE TYPE ASSEM .Q
         BZ        PUTO                BRANCH TO PRINT IF NOT
         LA        R14,OPENCOM         COMMON BRANCHING POINT
         CLC       =C'SETA ',NAME      IS IT 'SETA' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'SETB ',NAME      IS IT 'SETB' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'SETC ',NAME      IS IT 'SETC' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'ACTR ',NAME      IS IT 'ACTR' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'AGO ',NAME       IS IT 'AGO' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'AIF ',NAME       IS IT 'AIF' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'ANOP ',NAME      IS IT 'ANOP' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'GBLA ',NAME      IS IT 'GBLA' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'GBLB ',NAME      IS IT 'GBLB' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'GBLC ',NAME      IS IT 'GBLC' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'LCLA ',NAME      IS IT 'LCLA' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'LCLB ',NAME      IS IT 'LCLB' .Q
         BCR       8,R14               BRANCH IF YES
         CLC       =C'LCLC ',NAME      IS IT 'LCLC' .Q
         BCR       8,R14               BRANCH IF YES
         B         PUTO                OTHERWISE PRINT ASSEMBLER OPCODE
OPENCOM  DS        0H
         MVC       BOUTPUT(1),COMCHAR  COMMENT IT
         MVC       BCMNT(17),=C'***CONDITIONAL***'
         B         PUTO                AND PRINT IT
MENDSKIP DS        0H
         TM        MACROSW,MACPROT     EXPECTING PROTOTYPE .Q
         BO        PROTHERE            BRANCH IF YES
         MVC       BCMNT(19),=C'***SKIP FOR MEND***'
         B         PUTO                AND PRINT IT
PROTHERE DS        0H
         NI        MACROSW,ON-MACPROT  KILL PROTOTYPE EXPECTED SWITCH
         MVC       BCMNT(15),=C'***PROTOTYPE***'
         BAL       R14,SETMACNM        ENTER NAME IN MACRO TABLE
         B         PUTO                AND PRINT IT
CKBATCH  DS        0H
         L         R1,MACTBLA          MACRO TABLE ADDRESS
         L         R4,MACTBLO          CURRENT MACRO OFFSET
         LA        R0,8                ENTRY LENGTH OF NAME
         LD        FR0,NAME            GET MACRO NAME
TBLLOOP  DS        0H
         SR        R4,R0               NEXT NAME
         LTR       R4,R4               STILL OK .Q
         BM        CKLIB               BRANCH IF NOT
         CD        FR0,0(R4,R1)        IS THIS IT .Q
         BNE       TBLLOOP             BRANCH IF NOT
         B         FINDNENT            GOT IT, NO NEW ENTRY
CKLIB    DS        0H
         L         R1,L1DCBADS+L1SLIB(,R9) SYSLIB DCB ADDR
         TM        48(R1),X'10'        IS IT OPEN .Q
         BZ        PUTO                BRANCH IF NOT
         TM        L1PBYT1(R9),BATCH   ARE WE IN BATCH MODE .Q
         BZ        FINDOS              NO MACRO TABLE IF NOT
         TM        L1PBYT3(R9),CMS     ARE WE UNDER CMS .Q
         BO        PUTO                YES, NO INCORE MACRO TABLE
         L         R9,ADLIST1(,R3)     START OF LIST1 IN ASMGASM
         L         R14,L1TOPMC(,R9)    TOP OF MACRO NAMES
         L         R15,L1BOTMC(,R9)    BOTTOM
         LA        R0,11               ENTRY LENGTH
         MVC       0(8,R15),NAME       MOVE NAME INTO TABLE
SCAN     DS        0H
         SR        R14,R0              DECREMENT TO NEXT
         CLC       NAME(8),0(R14)      THIS ENTRY .Q
         BNE       SCAN                BRANCH IF NOT
         CR        R14,R15             THE ONE WE MOVED IN .Q
         BNE       FINDCMNT            BRANCH IF NOT
         TM        L1SYNERR(R9),X'08'  DID MACRO TABLE OFLOW .Q
         BZ        PUTO                BRANCH IF NOT
FINDOS   DS        0H
         L         R1,L1DCBADS+L1SLIB(,R9) SYSLIB DCB ADDRESS
         FIND      (1),NAME,D          LET OS DO IT
         LTR       R15,R15             WAS IT SUCCESSFUL .Q
         BNZ       PUTO                BRANCH IF NOT
FINDCMNT DS        0H
         BAL       R14,SETMACNM        ENTER NAME IN MACRO TABLE
FINDNENT DS        0H
         MVC       BOUTPUT(1),COMCHAR  MAKE IT A COMMENT
         MVC       BCMNT(16),=C'***MACRO CALL***'
         CLI       BOUTPUT+71,BLANK    IS THIS CONTINUED .Q
         BE        PUTO                BRANCH IF NOT
         OI        MACROSW,MACCALL     SET CONTINUED MAC CALL
         MVI       BOUTPUT+71,BLANK    CLEAR CONTINUATION
         BAL       R14,STMTBUMP        SET STATEMENT NUMBER
         B         PUTPOINT            AND WRITE IT OUT
SETMACNM DS        0H
         STM       R0,R15,PRSAVE       SAVE CALLER'S REGS
         L         R1,MACTBLA          GET TABLE ADDRESS
         LTR       R1,R1               IS IT PRESENT .Q
         BZ        SETMACDN            BRANCH IF NOT
         L         R2,MACTBLO          GET CURRENT OFFSET
         AR        R1,R2               POINT TO NEXT SLOT
         MVC       0(8,R1),NAME        ADD MACRO NAME
         LA        R2,8(,R2)           POINT TO NEXT ENTRY
         C         R2,MACTBLM          COMPARE WITH MAXIMUM
         BH        ABEND953            BRANCH IF TOO HIGH
         ST        R2,MACTBLO          SET NEW OFFSET
SETMACDN DS        0H
         LM        R0,R15,PRSAVE       RESTORE CALLER'S REGS
         BR        R14                 AND RETURN
ABEND953 DS        0H
         BAL       R0,ASMABEND         ERROR, WE QUIT NOW
         DC        C'953I',AL1(L'MES953-1)
MES953   DC        C'MACRO NAMES USED TABLE OVERFLOWED.'
PUTO     DS        0H                  ****
         TM        MACROSW,MACCALL     CONTINUED MACRO CALL .Q
         BZ        PUTNCONT            BRANCH IF NOT
         NI        MACROSW,ON-MACCALL  CLEAR CONTINUED SWITCH
         MVC       BOUTPUT(1),COMCHAR  COMMENT THIS RECORD
         CLI       BOUTPUT+71,BLANK    IS THIS CONTINUED .Q
         BE        PUTPOINT            BRANCH IF NOT
         OI        MACROSW,MACCALL     SET SWITCH AGAIN
         MVI       BOUTPUT+71,BLANK    CLEAR CONTINUATION
         B         PUTPOINT            GO AND PRINT IT
PUTNCONT DS        0H
         CLI       LASTREC+71,BLANK    WAS LAST RECORD A CONTINUED REC
         BNE       PUTPOINT            BRANCH IF YES
         BAL       R14,STMTBUMP        BUMP AND SET STATEMENT NUMBER
PUTPOINT DS        0H
         MVC       LASTREC,BOUTPUT     SAVE CURRENT IMAGE
         LA        R10,BUFF            POINT TO OUTPUT RECORD
         MVI       BUFF,X'00'          SINGLE SPACE
         BAL       R14,WRLST           BRANCH TO SYSPRINT ROUTINE
         LA        R10,BOUTPUT         POINT TO CARD IMAGE
         BAL       R14,WRPCH           BRANCH TO DECK/LOAD ROUTINE
SKIP     DS        0H
         MVC       LASTTYPE,2(R2)      SAVE FORMER RECORD TYPE
         TM        2(R2),X'80'         TEST LAST RECORD
         BO        INEND               YES
         L         R0,UT2REML          CURRENT BLOCK REMAINDER LENGTH
         S         R0,LENWORD          CURRENT LENGTH
         BNP       READ                NEXT BLOCK
         ST        R0,UT2REML
         A         R2,LENWORD          TO NEXT RECORD
         B         DEBLOCK
INEND    DS        0H                  END OF INPUT FILE
*                                                                     *
         NI        MACROSW,ON-NOPRINT  PRINT DIAGNOSTICS AND SUMMARY
         TM        CTTRMI(R3),TERM     IS TERM OPTION SPECIFIED .Q
         BZ        DIAGPH              NO, DON'T PRINT FINAL MESSAGE
         L         R1,ERCTR            GET NUMBER OF STMTS FLAGGED
         LTR       R1,R1               ARE THERE ANY .Q
         BZ        NOTMSGSK            NO FINAL SKIP IF SO
         BAL       R14,TBLANK          LEAVE A BLANK
NOTMSGSK DS        0H
         MVC       BUFR,L1BLANKS(R9)   CLEAR PRINT BUFFER
         MVC       BUFR+1(L'TMSG),TMSG BUFFER AREA
         MVC       BUFR+L'TMSG+2(4),CTITLE(R3)  ADD PROGRAM I.D.
         MVC       BUFR+30(8),L1PRTIME(R9) MOVE TIME TO HEADING LINE
         MVC       BUFR+42(9),L1PRDATE(R9) MOVE DATE TO HEADING LINE
         LA        R10,BUFR            ADDR TO PUT
         BAL       R14,SYSTRMD         ASSEMBLER (G7) DONE MSG
         BAL       R14,TBLANK          TMSG
         MVC       BUFR,L1BLANKS(R9)   BLANK OUTPUT BUFFER
         B         DIAGPH              BRANCH TO DIAGNOSTICS
STMTBUMP DS        0H
         STM       R0,R15,PRSAVE       SAVE CALLER'S REGS
         L         R1,STMTCTR          GET CURRENT STMT COUNTER
         LA        R1,1(,R1)           BUMP BY ONE
         ST        R1,STMTCTR          PUT IT BACK
         BAL       R14,CVTBTC          CONVERT BINARY TO CHARACTER
         MVC       BSTMNO(L5),WORD-1   ADD STMT TO OUTPUT LINE
         LM        R0,R15,PRSAVE       RESTORE CALLER'S REGS
         BR        R14                 AND RETURN
NOCORE   DS        0H
         BAL       R0,ASMABEND         POINT TO ERROR MESSAGE
         DC        C'951I',AL1(L'MES951-1)  MESSAGE NUMBER AND LENGTH
MES951   DC        C'INSUFFICIENT CORE FOR SYSUT2 BUFFERS IN ASMGMACP'
ASMABEND DS        0H
         L         R1,ADLIST1(,R3)     POINT TO LIST1 IN ASMGASM
         B         L1ABEND(,R1)        BRANCH TO ABEND ROUTINE
         TITLE     'MACRO POST PROCESSING DIAGNOSTIC PHASE'
ON       EQU       X'FF'               NORMAL SWITCH SETTING
OFF      EQU       X'00'               NORMAL SWITCH SETTING
GEN      EQU       C'+'                A GENERATED LINE MARKER
L1F      EQU       1                   NUMBER OF BYTES TO MOVE
L2D      EQU       2                   NUMBER OF BYTES TO MOVE
L8C      EQU       8                   NUMBER OF BYTES TO MOVE
L3B      EQU       3                   NUMBER OF BYTES TO MOVE
MLG      EQU       120-1               LENGTH OF BLANKING
MKF      EQU       X'10'               MASK FOR SYSPRINT
L4C      EQU       4                   NUMBER OF BYTES TO COMPARE
L4D      EQU       4                   OFFSET IN AN AREA
L2E      EQU       2                   NUMBER OF BYTES TO COMPARE
L3H      EQU       3                   NUMBER OF BYTES TO MOVE
L16      EQU       16                  NUMBER OF BYTES TO MOVE
L7A      EQU       7                   OFFSET IN AN AREA
L102     EQU       102                 NUMBER OF BYTES TO MOVE
L111     EQU       111                 NUMBER OF BYTES TO MOVE
MKI      EQU       X'80'               LAST RECORD MASK
L2F      EQU       2                   OFFSET IN AN AREA
L2G      EQU       2                   NUMBER OF BYTES TO MOVE
L1G      EQU       1                   OFFSET IN AN AREA
L119     EQU       119                 NUMBER OF BYTES TO MOVE
L120     EQU       120                 NUMBER OF BYTES TO MOVE
L121     EQU       121                 NUMBER OF BYTES TO MOVE
L2H      EQU       2                   OFFSET IN AN AREA
L5       EQU       5                   NUMBER OF BYTES TO MOVE
L81      EQU       81                  NUMBER OF BYTES TO MOVE
L8D      EQU       8                   NUMBER OF BYTES TO MOVE
L73      EQU       73                  NUMBER OF BYTES TO MOVE
         SPACE     3
DIAGPH   DS        0H
         MVC       HEAD2+1(111),L1BLANKS+1(R9) CLEAR 2ND HEADER
         MVC       HEAD1+82(11),=C'DIAGNOSTICS' CHANGE 1ST HEADER
         CLI       L1SYNERR(R9),X'00'  ANY ERROR SWITCHES ON .Q
         BZ        ML00                NO, BRANCH AROUND
         LA        R4,X'80'            SET TO CHECK FIRST SWITCH
         LA        R6,BRANCHES         ROUTINES FOR VARIOUS SWITCHES
TST      DS        0H
         TM        L1SYNERR(R9),X'80'+*-* TEST A SWITCH
         BCR       1,R6                BOR    GO TO APPROPRIATE ROUTINE
         CLC       CTSEVCOD(1,R3),SVCODE HIGHEST SO FAR .Q
         BNL       BFBR                NO THEN SKIP IT
         MVC       CTSEVCOD(1,R3),SVCODE YES THEN REPLACE IT
         MVI       SVCODE,X'00'        RESET THE TEMP CODE
BFBR     DS        0H
         LA        R6,4(,R6)           SET TO NEXT ROUTINE
         SRA       R5,1                NEXT SWITCH TO TEST
         STC       R5,TST+1            IS PUT INTO CODING
         BNZ       TST                 BRANCH IF NOT LAST SWITCH TO TST
*                                                                     *
         MVI       TST+1,X'01'         RESTORE CODING
         SR        R5,R5               ZERO A WORK REGISTER
         TM        L1SYNERR(R9),X'08'  DID INCORE MACRO TABLE O'FLOW
         BZ        NOOFLOW             BRANCH IF NOT
         LA        R5,X'08'            SET REGISTER IF SO
NOOFLOW  DS        0H
         XC        L1SYNERR(10,R9),L1SYNERR(R9) ZERO SW AND COUNTERS
         STC       R5,L1SYNERR(,R9)    RESET O'FLOW CONDITION
ML00     DS        0H
         B         ML102               GO ENDUP ASMGMACP WITH STATS
*                                                                     *
*        PRINT OUT ***ERROR*** RECORDS                                *
*                                                                     *
ML01A    DS        0H
         SR        R1,R1               ZERO REGISTER
         IC        R1,ERCT(,R2)        GET ERROR COUNT
         LTR       R1,R1               IS COUNT ZERO .Q
         BNZ       ML02                NO, GO OUTPUT ERROR MESSAGES
         LA        R6,6                SET ERROR CODE TO PROCEDURE ERR
         B         ML03                SKIP GETTING ERROR CODE
ML02     DS        0H
         SR        R6,R6               ZERO WORK REGISTER
         IC        R6,ERM(,R2)         GET ERROR CODE
         CLI       ERM(R2),78          ERROR ASMG078 .Q
         BNE       ML03                BRANCH IF NOT
         OI        MACROSW,POSTER78    TURN OFF PUNCHING OUTPUT
ML03     DS        0H
         MVC       ERBUFR,L1BLANKS(R9)  BLANK ERROR PRINT BUFFER
         MVC       ERBUFR+1(18),=C'****** ***ERROR***' SET ERROR IND
         MVC       ERCD(10),PRGTYP     MOVE PROGRAM TYPE TO MESSAGE
         LR        R1,R6               TRANSFER FOR CONVERSION
         BAL       R14,CVTBTC          GO CONVERT ERROR MESSAGE FOR
         OC        WORD(4),MASK        CHANGE BLANKS TO ZEROS
         MVC       ERNO(3),WORD+1      MOVE ERROR NUMBER TO PRINT
         LTR       R6,R6               IS ERROR CODE ZERO
         BZ        ML031               YES, BAD ERROR CODE
         BCTR      R6,0                REDUCE ERROR NUMBER BY 1
         AR        R6,R6               MULTIPLY BY 2
         LA        R7,PTRTBL(R6)       POINT TO TABLE
         LA        R1,ENDTBL           GET END OF TABLE LOCATION
         CR        R7,R1               IS NUMBER IN TABLE
         BL        ML04                YES, GO PUT MESSAGE
*                                                                     *
ML031    DS        0H
         LH        R1,ENDTBL           ERROR NUMBER NOT KNOWN
         LA        R4,ESTART(R1)       ERROR CODE
         LA        R7,MSGBG            SET POINTER FOR MESSAGE MOVE
         B         ML05                CONTINUE
ML04     DS        0H
         LH        R1,PTRTBL(R6)       GET POINTER TO MESSAGE
         LA        R4,ESTART(R1)       SET POINTER TO MESSAGE
         LA        R7,MSGBG            SET POINTER FOR MESSAGE MOVE
         CLI       ERCOL(R2),X'00'     IS COLUMN POINTER ZERO .Q
         BE        ML05                YES, GO PUT MESSAGE
*                                                                     *
         SR        R1,R1               NO, PUT OUT COLUMN POINTER
         IC        R1,ERCOL(,R2)       GET COLUMN POINTER
         BAL       R14,CVTBTC          GO CONVERT FOR LISTING
         MVC       MSGBG(25),PTRMSG    MOVE COLUMN POINTER MESSAGE
         MVC       MSGBG+20(3),WORD+1  MOVE COLUMN POINTER
         LA        R7,25(,R7)          STEP POINTER TO WHERE TO PUT
*                                       MESSAGE BY 20 BYTES           *
ML05     DS        0H
         IC        R1,0(,R4)           GET MOVE LENGTH-1 OF MESSAGE
         EX        R1,MVMSG            MOVE MESSAGE TO BUFR
         TM        1(R4),NOPERR        IS ERROR VALID .Q
         BZ        MLVALER             BRANCH IF YES
         TM        LASTTYPE,X'70'      WAS LAST RECORD GENNED .Q
         BNO       MLDONE              BRANCH IF NOT
         IC        R1,1(,R4)           GET SEVERITY CODE
         N         R1,=X'0000007F'     CLEAR HIGH BIT
         STC       R1,WORD+1           SAVE SEVERITY CODE
         LA        R4,WORD             WORK WITH ACTUAL SEVERITY
MLVALER  DS        0H
         CLC       LSTMTN,STMTCTR      HAS STMT NUMBER CHANGED .Q
         BE        MLSEVCD             BRANCH IF NOT
         MVC       LSTMTN,STMTCTR      SAVE NEW STMT NUMBER
         L         R1,ERCTR            GET CURRENT STATEMENTS IN ERROR
         LA        R1,1(,R1)           BUMP BY ONE
         ST        R1,ERCTR            SAVE IT BACK FOR LISTING
MLSEVCD  DS        0H
         CLC       CTSEVCOD(1,R3),1(R4)  COMPARE SEVCODE OF CURRENT
         BNL       *+10                MESSAGE TO HIGHEST CODE SO FAR
         MVC       CTSEVCOD(1,R3),1(R4)  ENCOUNTERED (INCLUDING MNOTE)
         LA        R10,ERBUFR          SET POINTER TO BUFR
         BAL       R14,WRLST           GO LIST MESSAGE
         LA        R10,BUFR            POINT TO SYSPRINT BUFR
         BAL       R14,SYSTRMD         PRINT IT ON SYSTERM
         LA        R10,ERBUFR          POINT TO ERROR BUFR
         BAL       R14,SYSTRMD         GO LIST SYSTERM ERROR MSG
MLDONE   DS        0H
         B         SKIP                RETURN TO CALLER
*                                                                     *
*        PRINT OUT FINAL STATISTICS                                   *
*                                                                     *
ML102    DS        0H
         L         R10,YLCNT           GET NUMBER OF LINES LEFT
         S         R10,=F'11'          DECREMENT BY TRAILER LENGTH
         BP        ML103               BRANCH IF STILL ROOM
         LA        R10,1               GET ONE IN A REGISTER
         ST        R10,YLCNT           SET UP FOR A NEW PAGE
ML103    DS        0H
*                                                                     *
*        PRINT ERROR SUMMARY RECORDS                                  *
*                                                                     *
ML10     DS        0H
         MVC       BUFR,L1BLANKS(R9)   BLANK SYSPRINT BUFFER
         L         R1,ERCTR            GET NUMBER OF ERROR RECORDS
         LTR       R1,R1               WERE THERE ANY ERRORS
         BNZ       ML101               BRANCH IF YES
         MVC       BUFR(39),ERCTM+2    'NO STATEMENTS FLAGGED'
         MVC       BUFR(3),CAC         'NO'
         B         ML112               GO AND PRINT IT
ML101    DS        0H
         MVC       BUFR(42),ERCTM-1    ENTER STMTS FLAGGED MESSAGE
         BCT       R1,ML101A           TEST FOR ONLY 1 ERROR RECORD
         MVI       BUFR+16,BLANK       BLANK 'S' ON 'STATEMENTS'
ML101A   DS        0H
         A         R1,=F'1'            RESTORE STMTS FLAGGED
         BAL       R14,CVTBTC          CONVERT ERROR COUNT
         MVC       BUFR+2(4),WORD      FOR LISTING MESSAGE
ML112    DS        0H
         LA        R10,BUFR            GET MESSAGE LOCATION
         BAL       R14,WRLST           PRINT NUMBER OF ERRORS
         BAL       R14,TBLANK          LEAVE A LINE ON SYSTERM
         BAL       R14,SYSTRMD         SYSTERM NUMBER OF ERRORS
ML100    DS        0H
         IC        R1,CTSEVCOD(,R3)    GET SEVERITY CODE
         LTR       R1,R1               IS IT ZERO .Q
         BZ        ZSVCD               IF SO, DON'T PRINT SEV CODE
         BAL       R14,CVTBTC          CONVERT TO DECIMAL
         MVC       BUFR(42),SVMES      MOVE SEVERITY MESSAGE
         MVC       BUFR+32(10),L1BLANKS+1(R9) BLANK PART OF RECORD
         MVC       BUFR+3(3),WORD+1    PUT IN SEVERITY CODE
         LA        R10,BUFR            POINT TO MESSAGE
         BAL       R14,WRLST           PRINT SEVERITY MESSAGE
         BAL       R14,SYSTRMD         SYSTERM SEVERITY MESSAGE
ZSVCD    DS        0H
*                                                                     *
*        PRINT OUT CARDS READ/LINES OUTPUT STATISTICS                 *
*                                                                     *
         MVI       BUFR,X'03'          LEAVE THREE LINES AGAIN
STATLOP1 DS        0H
         SR        R4,R4               ZERO OFFSET IN DCB ADDR LIST
         MVC       BUFR+1(L'BUFR-1),L1BLANKS+1(R9)  BLANK OUTPUT LINE
         LA        R10,BUFR            POINT TO OUTPUT LINE
STATLOP2 DS        0H
         L         R6,L1DCBADS(R4,R9)  GET ADDRESS OF NEXT DCB
TYPESW   TM        L1DCBPAD(R6),X'01'+*-* IS IT TYPE WE WANT .Q
         BZ        STATLOP3            BRANCH IF NOT
         L         R1,L1DCBRCT(,R6)    GET NUMBER OF RECORDS
         LTR       R1,R1               IS IT ZERO .Q
         BZ        STATLOP3            BRANCH IF SO
         BAL       R14,CVTBTC          CONVERT TO CHARACTER
         SR        R1,R1               ZERO A REGISTER
         ST        R1,L1DCBRCT(,R6)    ZERO RECORD COUNT
         MVC       1(5,R10),WORD-1     MOVE IN COUNT
         LA        R5,L1DDNAM(R4,R4)   GET DDNAME OFFSET IN LIST1
         AR        R5,R9               POINT TO DDNAME
         MVC       7(8,R10),0(R5)      ADD DDNAME
         LA        R10,14(,R10)        BUMP TO END OF DDNAME
DDNAMLOP DS        0H
         CLI       0(R10),BLANK        IS THIS THE END .Q
         BNE       DDNAMOUT            BRANCH IF YES
         BCT       R10,DDNAMLOP        DECREMENT AND BRANCH
DDNAMOUT DS        0H
         MVC       2(L'RECMESS,R10),RECMESS  ADD TEXT
         LA        R10,L'RECMESS+2(,R10)  NEW END OF STRING
         MVI       0(R10),C','         FOLLOWED BY A COMMA
STATLOP3 DS        0H
         LA        R4,4(,R4)           POINT TO NEXT DCB IN LIST
         LTR       R6,R6               AT END OF DCB LIST .Q
         BP        STATLOP2            BRANCH IF NOT
         MVI       0(R10),BLANK        BLANK LAST COMMA
         LA        R10,BUFR            LINE TO PRINT
         BAL       R14,WRLST           GO PRINT IT
         TM        TYPESW+1,X'02'      HAVE WE DONE OUTPUT .Q
         BO        STATEND             BRANCH IF YES
         MVI       TYPESW+1,X'02'      DO OUTPUT RECORDS NOW
         MVC       RECMESS(6),=C'OUTPUT' CHANGE MESSAGE TEXT
         MVI       BUFR,X'00'          SINGLE SPACE
         B         STATLOP1            DO IT AGAIN
STATEND  DS        0H
         L         R1,L1DCBADS+L1SPRINT(,R9) POINT TO SYSPRINT DCB
         MVI       L1DCBCC(R1),X'40'   SET NUMERIC CARRIAGE CONTROL
         SR        R0,R0               ZERO A WORK REGISTER
         ST        R0,L1DCBRCT(,R1)    ZERO SYSPRINT RECORD COUNT
         B         ARND                CLOSE PHASE
         SPACE     2
CVTBTC   DS        0H
         CVD       R1,DWORD            CONVERT BINARY TO DECIMAL
         MVC       WORD-2(6),=X'402020202120'  EDIT MASK WITH BLANKS
         ED        WORD-2(6),DWORD+5   EDIT IN THE NUMBER
         BR        R14                 AND RETURN
         SPACE     2
ARND     DS        0H
         LM        R0,R1,SPREQ         GET LENGTH/ADDR OF WORK AREA
         STM       R0,R1,RETREQ        STORE LENGTH/ADDR TO RELEASE IT
         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF
         CNOP      2,4                 FOR ALIGNMENT
         BALR      R0,R1               GO AND RELEASE THE SPACE
         DC        A(32)               GROW CALL
RETREQ   DS        F                   LENGTH TO BE FREED
RETGOT   DS        F                   ADDRESS TO BE FREED
         L         R1,L1BUFADR(,R9)    POINT TO ASMGBUFF
         CNOP      2,4                 ALIGN PARAMETERS
         BALR      R0,R1               GO AND TCLOSE SYSUT2
         DC        A(24,4,1)           MEANS A TCLOSE OF SYSUT2
         SR        R15,R15             ZERO A WORK REGISTER
         IC        R15,CTSEVCOD(,R3)   RC  =  HIGHEST SEVCODE
         C         R15,L1SAVECC(,R9)   IS THIS HIGHEST CC SO FAR
         BNH       *+8                 NO, PROCEED
         ST        R15,L1SAVECC(,R9)   YES, SAVE HIGHEST SO FAR
         TM        L1PBYT1(R9),BATCH   IS BATCH ON .Q
         BO        SAVESUM             YES, SAVE BATCH TABLE INFO
         DELETE    EPLOC=L1ISNAME(,R9) DELETE INSTRUCTION SET
         TM        L1SINSW(R9),X'80'   HAVE WE HIT END OF FILE .Q
         BO        RETURN              YES, THEN WE'RE DONE
         MVI       BUFR+1,BLANK        INSERT A BLANK
         MVC       BUFR+2(L'BUFR-2),BUFR+1  AND MOVE IT ACROSS
         MVC       BUFF+1(L'MSUNPROC),MSUNPROC  TEXT OF ERROR MESSAGE
         MVC       BUFF+23(8),L1DDNAM+2*L1SIN(R9) PLACE SYSIN DDNAME
         MVC       BUFF+39(8),L1DDNAM+2*L1SUP(R9) AND SYSUP DDNAME
         TM        L1PBYT2(R9),UPDATE  WAS UPDATE SPECIFIED .Q
         BO        TWOFILES            BRANCH IF YES
         MVI       BUFF+7,C'5'         CHANGE TO ASMG205
         MVC       BUFF+32(30),BUFF+48 BLANK SYSUP INFORMATION
TWOFILES DS        0H
         MVC       HEAD2+1(30),HEAD2+31 BLANK SECOND HEADER
         MVI       BUFF,X'03'          TRIPLE SPACE
         LA        R10,BUFF            POINT TO OUTPUT LINE
         BAL       R14,WRLST           GO LIST FINAL MESSAGE
         MVI       BUFF,X'00'          PREPARE FOR SYSTERM
         BAL       R14,TBLANK          LEAVE A LINE
         BAL       R14,SYSTRMD         AND PRINT THE UNPROCESSED ERROR
         B         RETURN              THAT'S ALL
GOAGAIN  DS        0H
         LA        R10,ON              SET BATCH SWITCH FOR RTA
         LA        R2,L1BLDL+L1LENBL(,R9) ADDRESS OF F1 IN BLDL TABLE
         B         RETURN1             GO AND TERMINATE
*                                                                     *
*        SAVE BATCH SUMMARY INFORMATION                               *
SAVESUM  DS        0H
         L         R1,L1BUFADR(,R9)    ADDRESS OF ASMGBUFF
         CNOP      2,4                 ALIGN PARAMETERS
         BALR      R0,R1               BRANCH TO SHRINK
         DC        F'36'               MEANS A SHRINK OF BUFF SPACE
         DC        F'8'                I NEED 8 BYTES
SHADR    DS        F                   BUFF WILL FILL THIS IN
*                                                                     *
         L         R1,SHADR            ADDRESS OF CORE WE GOT
         L         R4,L1BTCSUM(,R9)    GET FIRST BATCH SUMMARY ADDRESS
         LTR       R4,R4               FIRST PROGRAM IN BATCH .Q
         BNZ       *+8                 NO, THEN BRANCH AROUND
         ST        R1,L1BTCSUM(,R9)    REMEMBER 1ST 8 BYTES IN CHAIN
         MVI       0(R1),X'00'         THIS MAY NOT BE LAST ASSEMBLY
         STC       R15,1(,R1)          SEVERITY CODE OF THIS PROGRAM
         MVC       2(2,R1),ERCTR+2     NUMBER OF STMTS FLAGGED
         MVC       4(4,R1),CTITLE(R3)  PROGRAM I.D.
         TM        L1SINSW(R9),X'80'   ARE WE AT EOF .Q
         BNO       GOAGAIN             NO, SET XCTL FOR RTA
*                                                                     *
*        NOW PRINT THE BATCH SUMMARY                                  *
         MVI       0(R1),ON            MARKS THE LAST ASSEMBLY
         L         R5,L1BTCSUM(,R9)    ADDRESS OF FIRST BATCH ENTRY
         CLI       0(R5),ON            IS FIRST THE LAST .Q
         BE        RETURN              YES, SUMMARY IS THEN USELESS
         SR        R4,R4               ZERO A REGISTER
         ST        R4,L1PAGENO(,R9)    ZERO PAGE COUNT
         LA        R4,1                ONE IN A REGISTER
         ST        R4,YLCNT            INITIALIZE LINES FOR NEW PAGE
         MVC       HEAD1+1(101),L1BLANKS+1(R9) BLANK HEADER 1
         MVC       HEAD1+23(14),BSUMMARY SET UP 1ST HEADING
         MVC       HEAD2+1(59),=C'DECK NUMBER  DECK I.D.  SEVERITY CODE*
                 NUMBER STMTS FLAGGED'
         MVC       BUFR,L1BLANKS(R9)   BLANK LINE BUFFER
         SR        R7,R7               ZERO TOTAL ERROR COUNT
         SR        R6,R6               ZERO FOR DECK NUMBER
NEXTPGM  LA        R6,1(,R6)           INCREMENT DECK NUMBER
         LR        R1,R6               TRANSFER DECK NUMBER
         BAL       R14,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+3(4),WORD      MOVE INTO PRINT LINE
         MVC       BUFF+16(4),4(R5)    MOVE IN DECK I.D.
         IC        R1,1(,R5)           INSERT SEVERITY CODE
         BAL       R14,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+30(4),WORD     MOVE INTO PRINT LINE
         LH        R1,2(,R5)           GET NUMBER OF STMTS FLAGGED
         AR        R7,R1               INCREASE TOTAL ERROR COUNT
         BAL       R14,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+46(4),WORD     MOVE INTO PRINT LINE
         LA        R10,BUFF            POINT TO PRINT LINE
         BAL       R14,WRLST           PRINT INFORMATION LINE
         CLI       0(R5),ON            IS THIS THE END .Q
         BE        TESTMESS            YES, MAKE UP FIRST MESSAGE
         LA        R5,8(,R5)           POINT TO NEXT SUMMARY
         B         NEXTPGM             DO NEXT PROGRAM IN BATCH
*                                                                     *
*        OUTPUT NO STATEMENTS FLAGGED MESSAGE                         *
TESTMESS MVI       BUFF,X'02'          LEAVE 2 LINES
         LTR       R7,R7               WERE NO STATEMENTS FLAGGED .Q
         BNZ       TWOMESS             NO, MAKE UP TWO MESSAGES
         MVC       BUFF+1(38),ERCTM+3  MOVE IN MESSAGE
         MVC       BUFF+1(2),CAC+1     MOVE IN 'NO'
         MVC       BUFF+31(6),BSUMMARY CHANGE MESSAGE
         MVC       BUFF+37(20),BUFF+36 BLANK THE REST OF THE LINE
         B         LASTMESS            THAT'S ALL HERE
*                                                                     *
*        NUMBER FLAGGED AND SEVERITY CODE                             *
TWOMESS  DS        0H
         LR        R1,R7               NUMBER OF STATEMENTS FLAGGED
         BAL       R14,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+1(41),ERCTM    MOVE IN MESSAGE
         MVC       BUFF+34(6),BSUMMARY CHANGE MESSAGE
         MVC       BUFF+40(20),BUFF+39 BLANK REST OF LINE
         BCT       R7,*+8              ONLY ONE ERROR .Q
         MVI       BUFF+16,BLANK       REMOVE 'S'
         MVC       BUFF+2(4),WORD      MOVE IN NUMBER
         LA        R10,BUFF            POINT TO OUTPUT LINE
         BAL       R14,WRLST           AND PRINT IT
         MVI       BUFF,X'00'          DON'T SKIP LINE
         MVC       BUFF+1(40),SVMES+1  MOVE IN SEVERITY MESSAGE
         L         R1,L1SAVECC(,R9)    GET HIGHEST SEVERITY CODE
         BAL       R14,CVTBTC          CONVERT TO CHARACTER
         MVC       BUFF+2(4),WORD      MOVE IN NUMBER
LASTMESS DS        0H
         LA        R10,BUFF            POINT TO MESSAGE
         BAL       R14,WRLST           AND PRINT IT
RETURN   DS        0H
         SR        R10,R10             RETURN TO ASMGASM VIA RTA
RETURN1  DS        0H
         L         R14,CTMRSRTN(,R3)   RESTORE RETURN REGISTER
         BR        R14                 AND RETURN
*                                                                     *
BRANCHES EQU       *                   ROUTINES
         B         AE20416             0
         B         AE204               1
         B         AE207               2
         B         AE206               3
         B         AE208               4         IN CORE MACRO DIR EXCE
         B         AE209               5         THIS MANY FINDS RESULT
         B         AE203               6
         B         BFBR                7
         SPACE     2
AE203    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
         MVC       BUFR+20(21),=C'ILLEGAL DCB OPERANDS.'
         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'
         LA        R7,C'3'             ASMG203
         B         ASMGDDDI
AE204    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
AE204B   DS        0H
         MVC       BUFR+20(21),=C'UNOPENABLE DATA SETS.'
         MVC       BUFR+42(15),=C'SEE FIRST PAGE.'
         LA        R7,C'4'             ASMG204
         B         ASMGDDDI
AE20416  MVI       SVCODE,X'10'        SEVERITY CODE OF 16
         NI        L1SYNERR(R9),ON-X'40'  SKIP 204 SEV 4 TEST
         B         AE204B              OTHERWISE SAME AS OTHER 204
AE206    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
         LA        R7,C'6'             ASMG206
         MVC       BUFR+39(8),L1DDNAM+2*L1SPRINT(R9) SYSPRINT DDNAME
         LH        R1,L1IOERR+2(,R9)   GET NUMBER OF SYSPRINT ERRORS
         B         MSG67
AE207    DS        0H
         MVI       SVCODE,X'04'        SEVERITY FOUR
         LA        R7,C'7'             ASMG207
         MVC       BUFR+39(8),L1DDNAM+2*L1SPUNCH(R9) SYSPUNCH DDNAME
         LH        R1,L1IOERR(,R9)     GET NUMBER OF SYSPUNCH ERRORS
         B         MSG67
AE208    DS        0H
         MVC       BUFR+20(34),=C'MORE THAN****** MACROS ON LIBRARY.'
         L         R0,L1TOPMC(,R9)     GET ADDR OF TOP OF MACRO TABLE
         S         R0,L1BOTMC(,R9)     LESS THE BOTTOM
         SRDA      R0,32               SET FOR A DIVIDE
         D         R0,=F'11'           DIVIDE BY EACH ENTRY LENGTH
         BCTR      R1,0                LESS THE END DUMMY ENTRY
         CVD       R1,DWORD            CONVERT TO DECIMAL
         MVC       BUFR+29(6),=X'402020202020' ADD MASK
         ED        BUFR+29(6),DWORD+5  EDIT IN NUMBER OF MACROS
         LA        R7,C'8'             ASMG208
         B         ASMGDDDI            GO DO IT
AE209    DS        0H
         MVC       BUFR+25(40),=C'LIBRARY FINDS DONE TO COMPLETE ASSEMB*
               LY.'
         L         R1,L1FINDCT(,R9)    GET NUMBER OF FINDS DONE
         CVD       R1,DWORD            CONVERT TO DECIMAL
         BCT       R1,*+8              ONLY 1 FIND .Q
         MVI       BUFR+37,BLANK       BLANK THE 'S'
         MVC       BUFR+18(6),=X'402020202020' ADD MASK
         ED        BUFR+18(6),DWORD+5  EDIT IN THE COUNT
         LA        R7,C'9'             ASMG209
         B         ASMGDDDI            GO DO IT
MSG67    DS        0H
         MVC       BUFR+25(13),=C'I/O ERRORS ON'
         CVD       R1,DWORD            CONVERT NUMBER TO DECIMAL
         BCT       R1,*+8              ONLY 1 ERROR .Q
         MVI       BUFR+34,BLANK       YES, BLANK 'S' ON 'ERRORS'
         MVC       BUFR+18(6),=X'402020202020'
         ED        BUFR+18(6),DWORD+5  EDIT IN NUMBER OF ERRORS
         LA        R1,BUFR+39          POINT TO DDNAME
BLKSAD   DS        0H
         LA        R1,1(,R1)           ADVANCE 1 CHARACTER
         CLI       0(R1),BLANK         END OF DDNAME .Q
         BNE       BLKSAD              NO, CONTINUE LOOKING
         MVI       0(R1),C'.'          YES, PUT IN PERIOD
ASMGDDDI DS        0H
         MVC       BUFR+9(10),PRGTYP
         STC       R7,BUFR+15          PUT IN LAST DIGIT
         LA        R10,BUFR
         BAL       R14,WRLST           GO LIST ERROR
         MVC       CTLINECT(4,R3),YLCNT UPDATE LINES LEFT ON PAGE
         MVI       BUFR,X'00'          SET UP FOR SYSTERM
         BAL       R14,SYSTRMD         GO PRINT ERROR ON SYSTERM
         BAL       R14,TBLANK          AND LEAVE A BLANK LINE
         MVC       BUFR,L1BLANKS(R9)   RESET CARR CONTROL AND LINE
         B         BFBR                TEST NEXT SWITCH
         EJECT
***********************************************************************
*        SYSPUNCH, SYSLIN OUTPUT ROUTINE                              *
***********************************************************************
WRPCH    DS        0H
         TM        MACROSW,POSTER78    AFTER ASMG078 ERROR .Q
         BCR       1,R14               RETURN IMMEDIATELY IF SO
         TM        MACROSW,INMAC+NOPUNCH  CAN I PUNCH THIS RECORD
         BCR       1,R14               BRANCH BACK IF NOT
         BZ        PCHNXT              TEST FURTHER IF NOTHING
         NI        MACROSW,ON-(INMAC+NOPUNCH)  CLEAR SWITCHES
         BR        R14                 AND RETURN
PCHNXT   DS        0H
         TM        L1PBYT(R9),DECK+LOAD ANYTHING TO WRITE OUT
         BCR       8,R14               BRANCH BACK IF NOT
         STM       R0,R15,PRSAVE       SAVE CALLER'S REGISTERS
         TM        L1PBYT(R9),DECK     WAS DECK SPECIFIED .Q
         BZ        NODECK              BRANCH IF NOT
         L         R1,L1DCBADS+L1SPUNCH(,R9) GET SYSPUNCH DCB ADDRESS
         PUT       (1),(R10)           DO THE IO
NODECK   DS        0H
         TM        L1PBYT(R9),LOAD     WAS LOAD SPECIFIED .Q
         BZ        NOLOAD              BRANCH IF NOT
         L         R1,L1DCBADS+L1SLIN(,R9) GET SYSLIN DCB ADDRESS
         PUT       (1),(R10)           DO THE IO
NOLOAD   DS        0H
         LM        R0,R15,PRSAVE       RESTORE CALLER'S REGS
         BR        R14                 AND RETURN
***********************************************************************
*        WRITE RECORDS ON SYSPRINT                                    *
***********************************************************************
WRLST    DS        0H
         TM        MACROSW,NOPRINT     SHOULD THIS LINE BE PRINTED .Q
         BCR       1,R14               BRANCH BACK IF NOT
         STM       R0,R15,PRSAVE       SAVE ALL REGISTERS
         L         R2,YLCNT            CURRENT LINE COUNT
         BCT       R2,WRLINE           AT BOTTOM OF PAGE .Q
         L         R1,L1PAGENO(,R9)    GET CURRENT PAGE NUMBER
         LA        R1,1(,R1)           INCREMENT BY ONE
         ST        R1,L1PAGENO(,R9)    UPDATE CURRENT PAGE NUMBER
         BAL       R14,CVTBTC          CONVERT TO CHARACTER
         MVC       HPAGENO(4),WORD     MOVE TO HEADER LINE
         LA        R0,HEAD1            POINT TO FIRST HEADER
         BAL       R14,SYSL            PRINT IT
         LA        R0,HEAD2            POINT TO SECOND HEADER
         BAL       R14,SYSL            PRINT IT
         MVI       0(R10),X'01'        LEAVE A LINE NEXT TIME
         SR        R2,R2               ZERO A REGISTER
         IC        R2,CTPGLNCT(,R3)    RESTORE LINE COUNT PER PAGE
WRLINE   DS        0H
         ST        R2,YLCNT            SAVE NEW LINES LEFT
         LR        R0,R10              POINT TO LINE TO BE OUTPUT
         BAL       R14,SYSL            PRINT IT
         MVI       0(R10),X'00'        RESET SPACE OPERAND
         LM        R0,R15,PRSAVE       RESTORE ALL REGISTERS
         BR        R14                 RETURN
***********************************************************************
*        SYSTEM LIST SUBROUTINE                                       *
***********************************************************************
SYSL     DS        0H
         L         R1,L1DCBADS+L1SPRINT(,R9) SYSPRINT DCB ADDR
         L         R15,48(,R1)         LOAD PUT ROUTINE ADDRESS
         BR        R15                 AND BRANCH TO IT
         EJECT
*                                                                     *
*                                                                     *
*        SYSTERM OUTPUT LISTING VIA SYSTERM                           *
*                                                                     *
SYSTRMD  DS        0H
         TM        L1PBYT2(R9),TERM    IS TERM OPTION ON .Q
         BCR       8,R14               NO, THEN EXIT
         STM       R0,R15,PRSAVE       SAVE ALL REGISTERS
SYSTRMD1 DS        0H
         L         R4,L1TRSAVE(,R9)    RESTORE PAST LINE DATA
         BCT       R4,SYSTRA           TEST FOR NO EJECT
         MVI       0(R10),ON           SKIP TO A NEW PAGE
         SR        R4,R4               ZERO A REGISTER
         IC        R4,CTPGLNCT(,R3)    GET LINE COUNT PER PAGE
SYSTRA   DS        0H
         ST        R4,L1TRSAVE(,R9)    UPDATE LINES LEFT
         L         R1,L1DCBADS+L1STERM(,R9) SYSTERM DCB ADDRESS
         PUT       (1),(R10)
         MVI       0(R10),X'00'        RESET CARRIAGE CONTROL
         LM        R0,R15,PRSAVE       RESTORE REGISTERS
         BR        R14                 AND RETURN
         SPACE     2
*                                                                     *
*        BLANK LINE ON SYSTERM                                        *
*                                                                     *
TBLANK   DS        0H
         TM        L1PBYT2(R9),TERM    IS TERM OPTION ON .Q
         BCR       8,R14               NO, THEN EXIT IMMEDIATELY
         STM       R0,R15,PRSAVE       SAVE REGISTERS
         LA        R10,L1BLANKS(,R9)   POINT TO X'00'.BLANKS
         B         SYSTRMD1            GO AND PRINT IT
         TITLE     'ASMGMACP    CONSTANTS AND WORK AREAS'
***********************************************************************
*        CONSTANTS AND WORK AREAS                                     *
***********************************************************************
         SPACE     2
SAVE     DC        18F'0'              MY SAVE AREA
PATCH    DC        10S(*)              ASMGMACP PATCH AREA
         SPACE     2
FUPLIST  EQU       X'80'               *PARBYT1  FULLUPLIST
DOS      EQU       X'40'               *         DOS
ESD      EQU       X'20'               *         ESD
BATCH    EQU       X'10'               *         BATCH
FLIST    EQU       X'08'               *         FULLLIST
EXTEN    EQU       X'04'               *         EXTEN
FXREF    EQU       X'02'               *         FULLXREF
ALGN     EQU       X'01'               *         ALGN
         SPACE
DECK     EQU       X'80'               *PARBYT   DECK
LOAD     EQU       X'40'               *         LOAD
RENT     EQU       X'20'               *         RENT
LIST     EQU       X'10'               *         LIST
RLD      EQU       X'08'               *         RLD
UPLIST   EQU       X'04'               *         UPLIST
XREF     EQU       X'02'               *         XREF
TEST     EQU       X'01'               *         TEST
         SPACE
LREF     EQU       X'80'               *PARBYT2  LREF
UPDATE   EQU       X'40'               *         UPDATE
EXECUTE  EQU       X'20'               *         EXECUTE
SPACE    EQU       X'10'               *         SPACE=MAX
TERM     EQU       X'08'               *         TERM
NUM      EQU       X'04'               *         NUM
STMT     EQU       X'02'               *         STMT
*RSVD    EQU       X'01'               *         RESERVED
         SPACE
UMAP     EQU       X'80'               *PARBYT3  UMAP
CMS      EQU       X'40'               *         CMS
*RSVD    EQU       X'20'               *         RESERVED
*RSVD    EQU       X'10'               *         RESERVED
*RSVD    EQU       X'08'               *         RESERVED
*RSVD    EQU       X'04'               *         RESERVED
*RSVD    EQU       X'02'               *         RESERVED
UNUSED   EQU       X'01'               *         UNUSED
         SPACE
*                                                                     *
POSTSW   DC        X'00'               TYPE OF POST PROCESSING
ASM      EQU       X'80'               360 ASSEMBLER CODE
PDP      EQU       X'40'               PDP ASSEMBLER CODE
CC70     EQU       X'20'               CC70 ASSEMBLER CODE
FORT     EQU       X'10'               FORTRAN CODE
*                                                                     *
COMCHAR  DC        C' '                COMMENT CHARACTER
*                                                                     *
FR0      EQU       0                   FLOATING REGISTER ZERO
R0       EQU       0
R1       EQU       1
R2       EQU       2
R3       EQU       3                   POINTS TO FDIMEN COMMUNICATIONS
R4       EQU       4
R5       EQU       5
R6       EQU       6
R7       EQU       7
R8       EQU       8                   UNUSED
R9       EQU       9                   LIST1 COMMON AREA IN ASMGASM
R10      EQU       10
R11      EQU       11                  UNUSED
R12      EQU       12                  BASE REGISTER
R13      EQU       13                  SAVE AREA POINTER
R14      EQU       14                  LINK REGISTER
R15      EQU       15                  LINK REGISTER
*                                                                     *
PRSAVE   DC        16F'0'              SAVE AREA FOR SYSTEM LIST
         SPACE     2
YLCNT    DC        F'0'                LINE COUNTER
ERCTR    DC        F'0'                NUMBER OF ERRORS
MLSW     DC        X'00'               FF= ERROR 58 OR 46, 00= NOT
LASTTYPE DC        X'00'               SAVE FORMER RECORD TYPE
MACROSW  DC        X'00'               MACRO/MEND SWITCH
INMAC    EQU       X'80'                    IN A PROGRAMMER MACRO
NOPUNCH  EQU       X'40'                    NO PUNCH THIS STMT
POSTER78 EQU       X'20'                    AFTER ASMG078 MESSAGE
MACCALL  EQU       X'10'                    CONTINUED MACRO CALL
MACPROT  EQU       X'08'                    MACRO PROTOTYPE EXPECTED
NOPRINT  EQU       X'04'                    DON'T PRINT THIS STATEMENT
*                                                                     *
BLANK    EQU       X'40'               A BLANK CHARACTER
ZERX     EQU       X'F0'               A ZERO CHARACTER
NOPERR   EQU       X'80'               BIT TO NO-OP AN ERROR
         EJECT
*                                                                     *
*        WORK AND DATA AREA                                           *
*                                                                     *
SNAPWORK DC        D'0'                WORK AREA
ENDWORD  DC        F'0'                WORK AREA FOR FULLWORD
SNAPSAVE DC        16F'0'              SAVE AREA FOR SNAPDATA
SNAPCARR DC        X'00'               CARRIAGE CONTROL FOR SNAP
SNAPAREA DC        CL132' '            FORMAT DATA HERE
SNAPHEX  EQU       *-240               START OF TRANSLATE DOESN'T HURT
SNAPTRAN DC        X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC        X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'
         DC        X'E6E7E8E95B7B7C4E605C616B7E504B4D'
         DC        X'5D7D404B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC        192XL1'4B'
*                                                                     *
LSTMTN   DC        F'0'                LAST STATEMENT WITH ERROR
PTRMSG   DC        C'NEAR OPERAND COLUMN 000--'
PRGTYP   DC        C'ASMG200   '
*                                                                     *
SVCODE   DC        X'00'               SEVERITY CODE FOR L1SYNERR'S
MASK     DC        4X'F0'              MASK TO SET BLANKS ZERO
LASTREC  DC        CL80' '             LAST RECORD PRINTED
BUFR     DS        0CL133              DETAIL OUTPUT BUFFER
         DC        X'01'               NUMERIC CARRIAGE CONTROL
         DC        132C' '
BUFF     EQU       BUFR
BCMNT    EQU       BUFR+8              FOR (F7) COMMENTS
BSTMNO   EQU       BUFR+35             FOR (F7) STATEMENT COUNT
BGENNED  EQU       BUFR+40             FOR (F7) GENERATED STATEMENTS
BOUTPUT  EQU       BUFR+41             FOR (F7) OUTPUT RECORDS
BLINENO  EQU       BUFR+112            FOR (F7) LINE NUMBERS
ERBUFR   DS        0CL133              PRINT BUFFER FOR DIAGNOSTICS
         DC        X'00'               CARRIAGE CONTROL
         DC        CL132' '            PRINT AREA
ERNO     EQU       ERBUFR+26           ERROR NUMBER
MSGBG    EQU       ERBUFR+33           BEGINNING OF ERROR MESSAGE
ERCD     EQU       ERBUFR+22           ERROR CODE
*                                                                     *
NAME     DC        D'0'                FOR OPCODE NAMES
TRNAME   DC        D'0'                TRANSLATED MACRO NAME
NAMELEN  DC        F'0'                LENGTH-1 OF OPCODE NAME ENTRY
MACTBLM  DC        A(&MAXMAC*8)        SIZE OF MACRO NAME TABLE
MACTBLO  DC        F'0'                CURRENT MACTBL OFFSET
MACTBLA  DC        A(0)                MACTBL ADDRESS
PROCPTR  DC        F'0'                START EDITED TEXT STRING
*                                                                     *
*                                                                     *
HEAD1    DS        0CL133              HEADER LINE ONE
         DC        X'FF'               SKIP TO NEW PAGE
HDECKID  DC        CL4' '              DECK I. D.
         DC        CL40' '
         DC        CL67'ASSEMBLER (G7) MACRO POST PROCESSOR'
         DC        CL4'PAGE'
         DC        C' '
HPAGENO  DC        CL4' '              PAGE NUMBER
         DC        CL12' '
*                                                                     *
HEAD2    DS        0CL133              HEADER LINE TWO
         DC        X'02'               LEAVE TWO LINES BEFORE
         DC        CL35'       COMMENT'
         DC        CL76'STMT   SOURCE STATEMENT'
HDATE    DC        CL9' '
         DC        CL12' '
*                                                                     *
BSUMMARY DC        CL14'BATCH  SUMMARY'
DCBEODAD EQU       32                  EODAD EXIT ADDRESS
DCBGET   EQU       48                  DCB GET ADDRESS
ERM      EQU       4                   POSITION OF ERROR CODE
ERCT     EQU       3                   POSITION OF ERROR COUNT
ERCOL    EQU       5                   POSITION OF COLUMN IN ERROR
SVMES    DC        X'00',C'  000 WAS HIGHEST SEVERITY CODE'
         DC        10C' '
MSUNPROC DC        C'ASMG202   UNPROCESSED ******** AND/OR ******** REC*
               ORDS EXIST.'
TMSG     DC        C'ASSEMBLER (G7) DONE'
MVMSG    MVC       0(*-*,R7),2(R4)     EXECUTED MOVE MESSAGE TO BUFFER
         CNOP      2,4                 FOR PREFACE OF WORD
         DC        H'0'                PRELUDE TO WORD
WORD     DC        F'0'                DECIMAL RESULTS OF CVTBTC
DWORD    DC        D'0'                WORK AREA FOR CVTBTC
LENWORD  DC        F'0'                WORK FOR DEBLOCKING
UT2REML  DC        F'0'                REMAINDER IN CURRENT BLOCK
STMTCTR  DC        F'0'                STATEMENT COUNTER
         DC        X'03'               BEGIN MESSAGE ERCTM
ERCTM    DC        C' '                ERROR COUNT
         DC        C'     STATEMENTS FLAGGED IN THIS ASSEMBLY'
NOERM    EQU       ERCTM+2             NO ERROR MESSAGES POINTER
CAC      DC        X'03D5D6'           NUMERIC TRIPLE SPACE 'NO'
RECMESS  DC        C'SOURCE RECORDS'
EOF      DC        4X'7F'              EOF INDICATOR
         TITLE     'ASMGMACP LITERALS'
*                                                                     *
         LTORG
         DS        CL1
         TITLE     'ASMGMACP DIAGNOSTIC TABLES AND MESSAGES'
         DS        0H
         DC        AL2(E0017-ESTART)   FOR A ZERO
PTRTBL   EQU       *                   POINTER TABLE
         PRINT     NOGEN
         EPTR      117,ERROR=(36,53,54,113,114,117)  ERROR POINTERS
ENDTBL   DC        AL2(EFM-ESTART)     MESSAGE NOT DEFINED POINTER
         EJECT
ESTART   DS        0H
         EMSG      001,12,'DUPLICATION FACTOR ERROR'
         EMSG      002,12,'RELOCATABLE DUPLICATION FACTOR'
         EMSG      003,12,'LENGTH ERROR'
         EMSG      004,12,'RELOCATABLE LENGTH'
         EMSG      005,08,'S-TYPE CONSTANT IN LITERAL'
         EMSG      006,12,'INVALID ORIGIN'
         EMSG      007,12,'LOCATION COUNTER ERROR'
         EMSG      008,08,'INVALID DISPLACEMENT'
         EMSG      009,12,'MISSING OPERAND'
         EMSG      010,08,'INCORRECT SPECIFICATION OF REGISTER OR MASK'
         EMSG      011,08,'SCALE MODIFIER ERROR'
         EMSG      012,08,'RELOCATABLE SCALE MODIFIER'
         EMSG      013,08,'EXPONENT MODIFIER ERROR'
         EMSG      014,08,'RELOCATABLE EXPONENT MODIFIER'
         EMSG      015,08,'INVALID LITERAL USAGE'
         EMSG      016,08,'INVALID NAME'
         EMSG      017,08,'DATA ITEM TOO LARGE'
         EMSG      018,08,'INVALID SYMBOL'
         EMSG      019,08,'EXTERNAL SYMBOL ERROR'
         EMSG      020,08,'INVALID IMMEDIATE FIELD'
         EMSG      021,08,'SYMBOL NOT PREVIOUSLY DEFINED'
         EMSG      022,12,'ESD TABLE OVERFLOW'
         EMSG      023,08,'PREVIOUSLY DEFINED NAME'
         EMSG      024,08,'UNDEFINED SYMBOL'
         EMSG      025,08,'RELOCATABILITY ERROR'
         EMSG      026,12,'TOO MANY LEVELS OF PARENTHESES'
         EMSG      027,12,'TOO MANY TERMS'
         EMSG      028,04,'REGISTER NOT USED'
         EMSG      029,08,'CCW ERROR'
         EMSG      030,12,'INVALID CNOP'
         EMSG      031,08,'UNKNOWN TYPE'
         EMSG      032,08,'OP-CODE NOT ALLOWED TO BE GENERATED'
         EMSG      033,04,'ALIGNMENT ERROR'
         EMSG      034,08,'INVALID OP-CODE'
         EMSG      035,08,'ADDRESSABILITY ERROR'
         EMSG      036,16,'ASSEMBLER ERROR'
         EMSG      037,00,'MNOTE STATEMENT'
         EMSG      038,08,'ENTRY ERROR'
         EMSG      039,12,'INVALID DELIMITER'
         EMSG      040,12,'STATEMENT IS TOO LONG'
         EMSG      041,08,'UNDECLARED VARIABLE SYMBOL'
         EMSG      042,08,'SINGLE TERM LOGICAL EXPRESSION IS NOT A SETB*
                SYMBOL'
         EMSG      043,08,'SET SYMBOL PREVIOUSLY DEFINED'
         EMSG   044,08,'SET SYMBOL USAGE INCONSISTENT WITH DECLARATION'
         EMSG      045,08,'ILLEGAL SYMBOLIC PARAMETER'
         EMSG      046,04,'AT LEAST ONE RELOCATABLE Y-TYPE CONSTANT IN *
               ASSEMBLY'
         EMSG      047,12,'SEQUENCE SYMBOL PREVIOUSLY DEFINED'
         EMSG      048,12,'SYMBOLIC PARAMETER PREVIOUSLY DEFINED OR SYS*
               TEM VARIABLE SYMBOL DECLARED AS SYMBOLIC PARAMETER'
         EMSG      049,12,'VARIABLE SYMBOL MATCHES A PARAMETER'
         EMSG      050,08,'INCONSISTENT GLOBAL DECLARATIONS'
         EMSG      051,12,'MACRO DEFINITION PREVIOUSLY DEFINED'
         EMSG      052,08,'NAME FIELD CONTAINS ILLEGAL SET SYMBOL'
         EMSG      053,16,'ASSEMBLER ERROR'
         EMSG      054,16,'ASSEMBLER ERROR'
         EMSG      055,08,'INVALID EXECUTE CARD PARAMETER(S)'
         EMSG      056,08,'ARITHMETIC OVERFLOW'
         EMSG      057,08,'SUBSCRIPT NOT WITHIN DIMENSIONS'
         EMSG      058,04,'RE-ENTRANCY VIOLATION'
         EMSG      059,12,'UNDEFINED SEQUENCE SYMBOL'
         EMSG      060,08,'ILLEGAL ATTRIBUTE NOTATION'
         EMSG      061,12,'ACTR COUNTER EXCEEDED'
         EMSG     062,08,'GENERATED STRING GREATER THAN 255 CHARACTERS'
         EMSG      063,08,'EXPRESSION 1 OF SUBSTRING IS ZERO OR MINUS'
         EMSG      064,08,'EXPRESSION 2 OF SUBSTRING IS ZERO OR MINUS'
         EMSG 065,08,'INVALID OR ILLEGAL TERM IN ARITHMETIC EXPRESSION'
         EMSG      066,12,'UNDEFINED OR DUPLICATE KEYWORD OPERAND'
         EMSG      067,08,'EXPRESSION 1 OF SUBSTRING GREATER THAN LENGT*
               H OF CHARACTER EXPRESSION'
         EMSG      068,08,'ILLEGAL LENGTH SPECIFICATION IN GBL OR LCL S*
               TATEMENT'
         EMSG     069,08,'VALUE OF EXPRESSION 2 OF SUBSTRING TOO LARGE'
         EMSG      070,12,'FLOATING POINT CHARACTERISTIC OUT OF RANGE'
         EMSG      071,08,'ILLEGAL OCCURRENCE OF LCL, GBL, OR ACTR STAT*
               EMENT'
         EMSG      072,04,'ILLEGAL RANGE ON ISEQ STATEMENT'
         EMSG      073,08,'ILLEGAL NAME FIELD'
         EMSG   074,08,'ILLEGAL STATEMENT IN COPY CODE OR SYSTEM MACRO'
         EMSG  075,08,'ILLEGAL STATEMENT OUTSIDE OF A MACRO DEFINITION'
         EMSG      076,12,'SEQUENCE ERROR'
         EMSG      077,08,'ILLEGAL CONTINUATION CARD'
         EMSG      078,00,'FOLLOWING ERRORS OCCURED WHILE EDITING LIBRA*
               RY MACROS'
         EMSG      079,08,'ILLEGAL STATEMENT IN MACRO DEFINITION'
         EMSG      080,08,'ILLEGAL START CARD'
         EMSG      081,08,'ILLEGAL FORMAT IN GBL OR LCL STATEMENTS'
         EMSG      082,08,'ILLEGAL DIMENSION SPECIFICATION IN GBL OR LC*
               L STATEMENT'
         EMSG   083,08,'SET STATEMENT NAME FIELD NOT A VARIABLE SYMBOL'
         EMSG      084,08,'ILLEGAL OPERAND FIELD FORMAT'
         EMSG      085,08,'INVALID SYNTAX IN EXPRESSION'
         EMSG      086,08,'ILLEGAL USAGE OF SYSTEM VARIABLE SYMBOL'
         EMSG      087,08,'NO ENDING APOSTROPHE'
         EMSG      088,12,'UNDEFINED OPERATION CODE'
         EMSG      089,08,'INVALID ATTRIBUTE NOTATION'
         EMSG      090,08,'INVALID SUBSCRIPT'
         EMSG      091,08,'INVALID SELF-DEFINING TERM'
         EMSG      092,08,'INVALID FORMAT FOR VARIABLE SYMBOL'
         EMSG      093,08,'UNBALANCED PARENTHESES OR EXCESSIVE LEFT PAR*
               ENTHESES'
         EMSG      094,12,'INVALID OR ILLEGAL NAME OR OPERATION IN PROT*
               OTYPE STATEMENT'
         EMSG      095,08,'ENTRY TABLE OVERFLOW'
         EMSG      096,12,'MACRO INSTRUCTION OR PROTOTYPE OPERAND EXCEE*
               DS 255 CHARACTERS IN LENGTH'
         EMSG      097,12,'INVALID FORMAT IN MACRO INSTRUCTION OPERAND *
               OR PROTOTYPE PARAMETER'
         EMSG      098,12,'EXCESSIVE NUMBER OF OPERANDS OR PARAMETERS'
         EMSG      099,12,'POSITIONAL MACRO INSTRUCTION OPERAND, PROTOT*
               YPE PARAMETER OR EXTRA COMMA FOLLOWS KEYWORD'
         EMSG      100,08,'STATEMENT COMPLEXITY EXCEEDED'
         EMSG      101,12,'EOD ON SYSIN'
         EMSG      102,16,'INVALID OR ILLEGAL ICTL'
         EMSG      103,12,'ILLEGAL NAME IN OPERAND FIELD OF COPY CARD'
         EMSG      104,12,'COPY CODE NOT FOUND'
         EMSG      105,12,'EOD ON SYSTEM MACRO LIBRARY'
         EMSG      106,08,'NOT NAME OF DSECT OR DXD'
         EMSG      107,08,'INVALID OPERAND'
         EMSG      108,08,'INVALID EQU ARGUMENT'
         EMSG      109,08,'PRECISION LOST'
         EMSG      110,08,'EXPRESSION VALUE TOO LARGE'
         EMSG      111,08,'INVALID PRINT, PUSH OR POP OPERAND'
         EMSG      112,08,'INVALID PUSH/POP REQUEST'
         EMSG      113,16,'ASSEMBLER ERROR'
         EMSG      114,16,'ASSEMBLER ERROR'
         EMSG      115,*-*,'UPDATE CONDITION CODE EXCEEDED'
         EMSG      116,08,'ILLEGAL OPSYN'
         EMSG      117,16,'ASSEMBLER ERROR'
EFM      DC        AL1(19,04),C'MESSAGE NOT DEFINED'
         PRINT     ON
ENDM     DC        AL1(0)
         SPACE     3
         END       ASMGMACP
./ ADD NAME=ASMGRTA
RTA      TITLE     'ASMG     ASSEMBLY PHASES ROOT SEGMENT'
         ISEQ  73,78
         COPY      ASMGSET
ASMGRTA  START
*                                                                     *
*TITLE- 'ASMGRTA ' ... ROOT SEGMENT ASSEMBLER PHASE                   *
*FUNCTION/OPERATION-                                                  *
*   SETS UP PARTS OF THE ASSEMBLER CONTROL TABLE AND SETS UP THE      *
*   REGISTER ACT FOR ALL OF PHASE F7, F8, AND FPP. CONTAINS THE       *
*   ASSEMBLER CONTROL TABLE AND THE TRANSLATE TABLE.
*ENTRY POINTS-                                                        *
*  ASMGRTA ... ROOT SEGMENT FOR PHASES F7, F8, AND FPP                *
*        CALLING SEQUENCE FROM ASMGF3                                 *
*          XCTL   ,DE=(R9)     I.E. EP=ASMGRTA   CALL ASSEMBLER PHASES*
*EXTERNAL ROUTINES-                                                   *
*  ASMGRTA LINKS TO ASSEMBLER PHASES. CONTROL IN RTA IS AS SHOWN...   *
*       ASMGRTA LINKS  TO ASMGF7                                      *
*       ASMGF7  BRANCH TO ASMGFI                                      *
*       ASMGFI  XCTL   TO ASMGF8                                      *
*       ASMGF8  XCTL   TO ASMGFPP                                     *
*       ASMGFPP BRANCH TO ASMGFD                                      *
*       ASMGFD  BRANCH TO ASMGFEX IF EXECUTION OPTION                 *
*       ASMGFEX RETURN TO ASMGFD                                      *
*       ASMGFD  RETURN TO ASMGRTA                                     *
*       ASMGRTA RETURN TO ASMGASM                                     *
*EXITS- NORMAL                                                        *
*   RETURNS TO ASMGASM                                                *
*TABLES/WORKAREAS-                                                    *
*   ACT        ASSEMBLER CONTROL TABLE                                *
*   TRSLTB     TRANSLATE AND TEST TABLE                               *
*   ACT1       STORAGE FOR FUNCTION LINKAGE ALGORITHIMS               *
*   ACT2                   FUNCTION BASE/ENTRY ADDRESSES              *
*   ACT3                   SUBROUTINE BASE/ENTRY ADDRESSES            *
*   ACT4                   POINTERS TO COMMON DATA AREAS              *
*   ACT5                   CENTRAL TABLES AND ITEMS                   *
*   ACT6                   TEXT RECORD WORK AREA                      *
*                                                                     *
         EJECT
         FDIMEN
         SPACE 2
*
*        REGISTER PARAMETERS PASSED FROM ASMGF3
*
*   REGISTER 2 CONTAINS TEXT BLOCKSIZE ON UTILITY
*   REGISTER 3 POINTS TO LIST1 AREA IN ASMGASM
*   REGISTER 13 POINTS TO SAVE AREA IN ASMGASM
*   REGISTER 14 CONTAINS ADDRESS OF RETURN TO ASMGASM
*
BASE2    EQU   7                       TEMPORARY WORK BASE REGISTER
         EJECT
         BALR  BASE2,0                  SET UP BASE
         USING *,BASE2
         ST        13,LIKSAV           SAVE ADDRESS OF SAVE AREA IN ASM
*./      DELETE    SEQ1=01080020,SEQ2=01080020
         ST        14,RETSAV            SAVE RETURN ADDRESS
         MESSAGE   'PHASE RTA ENTERED'
         LA    BASE2,ACTABL             LOAD UP ACT
         USING ACTABL,BASE2             USE IT AS BASE
CTINIT0  BAL   SP1,CTINIT               CALL CTIN INITIALIZATION
         USING *,SP1                    BASE SET BY ABOVE BAL
*
*        NOW LINK TO ASMGF7, SRR ALREADY SET BY CTINIT
         LINK  DE=(SRR),MF=(E,(1))      CALL ASMGF7 IN ASMGF7I
         DROP  SP1
         SPACE 2
         BALR      BASE2,0             CAME FROM FD IN ASMGFPP
         USING     *,BASE2             SET UP A BASE
         L         13,LIKSAV           LOAD SAVE AREA ADDRESS
         L         14,RETSAV           AND THE RETURN ADDRESS
         LTR       SP1,SP1             IS R10 ZERO .Q
         BNZ       F2XCTL              NO, THEN INVOKE F2 AGAIN
         BR        14                  RETURN TO ASMGASM
*
*                                      R9 IS ADDRESS OF LIST1 IN ASM
*                                      R2 POINTS TO F2 IN BLDL TABLE
F2XCTL   XCTL      DE=(GR2),MF=(E,(1)) GO TO F1 IN ASMGF2
         SPACE     3
RETSAV   DC        F'0'                ADDRESS OF RETURN POINT IN ASM
LIKSAV   DC        F'0'                ADDRESS OF SAVE AREA IN ASM
         SPACE 2
         DROP  BASE2
         EJECT
*                                       *******************************
*                                       * TRANSLATE AND TEST TABLE    *
*                                       *******************************
TRSLTB   DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'                01-16
         DC    X'C7C8C9D1D2D3D4D5D6D7D8D9E2E3E4E5'                02-16
         DC    X'E6E7E8E95B7B7C4E605C616B7E504B4D'                03-16
         DC    X'5D7D40333435363738393A3B3C3D3E3F'                04-16
         DC    X'324142434445464748494A2E4C2F274F'                05-16
         DC    X'2D5152535455565758595A2429305E5F'                06-16
         DC    X'282A62636465666768696A2B6C6D6E6F'                07-16
         DC    X'707172737475767778797A2526312C7F'                08-16
         DC    X'808182838485868788898A8B8C8D8E8F'                09-16
         DC    X'909192939495969798999A9B9C9D9E9F'                10-16
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'                11-16
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'                12-16
         DC    X'C00A0B0C0D0E0F101112CACBCCCDCECF'                13-16
         DC    X'D0131415161718191A1BDADBDCDDDEDF'                14-16
         DC    X'E0E11C1D1E1F20212223EAEBECEDEEEF'                15-16
         DC    X'00010203040506070809FAFBFCFDFEFF'                16-16
         EJECT
ACTABL   DS    0F                       BEGINNING OF ASSEMBLER CONTROL
*                                       TABLE
******** CT1 - MLC/FUNCTIONAL ROUTINE LINKAGE ALGORITHIMS *************
*
         USING ACTABL,ACT               SET UP BASE
         ORG   ACTABL                   PUT IN CORRECT SPOT
ACT1     DS    (CT1C)C
*
         ORG   ACT1+0                   CTLNK1
         STM   GRA,GRD,SAVER            SAVE
         BR    FRB                      GO TO FUNCTION
*
         ORG   ACT1+CTLNK2              CTLNK2
         STM   GRA,GRD,SAVER            SAVE
         L     FRB,CBRNDA(ACT)          GET THE BASE
         BR    GRX                      GO TO THE FUNCTION
*
         ORG   ACT1+CTRTRN              CTRTRN
         LM    GRA,GRD,SAVER            RESTORE THE SAVED REGISTERS
         BR    CRR                      RETURN
*
         ORG   ACT1+CTSAVE              CTSAVE
SAVER    DS    4F                       SAVE AREA FOR MLC/FUNCTION
         DROP  ACT
*
*
******** CT2 - FUNCTIONAL ROUTINES BASE/ENTRY ADDRESSES ***************
*
         ORG   ACT1+CT2
ACT2     DS    (CT2C)A                  SET ASIDE AREA FOR FUNCTION ADD
*
*
******** CT3 - COMMON SUBROUTINES BASE/ENTRY ADDRESS
*
         ORG   ACT1+CT3
ACT3     DS    (CT3C)A                  SET ASIDE AREA FOR SUBROUTINES
*
*
******** CT4 - POINTERS TO COMMON DATA AREAS **************************
*
         ORG   ACT1+CT4
ACT4     DS    (CT4C)A                  SET ASIDE AREA FOR COMMON DATA
*
*
******** CT5 - CENTRAL TABLES AND ITEMS *******************************
*
         ORG   ACT1+CT5
ACT5     DC    (CT5C)X'0'               SET ASIDE AREA FOR TABLES
*
*
******** CT6 - TEXT RECORD WORK AREA **********************************
*
         ORG   ACT1+CT6
ACT6     DS    (CT6C)C                  SET ASIDE AREA FOR WORK AREA
         EJECT
******** CT2 INITIAL CONDITIONS ***************************************
*
         SPACE 5
******** CT3 INITIAL CONDITIONS ***************************************
*
         SPACE 5
******** CT4 INITIAL CONDITIONS ***************************************
*
         ORG   ACT1+CTRTBP             PUT IN ADDRESS OF TRT TABLE
         DC    A(TRSLTB)
         ORG       ACT1+CTLBTP
         DC        F'0'
         SPACE 5
******** CT5 INITIAL CONDITIONS ***************************************
*
         ORG   ACTABL+CTWORK            OVERLAY SCRATCH PAD AREA
         USING ACTABL,BASE2
******** CTINIT - F/7I8PP INITIALIZATION ROUTINE (ONCE ONLY CODE) *****
*
*
*
* SAVE ENTRANCE PARAMETERS (SET BY F3) IN F7,F8,FPP CONTROL TABLE
*
CTINIT   DS    0H
         LR    SRR,ACT                 TRANSFER ADDRESS OF LIST1 IN ASM
         LR    ACT,BASE2               TRANSFER ADDRESS OF COMMON TABLE
         ST    SRR,ADLIST1(,ACT)       SAVE ADDRESS OF LIST1 IN ASM
         STH   GR2,CTXLEN(,ACT)        SAVE TEXT BLOCK LENGTH
*
         MVC   CTFUPLI(4,ACT),L1PBYT1(SRR)  MOVE PARM BITS TO TABLE
         MVC   CTPGLNCT(1,ACT),L1LINECT+1(SRR)  LINES PER PAGE
         MVC   LSTDCB(8,ACT),L1DCBADS+L1SPRINT(SRR)  SYSPRINT
*                                             AND SYSPUNCH DCB ADDRS
         MVC   GODCB(4,ACT),L1DCBADS+L1SLIN(SRR)  SYSLIN DCB ADDRESS
         MVC   CTDATE(9,ACT),L1PRDATE(SRR)  GET DATE FROM ASM
         MVC   BUFFPT(4,ACT),L1BUFADR(SRR)  ADDRESS OF BUFF
*
         LA    GR2,ACT6                GET TEXT RECORD WORK AREA
         ST    GR2,CTXWAP(,ACT)        PUT IN TEXT WORK AREA POINTER
         ST    GR2,CTLDCP(,ACT)        AND LITERAL DC WORK AREA POINTER
         LA    SRR,L1BLDL+4*L1LENBL(,SRR)  ASMGF7 IN BLDL TABLE
*
         DROP  BASE2
         BR    SP1                     RETURN TO CALLER
         SPACE 5
         ORG   ACT1+CHAINPT             CONTINUE INITIALIZATION IN CT5
         DC        A(ACT1+STCHAIN)     LAST ST ENTRY ON CHAIN
         ORG   ACT1+CTNDID
         DC    H'255'                   NEXT DSECT ID
         ORG   ACT1+CTITLE
         DC    CL8' '                   FIRST TITLE LABEL
         ORG       ACT1+CFREEP
         DC       A(ESDSEG+FASH)
         ORG       ACT1+CSGCTR
         DC        H'16'
         ORG       ACT1+CPRIME
         DC        A(PRIME)
PRIME    EQU       307
LASH     EQU       31                  LITERAL HASH (28) + OPSYN PTR
HASH     EQU       3*PRIME+LASH        SIZE OF HASH TABLE
FASH     EQU       HASH/8*8+8          HASH ROUNDED TO D LENGTH
ESDSEG   EQU       256                 ESD RESIDENT SEGMENT POINTR LGTH
         ORG       ASMGRTA+X'800'      ROUND UP TO TWO K
         END       ASMGRTA
./ ADD NAME=ASMGUP
UP       TITLE     'ASMGUP  --  UPDATE INPUT INTERFACE'
         ISEQ      73,78
*
*        THIS DECK PERFORMS THE UPDATE INPUT FUNCTIONS FOR ASMG.
*        IT IS ONLY LOADED AND USED IF PARM=UPDATE IS SPECIFIED.
*
*        EACH TIME THE ASSEMBLER (OR THE USER'S PROGRAM IF EXECUTE)
*        ATTEMPTS TO READ A CARD ON SYSIN, THEN THIS ROUTINE IS
*        INVOKED INSTEAD.
*
*        THIS ROUTINE WILL READ RECORDS FROM SYSIN AND/OR SYSUP
*        TO DETERMINE WHICH RECORD SHOULD BE PASSED TO THE ASSEMBLER
*        NEXT.
*
*        AFTER MOVING THE RECORD TO THE BUFFER SPECIFIED BY THE USER,
*        THE REGISTERS ARE SAVED SUCH THAT THE NEXT TIME THE ROUTINE
*        IS CALLED, IT WILL REMEMBER WHERE IT WAS AND WHAT IT WAS
*        DOING.
*
*        USAGE OF FILES --
*
*    SYSIN   - THIS CONTAINS THE OLD MASTER DATA SET.
*    SYSUP   - THIS CONTAINS THE UPDATE DECK.
*    SYSOUT  - THIS WILL CONTAIN THE NEW MASTER DATA SET.  IT IS
*              AN IMAGINARY FILE, BEING IN FACT THE ASSEMBLER.
*    SYSPRINT- IF OPEN, THIS WILL CONTAIN THE UPDATE LOG IF
*              REQUESTED, PLUS ANY UPDATE DIAGNOSTICS.
*    SYSTERM - IF OPEN, THIS WILL CONTAIN ANY UPDATE DIAGNOSTICS.
*
*    NOTE    - AT LEAST ONE OF SYSPRINT OR SYSTERM MUST BE OPEN.
*
         COPY      ASMGSET
*        END OF SETTING GLOBAL SWITCHES
         AIF       (NOT &HRDCOPY).NOJDESC
*
*        A HARD COPY OF THE MERGED SYSOUT FILE MAY BE OBTAINED
*        BY TURNING ON THE &HRDCOPY VARIABLE AND REASSEMBLING
*        ASMGUP.
*
*        THIS IS DONE BY POINTING THE SYSPUNCH DD CARD TO THE
*        DESIRED OUTPUT FILE AND SPECIFYING 'UNUSED' IN THE
*        PARAMETER LIST.  NOTE THAT THIS UNDOCUMENTED FEATURE
*        IS INCOMPATIBLE WITH THE 'DECK' OPTION AND THAT SYSPUNCH
*        MUST OPEN SUCCESSFULLY.  A DIAGNOSTIC MESSAGE IS LISTED
*        IF EITHER CONDITION FAILS.
*
.NOJDESC ANOP
         EJECT
*
*        THIS IS THE ENTRY POINT FOR ASMGUP.
*        IS SIMPLY RESTORES THE REGISTERS AS SAVED BY THE WROUT
*        ROUTINE, AND THEN SIMULATES A RETURN FROM WROUT TO
*        WHOEVER CALLED IT.
*
ASMGUP   START
         USING     *,RF                WE HAVE TO START WITH SOMETHING
         STM       R0,RF,UPSAV1        SAVE USER'S REGISTERS
         LM        R0,RF,UPSAV2        RESTORE MY REGISTERS
         BR        RE                  RETURN TO WROUT'S CALLER
         DROP      RF                  FORGET R15 NOW
         USING     ASMGUP,RC           NOW WE USE R12
         USING     ASMGIND,R6          R6 FOR SYSIN RECORDS
         USING     ASMGUPD,R7          AND R7 FOR SYSUP RECORDS
         SPACE     4
*
*        THIS ROUTINE IS ENTERED THE FIRST TIME THE ASSEMBLER
*        ATTEMPTS TO READ A RECORD.
*        IT DOES THE NECESSARY INITIALIZATION.
*
*        INPUT   R9   ADDRESS OF LIST1 IN ASMGASM (1ST TIME ONLY).
*                R8   ADDRESS OF EXLST IN ASMGF1  (1ST TIME ONLY).
*                          NOT NORMALLY USED
*                R0   ADDRESS OF BUFFER TO READ RECORD INTO.
*
UPINIT   L         R9,UPSAV1+36        GET ADDRESS OF LIST1
         L         R1,L1DCBADS+L1SUP(,R9)  ADDRESS OF SYSUP DCB
         MVC       DCBEODAD+1(3,R1),=AL3(RDUPEOF)  SET SYSUP EODAD
         MVC       PRDATE(9),L1PRDATE(R9)  MOVE DATE TO HEADER LINE
         AIF       (NOT &HRDCOPY).NOJINIT
         TM    L1PBYT3(R9),X'01'       IS UNUSED BIT ON .Q
         BZ    ARNDJACQ                NO, BRANCH AROUND
*
*        TEST IF SYSPUNCH ALREADY OPEN
         L     R4,L1DCBADS+L1SPUNCH(,R9)  ADDRESS OF SYSPUNCH DCB
         TM    DCBOFLGS(R4),X'10'      TEST IF SYSPUNCH OPEN
         BZ    OPENJACQ                NO, WELL OPEN IT NOW
*
*        SYSPUNCH ALREADY OPEN
         MVC   $LIT0345+3(8),L1DDNAM+2*L1SPUNCH(R9)  SYSPUNCH DDNAME
         LA    R3,$LIT0345             ERROR MESSAGE
         SR    R4,R4                   NO RECORD IN ERROR
         BAL   RE,ERROR                GO PRINT OUT ERROR
         B     ARNDJACQ                AND CONTINUE PROCESSING
         UPEMSG 345,12,'SYSPUNCH OPEN FOR ''DECK'''
*
*        OPEN SYSPUNCH FOR OUTPUT OF MERGED DECK
OPENJACQ DS    0H
         STM   R0,RF,UPSAV2            SAVE MY REGISTERS
         LR    R2,RC                   REMEMBER MY BASE
         DROP  RC                      FORGET THE OLD
         USING ASMGUP,R2               AND USE THE NEW
         LM    R5,RF,UPSAV1+20         RESTORE SOME OF CALLER'S REGS
         OPEN  ((R4),(OUTPUT,REREAD))  OPEN SYSPUNCH
         LM    R0,RF,UPSAV2            RESTORE MY OLD REGISTERS
         DROP  R2                      FORGET THE TEMPORARY
         USING ASMGUP,RC               AND REVERT TO THE OLD
         TM    DCBOFLGS(R4),X'10'      TEST IF SYSPUNCH OPEN NOW
         BO    SETJACQ                 YES, GO SET SWITCH
*
*        SYSPUNCH OPEN FAILED
         MVC   $LIT0200+18(8),L1DDNAM+2*L1SPUNCH(R9)  SYSPUNCH DDNAME
         LA    R3,$LIT0200             ERROR MESSAGE
         SR    R4,R4                   NO RECORD IN ERROR
         BAL   RE,ERROR                GO PRINT OUT ERROR
         B     ARNDJACQ                AND CONTINUE PROCESSING
         UPEMSG 200,08,'UNABLE TO OPEN SYSPUNCH'
*
*        SET SYSPUNCH WRITEOUT SWITCH
SETJACQ  NI    SWITJACQ+1,X'0F'        ALTER A BRANCH INSTRUCTION
*
*        THAT'S ALL TO INITIALIZE
ARNDJACQ DS    0H                      JUST A LABEL
.NOJINIT ANOP
         B         UPIN                START BY READING SYSIN
         EJECT
*        THIS IS THE MAIN LOOP OF THE ASMGUP ROUTINE.
*        IT READS CARDS FROM SYSUP AND SYSIN WHEN NECESSARY.
*        IT IDENTIFIES THE TYPE OF CARD COMING FROM SYSUP, AND
*        ACTS ACCORDINGLY.
*
*        READ A RECORD FROM SYSIN
UPIN     BAL       RE,RDIN             READ A RECORD ON SYSIN
*
*        READ A RECORD FROM SYSUP
UPUP     BAL       RE,RDUP             READ A RECORD ON SYSUP
         CLC       UTUPREC(2),=C'./'   TEST IF A CONTROL CARD
         BE        UPCC                BRANCH IF IT IS
*
*        TEST IF UPDATE CARD HAS A SEQUENCE NUMBER
         CLC       UTUPSEQ(8),=CL8' '  TEST FOR A BLANK SEQUENCE
         BNE       UPDATA              BRANCH IF NOT BLANK
         MVC       $LIT0321+9(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME
         LA        R3,$LIT0321         ERROR MESSAGE
         LA        R4,UTUPREC          RECORD IN ERROR
         BAL       RE,ERROR            PROCESS THE ERROR
         B         UPUP                GET THE NEXT SYSUP CARD
*
*        SYSUP CARD WITH A VALID SEQUENCE NUMBER
UPDATA   LA        R1,UTUPSEQ          SEQUENCE NUMBER OF SYSUP
         BAL       RE,COPYUT           COPY SYSIN TILL SEQUENCE FOUND
         LA        RA,UTUPREC          WRITE OUT SYSUP NOW
         BAL       RE,WROUT            WRITE IT OUT
         LTR       RF,RF               TEST IF SEQUENCE ERROR
         BNZ       UPUP                GET NEXT CARD IF ERROR
         NI        ERSW,X'FF'-(ERSWER+ERSWFL)  CLEAR ERROR SWITCH
         CLC       UTINSEQ(8),UTUPSEQ  TEST IF INSERT OR REPLACE
         BE        UPREPL              BRANCH IF REPLACE
         TM        L1PBYT(R9),X'04'    DON'T LIST IF NOUPLIST
         BZ        UPUP                GET NEXT SYSUP RECORD
         LA        R3,$LIT0323         COMMENT TEXT
         LA        R4,UTUPREC          RECORD TO BE PRINTED
         BAL       RE,ERROR            GO PRINT IT OUT
         B         UPUP                GET NEXT SYSUP RECORD
*
UPREPL   TM        L1PBYT(R9),X'04'    DON'T LIST IF NOUPLIST
         BZ        UPIN                GET TWO MORE RECORDS IF OFF
         LA        R3,$LIT0324         MESSAGE TEXT
         LA        R4,UTINREC          POINT TO SYSIN RECORD
         BAL       RE,ERROR            GO PRINT IT
         LA        R3,$LIT0325         MESSAGE TEXT
         LA        R4,UTUPREC          POINT TO SYSUP RECORD
         BAL       RE,ERROR            GO AND PRINT IT
         B         UPIN                GET TWO MORE CARDS
*
*        CONTROL CARD READ ON SYSUP
UPCC     LA        R8,UTUPREC+2        POINT TO SYSUP RECORD
UPCCA    CLI       0(R8),C' '          DOES A NAME FIELD EXIST
         BE        UPCCB               NO, CHECK FOR COMMAND
         BAL       RE,UPBUMP           BUMP RECORD POINTER
         B         UPCCA               CHECK AGAIN
*
*        SEARCH FOR START OF COMMAND FIELD
UPCCB    LA        R5,UPBADCOM         ERROR IF BUMP OVERFLOWS
UPCCC    BAL       RE,UPBUMP           GO ONE PAST FIRST BLANK
         CLI       0(R8),C' '          DOES A COMMAND START EXIST .Q
         BE        UPCCC               NOT YET, KEEP GOING
         CLC       =C'DELETE ',0(R8)   A 'DELETE' CARD .Q
         BE        UPCCD               YES, GO AND PROCESS IT
         CLC       =C'ENDUP ',0(R8)    AN 'ENDUP' CARD .Q
         BE        UPEND               YES, GO AND PROCESS IT
         CLC       =C'CHANGE ',0(R8)   A 'CHANGE' CARD .Q
         BE        UPCOM               YES, NOT SUPPORTED
         CLC       =C'ADD ',0(R8)      AN 'ADD' CARD .Q
         BE        UPCOM               YES, NOT SUPPORTED
         CLC       =C'REPL ',0(R8)     A 'REPL' CARD .Q
         BE        UPCOM               YES, NOT SUPPORTED
         CLC       =C'REPRO ',0(R8)    A 'REPRO' CARD .Q
         BE        UPCOM               YES, NOT SUPPORTED
         CLC       =C'NUMBER ',0(R8)   A 'NUMBER' CARD .Q
         BE        UPCOM               YES, NOT SUPPORTED
         CLC       =C'LABEL ',0(R8)    A 'LABEL' CARD .Q
         BE        UPCOM               YES, NOT SUPPORTED
         CLC       =C'ALIAS ',0(R8)    AN 'ALIAS' CARD .Q
         BE        UPCOM               YES, NOT SUPPORTED
*
*        CONTROL CARD NOT RECOGNIZED BY ASMG OR IEBUPDTE
UPBADCOM DS        0H
         LA        R3,$LIT0337         ERROR MESSAGE
         LA        R4,UTUPREC          RECORD IN ERROR
         BAL       RE,ERROR            PRINT THE ERROR
         B         UPCONT              CHECK THIS AND GET NEXT SYSUP
*
*        CONTROL CARD NOT SUPPORTED BY ASMG
UPCOM    TM        L1PBYT(R9),X'04'    IS NOUPLIST ON .Q
         BZ        UPCONT              YES, GET NEXT SYSUP CARD
         LA        R3,$LIT0336         ERROR MESSAGE
         LA        R4,UTUPREC          RECORD IN ERROR
         BAL       RE,ERROR            GO PRINT THE ERROR
*
*        CHECK IF UNSUPPORTED CONTROL CARD WAS CONTINUED
UPCONT   CLI       UTUPREC+71,C' '     NO BLANK MEANS NO CONTINUE
         BE        UPUP                A BLANK, PROCESS NEXT SYSUP CARD
         BAL       RE,RDUP             CONTINUED, GET CONTINUING CARD
         TM        L1PBYT(R9),X'04'    IS NOUPLIST ON .Q
         BZ        UPCONT              YES, TEST THIS CARD FOR CONTIN
         LA        R3,$LIT0338         ERROR MESSAGE
         LA        R4,UTUPREC          RECORD IN ERROR
         BAL       RE,ERROR            GO PRINT THE ERROR
         B         UPCONT              TEST THIS CARD FOR CONTIN
*
*        BUMP RECORD POINTER AND CHECK FOR END OF CARD
UPBUMP   LA        R8,1(,R8)           BUMP BY ONE
         LA        R4,70(,R7)          LAST POSSIBLE ADDR FOR PARMS
         CR        R8,R4               ARE WE NOW TOO LATE .Q
         BCR       12,RE               BL+BE  NO, THEN RETURN
         BR        R5                  YES, GO TO ERROR ROUTINE
*
*        ./ ENDUP  --  CHECK THIS REALLY IS THE END OF SYSUP
UPEND    DS        0H
         MVC       $LIT0339+20(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME
         LA        R3,$LIT0339         ERROR COMMENT
         LA        R4,UTUPREC          RECORD POINTER
         BAL       RE,ERROR            PRINT IT OUT
*
UPENDEOF BAL       RE,RDUP             READ AN EXTRA SYSUP RECORD
         TM        UTSW,UTSW1EOF       DID SYSUP GET AN EOF .Q
         BO        UPDATA              YES, OK TO CONTINUE WITH SYSIN
         MVC       $LIT0340+15(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME
         LA        R3,$LIT0340         ERROR MESSAGE
         LA        R4,UTUPREC          RECORD WITH PROBLEMS
         BAL       RE,ERROR            PROCESS THE ERROR
         B         UPENDEOF            DO IT TILL SYSUP ENDS
*
*        SEARCH FOR  ./ DELETE  OPERANDS
UPCCD    LA        R5,UPDELER          ERROR IF BUMP OVERFLOWS
         LA        R8,6(,R8)           MOVE PAST 'DELETE'
UPCCE    BAL       RE,UPBUMP           GO ONE PAST FIRST BLANK
         CLI       0(R8),C' '          DOES A PARM EXIST .Q
         BE        UPCCE               NOT YET, KEEP GOING
         MVI       UPDELS1,X'FF'       1ST ARG NOT INITIALIZED
         MVI       UPDELS2,X'FF'       2ND ARG NOT INITIALIZED
         NI        ERSW,X'FF'-ERSWNUM  NUMERIC NOT REQUIRED
DELOOP   DS        0H
         CLI       0(R8),C' '          AT THE END OF THE LINE .Q
         BE        DEDONE              YES, GO TEST FOR COMPLETENESS
         CLC       =C'SEQ1=',0(R8)     1ST KEYWORD FOUND .Q
         BNE       DETRY2              BRANCH IF NOT
         LA        R1,UPDELS1          POINT TO 1ST ARG TARGET
         BAL       RE,DEPOINT          GO ENTER THE DATA
         B         DELOOP              CONTINUE
DETRY2   DS        0H
         CLC       =C'SEQ2=',0(R8)     2ND KEYWORD FOUND .Q
         BNE       UPDELER             THAT'S IT IF NOT
         LA        R1,UPDELS2          POINT TO 2ND ARG TARGET
         BAL       RE,DEPOINT          GO ENTER IT
         B         DELOOP              CONTINUE
UPDELER  DS        0H
         LA        R3,$LIT0334         ERROR MESSAGE
         LA        R4,UTUPREC          RECORD IN ERROR
         BAL       RE,ERROR            GO PRINT OUT THE ERROR
         B         UPCONT              CHECK FOR CONTIN IN SYSUP
*
*        CHECK SEQUENCES SPECIFIED
DEDONE   DS        0H
         CLI       UPDELS1,X'FF'       DID WE GET ARG 1 .Q
         BE        UPDELER             ERROR IF NOT
         CLI       UPDELS2,X'FF'       DID WE GET ARG 2 .Q
         BE        UPDELER             ERROR IF NOT
         CLC       UPDELS1(8),UPDELS2  TEST SEQ1 NOT GT SEQ2
         BNH       UPDELIT             BRANCH IF OK
         LA        R3,$LIT0335         ERROR MESSAGE
         LA        R4,UTUPREC          RECORD IN ERROR
         BAL       RE,ERROR            PRINT OUT ERROR
         B         UPCONT              CHECK FOR CONTIN IN SYSUP
*
*        SCAN OFF VARYING LENGTH ARGUMENT
DEPOINT  DS        0H
         CLI       0(R1),X'FF'         IS ARG INITIALIZED .Q
         BCR       7,R5                ERROR IF NOT
         ST        RE,UPSAV2           SAVE RETURN REGISTER
         LA        R8,5(,R8)           POINT TO 1ST CHAR OF ARG
         LR        RA,R8               REMEMBER WHERE ARG STARTS
         LA        R3,9                MAX ARG LENGTH +1
DENEXT   DS        0H
         CLI       0(R8),C','          END OF ARGUMENT .Q
         BE        DEOUT1              END OF SEARCH IF SO
         CLI       0(R8),C' '          END OF ARGUMENT .Q
         BE        DEOUT2              FINAL END OF SEARCH IF SO
         TM        ERSW,ERSWNUM        MUST IT BE NUMERIC .Q
         BZ        DENUMOK             BRANCH IF NOT
         CLI       0(R8),C'0'          LESS THAN ZERO .Q
         BCR       4,R5                BM  ERROR IF SO
         CLI       0(R8),C'9'          MORE THAN NINE .Q
         BCR       2,R5                BP  ERROR IF SO
DENUMOK  DS        0H
         BAL       RE,UPBUMP           BUMP TO NEXT CHAR
         BCT       R3,DENEXT           CONTINUE
         BR        R5                  INVALID ARG IF HERE
DEOUT1   DS        0H
         BAL       RE,UPBUMP           POINT PAST THE COMMA
DEOUT2   DS        0H
         S         R3,=F'9'            GET LENGTH OF ARGUMENT
         LPR       R3,R3               THE ABSOLUTE LENGTH
         BCR       8,R5                DON'T TAKE NULL ARGS
         MVC       0(8,R1),=C'00000000'  ZERO TARGET RESULT
         LA        R2,8(,R1)           POINT PAST TARGET
         SR        R2,R3               LESS LENGTH OF ACTUAL ARG
         BCTR      R3,0                DECREMENT LENGTH BY ONE
         EX        R3,DEMOVE           MOVE IN ARGUMENT
         L         RE,UPSAV2           RESTORE RETURN REGISTER
         BR        RE                  AND RETURN
DEMOVE   MVC       0(*-*,R2),0(RA)     EXECUTED MOVE ARGUMENT
*
*        DO THE  ./ DELETE  PROCESSING
UPDELIT  SR        R8,R8               ZERO COUNTER
         LA        R1,UPDELS1          ADDRESS OF STOPPING SEQUENCE
         BAL       RE,COPYUT           COPY SYSIN TILL SEQ1
         MVC       UPDEL01(8),UTINSEQ  SAVE SEQ OF 1ST CARD DELETED
UPDELCHK CLC       UPDELS2(8),UTINSEQ  TEST IF THIS CARD GETS DELETED
         BL        UPDELIND            BR IF THIS CARD NOT DELETED
         TM        L1PBYT(R9),X'04'    DON'T PRINT IF NOUPLIST
         BZ        UPDELDEL            DON'T PRINT IT IF BRANCH
         LA        R3,$LIT0326         MESSAGE TEST
         LA        R4,UTINREC          POINT TO SYSIN
         BAL       RE,ERROR            PRINT IT OUT
UPDELDEL MVC       UPDEL02(8),UTINSEQ  SAVE SEQ OF LAST CARD
         LA        R8,1(,R8)           BUMP CARDS DELETED COUNTER
         BAL       RE,RDIN             READ ANOTHER SYSIN CARD
         B         UPDELCHK            TEST IF THIS ONE GETS DELETED
*
*        OUTPUT THE RESULTS OF THE DELETE
UPDELIND NI        ERSW,X'FF'-(ERSWER+ERSWFL)  CLEAR ERROR SWITCHES
         LTR       R8,R8               TEST IF 0 RECORDS DELETED
         BNZ       UPDELCVD            BRANCH IF NOT
         LA        R3,$LIT0327         ERROR MESSAGE
         LA        R4,UTUPREC          ERRONIOUS COMMAND
         BAL       RE,ERROR            PRINT OUT ERROR
         B         UPCONT              CHECK FOR CONTIN IN SYSUP
*
*        OUTPUT NUMBER OF RECORDS DELETED AND TEST IF RANGE CORRECT
UPDELCVD CLC       UPDELS1(8),UPDEL01  TEST IF RANGE WAS CORRECT
         BNE       UPDELRER            BRANCH IF RANGE ERROR
         CLC       UPDELS2(8),UPDEL02  TEST IF SEQ2 WAS OK
         BE        UPDELGOD            BRANCH IF GOOD DELETE
*
*        PRINT INCORRECT DELETE STATEMENT
UPDELRER MVC       $LIT0328+3(8),UPDEL01    SEQ1
         MVC       $LIT0328+15(8),UPDEL02   SEQ2
         LA        R3,$LIT0328         ERROR MESSAGE
         LA        R4,UTUPREC          ERRONIOUS COMMAND RECORD
         BAL       RE,ERROR            BRANCH TO ERROR
*
*        NORMAL DELETE MESSAGE
UPDELGOD TM        L1PBYT(R9),X'04'    IS NOUPLIST ON .Q
         BZ        UPCONT              YES, CHECK FOR CONTIN IN SYSUP
         MVC       $LIT0329+8(6),=X'402020202120'   EDIT MASK
         CVD       R8,ERCVD            CONVERT TO DECIMAL
         ED        $LIT0329+8(6),ERCVD+5    EDIT IN NUMBER
         MVI       $LIT0329+21,C'S'    ASSUME PLURAL
         BCT       R8,*+8              BUT TEST IT
         MVI       $LIT0329+21,C' '    THERE'S ONLY ONE
         LA        R3,$LIT0329         MESSAGE TEXT
         LA        R4,UTUPREC          SYSUP RECORD
         BAL       RE,ERROR            PRINT IT OUT
         B         UPCONT              CHECK FOR CONTIN IN SYSUP
         EJECT
RDIN1    DS        0F
         DC        18F'0'              SYSIN READ SAVE AREA
*
*        THIS ROUTINE READS RECORDS FROM SYSIN AND CHECKS FOR
*        CHECKS FOR CORRECT SEQUENCING.
*
RDIN     DS        0H
         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS
         LR        RF,RD               TRANSFER SAVE AREA
         LA        RD,RDIN1            READ SYSIN SAVE AREA
         ST        RF,4(,RD)           FORWARD CHAINING
         ST        RD,8(,RF)           BACKWARD CHAINING
         L         RF,16(,RF)          RESTORE R15
         L         R8,L1DCBADS+L1SIN(,R9)  SYSIN DCB ADDRESS
         MVC       SAEODAD+1(3),DCBEODAD+1(R8)    SAVE EODAD EXIT
         MVC       DCBEODAD+1(3,R8),=AL3(RDINEOF)  SET MY EODAD
RDINA    DS        0H
         NI        L1SINSW(R9),X'FE'   TURN OFF RE-READ SWITCH
         LR        R1,R8               TRANSFER DCB ADDRESS
         L         RF,L1DCBPAD(,R8)    GET REAL SYSIN GET ADDRESS
         BALR      RE,RF               DO THE GET
         TM        L1SINSW(R9),X'01'   TEST RE-READ SWITCH
         BZ        RDINOK              GO ON IF NO RE-READ REQ'D
         MVC       L1DCBPAD+1(3,R8),DCBGET+1(R8)  SAVE REAL ADDRESS
         MVC       DCBGET+1(3,R8),L1SINAD+1(R9)  RESET DUMMY ASM ADDR
         B         RDINA               RE-ISSUE THE GET
RDINOK   DS        0H
         LR        R6,R1               ADDR OF SYSIN RECORD
         CLC       UTINSEQ(8),=CL8' '  TEST FOR BLANK SEQUENCE NUMBER
         BNE       RDINB               SEQUENCE NUMBER OK
         MVC       $LIT0320+9(8),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME
         LA        R3,$LIT0320         MESSAGE TEXT
         LA        R4,UTINREC          RECORD IN ERROR
         BAL       RE,ERROR            PRINT OUT ERROR
         B         RDINA               GET NEXT SYSIN RECORD
RDINB    TM        UTSW,UTSWIN         TEST FOR FIRST RECORD
         BO        RDFINI              BRANCH IF FIRST RECORD
         CLC       UTINSEQ(8),UTINOLD  CHECK FOR SEQUENCE ERROR
         BH        RDFINI              BRANCH IF OK
         MVC       $LIT0332+3(8),L1DDNAM+2*L1SIN(R9)  SYSIN DDNAME
         LA        R3,$LIT0332         MESSAGE TEXT
         LA        R4,UTINREC          RECORD IN ERROR
         BAL       RE,ERROR            PRINT OUT ERROR
         B         RDINA               GET NEXT SYSIN RECORD
RDFINI   MVC       UTINOLD(8),UTINSEQ  SAVE SEQ TO TEST NEXT RECORD
         NI        UTSW,X'FF'-UTSWIN   TURN OFF FIRST CARD SWITCH
*
*        FIX THINGS UP AND RETURN
         MVC       DCBEODAD+1(3,R8),SAEODAD+1  RESTORE EODAD
RDRETRN  L         RD,4(,RD)           RESTORE SAVE AREA
         LM        RE,R5,12(RD)        RESTORE REGISTERS
         LM        R7,RC,48(RD)        ALL BUT R6, NOW ALTERED
         SR        RF,RF               SET RETURN CODE
         BR        RE                  RETURN
*
*        EOF ON SYSIN
RDINEOF  OI        UTSW,UTSWEOF        SET EOF ON SYSIN
         MVC       DCBEODAD+1(3,R8),SAEODAD+1  RESTORE SYSIN EODAD
         LA        R6,UTLASTR          MAKE SYSIN AS HIGH AS POSSIBLE
         TM        UTSW,UTSW1EOF       HAS SYSUP ENDED .Q
         BNZ       REODAD              YES, TAKE EODAD EXIT
         B         RDRETRN             GO AND RETURN
         EJECT
COPYUT1  DS        0F
         DC        18F'0'              COPY SYSIN UTILITY SAVE AREA
*
*        THIS ROUTINE COPIES CARDS FROM SYSIN TO SYSOUT
*        UNTIL A SEQUENCE NUMBER GREATER THAN THE ONE
*        SPECIFIED IS FOUND.
*
*        INPUT   R1   ADDR OF STOPPING SEQUENCE NUMBER
*
COPYUT   DS        0H
         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS
         LR        RF,RD               TRANSFER SAVE ADDRESS
         LA        RD,COPYUT1          COPYUT SAVE AREA
         ST        RF,4(,RD)           FORWARD CHAINING
         ST        RD,8(,RF)           BACKWARD CHAINING
         L         RF,16(,RF)          RETAIN R15
         LR        R8,R1               ADDR OF STOPPING SEQUENCE
COTEST   CLC       UTINSEQ(8),0(R8)    TEST FOR STOPPING SEQUENCE
         BNL       CODONE              BRANCH IF END OF COPY
*
*        WRITE RECORD TO SYSOUT
         LA        RA,UTINREC          RECORD FROM SYSIN
         BAL       RE,WROUT            'WRITE' OUT TO SYSOUT
         TM        L1PBYT1(R9),X'80'   IS IT FULLUPLIST .Q
         BZ        COREAD              NO, DON'T LIST IT
         LA        R3,$LIT0341         MESSAGE TEXT
         LA        R4,UTINREC          SYSIN RECORD TO PRINT
         BAL       RE,ERROR            GO AND PRINT IT
         NI        ERSW,X'FF'-(ERSWER+ERSWFL) CLEAR ERROR SWITCHES
*
*        READ A CARD FROM SYSIN
COREAD   BAL       RE,RDIN             READ NEXT SYSIN CARD
         B         COTEST              TEST IF THIS CARD GETS COPIED
*
*        RETURN
CODONE   L         RD,4(,RD)           GET LAST SAVE
         LM        RE,R5,12(RD)        RESTORE CALLER'S REGISTERS
         LM        R7,RC,48(RD)        ALL BUT R6 NOW POSSIBLY ALTERED
         SR        RF,RF               SET ZERO RETURN CODE
         BR        RE                  RETURN
         EJECT
RDUP1    DS        0F
         DC        18F'0'              READ SYSUP SAVE AREA
*
*        THIS ROUTINE READS RECORDS ON SYSUP
*        R7 WILL BE ALTERED WHEN  RDUP  RETURNS
*
RDUP     DS        0H
         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS
         LR        RF,RD               REMEMBER SAVE AREA
         LA        RD,RDUP1            NEW SAVE AREA
         ST        RF,4(,RD)           CHAIN FORWARD
         ST        RD,8(,RF)           AND BACKWARD
         L         RF,16(RF)           RESTORE R15
RDUPA    L         R1,L1DCBADS+L1SUP(,R9)  ADDR OF SYSUP DCB
         NI        L1SINSW(R9),X'FE'   TURN OFF THE RE-READ SWITCH
         GET       (1)                 DO A SYSUP GET
         TM        L1SINSW(R9),X'01'   TEST RE-READ SWITCH
         BO        RDUPA               RE-READ IF ON
         LR        R7,R1               SET SYSUP RECORD BASE
         L         R2,L1DCBADS+L1SIN(,R9)  GET SYSIN DCB ADDRESS
         L         R1,L1DCBRCT(,R2)    GET SYSIN RECORD COUNT
         BCTR      R1,0                DECREMENT BY ONE
         ST        R1,L1DCBRCT(,R2)    AND RESTORE
         L         R2,L1DCBADS+L1SUP(,R9)  GET SYSUP DCB ADDRESS
         L         R1,L1DCBRCT(,R2)    GET SYSUP RECORD COUNT
         LA        R1,1(,R1)           BUMP BY ONE
         ST        R1,L1DCBRCT(,R2)    AND RESTORE
*
*        RETURN TO CALLER
RDUPRET  L         RD,4(,RD)           RESTORE SAVE AREA POINTER
         LM        RE,R6,12(RD)        RESTORE MOST REGISTERS
         LM        R8,RC,52(RD)        ALL BUT R7, NOW ALTERED
         SR        RF,RF               SET RETURN CODE
         BR        RE                  RETURN
*
*        EOF ON SYSUP
RDUPEOF  OI        UTSW,UTSW1EOF       SET EOF ON SYSUP
         LA        R7,UTLASTR          DUMMY EOF SYSUP RECORD
         TM        UTSW,UTSWEOF        HAS SYSIN ENDED .Q
         BZ        RDUPRET             NO, NOT YET
*
*        TAKE EODAD OF SYSIN AND NEVER RETURN
REODAD   L         R2,L1DCBADS+L1SIN(,R9)  SYSIN DCB ADDRESS
         MVC       UPSAV1+61(3),DCBEODAD+1(R2)  ALTER R15 FOR A BRANCH
         LM        R0,RF,UPSAV1        RESTORE CALLER'S REGISTERS
         BR        RF                  BRANCH TO EODAD
         EJECT
ERROR1   DS        0F
         DC        18F'0'              ERROR SAVE AREA
ERCVD    DS        D                   CVD WORK AREA
*
*        THIS ROUTINE PRINTS AN ERROR MESSAGE
*
*        IF THE SAME ERROR OCCURS TWICE IN A ROW, THEN THE FLUSH
*        SWITCH IS SET AND A 'FLUSHING' MESSAGE IS PRINTED INSTEAD.
*
*        INPUT -
*                R3   ERROR MESSAGE
*                R4   RECORD IN ERROR
*
ERROR    DS        0H
         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS
         LR        RF,RD               TRANSFER SAVE AREA
         LA        RD,ERROR1           ESTABLISH SAVE FOR ERROR
         ST        RF,4(,RD)           FORWARD CHAINING
         ST        RD,8(,RF)           BACKWARD CHAINING
         L         RF,16(,RF)          RESTORE R15
*
         LR        R5,R4               TRANSFER RECORD IN ERROR
         LR        R4,R3               ERROR MESSAGE POINTER
         BAL       RE,ERNUMSEV         GET ERROR NUMBER AND SEVERITY
         LTR       R1,R1               IS IT SERIOUS .Q
         BNZ       ERCOMP              BRANCH IF YES
         NI        ERSW,X'FF'-(ERSWER+ERSWFL)  CLEAR ERROR SWITCHES
         BAL       RE,PRINT            GO PRINT IT
         B         ERDONE              AND RETURN
*
*        CHECK FOR HIGHEST COMPLETION CODE SO FAR
ERCOMP   DS        0H
         CH        R1,UTRETCD          COMPARE WITH PREVIOUS HIGH
         BNH       *+8                 BRANCH IF NOT HIGHER
         STH       R1,UTRETCD          SAVE THIS AS HIGHEST SO FAR
         CLC       UTRETCD+1(1),L1UPCOND(R9)  GREATER THAN MAX .Q
         BNH       ERLEMAX             BRANCH IF NOT
         OI        L1SYNERR+1(R9),X'01'  SET ERROR FOR ASMGF3
         MVC       L1UPCOND(1,R9),UTRETCD+1  REMEMBER THE HIGHER
*
*        TEST IF THIS SAME ERROR AS LAST
ERLEMAX  DS        0H
         TM        ERSW,ERSWER         TEST IF NOT INTERVENING OK OPER
         BZ        ERPUT               OK OPERATION FOUND
         CH        R3,UTERCODE         TEST IF SAME ERROR AS LAST TIME
         BNE       ERPUT               BRANCH IF NOT SAME
         TM        ERSW,ERSWFL         TEST IF ALREADY IN FLUSH MODE
         BO        ERDONE              YES WE ARE
         LA        R4,$LIT0330         ERROR MESSAGE
         BAL       RE,ERNUMSEV         GET ERROR NUMBER AND SEVERITY
         BAL       RE,PRINT            GO TO PRINT ROUTINE
         OI        ERSW,ERSWFL         SET FLUSH MODE
         B         ERDONE              RETURN
*
*        GET ERROR NUMBER AND SEVERITY
ERNUMSEV DS        0H
         SR        R3,R3               CLEAR ERROR NUMBER
         IC        R3,0(,R4)           GET ERROR NUMBER LESS 200 OFFSET
         LA        R3,200(,R3)         ACTUAL ERROR NUMBER
         SR        R1,R1               CLEAR SEVERITY
         IC        R1,2(,R4)           GET ERROR SEVERITY
         BR        RE                  AND RETURN
*
*        NOT FLUSHING  --  PRINT ERROR MESSAGE
ERPUT    DS        0H
         STH       R3,UTERCODE         SAVE TO SEE IF NEXT ERROR FLUSH
         BAL       RE,PRINT            GO TO PRINT ROUTINE
         OI        ERSW,ERSWER         SET ERROR OCCURRED
         NI        ERSW,X'FF'-ERSWFL   CLEAR FLUSH MODE
*
*        RETURN
ERDONE   L         RD,4(,RD)           RESTORE FORMER SAVE AREA
         LM        RE,RC,12(RD)        RESTORE REGISTERS
         SR        RF,RF               SET RETURN CODE
         BR        RE                  RETURN
         EJECT
PRINT1   DS        0F
         DC        18F'0'              SAVE AREA FOR PRINT
*
*        THIS ROUTINE BUILDS UP A PRINT LINE FROM THE INPUT
*        PARAMETERS AND PRINTS IT.
*        CAN'T TELL WHERE LAST LINE WAS PRINTED (IF EXECUTE)
*        SO DON'T TRY ANY EFFICIENT CARRIAGE CONTROL MODS.
*
*        INPUT   R1   NUMERIC CARRIAGE CONTROL
*                     R1 = 0  LEAVE NO SPACE, DON'T PRINT ON SYSTERM
*                     R1 = 4  LEAVE A SPACE, DON'T PRINT ON SYSTERM
*                     R1 >=8  LEAVE A SPACE, PRINT ON SYSTERM
*                R3   MESSAGE I.D.
*                R4   COMMENT TEXT OR 0 IF NONE
*                R5   RECORD TO BE PRINTED
*
*        WORK AREA
*
PRNUM    DS        D                   CVD WORK AREA
*
PRCARR   DS        C                   SAVE AREA FOR R1 CARR CONTROL
MVTEXT   MVC       UTPRCOM(*-*),0(R1)  MOVE IN COMMENT
*
*./      DELETE    SEQ1=11780025,SEQ2=11920025
*
PRINT    DS        0H
         STM       RE,RC,12(RD)        SAVE CALLER'S REGISTERS
         LR        RF,RD               REMEMBER OLD SAVE
         LA        RD,PRINT1           NEW SAVE AREA
         ST        RF,4(,RD)           FORWARD CHAIN
         ST        RD,8(,RF)           BACKWARD CHAIN
         L         RF,16(,RF)          RESTORE R15
         SRL       R1,2                CHANGE 0,4,8 TO 0,1,2
         STC       R1,PRCARR           SAVE NUMERIC CARR CONTROL
         L         R8,L1DCBADS+L1SPRINT(,R9)  POINT TO SYSPRINT DCB
*
*        BLANK THE BUFFER
*        USING CARR CONTROL AND BLANKS IN LIST1
         MVC       UTPRBUF(L'UTPRBUF),L1BLANKS(R9) BLANK ENTIRE AREA
*
         MVC       UTPRID(4),=C'ASMG'  PLACE 4 CHARS OF I.D.
         CVD       R3,PRNUM            CONVERT I.D. TO PACKED
         UNPK      UTPRID+4(3),PRNUM(8)  CONVERT TO CHAR IN PRINT LINE
         OI        UTPRID+6,X'F0'      FIX UP LAST ZONE
*
*        PLACE COMMENT TEXT
*
         LTR       R4,R4               TEST IF THERE IS ANY
         BZ        PRREC               BRANCH IF NONE
         LA        R1,3(,R4)           ADDRESS OF TEXT
         IC        R2,1(,R4)           LENGTH-1 FOR MVC
         EX        R2,MVTEXT           MOVE COMMENT TO PRINT LINE
*
*        PLACE THE RECORD
PRREC    LTR       R5,R5               TEST IF A RECORD PRESENT
         BZ        PRTEST              BRANCH IF NOT
         MVC       UTPRREC(80),0(R5)   MOVE RECORD TO PRINT LINE
PRTEST   IC        R5,L1DCBCC(,R8)     SAVE CARRIAGE CONTROL
         NI        L1DCBCC(R8),X'7F'   TURN OFF ASA BIT
         OI        L1DCBCC(R8),X'40'   TURN ON NUMERIC BIT
         L         R2,L1UTLINO(,R9)    GET NUMBER OF LINES LEFT
         BCT       R2,*+8              DECREMENT AND TEST
         B         PRHEAD              DOWN TO ONE, EJECT
         CLI       PRCARR,X'00'        TEST IF THIS ONE NORMAL
         BE        PRLINE              BRANCH IF SO
*
*        DOUBLE SPACING REQUIRED
PRDEC    BCT       R2,*+8              PRINT IF NOT END OF PAGE
         B         PRHEAD              IT IS THE END OF PAGE
*./      DELETE    SEQ1=12780025,SEQ2=12780025
         MVI       UTPRCARR,X'01'      LEAVE A BLANK LINE
         B         PRLINE              GO AND PRINT THIS LINE
*
*        SKIP TO NEW PAGE AND PRINT TITLE AND HEADING
PRHEAD   DS        0H
         L         R1,L1PAGENO(,R9)    GET CURRENT PAGE NUMBER
         LA        R1,1(,R1)           BUMP PAGE NUMBER BY ONE
         ST        R1,L1PAGENO(,R9)    SAVE IT BACK
         CVD       R1,PRNUM            CONVERT TO DECIMAL
         MVC       PRPAGNO(4),=X'40202120'  SET EDIT MASK
         ED        PRPAGNO(4),PRNUM+6  EDIT PAGE NUMBER TO OUTPUT
         PUT       (R8),PRHEAD1        PRINT TITLE LINE
         PUT       (R8),PRHEAD2        PRINT HEADER LINE
         LH        R2,L1LINECT(,R9)    RESET LINES PER PAGE
         MVI       UTPRCARR,X'01'      DOUBLE SPACE NEXT LINE
*
*        PRINT THE LINE
PRLINE   DS        0H
         PUT       (R8),UTPRBUF        PRINT THE LINE
         STC       R5,L1DCBCC(,R8)     RESTORE CARRIAGE CONTROL
         ST        R2,L1UTLINO(,R9)    SAVE LINES LEFT FOR NEXT
*
*        TEST IF SYSTERM IS OPEN
PRTERM   L         R8,L1DCBADS+L1STERM(,R9)  POINT TO SYSTERM DCB
         TM        DCBOFLGS(R8),X'10'  DID SYSTERM OPEN .Q
         BZ        PRDONE              NO, TIME TO RETURN
         CLI       PRCARR,X'02'        IS SEVERITY TWO OR MORE .Q
         BL        PRDONE              NO, DON'T PRINT ON SYSTERM
         L         R4,L1TRSAVE(,R9)    GET SYSTERM LINE COUNT
         IC        R5,L1DCBCC(,R8)     RETAIN CARRIAGE CONTROL
         NI        L1DCBCC(R8),X'7F'   TURN OFF ASA BIT
         OI        L1DCBCC(R8),X'40'   TURN ON NUMERIC BIT
         MVI       UTPRCARR,X'00'      NO SPACE FOR THIS
         BCT       R4,PRTERR           NEW PAGE YET .Q
         MVI       UTPRCARR,X'FF'      YES, EJECT THIS PAGE
         LH        R4,L1LINECT(,R9)    RESTORE LINES PER PAGE
PRTERR   PUT       (R8),UTPRBUF        PRINT THIS LINE
         STC       R5,L1DCBCC(,R8)     RESTORE CARRIAGE CONTROL
         ST        R4,L1TRSAVE(,R9)    RESTORE SYSTERM LINE COUNT
*
*        RETURN
PRDONE   L         RD,4(,RD)           RESTORE FORMER SAVE AREA
         LM        RE,RC,12(RD)        RESTORE REGISTERS
         SR        RF,RF               SET RETURN CODE
         BR        RE                  RETURN
         EJECT
*
*        THIS ROUTINE 'WRITES' RECORDS TO THE
*        ASSEMBLER AFTER CHECKING FOR CORRECT SEQUENCING.
*
*
*        INPUT   RA   ADDRESS OF RECORD TO BE WRITTEN
*
*        RETURN IS EFFECTED VIA THE ASMGUP ENTRY POINT
*        THE NEXT TIME THE ASSEMBLER CALLS ASMGUP FOR
*        ANOTHER CARD.
*
WROUT    DS        0H
         SR        RF,RF               PRESUMABLY WE RETURN TRIUMPHANT
         STM       R0,RF,UPSAV2        SAVE ALL MY REGISTERS
         TM        UTSW,UTSWOUT        IS THIS FIRST CARD RETURNED .Q
         BO        UPWRITE             YES, SKIP SEQUENCE CHECK
         CLC       72(8,RA),UTOUTSEQ   CHECK SEQUENCING OK
         BH        UPWRITE             BRANCH IF OK
*
*        BLAME INCORRECT SEQUENCE ON SYSUP CAUSE SYSIN ALREADY CHECKED
         MVC       $LIT0331+3(8),L1DDNAM+2*L1SUP(R9)  SYSUP DDNAME
         LA        R3,$LIT0331         ERROR MESSAGE
         LA        R4,UTUPREC          SYSUP IS IN ERROR
         BAL       RE,ERROR            PRINT OUT ERROR
         LM        R0,RF,UPSAV2        RESTORE ALL REGISTERS
         LA        RF,4                SET RETURN CODE
         BR        RE                  AND RETURN
*
*        RETURN RECORD TO SYSOUT
UPWRITE  NI        UTSW,X'FF'-UTSWOUT  TURN OFF FIRST SYSOUT CARD SW
         MVC       UTOUTSEQ(8),72(RA)  SAVE SEQ FOR CHECKING THE NEXT
         AIF       (NOT &HRDCOPY).NOJOUT
*
*        DO WE WRITE THIS RECORD OUT ON SYSPUNCH ALSO .Q
SWITJACQ BC    *-*+15,OMITJACQ         SWITCH FOR SYSPUNCH OUTPUT
         L     R1,L1DCBADS+L1SPUNCH(,R9)  SYSPUNCH DCB ADDRESS
         PUT   (1)                     GET BUFFER FOR MERGED RECORD
         MVC   0(80,R1),0(RA)          MOVE RECORD TO THE BUFFER
OMITJACQ DS    0H                      JUST ANOTHER LABEL
.NOJOUT  ANOP
*./      DELETE    SEQ1=14500025,SEQ2=14500025
         ST        RA,UPSAV1+4*R1      PASS ADDR OF RECORD TO USER
         LM        R0,RF,UPSAV1        GET ALL USER'S REGISTERS
         BR        RE                  RETURN TO HIM
         EJECT
*
*        WORK AREA USED BY ASMGUP
*
UPSAV1   DC        16F'0'              SAVE AREA FOR USERS REGISTERS
UPSAV2   DC        12F'0',A(ASMGUP,UPSAV3,UPINIT,0)
*                                      SAVE AREA FOR MY REGISTERS
UPSAV3   DC        18F'0'              SAVE AREA FOR O/S USAGE
PATCH    DC        10S(*)              PATCH AREA
*
ERSW     DC        X'00'               ERROR SWITCH
ERSWER   EQU       X'80'               ERROR ON LAST OPERATION
ERSWFL   EQU       X'40'               IN FLUSH MODE
ERSWNUM  EQU       X'20'               NUMERIC ARGUMENT REQUIRED
*
UTSW     DC        X'C0'               FILE SWITCH
UTSWIN   EQU       X'80'               NOTHING ON SYSIN YET
UTSWOUT  EQU       X'40'               NOTHING ON SYSOUT YET
UTSWEOF  EQU       X'20'               EOF ON SYSIN
UTSW1EOF EQU       X'10'               EOF ON SYSUP
*
PRHEAD1  DS        0CL133              PRINTER TITLE LINE
         DC        X'FF'               EJECT BEFORE PRINTING
         DC        CL34' '             BLANKS
         DC        CL26'ASSEMBLER (G)  UPDATE  LOG'
         DC        CL51' '             BLANKS
         DC        C'PAGE '            PAGE
PRPAGNO  DS        CL4                 PAGE NUMBER
         DC        CL12' '             TRAILER BLANKS
*
PRHEAD2  DS        0CL133              PRINTER TITLE LINE TWO
         DC        X'02'               SPACE 2 AND PRINT
         DC        CL2' '
         DC        CL10'I.D.'
         DC        CL30'MESSAGE'
         DC        CL69'RECORD'
PRDATE   DS        CL9                 TODAY'S DATE
         DC        CL12' '             TRAILER BLANKS
*
UTPRBUF  DS        0CL133              LINE BUFFER
UTPRCARR DS        X                   NUMERICAL CARRIAGE CONTROL
UTPRID   DS        CL10                I.D. PORTION
UTPRCOM  DS        CL30                COMMENT OR ERROR MESSAGE
UTPRREC  DS        CL80                RECORD BEING PRINTED
         DC        CL12' '             TRAILER BLANKS
*
UTERCODE DC        H'0'                FORMER ERROR MESSAGE I.D.
UTRETCD  DC        H'0'                HIGHEST RETURN CODE
*
ASMGIND  DSECT
*        SYSIN RECORD POINTED TO BY R6
UTINREC  DS        CL80                SYSIN RECORD
UTINSEQ  EQU       *-8                 SYSIN SEQUENCE NUMBER
*
ASMGUPD  DSECT
*        SYSUP RECORD POINTED TO BY R7
UTUPREC  DS        CL80                SYSUP RECORD
UTUPSEQ  EQU       *-8                 SYSUP SEQUENCE NUMBER
*
ASMGUP   CSECT
UTLASTR  DC        80X'FF'             DUMMY EOF RECORD FOR SYSIN,SYSUP
*
UTOUTSEQ DS        CL8                 FORMER SYSOUT SEQUENCE NUMBER
UTINOLD  DS        CL8                 FORMER SYSIN SEQUENCE NUMBER
*
UPDELS1  DS        CL8                 SEQ1 FROM DELETE CARD
UPDELS2  DS        CL8                 SEQ2 FROM DELETE CARD
UPDEL01  DS        CL8                 SEQ OF 1ST CARD DELETED
UPDEL02  DS        CL8                 SEQ OF LAST CARD DELETED
SAEODAD  DS        F                   SAVE SYSIN EODAD ADDRESS
*
*        ERROR DESCRIPTIONS
*
*     ERROR SEVERITY          MEANING
*           0   --   JUST A PASSING COMMENT.
*           4   --   AN INTERESTING COMMENT.
*           8   --   UNSUPPORTED FUNCTION, ALL OK.
*          12   --   POSSIBLE ERROR, MAYBE ALL OK.
*          16   --   PROBABLE ERROR.
*
         UPEMSG    320,12,'BLANK SYSINXXX SEQUENCE FIELD'
         UPEMSG    321,12,'BLANK SYSUPXXX SEQUENCE FIELD'
         UPEMSG    323,00,'     INSERTION'
         UPEMSG    324,00,'     TO BE REPLACED'
         UPEMSG    325,00,'     REPLACEMENT'
         UPEMSG    326,00,'     DELETION'
         UPEMSG    327,16,'NO RECORDS IN RANGE'
         UPEMSG    328,16,'XXXXXXXX TO XXXXXXXX MISMATCH'
         UPEMSG    329,00,'     XXXXXX RECORDS DELETED'
         UPEMSG    330,04,'FLUSHING'
         UPEMSG    331,12,'SYSUPXXX SEQUENCE ERROR'
         UPEMSG    332,12,'SYSINXXX SEQUENCE ERROR'
         UPEMSG    334,16,'INVALID DELETE OPERANDS'
         UPEMSG    335,16,'SEQ1 IS GREATER THEN SEQ2'
         UPEMSG    336,08,'CONTROL CARD NOT SUPPORTED'
         UPEMSG    337,16,'CONTROL CARD NOT RECOGNIZED'
         UPEMSG    338,00,'CONTINUED CONTROL CARD'
         UPEMSG    339,04,'./ ENDUP CARD ON SYSUPXXX'
         UPEMSG    340,12,'UNPROCESSED SYSUPXXX RECORDS'
         UPEMSG    341,00              SYSIN RECORD UNDER FULLUPLIST
*
*        END OF ASMGUP DECK
*        MISCELLANEOUS DECLARATIONS
*
R0       EQU       0
R1       EQU       1
R2       EQU       2
R3       EQU       3
R4       EQU       4
R5       EQU       5
R6       EQU       6
R7       EQU       7
R8       EQU       8
R9       EQU       9
RA       EQU      10
RB       EQU      11
RC       EQU      12
RD       EQU      13
RE       EQU      14
RF       EQU      15
*
         LIST1EQU
*
*        DCB DISPLACEMENTS
DCBEODAD EQU       32
DCBGET   EQU       48
DCBOFLGS EQU       48
*
         LTORG
         ORG       ASMGUP+X'1000'      ROUND SIZE UP
         END       ASMGUP
./ ADD NAME=ASMGWYL
ASM      TITLE     'ASMG     MASTER ROOT SEGMENT'
         ISEQ  73,78
*TITLE-ASMGASM- PHASE 'ASM'- MASTER ROOT SEGMENT
*FUNCTION- PERMANENT RESIDENT PHASE.
*   SAVES CONTROL PROGRAM (O.S. OR INVOKER) REGS.
*   LINK'S TO ASMGF1 TO INITIATE THE ASSEMBLY.
*   RECEIVES CONTROL FROM 'FPP' VIA 'RTA' AT THE END
*   OF THE ASSEMBLY.  ASMGASM THEN
*   RETURNS TO ITS INVOKER AFTER CLOSING ALL DATASETS.
*   DEFINES DCB'S FOR ALL 10 DATASETS.
*   CONTAINS SYSIN AND QSAM OUTPUT MONITORING ROUTINES, I/O ERROR
*     ROUTINE AND ABEND (NAMED FOR HISTORICAL REASON) ROUTINE.
*ENTRY POINT- ASMGASM
*EXIT-   BR        R14
         SPACE     2
         COPY      ASMGSET
         EJECT
ASMGASM  START
*
*        REGISTER DEFINITIONS
*
         SETR
         SPACE     2
*        TO SAVE SOME CORE INITIALIZE IN A FUTURE SAVE AREA.
         USING     ASMGASM,R15         FOR A SINGLE BRANCH
         B         INITIAL             BRANCH FOR INITIALIZING
         DROP      R15                 FORGET R15
         USING     ASMGASM,R12         NOW WE'RE USING R12
         DC        AL1(8),CL8'ASMGV2L7'
*./      DELETE    SEQ1=00580025,SEQ2=00640025
*
*        LINK TO PHASE ASMGF1
*
DONEINIT DS        0H
         SVC       6                   ISSUE LINK SVC TO ASMGF1
         EJECT
*
*        RETURN AFTER ALL ASSEMBLIES
*
RETURN   DS        0H
         BALR      R14,0               SET TEMPORARY BASE
         USING     *,R14
         L         R12,=A(ASMGASM)     SET UP NORMAL BASE
         DROP      R14
         LA        R13,SAVE2            OS SAVE AREA
*./      DELETE    SEQ1=00940022,SEQ2=01400022
*
*        RETURN TO INVOKING PROGRAM
*
*
*        FREE THE CORE IF NECESSARY
         L         R1,FREEMEM          FREE GETMAIN AREA
         L         R0,FREEMEM+4
         LTR       R0,R0               TEST IF CORE GOTTEN YET
         BZ        CLOSE               BR IF NOT
         FREEMAIN  R,LV=(0),A=(1)
*
*        CLOSE ALL DCB'S. A FEW MAY NOT HAVE BEEN OPENED - CLOSE ANYWAY
*
CLOSE    DS        0H
*./      DELETE    SEQ1=01574426,SEQ2=01575226
         LA        R2,LIST1+L1DCBADS   POINT TO 1ST DCB ADDR
CLOSLOOP DS        0H
         L         R5,0(,R2)           GET DCB ADDRESS
         L         R3,L1DCBPAD(,R5)    GET PATCHED GET/PUT ADDRESS
         LA        R3,0(,R3)           CLEAR HIGH BYTE
         LTR       R3,R3               WAS DCB PATCHED INTO .Q
         BZ        CLOSPTCH            BRANCH IF NOT
         MVC       DCBGET+1(3,R5),L1DCBPAD+1(R5)  RESTORE REAL ADDRESS
CLOSPTCH DS        0H
         LA        R2,4(,R2)           POINT TO NEXT DCB ADDR
         LTR       R5,R5               LAST DCB .Q
         BP        CLOSLOOP            BRANCH IF NOT
        CLOSE (SYSTERM,LEAVE,          SYSTERM                         X
               SYSUP,DISP,             SYSUP                           X
               SYSLIB,DISP,            SYSLIB                          X
               SYSIN,DISP,             SYSIN                           X
               SYSLIN,DISP,            SYSLIN                          X
               SYSPRINT,LEAVE,         SYSPRINT                        X
               SYSPUNCH,LEAVE,         SYSPUNCH                        X
               SYSUT1,REREAD,          SYSUT1                          X
               SYSUT2,REREAD,          SYSUT2                          X
               SYSUT3,REREAD)          SYSUT3
*
*        FREE ALL QSAM BUFFERS.
         CLC       SYSIN+DCBBUFCB(3),SYSLIN+DCBBUFCB TEST IF SYSIN AND
         BE        FREEPRT               SYSLIN HAVE SAME BUFFER POOL
         LA        R1,SYSIN
         BAL       R2,FREEPOOL
FREEPRT  LA        R1,SYSPRINT
         BAL       R2,FREEPOOL
         LA        R1,SYSPUNCH
         BAL       R2,FREEPOOL
         LA        R1,SYSLIN
         BAL       R2,FREEPOOL
         LA        R1,SYSTERM
         BAL       R2,FREEPOOL
         LA        R1,SYSUP
         BAL       R2,FREEPOOL
*        DELETE THE ASMGISXX MODULE IN CASE BATCH
         DELETE    EPLOC=ISNAME
*        DELETE THE ASMGUP ROUTINE IN CASE UPDATE
         DELETE    EP=ASMGUP
*
*        RESTORE CALLER'S REGISTERS AND RETURN
         L         R13,SAVE1            RESTORE CTL PROG SAVE ADDRESS
         LM        R14,R12,12(R13)      RESTORE CALLER'S REGISTERS
         L         R15,SAVECC-ASMGASM(,R15)  GET COMPLETION CODE
         LTR       R15,R15              IF ERR CODE IN REG,
         BCR       7,R14                RETURN IMMEDIATELY  (BNZR)
         MVI       12(R13),X'FF'        SET FOR NORMAL RETURN
         BR        R14                  RETURN
*        FREEPOOL SUBROUTINE
FREEPOOL TM        23(R1),X'01'        TEST IF BUFFERS EXIST
         BCR       1,R2                BOR  BRANCH IF NOT
         FREEPOOL  (1)                 DO THE FREEPOOL
         BR        R2                  RETURN
         EJECT
ABWTO    DC        0F'0',AL2(120+4),X'8000'  MF=E WTO INCL ROUTE CODES
ABMESS   DS        0CL133
         DC        C'  ASMG999A   ASSEMBLY TERMINATED. I/O ERROR. SYNAD*
               AF INFO='''
*        THE NEXT 77 BYTES MAY BE CLOBBERED BY THE ABEND OR
*        THE I/O ERROR ROUTINES.
         SPACE     5
*
*        THIS EXLST ROUTINE IS ENTERED DURING OPEN FOR EACH DCB
*        R8 CONTAINS ADDRESS OF EXLST ROUTINE IN F1 (LOADED BY F1)
*        IT IS ALSO ENTERED ON EACH IMPLICIT OPEN FORCED BY THE
*           CONCATENATION OF UNLIKE DEVICES
*
         DC        0F'0'
EXITLIST DC        X'85'
         DC        AL3(EXITROUT)
EXITROUT DS        0H
         USING     *,R15
         LA        R1,0(,R1)           ZERO TOP BYTE
         C         R1,LIST1+L1DCBADS+L1SIN  IS THIS SYSIN .Q
         BE        EXIT0               YES, CONTINUE FURTHER ON
         C         R1,LIST1+L1DCBADS+L1SUP  IS THIS SYSUP .Q
         BCR       7,R8                NO, BR TO EXLST ROUTINE IN F1
EXIT0    TM        DCBOFLGS(R1),X'08'  TEST IF FIRST OPEN
         BO        EXIT1               BR IF NOT
         OI        DCBOFLGS(R1),X'08'  TURN ON CONCAT OF UNLIKE DEVICES
         BR        R8                  GO TO EXLST ROUTINE IN F1
EXIT1    OI        SYSINSW,X'01'       SET RE-GET SWITCH
         NI        DCBRECFM(R1),X'EF'  TURN OFF BLOCKED BIT
         LH        R2,DCBBLKSI(,R1)    GET THE BLOCKSIZE
         CH        R2,DCBLRECL(,R1)    TEST IF BLOCKED
         BE        *+8                 BR IF NOT
         OI        DCBRECFM(R1),X'10'  SET THE  B  BIT
         TM        DCBBUFCB+2(R1),X'01' TEST FOR MY BUFCB
         BCR       1,R14               BOR  BRANCH IF NOT
         L         R3,DCBBUFCB-1(,R1)  POINT AT BUFFER CONTROL BLOCK
         CLC       DCBBUFNO(1,R1),5(R3) TEST IF ENOUGH BUFFERS
         BH        EXIT2               BRANCH IF NOT
*./      DELETE    SEQ1=02572023,SEQ2=02572023
         LA        R2,4(,R2)           ADD 4 IN CASE IT GETS DUMMY BUF
         CH        R2,6(,R3)           TEST IF POOL BUFFERS LONG ENOUGH
         BCR       13,R14              BNHR  RETURN TO OPEN IF OK
EXIT2    OI        DCBBUFCB+2(R1),X'01' SET NO BUFCB IN DCB
         BR        R14                 RETURN TO OPEN
         DROP      R15
         EJECT
*
*        THIS ROUTINE MONITORS SYSIN TO HANDLE EOF AND $JOB SITUATIONS
*
*        IT IS ENTERED BY DOING A NORMAL GET MOVE ON THE SYSIN DCB
*        PHASE F1 HAS ALTERED THE DCBGET ADDR IN THE DCB TO POINT HERE
*
SYSINMON DS        0H
         USING     SYSINMON,R15        USE CALLER'S BRANCH REGISTER
         CLI       SYSINSW,X'00'       TEST FOR EOF OR $JOB
         BZ        SYSINMOV            NOT YET, THEN BRANCH
         L         R15,DCBEODAD(,R1)   LOAD EODAD ADDRESS
         BR        R15                 AND SIMULATE AN EOF
*
SYSINMOV DS        0H
         STM       R12,R14,GETSAVE     SAVE SOME OF CALLER'S REGS
         LR        R12,R15             TRANSFER THE BASE
         DROP      R15                 DROP THE OLD
         USING     SYSINMON,R12        AND USE THE NEW
         LR        R14,R0              POINT TO USER'S INPUT AREA
         L         R15,SYSINBUF        GET ADDR OF NEXT RECORD
         MVC       0(80,R14),0(R15)    GIVE USER THE LAST RECORD
         MVC       SYSINEOD(3),DCBEODAD+1(R1)  SAVE USER'S EODAD ADDR
         MVC       DCBEODAD+1(3,R1),=AL3(SYSINEOF) SET MY EODAD
SYSINGET DS        0H
         NI        SYSINSW,X'FE'       TURN OFF RE-READ SWITCH
         L         R15,DCBGETSV        GET REAL QSAM ADDRESS
         BALR      R14,R15             DO THE GET
         TM        SYSINSW,X'01'       TEST RE-READ SWITCH
         BZ        SYSINGOK            GO ON IF NO RE-READ REQ'D
         MVC       DCBGETSV+1(3),SYSIN+DCBGET+1  SAVE GET ADDR AGAIN
         MVC       SYSIN+L1DCBPAD+1(3),SYSIN+DCBGET+1  SAVE FOR CLOSE
         MVC       SYSIN+DCBGET+1(3),SYSINAD+1   RESET FAKE ADDRESS
         B         SYSINGET            RE-ISSUE THE GET
SYSINGOK DS        0H
         TM        PARBYT1,X'10'       WAS BATCH SPECIFIED .Q
         BZ        SYSINRET            BRANCH IF NOT
         TM        PARBYT2,X'20'       WAS EXECUTE SPECIFIED .Q
         BZ        SYSINRET            BRANCH IF NOT
         CLC       0(L'$JOB,R1),$JOB   TEST FOR A $JOB CARD
         BNE       SYSINRET            BRANCH IF NOT
         MVI       SYSINSW,X'40'       SET $JOB SWITCH
         B         SYSINRET            AND QUIT
*
SYSINEOF DS        0H
         MVI       SYSINSW,X'80'       SET EOF SWITCH
*
SYSINRET DS        0H
         ST        R1,SYSINBUF         SAVE ADDR OF NEXT RECORD
         MVC       SYSIN+DCBEODAD+1(3),SYSINEOD  RESTORE USER'S EODAD
*./      DELETE    SEQ1=03480026,SEQ2=03500026
         LM        R12,R14,GETSAVE     RESTORE CALLER'S REGISTERS
         BR        R14                 RETURN TO USER
         USING     ASMGASM,R12         RESTORE USE OF R12
*
GETSAVE  DC        3F'0'               R12,R13,R14 GET ROUTINE SAVE
SYSINBUF DC        A(BLANKS+1)         ADDR FOR READING 1 CARD AHEAD
SYSINEOD DC        AL3(0)              SAVE REAL SYSIN EODAD
         EJECT
*
*        OUTPUT MONITORING ROUTINE FOR ALL OUTPUT FILES
*
ASMGPUT  DS        0H                  THIS IS IT
         STM       R14,R12,PUTSAVE-ASMGASM(R15)  SAVE CALLER'S REGS
         LR        R12,R15             TRANSFER BASE ADDRESS
         LR        R2,R0               TRANSFER DATA ADDRESS
         LR        R3,R1               TRANSFER DCB ADDRESS
         LM        R4,R5,L1DCBRCT(R3)  R4 IS RECORD COUNT
*                                      R5 IS PREVIOUS LINE LOCATION
*
         TM        L1DCBCC(R3),X'C0'   WHICH CARRIAGE CONTROL .Q
         BM        SYSLNUM             BRANCH IF NUMERIC
         BO        SYSLASA             BRANCH IF ASA
         BAL       R10,SYSLPUT         AS IT IS, GET A BUFFER
         EX        R6,SYSLASIS         PUT OUT THE LINE
         B         SYSLRET             AND RETURN
SYSLASA  DS        0H
         CLI       0(R2),C'1'          NEW PAGE .Q
         BNE       NOTONE              BRANCH IF NOT
         MVI       CARCONT,EJECTIM     SET CARRIAGE CONTROL
         B         FIRSTPUT            BRANCH TO 1ST PUT
NOTONE   DS        0H
         CLI       0(R2),C'-'          TRIPLE SPACE .Q
         BNE       NOTRIP              BRANCH IF NOT
         MVI       CARCONT,SPACE3IM    SET CARRIAGE CONTROL
         B         FIRSTPUT            BRANCH TO FIRST PUT
NOTRIP   DS        0H
         CLI       0(R2),C'0'          DOUBLE SPACE .Q
         BNE       NOTDOUB             BRANCH IF NOT
         MVI       CARCONT,SPACE2IM    DOUBLE SPACE IMMEDIATE
         B         FIRSTPUT            BRANCH TO 1ST PUT
NOTDOUB  CLI       0(R2),C'+'          NO SPACE AT ALL .Q
         BE        SECNDPUT            BRANCH IF YES TO 2ND PUT
NOTPLUS  DS        0H
         MVI       CARCONT,SPACE1IM    MOVE IN SINGLE SPACE
FIRSTPUT DS        0H
         BAL       R10,SYSLPUT         GET OUTPUT BUFFER
         MVC       0(1,R5),CARCONT     SET CARRIAGE CONTROL
         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE
         EX        R6,SYSLBLNK         AND BLANK LINE
SECNDPUT DS        0H
         BAL       R10,SYSLPUT         GET A BUFFER
         MVI       0(R5),SPACE0AP      NO SPACE AFTER PRINT
         BCTR      R6,0                DECREMENT LRECL BY ANOTHER ONE
         EX        R6,SYSLMOVE         MOVE RECORD
         B         SYSLRET             AND RETURN
SYSLNUM  DS        0H
         CLI       0(R2),X'00'         NORMAL PRINT CODE .Q
         BE        SYSLNORM            BRANCH TO PUT IF YES
         LTR       R5,R5               HAS FILE BEEN WRITTEN BEFORE .Q
         BNZ       SYSLCC2             BRANCH IF YES
         BAL       R10,SYSLPUT         GET AN OUTPUT BUFFER
         BCTR      R6,0                DECREMENT LRECL BY ANOTHER
         EX        R6,SYSLBLNK         AND BLANK THE LINE
SYSLCC2  DS        0H
         CLI       0(R2),200           DO WE WANT AN EJECT .Q
         BL        SYSLSPCE            BRANCH LOW FOR SPACES
SYSLEJCT DS        0H
         MVI       0(R5),EJECTAP       PUT IN EJECT CODE
         B         SYSLNORM            CONTINUE AS USUAL
SYSLSPCE DS        0H
         SR        R7,R7               01 TO 54 FORCES THAT NUMBER
         IC        R7,0(,R2)           OF BLANK LINES (SPACES)
         CLI       0(R2),X'02'         SEE IF LESS THAN 2
         BH        SYSLTRIP            NO, SPACE 3 AT A TIME
         IC        R7,APTBL-1(R7)      01 OR 02 FORCES ONLY
         STC       R7,0(,R5)           NEW CODE IN PREVIOUS LINE
         B         SYSLNORM            CONTINUE AS NORMAL
SYSLTRIP DS        0H
         MVI       0(R5),SPACE3AP      03 TO 54 GENERATES MINIMUM
         S         R7,FW002            NUMBER OF LINES WITH
SYSLSPLP DS        0H                  SPACE IMMEDIATE CODES
         BAL       R10,SYSLPUT         PUT OUT 3 BLANK LINES
         BCTR      R6,0                DECREMENT BY ANOTHER ONE
         EX        R6,SYSLBLNK         BLANK ENTIRE LINE
         C         R7,FW003            ARE WE LESS THAN 3 .Q
         BNH       SYSLDBL             YES, PUT IN NUMBER SPACES LEFT
         MVI       0(R5),SPACE3IM      NO, SPACE ANOTHER 3
         S         R7,FW003            REDUCE COUNTER BY 3
         B         SYSLSPLP            LOOP
SYSLDBL  DS        0H
         IC        R7,IMTAB-1(R7)      PUT IN CORRECT SPACING
         STC       R7,0(,R5)           SAVE NUMBER OF SPACES
SYSLNORM DS        0H
         BAL       R10,SYSLPUT         PUT OUT RECORD
         MVI       0(R5),SPACE1AP      PUT IN NORMAL SPACE
         BCTR      R6,0                DECREMENT BY ANOTHER ONE
         EX        R6,SYSLMOVE         TRANSFER LINE TO BUFFER
SYSLRET  DS        0H
         STM       R4,R5,L1DCBRCT(R3)  RESTORE RECORD COUNT, POINTER
         LM        R14,R12,PUTSAVE     RESTORE CALLER'S REGISTERS
         BR        R14                 RETURN
SYSLPUT  DS        0H
         L         R15,L1DCBPAD(,R3)   GET REAL PUT ADDRESS
         LR        R1,R3               RESTORE DCB ADDRESS
         BALR      R14,R15             GO DO IT
         LR        R5,R1               SAVE POSITION OF NEXT RECORD
         LA        R4,1(,R4)           INCREMENT LINE COUNT
         LH        R6,DCBLRECL(,R3)    GET LRECL OF FILE
         BCTR      R6,0                DECREMENT BY ONE
         BR        R10                 RETURN
         SPACE     2
PUTSAVE  DC        15F'0'              PUT ROUTINE SAVE AREA
FW002    DC        F'2'                FULL WORD TWO
FW003    DC        F'3'                FULL WORD THREE
SYSLBLNK MVC       1(*-*,R5),BLANKS+1  MOVE BLANKS TO OUTPUT LINE
SYSLMOVE MVC       1(*-*,R5),1(R2)     TRANSFER LINE TO BUFFER
SYSLASIS MVC       0(*-*,R5),0(R2)     OUTPUT RECORD AS IS
CARCONT  DC        X'00'               WORK AREA FOR CARRIAGE CONTROL
APTBL    DC        AL1(SPACE2AP,SPACE3AP)        SPACE AFTER PRINT
IMTAB    DC        AL1(SPACE1IM,SPACE2IM,SPACE3IM)  SPACE IMMEDIATE TBL
SPACE0AP EQU       X'01'
SPACE1AP EQU       X'09'
SPACE2AP EQU       X'11'
SPACE3AP EQU       X'19'
EJECTAP  EQU       X'89'
SPACE0IM EQU       X'03'
SPACE1IM EQU       X'0B'
SPACE2IM EQU       X'13'
SPACE3IM EQU       X'1B'
EJECTIM  EQU       X'8B'
*
         EJECT
*
*        THIS ROUTINE IS ENTERED BY THE SYNAD EXIT ON AN I/O ERROR
*        R1 POINTS AT THE DCB FOR WHICH THE ERROR OCCURED
*
IOERR    DS        0H
         USING     *,R15
         STM       R11,R12,SAVE3       SAVE REGISTERS
         L         R12,=A(ASMGASM)     LOAD REGULAR BASE VALUE
         DROP      R15
         LA        R11,0(0,R1)         CLEAR TOP BYTE OF REG FOR COMPAR
         C         R11,LIST1+L1DCBADS+L1SPRINT  IS THIS SYSPRINT .Q
         BE        SYSPNTER
         C         R11,LIST1+L1DCBADS+L1SPUNCH  IS THIS SYSPUNCH .Q
         BE        SYSPCHER
         BNL       SYNADQ              SYSPUNCH & ABOVE ARE QSAM
         MVI       SYNADAF+12,2        SYNADAF ACSMETH CODE FOR BSAM
         C         R11,LIST1+L1DCBADS+L1SLIB  IS THIS SYSLIB .Q
         BNE       SYNADQ
         MVI       SYNADAF+12,1        SYNADAF ACSMETH CODE FOR BPAM
SYNADQ   DS        0H
         CNOP      0,4
SYNADAF  SYNADAF   ACSMETH=QSAM
         MVC         ABMESS+59(60),68(1) PICK UP PART OF MESSAGE I WANT
         MVI         ABMESS+119,C''''
         SYNADRLS    ,                 RELEASE SYNADAF BUFF & SAVE AREA
         MVI         AB3+1,X'00'       NOP SW TO TYPE AND PRINT
         B           AB2
*
SYSPCHER LH        R11,PCHERTOT        INCREMENT
         LA        R11,1(0,R11)        PCHERTOT
         STH       R11,PCHERTOT
         OI        ERRORSW,X'20'
         B         BACK1
*
SYSPNTER LH        R11,PRTERTOT        INCREMENT
         LA        R11,1(0,R11)        PRTERTOT
         STH       R11,PRTERTOT
         OI        ERRORSW,X'10'
*
BACK1    LM        R11,R12,SAVE3
         BR        R14                 RETURN TO I/O SUPERVISOR
         EJECT
*        THIS POINT IS ENTERED IF BUFF RUNS OUT OF CORE
BUFFERR  DS        0H
         USING     *,R1
         L         R12,=A(ASMGASM)
         DROP      R1
         BAL       R0,ABEND            PRINT ERROR AND ABEND
         DC        C'990I',AL1(L'MESS990-1)
MESS990  DC        C'INSUFFICIENT MEMORY TO BUFFER UTILITIES'
         EJECT
*
*        ABEND ROUTINE  (ACTUALLY ONLY DOES A RETURN WITH CC=20)
*        ENTER WITH R0 POINTING AT MESSAGE IN FOLLOWING FORMAT
*        DC        C'NNNX',AL1(L'MES-1)
* MES    DC        C'MESSAGE'
*                  NNN IS ERROR NUMBER, X IS 'BLANK', 'I' OR 'A'.
*
ABEND    LR        R1,R0               R1 -> PARMS NOW
         LA        R13,SAVE2           R13 -> OS SAVE AREA
         MVC       AB1+1(1),4(R1)      PLACE LENGTH IN MVC
         MVC       ABMESS+6(4),0(R1)   MOVE ERROR NUMBER
         MVC       ABMESS+13(132-13),ABMESS+12   BLANK LINE
AB1      MVC       ABMESS+13(*-*),5(R1) PLACE MESSAGE
         TM        SYSPRINT+DCBOFLGS,X'10' TEST IF PRINTER IS OPEN
         BO        AB4                 BRANCH IF OPEN
         TM        SYSTERM+DCBOFLGS,X'10'  TEST IF SYSTERM OPEN
         BO        AB6                 BRANCH IF SYSTERM OPEN
AB2      MVC       ABMESS+120(4),=X'02004020' PLACE ROUTE AND DESC CODE
         WTO       MF=(E,ABWTO)        TYPE THE MESSAGE
         MVC       ABMESS+120(12),BLANKS+1  REMOVE ROUTE & DESC CODES
AB3      BC        *-*+15,AB5          BYPASS PRINTING
AB4      DS        0H
         MVI       ABMESS,X'03'        NUMERIC SPACE 3 LINES AND PRINT
         NI        SYSPRINT+L1DCBCC,X'7F'  KILL ASA FLAG
         OI        SYSPRINT+L1DCBCC,X'40'  SET NUMERIC FLAG
         PUT       SYSPRINT,ABMESS     PUT ABEND MESSAGE
*
         TM        SYSTERM+DCBOFLGS,X'10'  IS SYSTERM OPEN .Q
         BZ        AB5                 NO, THEN DON'T PRINT THERE
*
AB6      DS        0H
         NI        SYSTERM+L1DCBCC,X'7F'  KILL ASA FLAG
         OI        SYSTERM+L1DCBCC,X'40'  SET NUMERIC FLAG
         PUT       SYSTERM,ABMESS      PUT ABEND MESSAGE
*
AB5      DS        0H
         AIF       (&DEBUG).AB1
         MVI       SYSINSW,X'80'       SIMULATE EOF ON SYSIN
         SR        R10,R10             ZERO R10 SO RTA MAY TERMINATE
         LA        R15,20              SET RETURN CODE TO 20
         ST        R15,SAVECC          AND PASS IT ON FOR LATER
         SVC       3                   RETURN SVC TO DELETE MODULE
         AGO       .AB2
.AB1     ANOP
         CLOSE     (SYSPRINT,LEAVE)    FORCE BUFFERS
         ABEND     20,DUMP
.AB2     ANOP
*
*./      DELETE    SEQ1=05300022,SEQ2=05360022
         EJECT
*
*        ASM PARAM LIST. ORDER-DEPENDENT. REFERENCED RELATIVE TO
*        'LIST1' BY OTHER PHASES.
*
*
         LIST1EQU
         CNOP      4,8                 DEFDDNAM SHOULD BE ON D BOUNDARY
LIST1    EQU       *
*
* LIST1+L1DCBADS
*
         DC        A(SYSLIN)
         DC        A(SYSTERM)
         DC        A(SYSUP)
         DC        A(SYSLIB)
         DC        A(SYSIN)
         DC        A(SYSPRINT)
         DC        A(SYSPUNCH)
         DC        A(SYSUT1)
         DC        A(SYSUT2)
         DC        X'80'               MARK THE LAST DCB ADDRESS
         DC        AL3(SYSUT3)
*
* LIST1+L1VACFL
*
         DC        A(0)                VACANT FULL WORD AREA
*
*
* LIST1+L1CTLPRM
*
         DC        A(0)                ADDR OF CNTRL PROG PARM LIST
*
* LIST1+L1TIMELM
*
*                  PARAMETERS FILLED BY F1 FROM EXEC CARD
         DC        F'0'          EXECUTION TIME IN SECONDS
*
* LIST1+L1LINECT
*
         DC        H'0'          LINE COUNT
*
* LIST1+L1PBYT1
*
PARBYT1  DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    FULLUPLIST   1    DOS
*                                 2    ESD          3    BATCH
*                                 4    FULLLIST     5    EXTEN
*                                 6    FULLXREF     7    ALGN
*
* LIST1+L1PBYT
*
PARBYT   DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    DECK         1    LOAD
*                                 2    RENT         3    LIST
*                                 4    RLD          5    UPLIST
*                                 6    XREF         7    TEST
*
* LIST1+L1PBYT2
*
PARBYT2  DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    LREF         1    UPDATE
*                                 2    EXECUTE      3    SPACE=MAX
*                                 4    TERM         5    NUM
*                                 6    STMT         7    RESERVED
*
* LIST1+L1PBYT3
*
PARBYT3  DC        X'00'         BIT   MEANING     BIT   MEANING
*                                 0    RESERVED     1    RESERVED
*                                 2    RESERVED     3    RESERVED
*                                 4    RESERVED     5    RESERVED
*                                 6    RESERVED     7    UNUSED
*
* LIST1+L1SYNERR
*
*        FOLLOWING 3 ITEMS SET BY SYNAD ROUTINE AND
*        AND MACRO TABLE BUILDER FOR ASMGFD.
ERRORSW  DC        X'0000'             ERROR SWITCHES IN TOP BYTE
*                            BIT  ERROR       BIT  ERROR
*                             0  204 SEV 16    1  204 SEV 4
*                             2    207         3    206
*                             4    208         5    209
*                             6    203         7   UNUSED
*                             8    ---         9    ---
*                            10    ---        11    ---
*                            12    ---        13    ---
*                            14    ---        15    115
*
* LIST1+L1IOERR
*
PCHERTOT DC        H'0'                COUNTS I/O ERRORS ON SYSPUNCH
PRTERTOT DC        H'0'                COUNTS I/O ERRS ON SYSPRINT
*
* LIST1+L1FINDCT
*
         DC        F'0'                FINDS ON SYSLIB COUNT
*
* LIST1+L1CALIGN
*
         DC        X'00',XL3'00'       COMMENT ALIGNMENT VALUE
*
* LIST1+L1BUFADR
*
BUFRTADR DC        V(BUFFENT)          ADDR OF SUPER BUFFER AND CORE   X
                             MANAGEMENT ROUTINE
*
* LIST1+L1DDNAM
*
*        TABLE OF DDNAMES. MAY BE ALTERED BY F1.
DEFDDNAM DC        C'SYSLIN  '
         DC        C'SYSTERM '
         DC        C'SYSUP   '
         DC        C'SYSLIB  '
         DC        C'SYSIN   '
         DC        C'SYSPRINT'
         DC        C'SYSPUNCH'
         DC        C'SYSUT1  '
         DC        C'SYSUT2  '
         DC        C'SYSUT3  '
*
* LIST1+L1PRDATE
*
         DC        C'DD MON YY'        SET TO DATE BY F1
*
* LIST1+L1UPCOND
*
         DC        X'00'               MAX UPDATE CONDITION CODE
*./      DELETE    SEQ1=07110025,SEQ2=07116025
*
* LIST1+L1ABEND
*
         USING     LIST1,R1
         L         R12,=A(ASMGASM)     THIS POINT ENTERED TO TYPE/PRINT
         B         ABEND                 MESSAGE AND ABEND
         DROP      R1
*
* LIST1+L1LSETC
*
         DC        X'00'               DEFAULT SETC VARIABLE LENGTH
*
* LIST1+L1COLCT
*
         DC        X'00'               COLUMN= COUNT FOR XREFS
*
* LIST1+L1BUFERR
*
         DC        A(BUFFERR)          BUFF ERROR HANDLING ROUTINE
*
* LIST1+L1SINAD
*
SYSINAD  DC        A(SYSINMON)         SYSIN MONITOR
DCBGETSV DC        2F'0'               SAVE FOR DCBGET IN SYSIN DCB
*
* LIST1+L1FREEMN
*
FREEMEM  DC        2F'0'               FREEMAIN OPERANDS  SET BY F1
*
* LIST1+L1ISADDR
*
         DC        F'0'                ADDRESS OF ASMGISXX MODULE
*
* LIST1+L1ISNAME
*
ISNAME   DC        C'ASMGISXX'         NAME OF THE INSTRUCTION SET MOD.
*
* LIST1+L1PRTIME
*
         DC        C'HH:MM:SS'         SET TO TIME BY F1
*
* LIST1+L1BTCSUM
*
BATCHSUM DC        A(0)                ADDRESS OF FIRST BATCH SUMMARY
*
* LIST1+L1ASPARM
*
ASYSPARM DC        F'0'                LENGTH AND ADDRESS OF SYSPARM
*
* LIST1+L1SAVECC
*
SAVECC   DC        F'0'                SAVES HIGHEST COND CODE RETURNED
*
* LIST1+L1BLDL-4
*
BLDLADDR DC        H'7'                SEVEN ENTRIES TO BUILD
         DC        H'36'               EACH ONE 36 BYTES LONG
         DC        CL8'ASMGFPP'        L1BLDL
         DC        14H'0'
         DC        CL8'ASMGF1'
         DC        14H'0'
         DC        CL8'ASMGF2'
         DC        14H'0'
         DC        CL8'ASMGF3'
         DC        14H'0'
         DC        CL8'ASMGF7'
         DC        14H'0'
         DC        CL8'ASMGF8'
         DC        14H'0'
         DC        CL8'ASMGRTA'
         DC        14H'0'
*                                      L1BLDL+7*L1LENBL
* LIST1+L1SINSW
*
SYSINSW  DC        X'00'               EOF AND $JOB SWITCHES
*                  X'80'               EOF
*                  X'40'               $JOB
*                  X'01'               CLOSE & OPEN AT CONCATENATION
*
* LIST1+L1RLSDTE
*
RELSDATE DC        C'21FEB74'          ASSEMBLER RELEASE DATE
*
* LIST1+L1ASDATE
*
ASYSDATE DC        C'LYYMONDD'         LENGTH & DATE IN INTERNAL CODE
*
* LIST1+L1ASTIME
*
ASYSTIME DC        C'HH:MM:SS'         TIME IN INTERNAL CODE
*
* LIST1+L1VERMOD
*
         DC        CL4'0207'           ASSEMBLER VERSION AND LEVEL
*
* LIST1+L1JDATE
*
         DC        CL6'YYDDDS'         TODAY'S JULIAN DATE
*
* LIST1+L1PID
*
         DC        CL10'ASMG21FEB'     PROGRAM IDENTIFICATION
*
* LIST1+L1TRSAVE
*
TRSAVE   DC        F'0'                SYSTERM LINES PER PAGE
         DC        A(0)                ADDRESS OF LAST LINE IN BUFFER
*
* LIST1+L1UTLINO
*
         DC        F'0'                LINE NUMBER FOR UPDATE FEATURE
*
* LIST1+L1PAGENO
*
         DC        F'0'                PAGE NUMBER FOR SYSPRINT
*
* LIST1+L1LENMC
*
         DC        F'0'                LENGTH OF MACRO DRCTRY D ALIGNED
*
* LIST1+L1BOTMC
*
         DC        F'0'                BOTTOM OF MACRO DIRECTORY
*
* LIST1+L1TOPMC
*
         DC        F'0'                TOP ENTRY IN MACRO DIRECTORY
*
*
* LIST1+L1OUTRTN
*
         USING     *,R15               ENTRY ADDRESS SET BY PUT
         L         R15,=A(ASMGASM)     CHANGE BASE ADDRESSES
         USING     ASMGASM,R15         TRANSFER BASE
         B         ASMGPUT             BRANCH TO GENERAL PUT ROUTINE
         DROP      R15
*
* LIST1+L1DPTRTN
*
         BR        R14                 RETURN IMMEDIATELY
*
* LIST1+L1BLANKS
*
BLANKS   DC        X'00',CL133' '      ZERO FOLLOWED BY BLANKS
*
* LIST1+L1$JOB
*
$JOB     DC        CL5'$JOB '          BATCH,EXECUTE JOB SEPARATOR
*
* LIST1+L1PATCH
*
         DC        41S(*)              COMMON PATCH, ASMGASM/ASMGBUFF
*                                      ALIGNING TO 2K MULTIPLE.
*
*
*        LIST1 ENDS HERE
*
         EJECT
SAVE1    DC        F'0'                POINTER TO INVOKER'S SAVE AREA
*        THE FOLLOWING SAVE AREA IS USED BY ASM, RTA AND ABEND
SAVE2    DS        18F                 OS SAVE AREA
         SPACE     2
         ORG       SAVE2               OVERLAY SAVE AREA
INITIAL  STM       R14,R12,12(R13)     SAVE REGISTERS IN CALLER'S AREA
         LR        R12,R15             SET R12 AS THE BASE
         ST        R13,SAVE1           SAVE CONTROL PROGRAM SAVE AREA
         ST        R1,LIST1+L1CTLPRM   SAVE ADDR OF CTL PROG PARAM LIST
         LA        R13,SAVE2           SET SAVE AREA ADDRESS
         SR        R10,R10             TURN BATCH SWITCH OFF IN F1
         BLDL      0,BLDLADDR          DO BLDL ON LOAD MODULES
         LTR       R15,R15             WAS IT SUCCESSFUL .Q
         BZ        INITLINK            YES, INITIALIZE LINK TO ASMGF1
         L         R1,SYS806           LOAD DUMP MASK
         ABEND     (1)                 SYSTEM ABEND 806
         DS        0F                  ALIGNMENT
SYS806   DC        X'80806000'         SYSTEM 806 WITH DUMP
INITLINK DS        0H
         ENTRYOUT  ASM
         LA        R9,LIST1            PASS LIST1 ADDRESS TO ASMGF1
         LA        R15,F1LINK          LINK ARGUMENT LIST
         B         DONEINIT            GO BACK AND LINK
         ORG
SAVE3    DS        2F                  SAVE AREA FOR I/O ERROR ROUTINE
         ORG       SAVE3               BACK UP
F1LINK   DS        0F                  ALIGN THE LINK ARG LIST
         DC        X'80'               SET DE SWITCH BIT ON
         DC        AL3(LIST1+L1BLDL+L1LENBL)  DE PARAMETER
         DC        A(0)                DCB ADDRESS PARAMETER
         ORG
         SPACE     2
         LTORG
         EJECT
*
*        DCB'S ARE GENERATED HERE
*
DCBBUFNO EQU       20                  NUMBER OF BUFFERS
DCBBUFCB EQU       21                  ADDR OF BUFFER CONTROL BLOCK
DCBEODAD EQU       32                  EODAD EXIT ADDRESS
DCBRECFM EQU       36                  RECORD FORMAT
DCBDDNAM EQU       40                  DD NAME POSITION WITHIN DCB
DCBOFLGS EQU       48                  DCB OPEN FLAGS
DCBGET   EQU       48                  DCB GET ADDRESS
DCBBLKSI EQU       62                  BLOCK SIZE
DCBLRECL EQU       82                  LOGICAL RECORD LENGTH
*
*
         SPACE     2
***********************************************************************
*        EACH DCB IS FOLLOWED BY A WORK AREA FOR THAT FILE            *
*        AT DCB + L1DCBRCT  -  F'A COUNT OF RECORDS PASSED'           *
*               + L1DCBLPT  -  A(LAST RECORD POINTER IN LOCATE MODE)  *
*               + L1DCBCC   -  X'CARRIAGE CONTROL INDICATOR'          *
*                           -  X'C0'        ASA                       *
*                           -  X'40'        NUMERIC                   *
*                           -  X'00'        NONE                      *
*               + L1DCBPAD  -  X'08'    MONITOR FOR PUTS              *
*                           -  X'04'    MONITOR FOR GETS              *
*                           -  X'02'    SUMMARY OF PUT RECORDS AT END *
*                           -  X'01'    SUMMARY OF GET RECORDS AT END *
*                           -  AL3(REAL GET/PUT ADDRESS)              *
***********************************************************************
*
*        DATA CONTROL BLOCK FOR SYSUT1
SYSUT1   DCB       DDNAME=SYSUT1,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X
               SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUT1+L1DCBBLK
         DC        H'0'                SYSUT1 BLKSIZE FROM JFCB
         DC        F'0'                RECORD COUNT FOR SYSUT1
         DC        A(0)                LAST RECORD POINTER
         DC        X'00'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSUT2
SYSUT2   DCB       DDNAME=SYSUT2,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X
               SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUT2+L1DCBBLK
         DC        H'0'                SYSUT2 BLKSIZE FROM JFCB
         DC        F'0'                RECORD COUNT FOR SYSUT2
         DC        A(0)                LAST RECORD POINTER
         DC        X'00'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSUT3
SYSUT3   DCB       DDNAME=SYSUT3,MACRF=(RP,WP),RECFM=U,DSORG=PS,       X
               SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUT3+L1DCBBLK
         DC        H'0'                SYSUT3 BLKSIZE FROM JFCB
         DC        F'0'                RECORD COUNT FOR SYSUT3
         DC        A(0)                LAST RECORD POINTER
         DC        X'00'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSLIB
SYSLIB   DCB       DDNAME=SYSLIB,MACRF=(R),RECFM=F,DSORG=PO,           X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSLIB+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSLIB
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08514026,SEQ2=08514026
         DC        X'01'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSPUNCH
SYSPUNCH DCB       DDNAME=SYSPUNCH,MACRF=(PL),RECFM=F,DSORG=PS,        X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSPUNCH+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSPUNCH
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08614026,SEQ2=08614026
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSPRINT
SYSPRINT DCB       DDNAME=SYSPRINT,MACRF=(PL),RECFM=FM,DSORG=PS,       X
               LRECL=0,EROPT=ACC,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSPRINT+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSPRINT
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08714026,SEQ2=08714026
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSIN
SYSIN    DCB       DDNAME=SYSIN,MACRF=(GL),RECFM=F,DSORG=PS,           X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSIN+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSIN
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08814026,SEQ2=08814026
         DC        X'05'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSLIN
SYSLIN   DCB       DDNAME=SYSLIN,MACRF=(PL),RECFM=F,DSORG=PS,          X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSLIN+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSLIN
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08900726,SEQ2=08900726
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSTERM
SYSTERM  DCB       DDNAME=SYSTERM,MACRF=(PL),RECFM=FM,DSORG=PS,        X
               LRECL=0,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSTERM+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSTERM
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08905726,SEQ2=08905726
         DC        X'0A'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
*        DATA CONTROL BLOCK FOR SYSUP
SYSUP    DCB       DDNAME=SYSUP,MACRF=(GL),RECFM=F,DSORG=PS,           X
               LRECL=80,SYNAD=IOERR,EXLST=EXITLIST
         ORG       SYSUP+L1DCBRCT
         DC        F'0'                RECORD COUNT FOR SYSUP
         DC        A(0)                LAST RECORD POINTER
*./      DELETE    SEQ1=08917026,SEQ2=08917026
         DC        X'05'               CARRIAGE CONT/MONITOR IND
         DC        AL3(0)              REAL GET/PUT ADDRESS
*
*
         END       ASMGASM
./ ADD NAME=ASMJCL   0103-88330-88357-1256-00056-00057-00001-CHSY227
//CHSYASMG JOB   (0227,CHSY),'FOCHTMAN - SYSTEMS',
//         CLASS=S,NOTIFY=CHSY227,MSGCLASS=X
//ASM      PROC  MEMBER=
//ASM      EXEC  PGM=IEV90,
//         PARM='BATCH,DECK,NOOBJ,TERM,NOLIST',
//         REGION=4096K
//SYSTERM  DD    SYSOUT=C,HOLD=YES
//SYSLIB   DD    DSN=CHSY227.ASMG.SRCE,DISP=SHR
//         DD    DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD    UNIT=VIO,SPACE=(CYL,(3,1))
//SYSPUNCH DD    DSN=CHSY227.ASMG.OBJ(&MEMBER),DISP=SHR
//SYSIN    DD    DSN=CHSY227.ASMG.SRCE(&MEMBER),DISP=SHR
//         PEND
//ASMGASM  EXEC  ASM,MEMBER=ASMGASM
//ASMGBUFF EXEC  ASM,MEMBER=ASMGBUFF
//ASMGFD   EXEC  ASM,MEMBER=ASMGFD
//ASMGFEX  EXEC  ASM,MEMBER=ASMGFEX
//ASMGFI   EXEC  ASM,MEMBER=ASMGFI
//ASMGFPP  EXEC  ASM,MEMBER=ASMGFPP
//ASMGF1   EXEC  ASM,MEMBER=ASMGF1
//ASMGF2   EXEC  ASM,MEMBER=ASMGF2
//ASMGF2A  EXEC  ASM,MEMBER=ASMGF2A
//ASMGF3   EXEC  ASM,MEMBER=ASMGF3
//ASMGF7C  EXEC  ASM,MEMBER=ASMGF7C
//ASMGF7D  EXEC  ASM,MEMBER=ASMGF7D
//ASMGF7E  EXEC  ASM,MEMBER=ASMGF7E
//ASMGF7G  EXEC  ASM,MEMBER=ASMGF7G
//ASMGF7I  EXEC  ASM,MEMBER=ASMGF7I
//ASMGF7L  EXEC  ASM,MEMBER=ASMGF7L
//ASMGF7N  EXEC  ASM,MEMBER=ASMGF7N
//ASMGF7S  EXEC  ASM,MEMBER=ASMGF7S
//ASMGF7V  EXEC  ASM,MEMBER=ASMGF7V
//ASMGF7X  EXEC  ASM,MEMBER=ASMGF7X
//ASMGF8A  EXEC  ASM,MEMBER=ASMGF8A
//ASMGF8C  EXEC  ASM,MEMBER=ASMGF8C
//ASMGF8D  EXEC  ASM,MEMBER=ASMGF8D
//ASMGF8I  EXEC  ASM,MEMBER=ASMGF8I
//ASMGF8L  EXEC  ASM,MEMBER=ASMGF8L
//ASMGF8M  EXEC  ASM,MEMBER=ASMGF8M
//ASMGF8N  EXEC  ASM,MEMBER=ASMGF8N
//ASMGF8P  EXEC  ASM,MEMBER=ASMGF8P
//ASMGF8S  EXEC  ASM,MEMBER=ASMGF8S
//ASMGF8V  EXEC  ASM,MEMBER=ASMGF8V
//ASMGIS00 EXEC  ASM,MEMBER=ASMGIS00
//ASMGIS02 EXEC  ASM,MEMBER=ASMGIS02
//ASMGIS09 EXEC  ASM,MEMBER=ASMGIS09
//ASMGIS11 EXEC  ASM,MEMBER=ASMGIS11
//ASMGIS20 EXEC  ASM,MEMBER=ASMGIS20
//ASMGIS44 EXEC  ASM,MEMBER=ASMGIS44
//ASMGIS60 EXEC  ASM,MEMBER=ASMGIS60
//ASMGIS67 EXEC  ASM,MEMBER=ASMGIS67
//ASMGIS70 EXEC  ASM,MEMBER=ASMGIS70
//ASMGIS71 EXEC  ASM,MEMBER=ASMGIS71
//ASMGMACP EXEC  ASM,MEMBER=ASMGMACP
//ASMGRTA  EXEC  ASM,MEMBER=ASMGRTA
//ASMGUP   EXEC  ASM,MEMBER=ASMGUP
./ ADD NAME=INSTJCL
//ASMG#0   JOB  'C0018R.V.PETERSEN,TIME=5,CARDS=1500,PAGES=50',
//             MSGLEVEL=(1,1)
//*
//*                THIS JOB PUNCHES AND PRINTS THE ASMG.JCL DATASET.
//*                THAT DATASET CONTAINS SAMPLE JOBS FOR PUTTING
//*                ASMG INTO YOUR SYSTEM, TESTING IT, AND MODIFYING
//*                IT IF NECESSARY.
//*
//         EXEC PGM=IEBUPDTE,REGION=40K
//SYSPRINT DD   SYSOUT=A
//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,
//             DSNAME=ASMG.JCL
//SYSUT2   DD   SYSOUT=B
//SYSIN    DD   *
><       REPRO     LIST=ALL
><       ENDUP
/*





//ASMG#1   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)
//*
//*                THIS JOB MOVES ASMG.LOADMODS TO THE DISK UNDER
//*                THE SAME NAME AND CATALOGS IT.
//*
//         EXEC PGM=IEHMOVE,REGION=100K
//SYSPRINT DD   SYSOUT=A
//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD
//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD
//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),
//             DSN=ASMG.LOADMODS,SPACE=(7294,(40,,3)),
//             DCB=(RECFM=U,BLKSIZE=7294)
//SYSIN    DD   *
         COPY      PDS=ASMG.LOADMODS,FROM=2400=(ASMG27,2),             X
               TO=2314=333333
/*
//         EXEC PGM=IEHPROGM,REGION=44K
//SYSPRINT DD   SYSOUT=A
//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD
//SYSIN    DD   *
         CATLG     DSNAME=ASMG.LOADMODS,VOL=2314=333333
/*





//ASMG#2   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)
//*
//*                THIS JOB MOVES ASMG.SOURCE, ASMG.OBJMODS,
//*                ASMG.MACROLIB, ASMG.LKEDIN AND ASMG27A.UPDATE
//*                TO DISK AND CATALOGUES THEM.
//*
//         EXEC PGM=IEHMOVE,REGION=100K
//SYSPRINT DD   SYSOUT=A
//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=777777,DISP=OLD
//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD
//DD30     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),
//             DSN=ASMG.SOURCE,SPACE=(3360,(1200,,3)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)
//DD31     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),
//             DSN=ASMG.OBJMODS,SPACE=(3200,(200,,3)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//DD32     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),
//             DSN=ASMG.MACROLIB,SPACE=(3360,(100,,5)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)
//DD33     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),
//             DSN=ASMG.LKEDIN,SPACE=(80,(200,,3)),
//             DCB=(RECFM=F,LRECL=80,BLKSIZE=80)
//DD34     DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=(NEW,KEEP),
//             DSN=ASMG27A.UPDATE,SPACE=(3360,(60,,3)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3360)
//SYSIN    DD   *
         COPY  PDS=ASMG.SOURCE,FROM=2400=(ASMG27,5),TO=2314=333333
         COPY  PDS=ASMG.OBJMODS,FROM=2400=(ASMG27,6),TO=2314=333333
         COPY  PDS=ASMG.MACROLIB,FROM=2400=(ASMG27,7),TO=2314=333333
         COPY  PDS=ASMG.LKEDIN,FROM=2400=(ASMG27,8),TO=2314=333333
         COPY  PDS=ASMG27A.UPDATE,FROM=2400=(ASMG27,9),TO=2314=333333
/*
//         EXEC PGM=IEHPROGM,REGION=44K
//SYSPRINT DD   SYSOUT=A
//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD
//SYSIN    DD   *
         CATLG     DSNAME=ASMG.SOURCE,VOL=2314=333333
         CATLG     DSNAME=ASMG.OBJMODS,VOL=2314=333333
         CATLG     DSNAME=ASMG.MACROLIB,VOL=2314=333333
         CATLG     DSNAME=ASMG.LKEDIN,VOL=2314=333333
         CATLG     DSNAME=ASMG27A.UPDATE,VOL=2314=333333
/*





//ASMG#3  JOB   'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)
//*
//*                THIS JOB TESTS THE BATCH-EXECUTE FEATURES.
//*                NOTE THAT THE MACROS WOULD NORMALLY BE IN A
//*                SYSLIB DATASET.
//*
//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=SHR
//ASM      EXEC PGM=ASMGASM,PARM='B,EXEC,NOLO',REGION=120K
//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),
//             SPACE=(3500,(400,50))
//SYSPRINT DD   SYSOUT=A,DCB=LRECL=133   ***LRECL CHANGED FOR EXECUTE
//SYSPUNCH DD   SYSOUT=B
//SYSTERM  DD   SYSOUT=A
//SYSLIN   DD   DSN=&LOADSET,UNIT=SYSSQ,SPACE=(3200,(10,5)),
//             DISP=(MOD,PASS)
//ASM.SYSIN DD  *
*JOB
         BR        14
*THIS WILL WORK WITH A GENERATED $JOB CARD
         END
$JOB
         DC        H'0'
         BR        14
*        THIS WILL NOT
         END
$JOB   ASMG   C0018R.V.PETERSEN
*        THIS ONE SHOULD ASSEMBLE AND EXECUTE SUCCESSFULLY
         PRINT     ON
         MACRO
&LABEL   COMMENCE  &EOF=
&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS
         BALR      12,0 .              ESTABLISH THE BASE
         USING     *,12 .              AND TELL THE ASSEMBLER
         LR        15,13 .             REMEMBER CALLER'S SAVE AREA
         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA
         ST        13,8(15) .          TELL THE CALLER
         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA
         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST
         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q
         L         1,16(0,1) .         POINT TO SYSIN DCB
         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD
.NOEOF   ANOP
         LA        1,50 .              50 LINES PER PAGE FOR USER
         ST        1,ZZZLINES .        AND REMEMBER IT
         B         ZZAROUND .          BRANCH AROUND DATA
ZZZDUMMY DS        D .                 DUMMY CONVERT AREA
ZZZZTEMP DS        4F .                TEMPORARY SAVE AREA
ZZZZSAVE DS        18F .               MY SAVE AREA
ZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE
ZZZINPUT DS        CL80 .              CARD INPUT AREA
ZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA
ZZAROUND DS        0H
         MEND
         MACRO
&LABEL   RD        &INPUT,&NUMBER=8,&EOF=
         LCLA      &TNUM
&TNUM    SETA      &NUMBER
         AIF       (&TNUM GE 1).NEXT1
         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'
&TNUM    SETA      1
.NEXT1   AIF       (&TNUM LE 8).NEXT2
         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'
&TNUM    SETA      8
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS
         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST
         L         1,16(,1) .          POINT TO SYSIN DCB
         AIF       (K'&EOF EQ 0).NOEOF
         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT
         LR        2,1 .               REMEMBER DCB ADDR OVER GET
         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD
.NOEOF   ANOP
         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA
         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB
         BALR      14,15 .             DO THE GET
         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED
         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS
.NOEOD   ANOP
         SR        3,3 .               ZERO A NUMBER COUNTER
         LA        14,ZZZINPUT .       POINT TO CARD IMAGE
         LA        15,&INPUT .         POINT TO TARGET
.LOOP1   NI        9(14),X'0F' .       REMOVE THE SIGN
         CLI       0(14),C'-' .        IS NUMBER NEGATIVE
         BNE       *+8 .LOOP2          NO
         OI        9(14),X'D0' .       MAKE IT NEGATIVE
.LOOP2   OI        9(14),X'C0' .       MAKE IT POSITIVE
         PACK      ZZZDUMMY,1(9,14) .  CONVERT TO DECIMAL
         CVB       2,ZZZDUMMY .        CONVERT TO BINARY
         ST        2,0(,15) .          ENTER NUMBER IN TARGET
         LA        15,4(,15) .         INCREMENT TARGET
         LA        14,10(,14) .        INCREMENT CARD FIELD
         LA        3,1(,3) .           INCREMENT NUMBER COUNT
         LA        2,&TNUM .           GET TOTAL NUMBER TO BE CONVERTED
         CR        3,2 .               ARE WE DONE .Q
         BNE       *-52 .LOOP1         NO, DO NEXT NUMBER
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   PRNT      &OUTPUT,&NUMBER=8
         LCLA      &TNUM
&TNUM    SETA      &NUMBER
         AIF       (&TNUM GE 1).NEXT1
         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'
&TNUM    SETA      1
.NEXT1   AIF       (&TNUM LE 10).NEXT2
         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'
&TNUM    SETA      10
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE FOUR WORK REGISTERS
         LA        14,&OUTPUT .        GET ADDRESS OF SOURCE
         MVI       ZZOUTPUT,C' ' .     BLANK OUTPUT FIELD
         MVC       ZZOUTPUT+1(132),ZZOUTPUT THE WHOLE FIELD
         LA        15,ZZOUTPUT .       POINTER TO OUTPUT FIELD
         SR        3,3 .               ZERO A NUMBER COUNT
.LOOP1   L         2,0(,14) .          GET A NUMBER FOR OUTPUT
         LTR       2,2 .               TEST ITS SIGN
         BNL       *+12 .LOOP2         IS IT POSITIVE
         MVI       2(15),C'-' .        NO IT IS NEGATIVE
         B         *+8 .LOOP3          BRANCH AROUND
.LOOP2   MVI       2(15),C'+' .        IT IS POSITIVE
.LOOP3   CVD       2,ZZZDUMMY .        CONVERT TO DECIMAL
         UNPK      3(10,15),ZZZDUMMY . CONVERT IT TO ZONED
         OI        12(15),X'F0' .      SET ZONE SIGN POSITIVE
         LA        14,4(,14) .         INCREMENT SOURCE FIELD
         LA        15,12(,15) .        INCREMENT TARGET FIELD
         LA        3,1(,3) .           INCREMENT NUMBER OF NUMBERS
         LA        2,&TNUM .           GET TOTAL NUMBER OF NUMBERS
         CR        3,2 .               ARE WE DONE .Q
         BNE       *-54 .LOOP1         NO, DO NEXT NUMBER
         L         3,ZZZLINES .        GET LINES LEFT ON PAGE
         BCT       3,*+12 .LOOP4       DECREMENT AND TEST
         LA        3,50 .              RESTORE PAGE SIZE
         MVI       ZZOUTPUT,C'1'       SKIP TO NEW PAGE
.LOOP4   ST        3,ZZZLINES .        UPDATE LINES LEFT COUNT
         L         1,ZZZZSAVE .        POINT TO ASMG DCB LIST
         L         1,20(,1) .          GET SYSPRINT DCB ADDRESS
         LA        0,ZZOUTPUT .        POINT TO OUTPUT LINE
         L         15,48(,1) .         GET PUT ADDRESS FROM DCB
         BALR      14,15 .             DO THE PUT
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   FINISH    &RC=0
&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA
         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS
         LA        15,&RC .            SET RETURN CODE
         BR        14 .                RETURN TO CALLER
         MEND
         PRINT     ON,NOGEN
START    COMMENCE  EOF=ENDFILE
LOOP     EQU       *
         RD        INPUT
         PRNT      INPUT
         B         LOOP
ENDFILE  FINISH
INPUT    DC        10F'0'
         END       START
+123456789-987654321+000000000-111111111+222222222+333333333+444444444+5
+123456789
+987654321
H012345678
+876543210
$JOB     ASMG      C0032D.G.POTTER
*        THIS ONE SHOULD GET AN INVALID OPCODE
         PRINT     OFF
         MACRO
&LABEL   COMMENCE  &EOF=
&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS
         BALR      12,0 .              ESTABLISH THE BASE
         USING     *,12 .              AND TELL THE ASSEMBLER
         LR        15,13 .             REMEMBER CALLER'S SAVE AREA
         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA
         ST        13,8(15) .          TELL THE CALLER
         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA
         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST
         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q
         L         1,16(0,1) .         POINT TO SYSIN DCB
         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD
.NOEOF   ANOP
         LA        1,50 .              50 LINES PER PAGE FOR USER
         ST        1,ZZZLINES .        AND REMEMBER IT
         B         ZZAROUND .          BRANCH AROUND DATA
ZZZDUMMY DS        D .                 DUMMY CONVERT AREA
ZZZZTEMP DS        4F .                TEMPORARY SAVE AREA
ZZZZSAVE DS        18F .               MY SAVE AREA
ZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE
ZZZINPUT DS        CL80 .              CARD INPUT AREA
ZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA
ZZAROUND DS        0H
         MEND
         MACRO
&LABEL   FINISH    &RC=0
&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA
         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS
         LA        15,&RC .            SET RETURN CODE
         BR        14 .                RETURN TO CALLER
         MEND
         PRINT     ON,NOGEN
         COMMENCE
         L         3,=A(AD)
         MVC       0(4,3),=C'FLAG'
         L         3,AX
         BR        3
         DS        0F
AD       DC        4C' '
AY       DC        4C' '
AQ       DC        V(NCSC)
AX       DC        X'00',AL3(FF)
         LTORG
FF       MVC       AY,=C'LAGF'
         L         3,AQ
         BR        3
NCSC     CSECT
         USING     *,3
         L         4,=V(AQ)
         MVC       0(4,4),=C'AAAA'
         ENTRY     AQ
         LD        0,=D'-95.387'
         LD        2,=D'.0000692'
         LD        4,=D'987654321'
         LD        6,=D'0'
         DC        X'00'
         FINISH
         END
$JOB     ASMG      C0018R.V.PETERSEN
*        THIS ONE SHOULD GET A TIMER OVERFLOW
         BALR      3,0
         BR        3
         END
$JOB     ASMG      C0032D.G.POTTER
*        THIS ONE SHOULD GET AN END-OF-FILE ON SYSIN
         PRINT     OFF
         MACRO
&LABEL   COMMENCE  &EOF=
&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS
         BALR      12,0 .              ESTABLISH THE BASE
         USING     *,12 .              AND TELL THE ASSEMBLER
         LR        15,13 .             REMEMBER CALLER'S SAVE AREA
         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA
         ST        13,8(15) .          TELL THE CALLER
         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA
         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST
         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q
         L         1,16(0,1) .         POINT TO SYSIN DCB
         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD
.NOEOF   ANOP
         LA        1,50 .              50 LINES PER PAGE FOR USER
         ST        1,ZZZLINES .        AND REMEMBER IT
         B         ZZAROUND .          BRANCH AROUND DATA
ZZZDUMMY DS        D .                 DUMMY CONVERT AREA
ZZZZTEMP DS        4F .                TEMPORARY SAVE AREA
ZZZZSAVE DS        18F .               MY SAVE AREA
ZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE
ZZZINPUT DS        CL80 .              CARD INPUT AREA
ZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA
ZZAROUND DS        0H
         MEND
         MACRO
&LABEL   RD        &INPUT,&NUMBER=8,&EOF=
         LCLA      &TNUM
&TNUM    SETA      &NUMBER
         AIF       (&TNUM GE 1).NEXT1
         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'
&TNUM    SETA      1
.NEXT1   AIF       (&TNUM LE 8).NEXT2
         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'
&TNUM    SETA      8
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS
         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST
         L         1,16(,1) .          POINT TO SYSIN DCB
         AIF       (K'&EOF EQ 0).NOEOF
         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT
         LR        2,1 .               REMEMBER DCB ADDR OVER GET
         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD
.NOEOF   ANOP
         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA
         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB
         BALR      14,15 .             DO THE GET
         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED
         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS
.NOEOD   ANOP
         SR        3,3 .               ZERO A NUMBER COUNTER
         LA        14,ZZZINPUT .       POINT TO CARD IMAGE
         LA        15,&INPUT .         POINT TO TARGET
.LOOP1   NI        9(14),X'0F' .       REMOVE THE SIGN
         CLI       0(14),C'-' .        IS NUMBER NEGATIVE
         BNE       *+8 .LOOP2          NO
         OI        9(14),X'D0' .       MAKE IT NEGATIVE
.LOOP2   OI        9(14),X'C0' .       MAKE IT POSITIVE
         PACK      ZZZDUMMY,1(9,14) .  CONVERT TO DECIMAL
         CVB       2,ZZZDUMMY .        CONVERT TO BINARY
         ST        2,0(,15) .          ENTER NUMBER IN TARGET
         LA        15,4(,15) .         INCREMENT TARGET
         LA        14,10(,14) .        INCREMENT CARD FIELD
         LA        3,1(,3) .           INCREMENT NUMBER COUNT
         LA        2,&TNUM .           GET TOTAL NUMBER TO BE CONVERTED
         CR        3,2 .               ARE WE DONE .Q
         BNE       *-52 .LOOP1         NO, DO NEXT NUMBER
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   PRNT      &OUTPUT,&NUMBER=8
         LCLA      &TNUM
&TNUM    SETA      &NUMBER
         AIF       (&TNUM GE 1).NEXT1
         MNOTE     0,'NUMBER PARAMETER WAS TOO SMALL'
&TNUM    SETA      1
.NEXT1   AIF       (&TNUM LE 10).NEXT2
         MNOTE     0,'NUMBER PARAMETER WAS TOO BIG'
&TNUM    SETA      10
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE FOUR WORK REGISTERS
         LA        14,&OUTPUT .        GET ADDRESS OF SOURCE
         MVI       ZZOUTPUT,C' ' .     BLANK OUTPUT FIELD
         MVC       ZZOUTPUT+1(132),ZZOUTPUT THE WHOLE FIELD
         LA        15,ZZOUTPUT .       POINTER TO OUTPUT FIELD
         SR        3,3 .               ZERO A NUMBER COUNT
.LOOP1   L         2,0(,14) .          GET A NUMBER FOR OUTPUT
         LTR       2,2 .               TEST ITS SIGN
         BNL       *+12 .LOOP2         IS IT POSITIVE
         MVI       2(15),C'-' .        NO IT IS NEGATIVE
         B         *+8 .LOOP3          BRANCH AROUND
.LOOP2   MVI       2(15),C'+' .        IT IS POSITIVE
.LOOP3   CVD       2,ZZZDUMMY .        CONVERT TO DECIMAL
         UNPK      3(10,15),ZZZDUMMY . CONVERT IT TO ZONED
         OI        12(15),X'F0' .      SET ZONE SIGN POSITIVE
         LA        14,4(,14) .         INCREMENT SOURCE FIELD
         LA        15,12(,15) .        INCREMENT TARGET FIELD
         LA        3,1(,3) .           INCREMENT NUMBER OF NUMBERS
         LA        2,&TNUM .           GET TOTAL NUMBER OF NUMBERS
         CR        3,2 .               ARE WE DONE .Q
         BNE       *-54 .LOOP1         NO, DO NEXT NUMBER
         L         3,ZZZLINES .        GET LINES LEFT ON PAGE
         BCT       3,*+12 .LOOP4       DECREMENT AND TEST
         LA        3,50 .              RESTORE PAGE SIZE
         MVI       ZZOUTPUT,C'1'       SKIP TO NEW PAGE
.LOOP4   ST        3,ZZZLINES .        UPDATE LINES LEFT COUNT
         L         1,ZZZZSAVE .        POINT TO ASMG DCB LIST
         L         1,20(,1) .          GET SYSPRINT DCB ADDRESS
         LA        0,ZZOUTPUT .        POINT TO OUTPUT LINE
         L         15,48(,1) .         GET PUT ADDRESS FROM DCB
         BALR      14,15 .             DO THE PUT
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   FINISH    &RC=0
&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA
         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS
         LA        15,&RC .            SET RETURN CODE
         BR        14 .                RETURN TO CALLER
         MEND
         PRINT     ON,NOGEN
         COMMENCE
         L         3,=A(ADD)
         BR        3
ADD      RD        IN
         L         3,IN
         A         3,IN+4
         ST        3,IN+8
         PRNT      IN,NUMBER=3
         RD        IN
         FINISH
IN       DS        0D
         DS        CL80
         END
+        1+        2
$JOB     ASMG      C0018B.UTTLEY
*        THIS JOB PRINTS A LINE OF 133 CHARACTERS WITH CARR CONTROL
         PRINT     ON
         MACRO
&LABEL   COMMENCE  &EOF=
&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS
         BALR      12,0 .              ESTABLISH THE BASE
         USING     *,12 .              AND TELL THE ASSEMBLER
         LR        15,13 .             REMEMBER CALLER'S SAVE AREA
         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA
         ST        13,8(15) .          TELL THE CALLER
         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA
         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST
         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q
         L         1,16(0,1) .         POINT TO SYSIN DCB
         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD
.NOEOF   ANOP
         LA        1,50 .              50 LINES PER PAGE FOR USER
         ST        1,ZZZLINES .        AND REMEMBER IT
         B         ZZAROUND .          BRANCH AROUND DATA
ZZZDUMMY DS        D .                 DUMMY CONVERT AREA
ZZZZTEMP DS        4F .                TEMPORARY SAVE AREA
ZZZZSAVE DS        18F .               MY SAVE AREA
ZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE
ZZZINPUT DS        CL80 .              CARD INPUT AREA
ZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA
ZZAROUND DS        0H
         MEND
         MACRO
&LABEL   GETT      &INPUT,&LENGTH=80,&EOF=
         LCLA      &TLEN
&TLEN    SETA      &LENGTH
         AIF       (&TLEN GE 1).NEXT1
         MNOTE     0,'LENGTH PARAMETER WAS TOO SMALL'
&TLEN    SETA      80
.NEXT1   AIF       (&TLEN LE 80).NEXT2
         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'
&TLEN    SETA      80
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS
         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST
         L         1,16(,1) .          POINT TO SYSIN DCB
         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED
         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT
         LR        2,1 .               REMEMBER DCB ADDR OVER GET
         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD
.NOEOF   ANOP
         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA
         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB
         BALR      14,15 .             DO THE GET
         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED
         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS
.NOEOD   ANOP
         MVC       &INPUT.(&TLEN),ZZZINPUT TRANSFER TO USER'S AREA
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   PUTT      &A,&LENGTH=121
         LCLA      &TLEN
&TLEN    SETA      &LENGTH
         AIF       (&TLEN GE 1).NEXT1
         MNOTE     0,'LENGTH PARAMETER TOO SMALL'
&TLEN    SETA      121
.NEXT1   AIF       (&TLEN LE 133).NEXT2
         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'
&TLEN    SETA      133
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE SOME WORK REGISTERS
         MVI       ZZOUTPUT,C' ' .     INITIALIZE THE OUTPUT AREA
         MVC       ZZOUTPUT+1(132),ZZOUTPUT ALL OF IT
         MVC       ZZOUTPUT(&LENGTH),&A MOVE OUTPUT LINE
         L         3,ZZZLINES .        LOAD NUMBER OF LINES LEFT
         CLI       ZZOUTPUT,C'1' .     NEW PAGE .Q
         BNE       *+12 .LOOP1         BRANCH IF NO
         LA        3,1 .               ZERO THE LINES LEFT
         B         *+44 .LOOP5         GO PUT IT OUT
.LOOP1   CLI       ZZOUTPUT,C'-' .     TRIPLE SPACE .Q
         BNE       *+10 .LOOP2         BRANCH IF NOT
         BCTR      3,0 .               DECREASE LINES BY ONE
         B         *+12 .LOOP3         BRANCH
.LOOP2   CLI       ZZOUTPUT,C'0' .     DOUBLE SPACE .Q
         BNE       *+10 .LOOP4         BRANCH IF NOT
.LOOP3   BCTR      3,0 .               DECREASE LINES BY ONE
         B         *+16 .LOOP5         BRANCH
.LOOP4   CLI       ZZOUTPUT,C'+' .     NO SPACE AT ALL .Q
         BNE       *+8 .LOOP5          BRANCH IF NOT
         B         *+28 .LOOP6         BRANCH TO SINGLE SPACE
.LOOP5   BCTR      3,0 .               DECREASE LINES BY ONE
         ST        3,ZZZLINES .        UPDATE CURRENT LINE COUNT
         LTR       3,3 .               TEST LINES LEFT
         BP        *+16 .LOOP6         BRANCH IF SOME LEFT
         LA        3,50 .              RESTORE PAGE COUNT
         ST        3,ZZZLINES .        AND STORE IT
         MVI       ZZOUTPUT,C'1' .     NEW PAGE
.LOOP6   L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST
         L         1,20(,1) .          SYSPRINT DCB ADDRESS
         LA        0,ZZOUTPUT .        OUTPUT POINTER
         L         15,48(,1) .         LOAD PUT ADDRESS FROM DCB
         BALR      14,15 .             DO THE PUT
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   FINISH    &RC=0
&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA
         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS
         LA        15,&RC .            SET RETURN CODE
         BR        14 .                RETURN TO CALLER
         MEND
         PRINT     ON,GEN
         COMMENCE  EOF=ENDFILE
LOOP     GETT      X
         GETT      X+80,LENGTH=53
         PUTT      X,LENGTH=133
         B         LOOP
ENDFILE  PUTT      Y,LENGTH=133
         FINISH
X        DS        CL133
Y        DC        CL133'0DOUBLE SPACE COMMENT TO TERMINATE THIS ASSEMBX
               LY.    BUT IT MUST BE LONG ENOUGH TO EXCEED THE 121ST PRX
               INT POSITION.  AND IT IS.'
         END
123456789012345678901234567890123456789012345678901234567890123456789012
123456789012345678901234567890123456789012345678901234567890
+_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
-***********************************************************************
************************************************************
$JOB
*        TO TEST GLOBAL END-OF-FILE
         PRINT     OFF
         MACRO
&LABEL   COMMENCE  &EOF=
&LABEL   STM       14,12,12(13) .      SAVE CALLER'S REGISTERS
         BALR      12,0 .              ESTABLISH THE BASE
         USING     *,12 .              AND TELL THE ASSEMBLER
         LR        15,13 .             REMEMBER CALLER'S SAVE AREA
         LA        13,ZZZZSAVE .       WHAT IS MY SAVE AREA
         ST        13,8(15) .          TELL THE CALLER
         ST        15,ZZZZSAVE+4 .     SAVE CALLER'S SAVE AREA
         ST        1,ZZZZSAVE .        SAVE POINTER TO ASMG DCB LIST
         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED .Q
         L         1,16(0,1) .         POINT TO SYSIN DCB
         MVC       33(3,1),=AL3(&EOF) .MODIFY THE EODAD
.NOEOF   ANOP
         LA        1,50 .              50 LINES PER PAGE FOR USER
         ST        1,ZZZLINES .        AND REMEMBER IT
         B         ZZAROUND .          BRANCH AROUND DATA
ZZZDUMMY DS        D .                 DUMMY CONVERT AREA
ZZZZTEMP DS        4F .                TEMPORARY SAVE AREA
ZZZZSAVE DS        18F .               MY SAVE AREA
ZZZLINES DS        F .                 LINES PER USER OUTPUT PAGE
ZZZINPUT DS        CL80 .              CARD INPUT AREA
ZZOUTPUT DC        CL133' ' .          PRINTER OUTPUT AREA
ZZAROUND DS        0H
         MEND
         MACRO
&LABEL   GETT      &INPUT,&LENGTH=80,&EOF=
         LCLA      &TLEN
&TLEN    SETA      &LENGTH
         AIF       (&TLEN GE 1).NEXT1
         MNOTE     0,'LENGTH PARAMETER WAS TOO SMALL'
&TLEN    SETA      80
.NEXT1   AIF       (&TLEN LE 80).NEXT2
         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'
&TLEN    SETA      80
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE WORK REGISTERS
         L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST
         L         1,16(,1) .          POINT TO SYSIN DCB
         AIF       (K'&EOF EQ 0).NOEOF WAS EOF SPECIFIED
         MVC       ZZZDUMMY(3),33(1) . SAVE GLOBAL EODAD EXIT
         LR        2,1 .               REMEMBER DCB ADDR OVER GET
         MVC       33(3,1),=AL3(&EOF)  MODIFY THE SYSIN EODAD
.NOEOF   ANOP
         LA        0,ZZZINPUT .        POINT TO MY INPUT AREA
         L         15,48(,1) .         LOAD GET ADDRESS FROM DCB
         BALR      14,15 .             DO THE GET
         AIF       (K'&EOF EQ 0).NOEOD WAS EOF SPECIFIED
         MVC       33(3,2),ZZZDUMMY .  RESTORE EODAD ADDRESS
.NOEOD   ANOP
         MVC       &INPUT.(&TLEN),ZZZINPUT TRANSFER TO USER'S AREA
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   PUTT      &A,&LENGTH=121
         LCLA      &TLEN
&TLEN    SETA      &LENGTH
         AIF       (&TLEN GE 1).NEXT1
         MNOTE     0,'LENGTH PARAMETER TOO SMALL'
&TLEN    SETA      121
.NEXT1   AIF       (&TLEN LE 133).NEXT2
         MNOTE     0,'LENGTH PARAMETER WAS TOO BIG'
&TLEN    SETA      133
.NEXT2   ANOP
&LABEL   STM       0,3,ZZZZTEMP .      SAVE SOME WORK REGISTERS
         MVI       ZZOUTPUT,C' ' .     INITIALIZE THE OUTPUT AREA
         MVC       ZZOUTPUT+1(132),ZZOUTPUT ALL OF IT
         MVC       ZZOUTPUT(&LENGTH),&A MOVE OUTPUT LINE
         L         3,ZZZLINES .        LOAD NUMBER OF LINES LEFT
         CLI       ZZOUTPUT,C'1' .     NEW PAGE .Q
         BNE       *+12 .LOOP1         BRANCH IF NO
         LA        3,1 .               ZERO THE LINES LEFT
         B         *+44 .LOOP5         GO PUT IT OUT
.LOOP1   CLI       ZZOUTPUT,C'-' .     TRIPLE SPACE .Q
         BNE       *+10 .LOOP2         BRANCH IF NOT
         BCTR      3,0 .               DECREASE LINES BY ONE
         B         *+12 .LOOP3         BRANCH
.LOOP2   CLI       ZZOUTPUT,C'0' .     DOUBLE SPACE .Q
         BNE       *+10 .LOOP4         BRANCH IF NOT
.LOOP3   BCTR      3,0 .               DECREASE LINES BY ONE
         B         *+16 .LOOP5         BRANCH
.LOOP4   CLI       ZZOUTPUT,C'+' .     NO SPACE AT ALL .Q
         BNE       *+8 .LOOP5          BRANCH IF NOT
         B         *+28 .LOOP6         BRANCH TO SINGLE SPACE
.LOOP5   BCTR      3,0 .               DECREASE LINES BY ONE
         ST        3,ZZZLINES .        UPDATE CURRENT LINE COUNT
         LTR       3,3 .               TEST LINES LEFT
         BP        *+16 .LOOP6         BRANCH IF SOME LEFT
         LA        3,50 .              RESTORE PAGE COUNT
         ST        3,ZZZLINES .        AND STORE IT
         MVI       ZZOUTPUT,C'1' .     NEW PAGE
.LOOP6   L         1,ZZZZSAVE .        POINTER TO ASMG DCB LIST
         L         1,20(,1) .          SYSPRINT DCB ADDRESS
         LA        0,ZZOUTPUT .        OUTPUT POINTER
         L         15,48(,1) .         LOAD PUT ADDRESS FROM DCB
         BALR      14,15 .             DO THE PUT
         LM        0,3,ZZZZTEMP .      RESTORE WORK REGISTERS
         MEND
         MACRO
&LABEL   FINISH    &RC=0
&LABEL   L         13,ZZZZSAVE+4 .     POINT TO CALLER'S SAVE AREA
         LM        14,12,12(13) .      RESTORE CALLER'S REGISTERS
         LA        15,&RC .            SET RETURN CODE
         BR        14 .                RETURN TO CALLER
         MEND
         PRINT     ON,NOGEN
         COMMENCE  EOF=DONE
         GETT      X,EOF=ALMOST
         GETT      X
         DC        H'0'                ABEND IF NEITHER WORKS
ALMOST   PUTT      Y
         B         DONE
DONE     PUTT      Z
         FINISH
X        DS        80C
Y        DC        CL133'0ALMOST FINISHED ----   TOOK LOCAL EOF'
Z        DC        CL133'-ALL DONE        ----   GLOBAL END OF FILE'
         END
HERE IS THE ONE AND ONLY INPUT RECORD ON SYSIN
/*





//ASMG#4   JOB  'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)
//*
//*                THIS JOB IS AN ASSEMBLY OF 'WEEKDAY'.  THE
//*                SYSLIN CARD HAS BEEN PURPOSLY OMITTED.  THIS
//*                WILL CAUSE THE LKED STEP TO BE BYPASSED.
//*
//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=SHR
//ASM      EXEC PGM=ASMGASM,REGION=130K
//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),
//             SPACE=(3500,(400,50))
//SYSPRINT DD   SYSOUT=A
//SYSPUNCH DD   SYSOUT=B
//SYSTERM  DD   SYSOUT=A
//ASM.SYSIN DD  *
WKDY     TITLE 'DAY OF WEEK SUBROUTINE - DICK CONNER, 212 MU6-4000 USA'
WEEKDAY  START
***********************************************************************
*                                                                     *
*        THIS SERIALLY-REUSABLE SUBROUTINE DETERMINES THE DAY OF THE  *
*   WEEK FOR ANY GREGORIAN DATE FROM OCTOBER 15, 1582, THROUGH FEBRU- *
*   ARY 28, 4000.                                                     *
*                                                                     *
*        CALL  WEEKDAY(DATE,DAY)                                      *
*              WHERE DATE NAMES THE ARGUMENT AND DAY NAMES THE ANSWER.*
*              THEY HAVE THE FOLLOWING FORMATS, RESPECTIVELY -        *
*DATE    DS    0ZL8                                                   *
*YEAR    DS    ZL4  YEAR - ANY VALUE 1582-4000                        *
*MONTH   DS    ZL2  MONTH - ANY VALUE 01-12                           *
*D       DS    ZL2  DAY OF MONTH - ANY VALUE 01-31                    *
*DAY     DS    ZL1  DAY OF WEEK - 0(SUNDAY)-6(SATURDAY)               *
*                                                                     *
***********************************************************************
         SPACE 3
         ENTRY WEKDAY   *** PSEUDONYM FOR FORTRAN CALLERS ***
CORR     EQU   11   ACCUMULATOR FOR CORRECTIONS
BINMTH   EQU   9    MONTH IN BINARY FORM
BINYR    EQU   9    YEAR IN BINARY FORM
X        EQU   7    ACCUMULATOR FOR INTERMEDIATE VALUE
QOT      EQU   9    QUOTIENT
RMNDR    EQU   8    REMAINDER
DVDND    EQU   RMNDR     DIVIDEND(OPERAND 1 FOR DIVISION)
         SPACE 1
         USING *,15      CALLER HAS LOADED GPR15
WEKDAY   SAVE  (14,12)   SAVE ALL NON-LINKAGE GPR'S
         USING INPUT,3   DATA BASE
         L     3,0(1)    PICK UP SOURCE ADDRESS
         PACK  DECMY,INDAY
         CVB   CORR,DECDATE
         PACK  DECMTH,INMTH
         CVB   BINMTH,DECDATE
         IC    BINMTH,FFTBL-1(BINMTH)   FIND FUDGE FACTOR
         AR    CORR,BINMTH              AND APPLY IT TO CORRECTION
         PACK  DECMY,INMY
         SP    DECMY,=P'3'    ADJUST YEAR IF JANUARY OR FEBRUARY
         OI    YRSIGN,15      LEGITIMIZE SIGN FOR ZAP
         ZAP   DECMY,DECYR
         CVB   BINYR,DECDATE
         SR    DVDND,DVDND
         LA    X,3  USED TO FIND CENTURY MOD 4
         D     DVDND,=F'100'  FIND CENTURY
         NR    QOT,X     CENTURIES MOD 4
         NR    X,RMNDR   THIS MANY COMMON YEARS
         SRA   RMNDR,2        AND
         AR    QOT,RMNDR           THIS MANY LEAP YEARS
         MH    QOT,=H'5'
         AR    CORR,QOT
         AR    CORR,X
         SR    CORR-1,CORR-1  PREPARE TO DIVIDE
         D     CORR-1,=F'7'
         L     3,4(1)    PICK UP SINK ADDRESS
         STC   CORR-1,DAY
         OI    DAY,X'F0'      PLUG IN BLANK ZONE
         MVI   12(13),X'FF'   ASSIST DEBUGGING
         RETURN (14,12)  BACK TO CALLER
         EJECT
*              DATA DEFINITIONS
         SPACE 3
         DS    0D   ALIGNMENT FOR CVB
DECDATE  DS    0PL8      BUCKET FOR PACKED DATE
         DC    4XL1'0'
DECMY    DS    0PL4      MONTH AND YEAR 0YYYYMMS
DECYR    DS    PL3       YEAR 0YYYYS
         ORG   DECYR+2
DECMTH   DS    0PL2      MONTH 0MMS
YRSIGN   DS    PL1
         DS    PL1
*
FFTBL    DC    FL1'0,3,2,5,0,3,5,1,4,6,2,4'  FUDGE FACTORS
*
INPUT    DSECT      SOURCE AND SINK FORMATS
DAY      DS    0ZL1      RESULT
DATE     DS    0ZL8      ARGUMENT
INMY     DS    0ZL6
         DS    ZL4
INMTH    DS    ZL2
INDAY    DS    ZL2
         END
/*
//LKED     EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),COND=(8,LT,ASM),
//             REGION=96K
//SYSLIN   DD   DSN=&LOADSET,DISP=(OLD,DELETE)
//         DD   DDNAME=SYSIN
//SYSLMOD  DD   DSN=&TEMP(PDS),UNIT=SYSDA,SPACE=(1024,(50,20,1)),
//             DISP=(MOD,PASS)
//SYSUT1   DD   UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),SPACE=(1024,(50,20))
//SYSPRINT DD   SYSOUT=A





//ASMG#5   JOB  'C0018R.V.PETERSEN,TIME=2',MSGLEVEL=(1,1)
//*
//*                THIS JOB IS AN ASSEMBLY, LINKEDIT, AND GO OF
//*                A PROGRAM TO INVOKE ASMG.  THE INVOCATION
//*                WILL ABEND FOR LACK OF UTILITY AND INPUT DD
//*                CARDS.  THIS INVOCATION PROGRAM MAKES ASMG
//*                VERY ASSEMBLER (F) COMPATIBLE.
//*
//JOBLIB   DD   DSN=ASMG.LOADMODS,DISP=(SHR,PASS)
//ASM      EXEC PGM=ASMGASM,REGION=130K
//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),
//             SPACE=(3500,(400,50))
//SYSPRINT DD   SYSOUT=A
//SYSPUNCH DD   SYSOUT=B
//SYSTERM  DD   SYSOUT=A
//SYSLIN   DD   DSN=&LOADSET,UNIT=SYSSQ,SPACE=(3200,(10,5)),
//             DISP=(MOD,PASS)
//ASM.SYSIN DD  *
*        THIS PROGRAM INVOKES ASMG SUCH THAT THE DEFAULT OPTIONS ARE
*        DECK,NOLOAD,NOEXTEN,INSTSET=0,LREF AND CHANGES SYSLIN
*        TO SYSGO.
*        IF THE USER HAS A PARM FIELD IT IS CONCATENATED ONTO THE
*        END OF THE PARM FIELD DEFINED IN THIS PROGRAM.
IEUASM   CSECT
         LR        12,15               TRANSFER ENTRY ADDRESS
         USING     IEUASM,12           AND USE IT AS A BASE
         ST        14,SAVE             REMEMBER RETURN ADDRESS
         L         1,0(,1)             LOAD ADDRESS OF PARM LIST
         LH        3,0(,1)             GET LENGTH OF USER PARM
         LTR       3,3                 WAS THERE A USER PARM .Q
         BZ        LINK                BRANCH IF NOT
         BCTR      3,0                 DECREMENT PARM LENGTH FOR MVC
         EX        3,MUSEROPL          MOVE USER PARM TO END OF MINE
         LA        3,L'MYOPL+2(,3)     GET ACTUAL LENGTH OF BOTH PARMS
         STH       3,OPLIST            AND SET IT
LINK     LINK      EP=ASMGASM,PARAM=(OPLIST,DDLIST),VL=1
         USING     *,14                THE RETURN REGISTER IS A BASE
         L         14,SAVE             RESTORE RETURN ADDRESS
         BR        14                  AND RETURN TO INVOKER
         DROP      14                  THAT'S IT
         SPACE     2
MUSEROPL MVC       USEROPL(*-*),2(1)   MOVE USER PARM
OPLIST   DC        AL2(L'MYOPL)        LENGTH OF MY PARM LIST
MYOPL    DC        C'D,NOLO,NOEX,IS=0,NOLR'  MY PARMS
         DC        C','                TO SEPERATE USER PARMS FROM MINE
USEROPL  DS        CL100               USERS PARMS
DDLIST   DC        H'80'               LIST ALL 10 DDNAMES
         DC        CL8'SYSGO'          OVERRIDE SYSLIN
         DC        4H'0'               SYSTERM
         DC        4H'0'               SYSUP
         DC        4H'0'               SYSLIB
         DC        4H'0'               SYSIN
         DC        4H'0'               SYSPRINT
         DC        4H'0'               SYSPUNCH
         DC        4H'0'               SYSUT1
         DC        4H'0'               SYSUT2
         DC        4H'0'               SYSUT3
SAVE     DS        F                   RETAIN RETURN ADDRESS
         END       IEUASM
/*
//LKED     EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),COND=(8,LT,ASM),
//             REGION=96K
//SYSLIN   DD   DSN=&LOADSET,DISP=(OLD,DELETE)
//         DD   DDNAME=SYSIN
//SYSLMOD  DD   DSN=&TEMP(PDS),UNIT=SYSDA,SPACE=(1024,(50,20,1)),
//             DISP=(MOD,PASS)
//SYSUT1   DD   UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),SPACE=(1024,(50,20))
//SYSPRINT DD   SYSOUT=A
//GO       EXEC PGM=*.LKED.SYSLMOD,COND=((8,LT,ASM),(4,LT,LKED)),
//             PARM=FX
//GO.SYSPRINT DD SYSOUT=A





//ASMG#6   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)
//*
//*                THIS JOB SCRATCHES THE ASMG LOADMODULES FROM
//*                JOBLIB IF THEY ARE THERE, MOVES THE LOADMODULES
//*                FROM ASMG.LOADMODS INTO JOBLIB, AND THEN
//*                SCRATCHES AND UNCATALOGS ASMG.LOADMODS
//*
//*                NOTE --  ASMG.LOADMODS AS DISTRIBUTED IS
//*                BLOCKED AT 7294.  THIS MEANS SHORT BLOCKS
//*                IN JOBLIB IF JOBLIB IS BLOCKED HIGHER.  SEE
//*                ASMG#7 FOR AN ALTERNATIVE METHOD.
//*
//         EXEC PGM=IEHPROGM,REGION=44K
//SYSPRINT DD   SYSOUT=A
//DD222222 DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD
//SYSIN    DD   *
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGASM
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMG
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGFPP
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF2
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF3
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF7
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF8
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS00
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS01
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS09
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS20
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS44
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS67
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS70
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGRTA
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGUP
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGWYL
/*
//        EXEC  PGM=IEHMOVE,REGION=100K
//SYSPRINT DD   SYSOUT=A
//SYSUT1   DD   UNIT=2314,VOL=SER=777777,DISP=OLD
//DD333333 DD   UNIT=SYSDA,VOL=SER=333333,DISP=OLD
//DD222222 DD   UNIT=SYSDA,VOL=SER=222222,DISP=OLD
//SYSIN    DD   *
         COPY      PDS=ASMG.LOADMODS,FROM=2314=333333,                 X
               TO=2314=222222,RENAME=JOBLIB
/*
//         EXEC PGM=IEHPROGM,REGION=44K
//SYSPRINT DD   SYSOUT=A
//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD
//SYSIN    DD   *
         SCRATCH   DSNAME=ASMG.LOADMODS,VOL=2314=333333
         UNCATLG   DSNAME=ASMG.LOADMODS
/*




//ASMG#7   JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)
//*
//*                THIS JOB SCRATCHES THE ASMG LOADMODULES FROM
//*                JOBLIB IF THEY ARE THERE, LINKS THE LOADMODULES
//*                FROM ASMG.OBJMODS INTO JOBLIB.  NOTE THE
//*                'DCBS' PARM ON THE LINKEDIT STEP AND
//*                'DCB=BLKSIZE=' FIELD ON SYSLMOD.  7294
//*                HAS BEEN CHOSEN FOR 2314'S.
//*
//         EXEC PGM=IEHPROGM,REGION=44K
//SYSPRINT DD   SYSOUT=A
//DD222222 DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD
//SYSIN    DD   *
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGASM
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMG
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGFPP
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF1
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF2
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF3
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF7
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGF8
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS00
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS01
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS09
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS20
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS44
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS67
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS70
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGIS71
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGRTA
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGUP
         SCRATCH   DSNAME=JOBLIB,VOL=2314=222222,MEMBER=ASMGWYL
/*
//         EXEC PGM=IEWL,PARM='LIST,XREF,DCBS,NCAL',REGION=96K
//SYSPRINT DD   SYSOUT=A
//SYSUT1   DD   VOL=SER=777777,UNIT=SYSDA,DISP=(NEW,DELETE),
//             SPACE=(CYL,(2,1))
//MODLIB   DD   DSN=ASMG.OBJMODS,DISP=SHR
//SYSLMOD  DD   DSN=JOBLIB,DISP=OLD,DCB=BLKSIZE=7294
//SYSLIN   DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGASM)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGWYL)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGUP)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF1)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF2)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF3)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGRTA)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF7)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGF8)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGFPP)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS00)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS09)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS20)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS44)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS60)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS67)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS70)
//         DD   DISP=SHR,DSN=ASMG.LKEDIN(ASMGIS71)
//





//ASMG#8   JOB  'C0018R.V.PETERSEN,TIME=5,COPIES=5,PAGES=50',
//             MSGLEVEL=(1,1)
//*
//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE
//*                WITH SMALL LETTERS SEE '//ASMG#13'.
//*
//*                THIS PROGRAM PRINTS THE USER'S GUIDE.
//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE
//*                EASILY MADE BY USING THE COPIES PARAMETER.
//*                FORMS # 0001 SHOULD BE BLANK PAPER.
//*
//         EXEC PGM=IEBGENER,REGION=70K
//SYSPRINT DD   DUMMY
//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,
//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360),
//             DSNAME=ASMG.GUIDE.USERS,LABEL=3
//SYSUT2   DD   SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)
//SYSIN    DD   DUMMY





//ASMG#9   JOB  'C0018R.V.PETERSEN,TIME=5,COPIES=5,PAGES=20',
//             MSGLEVEL=(1,1)
//*
//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE
//*                WITH SMALL LETTERS SEE '//ASMG#13'.
//*
//*                THIS PROGRAM PRINTS THE IMPLIMENTATION GUIDE.
//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE
//*                EASILY MADE BY USING THE COPIES PARAMETER.
//*                FORMS # 0001 SHOULD BE BLANK PAPER.
//*
//         EXEC PGM=IEBGENER,REGION=70K
//SYSPRINT DD   DUMMY
//SYSUT1   DD   UNIT=2400,VOLUME=(PRIVATE,SER=ASMG27),DISP=OLD,
//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360),
//             DSNAME=ASMG.GUIDE.IMPL,LABEL=4
//SYSUT2   DD   SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)
//SYSIN    DD   DUMMY





//ASMG#10  JOB  'C0018R.V.PETERSEN,TIME=5,PAGES=200',MSGLEVEL=(1,1)
//*
//*                THIS JOB IS A SAMPLE ASSEMBLE WITH UPDATE AND
//*                LINKEDIT OF ASMG. FOR PURPOSES OF ILLUSTRATION
//*                THE ASMGF2A DECK OF THE ASMGF2 MODULE IS USED.
//*
//JOBLIB   DD   DSN=JOBLIB,DISP=SHR
//         EXEC PGM=ASMGASM,PARM='IS=0,NOEXTEN,UPDATE',REGION=140K
//SYSLIB   DD   DSN=ASMG.MACROLIB,DISP=SHR,DCB=BLKSIZE=3360
//         DD   DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT2   DD   UNIT=SYSDA,SPACE=(3500,(400,50))
//SYSUT3   DD   UNIT=(SYSDA,SEP=(SYSUT2,SYSUT1,SYSLIB)),
//             SPACE=(3500,(400,50))
//SYSPRINT DD   SYSOUT=A
//SYSLIN   DD   DSN=ASMG.OBJMODS(ASMGF2A),DISP=OLD
//SYSIN    DD   DSN=ASMG.SOURCE(ASMGF2A),DISP=SHR
//SYSUP    DD   DSN=ASMG27A.UPDATE(ASMGF2A),DISP=SHR
//         EXEC PGM=IEWL,PARM=(XREF,LIST,NCAL),REGION=96K
//MODLIB   DD   DSN=ASMG.OBJMODS,DISP=OLD
//SYSLIN   DD   DSN=ASMG.LKEDIN(ASMGF2),DISP=SHR
//SYSLMOD  DD   DSN=ASMG.LOADMODS,DISP=OLD
//SYSUT1   DD   UNIT=(SYSDA,SEP=(MODLIB,SYSLMOD)),SPACE=(1024,(50,20))
//SYSPRINT DD   SYSOUT=A





//ASMG#11  JOB  'C0018R.V.PETERSEN,TIME=5',MSGLEVEL=(1,1)
//*
//*                THIS JOB COPIES ASMG.LOADMODS, ASMG.SOURCE,
//*                ASMG.OBJMODS, ASMG.MACROLIB, ASMG.LKEDIN
//*                AND ASMG27A.UPDATE BACK ONTO THE TAPE.
//*                IN ORDER TO REPRODUCE THE ASMG27A
//*                TAPE, THE DATASETS ASMG.JCL,
//*                ASMG.GUIDE.USERS, AND ASMG.GUIDE.IMPL ARE FIRST
//*                MOVED TO DISK, AND THEN MOVED BACK TO TAPE AS
//*                THE OTHER DATASETS ARE BEING COPIED TO TAPE.
//*
//         EXEC PGM=IEHMOVE,REGION=100K
//SYSPRINT DD   SYSOUT=A
//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD
//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD
//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD
//SYSIN    DD   *
         COPY      DSNAME=ASMG.JCL,FROM=2400=(ASMG27,1),TO=2314=333333
         COPY      DSNAME=ASMG.GUIDE.USERS,FROM=2400=(ASMG27,3),       X
               TO=2314=333333
         COPY      DSNAME=ASMG.GUIDE.IMPL,FROM=2400=(ASMG27,4),        X
               TO=2314=333333
/*
//         EXEC PGM=IEHMOVE,REGION=100K
//SYSPRINT DD   SYSOUT=A
//SYSUT1   DD   UNIT=SYSDA,VOLUME=SER=222222,DISP=OLD
//DDASMG27 DD   UNIT=2400,VOLUME=(PRIVATE,RETAIN,SER=ASMG27),DISP=OLD
//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD
//SYSIN    DD   *
         MOVE      DSNAME=ASMG.JCL,TO=2400=(ASMG27,1),FROM=2314=333333
         COPY      PDS=ASMG.LOADMODS,TO=2400=(ASMG27,2)
         MOVE      DSNAME=ASMG.GUIDE.USERS,TO=2400=(ASMG27,3),         X
               FROM=2314=333333
         MOVE      DSNAME=ASMG.GUIDE.IMPL,TO=2400=(ASMG27,4),          X
               FROM=2314=333333
         COPY      PDS=ASMG.SOURCE,TO=2400=(ASMG27,5)
         COPY      PDS=ASMG.OBJMODS,TO=2400=(ASMG27,6)
         COPY      PDS=ASMG.MACROLIB,TO=2400=(ASMG27,7)
         COPY      PDS=ASMG.LKEDIN,TO=2400=(ASMG27,8)
         COPY      PDS=ASMG27A.UPDATE,TO=2400=(ASMG27,9)
/*





//ASMG#12  JOB  'C0018R.V.PETERSEN,TIME=1',MSGLEVEL=(1,1)
//*
//*                THIS JOB SCRATCHES AND UNCATALOGS ASMG.SOURCE,
//*                ASMG.OBJMODS, ASMG.MACROLIB, ASMG.LKEDIN
//*                AND ASMG27A.UPDATE.
//*
//         EXEC PGM=IEHPROGM,REGION=44K
//SYSPRINT DD   SYSOUT=A
//DD333333 DD   UNIT=SYSDA,VOLUME=SER=333333,DISP=OLD
//SYSIN    DD   *
         SCRATCH   DSNAME=ASMG.SOURCE,VOL=2314=333333
         UNCATLG   DSNAME=ASMG.SOURCE
         SCRATCH   DSNAME=ASMG.OBJMODS,VOL=2314=333333
         UNCATLG   DSNAME=ASMG.OBJMODS
         SCRATCH   DSNAME=ASMG.MACROLIB,VOL=2314=333333
         UNCATLG   DSNAME=ASMG.MACROLIB
         SCRATCH   DSNAME=ASMG.LKEDIN,VOL=2314=333333
         UNCATLG   DSNAME=ASMG.LKEDIN
         SCRATCH   DSNAME=ASMG27A.UPDATE,VOL=2314=333333
         UNCATLG   DSNAME=ASMG27A.UPDATE
/*





//ASMG#13  JOB  'C0001ASMG.USER,TIME=1,COPIES=5,PAGES=100',
//              MSGLEVEL=(1,1)
//*
//*                IF YOU DO NOT HAVE A 'TN' PRINT CHAIN OR ONE
//*                WITH SMALL LETTERS, THIS PROGRAM WILL CONVERT
//*                THE IMPLEMENTATION GUIDE OR USER'S GUIDE
//*                TO UPPER CASE FOR PRINTING.
//*                NOTE -- THE USER'S GUIDE IS USED IN THIS EXAMPLE.
//*
//*                IF RUN UNDER HASP, MULTIPLE COPIES MAY BE
//*                EASILY MADE BY USING THE COPIES PARAMETER.
//*                FORMS # 0001 SHOULD BE BLANK PAPER.
//*
//TRANSLAT  EXEC  ASMGCLG,REGION.ASM=100K
//ASM.SYSPRINT DD SYSOUT=A
//ASM.SYSIN DD *
BEGIN    STM       14,12,12(13)        SAVE CALLER'S REGISTERS
         BALR      12,0                ESTABLISH THE BASE
         USING     *,12                AND TELL THE ASSEMBLER
         LR        15,13               REMEMBER CALLER'S SAVE AREA
         LA        13,ZZZZSAVE         THIS IS MY SAVE AREA
         ST        13,8(,15)           TELL THE CALLER
         ST        15,ZZZZSAVE+4       SAVE CALLER'S SAVE AREA
         OPEN      (READER,(INPUT),DISKOUT,(OUTPUT))
READLOOP GET       READER,RECORD
WRITEOUT TR        RECORD+5(L'RECORD-5),TABLE
         PUT       DISKOUT,RECORD
         B         READLOOP
*
*        EXIT TO CALLER WHEN NO MORE RECORDS
*
CLOSEFIL CLOSE     (READER,,DISKOUT)
         L         13,ZZZZSAVE+4       POINT TO CALLER'S SAVE AREA
         LM        14,12,12(13)        RESTORE CALLER'S REGISTERS
         SR        15,15               SET A RETURN CODE
         BR        14                  RETURN TO CALLER
*
*        DATA AREA
*
ZZZZSAVE DS        18F                 MY SAVE AREA
RECORD   DS        CL132               RECORD TO BE TRANSLATED
TABLE    DC        75CL1' '
         DC        X'4B4C4D4E4F50'
         DC        9CL1'*'
         DC        X'5A5B5C5D5E5F6061'
         DC        9CL1'*'
         DC        X'6B6C6D6E6F'
         DC        10CL1'*'
         DC        X'7A7B7C7D7E7F5C'
         DC        X'C1C2C3C4C5C6C7C8C9'
         DC        7CL1'*'
         DC        X'D1D2D3D4D5D6D7D8D9'
         DC        8CL1'*'
         DC        X'E2E3E4E5E6E7E8E9'
         DC        22CL1'*'
         DC        X'C0C1C2C3C4C5C6C7C8C9'
         DC        7CL1'*'
         DC        X'D1D2D3D4D5D6D7D8D9'
         DC        8CL1'*'
         DC        X'E2E3E4E5E6E7E8E9'
         DC        6CL1'*'
         DC        X'F0F1F2F3F4F5F6F7F8F9'
         DC        6CL1'*'
READER   DCB       DDNAME=TAPE,DSORG=PS,MACRF=(GM),RECFM=VB,           X
               LRECL=84,BLKSIZE=3360,EODAD=CLOSEFIL
DISKOUT  DCB       DDNAME=OUTFILE,DSORG=PS,MACRF=(PM),RECFM=VA,        X
               LRECL=84,BLKSIZE=88
         END       BEGIN
/*
//GO.TAPE DD UNIT=2400,VOL=(PRIVATE,SER=ASMG27),DISP=OLD,
//             DSNAME=ASMG.GUIDE.USERS,LABEL=3,
//             DCB=(RECFM=VB,LRECL=84,BLKSIZE=3360)
//GO.OUTFILE DD SYSOUT=(A,,0001),DCB=(RECFM=VA,LRECL=84,BLKSIZE=88)
//





//ASMG#14  JOB  'C0001ASMG.USER,TIME=0',
//             MSGLEVEL=(1,1)
//*
//*                THIS DUMMY JOB IS ONLY OF INTEREST TO A USER
//*                INSTALLING ASSEMBLER (G) UNDER CMS.  THIS IS
//*                AN INDICATION OF WHAT MAY BE USED AS A GUIDE
//*                TO CREATE AN EXEC FILE TO DO THE INSTALLATION.
//DUMMY   EXEC  PGM=IEFBR14
//SYSIN     DD  *
&CONTROL OFF
*  AT THIS POINT THE OBJECT DECKS FOR ASSEMBLER (G) HAVE
*  BEEN RESTORED TO THE B DISK AT 192.
*
*  THE ASSEMBLER (G) ROUTINES ASMGF7 AND ASMGF8 HAVE MANY DECKS
*  TO INCLUDE.  NOW THESE WILL BE ENTERED INTO ONE SINGLE FILE
*  FOR EACH ROUTINE TO SIMPLIFY THE SUBSEQUENT INCLUDE FOR THE
*  CMS LOADER.
*
COPY ASMGF7C TEXT B1 ASMGF7 TEXT B1 (REP
COPY ASMGF7D TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7E TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7G TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7I TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7L TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7N TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7S TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7V TEXT B1 ASMGF7 TEXT B1 (APP
COPY ASMGF7X TEXT B1 ASMGF7 TEXT B1 (APP
*
COPY ASMGF8A TEXT B1 ASMGF8 TEXT B1 (REP
COPY ASMGF8C TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8D TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8I TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8L TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8M TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8N TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8P TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8S TEXT B1 ASMGF8 TEXT B1 (APP
COPY ASMGF8V TEXT B1 ASMGF8 TEXT B1 (APP
*
LOAD ASMGASM ASMGBUFF (ORIGIN 22000
GENMOD ASMGASM MODULE B1 (FROM ASMGASM
LOAD ASMGUP (ORIGIN 24000
GENMOD ASMGUP MODULE B1 (FROM ASMGUP
LOAD ASMGIS00 (ORIGIN 25000
GENMOD ASMGIS00 MODULE B1 (FROM ASMGIS00
LOAD ASMGIS71 (ORIGIN 25000
GENMOD ASMGIS01 MODULE B1 (FROM ASMGIS71
LOAD ASMGIS70 (ORIGIN 25000
GENMOD ASMGIS70 MODULE B1 (FROM ASMGIS70
LOAD ASMGIS71 (ORIGIN 25000
GENMOD ASMGIS71 MODULE B1 (FROM ASMGIS71
LOAD ASMGF1 (ORIGIN 26000
GENMOD ASMGF1 MODULE B1 (FROM ASMGF1
LOAD ASMGF2 ASMGF2A (ORIGIN 26000
GENMOD ASMGF2 MODULE B1 (FROM ASMGF2
LOAD ASMGF3 (ORIGIN 26000
GENMOD ASMGF3 MODULE B1 (FROM ASMGF3
LOAD ASMGRTA (ORIGIN 26000
GENMOD ASMGRTA MODULE B1 (FROM ASMGRTA
LOAD ASMGF7 (ORIGIN 26800 RESET ASMGF7
GENMOD ASMGF7 MODULE B1 (FROM ASMGF7C
LOAD ASMGF8 (ORIGIN 26800 RESET ASMGF8
GENMOD ASMGF8 MODULE B1 (FROM ASMGF8A
LOAD ASMGFPP ASMGFD ASMGFEX (ORIGIN 26800
GENMOD ASMGFPP MODULE B1 (FROM ASMGFPP
*
*  ASSUME ASSEMBLER (F) IS ON THE Y DISK AT 19E
*  ASSEMBLER (G) IS ON THE B DISK AT 192
*  AND ASSUME ASSEMBLER (XF) IS ON THE S DISK AT 190
ACC 192 B/A
ACC 19E C/A
ACC 190 D/A
LOAD WMSASM (CLEAR ORIGIN 20000
GENDIRT ASMFDIRT Y
GENDIRT ASMGDIRT B
GENDIRT ASMXDIRT S
ACC 192 B
REL C
REL D
GENMOD ASSEMBLE  (FROM WMSASM
/*





./ ADD NAME=MACDIR   0103-88356-88356-1611-00168-00166-00000-CHSY227
MACDIR   CSECT
R0       EQU   0                   R
R1       EQU   1                    E
R2       EQU   2                     G
R3       EQU   3                      I
R4       EQU   4                       S
R5       EQU   5                        T
R6       EQU   6                         E
R7       EQU   7                          R
R8       EQU   8
R9       EQU   9                   E
R10      EQU   10                   Q
R11      EQU   11                    U
R12      EQU   12                     A
R13      EQU   13                      T
R14      EQU   14                       E
R15      EQU   15                        S
         B     12(,R15)            BRANCH AROUNG NAME
         DC    X'07',CL7'MACDIR'   NAME FOR DUMP SCANNERS
         STM   R14,R12,12(R13)     STORE THE REGISTERS
         BAL   R2,92(R15)          BAL AROUND SAVE AREA
         USING *,13
         DS    18F                 SAVE AREA
         ST    R2,8(R13)           FORWARD POINTER
         ST    R13,4(R2)           BACK POINTER
         LR    R13,R2              ADD TO CHAIN
         LM    R8,R10,0(R1)        LOAD PARAMETER POINTERS
         L     R11,0(,R9)          POINT TO AREA START
         LA    R7,DIR              POINT TO DIRECTORY DCB
         USING IHADCB,R7           AND BASE THE DSECT
         MVC   DCBDDNAM,0(R8)      COPY THE DDNAME
         DROP  R7
         OPEN  (DIR,INPUT)
         LA    R13,0(,R13)
*        $BSM  MODE=31
         CPOOL BUILD,                                                  X
               PCELLCT=100,                                            X
               SCELLCT=100,                                            X
               CSIZE=16,                                               X
               LOC=(RES),                                              X
               SP=80,                                                  X
               CPID=POOLID
         LA    R7,TREEROOT
*        $BSM  MODE=24
LOOP1    DS    0H
         GET   DIR
SKIPPER  NOP   LOOP1
         LH    R3,0(,R1)           LOAD BLK LENGTH
         AR    R3,R1               ADD START ADDRESS
         LR    R4,R1               COPY START POINTER
         CR    R4,R3               BLOCK EMPTY ?
         BE    LOOP1               YES - - -
         LA    R4,2(,R4)           BUMP PAST BLKLENGTH FIELD
GOTHIS   DS    0H
         TM    11(R4),128          ALIAS BIT ON ?
         BO    NOGO                YES, IGNORE THIS ENTRY
         CLC   0(8,R4),=8X'FF'     LAST ENTRY MARKER ?
         BNE   NOTEND
         OI    SKIPPER+1,X'F0'
         B     LOOP1
NOTEND   DS    0H
*        $BSM  MODE=31
         CPOOL GET,U,CPID=POOLID
         AP    DIRCNT,=P'1'        INCREMENT ENTRY COUNT
         XC    0(16,R1),0(R1)      CLEAR THE CELL
         MVC   4(11,R1),0(R4)      COPY DIR ENTRY
         MVC   15(1,R1),EXT#       COPY EXTENT NUMBER
         ST    R1,0(,R7)           SAVE ITS ADDRESS
         LR    R7,R1               COPY FOR NEXT POINTER
*        $BSM  MODE=24             GO FOR ANOTHER ENTRY
NOGO     DS    0H
         IC    R5,11(,R4)          GET LENGTH BITS
         N     R5,=A(X'1F')        ONLY LENGTH, DAMMIT
         SLL   R5,1                DOUBLE IT
         LA    R4,12(R5,R4)        BUMP POINTER
         CR    R4,R3               OFF THE END YET ?
         BE    LOOP1               YES, READ ANOTHER BLOCK
         B     GOTHIS              NO, CONTINUE SCAN THIS BLOCK
DIRDONE  DS    0H
         CLOSE DIR
         FREEPOOL DIR
         CVB   R3,DIRCNT           GET MEMBER COUNT
         MH    R3,=H'12'           TIMES ENTRY LENGTH
*        $BSM  MODE=31
         ST    R3,TBLSZ            AND SIZE
         GETMAIN RU,LV=(3),SP=80
         LR    R2,R1               COPY ITS ADDRESS
         LA    R4,0
         LA    R5,0
         MVCL  R2,R4               CLEAR THE AREA OUT
         ST    R1,TBLRT            SAVE TABLE ADDRESS
         LR    R3,R1               COPY TABLE POINTER
         LA    R4,12               AND ENTRY LENGTH
         L     R5,TBLSZ            LOAD TABLE SIZE
         LA    R5,0(R3,R5)         POINT TO
         SR    R5,R4                 LAST POSSIBLE ENTRY
         L     R6,TREEROOT         POINT TO FIRST CHAIN ENTRY
BLD1     DS    0H
         MVC   0(8,R3),=8X'FF'     DUMMY ENTRY
         CLC   4(8,R6),=CL8' '     BLANK ENTRY ??
         BNH   BLD2                YES; SKIP IT ---
         MVC   0(12,R3),4(R6)      COPY NAME/TTR/C
BLD2     DS    0H
         LR    R2,R6               COPY ENTRY POINTER
         L     R6,0(,R6)           POINT TO NEXT LINK
         CPOOL FREE,CPID=POOLID,CELL=(2)
         BXLE  R3,R4,BLD1          LOOP FOR THE WHOLE CHAIN
         CPOOL DELETE,CPID=POOLID  RELEASE THE CELL-POOL
         SR    R5,R4               BACK UP ONE MORE ENTRY
SRT1     DS    0H
         L     R3,TBLRT            POINT TO TABLE ROOT
         MVI   EXT#,0              SWAP FLAG OFF
SRT2     DS    0H
         CLC   0(8,R3),12(R3)      NEED TO SWAP ??
         BH    SRT3                YES ---
         BL    SRT4                NOPE ---
         CLC   11(1,R3),23(R3)     EQUAL NAMES; CHK CONCAT #
         BL    SRT5                ORDER IS OK NOW
SRT3     DS    0H
         LM    R6,R8,0(R3)
         MVC   0(12,R3),12(R3)
         STM   R6,R8,12(R3)
         MVI   EXT#,255            SET 'SWAP' FLAG
SRT4     DS    0H
         BXLE  R3,R4,SRT2          LOOP, SORTINGLY ---
         CLI   EXT#,0              ANY SWAPS THIS PASS ??
         BNE   SRT1                YES; MAKE ANOTHER PASS
         B     EXIT
SRT5     DS    0H
         MVC   12(8,R3),=8X'00'    CLOBBER NAME OF DUPLICATE
         XC    20(4,R3),20(R3)     AND TTR
         B     SRT3                AND CONTINUE SORTING
EXIT     DS    0H
*        $BSM  MODE=24
         L     R1,4(,R13)          LOAD BACK S.A. POINTER
         L     R1,24(,R1)          RELOAD PARM LIST POINTER
         L     R2,4(,R1)           POINT TO ADDRESS RETURN AREA
         MVC   0(4,R2),TBLRT       COPY TABLE ADDRESS TO IT
         L     R2,8(,R1)           POINT TO SIZE RETURN AREA
         MVC   0(4,R2),TBLSZ       COPY TABLE SIZE TO IT
         ST    R11,0(,R10)         RETURN REAL TABLE START ADDRESS
         L     R13,4(R13)          LOAD BACK POINTER
         L     R14,12(R13)         LOAD RETURN ADDRESS
         LM    R2,R12,28(R13)      RESTORE REGISTERS
         LA    R15,0               RC = 0
         MVI   12(R13),255         SET 'DONE' FLAG
         BR    R14                 RETURN
         TITLE 'DATA CONTROL BLOCKS AND CONSTANT AREAS'
DIR      DCB   DSORG=PS,MACRF=GL,DDNAME=PDS,EODAD=DIRDONE,RECFM=U,     *
               BLKSIZE=256,EXLST=EOVE
EXT#     DC    X'00'
         DS    0F
EOVE     DC    X'86',AL3(EOVE+4)   DCB EXIT LIST
         NI    SKIPPER+1,X'0F'
         LA    R0,0
         IC    R0,EXT#
         AH    R0,=H'1'
         STC   R0,EXT#
         BR    R14                 RETURN TO OPEN - - -
         DS    0D
DIRCNT   DC    PL8'0'
TBLRT    DC    F'0'
TBLSZ    DC    F'0'
POOLID   DC    F'0'
TREEROOT DC    F'0'
         LTORG
         DCBD  DSORG=QS,DEVD=DA
         END
./ ADD NAME=TESTJCL  0105-88330-88358-0724-00017-00017-00000-CHSY227
//CHSYASMG JOB   (0227,CHSY),'FOCHTMAN - SYSTEMS',
//         CLASS=S,NOTIFY=CHSY227,MSGCLASS=X
//JOBLIB   DD    DSN=CHSY227.ASMG.LOAD,DISP=SHR
//ASM      EXEC  PGM=ASMGASM,
//         PARM='SYSPARM=ASM,COL=3,DECK,NOOBJ,TERM,IS=70',
//         REGION=4096K
//SYSPRINT DD    SYSOUT=E,HOLD=YES
//SYSTERM  DD    SYSOUT=C,HOLD=YES
//SYSLIB   DD    DSN=CHSY227.ASMG.SRCE,DISP=SHR
//         DD    DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(3,1)),DCB=BLKSIZE=4096
//SYSUT2   DD    UNIT=SYSDA,SPACE=(CYL,(3,1)),DCB=BLKSIZE=4096
//SYSUT3   DD    UNIT=SYSDA,SPACE=(CYL,(3,1)),DCB=BLKSIZE=4096
//SYSPUNCH DD    DSN=CHSY227.ASMG.OBJ(TESTOUT),DISP=SHR
//SYSIN    DD    DSN=CHSY227.ASMG.SRCE(ASMGASM),DISP=SHR
//SYSUDUMP DD    SYSOUT=F,HOLD=YES
//ABNLIGNR     DD                  DUMMY
./ ADD NAME=WMSASM
WASM     TITLE     'WMSASM        VM/370            VERSION 1, LEVEL 0'
*
* MODULE NAME --
*
*        WMSASM (ASSEMBLE)
*
* FUNCTION --
*
*        ASSEMBLE COMMAND.  TO PROVIDE THE INTERFACE BETWEEN
*        THE USER AND ASSEMBLER (F), (G), (XF) OR (XG).
*
* ATTRIBUTES --
*
*        DISK RESIDENT.
*
* ENTRY POINTS --
*
*        WMSASM  --  SEE FUNCTION DESCRIPTION.
*        ASMPROC --  SYSUTX PROCESSING ROUTINE FOR ASSEMBLERS.
*                    (CALLED FROM DMSSOB)
*
* ENTRY CONDITIONS --
*
*        ASSEMBLE --
*             R1  --  A(PLIST)
*             R14 --  RETURN ADDRESS
*             R15 --  A(CALLED ROUTINE)
*            PLIST--  CL8'FILENAM1'(,CL8'FILENAM2(, ...))
*
*                  NORMAL ASSEMBLER PARMS, OPTIONAL AND IN ANY ORDER
*                  FOLLOWED BY A FENCE.
*
* EXIT CONDITIONS --
*
*        NORMAL  --
*           R15  --  0 IF NO ERROR.
*
*        ERROR   --
*           R15  --  4 MINOR ERRORS DETECTED DURING ASSEMBLE,
*                      SUCCESSFUL PROGRAM EXECUTION IS PROBABLE.
*                --  8 ERRORS DETECTED DURING ASSEMBLE,
*                      UNSUCCESSFUL PROGRAM EXECUTION IS POSSIBLE.
*                -- 12 SERIOUS ERRORS DETECTED DURING ASSEMBLE,
*                      UNSUCCESSFUL EXECUTION IS PROBABLE.
*                -- 16 CRITICAL ERRORS DETECTED DURING ASSEMBLE,
*                      UNSUCCESSFUL EXECUTION IS PROBABLE.
*                -- 20 CATASTROPHIC ERRORS DETECTED DURING ASSEMBLE,
*                      PARTIAL OR COMPLETE ASSEMBLY CANCELLED.
*                -- 24 INVALID OPTIONS OR
*                      NO FILENAME.
*                -- 28 FILE NOT FOUND.
*
*                -- 32 ILLEGAL RECORD LENGTH FOR ASSEMBLE FILE.
*
*                -- 36 NO READ/WRITE DISKS ACCESSED.
*
* CALLS TO OTHER ROUTINES --
*
*        DMSERSA -- ERASE OLD FILES.
*        DMSSMNE -- INITIALIZE STORAGE POINTERS.
*        DMSSTTA -- LOCATE THE FILE.
*        IEUASM  -- ASSEMBLER (F) ROOT SEGMENT.
*        ASMGASM -- ASSEMBLER (G) ROOT SEGMENT.
*        IFOX00  -- ASSEMBLER (XF) ROOT SEGMENT.
*        AXH90   -- ASSEMBLER (XG) ROOT SEGMENT.
*
* EXTERNAL REFERENCES --
*
*        FREEMAIN
*        GETMAIN
*        NUCON
*        TYPE
*
* TABLES/WORKAREAS --
*
*        OPTEST TO OPTEND - LISTS OF VALID OPTIONS.
*        KWDEF            - DEFAULT KEYWORD VALUES.
*        PARBYT(N)        - USER OPTION BITS.
*        ASMFDEF, ASMGDEF - DEFAULT OPTIONS.
*
* NOTES --
*
*        NONE FOR NOW.
*
* OPERATION --
*
*        WMSASM, ALIAS ASSEMBLE FIRST SETS THE COMPSWT BIT IN
*        OSSFLAGS TO INDICATE THE ASSEMBLER IS RUNNING.
*
*        THE PRESENCE OF ONE OR MORE FILENAME(S) TO BE
*        ASSEMBLED IS VERIFIED, AND ITS EXISTANCE VERIFIED IF
*        MULTIPLE.  WMSASM NEXT SCANS THE OPTIONS SPECIFIED
*        AFTER A LEADING '('  AND THEREBY CONSTRUCTS AN
*        OS PARM LIST OF THOSE USER OPTIONS THAT DIFFER FROM
*        THE ASSEMBLER DEFAULTS.
*
*        IF RUNNING UNDER THE BATCH MONITOR, WMSASM TYPES
*        A MESSAGE AT THE TERMINAL GIVING THE NAME OF THE
*        FILE ABOUT TO BE ASSEMBLED.  IT THEN CALLS STATE
*        TO VERIFY THE EXISTENCE OF THIS FILE, TWICE IF NEEDS
*        BE WITH MODES 'ASSEMBLE' AND 'ASM'.  IF IT DOES
*        NOT EXIST, WMSASM ISSUES AN ERROR MESSAGE AND RETURNS
*        TO THE CALLER.  IF IT DOES EXIST, WMSASM CHECKS THE
*        ITEM LENGTH, ISSUES AN ERROR MESSAGE IF THE ITEM
*        LENGTH IS INCORRECT AND RETURNS TO THE CALLER.
*
*        IF THE LENGTH IS CORRECT, WMSASM CALLS ERASE TO
*        DELETE ANY EXISTING UTILITY FILES FOR THE CURRENT
*        ASSEMBLE FILE, AND FOR TEXT IF LOAD, PUNCH IF DECK,
*        AND LISTING UNLESS NOPRINT.  STORAGE IS THEN SET UP
*        BY CALLS TO STRINIT AND GETMAIN.
*
*        WMSASM THEN CALLS ADTLKW TO OBTAIN THE MODE OF THE
*        READ-WRITE DISK WITH MOST AVAILABLE SPACE AND USES
*        IT TO SET UP THE FILEDEF PLIST FOR THE SYSUT FILES
*        AND CHECKS TO SEE IF THE DISK WITH THE MOST SPACE IS
*        THE SOURCE DISK.  IF IT IS DIFFERENT, THE SYSUT FILES
*        ARE ERASED AGAIN, HAVING ALREADY BEEN ERASED FROM THE
*        SOURCE DISK.  IF NOT SPECIFIED BY THE USER, THE TEXT
*        AND LISTING FILES ARE WRITTEN ON THE --
*     1) DISK FROM WHICH THE ASSEMBLE SOURCE IS READ,
*     2) ON THE 'PARENT' DISK IF THE FIRST DISK IS A READ ONLY
*        EXTENSION, OR
*     3) THE PRIMARY A-DISK.
*        IF NONE OF THESE CHOICES IS AVAILABLE THE COMMAND WILL
*        BE TERMINATED.  CMS CONTROL BLOCKS (CMSCB'S), WHICH
*        REFLECT THE SELECTED OPTION, ARE SET UP FOR THE TEXT,
*        LISTING, ASSEMBLE, UPDATE AND UTILITY FILES.  AFTER
*        EACH SUCCESSFUL RETURN FROM FILEDEF WMSASM SETS A
*        CLEAR SWITCH TO INDICATE WHICH CMSCB'S ARE TO BE
*        CLEARED AT THE END OF THE ASSEMBLY.  WMSASM PLACES
*        THE ADDRESS OF THE APPROPRIATE AUXILIARY ASSEMBLER
*        DICTIONARY ----DIRT IN SSTATEXT.
*        FINALLY WMSASM LOADS THE ROOT SEGMENT OF THE ASSEMBLER
*        SAVES ANY STARTING STATISTICS IF REQUIRED AND
*        BRANCHES TO THE ASSEMBLER.
*
*        ON RETURN FROM THE ASSEMBLER, WMSASM ERASES THE
*        UTILITY FILES AND CLEARS THE CMSCBS WHICH IT HAD
*        SET UP.  AFTER ANY NECESSARY ERROR MESSAGES, WMSASM
*        SETS THE RELEASE PAGE BIT, CLEARS THE SSTATEXT
*        EXTENSION AND CLEARS OSSFLAGS.  IF MORE ASSEMBLY
*        FILES IN PLIST BEFORE OPTIONS THEN THE PLIST POINTER
*        IS RESET AND WE DO IT ALL AGAIN.  IF NO MORE ASSEMBLIES
*        THEN THE HIGHEST RETURN CODE IS PLACED IN R15
*        AND A RETURN IS MADE TO THE CALLER BY R14.
*
*
*        SPECIAL OUTPUT HANDLING ROUTINE -- ASMPROC
*
*        THE SYSTEM ROUTINE SOEOB INTERFACES WITH ASMPROC
*        WHENEVER ANY I/O ACTIVITY PERTAINS TO THE UTILITY
*        FILES.  NORMALLY A FIXED WRITE OF 4000 BYTES IS
*        FORCES AND THEN A RETURN TO THE CALLER.
*
*        ASSEMBLER (F) GETS SPECIAL TREATMENT FOR SYSUT2
*        DURING PHASE ONE MACRO SUBSETTING.  IF THE FILE
*        IS BEING READ IN ASSEMBLER PHASE ONE, ASMPROC
*        ACCESSES THE UTILITY CONTROL TABLE TO ASCERTAIN
*        THE LENGTH AND LOCATION OF THE RECORDS TO BE MOVED
*        AND MOVES IT TO THE SPECIFIED INPUT BUFFER.  IF
*        THE FILE IS BEING READ, BUT NOT IN PHASE ONE, FIXED
*        LENGTH IS FORCED AND ASMPROC RETURNS TO SOEOB.
*
*        IF THE FILE IS BEING WRITTEN IN PHASE ONE, THE
*        UTILITY CONTROL TABLE IS FIRST SET UP BY A CALL
*        TO GETMAIN AND THEN UPDATED TO REFLECT THE NUMBERS
*        OF RECORDS TO BE WRITTEN.  IF THE FILE IS BEING
*        WRITTEN BUT IS NOT IN PHASE ONE, ASMPROC FORCES A
*        WRITE OF 4000 OR 8000 BYTES AND RETURNS TO THE CALLER.
*
*
         EJECT
         MACRO
         PARM      &TKEYW,&MIN=,&EX=,&ON=,&OFF=,                       X
               &ADDR=,&INRTN=ONDIGIT,&OUTRTN=OPTDIGIT
         LCLA      &LENS,&I,&J,&T
         LCLB      &F,&G,&XF,&XG,&B(48)
         LCLC      &TC,&X(12)
         AIF       (K'&TKEYW LT 1 OR K'&TKEYW GT 15).MNOTE1
&I       SETA      1
&LENS    SETA      K'&TKEYW-1
         AIF       ('&TKEYW'(1,1) NE '''').SKIP01
&LENS    SETA      K'&TKEYW-3
.SKIP01  AIF       (K'&MIN LT 1).MNOTE2
         AIF       ('&ADDR' NE '' AND ('&ON' NE '' OR '&OFF' NE '')).MNX
               OTE5
&LENS    SETA      (&MIN-1)*16+&LENS
&I       SETA      N'&EX
         AIF       (&I EQ 0).SKPFG
         AIF       ('&EX' NE 'ALL').EXLOOP
&T       SETA      15*16
         AGO       .SKPFG
.EXLOOP  ANOP
         AIF       ('&EX(&I)' NE 'F').EX01
&F       SETB      1
         AGO       .EX04
.EX01    ANOP
         AIF       ('&EX(&I)' NE 'G').EX02
&G       SETB      1
         AGO       .EX04
.EX02    ANOP
         AIF       ('&EX(&I)' NE 'XF').EX03
&XF      SETB      1
         AGO       .EX04
.EX03    ANOP
         AIF       ('&EX(&I)' NE 'XG').MNOTE3
&XG      SETB      1
.EX04    ANOP
&I       SETA      &I-1
         AIF       (&I GT 0).EXLOOP
.SKPFG   ANOP
&T       SETA      &F*128+&G*64+&XF*32+&XG*16+&T
         AIF       ('&ADDR' NE '').KWTYPE
         AIF       ('&ON' EQ '' AND '&OFF' EQ '').MNOTE6
         AIF       ('&OFF' NE '').TRYOFF
&I       SETA      N'&ON
.ONLOOP  ANOP
&TC      SETC      T'&ON(&I)
&TC      SETC      'C''&TC'''
&J       SETA      &TC
         AIF       (&J LT 1 OR &J GT 48).MNOTE7
&B(&J)   SETB      (1)
&I       SETA      &I-1
         AIF       (&I GT 0).ONLOOP
         AGO       .SETBIT
.TRYOFF  AIF       ('&ON' NE '').TRYONF
&I       SETA      N'&OFF
.OFFLOOP ANOP
&TC      SETC      T'&OFF(&I)
&TC      SETC      'C''&TC'''
&J       SETA      &TC
         AIF       (&J LT 1 OR &J GT 48).MNOTE7
&B(&J)   SETB      (1)
&I       SETA      &I-1
         AIF       (&I GT 0).OFFLOOP
&I       SETA      48
.OFFREV  ANOP
&B(&I)   SETB      (NOT &B(&I))
&I       SETA      &I-1
         AIF       (&I GT 0).OFFREV
&T       SETA      &T+1
         AGO       .SETBIT
.TRYONF  ANOP
&I       SETA      N'&ON
.ONFLOP1 ANOP
&TC      SETC      T'&ON(&I)
&TC      SETC      'C''&TC'''
&J       SETA      &TC
         AIF       (&J LT 17 OR &J GT 48).MNOTE7
&B(&J)   SETB      (1)
&I       SETA      &I-1
         AIF       (&I GT 0).ONFLOP1
&I       SETA      N'&OFF
.ONFLOP2 ANOP
&TC      SETC      T'&OFF(&I)
&TC      SETC      'C''&TC'''
&J       SETA      &TC
         AIF       (&J LT 1 OR &J GT 16).MNOTE7
&B(&J)   SETB      (1)
&I       SETA      &I-1
         AIF       (&I GT 0).ONFLOP2
&I       SETA      16
.ONFREV  ANOP
&B(&I)   SETB      (NOT &B(&I))
&I       SETA      &I-1
         AIF       (&I GT 0).ONFREV
&T       SETA      &T+2
         AGO       .SETBIT
.KWTYPE  ANOP
&T       SETA      &T+3
         DC        AL1(&LENS,&T),AL2(&ADDR.-WMSASM)
         DC        AL2(&INRTN.-WMSASM),AL2(&OUTRTN.-WMSASM)
         AGO       .CHRSET
         MEXIT
.SETBIT  ANOP
&I       SETA      4
.LOOPX   ANOP
&J       SETA      &B(&I-3)*8+&B(&I-2)*4+&B(&I-1)*2+&B(&I)+1
&X(&I/4) SETC      '0123456789ABCDEF'(&J,1)
&I       SETA      &I+4
         AIF       (&I LE 48).LOOPX
         DC        AL1(&LENS,&T),XL6'&X(1)&X(2)&X(3)&X(4)&X(5)&X(6)&X(7X
               )&X(8)&X(9)&X(10)&X(11)&X(12).'
.CHRSET  AIF       ('&TKEYW'(1,1) EQ '''').CHRQUT
         DC        C'&TKEYW.'
         MEXIT
.CHRQUT  DC        C&TKEYW
         MEXIT
.MNOTE1  MNOTE     'PARM -- PARAMETER &TKEYW INVALID'
         MEXIT
.MNOTE2  MNOTE     'PARM -- MIN= PARM MISSING'
         MEXIT
.MNOTE3  MNOTE     'PARM -- EX= &EX INVALID'
         MEXIT
.MNOTE5  MNOTE     'PARM -- ADDR= &ADDR INVALID'
         MEXIT
.MNOTE6  MNOTE     'PARM -- MISSING ON= AND OFF='
         NEXIT
.MNOTE7  MNOTE     'PARM -- ON/OFF PARM &J OUT OF RANGE'
         MEND
         EJECT
WMSASM   CSECT
         LR        R12,R15             TRANSFER ENTRY ADDRESS
         USING     WMSASM,R12          AND TELL ASSEMBLER
         LA        R2,8(,R1)           SAVE PARAMETER LIST ADDRESS
         ST        R14,SVREG14         SAVE RETURN TO CMS
         LA        R13,SAVEAREA        POINT TO MY SAVE AREA
ASMLOOP  DS        0H
         USING     SAVEAREA,R13        USE THIS FOR DATA/WORK BASE
*        SET UP SOME QUANTITIES
         USING     NUCON,R0            NUCLEUS ADDRESSABILITY
         COMPSWT   ON                  INDICATE ASSEMBLER RUNNING
         MVI       FDEFSWT,ZERO        INITIALIZE FILEDEF SWITCH
         MVI       ASMSW,X'00'         CLEAR ASSEMBLER SWITCH
         EJECT
***********************************************************************
*                  PROCESS ASSEMBLER OPTIONS                          *
*                                                                     *
***********************************************************************
         SPACE
         CLI       0(R2),FENCE         FILE NAME SPECIFIED .Q
         BE        ERR1E               NO, ERROR
         CLI       0(R2),LPAREN        DITTO
         BE        ERR1E               NO, ERROR
         ST        R2,FILENMPT         SAVE POINTER TO FILENAME
         XC        FILENEXT(4),FILENEXT  CLEAR MULTIPLE ASSEMBLIES
         CLI       0(R2),C'?'          IS USER IN SEARCH OF HELP .Q
         BE        USERQURY            BRANCH IF YES
         LA        R8,8(,R2)           POINT TO OPTIONS
         CLI       0(R8),FENCE         END OF OPTIONS .Q
         BE        ASMBNCE1            YES, NO OPTIONS
         CLI       0(R8),LPAREN        STARTS WITH '(' .Q
         BE        ASMBNCE1            YES, THAT'S THE LAST ASSEMBLY
         ST        R8,FILENEXT         SET PLIST POINTER TO RESUME
         B         ASMBNCE1            ENTER THE LOOP
ASMBNCE  DS        0H
         LA        R8,8(,R8)           NEXT ENTRY IN PLIST
ASMBNCE1 DS        0H
         TM        PDIRTDNE,X'80'      ARE OPTIONS SCANNED AND BUILT .Q
         BO        SUIT15              YES, BRANCH WAY AHEAD
         CLI       0(R8),FENCE         END NO OPTIONS .Q
         BE        SUIT04              BRANCH IF YES
         CLI       0(R8),LPAREN        START OF OPTIONS .Q
         BE        ASMLAST             START OPTIONS IF NOT
         CLI       0(R8),C'?'          DOES IT START WITH QUESTION .Q
         BE        ASMBNCE             YES, HANDLE THIS LATER
         LR        R1,R8               POINT TO FILENAME
         BAL       R9,STATCHK          CHECK EXISTANCE NOT LEFT OUT '('
         BZ        ASMBNCE             GO BACK IF OK
         LR        R9,R8               POINT TO FILE NAME
         B         ERR002E             ERROR MESSAGE
ASMLAST  DS        0H
*        OPTIONS HANDLING
         LA        R8,8(,R8)           BUMP POINTER TO 1ST OPTION
*        BEGIN THE UNIQUE SCANNING
SUIT14   DS        0H
         CLI       0(R8),RPAREN        END OF OPTIONS .Q
         BE        SUIT04              BRANCH IF YES
         CLI       0(R8),FENCE         ANOTHER WAY OF SAYING
         BE        SUIT04              THE SAME THING
         LA        R4,8(,R8)           POINT TO NEXT DOUBLE WORD
         BCTR      R4,0                LAST BYTE OF ONE BEFORE
BLNKTST  DS        0H
         CLI       0(R4),EQUAL         AN EQUAL SIGN LAST .Q
         BE        BLNKBCT             FORGET IT IF YES
         CLI       0(R4),BLANK         IS THIS THE END .Q
         BNE       BLNKARND            BRANCH IF YES
BLNKBCT  DS        0H
         BCT       R4,BLNKTST          DECREMENT AND BRANCH
BLNKARND DS        0H
         SR        R4,R8               GET LENGTH-1 OF PARM
         BM        ERR3E               THIS MAY BE POSSIBLE
         L         R5,ADOPTEST         POINT TO START OF PARM TABLE
NEXTOPT  DS        0H
         IC        R3,OPTPLEN(,R5)     GET MIN LENGTH-1 OF PARM
         SRL       R3,4                SHIFT
         N         R3,F15              AND PURIFY IT
         CR        R4,R3               IS THIS A CANDIDATE .Q
         BL        BXLE                BRANCH IF NOT
         EX        R4,OPTCLC           DO THE COMPARE
         BE        FOUND               BRANCH IF FOUND
BXLE     DS        0H
         IC        R3,OPTPLEN(,R5)     GET LENGTH-1 OF CHAR
         N         R3,F15              PURIFY LENGTH-1
         LA        R5,OPTCHAR+1(R3,R5) NEXT ENTRY
         CLI       0(R5),FENCE         AT THE END .Q
         BNE       NEXTOPT             BRANCH BACK IF NOT
         B         ERR3E               INVALID OPTION, SO QUIT
OPTCLC   CLC       OPTCHAR(*-*,R5),0(R8)  COMPARE PARM ENTRIES
FOUND    DS        0H
         IC        R3,OPTPFLGS(,R5)    GET PARM TYPE
         N         R3,F15              PURIFY TYPE
         AR        R3,R3               DOUBLE IT
         LH        R3,ONOFFTBL(R3)     GET ROUTINE OFFSET
         B         WMSASM(R3)          DO WHAT CONTROL BYTE SAYS
ONOFFTBL DC        AL2(ON1ON2-WMSASM)    CONTROL BYTE X'0'
         DC        AL2(OFF1OFF2-WMSASM)  CONTROL BYTE X'1'
         DC        AL2(OFF1ON2-WMSASM)   CONTROL BYTE X'2'
         DC        AL2(ONBRNCH-WMSASM)   CONTROL BYTE X'3'
ON1ON2   DS        0H
         OC        PARBYT0(6),OPTPBITS(R5)  TURN ON SWITCH BITS
BUMPPRMP DS        0H
         LA        R8,8(,R8)           POINT TO NEXT PARM
         B         SUIT14              AND CONTINUE
OFF1OFF2 DS        0H
         NC        PARBYT0(6),OPTPBITS(R5)  TURN OFF SWITCH BITS
         B         BUMPPRMP            AND CONTINUE
OFF1ON2  DS        0H
         NC        PARBYT0(2),OPTPBITS(R5)  TURN SOME BITS OFF
         OC        PARBYT0+2(4),OPTPBITS+2(R5)  AND SOME BITS ON
         B         BUMPPRMP            AND CONTINUE
         SPACE
ONBRNCH  DS        0H
         MVI       NUMSWIT,X'00'       INITIALIZE BRACKET SWITCH
         LH        R3,OPTPBITS+2(,R5)  GET ROUTINE OFFSET
         B         WMSASM(R3)          GO TO IT
         SPACE
*        SCAN OFF A NUMBER
ONDIGIT  DS        0H
         LA        R8,8(,R8)           POINT TO NEXT PARM
         CLI       0(R8),LPAREN        PARENS AROUND NUMBER .Q
         BNE       ONDGTLPN            BRANCH IF NOT
         LA        R8,8(,R8)           BUMP OVER LEFT PAREN
         OI        NUMSWIT,X'01'       REMEMBER THERE ARE PARENS
ONDGTLPN DS        0H
         LR        R1,R8               NUMBER POINTER
         LR        R3,R1               REMEMBER 1ST DIGIT OF NUMBER
         CLI       0(R1),RPAREN        END OF PARM .Q
         BE        NUMEND              BRANCH IF YES
         CLI       0(R1),FENCE         END OF PARM AGAIN .Q
         BE        NUMEND              BRANCH IF YES
NUMSCAN  DS        0H
         CLI       0(R1),N0            TEST FOR NUMERIC
         BL        NUMEND              BRANCH IF NOT
         CLI       0(R1),N9            TEST FOR TOO HIGH
         BH        NUMEND              BRANCH IF YES
         LA        R1,1(,R1)           POINT TO NEXT CHARACTER
         B         NUMSCAN             AND LOOP BACK
NUMEND   DS        0H
         LR        R2,R1               TRANSFER END OF STRING
         SR        R2,R3               LESS INITIAL DIGIT
         BZ        ERR3E               ERROR IF NO DIGITS
         C         R2,F7               TEST FOR TOO MANY DIGITS
         BH        ERR3E               ERROR IF TOO BIG
         BCTR      R2,0                LENGTH-1
         EX        R2,PARMPACK         PACK DIGITS INTO DWORD
         CVB       R2,DWORD            GET NUMBER IN BINARY
*        TEST IF NUMBER FOLLOWED BY 'K'
         CLI       0(R1),BLANK         TEST FOR TERMINATING BLANK
         BE        NOK                 OK IF YES
         TM        NUMSWIT,X'01'       IS ARG WITHIN PARENS .Q
         BZ        NUMNOPN             BRANCH IF NOT
         CLI       0(R1),RPAREN        IS THIS A CLOSING BRACKET .Q
         BE        NOK                 BRANCH IF YES
NUMNOPN  DS        0H
         CLI       0(R1),K             TEST FOR LETTER 'K'
         BNE       ERR3E               ERROR IF NOT
         SLA       R2,10               MULTIPLY NUMBER BY 1024
         BO        ERR3E               TEST FOR OVERFLOW
NOK      DS        0H
         LH        R3,OPTPBITS(,R5)    GET PARM LIMIT OFFSET
         LA        R3,WMSASM(R3)       GET PARM LIMIT ADDRESS
         C         R2,KWMIN(,R3)       CHECK FOR BIG ENOUGH
         BL        ERR3E               ERROR IF NOT
         CL        R2,KWMAX(,R3)       CHECK SMALL ENOUGH
         BH        ERR3E               ERROR IF NOT
         ST        R2,KWVALUE(,R3)     STORE CONVERTED NUMBER
         TM        NUMSWIT,X'01'       IS ARE WITHIN PARENS .Q
         BZ        NUMRET              BRANCH IF NOT
         CLI       8(R8),RPAREN        IS CLOSING PAREN PRESENT .Q
         BNE       NUMRET              BRANCH IF NOT
         LA        R8,8(,R8)           BUMP TO CLOSING PAREN
NUMRET   DS        0H
         B         BUMPPRMP            AND CONTINUE
PARMPACK PACK      DWORD(8),0(*-*,R8)  CONVERT KEYWORD OPERAND
*        SCAN OFF SYSPARM AND ITS LENGTH
ONSPARM  DS        0H
         LA        R8,8(,R8)           THIS IS WHERE PARM STARTS
         CLI       0(R8),LPAREN        SYSPARM IN PARENS .Q
         BNE       ONPRMLPN            BRANCH IF NOT
         LA        R8,8(,R8)           BUMP TO PARM START
         OI        NUMSWIT,X'01'       INDICATE PARENS PRESENT
ONPRMLPN DS        0H
         ST        R8,ADSPARM          SAVE PARM ADDRESS
         SR        R3,R3               ZERO LENGTH OF PARM
         CLI       0(R8),RPAREN        END OF PARM .Q
         BNE       ONPRMRPN            BRANCH IF NOT
         TM        NUMSWIT,X'01'       ARG IN PARENS .Q
         BZ        SUIT04              BRANCH TO END IF NOT
         S         R8,F8               POINT BACK TO LEFT PAREN
         B         CHKNULL             CLEAR SYSPARM VALUE
ONPRMRPN DS        0H
         CLI       0(R8),FENCE         END OF PARM
         BE        SUIT04              BRANCH IF YES
         LA        R3,7(,R8)           POINT TO END OF PARM
SYSPTST  DS        0H
         CLI       0(R3),BLANK         IS THIS THE END .Q
         BNE       SYSPARND            BRANCH IF YES
         BCT       R3,SYSPTST          DECREMENT AND BRANCH
SYSPARND DS        0H
         SR        R3,R8               GET LENGTH-1 OF PARM
         BM        ERR3E               BRANCH IF NEGATIVE
         BNZ       SYSPDONE            BRANCH IF NOT ONE
         CLI       0(R8),C'?'          DOES USER WANT PROMPT .Q
         BNE       SYSPDONE            BRANCH IF NOT
         LA        R1,CONWR            ASK FOR SYSPARM VALUE
         SVC       SVC202              ...
         DC        AL4(SYSPDONE)       BAD RETURN
         LA        R1,CMNDLINE         CONSOLE BUFFER ADDR
         STCM      R1,B'0111',CONBUF+1 SAVE PARM ADDR
         STCM      R1,B'0111',ADSPARM+1  AND SAVE AGAIN
         LA        R1,CONRD            TERMINAL READ REQUEST
         SVC       SVC202              ...
         DC        AL4(SYSPDONE)       BAD RETURN
         LH        R3,CONCNT+2         GET BYTES READ
         S         R3,F1               LENGTH-1
         BNM       CHKBLNK             BRANCH IF NOT NULL
CHKNULL  DS        0H
         XC        ADSPARM,ADSPARM     CLEAR SYSPARM
         SR        R3,R3               ZERO LENGTH
         B         SYSPDONE            AND EXIT
CHKBLNK  DS        0H
         LA        R1,CMNDLINE(R3)     END OF USER'S STRING
         CLI       0(R1),C' '          TERMINATING BLANK .Q
         BNE       SYSPDONE            BRANCH IF NOT
         BCT       R3,CHKBLNK          AND LOOP AGAIN
         LTR       R3,R3               NOTHING FOUND .Q
         BM        CHKNULL             BRANCH IF YES
SYSPDONE DS        0H
         LA        R3,1(,R3)           GET ACTUAL LENGTH
         STC       R3,ADSPARM          SAVE LENGTH OF PARM
SYSPCHCK DS        0H
         TM        NUMSWIT,X'01'       WAS PARM IN PARENS .Q
         BZ        SYSPRET             RETURN IF NOT
         CLI       8(R8),RPAREN        TERMINATING PAREN .Q
         BNE       SYSPRET             RETURN IF NOT
         LA        R8,8(,R8)           BUMP TO RIGHT PAREN
SYSPRET  DS        0H
         B         BUMPPRMP            AND CONTINUE
         SPACE
*        SCAN OFF BUFSIZE AND ITS OPERAND
ONSBUFS  DS        0H
         CLI       8(R8),LPAREN        BUFSIZE ARG IN PARENS .Q
         BNE       ONBUFLPN            BRANCH IF NOT
         LA        R8,8(,R8)           POINT TO LEFT PAREN
         OI        NUMSWIT,X'01'       INDICATE PAREN PRESENT
ONBUFLPN DS        0H
         CLC       =C'STD ',8(R8)      STANDARD BUFFERING .Q
         BE        ONBUF01             BRANCH IF YES
         CLC       =C'MIN ',8(R8)      MINIMUM BUFFERING .Q
         BNE       ERR3E               BRANCH IF NOT, ERROR
         OI        PARBYT3,STDMIN      TURN ON MINIMUM
         B         ONBUF02             AND CONTINUE
ONBUF01  DS        0H
         NI        PARBYT3,X'FF'-STDMIN  TURN OFF MINIMUM
ONBUF02  DS        0H
         LA        R8,8(,R8)           NEXT PAREN
         B         SYSPCHCK            AND TEST
         SPACE
*        ALL ELEMENTS OF PLIST ARE SCANNED
SUIT04   DS        0H
         SR        R15,R15             ZERO WORK REGISTER
         TM        PARBYT0,ASMXF+ASMXG CHECK FOR EXTENDED ASSEMBLER
         BNZ       CKASM00             BRANCH IF ONE OF THEM
         TM        PARBYT4,ASMG        ASSEMBLER (G) OR (XF) .Q
         BNO       CKASM01             BRANCH IF NOT
CKASM00  DS        0H
         LA        R15,4(,R15)         BUMP BY FOUR
         TM        PARBYT0,ASMXF       ASSEMBLER (XF) .Q
         BNO       CKASM01             BRANCH IF NOT
         LA        R15,4(,R15)         BUMP BY FOUR
         TM        PARBYT0,ASMXG       ASSEMBLER (XG) .Q
         BNO       CKASM01             BRANCH IF NOT
         LA        R15,4(,R15)         BUMP BY FOUR
*        COULD CHECK FOR (XF) (XG) CONFLICT HERE, BUT ASSUME (XG)
CKASM01  DS        0H
         ST        R15,CKASM           SAVE THIS DECISION FOR LATER
         B         *+4(R15)            GO AS REQUIRED
         B         ENDFSCN             ASSEMBLER (F)
         B         ENDGSCN             ASSEMBLER (G)
         B         ENDXFSCN            ASSEMBLER (XF)
         B         ENDXGSCN            ASSEMBLER (XG)
ENDXGSCN DS        0H
ENDXFSCN DS        0H
ENDFSCN  DS        0H
         NI        PARBYT1,X'FF'-FUPLIST-FLIST-FXREF KILL FULL OPTIONS
         TM        PARBYT2,TERM        IS TERM SPECIFIED .Q
         BO        SUIT23A             YES, CONTINUE
         NI        PARBYT2,X'FF'-NUM-STMT  FORCE 'NONUM,NOSTMT'
         B         SUIT23A             AND CONTINUE
*        ASMG ONLY --  CHECK IF CONFLICTING SPACE PARAMETERS
ENDGSCN  DS        0H
         CLI       SPACEPOS+8,X'FF'    TEST FOR SPACE=N FORM
         BE        TRYMAX              BRANCH IF NOT
         NI        PARBYT2,X'FF'-SPACE TURN OFF SPACE=MAX
OFFMAXN  DS        0H
         MVI       SPACENEG+8,X'FF'    TURN OFF SPACE=MAX-N
         B         SUIT23A             AND CONTINUE
TRYMAX   DS        0H
         TM        PARBYT2,SPACE       TEST FOR SPACE=MAX
         BO        OFFMAXN             BRANCH IF YES
SUIT23A  DS        0H
         TM        PARBYT4,PRDISK      WAS 'NOPRINT' SPECIFIED .Q
         BO        SUIT24A             BRANCH IF NOT
         NI        PARBYT1,X'FF'-FUPLIST-ESD-FLIST-FXREF  TURN OFF
         NI        PARBYT,X'FF'-LIST-RLD-UPLIST-XREF      ANYTHING
         NI        PARBYT2,X'FF'-LREF                     THAT
         NI        PARBYT3,X'FF'-UMAP                     PRINTS
         L         R15,CKASM           GET ASSEMBLER OFFSET
         B         *+4(R15)            GO AS REQUIRED
         B         REFORMAT            (F) GO RECONSTRUCT PARM
         B         REFORMAT            (G) GO RECONSTRUCT PARM
         B         REFORMAT            (XF) GO RECONSTRUCT PARM
         OI        PARBYT,LIST         TURN ON LIST FOR ERRORS
         B         REFORMAT            AND GO RECONSTRUCT PARM
         SPACE
SUIT24A  DS        0H
         TM        PARBYT0,PRINTER     IS SYSPRINT A PRINTER .Q
         BZ        REFORMAT            BRANCH IF NOT
         MVC       LISTDEV(8),PRINTERC SET PRINTER AS OUTPUT DEVICE
         MVC       LISTNAM(LISTEND-OVER),OVER  SET PRINTER OPTIONS
         EJECT
***********************************************************************
*                                                                     *
*        REFORMAT PARM LIST FOR APPROPRIATE ASSEMBLER                 *
*                                                                     *
***********************************************************************
         SPACE
REFORMAT DS        0H
         XC        EXECPARM(2),EXECPARM  ZERO PARM LENGTH
         L         R5,ADOPTEST         POINT TO START OF PARM TABLE
         B         OPTFRST             BRANCH TO FIRST ENTRY
OPTSEAR  DS        0H
         IC        R3,OPTPLEN(,R5)     GET LENGTH-1 OF STRING
         N         R3,F15              PURIFY LENGTH-1
         LA        R5,OPTCHAR+1(R3,R5) NEXT ENTRY POINTER
OPTFRST  DS        0H
         CLI       0(R5),FENCE         TEST FOR LAST ONE
         BE        OPT1                BRANCH IF YES
         L         R15,CKASM           GET ASSEMBLER OFFSET
         B         *+4(R15)            GO AS REQUIRED
         B         OPTASMF             ASSEMBLER (F)
         B         OPTASMG             ASSEMBLER (G)
         B         OPTASMXF            ASSEMBLER (XF)
         B         OPTASMXG            ASSEMBLER (XG)
OPTASMG  DS        0H
         TM        OPTPFLGS(R5),X'40'  APPLICABLE TO (G) .Q
         BO        OPTSEAR             LOOP BACK IF NOT
         MVC       ASMWORK(6),ASMGDEF  SET (G) DEFAULTS
         B         OPTFORG             AND CONTINUE
OPTASMF  DS        0H
         TM        OPTPFLGS(R5),X'80'  APPLICABLE TO (F) .Q
         BO        OPTSEAR             LOOP BACK IF NOT
         MVC       ASMWORK(6),ASMFDEF  SET (F) DEFAULTS
         B         OPTFORG             AND CONTINUE
OPTASMXF DS        0H
         TM        OPTPFLGS(R5),X'20'  APPLICABLE TO (XF) .Q
         BO        OPTSEAR             LOOP BACK IF NOT
         MVC       ASMWORK(6),ASMXFDEF SET (XF) DEFAULTS
         B         OPTFORG             AND CONTINUE
OPTASMXG DS        0H
         TM        OPTPFLGS(R5),X'10'  APPLICABLE TO (XG) .Q
         BO        OPTSEAR             LOOP BACK IF NOT
         MVC       ASMWORK(6),ASMXGDEF SET (XG) DEFAULTS
OPTFORG  DS        0H
         MVC       OPTWORK(6),PARBYT0  MOVE PARMS TO WORK AREA
         MVI       NUMSWIT,X'00'       RESET NUMBER SWITCH
         IC        R3,OPTPFLGS(,R5)    PICK UP CONTROL BYTE
         N         R3,F15              PURIFY IT
         AR        R3,R3               DOUBLE INDEX VALUE
         LH        R3,OPTBTBL(R3)      GET ROUTINE OFFSET
         B         WMSASM(R3)          DO WHAT CONTROL BYTE SAYS
OPTBTBL  DC        AL2(OPTN1N2-WMSASM)      CONTROL BYTE X'0'
         DC        AL2(OPTF1F2-WMSASM)      CONTROL BYTE X'1'
         DC        AL2(OPTF1N2-WMSASM)      CONTROL BYTE X'2'
         DC        AL2(OPTBRNCH-WMSASM)     CONTROL BYTE X'3'
*        DO OPPOSITE OF WHAT PARM SCAN DOES
OPTN1N2  DS        0H
         NC        OPTWORK(6),OPTPBITS(R5)  KILL OTHER SWITCHES
         NC        ASMWORK(6),OPTPBITS(R5)  IN DEFAULTS TOO
         B         OPT2                AND CONTINUE
OPTF1F2  DS        0H
         OC        OPTWORK(6),OPTPBITS(R5)  FORCE SWITCHES
         OC        ASMWORK(6),OPTPBITS(R5)  IN DEFAULTS TOO
         B         OPT2                AND CONTINUE
OPTF1N2  DS        0H
         OC        OPTWORK(2),OPTPBITS(R5)  FORCE SOME SWITCHES
         NC        OPTWORK+2(4),OPTPBITS+2(R5)  KILL SOME OTHERS
         OC        ASMWORK(2),OPTPBITS(R5)  FORCE SOME DEFAULTS
         NC        ASMWORK+2(4),OPTPBITS+2(R5)  KILL SOME OTHERS
         B         OPT2                AND CONTINUE
         SPACE
OPTBRNCH DS        0H
         LH        R3,OPTPBITS+4(,R5)  GET ROUTINE OFFSET
         B         WMSASM(R3)          GO TO IT
         SPACE
OPTDIGIT DS        0H
         LH        R3,OPTPBITS(,R5)    PICK UP OFFSET TO DATA
         LA        R3,WMSASM(R3)       CONVERT TO ADDRESS
         L         R4,KWVALUE(,R3)     PICK UP THE NUMBER
         C         R4,KWDEF(,R3)       DOES IT EQUAL DEFAULT .Q
         BE        OPTSEAR             FORGET FORMATTING THEN
         LTR       R4,R4               IS IT NEGATIVE .Q
         BM        OPTSEAR             NEG MEANS NOT IN EFFECT
         MVI       NUMSWIT,X'01'       SET FOR DIGIT
         B         OPTNAM              AND CONTINUE
OPTCPARM DS        0H
         CLI       ADSPARM,ZERO        IS PARM LENGTH ZERO .Q
         BZ        OPTSEAR             NOTHING IF YES
         MVI       NUMSWIT,X'03'       SET PARM SWITCH
         B         OPTNAM              ENTRY SYSPARM IN LINE
OPT2     DS        0H
         CLC       OPTWORK(6),OPTPBITS(R5)  TEST IF SWITCHES IN EFFECT
         BNE       OPTSEAR             BRANCH BACK IF NOT
         CLC       ASMWORK(6),OPTWORK  WAS THIS A DEFAULT .Q
         BE        OPTSEAR             BRANCH BACK IF YES
*        PLACE NAME ON LINE
OPTNAM   DS        0H
         IC        R3,OPTPLEN(,R5)     GET ACTUAL LENGTH
         N         R3,F15              PURIFY IT
         LH        R1,EXECPARM         GET CURRENT PARM LENGTH
         LTR       R1,R1               FIRST TIME .Q
         BZ        OPTFIRST            BRANCH IF YES
         LA        R1,1(,R1)           BUMP PAST LAST DELIMITER
OPTFIRST DS        0H
         LA        R6,EXECPARM+2(R1)   POINT TO TARGET
         EX        R3,OPTMVC           MOVE IN NAME
         LA        R1,1(R1,R3)         INCREMENT OFFSET PTR
         STH       R1,EXECPARM         STUFF IN LENGTH
         LA        R6,1(R3,R6)         BUMP PARM POINTER
         TM        NUMSWIT,X'03'       TEST NO NUMBER/PARM
         BZ        OPT3                BRANCH IF NONE
         BO        OPTPARMO            BRANCH IF SYSPARM
*        PLACE NUMBER IN PARM
         MVI       NUMSWIT,X'00'       RESET NUMBER SWITCH
         LTR       R3,R4               TEST FOR MULT OF 1024
         BZ        OPT9                ZERO IS 0 NOT 0K
         N         R3,LASTTEN          AND OUT DIFFERENCE
         CR        R3,R4               HAS IT CHANGED .Q
         BNE       OPT9                NOT MULT IF YES
         MVI       NUMSWIT,X'01'       INDICATE MULTIPLE
         SRL       R4,10               DIVIDE BY 1024
OPT9     DS        0H
         CVD       R4,DWORD            CONVERT TO PACKED
         MVC       OPTWORK(8),OPTEDIT  PREPARE TO FIND LENGTH
         LA        R1,OPTWORK+7        IN CASE NUMBER ZERO
         LR        R3,R1               PREPARE TO CALC LENGTH
         EDMK      OPTWORK(8),DWORD+4  CHANGE TO CHARACTER
         TM        NUMSWIT,X'01'       MULT OF 1024 .Q
         BZ        OPTA                BRANCH IF NOT
         LA        R3,1(,R3)           BUMP END PTR BY ONE
         MVI       0(R3),K             ADD THE LETTER 'K'
OPTA     DS        0H
         SR        R3,R1               CALC LENGTH-1
         EX        R3,OPTMNUM          PLACE NUM ON LINE
         LA        R6,1(R3,R6)         INCREMENT PARM POINTER
         LA        R3,1(,R3)           GET ACTUAL VALUE
         AH        R3,EXECPARM         PLUS CURRENT LENGTH
         STH       R3,EXECPARM         PUT IT BACK
OPT3     DS        0H
         MVI       0(R6),BLANK         ANTICIPATE
         L         R15,CKASM           GET ASSEMBLER OFFSET
         B         *+4(R15)            GO AS REQUIRED
         B         OPTCOMA             ASSEMBLER (F)
         B         OPT4                ASSEMBLER (G)
         B         OPTCOMA             ASSEMBLER (XF)
         B         OPTCOMA             ASSEMBLER (XG)
OPTCOMA  DS        0H
         MVI       0(R6),COMMA         PLACE A COMMA
OPT4     DS        0H
         LA        R1,EXECEND          END ADDR OF PARM FIELD
         CR        R1,R6               HAVE WE EXCEEDED END .Q
         BH        OPTSEAR             BRANCH IF NOT
         B         ERR024W             SET ERROR
         SPACE
OPTMVC   MVC       OPTPSTR(*-*,R6),OPTCHAR(R5)  MOVE PARM NAME
OPTMNUM  MVC       0(*-*,R6),0(R1)     PLACE NUMBER ON LINE
         SPACE
*        PLACE SYSPARM ARG ON LINE
OPTPARMO DS        0H
         SR        R3,R3               ZERO WORK REGISTER
         IC        R3,ADSPARM          GET PARM BYTE
         BCTR      R3,0                DECREMENT BY ONE
         L         R4,ADSPARM          GET PARM ADDRESS
         EX        R3,OPTSPRM          MOVE IN PARM
         LA        R6,1(R3,R6)         BUMP END PTR
         LA        R3,1(,R3)           RESTORE ACTUAL LENGTH
         AH        R3,EXECPARM         ADD CURRENT LENGTH
         STH       R3,EXECPARM         PUT UPDATED BACK
         MVI       0(R6),COMMA         COMMA DELIMITER FOR (F) AND (G)
         B         OPT4                AND RETURN
OPTSPRM  MVC       0(*-*,R6),0(R4)     MOVE PARM TO FIELD
OPT1     DS        0H
         EJECT
***********************************************************************
*                                                                     *
*        FOR ANY FILE TO ASSEMBLE, CHECK ITS EXISTENCE,               *
*        RECORD LENGTH AND ERASE UNNECESSARY FILES                    *
*                                                                     *
***********************************************************************
         SPACE     2
SUIT15   DS        0H
         L         R2,FILENMPT         RESTORE FILENAME POINTER
         TM        BATFLAGS,BATRUN     IS BATCH RUNNING .Q
         BZ        SUIT20              BRANCH IF NOT
         MVC       MSG1NAM(8),0(R2)    ENTER FILE NAME
         LA        R1,CONSOL           POINT TO USER AT CONSOLE
         SVC       SVC202              TELL USER ALL ABOUT IT
         DC        AL4(*+4)            IGNORE ERRORS
*
*        VERIFY UPDATE FILE EXISTENCE
SUIT20   DS        0H
         TM        PARBYT2,UPDATE      IS UPDATE OPTION ON .Q
         BZ        SUIT25              BRANCH TO SYSIN IF NOT
         MVC       STATE+8(8),0(R2)    SET FILE NAME
         XC        ODE(2),ODE          CLEAR ODE SPECIFICATION
         MVC       STATE+16(8),SYSUP   SET INPUT TYPE NAME
         LA        R1,STATE            POINT TO PLIST
         SVC       SVC202              VERIFY FILE'S EXISTENCE
         DC        AL4(SUIT21)         ERROR EXIT
         L         R8,AFSTCOPY         GET ADDRESS OF FIRST COPY
         USING     FSTSECT,R8          TELL ASSEMBLER ABOUT IT
         MVC       SYSUMOD(2),FSTM     PROVIDE ASSEM UPDATE MODE
         DROP      R8
         CLI       35(R8),X'50'        LRECL EQUALS EIGHTY .Q
         BE        SUIT25              BRANCH IF YES
         MVC       SYSUNAM(8),0(R2)    SET FILE ID FOR ERRMSG
         LA        R9,SYSUNAM          POINT TO FILE ID
         B         ERR007E             GO WRITE OUT ERROR
SUIT21   DS        0H
         OI        FDEFSWT,ASMSYSUP    SET ERROR SWITCH
         MVC       ERASE+24(2),A1      DUMMY OUT MODE
*
*        VERIFY ASSEMBLE FILE EXISTENCE
SUIT25   DS        0H
         LR        R1,R2               POINT TO FILENAME
         BAL       R9,STATCHK          CHECK STATE OF FILE
         BZ        SUIT16              BRANCH IF FOUND
         OI        FDEFSWT,ASMSYSIN    SET ERROR SWITCH
         MVC       ERASE+24(2),A1      DUMMY OUT MODE
         B         SUIT18A             CLEAR FILES
*
*        SUBROUTINE TO VERIFY EXISTENCE OF ASSEMBLE FILES
*
STATCHK  DS        0H
         MVC       STATE+8(8),0(R1)    SET FILE NAME
         XC        ODE(2),ODE          CLEAR ODE SPECIFICATION
         MVC       STATE+16(8),FMASM1  PRIMARY FILE TYPE
         LA        R1,STATE            POINT TO PLIST
         SVC       SVC202              CAN WE FIND IT .Q
         DC        AL4(STAT24A)        ERROR EXIT
         B         STATRET0            WE FOUND IT
STAT24A  DS        0H
         XC        ODE(2),ODE          CLEAR ODE SPECIFICATION
         MVC       STATE+16(8),FMASM2  SECONDARY FILE TYPE
         LA        R1,STATE            POINT TO PLIST
         SVC       SVC202              CAN WE FIND IT NOW .Q
         DC        AL4(STAT24B)        ERROR EXIT
STATRET0 DS        0H
         MVC       SYSNMD2(8),STATE+16 SAVE TYPE FOR FILEDEF
         CLI       *+1,X'00'           THIS IS SUCCESS
         BR        R9                  AND RETURN
STAT24B  DS        0H
         LTR       R9,R9               NON ZERO CONDITION CODE
         BR        R9                  AND RETURN
*
SUIT16   DS        0H
         L         R8,AFSTCOPY         GET ADDRESS OF FIRST COPY
         USING     FSTSECT,R8          TELL ASSEMBLER ABOUT IT
         MVC       SYSNMOD(2),FSTM     PROVIDE ASSEM SOURCE MODE
         DROP      R8
         CLI       35(R8),X'50'        LRECL EQUALS EIGHTY .Q
         BE        SUIT17              OK IF YES
         MVC       SYSNAM(8),0(R2)     SET FILEID FOR ERRMSG
         LA        R9,SYSNAM           POINT TO FILEID
         B         ERR007E             GO WRITE OUT ERROR
*
*        FIND A R/W DISK FOR WRITING TEXT AND LISTING FILES
*
SUIT17   DS        0H
         L         R1,FSTL(,R8)        GET A(ADT) FROM FSTCOPY
         USING     ADTSECT,R1          AND TELL ASSEMBLER ABOUT IT
         TM        ADTFLG1,ADTFRW      IS ORIGIN OF ASSEM FILE R/W .Q
         BO        USEIT               YES - WRITE BACK TO IT
         CLI       ADTMX,BLANK         NO - IS IT AN EXTENSION .Q
         BE        CONTINUE            NO - DEFAULT TO PRIMARY DISK
         MVC       ADTPARM(1),ADTMX    YES -
         LA        R1,ADTLIST          CALL ADTLKW FOR PARENT DISK
         L         R15,AADTLKW         GET ENTRY ADDRESS FOR ADTLKW
         BALR      R14,R15             DO THE LINK
         BP        CONTINUE            IF PARENT DISK NOT R/W, DEFAULT
*
USEIT    DS        0H
         MVC       WMODE(1),ADTM       IF R/W, USE FOR NEW FILES
         DROP      R1
*
*        PREPARE TO ERASE OLD FILES
*
CONTINUE DS        0H
         MVC       ERASE+24(2),WMODE   SET MODE
SUIT18A  DS        0H
         MVC       ERASE+8(8),0(R2)    SET NAME
         TM        PARBYT,LOAD         DOES USER WANT LOAD .Q
         BZ        SKPERA1             BRANCH IF NOT
         LA        R8,SYSLIN           POINT TO DDNAME
         BAL       R9,ERASEO           ERASE OLD OUTPUT
SKPERA1  DS        0H
         LA        R8,SYSPRINT         POINT TO DDNAME
         BAL       R9,ERASEO           ERASE OLD LISTING
         TM        PARBYT,DECK         DOES USER WANT DECK .Q
         BZ        SKPERA3             BRANCH IF NOT
         LA        R8,SYSPUNCH         POINT TO DDNAME
         BAL       R9,ERASEO           ERASE OLD PUNCH DECK
SKPERA3  DS        0H
         BAL       R7,ERAUTLS          ERASE ALL UTILITIES ON SOURCE
         B         ERADONE             AND CONTINUE
ERAUTLS  DS        0H
         LA        R8,SYSUT1           POINT TO FIRST UTILITY
         BAL       R9,ERASEO           ERASE FILE
         LA        R8,SYSUT2           POINT TO SECOND UTILITY
         BAL       R9,ERASEO           ERASE FILE
         LA        R8,SYSUT3           POINT TO THIRD UTILITY
         BAL       R9,ERASEO           ERASE FILE
         BR        R7                  ALL UTILITY ERASURES DONE
*
*        SUBROUTINE TO ERASE OUTPUT FILES ON DISK
*
ERASEO   DS        0H
         LA        R1,ERASE            POINT TO ERASE PLIST
         MVC       ERASE+16(8),0(R8)   MOVE IN DDNAME
         SVC       SVC202              DO THE ERASURE
         DC        AL4(*+4)            IGNORE IF FILE NOT PRESENT
         BR        R9                  AND RETURN
ERADONE  DS        0H
         EJECT
***********************************************************************
*                                                                     *
*                  INITIALIZATION IN CMS NUCLEUS                      *
*                                                                     *
***********************************************************************
         SPACE
         TM        PDIRTDNE,X'80'      HAVE WE DONE DMSLADAD ALREADY .Q
         BO        STRINIT             BRANCH IF YES
         L         R1,CKASM            ASSEMBLER CODE
         L         R1,ASMDIRT(R1)      APPROPRIATE AUX DIRECTORY
         L         R15,PDIRTASM        PLACE AUX DIRECTORY
         MVC       0(256,R15),0(R1)       MOVE THE ACTUAL AUX DIRECT
         MVC       256(256,R15),256(R1)   AND SOME MORE
         MVC       512(ADIRTLEN-512,R15),512(R1)   AND THE LAST
         SPACE
STRINIT  DS        0H
         STRINIT   ,                   INITIALIZE FREE STORAGE
         L         R15,ADOPTEST        START OF TABLE TO BE OVERLAID
         DMSEXS    ST,R15,MAINHIGH     KLUDGE TO STORAGE MANAGEMENT
*
*        RESERVE A LARGE ENOUGH AREA TO LOAD THE LONGEST ASSEMBLE PATH
         L         R1,CKASM            GET ASSEMBLER INDICATOR
         L         R0,MAXLENG(R1)      GET MAX LENGTH FOR ASSEMBLER
         GETMAIN   R,LV=(0)            GET LONGEST PATH
         L         R0,BLOCK+KWVALUE    GET SYSUT BLOCKSIZE
         LTR       R0,R0               WAS IT SPECIFIED .Q
         BNM       BLOCKOK             BRANCH IF YES
         L         R1,CKASM            GET ASSEMBLER VALUE
         L         R0,ASMBLOCK(R1)     GET ASSEMBLER DEFAULT
         ST        R0,BLOCK+KWVALUE    UPDATE VALUE
BLOCKOK  DS        0H
         L         R0,BFILE+KWVALUE    GET BUFFERED FILE VALUE
         LTR       R0,R0               WAS IT SPECIFIED .Q
         BNM       BFILEOK             BRANCH IF YES
         L         R1,CKASM            GET ASSEMBLER VALUE
         L         R0,ASMFILE(R1)      GET ASSEMBLER DEFAULT
         ST        R0,BFILE+KWVALUE    UPDATE VALUE
BFILEOK  DS        0H
         LTR       R0,R0               ANY BUFFERED FILE .Q
         BNP       GETMARND            BRANCH IF NONE
         L         R1,MAINHIGH         GET USER AREA HIGH
         L         R0,FREELOWE         GET SYSTEM HIGHEST
         SR        R0,R1               GET AMOUNT OF FREE STORAGE
         SRL       R0,1                GET FIFTY PER CENT
         L         R1,CKASM            GET ASSEMBLER INDICATOR
         C         R0,COMPWORK(R1)     ENOUGH FOR PROCESSOR .Q
         BNL       DWORDS              YES, SPLIT FIFTY FIFTY
         SRL       R0,1                NO, TWENTY-FIVE PERCENT
DWORDS   DS        0H
         GETMAIN   R,LV=(0)
GETMARND DS        0H
         STM       R0,R1,FAKENOS       SAVE LENGTH AND ADDRESS
*
*        MOVE FILENAME AND MODE INTO OSSVC PACKAGE
         L         R8,AOPSECT
         MVC       8(8,R8),0(R2)       MOVE FILE NAME
         MVC       24(2,R8),ERASE+24   AND FILE MODE
         L         R15,AADTLKW         SET UP CALL TO ADTLKW
         MVC       ADTPARM,QUESTION    TO FIND DISK WITH MOST AVAIL SP
         LA        R1,ADTLIST          POINT TO PLIST
         BALR      R14,R15
         BH        ERR006E             BRANCH IF NO READ/WRITE DISKS
         USING     ADTSECT,R1          TELL ASSEMBLER
         MVC       SYSUTMOD(1),ADTM
         MVC       ERASE+24(2),SYSUTMOD  SET UP UTILITY ERASE
         DROP      R1
         CLC       SYSUTMOD(1),WMODE   MOST AVAIL SPACE ON SOURCE .Q
         BE        NOERASE             IF SO, ALREADY ERASED SYSUTS
         BAL       R7,ERAUTLS          ERASE ALL UTILITIES
NOERASE  DS        0H
         USING     FCBSECT,R11
         MVC       SUTNAM(8),0(R2)     INITIALIZE SYSUT FILENAME
         L         R1,BLOCK+8          GET UTILITY BLOCKSIZE
         CVD       R1,DWORD            CONVERT TO PACKED
         MVC       OPTWORK(8),OPTEDIT  PREPARE TO FIND LENGTH
         LA        R1,OPTWORK+7        IN CASE NUMBER ZERO
         LR        R3,R1               REMEMBER THE END-1
         EDMK      OPTWORK(8),DWORD+4  EDIT IN BLOCKSIZE
         SR        R3,R1               GET LENGTH-1
         EX        R3,SYSUTMVC         ENTER THE BLKSIZE
         MVC       SYSUTLRL(8),SYSUTBLK  SET LRECL = BLKSIZE
         MVI       DDSYSUT+5,N1        SET UP FILEDEF SYSUT1
         MVI       DD2SYSUT+5,N1
         LA        R1,UTFDEF           FILEDEF SYSUT1
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               YES, GO AWAY
         CLI       BFILE+KWVALUE+3,X'01'  SYSUT1 BUFFERED .Q
         BNE       FDEFUT2             BRANCH IF NOT
         LPR       R11,R0              GET FCB ADDRESS
         OI        FCBIOSW,FCBPROCC    AUXPROC FOR SYSUT1
FDEFUT2  DS        0H
         OI        ASMSW,FRSTCALL      SET FIRST RECORD UTILITY SWITCH
         MVI       DDSYSUT+5,N2        SET UP FILEDEF SYSUT2
         MVI       DD2SYSUT+5,N2
         LA        R1,UTFDEF           POINT TO PLIST
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               YES, GO AWAY
         CLI       BFILE+KWVALUE+3,X'02'  SYSUT2 BUFFERED .Q
         BNE       FDEFUT3             BRANCH IF NOT
         LPR       R11,R0              FCB ADDRESS
         OI        FCBIOSW,FCBPROCC    AUXPROC FOR SYSUT2
FDEFUT3  DS        0H
         MVI       DDSYSUT+5,N3        SET UP FILEDEF SYSUT3
         MVI       DD2SYSUT+5,N3
         LA        R1,UTFDEF           POINT TO FILEDEF PLIST
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               YES, GO AWAY
         CLI       BFILE+KWVALUE+3,X'03'  SYSUT3 BUFFERED .Q
         BNE       TERMDEF             BRANCH IF NOT
         LPR       R11,R0              FCB ADDRESS
         OI        FCBIOSW,FCBPROCC    AUXPROC FOR SYSUT3
TERMDEF  DS        0H
         TM        PARBYT2,TERM        WAS 'TERM' OPTION SPECIFIED .Q
         BZ        DEFSYSIN            NO, NO FILEDEF FOR SYSTERM
         LA        R1,TRMFDEF          SET UP FOR SYSTERM FILEDEF
         SVC       SVC202
         DC        AL4(*+4)
DEFSYSIN DS        0H
         MVC       SYSNAM(8),0(R2)     STORE FILENAME IN SYSIN PLIST
         MVC       SYSUNAM(8),0(R2)    STORE FILENAME IN SYSUP PLIST
         MVC       TEXTMOD(2),WMODE    PROVIDE DISK MODE FOR TEXT
         MVC       TEXTNAM(8),0(R2)    STORE FILENAME IN TEXT PLIST
         TM        PARBYT0,PRINTER     IS SYSPRINT DEVICE PRINTER .Q
         BO        SETFDEF             YES, PLIST ALREADY DONE
         B         DISKLIST            SET EXTRA INFO FOR DISK
SYSUTMVC MVC       SYSUTBLK(*-*),0(R1) ENTER UTILITY BLOCKSIZE
*
DISKLIST DS        0H
         MVC       LISTMOD(2),WMODE    PROVIDE DISK O/P MODE
         MVC       LISTNAM(8),0(R2)    STORE FILENAME IN LISTING PLIST
SETFDEF  DS        0H
         LA        R1,SYSFDEF          SET UP SYSIN FILEDEF
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               BRANCH IF YES
         TM        FDEFSWT,ASMSYSIN    SYSIN FILE ON DISK .Q
         BZ        SETUDEF             YES, GO ON
         LTR       R11,R0              USER FCB PRESENT .Q
         BP        DEVTEST             YES, GO CHECK HIS DEVICE
         LA        R9,SYSNAM           POINT TO ASSEMBLE NAME
         NI        FDEFSWT,X'FF'-ASMSYSIN  NO, ERROR EXIT
         B         ERR002E             GO SET ERROR
DEVTEST  DS        0H
         CLI       FCBDEV,X'14'        IS DEVICE A DISK .Q
         BNE       SETUDEF             NO, SOMETHING ELSE,SO OK
         NI        FDEFSWT,X'FF'-ASMSYSIN  YES, ERROR EXIT
         B         ERR002E             GO SET ERROR
SETUDEF  DS        0H
         TM        PARBYT2,UPDATE      IS UPDATE SPECIFIED .Q
         BZ        SETEXT              BRANCH IF NOT
         LA        R1,SYSUDEF          POINT TO SYSUP FILEDEF
         SVC       SVC202
         DC        AL4(*+4)            ERROR EXIT IGNORED
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               BRANCH IF YES
         TM        FDEFSWT,ASMSYSUP    SYSUP FILE ON DISK .Q
         BZ        SETEXT              YES, GO ON
         LTR       R11,R0              USER FCB PRESENT .Q
         BP        DEVUTEST            YES, GO CHECK HIS DEVICE
         LA        R9,SYSUNAM          POINT TO UPDATE NAME
         NI        FDEFSWT,X'FF'-ASMSYSUP  NO, ERROR EXIT
         B         ERR002E             GO SET ERROR
DEVUTEST DS        0H
         CLI       FCBDEV,X'14'        IS DEVICE A DISK .Q
         BNE       SETEXT              NO SOMETHING ELSE, SO OK
         LA        R9,SYSUNAM          POINT TO UPDATE NAME
         NI        FDEFSWT,X'FF'-ASMSYSUP  YES, ERROR EXIT
         B         ERR002E             GO SET ERROR
SETEXT   DS        0H
         TM        PARBYT,LOAD         IS LOAD OPTION SPECIFIED .Q
         BZ        DEFPUNCH            BRANCH IF NOT
         LA        R1,TXTFDEF          SET UP TEXT FILEDEF
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               BRANCH IF YES
DEFPUNCH DS        0H
         TM        PARBYT,DECK         CHECK FOR 'DECK' OPTION
         BZ        LISTR               NO, CHECK FOR LISTING
         LA        R1,PUNFDEF          YES, SET UP SYSPUNCH FILEDEF
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               BRANCH IF YES
LISTR    DS        0H
         LA        R1,LSTFDEF          SET UP LISTING FILEDEF
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLOSE               BRANCH IF YES
*
FDEFLIB  DS        0H
         LA        R1,LIBFDEF          SET UP CMSLIB FILEDEF
         SVC       SVC202
         DC        AL4(*+4)
         LTR       R15,R15             ANY ERRORS .Q
         BP        CLEARFCB            YES, PROBABLY NO MACLIB FOUND
         EJECT
***********************************************************************
*                                                                     *
*                  CALL THE APPROPRIATE ASSEMBLER                     *
*                                                                     *
***********************************************************************
         SPACE     2
         TM        PDIRTDNE,X'80'      HAVE WE DONE DMSLADAD ALREADY .Q
         BO        POINTASM            BRANCH IF YES
         LA        R1,PDIRTLST         POINT TO SET AUX DIR
         SVC       SVC202              AND DO IT
         DC        AL4(ERR016W)        ERROR EXIT
POINTASM DS        0H
         L         R1,CKASM            GET ASSEMBLER INDICATOR
         AR        R1,R1               DOUBLE OFFSET
         LA        R0,EPASM(R1)        POINT TO ENTRY POINT NAME
         SR        R1,R1               CLEAR DCB POINTER
         SVC       8                   LOAD THE ASSEMBLER
         ST        R0,VASM             SAVE ENTRY POINT ADDRESS
         TM        PARBYT4,STATS       STATISTICS REQUESTED .Q
         BZ        CALLASM             BRANCH IF NOT
         TIME      BIN                 GET TIME OF DAY
         ST        R0,BRTIME           SAVE BEFORE REAL TIME
         LA        R1,BTIME            POINT TO BEFORE TIME AREA
         HVC       R1,R1,HVCTIME       GET TIME STATISTICS BEFORE
CALLASM  DS        0H
         LM        R13,R1,LINK         GET ENTRY REGS FOR ASSEMBLER
         BR        R15                 HELLO ASSEMBLER
*
*        ON RETURN FROM THE ASSEMBLER
*
RETURN   DS        0H
         OI        FDEFSWT,ASMFIN      SIGNAL BACK FROM ASSEMBLER
         ST        R15,CC              SAVE RETURN CODE
         SPACE
         TM        PARBYT4,STATS       STATISTICS REQUESTED .Q
         BZ        RETCMS              BRANCH IF NOT
         LA        R1,ATIME            POINT TO AFTER TIME AREA
         HVC       R1,R1,HVCTIME       GET TIME STATISTICS AFTER
         TIME      BIN                 GET TIME OF DAY
         ST        R0,ARTIME           SAVE AFTER REAL TIME
         LM        R2,R3,AVIRTCPU      AFTER VIRTUAL TIME
         SL        R3,BVIRTCPU+4       LESS BEFORE VIRTUAL TIME
         BO        NOVIRTCA            BRANCH, NO CARRY
         BCTR      R2,0                DECREMENT FIRST HALF
NOVIRTCA DS        0H
         SL        R2,BVIRTCPU         LESS BEFORE VIRTUAL TIME
         D         R2,F10000           FROM MICRO TO 100THS
         SR        R2,R2               ZERO REMAINDER
         D         R2,F6000            SEPARATE SECONDS
         MH        R3,H10000           DECIMAL MINUTES
         AR        R2,R3               COMBINED MINS AND SECS
         CVD       R2,DWORD            CONVERT TO DECIMAL
         MVC       VIRTMASK,STATEDIT   EDIT MASK
         ED        VIRTMASK,DWORD+4    EDIT IN VIRTUAL TIME
         LM        R2,R3,ATOTCPU       AFTER CPU TIME
         SL        R3,BTOTCPU+4        LESS BEFORE CPU TIME
         BO        NOCPUCA             BRANCH, NO CARRY
         BCTR      R2,0                DECREMENT FIRST HALF
NOCPUCA  DS        0H
         SL        R2,BTOTCPU          LESS BEFORE TOTAL CPU TIME
         D         R2,F10000           FROM MICRO TO 100THS
         SR        R2,R2               ZERO REMAINDER
         D         R2,F6000            SEPARATE SECONDS
         MH        R3,H10000           DECIMAL MINUTES
         AR        R2,R3               COMBINED MINS AND SECS
         CVD       R2,DWORD            CONVERT TO DECIMAL
         MVC       CPUMASK,STATEDIT    EDIT MASK
         ED        CPUMASK,DWORD+4     EDIT IN TOTAL CPU TIME
         L         R2,ARTIME           GET REAL AFTER TIME
         C         R2,BRTIME           LESS THAN REAL BEFORE TIME .Q
         BH        NOREALCA            BRANCH IF NOT
         A         R2,HOUR24           ADD 24 HOURS TO AFTER
NOREALCA DS        0H
         SL        R2,BRTIME           LESS START TIME
         SRDL      R2,32               PREPARE FOR DIVIDE
         D         R2,F6000            SEPARATE SEDONDS
         MH        R3,H10000           DECIMAL MINUTES
         AR        R2,R3               COMBINED MINS AND SECS
         CVD       R2,DWORD            CONVERT TO DECIMAL
         MVC       REALMASK,STATEDIT   EDIT MASK
         ED        REALMASK,DWORD+4    EDIT IN REAL TIME
         LA        R1,CONSTAT          POINT TO USER AT CONSOLE
         SVC       SVC202              TELL USER STATS
         DC        AL4(*+4)            IGNORING ALL ERRORS
         L         R15,CC              RESTORE RETURN CODE
         SPACE
RETCMS   DS        0H
         TM        PARBYT2,TERM        TERMINAL DIAG'S REQUESTED .Q
         BO        SUIT19              IF YES, SKIP REDUNDANT MESSAGES
         LA        R1,3                CONSTANT THREE
         NR        R1,R15              CHECK FOR MULTIPLE OF FOUR
         LTR       R1,R1               IS IT .Q
         BNZ       SUIT19              STRANGE RETURN CODE FROM ASM
         C         R15,F16             ALSO IF GT SIXTEEN
         BH        SUIT19              SKIP ANY FINAL MESSAGE
         B         *+4(R15)            JUMP TAB FOR NORMAL RETURNS
         B         SUIT19              RETURN =  0
         B         ERR004W                    =  4
         B         ERR008W                    =  8
         B         ERR012W                    = 12
         B         ERR016W                    = 16
*
*        ERASE UTILITIES
*
SUIT19   DS        0H
         BAL       R7,ERAUTLS          ERASE THREE UTILITIES
CLOSE    DS        0H
         LA        R1,FINIS            FINIS * * * (TO BE SAFE)
         SVC       SVC202
         DC        AL4(*+4)
*
CLEARFCB DS        0H
         MVC       CLEARNAM(8),CLEARALL  CLEAR ALL FCB'S
         LA        R1,CLEARFIL
         SVC       SVC202
         DC        AL4(*+4)
         EJECT
*
*        ALL FILES ARE NOW ASSEMBLED
*
END      DS        0H
         CLC       CC,ERRHIGH          IS THIS HIGHER .Q
         BNH       ENDNOH              BRANCH IF NOT
         MVC       ERRHIGH,CC          SET HIGHER RETURN CODE
ENDNOH   DS        0H
         COMPSWT   OFF                 ASSEMBLER NO LONGER RUNNING
         RELPAGES  ,                   SET RELEASE PAGE BIT
         CLC       ERRHIGH,F16         RETCODE GREATER THAN 16 .Q
         BH        CMDDONE             QUIT NOW IF YES
         L         R2,FILENEXT         GET PLIST REPEAT POINTER
         LTR       R2,R2               IS IT ZERO .Q
         BNZ       ASMLOOP             BRANCH BACK IF NOT
CMDDONE  DS        0H
         TM        PDIRTDNE,X'80'      HAS A CMSLADAD BEEN DONE .Q
         BZ        CMDFIN              BRANCH IF NOT
         LA        R1,PDIRTLST         POINT TO RESET AUX DIRECTORY
         SVC       SVC202              AND RESET IT
         DC        AL4(*+4)            IGNORE ERRORS, TOO LATE
CMDFIN   DS        0H
         L         R14,SVREG14         RESTORE RETURN TO CMS
         L         R15,ERRHIGH         SET RETURN CODE
         BR        R14                 RETURN TO SVCINT
         SPACE     2
USERQURY DS        0H
         LA        R1,ASMTYPED         POINT TO TYPE PLIST
         SVC       SVC202              TELL USER ALL ABOUT IT
         B         END                 RETURN TO SVCINT
         SPACE     2
ERR1E    DS        0H
         LA        R1,ERR001           POINT TO ERROR INFO
         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC
         B         END                 AND RETIRE
         SPACE
ERR002E  DS        0H
         DMSERR    NUM=022,LET=E,SUB=(CHAR8A,(R9)),                    *
               TEXT='FILE ''.................'' NOT FOUND'
         MVI       CC+3,28             SET RETURN CODE
         B         CLOSE               AND QUIT
         SPACE
ERR007E  DS        0H
         DMSERR    NUM=077,LET=E,SUB=(CHAR8A,(R9)),                    *
               TEXT='FILE ''....................'' NOT FIXED, LRECL 80'
         MVI       CC+3,32             SET RETURN CODE
         B         CLOSE               AND QUIT
         SPACE
ERR006E  DS        0H
         DMSERR    NUM=6,LET=E,TEXT='NO READ/WRITE DISK ACCESSED'
         MVI       CC+3,36             SET RETURN CODE
         B         END                 AND QUIT
         SPACE
ERR3E    DS        0H
         DMSERR    NUM=3,LET=E,SUB=(CHARA,(R8)),                       *
               TEXT='INVALID OPTION ''........'''
         MVI       CC+3,24             SET RETURN CODE
         B         END                 AND QUIT
         SPACE
ERR004W  DS        0H
         LA        R1,ERR004           POINT TO ERROR INFO
         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC
         B         SUIT19              AND QUIT
         SPACE
ERR008W  DS        0H
         LA        R1,ERR008           POINT TO ERROR INFO
         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC
         B         SUIT19              AND QUIT
         SPACE
ERR012W  DS        0H
         LA        R1,ERR012           POINT TO ERROR INFO
         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC
         B         SUIT19              AND QUIT
         SPACE
ERR016W  DS        0H
         LA        R1,ERR016           POINT TO ERROR INFO
         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC
         B         SUIT19              AND QUIT
         SPACE
ERR024W  DS        0H
         LA        R1,ERR024           POINT TO ERROR INFO
         BAL       R14,ERRCOMON        OUTPUT DIAGNOSTIC
         B         END                 AND QUIT
         SPACE
ERRCOMON DS        0H
         MVC       CC+3(1),0(R1)       SET RETURN CODE
         MVC       ERDMSERR+2(1),0(R1) SET ERROR CODE
         MVC       ERDMSMSG,1(R1)      SET MESSAGE LENGTH AND MESSAGE
         LA        R1,ERDMSERR         POINT AT AREA
         SVC       SVC203              OUTPUT THE DIAGNOSTIC
         DC        H'-6'               FUNCTION CODE
         BR        R14                 AND RETURN
         SPACE
ERR001   DC        AL1(1),AL1(ERR001E-*-1),C'NO FILENAME SPECIFIED'
ERR001E  EQU       *
ERR004   DC        AL1(4),AL1(ERR004E-*-1),C'WARNING MESSAGES'
ERR004E  EQU       *
ERR008   DC        AL1(8),AL1(ERR008E-*-1),C'ERROR MESSAGES'
ERR008E  EQU       *
ERR012   DC        AL1(12),AL1(ERR012E-*-1),C'SEVERE ERROR MESSAGES'
ERR012E  EQU       *
ERR016   DC        AL1(16),AL1(ERR016E-*-1),C'TERMINAL ERROR MESSAGES'
ERR016E  EQU       *
ERR024   DC        AL1(24),AL1(ERR024E-*-1),C'PARM STRING TOO LONG'
ERR024E  EQU       *
         EJECT
***********************************************************************
*                                                                     *
*                  PARAMETER LIST FOR THE ASSEMBLER                   *
*                                                                     *
***********************************************************************
         SPACE
SAVEAREA DC        18F'0'              OS SAVE AREA FOR ASSEMBLER
LINK     DC        A(SAVEAREA)         R13
         DC        A(RETURN)           R14
VASM     DC        A(0)                R15  V(IEUASM|ASMGASM|IFOX00)
         DC        A(0)                R0
         DC        A(PARAMLST)         R1
SVREG14  DC        A(0)                RETURN TO CMS
FILENMPT DC        A(0)                FILENAME POINTER
FILENEXT DC        A(0)                NEXT FILENAME TO BE ASSEMBLED
ADSPARM  DC        X'00',AL3(0)        SYSPARM LENGTH AND ADDRESS
*
PARAMLST DC        A(EXECPARM)
         DC        X'80',AL3(DDNAMES)
*
ERDMSERR DC        AL1(64,192)         DMSERR OPERAND LIST
         DC        AL2(*-*),CL1'W',CL3'WMS'
ERDMSMSG DC        0CL100' '           ERROR MESSAGE
*
EXECPARM DC        H'0',CL100' '       OS PARM FIELD
EXECEND  EQU       *
*
DDNAMES  DC        AL2(DDFIN-*-2)      ASSEMBLER OVERRIDING DDNAMES
SYSLIN   DC        CL8'TEXT'           SYSLIN
SYSTERM  DC        CL8'SYSTERM'        SYSTERM
SYSUP    DC        CL8'UPDATE'         SYSUP
SYSLIB   DC        CL8'CMSLIB'         SYSLIB
SYSIN    DC        CL8'ASSEMBLE'       SYSIN
SYSPRINT DC        CL8'LISTING'        SYSPRINT
SYSPUNCH DC        CL8'PUNCH'          SYSPUNCH
SYSUT1   DC        CL8'SYSUT1'         SYSUT1
SYSUT2   DC        CL8'SYSUT2'         SYSUT2
SYSUT3   DC        CL8'SYSUT3'         SYSUT3
SYSGO    DC        CL8'TEXT'           SYSGO
SYSTERM2 DC        CL8'SYSTERM'        SYSTERM
DDFIN    EQU       *
         EJECT
*
*        ENTRIES OF KEYWORD NUMERIC PARMS.
*          1ST WORD IS MINIMUM VALUE ACCEPTABLE
*          2ND WORD IS MAXIMUM VALUD ACCEPTABLE (IF -1, NO MAX)
*          3RD WORD IS WORKING VALUE TO BE PASSED
*          4TH WORD IS DEFAULT VALUE.
*
         SPACE
KWMIN    EQU       0
KWMAX    EQU       KWMIN+4
KWVALUE  EQU       KWMAX+4
KWDEF    EQU       KWVALUE+4
         SPACE
BFILE    DC        F'0',F'3',2F'-1'
BLOCK    DC        F'1',F'7294',2F'-1'
EXTIME   DC        F'1',F'999',2F'5'
LSETC    DC        F'0',F'255',2F'8'
INSTSET  DC        F'0',F'99',2F'1'
SPACEPOS DC        A(20*1024),F'-1',2F'-1'
SPACENEG DC        F'8',F'-1',2F'2048'
COLUMN   DC        F'0',F'3',2F'1'
UPCOND   DC        F'1',F'20',2F'12'
CALIGN   DC        F'0',F'255',2F'0'
FLAG     DC        F'0',F'255',2F'0'
UTBUFF   DC        F'0',F'3',2F'3'
LINECNT  DC        F'0',F'254',2F'55'
*
PARBYT0  DC        AL1(0)              *PARBYT0
PRINTER  EQU       X'80',,1            *         LISTING TO PRINTER
FULLTERM EQU       X'40',,2            *         FULL TERM OUTPUT
ASMXF    EQU       X'20',,3            *         ASSEMBLER (XF)
ASMXG    EQU       X'10',,4            *         ASSEMBLER (XG)
*        EQU       X'08',,5            *         RESERVED
*        EQU       X'04',,6            *         RESERVED
*        EQU       X'02',,7            *         RESERVED
*        EQU       X'01',,8            *         RESERVED
*
PARBYT1  DC        AL1(EXTEN+ALGN)     *PARBYT1
FUPLIST  EQU       X'80',,9            *         FULLUPLIST
DOS      EQU       X'40',,10           *         DOS
ESD      EQU       X'20',,11           *         ESD
BATCH    EQU       X'10',,12           *         BATCH
FLIST    EQU       X'08',,13           *         FULLLIST
EXTEN    EQU       X'04',,14           *         EXTEN
FXREF    EQU       X'02',,15           *         FULLXREF
ALGN     EQU       X'01',,16           *         ALGN
*
PARBYT   DC        AL1(LOAD+LIST+UPLIST+XREF)  *PARBYT
DECK     EQU       X'80',,17           *         DECK
LOAD     EQU       X'40',,18           *         LOAD
RENT     EQU       X'20',,19           *         RENT
LIST     EQU       X'10',,20           *         LIST
RLD      EQU       X'08',,21           *         RLD
UPLIST   EQU       X'04',,22           *         UPLIST
XREF     EQU       X'02',,23           *         XREF
TEST     EQU       X'01',,24           *         TESTRAN
*
PARBYT2  DC        AL1(LREF+TERM+NUM+STMT)  *PARBYT2
LREF     EQU       X'80',,25           *         LREF
UPDATE   EQU       X'40',,26           *         UPDATE
EXECUTE  EQU       X'20',,27           *         EXECUTE
SPACE    EQU       X'10',,28           *         SPACE=MAX
TERM     EQU       X'08',,29           *         TERM
NUM      EQU       X'04',,30           *         NUM
STMT     EQU       X'02',,31           *         STMT
*        EQU       X'01',,32           *         RESERVED
*
PARBYT3  DC        AL1(0)              *PARBYT3
UMAP     EQU       X'80',,33           *         UMAP
CMS      EQU       X'40',,34           *         CMS
XREFFS   EQU       X'20',,35           *         XREF(FULL/SHORT)
ALOGIC   EQU       X'10',,36           *         ASSEMBLER LOGIC
MLOGIC   EQU       X'08',,37           *         MACRO LOGIC
MCALL    EQU       X'04',,38           *         MACRO CALL
STDMIN   EQU       X'02',,39           *         BUFSIZE(STD/MIN)
UNUSED   EQU       X'01',,40           *         UNUSED
*
PARBYT4  DC        AL1(ASMG+PRDISK+YFLAG)  *PARBYT4
ASMG     EQU       X'80',,41           *         ASSEMBLER (G)
PRDISK   EQU       X'40',,42           *         LISTING TO DISK
STATS    EQU       X'20',,43           *         STATISTICS TO TERMINAL
YFLAG    EQU       X'10',,44           *         Y-CON DIAGNOSTIC
*        EQU       X'08',,45           *         RESERVED
*        EQU       X'04',,46           *         RESERVED
*        EQU       X'02',,47           *         RESERVED
*        EQU       X'01',,48           *         RESERVED
*
ASMFDEF  DC        AL1(0,ALGN,DECK+LIST+XREF,0,0,0)  (F) DEFAULTS
ASMGDEF  DC        AL1(0,EXTEN+ALGN,LOAD+LIST+UPLIST+XREF,LREF+STMT+NUM*
               ,UMAP,YFLAG)  ASSEMBLER (G) DEFAULTS
ASMXFDEF DC        AL1(0,ALGN+ESD,DECK+LIST+RLD+XREF,0,0,YFLAG)  (XF)
ASMXGDEF DC        AL1(0,ALGN+ESD,DECK+LIST+RLD+XREF,0,0,0) (XG) DEFS
         SPACE
         DC        0D'0'               FOR ALIGNMENT
EPASM    DC        CL8'IEUASM'         ENTRY NAME FOR ASSEMBLER (F)
         DC        CL8'ASMGASM'        ENTRY NAME FOR ASSEMBLER (G)
         DC        CL8'IFOX00'         ENTRY NAME FOR ASSEMBLER (XF)
         DC        CL8'AXH90'          ENTRY NAME FOR ASSEMBLER (XG)
         SPACE
DWORD    DC        D'0'                FOR CONVERSIONS
OPTWORK  DC        XL8'00'             FOR OPTION WORK
ASMWORK  DC        XL8'00'             FOR DEFAULT OPTION WORK
*
SVC202   EQU       202                 SVC 202
SVC203   EQU       203                 SVC 203
HVCTIME  EQU       X'0C'               DIAGNOSE TIME
*
R0       EQU       0
R1       EQU       1
R2       EQU       2
R3       EQU       3
R4       EQU       4
R5       EQU       5
R6       EQU       6
R7       EQU       7
R8       EQU       8
R9       EQU       9
R10      EQU       10
R11      EQU       11
R12      EQU       12
R13      EQU       13
R14      EQU       14
R15      EQU       15
*
ZERO     EQU       X'00'               BINARY ZERO
K        EQU       C'K'                THE LETTER 'K'
FENCE    EQU       X'FF'               END OF THE LINE
RPAREN   EQU       C')'                RIGHT PAREN
LPAREN   EQU       C'('                LEFT PAREN
N0       EQU       C'0'                CHARACTER ZERO
N1       EQU       C'1'                CHARACTER ONE
N2       EQU       C'2'                CHARACTER TWO
N3       EQU       C'3'                CHARACTER THREE
N9       EQU       C'9'                CHARACTER NINE
COMMA    EQU       C','                COMMA
BLANK    EQU       C' '                BLANK
EQUAL    EQU       C'='
*
F1       DC        F'1'                CONSTANT ONE
F7       DC        F'7'                CONSTANT SEVEN
F8       DC        F'8'                FULLWORD EIGHT
F15      DC        F'15'               CONSTANT FIFTEEN
F16      DC        F'16'               CONSTANT SIXTEEN
H16      EQU       F16+2               HALFWORD SIXTEEN
LASTTEN  DC        X'FFFFFC00'         LAST TEN BITS OFF
QUESTION DC        C'??'               QUESTION MARKS
OPTEDIT  DC        X'4020202020202120' EDIT MASK
*
NUMSWIT  DC        X'00'               NUMBER SWITCH
STATEDIT DC        C' ',X'202120',C':',X'2020',C'.',X'2020'  TIME MASK
*
WMODE    DC        CL2'A1'             MODE FOR DISK OUTPUT
         EJECT
***********************************************************************
*                                                                     *
*                  MANDATORY FILE SETUPS                              *
*                                                                     *
***********************************************************************
         SPACE     2
SYSFDEF  DC        0D'0'
         DC        CL8'FILEDEF'
         DC        CL8'ASSEMBLE'
         DC        CL8'DISK'
SYSNAM   DC        CL8' '
SYSNMD2  DC        CL8'ASSEMBLE'
SYSNMOD  DC        CL8'A1'
         DC        CL8'('
         DC        CL8'RECFM'
         DC        CL8'FB'
         DC        CL8'LRECL'
         DC        CL8'80'
         DC        CL8'BLOCK'
         DC        CL8'800'
         DC        CL8'NOCHANGE'
         DC        8X'FF'
         SPACE
SYSUDEF  DC        0D'0'
         DC        CL8'FILEDEF'
         DC        CL8'UPDATE'
         DC        CL8'DISK'
SYSUNAM  DC        CL8' '
         DC        CL8'UPDATE'
SYSUMOD  DC        CL8'A1'
         DC        CL8'('
         DC        CL8'RECFM'
         DC        CL8'FB'
         DC        CL8'LRECL'
         DC        CL8'80'
         DC        CL8'BLOCK'
         DC        CL8'800'
         DC        CL8'NOCHANGE'
         DC        8X'FF'
         SPACE
TXTFDEF  DC        0D'0'
         DC        CL8'FILEDEF'
         DC        CL8'TEXT'
TEXTDEV  DC        CL8'DISK'
TEXTNAM  DC        CL8' '
         DC        CL8'TEXT'
TEXTMOD  DC        CL8' '
         DC        CL8'('
         DC        CL8'NOCHANGE'
         DC        8X'FF'
         SPACE
PUNFDEF  DS        0D'0'
         DC        CL8'FILEDEF'
         DC        CL8'PUNCH'
         DC        CL8'PUNCH'
         DC        CL8'('
         DC        CL8'RECFM'
         DC        CL8'F'
         DC        CL8'LRECL'
         DC        CL8'80'
         DC        CL8'BLOCK'
         DC        CL8'80'
         DC        CL8'NOCHANGE'
         DC        8X'FF'
         SPACE
LSTFDEF  DC        0D'0'
         DC        CL8'FILEDEF'
         DC        CL8'LISTING'
LISTDEV  DC        CL8'DISK'
LISTNAM  DC        CL8' '
         DC        CL8'LISTING'
LISTMOD  DC        CL8' '
OVER     DC        CL8'('
         DC        CL8'RECFM'
         DC        CL8'FB'
         DC        CL8'BLOCK'
         DC        CL8'1210'
         DC        CL8'NOCHANGE'
         DC        CL8'AUXPROC'
         DC        AL4(LISTPROC,0)
         DC        8X'FF'
LISTEND  DC        0D'0'
         SPACE
UTFDEF   DC        0D'0'
         DC        CL8'FILEDEF'
DDSYSUT  DC        CL8'SYSUT1'
DISK     DC        CL8'DISK'
SUTNAM   DC        CL8' '
DD2SYSUT DC        CL8'SYSUT1'
SYSUTMOD DC        CL8' 4'
         DC        CL8'('
         DC        CL8'NOCHANGE'
         DC        CL8'BLOCK'
SYSUTBLK DC        CL8'X       '
         DC        CL8'LRECL'
SYSUTLRL DC        CL8'X       '
         DC        CL8'AUXPROC'
         DC        AL4(ASMPROC,0)
         DC        8X'FF'
         SPACE
LIBFDEF  DC        0D'0'
         DC        CL8'FILEDEF'
         DC        CL8'CMSLIB'
         DC        CL8'DISK'
         DC        CL8'CMSLIB'
         DC        CL8'MACLIB'
         DC        CL8'*'
         DC        CL8'(LRECL'
         DC        CL8'80'
         DC        CL8'RECFM'
         DC        CL8'FB'
         DC        CL8'BLOCK'
         DC        CL8'800'
         DC        CL8'CONCAT'
         DC        CL8'NOCHANGE'
         DC        8X'FF'
         SPACE
CLEARFIL DC        0D'0'
         DC        CL8'FILEDEF'
CLEARNAM DC        CL8'*'
         DC        CL8'CLEAR'
         DC        8X'FF'
         SPACE
TRMFDEF  DC        0D'0'
         DC        CL8'FILEDEF'
         DC        CL8'SYSTERM'
         DC        CL8'TERMINAL'
         DC        CL8'('
         DC        CL8'AUXPROC'
         DC        AL4(TERMPROC,0)
         DC        CL8'NOCHANGE'
         DC        8X'FF'
         SPACE
ADTLIST  DC        0D'0'
         DC        CL24' '             IMMATERIAL
ADTPARM  DC        CL2'  '             CODE FOR ADTLKW CALLS
         DC        CL8'SYSUT1'
         DC        CL8'SYSUT2'
         DC        CL8'SYSUT3'
CLEARALL DC        CL8'*'
         SPACE
PRINTERC DC        CL8'PRINTER'
         SPACE     2
ASMTYPED DC        0D'0'
         DC        CL8'TYPE'
         DC        CL8'ASSEMBLE'
         DC        CL8'MEMO'
         DC        CL8'S'
         DC        8X'FF'
         SPACE     2
FMASM1   DC        CL8'ASSEMBLE'       PRIMARY SYSIN TYPE
FMASM2   DC        CL8'ASM'            SECONDARY SYSIN TYPE
         EJECT
***********************************************************************
*                                                                     *
*                       CALLING SEQUENCE                              *
*                                                                     *
***********************************************************************
         SPACE     2
         DC        0D'0'
STATE    DC        CL8'STATE'
         DC        CL8' '              FILENAME
         DC        CL8' '              FILE TYPE
ODE      DC        CL2'0'              FILE MODE
         DC        CL2'0'              UNUSED
AFSTCOPY DC        A(0)                ADDRESS OF FST COPY LOCATION
         SPACE
         DC        0D'0'
ERASE    DC        CL8'ERASE'
         DC        CL8' '              FILENAME
         DC        CL8' '              FILE TYPE
         DC        CL2' '              FILE MODE
         SPACE
         DC        0D'0'
PDIRTLST DC        CL8'DMSLADAD'
PDIRTASM DC        A(ANYDIRT)          ADDR OF DIRECTORY LIST
PDIRTDNE DC        F'0'                FOR CMS USE
         DC        8X'FF'
         SPACE
         DC        0D'0'
FINIS    DC        CL8'FINIS'
         DC        CL8'*'
         DC        CL8'*'
         DC        CL8'*'
         SPACE
         DC        0D'0'
CONSOL   DC        CL8'TYPLIN'
         DC        AL1(1)
         DC        AL3(MSG1)           MESSAGE ADDRESS
         DC        C'R'
         DC        AL3(EMSG1-MSG1)     MESSAGE LENGTH
         SPACE
         DC        0D'0'
CONSTAT  DC        CL8'TYPLIN'
         DC        AL1(1)
         DC        AL3(MSGSTAT)        MESSAGE ADDRESS
         DC        C'R'
         DC        AL3(MSGSTATE-MSGSTAT)  MESSAGE LENGTH
         SPACE
         DC        0D'0'
CONWR    DC        CL8'TYPLIN'         CONSOLE WRITE LIST
         DC        AL1(1),AL3(SYSMSG)
         DC        CL1'B',AL3(L'SYSMSG)
         SPACE
         DC        0D'0'
CONRD    DC        CL8'CONREAD'        CONSOLE READ LIST
CONBUF   DC        AL1(1),AL3(*-*)
CONCNT   DC        CL1'V',AL3(*-*)
         SPACE
SYSMSG   DC        C' ENTER SYSPARM: '
         EJECT
***********************************************************************
*                                                                     *
*                            DATA                                     *
*                                                                     *
***********************************************************************
         SPACE     2
CKASM    DC        A(*-*)              (F), (G), (XF) OR (XG)
CC       DC        F'0'
CCAUXP   DC        F'0'                AUXPROC RETURN CODE
ERRHIGH  DC        F'0'                HIGHEST RETURN CODE PASSED BACK
MSG1     DC        C' ASSEMBLING: '
MSG1NAM  DC        CL8' '              FILE NAME
EMSG1    EQU       *
         SPACE
MSGSTAT  DC        C'*** VIRTCPU='
VIRTMASK DC        C' MMM:SS.TH'
         DC        C' TOTCPU='
CPUMASK  DC        C' MMM:SS.TH'
         DC        C' REAL='
REALMASK DC        C' MM:SS.TH'
         DC        C' ***'
MSGSTATE EQU       *
         SPACE
A1       DC        CL2'A1'
         SPACE
ADOPTEST DC        A(OPTEST)           OPTIONS TABLE
AASMHAND DC        A(ASMPROC)          AUXILLARY I/O HANDLING
         SPACE
ASMDIRT  DC        A(ASMFDIRT)         POINTER TO ASMF AUX DIRECTORY
         DC        A(ASMGDIRT)         POINTER TO ASMG AUX DIRECTORY
         DC        A(ASMXDIRT)         POINTER TO ASMXF AUX DIRECTORY
         DC        A(ASMYDIRT)         POINTER TO ASMXG AUX DIRECTORY
         SPACE
ASMFILE  DC        F'2'                SYSUT2 FOR ASSEMBLER (F)
         DC        F'0'                NOTHING FOR ASSEMBLER (G)
         DC        F'1'                SYSUT1 FOR ASSEMBLER (XF)
         DC        F'0'                NOTHING FOR ASSEMBLER (XG)
         SPACE
ASMBLOCK DC        F'4000'             UTILITY BLKSIZE FOR (F)
         DC        F'4000'             UTILITY BLKSIZE FOR (G)
         DC        F'7294'             UTILITY BLKSIZE FOR (XF)
         DC        F'4000'             UTILITY BLKSIZE FOR (XG)
         SPACE
COMPWORK DC        X'00020000'         MIN ASSEMBLER (F) WORK
         DC        X'00020000'         MIN ASSEMBLER (G) WORK
         DC        X'00020000'         MIN ASSEMBLER (XF) WORK
         DC        X'00020000'         MIN ASSEMBLER (XG) WORK
         SPACE
MAXLENG  DC        X'00008000'         LONGEST ASSEMBLER (F) PATH
         DC        X'0000A800'         LONGEST ASSEMBLER (G) PATH
         DC        X'00007000'         LONGEST ASSEMBLER (XF) PATH
         DC        X'00016000'         LONGEST ASSEMBLER (XG) PATH
         SPACE
BTIME    DC        4D'0'               BEFORE STATISTICS TIME
         ORG       BTIME
BMMDDYY  DC        D'0'                MM/DD/YY
BHHMMSS  DC        D'0'                HH:MM:SS
BVIRTCPU DC        D'0'                VIRTUAL CPU TIME
BTOTCPU  DC        D'0'                TOTAL CPU TIME
         SPACE
ATIME    DC        4D'0'               AFTER STATISTICS TIME
         ORG       ATIME
AMMDDYY  DC        D'0'                MM/DD/YY
AHHMMSS  DC        D'0'                HH:MM:SS
AVIRTCPU DC        D'0'                VIRTUAL CPU TIME
ATOTCPU  DC        D'0'                TOTAL CPU TIME
         SPACE
BRTIME   DC        F'0'                BEFORE REAL TIME
ARTIME   DC        F'0'                AFTER REAL TIME
         SPACE
FAKENOS  DC        2A(*-*)             LENGTH/ADDRESS OF RESERVED AREA
HALFWORD DC        F'65535'
FDEFSWT  DC        X'00'
ASMFIN   EQU       X'40'               ON IF ASSEMBLER CALLED
ASMSYSIN EQU       X'08'               SYSIN ON DISK SWITCH
ASMSYSUP EQU       X'04'               SYSUP ON DISK SWITCH
         SPACE
ASMSW    DC        X'00'               ASSEMBLER SWITCHES
NOCORE   EQU       X'80'               RAN OUT OF UTILITY CORE
TODISK   EQU       X'40'               FURTHER RECORDS TO DISK
NOTERM   EQU       X'20'               DON'T TYPE SYSTERM LINE
FRSTCALL EQU       X'10'               UTILITY FIRST TIME SWITCH
         SPACE
F256     DC        F'256'
F255     DC        F'255'
F4000    DC        F'4000'
HALF99   DC        H'99'
F6000    DC        F'6000'
F10000   DC        F'10000'
H10000   EQU       F10000+2
HOUR24   DC        A(24*60*60*100)     24 HOURS OF 100THS SECS
         DROP      R12                 FORGET MY BASE
         DROP      R13                 AND MY DATA/WORK AREA
         EJECT
*
*        SPECIAL HANDLING ROUTINE.  ENTERED FROM 'EOBROUTN'.
*
*        UPON ENTRY --
*               R1  -- A(DECB)
*               R2  -- A(DCB)
*               R8  -- A(OPSECT)
*               R11 -- A(FCBSECT)
*               R14 -- A(RETURN)
*               R15 -- A(ASMPROC)
*
*        UPON RETURN  --  ALL REGISTERS RESTORED, EXCEPT R15.
*               R15 -- 0  EXECUTE I/O REQUEST
*               R15 GT 0  RESIDUAL COUNT
*               R15 LT 0  ERROR CODE
*
         SPACE     2
ASMPROC  DS        0H
         PUSH      USING
         USING     ASMPROC,R15         ENTRY ADDRESS
         USING     NUCON,R0            CMS NUCLEUS
         USING     FCBSECT,R11
         STM       R0,R15,SAVEREGS     SAVE CALLER'S REGISTERS
         LR        R12,R15             TRANSFER ENTRY ADDRESS
         DROP      R15                 DROP ENTRY ADDRESS
         USING     ASMPROC,R12         USE NEW ADDRESS
         USING     UTENTRY,R2
         USING     UTHEAD,R5
         USING     OPSECT,R3
         LA        R0,ASMPROC-SAVEAREA OFFSET TO SAVE AREA
         LR        R13,R12             TRANSFER BASE ADDRESS
         SR        R13,R0              DECREMENT R13 TO SECOND BASE
         USING     SAVEAREA,R13        BASE FOR DATA/WORK AREA
*
*        DETERMINE WHICH DATA SET NEEDS SPECIAL HANDLING
         SPACE
*        DETERMINE WHICH UTS NEED SPECIAL HANDLING
         CLC       FCBDD(5),SYSUT1     IS THIS A UTILITY FILE .Q
         BNE       RETURN1             NO, RETURN TO O/S SIMULATION
         IC        R15,FCBDD+5         GET UTILITY NUMBER
         N         R15,F15             PURIFY IT
         C         R15,BFILE+KWVALUE   THIS ONE TO BE SIMULATED .Q
         BE        SYSUTY              YES, BRANCH
         TM        FCBRECFM,X'C0'      IS FILE RECFM 'U' .Q
         BNO       RETURN1             NO, RETURN TO O/S SIMULATION
         SPACE
SYSUTX   DS        0H
         MVI       FCBFORM,C'F'        FORCE RECFM OF FIXED
         TM        IOBIOFLG,IOBIN      ARE WE DOING INPUT .Q
         BO        RETURN1             YES, RETURN
         L         R15,F4000           FOR FAST I/O SIMULATION
         C         R15,BLOCK+KWVALUE   LARGE ENOUGH .Q
         BNL       SYSSETB             BRANCH IF YES
         AR        R15,R15             DOUBLE IT
SYSSETB  DS        0H
         STH       R15,FCBBYTE+2       FORCE EVEN LENGTH FOR FAST I/O
         B         RETURN1             RETURN TO O/S SIMULATION
         SPACE
SYSUTY   DS        0H
         TM        ASMSW,NOCORE        ARE THERE CORE PROBLEMS .Q
         BO        SYSUTX              YES, RETURN
         TM        ASMSW,FRSTCALL      IS THIS FIRST CALL .Q
         BO        UTSETUP             YES, GO AND SETUP CORE
         L         R5,UTSAV            GET ADDRESS OF ENTRIES TABLE
         LTR       R5,R5               ANY CORE OBTAINED .Q
         BZ        SYSUTX              NO, JUST RETURN
         TM        FCBIOSW,FCBCLOSE    ARE WE IN CLOSE EXIT .Q
         BO        UTFIN               YES, CHECK NOT TCLOSE
         SPACE
UTCOMM   DS        0H
         LH        R6,FCBITEM          GET ITEM NUMBER
         N         R6,HALFWORD         MASK IT FOR NEXT COMPARE
         CH        R6,UTCORENT         IS IT HIGHER THAN OUT LAST .Q
         BH        UTEOF               YES, IS EOF OR WE NEED CORE
         SLL       R6,3                ADJUST ENTRY INDEX
         LA        R2,0(R5,R6)         GET PROPER RECORD ENTRY
UTSET    DS        0H
         LH        R6,FCBBYTE+2        GET NUMBER OF BYTES TO MOVE
         TM        IOBIOFLG,IOBIN      ARE WE DOING INPUT .Q
         BZ        UTWRITE             NO, THEN GO TO WRITE
         CH        R6,UTRECLN          IS NUM OF BYTES GT OURS .Q
         BH        UTEOF2              YES, DEFINITELY EOF
         L         R5,UTRECAD          GET INCORE RECORD ADDRESS
         L         R4,FCBBUFF          GET USERS BUFFER ADDRESS
         B         PREMOVE             GO TO MOVE ROUTINE
         SPACE
UTWRITE  DS        0H
         CH        R6,UTRECLN          RECORD LENGTH SAME AS INCORE .Q
         BNH       UTWRITE2            YES, IT IS OK THEN
         LH        R0,UTRECLN          GET INCORE RECORD LENGTH
         L         R1,UTRECAD          GET INCORE RECORD ADDRESS
         FREEMAIN  R,LV=(0),A=(1)
         LH        R6,FCBITEM          GET ITEM NUMBER
         N         R6,HALFWORD         MASK HIGH ORDER BYTES
         B         UTGET2              GET CORE FOR THIS RECORD
         SPACE
UTWRITE2 DS        0H
         STH       R6,UTRECLN          SAVE INCORE RECORD LENGTH
         L         R5,FCBBUFF          GET USERS BUFFER ADDRESS
         L         R4,UTRECAD          GET INCORE RECORD ADDRESS
         SPACE
PREMOVE  DS        0H
         ST        R6,FCBREAD          FCBREAD = NUM BYTES MOVED
         SPACE
UTMOVE   DS        0H
         S         R6,F256             IS LRECL GREATER THAN 256 .Q
         BM        LT256               NO, JUST DO ONE PASS
         MVC       0(256,R4),0(R5)     MOVE 256 BYTES
         BE        RETURN2             IF NO MORE, RETURN
         LA        R4,256(,R4)         UP MOVE REGISTER BY 256
         LA        R5,256(,R5)         UP MOVE REGISTER BY 256
         B         UTMOVE              GO AND MOVE SOME MORE
LT256    DS        0H
         A         R6,F255             RESET LENGTH-1
         EX        R6,MOVEIT           EXECUTE LAST MOVE
         B         RETURN2             RETURN WITH COUNT IN R15
         SPACE
MOVEIT   MVC       0(*-*,R4),0(R5)     MOVE RECORD FROM/TO CORE
         SPACE
UTSETUP  DS        0H
         LM        R0,R1,FAKENOS       GET FAKE AREA LENGTH/ADDRESS
         FREEMAIN  R,LV=(0),A=(1)      FREE SAVED CORE
         SPACE
         LA        R4,800              100 ENTRIES (1 READ, 99 RECS)
         LA        R6,UTSAV            ADDRESS OF GETMAINED AREA
         BAL       R3,GETCORE          GET CORE FOR ENTRIES
         BZ        UTCOREOK            IF ZERO, CORE OBTAINED
         OI        ASMSW,NOCORE        SET NOCORE SWITCH
         B         SYSUTX              RETURN EMPTY HANDED
         SPACE
UTCOREOK DS        0H
         LA        R4,1                SET REG TO ONE
         L         R5,UTSAV            GET ADDRESS OF ENTRIES
         ST        R4,UTCORENT         INIT UTCORENT AND UTNXTENT
         XC        UTTOTENT(2),UTTOTENT  ZERO TOTAL ENTRIES
         NI        ASMSW,X'FF'-FRSTCALL  TURN OFF FIRST CALL SWITCH
         B         UTCOMM              GO SATISFY I/O REQUEST
         SPACE
UTEOF    DS        0H
         TM        IOBIOFLG,IOBIN      ARE WE DOING INPUT .Q
         BZ        UTGETCOR            NO, THEN GET CORE
         CH        R6,UTTOTENT         IS ITEM GT TOTAL ENTRIES .Q
         BNH       SYSUTX              NO, SOME RECS POSS ON DISK
UTEOF2   DS        0H
         LA        R15,12              GET EOF CODE
         LNR       R15,R15             NEGATIVE OF 12
         B         UTRETURN            GIVE CODE TO I/O SIM
         SPACE
UTGETCOR TM        ASMSW,TODISK        THIS RECORD TO DISK .Q
         BO        UTTODSK             YES, DON'T BOTHER
         LH        R2,UTCORENT         GET LAST IN CORE REC NUMBER
         CH        R2,HALF99           EQUAL OR GREATER THAN 99 .Q
         BNL       UTTODSK             YES, BRANCH TO SPILL
         CH        R6,UTNXTENT         FCBITEM SAME AS NEXT ENTRY .Q
         BNE       UTTODSK             NO, BRANCH TO SPILL
         STH       R6,UTCORENT         MAKE FCBITEM OUT LAST ITEM
         STH       R6,UTTOTENT         ALSO OUT TOTAL ENTRIES
         LA        R2,1(,R6)           UP FCBITEM BY ONE AND
         STH       R2,UTNXTENT         THIS MUST BE OUR NEXT ENTRY
UTGET2   DS        0H
         SLL       R6,3                SET INDEX TO PROPER ENTRY
         LA        R2,0(R5,R6)         GET PROPER INCORE REC ENTRY
         LH        R4,FCBBYTE+2        GET LENGTH OF RECORD
         STH       R4,UTRECLN          SAVE AS OUT INCORE REC LENGTH
         LA        R6,UTRECAD          GET RECORD ADDRESS
         BAL       R3,GETCORE          GET CORE FOR THIS RECORD
         BZ        UTSET               IF OBTAINED, GO MOVE RECORD
         LH        R2,UTCORENT         GET UPDATED LAST REC NUMBER
         BCTR      R2,0                LESS ONE
         STH       R2,UTCORENT         REAL LAST INCORE RECORD
         LH        R2,UTNXTENT         GET UPDATED NEXT REC NUMBER
         BCTR      R2,0                LESS ONE
         STH       R2,UTNXTENT         REAL NEXT INCORE RECORD
         LH        R6,FCBITEM          GET ITEM NUMBER
         OI        ASMSW,TODISK        REMAINING RECORDS TO DISK
         SPACE
UTTODSK  DS        0H
         STH       R6,UTTOTENT         FCBITEM IS NUMBER TOTAL RECS
         B         SYSUTX              RETURN
         SPACE
UTFIN    DS        0H
         CLI       OSIOTYPE,C'T'       IS THIS A TCLOSE .Q
         BE        RETURN1             YES, IGNORE
         XC        UTSAV(4),UTSAV      CLEAR ENTRIES ADDRESS
         SPACE
RETURN1  DS        0H
         SR        R15,R15             RETURN NOTHING TO I/O SIM
         B         UTRETURN            FINAL RETURN
         SPACE
RETURN2  DS        0H
         L         R15,FCBREAD         GET BYTES MOVED FOR I/O SIM
         SLL       R15,16              SET RESIDUAL COUNT TO ZERO
UTRETURN DS        0H
         LM        R0,R14,SAVEREGS     RESTORE REGISTERS
         BR        R14                 RETURN TO I/O SIMULATION
         SPACE
GETCORE  DS        0H
         GETMAIN   EC,LV=(R4),A=(R6)
         ST        R15,CCAUXP          SAVE RETURN CODE
         LTR       R15,R15             CORE OBTAINED .Q
         BZ        GETDONE             YES, JUST RETURN
         OI        ASMSW,TODISK        REMAINING RECORDS TO DISK
GETDONE  DS        0H
         L         R15,CCAUXP          GET RETURN CODE
         LTR       R15,R15             SET CONDITION CODE
         BR        R3                  RETURN TO CALLER
         POP       USING
         EJECT
*
*        SPECIAL HANDLING OF SYSTERM TO TRUNCATE USELESS OPTIONS
*
         SPACE
TERMPROC DS        0H
         USING     TERMPROC,R15        ENTRY ADDRESS
         STM       R0,R15,SAVEREGS     SAVE CALLER'S REGS
         LR        R12,R15             TRANSFER ENTRY ADDRESS
         USING     TERMPROC,R12        USE NEW REGISTER
         DROP      R15                 FORGET THE OLD
         LA        R0,TERMPROC-SAVEAREA OFFSET TO SAVE AREA
         LR        R13,R12             TRANSFER BASE ADDRESS
         SR        R13,R0              DECREMENT R13 FOR SECOND BASE
         USING     SAVEAREA,R13        BASE FOR DATA/WORK AREA
         SPACE
         TM        ASMSW,NOTERM        SHOULD LINE BE TYPED .Q
         BO        TERMKILL            NO, JUST RETURN
         L         R1,FCBBUFF          GET BUFFER ADDRESS
         L         R15,CKASM           GET ASSEMBLER SWITCH
         B         *+4(R15)            BRANCH ACCORDINGLY
         B         TERMF               ASSEMBLER (F)
         B         TERMG               ASSEMBLER (G)
         B         TERMXF              ASSEMBLER (XF)
         B         TERMRET             ASSEMBLER (XG)
         SPACE
TERMF    DS        0H
         MVI       0(R1),C' '          CLEAR MACHINE CARRIAGE CONTROL
         CLC       =C'*OPTIONS',1(R1)  THE ASSEMBER (F) LINE .Q
         BE        TERMEND             SET SWITCH IF YES
         CLC       =C'ASSEMBLER',1(R1) DONE MESSAGE .Q
         BNE       TERMOK              BRANCH IF NOT
         MVC       20(8,R1),SYSNAM     ADD FILE NAME
         B         TERMOK              AND LET LINE THROUGH
TERMG    DS        0H
         MVI       0(R1),C' '          CLEAR MACHINE CARRIAGE CONTROL
         CLC       =C'ASSEMBLER',1(R1) DONE MESSAGE .Q
         BNE       TERMOK              BRANCH IF NOT
         CLI       20(R1),C' '         ANY (G) TITLE LABEL .Q
         BNE       TERMOK              BRANCH IF YES
         MVC       20(8,R1),SYSNAM     ADD FILE NAME
         B         TERMOK              AND LET LINE THROUGH
TERMXF   DS        0H
         CLC       =C' HIGHEST',0(R1)  THE ASSEMBLER (XF) LINE .Q
         BE        TERMEND             SET SWITCH IF YES
         CLC       =C'ASSEMBLER',1(R1) DONE MESSAGE .Q
         BNE       TERMOK              BRANCH IF NOT
         MVC       11(9,R1),=C'(XF) DONE'  ADD ASSEMBLER I.D.
         MVC       21(8,R1),SYSNAM     ADD FILE NAME
TERMOK   DS        0H
         SR        R15,R15             ALLOW LINE THROUGH
         B         TERMRET             AND RETURN
         SPACE
TERMEND  DS        0H
         TM        PARBYT0,FULLTERM    OK REGARDLESS .Q
         BO        TERMOK              YES, ALLOW LINE THROUGH
         OI        ASMSW,NOTERM        TERMINATE SYSTERM OUTPUT
TERMKILL DS        0H
         LA        R15,4               KILL THIS LINE
TERMRET  DS        0H
         LM        R0,R14,SAVEREGS     RESTORE CALLER'S REGS
         BR        R14                 RETURN
         SPACE     2
*
         LTORG
         EJECT
*
*        SPECIAL HANDLING OF SYSPRINT TO PRODUCE SYSTERM
*
         SPACE
LISTPROC DS        0H
         USING     LISTPROC,R15        ENTRY ADDRESS
         STM       R0,R15,SAVEREGS     SAVE CALLER'S REGISTERS
         LR        R12,R15             TRANSFER ENTRY ADDRESS
         USING     LISTPROC,R12        USE NEW REGISTER
         DROP      R15                 FORGET THE OLD
         LA        R0,LISTPROC-SAVEAREA  OFFSET TO SAVE AREA
         LR        R13,R12             TRANSFER BASE ADDRESS
         SR        R13,R0              DECREMENT R13 FOR SECOND BASE
         USING     SAVEAREA,R13        BASE FOR DATA/WORK
         SPACE
         L         R3,FCBBUFF          GET BUFFER ADDRESS
         L         R15,CKASM           GET ASSEMBLER CODE
         B         *+4(R15)            DO AS REQUIRED
         B         LISTOK              ASSEMBLER (F)
         B         LISTOK              ASSEMBLER (G)
         B         LISTOK              ASSEMBLER (XF)
         B         LISTCHK             ASSEMBLER (XG)
         SPACE
LISTCHK  DS        0H
         LH        R4,FCBCOUT          GET NUMBER OF RECORDS IN BLOCK
LISTLOOP DS        0H
         CLI       0(R3),X'09'         JUST A DATA RECORD .Q
         BNE       LISTFL              BRANCH IF NOT
         CLC       =C' *** MNOTE *** ',11(R3)  MNOTE MESSAGE .Q
         BE        LISTONE             YES, PRINT ONE LINE
         CLC       =C' *** ERROR *** ',11(R3)  ERROR MESSAGE .Q
         BE        LISTPRT             BRANCH IF YES
         MVI       LASTREC,X'00'       LAST REC CONTAINS DATA
         MVC       LASTREC+1(8),113(R3)  SAVE NUMBER OF RECORD
         MVC       LASTREC+9(79),34(R3)  SAVE STATEMENT NUMBER AND DATA
         B         LISTDC              AND CONTINUE DEBLOCKING
         CLI       0(R3),X'11'         WRITE AND SPACE TWO .Q
         BNE       LISTDC              NO, JUST RETURN THE LINE
         SPACE
LISTFL   DS        0H
         CLC       =C' FLAGGED IN THIS ASSEMBLY ',19(R3)
         BE        LISTONE             BRANCH IF YES, ONE RECORD ONLY
         B         LISTDC              ELSE JUST RETURN THE LINE
         SPACE
LISTONE  DS        0H
         MVI       LASTREC,X'FF'       NO LAST RECORD TO PRINT
LISTPRT  DS        0H
         CLI       LASTREC,X'FF'       ANY LAST RECORD TO PRINT .Q
         BE        LIST2ND             BRANCH IF NOT
         LA        R2,LASTREC+1        POINT TO LAST RECORD
         WRTERM    (R2),120,EDIT=YES   DISPLAY THE LAST RECORD
LIST2ND  DS        0H
         LA        R2,1(,R3)           POINT TO CURRENT RECORD
         WRTERM    (R2),120,EDIT=YES   DISPLAY THE CURRENT RECORD
         MVI       LASTREC,X'FF'       REMOVE THE LAST RECORD
LISTDC   DS        0H
         AH        R3,FCBRECL          POINT TO NEXT RECORD IN BUFFER
         BCT       R4,LISTLOOP         CHECK ALL RECORDS IN THE BLOCK
         SPACE
LISTOK   DS        0H
         SR        R15,R15             ALLOW LINE THROUGH
         TM        PARBYT4,PRDISK      WAS 'NOPRINT' SPECIFIED .Q
         BO        LISTCONT            BRANCH IF NOT
         LA        R15,4               SET RETURN CODE TO KILL LINE
LISTCONT DS        0H
         LM        R0,R14,SAVEREGS     RESTORE CALLER'S REGS
         BR        R14                 RETURN
         DROP      R12
         SPACE
LASTREC  DC        0CL133' ',X'FF',CL132' '  LAST RECORD BUFFER
SAVEREGS DC        16F'0'              SAVE AREA FOR AUXPROCS
*
         LTORG
         EJECT
UTHEAD   DSECT
UTCORENT DS        H                   LAST INCORE RECORD NUMBER
UTNXTENT DS        H                   NEXT INCORE RECORD NUMBER
UTTOTENT DS        H                   TOTAL NUM RECS (INCORE AND DISK)
         DS        H
         SPACE
UTENTRY  DSECT
         DS        H
UTRECLN  DS        H                   INCORE RECORD LENGTH
UTRECAD  DS        A                   INCORE RECORD ADDRESS
         EJECT
         PRINT     NOGEN
         CMSCB
         ADT
         FSTB
         IO
         NUCON
         EJECT
UTSAV    EQU       IOBCSW              HANDLING SYSUT2
         SPACE     2
ANYDIRT  CSECT
         DC        F'40'               LENGTH OF FST ENTRY
         DC        A(*-*)              SIZE OF DIRECTORY
ADIRTBEG EQU       *
         DC        (16*40)X'00'        ROOM FOR SIXTEEN ENTRIES
         DC        2A(0)               POINTER TO NEXT FST BLOCK
ADIRTEND EQU       *
ADIRTLEN EQU       ADIRTEND-ANYDIRT
         SPACE     2
WMSASM   CSECT
         ORG       WMSASM+X'2000'-ADIRTLEN
         SPACE     2
*
*        ASSEMBLER OPTIONS
*
*        THE FOLLOWING TABLE IDENTIFIES EACH OPTION AND ITS FUNCTION
*
*        BITS 0-3     ACTUAL LENGTH-1 OF PARM
*        BITS 4-7     MINIMUM LENGTH-1 OF PARM
*        BIT  0       ON IF NOT APPLICABLE TO ASSEMBLER (F)
*        BIT  1       ON IF NOT APPLICABLE TO ASSEMBLER (G)
*        BIT  2       ON IF NOT APPLICABLE TO ASSEMBLER (XF)
*        BIT  3       ON IF NOT APPLICABLE TO ASSEMBLER (XG)
*        BITS 4-7     X'0'  OR NEXT 6 BYTES INTO SWITCHES
*                     X'1'  AND NEXT 6 BYTES INTO SWITCHES
*                     X'2'  OR 2, AND 4 BYTES INTO SWITCHES
*                     X'3'  NEXT 2 IS OFFSET TO NUMBER CONTROL
*                           NEXT 2 IS OFFSET TO INPUT SCANNING
*                           NEXT 2 IS OFFSET TO OUTPUT FORMATTING
*        SWITCH BITS OR TARGET OFFSETS
*        CHARACTERS IDENTIFYING THE PARM
*
         SPACE
OPTPSTR  EQU       0
OPTPLEN  EQU       OPTPSTR+0
OPTPFLGS EQU       OPTPLEN+1
OPTPBITS EQU       OPTPFLGS+1
OPTCHAR  EQU       OPTPBITS+6
         SPACE
OPTEST   CSECT     *                   START OF PARM OPTIONS
  PARM   FULLUPLIST,MIN=5,ON=(FUPLIST,UPLIST),EX=(F,XF,XG)
  PARM   FUPLIST,MIN=2,ON=(FUPLIST,UPLIST),EX=ALL
  PARM   UPLIST,MIN=3,ON=UPLIST,OFF=FUPLIST,EX=(F,XF,XG)
  PARM   NOUPLIST,MIN=5,OFF=(FUPLIST,UPLIST),EX=(F,XF,XG)
  PARM   DOS,MIN=3,ON=DOS,EX=(XF,XG)
  PARM   OS,MIN=2,OFF=DOS,EX=(XF,XG)
  PARM   ESD,MIN=3,ON=ESD,EX=F
  PARM   NOESD,MIN=5,OFF=ESD,EX=F
  PARM   BATCH,MIN=1,ON=BATCH,EX=(F,XF)
  PARM   MULT,MIN=4,ON=BATCH,EX=ALL
  PARM   NOBATCH,MIN=3,OFF=BATCH,EX=(F,XF)
  PARM   NOMULT,MIN=6,OFF=BATCH,EX=ALL
  PARM   FULLLIST,MIN=5,ON=(FLIST,LIST),EX=(F,XF,XG)
  PARM   FLIST,MIN=2,ON=(FLIST,LIST),EX=ALL
  PARM   LIBMAC,MIN=4,ON=(FLIST,LIST),EX=(F,G,XG)
  PARM   NOLIBMAC,MIN=6,ON=LIST,OFF=FLIST,EX=(F,G,XG)
  PARM   ALOGIC,MIN=3,ON=ALOGIC,EX=(F,G,XG)
  PARM   NOALOGIC,MIN=5,OFF=ALOGIC,EX=(F,G,XG)
  PARM   MLOGIC,MIN=3,ON=MLOGIC,EX=(F,G,XG)
  PARM   NOMLOGIC,MIN=5,OFF=MLOGIC,EX=(F,G,XG)
  PARM   MCALL,MIN=3,ON=MCALL,EX=(F,G,XG)
  PARM   NOMCALL,MIN=5,OFF=MCALL,EX=(F,G,XG)
  PARM   STD,MIN=3,OFF=STDMIN,EX=ALL
  PARM   MINIMUM,MIN=3,ON=STDMIN,EX=ALL
  PARM   BUFSIZE(STD),MIN=12,OFF=STDMIN,EX=(F,G,XG)
  PARM   BUFSIZE(MIN),MIN=12,ON=STDMIN,EX=(F,G,XG)
  PARM   BUFSIZE,MIN=4,ADDR=WMSASM+1,EX=ALL,                           X
               INRTN=ONSBUFS,OUTRTN=WMSASM+1
  PARM   LIST,MIN=1,ON=LIST,OFF=FLIST
  PARM   NOLIST,MIN=3,OFF=(FLIST,LIST)
  PARM   EXTEN,MIN=2,ON=EXTEN,EX=(F,XF,XG)
  PARM   NOEXTEN,MIN=4,OFF=EXTEN,EX=(F,XF,XG)
  PARM   FULLXREF,MIN=5,ON=(FXREF,XREF),EX=(F,XF,XG)
  PARM   FXREF,MIN=2,ON=(FXREF,XREF),EX=ALL
  PARM   XREF,MIN=1,ON=XREF,OFF=FXREF
  PARM   NOXREF,MIN=3,OFF=(FXREF,XREF)
  PARM   FULL,MIN=4,OFF=XREFFS,EX=ALL
  PARM   SHORT,MIN=5,ON=XREFFS,EX=ALL
  PARM   FULLXREF(SHORT),MIN=15,ON=(FXREF,XREF,XREFFS),EX=(F,XF,XG)
  PARM   XREF(SHORT),MIN=11,ON=(XREF,XREFFS),EX=(F)
  PARM   ALGN,MIN=2,ON=ALGN,EX=(XF,XG)
  PARM   ALIGN,MIN=3,ON=ALGN,EX=(F,G)
  PARM   NOALGN,MIN=4,OFF=ALGN,EX=(XF,XG)
  PARM   NOALIGN,MIN=5,OFF=ALGN,EX=(F,G)
  PARM   DECK,MIN=1,ON=DECK
  PARM   NODECK,MIN=3,OFF=DECK
  PARM   LOAD,MIN=2,ON=LOAD,EX=(XF,XG)
  PARM   OBJECT,MIN=3,ON=LOAD,EX=(F,G)
  PARM   NOLOAD,MIN=4,OFF=LOAD,EX=(XF,XG)
  PARM   NOOBJECT,MIN=5,OFF=LOAD,EX=(F,G)
  PARM   RENT,MIN=1,ON=RENT
  PARM   NORENT,MIN=3,OFF=RENT
  PARM   RLD,MIN=3,ON=RLD,EX=F
  PARM   NORLD,MIN=5,OFF=RLD,EX=F
  PARM   TEST,MIN=1,ON=TEST
  PARM   TESTRAN,MIN=3,ON=TEST,EX=ALL
  PARM   NOTEST,MIN=3,OFF=TEST
  PARM   NOTESTRAN,MIN=5,OFF=TEST,EX=ALL
  PARM   LREF,MIN=2,ON=LREF,EX=(F,XF,XG)
  PARM   NOLREF,MIN=4,OFF=LREF,EX=(F,XF,XG)
  PARM   UPDATE,MIN=2,ON=UPDATE,EX=(F,XF,XG)
  PARM   NOUPDATE,MIN=4,OFF=UPDATE,EX=(F,XF,XG)
  PARM   EXECUTE,MIN=4,ON=EXECUTE,EX=(F,XF,XG)
  PARM   NOEXECUTE,MIN=6,OFF=EXECUTE,EX=(F,XF,XG)
  PARM   FULLTERM,MIN=6,ON=(FULLTERM,TERM),EX=ALL
  PARM   FTERM,MIN=3,ON=(FULLTERM,TERM),EX=ALL
  PARM   TERM,MIN=2,ON=TERM,EX=(XG)
  PARM   TERMINAL,MIN=3,ON=TERM,EX=ALL
  PARM   NOTERM,MIN=4,OFF=(FULLTERM,TERM),EX=(XG)
  PARM   NOTERMINAL,MIN=5,OFF=(FULLTERM,TERM),EX=ALL
  PARM   NUM,MIN=1,ON=NUM,EX=(XG)
  PARM   NUMBER,MIN=3,ON=NUM,EX=ALL
  PARM   NONUM,MIN=3,OFF=NUM,EX=(XG)
  PARM   NONUMBER,MIN=4,OFF=NUM,EX=ALL
  PARM   STMT,MIN=2,ON=STMT,EX=(XG)
  PARM   STATEMENT,MIN=5,ON=STMT,EX=ALL
  PARM   NOSTMT,MIN=4,OFF=STMT,EX=(XG)
  PARM   NOSTATEMENT,MIN=7,OFF=STMT,EX=ALL
  PARM   UMAP,MIN=2,ON=UMAP,EX=(F,XF,XG)
  PARM   NOUMAP,MIN=4,OFF=UMAP,EX=(F,XF,XG)
  PARM   CMS,MIN=3,ON=CMS,EX=(F,XF,XG)
  PARM   STATISTICS,MIN=5,ON=STATS,EX=ALL
  PARM   STATS,MIN=5,ON=STATS,EX=ALL
  PARM   NOSTATISTICS,MIN=7,OFF=STATS,EX=ALL
  PARM   NOSTATS,MIN=7,OFF=STATS,EX=ALL
  PARM   YFLAG,MIN=2,ON=YFLAG,EX=(F,XG)
  PARM   NOYFLAG,MIN=4,OFF=YFLAG,EX=(F,XG)
  PARM   'EXTIME=',MIN=3,ADDR=EXTIME,EX=(F,XF,XG)
  PARM   'LSETC=',MIN=2,ADDR=LSETC,EX=(F,XF,XG)
  PARM   'INSTSET=',MIN=4,ADDR=INSTSET,EX=(F,XF,XG)
  PARM   'IS=',MIN=2,ADDR=INSTSET,EX=ALL
  PARM   'SPACE=',MIN=2,ADDR=SPACEPOS,EX=(F,XF,XG)
  PARM   'SP=MAX-',MIN=7,ADDR=SPACENEG,EX=(F,XF,XG)
  PARM   'SPACE=MA',MIN=7,ON=SPACE,EX=ALL
  PARM   'SP=MAX',MIN=4,ON=SPACE,EX=(F,XF,XG)
  PARM   'COL=',MIN=2,ADDR=COLUMN,EX=(F,XF,XG)
  PARM   'COLUMN=',MIN=4,ADDR=COLUMN,EX=ALL
  PARM   'UPCOND=',MIN=3,ADDR=UPCOND,EX=(F,XF,XG)
  PARM   'CALIGN=',MIN=3,ADDR=CALIGN,EX=(F,XF,XG)
  PARM   'FLAG=',MIN=2,ADDR=FLAG,EX=(F,G)
  PARM   'UTBUFF=',MIN=3,ADDR=UTBUFF,EX=(F,XF,XG)
  PARM   'UBUFF=',MIN=2,ADDR=UTBUFF,EX=ALL
  PARM   'LINECNT=',MIN=4,ADDR=LINECNT
  PARM   'LINECOUNT=',MIN=6,ADDR=LINECNT,EX=ALL
  PARM   'SYSPARM=',MIN=2,ADDR=ADSPARM,EX=F,                           X
               INRTN=ONSPARM,OUTRTN=OPTCPARM
  PARM   PRINTER,MIN=2,ON=(PRINTER,PRDISK),EX=ALL
  PARM   PRT,MIN=3,ON=(PRINTER,PRDISK),EX=ALL
  PARM   DISK,MIN=4,ON=PRDISK,OFF=PRINTER,EX=ALL
  PARM   NOPRINTER,MIN=4,OFF=(PRINTER,PRDISK),EX=ALL
  PARM   NOPRT,MIN=5,OFF=(PRINTER,PRDISK),EX=ALL
  PARM   ASMG,MIN=4,ON=ASMG,OFF=(ASMXF,ASMXG),EX=ALL
  PARM   G,MIN=1,ON=ASMG,OFF=(ASMXF,ASMXG),EX=ALL
  PARM   ASMF,MIN=4,OFF=(ASMG,ASMXF,ASMXG),EX=ALL
  PARM   F,MIN=1,OFF=(ASMG,ASMXF,ASMXG),EX=ALL
  PARM   ASMXF,MIN=5,ON=(ASMG,ASMXF),EX=ALL
  PARM   XF,MIN=2,ON=(ASMG,ASMXF),EX=ALL
  PARM   ASMXG,MIN=5,ON=(ASMXF,ASMXG),EX=ALL
  PARM   XG,MIN=2,ON=(ASMXF,ASMXG),EX=ALL
  PARM   UNUSED,MIN=6,ON=UNUSED,EX=(F,XF,XG)
  PARM   'BLOCKSIZE=',MIN=5,ADDR=BLOCK,EX=ALL
  PARM   'BLKSIZE=',MIN=3,ADDR=BLOCK,EX=ALL
  PARM   'BFILE=',MIN=2,ADDR=BFILE,EX=ALL
         DC        X'FF'               END OF OPTIONS
         SPACE 2
ASMGDIRT CSECT
         DC        F'40'               LENGTH OF FST ENTRY
         DC        A(GDIRTEND-GDIRTBEG)  SIZE OF DIRECTORY
GDIRTBEG EQU       *
         DMSFST    ASMGASM
         DMSFST    ASMGUP
         DMSFST    ASMGF1
         DMSFST    ASMGF2
         DMSFST    ASMGF3
         DMSFST    ASMGRTA
         DMSFST    ASMGF7
         DMSFST    ASMGF8
         DMSFST    ASMGFPP
         DMSFST    ASMGIS00
         DMSFST    ASMGIS01
         DMSFST    ASMGIS70
         DMSFST    ASMGIS71
         DC        2A(0)               POINTER TO NEXT FST BLOCK
GDIRTEND EQU       *
GDIRTLEN EQU       GDIRTEND-ASMGDIRT
         SPACE     2
ASMFDIRT CSECT
         DC        F'40'               LENGTH OF FST ENTRY
         DC        A(FDIRTEND-FDIRTBEG)  SIZE OF DIRECTORY
FDIRTBEG EQU       *
         DMSFST    IEUASM
         DMSFST    IEUMAC
         DMSFST    IEUF1
         DMSFST    IEUF2
         DMSFST    IEUF3
         DMSFST    IEURTA
         DMSFST    IEUF7
         DMSFST    IEUFI
         DMSFST    IEUF8
         DMSFST    IEUFPP
         DMSFST    IEUERR
         DC        2A(0)               POINTER TO NEXT FST BLOCK
FDIRTEND EQU       *
FDIRTLEN EQU       FDIRTEND-ASMFDIRT
         SPACE     2
ASMXDIRT CSECT
         DC        F'40'               LENGTH OF FST ENTRY
         DC        A(XDIRTEND-XDIRTBEG)  SIZE OF DIRECTORY
XDIRTBEG EQU       *
         DMSFST    IFOX00
         DMSFST    IFOX01
         DMSFST    IFOX02
         DMSFST    IFOX03
         DMSFST    IFOX04
         DMSFST    IFOX05
         DMSFST    IFOX06
         DMSFST    IFOX07
         DMSFST    IFOX11
         DMSFST    IFOX21
         DMSFST    IFOX31
         DMSFST    IFOX41
         DMSFST    IFOX42
         DMSFST    IFOX51
         DMSFST    IFOX61
         DMSFST    IFOX62
         DC        2A(0)               POINTER TO NEXT FST BLOCK
XDIRTEND EQU       *
XDIRTLEN EQU       XDIRTEND-ASMXDIRT
         SPACE     2
ASMYDIRT CSECT
         DC        F'40'               LENGTH OF FST ENTRY
         DC        A(YDIRTEND-YDIRTBEG)  SIZE OF DIRECTORY
YDIRTBEG EQU       *
         DMSFST    AXH90
         DMSFST    AXH00
         DMSFST    AXH50
         DMSFST    AXH80
         DMSFST    AXH10
         DMSFST    AXH20
         DMSFST    AXH60
         DC        2A(0)               POINTER TO NEXT FST BLOCK
YDIRTEND EQU       *
YDIRTLEN EQU       YDIRTEND-ASMYDIRT
         SPACE
         END       WMSASM
