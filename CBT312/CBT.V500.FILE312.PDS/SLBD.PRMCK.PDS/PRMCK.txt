/* ---------------------  rexx procedure  -------------------- *
 * Name:      PRMCK (ParmLib Check)                            *
 *                                                             *
 * Function:  Parmlib Member Validation                        *
 *            Support for PROGxx member statements             *
 *               - LNKLST                                      *
 *               - APF                                         *
 *               - LPA                                         *
 *               - SYSLIB                                      *
 *            Support for LNKLSTxx and LPALSTxx members        *
 *                                                             *
 *  Syntax: PRMCK cat sysres -debug -nowarn -noerror           *
 *                                                             *
 *  valid options are:                                         *
 *        -HELP will display a Tutorial Panel                  *
 *        ?   - will prompt for catalog and sysres             *
 *        cat - is a name that will be used in the master      *
 *              catalog lookup (find *custom* below) and       *
 *              if not found will be used as the master        *
 *              catalog name (enter without quotes).           *
 *        sysres is the volser of the system ipl volume        *
 *              to be checked when a volser of ****** is       *
 *              coded.                                         *
 *        -DEBUG   - turn on tracing                           *
 *        -NOWARN  - turn off warning messages                 *
 *        -NOERROR - turn off error messages                   *
 *        -NOSEC   - turn off secondary allocation warnings    *
 *        -REPORT  - create a report data set                  *
 *                                                             *
 *  System symbolics are supported in PROGxx for the volser    *
 *  at this time.  Future support will be there for them in    *
 *  the dataset name and elsewhere.                            *
 *                                                             *
 *  The member validation is a rough validation which verifies *
 *  that the keywords used are valid.  Not necessarily that the*
 *  right keywords are used together.  Dataset names are also  *
 *  validated, including existence in the catalog and on the   *
 *  volume.  Multiple occurances of a keyword are not checked  *
 *  nor are inappropriate uses of keywords (e.g. delete and add*
 *  in the same statement).  However this process has been used*
 *  and has caught the majority of the errors that we make.    *
 *                                                             *
 * Syntax:    ISPF Edit command PRMCK                          *
 *                                                             *
 * Author:    Lionel B. Dyck                                   *
 *            Internet: lbdyck'gmail.com                       *
 *                                                             *
 * History:                                                    *
 *            05/14/20 - Correct oversight test volser syms    *
 *                       for PROGxx                            *
 *            03/10/20 - Clean up typos                        *
 *            03/04/20 - Check for valid dsname (routine)      *
 *            11/16/18 - add var xdsnsave to check more precise*
 *                       - original dsname with symbols and vol*
 *            11/02/18 - clean up duplicate warning            *
 *            10/29/18 - add DD check for PRMCKDBG to enable   *
 *                       MACRO debug (only SYSENV='BACK')      *
 *                     - bug fix: initialize all variables for *
 *                       keywords SYSLIB and LPA like LNKLST   *
 *            10/05/18 - Correct if 2 line entry w/error to    *
 *                       display the full record (lbd)         *
 *            10/01/18 - BATCH: gather also line(s) with       *
 *                       leading blanks                        *
 *                     - bug fix: rpt_line was not added to    *
 *                       report if rpt_line2 is used.          *
 *            09/13/18 - ADD function mode to get values for   *
 *                       VERSION and DEFAULTS                  *
 *            09/10/18 - EDIT macro "batchified"               *
 *            06/25/18 - Corrections for handling system       *
 *                       symbols                               *
 *                     - Clean up code for SMS (thx HB)        *
 *            06/21/18 - Correction for SMS test (thx Gene Pate*
 *            05/09/18 - Display Tutorial Panel if NOT under   *
 *                       ISPF Edit or incorrect Member         *
 *            05/08/18 - Add -Help                             *
 *            05/07/18 - Turn off/restore PFSHOW               *
 *            04/27/18 - Multiple updates                      *
 *                     - move panels inline for easier distro  *
 *                     - check for load lib for apf/link/lpa   *
 *                       recfm=u                               *
 *            02/29/16 - Multiple updates                      *
 *                     - clean up displaying error lines       *
 *                     - get the master catalog info           *
 *                       dynamically                           *
 *                     - support for PROGxx DEFAULTS statement *
 *            02/28/16 - Update Extent warning for LNKLST      *
 *            08/09/10 - Correct if apf dsn ends with a .      *
 *                       Thanks to W. Jensen                   *
 *            03/29/04 - Correct bug with comments             *
 *                     - Put summary at top of file as notes   *
 *                     - Add -REPORT option                    *
 *            03/28/04 - Correct bug reprocessing last stmt    *
 *                     - add Age counter                       *
 *            03/25/04 - Fix missing quote on racf message     *
 *                     - Add warning if APF libraries have not *
 *                       been used for over 365 days.          *
 *            03/23/04 - Update for flip error/warning lines   *
 *                       Mathew E Goldstein of the IRS         *
 *            03/19/04 - Add Linklist Extent Checking          *
 *                       Mathew E Goldstein of the IRS         *
 *            03/18/04 - Add RACF checking and more thx to     *
 *                       Mathew E Goldstein of the IRS         *
 *            03/16/04 - Update for SMS vol from               *
 *                       Mathew E Goldstein of the IRS         *
 *                     - Added duplciate checking              *
 *            11/20/03 - Enhanced to support comments better\  *
 *            10/17/03 - Add -NOWARN and -NOERROR options      *
 *                     - Change (DEBUG to -DEBUG               *
 *            10/25/02 - change to exclude lines not in error  *
 *            09/20/01 - minor fixes from Mathew Goldstein     *
 *            02/21/01 - minor corrections                     *
 *            09/11/00 - fix after check                       *
 *            09/05/00 - fix from  Herman  R. Stocker (HRS)    *
 *            11/19/99 - fixed dup msg if ext and sec > 0      *
 *            11/08/99 - fixed &SYSR1                          *
 *            11/04/99 - fixed SYSLIB checking                 *
 *            11/03/99 - find missing parenthesis              *
 *            10/20/99 - add support for vol of *mcat* (apf)   *
 *            10/19/99 - make lookup table more generic        *
 *            10/19/99 - if not on vol - find where cataloged  *
 *            10/18/99 - add lookup table and other options    *
 *            09/30/99 - additional cleanup                    *
 *            09/28/99 - extent and symbolic support           *
 *                     - changed name to PRMCK                 *
 *            09/27/99 - add lnklstxx and lpalstxx support     *
 *            09/26/99 - creation                              *
 *                                                             *
 * ----------------------------------------------------------- *
 * Copyright (c) 1999-2020 by Lionel B. Dyck                   *
 * ----------------------------------------------------------- */
  _version_ = "2.0 2018-09-13"
  _version_ = "2.1 2018-10-01"
  _version_ = "2.2 2018-10-05"
  _version_ = "2.3 2018-10-29"
  _version_ = "2.4 2018-11-02"
  _version_ = "2.5 2018-11-16"
  _version_ = "2.6 2020-03-04"
  _version_ = "2.7 2020-03-10"

  _junk_ = sub_init()

  if _sysenv_ = "BACK" ,
    then do
    _junk_ = MSG("OFF")
    "ALLOC FI(PRMCKDBG) DATA(*)"
    rcode = rc
    if rcode = 0 ,
      then do
      "FREE FI(PRMCKDBG)"
    end
    else do
      _junk_ = trace("R")
      nop
    end
    _junk_ = MSG("ON")
  end

  mem_patterns = "LNKLST* LPALST* PROG*"

  if rexxinv = "FUNCTION" ,
    then do
    parse upper arg _parms_
    parse var _parms_ word1 .
    select
      when ( word1 = "VERSION"  ) then _str_ = "0 "_version_
      when ( word1 = "DEFAULTS" ) then _str_ = "0 "mem_patterns
      otherwise                        _str_ = 4
    end
    return _str_
  end
  Address ISREDIT
  "MACRO (parm) NOPROCESS"
  rcode = rc
  _junk_ = sub_check_edit_environment(rcode" "parm)
  "Reset"

  "(dataset) = Dataset"
  "(volume)  = volume"
  "(member) = MEMBER"

/* -------------------- *
 | Load the ISPF Panels |
 * -------------------- */
  load_info = loadispf()

  Select
    When left(member,6) = "LNKLST" then nop
    When left(member,6) = "LPALST" then nop
    When left(member,4) = "PROG" then nop
    Otherwise do
      Address ISPExec ,
        'Select pgm(isptutor) parm(prmckh)'
      call free_panels
      exit 4
    end
  end

/* ------------------------------------ *
 | Save the CAPS state and reset to OFF |
 * ------------------------------------ */
  "(savecaps) = CAPS"
  if savecaps = "ON" then
  "CAPS = OFF"

  parse value "" with null dsname volser sms cards_flipped ,
    cont lnklpaxx_dsname report ,
    master_cat sysres paren tdsnf ,
    nowarn noerror nosec dupdsns stype
  errors   = 0
  warnings = 0
  dups     = 0
  aged     = 0
  rprofs   = 0
  extents  = 0
  cmt_card = 0
  parse value "" with editmsg
  editrc    = 0
  editmsg.0 = 0
  process_loglevel = 0

  If SYSVAR(SYSRACF) = 'AVAILABLE' Then
  racf = sysvar('syslracf')
  else racf = null

/* ----------------------------------------------------- *
 * Process the parm                                      *
 * ----------------------------------------------------- */
  parm = translate(parm)
  if abbrev("-HELP",parm,2) = 1 then do
    Address ISPExec ,
      'Select pgm(isptutor) parm(prmckh)'
    call free_panels
    exit 0
  end
  if wordpos("-DEBUG",parm)   > 0 then trace "?i"
  if wordpos("-NOWARN",parm)  > 0 then nowarn = 1
  if wordpos("-NOERROR",parm) > 0 then noerror = 1
  if wordpos("-NOSEC",parm) > 0 then nosec = 1
  if wordpos("-REPORT",parm)  > 0 then do
    report = 1
    reportdd  = "RPT"random(99999)
    reportdsn = "PRMCK."reportdd".LIST"
    n=0
    if _sysenv_ = "BACK" ,
      then do
      n=n+1;report.n=" "
      n=n+1;report.n=copies("=",76)
    end
    minll = 20
    if length(dataset) > minll ,
      then _ll_ = length(dataset)
    else _ll_ = minll
    n=n+1;report.n = "Report for Dataset:" ,
      left(dataset,_ll_) ,
      "Member: "left(member,8)" on Volser: "volume
    n=n+1;report.n = " "
    report.0 = n
    reportc   = n
  end
  parse value parm with cat res .
  cat = word(parm,1)
  res = word(parm,2)
  if left(cat,1) = "-" then cat = null
  if left(res,1) = "-" then res = null
  if cat = "?" then do
    cat = null
    Address ISPExec
    "Addpop column(11) row(2)"
    call pfshow 'off'
    "Display Panel(PRMCKP)"
    call pfshow 'reset'
    "Rempop"
    Address ISREdit
  end
  if res <> null then
  sysres = res

/* ----------------------------------------------------- *
 *  Find the master catalog and set variable             *
 * ----------------------------------------------------- */
  call outtrap "cat."
  address tso,
    "Listc ent('sys1.linklib')"
  call outtrap "off"
  master_cat = word(cat.2,3)

/* ----------------------------------------------------- *
 * Get sysres volser                                     *
 * ----------------------------------------------------- */
  if sysres = null then
  sysres = mvsvar('symdef','sysr1')

/* ----------------------------------------------------- *
 * Get master catalog name                               *
 * ----------------------------------------------------- */
  if master_cat = null then do
    call outtrap "cat."
    Address TSO,
      "Listc ent('sys1.linklib')"
    call outtrap "off"
    master_cat = word(cat.2,3)
  end

/* ----------------------------------------------------- *
 * Get master catalog volser                             *
 * ----------------------------------------------------- */
  call outtrap "cat."
  Address TSO,
    "Listc ent('"master_cat"') volume"
  call outtrap "off"
  last = cat.0
  parse value cat.last with "VOLSER------------" master_vol .

/* ----------------------------------------------------- *
 * Process all card images in the edit dataset(member)   *
 * ----------------------------------------------------- */
  "(last) = linenum .zl"
  last = last + 0
  first_card = 1
  "EXCLUDE All"

  call pfshow 'off'
  do card = 1 to last
    "(line)  = line" card
    new_card = 0
    if left(line,2) <> "  " then do
      save_first = first_card
      first_card = card
    end
    else save_card = card
    line = left(strip(line),72)
    if pos("/*",line) > 0 then call strip_comments
    if length(line) > 0 then call test_card
  end
  save_first = first_card
  call pfshow 'reset'
  if tdsnf = 1 then dsname = null
  if dsname <> null then do
    card = card - 1
    if dsname <> lnklpaxx_dsname then call test_dsname
  end
  if extents > 255 then call excess_extents

  zedsmsg = null
  if errors + warnings = 0 then "flip .zf .zl"

  if report <> null then
  call do_report "  "

  if errors = 0 then errors = "No"
  zedlmsg = "Status:" errors "errors were encountered. "
  call edline "line_before 1 = msgline '"zedlmsg"'"
  call do_report zedlmsg

  if warnings = 0 then warnings = "No"
  zedlmsg = "With "warnings ,
    "warnings encountered."
  call edline "line_before 1 = msgline '"zedlmsg"'"
  call do_report zedlmsg

  if dups = 0 then zedlmsg = "With No duplicates."
  else
  zedlmsg = "With" dups "duplicates."
  call edline "line_before 1 = msgline '"zedlmsg"'"
  call do_report zedlmsg

  if aged = 0 then zedlmsg = "With No Aged data sets."
  else
  zedlmsg = "With" aged "aged data sets."
  call edline "line_before 1 = msgline '"zedlmsg"'"
  call do_report zedlmsg

  if rprofs = 0 then zedlmsg = "With No Missing RACF Profiles."
  else
  zedlmsg = "With" rprofs "missing RACF Profiles."
  call edline "line_before 1 = msgline '"zedlmsg"'"
  call do_report zedlmsg

  if extents > 0 then do
    zedlmsg = "Linklist Extents:" extents
    call edline "line_before 1 = msgline '"zedlmsg"'"
    call do_report zedlmsg
  end
/* ---------------------------------- *
 * Create the Report and then View It *
 * ---------------------------------- */
  if report <> null then do
    if _sysenv_ = "BACK" ,
      then do
      select
        when ( abbrev(member,"PROG") = 1 ) ,
          then do
          address tso ,
            "Execio * diskw REPPROG  ( stem report. )"
          execio_rc = rcode
        end
        when ( abbrev(member,"LNK")  = 1 ) ,
          then do
          address tso ,
            "Execio * diskw REPLNK   ( stem report. )"
          execio_rc = rcode
        end
        when ( abbrev(member,"LPA")  = 1 ) ,
          then do
          address tso ,
            "Execio * diskw REPLPA   ( stem report. )"
          execio_rc = rcode
        end
        otherwise execio_rc = 4
      end
      if execio_rc <> 0 ,
        then do
        address tso ,
          "Execio * diskw REPORT   ( stem report. )"
        execio_rc = rcode
      end
    end
    else do
      alloc_parm = "new Spa(15,15) tr DS("reportdsn")" ,
        "Recfm(v b) Lrecl(84) Blksize(0)"
      Address TSO
      "Alloc f("reportdd") "alloc_parm
      "Execio * diskw" reportdd "(finis stem report."
      "Free f("reportdd")"
      Address ISPExec ,
        "View Dataset("reportdsn")"
    end
    Address ISREdit
  end

  if imacrunning = 1 ,
    then do
    "Up Max"
  end

  "CAPS =" savecaps
  Call free_panels
  if _sysenv_ = "BACK" ,
    then do
    "END"
  end
  select
    when ( errors   > 0 ) then editrc = 8
    when ( warnings > 0 ) then editrc = 4
    otherwise                  editrc = 0
  end
  if editmsg.0 > 0 ,
    then do
    do idx = 1 to editmsg.0
      editmsg = editmsg"<MSG."idx">"editmsg.idx"</MSG."idx">"
    end
    editmsg = "<MSG.0>"editmsg.0"</MSG.0>"editmsg
  end
  address ispexec "vput (editrc editmsg)"
  Exit 0

/* ----------------------------------------------------------------- */
sub_init:
  /* to get the correct name for MYMSGID don't use other cmds before */
  parse source ,
    rexxenv rexxinv rexxname rexxdd rexxdsn . rexxtype addrspc .
  myname = rexxname
  if myname = "?" ,
    then do ;
    myname = sysvar("sysicmd")
    if length(myname) = 0 ,
      then  myname = sysvar("syspcmd")
  end;
  mymsgid = left(myname":",10)

  _sysenv_ = SYSVAR("SYSENV")
  parse value "" with dispmsg dispmsg_old
  return 0

sub_check_edit_environment:
  parse arg _rc_ _parm_
  ineditmacro = 0
  imacrunning = 0

  ineditmacro = (_rc_ = 0)
  if ineditmacro ,
    then do
        /*
           according to the ISPF Edit and Edit Macros manual,
           Chapter 2. Controlling the edit environment, the section
           Initial macros, under the Notes section:
              2. Remember that commands referencing display values
                 (DISPLAY_COLS , DISPLAY_LINES, DOWN, LEFT, RIGHT,
                 UP, LOCATE) are invalid in an initial macro because
                 no data has been displayed.
        */
    address ispexec "CONTROL ERRORS RETURN"
    address isredit "up m"
    imacrunning = (rc <> 0)
  end
 /*
 say mymsgid"ineditmacro         "ineditmacro
 say mymsgid"Initial Edit Macro  "imacrunning
 say mymsgid"Macro parms ......  "_parm_
 say " "
 */
  return 0

/* --------------------------- *
 | Turn off and Restore PFSHOW |
 * --------------------------- */
pfshow:
  if _sysenv_ = "BACK" then return 0
  arg pfkopt
  if pfkopt = 'RESET' then do
    if pfkeys = 'ON' then
    Address ISPExec ,
      'select pgm(ispopf) parm(FKA,ON)'
  end
  if pfkopt = 'OFF' then do
    Address ISPExec ,
      'vget (zpfshow)'
    pfkeys = zpfshow
    Address ISPExec ,
      'select pgm(ispopf) parm(FKA,OFF)'
  end
  return

/* --------------------------------------- *
 * line_after or say (BATCH)               *
 * --------------------------------------- */
 /*                                               */
 /*  "line_after" card "= msgline '"rpt_line"'"   */
 /*  "line_before 1 = msgline '"zedlmsg"'"        */
 /*                                               */
edline:
  parse arg _data_
  parse var _data_ 1 editcmd editdata                     ,
    1 . "=" . _data_
  if _sysenv_ = "BACK" ,
    then do
    _data_ = strip(_data_)
    if left(_data_,1)"-"right(_data_,1) = "'-'" ,
      then _data_ = substr(_data_,2,length(_data_)-2)
    key_word = translate(word(_data_,1))
    select
      when ( left(_data_,05)       = "     "  ) ,
        then gather_message = "YES"
      when ( translate("WARNING:") = key_word ) ,
        then gather_message = "YES"
      when ( translate("ERROR:")   = key_word ) ,
        then gather_message = "YES"
      otherwise gather_message = "NO"
    end
    if gather_message = "YES" ,
      then do
      editidx   = editmsg.0 + 1
      editmsg.0 = editidx
      editmsg.editidx = _data_
    end
           /*
           say left(_data_,60)""left(member,8)" - EDL "
           */
    say      _data_
  end
  else do
    ""editcmd" " editdata
  end
  return 0

/* --------------------------------------- *
 * line_after or say (BATCH)               *
 * --------------------------------------- */
Do_line_after:
  parse arg _data_
  if _sysenv_ = "BACK" ,
    then do
    parse var _data_ 1 . "=" . _data_
    say "DBG: "_data_
  end
  else do
    "line_after" _data_
  end
  return 0

/* --------------------------------------- *
 * Add to the Report stem if Report active *
 * --------------------------------------- */
Do_Report:
  parse arg data
  if report = null then return
  reportc = reportc + 1
  report.reportc = data
  return

/* ---------------------------------- *
 * Strip all comments from the record *
 * ---------------------------------- */
Strip_comments:
  parse value line with left"/*" . "*/"right
  line = left right
  return

/* ----------------------------------------------------- *
 * Test for various control statements                   *
 * ----------------------------------------------------- */
Test_Card:
  val   = 0
  tdsnf = 0
  do word = 1 to words(line)
    call test_word word(line,word)
    if val = 1 then call invalid_keyword
    val = 0
    if new_card = 1 then leave
  end

/* ----------------------------------------------------- *
 * Now test for missing paren's                          *
 * ----------------------------------------------------- */
  data = strip(line)
  lp = 0 ; rp = 0
  do c = 1 to length(data)
    if substr(data,c,1) = "(" then
    lp = lp + 1
    if substr(data,c,1) = ")" then
    rp = rp + 1
  end
  if lp <> rp then
  call missing_paren
  return

/* ----------------------------------------------------- *
 * Test specific keyword                                 *
 * ----------------------------------------------------- */
Test_Word:
  arg keyword
  Select
    When left(member,4) = "PROG" then do
      call Test_Prog
    end
    When left(member,6) = "LNKLST" then do
      type = "LNKLST"
      call Test_LNKLPAxx
    end
    When left(member,6) = "LPALST" then do
      type = "LPA"
      call Test_LNKLPAxx
    end
    otherwise val = 1
  end
  if new_card = 0 then cmt_card = 0
  return

/* ----------------------------------------------------- *
 * Process ongoing process message                       *
 * ----------------------------------------------------- */
Disp_Process:
  if _sysenv_ = "BACK" ,
    then do
    if dispmsg = null ,
      then nop
    else do
      if dispmsg = dispmsg_old ,
        then nop
      else do
        dispmsg_old = dispmsg
        if process_loglevel > 0 ,
          then say "process ... "dispmsg
      end
    end
    return 0
  end
  Address ISPEXec
  "Control Display Lock"
  "Addpop column(11) row(2)"
  "Display Panel(PRMCK)"
  "Rempop"
  Address ISREdit
  return

/* ----------------------------------------------------- *
 * Test LNKLSTxx and LPALSTxx members                    *
 * ----------------------------------------------------- */
Test_LnkLpaxx:
  mcat_test = 1
  cardk     = card
  new_card  = 1
  if cont = 0 then call Cont_After_End
  if right(keyword,1) = "," then cont = 1
  else cont = 0
  if pos("(",keyword) > 0 then
  parse value keyword with dsname "(" volser ")" .
  else do
    parse value keyword with dsname "," .
    volser = null
  end
  lnklpaxx_dsname = dsname
  dispmsg = dsname
  call Disp_Process
  call test_dsname
  return

/* ----------------------------------------------------- *
 * Test PROGxx member of SYS1.PARMLIB                    *
 * ----------------------------------------------------- */
Test_Prog:
  call fix_volser
  Select
    when word(line,1) = "DEFAULTS" then do
      new_card = 1
      call test_defaults
    end
    When keyword = "EXIT" then do
      type    = "EXIT"
      parse value "" with dsname volser sms dsname dupdsns
      cardk   = card
      mcat_test = 0
    end
    When keyword = "APF" then do
      type    = "APF"
      if stype <> type then do
        parse value "" with dsname volser sms dsname dupdsns
        stype   = type
      end
      mcat_test = 0
      if dsname <> null then do
        card = card - 1
        call test_dsname
        card = card + 1
      end
      parse value "" with dsname volser sms
      cardk   = card
    end
    When keyword = "LNKLST" then do
      type    = "LNKLST"
      if stype <> type then do
        parse value "" with dsname volser sms dsname dupdsns
        stype   = type
      end
      mcat_test = 1
      if dsname <> null then do
        card = card - 1
        call test_dsname
        card = card + 1
      end
      parse value "" with dsname volser
      cardk   = card
    end
    When keyword = "SYSLIB" then do
      type    = "SYSLIB"
      if stype <> type then do
        parse value "" with dsname volser sms dsname dupdsns
        stype   = type
      end
      mcat_test = 1
      if dsname <> null then do
        card = card - 1
        call test_dsname
        card = card + 1
      end
      parse value "" with dsname volser
      cardk   = card
    end
    When keyword = "LPA" then do
      type    = "LPA"
      if stype <> type then do
        parse value "" with dsname volser sms dsname dupdsns
        stype   = type
      end
      mcat_test = 1
      if dsname <> null then do
        card = card - 1
        call test_dsname
        card = card + 1
      end
      parse value "" with dsname volser
      cardk   = card
    end
    otherwise do
      call Disp_Process
      Select
        when type = "APF" then call test_apf
        when type = "EXIT" then call test_exit
        when type = "LNKLST" then call test_lnklst
        when type = "LPA" then call test_lpa
        when type = "SYSLIB" then call test_syslib
        when type = "SYSLIB" then call test_syslib
        otherwise val = 1
      end
    end
  end
  return

/* ------------------------------ *
 * Test DEFAULTS keyword (Progxx) *
 * ------------------------------ */
Test_Defaults:
  defdata = subword(line,3)
  dtype = word(line,2)
  keyword = ''
  defdata = translate(defdata,' ','()')
  do idw = 1 to words(defdata)
    Select
      When dtype = "LNKLST" then do
        if wordpos(word(defdata,idw),"REQCOPYFROM NOREQCOPYFROM" ,
          " COPYFROMCUR NOCOPYFROMCUR") = 0 then do
          val = 1
          keyword = keyword word(defdata,idw)
        end
      end
      When dtype = "LPA" then do
        if wordpos(word(defdata,idw),"ADDALIAS " ,
          "NOADDALIAS") = 0 then do
          val = 1
          keyword = keyword word(defdata,idw)
        end
      end
      When dtype = "EXIT" then do
        if wordpos(word(defdata,idw),"EXITTYPE ALL " ,
          "INSTALLATION NOTPROGRAM") = 0 then do
          val = 1
          keyword = keyword word(defdata,idw)
        end
      end
    Otherwise nop
    end
  end
  return

/* ----------------------------------------------------- *
 * Test APF keywords (Progxx)                            *
 * ----------------------------------------------------- */
Test_APF:
  volser = null
  Select
    When keyword = "ADD" then nop
    When keyword = "DELETE" then nop
    When keyword = "SMS" then sms = "SMS"
    When left(keyword,7) = "DSNAME(" then do
      parse value keyword with "DSNAME(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
    end
    When left(keyword,4) = "DSN(" then do
      parse value keyword with "DSN(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
    end
    When left(keyword,4) = "VOL(" then
    parse value keyword with "VOL(" volser ")"
    When left(keyword,7) = "VOLUME(" then
    parse value keyword with "VOLUME(" volser ")"
    When left(keyword,7) = "VOLSER(" then
    parse value keyword with "VOLSER(" volser ")"
    When left(keyword,7) = "FORMAT(" then do
      parse value keyword with "FORMAT(" format ")"
      if wordpos(format,"DYNAMIC STATIC") = 0 then val = 1
    end
    otherwise val = 1
  end
  call fix_volser
  return

/* ----------------------------------------------------- *
 * Test EXIT keywords (Progxx)                           *
 * ----------------------------------------------------- */
Test_Exit:
  Select
    When keyword = "ADD"      then nop
    When keyword = "DELETE"   then nop
    When keyword = "ATTRIB"   then nop
    When keyword = "UNDEFINE" then nop
    When keyword = "ABENDNUM" then nop
    When keyword = "MODIFY"   then nop
    When keyword = "FIRST"    then nop
    When keyword = "LAST"     then nop
    When left(keyword,9) = "EXITNAME(" then nop
    When left(keyword,7) = "KEEPRC(" then nop
    When left(keyword,8) = "JOBNAME(" then nop
    When left(keyword,8) = "MODNAME(" then do
      parse value keyword with "MODNAME(" modname ")"
      dispmsg = "Modname" modname
      call Disp_Process
    end
    When left(keyword,9) = "EXITNAME(" then do
      parse value keyword with "EXITNAME(" exitname ")"
      dispmsg = "Exitname" exitname
      call Disp_Process
    end
    When left(keyword,7) = "DSNAME(" then do
      parse value keyword with "DSNAME(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      call test_dsname
    end
    When left(keyword,6) = "STATE(" then do
      parse value keyword with "STATE(" state ")"
      if wordpos(state,"ACTIVE INACTIVE") = 0 then val = 1
    end
    When left(keyword,6) = "FORCE(" then do
      parse value keyword with "FORCE(" force ")"
      if wordpos(force,"YES NO") = 0 then val = 1
    end
    otherwise val = 1
  end
  return

/* ----------------------------------------------------- *
 * Test LNKLST keywords (progxx)                         *
 * ----------------------------------------------------- */
Test_LNKLST:
  volser = null
  Select
    When keyword = "ACTIVATE"   then nop
    When keyword = "ADD"        then nop
    When keyword = "ATBOTTOM"   then nop
    When keyword = "ATTOP"      then nop
    When keyword = "DEFINE"     then nop
    When keyword = "DELETE"     then nop
    When keyword = "NOCHECK"    then nop
    When keyword = "UNALLOCATE" then nop
    When keyword = "UNDEFINE"   then nop
    When keyword = "UPDATE"     then nop
    When keyword = "SMS" then sms = "SMS"
    When left(keyword,6) = "AFTER(" then do
      parse value keyword with "AFTER(" aftdsn ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
    end
    When left(keyword,4) = "JOB(" then nop
    When left(keyword,5) = "ASID(" then nop
    When left(keyword,9) = "COPYFROM(" then nop
    When left(keyword,4) = "DSN(" then do
      parse value keyword with "DSN(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
    end
    When left(keyword,7) = "DSNAME(" then do
      parse value keyword with "DSNAME(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
    end
    When left(keyword,5) = "NAME(" then
    parse value keyword with "NAME(" name ")"
    When left(keyword,4) = "VOL(" then
    parse value keyword with "VOL(" volser ")"
    When left(keyword,7) = "VOLSER(" then
    parse value keyword with "VOLSER(" volser ")"
    When left(keyword,7) = "VOLUME(" then
    parse value keyword with "VOLUME(" volser ")"
    otherwise val = 1
  end
  call fix_volser
  return

/* ----------------------------------------------------- *
 * Test LPA keywords    (progxx)                         *
 * ----------------------------------------------------- */
Test_LPA:
  volser = null
  Select
    When keyword = "ADD"        then nop
    When keyword = "CURRENT"    then nop
    When keyword = "DELETE"     then nop
    When keyword = "FIXED"      then nop
    When keyword = "OLDEST"     then nop
    When keyword = "PAGEABLE"   then nop
    When keyword = "PAGEPROTPAGE" then nop
    When left(keyword,7) = "CSALIM(" then nop
    When left(keyword,5) = "MASK(" then nop
    When left(keyword,8) = "MODNAME(" then nop
    When left(keyword,6) = "FORCE(" then do
      parse value keyword with "FORCE(" force ")"
      if force <> "YES" then val = 1
    end
    When left(keyword,7) = "DSNAME(" then do
      parse value keyword with "DSNAME(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
      if dsname = "LNKLST" then dsname = null
    end
    When left(keyword,4) = "DSN(" then do
      parse value keyword with "DSNAME(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
      if dsname = "LNKLST" then dsname = null
    end
    When left(keyword,7) = "VOLSER(" then
    parse value keyword with "VOLSER(" volser ")"
    otherwise val = 1
  end
  call fix_volser
  return

/* ----------------------------------------------------- *
 * Test SYSLIB keywords (progxx)                         *
 * ----------------------------------------------------- */
Test_SYSLIB:
  Select
    When left(keyword,7) = "LPALIB(" then do
      parse value keyword with "LPALIB(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
      call test_dsname
      dsname = null
    end
    When left(keyword,7) = "MIGLIB(" then do
      parse value keyword with "MIGLIB(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
      call test_dsname
      dsname = null
    end
    When left(keyword,7) = "CSSLIB(" then do
      parse value keyword with "CSSLIB(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
      call test_dsname
      dsname = null
    end
    When left(keyword,8) = "LINKLIB(" then do
      parse value keyword with "LINKLIB(" dsname ")"
      if right(keyword,1) <> ")" then
      if word(line,word+1) = ")" then word = word + 1
      dispmsg = dsname
      call Disp_Process
      call test_dsname
      dsname = null
    end
    otherwise val = 1
  end
  return

/* ----------------------------------------------------- *
 * Test validity of the dataset name                     *
 * ----------------------------------------------------- */
Test_Dsname:
  dsname_save = dsname
  lmvol = null
  tdsnf = 1
  do forever
    if pos("&",dsname) > 0 then call fix_symdef
    else leave
  end
  dsnok = dsnvalid(dsname)
  if dsnok = 'NO' then do
    call not_valid
    return
  end
  Select
    When sms = "SMS" then call test_sms
    When volser = null then
    call test_catalog
    When volser <> null then do
      if volser = "******" then volser = sysres
      call fix_volser
      lmvol = "Vol("volser")"
      call test_volume
    end
    Otherwise nop
  end
  if racf <> null then call test_racf
  call test_dsndcb
  call test_dsnVALID
  xdsn = dsname"/"volser
  xdsnsave = dsname_save"/"volser
  if type <> "EXIT" then
 /*if wordpos(xdsn,dupdsns) > 0 then do */
  if wordpos(xdsnsave,dupdsns) > 0 then do
    if nowarn = 1 then return
    parse var xdsnsave 1 xdsnname "/" xdsnvol
    if strip(xdsnvol) = "" ,
      then xdsnsave_info = strip(xdsnname)
    else xdsnsave_info = strip(xdsnsave)
    rpt_line = "Warning: "xdsnsave_info,
      "appears to be a duplicate."
    call edline "line_after" card "= msgline '"rpt_line"'"
     /* Comment Start
     call Do_line_after card "= msgline '"rpt_line"'"
        Comment End */
    call flip_line
    dups = dups + 1
    warnings = warnings + 1
  end
  else do
    dupdsns = strip(dupdsns" "xdsnsave)
  end
  return

/* ----------------------------------------------------- *
 * Fixup dsname found with system symbolics              *
 * ----------------------------------------------------- */
Fix_Symdef:
  parse value dsname with . '&' symbol '.' .
  if pos("&",symbol) > 0 then
  parse value dsname with symbol '&' .
  p1 = pos("&"symbol,dsname)
  p1l = length(symbol)
  newdsnl = left(dsname,p1-1)
  p1r = p1l + p1
  newdsnr = right(dsname,length(dsname)-p1r)
  if left(newdsnr,2) = ".." then
  newdsnr = substr(newdsnr,1)
  if left(newdsnr,1) = "." then
  newdsnr = substr(newdsnr,2)
  newdsn = newdsnl""mvsvar('symdef',symbol)""newdsnr
  newdsn = strip(newdsn,'t','.')   /* W.Jensen */
  dsname = newdsn
  return

/* ----------------------------------------------------- *
 * Fixup volser found with system symbolics              *
 * ----------------------------------------------------- */
Fix_volser:
  if pos('&',volser) = 0 then return
  parse value volser with . '&' symbol '.' .
  p1 = pos("&"symbol,volser)
  p1l = length(symbol)
  newvoll = left(volser,p1-1)
  p1r = p1l + p1
  newvolr = right(volser,length(volser)-p1r)
  if left(newvolr,2) = ".." then
  newvolr = substr(newvolr,1)
  if left(newvolr,1) = "." then
  newvolr = substr(newvolr,2)
  newvol = newvoll""mvsvar('symdef',symbol)""newvolr
  newvol = strip(newvol,'t','.')
  volser = newvol
  return

 /* ----------------------------------------------------- *
  * Test RACF Status of dataset                           *
  * ----------------------------------------------------- */
Test_RACF:
  call listdsi "'"dsname"'" norecall
  if sysracfa = 'NONE' then Do
    if nowarn = 1 then return
    rpt_line = "Warning:" dsname,
      "No RACF profile"
    call edline "line_after" card "= msgline '"rpt_line"'"
    rprofs = rprofs + 1
    warnings = warnings + 1
    call flip_line
  End
  return

/* -------------------------------------------- *
 * Test to see if the dataset is a load library *
 * RECFM=U and DSORG=PO or POE                  *
 * -------------------------------------------- */
Test_DSNDCB:
  x=listdsi("'"dsname"' Vol("volser")")
  if left(sysdsorg,2) /= 'PO' then call Not_PO
  if sysrecfm         /= 'U'  then call Not_LOAD
  return

/* ----------------------------------------------------- *
 * Test existence  of dataset                            *
 * ----------------------------------------------------- */
Test_DSNVALID:
  IF listdsi("'"dsname"'") > 0 & sysreason=1 THEN
  call Not_VALID
  return

/* ----------------------------------------------------- *
 * Test SMS Status of dataset                            *
 * ----------------------------------------------------- */
Test_SMS:
  call listdsi "'"dsname"' norecall smsinfo"
  select
    when ( sysreason = 5 )     then call Not_Catalog  /*gp*/
    when ( sysreason = 9 )     then call Migrate_Msg
    otherwise do
      if sysstorclass = null then call Not_SMS
    end
  end
  return

/* ----------------------------------------------------- *
 * Test Catalog status of datasets                       *
 * ----------------------------------------------------- */
Test_Catalog:
  call outtrap "cat."
  Address TSO "Listc ent('"dsname"') vol"
  cat_rc = rc
  call outtrap "off"
  x = cat.0
  volser = substr(cat.x,26,6)
  if cat_rc > 0 then do
    call Not_Catalog
    return
  end
  if Mcat_Test = 1 then do
    call outtrap "c."
    Address TSO "Listc ent('"dsname"') cat('"master_cat"')"
    c_rc = rc
    call outtrap "off"
    if c_rc > 0 then call Not_Master_Cat
  end
  if volser = "******" then volser = sysres
  call fix_volser
  lmvol = "Vol("volser")"
  volser = sysres
  call test_volume
  return

/* ----------------------------------------------------- *
 * Test dataset on volume                                *
 * ----------------------------------------------------- */
Test_Volume:
  sysvolume = null
  call listdsi "'"dsname"'" lmvol
  if sysreason > 0 then do
    call listdsi "'"dsname"'"
    if sysvolume <> null then
    found_vol = sysvolume
    else found_vol = null
    call Not_OnVolume
  end
  else do
    if wordpos(type,"LNKLST") = 1 then do
      extents = extents + 1
      if sysused <> 'N/A' Then Do
        if sysextents > 1 then Do
          extents = extents + sysextents - 1
          call mult_extents
        end
        else if sysseconds > 0 then call mult_seconds
      end
    end
    if sms <> null then
    if volser <> null then do
      call listdsi "'"dsname"' smsinfo"
      if sysmgmtclass <> null then call not_defined_sms
    end
  end
  if sysrefdate = null then return
  if sysrefdate = 0 then sysrefdate = syscreate
  parse value sysrefdate with ryear"/"rdays
  refdate = right(ryear,2)right(rdays+1000,3)
  refdate = date('b',refdate,'j')
  today   = date('b')
  if (today - refdate) > 365 then call Long_Time
  return

/* ----------------------------------------------------- *
 * Set messages                                          *
 * ----------------------------------------------------- */
Missing_Paren:
  if nowarn = 1 then return
  rpt_line = "Error: Missing parenthesis",
    "on the previous statement."
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Cont_After_End:
  if noerror = 1 then return
  rpt_line = "Error: Invalid Continuation "
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Migrate_Msg:
  if nowarn = 1 then return
  rpt_line = "Error: Dataset Migrated",
    "unable to determine SMS Status"
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Not_Catalog:
  if noerror = 1 then return
  rpt_line = "Error:" dsname "Not Cataloged"
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Not_Master_Cat:
  if noerror = 1 then return
  rpt_line = "Error:" dsname ,
    "Not Cataloged in the Master Catalog"
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Not_OnVolume:
  if noerror = 1 then return
  rpt_line2 = null
  if found_vol <> null then do
    rpt_line2 = "       was found on:" found_vol
    call edline "line_after" card "= msgline '"rpt_line2"'"
  end
  rpt_line = "Error:" dsname "Not on" volser
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  found_vol = null
  call do_report rpt_line
  if rpt_line2 <> null then
  call do_report rpt_line2
  call flip_line
  '(check) = line' card
  if pos(' ',check) = 1 then do
    scard = card
    card = card -1
    call flip_line
    card = scard
  end
  return

Not_SMS:
  if nowarn = 1 then return
  rpt_line = "Warning:" dsname,
    "Not SMS Managed"
  call edline "line_after" card "= msgline '"rpt_line"'"
  warnings = warnings + 1
  call flip_line
  return

Not_Load:
  if nowarn = 1 then return
  rpt_line = "Error:" dsname ,
    'Not a Load Library.'
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Not_VALID:
  if nowarn = 1 then return
  rpt_line = "Error:" dsname ,
    'IS INVALID|'
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Not_PO:
  if nowarn = 1 then return
  rpt_line = "Error:" dsname ,
    'Not a Partitioned Dataset'
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Long_Time:
  if type <> "APF" then return
  if nowarn = 1 then return
  rpt_line = "Warning:" dsname,
    "last referenced" ,
    date(,refdate,'b')"."
  call edline "line_after" card "= msgline '"rpt_line"'"
  warnings = warnings + 1
  aged     = aged + 1
  call flip_line
  return

Not_Defined_SMS:
  if nowarn = 1 then return
  rpt_line2 = "         volume:" volser
  call edline "line_after" card "= msgline '"rpt_line2"'"
  rpt_line = "Warning:" dsname,
    "SMS Managed but defined to"
  call edline "line_after" card "= msgline '"rpt_line"'"
  warnings = warnings + 1
  call flip_line
  call do_report rpt_line
  if rpt_line2 <> null then
  call do_report rpt_line2
  return

Mult_Extents:
  if nowarn = 1 then return
  rpt_line = "Warning:" dsname ,
    "has" sysextents "used extents"
  call edline "line_after" card "= msgline '"rpt_line"'"
  warnings = warnings + 1
  call flip_line
  return

Mult_Seconds:
  if nowarn = 1 then return
  if nosec = 1 then return
  warn = "Warning:"
  if sysextents > 1 then do
    rpt_line = "         Using" sysextents " extents"
    call edline "line_after" card "= msgline '"rpt_line"'"
    warn = "Error:"
  end
  rpt_line = warn dsname ,
    "has secondary allocation of" sysseconds
  call edline "line_after" card "= msgline '"rpt_line"'"
  if sysextents = 1 ,
    then warnings = warnings + 1
  else errors = errors + 1
  call flip_line
  return

Invalid_Keyword:
  if noerror = 1 then return
  if words(keyword) > 1 then kw = "keywords"
  else kw = "keyword"
  rpt_line = "Error:",
    "record has a syntax error in" kw ":" ,
    keyword
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

Excess_Extents:
  if noerror = 1 then return
  card = card - 1
  rpt_line = "Error: link list",
    extents" extents exceeds the maximum 255",
    keyword
  call edline "line_after" card "= msgline '"rpt_line"'"
  errors = errors + 1
  call flip_line
  return

/* ----------------------------------------------------------- *
 * This routine will flip (un-hide) the current record. Since  *
 * this routine may be called multiple times the record number *
 * is saved and tested to prevent un-hiding and then hiding.   *
 * ----------------------------------------------------------- */
Flip_Line:
  if wordpos(card,cards_flipped) > 0 then return
  "Label" card "= .rec"
  'flip .rec'
  cards_flipped = cards_flipped card
  return

Free_Panels:
  Address ISPEXEC
  do until length(load_info) = 0
    parse value load_info with dd libd load_info
    "libdef" libd
    address tso "free f("dd")"
  end
  return

/* --------------------  rexx procedure  -------------------- *
 * Name:      LoadISPF                                        *
 *                                                            *
 * Function:  Load ISPF elements that are inline in the       *
 *            REXX source code.                               *
 *                                                            *
 * Syntax:    rc = loadispf()                                 *
 *                                                            *
 *            The inline ISPF resources are limited to        *
 *            ISPF Messages, Panels, and Skeletons,           *
 *                 CLISTs and EXECs are also supported.       *
 *                                                            *
 *            The inline resources must start in column 1     *
 *            and use the following syntax:                   *
 *                                                            *
 *            >START    used to indicate the start of the     *
 *                      inline data                           *
 *                                                            *
 *            >END    - used to indicate the end of the       *
 *                      inline data                           *
 *                                                            *
 *            Each resource begins with a type record:        *
 *            >type name                                      *
 *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *
 *                     name is the name of the element        *
 *                                                            *
 * Sample usage:                                              *
 *          -* rexx *-                                        *
 *          load_info = loadispf()                            *
 *          ... magic code happens here (your code) ...       *
 *          Address ISPEXEC                                   *
 *          do until length(load_info) = 0                    *
 *             parse value load_info with dd libd load_info   *
 *             if left(libd,6) = "ALTLIB" then do             *
 *                if libd = "ALTLIBC" then lib = "CLIST"      *
 *                                    else lib = "EXEC"       *
 *                Address TSO,                                *
 *                  "Altlib Deact Application("lib")"         *
 *                end                                         *
 *             else "libdef" libd                             *
 *             address tso "free f("dd")"                     *
 *             end                                            *
 *          exit                                              *
 *          >Start inline elements                            *
 *          >Panel panel1                                     *
 *          ...                                               *
 *          >Msg msg1                                         *
 *          ...                                               *
 *          >End of inline elements                           *
 *                                                            *
 * Returns:   the list of ddnames allocated for use along     *
 *            with the libdef's performed or altlib           *
 *                                                            *
 *            format is ddname libdef ddname libdef ...       *
 *                   libdef may be altlibc or altlibe         *
 *                   for altlib clist or altlib exec          *
 *                                                            *
 * Notes:     Entire routine must be included with REXX       *
 *            exec - inline with the code.                    *
 *                                                            *
 * Comments:  The entire rexx program is processed from the   *
 *            last record to the first to find the >START     *
 *            record at which point all records from that     *
 *            point on are processed until the >END           *
 *            statement or the end of the program is found.   *
 *                                                            *
 *            It is *strongly* suggested that the inline      *
 *            elements be at the very end of your code so     *
 *            that the search for them is faster.             *
 *                                                            *
 *            Inline ISPTLIB or ISPLLIB were not supported    *
 *            because the values for these would have to be   *
 *            in hex.                                         *
 *                                                            *
 * Author:    Lionel B. Dyck                                  *
 *                                                            *
 * History:                                                   *
 *            08/29/17 - Fixup static values that were vars   *
 *            05/31/17 - Change default directory count       *
 *            12/09/16 - update for add_it routine            *
 *            05/10/16 - correction for clist and exec        *
 *            04/19/16 - bug correction                       *
 *            06/04/04 - Enhancements for speed               *
 *            08/05/02 - Creation                             *
 *                                                            *
 * ---------------------------------------------------------- *
 * Disclaimer: There is no warranty, either explicit or       *
 * implied with this code. Use it at your own risk as there   *
 * is no recourse from either the author or his employeer.    *
 * ---------------------------------------------------------- */
LoadISPF: Procedure

  parse value "" with null kmsg kpanel kskel first returns ,
    kclist kexec
/* ------------------------------------------------------- *
 * Find the InLine ISPF Elements and load them into a stem *
 * variable.                                               *
 *                                                         *
 * Elements keyword syntax:                                *
 * >START - start of inline data                           *
 * >CLIST name                                             *
 * >EXEC name                                              *
 * >MSG name                                               *
 * >PANEL name                                             *
 * >SKEL name                                              *
 * >END   - end of all inline data (optional if last)      *
 * ------------------------------------------------------- */
  last_line = sourceline()
  do i = last_line to 1 by -1
    line = sourceline(i)
    if translate(left(line,6)) = ">START " then leave
  end
  rec = 0
/* --------------------------------------------------- *
 * Flag types of ISPF resources by testing each record *
 * then add each record to the data. stem variable.    *
 * --------------------------------------------------- */
  do j = i+1 to last_line
    line = sourceline(j)
    if translate(left(line,5)) = ">END "   then leave
    if translate(left(line,7)) = ">CLIST " then kclist = 1
    if translate(left(line,6)) = ">EXEC "  then kexec  = 1
    if translate(left(line,5)) = ">MSG "   then kmsg   = 1
    if translate(left(line,7)) = ">PANEL " then kpanel = 1
    if translate(left(line,6)) = ">SKEL "  then kskel  = 1
    rec  = rec + 1
    data.rec = line
  end

/* ----------------------------------------------------- *
 * Now create the Library and Load the Member(s)         *
 * ----------------------------------------------------- */
  Address ISPExec
/* ----------------------------- *
 * Assign dynamic random ddnames *
 * ----------------------------- */
  clistdd = "lc"random(999)
  execdd  = "le"random(999)
  msgdd   = "lm"random(999)
  paneldd = "lp"random(999)
  skeldd  = "ls"random(999)

/* ---------------------------------------- *
 *  LmInit and LmOpen each resource library *
 * ---------------------------------------- */
  if kclist <> null then do
    call alloc_dd clistdd
    "Lminit dataid(clist) ddname("clistdd")"
    "LmOpen dataid("clist") Option(Output)"
    returns = strip(returns clistdd 'ALTLIBC')
  end
  if kexec <> null then do
    call alloc_dd execdd
    "Lminit dataid(exec) ddname("execdd")"
    "LmOpen dataid("exec") Option(Output)"
    returns = strip(returns execdd 'ALTLIBE')
  end
  if kmsg <> null then do
    call alloc_dd msgdd
    "Lminit dataid(msg) ddname("msgdd")"
    "LmOpen dataid("msg") Option(Output)"
    returns = strip(returns msgdd 'ISPMLIB')
  end
  if kpanel <> null then do
    call alloc_dd paneldd
    "Lminit dataid(panel) ddname("paneldd")"
    "LmOpen dataid("panel") Option(Output)"
    returns = strip(returns paneldd 'ISPPLIB')
  end
  if kskel <> null then do
    call alloc_dd skeldd
    "Lminit dataid(skel) ddname("skeldd")"
    "LmOpen dataid("skel") Option(Output)"
    returns = strip(returns skeldd 'ISPSLIB')
  end

/* ----------------------------------------------- *
 * Process all records in the data. stem variable. *
 * ----------------------------------------------- */
  do i = 1 to rec
    record = data.i
    recordu = translate(record)
    if left(recordu,5) = ">END " then leave
    if left(recordu,7) = ">CLIST " then do
      if first = 1 then call add_it
      type = "Clist"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,6) = ">EXEC " then do
      if first = 1 then call add_it
      type = "Exec"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,5) = ">MSG " then do
      if first = 1 then call add_it
      type = "Msg"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,7) = ">PANEL " then do
      if first = 1 then call add_it
      type = "Panel"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,6) = ">SKEL " then do
      if first = 1 then call add_it
      type = "Skel"
      first = 1
      parse value record with x name
      iterate
    end
   /* --------------------------------------------*
    * Put the record into the appropriate library *
    * based on the record type.                   *
    * ------------------------------------------- */
    Select
      When type = "Clist" then
      "LmPut dataid("clist") MODE(INVAR)" ,
        "DataLoc(record) DataLen(255)"
      When type = "Exec" then
      "LmPut dataid("exec") MODE(INVAR)" ,
        "DataLoc(record) DataLen(255)"
      When type = "Msg" then
      "LmPut dataid("msg") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      When type = "Panel" then
      "LmPut dataid("panel") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      When type = "Skel" then
      "LmPut dataid("skel") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      Otherwise nop
    end
  end
  if type <> null then call add_it
/* ---------------------------------------------------- *
 * Processing completed - now lmfree the allocation and *
 * Libdef the library.                                  *
 * ---------------------------------------------------- */
  if kclist <> null then do
    Address TSO,
      "Altlib Act Application(Clist) File("clistdd")"
    "LmFree dataid("clist")"
  end
  if kexec <> null then do
    Address TSO,
      "Altlib Act Application(Exec) File("execdd")"
    "LmFree dataid("exec")"
  end
  if kmsg <> null then do
    "LmFree dataid("msg")"
    "Libdef ISPMlib Library ID("msgdd") Stack"
  end
  if kpanel <> null then do
    "Libdef ISPPlib Library ID("paneldd") Stack"
    "LmFree dataid("panel")"
  end
  if kskel <> null then do
    "Libdef ISPSlib Library ID("skeldd") Stack"
    "LmFree dataid("skel")"
  end
  return returns

/* --------------------------- *
 * Add the Member using LmmAdd *
 * based upon type of resource *
 * --------------------------- */
Add_It:
  Select
    When type = "Clist" then
    "LmmAdd dataid("clist") Member("name")"
    When type = "Exec" then
    "LmmAdd dataid("exec") Member("name")"
    When type = "Msg" then
    "LmmAdd dataid("msg") Member("name")"
    When type = "Panel" then
    "LmmAdd dataid("panel") Member("name")"
    When type = "Skel" then
    "LmmAdd dataid("skel") Member("name")"
    Otherwise nop
  end
  type = null
  return

dsnvalid: Procedure Expose null
  /* Tests for a 'potentially valid' z/OS datasetname */
  parse arg val_dsn
  if strip(val_dsn) = null then return 'NO'
  val_dsn = strip(val_dsn,'B',"'")
  upp = TRANSLATE(val_dsn,".ABCDEFGHIJKLMNOPQRSTUVWXYZ",,
    ".abcdefghijklmnopqrstuvwxyz")
  tdsn = translate(val_dsn,' ','.')
  retval = 'OK'   /* asssume good */
  do i = 1 to words(tdsn)
    w = word(tdsn,i)
    if length(w) > 8 then retval = 'NO'
    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'
    w = translate(w,left(' ',39,' '), ,
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')
    w = strip(w)
    if w /= null then retval = 'NO'
  end
  if retval /= 'NO' then
  if upp = val_dsn then do
    smsg = msg()
    call msg 'OFF'
    if sysdsn("'"val_dsn"'") = "OK" | ,
       sysdsn("'"val_dsn"'") = "DATASET NOT FOUND"
    then retval = 'OK'
    else retval = "NO"
    call msg smsg
  end
  return retval

/* ------------------------------ *
 * ALlocate the temp ispf library *
 * ------------------------------ */
Alloc_DD:
  arg dd
  Address TSO
  if pos(left(dd,2),"lc le") > 0 then
  "Alloc f("dd") unit(sysda) spa(5,5) dir(5)",
    "recfm(v b) lrecl(255) blksize(32760)"
  else
  "Alloc f("dd") unit(sysda) spa(5,5) dir(5)",
    "recfm(f b) lrecl(80) blksize(23440)"
  return
 /*
>START
>Panel PRMCK
)Attr Default(%+_)
/* + type(text  ) intens(low )                   information only  */
  _ type( input) intens(high) caps(off) just(left )
  # type(output) intens(high)  caps(off) just(left ) color(yellow)
   type(output) intens(high)  caps(off) just(right) color(yellow)
   % type(text) intens(high)
   $ type(text) intens(high) color(blue) hilite(reverse)
)Body Window(43,5)
+Processing: #dispmsg
+Statement:  card +out oflast   +
+Warnings:warnings+Errors:       errors +
+Dups:    dups    +RACF Profiles:rprofs +
+Aged:    aged    +
)Init
 &zwinttl = 'Parmlib Validation Progress'
)Proc
)End
>Panel PRMCKH
)Attr Default(%+_)
/* + type(text  ) intens(low )                   information only  */
 _ type( input) intens(high) caps(on) just(left )
 # type(output) intens(high)  caps(off) just(left ) color(yellow)
 % type(text) intens(high)
 $ type(text) intens(high) color(blue) hilite(reverse)
)Body expand(//)
%-/-/$Parmlib Verification Help%/-/-
+Command ===>_zcmd
+
%PRMCK+is an%ISPF Edit Command+that will check the syntax
+of%PROGxx, LNKLSTxx, LPALSTxx members.
+
%Syntax:+PRMCK cat sysres -debug -nowarn -noerror
+
+     ?   - will prompt for catalog and sysres
+     cat - is a name that will be used in the master
+           catalog lookup (find *custom* below) and
+           if not found will be used as the master
+           catalog name (enter without quotes).
+     sysres is the volser of the system ipl volume
+           to be checked when a volser of ****** is
+           coded.
+     -DEBUG   - turn on tracing
+     -Help    - display this tutorial panel
+     -NOWARN  - turn off warning messages
+     -NOERROR - turn off error messages
+     -NOSEC   - turn off secondary allocation warnings
+     -REPORT  - create a report data set
)Proc
ver (&cat,dsname)
&zcont = prmckh
)End
>Panel PRMCKP
)Attr Default(%+_)
/* + type(text  ) intens(low )                   information only  */
  _ type( input) intens(high) caps(on) just(left )
   type( input) intens(high) caps(on) just(left ) pad(_) color(green)
  # type(output) intens(high)  caps(off) just(left ) color(yellow)
   % type(text) intens(high)
   $ type(text) intens(high) color(blue) hilite(reverse)
)Body Window(64,2) Expand(//)
+Master Catalog: cat                                          +
+Sysres:         res   +
)Init
 &zwinttl = 'Parmlib Verification Setup'
)Proc
 ver (&cat,dsname)
)End
>End
*/
