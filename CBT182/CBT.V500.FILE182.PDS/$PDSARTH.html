<html>
<!-- HTML tagged version of $PDSART1, $PDSART2, and $PDSART3 -->
<!-- "Browse on..."                                DRK JAN98 -->
<head>
<title>Learning the PDS Command</title>
</head>
<body>
<h1>
<font face="arial,helvetica">
Learning PDS - A Short Course
</font>
</h1>
<i> A published work, by Sam Golob</i><p>
<ul>
<a href="#$pdsart0">The PDS Command - Preface</a><br>
<a href="#$pdsart1">The PDS Command - Part One</a><br>
<a href="#$pdsart2">The PDS Command - Part Two</a><br>
<a href="#$pdsart3">The PDS Command - Part Three</a><br>
</ul>
<hr>
<pre>
<a name="$pdsart0"></a>

                  The PDS Program  -  Course PREFACE


        This is the preface to members $PDSART1, $PDSART2, and $PDSART3,
which constitute a short course of study to expand the user's horizons
and skill with the PDS program product.  In this preface, I'd like to
explain the origins and purpose of the course.

        The material consists of drafts of a three part series of
articles in "Technical Support" magazine from NaSPA (National Systems
Programmers Association in Milwaukee, Wisconsin).  Edited versions of
these drafts were published in the January, February, and March 1988
issues of the magazine.  Bob Becker, the editor, kindly gave
permission for the authors of PDS to include the material within the
package itself.  Bruce Leland and Steve Smith, (and I) thank Bob for his
support.

        My aim is to present an introductory though somewhat
sophisticated course.  I think it will help all users to widen their
view of this extraordinarily helpful package.  One of the difficulties
in writing any course on the PDS product is the fact that PDS varies
qualitatively from release to release.  The beauty of the product is
that Bruce Leland and Steve Smith are constantly taking suggestions
from users the world over, and are always improving the product in
some way.  Usage of subcommands and ISPMODE commands may differ
somewhat between one version and the next.  But it is also our
realization that the user community as a whole cannot appreciate the
enormity of the product without a good overview.  How can a new user
or even an "experienced" user get INTO the PDS capabilities more?  I
feel that despite the difficulties, a short introductory course of
study was necessary, to bring the diamond to its beholders.

        I have therefore made some decisions.  My course will be about
ONE RELEASE LEVEL.  At the time of its writing, the current level of PDS
was 8.0.  Therefore, the course describes Release 8.0 and not 7.3 or the
previous levels.  My experience from the past shows me, that if a user
is familiar with one level of PDS, it is relatively easy to get
accustomed to and appreciate the luxuries of the next release.  Learn
8.0, and you'll know 8.1 and 8.2 too.

        It is anticipated that supplements will be written to extend
the course material to the new features of subsequent releases of
this product.  There is ample "change" documentation from the authors,
though not in "course" format.

        The plan of the course is to COVER THE PDS SUBCOMMANDS.  Our
experience is, that PDS is so vast, that most users really don't exploit
most of its capabilities.  PDS can save its users great amounts of time,
IF YOU GET INTO IT.  This course aims to get people INTO PDS.

       How?  I have taken the PDS subcommands (from Release 8.0) and
organized them into five categories.  By covering one group of commands
at a time, as we start to march through them, we begin to see the
greater picture.  We think it really shows it to you.

       Hopefully, the information is presented slowly and interestingly,
one step at a time, so you can catch your breath.

       The material is divided into three pieces because it was
originally written as three magazine articles.  It is good this way,
because you can digest a little at a time.  Three sittings are better
than one.

       The course does not attempt to convey ALL of PDS.  (That is
perhaps impossible.)  Its purpose is to show how much good that PDS
can do for you.  I personally think that PDS contains possibly
SIXTY PERCENT OF ALL THE TOOLS THAT A SYSTEM PROGRAMMER NEEDS.  That's
putting myself on a limb, but it really isn't.  Just use the product
as part of your ISPF working day, and you'll really see what I mean
after a while.

       Application programmers can benefit from PDS too.  The shop
should have a security package to restrict them to their own data.  If
the subcommand set must be restricted for the application programmers,
this is possible.  Subcommands can be nullified, and there are also
security modules within the PDS distribution package.  See the install
documentation.

       Much thanks are, of course, due to Bruce Leland and Steve Smith,
the authors of PDS, for making all this possible, and for their
continuing cooperation with me.  Thanks are due to all of you too, the
using and contributing public.  PDS would not be what it is, without
all the feedback and suggestions.  (Bruce and Steve put most of them
in.)  Use it all well!



                                       Sam Golob
                                       January 22, 1988

<hr>
<a name="$pdsart1"></a>

           Public MVS Software - The PDS Program - Part One

                                  Sam Golob
                                  MVS Systems Programmer
                                  Newsweek, Inc.
                                  Mountain Lakes, New Jersey 07046
                                  (201) 316-2328


       In my last article, which was an introduction to Public
Domain software available for MVS, I mentioned one of the most
amazing products, the PDS program product.  This is a facility that
one literally can't afford to do without.  It is unbelievably
powerful and a great time saver.  The main thing is that you must
learn how to use its many features.

       STARTING to use PDS has proven to be the greatest barrier.
PDS has many subcommands, each of which in turn, has a variety of
options.  (Help!!)  The new user, unaware of the things he
potentially can do, and swamped by the number of things to choose,
doesn't know where to start.  In this article, we'll use a method of
progression developed for my course on PDS.  It is a methodology to
get you INTO PDS.  Once you know how PDS works, you can expand your
knowledge on your own.  It's just a question of learning "where
everything is at".

       We should begin from what PDS is.  PDS is a facility for
manipulating a DATASET, which can be either PARTITIONED or SEQUENTIAL.
Other types can also be dealt with, but for simplicity, we shall
restrict our discussion to these two types.  PDS is a TSO COMMAND
PROCESSOR.  At minimum, we can enter PDS from TSO READY, by typing
PDS 'dataset.name' or PDS80 'dataset.name', depending on what name
we have given to the PDS load module.  PDS must always point to a
dataset (which we call the "current dataset").  If we try to enter
"PDS" from TSO READY, without a target dataset, there will be a TSO
prompt:  "ENTER NAME OF DATASET".  Suppose we enter a dataset name.
The resulting display will look like the following:
<font face="Fixedsys">
- DSN=TST2SSG.SMP.CNTL,VOL=SER=TSO001  MEM=
PDS80 -- VERSION 8.0

DISP UNIT OPT RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR
SHR  3380 W   FB       80    3120   2X    36       0    30 TRK      46

ENTER OPTION -- DSN=TST2SSG.SMP.CNTL,VOL=SER=TSO001  MEM=
</font>

       This display itself is almost worth the price.  It can be
recreated by entering the DSNAME or DSN subcommand.  You'll notice
that the basic PDS prompt is "ENTER OPTION", just as the basic prompt
for TSO is "READY".  Suppose we take the hint and enter "OPTIONS" or
"O".  What will appear is a list of about 48 options or SUBCOMMANDS,
in PDS parlance.  This gives you quite a choice!

       So where do you start?  Here's where this article comes in.
Basically, we're here to ORGANIZE the options, so we can get decent
coverage of them--a good once-over.  This will give you the knowledge
to get going on your own.

       Please take a look at the organized list of PDS options in
Figure 1.  This is merely a re-sorted and re-commented list of what
you get when you enter the PDS "OPTIONS" command yourself.  We have
divided the subcommands into five general groups.  As we cover the
commands in each group, the general nature of the capabilities of PDS
will gradually fall into perspective, and you'll start to get the
picture.  (This will bring you to the stage where I am.  I've just
about started to get the picture myself.)  The whole thing should
take about three articles, and I'm ready if you are!  (Really, it's
worth the time spent.  Your productivity rate will start to fly.)

       OK.  The first class of commands deals with the "current
dataset" itself.  Remember that the PDS command processor must always
be pointed at a "current dataset".  If you want to change the
"current dataset", all you have to do is enter a "CHANGE" or "C"
subcommand followed by the TSO-qualified new dataset name after the
"ENTER OPTIONS" prompt.  PDS will switch to the new dataset and show
you the new dataset's characteristics.

       Let's look at the some of the subcommands in SECTION ONE.
We've mentioned the "OPTIONS" subcommand, now let's discuss "HELP".
Help is what we always need, especially with such a versatile product.
I'll assume you installed the "HEL" full-screen TSO help program from
CBT tape file 296, and genned the "HEL" TSO help option when you
installed PDS from the CBT tape.  Now when you see the "ENTER
OPTIONS" prompt, enter "H" or "HELP" followed by a subcommand name.
You'll get a full-screen scrollable view of the 6000-line PDS help
member, but conveniently positioned to the subcommand you want.  You
can scroll up and down as much as you want for as long as you want.
This is convenient to say the least.  The full-screen help program
"HEL" is a separate TSO command, called by PDS, which can be used to
view other TSO help datasets as well.  If this is working, you now
have a lot of help available.  (Be sure the PDS help member has an
alias of "PDS80" in your SYSHELP dataset.  In later releases, this
should be "PDS81", etc.)

       What's next?  "END".  If you see the "ENTER OPTIONS" prompt
and you enter "END", you'll pop out of PDS.  This will even happen
if you enter "EN".  But if you enter "E" alone, PDS will try to allocate
ISPF datasets and "EDIT" the dataset you're currently pointing to.
This is because of the way PDS subcommands are set up.  You can
abbreviate to the point of uniqueness, but beyond that, PDS has a table
of preference for subcommands, and EDIT is higher on that table than
END.  Therefore if you try entering "E" alone, EDIT is the command
that PDS chooses to execute, and not END.

       "DSNAME" is next on the list.  We saw what you get when you
enter this subcommand at the "ENTER OPTIONS" prompt.  That should be
all of DSNAME, right?  NO!  That's definitely not right.  Here, we'll
begin to sense the unique beauty of the PDS product.  There are THREE
"DSNAME" displays.  Enter "DSN MSG" and you get the above display.
Enter "DSN TSO" and you get the equivalent information in the format
of the TSO ALLOCATE command:
<font face="Fixedsys">
ALLOC F(SYS00026) DA('TST2SSG.SMP.CNTL') SHR UNIT(3380) -
  RECFM(F B) LRECL(80) BLKSIZE(3120) OPTCD(W) VOLUME(TSO001) -
  TRK SPACE(36,30) DIR(91)               /*FREE TRK=0,FREE DIR=46*/
</font>
Finally, if you enter "DSN JCL", the format is that of a JCL dataset
allocation:
<font face="Fixedsys">
//SYS00026  DD  DSN=TST2SSG.SMP.CNTL,DISP=SHR,UNIT=3380,
//  DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120,OPTCD=W),VOL=SER=TSO001,
//  SPACE=(TRK,(36,30,91))               /*FREE TRK=0,FREE DIR=46*/
</font>
Good automatic formatting?  We'll see more and more, that the whole
product is pervaded with such versatility.  These formats are not just
pretty pictures, but they will prove to be darn useful.  We'll see
that from ISPMODE, all of these generated outputs can be written to a
file for subsequent use.  They can prove to be machine-readable
timesavers for your later processing.

       Let's go further down our list.  We'll look at the "USAGE"
or "U" subcommand.  This shows us a thorough picture of the dataset's
vitals.  Enter "U" at the "ENTER OPTION" prompt and you get the
display below.  Adding any extra character such as "U T" gives you
the track map of the dataset as well.  (In PDS 8.1, "U ALL" will also
dump the entire VTOC entry for the current dataset, and will format
each field of the VTOC.  Wow!)  For our dataset...
<font face="Fixedsys">
DISP UNIT OPT RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR
SHR  3380 W   FB       80    3120   2X    36       0    30 TRK      46

DATA SET: CREATED  EXPIRES  LAST USE  UPDATED  SECURITY
          2/27/85  0/00/00  10/13/87  YES      NONE

EXTENTS IN TRACKS: 6, 30

TRACKS: ALLOCATED    USED    FREE  EXTENTS
               36      36       0        2

DIRECTORY: BLOCKS    USED    FREE   TRACKS  MEMBERS  ALIASES
               91      45      46        2      272        0

EXTENT  UCB  LO TT-HI TT  TRACKS     LOW CCHH-HIGH CCHH    BOUNDARY
------  ---  ----- -----  ------  ----------- -----------  --------
     0  9B7  00.00 00.05       6  01.06.00.01 01.06.00.06  TRK
     1  9B7  00.06 00.23      30  00.75.00.0C 00.77.00.0B  TRK
</font>

       Not bad, not bad.  We're now about half way down the list in
Section One.  For completeness at this point, it's probably best to
mention some stuff from Section Two and talk about ISPMODE a bit.
Then we'll be able to finish Section One with better perspective.

       What's ISPMODE?  Remember that PDS is a TSO command processor.
In non-ISPMODE, or what we'll call LINE MODE, the results of the PDS
subcommands are output to the terminal, as in any TSO command.  When
PDS is in ISPMODE however, it is operating in a full ISPF environment,
and it is an ISPF dialog manager.  Prompting lines for subcommands are
at the top of the full screen ISPMODE displays, while the results
of the commands go to a scrollable DISPLAY LOG at the bottom of the
screen.  Another name for this scrollable DISPLAY LOG is VIEW MODE.
There are three other ISPMODE scrollable displays supported in the
current version (8.0) of PDS.  They are MEMLIST, LISTA, and LISTV.
You can switch back and forth between them.  We'll get to a discussion
of them by and by.

       If ISPF is available in the TSO environment, ISPMODE may be
entered from a PDS session in LINE MODE, merely by entering "ISPMODE"
or "ISPM" at the "ENTER OPTIONS" prompt.  PDS will then allocate all
relevant ISPF datasets and call itself again as a dialog manager.  PDS
can also be entered directly in ISPMODE from an ISPF menu option. You
can refer to the PDS installation literature for more direction on how
to set this up.  The information can be found in the install pds that
comes from CBT tape file 182.

       For now, I'd like to mention the existence of the "Data Table
Output" option "7" in ISPMODE.  This option is used to write the
ISPMODE LOG to a disk dataset or to SYSOUT, thus preserving the results
of your PDS subcommands.  All four ISPMODE scrollable displays have
this capability.

       Now we can go on to finish the commands of Section One.
The "DISPLAY" and "PATTERN" subcommands display subsets of members
of the "current dataset" if it is partitioned.  "DISPLAY" deals with
ranges of names in collating sequence order.  "DISPLAY" or "D" without
any operands displays all members.  The colon ":" is the range
indicator.  "D A:C" will display all members in collating sequence
starting from those beginning with "A" thru those beginning with "C".
If you genned the "display delimit" option when you installed PDS
(&CONDRNG  SETC  'Y' in #PDSGEN), the subcommand "D A" will mean the
same as the command "D A:A".  This allows easy abbreviation of DISPLAY
commands and has other unexpected dividends.  If you don't gen this
option at install time, then "D A" will mean "D A:x'FF'", and the
display will fly off to the end of the directory.

       "PATTERN" displays all members containing a string.  The string
does not have to occur at the beginning of the name, but can occur
anywhere in the member name.  The control character indicating "PATTERN"
is the slash, "/".  "DISPLAY ABC/" or "PATTERN ABC" will display all
member names containing the string ABC, such as EXABC, ABCDE, OR XABCY.
The DISPLAY and PATTERN subcommands have many variations in their use,
and you'd be advised to see the HELP entries for them.

       At this point, there is an important PDS concept that should
be introduced.  This is the MEMBER GROUP.  You always have a default
MEMBER GROUP if your current dataset is partitioned.  (It can be EMPTY
or UNDEFINED if you haven't defined it yet with one of the subcommands
from Section Three or Section Four).  The member group can either be
defined as a rule with the MEMBERS subcommand (using logic from DISPLAY,
PATTERN, or a combination of these - see HELP GROUP), or as a list of
member names, with the SUBLIST subcommand.  The fact that PDS keeps
track of MEMBER GROUPS allows it to do subcommand operations on many
members at a time.  We don't want to discuss MEMBER GROUPS now.  They
are the main topic of the next article.  Suffice it to say that the
"MEMBERS" subcommand of PDS will display or redefine the "current
member group".  So will the "SUBLIST" subcommand.  To learn more about
groups, you should refer to the TSO HELP for PDS under HELP MEMBERS,
HELP SUBLIST, and the special entry HELP GROUP.  (There is no GROUP
subcommand in PDS.)

       How does this relate to DISPLAY and PATTERN?  DISPLAY and
PATTERN do not alter the "current member group".  However the internal
logic used for the DISPLAY and PATTERN subcommands in PDS code
IS used in executing OTHER subcommands which DO alter the current
group.

       Next case.  The "RECALL" or "R" subcommand is particularly
useful throughout your travels in PDS-land.  If "R" is entered from
the command line in ISPMODE or from the "ENTER OPTION" prompt, you
will get a display of the last command you entered. In ISPMODE, the
RECALL subcommand has the additional capability of finding previous
commands entered, that are still in the VIEW MODE log. The RECALL
ISPF panel prompts you how to use the facility, and it saves you
a lot of retyping.

       We are left with the "TSO", "COMPRESS", "VERIFY", "FIXPDS",
and "CONTROL" subcommands to complete our discussion of Section One.
"TSO" allows the execution of an arbitrary TSO command while we are
still within a PDS session.  It can (and should) be abbreviated to
"TS" or "T".  Why?

       When you are using ISPF, there is a "TSO" prefix you can issue
from the command line of any ISPF panel.  The prefix "TSO" allows you
to execute a TSO command that is typed after it.  The facility is a
part of native ISPF, and not of PDS.  Now what if we are using PDS in
ISPMODE, and we enter "TSO" on the command line of an ISPMODE panel
followed by a TSO command.  What gets executed, ISPF's TSO, or PDS's
"TSO"?  The answer is ISPF's TSO.  (In LINE MODE execution of PDS,
this is not a problem.)  So when you abbreviate PDS's "TSO" command to
"TS" or "T", you can be sure you're not getting the ISPF version.

       What's the difference?  It makes a difference to execute PDS's
version, because you can gen PDS so that "TS" really means "TSO
TSOEXEC" (for users having TSO/E).  That way, you can efficiently
execute authorized TSO commands, even though you are within ISPF.
The TSOEXEC command that comes with TSO/E allows execution of
authorized commands from within ISPF, and it is quicker to type "T"
than to type "TSO TSOEXEC".  Saves your fingers.

       The "COMPRESS" subcommand invokes the program IEBCOPY to
compress a partitioned dataset.  IEBCOPY has the hitch that it must
run authorized, and it is somewhat difficult to get an authorized
program to run under TSO.  Special measures must be taken.  There are
several programs described in the #PDSGEN install member which do the
authorization process for IEBCOPY.  They are either the SPFCOPY front
end for IEBCOPY, which calls a user SVC (info can be found in the ISPF
program directory from IBM or file 300 on the CBT tape).  Or the TSO
module IKJEFTSR (which is dangerous because it accepts attention
interrupts during a compress).  If you have the vendor product PDSFAST
(sold by Software Engineering Associates of Lake Success, New York),
this is the most convenient COMPRESS and COPY program of all.  It
doesn't have to be authorized, and PDS is fully compatible with it.
PDSFAST is also much faster than IEBCOPY, making foreground compresses
more convenient.  You can gen PDSFAST as PDS's COPY or COMPRESS
program during the install process.  The second best COPY/COMPRESS
choice is probably SPFCOPY, if your company doesn't have PDSFAST.

       "CONTROL" sets certain PDS internal mechanisms and display
defaults for subcommands.  If you enter the "CONTROL" subcommand
without any operands, one of the items shown will be the available
virtual storage for your TSO session.  CONTROL can be very significant
when you know more about how PDS works, but for now, I'll just refer
you to the TSO help for it.

       "VERIFY" "verifies" the current dataset or its members.  It
does all kinds of block size measurements and other things.  It tries
to make sure that the members have characteristics consistent with the
DCB attributes of the dataset, and that the members are consistent
with each other.  When there's something wrong, you get a message.
VERIFY also counts logical records and physical blocks.  You get a
statistical report concerning them.

       Some examples of VERIFY messages:  If you do a VERIFY on a
dataset, and a member has a block size bigger than what's in the DCB,
this will show up.  If there are members which are "orphaned" (marked
as aliases but with no main member) or "apparent aliases" (not marked
as aliases, but two members point to the same disk location), that
will show up.  A VERIFY run will also show how many tracks can be
gained by a compress.  There is much more.  As usual, please refer to
the TSO help member for this subcommand.

       "FIXPDS" is an extremely multifaceted subcommand incorporating
at least ten functions in one.  Space prohibits a big discussion here,
but I'll try to whet your appetite before sending you off to the HELP
member.

       You can use FIXPDS to reduce the current dataset's unused
allocated space, without deleting and reallocating the dataset.  It
just gets rid of the extra space.  Another thing you can do is to
release the space taken up by the dataset's unused extents, or you can
release all the unused space.  These features of FIXPDS use the
RELEASE program from File 296 of the CBT tape.  You can add or reduce
the number of DIRECTORY BLOCKS a pds has, ON THE FLY, with the
"EXPANDDIR" and "FREEDIR" options of FIXPDS.  You can change many of
the DCB characteristics of the dataset ON THE FLY.  For instance you
can change the RECFM, DSORG, or BLKSIZE.  You can also clear a pds of
all its members, and optionally readjust the number of directory
blocks while doing so.  Pretty good, and there's much more in FIXPDS.

       Well we got through Section One!  We already know enough now to
start working with the PDS product and to get some major use out of it.
We also have enough information to start exploring ahead on our own.
However, there's a lot of BASIC work still to cover.

       We still don't know much about manipulating GROUPS of members at
once.  I haven't even mentioned the magnificent "MEMLIST" capability,
that allows ISPF BROWSE or EDIT or RENAME or PRINTOFF (and 20 other
things) from a SINGLE fullscreen list of pds members.  "MEMLIST" also
makes possible exquisitely delicate manipulation of the member GROUPS.

       So there's lots more to follow folks!!!  Tune in next month...
same time... same station.


         *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *


 Figure 1.


      PDS SUBCOMMANDS - Organized by Type - (for PDS version 8.0)


  SECTION ONE.    General Commands concerning the CURRENT DATASET.

       OPTIONS  - Display the list of subcommands
       HELP     - HELP for PDS subcommands
       END      - STOP THE PROGRAM
       DSNAME   - Display allocation of the "CURRENT DATASET"
       USAGE    - "CURRENT DATASET" STATISTICS (very comprehensive)
       CHANGE   - Change the "CURRENT DATASET"
       RECALL   - Display a PREVIOUS SUBCOMMAND
       DISPLAY  - Display MEMBER NAMES of the "CURRENT PDS" by RANGE
       PATTERN  - Display MEMBER NAMES matching a PATTERN
       TSO      - Invoke a TSO COMMAND from within PDS
       COMPRESS - Compress the "CURRENT DATASET" in place
       VERIFY   - VALIDITY CHECK the "CURRENT DATASET"
       FIXPDS   - Modify DATA SET ATTRIBUTES (very very powerful)
       CONTROL  - Set PROGRAM CONTROLS for general PDS execution

  SECTION TWO.    ISPMODE Commands.

       ISPMODE  - Put this PDS session into ISPMODE
       VIEW     - View the ISPMODE log
       MEMLIST  - ISPF DISPLAY TABLE of members (very versatile)
       LISTA    - Display DATASET ALLOCATIONS for this TSO session
       LISTV    - Display statistics for MOUNTED DISK VOLUMES
       (Each of these has options and subcommands of its own)

  SECTION THREE.  MEMBER GROUP Manipulation Commands.

       MEMBERS  - DISPLAY/DEFINE a MEMBER GROUP
       SUBLIST  - Define a MEMBER LIST SUBGROUP
       MEMLIST  - ISPF DISPLAY TABLE of "MEMLIST SUBSET" of members
       IF       - Conditionally Execute a PDS SUBCOMMAND (powerful)
       FIND     - LIST  occurrences of a STRING for members in a GROUP
       REPLACE  - CHANGE occurrences of a STRING for members in a GROUP
       ATTRIB   - LIST/CHANGE ATTRIBUTES of all members in a GROUP
       VERIFY   - VALIDITY CHECK a MEMBER GROUP
       COPY     - COPY MEMBER GROUP to another Data Set
       OUTCOPY  - Generate IEBCOPY MEMBER SELECT STATEMENTS for a GROUP

  SECTION FOUR.   Individual MEMBER Manipulation Commands.

       EDIT     - EDIT a member using ISPF EDIT
       BROWSE   - BROWSE a member with ISPF BROWSE
       REVIEW   - BROWSE a member using REVIEW (doesn't need ISPF)
       LIST     - DISPLAY a member
       RENAME   - RENAME a member
       DELETE   - DELETE a member
       ATTRIB   - LIST/CHANGE ATTRIBUTES of a member (Source or Load)
       ALIAS    - ASSIGN AN ALIAS to a member (Source or Load)
       HISTORY  - LIST HISTORY of a LOAD MODULE CSECTS and ZAPS
       MAP      - MAP A LOAD MODULE
       COPY     - COPY a member to another Data Set
       CONTROL  - Set PROGRAM CONTROLS for display of MEMBERS
       COMPARE  - COMPARE TWO MEMBERS from the Data Set
       FIND     - LIST LINES containing a STRING
       REPLACE  - CHANGE LINES containing A STRING
       REPRO    - RECOPY A MEMBER in this Data Set
       RESTORE  - RESURRECT a PREVIOUSLY DELETED member
       PRINTOFF - PRINT A HARDCOPY of a member
       SUBMIT   - SUBMIT JCL
       VERIFY   - VALIDITY CHECK a dataset member
       DIRENTRY - DUMP a DIRECTORY ENTRY of a member and DISPLAY FIELDS

  SECTION FIVE.   Other Commands.

       "UNDOCUMENTED" OPTIONS  -  See member $$$UNDOC in install pds
       EXEC     - Execute PDS subcommands from a CLIST
       ISPF     - Invoke ISPF Primary Panel from PDS
       TSOEDIT  - EDIT using TSO EDIT
       TSOLIST  - LIST DATA with TSO LIST
       FSE      - EDIT using FSE (vendor product or free product)
       DSPRINT  - Print a HARDCOPY with DSPRINT  (vendor product)
       VPSPRINT - Print a HARDCOPY with VPSPRINT (vendor product)
       <i>"There is more.  You have to explore."</i>

<hr>
<a name="$pdsart2"></a>

            Public MVS Software - The PDS Program - Part Two


                                      Sam Golob
                                      MVS Systems Programmer
                                      Newsweek, Inc.
                                      Mountain Lakes, New Jersey 07046
                                      (201) 316-2328


       This series of several installments deals with a tremendously
useful productivity aid, the PDS Program Product, Version 8.0, which
can be found on the CBT mods tape for MVS.  Besides introducing
revolutionary new extensions to IBM's ISPF/PDF, it has capabilities of
pds member manipulation that truly boggle the mind.  It is (literally)
one hundred utilities, or more, rolled into one. If you spend some
time studying how to install and use PDS, the payback is guaranteed!

       To my knowledge, this series of articles is the first attempt
to create a systematic course of study to guide the reader through the
many PDS SUBCOMMANDS.  It is our aim to provide as full an overview as
possible.  To this end, we have grouped the PDS subcommands into FIVE
SECTIONS, according to their functionality (see Figure 1).

       In our last article, we introduced some of the special concepts
connected with using the PDS product.  We talked about the "CURRENT
DATASET", which is the dataset that PDS is pointing to and acting
upon.  Every time PDS executes, it has to point to a CURRENT DATASET.
The PDS SUBCOMMANDS we talked about last time dealt mostly with
finding (or changing) the attributes of the current dataset as a
whole.  Commands of that type were grouped together in SECTION ONE
of our list of PDS subcommands.

       This month's installment will concentrate on SECTIONS TWO AND
THREE of the PDS subcommands.  We will spend most of the discussion
on how to manipulate MEMBER GROUPS, and we will see how the ISPMODE
enhancements to PDS increase this capability in our hands.  In
addition, we will try and complete our overview of the ISPMODE
features, and to start opening your eyes to the productivity that
they will buy you.

       PDS deals mainly with two types of datasets, partitioned and
sequential.  If the current dataset is partitioned, there is always a
"CURRENT MEMBER GROUP", which is a subset of the members of the
current dataset.  This CURRENT MEMBER GROUP can contain ALL members of
the pds, or it can be a PROPER SUBSET of members, or it can be a NULL
subset.

       Much of the great strength of the PDS program lies in its
ability to manipulate GROUPS OF PDS MEMBERS very delicately.  The
other half of this strength is the LARGE VARIETY OF FUNCTIONS that
can easily be performed on ALL THE MEMBERS OF THE GROUP IN ONE
OPERATION.  We will discuss commands to select which members will
comprise a member group at any given time.  We will look at how
PDS commands DEAL WITH GROUPS.  And we will see how ISPMODE OPERATION
OF PDS extends our power with groups very much and very exquisitely.

       To start, we'll have to review a few basic facts about PDS
which were discussed last time.  PDS is a TSO COMMAND PROCESSOR, and
being such, it can operate directly from the READY prompt that TSO
users are familiar with.  You simply enter:
             PDS  'dataset.name'
This will begin execution of PDS and point it to 'dataset.name' as the
CURRENT DATASET.  We talked about the details of how this works in the
last issue.

       PDS can also operate interactively with ISPF/PDF.  This mode
of PDS operation is called ISPMODE.  If ISPF is in the environment of
the TSO session, ISPMODE can be entered using the "ISPMODE" or "ISPM"
subcommand, even though PDS was originally entered in native TSO or
"LINE MODE", without ISPF.  When the ISPMODE subcommand is entered,
the PDS program attempts to use all the datasets allocated for ISPF,
and it invokes itself again as a dialog manager.  PDS can also be
entered in ISPMODE initially through ISPF menus, or directly from TSO
READY through a generation option.  To see how to set these up, please
refer to the installation instructions included in the PDS package.

       What does ISPMODE operation of PDS look like?  We have supplied
a number of sample screens.

<font face="Fixedsys">
SCREEN #1

 ----------------------  ISPMODE SESSION DISPLAY  ----------------  ROW 1 OF 6
 COMMAND ===>                                                 SCROLL ===> CSR
Enter an ISPF command, a PDS subcommand or a special control code:
   LA Lista      1 Suspend ISPF     9 Swap panels    R Recall
   LV Listv      6 MEMLIST all      F Find           X Above/Below/All
   ML Memlist    7 Output log       O Options        * Memlist *
 - DSN=TST2SSG.SMP.CNTL,VOL=SER=TSO001  MEM=  --------------------------------
 PDS80 -- VERSION 8.0

 DISP UNIT OPT RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR
 SHR  3380 W   FB       80    3120   3X    66      31    30 TRK      46

 ENTER OPTION -- DSN=TST2SSG.SMP.CNTL,VOL=SER=TSO001  MEM=



SCREEN #2

 -------------------  MEMLIST Source Member List 1  -------------  ROW 1 OF 273
 COMMAND ===>                                                  SCROLL ===> CSR
Enter an ISPF command, a PDS subcommand or a special control code:
   8 View log  1 Suspend ISPF   6 MEMLIST all   F Find     R Recall
  LA Lista     4 Sublist =      7 Output table  L Locate  SO Sort
  LV Listv     5 Check aliases  9 Swap panels   O Options  X Above/Below/All
 - DSN=TST2SSG.SMP.CNTL,VOL=SER=TSO001  MEM=(ACCEPCHK  ------------------------
 CMD  NAME     DATA     VER.MOD    CREATED   LAST MODIFIED  SIZE  INIT   ID
      ACCEPCHK           01.03    85/03/21  85/11/18 18:45    15    17  TST2SSG
      ACCEPCK2           01.00    86/09/02  86/09/02 15:46    21    21  TST2SSG
      ACCEPT             01.02    85/03/25  87/09/14 23:42    15    15  TST2SSG



SCREEN #3

 -------------------  MEMLIST Source Member List 2  -------------  ROW 1 OF 273
 COMMAND ===>                                                  SCROLL ===> CSR
Enter an ISPF command, a PDS subcommand or a special control code:
   8 View log  1 Suspend ISPF   6 MEMLIST all   F Find     R Recall
  LA Lista     4 Sublist =      7 Output table  L Locate  SO Sort
  LV Listv     5 Check aliases  9 Swap panels   O Options  X Above/Below/All
 - DSN=TST2SSG.SMP.CNTL,VOL=SER=TSO001  MEM=(ACCEPCHK  -----------------------
 CMD  NAME     DATA     ALIASOF   TTR      VER.MOD   LAST MODIFIED  SIZE  ID
      ACCEPCHK                    001310    01.03   85/11/18 18:45    15 TST2SSG
      ACCEPCK2                    001701    01.00   86/09/02 15:46    21 TST2SSG
      ACCEPT                      001E19    01.02   87/09/14 23:42    15 TST2SSG



SCREEN #4

 --------------------  MEMLIST Load Member List 1  -------------  ROW 32 OF 98
 COMMAND ===>                                                  SCROLL ===> CSR
Enter an ISPF command, a PDS subcommand or a special control code:
   8 View log  1 Suspend ISPF   6 MEMLIST all   F Find     R Recall
  LA Lista     4 Sublist =      7 Output table  L Locate  SO Sort
  LV Listv     5 Check aliases  9 Swap panels   O Options  X Above/Below/All
 - DSN=TST2SSG.LOAD,VOL=SER=TSO001  MEM=($$PALIST  ---------------------------
 CMD  NAME     DATA     ALIASOF  LEN/LKED --  ATTRIBUTES   -- APF  MODE  MAIN
      IGC0022H                   85/07/23 RENT REUS           AC=1
      IKJEFF53                   85/06/06 RENT REUS
      INTTBIPO                   86/06/13



SCREEN #5

 --------------------  MEMLIST Load Member List 2  --------------  ROW 32 OF 98
 COMMAND ===>                                                  SCROLL ===> CSR
Enter an ISPF command, a PDS subcommand or a special control code:
   8 View log  1 Suspend ISPF   6 MEMLIST all   F Find     R Recall
  LA Lista     4 Sublist =      7 Output table  L Locate  SO Sort
  LV Listv     5 Check aliases  9 Swap panels   O Options  X Above/Below/All
 - DSN=TST2SSG.LOAD,VOL=SER=TSO001  MEM=($$PALIST  ----------------------------
 CMD  NAME     DATA     ALIASOF   TTR     MAIN   MATCH   LENGTH  ENTRY   SSI
      IGC0022H                   000926                  000448 000000 EFB00000
      IKJEFF53                   000820                  000008 000000
      INTTBIPO                   007326                  000368 000000



SCREEN #6

 --------------------  MEMLIST Load Member List 3  --------------  ROW 32 OF 98
 COMMAND ===>                                                  SCROLL ===> CSR
Enter an ISPF command, a PDS subcommand or a special control code:
   8 View log  1 Suspend ISPF   6 MEMLIST all   F Find     R Recall
  LA Lista     4 Sublist =      7 Output table  L Locate  SO Sort
  LV Listv     5 Check aliases  9 Swap panels   O Options  X Above/Below/All
 - DSN=TST2SSG.LOAD,VOL=SER=TSO001  MEM=($$PALIST  ----------------------------
 CMD  NAME     DATA     ALIASOF  LEN/LKED --  ATTRIBUTES   -- APF  MODE  MAIN
                        MATCH    LENGTH   TTR       ENTRY     SSI
 ---- -------- -------- -------- -------- ---- ---- ---- ---- ---- ---- --------
      IGC0022H                   85/07/23 RENT REUS           AC=1
                                 000448   000926    000000    EFB00000
 ---- -------- -------- -------- -------- ---- ---- ---- ---- ---- ---- --------
      IKJEFF53                   85/06/06 RENT REUS
                                 000008   000820    000000
 ---- -------- -------- -------- -------- ---- ---- ---- ---- ---- ---- --------




SCREEN #7

 -----------------------  LIST ALLOCATIONS  ---------------------  ROW 1 OF 46
 COMMAND ===>                                                 SCROLL ===> CSR
Enter an ISPF command or a special control code:
  LV Listv     7 Output table   9 Swap panels   O Options
  ML Memlist   8 View log       F Find          X Above/Below/All
   ----------------------------------------------------------------------------
 CMD  DDNAME   DATA     TYPE O# VOLUME  MEMBER   ------ DATA SET NAME ---------
      STEPLIB                1  MVSRES           IPO1.LINKLIB
                             1  TSO001           TST.TSO.CMDLIB
                             1  TSO001           TSP.TSO.CMDLIB
      SYSPRINT          TERM 0                   NULLFILE
      SYSTERM           TERM 0                   NULLFILE
      SYSIN             TERM 0                   NULLFILE
      SYSABEND          JES  0  CLS= L           JES2.TSU09137.SO000103
      SYS00001          CTLG 1  MVSRES           TS.ICFUCAT.VMVSRES
      ISPPROF           PO   1  TSO001           TST2SSG.ISPF.ISPPROF





SCREEN #8

 ------------------------  LIST VOLUMES  -------------------------  ROW 1 OF 70
 COMMAND ===>                                                  SCROLL ===> CSR
Enter an ISPF command or a special control code:
  LA Lista     7 Output table   9 Swap panels   O Options
  ML Memlist   8 View log       F Find          S Sort      X Above/Below/All
 -------------------------------------------------------------------------------
 CMD  VOLUME   DATA   DEV DEV   MOUNT USE ---- TOTAL FREE ---  LARGEST   STATUS
 ----  NAME  -------- ADR TYPE   ATTR CNT CYLS TRKS  NUM DSCB CYLS TRKS --INDC--
      MVSARS          9BA 3380   PRIV   0   31  122   15  428   17   18    SI
      MVSRES          9A9 3380   PRIV 113   33  281   34  429    8   13 A  SI
      RESCUE          9A7 3380   PRIV   0    0  131   18  492    0   14    SIV
      TSO001          9B7 3380   STOR  49   81  745  131  633    8    2 A  SI
      VSAM01          9A4 3380   PRIV  74    0    2    1   47    0    2 A  S V
      WORK01          9AA 3380   PUB    1  745   22    6  574  480    0 A  S




SCREEN #9

 ------------------------  SET MEMLIST DEFAULTS ------------------------------
 OPTION ===>

    MEMLIST prompt       ===> NO    (Yes/No)
    LKED date for load   ===> YES   (Yes/No)
    Alias check          ===> YES   (Yes/No)
    Hierarchical panels  ===> NO    (Yes/No)
    Function prompt      ===> YES   (Yes/No)
    Save in profile      ===> YES   (Yes/No)
Notes:
  1.  MEMLIST prompt:   etc.  (There follows a brief explanation of
           each option. )




SCREEN #10

 ------------------------- PDS Function Selection ----------------------------
 OPTION ===>


 Choose one of the following options:

   Option     Function     -- Description --     ---- Status -----
     8      - View Log     View session log      Active
     ML     - MEMLIST      Member list           Active
     LA     - LISTA        Allocation list       Active
     LV     - LISTV        Volume list           Inactive


 OR choose one of the following special functions:

     CAN ML - Cancel pending MEMLIST line commands
     CAN LA - Cancel pending LISTA line commands
     CAN LV - Cancel pending LISTV line commands
     SETLOG - Set log defaults
     SETML  - Set MEMLIST defaults
     END    - Terminate PDS
     QUIT   - Terminate PDS
</font>




       Screen #1 is the introductory screen that is displayed when
ISPMODE is first entered. All ISPMODE screens consist of two parts,
a "TITLE" part and a "TABLE" or "LOG" part.  The TITLE part, at the
top of the screen, is composed of the fixed prompting information and
the variable DSN line of information, with the CURRENT DATASET name,
its VOLUME, and an indication of the DEFAULT MEMBER GROUP, to the
right of the "MEM=" field.

       Below the TITLE part of the screen is the LOG or TABLE
information which is scrollable, using the usual ISPF commands for
scrolling a member list, plus a few that were added by the authors of
PDS.  Screen #1, which one sees immediately upon entering ISPMODE, has
the same information in the LOG portion as if one entered a "DSN"
command initially.  The results of any new PDS commands entered from
the "command line" appear consecutively in the ISPMODE log, and this
log is positioned to view the last command that was just entered.
This action thus approximates how PDS in line-mode appears to the TSO
user, but the "VIEW LOG" has a complete record of the past actions
that occurred. It can be SCROLLED and (with Option 7) OUTPUTTED to
SYSOUT or a dataset, or previous commands in the log can be RECALLed
with the "RECALL" OR "R" command.  The capacity of the ISPMODE view
log can be controlled using the "SETLOG" ISPMODE command.

       So we have glimpsed the "VIEW MODE" ISPMODE function.  In
PDS Version 8.0, there are three more ISPMODE functions:  "MEMLIST",
"LISTA", and "LISTV".  These exist in parallel, that is, one can
switch within ISPMODE from one function to another through special
control codes from the "prompt" part of the screen.  The four functions
exist internally to the session as four separate ISPF tables which
are maintained by the PDS program.  PDS, at the 8.0 level, is cleverly
constructed so that the user can dynamically keep track of these four
sessions.

       How is this done?  Enter the "SETML" command from an ISPMODE
screen.  There will appear a special screen, part of which is
displayed as Screen #9.  Answer YES to "Function prompt" and exit the
screen with PF3.  A new screen will appear; this is illustrated as
Screen #10, the "FUNCTION PROMPT" screen.  On that screen, the four
ISPMODE functions in the session can be tracked.  The user can go in
to any one of the modes by entering an appropriate command.  For
convenience, one may want to skip this prompt screen during his
everyday work.  To do so, just enter the SETML command and answer NO
to "Function prompt".

       An explanation of "HIERARCHICAL PANELS" is in order at this
point, and then we'll go on to the other ISPMODE functions.

       The previous level of PDS, Version 7.3, did not have the four
ISPMODE functions arranged in parallel, as does Version 8.0.  The two
functions LISTA and LISTV were add-ons from what existed in previous
levels of the product.  Also, in Version 7.3, the ISPF internal
processing involved in managing the tables was different.  The
resulting structure was such, that one had to get into VIEW MODE first.
Even if he entered a prompt to get into MEMLIST mode first, he would
always go back into VIEW MODE before exiting from PDS altogether.  The
other two functions LISTA and LISTV could never be entered directly,
but only from either VIEW MODE or MEMLIST mode.  Thus the hierarchy.
VIEW MODE always came first, then MEMLIST mode, then the other two,
LISTA or LISTV.  In Version 8.0, there is still the option of keeping
this kind of relation between modes.  Just answer YES in the SETML
screen to the question about hierarchical panels.

       Now to MEMLIST.  MEMLIST is what the name implies, a list of
members of the current dataset, if it is partitioned.  The list of
members DOES NOT HAVE TO BE A COMPLETE LIST, as in ISPF (versions 2.2
and below).  An important question is:  "Which members are listed?"
This will be dealt with later.  For now, and for simplicity, lets
assume that all the members are listed.  First we want to know what
MEMLIST will do for us.

       Look at Screen #2 and Screen #4.  The first thing you'll
probably notice is that MEMLIST displays as much useful information
for a LOAD MODULE pds as for a SOURCE-TYPE pds.  At a glance, in neat
table form, one can look at groups of members and see what they're
really like.  It doesn't end there.  The alternate screens #3 and #5
show even more stats for the same members.  For load modules, the
third alternate, Screen #6, shows the information from screens #4 and
#5 TOGETHER, so one can glance at all the attributes of particular
modules at once.  Option "9" in MEMLIST screens toggles between
these alternate displays.  The added convenience of OUTPUTTING the
entire MEMLIST log with option "7" is extremely attractive if one
wants to see stats for entire libraries or subgroups of members.

       That isn't really the main purpose of MEMLIST.  Although they
are great, the statistics displays are very secondary when you look at
MEMLIST as a whole.  Its real clout is its ability to give UPWARDS OF
20 SEPARATE FUNCTIONS FROM THE SAME MENU, plus THE ABILITY TO CHANGE
LIBRARIES VERY QUICKLY.

       ISPF/PDF doesn't offer that, even in the latest releases,
although it's come a bit closer lately.  In regular ISPF as shipped
from IBM, if you want to edit a source member, you have to get into
the "EDIT" option first.  If you want to browse the same member, you
have to GET OUT of the EDIT OPTION and GO INTO the "BROWSE" option.
Then, more often then not, you have to choose the name of the member
a second time.  If you want to RENAME or DELETE the member, it's the
same pain in the neck over again--you have to get out of BROWSE
and go into UTILITIES option 3.1.  Even the new Option 3.4 doesn't
eliminate this hassle, although it saves some of the work involved.
With PDS MEMLIST, ALL OF THIS AND MORE, IS DONE WITH THE SAME MEMBER
LIST.  Enter a "B" next to the member and you "browse" it.  Enter "E"
or "S", and you SPFEDIT it.  Enter "REN" and you have the option to
rename the member.  Enter "DEL" or "SC" or "SCR" and you delete the
member.

       There are fifteen-or-so other things one can do from a
MEMLIST screen.  Enter "O" next to a member name, and one gets a
panel of OPTIONS available from there.  Enter "O" from the command
line, and there appears another panel of options for manipulating
members and the dataset itself.

       We have to go on.  LISTA or "LA", the third ISPMODE function,
shows the datasets allocated to the TSO session, by DDNAME.  "LISTA"
is much better than IBM's LISTA TSO command.  LISTA is not merely a
list.  One can DO things from the list.  For example, to free a ddname
allocation, type "FREE" or "F" in the command area next to the ddname.
To change the "current dataset" for the PDS session to one of the
other allocated datasets, merely enter "C" next to that dataset name
on the LISTA screen.  There is also an alternate screen to toggle into
by entering "9".  This shows additional info about the allocated
datasets.

       LISTV or "LV", the fourth ISPMODE function, is a table of
mounted disk volumes.  One must enter an operand with the LV command.
Enter LV followed by a partial name.  A list appears with stats
of mounted disk volumes whose names begin with those characters.  The
stats are very good (see Screen #8 in the illustrations).  LISTV
accepts generic volume names.  One must add the keyword "GENERIC".
Upon entering:  LV SYSDA GENERIC, all mounted volumes in the SYSDA
group are shown.  The screen is set up so that upon pressing your
"HELP" PFKEY (usually PF1) from the LISTV screen, you can get help on
the possible options.  If there is a TSO command with the name "VTOC"
installed on your system, (see file 112 of the CBT tape) you get a
vtoc list upon entering "VTOC" in the command slot next to the volume
name.  These facilities can come in handy.  Remember that all the
lists can be OUTPUTTED with option "7".

       (PDS 8.1 note:  The "line command" facility for both LISTA and
LISTV is greatly expanded in Version 8.1 of PDS.)

       This cursory discussion of the four ISPMODE functions will have
to suffice for now.  We turn our attention to the several concepts of
MEMBER GROUPS that are connected with the PDS product.

       Member subgroups account for much of the heart and power of PDS.
In its old form, the attractiveness of PDS was in the variety of its
utility functions operating on members.  This has grown to bulldozer
power in the current product, when all these abilities can be thrown
on tens, or hundreds of members at once. When one sees the delicacy
with which the groups can be handled, increased, decreased, trimmed,
adjusted--the possibilities truly confound the imagination.

       Basic member manipulation rests on two subcommands, "MEMBERS"
(or "MEM"), and "SUBLIST" (or "SUBL").  These are the rock-bottom
elementary commands that define subgroups of pds members.  There is
a basic difference between them.  Once one understands this difference,
it is easy to follow the workings of the other subcommands that affect
the default, or current MEMBER GROUP.

       Yes, yes.  Not only do we have a CURRENT DATASET, we also have
a CURRENT MEMBER GROUP, which stays with us in our session as long as
the current dataset is partitioned.  If we change the current dataset
with a CHANGE command, as a rule the CURRENT MEMBER GROUP REMAINS THE
SAME.  The current member group changes only if a SUBCOMMAND that
changes it is issued, not if the current dataset is changed.  Now we
are in a position to understand why MEMBERS is different from SUBLIST.

       Groups are initially defined by means of RULES.  We can either
use RANGES of member names, such as "A:C", all members beginning with
letters A thru C.  Or we can use PATTERNS of member names, such as
"ABC/", which specifies that all members containing the string "ABC"
anywhere in the member name, will qualify.  We can use combinations of
the above rules to define a subgroup.  See the special PDS HELP entry
called HELP GROUP, for details.

       If one used the MEMBERS command to initially define the
subgroup, the DEFINITION STAYS AS A RULE.  For example, if one
entered "MEMBERS A:C", the default member group is characterized as
"A:C", NOT as a LIST of members, but merely as A:C.  Upon looking at
the "MEM= " field of the PDS header display, one will see the RULE
DEFINING THE GROUP displayed there if the MEMBERS command was used.
Now if a CHANGE command is issued to change to another current
dataset, the RULE still is displayed, but in this new dataset, a
different LIST OF MEMBERS will qualify as satisfying the rule.

       All this is NOT true if "SUBLIST A:C" was the command first
issued.  In that case, the rules are immediately compared to the list
of members in the current dataset, and a SUBGROUP LIST OF MEMBER NAMES
is generated.  THIS LIST OF NAMES, and not the original rule defining
them, remains as the default member subgroup.  The first NAME in the
list, and NOT the defining rule, will now appear in the "MEM=( " field
of the PDS header display, and an open-paren "(" will be included in
the "MEM=" field.  If the current dataset is now changed, the OLD LIST
OF NAMES WILL REMAIN as the subgroup list, EVEN IF NO SUCH MEMBERS
EXIST in the new current dataset.  The default group now is the LIST,
not the RULES.  There it is in a nutshell.

       We have now learned how to set the member group that we want.
But how do we specify a member group when issuing a PDS subcommand?

       The asterisk "*" is the member group designation character.
Remember that PDS subcommands are issued in the format:
            SUBCOMMAND  MEMBERS  PARAMETERS
where the "MEMBERS" field designates WHICH MEMBERS ARE OPERATED UPON.
(This field is omitted if the current dataset is not partitioned.)
The "members" field can be a range or a pattern, an individual member,
a colon ":" for ALL MEMBERS, or an asterisk "*" for all the members
in the CURRENT SUBGROUP.  By using the asterisk to denote the current
member group in a PDS subcommand, WE CAN PERFORM OPERATIONS ON ALL
MEMBERS IN THE ENTIRE GROUP AT ONCE.  This capability gives the PDS
product much of its power.

       Now we'll discuss more commands which can create the current
member group.  These are "MEMLIST", "IF", and "FIND".

       The "MEMLIST" or "ML" subcommand operates in ISPMODE only, and
causes the session to enter the MEMLIST function and display a member
list.  You may specify which members you want to display, by entering
a range or pattern, or a colon, or an asterisk after the subcommand.
The default is to display the members in the CURRENT MEMBER GROUP.

       Be it known that the LIST OF MEMBERS displayed by MEMLIST is
stored by the PDS program in a table, known as the MEMLIST TABLE.
This table is DIFFERENT from the table which stores the members in
the current group, if the group is defined by a list.  That table is
known as the SUBLIST TABLE.

       When the MEMLIST subcommand is first invoked, the default is to
set the memlist table EQUAL to the sublist table.  You can always
reset the memlist table equal to the sublist table by issuing the
command:  MEMLIST * RESET.

       When you issue another MEMLIST command after the first one, PDS
acts to MERGE the NEW member list generated by the second MEMLIST
command with the member list already in the memlist table. The MEMLIST
TABLE keeps on growing larger, unless the RESET parameter is issued
with an "ML" invocation.  However, EVERY MEMLIST COMMAND INVOCATION
RESETS THE SUBLIST TABLE (and consequently the current group) to
contain ONLY those members from THAT MEMLIST COMMAND, wiping out what
was there before.

       For instance, if you would say:  "ML A:A" followed by "ML C:E",
the MEMLIST TABLE would contain all members starting with the letters
A, C, D, and E.  The SUBLIST TABLE would contain ONLY the members
starting with C, D, and E, as specified by the LAST MEMLIST COMMAND
issued.  However, we can only perform operations on all members of the
current group if they are in the SUBLIST TABLE.  Therefore we need
some command to MAKE THE SUBLIST TABLE EQUAL TO THE MEMLIST TABLE.
This command is:  "SUBLIST = MEMLIST" which cannot be abbreviated.
To make its use easier, so you don't have to type the whole thing, you
can enter option "4" from an ISPMODE screen to get the same effect.

       In brief:  "ML * RESET"  makes the MEMLIST TABLE EQUAL TO THE
CURRENT SUBLIST TABLE.  "SUBLIST = MEMLIST" or ISPMODE option "4"
makes the SUBLIST TABLE EQUAL TO THE CURRENT MEMLIST TABLE, so the
group of members in the MEMLIST TABLE can be made into the current
subgroup.  Once the CURRENT SUBGROUP is made EQUAL TO THE MEMLIST,
then ALL THE MEMBERS IN THE MEMLIST TABLE can be operated upon by PDS
subcommands in one shot.

       All of this means that you can CREATE A CURRENT SUBGROUP from
the MEMLIST members, using option "4".  MEMLIST has one more trick up
its sleeve.  If you enter an "X" next to a member in a MEMLIST, the
member gets EXCLUDED from the MEMLIST TABLE.  By entering option "4",
we then exclude that member individually from the CURRENT SUBGROUP, so
it will NOT be acted upon when we perform a subsequent group operation.
Thus, we have CONTROL OF INDIVIDUAL MEMBERS in designating the members
of the current subgroup.  This shows the power of MEMLIST in
fine-tuning group PDS operations.

       The "IF" subcommand.  This is another super power-packed
tool.  It is one of the unbelievably powerful things included in
this incredible package. The "IF" subcommand allows selection of
a member subgroup, followed by an action of another PDS
subcommand, designated by a THEN keyword parameter.  The format is:
    IF memgroup criterion THEN(subcommand) ELSE(subcommand).
If we look at the PDS HELP entry for the IF subcommand, we can only
gape in wonderment at the huge number of criteria we have. We can pick
only those members created or changed most recently.  Or we can select
only those load modules linkedited within a certain time interval.
The selection of possibilities is enormous and mind-boggling.  The
time and effort that this can save a person can only be appreciated by
personal experience and practice with the "IF" subcommand.

       "FIND".  This is a global command that acts on all members of
a group.  Its power is enormous.  The "FIND" subcommand can be used on
load module libraries as well as source-type libraries, to find all
occurrences of any character string, in all the members.  Just thinking
about this a bit will blow your mind with possibilities.  I use FIND
to scan SYS1.LPALIB to figure out which modules can issue a certain
system message.  There are many far-out and hitherto undreamed of
applications of this subcommand.

       The FIND subcommand also has the THEN-ELSE capability.
Full format is similar to that of the IF subcommand.  It is:
FIND memgroup /string/ THEN(subcommand) ELSE(subcommand).
The default action of the FIND command is to display all occurrences
of the string in a beautiful display, member by member.  FIND can be
used for other purposes, however, such as to pick out all members
from a large library which contain a certain string, or all load
modules which contain a company's logo, for instance.  This is
accomplished by a command of the form:  FIND : /string/ THEN(SUBLIST).
The current member group is reset to include only those members
containing the specified character string.  Again, we have only
begun to scratch the surface.  A referral to the HELP member should
start to set the creativity a-flowing.

       Finally, if you can FIND a string, then you can REPLACE the
string also, or so you would think.  In PDS you CAN do this.  The
REPLACE subcommand changes the found string for a different string,
globally in the partitioned dataset, over the ENTIRE MEMBER GROUP
that has been specified.  It even works for load modules and other
RECFM=U datasets, although for those, there is no capability of
replacing a string with one of different length (an obvious safety
measure for load modules).  REPLACE allows for trial runs before
doing the rewrites, to make sure it will accomplish the desired
result.

       Full format of the REPLACE command is:
REPLACE memgroup /from string/to string /  |WRITE|.  If "WRITE" or "W"
is specified, the replace operation will actually be performed and the
data blocks rewritten.  The resulting display will mention this fact.
If the WRITE keyword is omitted, then there will be a trial run and
a display only.  Mighty powerful stuff.

       In this installment, we have learned about the powerful
PDS features of ISPMODE and member group control.  In the next and
final phase of this introduction to PDS, we will examine the many
subcommands in the PDS product that are available to manipulate
the dataset members themselves.




              *  *  *  *  *  *  *  *  *  *  *  *  *  *


FIGURE 1.


      PDS SUBCOMMANDS - Organized by Type - (for PDS version 8.0)


  SECTION ONE.    General Commands concerning the CURRENT DATASET.

       OPTIONS  - Display the list of subcommands
       HELP     - HELP for PDS subcommands
       END      - STOP THE PROGRAM
       DSNAME   - Display allocation of the "CURRENT DATASET"
       USAGE    - "CURRENT DATASET" STATISTICS (very comprehensive)
       CHANGE   - Change the "CURRENT DATASET"
       RECALL   - Display a PREVIOUS SUBCOMMAND
       DISPLAY  - Display MEMBER NAMES of the "CURRENT PDS" by RANGE
       PATTERN  - Display MEMBER NAMES matching a PATTERN
       TSO      - Invoke a TSO COMMAND from within PDS
       COMPRESS - Compress the "CURRENT DATASET" in place
       VERIFY   - VALIDITY CHECK the "CURRENT DATASET"
       FIXPDS   - Modify DATA SET ATTRIBUTES (very very powerful)
       CONTROL  - Set PROGRAM CONTROLS for general PDS execution

  SECTION TWO.    ISPMODE Commands.

       ISPMODE  - Put this PDS session into ISPMODE
       VIEW     - View the ISPMODE log
       MEMLIST  - ISPF DISPLAY TABLE of members (very versatile)
       LISTA    - Display DATASET ALLOCATIONS for this TSO session
       LISTV    - Display statistics for MOUNTED DISK VOLUMES
       (Each of these has options and subcommands of its own)

  SECTION THREE.  MEMBER GROUP Manipulation Commands.

       MEMBERS  - DISPLAY/DEFINE a MEMBER GROUP
       SUBLIST  - Define a MEMBER LIST SUBGROUP
       MEMLIST  - ISPF DISPLAY TABLE of "MEMLIST SUBSET" of members
       IF       - Conditionally Execute a PDS SUBCOMMAND (powerful)
       FIND     - LIST  occurrences of a STRING for members in a GROUP
       REPLACE  - CHANGE occurrences of a STRING for members in a GROUP
       ATTRIB   - LIST/CHANGE ATTRIBUTES of all members in a GROUP
       VERIFY   - VALIDITY CHECK a MEMBER GROUP
       COPY     - COPY MEMBER GROUP to another Data Set
       OUTCOPY  - Generate IEBCOPY MEMBER SELECT STATEMENTS for a GROUP

  SECTION FOUR.   Individual MEMBER Manipulation Commands.

       EDIT     - EDIT a member using ISPF EDIT
       BROWSE   - BROWSE a member with ISPF BROWSE
       REVIEW   - BROWSE a member using REVIEW (doesn't need ISPF)
       LIST     - DISPLAY a member
       RENAME   - RENAME a member
       DELETE   - DELETE a member
       ATTRIB   - LIST/CHANGE ATTRIBUTES of a member (Source or Load)
       ALIAS    - ASSIGN AN ALIAS to a member (Source or Load)
       HISTORY  - LIST HISTORY of a LOAD MODULE CSECTS and ZAPS
       MAP      - MAP A LOAD MODULE
       COPY     - COPY a member to another Data Set
       CONTROL  - Set PROGRAM CONTROLS for display of MEMBERS
       COMPARE  - COMPARE TWO MEMBERS from the Data Set
       FIND     - LIST LINES containing a STRING
       REPLACE  - CHANGE LINES containing A STRING
       REPRO    - RECOPY A MEMBER in this Data Set
       RESTORE  - RESURRECT a PREVIOUSLY DELETED member
       PRINTOFF - PRINT A HARDCOPY of a member
       SUBMIT   - SUBMIT JCL
       VERIFY   - VALIDITY CHECK a dataset member
       DIRENTRY - DUMP a DIRECTORY ENTRY of a member and DISPLAY FIELDS

  SECTION FIVE.   Other Commands.

       "UNDOCUMENTED" OPTIONS  -  See member $$$UNDOC in install pds
       EXEC     - Execute PDS subcommands from a CLIST
       ISPF     - Invoke ISPF Primary Panel from PDS
       TSOEDIT  - EDIT using TSO EDIT
       TSOLIST  - LIST DATA with TSO LIST
       FSE      - EDIT using FSE (vendor product or free product)
       DSPRINT  - Print a HARDCOPY with DSPRINT  (vendor product)
       VPSPRINT - Print a HARDCOPY with VPSPRINT (vendor product)
       <i>"There is more.  You have to explore."</i>

<hr>
<a name="$pdsart3"></a>

           Public MVS Software - The PDS Program - Part Three


                                      Sam Golob
                                      MVS Systems Programmer
                                      Newsweek, Inc.
                                      Mountain Lakes, New Jersey 07046
                                      (201) 316-2328


       This series of several installments deals with a tremendously
useful productivity aid, the PDS Program Product, Version 8.0, which
can be found on the CBT mods tape for MVS.  This product introduces
new extensions to IBM's ISPF/PDF, and has very great capabilities of
partitioned dataset member manipulation.  It is (literally) one
hundred utilities, or more, cleverly woven into one framework.

       PDS Version 8.0 also has a unique beauty in its construction
that makes it an ideal system programmer tool, dear to all those
familiar with it.  In this article of the series, I hope to convey
some of the elegance of PDS to the reader.  The many ways of doing
things in PDS, and the possibility of interweaving combinations of
different operations, make for the opportunity to creatively accomplish
things you've never done before.

       Our format in this series is to guide the reader through the
many PDS options, or SUBCOMMANDS.  For the sake of clarity, we have
grouped the PDS subcommands into FIVE SECTIONS, according to type
(see Figure 1).

       The first installment of this series dealt with the dataset
currently being handled by the PDS program.  In PDS terms, this is
called the CURRENT DATASET.  PDS has formidable capability of displaying
and changing the current dataset's characteristics and vitals.  The PDS
subcommands which deal with the current dataset as a whole are grouped
into SECTION ONE of our option list.  Part one of these articles
dealt with the PDS subcommands in SECTION ONE.

       In our last article, we introduced the reader to PDS's
time-saving ISPF INTERFACE and to PDS's great ability to operate ON
GROUPS OF PDS MEMBERS AT ONE TIME.  The fact that one can BROWSE,
EDIT, RENAME, DELETE, or PRINT a pds member from THE SAME MEMBER LIST,
without having to switch to a different ISPF option, is nothing short
of amazing to the ISPF user.  This, combined with the fact that there
can be a PARTIAL MEMBER LIST at the convenience of the viewer, makes
for some very considerable power.  The concept of a partial subset of
members extends to the user's ability to OPERATE ON ALL THE GROUP
MEMBERS IN ONE SHOT.  For example, one can select all members (or even
load modules) containing a given search string, and delete or copy
them all together.  The subcommands controlling these phases of PDS
use were covered in the last installment. Those subcommands are
roughly in SECTIONS TWO AND THREE of our subcommand list.

       This month's installment will concentrate on SECTIONS FOUR AND
FIVE of the subcommand list, dealing with individual member manipulation
and special options.  We'll show how someone who uses PDS can be like
an ordinary ISPF user, and yet have five or ten times more power.
He can do all of the same things; none of ISPF is lost when PDS is
hooked in.  However, he has many more tools at his immediate disposal,
and the whole force of PDS capability can be marshalled in one unified
session.

       We begin our discussion with the most common member manipulation
subcommands, EDIT, BROWSE, RENAME, and DELETE (or SCRATCH).  To put the
discussion in perspective, let's see how these functions are handled
in ordinary ISPF, as shipped by IBM.

       In normal ISPF, the usual way to edit a pds member is to get
into the "EDIT" ISPF option by typing "2" at the top of the main
ISPF menu.  This gets the user into the "EDIT" main menu.  Once
there, the dataset name is entered, and the user is presented with
an alphabetical list of members.  One positions to the desired member
by using the "LOCATE" or "L" command on the command line, and the
desired member is then selected, by putting the letter "S" next to its
name.  When the machine responds, the member to be edited appears on
the screen.  If one would now like to "BROWSE" or "RENAME" the member,
one cannot do so in "EDIT".  Ordinary ISPF as shipped by IBM requires
that you get out of "EDIT" and go into the "BROWSE" screen "=1" to
browse, or to the "UTILITY" screen "=3.1" to rename or delete the
member.  One must also retype the member name, or reposition the
selection list to the appropriate name, because that information is
not preserved when you change ISPF "modes" in ordinary ISPF.

       This is much simpler using PDS in ISPMODE.  First, one gets into
the PDS main screen from the initial ISPF menu (an option must be set
up for this with the PDS install).  There, a CURRENT DATASET is selected
as with ordinary "EDIT" or "BROWSE" modes.  Then, once you're into the
PDS view mode screen for the dataset, a member list can be generated
by the use of the "MEMLIST" or "ML" commands.  Here is where the PDS
advantage starts.

       First, one need not select a complete member list.  An option
"6" from the ISPMODE View Mode screen will indeed create a full member
list, but the ML command may be used with a "range" such as "ML AB:C"
or a pattern such as "ML XYZ/" to select a partial list.  This sets up
the CURRENT MEMBER GROUP as well as initially creating a partial
member list.  We discussed more particulars of this process in our
last article.

       Once a member list is obtained, the user merely enters "E" or
"S" (for SPFEDIT) next to the member name to EDIT, "B" to BROWSE, "REN"
to RENAME, "SC" or "DEL" to DELETE.  Simple.  That is the way it ought
to be.  The last command executed on a given member name in the list
is displayed in the data area to the right of the command.  This is
illustrated in Screen #1.

       Please refer to Screen #2.  The list of options available
from the MEMLIST member list is not limited to these four, but it
includes almost every PDS option which affects an individual member.
At this point we shall divide the discussion into subcommands affecting
source-type members (Program Source, JCL, printout, TSO CLISTS, any
RECFM=FB or VB libraries), and load-type libraries (load libraries,
SYS1.IMAGELIB, any RECFM=U library).  PDS has many special features
tailored to each type of library member.

       Options available from the MEMLIST screen for source-type members
include:  REVIEW, LIST, ATTRIB, ALIAS, COPY, COMPARE, FIND, REPLACE,
SUBMIT, PRINTOFF, VERIFY, COPY, REPRO, OUTCOPY and DIRENTRY, besides
the four others already mentioned.

       For load-type libraries:  MAP, ATTRIB, HISTORY, VERIFY, and
DIRENTRY are especially valuable utilities and investigative tools.
If full-screen ZAP from CBT tape file 134 is installed and available,
it can be accessed for the CURRENT DATASET by placing "Z" on the
ISPMODE command line.  ALIAS, BROWSE, COPY, REPRO, FIND, REPLACE, and
OUTCOPY are also extremely valuable for load libraries.  RESTORE is a
particularly useful tool for both types of dataset.

       In keeping with our systematic approach in covering the
features of the PDS product, we shall consider the more source-oriented
subcommands first, and we follow with the load library manipulations
afterwards.  This will cover Section Four.  Then we'll conclude
with the miscellaneous features of Section Five, and with some mention
of customization.

       To clarify and crystallize the discussion which follows, we
will talk about all these subcommands from a MEMLIST framework.  The
commands will be illustrated by examples using the MEMLIST screens.
It should be clear, however, that these commands can all be done from
the ISPMODE command line or the "Enter Options" prompt also.  In fact,
it is necessary to enter a subcommand from the command line if its
operands have more than eight characters.  Our discussion will center
around the MEMLIST screen to show the versatility of the member list
and its clear advantage over ordinary ISPF.

       We begin the source-oriented commands with REVIEW, LIST, SUBMIT,
PRINTOFF, and REPRO.  "REVIEW" or "REV" is a full screen browse-like
command that is really a separate TSO utility, completely independent
of ISPF.  It is accessible from the MEMLIST screen by placing the
letters "REV" next to the member name to be "browsed".  This REVIEW
command has its own internal "help" facility, accessible through
pfkeys.  The command is extremely handy at times, for example, if ISPF
is not available.  The REVIEW program from file 296 of the CBT
tape has to be installed for this option to work under PDS.

       The "LIST" subcommand of the PDS product is not the same as the
TSO "list" command.  (The latter is obtainable through the "TSOLIST"
or "TSOL" subcommand.)  The "PDS" LIST subcommand will place an image
of the target member into the ISPMODE VIEW LOG for scrolling.  This
image can be written out to a SYSOUT file or another dataset by means
of the "log outputting" facility, option "7" of the MEMLIST screen.
To "LIST" a member from the MEMLIST screen, type an "L" next to the
member name in the command space.

       The SUBMIT or "SUB" subcommand can be executed from MEMLIST by
placing "SUB" next to a member name containing JCL.  This command is
different from "submit from ISPF edit" in that a temporary copy of the
submitted JCL is not created during the submission.  There is a nice
technique of submitting JCL when full screen TSO is not available.
LIST is used to view the jobstream.  Tailoring of the JCL may be done,
avoiding ISPF edit, by using the FIND/REPLACE commands.  One can use
REPLACE to do minor alterations of the existing job via update
in-place.  Using this technique, I edit and submit jobs from a SYSTEM
CONSOLE, running PDS under TSSO Release 4.3 (file 404 of the CBT tape).
It is applicable under any circumstance where one wishes to avoid ISPF
edit, or where the user does not have full screen capability.

       The PRINTOFF utility (distributed with IPO, or obtainable from
several places on the CBT tape) prints a dataset or a pds member.  It
can be called from PDS if the command is installed.  "PR" is the
abbreviation you can enter from the MEMLIST screen, but "O.PR" will
provide the user with an extremely convenient panel from which to enter
the print options.  Output can be routed to any class or normal
destination.  The "O.PR" screen prompts the available options.  The
version of the PRINTOFF utility from file 325 of the CBT tape (from
Wells Fargo Bank) is an exceptionally good version of the program.
This version allows VM-type destinations for output, for example:
DEST(RSCS.VMPRINTR) or DEST(RSCS.VMUSER).  The print can then go to a
VM-controlled destination without manual intervention from VM itself.

       The "REPRO" subcommand of PDS is used to make a copy of a member
in the same pds.  It can be used for either source or load-type members.
It is quite handy.  REPRO is the subcommand to use if you want to
duplicate a pds member within the same pds.  It requires answering
a prompt of "YES".  This prompt can be turned off globally in your
session by entering "CONTROL NOPROMPT" from the command line.  It is
probably better for most sessions to retain the prompt, because other
more critical commands (such as FIXPDS RESET, which clears a pds of
its members) require the prompt also.

       The "ALIAS" subcommand does not make a copy of the member, but
makes an additional directory entry pointing to it.  The "alias" entry
provides an alternate name for accessing a pds member.  The ALIAS
subcommand of PDS works for source or load modules.  For source, I
find it useful for naming TSO help members with alternate names.
These are usually the alias names of the TSO command which the "help"
is for.

       With load modules, the ALIAS subcommand does even more.
Non-trivial entry points of a load module, that have the same name as
the new "alias" entry, are respected by the ALIAS subcommand, and the
new alias will have its own entry point, not the one of the original
member name.  If the new alias name doesn't have an entry point in the
load module corresponding to that name, the main member's entry point
is assigned as the alias member's entry point.  The ALIAS subcommand
can be entered next to a member name in a MEMLIST by entering "AL"
in the command space, and the new name in the data area.

       Speaking of pds directory entries, the odds are that you've
never seen a utility that displays and formats one.  Well you have
that utility now.  The DIRENTRY subcommand, accessible from the MEMLIST
screen by putting "DIR" next to the member name, displays a hex dump
of the directory entry for that member.  It also formats every field
in the entry, and explains its meaning to you in English.  Wow is the
word for this little tool.

       For source-type members, we basically have FIND, REPLACE,
VERIFY, and COMPARE left to discuss.

       To use the FIND subcommand for a single member on the MEMLIST
screen, enter "FIND" in the command space to the left of the member
name, and the string (up to six characters) between delimiters, in
the "data" space to the right of the member name.  See Screen #1.
Of course, the data area of the MEMLIST screen has only eight characters
in the space.  The same command entered from the command line at the
top of the screen can have a much longer operand, because the command
line has much more room.  On the MEMLIST line, you don't have to type
the member name over.  You have the choice, whichever way to do it is
most convenient.

       REPLACE is very much like FIND.  It is usually impractical to
execute a REPLACE subcommand from a MEMLIST screen, but for very short
search strings, it is possible, and I have illustrated it in Screen
#1.  The format of the REPLACE command for a string in a single member
is:
         REPL member   /scanstring/replstring/ |WRITE|  .
For a member group the REPLACE format is:
         REPL memgroup /scanstring/replstring/ |WRITE|  .
The keyword "WRITE", if present, makes the string replace permanent,
via update in-place.  Without the keyword "WRITE", the command is a
dry run, to display what WOULD BE found and replaced.

       VERIFY, for a single member, counts the number of logical
records and physical blocks.  It displays the size of the largest
physical block in the member, and it also shows the average size
of the blocks in that member.  If the member has any irregularities,
for instance, if it is marked as an alias, but no main member exists
for it, this will be shown.  VERIFY is useful for spotting troublesome
members or load modules quickly.  To execute VERIFY from a MEMLIST
screen, simply type "VER" in the command area next to the member name.

       COMPARE does a line-by line matchup between two source-type
fixed blocked members of a pds, and reports the differences.  It is
designed for 80-byte LRECL files.  It uses the COMPARE utility which
is found on CBT tape file 296.  This quick check is extremely useful
in many common circumstances, for instance, when updating JCL or
program source listings, to keep track of the changes against the
original member.  COMPARE requires the two member names as operands.
It can be executed from a MEMLIST screen by typing "COMP" in the
command area to the left of the first member's name, and typing the
second member's name in the data area to the right side of that name.
The compare report showing the differences will appear on the TSO
screen.

       It should be apparent by now, that ISPMODE operation of PDS
can combine the advantages and tools of normal ISPF with the
enormous power of the PDS subcommands.  The normal ISPF "locate"
or "L" command can be used to position a MEMLIST member list in the
same way as with any other ISPF member list.  In addition, there
is a "find" or "F" command which will position the MEMLIST downward
to find any scan string, such as a member's userid.  This extra
command is an added convenience.

       We must now talk about the special capabilities that PDS has
with load module libraries and their members.  For many users, these
load module utility features fully justify their use of the PDS product.
The utter power of PDS on load modules makes the user feel like
Superman.

       The big gun subcommands for load modules are:  ATTRIB, MAP,
HISTORY, IF, FIND, VERIFY, CONTROL, and COPY.

       "ATTRIB" or "AT", the "attribute" PDS subcommand, is big gun
number one.  Its function is to show, and also to CHANGE, load
module attributes, either for a single load module, or for a member
group of load modules.  (For source modules, ATTRIB plays with ISPF
statistics.)  Almost every load module attribute can be CHANGED ON
THE FLY with the ATTRIB subcommand.  If you forgot to linkedit a load
module as reentrant, all you have to do is say:  "AT modname RENT".
Zappo, it's now marked reentrant.  If it was linkedited as reentrant
by mistake, you just have to say:  "AT modname NORENT NOREUS".  Voila.
The reentrant attribule is gone.  "AT modname AUTH" and "AT modname
NOAUTH" make a module authorized or non-authorized with a few flicks
of a keyboard.  One can put an SSI on a module.  Simply enter:  "AT
modname SSI(ssinumbr)", and it's there.  This can also be done to a
group of modules just as easily.  "AT memgroup SSI(ssinumbr)" does the
trick just as easily as for one member.  That applies for all the
other ATTRIB capabilities.  They work for groups as well.

       If you think that's power, consider "MAP" and "HISTORY" as well.
"MAP" does a load module map of csects and entry points, similar
to the "map" option of the linkage editor.  "MAP" has some nice
non-default options, but the real winger-dinger is "MAP modname
RELINK", which can be done from a MEMLIST member entry, as well as
from the command line.  The output of this gem, is no less than THE
COMPLETE RE-LINKEDIT JCL for the load module.  This is written to
the ISPMODE View Log if you're in ISPMODE.  Using the ISPMODE
"outputting" option "7", the generated JCL can be written to a dataset
and rerun, perhaps with a few changes or different linkedit control
cards.  The linkedit attributes in the generated job are all correct,
according to the current structure of the load module.  Bet you've
never seen anything like THAT before.  Here's the beauty of PDS.

       The "HISTORY" subcommand shows the complete linkedit history
of all csects in a load module, showing csect replacement IDR records
and zap IDR records sorted by date, with the most current changes
listed first.  It is a good way of looking at a load module to see
which PTFs were applied.  This subcommand is inherited from the
original version of PDS from long ago, but like everything else in the
product, it has been jazzed up significantly.  If the "CONTROL
TRANSLATOR" option is in effect (which can be accomplished by entering
"CONTROL TRANS" on the command line), then the assembly or compile
history of the csects is included as well.  The information, of
course, is obtained from the IDR records of the load module; PDS's
ability to report such information in formatted form to the user is
thorough, and covers the ground well.

       Are we finished yet?  Not quite.  We have to look at IF, FIND,
REPLACE, and COPY for load modules, then a word about undocumented
commands, miscellaneous commands, and customization.

       The "IF" subcommand (complete with THEN and ELSE operands)
provides an exquisite, sophisticated, and extremely handy means of
selecting subgroups of members, and performing operations on the
whole group.  Load modules can be selected to be in the group by
date created or changed, or by practically any attribute.  One can
select all reentrant load modules in a library, or modules linkedited
before or after the last month, for example.  The combinations and
possibilities for such selections are practically endless.  Once
a SUBLIST has been selected, (for example, using "IF : LAST(38)
THEN(SUBLIST)", which will select all modules linkedited in the last
38 days), then a subsequent operation can be performed on the entire
selected group at once.  The number of "IF" options provided by PDS
for both source and load modules is too vast to discuss here.  A good
treatment can be found in the TSO HELP member which comes with the
PDS product.

       We mentioned in our last article that the "FIND" subcommand
finds occurrences of character strings in all members of a member
subgroup.  "FIND" also has THEN-ELSE logic connected with it, just
as "IF" does.  For example, we may want to know which module of a
package produces a certain operator message.  The operator message we
want to know about is $HASP249.  The product is JES2, which resides on
SYS1.LINKLIB and SYS1.LPALIB.  All the JES2 modules begin with the
letters "HAS".  After setting the CURRENT DATASET to SYS1.LINKLIB with
the command "Change SYS1.LINKLIB", we can enter:  "FIND HAS: /HASP249/
THEN(SUBLIST)".  PDS will look at all members whose names begin with
"HAS" in SYS1.LINKLIB and which also contain the string "HASP249".
Then a SUBLIST or member group will be created, such that each member
fulfills these conditions.  This subgroup can be referred to later
by the asterisk "*" designation.  For example, you may want to restrict
a subsequent "FIND" operation to this current group.  The command
"FIND * /HASP249/" will display all the actual occurrences of and
locations of the string at the TSO tube, or in the ISPMODE view log.

       It's a pity that I had to leave the "COPY" and "COMPRESS"
subcommands for last.  "COPY" is so useful, that it deserves a more
prominent place in our discussion.  "COPY" can create NEW COPIES of a
dataset as well as copy a selection of members from one dataset to
another.  "COPY" can optionally pull all the aliases into the copy
automatically, together with the original member names.  The only
drawback in COPY is setting it up, because the IEBCOPY program from
IBM must be authorized in order to run, and the ISPF environment (as
well as PDS in general, usually) is not an authorized environment.
Having the vendor copy product PDSFAST (from SEA) is one solution;
PDSFAST doesn't run authorized.  There are several ways of setting up
the COPY command to run, as described in the PDS install literature
which comes with the product.  All I need say here is that it is well
worth setting up.  The same remarks apply to the "COMPRESS"
subcommand, which does on-line compresses to the current dataset.

       I promised to talk about "undocumented" options, specialized
subcommands and customization.  There is a member in the PDS install
library which describes unpublicized commands and some tricks and
hints.  For instance, the "K" or "KLEAR" command can be used to clear
the screen.  The "TIME" command formats a nice time and date message.
The "SCRATCH" command and the "DELETE" command mean the same thing.
The "EDIT" and "SPFEDIT" subcommands mean the same thing, and so on.
Also, PDS has a "UTILITY" connection in ISPMODE that can be customized
to accept new commands within the PDS environment.  So much for that.
The literature is available on the PDS install dataset if you want
to delve deeper.

       Invocations to several vendor commands are supported by PDS
which I relegated to Section Five, because not every shop has these
commands.  These are "DSPRINT", "VPSPRINT", and "FSE".

       "TSOEDIT", which invokes the old TSO EDIT command, is seldom
used by most people, but it is available in the PDS environment.
"TSOLIST", or the actual TSO "LIST" command, is also available.
Enough said.

       A last word about customization, and that's it.  When PDS is
installed, there is a copy member with a large number of assembler
globals that control the default operation of how PDS will work.
There are maybe 70 to 100 things that can be set in there.  Some of
the defaults most likely will not be appropriate or best for your
environment.  Others will result in commands being not as easy to use
as they could have been if the options had been set otherwise.  As
always, it pays to investigate.

       Well, I can't tell you that now you know everything about PDS.
I can assure you that with this background, you're in a position to be
a far more productive system programmer.  Learning to get new results
and techniques from the PDS product is a continuous process.  Growing
is part of this territory.  But then, growing is what our job is all
about.



              *  *  *  *  *  *  *  *  *  *  *  *  *

<font face="Fixedsys">
SCREEN #1

 -----------------  MEMLIST Source Member List 1  -----------  ROW 1 OF 273
 COMMAND ===>                                              SCROLL ===> CSR
Enter an ISPF command, a PDS subcommand or a special control code:
   8 View log  1 Suspend ISPF   6 MEMLIST all   F Find     R Recall
  LA Lista     4 Sublist =      7 Output table  L Locate  SO Sort
  LV Listv     5 Check aliases  9 Swap panels   O Options  X Above/Below/All
 - DSN=TST2SSG.SMP.CNTL,VOL=SER=TSO001  MEM=(ACCEPCHK  -----------------------
CMD  NAME     DATA     VER.MOD    CREATED   LAST MODIFIED  SIZE  INIT    ID
REN  ACCEPCHK ACCEPCK   01.03    85/03/21  85/11/18 18:45    15    17   TST2SSG
     ACCEPCK2 *EDIT*    01.00    86/09/02  86/09/02 15:46    21    21   TST2SSG
     ACCEPT   *BROWSE*  01.02    85/03/25  87/09/14 23:42    15    15   TST2SSG
     ACCEPTD  *PRINTOF  01.01    85/03/26  85/03/26 10:18    15    15   TST2SSG
     ACCEPTU  *FIND*    01.01    85/11/26  85/11/27 10:49    18    23   TST2SSG
     ACCEPT3  *INVALID  01.00    85/05/13  85/05/13 15:55    16    16   TST2SSG
REPL ACCPTFN  /SMP/SMQ/ 01.02    84/12/19  86/07/21 15:24    15    15   TST2SSG
     ACK1     *ATTRIB*  01.05    85/05/06  86/07/07  7:21    18    15   TST2SSG
     ACPCK0   *NEWNAME  01.00    87/04/28  87/04/28 14:22    28    28   TST2SSG
     ACPCK1   *ALIAS*   01.00    87/04/28  87/04/28 14:22    28    28   TST2SSG
     ACPCK2   *REPRO*   01.01    87/04/28  87/04/28 18:30    38    38   TST2SSG
     ACPCK3   *NEWNAME  01.01    87/04/28  87/04/28 18:30    38    38   TST2SSG
     ACPTCHD  *DIRENTR  01.00    85/03/23  85/03/23 22:33    15    15   TST2SSG
     ACPTTSO3 *REVIEW*  01.01    87/02/19  87/02/19 13:41    48    48   TST2SSG
     ACPTUSR1           01.01    85/11/18  85/11/19 10:06    16    16   TST2SSG
     ALLCOVER *SUBMIT*  01.01    85/01/24  85/01/24 16:19    48    32   TST2SSG
     APARGENR           01.00    86/05/06  86/05/06 10:27    15    15   TST2SSG
     APCKUCC1           01.00    87/12/03  87/12/03 17:43    19    19   TST2SSG




SCREEN #2

 -------------------------  PDS o line command selection  ----------------------
 OPTION  ===>


 Choose one of the following for member ACCEPTU

     A    - Attrib             LOG  - Log line
     AL   - Alias              OUT  - Outcopy
     B    - Browse             PR   - Printoff
     COM  - Compare            REN  - Rename
     COPY - Copy               REP  - Replace
     DEL  - Delete             REPR - Repro
     DIR  - Direntry           REV  - Review
     DSP  - Dsprint            SUB  - Submit
     E    - Edit               TSOE - Tsoedit
     F    - Find               TSOL - Tsolist
     FSE  - Fse                V    - Verify
     H    - History            VPS  - Vpsprint
     L    - List


 Enter UTIL if your choice is on the associated utility panel
</font>


              *  *  *  *  *  *  *  *  *  *  *  *  *

 Figure 1.


      PDS SUBCOMMANDS - Organized by Type - (for PDS version 8.0)


  SECTION ONE.    General Commands concerning the CURRENT DATASET.

       OPTIONS  - Display the list of subcommands
       HELP     - HELP for PDS subcommands
       END      - STOP THE PROGRAM
       DSNAME   - Display allocation of the "CURRENT DATASET"
       USAGE    - "CURRENT DATASET" STATISTICS (very comprehensive)
       CHANGE   - Change the "CURRENT DATASET"
       RECALL   - Display a PREVIOUS SUBCOMMAND
       DISPLAY  - Display MEMBER NAMES of the "CURRENT PDS" by RANGE
       PATTERN  - Display MEMBER NAMES matching a PATTERN
       TSO      - Invoke a TSO COMMAND from within PDS
       COMPRESS - Compress the "CURRENT DATASET" in place
       VERIFY   - VALIDITY CHECK the "CURRENT DATASET"
       FIXPDS   - Modify DATA SET ATTRIBUTES (very very powerful)
       CONTROL  - Set PROGRAM CONTROLS for general PDS execution

  SECTION TWO.    ISPMODE Commands.

       ISPMODE  - Put this PDS session into ISPMODE
       VIEW     - View the ISPMODE log
       MEMLIST  - ISPF DISPLAY TABLE of members (very versatile)
       LISTA    - Display DATASET ALLOCATIONS for this TSO session
       LISTV    - Display statistics for MOUNTED DISK VOLUMES
       (Each of these has options and subcommands of its own)

  SECTION THREE.  MEMBER GROUP Manipulation Commands.

       MEMBERS  - DISPLAY/DEFINE a MEMBER GROUP
       SUBLIST  - Define a MEMBER LIST SUBGROUP
       MEMLIST  - ISPF DISPLAY TABLE of "MEMLIST SUBSET" of members
       IF       - Conditionally Execute a PDS SUBCOMMAND (powerful)
       FIND     - LIST  occurrences of a STRING for members in a GROUP
       REPLACE  - CHANGE occurrences of a STRING for members in a GROUP
       ATTRIB   - LIST/CHANGE ATTRIBUTES of all members in a GROUP
       VERIFY   - VALIDITY CHECK a MEMBER GROUP
       COPY     - COPY MEMBER GROUP to another Data Set
       OUTCOPY  - Generate IEBCOPY MEMBER SELECT STATEMENTS for a GROUP

  SECTION FOUR.   Individual MEMBER Manipulation Commands.

       EDIT     - EDIT a member using ISPF EDIT
       BROWSE   - BROWSE a member with ISPF BROWSE
       REVIEW   - BROWSE a member using REVIEW (doesn't need ISPF)
       LIST     - DISPLAY a member
       RENAME   - RENAME a member
       DELETE   - DELETE a member
       ATTRIB   - LIST/CHANGE ATTRIBUTES of a member (Source or Load)
       ALIAS    - ASSIGN AN ALIAS to a member (Source or Load)
       HISTORY  - LIST HISTORY of a LOAD MODULE CSECTS and ZAPS
       MAP      - MAP A LOAD MODULE
       COPY     - COPY a member to another Data Set
       CONTROL  - Set PROGRAM CONTROLS for display of MEMBERS
       COMPARE  - COMPARE TWO MEMBERS from the Data Set
       FIND     - LIST LINES containing a STRING
       REPLACE  - CHANGE LINES containing A STRING
       REPRO    - RECOPY A MEMBER in this Data Set
       RESTORE  - RESURRECT a PREVIOUSLY DELETED member
       PRINTOFF - PRINT A HARDCOPY of a member
       SUBMIT   - SUBMIT JCL
       VERIFY   - VALIDITY CHECK a dataset member
       DIRENTRY - DUMP a DIRECTORY ENTRY of a member and DISPLAY FIELDS

  SECTION FIVE.   Other Commands.

       "UNDOCUMENTED" OPTIONS  -  See member $$$UNDOC in install pds
       EXEC     - Execute PDS subcommands from a CLIST
       ISPF     - Invoke ISPF Primary Panel from PDS
       TSOEDIT  - EDIT using TSO EDIT
       TSOLIST  - LIST DATA with TSO LIST
       FSE      - EDIT using FSE (vendor product or free product)
       DSPRINT  - Print a HARDCOPY with DSPRINT  (vendor product)
       VPSPRINT - Print a HARDCOPY with VPSPRINT (vendor product)
       <i>"There is more.  You have to explore."</i>

<hr>
</pre>
<address>
sbgolob@att-global.net
</address>
</body>
</html>
