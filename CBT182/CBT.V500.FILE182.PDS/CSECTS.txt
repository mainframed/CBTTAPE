/* --------------------  rexx procedure  --------------------------- */
/* Name:      CSECTS                                                 |
 |                                                                   |
 | Function:  Present the user with a table of available             |
 |            CSECTs from which the user may select to LIST          |
 |            or DISAssemble with the PDS command.  In addition,     |
 |            program object CSECTs can be listed with the           |
 |            DUMPT option of the SPZAP program.                     |
 |                                                                   |
 | Use:       User extended line command in P86LLUX to display a     |
 |            list of CSECTs for a load module.                      |
 |                                                                   |
 |            CS,'CMD(%CSECTS ''&PDSDSN'' &PDSMEM)'                  |
 |                                                                   |
 | Syntax:    %CSECTS loadmod                                        |
 |                                                                   |
 | Author:    Janko Kalinic (inspired by Lionel B. Dyck)             |
 |            The ISPF Cabal - Vive la révolution                    |
 |                                                                   |
 | History:                                                          |
 |            04/04/18 - Creation                                    |
 |            12/09/18 - Add D line command. Invoke SPZAP DUMPT      |
 |                       for program objects in a PDSE               |
 | ----------------------------------------------------------------- |
 | Copyleft (c) All Wrongs Reserved                                  |
 * ----------------------------------------------------------------- */

/* --------------- *
 | define defaults |
 * --------------- */
  parse value '' with null load_info

/* ----------------------- *
 * Get the passed module  *
 * ----------------------- */
  parse upper arg pdsdsn csctname

/* ---------------------------------------- *
 | Build and Display the table of CSECTs    |
 * ---------------------------------------- */
  Address ISPExec
  load_info = loadispf()

  module = csctname
  x = outtrap("stdout.","*")
  Address TSO
  queue "history "module
  queue "end"
  "pds "pdsdsn" xispmode"
  x= outtrap("off")
  Address ISPexec

  call build_list
  ztdsels = 0
  src = 0
  rowcrp = 0
  crp = 1
  table_panel = CSECTS
  do forever
    zcmd = null
    zsel = null
    if ztdsels > 0 then src = 4
    if src = 4 then "TBDispl" csctable
    else do
      "TBTOP" csctable
      "TBSKIP" csctable "NUMBER("crp")"
      if rowcrp = 0 then
         "TBDISPL" csctable "PANEL("table_panel")"
      else
         "TBDISPL" csctable "PANEL("table_panel")",
                  "CSRROW("rowcrp") AUTOSEL(NO)"
    end
    src = rc
    crp = ztdtop
    if rc > 4 then do
      'tbend' csctable
      leave
    end

    if datatype(row) /= 'NUM' then row = 0
    if row /= 0 then do
      ssel = zsel
      "TBTOP" csctable
      "TBSKIP" csctable "NUMBER("row")"
      zsel = ssel
    end

    if zcmd /= null then do
      Select
        When zcmd = 'RL' then do
             if srchcsct = null then do
                smsg = 'Invalid'
                lmsg = 'Repeat Locate (RL) must follow' ,
                       'a Locate command.'
                'setmsg msg(csct001)'
                end
             else call do_locate srchcsct 'Next'
             end
        When abbrev('H',translate(word(zcmd,1)),1) = 1 then do
             'Select pgm(isptutor) parm(#cscth1)'
             end
        When abbrev('S',translate(word(zcmd,1)),1) = 1 then do
             parse value zcmd with x csctname
             if csctname = null then do
                smsg = 'Unknown'
                lmsg = 'Select requires a CSECT name.'
                'Setmsg msg(csct001)'
                end
             else do
                  call do_it
                  end
             end
        When abbrev('LOCATE',translate(word(zcmd,1)),1) = 1 |,
          abbrev('FIND',translate(word(zcmd,1)),1) = 1 then
          call do_locate subword(zcmd,2)
        Otherwise do
          smsg = 'Unknown'
          lmsg = word(zcmd,1) 'is an unknown command.'
          'Setmsg msg(csct001)'
          end
        end
      end
    if zsel /= null then do
      call do_it
      end
  end

/* -------------------------- *
 | Done so clean up and leave |
 * -------------------------- */
  Address ISPEXEC
  do until length(load_info) = 0
    parse value load_info with dd libd load_info
    if left(libd,6) = "ALTLIB" then do
      if libd = "ALTLIBC"
         then lib = "CLIST"
         else lib = "EXEC"
      Address TSO,
        "Altlib Deact Application("lib")"
    end
    else "libdef" libd
    Address TSO "free f("dd")"
  end
  exit

/* ---------------------------------------- *
 | Build the list of available CSECTs by    |
 | executing the PDS HISTORY command.       |
 * ---------------------------------------- */
build_list:
  csctable = 'csc'random(999)
  'tbcreate' csctable 'keys(csctname) names(csctdesc)' ,
    'replace share nowrite'
  do i = 1 to stdout.0
    Parse Var stdout.i csctname +9 csctdesc +30
    if Pos('/',Left(csctdesc,3)) = 0 then Iterate
    'tbadd' csctable 'order'
  end
  drop stdout.
  'tbtop' csctable
  'tbsort' csctable 'fields(csctname,c,a)'
  return

Do_Locate:
  arg srchcsct next
  if srchcsct = null then do
    smsg = 'Invalid'
    lmsg = 'No CSECT name provided'
    'Setmsg msg(csct001)'
  end
  else do
    if next = null
       then 'tbtop' csctable
    else do
      'tbtop' csctable
      'tbskip' csctable 'Number('crp')'
       end
    rlhit = 0
    'tbvclear' csctable
    csctname = srchcsct'*'
    if next /= null then next = 'NEXT'
    'tbsarg' csctable 'namecond(csctname,EQ)' next
    newcrp = 0
    'tbscan' csctable 'position(newcrp)'
    if rc > 0 then do
       if rlhit = 0 then do
          rlhit = 1
          'tbtop' csctable
          'tbvclear' csctable
          csctname = srchcsct'*'
         'tbsarg' csctable 'namecond(csctname,EQ)'
          newcrp = 0
          'tbscan' csctable 'position(newcrp)'
          if rc = 0 then do
             crp = newcrp
             smsg = 'Wrapped'
             lmsg = srchcsct 'found after wrapping the table.'
             'setmsg msg(csct001)'
             end
          else do
               smsg = 'Not found'
               lmsg = srchcsct 'not found.'
               'setmsg msg(csct001)'
               end
          end
       else do
             smsg = 'Not found'
             lmsg = srchcsct 'not found.'
             'setmsg msg(csct001)'
             end
       end
    else do
         crp = newcrp
         smsg = 'Found'
         lmsg = srchcsct 'found in row' crp
         'setmsg msg(csct001)'
         end
    end
  Return

do_it:
/* ------------------------------------------------- *
 * Issue the PDS command and trap the output         *
 * ------------------------------------------------- */
  x = Outtrap("stdout.","*")
  Address TSO
  Select
    When zsel = 'A' then
      pdscmd = "disasm "module csctname
    When zsel = 'D' then do
      call dumpt
      signal skipcmd
      end
    Otherwise
      pdscmd = "list "module "module("csctname")"
  end
  queue pdscmd
  queue "end"
  "pds "pdsdsn" xispmode"
  x= Outtrap("off")

skipcmd:
  Address ISPexec
  if zsel = 'V'
     then cscvopt = 'View'
     else cscvopt = 'Browse'

/* --------------------- *
 | Find the lrecl to use |
 * --------------------- */
  lrecl = 80
  do lx = 1 to stdout.0
    l = length(stdout.lx)
    if l > lrecl then lrecl = l
  end

/* ------------------------ *
 | Now display the CSECTs   |
 * ------------------------ */
  Address TSO
  cscdd = 'zsyn'random(9999)
  'alloc f('cscdd') unit(sysda) space(5,5) tr' ,
    'recfm(v b) lrecl('lrecl+4') blksize(0)'
  'execio * diskw' cscdd '(finis stem stdout.'
  drop stdout.
  Address ISPExec
  "LMINIT DATAID(lmb) DDNAME("cscdd")"
  if load_info /= null then
     'Control Display Save'
  cscvopt 'dataid('lmb')'
  if load_info /= null then
     'Control Display Restore'
  "LMFree  Dataid("lmb")"
  Address TSO 'Free f('cscdd')'
  Address ISPExec
  return

dumpt:
/* ------------------------------------------------- *
 * Execute Superzap DUMPT and display the output     *
 * ------------------------------------------------- */

Address TSO
"newstack"

queue 'DUMPT 'module csctname
queue

"alloc f(sysin) unit(vio) new reuse space(1,1) tracks",
  "lrecl(80) recfm(f)"
"execio * diskw sysin (finis"
"delstack"
"alloc f(sysprint) unit(vio) new reuse space(5,5) tracks",
  "lrecl(121) recfm(f b a) blksize(27951)"
"alloc f(syslib) dsn("pdsdsn") shr reuse"
Address LINKMVS "IGWSPZAP"
"execio * diskr sysprint (stem stdout. finis"

Address TSO
"alloc f(sysprint) da(*) shr reuse"
"alloc f(sysin)    da(*) shr reuse"
"free  f(syslib)"
return

/* --------------------  rexx procedure  -------------------- *
 * Name:      LoadISPF                                        *
 *                                                            *
 * Function:  Load ISPF elements that are inline in the       *
 *            REXX source code.                               *
 *                                                            *
 * Syntax:    rc = loadispf()                                 *
 *                                                            *
 *            The inline ISPF resources are limited to        *
 *            ISPF Messages, Panels, and Skeletons,           *
 *                 CLISTs and EXECs are also supported.       *
 *                                                            *
 *            The inline resources must start in column 1     *
 *            and use the following syntax:                   *
 *                                                            *
 *            >START    used to indicate the start of the     *
 *                      inline data                           *
 *                                                            *
 *            >END    - used to indicate the end of the       *
 *                      inline data                           *
 *                                                            *
 *            Each resource begins with a type record:        *
 *            >type name                                      *
 *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *
 *                     name is the name of the element        *
 *                                                            *
 * Sample usage:                                              *
 *          -* rexx *-                                        *
 *          load_info = loadispf()                            *
 *          ... magic code happens here (your code) ...       *
 *          Address ISPEXEC                                   *
 *          do until length(load_info) = 0                    *
 *             parse value load_info with dd libd load_info   *
 *             if left(libd,6) = "ALTLIB" then do             *
 *                if libd = "ALTLIBC" then lib = "CLIST"      *
 *                                    else lib = "EXEC"       *
 *                Address TSO,                                *
 *                  "Altlib Deact Application("lib")"         *
 *                end                                         *
 *             else "libdef" libd                             *
 *             address tso "free f("dd")"                     *
 *             end                                            *
 *          exit                                              *
 *          >Start inline elements                            *
 *          >Panel panel1                                     *
 *          ...                                               *
 *          >Msg msg1                                         *
 *          ...                                               *
 *          >End of inline elements                           *
 *                                                            *
 * Returns:   the list of ddnames allocated for use along     *
 *            with the libdef's performed or altlib           *
 *                                                            *
 *            format is ddname libdef ddname libdef ...       *
 *                   libdef may be altlibc or altlibe         *
 *                   for altlib clist or altlib exec          *
 *                                                            *
 * Notes:     Entire routine must be included with REXX       *
 *            exec - inline with the code.                    *
 *                                                            *
 * Comments:  The entire rexx program is processed from the   *
 *            last record to the first to find the >START     *
 *            record at which point all records from that     *
 *            point on are processed until the >END           *
 *            statement or the end of the program is found.   *
 *                                                            *
 *            It is *strongly* suggested that the inline      *
 *            elements be at the very end of your code so     *
 *            that the search for them is faster.             *
 *                                                            *
 *            Inline ISPTLIB or ISPLLIB were not supported    *
 *            because the values for these would have to be   *
 *            in hex.                                         *
 *                                                            *
 * Author:    Lionel B. Dyck                                  *
 *                                                            *
 * History:                                                   *
 *            05/10/16 - correction for clist and exec        *
 *            04/19/16 - bug correction                       *
 *            06/04/04 - Enhancements for speed               *
 *            08/05/02 - Creation                             *
 *                                                            *
 * ---------------------------------------------------------- *
 * Disclaimer: There is no warranty, either explicit or       *
 * implied with this code. Use it at your own risk as there   *
 * is no recourse from either the author or his employeer.    *
 * ---------------------------------------------------------- */
 LoadISPF: Procedure

 parse value "" with null kmsg kpanel kskel first returns ,
                     kclist kexec
/* ------------------------------------------------------- *
 * Find the InLine ISPF Elements and load them into a stem *
 * variable.                                               *
 *                                                         *
 * Elements keyword syntax:                                *
 * >START - start of inline data                           *
 * >CLIST name                                             *
 * >EXEC name                                              *
 * >MSG name                                               *
 * >PANEL name                                             *
 * >SKEL name                                              *
 * >END   - end of all inline data (optional if last)      *
 * ------------------------------------------------------- */
 last_line = sourceline()
 do i = last_line to 1 by -1
    line = sourceline(i)
    if translate(left(line,6)) = ">START " then leave
    end
 rec = 0
/* --------------------------------------------------- *
 * Flag types of ISPF resources by testing each record *
 * then add each record to the data. stem variable.    *
 * --------------------------------------------------- */
 do j = i+1 to last_line
    line = sourceline(j)
    if translate(left(line,5)) = ">END "   then leave
    if translate(left(line,7)) = ">CLIST " then kclist = 1
    if translate(left(line,6)) = ">EXEC "  then kexec  = 1
    if translate(left(line,5)) = ">MSG "   then kmsg   = 1
    if translate(left(line,7)) = ">PANEL " then kpanel = 1
    if translate(left(line,6)) = ">SKEL "  then kskel  = 1
    rec  = rec + 1
    data.rec = line
    end

/* ----------------------------------------------------- *
 * Now create the Library and Load the Member(s)         *
 * ----------------------------------------------------- */
 Address ISPExec
/* ----------------------------- *
 * Assign dynamic random ddnames *
 * ----------------------------- */
 clistdd = "lc"random(999)
 execdd  = "le"random(999)
 msgdd   = "lm"random(999)
 paneldd = "lp"random(999)
 skeldd  = "ls"random(999)

/* ---------------------------------------- *
 *  LmInit and LmOpen each resource library *
 * ---------------------------------------- */
 if kclist <> null then do
    call alloc_dd clistdd
    "Lminit dataid(clist) ddname("clistdd")"
    "LmOpen dataid("clist") Option(Output)"
    returns = strip(returns clistdd ALTLIBC)
    end
 if kexec <> null then do
    call alloc_dd execdd
    "Lminit dataid(exec) ddname("execdd")"
    "LmOpen dataid("exec") Option(Output)"
    returns = strip(returns execdd ALTLIBE)
    end
 if kmsg <> null then do
    call alloc_dd msgdd
    "Lminit dataid(msg) ddname("msgdd")"
    "LmOpen dataid("msg") Option(Output)"
    returns = strip(returns msgdd ISPMLIB)
    end
 if kpanel <> null then do
    call alloc_dd paneldd
    "Lminit dataid(panel) ddname("paneldd")"
    "LmOpen dataid("panel") Option(Output)"
    returns = strip(returns paneldd ISPPLIB)
    end
 if kskel <> null then do
    call alloc_dd skeldd
    "Lminit dataid(skel) ddname("skeldd")"
    "LmOpen dataid("skel") Option(Output)"
    returns = strip(returns skeldd ISPSLIB)
    end

/* ----------------------------------------------- *
 * Process all records in the data. stem variable. *
 * ----------------------------------------------- */
 do i = 1 to rec
    record = data.i
    recordu = translate(record)
    if left(recordu,5) = ">END " then leave
    if left(recordu,7) = ">CLIST " then do
       if first = 1 then call add_it
       type = "Clist"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,6) = ">EXEC " then do
       if first = 1 then call add_it
       type = "Exec"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,5) = ">MSG " then do
       if first = 1 then call add_it
       type = "Msg"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,7) = ">PANEL " then do
       if first = 1 then call add_it
       type = "Panel"
       first = 1
       parse value record with x name
       iterate
       end
    if left(recordu,6) = ">SKEL " then do
       if first = 1 then call add_it
       type = "Skel"
       first = 1
       parse value record with x name
       iterate
       end
   /* --------------------------------------------*
    * Put the record into the appropriate library *
    * based on the record type.                   *
    * ------------------------------------------- */
    Select
      When type = "Clist" then
           "LmPut dataid("clist") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(255)"
      When type = "Exec" then
           "LmPut dataid("exec") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(255)"
      When type = "Msg" then
           "LmPut dataid("msg") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      When type = "Panel" then
           "LmPut dataid("panel") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      When type = "Skel" then
           "LmPut dataid("skel") MODE(INVAR)" ,
                 "DataLoc(record) DataLen(80)"
      Otherwise nop
      end
    end
 if type <> null then call add_it
/* ---------------------------------------------------- *
 * Processing completed - now lmfree the allocation and *
 * Libdef the library.                                  *
 * ---------------------------------------------------- */
 if kclist <> null then do
    Address TSO,
    "Altlib Act Application(Clist) File("clistdd")"
    "LmFree dataid("clist")"
    end
 if kexec <> null then do
    Address TSO,
    "Altlib Act Application(Exec) File("execdd")"
    "LmFree dataid("exec")"
    end
 if kmsg <> null then do
    "LmFree dataid("msg")"
    "Libdef ISPMlib Library ID("msgdd") Stack"
    end
 if kpanel <> null then do
    "Libdef ISPPlib Library ID("paneldd") Stack"
    "LmFree dataid("panel")"
    end
 if kskel <> null then do
    "Libdef ISPSlib Library ID("skeldd") Stack"
    "LmFree dataid("skel")"
    end
 return returns

/* --------------------------- *
 * Add the Member using LmmAdd *
 * based upon type of resource *
 * --------------------------- */
 Add_It:
 Select
    When type = "Clist" then
         "LmmAdd dataid("clist") Member("name")"
    When type = "Exec" then
         "LmmAdd dataid("exec") Member("name")"
    When type = "Msg" then
         "LmmAdd dataid("msg") Member("name")"
    When type = "Panel" then
         "LmmAdd dataid("panel") Member("name")"
    When type = "Skel" then
         "LmmAdd dataid("skel") Member("name")"
    Otherwise nop
    end
 type = null
 return

/* ------------------------------ *
 * ALlocate the temp ispf library *
 * ------------------------------ */
 Alloc_DD:
 arg dd
 Address TSO
 if pos(left(dd,2),"lc le") > 0 then
 "Alloc f("dd") unit(sysda) spa(5,5) dir(1)",
    "recfm(v b) lrecl(255) blksize(32760)"
 else
 "Alloc f("dd") unit(sysda) spa(5,5) dir(1)",
    "recfm(f b) lrecl(80) blksize(23440)"
 return
>START
>Panel CSECTS
)Attr Default(%+_)
   ! type( input) intens(high) caps(on ) just(left ) pad('_')
   ¬ type( input) intens(low ) caps(off) just(asis ) pad(' ')
   @ type( input) intens(low ) caps(off) just(right) pad(' ')
   $ type(text) intens(high) hilite(reverse)
   # type(text) intens(high) color(turq)
)Body  Expand(\\) Width(&zscreenw)
%-\-\ $CSECT Display for load module%\-\-
%Command ===>_zcmd                                 \ \%Scroll ===>_amt +
%
+Primary Commands:  %Locate+Csect   %RL+Repeat Locate
+Line Commands:     %S+- LIST Csect  %A+- DISASM Csect  %D+- DUMPT Csect
+
%Module:# &module
%     Control Section      Date       Translator  Version
)Model
!z+  ¬z                   ¬z
)Init
  .ZVARS = '(zsel csctname csctdesc)'
  if (&amt = &z)
      &amt = csr
  .cursor = zcmd
  .help = csectsh
)Proc
if (&zsel = _)
    &zsel = &z
ver (&zsel,list,S,V,A,D,'=')
if (&ztdsels = 0000)
   &row = .csrrow
   if (&row ¬= 0)
       if (&zsel = &z)
           &zsel = 'S'
if (&ztdsels ¬= 0000)
    &row = 0
if (&zsel ¬= &z)
   if (&zsel = '=')
       &zsel = &osel
&osel = &zsel
)End
>Panel csectsh
)ATTR DEFAULT(%+_)
   %   TYPE(TEXT)  INTENS(HIGH) SKIP(ON)
   +   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(TURQ)
   !   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(RED)
   @   TYPE(TEXT)  INTENS(HIGH) SKIP(ON) HILITE(USCORE) COLOR(BLUE)
   _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) HILITE(USCORE)
)BODY EXPAND(\\)
%Tutorial+\-\(%CSECT Display+)\-\%Tutorial
%Command ===>_ZCMD
+
+This table displays the CSECT structure of a load module.
+
+Primary Commands:
  %  Locate csect next+Locate the requested CSECT in the table
  %  RL               +Repeat Locate
  %  S Csect          +Select the CSECT
+
+Line Commands:
%    S+               +Select a CSECT to be displayed with PDS LIST
%    A+               +Select a CSECT to be disassembled with PDS DISASM
%    D+               +Select a CSECT to be dumped with SPZAP DUMPT
+
+Note:  The LIST output can be disassembled with the Arthur Fichtl
+       REXX Interactive Short DisAssembler, ISDA on CBT File 773.
+
+       Assign a PF key as follows:  PF13  . . tso isda
+       Initial setup:
+         Enter the start column and number of lines:  16 5%<PF13>+
+       To disassemble:
+         Position cursor on instruction and press%<PF13>+
)PROC
 &zcont = csectsh
)End
>msg csct00
CSCT001 '&SMSG'
'&LMSG'
>END
