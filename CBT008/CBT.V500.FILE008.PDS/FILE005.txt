:READ CBTTAPE EXEC
/* **************************************************************** */
/* *     Module Name: CBTTAPE EXEC                                * */
/* *                                                              * */
/* *     Author:        George Shedlock Jr.                       * */
/* *                    george@shedlock.org                       * */
/* *                                                              * */
/* *                                                              * */
/* *     Version:       1.1 (I don't like version 1.0 since it    * */
/* *                    implies a lot of bugs are still in there  * */
/* *                    waiting to be discovered.)                * */
/* *                                                              * */
/* *     Purpose:       This REXX EXEC was written because I made * */
/* *                    the mistake of telling Sam Golub that it  * */
/* *                    wouldn't be hard to write something like  * */
/* *                    this since I had most of the pieces and   * */
/* *                    just had to put them together. Well, here * */
/* *                    it is... 3 years, 1100 miles (I moved     * */
/* *                    from New Jersey), and a lot of deserved   * */
/* *                    nagging from Sam. If this is of some      * */
/* *                    value to you, great. If this is of NO     * */
/* *                    value to you, you're welcome to write     * */
/* *                    you're welcome to write something of      * */
/* *                    your own. Feel free to modify this to     * */
/* *                    modify this to suit your needs. If you    * */
/* *                    modify this, please send me a copy so     * */
/* *                    that it can be shared with others.        * */
/* *                                                              * */
/* *                    This EXEC will allow the VM site a way    * */
/* *                    to process the CBT tape in the native     * */
/* *                    VM environment. This is mainly because    * */
/* *                    there are a lot of really good programs,  * */
/* *                    macros, etc on this tape. Well, OK        * */
/* *                    there are some so-so programs also, but   * */
/* *                    most of it is good. Included in this      * */
/* *                    file is a program I found in my travels   * */
/* *                    on the Internet some years ago. If I      * */
/* *                    could remember who wrote it or where I    * */
/* *                    found it, I would gladly give the proper  * */
/* *                    credit. This program is the IEBCOPY       * */
/* *                    program. Although it will only load or    * */
/* *                    list the modules from the tape, it is     * */
/* *                    still a good little utility.              * */
/* *                                                              * */
/* *     Initial setup:                                           * */
/* *         SP PUN * CL K                                        * */
/* *         TAPE REW                                             * */
/* *         TAPE FSF 4                                           * */
/* *         FI INMOVE TAP1 (RECFM FB LRECL 80 BLOCK 80           * */
/* *         FI OUTFILE PUNCH (RECFM FB LRECL 80 BLOCK 80         * */
/* *         MOVEFILE                                             * */
/* *         CL PUN                                               * */
/* *         SP RDR CL K                                          * */
/* *         READCARD * *                                         * */
/* *         CBTTAPE 402 SETUP A 3390                             * */
/* *                                                              * */
/* *         NOTE: It is assumed that the CBT tape is mounted     * */
/* *               on your 181                                    * */
/* *               In the CBTTAPE command, the 402 is the CBT     * */
/* *               version, SETUP tells it to load the            * */
/* *               appropriate files from the CBT tape, assemble  * */
/* *               them and generate load modules. In addition    * */
/* *               SETUP will also create an index of the CBT     * */
/* *               tape so that future retrievals will be easier. * */
/* *                                                              * */
/* *     On-going usage:                                          * */
/* *            CBTTAPE 402 fileno target disktype                * */
/* *         NOTE: It is assumed that the CBT tape is mounted     * */
/* *               on your 181. The 402 is again the CBT version, * */
/* *               fileno is the file number you want to load,    * */
/* *               target is the filemode of the disk that will   * */
/* *               receive the extracted modules, and disktype    * */
/* *               is the device type to use for some t-disk      * */
/* *               (sometimes we need a little work space)        * */
/* *         Example:                                             * */
/* *               CBTTAPE 402 122 R 3390                         * */
/* *                    This will get, if we need it, 5 cylinders * */
/* *                    of t-disk on a 3390, and load file 122    * */
/* *                    from CBT version 402 to the R minidisk.   * */
/* *                                                              * */
/* *     Required files:                                          * */
/* *         CBTTAPE EXEC        (This file)                      * */
/* *         CBT973   ASSEMBLE  (From file 002 of the CBT tape)   * */
/* *         IEBCOPY  ASSEMBLE  (From elsewhere in this file)     * */
/* *         IEBCOPY  HELP        (From elsewhere in this file)   * */
/* **************************************************************** */

address command
arg CbtVersion File_No Target_Disk DiskType

/* *********************************** */
/* * Set up some initial variables   * */
/* *********************************** */

If Target_Disk = '' Then Do
    Target_Disk = 'A'
    End

If DiskType = '' Then Do
    DiskType = '3390'
    End

Maxfiles = 500
Spaces = '                    '                         /* 20 spaces */

If CbtVersion = '' Then Do
    Say 'CBT Version not entered'
    Say 'Re-enter with correct version'
    Exit 99
    End   /*  If CbtVersion  */

CBT = 'CBT' || CBTVersion
CBTF1 = CBT || ' FILE001 *'
CBTF3 = CBT || ' FILE003 *'

'STATE ' CBT 'INDEX *'
If RC <> 0 Then Do
    Say 'Building ' CBT ' INDEX'
    Call Obtain_Temp_Disk
    Call Load_File_One
    Call Condense_File_One
    Call Load_File_Three
    Call Process_File_Three
    Call Release_Temp_Disk
    Say 'Build of ' CBT ' INDEX is complete'
    End   /* If RC   */

'SET CMSTYPE HT'
'STATE CBT973 MODULE *'
'SET CMSTYPE RT'
If RC <> 0 Then Do
    Call Obtain_Temp_Disk
    Call Load_File_Two
    Call Generate_Cbt973
    Call Release_Temp_Disk
    End   /* If RC   */

'SET CMSTYPE HT'
'STATE IEBCOPY MODULE *'
'SET CMSTYPE RT'
If RC <> 0 Then do
    CALL GENERATE_IEBCOPY
    End   /*  If RC */

'SET CMSTYPE HT'
'STATE IEBUPDTE MODULE *'
'SET CMSTYPE RT'
If RC <> 0 Then do
    CALL GENERATE_IEBUPDTE
    End   /*  If RC */

If File_No = 'SETUP' Then Do
    Say 'Setup completed'
    Exit 0
    End   /*  If File_No  */
Address CMS 'EXECIO * DISKR' CBT 'INDEX * (ZONE 1 3 FIND /' || File_No || '/ '
Parse upper PULL junk
Parse upper PULL Line
Parse upper VAR Line 55 BKI 60 BKO 65 .
Parse upper VAR Line 1 FileNo 4 Desc 24 Last_Upd 32 P1 40 P2 48 LR 51 fm 55 .

If File_No <> FileNo Then Do
    Say 'Requested file number (' File_No ') not found'
    Exit 98
    End                                           /* If File_No ... */

Say 'File ' File_No ' is in ' P1 ' format'

Call Position_File

If P1 = 'IEBCOPY' Then Do     /* This is the COPY PROC simulation   */
    'SET CMSTYPE HT'
    'FILEDEF TAPE TAP1 SL VOLID' Cbt
    'IEBCOPY LOAD FMODE ' Target_Disk
    SaveRc = RC
    'SET CMSTYPE RT'
    End  /*  If P1 ...  */

If P1 = 'CBT973' Then Do     /* This is the UPDATEO PROC simulation */
    Call Obtain_Temp_Disk
    'FILEDEF INMOVE TAP1 (RECFM VB BLOCK ' BKI
    File_Num = 'FILE' || File_No
    'FILEDEF OUTMOVE DISK' CBT File_Num Fm1 ' (RECFM VB BLOCK' BKI
    'MOVEFILE'
    SaveRc1 = RC
    'FILEDEF INPUT DISK' CBT File_Num Fm1 ' (RECFM VB BLOCK' BKI
    'FILEDEF OUTPUT DISK' CBT File_Num Target_Disk '(RECFM FB BLOCK 80'
    'CBT973'
    SaveRc = RC
    If SaveRc1 ¬= 0 Then Do
        SaveRc = SaveRc1
        End
    'SET CMSTYPE RT'
    End  /*  If P1 ...  */

If P1 = 'IEBGENER' Then Do    /* This is the GENERO PROC simulation */
    'FILEDEF INMOVE TAP1 (RECFM' LR 'BLOCK ' BKI 'RECFM' FM
    File_Num = 'FILE' || File_No
    'FILEDEF OUTMOVE DISK' CBT File_Num Target_Disk ' (RECFM FB BLOCK 80'
    'MOVEFILE'
    SaveRc = RC
    End  /*  If P1 ...  */

If SaveRc = 0 Then Do
    Say 'File ' File_No ' has been successfully loaded to ' Target_Disk
    Exit 0
    End  /*  If SaveRc ...  */
Say 'File ' File_No ' has not been loaded '
Exit SaveRc

Position_File:
    Say 'Positioning to file ' FileNo
    'SET CMSTYPE HT'
    'TAPE REW'                  /*  Reset so we know where we are */
    Skip_Files = FileNo - 1
    If Skip_Files = 0
        Then return
    'TAPE FSF ' Skip_Files
    'SET CMSTYPE RT'
    Return

Condense_File_One:
    Address CMS 'EXECIO * DISKR' CBTF1 '(LO /'DO NOT REMOVE'/ FIFO'
    Parse Upper Pull junk
    Parse Upper Pull junk
    Do Forever
        Address CMS 'EXECIO 1 DISKR' CBTF1 '(VAR LINE'
        Parse upper VAR Line 1 . 5 Desc 22 FileNo 25 . 46 Last_upd 54 .
        FileNo = Strip(FileNo)
        If FileNo = '' Then Return
        File_Desc.FileNo  = Desc
        File_FileNo.FileNo = FileNo
        File_Last_Upd.FileNo = Last_Upd
        End   /*  Do Forever    */
    'ERASE' CBT 'FILE001' Fm1
    Return

Generate_Iebcopy:
    'SET CMSTYPE HT'
    'ASSEMBLE IEBCOPY'
    'LOAD IEBCOPY'
    'GENMOD IEBCOPY'
    'COPY IEBCOPY MODULE' Fm1 ' = = 'Target_Disk
    'SET CMSTYPE RT'
    Return

Generate_Iebupdte:
    'SET CMSTYPE HT'
    'ASSEMBLE IEBUPDTE'
    'LOAD IEBUPDTE'
    'GENMOD IEBUPDTE'
    'COPY IEBUPDTE MODULE ' Fm1 ' = = 'Target_Disk
    'SET CMSTYPE RT'
    Return

Generate_Cbt973:
    'SET CMSTYPE HT'
    'ASSEMBLE CBT973'
    'LOAD CBT973'
    'GENMOD CBT973'
    'COPY CBT973 MODULE' Fm1 ' = =' Target_Disk
    'SET CMSTYPE RT'
    Return


Obtain_Temp_Disk:
    'SET CMSTYPE HT'
    'GETFMADR'
    Parse pull . Fm1 Vaddr1 .
    ADDRESS CMS 'DEFINE T' || Disktype Vaddr1 '5'
    queue 'yes'
    queue 'TMP' || Right(Vaddr1,3,'0')
    'FORMAT' Vaddr1 Fm1
    'SET CMSTYPE RT'
    Return

Release_Temp_Disk:
    'SET CMSTYPE HT'
    'RELEASE' Fm1 '(det'
    'SET CMSTYPE RT'
    Return

Load_File_One:
    Say 'Positioning to first file'
    'SET CMSTYPE HT'
    'TAPE REW'
    'FILEDEF INPUT TAP1 (LRECL 80 BLOCK 32720 RECFM FB'
    'FILEDEF OUTPUT DISK' CBT 'FILE001' Fm1 '(LRECL 80 BLOCK 80 RECFM FB'
    'MOVEFILE INPUT OUTPUT'
    'SET CMSTYPE RT'
    Return

Load_File_Two:
    Say 'Positioning to second file'
    'SET CMSTYPE HT'
    'TAPE REW'              /*  Reset so we know where we are   */
    'TAPE FSF 1'            /*  skip first file                 */
    'FILEDEF INPUT TAP1 (LRECL 80 BLOCK 32720 RECFM FB'
    'FILED OUTPUT DISK CBT973 ASSEMBLE' FM1 '(LRECL 80 BLOCK 80 RECFM FB'
    'MOVEFILE INPUT OUTPUT'
    'SET CMSTYPE RT'
    Return

Load_File_Three:
    Say 'Positioning to third file'
    'SET CMSTYPE HT'
    'TAPE REW'              /*  Reset so we know where we are   */
    'TAPE FSF 2'            /*  skip first two files            */
    'FILEDEF INPUT TAP1 (LRECL 80 BLOCK 32720 RECFM FB'
    'FILEDEF OUTPUT DISK' CBT 'FILE003' FM1 '(LRECL 80 BLOCK 80 RECFM FB'
    'MOVEFILE INPUT OUTPUT'
    'SET CMSTYPE RT'
    Return

Process_File_Three:
    i = 0
    Detail.0 = 0
    Scale1 = '0  0                   2       3       4       4  5   5    6    6'
    'EXECIO 1 DISKW' CBT 'INDEX ' Target_Disk '( STR' Scale1
    Scale2 = '1  4                   4       2       0       8  1   5    0    5'
    'EXECIO 1 DISKW' CBT 'INDEX ' Target_Disk '( STR' Scale2
    Do Forever
        Address CMS 'EXECIO 1 DISKR' CBTF3 '(VAR LINE'
        If Rc ¬= 0 Then Do
            Signal Process_File_Three_B
            End
        If substr(Line,3,7) = 'STEPLIB' Then Do
            Iterate
            End
        If substr(Line,3,4) ¬= 'STEP' Then Do
            Iterate
            End
        i = i + 1
        Detail.i = line
        Detail.0 = Detail.0 + 1
        End
Process_File_Three_B:
    Do j = 1 to Detail.0
        Parse Upper VAR Detail.j junk 'EXEC' Proc_Name ',LAB=' Rest
        FileNo = Left(Rest,3)
        Proc_Name = Strip(Proc_Name)
        Select;
            When Proc_Name = 'COPY' Then Do
                P1 = 'IEBCOPY'
                P2 = ' '
                BKO = 0
                Call Save_Entry
                Iterate
                End    /* When Proc_Name = 'COPY'       */
            When Proc_Name = 'GENER' Then Do
                LR = 80
                BKI = 32716
                BKO = 0
                FM = FB
                P1 = 'IEBGENER'
                P2 = P1
                Call Process_Overrides
                Call Save_Entry
                Iterate
                End    /* When Proc_Name = 'GENER'      */
            When Proc_Name = 'GENERO' Then Do
                LR = 80
                BKI = 32720
                BKO = 0
                FM = FB
                P1 = 'IEBGENER'
                P2 = P1
                Call Process_Overrides
                Call Save_Entry
                Iterate
                End    /* When Proc_Name = 'GENERO'     */
            When Proc_Name = 'UPDATEO' Then Do
                LR = 80
                BKI = 32720
                BKO = 0
                FM = FB
                P1 = 'CBT973'
                P2 = 'PDSLOAD'
                Call Process_Overrides
                Call Save_Entry
                Iterate
                End    /* When Proc_Name = 'UPDATEO'    */
            Otherwise Do
                Iterate
                End    /* Otherwise Do                  */
            Parse Pull junk
        End            /* SELECT                        */
    End                /* DO                            */
    Return

Process_Overrides:
    Parse VALUE Rest WITH . 'FM=' RecFm ',' .
    Parse VALUE Rest WITH . 'LR=' LrecL ',' .
    Parse VALUE Rest WITH . 'BKI=' BlkSizeI ',' .
    Parse VALUE Rest WITH . 'BKO=' BlkSizeO ' ' .
    If LrecL <> '' Then LR = LrecL
    If RecFm <> '' Then FM = RecFm
    If BlkSizeI <> '' Then BKI = BlkSizeI
    If BlkSizeO <> '' Then BKO = BlkSizeO
    Return

Save_Entry:
    FileNo    = RIGHT(FileNo,3,'0')
    Desc      = LEFT(File_Desc.FileNo,20)
    Last_Upd  = LEFT(File_Last_Upd.FileNo,8)
    P1        = LEFT(P1,8)
    P2        = LEFT(P2,8)
    LR        = RIGHT(LR,3,'0')
    FM        = LEFT(FM,4)
    BKI       = RIGHT(BKI,5,'0')
    BKO       = RIGHT(BKO,5,'0')

    Entry = FileNo || Desc || Last_Upd || P1 || P2 || LR || FM
    Entry = Entry || BKI || BKO
    Entry = LEFT(Entry,80)
    'EXECIO 1 DISKW' CBT 'INDEX ' Target_Disk '( STR' Entry
    Return
:READ IEBCOPY ASSEMBLE
IEBCOPY  TITLE 'I E B C O P Y  -  LOAD A PDS DUMPED USING IEBCOPY'
* THIS UTILITY LOADS AND LISTS ANY MEMBER(S) OF DATA SET UNLOADED
* USING THE IEBCOPY UTILITY. YOU CAN:
* SELECT ANY MEMBER(S) TO BE LOADED
* LIST THE DIRECTORY OF THE FILE, WITH THE EXTRA INFORMATION IN HEX
         SPACE ,
* THE COMMAND IS IEBCOPY. THE FIRST OPTION MUST BE EITHER
*        LIST            LIST THE DIRECTORY OF THIS DATA SET
*        LOAD            LOAD THE FILE, EITHER USING THE SELECTED LIST
*                        OF MEMBERS, OR THE ENTIRE DATA SET.
         SPACE ,
* WITH EITHER OF THESE OPTIONS, THE FOLLOWING OPTIONS CAN ALSO BE
* SPECIFIED:
*        FTYPE/FILETYPE  WHEN LOADING A FILE, THE FILE TYPE.
*                        THE DEFAULT IS 'IEBCOPY'.
*        FMODE/FILEMODE  WHEN LOADING A FILE, THE FILE MODE.
*                        THE DEFAULT IS 'A2'.
*        FROM            FROM WHAT MEMBER THE LOAD/LIST IS TO START
*        TO/THRU/THROUGH TO WHAT MEMBER THE LOAD/LIST IS TO END
*        MEMBER          WHICH MEMBER IS TO BE LOADED/LISTED
         SPACE ,
* N.B.             (1)   BY DEFAULT, ALL MEMBERS ARE LOADED/LISTED.
*                  (2)   EOF ON TAPE IS NEVER REACHED, THIS WILL ABEND
*                        BECAUSE EODAD IS NOT CODED IN THE DCB.
*                  (3)   NOTE LISTS ARE DISCARDED AND NO MESSAGES ARE
*                        ISSUED. LOAD MODULES ARE RELOADED CORRECTLY;
*                        ONLY THE DATA PORTION IS RELOADED.
         SPACE ,
* SEE OS/VS UTILITIES LOGIC MANUAL FOR FURTHER INFORMATION:
* SY35-0005
         TITLE 'LOCAL MACROS'
         MACRO ,
&LABEL   OPT   &NAME,&ADDR
&LABEL   DC    CL8'&NAME',A(&ADDR)
         MEND  ,
         TITLE 'DSECTS AND EQUATES'
* THE UNLOADED FILE IS IN VB FORMAT, REGARDLESS OF THE INDICATORS
* ON THE TAPE. USE VB/32756/32760 TO OPEN THE TAPE.
* THE USER MUST SUPPLY THE CONTROL STATEMENTS.
         SPACE 3
COPYR1   DSECT ,             RECORD 1 LAYOUT
R1LEN    DS    H             LENGTH
         DS    H             RESERVED
R1INDC   DS    X             INDICATOR, X'00'=OK, X'80'=ERROR
R1ID     DS    XL3           IEBCOPY IDENTIFIER = X'CA6D0F'
R1DSORG  DS    XL2           DSORG
R1BLKSI  DS    XL2           BLKSIZE
R1LRECL  DS    XL2           LRECL
R1RECFM  DS    X             RECFM
R1KEYLEN DS    X             KEYLEN
R1OPTCD  DS    X             OPTCD
         DS    X             *** RESERVED ***
R1TBLKSI DS    XL2           BLKSIZE OF TAPE FILE
R1DEVTYP DS    XL20          DEVICE TYPE INFORMATION
R1TRKCYL EQU   R1DEVTYP+10,2,C'H'
LCOPYR1  EQU   *-COPYR1      LENGTH OF RECORD
         SPACE ,
R1IDEQ   EQU   X'CA6D0F'     IDENTIFIES IEBCOPY UNLOADED FILE
         SPACE 3
COPYR2   DSECT ,             RECORD 2 LAYOUT
R2LEN    DS    H             LENGTH OF RECORD
         DS    H             *** RESERVED ***
R2DEB    DS    XL16          LAST 16 BYTES OF BASIC DEB
R2DEBX   DS    16XL16        DASD DEB EXTENSION
         DS    XL4           *** RESERVED ***
LCOPYR2  EQU   *-COPYR2      LENGTH OF RECORD
         SPACE 3
COPYR3   DSECT ,             RECORD 3-N LAYOUT
R3F      DS    X             RECORD TYPE INDICATOR
R3FSTD   EQU   B'00000000'             NORMAL RECORD
R3FNOTE  EQU   B'11100000'             NOTE RECORD, JUST BEFORE MEMBER
R3M      DS    X             EXTENT
R3BB     DS    XL2           BIN
R3CC     DS    XL2           CYLINDER
R3HH     DS    XL2           TRACK
R3R      DS    X             RECORD
R3K      DS    X             KEY LENGTH
R3DL     DS    XL2           DATA LENGTH
LCOPYR3  EQU   *-COPYR3
         SPACE ,
DEBXTENT DSECT ,             FORMAT OF DEB EXTENT
DEBDVMOD DS    X             FILE MASK
DEBUCBA  DS    AL3           UCB ADDRESS
DEBINUM  DS    H             BIN NUMBER
DEBSTRCC DS    H             CYLINDER ADDRESS FOR START OF EXTENT
DEBSTRHH DS    H             TRACK ADDRESS FOR START OF EXTENT
DEBENDCC DS    H             CYLINDER ADDRESS FOR END OF EXTENT
DEBENDHH DS    H             TRACK ADDRESS FOR END OF EXTENT
DEBNMTRK DS    H             NO. OF TRACKS ALLOCATED TO THIS EXTENT
LDEBXNT  EQU   *-DEBXTENT
         SPACE ,
PDSREC   DSECT ,             FORMAT OF ENTRY IN DIRECTORY
PDSNAME  DS    CL8           MEMBER NAME
PDSADDR  DS    XL3           TTR OF MEMBER
PDSFLAGS DS    X             SPECIAL INDICATORS
PDSALIAS EQU   X'80'         INDICATES AN ALIAS
PDSNOTE  EQU   B'01100000'   NUMBER OF NOTE LISTS
PDSUSER  EQU   B'00011111'   NUMBER OF USER HALFWORDS IN ENTRY
LPDSREC  EQU   *-PDSREC
         EJECT ,
         DCBD  DEVD=DA,DSORG=PS
         TITLE 'MAIN PROGRAM'
IEBCOPY  START ,
         SPACE ,
         PRINT NOGEN
         SPACE ,
R0       EQU   0             REGISTER EQUATES
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE ,
         SAVE  (14,12),T,*   STOW REGS
         LR    R12,R15       ESTABLISH ADDRESABILITY
         LA    R11,2048(,R12)
         LA    R11,2048(,R11)
         USING IEBCOPY,R12,R11
         SPACE ,
         LA    R15,SAVEAREA
         ST    R15,8(,R13)
         ST    R13,4(,R15)
         LR    R13,R15
         SPACE ,
         XC    TOZERO,TOZERO MAKE SERIALLY REUSABLE
         MVC   TO,GATE
         MVC   FILETYPE(10),=CL10'IEBCOPY A2'
         SPACE ,
         LA    R2,8(,R1)     VALIDATE OPTION(S)
         CLC   =CL8'LOAD',0(R2)
         BE    SETLOAD
         CLC   =CL8'LIST',0(R2)
         BE    SETLIST
         WRTERM 'INVALID OR MISSING FUNCTION, NOT ''LIST'' OR ''LOAD'''
         MVC   RETCODE,=F'8'
         B     ENDFILE
         SPACE ,
SETLOAD  MVI   FLAG,LOAD
         B     CHECKOPT
SETLIST  MVI   FLAG,LIST
         B     CHECKOPT
         SPACE ,
CHECKOPT LA    R2,8(,R2)           SCAN NEXT OPTIONS
         CLI   0(R2),X'FF'         END OF PARAMETERS ?
         BE    EXECUTE             YES, FINIS
         LM    R3,R4,=A(OPTIONS,NOPTIONS)
TESTOPT  CLC   0(8,R3),0(R2)       SEE IF WE CAN FIND THE OPTION
         BE    EXECOPT
         LA    R3,12(,R3)          PUSH TO NEXT OPTION
         BCT   R4,TESTOPT          LOOP UNTIL DONE
         SPACE ,
         LINEDIT TEXT='INVALID OPTION - ........',SUB=(CHARA,(R2))
         MVC   RETCODE,=F'8'
         B     ENDFILE
         SPACE ,
BADPARM  WRTERM 'MISSING PARAMETER FOR LAST OPTION'
         MVC   RETCODE,=F'8'
         B     ENDFILE
         SPACE ,
EXECOPT  L     R3,8(,R3)           POINT TO OPTION ROUTINE
         LA    R2,8(,R2)           PUSH TO PARAMETER
         CLI   0(R2),X'FF'         MAKE SURE THERE IS ONE
         BE    BADPARM             IF NOT, ERROR
         EX    0,0(,R3)            PERFORM THE ROUTINE
         B     CHECKOPT            CHECK THE NEXT OPTION
         TITLE 'SCAN DIRECTORY, RETRIEVE REQUIRED INFORMATION'
EXECUTE  DS    0H                  ACTUALLY PERFORM THE FUNCTION
*
* PHASE 1  -  OPEN THE UNLOADED DATA SET
*
         OPEN  (TAPE,INPUT)        OPEN THE INPUT FILE
         TM    TAPE+DCBOFLGS-IHADCB,X'10'
         BZ    NOTOPEN             MUST OPEN INPUT DATA SET
         OI    FLAGS,OPENTAPE      SIGNAL TAPE DATA SET OPENED
         SPACE ,
*
* PHASE 2  -  VERIFY RECORD 1
*
         GET   TAPE                GET THE 1ST RECORD
         USING COPYR1,R1           ADDRESS THE 1ST RECORD
         CLC   R1LEN,=Y(LCOPYR1)   VERIFY LENGTH
         BL    BADTAPE             EVERYTHING MUST FIT
         CLC   R1ID,=AL3(R1IDEQ)
         BNE   BADTAPE             OK . . . .
         SPACE ,
         LH    R0,R1TRKCYL
         ST    R0,TRKCYL
         LA    R2,DISK
         USING IHADCB,R2           COPY THE REQUIRED FIELDS
         MVC   DCBLRECL,R1LRECL
         MVC   BLKSIZE,R1BLKSI
         MVC   DCBOPTCD,R1OPTCD
         MVC   DCBRECFM,R1RECFM
         CLI   R1KEYLEN,0
         BE    OKEY
         WRTERM 'WARNING: DATA SET KEY LENGTH NOT ZERO, KEY IGNORED'
OKEY     DS    0H
         DROP  R2,R1
         SPACE ,
*
* PHASE 3  -  VERIFY RECORD 2
*
         SPACE ,
         GET   TAPE
         USING COPYR2,R1           ADDRESS RECORD 2
         CLC   =Y(LCOPYR2),R2LEN
         BNE   BADTAPE             MAKE SURE WE HAVE ALL WE NEED
         MVC   DEB(16),R2DEB       AND COPY DEB BASIC SECTION
         MVC   EXTENTS(16*16),R2DEBX   AND EXTENTS
         DROP  R1
         SPACE ,
*
* PHASE 4  -  PREAMBLE TO DIRECTORY SCAN
*
         SPACE ,
         GETMAIN VU,LA=AREALEN,A=AREA   GET THE BUFFER
         LM    R1,R2,AREA          GET ADDRESS AND LENGTH
         AR    R2,R1               POINT TO END OF GETMAINED AREA
         STM   R1,R2,POINTER       UPDATE POINTER/END
         LA    R9,SHOWLIST         POINT TO DEFAULT ROUTINE
         TM    FLAG,LOAD
         BNO   NOTLOAD1
         LA    R9,SHOWLOAD
NOTLOAD1 DS    0H
         SPACE ,
*
* PHASE 5  -  SCAN DIRECTORY
*
         SPACE ,
NEXTPDS  BAL   R10,GETREC          GET A DIRECTORY BLOCK
         LR    R2,R1
         USING COPYR3,R2
         CLI   R3F,R3FSTD          MAKE SURE RECORD IS VALID
         BNE   BADTAPE
         CLC   R3K(3),=AL1(8,1,0)  VERIFY KDD
         BNE   BADTAPE
         DROP  R2
         LA    R3,LCOPYR3(,R2)     POINT PAST RECORD PREFIX
         LA    R2,10(,R3)          POINT PAST KEY + LENGTH INDICATOR
         USING PDSREC,R2           ADDRESS THE RECORD
SHOWNAME CLC   PDSNAME,=8X'FF'     LAST POSSIBLE ENTRY ?
         BE    WHATNOW             YES, FINISHED SCANNING DIRECTORY
         CLC   PDSNAME,FROM
         BL    NEXTNAME
         CLC   PDSNAME,TO
         BH    NEXTNAME
         BALR  R10,R9              PERFORM THE ROUTINE
         SPACE ,
NEXTNAME DS    0H
         CLC   PDSNAME,0(R3)       IS THIS THE LAST NAME ?
         BE    NEXTPDS             YES, READ THE NEXT RECORD
         IC    R1,PDSFLAGS
         N     R1,=A(PDSUSER)      NUMBER OF USER HALFWORDS
         AR    R1,R1               NUMBER OF BYTES
         LA    R2,LPDSREC(R2,R1)   POINT TO NEXT ELEMENT
         B     SHOWNAME            AND DISPLAY IT
         SPACE ,
         DROP  R2
         EJECT ,
*
* PHASE 6  -  FREE UNUSED AREA OBTAINED USING GETMAIN
*
         SPACE ,
WHATNOW  DS    0H
         LM    R1,R2,POINTER       FREE END OF GETMAINED AREA
         SR    R2,R1               DETERMINE LENGTH
         LR    R0,R2               PREPARE FOR FREEMAIN
         FREEMAIN R,A=(1),LV=(0)   FREE UNUSED AREA
         SPACE ,
*
* PHASE 7  -  TERMINATE IF LIST FUNCTION
*
         SPACE ,
         TM    FLAG,LIST
         BO    ENDFILE             IF LIST FUNCTION, WE HAVE FINISHED
         SPACE ,
*
* PHASE 8  -  GO TO THE END OF THE DIRECTORY
*
         SPACE ,
NEXTREC2 BAL   R10,GETREC          GET THE NEXT RECORD
         USING COPYR3,R1           ADDRESS THE RECORD
         CLI   R3F,R3FSTD
         BNE   BADTAPE
         CLC   R3DL,=AL2(0)
         BNE   NEXTREC2            UNTIL END OF DIRECTORY
         SPACE ,
*
* PHASE 9  -  SORT THE DIRECTORY BY ADDRESS
*
         SPACE ,
         L     R2,POINTER          GET END OF TABLE
         S     R2,AREA                 LENGTH
         SRL   R2,4                GET NUMBER OF ENTRIES
         LR    R4,R2               REMEMBER FOR LATER USE
         C     R2,=F'1'            HOW MANY
         BL    NOMEMBER            NONE, FINISHED !
         BE    NOSORT              1, ALREADY SORTED
         SPACE ,
SORT     BCTR  R2,0                DECREMENT, ONLY NEED N-1 COMPARES
         OI    FLAG,SORTED         SIGNAL FILE IS SORTED
         L     R3,AREA             POINT TO START OF AREA
COMPARE  CLC   0(8,R3),16(R3)      IS THIS IN ORDER ?
         BNH   NOSWITCH            NO, FLIP
         NI    FLAG,255-SORTED     NO LONGER SORTED
         XC    0(16,R3),16(R3)     SWAP ELEMENTS
         XC    16(16,R3),0(R3)
         XC    0(16,R3),16(R3)
NOSWITCH LA    R3,16(,R3)          POINT TO NEXT ELEMENT
         BCT   R2,COMPARE          LOOP UNTIL DONE
         TM    FLAG,SORTED         SEE IF SORTED
         BO    NOSORT              YES, OK
         LR    R2,R4               COPY NUMBER OF ELEMENTS
         B     SORT                AND DO IT AGAIN
         SPACE ,
NOSORT   DS    0H                  SORT FINISHED
         SPACE ,
*
* PHASE 10  -  SCAN THROUGH TAPE, PICK OFF AND LOAD REQUIRED FILES
*
         SPACE ,
         L     R3,AREA             POINT TO START OF LIST
PHASE10A BAL   R10,GETREC          GET A RECORD
         USING COPYR3,R1           ADDRESS THE RECORD
         CLI   R3F,R3FSTD          NOTE ENTRY?
         BNE   PHASE10A                YES, IGNORE RECORD
         CLC   0(8,R3),R3M         IS THIS THE RIGHT ADDRESS ?
         BE    LOADFILE            YES, LOAD THE FILE
         BH    PHASE10A            LOW, OK
         WRTERM 'ERROR: MISSING RECORD FROM TAPE FILE'
         MVC   RETCODE,=F'16'
         B     ENDFILE
         DROP  R1
         SPACE ,
LOADFILE LR    R2,R1               COPY THE ADDRESS OF THE RECORD
         MVC   FILENAME,8(R3)      SET FILE NAME
         TR    FILENAME(18),BADCHARS
         LA    R1,FILEDEF
         SVC   202                 ISSUE FILEDEF COMMAND
         DC    AL4(BADDISK)
         MVC   DISK+DCBBLKSI-IHADCB(2),BLKSIZE
         OPEN  (DISK,OUTPUT)       OPEN THE FILE
         OI    FLAGS,OPENDISK      SIGNAL THAT DISK WAS OPENED
         SPACE ,
         USING COPYR3,R2           ADDRESS RECORD
PUT      CLC   =H'0',R3DL          IS THE DATA LENGTH = 0
         BE    NEXTFILE            YES, END OF FILE
         SR    R15,R15
         IC    R15,R3K             GET THE KEY LENGTH
         LA    R6,LCOPYR3(R2,R15)  POINT TO DATA AREA
         SR    R5,R5
         ICM   R5,3,R3DL           GET THE LENGTH
         MVC   DISK+DCBBLKSI-IHADCB(2),R3DL
         WRITE DECB,SF,DISK,(R6),(R5)  WRITE THE RECORD
         CHECK DECB                MAKE SURE IT COMPLETED CORRECTLY
SKIPREC  BAL   R10,GETREC          GET THE NEXT RECORD
         LR    R2,R1               COPY THE ADDRESS
         CLI   R3F,R3FSTD          SKIP IF NOTE INFORMATION
         BNE   SKIPREC
         B     PUT                 AND WRITE IT OUT
         DROP  R2
         SPACE ,
NEXTFILE CLOSE (DISK,)             FINISHED WITH DISK FILE
         LINEDIT TEXT='........ LOADED',SUB=(CHARA,8(R3)),             X
               DOT=NO,COMP=NO
SAMEADDR LR    R1,R3               COPY ADDRESS OF THIS ELEMENT
         LA    R3,16(,R3)          POINT TO NEXT ELEMENT
         BCT   R4,SHOWSAME
         B     ENDFILE
SHOWSAME CLC   0(8,R3),0(R1)       SAME ADDRESS ?
         BNE   PHASE10A            NO, FINISH GOING THROUGH FILE
         LINEDIT TEXT='ALSO KNOWN AS ........',SUB=(CHARA,8(R3)),DOT=NO
         B     SAMEADDR
         EJECT ,
ENDFILE  CLOSE (TAPE,,DISK,) CLOSE THE FILES
         SPACE ,
         TM    FLAGS,OPENDISK          ONLY FREEPOOL IF DISK OPENED
         BZ    NOFREEDS
         NI    FLAGS,255-OPENDISK
         FREEPOOL DISK
NOFREEDS DS    0H
         SPACE ,
         TM    FLAGS,OPENTAPE
         BZ    NOFREETP
         NI    FLAGS,255-OPENTAPE
         FREEPOOL TAPE
NOFREETP DS    0H
         SPACE ,
         L     R1,AREA
         L     R0,POINTER
         SR    R0,R1
         BZ    NOFREE
         FREEMAIN R,A=(1),LV=(0)
NOFREE   DS    0H
         SPACE ,
         L     R13,4(,R13)   POP SAVE AREA CHAIN
         L     R15,RETCODE   LOAD RETURN CODE
         RETURN (14,12),T,RC=(15)   RETURN TO CALLER
         SPACE ,
NOMEMBER WRTERM 'WARNING: NO MEMBERS SELECTED TO BE LOADED'
         MVC   RETCODE,=F'4'
         B     ENDFILE
         SPACE ,
BADDISK  WRTERM 'ERROR: PROBLEM WITH DISK FILE'
         MVC   RETCODE,=F'16'
         B     ENDFILE
         SPACE ,
NOTOPEN  WRTERM 'I/O FILE DID NOT OPEN'
         MVC   RETCODE,=F'12'
         B     ENDFILE
         SPACE ,
BADTAPE  WRTERM 'SOURCE FILE DOES NOT MATCH IEBCOPY FORMAT'
         MVC   RETCODE,=F'12'
         B     ENDFILE
         TITLE 'LOCAL SUBROUTINES'
GETREC   DS    0H            OBTAIN NEXT RECORD FROM TAPE FILE
*                            RETURN ADDRESS IS IN R10
*                            ADDRESS OF RECORD RETURNED IN R1
         SPACE ,
         USING COPYR3,R1     ADDRESS THE RECORD
         CLC   =A(0),RECLEN  IS THERE ANYTHING IN THE BUFFER ?
         BNE   GETREC10      YES, THEN GIVE IT TO THE USER
         GET   TAPE          NO, OBTAIN THE NEXT RECORD
         LH    R15,0(,R1)    GET THE LENGTH OF THE RECORD
         SH    R15,=H'4'     SUBTRACT THE LENGTH OF THE HEADER
         LA    R1,4(,R1)     POINT PAST THE HEADER
         ST    R15,RECLEN    SET THE LENGTH OF THE RECORD LEFT
         ST    R1,RECADDR    SET THE ADDRESS OF THE NEXT ELEMENT
         SPACE ,
GETREC10 DS    0H            RETURN ADDRESS OF BUFFER IN R1
         L     R1,RECADDR    GET THE ADDRESS OF THE ELEMENT
         USING COPYR3,R1     ADDRESS THE ELEMENT
         SR    R15,R15       CALCULATE THE LENGTH
         SR    R0,R0
         IC    R15,R3K       GET THE KEY LENGTH
         ICM   R0,3,R3DL     GET THE DATA LENGTH
         AR    R15,R0        CALCULATE LENGTH OF THE KEY + DATA AREA
         LA    R15,LCOPYR3(,R15)   TOTAL LENGTH OF AREA
         L     R0,RECLEN     GET THE LENGTH
         SR    R0,R15        CALCULATE THE LENGTH LEFT
         BM    BADTAPE       SHOULD NEVER GO < 0
         ST    R0,RECLEN     UPDATE LENGTH
         LA    R15,0(R1,R15) POINT TO NEXT ELEMENT
         ST    R15,RECADDR
         BR    R10           RETURN TO CALLER
         SPACE ,
         DROP  R1
         EJECT ,
         USING PDSREC,R2     DISPLAY THE INFORMATION
SHOWLIST DS    0H            DISPLAY THE INFO. ABOUT A MEMBER
         IC    R4,PDSFLAGS
         N     R4,=A(PDSUSER)
         AR    R4,R4
         LA    R4,L'PDSADDR+L'PDSFLAGS(,R4)
         LINEDIT TEXT='MEMBER ........ ................................X
               .......................................',               X
               DOT=NO,RENT=NO,COMP=NO,                                 X
               SUB=(CHARA,PDSNAME,HEX4A,(PDSADDR,(R4)))
         BR    R10
         SPACE ,
         DROP  R2
         EJECT ,
         USING PDSREC,R2
SHOWLOAD DS    0H            ENTER LINE INTO INCORE LIST
         LM    R4,R5,POINTER POINT TO LAST ELEMENT USED
         LA    R6,16(,R4)    POINT TO NEW LAST ELEMENT
         CR    R6,R5         PAST THE END ?
         BH    TOOMANY       YES, CAN'T DO THIS
         ST    R6,POINTER    UPDATE POINTER
         SPACE ,
         MVC   8(8,R4),PDSNAME     COPY THE MEMBER NAME
         MVC   7(1,R4),PDSADDR+2   COPY THE R FROM TTR
         SR    R5,R5         CALCULATE MBBCCHHR
         IC    R5,DEBNMEXT   GET THE NUMBER OF EXTENTS
         LA    R6,EXTENTS    POINT TO DEB EXTENTS
         USING DEBXTENT,R6
         SR    R7,R7         GET THE TT OF THE TTR
         ICM   R7,3,PDSADDR
         SPACE ,
NEXTENT  CH    R7,DEBNMTRK
         BL    HAVEXNT       TT < NO. TT IN EXTENT
         SH    R7,DEBNMTRK   RELOCATE TT
         LA    R6,LDEBXNT(,R6)
         BCT   R5,NEXTENT
         B     BADTAPE
         SPACE ,
HAVEXNT  MVC   1(2,R4),DEBINUM     BB
         AH    R7,DEBSTRHH
         CLC   DEBSTRCC,DEBENDCC   CROSS CYLINDER BOUNDARIES ?
         BE    HAVECCHH
         SPACE ,
         LR    R1,R7
         SR    R0,R0
         D     R0,TRKCYL
         STCM  R0,3,5(R4)          HH
         AH    R1,DEBSTRCC         CC
         STCM  R1,3,3(R4)
         B     DOEXTENT
         SPACE ,
HAVECCHH MVC   3(2,R4),DEBSTRCC    CC
         STCM  R7,3,5(R4)          HH
         SPACE ,
         DROP  R6,R2
DOEXTENT S     R6,=A(EXTENTS)
         SRL   R6,4
         STC   R6,0(,R4)           M
         BR    R10
         SPACE ,
TOOMANY  WRTERM 'TOO MANY MEMBERS TO BE LOADED'
         MVC   RETCODE,=F'8'
         B     ENDFILE
         TITLE 'PARAMETER PROCESSING ROUTINE(S)'
OPTIONS  DS    0D
         OPT   MEMBER,SMEMBER
         OPT   FROM,SFROM
         OPT   TO,STO
         OPT   THRU,STO
         OPT   THROUGH,STO
         OPT   FILETYPE,STYPE
         OPT   FTYPE,STYPE
         OPT   FILEMODE,SMODE
         OPT   FMODE,SMODE
NOPTIONS EQU   (*-OPTIONS)/12
         SPACE ,
SMEMBER  BAL   R1,*+4
         MVC   FROM,0(R2)
         MVC   TO,0(R2)
         BR    R1
         SPACE ,
SFROM    BAL   R1,*+4
         MVC   FROM,0(R2)
         LA    R14,FROM+7
         LA    R15,L'FROM
TONULL   CLI   0(R14),C' '
         BNER  R1
         MVI   0(R14),0
         BCTR  R14,0
         BCT   R15,TONULL
         BR    R1
         SPACE ,
STO      BAL   R1,*+4
         MVC   TO,0(R2)
         LA    R14,TO+7
         LA    R15,L'TO
TOFF     CLI   0(R14),C' '
         BNER  R1
         MVI   0(R14),X'FF'
         BCTR  R14,0
         BCT   R15,TOFF
         BR    R1
         SPACE ,
STYPE    MVC   FILETYPE,0(R2)
SMODE    MVC   FILEMODE,0(R2)
         TITLE 'WORK AREA(S), CONSTANTS AND DCBS'
DISK     DCB   DDNAME=DISK,MACRF=W,DEVD=DA,DSORG=PS,EXLST=EXLST,BUFNO=1
TAPE     DCB   DDNAME=TAPE,MACRF=GL,LRECL=32756,BLKSIZE=32760,         X
               RECFM=VB,DSORG=PS,BUFNO=1
EXLST    DC    X'87',AL3(JFCB)
JFCB     DS    22D                     JFCB FOR DISK FILES
         SPACE ,
FLAGS    DC    X'00'                   INTERNAL FLAGS
OPENDISK EQU   X'80'                       SIGNALS DISK FILE WAS OPENED
OPENTAPE EQU   X'40'                       SIGNALS TAPE FILE WAS OPENED
         SPACE ,
AREALEN  DC    A(1024,1000*1024)       MIN/MAX LENGTH REQUESTED
AREA     DC    A(0,0)                  ADDRESS/LENGTH OF AREA
POINTER  DC    A(0)                    NEXT ELEMENT TO BE USED
END      DC    A(0)                    END OF GETMAINED AREA
RECADDR  DC    A(0)                    ADDRESS OF NEXT BUFFER
RECLEN   DC    A(0)                    LENGTH OF RECORD, 0 IF NOTHING
RETCODE  DC    F'0'                    RETURN CODE
BLKSIZE  DC    H'0'                    BLOCK SIZE OF DISK FILE
         SPACE ,
FROM     DC    X'0000000000000000'     FIRST VALID MEMBER
TOZERO   EQU   AREA,*-AREA,C'X'
TO       DC    X'FFFFFFFFFFFFFFFF'     LAST VALID MEMBER
FILEDEF  DS    0D
         DC    CL8'FILEDEF',CL8'DISK',CL8'DISK'
FILENAME DS    CL8
FILETYPE DC    CL8'IEBCOPY'            DEFAULT FILE TYPE
FILEMODE DC    CL8'A2'                 DEFAULT FILE MODE
GATE     DC    8X'FF'
FLAG     DC    X'00'                   FLAG
LOAD     EQU   X'80'                           LOAD FUNCTION
LIST     EQU   X'40'                           LIST FUNCTION
SORTED   EQU   X'20'                           LIST IS SORTED
SAVEAREA DC    18A(0)        O/S SAVE AREA
         SPACE 2
TRKCYL   DS    F             NUMBER OF TRACKS / CYLINDER
DEB      DS    0D            INCORE MAP OF DEB, LAST 16 BYTES OF BASIC
DEBNMEXT DS    X             NUMBER OF EXTENTS
         DS    XL15          *** RESERVED ***
EXTENTS  DS    16XL16        UP TO 16 EXTENTS
         EJECT ,
BADCHARS DC    256C'$'       INVALID CHARACTER TRANSFORMATION
         ORG   BADCHARS+C' '
         DC    AL1(*-BADCHARS)
         ORG   BADCHARS+C'a'
         DC    9AL1(*-BADCHARS)
         ORG   BADCHARS+C'j'
         DC    9AL1(*-BADCHARS)
         ORG   BADCHARS+C's'
         DC    8AL1(*-BADCHARS)
         ORG   BADCHARS+C'A'
         DC    9AL1(*-BADCHARS)
         ORG   BADCHARS+C'J'
         DC    9AL1(*-BADCHARS)
         ORG   BADCHARS+C'S'
         DC    8AL1(*-BADCHARS)
         ORG   BADCHARS+C'0'
         DC    10AL1(*-BADCHARS)
         ORG   ,
         LTORG ,             LITERAL POOL
         SPACE ,
         END   IEBCOPY       END OF PROGRAM
:READ IEBCOPY HELP
IEBCOPY
.sp
  Use the IEBCOPY command to LIST or LOAD member(s) from a partitioned
dataset, on tape created by the IEBCOPY utility (OS version), to CMS.
.sp
.fo off
The format of the IEBCOPY command is :
.sp
+----------------------------------------------------------+
!           !                                              !
!  IEBCOPY  !  < LIST | LOAD >  < options >                !
!           !                                              !
!           !  options: +           +  +          +        !
!           !           | FTYPE  ft |  | FMODE fm |        !
!           !           +           +  +          +        !
!           !           +                         +        !
!           !           | FROM   fn1 |            |        !
!           !           +            | MEMBER fn  |        !
!           !           | TO     fn2 |            |        !
!           !           +                         +        !
!           !                                              !
+----------------------------------------------------------+
.sp
.tr ^ 40
.fo on
.il 5
The IEBCOPY command requires that the tape containing the desired
dataset is attached to your account and that a filedef for the tape
device has been made eg. FILEDEF TAPE TAP1 SL VOLID tapename.
For more information try HELP FILEDEF or HELP MOUNT to attach the tape.
.sp
where:
.fo on
.sp
.sp
.of 5
ft^^^is the filetype given to the member(s) copied to CMS. The default
is IEBCOPY.
.sp
.of 5
fm^^^is the filemode given to the member(s) copied to CMS. The default
is A.
.sp
.of 5
fn1^^is the member name from which the LIST or LOAD is to begin with.
The member names are sorted alphabetically. Default is to start from
the begining of the sorted list.
.sp
.of 5
fn2^^is the member name to be the last to be LISTed or LOADed.
Default is to the end.
.sp
.of 5
fn^^^indicates the name of the MEMBER to be LISTed or LOADed. Only
one name may be given if the option MEMBER is used.
