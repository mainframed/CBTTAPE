./ ADD LIST=ALL,NAME=$$$$$$$$
This member was created using the UNUPDTE program from CBT File 093.
The UNUPDTE program was necessary because this file is RECFM=VB
and LRECL=255.  Use the PDSLOAD program from File 093 to create a PDS
from this member, or else, edit the piece that you want, and copy
it out to a separate pds member.

Sample JCL:

//SBGOLOBA  JOB (ACCT#),S-GOLOB,
// NOTIFY=&SYSUID,
// CLASS=B,MSGCLASS=X
//*                                            Source <= CBT FILE 093
//LOAD EXEC PGM=PDSLOAD                        Load   <= CBT FILE 035
//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB
//SYSPRINT DD SYSOUT=*
//SYSUT1  DD  DISP=SHR,DSN=SBGOLOB.CBT488.FILE221(OLDSTUFF)
//SYSUT2  DD  DISP=SHR,DSN=SBGOLOB.FILE221.OLDSTUFF   <= VB-255

./ ADD LIST=ALL,NAME=$$$DOC01
This file (221) goes together with File 220 from Lee Conyers.

This file (221) contains REXX execs to perform many EDP auditing
"snooping" functions.  This material will be useful for systems
programmers as well.  The material was tested on an MVS/XA 2.2.3
system.  Some of it also runs on MVS/ESA 4.3, but not all of it.

If you can fix any of this material for higher versions of the MVS
operating system, please submit your material to Sam Golob, at his
address as listed on File 001 of this tape.

      Lee Conyers
      U.S. Department of Transportation
      700 4th Street SW
      Room 7404, M-35
      Washington, DC  20590
      (202) 366-1126

./ ADD LIST=ALL,NAME=#NUCLKUP
/*REXX*/
/*****************************************************************/
/*#NUCLKUP: REXX external procedure to scan nucleus map.         */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */
/*****************************************************************/
Arg target
Numeric Digits 10
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */
@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */
nucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */
nucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */
nucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */
@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */
epaddr = 'FFFFFFFF'                  /* initialize with invalid value */
If nucmapid \= 'NUCMAP  ' Then Do
   Say 'Error: Nucleus map table eyecatcher not found'
   Exit
   End
i = 0   /* target = 'IGCERROR' */
Do While @nucmentry <= nucmeot                  /* loop thru storage  */
   i = i + 1
   epname   = STORAGE(D2X(@nucmentry),8)      /* get entry point name */
   If epname = target Then Do
      epaddr = C2X(STORAGE(D2X(@nucmentry+8),4))    /* get ep address */
      epflag = STORAGE(D2X(@nucmentry+12),1)     /* get raw flag byte */
      eplen  = C2X(STORAGE(D2X(@nucmentry+13),3))    /* get ep length */
      Leave
      End
   @nucmentry = @nucmentry + 16                 /* bump to next entry */
End
Return epaddr
./ ADD LIST=ALL,NAME=IOAPFP
/*REXX*/
/*****************************************************************/
/*  IOAPFP: REXX program to create APF programs database.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*             APFTAB - Undocumented in MVS DATA AREAS book.     */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */
@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */
apfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */
apfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */
@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */
Say 'The CVT  is located at '@cvt '('X2D(@cvt)')'
Say 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'
Say 'The APF table contains 'apfcount 'entries, as follows:'
Say ' '
lpadsn = 'NO'                /* SYS1.LPALIB is APF during NIP and not */
lpares = '  '                 /* normally in the APF table.  If it is */
                                 /* then must test for sysres volume. */
Do i = 1 to apfcount                            /* loop thru storage  */
   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */
   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */
   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))      /* length of next  */
   If i = 1 Then resvol = SUBSTR(apflib.i,1,6)       /* retain resvol */
   If SUBSTR(apflib.i,7) = 'SYS1.LPALIB' Then Do  /* check for LPALIB */
      lpadsn = 'YES' ; lpares = 'NO'
      If SUBSTR(apflib.i,1,6) = resvol Then lpares = 'YES'
      End
End
/***************************************************************/
/* The in-storage APF table has been fetched, now print it     */
/***************************************************************/
Say 'VOLSER --------------DATA SET NAME-----------------'
Say ' '
Do i = 1 To apfcount                            /* print the list     */
   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i
End
/***************************************************************/
/* Save the APF table to a data set                            */
/***************************************************************/
Address TSO
dsn1 = 'MS01.CONYERS.APFLIST.DATA.WORK'
"ALLOC F(APFLIST) DA('"dsn1"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOAPFP failed on 'dsn1' error: 'RC
   Exit
   End
Newstack
Do i = apfcount To 1 By -1                      /* write the list */
   Push ' 'SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i
End
Push ' APFCOUNT: 'RIGHT(apfcount,4,0)'   Date: 'DATE()'   Time: 'TIME()
Queue
'EXECIO * DISKW APFLIST ( FINIS'
Delstack
Say ' '
Say 'Saved APF table to DASD'
Say 'DSN: 'dsn1
Say 'Return Code: 'RC
"FREE F(APFLIST)"
Say ' '
/***************************************************************/
/* Now process the directory blocks of each APF library        */
/*   and save the member data to a data set.  Note that        */
/*   when we dynamically allocate each PDS, we are defining    */
/*   DCB parameters to enable reading the directory blocks.    */
/***************************************************************/
dsn2 = 'MS01.CONYERS.APFPGMS.DATA.WORK'
"ALLOC F(APFPGMS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOAPFP failed on 'dsn2' error: 'RC
   Exit
   End
/***************************************************************/
/*   Add SYS1.LPALIB on sysres if not in APF list.             */
/***************************************************************/
If lpadsn = 'NO' | (lpadsn = 'YES' & lpares \= 'YES') Then Do
   Say '*** SYS1.LPALIB on sysres appended to list for programs analysis.'
   Say '         Reason:  lpadsn='lpadsn'  lpares='lpares
   Say '    Explanation:  SYS1.LPALIB on the sysres volume is APF'
   Say '                    authorized by MVS design during IPL.  It'
   Say '                    is added to the APF list for authorized'
   Say '                    programs analysis if not already contained'
   Say '                    in the APF table.  If a SYS1.LPALIB is on'
   Say '                    the APF table, a check is made for its'
   Say '                    volser.  If not the sysres volume, it is'
   Say '                    added to the APF list accordingly for the'
   Say '                    authorized programs analysis.'
   Say ' '
   apfcount = apfcount + 1
   apflib.apfcount = resvol'SYS1.LPALIB'
   End
totpgms = 0
Say 'Beginning APF library contents analysis'
Say '===> note any TSO allocation error messages for skipped libraries'
Say ' '
Do i = 1 To apfcount                            /* cycle the list */
   dsn = STRIP(SUBSTR(apflib.i,7,44))
   vol = STRIP(SUBSTR(apflib.i,1,6))
Say ' '
   Say RIGHT(i,3,0)'  Processing 'dsn' on 'vol'  Mark: 'DATE() TIME()
   "ALLOC F(PDS) DA('"dsn"') VOL("vol") SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)"
   RC1 = RC
   'EXECIO * DISKR PDS ( FINIS STEM line.'
   RC2 = RC
   "FREE F(PDS)"
   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2
   If RC2 = 0 Then Do
      Say '       *** Directory blocks read: 'line.0
      Newstack
      last = 0  /* flags when no more members indicator is detected */
      memcount = 0
      Do j = 1 To line.0
         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */
         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */
         ix = 3                          /* Initialize DIRBLOCK parse index */
         Do While ix < blocklen & last \= 1          /* parse this DIRBLOCK */
            pds2ftb1 = '00'x                         /* initialize apf not  */
            pds2mnm  = '        '                    /* initialize alias of */
            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */
            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3
            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1
            udl = 0                           /* calculate user data length */
            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1
            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2
            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4
            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8
            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16
            udl = udl * 2                 /* finish calc halfwords to bytes */
            If udl >= 22 & last \= 1 Then Do   /* only process likely stuff */
               ix = ix + 8             /* adjust index to skip misc 8 bytes */
               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3
               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
                                                            /* scatter sect */
               If BITAND(pds2atr1,'04'x) = '04'x Then Do
                  pds2scat = SUBSTR(line.j,ix+33,8)
                  ix = ix + 8
                  End
                                                              /* alias sect */
               If BITAND(pds2indc,'80'x) = '80'x Then Do
                  If udl >= 32 Then Do
                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3
                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8
                     End
                  Else Do
                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i
                     pds2epm = '000000'x
                     pds2mnm = '????????'
                     End
                  End
                                                             /* ssi section */
               If BITAND(pds2ftb1,'10'x) = '10'x Then Do
                  If (ix-1)//2 \= 0 Then ix = ix + 1    /* halfword alignmt */
                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4
                  End
                                                             /* apf section */
               If BITAND(pds2ftb1,'08'x) \= '08'x Then pdsapfac = ' '/* none*/
               Else Do                                         /* maybe apf */
                  pdsapfct = SUBSTR(line.j,ix,1)
                  If pdsapfct = '01'x Then Do                /* NORMAL path */
                     ix = ix + 1
                     pdsapfac = SUBSTR(line.j,ix,1)
                     ix = ix + 1
                     If pdsapfac \= '00'x & pdsapfac \= '01'x Then Do
                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i
                        nop
                        End
                     End
                  If pdsapfct \= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do
                     pdsapfac=' '
                     ix = ix - 8
                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i
                     End
                  End
               End
            Else Do                              /* too short udl, leave it */
               ix = ix + udl
               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
                  last = 1
                  Leave
                  End
               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i
               pds2atr1 = '00'x
               pds2atr2 = '00'x
               pds2stor = '000000'x
               pds2mnm  = '        '
               pdsapfac = ' '
               End
            If (ix-1)//2 \= 0 Then ix = ix + 1          /* halfword alignmt */
            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
               last = 1
               Leave
               End
            If pds2name \= '0000000000000000'x Then Do
               memcount = memcount + 1
               Push ' 'LEFT(dsn,44,' ')' 'LEFT(vol,6,' '),
                    ' 'pds2name' TTR:'C2X(pds2ttrp),
                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),
                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),
                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),
                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),
                    ' IX:'RIGHT(ix,3,0)
               End
         End                                         /* DIRBLOCK parse done */
      End
      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount
      Queue
      'EXECIO * DISKW APFPGMS (      '
      Delstack
      totpgms = totpgms + memcount
   End
End
Newstack
Queue
'EXECIO * DISKW APFPGMS ( FINIS'
Delstack
Say ' '
Say 'Saved 'totpgms' APF program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(APFPGMS)"
Exit
./ ADD LIST=ALL,NAME=IOESRT
/*REXX*/
/*****************************************************************/
/*  IOESRT: REXX program to create router SVC database.          */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               SCVT - Supervisor Call Vector Table             */
/*                                                               */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */
@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */
@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */
@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */
@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct' 'DATE() TIME()
Say ' '
dsn = 'MVS.ESR.ESRTABLE'
Newstack
active = 0 ; inactive = 0 ; esrsvc = 0
module = 'IGXERROR' ; Call "#NUCLKUP" module ; igxerror = Result
d = Date() ; t = Time()
Do i = 0 to 255                                 /* loop thru storage  */
   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)
   bytes = C2X(bytes)
   svcep  = SUBSTR(bytes,1,8)
   svctp2 = SUBSTR(bytes,10,1)
   If svctp2 = '4'            /* EP address is an ESR table */
      Then Do
         esrid = STORAGE(svcep,4)                 /* table eyecatcher */
         esrct = C2X(STORAGE(D2X(X2D(svcep)+4),4))       /* esr count */
         Say 'SVC 'i' is 'esrid'.  Table at 'svcep', Slots 'X2D(esrct)' ('esrct')'
         Say ' '
         esrsvc = 0
         Do j = 0 to X2D(esrct)                   /* process this ESR */
            bytes = STORAGE(D2X(X2D(svcep)+(j*8)+8),8)
   addr = SUBSTR(bytes,1,4)       /* sloppy code to grap EP in binary */
   bytes = C2X(bytes)          /* legacy code before learning bit ops */
            esrep  = SUBSTR(bytes,1,8)
                                        /* determine storage location */
   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
            esrtp2 = SUBSTR(bytes,10,1)
            esrmisc = '   '
            If esrtp2 = '8'
               Then esrmisc = 'APF'
            inactflag = 0
            If igxerror = Right(D2X(addr),8,0) /* normalize address */
               Then inactflag = 1
               Else Do
                       active = active + 1
                       esrsvc = esrsvc + 1
                    End
            esrtp1 = SUBSTR(bytes,9,1)
               Select
                  When esrtp1 = '0'
                     Then esrtype = 'TYPE 1  '
                  When esrtp1 = '8'
                     Then esrtype = 'TYPE 2  '
                  When esrtp1 = 'C'
                     Then esrtype = 'TYPE 3/4'
                  When esrtp1 = '2'
                     Then esrtype = 'TYPE 6  '
               Otherwise
                          esrtype = 'TYPE ?  '
               End
            If inactflag = 0
               Then Push ' 'LEFT(dsn,44,' '),
                         'ESR'RIGHT(j,3,0) '('RIGHT(D2X(j),2,0)')',
                         'SVC'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',
                          esrtype esrep sloc esrmisc d t
         End
         Say '     Total ESR SVCs this table 'esrsvc
         Say ' '
      End
End
Say 'This system contains 'active' ESR SVCs'
Say ' '
Say '  (IGXERROR nucleus address = 'igxerror')'
Say ' '
Say 'ESRTABLE processing complete ' Time()
Say ' '
/***************************************************************/
/* Now save the stack to our ESR data set                      */
/***************************************************************/
dsn2 = 'MS01.CONYERS.ESRS.DATA.WORK'
"ALLOC F(ESRS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOESRT failed on 'dsn2' error: 'RC
   Exit
   End
Queue
'EXECIO * DISKW ESRS ( FINIS'
Delstack
Say ' '
Say 'Saved 'active' ESR SVC descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(ESRS)"
Exit
./ ADD LIST=ALL,NAME=IOLLTP
/*REXX*/
/*****************************************************************/
/*  IOLLTP: REXX program to create LLT programs database.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/*                CVT - Communications Vector Table (@'10'x)     */
/*                LLT - Linklist Lookaside Table                 */
/*               DCB3 - Data Control Block (BDAM)                */
/*                DEB - IOS Data Extent Block                    */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtlink  = STORAGE(D2X(X2D(@cvt)+8),4)      /* get CVTLINK address   */
@cvtlink  = D2X(C2D(@cvtlink))                 /* binary to hex       */
@dcbdebad = STORAGE(D2X(X2D(@cvtlink)+44),4)    /* LINKLIB DCB to DEB */
@dcbdebad = D2X(C2D(@dcbdebad))                 /* convert to hex     */
debflgs1  = STORAGE(D2X(X2D(@dcbdebad)+14),1)     /* LINKLIB DEBflags */
   debapfin = 'LNKLST'
   If BITAND(debflgs1,'02'x)\='02'x Then debapfin = 'APFTAB'
@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)   /* get CVTLLTA address   */
@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */
lltcount  = C2D(STORAGE(D2X(X2D(@cvtllta)+7),1))  /* LLT libraries    */
lltllen   = C2D(STORAGE(D2X(X2D(@cvtllta)+8),1))  /* length 1st entry */
@lltentry = X2D(@cvtllta)+9           /* address of 1st LLT entry     */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,
    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin
Say ' '
Say 'LLT scan on 'DATE()' started: 'TIME()
Say ' '
Do i = 1 to lltcount                            /* loop thru storage  */
   lltlib.i = STORAGE(D2X(@lltentry),lltllen)   /* get the LLT entry  */
   @lltentry = @lltentry + 45                   /* bump to next entry */
   lltllen = C2D(STORAGE(D2X(@lltentry-1),1))   /* length of next  */
End
Say '--------------DATA SET NAME-----------------'
Say ' '
Do i = 1 to lltcount                            /* print the list     */
   Say SUBSTR(lltlib.i,1,44,' ') i
End
Say ' '
Say 'LLT scan completed: 'TIME()
/***************************************************************/
/* Save the LINKLIST table to a data set                       */
/***************************************************************/
Address TSO
dsn1 = 'MS01.CONYERS.LLTLIST.DATA.WORK'
"ALLOC F(LLTLIST) DA('"dsn1"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOLLTP failed on 'dsn1' error: 'RC
   Exit
   End
Newstack
Do i = lltcount To 1 By -1                      /* write the list */
   Push ' 'SUBSTR(lltlib.i,1,44,' ') i
End
Push ' LLTCOUNT: 'RIGHT(lltcount,4,0)'   Date: 'DATE()'   Time: 'TIME()
Push 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,
    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin
Queue
'EXECIO * DISKW LLTLIST ( FINIS'
Delstack
Say ' '
Say 'Saved LINKLIST table to DASD'
Say 'DSN: 'dsn1
Say 'Return Code: 'RC
"FREE F(LLTLIST)"
Say ' '
/***************************************************************/
/* Now process the directory blocks of each LLT library        */
/*   and save the member data to a data set.  Note that        */
/*   when we dynamically allocate each PDS, we are defining    */
/*   DCB parameters to enable reading the directory blocks.    */
/***************************************************************/
dsn2 = 'MS01.CONYERS.LLTPGMS.DATA.WORK'
"ALLOC F(LLTPGMS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOLLTP failed on 'dsn2' error: 'RC
   Exit
   End
totpgms = 0
Say 'Beginning LINKLIST library contents analysis'
Say '===> note any TSO allocation error messages for skipped libraries'
Say ' '
Do i = 1 To lltcount                                /* cycle the list */
   dsn = STRIP(SUBSTR(lltlib.i,1,44))
Say ' '
   Say RIGHT(i,3,0)'  Processing 'dsn'   Mark: 'DATE() TIME()
   "ALLOC F(PDS) DA('"dsn"') SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)"
   RC1 = RC
   'EXECIO * DISKR PDS ( FINIS STEM line.'
   RC2 = RC
   "FREE F(PDS)"
   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2
   If RC2 = 0 Then Do
      Say '       *** Directory blocks read: 'line.0
      Newstack
      last = 0  /* flags when no more members indicator is detected */
      memcount = 0
      Do j = 1 To line.0
         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */
         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */
         ix = 3                          /* Initialize DIRBLOCK parse index */
         Do While ix < blocklen & last \= 1          /* parse this DIRBLOCK */
            pds2ftb1 = '00'x                         /* initialize apf not  */
            pds2mnm  = '        '                    /* initialize alias of */
            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */
            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3
            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1
            udl = 0                           /* calculate user data length */
            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1
            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2
            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4
            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8
            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16
            udl = udl * 2                 /* finish calc halfwords to bytes */
            If udl >= 22 & last \= 1 Then Do   /* only process likely stuff */
               ix = ix + 8             /* adjust index to skip misc 8 bytes */
               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3
               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
                                                            /* scatter sect */
               If BITAND(pds2atr1,'04'x) = '04'x Then Do
                  pds2scat = SUBSTR(line.j,ix+33,8)
                  ix = ix + 8
                  End
                                                              /* alias sect */
               If BITAND(pds2indc,'80'x) = '80'x Then Do
                  If udl >= 32 Then Do
                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3
                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8
                     End
                  Else Do
                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i
                     pds2epm = '000000'x
                     pds2mnm = '????????'
                     End
                  End
                                                             /* ssi section */
               If BITAND(pds2ftb1,'10'x) = '10'x Then Do
                  If (ix-1)//2 \= 0 Then ix = ix + 1    /* halfword alignmt */
                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4
                  End
                                                             /* apf section */
               If BITAND(pds2ftb1,'08'x) \= '08'x Then pdsapfac = ' '/* none*/
               Else Do                                         /* maybe apf */
                  pdsapfct = SUBSTR(line.j,ix,1)
                  If pdsapfct = '01'x Then Do                /* NORMAL path */
                     ix = ix + 1
                     pdsapfac = SUBSTR(line.j,ix,1)
                     ix = ix + 1
                     If pdsapfac \= '00'x & pdsapfac \= '01'x Then Do
                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i
                        nop
                        End
                     End
                  If pdsapfct \= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do
                     pdsapfac=' '
                     ix = ix - 8
                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i
                     End
                  End
               End
            Else Do                              /* too short udl, leave it */
               ix = ix + udl
               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
                  last = 1
                  Leave
                  End
               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i
               pds2atr1 = '00'x
               pds2atr2 = '00'x
               pds2stor = '000000'x
               pds2mnm  = '        '
               pdsapfac = ' '
               End
            If (ix-1)//2 \= 0 Then ix = ix + 1          /* halfword alignmt */
            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
               last = 1
               Leave
               End
            If pds2name \= '0000000000000000'x Then Do
               memcount = memcount + 1
               Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,3,0),
                    ' 'pds2name' TTR:'C2X(pds2ttrp),
                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),
                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),
                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),
                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),
                    ' IX:'RIGHT(ix,3,0)
               End
         End                                         /* DIRBLOCK parse done */
      End
      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount
      Queue
      'EXECIO * DISKW LLTPGMS (      '
      Delstack
      totpgms = totpgms + memcount
   End
End
Newstack
Queue
'EXECIO * DISKW LLTPGMS ( FINIS'
Delstack
Say ' '
Say 'Saved 'totpgms' LINKLIST program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(LLTPGMS)"
Exit
./ ADD LIST=ALL,NAME=IOLPAP
/*REXX*/
/*****************************************************************/
/*  IOLPAP: REXX program to create LPAT programs database.       */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/*                CVT - Communications Vector Table (@'10'x)     */
/*               LPAT - Link Pack Area (libraries) Table         */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */
@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */
@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */
lpatcount = C2D(STORAGE(D2X(X2D(@cvteplps)+4),4)) /* LPAT entries     */
lpatlen   = C2D(STORAGE(D2X(X2D(@cvteplps)+8),1)) /* length 1st entry */
@lpatentry= X2D(@cvteplps)+9          /* address of 1st LPAT entry    */
Say 'CVT:'@cvt  'CVTSMEXT:'@cvtsmext'  CVTEPLPS:'@cvteplps,
    '  'DATE() TIME()
Say ' '
Say 'The LPAT table contains 'lpatcount 'entries, as follows:'
Say ' '
Do i = 1 to lpatcount                           /* loop thru storage  */
   lpatlib.i = STORAGE(D2X(@lpatentry),lpatlen) /* get the LPAT entry */
   @lpatentry = @lpatentry + 45                 /* bump to next entry */
   lpatlen = C2D(STORAGE(D2X(@lpatentry-1),1))  /* length of next     */
End
Say '--------------DATA SET NAME-----------------'
Say ' '
Do i = 1 to lpatcount                           /* print the list     */
   Say SUBSTR(lpatlib.i,1,44,' ') i
End
/***************************************************************/
/* Save the LINK PACK AREA table list to a data set            */
/***************************************************************/
Address TSO
dsn1 = 'MS01.CONYERS.LPALIST.DATA.WORK'
"ALLOC F(LPALIST) DA('"dsn1"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOLPAP failed on 'dsn1' error: 'RC
   Exit
   End
Newstack
Do i = lpatcount To 1 By -1                        /* write the list */
   Push ' 'SUBSTR(lpatlib.i,1,44,' ') i
End
Push ' LPACOUNT: 'RIGHT(lpatcount,4,0)'   Date: 'DATE()'  Time: 'TIME()
Push 'CVT:'@cvt' CVTSMEXT:'@cvtsmext' CVTEPLPS:'@cvteplps
Queue
'EXECIO * DISKW LPALIST ( FINIS'
Delstack
Say ' '
Say 'Saved LINKLIST table to DASD'
Say 'DSN: 'dsn1
Say 'Return Code: 'RC
"FREE F(LPALIST)"
Say ' '
/***************************************************************/
/* Now process the directory blocks of each LPA library        */
/*   and save the member data to a data set.  Note that        */
/*   when we dynamically allocate each PDS, we are defining    */
/*   DCB parameters to enable reading the directory blocks.    */
/***************************************************************/
dsn2 = 'MS01.CONYERS.LPAPGMS.DATA.WORK'
"ALLOC F(LPAPGMS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOLPAP failed on 'dsn2' error: 'RC
   Exit
   End
totpgms = 0
Say 'Beginning LINK PACK AREA library contents analysis'
Say '===> note any TSO allocation error messages for skipped libraries'
Say ' '
Do i = 1 To lpatcount                               /* cycle the list */
   dsn = STRIP(SUBSTR(lpatlib.i,1,44))
Say ' '
   Say RIGHT(i,3,0)'  Processing 'dsn'   Mark: 'DATE() TIME()
   "ALLOC F(PDS) DA('"dsn"') SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)"
   RC1 = RC
   'EXECIO * DISKR PDS ( FINIS STEM line.'
   RC2 = RC
   "FREE F(PDS)"
   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2
   If RC2 = 0 Then Do
      Say '       *** Directory blocks read: 'line.0
      Newstack
      last = 0  /* flags when no more members indicator is detected */
      memcount = 0
      Do j = 1 To line.0
         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */
         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */
         ix = 3                          /* Initialize DIRBLOCK parse index */
         Do While ix < blocklen & last \= 1          /* parse this DIRBLOCK */
            pds2ftb1 = '00'x                         /* initialize apf not  */
            pds2mnm  = '        '                    /* initialize alias of */
            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */
            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3
            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1
            udl = 0                           /* calculate user data length */
            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1
            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2
            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4
            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8
            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16
            udl = udl * 2                 /* finish calc halfwords to bytes */
            If udl >= 22 & last \= 1 Then Do   /* only process likely stuff */
               ix = ix + 8             /* adjust index to skip misc 8 bytes */
               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3
               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
                                                            /* scatter sect */
               If BITAND(pds2atr1,'04'x) = '04'x Then Do
                  pds2scat = SUBSTR(line.j,ix+33,8)
                  ix = ix + 8
                  End
                                                              /* alias sect */
               If BITAND(pds2indc,'80'x) = '80'x Then Do
                  If udl >= 32 Then Do
                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3
                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8
                     End
                  Else Do
                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i
                     pds2epm = '000000'x
                     pds2mnm = '????????'
                     End
                  End
                                                             /* ssi section */
               If BITAND(pds2ftb1,'10'x) = '10'x Then Do
                  If (ix-1)//2 \= 0 Then ix = ix + 1    /* halfword alignmt */
                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4
                  End
                                                             /* apf section */
               If BITAND(pds2ftb1,'08'x) \= '08'x Then pdsapfac = ' '/* none*/
               Else Do                                         /* maybe apf */
                  pdsapfct = SUBSTR(line.j,ix,1)
                  If pdsapfct = '01'x Then Do                /* NORMAL path */
                     ix = ix + 1
                     pdsapfac = SUBSTR(line.j,ix,1)
                     ix = ix + 1
                     If pdsapfac \= '00'x & pdsapfac \= '01'x Then Do
                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i
                        nop
                        End
                     End
                  If pdsapfct \= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do
                     pdsapfac=' '
                     ix = ix - 8
                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i
                     End
                  End
               End
            Else Do                              /* too short udl, leave it */
               ix = ix + udl
               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
                  last = 1
                  Leave
                  End
               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i
               pds2atr1 = '00'x
               pds2atr2 = '00'x
               pds2stor = '000000'x
               pds2mnm  = '        '
               pdsapfac = ' '
               End
            If (ix-1)//2 \= 0 Then ix = ix + 1          /* halfword alignmt */
            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
               last = 1
               Leave
               End
            If pds2name \= '0000000000000000'x Then Do
               memcount = memcount + 1
               Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,3,0),
                    ' 'pds2name' TTR:'C2X(pds2ttrp),
                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),
                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),
                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),
                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),
                    ' IX:'RIGHT(ix,3,0)
               End
         End                                         /* DIRBLOCK parse done */
      End
      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount
      Queue
      'EXECIO * DISKW LPAPGMS (      '
      Delstack
      totpgms = totpgms + memcount
   End
End
Newstack
Queue
'EXECIO * DISKW LPAPGMS ( FINIS'
Delstack
Say ' '
Say 'Saved 'totpgms' PLPA program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(LPAPGMS)"
Exit
./ ADD LIST=ALL,NAME=IOLPAQ
/*REXX*/
/*****************************************************************/
/*  IOLPAQ: REXX program to create LPAQ programs database.       */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                GDA - Global Data Area                         */
/*               LPAQ - Link Pack Area Queue                     */
/*                CDE - Contents Directory Entry                 */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtqlpaq = STORAGE(D2X(X2D(@cvt)+188),4)    /* get CVTqlpaq address  */
@cvtqlpaq = D2X(C2D(@cvtqlpaq))                /* binary to hex       */
@lpaqptr  = STORAGE(@cvtqlpaq,4)             /* get pointer to LPAQ   */
@lpaqptr  = D2X(C2D(@lpaqptr))                 /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTQLPAQ:'@cvtqlpaq' LPAQPTR:'@lpaqptr' 'DATE() TIME()
@cdechn = @lpaqptr
Say ' '
dsn = 'MVS.LPAQ.CDECHAIN'           /* assign a pseudo data set name */
i = 0 ; d = Date() ; t = Time()
Newstack
Do While @cdechn \= '00000000'
   i = i + 1
   cde = STORAGE(@cdechn,32)                          /* get the cde */
   cdname = SUBSTR(cde,9,8)
   cdentpt= SUBSTR(cde,17,4)
                                        /* determine storage location */
   addr = BITAND(cdentpt,'7FFFFFFF'x)     /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
   cdxlmjp= C2X(SUBSTR(cde,21,4))
   cduse  = C2D(SUBSTR(cde,25,2))
   cdattr =     SUBSTR(cde,29,1)  /* do NOT convert raw byte */
   alias = 0 ; If (BITAND(cdattr,'04'x)='04'x) Then alias = 1
   cdattr2 = SUBSTR(cde,30,1)       /* do NOT convert raw byte */
   auth = 0 ; If (BITAND(cdattr2,'01'x)='01'x) Then auth = 1
   cdemjp  = '         '
   cdemjnm = '        '
   If alias = 1 Then Do
                        cdemjp  = ' Alias of'
                        cdemjnm = STORAGE(D2X(X2D(cdxlmjp)+8),8)
                     End
   Push ' 'LEFT(dsn,44,' ')' 'RIGHT(i,4,0),
       cdname ,
       C2X(cdentpt) ,
       sloc ,
       'USE:'RIGHT(cduse,5,0) ,
        'AC:'auth ,
        cdemjp cdemjnm d t
   @cdechn = C2X(LEFT(cde,4))                 /* get next cde address */
End
Say ' '
Say 'End of LPA Queue scan ' Time()
Say ' '
/***************************************************************/
/* Now save the stack to our LPAQMODS data set                 */
/***************************************************************/
dsn2 = 'MS01.CONYERS.LPAQMODS.DATA.WORK'
"ALLOC F(LPAQMODS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOLPAQ failed on 'dsn2' error: 'RC
   Exit
   End
Queue
'EXECIO * DISKW LPAQMODS ( FINIS'
Delstack
Say ' '
Say 'Saved 'i' LPAQ program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(LPAQMODS)"
Exit
./ ADD LIST=ALL,NAME=IONUCM
/*REXX*/
/*****************************************************************/
/*  IONUCM: REXX program to create nucleus map data set.         */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */
/*                                                               */
/*****************************************************************/
Numeric Digits 10
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */
@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */
nucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */
nucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */
nucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */
@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */
Address TSO ; 'CLEAR'
Say 'CVT:'@cvt  'CVTNUCMP:'@cvtnucmp'  NUCMLEN:'nucmlen' bytes',
    '  'DATE() TIME()
Say ' '
If nucmapid \= 'NUCMAP  ' Then Do
   Say 'Error: Nucleus map table eyecatcher not found'
   Exit
   End
i = 0 ; d = DATE() ; t = TIME()
Do While @nucmentry <= nucmeot                  /* loop thru storage  */
   i = i + 1
   epname.i = STORAGE(D2X(@nucmentry),8)      /* get entry point name */
   epaddr.i = C2X(STORAGE(D2X(@nucmentry+8),4))     /* get ep address */
   epflag.i = STORAGE(D2X(@nucmentry+12),1)      /* get raw flag byte */
   eplen.i  = C2X(STORAGE(D2X(@nucmentry+13),3))     /* get ep length */
   @nucmentry = @nucmentry + 16                 /* bump to next entry */
End
entries = i
/*--------------------------------------------------------------*/
/* epflag byte structure:                                       */
/*                                                              */
/*           XXXX XXXX --> epflag byte                          */
/*           |||| ||||                                          */
/*           |||| ||++---- AMODE 00/01=24, 10=31, 11=ANY        */
/*           |||| |+------ RMODE 0=24, 1=ANY                    */
/*           |||| +------- RSECT 1=yes                          */
/*           |||+--------- CSECT 1=yes                          */
/*           +++---------- unused                               */
/*--------------------------------------------------------------*/
Newstack
Do i = 1 to entries                             /* print the list     */
   csect = '  N  ' ; rsect = '  N  ' ; rmode = '  24 ' ; amode = '  24 '
   If BITAND(epflag.i,'10'x)='10'x Then csect = '  Y  ' /* is a csect */
   If BITAND(epflag.i,'08'x)='08'x Then rsect = '  Y  ' /* read only  */
   If BITAND(epflag.i,'04'x)='04'x Then rmode = ' Any ' /* residency  */
   If BITAND(epflag.i,'02'x)='02'x Then amode = '  31 ' /* addressing */
   If BITAND(epflag.i,'03'x)='03'x Then amode = ' Any ' /* addressing */
   Push ' NUCM'Right(i,4,0) epname.i epaddr.i csect,
                  rsect rmode amode eplen.i d t
End
Say ' '
Say 'End of Nucleus Map Table scan ' TIME()
Say ' '
/***************************************************************/
/* Now save the stack to our NUCMAP data set                   */
/***************************************************************/
dsn2 = 'MS01.CONYERS.NUCMAP.DATA.WORK'
"ALLOC F(NUCMAP) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IONUCM failed on 'dsn2' error: 'RC
   Exit
   End
Queue
'EXECIO * DISKW NUCMAP ( FINIS'
Delstack
Say ' '
Say 'Saved 'entries' NUCMAP program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(NUCMAP)"
Exit
./ ADD LIST=ALL,NAME=IOPCAUTH
/*REXX*/
/*****************************************************************/
/*IOPCAUTH: REXX program to obtain PC table from PCAUTH addspc.  */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               ASVT - Address Space Vector Table               */
/*               ASCB - Address Space Control Block              */
/*               OUCB - SRM User Control Block                   */
/*              Other - calls assembler SNAP macro for PCDATA    */
/*                                                               */
/*****************************************************************/
/*                                                               */
/*****************************************************************/
/*  First, get address space names (ASN) to associate with the   */
/*  EXEC ASID field in the PCAUTH table.                         */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */
@cvtasvt  = STORAGE(D2X(X2D(@cvt)+556),4)    /* get CVTASVT address   */
@cvtasvt  = D2X(C2D(@cvtasvt))                 /* binary to dec to hex*/
Address TSO ; "CLEAR"
Say 'CVT: '@cvt 'CVTASVT: '@cvtasvt' ===> Scan on 'DATE()'.  Started: 'TIME()
@asvt = @cvtasvt
asvtmaxu = STORAGE(D2X(X2D(@asvt)+516),4) /* get maxuser (table size) */
Do i = 1 to C2D(asvtmaxu)                  /* initialize name buckets */
   asn.i = 'Unknown '
End
asn.0 = '*Caller*'   /* if exec asid in pcauth is zero */
j = 0 ; k = 0 ; tablend = 524 + (4 * (C2D(asvtmaxu)-1))
Do i = 524 to tablend By 4                      /* loop thru the ASVT */
   j = j + 1                            /* count asvt slots processed */
   @ascb = STORAGE(D2X(X2D(@asvt)+i),4)        /* get address of ASCB */
   If BITAND(LEFT(@ascb,1),'80'x)\='80'x Then Do   /* bit off, in use */
      k = k + 1                                /* count active adrspc */
      ascbasid = STORAGE(D2X(C2D(@ascb)+36),2)            /* get ASID */
      x = C2D(ascbasid)    /* convert for indexing */
      @ascboucb = STORAGE(D2X(C2D(@ascb)+144),4)  /* get OUCB address */
      @ascbjbni = STORAGE(D2X(C2D(@ascb)+172),4)  /* get JOBN address */
      jbni = '        ' ; @ascbjbni = D2X(C2D(@ascbjbni))
      If @ascbjbni \= 0 Then jbni = STORAGE(@ascbjbni,8)
      @ascbjbns = STORAGE(D2X(C2D(@ascb)+176),4)  /* get STCN address */
      jbns = '        ' ; @ascbjbns = D2X(C2D(@ascbjbns))
      If @ascbjbns \= 0 Then jbns = STORAGE(@ascbjbns,8)
      oucbsubn = STORAGE(D2X(C2D(@ascboucb)+176),4)    /* subsys name */
      oucbtrxn = STORAGE(D2X(C2D(@ascboucb)+200),8)    /* transn name */
      oucbusrd = STORAGE(D2X(C2D(@ascboucb)+208),8)         /* userid */
      /* BATCH JOBS */
      If oucbsubn = 'JES2' & jbns = 'INIT    ' & jbni = oucbtrxn Then Do
         asn.x = oucbtrxn
         nop
         End
      /* TSO USERS  */
      If oucbsubn = 'TSO ' Then Do
         If oucbusrd = '        ' Then asn.x = '????????' /* missing lid */
                                  Else asn.x = oucbusrd
         nop
         End
      /* STARTED TASKS */
      If oucbsubn = 'STC ' & oucbtrxn \= 'INIT    ' & jbns \= 'INIT    ' Then Do
         asn.x = oucbtrxn
         nop
         End
      End
End
Say ' '
Say 'SNAP SDATA=(PCDATA) macro called ' Date() Time()
Say ' '
dsn = 'MS01.CONYERS.PCAUTH.DATA.WORK'
"ALLOC F(SNAPRINT) DA('"dsn"') OLD RELEASE"
pgm = 'MS01.CONYERS.LOAD(SNAPPC)'
"CALL '"PGM"'"
If RC \= 0 Then Do
   Say '  *** SNAP program failed on error: 'RC
   Exit
   End
Say 'Processing SNAP macro output     ' Date() Time()
Say ' '
"ALLOC F(SNAPRINT) DA('"dsn"') SHR"
Newstack
'EXECIO * DISKR SNAPRINT ( FINIS'
If RC \= 0 Then Do
   Say '  *** SNAP process failed on error: 'RC
   Exit
   End
"FREE F(SNAPRINT)"
Queue '*EOF*'
i = 0 ; j = 0 ; d = Date() ; t = Time()
Do while i < 2000
  i = i + 1
  Pull line
  If LEFT(line,5) = '*EOF*' Then Leave
  /* Say line */             /* uncomment say to see SNAP output */
  x = SUBSTR(line,17,4)      /* extract & test AUTH KEY MASK */
  y = SUBSTR(line,38,8)      /* extract & test ENTRY ADDRESS */
  z = SUBSTR(line,59,8)      /* extract & test LATENT PARMS  */
  /* Simple validity test for a PC INFORMATION line from SNAP output */
  If DATATYPE(x,'X')=1 & DATATYPE(y,'X')=1 & DATATYPE(z,'X')=1 Then Do
     j     = j + 1               /* INCREMENT PC ENTRY COUNTER */
     pc.j  = SUBSTR(line,4,6)    /* PC NUM        */
     akm.j = x                   /* AUTH KEY MASK */
     ex.j  = SUBSTR(line,29,4)   /* EXEC ASID     */
     ea.j  = y                   /* ENTRY ADDRESS */
     es.j  = SUBSTR(line,51,1)   /* EXEC STATE    */
     lp.j  = z                   /* LATENT PARMS  */
     ekm.j = SUBSTR(line,73,4)   /* EXEC KEY MASK */
     End
End
Delstack
Say 'Processing statistics:'
Say '                        REPORT OUTPUT  'RIGHT(i-1,4)' lines.'
Say '                        PC INFORMATION 'RIGHT(j,4)' lines.'
Say ' '
Say 'PC INFORMATION analysis completed ' Time()
/*-----------------------------------------------------------------*/
/*  Now get virtual storage map to classify pcauth entry address   */
/*-----------------------------------------------------------------*/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
/*-----------------------------------------------------------------*/
/*  Now reload a new stack with the parse output STEM'd from above */
/*-----------------------------------------------------------------*/
Newstack
dsn2 = 'MVS.PCAUTH.PCTABLE'      /* assign a pseudo data set name  */
Do i = j to 1 By -1              /* reverse stack unload on execio */
                                        /* determine storage location */
  k = X2D(ex.i) ; asname = asn.k    /* map address space name */
/*addr = BITAND(X2C(ea.i),'7FFFFFFF'x)      shave off amode bit (32) */
  addr = ea.i ; If LEFT(addr,1)='8' Then addr = SUBSTR(addr,2,7)
  addr = X2D(addr)                      /* make numeric for compares */
  sloc = 'ERROR'                       /* determine module residency */
  If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
     Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
     Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
     Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
     Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
     Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
     Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
     Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
     Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
     Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
     Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
     Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
     Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
     Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
  Push ' 'LEFT(dsn2,44,' '),
        pc.i akm.i ex.i asname ea.i sloc es.i ekm.i d t
End
Queue
"ALLOC F(SNAPRINT) DA('"dsn"') OLD RELEASE"
'EXECIO * DISKW SNAPRINT ( FINIS'
"FREE F(SNAPRINT)"
Delstack
Say ' '
Say 'Saved 'j' PC instruction descriptor records to DASD'
Say 'DSN: 'dsn
Say 'Return Code: 'RC
Exit
./ ADD LIST=ALL,NAME=IOPLPA
/*REXX*/
/*****************************************************************/
/*  IOPLPA: REXX program to copy PLPA directory to a dataset.    */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                GDA - Global Data Area                         */
/*               LPDE - Link Pack Directory Entry                */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtlpdir = STORAGE(D2X(X2D(@cvt)+361),3)    /* get CVTLPDIR address  */
@cvtlpdir = D2X(C2D(@cvtlpdir))                /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTLPDIR:'@cvtlpdir'  'DATE() TIME()
@lpdechn = @cvtlpdir
Say ' '
dsn = 'MVS.PLPA.DIRTABLE'            /* assign a pseudo data set name */
Newstack
i = 0 ; eot = '00000000000000000000000000000000'
d = Date() ; t = Time()
Do While i < 10000                                 /* arbitrary limit */
   lpde = STORAGE(@lpdechn,40)                        /* get the lpde */
   If C2X(SUBSTR(lpde,1,16))=eot Then Leave           /* end of table */
   i = i + 1
   module = SUBSTR(lpde,9,8)
   entry  = SUBSTR(lpde,17,4)
                                        /* determine storage location */
   addr = BITAND(entry,'7FFFFFFF'x)       /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
   size   = C2X(SUBSTR(lpde,33,4))
   att2   =     SUBSTR(lpde,30,1)
   auth = 0 ; If (BITAND(att2,'01'x)='01'x) Then auth = 1
   lpdemjp  = '         '
   lpdemjnm = '        '
   If C2D(SUBSTR(lpde,21,4)) \= 0 Then
      Do
         lpdemjp  = ' Alias of'
         lpdemjnm = SUBSTR(lpde,33,8)
             size = '        '
      End
   Push ' 'LEFT(dsn,44,' ') 'PLPA'RIGHT(i,4,0) ,
       module ,
       C2X(entry) ,
       sloc ,
       'SIZE:'RIGHT(size,8,0) ,
       'AC:'auth ,
       lpdemjp lpdemjnm d t
   @lpdechn = D2X(X2D(@lpdechn)+40)         /* address of next LPDE */
End
Say ' '
Say 'LPDE table scan completed 'Time()
/***************************************************************/
/* Now save the stack to our PLPAMODS data set                 */
/***************************************************************/
dsn2 = 'MS01.CONYERS.PLPAMODS.DATA.WORK'
"ALLOC F(PLPAMODS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOPLPA failed on 'dsn2' error: 'RC
   Exit
   End
Queue
'EXECIO * DISKW PLPAMODS ( FINIS'
Delstack
Say ' '
Say 'Saved 'i' PLPA program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(PLPAMODS)"
Exit
./ ADD LIST=ALL,NAME=IOSVCT
/*REXX*/
/*****************************************************************/
/*  IOSVCT: REXX program to create standard SVC database.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               SCVT - Supervisor Call Vector Table             */
/*               SVCT - SVC Table                                */
/*                                                               */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */
@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */
@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */
@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */
@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct DATE() TIME()
Say ' '
dsn = 'MVS.SVC.SVCTABLE'             /* assign a pseudo data set name */
Newstack
active = 0 ; inactive = 0 ; svcapf = 0 ; svcesr = 0
module = 'IGCERROR' ; Call "#NUCLKUP" module ; igcerror = Result
d = Date() ; t = Time()
Do i = 0 to 255                                 /* loop thru storage  */
   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)
   addr = SUBSTR(bytes,1,4)       /* sloppy code to grab EP in binary */
   bytes = C2X(bytes)          /* legacy code before learning bit ops */
   svcep  = SUBSTR(bytes,1,8)
                                        /* determine storage location */
   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
      inactflag = 0
      If igcerror = Right(D2X(addr),8,0)  /* normalize for match */
         Then Do
            inactive = inactive + 1
            inactflag = 1
         End
         Else active = active + 1
   svctp1 = SUBSTR(bytes,9,1)
      Select
         When svctp1 = '0'
            Then svctype = 'TYPE 1  '
         When svctp1 = '8'
            Then svctype = 'TYPE 2  '
         When svctp1 = 'C'
            Then svctype = 'TYPE 3/4'
         When svctp1 = '2'
            Then svctype = 'TYPE 6  '
      Otherwise
                 svctype = 'TYPE ?  '
      End
   svctp2 = SUBSTR(bytes,10,1)
      svcmisc = '   '
      If svctp2 = '8'
         Then Do
            svcmisc = 'APF'
            svcapf = svcapf + 1
         End
      If svctp2 = '4'
         Then Do
            svcmisc = 'ESR'
            svcesr = svcesr + 1
         End
   If inactflag = 0
      Then Push ' 'LEFT(dsn,44,' '),
                'SVC'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',
                svctype svcep sloc svcmisc d t
End
Say ' '
Say 'There are 'active 'active standard SVCs on this system.'
Say 'Among the active SVCs, 'svcapf 'are APF restricted.'
Say 'There are 'svcesr 'active ESR router SVCs present.'
Say 'The SVCTABLE contains 'inactive 'inactive slots (IGCERROR).'
Say '    (IGCERROR nucleus address = 'igcerror')'
Say ' '
Say 'SVCTABLE processing complete ' Time()
/***************************************************************/
/* Now save the stack to our SVC data set                      */
/***************************************************************/
dsn2 = 'MS01.CONYERS.SVCS.DATA.WORK'
"ALLOC F(SVCS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOSVCT failed on 'dsn2' error: 'RC
   Exit
   End
Queue
'EXECIO * DISKW SVCS ( FINIS'
Delstack
Say ' '
Say 'Saved 'active' SVC program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(SVCS)"
Exit
./ ADD LIST=ALL,NAME=LISTADSP
/* REXX */
/*****************************************************************/
/*LISTADSP: REXX program to display all address space names.     */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               ASVT - Address Space Vector Table               */
/*               ASCB - Address Space Control Block              */
/*               OUCB - SRM User Control Block                   */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */
@cvtasvt  = STORAGE(D2X(X2D(@cvt)+556),4)    /* get CVTASVT address   */
@cvtasvt  = D2X(C2D(@cvtasvt))                 /* binary to dec to hex*/
Address TSO ; "CLEAR"
Say 'CVT: '@cvt 'CVTASVT: '@cvtasvt' ===> Scan on 'DATE()'.  Started: 'TIME()
@asvt = @cvtasvt
asvtmaxu = STORAGE(D2X(X2D(@asvt)+516),4) /* get maxuser (table size) */
Do i = 1 to C2D(asvtmaxu)                  /* initialize name buckets */
   bat.i = ''
   tso.i = ''
   stc.i = ''
End
j = 0 ; k = 0 ; tablend = 524 + (4 * (C2D(asvtmaxu)-1))
b = 0 ; t = 0 ; s = 0 ; inits = 0      /* address space type counters */
Do i = 524 to tablend By 4                      /* loop thru the ASVT */
   j = j + 1                            /* count asvt slots processed */
   @ascb = STORAGE(D2X(X2D(@asvt)+i),4)        /* get address of ASCB */
   If BITAND(LEFT(@ascb,1),'80'x)\='80'x Then Do   /* bit off, in use */
      k = k + 1                                /* count active adrspc */
      ascbasid = STORAGE(D2X(C2D(@ascb)+36),2)            /* get ASID */
      @ascboucb = STORAGE(D2X(C2D(@ascb)+144),4)  /* get OUCB address */
      @ascbjbni = STORAGE(D2X(C2D(@ascb)+172),4)  /* get JOBN address */
      jbni = '        ' ; @ascbjbni = D2X(C2D(@ascbjbni))
      If @ascbjbni \= 0 Then jbni = STORAGE(@ascbjbni,8)
      @ascbjbns = STORAGE(D2X(C2D(@ascb)+176),4)  /* get STCN address */
      jbns = '        ' ; @ascbjbns = D2X(C2D(@ascbjbns))
      If @ascbjbns \= 0 Then jbns = STORAGE(@ascbjbns,8)
      oucbsubn = STORAGE(D2X(C2D(@ascboucb)+176),4)    /* subsys name */
      oucbtrxn = STORAGE(D2X(C2D(@ascboucb)+200),8)    /* transn name */
      oucbusrd = STORAGE(D2X(C2D(@ascboucb)+208),8)         /* userid */
      /* BATCH JOBS */
      If oucbsubn = 'STC ' & jbns = 'INIT    ' Then inits = inits + 1
      If oucbsubn = 'JES2' & jbns = 'INIT    ' & jbni = oucbtrxn Then Do
         inits = inits + 1
         b = b + 1
         bat.b = oucbtrxn
         End
      /* TSO USERS  */
      If oucbsubn = 'TSO ' Then Do
         t = t + 1
         If oucbusrd = '        ' Then tso.t = '????????' /* missing lid */
                                  Else tso.t = oucbusrd
         End
      /* STARTED TASKS */
      If oucbsubn = 'STC ' & oucbtrxn \= 'INIT    ' & jbns \= 'INIT    ' Then Do
         s = s + 1
         stc.s = oucbtrxn
         End
      End
End
Say ' '
Say RIGHT(inits,4,' ')' Initiators defined.  'RIGHT(b,3,' ')' Batch jobs active:'
If b > 0 Then Do i = 1 To b By 8
   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7
   Say '     'bat.c1' 'bat.c2' 'bat.c3' 'bat.c4,
              bat.c5' 'bat.c6' 'bat.c7' 'bat.c8
   End
Say ' '
Say RIGHT(t,4,' ')' TSO sessions:'
If t > 0 Then Do i = 1 To t By 8
   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7
   Say '     'tso.c1' 'tso.c2' 'tso.c3' 'tso.c4,
              tso.c5' 'tso.c6' 'tso.c7' 'tso.c8
   End
Say ' '
Say RIGHT(s,4,' ')' Started tasks:'
If s > 0 Then Do i = 1 To s By 8
   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7
   Say '     'stc.c1' 'stc.c2' 'stc.c3' 'stc.c4,
              stc.c5' 'stc.c6' 'stc.c7' 'stc.c8
   End
Say ' '
Say RIGHT(k,4,' ')' slots in use out of a total 'j' scanned.  Completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTAPFT
/*REXX*/
/*****************************************************************/
/*LISTAPFT: REXX program to display APF table from CSTOR.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*             APFTAB - Undocumented in MVS DATA AREAS book.     */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */
@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */
apfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */
apfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */
@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */
Say 'The CVT  is located at '@cvt '('X2D(@cvt)')'
Say 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'
Say 'The APF table contains 'apfcount 'entries, as follows:'
Say ' '
Do i = 1 to apfcount                            /* loop thru storage  */
   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */
   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */
   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next  */
End
Say 'VOLSER --------------DATA SET NAME-----------------'
Say ' '
Do i = 1 to apfcount                            /* print the list     */
   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i
End
Exit
./ ADD LIST=ALL,NAME=LISTCATS
/*REXX*/
/*****************************************************************/
/*LISTCATS: REXX program to display all open catalogs.           */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              AMCBS - Access Method Control Block Structure    */
/*              CAXWA - Calaog Auxiliary Work Area               */
/*                UCB - Device Unit Control Block                */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */
@cvtcbsp  = STORAGE(D2X(X2D(@cvt)+256),4)      /* get CVTCBSP address */
@cvtcbsp  = D2X(C2D(@cvtcbsp))                /* binary to dec to hex */
@cbscaxcn = STORAGE(D2X(X2D(@cvtcbsp)+20),4)  /* get CBSCAXCN address */
@cbscaxcn = D2X(C2D(@cbscaxcn))               /* binary to dec to hex */
@cbsacb   = STORAGE(D2X(X2D(@cvtcbsp)+8),4)     /* get CBSACB address */
@cbsacb   = D2X(C2D(@cbsacb))                 /* binary to dec to hex */
Address TSO ; "CLEAR"
Say 'CVT: '@cvt' CVTCBSP: '@cvtcbsp' ===> CAXWA chain trace started: 'TIME()
Say ' '
i = 0 ; endofcax = 0 ; @caxchn = @cbscaxcn
Do While endofcax = 0 & i < 500
   i = i + 1
   @caxacb = STORAGE(D2X(X2D(@caxchn)+24),4)   /* catalog acb address */
   @caxacb = D2X(C2D(@caxacb))                /* binary to dec to hex */
   cattype = 'User  ' ; If @caxacb = @cbsacb Then cattype = 'Master'
   @caxucb = STORAGE(D2X(X2D(@caxchn)+28),4)   /* catalog ucb address */
   @caxucb = D2X(C2D(@caxucb))                /* binary to dec to hex */
   caxvol  = STORAGE(D2X(X2D(@caxucb)+28),6)        /* catalog volser */
   caxcnam = STORAGE(D2X(X2D(@caxchn)+52),44)          /* catalog dsn */
   caxflg3 = STORAGE(D2X(X2D(@caxchn)+10),1)             /* cax flags */
   catorg = 'CVOL' ; If BITAND(caxflg3,'20'x)='20'x Then catorg = 'ICF '
   @caxnext = STORAGE(D2X(X2D(@caxchn)+4),4)    /* next caxwa address */
   @caxnext = C2X(@caxnext)                   /* binary to dec to hex */
   If @caxnext = 0 Then endofcax = 1            /* end of chain value */
   Say RIGHT(i,2,' ') cattype catorg caxvol caxcnam
   @caxchn = @caxnext
End
Say ' '
Say 'Last CAXWA after 'i' blocks scanned.  Completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTCONS
/*REXX*/
/*****************************************************************/
/* LISTCONS: REXX program to display system consoles and status. */
/*     Note: Developed and tested on an MVS/SP 2.2.3 system.     */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                UCM - Unit Control Module                      */
/*                UCB - IOS Unit Control Block                   */
/*****************************************************************/
Address TSO ; "CLEAR" ; Numeric Digits 10
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                                /* binary to hex */
@cvtcucb  = STORAGE(D2X(X2D(@cvt)+100),4)      /* get CVTCUCB address */
@cvtcucb  = D2X(C2D(@cvtcucb))                       /* binary to hex */
@ucmvea   = STORAGE(D2X(X2D(@cvtcucb)+72),4)    /* get UCMVEA address */
@ucme     = D2X(C2D(@ucmvea))                        /* binary to hex */
ucmvez    = STORAGE(D2X(X2D(@cvtcucb)+76),4)            /* get UCMVEZ */
ucmelen   = C2D(ucmvez)                              /* binary to dec */
@ucmvel   = STORAGE(D2X(X2D(@cvtcucb)+80),4)    /* get UCMVEL address */
@ucmelast = D2X(C2D(@ucmvel))                        /* binary to hex */
Say 'CVT:'@cvt'  CVTCUCB:'@cvtcucb'  UCMVEA:'@ucme'  'DATE() TIME()
Say ' '
Say 'Consoles  Status    Message Routing'
Say '--------  --------  ------------------------------------------------------'
Say ' '
bit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x
bit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x
Do While @ucme <= @ucmelast             /* loop through the ucme list */
   @ucmucb   = STORAGE(D2X(X2D(@ucme)+12),4)    /* get UCMUCB address */
   @ucmucb   = D2X(C2D(@ucmucb))                     /* binary to hex */
   ucbname   = STORAGE(D2X(X2D(@ucmucb)+13),3)         /* get UCBNAME */
   ucmatr    = STORAGE(D2X(X2D(@ucme)+25),1)            /* get UCMATR */
   ucmid     = STORAGE(D2X(X2D(@ucme)+26),1)             /* get UCMID */
   ucmid     = C2D(ucmid)                            /* binary to dec */
   active    = '' ; routing = ''
   If BITAND(ucmatr,'10'x) = '10'x Then Do /* process active consoles */
      active = '*Active* '
      @ucmfextp = STORAGE(D2X(X2D(@ucme)+72),4)  /* get UCMFEXTP addr */
      @ucmfextp = D2X(C2D(@ucmfextp))                /* binary to hex */
      ucmefrc   = STORAGE(D2X(X2D(@ucmfextp)+24),16)   /* get UCMEFRC */
      /*-------------------process route code data--------------------*/
      Do i = 1 to 16
         byte = SUBSTR(ucmefrc,i,1)
         k = (i-1) * 8
         If BITAND(byte,bit0)=bit0 Then routing = routing k+1
         If BITAND(byte,bit1)=bit1 Then routing = routing k+2
         If BITAND(byte,bit2)=bit2 Then routing = routing k+3
         If BITAND(byte,bit3)=bit3 Then routing = routing k+4
         If BITAND(byte,bit4)=bit4 Then routing = routing k+5
         If BITAND(byte,bit5)=bit5 Then routing = routing k+6
         If BITAND(byte,bit6)=bit6 Then routing = routing k+7
         If BITAND(byte,bit7)=bit7 Then routing = routing k+8
      End
      i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0
      Do While routing \= ''
         i = i + 1
         PARSE VAR routing type.i routing
      End
      If i > 2 Then
         Do k = 1 to i-2
            j = k + 1 ; jj = k + 2
            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'
                                                         Else f.k = ' '
         End
      routing = 'Codes('
      Do k = 1 to i
         If f.k \= '*' Then Do
                               routing = routing''type.k
                               If k \= i Then routing = routing','
                                         Else routing = routing')'
                            End
                       Else Do
                              routing = routing''type.k':'
                              Do While f.k = '*' ; k=k+1 ; End
                            End
      End
      line2 = ''
      If LENGTH(routing) >50 Then
         Do
            Do i = 70 to 1 By -1
               If SUBSTR(routing,i,1) = ',' Then Leave
            End
            line2 = SUBSTR(routing,i+1,60)
            routing = LEFT(routing,i)
         End
      /*--------------------end of route code data--------------------*/
      End
   Say RIGHT(ucmid,2)' ('ucbname')  'active routing
   If line2 \= '' Then Say   '                         'line2
   @ucme = D2X(X2D(@ucme)+ucmelen)               /* bump to next ucme */
End
Say ' '
Say 'Unit Control Module device table scan completed 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTDASD
/*REXX*/
/*****************************************************************/
/*LISTDASD: REXX program to display all online DASD devices.     */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                UCB - Device Unit Control Block                */
/*                DCE - Device Class Extension                   */
/*                VIP - VTOC Information Block                   */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */
@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */
@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/
Address TSO
"CLEAR"
Say 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> DASD chain trace started: 'TIME()
Say ' '
i = 0 ; endofucb = 0 ; j = 0 ; @ucbchn = @cvtucba
pri = 0 ; pub = 0 ; sto = 0 ; smsv = 0
Do While endofucb = 0 & i < 10000
   i = i + 1
   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */
   ucbfl5  = SUBSTR(ucb,2,1)                  /* get flags5 bitstring */
   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */
   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */
   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */
   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */
   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '20'x is DASD */
   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */
   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'20'x)='20'x) Then Do
      j = j + 1; device = ' Unknown'
      ioaddr = C2X(ucbchan)
      If BITAND(ucbfl5,'20'x)\='20'x Then sms = 'Not SMS'
                                     Else Do
                                          sms = 'SMS    '
                                          smsv = smsv + 1
                                          End
      If BITAND(ucbtbyt4,'04'x)='04'x Then device = '9340   '
      If BITAND(ucbtbyt4,'06'x)='06'x Then device = '2305-1 '
      If BITAND(ucbtbyt4,'07'x)='07'x Then device = '2305-2 '
      If BITAND(ucbtbyt4,'08'x)='08'x Then device = '2314   '
      If BITAND(ucbtbyt4,'09'x)='09'x Then device = '3330   '
      If BITAND(ucbtbyt4,'0D'x)='0D'x Then device = '3330-11'
      If BITAND(ucbtbyt4,'0A'x)='0A'x Then device = '3340   '
      If BITAND(ucbtbyt4,'0B'x)='0B'x Then device = '3350   '
      If BITAND(ucbtbyt4,'0C'x)='0C'x Then device = '3375   '
      If BITAND(ucbtbyt4,'85'x)='85'x Then device = '6421   ' /*facom*/
      If BITAND(ucbtbyt4,'0E'x)='0E'x Then device = '3380   '
      If BITAND(ucbtbyt4,'0F'x)='0F'x Then device = '3390   '
      @ucbx   = SUBSTR(ucb,21,4)          /* address of ucb extension */
      @ucbx   = D2X(C2D(@ucbx))               /* binary to dec to hex */
      @dce    = STORAGE(D2X(X2D(@ucbx)+24),4)       /* address of DCE */
      @dce    = D2X(C2D(@dce))                /* binary to dec to hex */
      @vib    = STORAGE(D2X(X2D(@dce)+4),4)         /* address of VIB */
      @vib    = D2X(C2D(@vib))                /* binary to dec to hex */
      vibflags= STORAGE(D2X(X2D(@vib)+6),1)    /* VTOC info flag byte */
      If BITAND(vibflags,'80'x)='80'x Then vtocix = 'VTOCIX'
                                      Else vtocix = '      '
      @vvds   = STORAGE(D2X(X2D(@dce)+8),4)  /* address of VVDS block */
      If C2D(@vvds) = 0 Then vvds = '    '
                        Else vvds = 'VVDS'
      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to DASD segment */
      ucbdasd = STORAGE(@ucbchn,24)       /* get 24 byte DASD segment */
      ucbvoli = SUBSTR(ucbdasd,5,6)              /* volser if mounted */
      ucbstab = SUBSTR(ucbdasd,11,1)         /* mount attribute codes */
      mount = 'Unknown '
      If BITAND(ucbstab,'10'x)='10'x Then Do
         mount = 'Private'
         pri = pri + 1
         End
      If BITAND(ucbstab,'08'x)='08'x Then Do
         mount = 'Public '
         pub = pub + 1
         End
      If BITAND(ucbstab,'04'x)='04'x Then Do
         mount = 'Storage'
         sto = sto + 1
         End
      Say RIGHT(j,3,' ') ucbvoli RIGHT(ioaddr,3) STRIP(device),
          mount vtocix vvds sms
   End
   @ucbchn = D2X(C2D(ucbnxucb))
   If @ucbchn = 0 Then endofucb = 1    /* zero address ends chain */
End
Say ' '
Say 'Summary ===>  Private: 'pri'  Storage: 'sto'  Public: 'pub'  SMS: 'smsv
Say ' '
Say 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTDCQ
/*REXX*/
/*****************************************************************/
/* LISTDCQ: REXX program to display the device class queue.      */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                DCQ - Device Class Queue                       */
/*                UCB - Device Unit Control Block                */
/*                                                               */
/*                                                               */
/*****************************************************************/
Address TSO ; "CLEAR" ; Numeric Digits 10
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                                /* binary to hex */
@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */
@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */
Say 'CVT:'@cvt' CVTDCQA:'@cvtdcqa' ==> Device Class Queue 'DATE() TIME()
Say ' '
dcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */
dcqname  = SUBSTR(dcq,1,4)                          /* dcq eyecatcher */
dcqlngth = SUBSTR(dcq,5,2)                /* length of each dcq entry */
dcqcount = SUBSTR(dcq,7,2)                      /* number of elements */
dcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */
dcqdstct = SUBSTR(dcq,13,4)    /* entries in device class stats table */
dcqucbno = SUBSTR(dcq,17,4) /* number of ucb's this I/O configuration */
@dcqchn  = C2X(dcqfirst) ; i = 0
Say ' This I/O configuration has defined -     UCBs: 'C2D(dcqucbno)
Say '                                         DCQEs: 'C2D(dcqcount)
Say '                                       1stDCQE: '@dcqchn
Say ' '
Say '      Name____  ID_   UCBs   1stUCB__   Active   Inactive  ID=UCB'
Say ' '
Do While @dcqchn \= 0 & i < 10000
   i = i + 1
   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */
   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */
   @dcqchn  = D2X(C2D(dcqchain))
   dcqdevcl = SUBSTR(dcqelmnt,5,1)     /* device class, i.e. UCBTBYT3 */
   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */
   dcqucbct = C2D(dcqucbct)
   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */
   dcqucbad = C2X(dcqucbad) ; @ucbchn = dcqucbad
   active = 0 ; inactive = 0 ; check = 0
   Do j = 1 to dcqucbct           /* scan ucb chain this device class */
      If @ucbchn = 0 Then Leave
      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */
      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */
      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */
      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */
      If BITAND(ucbstat,'80'x)='80'x Then active = active + 1
                                     Else inactive = inactive + 1
      If BITAND(ucbtbyt3,dcqdevcl)=dcqdevcl Then check = check + 1
      @ucbchn = C2X(ucbnxucb)
   End
   ok = 'ERROR ' ; If check = dcqucbct Then ok = '*okay*'
   dcqdevnm = SUBSTR(dcqelmnt,13,8)              /* device class name */
   If dcqucbad = '00000000' & dcqucbct = 0 Then Do
      dcqucbad = '        '
      active   = '    '
      inactive = '    '
      ok       = '      '
   End
   Say RIGHT(i,3)'   'dcqdevnm'  'C2X(dcqdevcl)'x',
       '  'RIGHT(dcqucbct,4)'   'dcqucbad,
       '   'RIGHT(active,4)'      'RIGHT(inactive,4)'    'ok
End
Say ' '
Say 'Device Class Queue scan completed 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTENV
/*REXX*/
/*****************************************************************/
/* LISTENV: REXX program to display system environment data.     */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              JESCT - JES Control Table                        */
/*             PCCAVT - Phys. Config. Comm. Area Vector Table    */
/*               PCCA - Physical Config. Communications Area     */
/*               TSVT - TSO Vector Table                         */
/*               MQCT - HSM CVT                                  */
/*                RCE - RSM Control and Enumeration Area         */
/*                PSA - Prefixed Saved Area (CVT & PSAATCVT)     */
/*              ASMVT - ASM Vector Table                         */
/*                DCQ - Device Class Queue                       */
/*                UCB - Device Unit Control Block                */
/*****************************************************************/
Address TSO ; "CLEAR" ; Numeric Digits 10
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                                /* binary to hex */
@cvtprodn = D2X(X2D(@cvt)-40)                 /* get CVTPRODN address */
mvssplvl  = STORAGE(@cvtprodn,8)                      /* get SP level */
@cvtprodi = D2X(X2D(@cvt)-32)                 /* get CVTPRODI address */
mvsfmid   = STORAGE(@cvtprodi,8)                          /* get FMID */
@cvtmdl   = D2X(X2D(@cvt)-6)                    /* get CVTMDL address */
cpumodel  = STORAGE(@cvtmdl,2)                           /* get MODEL */
cpumodel  = C2X(cpumodel)
@cvtsysad = STORAGE(D2X(X2D(@cvt)+48),4)      /* get CVTSYSAD address */
@cvtsysad = D2X(C2D(@cvtsysad))                      /* binary to hex */
sysresucb = STORAGE(@cvtsysad,48)                          /* get UCB */
ucbchan   = SUBSTR(sysresucb,5,2)
ucbchan   = SUBSTR(C2X(ucbchan),2)
ucbvoli   = SUBSTR(sysresucb,29,6)
@cvttvt   = STORAGE(D2X(X2D(@cvt)+156),4)       /* get CVTTVT address */
@cvttvt   = D2X(C2D(@cvttvt))                        /* binary to hex */
tsvtlver  = STORAGE(D2X(X2D(@cvttvt)+100),1)          /* get TSVTLVER */
tsvtlrel  = STORAGE(D2X(X2D(@cvttvt)+101),2)          /* get TSVTLREL */
tsvtlmod  = STORAGE(D2X(X2D(@cvttvt)+103),1)          /* get TSVTLMOD */
  tsoe = tsvtlver'.'tsvtlrel'.'tsvtlmod
@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)              /* get CVTMZ00 */
@cvtmz00  = D2X(C2D(@cvtmz00))                       /* binary to hex */
  eovm  = ((X2D(@cvtmz00)+1)/1048576)'M'
@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */
@cvtjesct = D2X(C2D(@cvtjesct))                      /* binary to hex */
  jes     = STORAGE(D2X(X2D(@cvtjesct)+28),4)         /* get JES name */
@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)      /* get CVTEORM address */
@cvteorm  = D2X(C2D(@cvteorm))                       /* binary to hex */
  cstor = ((X2D(@cvteorm)+1)/1048576)'M'             /* convert to MB */
@cvtext2  = STORAGE(D2X(X2D(@cvt)+328),4)      /* get CVTEXT2 address */
@cvtext2  = D2X(C2D(@cvtext2))                       /* binary to hex */
cvtnucls  = STORAGE(D2X(X2D(@cvtext2)+4),1)   /* get selected nucleus */
@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */
@cvtasmvt = D2X(C2D(@cvtasmvt))                      /* binary to hex */
asmflag2  = STORAGE(D2X(X2D(@cvtasmvt)+1),1)
  clpa = '(NO CLPA)'
  If BITAND(asmflag2,'08'x) \= '08'x Then clpa = '(CLPA)'
@cvtpccat = STORAGE(D2X(X2D(@cvt)+764),4)     /* get CVTPCCAT address */
@cvtpccat = D2X(C2D(@cvtpccat))                      /* binary to hex */
@cvtrlstg = STORAGE(D2X(X2D(@cvt)+856),4)       /* get CVTRLSTG bytes */
@cvtrlstg = C2D(@cvtrlstg)                           /* binary to dec */
  cstorol = ((@cvtrlstg)/1024)'M'                    /* convert to MB */
@cvthsm   = STORAGE(D2X(X2D(@cvt)+988),4)       /* get CVTHSM address */
@cvthsm   = D2X(C2D(@cvthsm))                        /* binary to hex */
mqctver   = STORAGE(D2X(X2D(@cvthsm)+48),2)            /* get MQCTVER */
mqctrel   = STORAGE(D2X(X2D(@cvthsm)+50),1)            /* get MQCTREL */
mqctmod   = STORAGE(D2X(X2D(@cvthsm)+51),1)            /* get MQCTMOD */
  hsm  = mqctver'.'mqctrel'.'mqctmod
@cvtdfa   = STORAGE(D2X(X2D(@cvt)+1216),4)      /* get CVTDFA address */
@cvtdfa   = D2X(C2D(@cvtdfa))                        /* binary to hex */
dfadata   = STORAGE(@cvtdfa,4)                  /* get DFP level data */
dfadata   = C2X(dfadata)
dfaver    = SUBSTR(dfadata,5,1)                    /* get DFP version */
dfarel    = SUBSTR(dfadata,6,1)                    /* get DFP release */
dfamod    = SUBSTR(dfadata,7,1)                    /* get DFP mod lvl */
  dfp  = dfaver'.'dfarel'.'dfamod
@cvtrcep  = STORAGE(D2X(X2D(@cvt)+1168),4)     /* get CVTRCEP address */
@cvtrcep  = D2X(C2D(@cvtrcep))                       /* binary to hex */
rceespl   = STORAGE(D2X(X2D(@cvtrcep)+160),4)  /* get RCEESPL frames  */
  estor = ((C2D(rceespl)*4096)/1048576)'M'           /* convert to MB */
@psaatcvt = STORAGE(408,4)             /* get VTAM ATCVT from PSAAOLD */
@psaatcvt = D2X(C2D(@psaatcvt))                      /* binary to hex */
atcvtdata = STORAGE(@psaatcvt,4)               /* get VTAM level data */
atcvtdata = C2X(atcvtdata)
atcvtver  = SUBSTR(atcvtdata,6,1)                 /* get VTAM version */
atcvtrel  = SUBSTR(atcvtdata,8,1)                 /* get VTAM release */
  vtam = atcvtver'.'atcvtrel
Say 'CVT:'@cvt'   SYSTEM ENVIRONMENT DATA on 'DATE() TIME()
Say ' '
Say '   Software -   MVS: 'mvssplvl' ('STRIP(mvsfmid)')    JES: 'jes
Say '                DFP: 'dfp'               TSO/E: 'tsoe
Say '               VTAM: 'vtam'                   HSM:'hsm
Say '                IPL: 'ucbvoli' @ 'ucbchan'      Nucleus: 'cvtnucls'  'clpa
Say ' '
Say '  Processor - Model: 'cpumodel
Say '              CSTOR: 'cstor'   ('cstorol' on-line)    ESTOR: 'estor
Say '              VSTOR: 'eovm'  (Highest virtual address '@cvtmz00'/'X2D(@cvtmz00)')'
Do i = 0 to 15                                 /* loop thru CPU table */
   @pcca = STORAGE(D2X(X2D(@cvtpccat)+(i*4)),4)
   @pcca = C2X(@pcca)
   If @pcca \= 0 Then Do
      Say '                CPU: 'RIGHT(i,2,0),
          '    ('STORAGE(D2X(X2D(@pcca)+4),8)')'
      End
   End
@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */
@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */
dcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */
dcqcount = SUBSTR(dcq,7,2)                      /* number of elements */
dcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */
@dcqchn  = C2X(dcqfirst) ; i = 0
Say ' '
Say '        I/O - Device     UCBs  Active  ID=UCB'
Say '              --------   ----  ------  ------'
Do While @dcqchn \= 0 & i < 100
   i = i + 1
   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */
   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */
   @dcqchn  = D2X(C2D(dcqchain))
   dcqdevcl = SUBSTR(dcqelmnt,5,1)     /* device class, i.e. UCBTBYT3 */
   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */
   dcqucbct = C2D(dcqucbct)
   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */
   dcqucbad = C2X(dcqucbad) ; @ucbchn = dcqucbad
   active = 0 ; check = 0
   Do j = 1 to dcqucbct           /* scan ucb chain this device class */
      If @ucbchn = 0 Then Leave
      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */
      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */
      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */
      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */
      If BITAND(ucbstat,'80'x)='80'x Then active = active + 1
      If BITAND(ucbtbyt3,dcqdevcl)=dcqdevcl Then check = check + 1
      @ucbchn = C2X(ucbnxucb)
   End
   ok = 'ERROR ' ; If check = dcqucbct Then ok = '*okay*'
   dcqdevnm = SUBSTR(dcqelmnt,13,8)              /* device class name */
   If dcqucbad = '00000000' & dcqucbct = 0 Then Do
      active   = '    '
      ok       = '      '
   End
   Say '              'dcqdevnm,
       '  'RIGHT(dcqucbct,4),
       '  'RIGHT(active,4)'   'ok
End
Exit
./ ADD LIST=ALL,NAME=LISTESRT
/*REXX*/
/*****************************************************************/
/*LISTESRT: REXX program to display all router SVCs.             */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               SCVT - Supervisor Call Vector Table             */
/*                                                               */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */
@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */
@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */
@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */
@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct' 'DATE() TIME()
Say ' '
Say 'Active ESR SVCs follow:'
Say ' '
active = 0 ; inactive = 0 ; esrsvc = 0
module = 'IGXERROR' ; Call "#NUCLKUP" module ; igxerror = Result
Do i = 0 to 255                                 /* loop thru storage  */
   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)
   bytes = C2X(bytes)
   svcep  = SUBSTR(bytes,1,8)
   svctp2 = SUBSTR(bytes,10,1)
   If svctp2 = '4'            /* EP address is an ESR table */
      Then Do
         esrid = STORAGE(svcep,4)                 /* table eyecatcher */
         esrct = C2X(STORAGE(D2X(X2D(svcep)+4),4))       /* esr count */
         Say 'SVC 'i' is 'esrid'.  Table at 'svcep', Slots 'X2D(esrct)' ('esrct')'
         Say ' '
         esrsvc = 0
         Do j = 0 to X2D(esrct)                   /* process this ESR */
            bytes = STORAGE(D2X(X2D(svcep)+(j*8)+8),8)
   addr = SUBSTR(bytes,1,4)       /* sloppy code to grap EP in binary */
   bytes = C2X(bytes)          /* legacy code before learning bit ops */
            esrep  = SUBSTR(bytes,1,8)
                                        /* determine storage location */
   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
            esrtp2 = SUBSTR(bytes,10,1)
            esrmisc = '   '
            If esrtp2 = '8'
               Then esrmisc = 'APF'
            inactflag = 0
            If igxerror = Right(D2X(addr),8,0) /* normalize address */
               Then inactflag = 1
               Else Do
                       active = active + 1
                       esrsvc = esrsvc + 1
                    End
            esrtp1 = SUBSTR(bytes,9,1)
               Select
                  When esrtp1 = '0'
                     Then esrtype = 'TYPE 1  '
                  When esrtp1 = '8'
                     Then esrtype = 'TYPE 2  '
                  When esrtp1 = 'C'
                     Then esrtype = 'TYPE 3/4'
                  When esrtp1 = '2'
                     Then esrtype = 'TYPE 6  '
               Otherwise
                          esrtype = 'TYPE ?  '
               End
            If inactflag = 0
               Then Say  '   ESR 'RIGHT(j,3,0) '('RIGHT(D2X(j),2,0)')',
                          esrtype esrep sloc esrmisc
         End
         Say ' '
         Say '     Total ESR SVCs this table 'esrsvc
         Say ' '
         Say ' '
      End
End
Say ' '
Say 'This system contains 'active' ESR SVCs'
Say ' '
Say '  (IGXERROR nucleus address = 'igxerror')'
Say ' '
Say 'ESRTABLE processing complete ' TIME()
Say ' '
Exit
./ ADD LIST=ALL,NAME=LISTLLT
/*REXX*/
/*****************************************************************/
/* LISTLLT: REXX program to display Linklist Lookaside Table.    */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                LLT - Linklist Lookaside Table                 */
/*               DCB3 - Data Control Block (BDAM)                */
/*                DEB - IOS Data Extent Block                    */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtlink  = STORAGE(D2X(X2D(@cvt)+8),4)      /* get CVTLINK address   */
@cvtlink  = D2X(C2D(@cvtlink))                 /* binary to hex       */
@dcbdebad = STORAGE(D2X(X2D(@cvtlink)+44),4)    /* LINKLIB DCB to DEB */
@dcbdebad = D2X(C2D(@dcbdebad))                 /* convert to hex     */
debflgs1  = STORAGE(D2X(X2D(@dcbdebad)+14),1)     /* LINKLIB DEBflags */
   debapfin = 'LNKLST'
   If BITAND(debflgs1,'02'x)\='02'x Then debapfin = 'APFTAB'
@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)   /* get CVTLLTA address   */
@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */
lltcount  = C2D(STORAGE(D2X(X2D(@cvtllta)+7),1))  /* LLT libraries    */
lltllen   = C2D(STORAGE(D2X(X2D(@cvtllta)+8),1))  /* length 1st entry */
@lltentry = X2D(@cvtllta)+9           /* address of 1st LLT entry     */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,
    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin
Say ' '
Say 'LLT scan on 'DATE()' started: 'TIME()
Say ' '
Do i = 1 to lltcount                            /* loop thru storage  */
   lltlib.i = STORAGE(D2X(@lltentry),lltllen)   /* get the LLT entry  */
   @lltentry = @lltentry + 45                   /* bump to next entry */
   lltllen = C2D(STORAGE(D2X(@lltentry-1),1))   /* length of next  */
End
Say '--------------DATA SET NAME-----------------'
Say ' '
Do i = 1 to lltcount                            /* print the list     */
   Say SUBSTR(lltlib.i,1,44,' ') i
End
Say ' '
Say 'LLT scan completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTLPAQ
/*REXX*/
/*****************************************************************/
/*LISTLPAQ: REXX program to display LPA Queue (MVS job pack).    */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                GDA - Global Data Area                         */
/*               LPAQ - Link Pack Area Queue                     */
/*                CDE - Contents Directory Entry                 */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtqlpaq = STORAGE(D2X(X2D(@cvt)+188),4)    /* get CVTqlpaq address  */
@cvtqlpaq = D2X(C2D(@cvtqlpaq))                /* binary to hex       */
@lpaqptr  = STORAGE(@cvtqlpaq,4)             /* get pointer to LPAQ   */
@lpaqptr  = D2X(C2D(@lpaqptr))                 /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTQLPAQ:'@cvtqlpaq' LPAQPTR:'@lpaqptr' 'DATE() TIME()
@cdechn = @lpaqptr
Say ' '
i = 0
Do While @cdechn \= '00000000'
   i = i + 1
   cde = STORAGE(@cdechn,32)                          /* get the cde */
   cdname = SUBSTR(cde,9,8)
   cdentpt= SUBSTR(cde,17,4)
                                        /* determine storage location */
   addr = BITAND(cdentpt,'7FFFFFFF'x)     /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
   cdxlmjp= C2X(SUBSTR(cde,21,4))
   cduse  = C2D(SUBSTR(cde,25,2))
   cdattr =     SUBSTR(cde,29,1)  /* do NOT convert raw byte */
   alias = 0 ; If (BITAND(cdattr,'04'x)='04'x) Then alias = 1
   cdattr2=     SUBSTR(cde,30,1)  /* do NOT convert raw byte */
   auth = 0 ; If (BITAND(cdattr2,'01'x)='01'x) Then auth = 1
   cdemjp  = '         '
   cdemjnm = '        '
   If alias = 1 Then Do
                        cdemjp  = ' Alias of'
                        cdemjnm = STORAGE(D2X(X2D(cdxlmjp)+8),8)
                     End
   Say 'LPAQ'RIGHT(i,4,0),
       cdname ,
       C2X(cdentpt) ,
       sloc ,
       'USE:'RIGHT(cduse,5,0) ,
        'AC:'auth ,
        cdemjp cdemjnm
   @cdechn = C2X(LEFT(cde,4))                 /* get next cde address */
End
Say ' '
Say 'End of LPA Queue scan ' TIME()
Exit
./ ADD LIST=ALL,NAME=LISTLPAT
/*REXX*/
/*****************************************************************/
/*LISTLPAT: REXX program to display LPA libraries.               */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               LPAT - Link Pack Area (libraries) Table         */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */
@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */
@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */
lpatcount = C2D(STORAGE(D2X(X2D(@cvteplps)+4),4)) /* LPAT entries     */
lpatlen   = C2D(STORAGE(D2X(X2D(@cvteplps)+8),1)) /* length 1st entry */
@lpatentry= X2D(@cvteplps)+9          /* address of 1st LPAT entry    */
Say 'CVT:'@cvt  'CVTSMEXT:'@cvtsmext'  CVTEPLPS:'@cvteplps,
    '  'DATE() TIME()
Say ' '
Say 'The LPAT table contains 'lpatcount 'entries, as follows:'
Say ' '
Do i = 1 to lpatcount                           /* loop thru storage  */
   lpatlib.i = STORAGE(D2X(@lpatentry),lpatlen) /* get the LLT entry  */
   @lpatentry = @lpatentry + 45                 /* bump to next entry */
   lpatlen = C2D(STORAGE(D2X(@lpatentry-1),1))  /* length of next     */
End
Say '--------------DATA SET NAME-----------------'
Say ' '
Do i = 1 to lpatcount                           /* print the list     */
   Say SUBSTR(lpatlib.i,1,44,' ') i
End
Exit
./ ADD LIST=ALL,NAME=LISTNUCM
/*REXX*/
/*****************************************************************/
/*LISTNUCM: REXX program to display the nucleus map.             */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */
/*                                                               */
/*****************************************************************/
Numeric Digits 10
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */
@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */
nucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */
nucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */
nucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */
@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */
Address TSO ; 'CLEAR'
Say 'CVT:'@cvt  'CVTNUCMP:'@cvtnucmp'  NUCMLEN:'nucmlen' bytes',
    '  'DATE() TIME()
Say ' '
If nucmapid \= 'NUCMAP  ' Then Do
   Say 'Error: Nucleus map table eyecatcher not found'
   Exit
   End
i = 0
Say 'The Nucleus Map table follows:'
Say ' '
Do While @nucmentry <= nucmeot                  /* loop thru storage  */
   i = i + 1
   epname.i = STORAGE(D2X(@nucmentry),8)      /* get entry point name */
   epaddr.i = C2X(STORAGE(D2X(@nucmentry+8),4))     /* get ep address */
   epflag.i = STORAGE(D2X(@nucmentry+12),1)      /* get raw flag byte */
   eplen.i  = C2X(STORAGE(D2X(@nucmentry+13),3))     /* get ep length */
   @nucmentry = @nucmentry + 16                 /* bump to next entry */
End
entries = i
/*--------------------------------------------------------------*/
/* epflag byte structure:                                       */
/*                                                              */
/*           XXXX XXXX --> epflag byte                          */
/*           |||| ||||                                          */
/*           |||| ||++---- AMODE 00/01=24, 10=31, 11=ANY        */
/*           |||| |+------ RMODE 0=24, 1=ANY                    */
/*           |||| +------- RSECT 1=yes                          */
/*           |||+--------- CSECT 1=yes                          */
/*           +++---------- unused                               */
/*--------------------------------------------------------------*/
Say 'Entry --Name-- -EPaddr- CSECT RSECT RMODE AMODE Length'
Say ' '
Do i = 1 to entries                             /* print the list     */
   csect = '     ' ; rsect = '     ' ; rmode = '  24 ' ; amode = '  24 '
   If BITAND(epflag.i,'10'x)='10'x Then csect = '  Y  '
   If BITAND(epflag.i,'08'x)='08'x Then rsect = '  Y  ' /* read only  */
   If BITAND(epflag.i,'04'x)='04'x Then rmode = ' Any ' /* residency  */
   If BITAND(epflag.i,'02'x)='02'x Then amode = '  31 ' /* addressing */
   If BITAND(epflag.i,'03'x)='03'x Then amode = ' Any ' /* addressing */
   Say ' 'Right(i,4,0) epname.i epaddr.i csect rsect rmode amode eplen.i
End
Exit
./ ADD LIST=ALL,NAME=LISTPART
/*REXX*/
/*****************************************************************/
/*LISTPART: REXX program to show ASM paging data set status.     */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              ASMVT - ASM Vector Table                         */
/*               PART - ASM Paging Activity Reference Table      */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */
@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */
@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */
@asmpart  = STORAGE(D2X(X2D(@asmvt)+8),4)         /* get PART address */
@part     = RIGHT(C2X(@asmpart),7)                    /* trim address */
partsize  = STORAGE(D2X(X2D(@part)+4),4)      /* get number of PART's */
partsize  = C2D(partsize)                            /* binary to dec */
@partdsnl = STORAGE(D2X(X2D(@part)+24),4)     /* get dsn list address */
@partdsnl = RIGHT(C2X(@partdsnl),7)                   /* trim address */
partlcnt  = STORAGE(D2X(X2D(@part)+32),2)     /* get number of locals */
partlcnt  = C2D(partlcnt)                            /* binary to dec */
@partplpa = STORAGE(D2X(X2D(@part)+48),4)      /* get plpa part entry */
@partplpa = RIGHT(C2X(@partplpa),7)                   /* trim address */
@partloca = STORAGE(D2X(X2D(@part)+52),4)      /* get 1st local entry */
@partloca = RIGHT(C2X(@partloca),7)                   /* trim address */
@partlsta = STORAGE(D2X(X2D(@part)+56),4)      /* get last locl entry */
@partlsta = RIGHT(C2X(@partlsta),7)                   /* trim address */
@partents  = STORAGE(D2X(X2D(@part)+80),4)      /* get 1st part entry */
@partents = RIGHT(C2X(@partents),7)                   /* trim address */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMPART:'@part'   'TIME() DATE()
Say ' '
Say 'The PART table starts at '@partplpa' and contains 'partsize' entries.'
Say ' '
p = 0 ; i = 0 ; @partix = @partplpa ; @dsnl = @partdsnl
Do p = 1 To partsize                           /* scan the PART table */
   pareflg1 = STORAGE(D2X(X2D(@partix)+9),1)         /* get flag byte */
   If BITAND(pareflg1,'80'x) \= '80'x Then Do  /* process in use only */
      i = i + 1                              /* count active pageds's */
      pagedsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */
      paretype = STORAGE(D2X(X2D(@partix)+8),1)      /* get type byte */
      ptype = '??????'
      If BITAND(paretype,'80'x) = '80'x Then ptype = 'PLPA  '
      If BITAND(paretype,'40'x) = '40'x Then ptype = 'Common'
      If BITAND(paretype,'20'x) = '20'x Then ptype = 'Duplex'
      If BITAND(paretype,'10'x) = '10'x Then ptype = 'Local '
      pareszsl = STORAGE(D2X(X2D(@partix)+16),4) /* get size in slots */
      pareszsl = C2D(pareszsl)
      pareslta = STORAGE(D2X(X2D(@partix)+20),4)   /* slots available */
      pareslta = C2D(pareslta) ; used = pareszsl - pareslta
      pctused  = TRUNC((used*100)/pareszsl,0)
      pctused  ='('RIGHT(pctused,3)'%)'
      @pareucbp = STORAGE(D2X(X2D(@partix)+44),4)  /* get UCB address */
      pioaddr  = STORAGE(D2X(C2D(@pareucbp)+4),2)  /* channel address */
      pioaddr  = RIGHT(C2X(pioaddr),3)
      pvolser  = STORAGE(D2X(C2D(@pareucbp)+28),6)     /* dasd volser */
      Say RIGHT(i,2) pagedsn ptype RIGHT(pareszsl,5) pctused pvolser pioaddr
   End
   @partix = D2X(X2D(@partix)+96)          /* bump to next PART entry */
   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */
End
Say ' '
Say 'Paging activity table analysis completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTPDSD
/*REXX*/
/*****************************************************************/
/*LISTPDSD: REXX program to display PDS directory records.       */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                 -none-                                        */
/*                                                               */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
Address TSO
dsn = 'SYS1.SORTLIB'                    /* Fake out DCB of PO */
"ALLOC F(PDS) DA('"dsn"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)"
Newstack
'EXECIO * DISKR PDS ( FINIS'
Queue '*EOF*'
i = 0
Do While i < 10
   i = i + 1
   Pull line
   If LEFT(line,5) = '*EOF*' Then Leave
   dirblock = C2X(line)
   blocklen = X2D(C2X(SUBSTR(line,1,2)))
   If blocklen = 0 Then Leave
   Say 'DIRBLOCK No. 'i'  RC = 'RC,
       ' DIRBLOCK Length = 'LENGTH(line)'  DIRDATA length = 'blocklen
   Say ' '
   Say 'Data: 'SUBSTR(dirblock,001,60)' *'SUBSTR(line,001,30)'*'
   Say '      'SUBSTR(dirblock,061,60)' *'SUBSTR(line,031,30)'*'
   Say '      'SUBSTR(dirblock,121,60)' *'SUBSTR(line,061,30)'*'
   Say '      'SUBSTR(dirblock,181,60)' *'SUBSTR(line,091,30)'*'
   Say '      'SUBSTR(dirblock,241,60)' *'SUBSTR(line,121,30)'*'
   Say '      'SUBSTR(dirblock,301,60)' *'SUBSTR(line,151,30)'*'
   Say '      'SUBSTR(dirblock,361,60)' *'SUBSTR(line,181,30)'*'
   Say '      'SUBSTR(dirblock,421,60)' *'SUBSTR(line,211,30)'*'
   Say '      'SUBSTR(dirblock,481,32),
       '                          ',
       ' *'SUBSTR(line,241,16),
       '             *'
   Say ' '
   Say 'Linear block dump follows:'
   Say ' '
   y = 0
   Do y = 1 to 256
      Say '   DIRBLOCK byte 'RIGHT(y,3,0),
          ' Char:'SUBSTR(line,y,1),
          ' Hex:'C2X(SUBSTR(line,y,1)),
          ' Dec:'C2D(SUBSTR(line,y,1))
   End
   Say ' '
End
Delstack
"FREE F(PDS)"
Exit
./ ADD LIST=ALL,NAME=LISTPDSM
/*REXX*/
/*****************************************************************/
/*LISTPDSM: REXX program to display all PDS member information.  */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                PDS - Partitioned Data Set (entry)             */
/*                                                               */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
Address TSO
dsn = 'SYS2.LINKLIB'                    /* Fake out DCB of PO */
"ALLOC F(PDS) DA('"dsn"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)"
Newstack
'EXECIO * DISKR PDS ( FINIS'
Queue '*EOF*'
i = 0
last = 0     /* flags when the no more members indicator is detected */
memcount = 0
Say 'Date: 'DATE()' PDS: 'dsn
Do While i < 1000 & last \= 1  /* had to pick some limit */
   i = i + 1
   Pull line
   If LEFT(line,5) = '*EOF*' Then Leave
   blocklen = X2D(C2X(SUBSTR(line,1,2)))  /* Not proud of this logic, */
   If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */
   ix = 3                          /* Initialize DIRBLOCK parse index */
   Do While ix < blocklen & last \= 1          /* parse this DIRBLOCK */
      pds2ftb1 = '00'x                         /* initialize apf not  */
      pds2mnm  = '        '                    /* initialize alias of */
      pds2name = SUBSTR(line,ix,8)  ; ix = ix + 8     /* main section */
      pds2ttrp = SUBSTR(line,ix,3)  ; ix = ix + 3
      pds2indc = SUBSTR(line,ix,1)  ; ix = ix + 1
      udl = 0                           /* calculate user data length */
      If BITAND(pds2indc,'01'x) = '01'x Then udl = 1
      If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2
      If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4
      If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8
      If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16
      udl = udl * 2                 /* finish calc halfwords to bytes */
      If udl >= 22 Then Do               /* only process likely stuff */
         ix = ix + 8             /* adjust index to skip misc 8 bytes */
         pds2atr1 = SUBSTR(line,ix,1) ; ix = ix + 1
         pds2atr2 = SUBSTR(line,ix,1) ; ix = ix + 1
         pds2stor = SUBSTR(line,ix,3) ; ix = ix + 3
         ix = ix + 2             /* adjust index to skip misc 2 bytes */
         pds2epa  = SUBSTR(line,ix,3) ; ix = ix + 3
         pds2ftb1 = SUBSTR(line,ix,1) ; ix = ix + 1
         ix = ix + 2             /* adjust index to skip misc 2 bytes */
                                                      /* scatter sect */
         If BITAND(pds2atr1,'04'x) = '04'x Then Do
            pds2scat = SUBSTR(line,ix+33,8)
            ix = ix + 8
            End
                                                        /* alias sect */
         If BITAND(pds2indc,'80'x) = '80'x Then Do
            If udl >= 32 Then Do
               pds2epm  = SUBSTR(line,ix,3) ; ix = ix + 3
               pds2mnm  = SUBSTR(line,ix,8) ; ix = ix + 8
               End
            Else Do
               Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i
               pds2epm = '000000'x
               pds2mnm = '????????'
               End
            End
                                                       /* ssi section */
         If BITAND(pds2ftb1,'10'x) = '10'x Then Do
            If (ix-1)//2 \= 0 Then ix = ix + 1    /* halfword alignmt */
            pdsssiwd = SUBSTR(line,ix,4) ; ix = ix + 4
            End
                                                       /* apf section */
         If BITAND(pds2ftb1,'08'x) \= '08'x Then pdsapfac = ' '/* none*/
         Else Do                                         /* maybe apf */
            pdsapfct = SUBSTR(line,ix,1)
            If pdsapfct = '01'x Then Do                /* NORMAL path */
               ix = ix + 1
               pdsapfac = SUBSTR(line,ix,1)
               ix = ix + 1
               If pdsapfac \= '00'x & pdsapfac \= '01'x Then Do
                  Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i
                  nop
                  End
               End
            If pdsapfct \= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do
               pdsapfac=' '
               ix = ix - 8
               Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i
               End
            End
         End
      Else Do                              /* too short udl, leave it */
         ix = ix + udl
         If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
            last = 1
            Leave
            End
         Say '*** WARNING - too short udl for 'pds2name' DBLK:'i
         pds2atr1 = '00'x
         pds2atr2 = '00'x
         pds2stor = '000000'x
         pds2mnm  = '        '
         pdsapfac = ' '
         End
      If (ix-1)//2 \= 0 Then ix = ix + 1          /* halfword alignmt */
      If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
         last = 1
         Leave
         End
      If pds2name \= '0000000000000000'x Then Do
         memcount = memcount + 1
         Say RIGHT(memcount,4,0) pds2name' TTR:'C2X(pds2ttrp),
             ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),
             C2X(pds2atr2)' SIZE:'C2X(pds2stor),
             ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),
             ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),
             ' IX:'RIGHT(ix,3,0)
         End
   End                                         /* DIRBLOCK parse done */
End
Delstack
"FREE F(PDS)"
Exit
./ ADD LIST=ALL,NAME=LISTPLPA
/*REXX*/
/*****************************************************************/
/*LISTPLPA: REXX program to display PLPA directory table.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                GDA - Global Data Area                         */
/*               LPDE - Link Pack Directory Entry                */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtlpdir = STORAGE(D2X(X2D(@cvt)+361),3)    /* get CVTLPDIR address  */
@cvtlpdir = D2X(C2D(@cvtlpdir))                /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTLPDIR:'@cvtlpdir'  'DATE() TIME()
@lpdechn = @cvtlpdir
Say ' '
i = 0 ; eot = '00000000000000000000000000000000'
Do While i < 10000                                 /* arbitrary limit */
   lpde = STORAGE(@lpdechn,40)                        /* get the lpde */
   If C2X(SUBSTR(lpde,1,16))=eot Then Leave           /* end of table */
   i = i + 1
   module = SUBSTR(lpde,9,8)
   entry  = SUBSTR(lpde,17,4)
                                        /* determine storage location */
   addr = BITAND(entry,'7FFFFFFF'x)       /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
   size   = C2X(SUBSTR(lpde,33,4))
   att2   =     SUBSTR(lpde,30,1)
   auth = 0 ; If (BITAND(att2,'01'x)='01'x) Then auth = 1
   lpdemjp  = '         '
   lpdemjnm = '        '
   If C2D(SUBSTR(lpde,21,4)) \= 0 Then
      Do
         lpdemjp  = ' Alias of'
         lpdemjnm = SUBSTR(lpde,33,8)
             size = '        '
      End
   Say 'PLPA'RIGHT(i,4,0) ,
       module ,
       C2X(entry) ,
       sloc ,
       'SIZE:'RIGHT(size,8,0) ,
       'AC:'auth ,
       lpdemjp lpdemjnm
   @lpdechn = D2X(X2D(@lpdechn)+40)         /* address of next LPDE */
End
Say ' '
Say 'LPDE table scan completed 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTSART
/*REXX*/
/*****************************************************************/
/*LISTSART: REXX program to show ASM swapping data set status.   */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              ASMVT - ASM Vector Table                         */
/*               SART - ASM Swapping Activity Reference Table    */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */
@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */
@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */
@asmsart  = STORAGE(D2X(X2D(@asmvt)+4),4)         /* get SART address */
@sart     = RIGHT(C2X(@asmsart),7)                    /* trim address */
sartsize  = STORAGE(D2X(X2D(@sart)+4),4)      /* get number of SART's */
sartsize  = C2D(sartsize)                            /* binary to dec */
@sardsnl  = STORAGE(D2X(X2D(@sart)+24),4)     /* get dsn list address */
@sardsnl  = RIGHT(C2X(@sardsnl),7)                    /* trim address */
@sarfrsta = STORAGE(D2X(X2D(@sart)+60),4)       /* get 1st sart entry */
@sarfrsta = RIGHT(C2X(@sarfrsta),7)                   /* trim address */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMSART:'@sart'   'TIME() DATE()
Say ' '
Say 'The SART table starts at '@sarfrsta' and contains 'sartsize' entries.'
Say ' '
s = 0 ; i = 0 ; @sartix = @sarfrsta ; @dsnl = @sardsnl
Do s = 1 To sartsize                           /* scan the SART table */
   sreflg = STORAGE(D2X(X2D(@sartix)+9),1)           /* get flag byte */
   If BITAND(sarflg,'80'x) \= '80'x Then Do    /* process in use only */
      i = i + 1                              /* count active swapds's */
      swapdsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */
      sretotsl = STORAGE(D2X(X2D(@sartix)+16),4) /* get size in slots */
      sretotsl = C2D(sretotsl)
      sreavlsl = STORAGE(D2X(X2D(@sartix)+20),4)   /* slots available */
      sreavlsl = C2D(sreavlsl) ; used = sretotsl - sreavlsl
      If sretotsl > 0 Then pctused = TRUNC((used*100)/sretotsl,0)
                      Else pctused = 0
      pctused  ='('RIGHT(pctused,3)'%)'
      @sreucb  = STORAGE(D2X(X2D(@sartix)+44),4)   /* get UCB address */
      sioaddr  = STORAGE(D2X(C2D(@sreucb)+4),2)    /* channel address */
      sioaddr  = RIGHT(C2X(sioaddr),3)
      svolser  = STORAGE(D2X(C2D(@sreucb)+28),6)       /* dasd volser */
      If sretotsl > 0 Then Say RIGHT(i,2) swapdsn RIGHT(sretotsl,5),
                               pctused svolser sioaddr
   End
   @sartix = D2X(X2D(@sartix)+80)          /* bump to next SART entry */
   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */
End
Say ' '
Say 'Swapping activity table analysis completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTSFT
/*REXX*/
/*****************************************************************/
/* LISTSFT: REXX program to display the PC system function table.*/
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                SFT - System Function Table                    */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtxsft  = STORAGE(D2X(X2D(@cvt)+772),4)    /* get CVTXSFT address   */
@cvtxsft  = D2X(C2D(@cvtxsft))                 /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt'  CVTXSFT:'@cvtxsft'   'DATE() TIME()
Say ' '
Say '    PC Number          Service Description'
Say '    ----------------   ----------------------------------------'
@start = @cvtxsft ; i = 0
sftentry = STORAGE(@start,4)
Do While sftentry \= 'FFFFFFFF'x                       /* process SFT */
   i = i + 1
   linkageix = SUBSTR(sftentry,2,2) ; linkageix = C2X(linkageix)
     entryix = SUBSTR(sftentry,4,1) ;   entryix = C2X(entryix)
   Select
      When sftentry = '00000000'x Then
         service = 'Linkage Index Reserve                    (IEAVXLRE)'
      When sftentry = '00000001'x Then
         service = 'Linkage Index Free                       (IEAVXLFR)'
      When sftentry = '00000002'x Then
         service = 'Entry Table Create                       (IEAVXECR)'
      When sftentry = '00000003'x Then
         service = 'Entry Table Destroy                      (IEAVXEDE)'
      When sftentry = '00000004'x Then
         service = 'Entry Table Connect                      (IEAVXECO)'
      When sftentry = '00000005'x Then
         service = 'Entry Table Disconnect                   (IEAVXEDI)'
      When sftentry = '00000006'x Then
         service = 'Authorization Index Reserve              (IEAVXRFE)'
      When sftentry = '00000007'x Then
         service = 'Authorization Index Free                 (IEAVXRFE)'
      When sftentry = '00000008'x Then
         service = 'Authorization Index Extract              (IEAVXRFE)'
      When sftentry = '00000009'x Then
         service = 'Authorization Index Set                  (IEAVXSET)'
      When sftentry = '0000000A'x Then
         service = 'Authorization Table Set                  (IEAVXSET)'
      When sftentry = '0000000B'x Then
         service = 'PC/Auth Resource Manager                 (IEAVXPAM)'
      When sftentry = '00000100'x Then
         service = 'ENQ/DEQ/RESERVE                          (ISGGQWBI)'
      When sftentry = '00000101'x Then
         service = 'ENQ/DEQ/RESERVE Redrive                  (ISGGQWBI)'
      When sftentry = '00000102'x Then
         service = 'ENQ/DEQ/RESERVE Resource Term Mgr        (ISGGTRMI)'
      When sftentry = '00000103'x Then
         service = 'Global Resource Serialization Dump       (ISGDGCB0)'
      When sftentry = '00000104'x Then
         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'
      When sftentry = '00000105'x Then
         service = 'Global Resource Serialization Stor Mgmt  (ISGSMI  )'
      When sftentry = '00000200'x Then
         service = 'Display Allocation Tables Manager        (IEFHB410)'
      When sftentry = '00000300'x Then
         service = 'VSM CPOOL Build Service                  (IGVCPBDP)'
      When sftentry = '00000301'x Then
         service = 'VSM CPOOL Expansion Interface            (IGVCPEXP)'
      When sftentry = '00000302'x Then
         service = 'VSM CPOOL Delete Service                 (IGVCPDLP)'
      When sftentry = '00000303'x Then
         service = 'VSMLIST Service                          (IGVLISTP)'
      When sftentry = '00000304'x Then
         service = 'VSMLOC Service                           (IGVLOCP )'
      When sftentry = '00000305'x Then
         service = 'CPUTIMER Service                         (IEAVRT04)'
      When sftentry = '00000400'x Then
         service = 'WTO Service                              (IEAVH600)'
      When sftentry = '00000106'x Then
         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'
      When sftentry = '00000107'x Then
         service = 'DEQUEUE Fast Path                        (ISGLNQDQ)'
      When sftentry = '00000108'x Then
         service = 'ENQUEUE Fast Path                        (ISGLNQDQ)'
      When sftentry = '00000109'x Then
         service = 'Global Resource Serialization ESTAE      (ISGGEST0)'
      When sftentry = '0000010A'x Then
         service = 'FRR for ENQ/DEQ/RESERVE Mainline         (ISGGFRR0)'
      When sftentry = '00000500'x Then
         service = 'System Trace Control Block Verification  (IEAVETCV)'
      When sftentry = '00000501'x Then
         service = 'System Trace Environment Alteration      (IEAVETEA)'
      When sftentry = '00000502'x Then
         service = 'System Trace Processor Alteration        (IEAVETPA)'
      When sftentry = '00000503'x Then
         service = 'System Trace Processor Snapshot          (IEAVETPS)'
      When sftentry = '00000504'x Then
         service = 'System Trace Processor Verification      (IEAVETPV)'
      When sftentry = '00000505'x Then
         service = 'System Trace Table Snapshot Data Extract (IEAVETSD)'
      When sftentry = '00000506'x Then
         service = 'System Trace Table Snapshot              (IEAVETSN)'
      When sftentry = '00000507'x Then
         service = 'System Trace Suspend, Resume, PSTART     (IEAVETSP)'
      When sftentry = '00000508'x Then
         service = 'System Trace Table Snapshot Filter       (IEAVETTF)'
      When sftentry = '00000306'x Then
         service = 'Virtual Fetch CSVVFORK Service           (CSVVFORK)'
      When sftentry = '00000600'x Then
         service = 'Virtual Fetch CSVVFSCH Service           (CSVVFSCH)'
      When sftentry = '00000700'x Then
         service = 'SMF Buffering Routine                    (IFAPCWTR)'
      When sftentry = '00000800'x Then
         service = 'Lnklst Lookaside (LLA)                   (CSVLLS01)'
      Otherwise
         service = '*** Unknown Program Call Function ***'
      End
   Say RIGHT(i,2,' ')'  LX: 'linkageix'  EX: 'entryix'   'service
   sftentry = STORAGE(D2X(X2D(@start)+(i*4)),4) /* bump to next entry */
End
Say ' '
Say 'System Function Table scan completed 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTSMAP
/*REXX*/
/*****************************************************************/
/*LISTSMAP: REXX program to display key virtual storage points.  */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                GDA - Global Data Area                         */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)    /* get CVTMZ00 bitstring */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)    /* get CVTEORM address   */
@cvteorm  = D2X(C2D(@cvteorm))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
Say 'The CVT  is located at '@cvt '('X2D(@cvt)')'
Say 'The CVTMZ00  field contains 'C2X(@cvtmz00) /*'('X2D(@cvtmz00)')'*/
Say 'The CVTSEORM field contains '@cvteorm '('X2D(@cvteorm)')'
Say 'The CVTREAL  field contains   '@cvtreal     '('X2D(@cvtreal)')'
Say 'The CVTSHRVM field contains  '@cvtshrvm  '('X2D(@cvtshrvm)')'
Say 'The CVTGDA   field contains  '@cvtgda    '('X2D(@cvtgda)')'
Say 'The GDACSA   field contains  '@gdacsa    '('X2D(@gdacsa)')'
Say 'The GDACSASZ field contains  '@gdacsasz  '('X2D(@gdacsasz)')'
Say 'The GDAECSA  field contains  '@gdaecsa   '('X2D(@gdaecsa)')'
Say 'The GDAECSAS field contains  '@gdaecsas  '('X2D(@gdaecsas)')'
Say 'The CVTMLPAS field contains  '@cvtmlpas  '('X2D(@cvtmlpas)')'
Say 'The CVTMLPAE field contains  '@cvtmlpae  '('X2D(@cvtmlpae)')'
Say 'The CVTFLPAS field contains  '@cvtflpas  '('X2D(@cvtflpas)')'
Say 'The CVTFLPAE field contains  '@cvtflpae  '('X2D(@cvtflpae)')'
Say 'The CVTPLPAS field contains  '@cvtplpas  '('X2D(@cvtplpas)')'
Say 'The CVTPLPAE field contains  '@cvtplpae  '('X2D(@cvtplpae)')'
Say 'The CVTRWNS  field contains  '@cvtrwns   '('X2D(@cvtrwns)')'
Say 'The CVTRWNE  field contains  '@cvtrwne   '('X2D(@cvtrwne)')'
Say 'The CVTRONS  field contains  '@cvtrons   '('X2D(@cvtrons)')'
Say 'The CVTRONE  field contains '@cvtrone   '('X2D(@cvtrone)')'
Say 'The CVTERWNS field contains '@cvterwns  '('X2D(@cvterwns)')'
Say 'The CVTERWNE field contains '@cvterwne  '('X2D(@cvterwne)')'
Say 'The CVTEPLPS field contains '@cvteplps  '('X2D(@cvteplps)')'
Say 'The CVTEPLPE field contains '@cvteplpe  '('X2D(@cvteplpe)')'
Say 'The CVTEFLPS field contains '@cvteflps  '('X2D(@cvteflps)')'
Say 'The CVTEFLPE field contains '@cvteflpe  '('X2D(@cvteflpe)')'
Say 'The CVTEMLPS field contains '@cvtemlps  '('X2D(@cvtemlps)')'
Say 'The CVTEMLPE field contains '@cvtemlpe  '('X2D(@cvtemlpe)')'
Say ' '
Say ' '
Say ' '
/*  simplify variable names & calculate some boundaries   */
@csa1   = @cvtshrvm  ; @csa2  = D2X(X2D(@cvtmlpas)-1)         /* csa  */
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
csas    = (X2D(@csa2)-X2D(@csa1)+1)/1024     /* size of csa   KB    */
csasg   =  X2D(@gdacsasz)/1024               /* size of csag  KB    */
mlpas   = (X2D(@mlpa2)-X2D(@mlpa1)+1)/1024   /* size of mlpa  KB    */
flpas   = (X2D(@flpa2)-X2D(@flpa1)+1)/1024   /* size of flpa  KB    */
plpas   = (X2D(@plpa2)-X2D(@plpa1)+1)/1024   /* size of plpa  KB    */
sqas    = (X2D(@sqa2)-X2D(@sqa1)+1)/1024     /* size of sqa   KB    */
nucs    = (X2D(@nuc2)-X2D(@nuc1)+1)/1024     /* size of nuc   KB    */
esqas   = (X2D(@esqa2)-X2D(@esqa1)+1)/1024   /* size of esqa  KB    */
eplpas  = (X2D(@eplpa2)-X2D(@eplpa1)+1)/1024 /* size of eplpa KB    */
eflpas  = (X2D(@eflpa2)-X2D(@eflpa1)+1)/1024 /* size of eflpa KB    */
emlpas  = (X2D(@emlpa2)-X2D(@emlpa1)+1)/1024 /* size of emlpa KB    */
ecsasg  =  X2D(@gdaecsas)/1024               /* size of ecsag KB    */
Say 'Key storage addresses for system routine residency analysis:'
Say ' '
Say 'STORAGE AREA NAME               SIZE(K)      ADDRESS RANGE'
Say ' '
Say 'Common Service Area (CSA)       'RIGHT(csas,5)  '     'RIGHT(@csa1,8,0)'-'RIGHT(@csa2,8,0)
Say 'Common Service Area (CSA/GDA)   'RIGHT(csasg,5)  '     'RIGHT(@csa1g,8,0)'-'RIGHT(@csa2g,8,0)
Say 'Modified Link Pack Area (MLPA)  'RIGHT(mlpas,5) '     'RIGHT(@mlpa1,8,0)'-'RIGHT(@mlpa2,8,0)
Say 'Fixed Link Pack Area (FLPA)     'RIGHT(flpas,5) '     'RIGHT(@flpa1,8,0)'-'RIGHT(@flpa2,8,0)
Say 'Pageable Link Pack Area (PLPA)  'RIGHT(plpas,5) '     'RIGHT(@plpa1,8,0)'-'RIGHT(@flpa2,8,0)
Say 'System Queue Area (SQA)         'RIGHT(sqas,5)  '     'RIGHT(@sqa1,8,0)'-'RIGHT(@sqa2,8,0)
Say 'MVS Nucleus (NUC)               'RIGHT(nucs,5)  '     'RIGHT(@nuc1,8,0)'-'RIGHT(@nuc2,8,0)
Say 'Extended SQA                    'RIGHT(esqas,5) '     'RIGHT(@esqa1,8,0)'-'RIGHT(@esqa2,8,0)
Say 'Extended PLPA                   'RIGHT(eplpas,5) '     'RIGHT(@eplpa1,8,0)'-'RIGHT(@eplpa2,8,0)
Say 'Extended FLPA                   'RIGHT(eflpas,5) '     'RIGHT(@eflpa1,8,0)'-'RIGHT(@eflpa2,8,0)
Say 'Extended MLPA                   'Right(emlpas,5) '     'RIGHT(@emlpa1,8,0)'-'RIGHT(@emlpa2,8,0)
Say 'Extended CSA/GDA                'Right(ecsasg,5) '     'RIGHT(@ecsa1g,8,0)'-'RIGHT(@ecsa2g,8,0)
Exit
./ ADD LIST=ALL,NAME=LISTSMF
/*REXX*/
/*****************************************************************/
/* LISTSMF: REXX program to show SMF information.                */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               SMCA - SMF Control Area                         */
/*                RDS - SMF Recording Data Set                   */
/*               SSTP - SMF Selectivity Table                    */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */
@cvtsmca  = STORAGE(D2X(X2D(@cvt)+196),4)      /* get CVTSMCA address */
@smca     = C2X(@cvtsmca) ; @cvtsmca = RIGHT(@smca,7)    /* trim addr */
smcasid   = STORAGE(D2X(X2D(@cvtsmca)+016),4)  /* get system id field */
smcasjwt  = STORAGE(D2X(X2D(@cvtsmca)+144),4)       /* get system jwt */
smcaprmt  = STORAGE(D2X(X2D(@cvtsmca)+208),1) /* get smf prompt flags */
@smcafrds = STORAGE(D2X(X2D(@cvtsmca)+244),4)  /* get 1st RDA address */
@smcafrds = C2X(@smcafrds)                           /* binary to hex */
@smcalrds = STORAGE(D2X(X2D(@cvtsmca)+248),4) /* get last RDA address */
@smcalrds = C2X(@smcalrds)                           /* binary to hex */
@smcasstp = STORAGE(D2X(X2D(@cvtsmca)+328),4)     /* get SSTP address */
@smcasstp = C2X(@smcasstp)                           /* binary to hex */
smcaitme  = STORAGE(D2X(X2D(@cvtsmca)+336),4)         /* get IPL time */
ipltime = C2D(smcaitme) ; iplhh = ipltime%360000         /* get hours */
iplmm = ipltime//360000 ; iplmm = iplmm%6000           /* get minutes */
iplt = RIGHT(iplhh,2,0)':'RIGHT(iplmm,2,0)            /* format HH:MM */
smcaidte  = STORAGE(D2X(X2D(@cvtsmca)+340),4)         /* get IPL date */
smcansst = STORAGE(D2X(X2D(@cvtsmca)+348),2)              /* get NSST */
smcansst = C2D(smcansst)                             /* binary to dec */
i = 0 ; endofrds = 0 ; j = 0 ; k = 0
prompt = 'NOPROMPT' ; @rds = @smcafrds ; @sstp = @smcasstp
If BITAND(smcaprmt,'80'x) = '80'x Then prompt = 'PROMPT(IPLR)'
If BITAND(smcaprmt,'40'x) = '40'x Then prompt = 'PROMPT(LIST)'
ipld = C2X(smcaidte) ; ipld = SUBSTR(ipld,3,5)
ipldays = SUBSTR(ipld,3,3) ; days = DATE(D) - ipldays
If days < 0 Then days = days + 365     /* crossed into new year */
If days = 0 Then iplday = '(Today)'
If days = 1 Then iplday = '(Yesterday)'
If days > 1 Then iplday = '('days' days ago)'
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' SMCA:'@smca 'RDS:'@rds'   'TIME() DATE()
Say ' '
Say 'SMFID:'smcasid'  JWT:'smcasjwt'  'prompt'  IPL:'ipld' 'iplday' at 'iplt
Say ' '
Do While endofrds = 0 & i < 37         /* Trace the RDS chain */
   i = i + 1                                  /* count all RDSs found */
   @rdsnext= STORAGE(D2X(X2D(@rds)+4),4)          /* next RDS address */
   @rdsnext=C2X(@rdsnext)                               /* bin to hex */
   rdsflg1 = STORAGE(D2X(X2D(@rds)+12),1)              /* get RDSFLG1 */
   dump = '' ; active = '      '
   If BITAND(rdsflg1,'08'x) = '08'x Then dump = 'Dump Requested'
   If BITAND(rdsflg1,'04'x) \= '04'x Then active = 'Active'
   rdsname = STORAGE(D2X(X2D(@rds)+16),10)          /* get RDS DSName */
   rdsvol  = STORAGE(D2X(X2D(@rds)+26),6)           /* get RDS volser */
   rdscapty= STORAGE(D2X(X2D(@rds)+40),4)   /* get RDS size in blocks */
   rdsnxtbk= STORAGE(D2X(X2D(@rds)+44),4)       /* get RDS next block */
   capty = C2D(rdscapty) ; nxtbk = C2D(rdsnxtbk) ; used = nxtbk - 1
   pctused=TRUNC((used*100)/capty,1) ; pctused=RIGHT(pctused,5)'%'
   Say RIGHT(i,2,' ') rdsname rdsvol RIGHT(capty,6),
       RIGHT(used,6)' ('pctused') 'dump active
   @rds = @rdsnext ; If @rds = @smcalrds Then endofrds = 1
End
Say ' '
Say 'SMF selectivity tables defined: 'smcansst
Say ' '
bit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x
bit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x
Do kk = 1 To smcansst
   sst    = STORAGE(@sstp,60)                        /* get sst block */
   sstn   = SUBSTR(sst,1,4)                      /* get subsysname id */
   If sstn = '00000000'x Then sstn = 'Null'
   rectbl = SUBSTR(sst,17,32)           /* get record type bit string */
   rectypes = ''
   Do i = 0 to 31
      byte = SUBSTR(rectbl,i+1,1)
      k = i * 8
      If BITAND(byte,bit0)=bit0 Then rectypes = rectypes k
      If BITAND(byte,bit1)=bit1 Then rectypes = rectypes k+1
      If BITAND(byte,bit2)=bit2 Then rectypes = rectypes k+2
      If BITAND(byte,bit3)=bit3 Then rectypes = rectypes k+3
      If BITAND(byte,bit4)=bit4 Then rectypes = rectypes k+4
      If BITAND(byte,bit5)=bit5 Then rectypes = rectypes k+5
      If BITAND(byte,bit6)=bit6 Then rectypes = rectypes k+6
      If BITAND(byte,bit7)=bit7 Then rectypes = rectypes k+7
   End
   i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0
   Do While rectypes \= ''
      i = i + 1
      PARSE VAR rectypes type.i rectypes
   End
   If i > 2 Then
         Do k = 1 to i-2
            j = k + 1 ; jj = k + 2
            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'
                                                         Else f.k = ' '
         End
   rectypes = 'TYPE('
   Do k = 1 to i
      If f.k \= '*' Then Do
                            rectypes = rectypes''type.k
                            If k \= i Then rectypes = rectypes','
                                      Else rectypes = rectypes')'
                         End
                    Else Do
                           rectypes = rectypes''type.k':'
                           Do While f.k = '*' ; k=k+1 ; End
                         End
   End
   If RIGHT(rectypes,1) = ':' Then  /* compensate for single type */
      Do
         rectypes = LEFT(rectypes,LENGTH(rectypes)-1)')'
         nop
      End
   line2 = ''
   If LENGTH(rectypes) >70 Then
      Do
         Do i = 70 to 1 By -1
            If SUBSTR(rectypes,i,1) = ',' Then Leave
         End
         line2 = SUBSTR(rectypes,i+1,60)
         rectypes = LEFT(rectypes,i)
      End
   If sstn = 'Null' Then rectypes = ''
   Say RIGHT(kk,2,' ') sstn rectypes
   If line2 \= '' Then Say '             'line2
   @sstp  = D2X(X2D(@sstp)+60)                    /* bump to next sst */
End
Say ' '
Say 'SMF analysis completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTSSN
/*REXX*/
/*****************************************************************/
/* LISTSSN: REXX program to show all MVS subsystems.             */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*              JESCT - JES Communications Table                 */
/*              SSCVT - Subsystem Communications Vector Table    */
/*               SSVT - Subsystem vector Table                   */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */
@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */
@cvtjesct = D2X(C2D(@cvtjesct))               /* binary to dec to hex */
@jesct    = STORAGE(D2X(X2D(@cvtjesct)+24),4)    /* get JESCT address */
@jesct    = D2X(C2D(@jesct))                  /* binary to dec to hex */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' JESCT:'@jesct' SSCVT chain trace started: 'TIME() DATE()
Say ' '
i = 0 ; endofchn = 0 ; j = 0 ; @ssct = @jesct ; e = 0
ina = 0 ; inacsnam = '' ; inaline1 = ''
Say '    Snam Fnum  Sysevents Monitored'
Say '    ---- ----  ------------------------------------------------------------'
Do While endofchn = 0 & i < 50
   i = i + 1                                 /* count all SSCTs found */
   @scta   = STORAGE(D2X(X2D(@ssct)+4),4)    /* get next SSCT address */
   @scta   = D2X(C2D(@scta))                     /* bin to dec to hex */
   snam    = STORAGE(D2X(X2D(@ssct)+8),4)     /* get subsystem's name */
   @ssvt   = STORAGE(D2X(X2D(@ssct)+16),4)        /* get SSVT address */
   @ssvt   = D2X(C2D(@ssvt))                     /* bin to dec to hex */
   If @ssvt = 0 Then Do           /* make note of inactive subsystems */
      ina = ina + 1
      inacsnam = inacsnam snam           /* build primary output line */
      If LENGTH(inacsnam) >= 70 Then Do   /* logic for 2 output lines */
         inaline1 = inacsnam
         inacsnam = ''
         End
      End
   If @ssvt \= 0 Then Do             /* detail only active subsystems */
      j = j + 1                                  /* count active ones */
      sysevents = ''                    /* SYSEVENTS output code line */
      fnum = STORAGE(D2X(X2D(@ssvt)+2),2)      /* number of functions */
      fnum = C2D(fnum)
      fmat = STORAGE(D2X(X2D(@ssvt)+4),256)   /* function code matrix */
      Do e = 1 to 256          /* scan fmat, load sysevents code line */
         If C2D(SUBSTR(fmat,e,1)) \= 0 Then sysevents = sysevents e
      End
      Say RIGHT(j,3,' ') snam'  'RIGHT(fnum,2,0)'  'sysevents
      End
   @ssct = @scta
   If @ssct = 0 Then endofchn = 1    /* zero address ends chain */
End
If ina > 0 Then Do
   Say ' '
   Say RIGHT(ina,3,' ') 'Subsystems defined, no SSVT built:'
   If LENGTH(inaline1) \= 0 Then Do
      Say '     'inaline1
      If LENGTH(inacsnam) \= 0 Then Say '     'inacsnam
      End
      Else Say '     'inacsnam
   End
Say '---'
Say RIGHT(i,3,' ')' SSCVT blocks scanned.  Completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTSVCJ
/*REXX*/
/*****************************************************************/
/*LISTSVCJ: REXX program to display SVC update journal.          */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               SCVT - Supervisor Call Vector Table             */
/*               SVCR - SVC Recording Table                      */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */
@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */
@scvtsvcr = D2X(X2D(@cvtabend)+136)          /* SCVT addressibility   */
@scvtsvcr = STORAGE(@scvtsvcr,4)                  /* SVCR table       */
@scvtsvcr = D2X(C2D(@scvtsvcr))                /* binary to hex       */
Say ' '
Say ' '
Say 'The CVT  is located at '@cvt '('X2D(@cvt)')'
Say 'The CVTABEND field points to '@cvtabend '('X2D(@cvtabend)')'
Say 'The SCVTSVCR field points to '@scvtsvcr '('X2D(@scvtsvcr)')'
Say ' '
Say 'The SVC Update Journal table is at '@scvtsvcr '('X2D(@scvtsvcr)')'
Say ' '
hits = 0
Do i = 0 to 255                                 /* loop thru storage  */
   bytes = STORAGE(D2X(X2D(@scvtsvcr)+(i*24)),24)
   bytes = C2X(bytes)
   If SUBSTR(bytes,1,16) \= '0000000000000000'
      Then Do
         hits = hits + 1
         Say ' '
         Say '  SVC 'RIGHT(i,3,0) 'updated.  Old SVCTABLE entry: 'SUBSTR(bytes,1,16)
         Say '           Updating pgm return address: 'SUBSTR(bytes,17,8)
         Say '                    New SVC EP address: 'SUBSTR(bytes,26,8)
         Say '                         Times updated: 'X2D(SUBSTR(bytes,41,4))
         If SUBSTR(bytes,35,5) = '00000'
            Then Say '                   Date of last update: unknown'
            Else Say '                   Date of last update: 'SUBSTR(bytes,35,5)
      End
End
Say ' '
Say 'SVCTABLE entries showing updates in the journal = 'hits
Exit
./ ADD LIST=ALL,NAME=LISTSVCT
/*REXX*/
/*****************************************************************/
/*LISTSVCT: REXX program to display SVC table from CSTOR.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*               SCVT - Supervisor Call Vector Table             */
/*               SVCT - SVC Table                                */
/*                                                               */
/*                                                               */
/*****************************************************************/
/*--------------virtual storage map definition section----------------*/
Numeric Digits 10           /* required to handle decimal conversions */
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
        /*------simplify variable names & make addresses decimal------*/
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
 eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
 eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
 emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)
@eprivs = X2D(@ecsa2g)+1                               /* ext private */
@eprive = 2147483647                         /* fixed by architecture */
 epriv1 = @eprivs ; epriv2 = @eprive
@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */
   psa1 = @psas ; psa2 = @psae
@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */
  priv1 = @privs ; priv2 = @prive
              /*------------------------------------------------------*/
             /* Usage Notes: Hex character compares are incompatible */
            /*    for storage residency determination.  Thus, entry */
           /*     point addresses must be converted to decimal and */
          /*      VS boundary addresses must be converted to de-  */
         /*       cimal for correct compare operations.          */
        /*------------------------------------------------------*/
/*----------end of virtual storage map definition section-------------*/
@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */
@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */
@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */
@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */
@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct DATE() TIME()
Say ' '
Say 'Active SVCs follow:'
Say ' '
active = 0 ; inactive = 0 ; svcapf = 0 ; svcesr = 0
nucepn = 'IGCERROR' ; Call "#NUCLKUP" nucepn ; igcerror = Result
Do i = 0 to 255                                 /* loop thru storage  */
   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)
   addr = SUBSTR(bytes,1,4)       /* sloppy code to grab EP in binary */
   bytes = C2X(bytes)          /* legacy code before learning bit ops */
   svcep  = SUBSTR(bytes,1,8)
                                        /* determine storage location */
   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */
   addr = C2D(addr)                      /* make numeric for compares */
   sloc = 'ERROR'                       /* determine module residency */
   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '
      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '
      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '
      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '
      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '
      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '
      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '
      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'
      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'
      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'
      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '
      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'
      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '
      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '
      inactflag = 0
      If igcerror = Right(D2X(addr),8,0)  /* normalize for match */
         Then Do
            inactive = inactive + 1
            inactflag = 1
         End
         Else active = active + 1
   svctp1 = SUBSTR(bytes,9,1)
      Select
         When svctp1 = '0'
            Then svctype = 'TYPE 1  '
         When svctp1 = '8'
            Then svctype = 'TYPE 2  '
         When svctp1 = 'C'
            Then svctype = 'TYPE 3/4'
         When svctp1 = '2'
            Then svctype = 'TYPE 6  '
      Otherwise
                 svctype = 'TYPE ?  '
      End
   svctp2 = SUBSTR(bytes,10,1)
      svcmisc = '   '
      If svctp2 = '8'
         Then Do
            svcmisc = 'APF'
            svcapf = svcapf + 1
         End
      If svctp2 = '4'
         Then Do
            svcmisc = 'ESR'
            svcesr = svcesr + 1
         End
   If inactflag = 0
      Then Say 'SVC 'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',
               svctype svcep sloc svcmisc
End
Say ' '
Say 'SVCTABLE processing complete ' TIME()
Say ' '
Say 'There are 'active 'active standard SVCs on this system.'
Say 'Among the active SVCs, 'svcapf 'are APF restricted.'
Say 'There are 'svcesr 'active ESR router SVCs present.'
Say 'The SVCTABLE contains 'inactive 'inactive slots (IGCERROR).'
Say '    (IGCERROR nucleus address = 'igcerror')'
Say ' '
Exit
./ ADD LIST=ALL,NAME=LISTTAPE
/*REXX*/
/*****************************************************************/
/*LISTTAPE: REXX program to display all online TAPE devices.     */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                UCB - Device Unit Control Block                */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */
@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */
@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/
Address TSO ; "CLEAR"
Say 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> TAPE UCB scan started: 'TIME()
Say ' '
@ucbchn = @cvtucba
i = 0 ; endofucb = 0 ; j = 0
Do While endofucb = 0 & i < 10000
   i = i + 1
   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */
   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */
   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */
   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */
   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */
   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '80'x is TAPE */
   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */
   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'80'x)='80'x) Then Do
      j = j + 1; device = 'Unknown'
      ioaddr = C2X(ucbchan)
      If BITAND(ucbtbyt4,'80'x)='80'x Then device = '3480   '
      If BITAND(ucbtbyt4,'01'x)='01'x Then device = '2400   '
      If BITAND(ucbtbyt4,'03'x)='03'x Then device = '3420   '
      If BITAND(ucbtbyt4,'81'x)='81'x Then device = '3490E  '
      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to TAPE segment */
      ucbtape = STORAGE(@ucbchn,24)       /* get 24 byte TAPE segment */
      ucbfser = SUBSTR(ucbtape,5,6)              /* volser if mounted */
      If C2X(ucbfser) = '000000000000' Then ucbfser = '-idle-'
      Say RIGHT(j,3,' ') RIGHT(ioaddr,3) STRIP(device) ucbfser
   End
   @ucbchn = D2X(C2D(ucbnxucb))
   If @ucbchn = 0 Then endofucb = 1    /* zero address ends chain */
End
Say ' '
Say 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()
Exit
./ ADD LIST=ALL,NAME=LISTVMAP
/*REXX*/
/*****************************************************************/
/*LISTSMAP: REXX program to display key virtual storage points.  */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                GDA - Global Data Area                         */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)    /* get CVTMZ00 bitstring */
@cvtmz00  = C2X(@cvtmz00)                    /* character to hex      */
@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */
@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */
@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)    /* get CVTEORM address   */
@cvteorm  = D2X(C2D(@cvteorm))                 /* binary to hex       */
Address TSO ; "CLEAR"
Say 'CVT:'@cvt'      Virtual Storage Map: 'DATE() TIME()
Say ' '
@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */
@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */
@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */
@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */
@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */
@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */
@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */
@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */
@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */
@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */
@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */
@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */
@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */
@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */
@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */
@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */
@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */
@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */
@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */
@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */
@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */
@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */
@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */
@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */
@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */
@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */
@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */
@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */
@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */
@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */
@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */
@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */
@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */
@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */
@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */
@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */
@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */
@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */
@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */
@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */
@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */
@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */
@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */
@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */
@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */
@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */
/*  simplify variable names & calculate some boundaries   */
@csa1   = @cvtshrvm  ; @csa2  = D2X(X2D(@cvtmlpas)-1)         /* csa  */
@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/
@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */
@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */
@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */
@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */
@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */
@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */
@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/
@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/
@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/
@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/
csas    = (X2D(@csa2)-X2D(@csa1)+1)/1024     /* size of csa   KB    */
csasg   =  X2D(@gdacsasz)/1024               /* size of csag  KB    */
mlpas   = (X2D(@mlpa2)-X2D(@mlpa1)+1)/1024   /* size of mlpa  KB    */
flpas   = (X2D(@flpa2)-X2D(@flpa1)+1)/1024   /* size of flpa  KB    */
plpas   = (X2D(@plpa2)-X2D(@plpa1)+1)/1024   /* size of plpa  KB    */
sqas    = (X2D(@sqa2)-X2D(@sqa1)+1)/1024     /* size of sqa   KB    */
nucs    = (X2D(@nuc2)-X2D(@nuc1)+1)/1024     /* size of nuc   KB    */
esqas   = (X2D(@esqa2)-X2D(@esqa1)+1)/1024   /* size of esqa  KB    */
eplpas  = (X2D(@eplpa2)-X2D(@eplpa1)+1)/1024 /* size of eplpa KB    */
eflpas  = (X2D(@eflpa2)-X2D(@eflpa1)+1)/1024 /* size of eflpa KB    */
emlpas  = (X2D(@emlpa2)-X2D(@emlpa1)+1)/1024 /* size of emlpa KB    */
ecsasg  =  X2D(@gdaecsas)/1024               /* size of ecsag KB    */
@eprivs = D2X(X2D(@ecsa2g)+1)                        /* ext private */
@eprive = 21
epriv   = (@eprive-X2D(@eprivs)+1)/1048576 /* size of epriv MB    */
@psas   = D2X(0) ; psa = 4 ; @psae = D2X(4095) /* psa fixed by arch */
@prive  = D2X(X2D(@csa1)-1) ; @privs = D2X(X2D(@psae)+1) /* private */
priv    = (X2D(@prive)-X2D(@privs)+1)/1024   /* size of ALL private */
@privsas= @privs ; privsa = 16                  /* sa fixed by arch */
@privsae= D2X(X2D(@privsas)+((privsa*1024)-1)) /* calc private part */
@privvrs= D2X(X2D(@privsae)+1)  /* adj priv start above system area */
@privvre= D2X(X2D(@cvtreal)-1)                   /* calc end of V=R */
privvr  = (X2D(@privvre)-X2D(@privvrs)+1)/1024       /* size of V=R */
@privvvs= @privvrs              /* adj priv start above system area */
@privvve= @prive                               /* assign end of V=V */
privvv  = (X2D(@privvve)-X2D(@privvvs)+1)/1024       /* size of V=V */
Say '    ------- COMPONENT -------   -SIZE-  --ADDRESS RANGE--'
Say ' '
Say '    EPrivate                    'Right(epriv,5)'M  'RIGHT(@eprivs,8,0)'-'RIGHT(@cvtmz00,8,0)
Say '    ECSA                        'Right(ecsasg,5)'K  'RIGHT(@ecsa1g,8,0)'-'RIGHT(@ecsa2g,8,0)
Say '    EMLPA                       'Right(emlpas,5)'K  'RIGHT(@emlpa1,8,0)'-'RIGHT(@emlpa2,8,0)
Say '    EFLPA                       'RIGHT(eflpas,5)'K  'RIGHT(@eflpa1,8,0)'-'RIGHT(@eflpa2,8,0)
Say '    EPLPA                       'RIGHT(eplpas,5)'K  'RIGHT(@eplpa1,8,0)'-'RIGHT(@eplpa2,8,0)
Say '    ESQA                        'RIGHT(esqas,5)'K  'RIGHT(@esqa1,8,0)'-'RIGHT(@esqa2,8,0)
Say '    MVS NUCLEUS                 'RIGHT(nucs,5)'K  'RIGHT(@nuc1,8,0)'-'RIGHT(@nuc2,8,0)
Say '    SQA                         'RIGHT(sqas,5)'K  'RIGHT(@sqa1,8,0)'-'RIGHT(@sqa2,8,0)
Say '    PLPA                        'RIGHT(plpas,5)'K  'RIGHT(@plpa1,8,0)'-'RIGHT(@plpa2,8,0)
Say '    FLPA                        'RIGHT(flpas,5)'K  'RIGHT(@flpa1,8,0)'-'RIGHT(@flpa2,8,0)
Say '    MLPA                        'RIGHT(mlpas,5)'K  'RIGHT(@mlpa1,8,0)'-'RIGHT(@mlpa2,8,0)
Say '  * CSA                         'RIGHT(csasg,5)'K  'RIGHT(@csa1g,8,0)'-'RIGHT(@csa2g,8,0)
Say '    Private (V=V)               'RIGHT(privvv,5)'K  'RIGHT(@privvvs,8,0)'-'RIGHT(@privvve,8,0)
Say '            (V=R)               'RIGHT(privvr,5)'K  'RIGHT(@privvrs,8,0)'-'RIGHT(@privvre,8,0)
Say '            (System)            'RIGHT(privsa,5)'K  'RIGHT(@privsas,8,0)'-'RIGHT(@privsae,8,0)
Say '    PSA                         'RIGHT(psa,5)'K  'RIGHT(@psas,8,0)'-'RIGHT(@psae,8,0)
Say ' '
csatol2 = csasg//1024 ; csatol1 = 1024 - csatol2
Say '  * CSA Segment Tolerance ===> Upper:'csatol1'K  Lower:'csatol2'K'
Exit
./ ADD LIST=ALL,NAME=NOT@OR
    IBM EBCDIC 'not' character is '5F'x                                al
  |  IBM EBCDIC 'or'  character is '4F'x                                al
./ ADD LIST=ALL,NAME=SDUMP
/*REXX*/
/**********************************************************************/
/*    PROCEDURE NAME:  SDUMP - formatted storage dump.                */
/*                                                                    */
/*            ARG(1):  HEXADECIMAL ADDRESS - DUMP starting location   */
/*            ARG(2):  DECIMAL LENGTH      - Bytes to dump            */
/*                                                                    */
/*    NOTES:  Produces a formatted storage dump for 80 column screens.*/
/*            The length is rounded to a 16 byte boundary.            */
/*            The TSO/E STORAGE function is used to access memory.    */
/**********************************************************************/
Arg @start bytes
Numeric Digits 10               /* for high end addresses in ESA */
If DATATYPE(@start,'X') \= 1 Then Do
   Say 'Starting address '@start' is not in hexadecimal form.'
   Return
   End
If bytes = '' Then bytes  =  256
If DATATYPE(bytes,'N') \= 1 Then Do
   Say 'Specified bytes 'bytes' is not in decimal form.'
   Return
   End
blocks16=bytes%16 ; If blocks16\=(bytes/16) Then blocks16=blocks16+1
Address TSO ; "CLEAR"
Say 'Storage dump beginning at '@start' for 'blocks16*16' bytes.'
Say ' '
Say '  ADDRESS  OFFSET            HEXADECIMAL DATA                CHARACTER'
Say ' --------  ------  ------------------------------------  :----------------:'
Do i = 0 to blocks16-1
   offset = i*16
   @address = D2X(X2D(@start)+offset)
   nbytes = STORAGE(@address,16)
   nbytes = C2X(nbytes)
   Say ' 'RIGHT(@address,8,0)'  'RIGHT(D2X(offset),6,0)' ',
           SUBSTR(nbytes,1,8)' 'SUBSTR(nbytes,9,8)' ',
           SUBSTR(nbytes,17,8)' 'SUBSTR(nbytes,25,8)' ',
           ':'X2C(nbytes)':'
End
Return
./ ADD LIST=ALL,NAME=VSDATA1
/*REXX*/
/*****************************************************************/
/* VSDATA1: REXX program to display some virtual storage.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*                                                               */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@tcb = STORAGE(21C,4)                 /* get TCB address from PSAAOLD */
@tcb = D2X(C2D(@tcb))                    /* binary to hex             */
@tcbjscb  = STORAGE(D2X(X2D(@tcb)+180),4)   /* get JSCB address       */
@jscb = D2X(C2D(@tcbjscb))                     /* binary to hex       */
@jscbopts = STORAGE(D2X(X2D(@jscb)+236),1)   /* get JSCBOPTS data     */
@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */
@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */
@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)  /* get CVTLLTA address    */
@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */
@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */
@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */
@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */
@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */
@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */
Say 'The CVT  is located at '@cvt '('X2D(@cvt)')'
Say 'The TCB  is located at '@tcb '('X2D(@tcb)')'
Say 'The JSCB is located at '@jscb '('X2D(@jscb)')'
Say 'The JSCBOPTS byte is 'C2X(@jscbopts) '('C2D(@jscbopts)')' @jscbopts
Say ' '
Say 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'
Say '    some storage follows'
Do i = 0 to 10                                  /* loop thru storage  */
   byte = STORAGE(D2X(X2D(@cvtauthl)+i),1)
   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte
End
Say '    ----+----1----+----2----+----3----+----4----+----5'
Do i = 0 to 10                                  /* loop thru storage  */
  Say '===>'STORAGE(D2X(X2D(@cvtauthl)+(i*50)),50)  'block 'i+1
End
Say ' '
Say 'The CVTLLTA  field points to '@cvtllta '('X2D(@cvtllta)')'
Say '    some storage follows'
Do i = 0 to 10                                  /* loop thru storage  */
   byte = STORAGE(D2X(X2D(@cvtllta)+i),1)
   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte
End
Say '    ----+----1----+----2----+----3----+----4----+----5'
Do i = 0 to 10                                  /* loop thru storage  */
  Say '===>'STORAGE(D2X(X2D(@cvtllta)+(i*50)),50)   'block 'i+1
End
Say 'The CVTSMEXT field points to '@cvtsmext '('X2D(@cvtsmext)')'
Say 'The CVTEPLPS field points to '@cvteplps '('X2D(@cvteplps)')'
Say '    some storage follows'
Do i = 0 to 10                                  /* loop thru storage  */
   byte = STORAGE(D2X(X2D(@cvteplps)+i),1)
   Say '    Table byte 'i 'is 'C2X(byte) C2D(byte) byte
End
Say '    ----+----1----+----2----+----3----+----4----+----5'
Do i = 0 to 10                                  /* loop thru storage  */
  Say '===>'STORAGE(D2X(X2D(@cvteplps)+(i*50)),50)   'block 'i+1
End
Say ' '
Exit
