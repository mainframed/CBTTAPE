Dialog manager authorisation program
This article addresses the problem of the authorisation of subset functions of
an ISPF Dialog Manager application.  Standard security validation programs, such
as RACF, are designed to provide global authorisation for resources and
applications. However,  within an application, there is very often the need to
provide authorisation for specific functions. Such  authorisation should be
transparent and easy to keep current, should the requirements change.
The AUTHRS program is table driven and enables the  current contents of ISPF
variables to be validated with regard to values stored in the table.  The AUTHRS
program returns a code, dependent on whether authorisation has  been granted.
The program is controlled by means of a predefined  ISPTLIB table.  The KEY
entries in this table are used as primary test criteria.  The NAME (and
EXTENSION) variables are used as secondary test criteria.   The Dialog Manager
variable names, as specified in the  table, are compared to the ISPF pool
variables.  If the  primary test criteria are met (KEY variables) then the
secondary test criteria must be met in order for authorisation to be granted.
The program performs two types of validation:
•    Sufficient authorisation - it is sufficient that none of the conditions is
not met.
•    Necessary authorisation - it is necessary that at least one of the
conditions is met.
SOFTWARE ENVIRONMENT
The AUTHRS program can only operate in the ISPF environment.  It uses a
partitioned dataset called ISPTLIB, which contains the authorisation table.  The
actual name of the authorisation table is passed as a PARM value in the ISPEXEC
statement.
Sample CLIST
ISPEXEC SELECT PGM(AUTHRS) PARM(tablename)
IF &LASTCC EQ 0 +
 THEN WRITE AUTHORISATION OK
 ELSE WRITE AUTHORISATION REJECTED
Return Codes
0 - OK, authorisation granted
4 - authorisation not granted
181 - EXEC parameter not defined
182 - table cannot be opened (eg not present  in the ISPTLIB table).
Table format
A table entry can have one of the following formats:
•    Data - ENGLAND, 9000
•    <variable name> - eg <CITY>,<POSTCODE>
•    *  which specifies all values
•    ? which denotes an absolute condition - it is necessary that at least one
of these conditions is met.
The values to be tested are fetched from the SHARED pool.  The condition
variables are obtained from the table and are stored in the FUNCTION pool.  The
length of the variables in the FUNCTION pool is used for comparison.
Authorisation is declined in the following cases:
•    A primary condition (KEY variable) is satisfied but the secondary condition
fails.
•    An absolute condition is specified, but no condition (primary, together
with non-failure in the secondary condition) has been satisfied.
If authorisation is not ‘not granted’ then it is granted.  This logic may appear
somewhat complicated, but the following examples will clarify the processing,
and demonstrate that this is the simplest means of performing authorisation
checks.
     Primary        Secondary
     PGMLANG   SYSTEM      DEPT
     ASM  P         SP
     COB  P    <XDEPT>
        * T
        ?
The authorisation table contains, in this example, three variables:
•    PGMLANG - programming language
•    SYSTEM - target system (P = production, T = test)
•    DEPT - department code.

The first entry requires that programs being transferred into the production
environment (SYSTEM=P) and written  in Assembler (PGMLANG=ASM) can only be
submitted by personnel from the System Programming department (DEPT=SP).
Programs submitted by personnel from other departments are rejected (= not
authorised).  The second entry requires that programs being transferred into the
production environment (SYSTEM=P) and written in COBOL (PGMLANG=COB) can only be
submitted by personnel whose Department Code (DEPT) corresponds to the contents
of the variable <XDEPT>.  The third entry states that programs being transferred
into the test environment (SYSTEM=T) are not subject to any restrictions with
regard to the programming language (PGMLANG=* - all PGMLANG entries are valid).
The fourth entry states that at least one of the previous conditions must have
been met in order for authorisation to be granted.  The secondary conditions may
be specified either as NAME entries or as EXTENSION variables.  The
authorisation table must contain at least one primary condition (KEY).  A table
with only primary conditions is a simple means of authorising a group of users.
For example, the table with the KEY entry <USER> can supply a list of users who
are exclusively authorised to perform a certain function as follows:
     Primary
     USER
     T000003
     T000245
     T000264
     ?
This specifies that only users with the user-id (ISPF variable <USER>) T000003,
T000245, or T000264 are authorised, where <USER> has been assigned the current
user-id (ISPF variable <ZUSER> through the code shown below:
SET &USER = &ZUSER
ISPEXEC VPUT (USER) SHARED
A table which has only primary condition(s) is meaningless without the absolute
condition flag (?).
THE SOURCE CODE FOR AUTHRS
AUTHRS   CSECT                     set up base register, etc.
*****    initialise addressing    *****
         STM   R14,R12,12(R13)         save registers
         BALR  R12,0                   base register
         USING *,R12
         LA    R15,SA                  A(save-area)
         ST    R13,4(R15)              backward ptr
         ST    R15,8(R13)              forward ptr
         LR    R13,R15                 A(new save-area)
         B     SA_END                  jump over save-area
SA       DS    18A                     save-area
SA_END   MVC   RC,=H'181'         ERROR-CODE
         L     R2,0(R1)           A(PARM-LIST)
         LH    R1,0(R2)           L(PARM-LIST)
         LTR   R1,R1
         BZ    EOJ                :no EXEC-Parameter
         CH    R1,=AL2(L'PARM)    :L(PARM-LIST)
         BH    EOJ                :Parameter length error
         BCTR  R1,0               LC(PARM-LIST)
         MVC   PARM(0),2(R2)
         EX    R1,*-6             move parameter (Table name)
         LOAD  EP=ISPLINK
         ST    R0,AISPLINK        A(ISPLINK)
*****    OPEN Table    *****
         MVC   RC,=H'182'         ERROR-CODE
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(TBOPEN,TABNAME,NOWRITE),VL
         LTR   R15,R15
         BNZ   EOJ                :Table not available
         MVC   RC,=H'0'           RETURN-CODE
*****    get field names and KEY-names    *****
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(TBQUERY,TABNAME,KEYNAME,VARNAME),VL
         MVC   VN,=CL8'KEYNAME'
         MVC   VL,=AL4(L'KEYNAME)
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(VCOPY,VN,VL,KEYNAME,MOVE),VL
*****    VAR-names    *****
         MVC   VN,=CL8'VARNAME'
         MVC   VL=AL4(L'VARNAME)
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(VCOPY,VN,VL,VARNAME,MOVE),VL
         STH   R15,NRC            <NRC>: NAME RETURN-CODE
*****    parse name lists   *****
         LA    R15,KEYNAME
         BAL   R14,SCAN           analyse KEY-name list
         LH    R15,NRC            <NRC>: NAME RETURN-CODE
         LTR   R15,R15
         BZ    A010               no names present
         LA    R15,VARNAME
         BAL   R14,SCAN           analyse VAR-name list
*****    position at start of table    *****
A010     L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(TBTOP,TABNAME),VL
*****    get next line   *****
A100     L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(TBSKIP,TABNAME),VL
         LTR   R15,R15
         BNZ   A300               end of table
         MVC   VN,=CL8'VNEX'      EXTENSION-VARIABLENAME
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(TBGET,TABNAME,VN),VL
*****    get KEY variables and check    *****
         LA    R10,KEYNAME
         MVI   FLAG,@AND          initialise condition
         BAL   R14,TESTVAR
*****    check KEY criteria    *****
         TM    FLAG1,@AND         ABSOLUTE condition requested?
         BO    A200               :yes
         TM    FLAG,@OR           >= 1 condition met
         BZ    A100               :no
         TM    FLAG,@AND          all conditions met?
         BZ    A100               :no
*****    KEY criteria met    *****
         OI    FLAG1,@OR          ABSOLUTE condition met
*****    get NAME variables and check    *****
         MVI   FLAG,@AND          initialise condition
         LH    R15,NRC            <NRC>: NAME RETURN-CODE
         LTR   R15,R15
         BZ    A220               no NAMEs (=condition met)
         LA    R10,VARNAME
         BAL   R14,TESTVAR
*****    check NAME criteria    *****
         TM    FLAG,@AND          all criteria met?
         BZ    A210               :no, no authorisation
*****    else ok    *****
*****    get EXTENSION variables    *****
A220     MVC   VN,=CL8'VNEX'
         MVC   VL,=AL4(L'VNEX)
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(VCOPY,VN,VL,VNEX,MOVE),VL
         L     R15,VL             check length
         LTR   R15,R15
         BZ    A110               :null, no extension variable
*****    parse name list    *****
         LA    R15,VNEX
         BAL   R14,SCAN           analyse name
*****    get EXTENSION-variables and check    *****
         LA    R10,VNEX
         BAL   R14,TESTVAR
*****    check EXTENSTION criteria    *****
A110     TM    FLAG,@AND          all criteria met?
         BZ    A210               :no, no authorisation
         B     A100               :next table line
A200     TM    FLAG1,@OR          ABSOLUTE condition met?
         BO    A300               :yes
A210     MVC   RC,=H'4'           else no authorisation
A300     L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(TBCLOSE,TABNAME),VL
EOJ      LH    R15,RC                  job end
         L     R13,4(R13)              restore A(old save-area)
         RETURN (14,12),RC=(15)   end of program, return
RC       DC    H'0'               Program RC
NRC      DC    H'0'               NAME-RC
FLAG     DC    X'0'               temporary flag
*        OR AND
*        1   .  condition met (at least once)
*        .   0  condition not met
*        .   1  all conditions met
FLAG1    DC  X'0'                 permanent flag
*        OR AND
*        1   . KEY criteria met (at least once)
*        .   0 no ABSOLUTE condition requested
*        .   1 ABSOLUTE condition requested (? operand)
@AND     EQU 01
@OR      EQU 02
         DS  AL4
TESTVAR  ST  R14,TESTVAR-4
* Function: test variable (obtained via GETVAR) and set condition
* input:     <VN>: L(field name)
*            <VL>: L(field)
* output:  <FLAG>: @OR   set, if condition met
*                 @AND  reset, if condition not met
TESTVAR1 BAL   R14,GETVAR
         LTR   R1,R1
*  R1: CODE (0 = END)
         BZ    TESTVAR9           :end of list
*****    else entry found    *****
*  <FLD>: data field
         L     R9,VL              L(field)
         LTR   R9,R9
         BZ    TESTVAR1           :NULL-field
         LA    R8,FLD             A(field)
         CLI   0(R8),C'?'         ABSOLUTE condition requested?
         BE    TESTVAR6           :yes
         CLI   0(R8),C'*'         all values?
         BE    TESTVAR4           :yes, condition met
         CLI   0(R8),C'<'         fieldname?
         BE    TESTVARS           :yes
*****    fetch POOL data for variable    *****
TESTVAR3 MVC   VL,=AL4(L'VL)
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(VGET,VN,SHARED),VL
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),VCOPY,VN,VL,VA,LOCATE),VL
         LTR   R15,R15
         BNZ   TESTVAR1           variable missing
         L     R15,VL             L(field)
         LTR   R15,R15
         BZ    TESTVAR1           NULL-variable
         L     R14,VA             A(field)
*****    compare data    *****
         CLCL  R14,R8
         BE    TESTVAR4           :ok
         LTR   R9,R9              generic entry in table?
         BZ    TESTVAR4           :yes, ok
*****    condition not met    *****
         NI    FLAG,X'FF'-@AND    no AND-condition
         B     TESTVAR9           terminate
*****    condition met    *****
TESTVAR4 OI    FLAG,@OR           OR-condition
         B     TESTVAR1
*****    compare fieldnames    *****
TESTVAR5 SH    R9,=H'3'           LC(fieldname)
         MVC   VNX,VNX-1          <VNX>:=blank
         MVC   VNX(0),1(R8)
         EX    R9,*-6
         MVC   VL,=AL4(L'VL)
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(VCOPY,VNX,VL,VA,LOCATE),VL
         LTR   R15,R15
         BNZ   TESTVAR1           variable missing
         L     R15,VL             L(field)
         LTR   R15,R15
         BZ    TESTVAR1           NULL-variable
         L     R8,VA              A(field)
         L     R9,VL              L(field)
         B     TESTVAR3
TESTVAR6 OI    FLAG1,@AND         ABSOLUTE condition requested
TESTVAR9 L     R14,TESTVAR-4
         BR    R14
         DS    AL4
GETVAR   ST    R14,GETVAR-4
*****    get table variable    *****
* input:   R10: A(name list)
* output:   R1: return code
*  <FLD>: data field
         SR    R1,R1
         IC    R1,0(R10)          L(name)
         LTR   R1,R1              end?
         BZ    GETVAR1            :yes
         BCTR  R1,0               LC(name)
         MVC   VN,VN-1            <VN>:-blank
         MVC   VN(0),1(R10)
         EX    R1,*-6
         LA    R10,2(R1,R10)
         MVC   VL,=AL4(L'FLD)
         L     R15,AISPLINK       A(ISPLINK)
         CALL  (15),(VCOPY,VN,VL,FLD,MOVE),VL
GETVAR1  L     R14,GETVAR-4
         BR    R14
SCAN     DS    0H
*****    analyse list    *****
* input:  R15: A(name-list)
* output: name length inserted into name-list
SCAN3    SR    R1,R1
         LR    R2,R15             A(start of name-1)
SCAN2    LA    R15,1(R15)
         CLI   0(R15),C' '        :end of field?
         BE    SCAN1              :yes
         CLI   0(R15),C')'        :end of list?
         BE    SCAN1              :yes
         LA    R1,1(R1)           length=length+1
         B     SCAN2
SCAN1    STC   R1,0(R2)           L(name)
         CLI   0(R15),C')'        :end of list?
         BNE   SCAN3              :no
         MVI   0(R15),0           set end-of-list indicator
         BR    R14                :return
***** DIALOG MANAGER parameter    *****
AISPLINK DS    A(0)               A(ISPLINK)
TBOPEN   DC    CL8'TBOPEN'
TBTOP    DC    CL8'TBTOP'
TBSKIP   DC    CL8'TBSKIP'
TBGET    DC    CL8'TBGET'
TBCLOSE  DC    CL8'TBCLOSE'
TBQUERY  DC    CL8'TBQUERY'
VCOPY    DC    CL8'VCOPY'
VGET     DC    CL8'VGET'
MOVE     DC    CL8'MOVE'
LOCATE   DC    CL8'LOCATE'
SHARED   DC    CL8'SHARED'
NOWRITE  DC    CL8'NOWRITE'
         DC    C' '
VNX      DC    CL8' '
         DC    C' '
VN       DC    CL8' '
VL       DS    AL4
VA       DS    AL4
FLD      DS    CL256
KEYNAME  DC    CL256'KEYNAME'
VARNAME  DC    CL256'VARNAME'
VNEX     DC    CL256'VNEX'
PARM     DC    CL8' '
         ORG   PARM
TABNAME  DS    CL8
         ORG
         END


A Rudd
Senior Technical Specialist (West Germany)   © A Rudd 1988





































