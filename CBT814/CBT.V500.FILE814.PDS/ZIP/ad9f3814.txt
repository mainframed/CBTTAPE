Dynamic allocation under JES2

Currently under JES2 there is no method of dynamically
allocating datasets at initialization, as there is under JES3. This
would be useful so that any errors in allocating procedure
libraries, for example, would not result in JES2 simply
terminating, but would allow the allocation to be bypassed and
JES started in the normal way.

If the allocation error was a simple typing mistake, a WTOR
could be issued asking the operator to supply the correct name.
We decided to write JES exit 19 (initialization statement read)
so that we can have DYNALLOC statements in JESPARMS
giving the dataset name and DDNAME to be used for
allocation. These are mostly used for procedure library
allocations but they could also be used for others. The
initialization statements for the exit itself (LOAD= and
EXITnnn) should be declared before any statements that exit 19
will need to handle.

The exit itself will take each DYNALLOC statement in
JESPARMS and allocate it using MVS dynamic allocation. If
the allocation fails because the DDNAME requested is not
available, the exit will assume that the dataset needs to be
concatenated with an existing DDNAME. It will first call
dynamic allocation to return a system DDNAME (SYSnnnnn)
and then use this returned DDNAME to concatenate with the
original DDNAME.

If the allocation fails for any other reason, a series of WTOs
and a WTOR will be issued giving the operator the chance to
supply a dataset name or bypass the allocation.


Sample JESparms.

LOAD=JESEX19                     /* Get module form LINKLST */
EXIT19   ROUTINE=UEXIT1,         /* Declare exit and CSECT to JES */
         TRACE=YES,
         ENABLE
         ...
         ...
DYNALLOC DDNAME=PROC00,DSN=SYS1.PROCLIB
DYNALLOC DDNAME=PROC00,DSN=<user1>.PROCLIB   /* Concatenate with above */
DYNALLOC DDNAME=PROC00,DSN=<user2>.PROCLIB   /* Concatenate with above */
DYNALLOC DDNAME=PROC01,DSN=SYS1.PROCLIB
         etc


SOURCE CODE FOR JESEX19

***********************************************************************
*MODULE NAME: JESEX19
*ON ENTRY: R0      AN INDICATION OF HOW THE INITIALIZATION INPUT WAS
*                  SUPPLIED.
*                  0 = INPUT CAME FROM THE PARAMETER LIBRARY FILE
*                  4 = INPUT CAME FROM THE OPERATOR
*                  8 = INPUT CAME FROM A PREVIOUS INSERTION BY AN
*                      EXIT 19 ROUTINE.
*          R1  =>  A FOUR-WORD PARAMETER LIST WITH THE FOLLOWING:
*                  WORD 1 (+0) ADDRESS OF THE INITIALIZATION
*                         STATEMENT ABOUT TO BE PROCESSED.
*                  WORD 2 (+4) LENGTH OF THE COMPLETE INITIALIZATION
*                         STATEMENT PASSED.
*                  WORD 3 (+8) A WORD THAT CAN BE USED BY EXIT 19 TO
*                         SPECIFY THE ADDRESS OF A STATEMENT
*                         YOU WANT TO INSERT AT THE NEXT POSSIBLE
*                         STATEMENT INSERTION POINT.
*                  WORD 4 (+12) LENGTH OF THE INITIALIZATION STATEMENT
*                         POINTED TO BY WORD 3.
*          R2-10   N/A
*          R11 =>  $HCT (HASP COMMUNICATIONS TABLE)
*          R12 =   N/A (USED AS BASE)
*          R13 =>  INITIALIZATION $PCE
*          R14 =>  RETURN ADDRESS
*          R15 =>  ENTRY ADDRESS
*ON EXIT:  R0      N/A
*          R1      N/A
*          R15 =   0       TELLS JES THAT IF THERE ARE ANY ADDITIONAL
*                          EXIT ROUTINES ASSOCIATED WITH THIS EXIT,
*                          CALL THE NEXT CONSECUTIVE EXIT ROUTINE.
*                          IF THERE ARE NO ADDITIONAL EXIT ROUTINES
*                          ASSOCIATED WITH THIS EXIT, CONTINUE WITH
*                          NORMAL INITIALIZATION STATEMENT PROCESSING.
*                          THE EXIT ROUTINE MIGHT HAVE CHANGED OR
*                          REPLACED THE INITIALIZATION STATEMENT
*                          PASSED.
*          R15 =  4        AS FOR RETURN CODE 0, EXCEPT JES SHOULD
*                          IGNORE ANY OTHER EXIT ROUTINES ASSOCIATED
*                          WITH THIS EXIT.
*          R15 =  8        TELLS JES TO BYPASS THIS INITIALIZATION
*                          STATEMENT AND CONTINUE WITH THE NEXT
*                          STATEMENT.
*          R15 = 12        TELLS JES TO TERMINATE ALL INITIALIZATION
*                          PROCESSING AND EXIT THE SYSTEM.
***********************************************************************
         COPY  $HASPGBL            COPY HASP GLOBAL PARAMETERS
*IDENTIFY MODULE TO JES ($MODULE)                              *
JESEX19  $MODULE NOTICE=SP215,     CREAT THE "MIT"                     C
               TITLE='JES2 EXITS',                                     C
               SYSP=(GEN,GEN,NODATA,NOGEN,NOGEN),                      C
               $CIRWORK,           GENERATE THE SOMETHING DSECT        C
               $HASPEQU,           GENERATE HASP GENERAL EQUATES       C
               $HCT,               GENERATE HASP HCT DSECT             C
               $MIT,               GENERATE HASP MIT DSECT             C
               $PCE                GENERATE HASP PCE DSECT             C
*IDENTIFY ENTRY POINT ($ENTRY) USING R12 AS BASE REGISTER      *
UEXIT19 $ENTRY CSECT=YES,BASE=R12  EXIT ROUTINE ENTRY POINT
        $SAVE  ,                   SAVE ENTRY REGISTERS
         USING HCT,R11             SET UP HCT ADDRESSABILITY
         LR    R12,R15             AND BASE REGISTER
*R1 POINTS TO A 4 WORD PARAMETER LIST OF WHICH ONLY WORDS      *
*1 & 2 ARE REQUIRED (ADDRESS OF INIT STATEMENT AND LENGTH)     *
         LM    R2,R3,0(R1)         GET STATEMENT ADDRESS AND LEN
*CHECK TO SEE WHAT KIND OF STATEMENT IT IS. IF IT IS NOT ONE WE*
*ARE INTERESTED IN, THEN RETURN TO JES.                        *
         CLC   0(8,R2),=C'DYNALLOC' IS THIS A "DYNALLOC" STATEMENT
         BE    EXIT19_DYNA_PROCESS  YES. GO TO PROCESS IT
         B     EXIT19_RETURN_0     ELSE. RETURN TO JES
*THIS IS A "DYNALLOC STATEMENT                                 *
*SO SCAN THE INCOMING PARMLIB STATEMENT IN ORDER TO            *
*BUILD THE WORK AREA ENTRY FOR THIS PROC                       *
EXIT19_DYNA_PROCESS EQU  *
*GETMAIN STORAGE FOR WORKAREA AND INITIALIZE IT                *
         LR    R7,R2               SAVE START OF STATEMENT
         GETMAIN R,LV=DYNWORK_LEN,LOC=ANY GET STORAGE FOR WORK AREA
         LR    R8,R1               MAKE R8 BASE
         USING $DYNA_WORK,R8       REGISTER FOR WORK AREA
         XC    DYNWORK_START(255),DYNWORK_START CLEAR IT OUT
         MVC   DYNWORK_WTOR,MODEL_WTOR    MOVE MODEL WTOR TO WORK AREA
* CLEAR OUT THE MESSAGE AREA OF THE WTOR
  XC    DYNWORK_WTOR_MSGVAR(L'DYNWORK_WTOR_MSGVAR),DYNWORK_WTOR_MSGVAR
*MAKE THE WTOR MESSAGE ARE NOT BIGGER THAN FIFTY               *
         CH    R3,=H'50'           IS LENGTH OF STMNT HIGHER THAN 50
         BNH   EXIT19_DYN_NOT_BIG  NO. JUST MOVE IT IN THE NORMAL WAY
         MVC   DYNWORK_WTOR_MSGVAR,0(R7) MOVE STATEMENT TO WTOR AREA
         B     EXIT19_DYN_SKIP_WTOEX
EXIT19_DYN_NOT_BIG EQU *           MOVE FOR TOTAL MESSAGE LENGTH
         BCTR  R3,0                ONE AWAY FOR EXECUTE
         EX    R3,EXIT19_DYN_MOVEWTOR
EXIT19_DYN_MOVEWTOR MVC  DYNWORK_WTOR_MSGVAR(*-*),0(R7)
         LA    R3,1(,R3)           ADJUST R3 FOR PROPER LENGTH
EXIT19_DYN_SKIP_WTOEX EQU  *
*MAKE SURE THERE IS A SPACE AFTER THE KEYWORD AND LOOK FOR PARMS*
         AR    R3,R2               R3 => END OF STATEMENT
         CLI   8(R2),C' '          IS THIS A SPACE?
         BNE   EXIT19_DYN_SYNTAX_ERROR NO SPACE AFTER "DYNALLOC"
         LA    R2,8(,R2)           SKIP OVER "DYNALLOC
EXIT19_DYN_SCAN_LOOP EQU *         ONLY CARRY ON IF IT IS A BLANK
*USE $SCANCOM TO SCAN THE STATEMENT FOR FIRST NON-BLANK NON-COMMENT*
         CR    R2,R3               IS START HIGHER THAN END
         BH    EXIT19_DYN_END_SCAN YES, ASSUME END OF STATEMENT
        $SCANCOM TEXTBEG=(R2),TEXTEND=(R3) FIND NEXT NON-COMMENT
         B     EXIT19_DYN_SCAN_TEST(R15) TEST RETURN CODE FROM SCANCOM
EXIT19_DYN_SCAN_TEST EQU *
         B     EXIT19_DYN_SCAN_NO_ERROR NON-BLANK, NON-COMMENT FOUND
         B     EXIT19_DYN_SCAN_NO_ERROR NON-BLANK, SKIPPED PAST COMMENT
         B     EXIT19_DYN_END_SCAN      ENCOUNTERED END OF STATEMENT
         B     EXIT19_DYN_SYNTAX_ERROR  ERROR IN COMMENTS
EXIT19_DYN_SCAN_NO_ERROR EQU *
*COME HERE WHEN FIRST NON-BLANK AND NON-COMMENT FOUND              *
*ONLY "DDNAME=" AND "DSN=" IS VALID FOR DYNALLOC STATEMENT         *
         LR    R2,R1               COPY ADDRESS OF STATEMENT
         CLC   =C'DDNAME=',0(R2)   IS IT A "DDNAME=" KEYWORD
         BE    EXIT19_DYN_IS_DDNAME YES, GO PROCESS
         CLC   =C'DSN=',0(R2)      IS IT A "DSN=" KEYWORD
         BE    EXIT19_DYN_IS_DSN   YES, GO PROCESS
         B     EXIT19_DYN_SYNTAX_ERROR ELSE, INVALID KEYWORD
*THIS IS A "DDNAME=" KEYWORD, SO EXTRACT DDNAME AND LENGTH AND *
*MOVE TO WORK AREA                                             *
EXIT19_DYN_IS_DDNAME EQU *
         LA    R2,7(,R2)           SKIP OVER "DDNAME="
         LR    R5,R2               R5 = TEMPORARY POINTER
         LA    R4,8                MAXIMUM LENGTH
EXIT19_DYN_LOOP_NAME EQU *
         LA    R5,1(,R5)           INCREMENT POINTER
         CLI   0(R5),C','          FOUND COMMA YET
         BE    EXIT19_DYN_FOUND_DDNAME_END
         CLI   0(R5),C' '          FOUND SPACE YET
         BE    EXIT19_DYN_FOUND_DDNAME_END
         BCT   R4,EXIT19_DYN_LOOP_NAME
         B     EXIT19_DYN_SYNTAX_ERROR DDNAME LONGER THEN 8 CHARS
EXIT19_DYN_FOUND_DDNAME_END   EQU *
         SR    R5,R2               R5 = LENGTH OF DDNAME
         STCM  R5,B'0001',DYNWORK_DDLEN SAVE LENGTH IN WORK AREA
         BCTR  R5,0                MINUS ONE FOR EXECUTE
         MVC   DYNWORK_DDNAME(8),=CL8' '        CLEAR DDNAME
         EX    R5,EXIT19_DYN_MOVE_DDNAME MOVE DDNAME TO WORKAREA
EXIT19_DYN_MOVE_DDNAME MVC DYNWORK_DDNAME(*-*),0(R2)
         LA    R5,1(,R5)           RE-ADJUST LENGTH OF DDNAME
         OI    DYNWORK_FLAG,GOT_DDNAME FLAG DDNAME KEYWORD AS GOT
         AR    R5,R2               POINT TO END OF DDNAME
         CLI   0(R5),C','          IS THERE A COMMA AT THE END?
         BNE   EXIT19_DYN_DDNAME_NOCOMMA NO, FURTHER CHECK REQUIRED
         LA    R5,1(,R5)           MOVE OVER COMMA
         LR    R2,R5               R2 POINTS TO AFTER COMMA
         B     EXIT19_DYN_SCAN_LOOP LOOP BACK TO CHECK NEXT
EXIT19_DYN_DDNAME_NOCOMMA EQU *
         CLI   0(R5),C' '          IS IT A SPACE?
         BE    EXIT19_DYN_END_SCAN YES, ASSUME END OF STATEMENT
         B     EXIT19_DYN_SYNTAX_ERROR NO. NO COMMA BEFORE NEXT KEYWORD
*THIS IS A "DSN=" KEYWORD, SO EXTRACT DATASET NAME AND LENGTH  *
*AND MOVE TO WORK AREA                                         *
EXIT19_DYN_IS_DSN EQU *
         LA    R2,4(,R2)           SKIP OVER "DSN="
         LR    R5,R2               R5 = TEMPORARY POINTER
         LA    R4,44               MAXIMUM LENGTH
EXIT19_DYN_LOOP_DSN EQU *
         LA    R5,1(,R5)           INCREMENT POINTER
         CLI   0(R5),C','          FOUND COMMA YET
         BE    EXIT19_DYN_FOUND_DSN_END
         CLI   0(R5),C' '          FOUND SPACE YET?
         BE    EXIT19_DYN_FOUND_DSN_END  YES. BRANCH OUT
         BCT   R4,EXIT19_DYN_LOOP_DSN OTHERWISE LOOP ROUND
         B     EXIT19_DYN_SYNTAX_ERROR DSN LONGER THEN 44 CHARS
EXIT19_DYN_FOUND_DSN_END EQU *
         SR    R5,R2               R5 = LENGTH OF DSN
         STCM  R5,B'0001',DYNWORK_DSNLEN SAVE LENGTH IN WORK AREA
         BCTR  R5,0                MINUS ONE FOR EXECUTE
         MVC   DYNWORK_DSN(42),=CL42' '
         EX    R5,EXIT19_DYN_MOVE_DSN MOVE DSN TO WORKAREA
EXIT19_DYN_MOVE_DSN MVC DYNWORK_DSN(*-*),0(R2)
         LA    R5,1(,R5)           RE-ADJUST LENGTH OF DSN
         OI    DYNWORK_FLAG,GOT_DSN  FLAG DSN KEYWORD AS GOT
         AR    R5,R2               POINT TO END OF DSN
         CLI   0(R5),C','          IS THERE A COMMA AT THE END?
         BNE   EXIT19_DYN_DSN_NOCOMMA NO, FURTHER CHECK REQUIRED
         LA    R5,1(,R5)           MOVE OVER COMMA
         LR    R2,R5               R2 POINTS TO AFTER COMMA
         B     EXIT19_DYN_SCAN_LOOP LOOP BACK TO CHECK NEXT
EXIT19_DYN_DSN_NOCOMMA EQU *
         CLI   0(R5),C' '          IS IT A SPACE?
         BE    EXIT19_DYN_END_SCAN YES, ASSUME END OF STATEMENT
         B     EXIT19_DYN_SYNTAX_ERROR NO. NO COMMA BEFORE NEXT KEYWORD
EXIT19_DYN_END_SCAN EQU *
         CLI   DYNWORK_FLAG,GOT_DDNAME+GOT_DSN
         BNE   EXIT19_DYN_MISSING_KEYWORD NOT ALL KEYWORDS SPECIFIED
* 1. ALLOCATE STORAGE FOR DYNALLOC CONTROL BLOCKS              *
* 2. ALLOCATE DSN TO THIS DDNAME. 3 TXT UNITS                  *
* 3. CHECK RETURN CODE FROM 1.                                 *
* 4. IF RETURN CODE IS GOOD. EXIT.                             *
* 5. IF RETURN CODE IS NO GOOD. IE IF DDNAME IS ALREADY USED.  *
*    ALLOC UNDER TEMP DDNAME AND THEN CONCATENATE WITH REQUIRED*
*    DDNAME                                                    *
         GETMAIN R,LV=DYNALLOC_WORKLEN,LOC=BELOW  GET WORKAREA STORAGE
         LR    R9,R1               MAKE R9 BASE
         USING $DYNALLOC_DATA,R9   FOR THIS WORK AREA
EXIT19_DYN_REPLY_LOOP EQU  *
         XC    DYNA_START(DYNALLOC_WORKLEN),DYNA_START CLEAR IT OUT
         MVC   DYNA_ID,=CL8'EX19DYNA'  MOVE EYECATCHER IN
*TEXT UNIT 1 - DDNAME
         LA    R4,DALDDNAM         PUT DDNAME KEY IN R4
         STH   R4,TEXT_UNIT1_KEY   STORE IN TEXT UNIT
         LA    R4,1                SET CORRECT NUM
         STH   R4,TEXT_UNIT1_NUM   SAVE IN TEXT UNIT
         SLR   R4,R4               ZEROIZE R4 BEFORE USING
         ICM   R4,B'0001',DYNWORK_DDLEN GET LENGTH OF DDNAME
         BZ    EXIT19_DYN_BYPASS   ZERO. ERROR
         STH   R4,TEXT_UNIT1_LEN   SAVE IN TEXT UNIT
         BCTR  R4,0                MINUS ONE FOR EXECUTE
         EX    R4,DYNAMOV1         MOVE DDNAME FOR CORRECT LENGTH
DYNAMOV1 MVC   TEXT_UNIT1_PARM(*-*),DYNWORK_DDNAME
*TEXT UNIT 2 - DSNAME
         LA    R4,DALDSNAM         PUT DSNAME KEY IN R4
         STH   R4,TEXT_UNIT2_KEY   SAVE IN TEXT UNIT
         LA    R4,1                SET CORRECT NUM FOR TEXT UNIT
         STH   R4,TEXT_UNIT2_NUM   SAVE IN TEXT UNIT
         SLR   R4,R4               ZEROIZE R4 BEFORE USING
         ICM   R4,B'0001',DYNWORK_DSNLEN GET LENGTH OF DSNAME
         BZ    EXIT19_DYN_BYPASS   ZERO. ERROR
         STH   R4,TEXT_UNIT2_LEN   SAVE IN TEXT UNIT
         BCTR  R4,0                MINUS ONE FOR EXECUTE
         EX    R4,DYNAMOV2         MOVE DDNAME FOR TO TEXT UNIT
DYNAMOV2 MVC   TEXT_UNIT2_PARM(*-*),DYNWORK_DSN
*TEXT UNIT 3 - DISPOSITION
         LA    R4,DALSTATS         PUT DSN STATUS KEY IN R4
         STH   R4,TEXT_UNIT3_KEY   SAVE IN TEXT UNIT
         LA    R4,1                SET NUM
         STH   R4,TEXT_UNIT3_NUM   SAVE IN TEXT UNIT
         STH   R4,TEXT_UNIT3_LEN   AND SET LEN = 1
         MVI   TEXT_UNIT3_PARM,X'08' CODE FOR DISP=SHR
         LA    R5,DYNA_TEXT_UNIT1  ADDR OF FIRST TEXT UNIT
         ST    R5,TEXT_POINTER1    AND SAVE IN POINTER
         LA    R5,DYNA_TEXT_UNIT2  AND SECOND UNIT
         ST    R5,TEXT_POINTER2    SAVE IN POINTER
         LA    R5,DYNA_TEXT_UNIT3  AND AGAIN
         ST    R5,TEXT_POINTER3    FOR THE THIRD ONE
         OI    TEXT_POINTER3,X'80' FLAG AS LAST POINTER
*POINTERS
         LA    R5,DYNA_RB          GET ADDRESS OF START OF RB
         USING S99RB,R5
         ST    R5,DYNA_RB_POINTER  PUT ADDRESS OF RB IN POINTER
         LA    R4,TEXT_POINTER1    GET ADDR OF TEXT UNIT LIST
         ST    R4,S99TXTPP         AND PUT IN RB
         OI    DYNA_RB_POINTER,S99RBPND TURN ON HIGH BIT
         MVI   S99RBLN,DYNA_RBLEN  SET LENGTH OF RB
         MVI   S99VERB,S99VRBAL    MOVE REQUEST ALLOCATION VERB INTO RB
         LA    R1,DYNA_RB_POINTER  POINT R1 AT PARAMETER LIST
         DYNALLOC                  CALL DYNAMIC ALLOCATION
         LTR   R15,R15             TEST RETURN CODE FROM DYNALLOC
         BZ    EXIT19_DYN_CLEANUP  GO TO CLEANUP IF OK
*WE HAVE A NON-ZERO RETURN CODE FROM DYNALLOC, SO HAVE A LOOK  *
*AT IT AND SEE IF IT IS A "DDNAME NOT AVAILABLE" ERROR         *
*WHICH IS WHAT WE WANT IF WE WANT TO CONCATENATE A DSN TO AN   *
*EXISTING DDNAME. IF IT IS WE ASK DYNALLOC TO GIVE US BACK A   *
*DDNAME  FOR THE ALLOCATION (SYSNNNNN) AND USE THAT FOR THE    *
*CONCATENATION. IF IT IS NOT A "DDNAME NOT AVAILABLE" ERROR    *
*BRANCH TO THE ERROR HANDLER.                                  *
EXIT19_DYN_CONCAT EQU  *
         CLC   S99ERROR,=X'0410'   IS IT A DDNAME NOT AVAIL ERROR?
         BNE   EXIT19_DYN_ERROR    NO. REAL ERROR
*THIS IS A "DDNAME NOT AVAILABLE" ERROR SO ADJUST TEXT UNIT 1  *
*TO ASK DYNALLOC TO GIVE US BACK A DDNAME FOR THIS ALLOCATION  *
*TEXT UNIT 1 - RETURN DDNAME
         LA    R4,DALRTDDN         PUT REQUEST DDNAME IN R4
         STH   R4,TEXT_UNIT1_KEY   PUT IN TEXT UNIT
         LA    R4,1                NUM  CODE "01"
         STH   R4,TEXT_UNIT1_NUM   PUT CORRECT NUM IN
         LA    R4,8                PUT MAX LEN IN R4 USING
         STH   R4,TEXT_UNIT1_LEN   SAVE IN TEXT UNIT PARM LENGTH
         LA    R1,DYNA_RB_POINTER  POINT R1 AT PARAMETER LIST
         DYNALLOC                  RE-ISSUE DYNALLOC TO RETURN DDNAME
         LTR   R15,R15             MAKE SURE DDNAME RETURN WORKED
         BNZ   EXIT19_DYN_ERROR
*GET RETURNED DDNAME AND MOVE TO WORK AREA                     *
*THEN CONSTRUCT TEXT UNITS FOR CONCATENATION FUNCTIONS         *
         LH    R4,TEXT_UNIT1_LEN   GET LENGTH OF RETURNED DDNAME
         STCM  R4,B'0001',DYNWORK_CONCAT_DDLEN AND SAVE IN WORK AREA
         BCTR  R4,0                MINUS ONE FOR EXECUTE
         EX    R4,DYNAMOV3         MOVE DDNAME TO WORK AREA
DYNAMOV3 MVC   DYNWORK_CONCAT_DDNAME(*-*),TEXT_UNIT1_PARM
*CONCAT TEXT UNIT 1 - DDNAMES
         LA    R4,1                KEY FOR CONCAT
         STH   R4,CONCT_UNIT_KEY1  SAVE IN CONCAT TEXT UNIT
         LA    R4,2                NUM FOR CONCAT
         STH   R4,CONCT_UNIT_NUM1  SAVE IN CONCAT TEXT UNIT
         LA    R4,8                LEN OF ORIGINAL DDNAME
         STH   R4,CONCT_UNIT_LEN1  AND SAVE IN CONCAT TEXT UNIT
         MVC   CONCT_UNIT_PARM1(8),DYNWORK_DDNAME MOVE ORIGINAL DDN
         ICM   R4,B'0001',DYNWORK_CONCAT_DDLEN GET LEN OF CONCAT DDN
         STH   R4,CONCT_UNIT_LEN2  AND SAVE IN CONCAT TEXT UNIT
         MVC   CONCT_UNIT_PARM2(8),DYNWORK_CONCAT_DDNAME MOVE CONC DDN
*CONCAT TEXT UNIT 2 - PERMANENTLY ALLOCATED ATTRIBUTE
         LA    R4,4                KEY FOR PERMANENTLY ALLOC ATTRIB
         STH   R4,PERM_UNIT_KEY3   SAVE IN TEXT UNIT
         SLR   R4,R4               ZEROIZE R4
         STH   R4,PERM_UNIT_NUM3   AND SAVE AS NUM
*POINTERS AND FLAGS
         LA    R4,DYNA_CONCT_UNIT  GET ADDR OF CONCAT TEXT UNIT
         ST    R4,TEXT_POINTER1    AND SAVE AS FIRST TEXT UNIT POINTER
         LA    R4,DYNA_PERM_UNIT   GET ADDR OF PERM ALLOC TEXT UNIT
         ST    R4,TEXT_POINTER2    AND SAVE AS 2ND TEXT UNIT POINTER
         OI    TEXT_POINTER2,X'80' FLAG AS LAST POINTER
         MVI   S99VERB,S99VRBCC    VERB = CONCATENATE
         LA    R1,DYNA_RB_POINTER  POINT AT RB POINTER
         DYNALLOC                  ISSUE DYNALLOC
         LTR   R15,R15             TEST RETURN FROM DYNALLOC
         BNZ   EXIT19_DYN_BYPASS   ERROR ON CONCAT. BYPASS ALLOCATION
         B     EXIT19_DYN_CLEANUP  OTHERWISE CLEANUP
EXIT19_DYN_ERROR EQU  *
         WTO   'WARNING! WARNING! WARNING! WARNING! WARNING!',         +
               ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG1    SAVE MSGID IN WORK AREA
         WTO   '********************************************',         +
               ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG2    SAVE MSGID IN WORK AREA
         WTO   '                                             ',        +
               ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG3    SAVE MSGID IN WORK AREA
         WTO   'JES EXIT 19 HAS ENCOUNTERED A PROBLEM ATTEMPTING',     +
               ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG4    SAVE MSGID IN WORK AREA
         WTO   'TO ALLOCATE THE FOLLOWING DATASET:-',                  +
               ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG5    SAVE MSGID IN WORK AREA
* PUT DATASET NAME IN PARM LIST FOR WTO AND ISUUE MESSAGE     *
         MVC   DYNWORK_WTO,MODEL_WTO  MOVE MODEL WTO TO WORK AREA
         MVC   DYNWORK_DSN_REPLY,=44C' '  BLANK OUT REPLY AREA
         ICM   R3,B'0001',DYNWORK_DSNLEN GET LENGTH OF DSN
         BCTR  R3,0                MINUS ONE FOR EXECUTE
         EX    R3,MOVEWTO          MOVE IT TO WTO AREA
MOVEWTO  MVC   DYNWORK_WTO_MSGVAR(*-*),DYNWORK_DSN
         WTO   MF=(E,DYNWORK_WTO)
         ST    R1,DYNA_DOM_MSG6    SAVE MSGID IN WORK AREA
EXIT19_DYN_WTOR EQU  *
         XC    DYNWORK_WTOR_MSGVAR(62),DYNWORK_WTOR_MSGVAR
 MVC DYNWORK_WTOR_MSGVAR(38),=C'REPLY "U" TO BYPASS, OR <DSN> TO RETRY'
         XC    DYNWORK_ECB,DYNWORK_ECB  CLEAR OUT ECB FOR WTOR
         WTOR  ,DYNWORK_DSN_REPLY,44,DYNWORK_ECB,MF=(E,DYNWORK_WTOR)
         WAIT  ECB=DYNWORK_ECB
         CLC   =C' ',DYNWORK_DSN_REPLY DID THEY REPLY NOTHING?
         BE    EXIT19_DYN_WTOR     YES. RE-ISSUE WTOR
         DOM   MSG=DYNA_DOM_MSG1   ELSE
         DOM   MSG=DYNA_DOM_MSG2        DELETE
         DOM   MSG=DYNA_DOM_MSG3               PREVIOUS
         DOM   MSG=DYNA_DOM_MSG4                       MESSAGES
         DOM   MSG=DYNA_DOM_MSG5
         DOM   MSG=DYNA_DOM_MSG6
         CLC   =C'U ',DYNWORK_DSN_REPLY DID THEY REPLY "U"?
         BE    EXIT19_DYN_CLEANUP  YES. CLEANUP AND EXIT
* GET DATASET NAME FROM REPLY AND MOVE TO WORK AREA           *
         LA    R4,DYNWORK_DSN_REPLY    POINT AT REPLY AREA
         SLR   R6,R6               INITIALIZE COUNTER
EXIT19_DYN_LOOPREP EQU  *
         CLI   0(R4),C' '          IS IT NULL?
         BE    EXIT19_DYN_ENDREPLY YES BRANCH OUT
         LA    R4,1(,R4)           INCREMENT POINTER
         LA    R6,1(,R6)           INCREMENT COUNTER
         B     EXIT19_DYN_LOOPREP  AND LOOP ROUND
EXIT19_DYN_ENDREPLY EQU  *
         STCM  R6,B'0001',DYNWORK_DSNLEN AND SAVE IN WORK AREA
         MVC   DYNWORK_DSN,DYNWORK_DSN_REPLY SAVE DSN IN WORK AREA
         B     EXIT19_DYN_REPLY_LOOP LOOP BACK TO FIRST ALLOCATION
* ISSUE WTO TO INFORM OPERATOR OF BYPASSING OF THIS ALLOCATION*
EXIT19_DYN_BYPASS EQU  *
         XC    DYNWORK_ECB,DYNWORK_ECB  CLEAR OUT ECB FOR WTOR
         WTO   'JES EXIT 19 HAS ENCOUNTERED A PROBLEM ATTEMPTING',     +
               ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG1    SAVE MSG ID IN WORKAREA
         WTO   'TO ALLOCATE THE FOLLOWING DATASET:-',                  +
               ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG2    SAVE MSG ID IN WORKAREA
         MVC   DYNWORK_WTO,MODEL_WTO  MOVE MODEL WTO TO WORK AREA
         MVC   DYNWORK_DSN_REPLY,=44C' '  BLANK OUT REPLY AREA
         ICM   R3,B'0001',DYNWORK_DSNLEN GET LENGTH OF DSN
         BCTR  R3,0                MINUS ONE FOR EXECUTE
         EX    R3,MOVEWTO2         MOVE IT TO WTO AREA
MOVEWTO2 MVC   DYNWORK_WTO_MSGVAR(*-*),DYNWORK_DSN
         WTO   MF=(E,DYNWORK_WTO)
         ST    R1,DYNA_DOM_MSG3    SAVE MSG ID IN WORKAREA
         XC    DYNWORK_WTOR_MSGVAR(62),DYNWORK_WTOR_MSGVAR
 MVC DYNWORK_WTOR_MSGVAR(38),=C'RECOVERY NOT POSSIBLE. REPLY U TO CONT'
         MVC   DYNWORK_WTOR_MSGVAR+38(5),=C'INUE.'
         WTOR  ,DYNWORK_REPLY,1,DYNWORK_ECB,MF=(E,DYNWORK_WTOR)
         WAIT  ECB=DYNWORK_ECB
         DOM   MSG=DYNA_DOM_MSG1   DELETE
         DOM   MSG=DYNA_DOM_MSG2         PREVIOUS
         DOM   MSG=DYNA_DOM_MSG3                 MESSAGES
         B     EXIT19_DYN_CLEANUP  CLEAN UP AND EXIT
* ISSUE WTO SHOWING WHICH STATEMENT IS IN ERROR               *
EXIT19_DYN_MISSING_KEYWORD EQU *
EXIT19_DYN_SYNTAX_ERROR EQU *
         USING $DYNA_WORK,R8       ESTABLISH WORK AREA ADDRESSABILITY
         XC    DYNWORK_ECB,DYNWORK_ECB  CLEAR OUT ECB FIRST
         WTO   'JES EXIT 19 HAS ENCOUNTERED A SYNTAX ERROR IN THE FOLLO+
               WING STATEMENT -',ROUTCDE=(1),DESC=(2)
         ST    R1,DYNA_DOM_MSG1    SAVE MSG ID IN WORK AREA
         WTOR  ,DYNWORK_REPLY,1,DYNWORK_ECB,MF=(E,DYNWORK_WTOR)
         WAIT  ECB=DYNWORK_ECB     WAIT FOR REPLY
         DOM   MSG=DYNA_DOM_MSG1   DELETE PREVIOUS WTO
         B     EXIT19_DYN_CLEANUP  GO TO CLEANUP AND RETURN
         DROP  R8                  DROP WORK AREA BASE REGISTER
EXIT19_DYN_CLEANUP EQU  *
         FREEMAIN R,LV=DYNWORK_LEN,A=(8)  FREE OFF WORK AREAS
         FREEMAIN R,LV=DYNALLOC_WORKLEN,A=(9)
         B     EXIT19_RETURN_8     RETURN TO JES
         DROP  R8                  DROP WORK AREA BASE
         DROP  R9                  DROP DYNALLOC RB BASE
         DROP  R5                  DROP DYNALLOC RB ADDRESSABILITY
*SET RETURN CODE 12 (JES SHOULD END INITIALIZATION)            *
EXIT19_RETURN_12 EQU  *
         LA    R15,12
         B     EXIT19_RETURN
*SET RETURN CODE 8 (JES SHOULD IGNORE THIS STATEMENT)          *
EXIT19_RETURN_8 EQU  *             I HAVE PROCESSED THIS STATEMENT
         LA    R15,8
         B     EXIT19_RETURN
*SET RETURN CODE 0 (JES SHOULD PROCESS THIS STATEMENT)         *
EXIT19_RETURN_0 EQU  *             JES SHOULD PROCESS THIS STATEMENT
         SLR   R15,R15
EXIT19_RETURN   EQU  *
        $RETURN RC=(R15)           RETURN TO JES
         LTORG ,
$DYNALLOC_DATA  DSECT                      DYNALLOC WORK AREA
*THIS IS A WORK AREA FOR DYNALLOC CONTAINING RB POINTER, RB, AND  *
*TEXT UNITS FOR NORMAL ALLOCATION, RETURN DDNAME, AND             *
*CONCATENATION.                                                   *
DYNA_START      EQU    *
DYNA_ID         DS     CL8                 EYECATCHER
DYNA_RBLEN      EQU    S99RBEND-S99RB      EQUATED LENGTH
DYNA_RB_POINTER DS     A                   POINTER TO DYNALLOC "RB"
DYNA_RB         DS     0F,CL(DYNA_RBLEN)   THE DYNALLOC "RB" ITSELF
*START OF TEXT POINTERS                                           *
DYNA_TEXT_POINT DS     0CL4                TEXT UNIT POINTERS
TEXT_POINTER1   DS     F                   POINTER TO FIRST TEXT UNIT
TEXT_POINTER2   DS     F                   POINTER TO SECOND TXT UNIT
TEXT_POINTER3   DS     F                   POINTER TO THIRD TEXT UNIT
*START OF TEXT UNITS                                              *
DYNA_TEXT_UNIT1 EQU    *                   FIRST TEXT UNIT STARTS HERE
TEXT_UNIT1_KEY  DS     H                   KEY
TEXT_UNIT1_NUM  DS     H                   NUMBER
TEXT_UNIT1_LEN  DS     H                   LENGTH
TEXT_UNIT1_PARM DS     CL42                PARM
DYNA_TEXT_UNIT2 EQU    *                   SECOND TEXT UNIT STARTS HERE
TEXT_UNIT2_KEY  DS     H                   KEY
TEXT_UNIT2_NUM  DS     H                   NUMBER
TEXT_UNIT2_LEN  DS     H                   LENGTH
TEXT_UNIT2_PARM DS     CL42                PARM
DYNA_TEXT_UNIT3 EQU    *                   THIRD TEXT UNIT STARTS HERE
TEXT_UNIT3_KEY  DS     H                   KEY
TEXT_UNIT3_NUM  DS     H                   NUMBER
TEXT_UNIT3_LEN  DS     H                   LENGTH
TEXT_UNIT3_PARM DS     CL42                PARM
*CONCAT TEXT UNIT PLUS PERMENENTLY CONCATENATED ATTRIBUTE UNIT    *
DYNA_CONCT_UNIT EQU    *                   CONCAT TEXT UNITS START HERE
CONCT_UNIT_KEY1 DS     H                   FIRST KEY
CONCT_UNIT_NUM1 DS     H                   FIRST NUM
CONCT_UNIT_LEN1 DS     H                   FIRST LENGTH
CONCT_UNIT_PARM1 DS    CL8                 FIRST PARM
CONCT_UNIT_LEN2 DS     H                   SECOND LENGTH
CONCT_UNIT_PARM2 DS    CL8                 SECOND PARM
DYNA_PERM_UNIT  EQU    *
PERM_UNIT_KEY3 DS     H                    KEY FOR PERM CONCAT ATTRIB
PERM_UNIT_NUM3 DS     H                    NUM FOR PERM CONCAT ATTRIB
DYNALLOC_WORKLEN   EQU    *-DYNA_START    EQUATED LENGTH FOR BLOCK
$DYNA_WORK DSECT
DYNWORK_START  EQU  *
DYNWORK_DDLEN  DS   X              LENGTH OF DD
DYNWORK_DDNAME DS   CL8            DDNAME OF INCOMING "DYNALLOC"
DYNWORK_CONCAT_DDLEN  DS  X        LENGTH OF CONCATENATE DDNAME
DYNWORK_CONCAT_DDNAME DS  CL8      DDNAME OF RETURNED DDNAME FOR CONCAT
DYNWORK_DSNLEN DS   X              LENGTH OF DSN
DYNWORK_DSN    DS   CL44           DSN OF INCOMING STATEMENT
DYNWORK_FLAG   DS   X              FLAGS
GOT_DDNAME     EQU  B'10000000'    DDNAME HAS BEEN GOT
GOT_DSN        EQU  B'01000000'    DSN HAS BEEN GOT
               DS   0F
DYNWORK_ECB    DS   F              ECB FOR WTOR
               DS   0F
DYNWORK_WTOR   DS   XL(MODEL_WTOR_LEN) WTOR AREA
DYNWORK_WTOR_MSG    EQU DYNWORK_WTOR+12           MESSAGE AREA
DYNWORK_WTOR_MSGVAR EQU DYNWORK_WTOR+12+1,50,C'C' VARIABLE BIT OF MSG
DYNWORK_REPLY  DS   X
DYNWORK_WTO    DS   XL(MODEL_WTO_LEN) WTO AREA
DYNWORK_WTO_MSG     EQU DYNWORK_WTO+4            MESSAGE AREA
DYNWORK_WTO_MSGVAR  EQU DYNWORK_WTO+4+1,44,C'C' VARIABLE BIT OF MSG
DYNWORK_DSN_REPLY   DS  CL44
DYNA_DOM_MSG1  DS   F
DYNA_DOM_MSG2  DS   F
DYNA_DOM_MSG3  DS   F
DYNA_DOM_MSG4  DS   F
DYNA_DOM_MSG5  DS   F
DYNA_DOM_MSG6  DS   F
DYNWORK_LEN    EQU  *-DYNWORK_START EQUATED LENGTH
UEXIT19  CSECT                     RETURN TO CURRENT CSECT
MODEL_WTOR    WTOR '"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+
               " - REPLY "U"',ROUTCDE=1,MF=L
MODEL_WTOR_LEN      EQU *-MODEL_WTOR
MODEL_WTO WTO  ('"                                            "'),     +
               ROUTCDE=(1),DESC=(2),MF=L
MODEL_WTO_LEN  EQU  *-MODEL_WTO
UEXIT19  CSECT
         $MODEND
         END


Luca Viggiani
Systems Programmer
Thomson Tour Operations Ltd (UK)              c Thomson Tour Operations 1993

