Stacked LIBDEFs

The LIBDEF (library define) service of ISPF was introduced with 
Version 2 of the product.  It temporarily directs library searches 
for ISPF objects (panels, skeletons, messages etc) to any specified 
partitioned datasets, without the user having to exit from ISPF and 
re-allocate.  The specified datasets are logically concatenated 
ahead of the standard search sequence as long as the LIBDEF 
remains in effect.  This offers at least a partial solution to two 
long-standing maintenance headaches:

1	The need to modify TSO logon procedures every time a new 
product with an ISPF component is acquired or relinquished 
by the installation.

2	The dilemma between maintaining either monolithic ISPF 
libraries or long concatenations to logon procedures.  If you 
use LIBDEF to make new libraries available, these libraries 
do not have to appear in the logon procedure.

Strangely, the installation documentation that accompanies IBM 
products which have an ISPF component (eg SMP/E, RACF, 
ISMF, SDSF, DB2I, QMF, DITTO, etc) never suggests the 
LIBDEF technique.  For example, the SMP/E installation manual 
just tells you to concatenate (in the logon procedure or with a 
CLIST prior to invoking ISPF) the SMP/E ISPF libraries 
(GIM.SGIMxxx0) with the base ISPF/PDF libraries.  Then 
SMP/E is invoked from an ordinary ISPF menu with the following 
menu )PROC statement segment:

	n,'PGM(GIMISCV) PARM(&ZCMD) NEWAPPL(SMPE) NOCHECK'

The LIBDEF technique for invoking SMP/E would be as follows:

1	Replace the above menu selection with one that invokes a 
CLIST called SMPE, eg:

	n,'CMD(%SMPE PARM(&ZCMD)) NOCHECK'

2   Write CLIST SMPE as follows:

	PROC 0 PARM()
	SET &DSNAME = &SYSUID..ISPF.PROFILE   /* installation-dependent
	ALLOC F(SMPTABL) REU DA('&DSNAME') SHR
	ISPEXEC LIBDEF ISPTLIB DATASET ID('&DSNAME' 'GIM.SGIMTBL0')
	ISPEXEC LIBDEF ISPPLIB DATASET ID('GIM.SGIMPNL0')
	ISPEXEC LIBDEF ISPMLIB DATASET ID('GIM.SGIMMSG0')
	ISPEXEC LIBDEF ISPSLIB DATASET ID('GIM.SGIMPRC0')
	ISPEXEC SELECT PGM(GIMISCV) PARM(&PARM) NEWAPPL(SMPE) PASSLIB
	ISPEXEC LIBDEF ISPTLIB
	ISPEXEC LIBDEF ISPPLIB
	ISPEXEC LIBDEF ISPMLIB
	ISPEXEC LIBDEF ISPSLIB
	FREE F(SMPTABL)

You still have to make load libraries (in this case 
GIM.SGIMLMD0) available via the old technique, because 
LIBDEF does not work for ISPLLIB when modules call each 
other with LINK, or LOAD and CALL, rather than via the ISPF 
SELECT PGM service.  Also, LIBDEF cannot be used for CLIST 
libraries, so SYSPROC concatenations still have to be done in the 
old way too.  Nevertheless, LIBDEF works for all the other types 
of ISPF object, and so can still save a considerable amount of the 
maintenance associated with logon procedures.  Moreover, using 
LIBDEF will tend to reduce the differences between logon 
procedures, so you may be able to eliminate some.

The usefulness of native LIBDEF is further limited, however, 
because LIBDEF environments cannot be stacked.  That is, if you 
issue LIBDEFs to set up the libraries for a given ISPF application 
(eg RACF, SMP/E) and then issue further LIBDEFs from within 
that application to invoke another, the second LIBDEF 
environment simply supersedes the first.  On leaving the second 
application, the libraries for the first one are no longer available, 
and all sorts of errors or abends can ensue.

However, there is a way to circumvent this restriction, by using a 
temporary ISPF table to stack the LIBDEFs.  LIBDEFs are issued 
via a CLIST, which also stores the name(s) of the newly-defined 
LIBDEF dataset(s) in this table.  The same CLIST is invoked on 
leaving the application, this time to issue the previous LIBDEF, if 
there was one.  Provided everyone conforms to the convention of 
issuing LIBDEFs only via this same CLIST, everything works 
well.  The CLIST, itself called 'LIBDEF', is shown below.

THE LIBDEF CLIST

PROC 1 DDNAME DATASET()                                 /* (1)
CONTROL NOFLUSH
ISPEXEC TBSTATS &DDNAME STATUS2(S2)                     /* (2)
IF &S2 = 1 THEN                                         /* (2) */ +
   ISPEXEC TBCREATE &DDNAME NAMES(DATASET) NOWRITE      /* (2)
IF &DATASET Â= THEN DO                                  /* (3)
   ISPEXEC TBADD &DDNAME                                /* (4)
   SYSCALL LIBDEF &DDNAME DATASET('&DATASET')           /* (5)
END
ELSE DO                                                 /* (6)
   ISPEXEC TBDELETE &DDNAME                             /* (7)
   IF &LASTCC = 0 THEN DO                               /* (8)
      ISPEXEC TBGET &DDNAME                             /* (9)
      IF &LASTCC = 0 THEN                               /* (10) */ +
         SYSCALL LIBDEF &DDNAME DATASET('&DATASET')     /* (11)
      ELSE DO                                           /* (12)
         ISPEXEC LIBDEF &DDNAME                         /* (13)
         ISPEXEC TBEND &DDNAME                          /* (14)
      END
   END
   ELSE +
      ISPEXEC TBEND &DDNAME                             /* (15) */
END
LIBDEF: PROC 1 DDNAME DATASET()                         /* (16)
        SET &TSOPFX = &SYSPREF                          /* (17)
        PROFILE NOPREFIX                                /* (17)
        ISPEXEC CONTROL ERRORS RETURN
        ISPEXEC LIBDEF &DDNAME DATASET ID(&DATASET)     /* (18)
        ISPEXEC CONTROL ERRORS CANCEL
        IF &TSOPFX Â= THEN                              /* (19) */ +
           PROFILE PREFIX(&TSOPFX)                      /* (19)
END

General notes

1	Parameter DDNAME is the ISPF library type, eg ISPPLIB, 
ISPSLIB, ISPTABL.  It also serves as the name for the 
temporary table which will control the stacking.  Parameter 
DATASET is either a single dataset or a concatenation of 
datasets, or is blank, in which case the invocation is a 'FREE' 
request, equivalent to native LIBDEF with library-type being 
the only parameter.

2	Check to see if the table for this library type exists and, if not, 
create it.  The table has a single non-key variable, 
DATASET.

3	Vary processing according to whether the DATASET 
parameter is blank or not.

4	The dataset parameter is non-blank, so this is a request to 
issue a new LIBDEF rather than to remove one.  Add to the 
bottom of the temporary table the name(s) of the dataset(s) 
being LIBDEFed.

5	Call subroutine LIBDEF, which actually issues the LIBDEF.

6	Processing when DATASET is blank (ie undo the last 
LIBDEF for this library type and re-establish the previous 
one, if any).

7	Delete the current (bottom) row of the table, which contains 
the name(s) of the currently LIBDEFed dataset(s).

8	Only continue if there was a row to delete.

9	Retrieve what was the penultimate row (it is now the last).  
This should contain the name(s) of the dataset(s) previously 
LIBDEFed to the current library type.

10	Zero return code from TBGET means there was indeed a prior 
LIBDEF

11	... so re-issue it.

12	There was no prior LIBDEF.

13	... so issue native LIBDEF with no DATASET parameter, 
thus removing all LIBDEFs for the current library type.

14	... and get rid of the temporary table.

15	This only gets executed if the CLIST is not being used 
properly, ie someone has invoked it with a blank DATASET 
parameter without previously having invoked it with a non-
blank DATASET parameter for the same library type.

16	This subroutine actually issues the LIBDEF service, with the 
DATASET parameter.

17	The user's TSO prefix needs to be temporarily switched off, 
in order to support concatenations in the DATASET 
parameter.

18	The LIBDEF itself.

19	Restore user's TSO prefix.

To illustrate the use of the LIBDEF CLIST here is our SMPE 
CLIST rewritten for this method:

PROC 0 PARM()
SET &DSNAME = &SYSUID..ISPF.PROFILE
ALLOC F(SMPTABL) REU DA('&DSNAME') SHR
%LIBDEF ISPTLIB DATASET('&DSNAME GIM.SGIMTBL0')
%LIBDEF ISPPLIB DATASET(GIM.SGIMPNL0)
%LIBDEF ISPMLIB DATASET(GIM.SGIMMSG0)
%LIBDEF ISPSLIB DATASET(GIM.SGIMPRC0)
ISPEXEC SELECT PGM(GIMISCV) PARM(&PARM) NEWAPPL(SMPE) PASSLIB
%LIBDEF ISPTLIB
%LIBDEF ISPPLIB
%LIBDEF ISPMLIB
%LIBDEF ISPSLIB
FREE F(SMPTABL)

Usage notes

When using LIBDEF to define a concatenation of datasets (as in 
the case of ISPTLIB above), the dataset names are passed to the 
CLIST together, between a single pair of quotes.  The dataset with 
the largest block size must go first.

LIBDEF environments are maintained separately for each logical 
screen when working in split-screen mode.

The level of stacking of LIBDEFs is limited only by practical 
bounds.

The LIBDEF CLIST, as written above, requires TSO/E Version 1 
Release 4 or later, because it uses an internal subroutine call.  It 
can easily be modified to run under earlier releases.


Ian D Ray
Systems Programmer
Banco de Espana (Spain)	© Xephon 1989

