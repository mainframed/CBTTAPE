Assembler macros in XA 31-bit mode

Most installations probably have a set of macros extending the functions of
IBM's SAVE and RETURN, among other things providing save area chaining,
GETMAINing new save and work areas, setting up base registers, defining register
equates,  restoring registers, providing return code support, and FREEMAINing
any GETMAINed areas.

In the following article some additional features supporting an XA environment
will be presented easing the conversion of our own Assembler programs to execute
in 31-bit mode.  In principle, all Assembler programs that do not play on 370-
specific features in instructions ought to be executed in 31-bit mode with any
residency mode under XA.  In any case, an installation probably has some
programs that must run in 31-bit mode because they access control blocks above
the 16MB line.

The following considerations apply:

1    Programs executing independently can be converted directly to AMODE 31 and
RMODE ANY.

2    Programs called via LINK, XCTL, or ATTACH can also be converted directly to
AMODE 31 and RMODE ANY.  The return to the calling program is also done in the
correct addressing mode.

3    Programs called via LOAD and BALR R14,R15 will receive control in the
correct addressing mode but the caller's different addressing mode will not be
restored upon standard return via BR R14.  Problems will arise if the caller is
AMODE 24 and the called program is in AMODE ANY and loaded above the 16MB line.

4    Programs in AMODE 31 are loaded via the LOAD macro and called in a way
other than BALR or BASSM, ie BR R15 from AMODE 24 program, so no addressing mode
switch takes place.  In programs loaded and called as above from an AMODE 31
program, since R14 does not contain an indication of the caller's 31-bit mode,
return must be done by a BR R14.  The first is a problem in itself, the latter
shows up a new problem specific to a general addressing mode approach.

5    Programs with different addressing modes are linked together.  The address
constants used for calling between such programs will not contain any indication
of the AMODE of a called program, thus a BALR R14,R15 cannot change the
addressing mode.  Likewise, no addressing mode change can happen on return since
BR R14 is used.

6    The picture is even more mixed up if programs fall into more than one of
the above categories and are called in different ways.

The solution for the above problems is to implement a general technique for
calling between programs, saving the addressing mode, and restoring it again at
return.  The assumption is then that R14 always contains the return address,
which is standard anyway, that R14 in its high order bit contains a zero if the
caller was in 24-bit mode and a one if the caller was in 31-bit mode, and that a
program receives control in the addressing mode under which it is link-edited or
itself switches address mode if it is receiving control in the wrong one.

Saving the addressing mode is accomplished by using BALR R14,R15; BASSM R14,R15;
or standard program transfer macros and the setting of the new addressing mode
by using BASSM R14,R15 or again the standard program transfer macros.

The technique should also cover compatibility with 370-mode both at compile time
and execution time.  XA-only instructions should obviously be avoided in 370-
mode.

A set of macros has been developed to implement the above ideas and let an
installation convert all of its Assembler programs.


The only snag could be high-level language programs or vendor software calling
Assembler subroutines using CALL technique number 4.  The user has no way of
changing the code generation of a compiler or the vendor software but must
ensure that RMODE is below the 16MB line while the AMODE can be
handled/corrected by the macros.

The macros that have been developed are:

¥    INITR - for program initialisation
¥    EXITR - for program return
¥    BALRXA - a substitute for Assembler BALR R14,R15
¥    CALLXA - a substitute for CALL
¥    BSM24 - for setting addressing mode to 24-bit mode
¥    BSM31 - for setting addressing mode to 31-bit mode
¥    TESTXA - for testing for 370 or XA and 24- or 31-bit mode.

BSM24, BSM31, and TESTXA are inner macros to INITR, EXITR, BALRXA, and CALLXA
but can also be used directly.


INITR

* INITR MACRO CREATES SUBPROGRAM LINKAGE IN FULL REENTRANT CODE:
*   THIS MACRO REQUIRES RETURN TO CALLER VIA MACRO EXITR.
*   WORKS IN MVS/370 AND MVS/XA ENVIRONMENT.
*   SAVES REGISTERS.  GETMAINS NEW SAVE AREA (BELOW 16MB TO ENSURE
*   FREE FLOW BETWEEN 24 AND 31 BIT MODE PROGRAMS).
*   THE SIZE OF THE GETMAINED DEFAULTS TO 72 FOR SAVE AREA BUT CAN
*   VIA SIZE PARAMETER BE BIGGER IF THE PROGRAM SHOULD GETMAIN A
*   WORK AREA FOR REENTRANCY.
*   GETMAIN CAN TAKE PLACE IN OTHER AREAS BY LOC=ANY OR LOC=RES.
*   SETS A BASE REGISTER (DEFAULT TO R21);  BASEREG POINTS TO PROGRAM
*   ENTRY POINT FOR EASE OF DEBUGGING:
*   CREATES REGISTER EQUATES (R0 TO R15)
*   CREATES PROGRAM NAME AND COMPILATION TIMESTAMP EYECATCHER.
*   CREATES AMODE, RMODE AND SPLEVEL.
*   GENERATES CODE THAT CHECKS THAT ASSEMBLED ADDRESSING MODE
*   CORRESPONDS TO EXECUTION ADDRESSING MODE:
*   IF ASSEMBLED IN AMODE 24 AND ENTERED IN 31 MODE, MODE IS CHANGED
*   TO 24:  IF ASSEMBLED IN AMODE 31 AND ENTERED IN 24 MODE (CAN ONLY
*   HAPPEN WHEN RESIDING UNDER 16M) MODE IS CHANGED TO 31; IF ASSEMBLED
*   IN AMODE ANY IT CAN BE ENTERED IN ANY ADDRESSING MODE.
         MACRO
&NAME    INITR &BASEREG=12,                                            *
               &SECBASE=0,                                             *
               &TERBASE=0,                                             *
               &SUBPOOL=0,                                             *
               &SIZE=72,                                               *
               &LOC=BELOW,                                             *
               &SPLEVEL=2,                                             *
               &AMODE=31,                                              *
               &RMODE=ANY
* INITR PARAMETERS: BASEREG, DEFAULTS TO R12; NO SECONDARY AND TERTIARY
* BASEREG IS DEFAULT.
* SIZE DEFAULTS TO 72, SUBPOOL DEFAULTS TO 0 FOR SAVE/WORK GETMAIN.
* SPLEVEL, DEFAULTS TO 2 FOR MVS/XA MACRO EXPANSIONS; CAN BE SET
* TO 1 FOR 370 MACRO EXPANSIONS PROVIDED 370 MACRO LIBRARY IS
* REFERENCED.
* AMODE, DEFAULTS TO 31. RMODE, DEFAULTS TO ANY.
* AMODE  RMODE  SPLEVEL COMBINATIONS VALID:
*  24     24       1
*  ANY    24    1 OR 2
*  31     ANY      2
*  31     24       2
         LCLC  &DT,&TM,&AM,&RM,&SP
         LCLC  &NONCHK,&START
&NONCHK  SETC  'IN1'.'&SYSNDX'
&START   SETC  'IN2'.'&SYSNDX'
&YY      SETC  '&SYSDATE'(7,2)
&MM      SETC  '&SYSDATE'(1,2)
&DD      SETC  '&SYSDATE'(4,2)
&TM      SETC  '&SYSTIME'
         GBLC  &GETPOOL
         GBLC  &MSIZE
&GETPOOL SETC  '&SUBPOOL'
&MSIZE   SETC  'IN3'.'&SYSNDX'
&OFFSET  SETC  'IN4'.'&SYSNDX'
&TEMPBS  SETC  'IN5'.'&SYSNDX'
&NAME    CSECT
         AIF   ('&BASEREG' NE '1').BASER
         MNOTE 8,'BASEREG CAN NOT BE R1'
         MEXIT
.BASER   ANOP
         AIF   ('&SECBASE' NE '1').SECBR
         MNOTE 8,'SECBASE CAN NOT BE R1'
         MEXIT
.SECBR   ANOP
         AIF   ('&TERBASE' NE '1').TERBR
         MNOTE 8,'TERBASE CAN NOT BE R1'
         MEXIT
.TERBR   ANOP
         AIF   ('&TERBASE' EQ '0').TERBO
         AIF   ('&SECBASE' NE '0').TERBO
         MNOTE 8,'SECBASE MUST BE SET IF TERBASE IS SET'
         MEXIT
.TERBO   ANOP
         AIF   ('&BASEREG' NE '&SECBASE').PSBR
         MNOTE 8,'PRIMARY BASE AND SECONDARY MAY NOT BE EQUAL'
         MEXIT
.PSBR    ANOP
         AIF   ('&BASEREG' NE '&TERBASE').PTBR
         MNOTE 8,'PRIMARY BASE AND TERTIARY MAY NOT BE EQUAL'
         MEXIT
.PTBR    ANOP
         AIF   ('&TERBASE' EQ '0').STBR
         AIF   ('&SECBASE' NE '&TERBASE'),STBR
         MNOTE 8,'SECBASE AND TERBASE MUST BE UNEQUAL'
         MEXIT
.STBR    ANOP
         AIF   ('&SIZE' GT '71').SSIZE
         MNOTE 8,'SIZE OF SAVE/WORK MUST BE AT LEAST 72 BYTES'
         MEXIT
.SSIZE   ANOP
         AIF   ('&AMODE' NE '24').AM31
         AIF   ('&RMODE' EQ '24').AMRM24
         MNOTE 8,'WHEN AMODE=24, RMODE MUST BE 24 ALSO'
         MEXIT
.AMRM24  ANOP
         AIF   ('&SPLEVEL' EQ '1').AMRM241
         MNOTE 8,'WHEN AMODE=24 AND RMODE=24, SPLEVEL MUST BE 1'
         MEXIT
.AMRM241 ANOP
         AGO   .SETMODE
.AM31    ANOP
         AIF   ('&AMODE' NE '31').AMANY
         AIF   ('&RMODE' EQ '24').AM31RM
         AIF   ('&RMODE' EQ 'ANY').AM31RM
         MNOTE 8,'WHEN AMODE=31, RMODE MUST BE 24 OR ANY'
         MEXIT
.AM31RM  ANOP
         AIF   ('&SPLEVEL' EQ '2').AMRM31
         MNOTE 8,'WHEN AMODE=31, SPLEVEL MUST BE 2'
         MEXIT
.AMRM31  ANOP
         AGO   .SETMODE
.AMANY   ANOP
         AIF   ('&AMODE' EQ 'ANY').AMANYRM
         MNOTE 8,'AMODE IS NOT 24, 31 OR ANY'
         MEXIT
.AMANYRM ANOP
         AIF   ('&RMODE' EQ '24').AMANY24
         MNOTE 8,'WHEN AMODE=ANY, RMODE MUST BE 24'
         MEXIT
.AMANY24 ANOP
         AIF   ('&SPLEVEL' EQ '1').AMANYSP
         AIF   ('&SPLEVEL' EQ '2').AMANYSP
         MNOTE 8,'WHEN AMODE=ANY, SPLEVEL MUST BE 1 OR 2'
         MEXIT
.AMANYSP ANOP
         AGO   .SETMODE
.SETMODE ANOP
&AM      SETC  '&AMODE'
&RM      SETC  '&RMODE'
&SP      SETC  '&SPLEVEL'
&NAME    AMODE &AM               ADDRESSING MODE
&NAME    RMODE &RM               RESIDENCY MODE
         SPLEVEL SET=&SP         SET MACRO LEVEL 370 OR XA
         SPLEVEL TEST            SET SYSSPLY
R0       EQU   0                 REGISTER EQU
R1       EQU   1                 -        -
R2       EQU   2                 -        -
R3       EQU   3                 -        -
R4       EQU   4                 -        -
R5       EQU   5                 -        -
R6       EQU   6                 -        -
R7       EQU   7                 -        -
R8       EQU   8                 -        -
R9       EQU   9                 -        -
R10      EQU   10                -        -
R11      EQU   11                -        -
R12      EQU   12                -        -
R13      EQU   13                -        -
R14      EQU   14                -        -
R15      EQU   15                -        -
         CNOP  0,4 .                      ALIGNMENT
         STM   14,12,12(13) .             SAVE REGISTERS
         USING &NAME,15 .                 MAKE INITIAL ADDRESSABILITY
         AIF   ('&AMODE' EQ 'ANY').NOCHK
         BALR  1,0 .                      GET ADDRESSING MODE
         LTR   1,1 .                      TEST FOR 31 OR 24 BIT MODE
         AIF   ('&AMODE' EQ '31').CHK31
         BNM   &NONCHK .                  ADDRESSING MODE OK
         BSM24 (1) .                      CHANGE TO 24 BIT MODE
         AGO   .NOCHK
.CHK31   ANOP
         BM    &NONCHK                    ADDRESSING MODE OK
         BSM31 (1) .                      CHANGE TO 31 BIT MODE
         AGO   .NOCHK
.NOCHK   ANOP
&NONCHK  DS    0H .
         BALR  1.0                        SET UP BASE REG FOR EVT MODE SW
&TEMPBS  DS    0H .
         USING *,1 .                      MAKE TEMPORARY ADDRESSABILITY
         DROP  15 .                       DROP INITIAL BASEREG
         LR    &BASEREG,1 .               BUILD FINAL BASEREG
         S     &BASEREG,&OFFSET           LET BASE POINT TO ENTRY (DEBUG)
         USING &NAME.&BASEREG .           MAKE ADDRESSABILITY
         DROP  1 .                        DROP TEMPORARY BASEREG
         AIF   ('&SECBASE' EQ '0').SECN
         USING &NAME+4096,&SECBASE .      MAKE SECONDARY BASE REG
         LA    &SECBASE,2048(&BASEREG)    MAKE SECONDARY BASE REG
         LA    &SECBASE,2048(&SECBASE)    MAKE SECONDARY BASE REG
.SECN    NOP
         AIF   ('&TERBASE' EQ '0').TERN
         USING &NAME+9192,&TERBASE .      MAKE TERTIARY BASE REG
         LA    &TERBASE,2048(&SECBASE)    MAKE TERTIARY BASE REG
         LA    &TERBASE,2048(&TERBASE)    MAKE TERTIARY BASE REG
.TERN    NOP
         B     &START .                   BRANCH AROUND ID AND DATE
         DC    CL8'&NAME' .               CSECT ID
         DC    CL9'&YY..&MM..&DD' .       COMPILATION DATE
         DC    CL5'&TM' .                 COMPILATION TIME
&MSIZE   DC    A(&SIZE) .                 SIZE FOR GETMAIN
&OFFSET  DC    A(&TEMPBS-&NAME) .         OFFSET FOR BASERG COMPUTATION
&START   DS    0H .                       BEGIN OF OWN CODE
         AIF   ('&SP' EQ '1').SP1GETM
         AIF   ('&LOC' NE 'BELOW').GETRU
.SP1GETM ANOP
         L     0.&MSIZE .               SET UP FOR GETMAIN OF SAVE/WORK
         LA    1,&SUBPOOL  .              INDICATE SUBPOOL NO
         SLL   1,24 .                     INDICATE SUBPOOL NO
         OR    0,1 .                      SET UP FOR GETMAIN
         GETMAIN R,LV=(0) .               GETMAIN SAVE/WORK
         AGO   .SAVE
.GETRU   ANOP
         L     0,&MSIZE .               SET UP FOR GETMAIN OF SAVE/WORK
         GETMAIN RU,LV=(0),SP=&SUBPOOL,LOC=&LOC   GETMAIN SAVE/WORK
.SAVE    ANOP
         ST    13,4(1) .                  SAVE POINTER TO PREV SAVE
         ST    1,8(13) .                  POINT FROM PREV
         LM    15,1,16(13) .              RESTORE WORK REGISTERS
         L     13,8(13) .                 SET UP STANDARD SAVE POINTER
         MEND


EXITR

* EXITR RETURNS TO CALLER (SHOULD BE USED TOGETHER WITH INITR):
*  RESTORES REGISTERS
*  FREEMAINS GETMAINED SAVEAREA
*  SETS RETURNCODE, DEFAULTS TO ZERO: USE ABSOLUTE OR REGISTER NOTATION
*   UNDER MVS/370 RETURN WILL BE DONE ON BRANCH ON R14
*   UNDER MVS/XA RETURN WILL BE DONE USING BSM 0,R14 TO RESTORE
*    CALLERS ADDRESSING MODE; WHATEVER THE SUBROUTINE WAS CALLED BY
*    BALR R14,R15 OR BY BASSM R14,R15, R14 WILL CONTAIN CALLER'S
*    ADDRESSING MODE.  NOTE THAT UNDER MVS/XA THE EXITR REQUIRES THIS
*    KIND OF CALL TECHNIQUE; IF THE SUBROUTINE IS LINKED BY, EG
*    LA R14,RETURN, L R15,ADDRSUBR AND BR R15 WHERE ADDRSUBR IS A 31
*    BIT ADDRESS MISSING MODE BIT INDICATION IN BIT 0, THE EXITR WILL
*    RETURN IN 24 BIT MODE ALTHOUGH IT SHOULD RETURN IN 31 BIT MODE.
*    TO FORCE A BR R14 AVOIDING BSM MODE CHANGE UNDER XA USE PARA-
*    METER BR14=YES.
         MACRO
&NAME    EXITR &RC=0,&BR14=NO
&NAME    DS    0H
         GBLC  &MSIZE
         GBLC  &GETPOOL
         LCLC  &NONXA
&NONXA   SETC  'EXR'.'&SYSNDX'
         LA    1,&GETPOOL .               INDICATE SUBPOOL NO
         SLL   1,24 .                     INDICATE SUBPOOL NO
         L     0,&MSIZE .                 SET UP FOR FREEMAIN
         OR    0,1 .                      SET UP FOR FREEMAIN
         LR    1,13 .                     SET UP FOR FREEMAIN
         L     13,4(13) .                 R13 -> PREV SAVEAREA
         AIF   ('&RC'(1,1) EQ '(').RCRET
         LA    14,&RC .                   SET RETURN CODE
         AGO   .EXITRE
.RCRET   ANOP
         LR    14,&RC(1).                 SAVE RETURN CODE
.EXITRE  ANOP
         FREEMAIN R,LV=(0),A=(1) .        FREEMAIN SAVEAREA
         AIF   ('&BR14' EQ 'YES').USEBR14
         AIF   ('&BR14' EQ 'NO').BSMBR14
         MNOTE 8,'BR14 MUST BE EITHER YES OR NO'
         MEXIT
.BSMBR14 ANOP
         TESTXA (15) .                    FIND OUT WHICH MODE
         LTR   15,15 .                    TEST MODE
         BP    &NONXA .                   THEN NON XA MODE
         LR    15,14 .                    SET RETURN CODE
         L     14,12(13) .                RESTORE R14
         LM    0,12,20(13) .              RESTORE R0 TO R12
         BSM   0,14 .                     BRANCH BACK TO CALLER
.USEBR14 ANOP
&NONXA   DS    0H .
         LR    15,14 .                    SET RETURN CODE
         L     14,12(13) .                RESTORE R14
         LM    0,12,20(13) .              RESTORE R0 TO R12
         BR    14 .                       BRANCH BACK TO CALLER
         MEND

The remaining macros, BALRXA, CALLXA, BSM24, BSM31, and TESTXA, will be printed
in next month's issue.


Nils Plum
Systems Programmer (Denmark)  © Nils Plum 1987
































