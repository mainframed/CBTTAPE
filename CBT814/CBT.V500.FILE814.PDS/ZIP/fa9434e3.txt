Low-level resource monitoring
As part of the task of software performance evaluation, one may periodically
find it desirable to be able to capture resource consumption data for every
invocation of a particular program.  If the program is executed exclusively as
the first and only module in a batch job step or as a TSO command, the process
is relatively simple using the appropriate SMF records generated by MVS or by
various vendor product offerings.
However, if the program in question is also invoked as a subroutine in different
environments, the task of monitoring it fully, using standard methods, becomes
exceedingly difficult.  For example, the IEBCOPY utility can be executed as a
job step program, but in addition it is invoked dynamically by the ISPF menu 3.1
COMPRESS function, and by SMP(E) for both compress and copy operations.  In the
latter instances, accurate determination of the resources used solely by IEBCOPY
is virtually impossible.
The solution to the above problem is found in a facility which can function as a
front end/back end to the program to be monitored.  The front end gains control
at the point at which the target program normally would, saves the initial
environment, captures resource consumption information at that point, restores
the initial environment, and passes control to the target program.  Upon return,
the back end captures final resource consumption information, and writes a data
(ie SMF) record containing the necessary items.  A report generator can
subsequently be used to process the records generated, subtracting initial
values from final values to derive actual resource consumption, and presenting
the results in a meaningful format.
The EXECUMON facility implements the above method.  It is capable of monitoring
down to the CSECT or entryname level in a multi-CSECT module.  Typically, it is
used to monitor the first or only CSECT or entryname to receive control, which
means that resource consumption information for the program module as a whole is
captured.  EXECUMON will not work if the CSECT or entryname to be monitored uses
XCTL or an equivalent mechanism to pass control elsewhere without return; in
such a case the back-end portion would not receive control.  Fortunately, with
the exception of a few specific areas in MVS system code, XCTL is not widely
used.  Major data items captured by EXECUMON are:
1    From  the  ASCB:   CPU/SRB time (reported in seconds) and I/O count.
2    From the output of SYSEVENT macros: service values for CPU, SRB, IOC, and
MSO.
ASCB-resident values are machine-dependent while service values are machine-
independent; thus conversion factors must be applied to derive one from the
other.  EXECUMON by default generates SMF record-type 255 subtype 1.  This can
be changed if necessary to conform to installation requirements.  The subtype
field does not have the same offset and length as that of certain standard
systems SMF records, eg type 30s and type 70 series.
EXECUMON attempts to avoid user program disruption in case it detects an error;
error messages are issued via WTL, therefore if results are not as expected
SYSLOG should be scanned for any problems.
EXECUMON SOURCE CODE
* EXTRACT 'SYSPARM' VALUES
         LCLA  &PARMSL,&INDEX,&STRTCOL
         LCLC  &LMODM,&CSECTM,&CSECTTN,&AMODE,&RMODE
&PARMSL  SETA  K'&SYSPARM
&INDEX   SETA  1
&STRTCOL SETA  &INDEX
.LOOP1   ANOP
         AIF   ('&SYSPARM'(INDEX,1) EQ ',').COMMA1
&INDEX   SETA  &INDEX+1
         AGO   .LOOP1
.COMMA1  ANOP
&LEN     SETA  &INDEX.&STRTCOL
&LMODM   SETC  '&SYSPARM'(&STRTCOL,&LEN)
&INDEX   SETA  &INDEX+1
&STRTCOL SETA  &INDEX
.LOOP2   ANOP
         AIF   ('&SYSPARM'(&INDEX,1) EQ ',').COMMA2
&INDEX   SETA  &INDEX+1
         AGO   .LOOP2
.COMMA2  ANOP
&LEN     SETA  &INDEX-&STRTCOL
&CSECTM  SETC  '&SYSPARM'(&STRTCOL,&LEN)
&INDEX   SETA  &INDEX+1
&STRTCOL SETA  &INDEX
.LOOP3   ANOP
         AIF   ('&SYSPARM'(&INDEX,1) EQ ',').COMMA3
&INDEX   SETA  &INDEX+1
         AGO   .LOOP3
.COMMA3  ANOP
&LEN     SETA  &INDEX-&STRTCOL
&CSECTTN SETC  '&SYSPARM'(&STRTCOL,&LEN)
&INDEX   SETA  &INDEX+1
&STRTCOL SETA  &INDEX
.LOOP4   ANOP
         AIF   ('&SYSPARM'(&INDEX,1) EQ ',').COMMA4
&INDEX   SETA  &INDEX+1
         AGO   .LOOP4
.COMMA4  ANOP
&LEN     SETA  &INDEX-&STRTCOL
&AMODE   SETC  '&SYSPARM'(&STRTCOL,&LEN)
&INDEX   SETA  &INDEX+1
&STRTCOL SETA  &INDEX
&LEN     SETA  &PARMSL-&STRTCOL+1
&RMODE   SETC  '&SYSPARM'(&STRTCOL,&LEN)
         PUNCH ' CHANGE &CSECTM.(&CSECTTN)'
         PUNCH ' INCLUDE LMODLIB(&LMODM)'
         PUNCH ' CHANGE EXECUMON(&CSECTM)'
EXECUMON CSECT
EXECUMON AMODE &AMODE
EXECUMON RMODE &RMODE
         STM   R14,R12,12(R13)          SAVE REGISTERS
         LR    R12,R15                  ESTABLISH BASE
         USING EXECUMON,R12             DECLARE IT
         CNOP  0,4                      FULLWORD ALIGN
         ICM   R0,15,*+8                LOAD SUBPOOL AND LENGTH
         B     *+8                      BRANCH AROUND IT
         DC    AL1(0),AL3(WORKLEN)      SUBPOOL AND LENGTH
         LR    R3,R0                    PREPARE FOR MVCL CLEAR
         LA    R3,0(R3)                 CLEAR HIGH ORDER BIT/BYTE
         GETMAIN R,LV=(R0)              GET SAVE AREA STORAGE
         LR    R2,R1
         SR    R4,R4
         SR    R5,R5
         MVCL  R2,R4                    CLEAR STORAGE
         ST    R13,4(R1)                CHAIN SAVE AREAS
         ST    R1,8(R13)
         LR    R15,R13
         LR    R13,R1
         LM    R0,R4,20(R15)
         B     @LINKE                   GO START PROGRAM
RETURN   SR    R15,R15                  CLEAR R15
         LR    R2,R15                   SAVE R15 IF BRANCH TO RETURN+2
         LR    R3,R0                    SAME FOR R0
         LR    R1,R13                   SAVE CURRENT SAVE AREA ADDRESS
         L     R13,4(R13)               RELOAD OLD SAVE AREA ADDRESS
         CNOP  0,4                      FULLWORD ALIGN
         ICM   R0,15,*+8                SUBPOOL AND LENGTH
         B     *+8
         DC    AL1(0),AL3(WORKLEN)
         FREEMAIN R,LV=(R0),A=(R1)      FREE SAVE AREA STORAGE
         LR    R15,R2                   RESTORE REGISTERS
         LR    R0,R3
         L     R14,X'10'                CVT ADDR
         TM    X'74'(R14),X'80'         XA?
         BZ    *+14                     NO
         LM    R1,R12,24(R13)           XA
         L     R14,12(,R13)
         BSM   0,R14
         LM    R1,R12,24(R13)           NON-XA
         L     R14,12(,R13)
         BR    R14
@LINKE   USING EXMNWORK,R13
         LR    R9,R1                    SAVE R1
         MVC   WTLLD(WTLLDL),WTLLC      INITIALIZE WTL LIST FORM
         L     R3,PSATOLD-PSA           CURRENT TCB ADDR
         L     R4,TCBJSCB-TCB(R3)       JSCB ADDR
         N     R4,=A(X'00FFFFFF')       CLEAR HIGH BYTE
         L     R5,JSCBSSIB-IEZJSCB(R4)  SSIB ADDR
         MVC   EXMNJID,SSIBJBID-SSIB(R5) SAVE JOB ID
         LA    R1,EXMNSTA1              SYSEVENT OUTPUT AREA 1
         SYSEVENT REQSVDAT,ENTRY=SVC    GET STARTING STATISTICS
         B     *+4(R15)                 HANDLE SYSEVENT RETURN CODE
         B     EXMN0530                 SYSEVENT WAS OK
         STH   R15,EXMNRC               SAVE RETURN CODE
         LA    R1,MSG03                 ERROR MESSAGE ADDR
         BAL   R14,EXMN6000             ISSUE WTL
         B     EXMN0550                 SKIP FURTHER ACTIVITY
EXMN0530 L     R1,PSAAOLD-PSA           ASCB ADDRESS
         MVC   EXMNTCP1,ASCBTCPT-ASCB(R1) STARTING TCB TIME
         MVC   EXMNSCP1,ASCBSCPT-ASCB(R1) STARTING SRB TIME
         MVC   EXMNIO1,ASCBIOSC-ASCB(R1)  STARTING I/O COUNT
         STCK  EXMNCIT                  STORE CSECT INITIATION TIME
EXMN0550 LR    R1,R9                    RESTORE R1 CONTENTS AT ENTRY
         L     R15,=V(&CSECTTN)         GET ENTRY POINT
         BALR  R14,R15                  GO TO IT
         CLC   =H'0',EXMNRC             ANY EXECUMON ERRORS SO FAR?
         BNE   RETURN+2                 YES, RETURN IMMEDIATELY
         STCK  EXMNCTT                  STORE CSECT TERMINATION TIME
         L     R1,PSAAOLD-PSA           ASCB ADDRESS
         MVC   EXMNTCP2,ASCBTCPT-ASCB(R1) ENDING TCB TIME
         MVC   EXMNSCP2,ASCBSCPT-ASCB(R1) ENDING SRB TIME
         MVC   EXMNIO2,ASCBIOSC-ASCB(R1)  ENDING I/O COUNT
         STM   R15,R0,RETSAVE           SAVE CALLED CSECT RETURN CODES
         LA    R1,EXMNSTA2              SYSEVENT OUTPUT AREA 2
         SYSEVENT REQSVDAT,ENTRY=SVC    GET ENDING STATISTICS
         B     *+4(R15)                 HANDLE SYSEVENT RETURN CODE
         B     EXMN0750                 SYSEVENT WAS OK
         LA    R1,MSG05                 ERROR MESSAGE ADDR
         BAL   R14,EXMN6000             INVOKE ISSUING ROUTINE
         LM    R15,R0,RETSAVE           LOAD CALLED CSECT RETURN CODES
         B     RETURN+2                 RETURN IMMEDIATELY
EXMN0750 MVC   EXMNLEN(2),=AL2(EXMNSIZ) RECORD LENGTH
         MVC   EXMNSEG(2),=AL2(0)       SEGMENT DESCRIPTOR
         L     R1,CVTPTR                CVT ADDR
         TM    CVTDCB-CVT(R1),CVTMVSE   XA?
         BZ    EXMN0800                 NO
         OI    EXMNFLG,X'04'            YES
EXMN0800 OI    EXMNFLG,X'02'            SET VS2 BIT
         MVC   EXMNRTY,=AL1(255)        RECORD TYPE - CHANGE TO SUIT
         MVC   EXMNSTP,=AL1(1)          RECORD SUBTYPE
         L     R6,TCBTCT-TCB(R3)        TCT POINTER
         N     R6,=A(X'00FFFFFF')       CLEAR HIGH BYTE
         L     R6,TCTJMR-SMFTCT(R6)     JMR POINTER
         MVC   EXMNSID,JMRCPUID-JMR(R6) MOVE SYSTEM ID
         MVC   EXMNJBN,JMRJOB-JMR(R6)   MOVE JOBNAME
         MVC   EXMNRST,JMRENTRY-JMR(R6) MOVE ENTRY TIME
         MVC   EXMNRSD,JMREDATE-JMR(R6) MOVE ENTRY DATE
         MVC   EXMNUIF,JMRUSEID-JMR(R6) MOVE USER IDENTIFICATION
         L     R6,JSCSCT-IEZJSCB(R4)    SCT POINTER
         N     R6,=A(X'00FFFFFF')       CLEAR HIGH BYTE
         LA    R6,16(R6)                BUMP PAST PREFIX
         MVC   EXMNPGMN,SCTPGMNM-INSMSCT(R6) MOVE JOBSTEP PROGRAM NAME
         MVC   EXMNSTMN,SCTSNAME-INSMSCT(R6) MOVE JOBSTEP NAME
         L     R6,JSCBJCT-IEZJSCB(R4)   JCT POINTER
         N     R6,=A(X'00FFFFFF')       CLEAR HIGH BYTE
         LA    R6,16(R6)                BUMP PAST PREFIX
         L     R6,JCTACTAD-INJMJCT(R6)  ACT POINTER
         SRL   R6,8                     GET IT INTO LOW ORDER 3 BYTES
         LA    R6,16(R6)                BUMP PAST PREFIX
         MVC   EXMNPRGN,ACTPRGNM-IEFAACTB(R6) MOVE PGMR NAME FIELD
         MVC   EXMNLMOD,=CL8'&LMODM'    MOVE MONITORED LOAD MODULE NAME
         MVC   EXMNCSCT,=CL8'&CSECTM'   MOVE MONITORED LOAD MODULE NAME
         TIME  BIN                      DATE AND TIME
         STCM  R0,15,EXMNTME            STORE SMF PRESENTATION TIME
         STCM  R1,15,EXMNDTE            STORE SMF PRESENTATION DATE
         SMFWTM EXMNFLDS                WRITE SMF RECORD
         LTR   R15,R15                  SMFWTM OK?
         BZ    EXMN5000                 YES
         LA    R1,MSG10                 ERROR MESSAGE ADDR
         BAL   R14,EXMN6000             INVOKE ISSUING ROUTINE
EXMN5000 LM    R15,R0,RETSAVE           LOAD CALLED PGM. RETURN REGS.
         B     RETURN+2                 RETURN
***   INTERNAL ROUTINES   ***
EXMN6000 ST    R14,R14SAVE              SAVE RETURN ADDR
         MVC   WTLLD+04(50),0(R1)       MOVE MESSAGE
         CVD   R15,WORK1                CONVERT RETURN CODE
         UNPK  WORK2(8),WORK1(8)        UNPACK IT
         OI    WORK2+7,X'F0'            DE-SIGN
         MVC   WTLLD+45(02),WORK2+6     MOVE TO OUTPUT MESSAGE
         MVC   WTLLD+04(L'EXMNJID),EXMNJID MOVE JOB ID
         WTL   MF=(E,WTLLD)             ISSUE MESSAGE
         L     R14,R14SAVE              LOAD RETURN ADDR
         BR    R14                      RETURN
***   DATA AREAS   ***
         DS    0F
WTLLC    WTL   '                                                  ',   X
               MF=L
MSG03    DC    CL50'XXXXXXXX  EXMN03 - SYSEVENT1 ERROR  RC=XX (DEC.)'
MSG05    DC    CL50'XXXXXXXX  EXMN05 - SYSEVENT2 ERROR  RC=XX (DEC.)'
MSG10    DC    CL50'XXXXXXXX  EXMN10 - SMFWTM ERROR     RC=XX (DEC.)'
         LTORG
***   DSECTS   ***
EXMNWORK DSECT
         DS    18F                     REGISTER SAVE AREA
EXMNFLDS DS    0C                      SMF RECORD FIELDS
EXMNLEN  DS    CL2                     RECORD LENGTH
EXMNSEG  DS    CL2                     SEGMENT DESCRIPTOR
EXMNFLG  DS    CL1                     SYSTEM INDICATOR
EXMNRTY  DS    CL1                     RECORD TYPE
EXMNTME  DS    CL4                     TIME RECORD PRESENTED TO SMF
EXMNDTE  DS    CL4                     DATE RECORD PRESENTED TO SMF
EXMNSID  DS    CL4                     SMF ID
EXMNSTP  DS    CL1                     RECORD SUBTYPE
EXMNJBN  DS    CL8                     JOB NAME
EXMNRST  DS    CL4                     READER START TIME
EXMNRSD  DS    CL4                     READER START DATE
EXMNUIF  DS    CL8                     USER IDENTIFICATION
EXMNJID  DS    CL8                     JES JOB ID
EXMNPGMN DS    CL8                     JOBSTEP PROGRAM NAME
EXMNSTMN DS    CL8                     JOBSTEP NAME
EXMNPRGN DS    CL20                    PROGRAMMER NAME
EXMNLMOD DS    CL8                     LOAD MODULE BEING MONITORED
EXMNCSCT DS    CL8                     CSECT BEING MONITORED
EXMNCIT  DS    CL8                     CSECT INITIATION TIME (STCK)
EXMNTCP1 DS    CL8                     CSECT STARTING TCB TIME
EXMNSCP1 DS    CL8                     CSECT STARTING SRB TIME
EXMNIO1  DS    CL4                     CSECT STARTING I/O COUNT
EXMNCTT  DS    CL8                     CSECT TERMINATION TIME (STCK)
EXMNTCP2 DS    CL8                     CSECT ENDING TCB TIME
EXMNSCP2 DS    CL8                     CSECT ENDING SRB TIME
EXMNIO2  DS    CL4                     CSECT ENDING I/O COUNT
         DS    0D                      ALIGNMENT
EXMNSTA1 DS    0CL40                   CSECT STARTING SRM STATISTICS
EXMNSRV1 DS    CL4                     TOTAL SERVICE
EXMNTAT1 DS    CL4                     TRANS. ACT. TIME
EXMNPGP1 DS    CL2                     PERFORMANCE GROUP
EXMNNOT1 DS    CL2                     NO. OF TRANSACTIONS
EXMNRTM1 DS    CL4                     RESIDENCY TIME
EXMNCPU1 DS    CL4                     CPU SERVICE
EXMNIOC1 DS    CL4                     IOC SERVICE
EXMNMSO1 DS    CL4                     MSO SERVICE
EXMNSRB1 DS    CL4                     SRB SERVICE
         DS    CL8                     FOR FUTURE EXPANSION
         DS    0D                      ALIGNMENT
EXMNSTA2 DS    0CL40                   CSECT ENDING SRM STATISTICS
EXMNSRV2 DS    CL4                     TOTAL SERVICE
EXMNTAT2 DS    CL4                     TRANS. ACT. TIME
EXMNPGP2 DS    CL2                     PERFORMANCE GROUP
EXMNNOT2 DS    CL2                     NO. OF TRANSACTIONS
EXMNRTM2 DS    CL4                     RESIDENCY TIME
EXMNCPU2 DS    CL4                     CPU SERVICE
EXMNIOC2 DS    CL4                     IOC SERVICE
EXMNMSO2 DS    CL4                     MSO SERVICE
EXMNSRB2 DS    CL4                     SRB SERVICE
         DS    CL8                     FOR FUTURE EXPANSION
EXMNSIZ  EQU   *-EXMNFLDS
RETSAVE  DS    2F                      PROGRAM RETURN REG. SAVE AREA
EXMNRC   DS    H
WORK1    DS    D
WORK2    DS    D
R14SAVE  DS    F                       INTERNAL ROUTINE RETURN ADDR
         DS    0F
WTLLD    WTL   '                                                 ',    X
               MF=L
WTLLDL   EQU   *-WTLLD                 WTL LIST FORM LENGTH
WORKLEN  EQU   *-EXMNWORK
         IHAPSA
         IHAASCB
         CVT   DSECT=YES
         IEFJMR
         IEFTCT
         IKJTCB
         IEZJSCB
         IEFJSSIB
         DSECT
         IEFASCTB
         DSECT
         IEFAJCTB
         END
This article will be concluded in next month’s issue of MVS Update when we shall
be looking at the JCL used to assemble and link-edit the module together with a
SAS analysis program used to process EXECUMON SMF records.

     © Xephon 1988










