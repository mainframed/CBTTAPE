Subsystems and the subsystem interface
INTRODUCTION
A great deal of misunderstanding and apprehension surround the use of subsystems
and the MVS subsystem interface.  Most of this stems from the fact that
documentation for using the subsystem interface is difficult to locate and what
is available requires significant research to understand.  These barriers,
however, should not prevent the resourceful developer from making significant
use of this valuable interface.
Those who are familiar with MVS are also familiar with two important subsystems:
the master subsystem and the job entry subsystem (either JES2 or JES3).  These
subsystems must function under the same guidelines that will be outlined in this
discussion.  In fact, many of the requests that are passed to the master and job
entry subsystem are also passed to other active subsystems and can be processed
by these subsystems.
Besides the subsystem itself, another area that must be addressed when talking
about subsystems is the subsystem interface.  The subsystem interface is the MVS
component used to pass subsystem function requests to any defined and active
subsystem.  Actions are performed by the subsystem based on the specific request
and information is passed back to the subsystem interface.
To create subsystems and make requests of the subsystem interface, the
appropriate environment must be established.  This article will focus on the
requirements of a proper subsystem environment.
THE SUBSYSTEM ENVIRONMENT
There are five basic components involved in establishing a subsystem and making
requests of the subsystem interface.  These five components are:
1    The subsystem definition
2    The subsystem initialisation
3    The subsystem interface request
4    The subsystem function routine processing
5    The subsystem termination.
Each of these components has distinct requirements, but they must be combined to
form a useful package.  The details of each component will be examined
separately with the sample subsystem providing the examples of component
combination to show the formation of a functional subsystem environment.
THE SUBSYSTEM DEFINITION
A subsystem is defined to MVS using one of three basic methods.  A subsystem can
be defined at system generation through the SCHEDULR macro (see MVS System
Generation).  This will create an entry in the job entry subsystem names table,
which is located in CSECT IEFJESNM.  A second method of subsystem definition is
with the subsystem names table in load module IEFJSSNT located in SYS1.LINKLIB
(see MVS SPL: System Modifications).  The third, and probably most convenient,
method of subsystem definition is with entries in the IEFSSNxx members of the
SYS1.PARMLIB dataset (see MVS SPL: Initialisation and Tuning).  These are
specified at IPL time by using the SSN=xx system parameter.
The significant result of the subsystem definition process is that once MVS has
gone through IPL, an SSCVT (Subsystem Communication Vector Table) control block
has been created for each specified subsystem.  The SSCVT becomes the root for
each subsystem and the information base for the activities the subsystem will
undertake.  Figure 1 shows the location of the SSCVT in the subsystem control
block chain.
If the subsystem has not been pre-defined by one of the three methods previously
described, it is possible to build the SSCVT for a subsystem ‘on the fly’.  The
newly-created SSCVT can be added on to the end of the existing SSCVT chain and
should reside in subpool 241 with a storage key of zero.
THE SUBSYSTEM INITIALISATION
The SSCVT control block for each subsystem is initially created so that the
subsystem it represents is uninitialised.  This is determined by a zero SSVT
(Subsystem Vector Table) pointer.  A subsystem becomes initialised only after
the SSVT has been created and the SSVT pointer in the SSCVT has been updated
with the address of the SSVT.  An initialisation program is used to create the
SSVT and update the SSVT pointer in the SSCVT.  This initialisation program can
be invoked in one of two ways depending upon which of the subsystem definition
methods has been used and what was specified at definition time.
Subsystems defined via the SYSGEN SCHEDULR macro must be initialised by a task
started under the master or job entry subsystem.  This restriction is imposed
because there is no provision for supplying an initialisation routine during
definition.  The best example of this is the job entry subsystem itself.  For
example, an S JES2 command must be issued to initialise JES2 under the master
subsystem.  All other subsystems may also be initialised in this way (eg S
INITSTC), however, for subsystems defined in the subsystems names table or
through IEFSSNxx parameter entries, it is also possible to specify an
initialisation routine that is invoked automatically once the SSCVT has been
created for the subsystem.  Consider the following example with the IEFSSNxx
PARMLIB member containing a definition record:
     SSIT,INITRTN1
In this example control is passed to INITRTN1 (which resides in a LNKLST
library) once the SSCVT has been created for subsystem SSIT.  In addition to
updating the SSVT pointer in the SSCVT, subsystem initialisation also includes
filling in the significant fields of the SSVT.  The key areas of the SSVT
consist of the number of functions supported by the subsystem, the function code
matrix, and the function routine address table.
The SSVTFNUM field is a two-byte field that indicates the number of functions
supported by the subsystem.  The function code matrix consists of 256 bytes -
one for each possible function code.  If a function is to be supported by the
subsystem, the corresponding byte in the function code matrix will contain a
non-zero value (from 1 to 255).  These values represent an index into the
function routine address table of the routine that supports this function.  For
example, if the third byte of the function matrix contains X‘01’, function code
three has as its function routine the entry located first in the function
routine address table.  The function routine address table is composed of four-
byte address fields for each function routine needed for supported functions.
Figure 2 provides an example of an initialised SSVT.
In this example, the first two bytes are uninitialised and represent a reserved
field.  The next two bytes are the SSVTFNUM field with a value of X‘0003’
indicating that this subsystem supports three functions.  The function code
matrix contains non-zero values in its third, fifth, and eighth bytes to
indicate that function codes three, five, and eight are supported.  The function
routine for function code three has entry point address addr1, the function
routine for function code five has entry point address addr3, and the function
routine for function code eight has entry point address addr2.
The SSVT is a variable length control block and as a result it can be extended
to contain other information that may be useful for the subsystem function
routine.
THE SUBSYSTEM INTERFACE REQUEST
Once the subsystem has been initialised, requests can be made to the subsystem.
These requests must pass through the subsystem interface.  This is accomplished
by using the IEFSSREQ macro.  The macro is invoked after a pointer to the
parameter list is placed in register 1.  The parameter list is simply a pointer
to the SSOB (Subsystem Option Block) with bit zero of the parameter list turned
on (see Figure 3).
The key fields in the SSOB are the function code-id, the SSIB (Subsystem
Identification Block) pointer, and the function dependent area pointer.  The
function code-id field indicates the function code for which the subsystem
interface is to make a request.  It must contain a value between 1 and 255.  The
SSIB pointer and the function dependent area pointer may or may not contain a
pointer address.
If the request is to be directed to a specific subsystem, the SSIB pointer must
contain the address of the SSIB that will identify the appropriate subsystem.
If the SSIB pointer is zero, the subsystem interface uses the SSIB pointed to by
the JSCBSSIB field, which is known as the life of job SSIB.  In this case the
subsystem request will be sent to the job entry subsystem under which the
requesting task was initiated.
The function dependent area pointer is used to pass information that is related
to the function code specified.  As an example, a function code 10 request is
issued for every operator command entered.  Each function code 10 request has an
SSOB function dependent area pointer which points to a control block that
contains the address of the console command buffer.
If the request is being made to a specific subsystem, the SSOB must point to an
SSIB that identifies the subsystem.  The SSIBSSNM field will contain the four-
character subsystem name identifying the subsystem which the request is being
made to (see the code below).
*    ASSUME ADDRESSABILITY TO ALL DSECTS HAS BEEN ESTABLISHED
*    INITIALIZE SSVT
         MVI   SSVTFCOD+239,1          FUNCTION 240
         LOAD  EP=SSITSSI2,GLOBAL=(YES,P) LOAD FUNCTION ROUTINE
         ST    R0,SSVTFRTN             SAVE FUNCTION ROUTINE ADDRESS
         MVI   SSVTFNUM+1,1            ONE FUNCTION SUPPORTED
*    ENABLE SUBSYSTEM
         LA    R4,SSVT                 GET SSVT ADDRESS
         ST    R4,SSCTSSVT             SAVE SSVT ADDRESS IN SSCVT
*    INITIALIZE SSOB AND SSIB
         MVC   SSIBID(4),=C'SSIB'      MOVE IN CONTROL BLOCK ID
         LA    R7,36                   GET SSIB LENGTH
         STH   R7,SSIBLEN              SAVE LENGTH
         MVC   SSIBSSNM(4),=C'SSIT'    MOVE IN SUBSYSTEM NAME
         LA    R6,SSIB                 GET SSIB ADDRESS
         ST    R6,SSOBSSIB             SAVE SSIB ADDRESS
         MVC   SSOBID(4),=C'SSOB'      MOVE IN CONTROL BLOCK ID
         XC    SSOBINDV(4),SSOBINDV    CLEAR EXTENTION POINTER
         LA    R7,240                  FUNCTION CODE 240
         STH   R7,SSOBFUNC             SAVE FUNCTION CODE
         LA    R7,20                   GET SSOB LENGTH
         STH   R7,SSOBLEN              SAVE LENGTH
*    MAKE SUBSYSTEM REQUEST
SSIREQ   LA    R1,SSOB                 GET SSOB ADDRESS
         ST    R1,SSOBSAVE             SAVE ADDRESS
         OI    SSOBSAVE,X'80'          SET UPPER BIT
         LA    R1,SSOBSAVE             GET PARAMETER LIST ADDRESS
         IEFSSREQ                      MAKE SSI REQUEST
WORKAREA DSECT
SSOBSAVE DS    F
SSOB     DSECT
SSOBID   DS    CL4                     CONTROL BLOCK ID
SSOBLEN  DS    AL2                     SSOB LENGTH
SSOBFUNC DS    AL2                     FUNCTION ID
SSOBSSIB DS    F                       ADDRESS OF SSIB OR ZERO
SSOBRETN DS    F                       RETURN CODE FROM SUBSYSTEM
SSOBINDV DS    F                       FUNCTION DEPENDENT AREA PTR
SSIB     DSECT
SSIBID   DS    CL4                     CONTROL BLOCK ID
SSIBLEN  DS    AL2                     LENGTH
SSIBFLG1 DS    AL1                     FLAGS
SSIBRESV DS    AL1                     RESERVED
SSIBSSNM DS    CL4                     SUBSYSTEM NAME
SSIBJBID DS    CL8                     JOB IDENTIFIER
SSIBDEST DS    CL8                     DEFAULT USERID FOR SYSOUT
SSIBRSV1 DS    F                       RESERVED
SSIBSUSE DS    F                       RESERVED
SSVT     DSECT
SSVTRSV  DS    XL2                     RESERVED
SSVTFNUM DS    XL2                     NUMBER OF SUPPORTED FUNCTIONS
SSVTFCOD DS    CL256                   FUNCTION CODE MATRIX
SSVTFRTN DS    F                       FUNCTION ROUTINE ADDRESS
SSVTEXT  EQU   *                       SSVT EXTENSION
SSCVT    DSECT
SSCTID   DS    CL4                     CONTROL BLOCK IDENTIFIER
SSCTSCTA DS    F                       PTR TO NEXT SSCVT OR ZERO
SSCTSNAM DS    CL4                     SUBSYSTEM NAME
SSCTFLG1 DS    XL1                     FLAGS
SSCTRSV1 DS    XL1                     RESERVED
SSCTSSVT DS    F                       SSVT POINTER
SSCTSUSE DS    F                       RESERVED
SSCTSYN  DS    F                       HASH TABLE SYMBOL POINTER
SSCTSUS2 DS    F                       RESERVED
SSCTRSV3 DS    F                       RESERVED
In the above example, a request is being made to subsystem SSIT.  The request is
for function 240 within the SSIT subsystem.  There is no function-dependent

information being passed to the fu