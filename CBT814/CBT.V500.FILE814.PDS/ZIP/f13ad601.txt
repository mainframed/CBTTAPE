DASD freespace management

INTRODUCTION

My shop implemented Systems Managed Storage using a third-
party DASD management package in place of DFHSM. As a
result, we did not have DASD threshold management. This
function comes standard with DFHSM in the form of dynamic
migration to level 1 when threshold levels are exceeded. With the
third-party software, this was not a standard function. There was
an option available to purchase an add-on product with the
feature, but budgetary constraints did not allow the expenditure.

Without threshold management, there is an inherent attempt by
DFSMS to keep volume freespace at a relatively consistent level
across the DASD farm. This is part of the selection process in
determining appropriate volumes for each allocation. However,
keeping freespace on a volume at a given level is difficult to
control once datasets are allocated. Secondary extents can use up
more space on a volume than originally expected. In the case of
VSAM files, this can grow significantly because of the possibility
of having 123 extents. Even in cases where only 16 extents are
granted, large requests can take a volume to the limit quickly.

We were periodically finding volumes getting dangerously close
to being out of space, potentially causing abends on files trying to
expand. At the same time, other DASD would have large
amounts of freespace. We had a third-party product to switch
volumes in some cases, but did not have the support for VSAM,
which is where volume space problems showed up most often.
The following was put in place to minimize this exposure.

THE SOLUTION

An Assembler program, called CHKFRSPC (check freespace),
was written to analyse our DASD to determine any need to free
up space. Using IDCAMS DCOLLECT, a low overhead quick
scan of the DASD is possible. As each volume's freespace is
examined, a check is made as to whether a pre-established
threshold has been reached. If the freespace threshold is below an
acceptable value, a job is submitted to invoke DFDSS COPY
processing to clear off a portion of the volume. After some
datasets are moved off the volume, available freespace is back to a
desired level. Various criteria are used in selecting eligible
datasets for COPY processing. The program is coded to consider
only PS, PO, or VSAM files for processing. For VSAM, only
base KSDS data components are analysed. If a data component
gets selected, COPY is performed on the base. For all selected
datasets, prior to issuing the COPY, a check is made to ensure no
outstanding enqueues which prevent successful COPY
completion. For a GDG, the base is also checked for an enqueue.

In addition to the above criteria coded in the program,
considerable flexibility is achieved via PARM values used to
determine how the DASD threshold analysis takes place.
Parameters passed to the program can affect the following
decisions:

o      At what point will a volume be selected for freespace creation
      (Freespace Percentage, FP)?

o      What will the target freespace be if a volume is selected
      (Target Percentage, TP)?

o      At what interval will the program perform the DASD
      freespace analysis and then go back to sleep (sleep time, ST)?

o      Should the program actually create freespace or only
      simulate the process (TEST or LIVE)?

o      Which volumes or storage groups will be selected to do the
      analysis (VL or SG)?

o      Which dataset names will be eligible to move off a volume to
      create freespace (DSNS)?

o      Which management classes will be eligible for movement
      (MGMT)?

Different combinations of these parameters can be used to achieve
the desired results - they all have default values. In addition, the
started task running the program can be modified via operator
command (eg F taskid,FP=10) to change any of these parameters.
An operator command can also request a display (F taskid,DISP)
of the current parameters or force a scan (F taskid,SCAN) without
waiting for an interval to expire.

To maximize the potential for dealing with volume out of space
conditions, there are two cases where a message is sent to a TSO
user if desired action cannot be taken. First, if no datasets are
found eligible to move off a volume, a message to that effect is
generated. Second, if only a portion of the target freespace can be
created, a message is sent indicating the current freespace and
what amount can be reclaimed. An appropriate TSO user-id
should be placed in the code for these messages. Also, the job
card for the DFDSS COPY process should be modified to reflect
shop standards. The program must be linked with AC=1.

SAMPLE JCL

//CHKFRSPC PROC
//STEP01   EXEC PGM=CHKFRSPC,REGION=5M,
//         PARM=('FP=03,TP=08,SG=SGBASE,ST=45,MGMT,DSNS,LIVE')
//*    PARM meanings and possible values:
//*    FP= - Freespace Percentage: volumes with a value less than or
//*          equal will have their freespace increased.  Must be two
//*          digits.  Defaults to 05.
//*    TP= - Target Percentage: if a volume is selected based on FP,
//*          this will be the target freespace the program attempts to
//*          achieve.  Must be two digits.  Defaults to 08.
//*    VL= - Volume: this is the volume(s) to select for analysis.
//*          VL and SG are optional.  If neither are coded, all volumes
//*          are selected.  An asterisk can be used as a mask after
//*          significant characters.  VL can be up to six characters.
//*    SG= - Storage Group: this is the storage group to select for
//*          analysis.  SG is optional.  No masking allowed.  SG can
//*          be up to eight characters.
//*    ST= - Sleep Time: this is the number of minutes the program
//*          will sleep between each iteration of analysing volume
//*          freespace.  Must be two digits.  Defaults to 30.
//*   MGMT - Management classes present for selecting candidate
//*          datasets.  If coded, the COPYMGMT DD contains management
//*          classes to use in selecting datasets to clear off volumes.
//*          Up to ten can be entered, one per line.  The COPYMGMT DD
//*          is defined as eighty-byte records and should be a PDS
//*          member name so modifications can be made while the task
//*          is running.  No masking, matches must be identical, up to
//*          eight characters.
//*   DSNS - Dataset masks present for selecting candidates.  If this
//*          parm is coded, the COPYDSNS DD contains dataset masks to
//*          use in selecting candidates to clear off volumes.  Up to
//*          ten can be entered, one per line.  The COPYDSNS DD must be
//*          defined as eighty-byte records and should be a PDS member
//*          name so modifications can be made while the task is
//*          running.  Available masks are ? for generic character,
//*          * for generic to end of qualifier, and / for generic to
//*          end of dataset name.
//*   TEST - DFDSS TYPRUN=NORUN will be used in jobs submitted to
//*          create freespace.  This is a good way to become familiar
//*          with the process before actually performing any dataset
//*          moves.  TEST is the default processing mode.
//*   LIVE - Jobs submitted to invoke DFDSS COPY processing will
//*          actually perform the dataset copies.
//*   All the above parameters can be invoked and changed via an
//*   operator MODIFY of the running task.  In addition, a MODIFY
//*   SCAN or DISP request can be made of the task to force a scan of
//*   the DASD or to display the currently active parameter values.
//*   If any parameters are changed, an automatic scan of DASD takes
//*   place and the sleep timer is reset from that point.  If a
//*   display is requested, no DASD analysis occurs and the timer will
//*   not be reset.  Halt the task via the P (STOP) operator command.
//SYSPRINT DD   SYSOUT=*
//SYSIN    DD   UNIT=VIO,SPACE=(CYL,(1,1))
//DDCOLECT DD   UNIT=VIO,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=264,RECFM=VB,DSORG=PS)
//VDCOLECT DD   UNIT=VIO,SPACE=(CYL,(1,1)),
//         DCB=(LRECL=264,RECFM=VB,DSORG=PS)
//*
//*  The following two datasets should be PDS member names so
//*  modification requests can be made while the task is running.
//COPYDSNS DD   DSN=ANY.PDS.DATASET(CHKDSNS),DISP=SHR
//COPYMGMT DD   DSN=ANY.PDS.DATASET(CHKMGMT),DISP=SHR
//INTRDR   DD   SYSOUT=(*,INTRDR)

CHKFRSPC SOURCE CODE

CHKFRSPC  CSECT
          STM   R14,R12,12(R13)         SAVE REGS
          LR    R10,R15                 SAVE ENTRY ADDRESS
          LA    R12,2048                SET UP
          LA    R12,2048(R10,R12)          SECOND BASE REG
          USING CHKFRSPC,R10,R12        ESTABLISH ADDRESSABILITY
          LA    R4,REGSAVE              LOAD REGSAVE ADDRESS
          ST    R4,8(R13)               STORE OUR REGSAVE ADDRESS
          ST    R13,4(R4)               STORE CALLING REGSAVE ADDRESS
          LR    R13,R4                  LOAD OUR REGSAVE
          L     R4,0(R1)                GET PARM LENGTH ADDRESS
          EXTRACT COMMLPTR,FIELDS=COMM  GET ADDR OF ECB AND CIB PTRS
          L     R2,COMMLPTR             GET COMMAND LIST ADDRESS
          USING COMLIST,R2              ESTABLISH ADDRESSABILITY
          LM    R6,R7,COMLIST           COMMAND ECB AND CIB POINTERS
          ST    R6,CMDECBPT             STORE ECB POINTER IN ECBLIST
          ICM   R5,15,0(R9)             IS THERE A START COMMAND CIB?
          BZ    CHKFS002                IF NO, MUST BE RUNNING BATCH
          QEDIT ORIGIN=COMCIBPT,BLOCK=(R7) FREE START COMMAND CIB
CHKFS002  QEDIT ORIGIN=COMCIBPT,CIBCTR=1 INDICATE 1 CIB TO BE CHAINED
          DROP  R2
          OPEN  (INTRDR,(OUTPUT))       PREPARE FOR JOB SUBMIT
          LH    R5,0(R4)                LENGTH OF PARM DATA
CHKFS004  LTR   R5,R5                   IS PARM LENGTH ZERO?
          BZ    CHKFS044                YES, NO PARMS
          CLI   MODFLG,C'3'             IS THIS A MODIFY REQUEST?
          BE    CHKFS006                IF YES, SUBTRACT NOT ADD TO R4
          LA    R5,2(R5,R4)             END OF INITIAL PARM DATA
          LA    R4,2(,R4)               POSITION FOR COMPARE
          B     CHKFS007                SKIP MODIFY LOGIC
CHKFS006  LA    R5,0(R5,R4)             END OF PARM ON MODIFY
CHKFS007  MVI   NUMICFLG,C'1'           ASSUME NUMERIC CHECK REQUIRED
          CLC   0(3,R4),=C'SG='         STORAGE GROUP?
          BE    CHKFS009                YES, SAVE IT
          CLC   0(3,R4),=C'VL='         VOLUME?
          BE    CHKFS011                YES, SAVE IT
          CLC   0(3,R4),=C'FP='         FREESPACE PERCENT?
          BE    CHKFS012                YES, SAVE IT
          CLC   0(3,R4),=C'TP='         TARGET PERCENT?
          BE    CHKFS013                YES, SAVE IT
          CLC   0(3,R4),=C'ST='         SLEEP TIME?
          BE    CHKFS014                YES, SAVE IT
          CLC   0(4,R4),=C'DSNS'        DSNS PRESENT?
          BE    CHKFS022                YES, PROCESS THEM
          CLC   0(4,R4),=C'MGMT'        MANAGEMENT CLASSES PRESENT?
          BE    CHKFS028                YES, PROCESS THEM
          CLC   0(4,R4),=C'TEST'        SHOULD DFDSS BE TEST MODE?
          BE    CHKFS020                YES, INDICATE
          CLC   0(4,R4),=C'LIVE'        SHOULD DFDSS BE LIVE MODE?
          BE    CHKFS021                YES, INDICATE
CHKFS008  BCTR  R4,0                    BACK UP 1 CHARACTER
          MVC   WTOBPARM+32(8),0(R4)    SET UP BAD PARM DISPLAY
          WTO   MF=(E,WTOBPARM)         INDICATE BAD PARM DATA
          CLI   MODFLG,C'3'             WAS THIS A MODIFY?
          BE    CHKFS122                IF YES, DON'T ABEND
          ABEND 999
CHKFS009  LA    R6,VDCOLSG2             POINT TO DCOLLECT STORGRP
          MVI   PRIMEFLG,C'1'           INDICATE THERE WAS A STORGRP
          MVC   VDCOLSG1,=C' STOG('     PRIME DCOLLECT
          MVC   VDCOLSG2,=C'        '   BLANK OUT IN CASE MODIFIED
          MVI   VDCOLSG3,C')'
          MVI   NUMICFLG,C'0'           SET NUMERIC CHECK FLAG OFF
          MVC   VDCOLVL1,=C'     '      CAN'T USE VL WITH SG
          MVC   VDCOLVL2,=C'      '
          MVC   VDCOLVL3,=C' '
          B     CHKFS016                GO MOVE IT
CHKFS011  LA    R6,VDCOLVL2             POINT TO DCOLLECT VOLUME
          MVI   PRIMEFLG,C'1'           INDICATE THERE WAS A VOLUME
          MVC   VDCOLVL1,=C' VOL('      PRIME DCOLLECT
          MVC   VDCOLVL2,=C'      '     BLANK OUT IN CASE MODIFIED
          MVI   VDCOLVL3,C')'
          MVI   NUMICFLG,C'0'           SET NUMERIC CHECK FLAG OFF
          MVC   VDCOLSG1,=C'      '     CANT USE SG WITH VL
          MVC   VDCOLSG2,=C'        '
          MVC   VDCOLSG3,=C' '
          B     CHKFS016
CHKFS012  LA    R7,FPPARM               POINT TO FPPARM
          B     CHKFS015
CHKFS013  LA    R7,TPPARM               POINT TO TPPARM
          B     CHKFS015
CHKFS014  LA    R7,STPARM               POINT TO STPARM
CHKFS015  LA    R6,WORKPARM             USE WORKPARM TILL SURE NUMERIC
          SR    R2,R2                   CLEAR REG 2
CHKFS016  LA    R4,3(R4)                BUMP TO ACTUAL PARM VALUE
CHKFS017  CLI   NUMICFLG,C'1'           NUMERIC CHECK REQUIRED?
          BNE   CHKFS018                IF NO, DON'T BOTHER
          TM    0(R4),X'F0'             IS IT NUMERIC?
          BNO   CHKFS008                IF NO, INDICATE BAD PARM
          LA    R2,1(R2)                ADD ONE TO LENGTH COUNTER
          C     R2,=F'2'                TWO BYTES LONG?
          BNH   CHKFS018                IF LESS OR EQUAL, CONTINUE ON
          B     CHKFS008                IF GREATER, IT'S A BAD PARM
CHKFS018  MVC   0(1,R6),0(R4)           MOVE CHARACTER
          LA    R4,1(R4)                NEXT CHARACTER
          CR    R4,R5                   AT END OF PARMS?
          BE    CHKFS042                IF YES, GO PROCESS
          CLI   0(R4),C','              IS IT A COMMA?
          BE    CHKFS035                IF YES, WHAT'S NEXT?
          LA    R6,1(R6)                NEXT POSITION IN SAVED PARM
          B     CHKFS017
CHKFS020  MVC   NORUN,=C',PARM=''TYPRUN=NORUN''' SET NORUN OPTION
          MVC   WTOLIST0+21(4),=C'TEST' INDICATE RUNNING IN TEST MODE
          B     CHKFS034                CONTINUE ON
CHKFS021  MVI   NORUN,C' '              CLEAR NORUN OPTION
          MVC   NORUN+1(L'NORUN-1),NORUN
          MVC   WTOLIST0+21(4),=C'LIVE' INDICATE RUNNING IN TEST MODE
          B     CHKFS034                CONTINUE ON
CHKFS022  OPEN  COPYDSNS                PREPARE TO READ DSNS
          LA    R6,DSNSTABL             ADDRESS DSNS SAVE TABLE
CHKFS024  GET   COPYDSNS                READ A DSN MASK
          MVC   0(44,R6),0(R1)          SAVE IT
          LA    R6,44(R6)               BUMP TO NEXT TABLE ENTRY
          CLC   0(2,R6),=C'XX'          AT END OF TABLE?
          BE    CHKFS037                IF YES, GO SEE IF THERE'S MORE
          B     CHKFS024                GET NEXT ONE
CHKFS026  CLOSE COPYDSNS                CLOSE DSNS FILE
          CLI   MODFLG,C'3'             WAS THIS A MODIFY?
          BE    CHKFS027                IF YES, BLANK REST OF TABLE
          B     CHKFS034                PROCEED TO NEXT PARM
CHKFS027  CLC   0(2,R6),=C'XX'          AT END OF TABLE?
          BE    CHKFS034                IF YES, PROCEED TO NEXT PARM
          MVC   0(44,R6),BLANKS         BLANK OUT TABLE ENTRY
          LA    R6,44(R6)               BUMP TO NEXT ENTRY
          B     CHKFS027                GO SEE IF END
CHKFS028  OPEN  COPYMGMT                PREPARE TO READ MGMT
          LA    R6,MGMTTABL             ADDRESS MGMT SAVE TABLE
CHKFS030  GET   COPYMGMT                READ A MANAGEMENT CLASS
          MVC   0(8,R6),0(R1)           SAVE IT
          LA    R6,8(R6)                BUMP TO NEXT TABLE ENTRY
          CLC   0(2,R6),=C'XX'          AT END OF TABLE?
          BE    CHKFS038                IF YES, GO SEE IF THERE'S MORE
          B     CHKFS030                GET NEXT ONE
CHKFS032  CLOSE COPYMGMT                CLOSE MGMT FILE
          CLI   MODFLG,C'3'             WAS THIS A MODIFY?
          BE    CHKFS033                IF YES, BLANK REST OF TABLE
          B     CHKFS034                PROCEED TO NEXT PARM
CHKFS033  CLC   0(2,R6),=C'XX'          AT END OF TABLE?
          BE    CHKFS034                IF YES, PROCEED TO NEXT PARM
          MVC   0(8,R6),BLANKS          BLANK OUT TABLE ENTRY
          LA    R6,8(R6)                BUMP TO NEXT ENTRY
          B     CHKFS033                GO SEE IF END
CHKFS034  LA    R4,4(R4)                SKIP OVER PARM
          CR    R4,R5                   AT END OF PARMS?
          BE    CHKFS044                IF YES, GO PROCESS
          CLI   0(R4),C','              IS IT A COMMA?
          BE    CHKFS036                IF YES, WHAT'S NEXT?
          B     CHKFS008                WASN'T EXPECTING THIS
CHKFS035  CLI   NUMICFLG,C'1'           NUMERIC CHECK REQUIRED?
          BNE   CHKFS036                IF NO, DON'T MOVE NUMERIC PARM
          C     R2,=F'2'                WAS IT TWO BYTES LONG?
          BNE   CHKFS008                IF NOT, BAD PARM
          MVC   0(2,R7),WORKPARM        NUMERIC PARM OK, SAVE IT
CHKFS036  LA    R4,1(R4)                POSITION FOR COMPARE
          B     CHKFS007                GO LOOK AT NEXT PARM
CHKFS037  GET   COPYDSNS                WAS THAT THE LAST DSNS?
          WTO   '*  MAXIMUM OF 10 DSN COPY MASKS, EXPAND TABLE *'
          ABEND 994
CHKFS038  GET   COPYMGMT                WAS THAT THE LAST MGMT?
          WTO   '*  MAXIMUM OF 10 MGMT CLASSES, EXPAND TABLE *'
          ABEND 995
CHKFS040  WTO   '*  LOGIC ERROR IN DATA DCOLLECT *'
          ABEND 996
CHKFS042  CLI   NUMICFLG,C'1'           WAS LAST PARM NUMERIC
          BNE   CHKFS044                IF NO, DON'T NEED TO MOVE
CHKFS043  C     R2,=F'2'                WAS IT TWO BYTES LONG?
          BNE   CHKFS008                IF NOT, BAD PARM
          MVC   0(2,R7),WORKPARM        NUMERIC PARM OK, SAVE IT
CHKFS044  WTO   MF=(E,WTOLIST0)         DISPLAY PROCESSING MODE
          CLC   FPPARM(2),=C'00'        FREESPACE VALUE PROVIDED?
          BNE   CHKFS046                IF YES, DON'T OVERRIDE
          MVC   FPPARM,FPDEFLT          NOTHING CODED, USE DEFAULT
CHKFS046  MVC   WTOLIST1+30(2),FPPARM   DISPLAY FREESPACE VALUE USED
          WTO   MF=(E,WTOLIST1)
          CLC   TPPARM(2),=C'00'        TARGET VALUE PROVIDED?
          BNE   CHKFS048                IF YES, DON'T OVERRIDE
          MVC   TPPARM,TPDEFLT          NOTHING CODED, USE DEFAULT
CHKFS048  MVC   WTOLIST2+30(2),TPPARM   DISPLAY TARGET VALUE USED
          WTO   MF=(E,WTOLIST2)
          MVC   WTOLIST3+30(2),STPARM   DISPLAY SLEEP TIME VALUE USED
          WTO   MF=(E,WTOLIST3)
          CLI   PRIMEFLG,C'1'           WAS THERE A STORGRP OR VOLUME?
          BNE   CHKFS052                IF NO, PROCESS ALL VOLUMES
          CLC   VDCOLVL2,=C'      '     WAS THERE A VOLUME?
          BNE   CHKFS050                IF YES, GO DISPLAY
          MVC   WTOLIST5+30(8),VDCOLSG2 DISPLAY STORAGE GROUP USED
          WTO   MF=(E,WTOLIST5)
          B     CHKFS056                SKIP VOLUME DISPLAY
CHKFS050  MVC   WTOLIST4+30(6),VDCOLVL2 PRIME VOLUME USED DISPLAY
          B     CHKFS054                SKIP VOLUME PRIMING
CHKFS052  MVC   VDCOLVL1,=C' VOL('      NEED TO PRIME DCOLLECT
          MVC   VDCOLVL2,=C'*     '        FOR ALL
          MVI   VDCOLVL3,C')'                 VOLUMES
          MVC   WTOLIST4+30(6),=C'*     '
CHKFS054  WTO   MF=(E,WTOLIST4)         DISPLAY VOLUME MASK USED
CHKFS056  LA    R6,DSNSTABL             PREPARE TO CHECK DSN MASKS
          CLI   0(R6),C' '              VALID ENTRY?
          BE    CHKFS060                IF NO, THERE WERE NONE
          WTO   MF=(E,WTOLIST6)         DISPLAY DSNTABLE FOLLOWS MSG
CHKFS058  CLC   0(2,R6),=C'XX'          END OF TABLE?
          BE    CHKFS062                IF YES, CONTINUE
          CLI   0(R6),C' '              ENTRY PRESENT?
          BE    CHKFS062                IF NO, CONTINUE
          MVC   WTOLIST7+6(44),0(R6)    DISPLAY DSN MASK
          WTO   MF=(E,WTOLIST7)
          LA    R6,44(R6)               ADDRESS NEXT ENTRY
          B     CHKFS058                GO PROCESS NEXT ENTRY
CHKFS060  MVC   WTOLIST6+30(3),=C'ANY'  INDICATE ANY DATASET ELIGIBLE
          WTO   MF=(E,WTOLIST6)
          MVC   WTOLIST6+30(3),=C'   '  BLANK OUT IN CASE IT CHANGES
CHKFS062  LA    R6,MGMTTABL             ADDRESS MANAGEMENT CLASS TABLE
          CLI   0(R6),C' '              VALID ENTRY?
          BE    CHKFS066                IF NO, THERE WERE NONE
          WTO   MF=(E,WTOLIST8)
CHKFS064  CLC   0(2,R6),=C'XX'          END OF TABLE?
          BE    CHKFS068                IF YES, CONTINUE
          CLI   0(R6),C' '              ENTRY PRESENT?
          BE    CHKFS068                IF NO, CONTINUE
          MVC   WTOLIST9+6(8),0(R6)     DISPLAY MANAGEMENT CLASS
          WTO   MF=(E,WTOLIST9)
          LA    R6,8(R6)                BUMP TO NEXT TABLE ENTRY
          B     CHKFS064                GO PROCESS IT
CHKFS066  MVC   WTOLIST8+30(3),=C'ANY'  INDICATE ANY MGMTCLAS ELIGIBLE
          WTO   MF=(E,WTOLIST8)
          MVC   WTOLIST8+30(3),=C'   '  BLANK OUT IN CASE IT CHANGES
CHKFS068  CLI   MODFLG,C'2'             WAS THIS A DISPLAY REQUEST?
          BE    CHKFS122                IF YES, GO BACK AND WAIT
          OPEN  (SYSIN,(OUTPUT))        GET READY FOR DCOLLECT
          PUT   SYSIN,VDCOLCRD          PUT DCOLLECT OUT TO IDCAMS
          CLOSE SYSIN                   CLOSE SYSIN SO IDCAMS CAN READ
          LA    R1,0                    PREPARE FOR IDCAMS LINK
          LINK  EP=IDCAMS               CALL IDCAMS TO DO DCOLLECT
          LTR   R15,R15                 ZERO RC FROM IDCAMS DCOLLECT?
          BZ    CHKFS070                IF YES, CONTINUE
          WTO   '*  NON ZERO VOLUME DCOLLECT RC, REVIEW SYSPRINT *'
          ABEND 997
CHKFS070  OPEN  VDCOLECT                PREPARE TO READ DCOLLECT DATA
CHKFS072  GET   VDCOLECT                READ DATA FROM DCOLLECT
          LA    R9,4(R1)                POINT TO RECORD
          USING IDCDOUT,R9              ADDRESS DCOLLECT RECORD
          CLI   DCURCTYP,C'V'           VOLUME RECORD?
          BNE   CHKFS072                IF NO, DON'T WANT IT
          CLC   DCVERROR,=X'00'         ANY ERRORS?
          BE    CHKFS074                IF YES, DON'T PROCESS
          MVC   WTOLISTA+32(6),DCVVOLSR INDICATE THERE WAS AN ERROR
          WTO   MF=(E,WTOLISTA)
          B     CHKFS072                GO PROCESS NEXT ONE
CHKFS074  TM    DCVFLAG1,DCVPHYST       IS THIS A MANAGED VOLUME?
          BNO   CHKFS072                IF NO, DON'T WANT IT
          PACK  WORK4,FPPARM            PACK FP PARM
CHKFS075  SR    R4,R4                   ZERO REG 4
          ICM   R4,1,DCVPERCT           LOAD THE FREESPACE VALUE
          CVD   R4,WORK1                CONVERT TO DECIMAL
          CP    WORK4,WORK5             COMPARE ACTUAL WITH PARM
          BL    CHKFS072                IF LESS, BYPASS VOLUME
          UNPK  SEND1FP(2),WORK5        UNPACK ACTUAL FREESPACE
          OI    SEND1FP+1,X'F0'         MAKE DISPLAY PRINTABLE
          MVC   SEND2FP,SEND1FP         SAVE ACTUAL IN OTHER DISPLAY
          PACK  WORK4,TPPARM            PACK TP PARM
          CP    WORK4,WORK5             COMPARE TARGET WITH ACTUAL
          BL    CHKFS072                IF LESS, BYPASS VOLUME
          BE    CHKFS072                IF EQUAL, BYPASS VOLUME
          SP    WORK4,WORK5             GET DIFFERENCE OF PERCENTAGES
          MVC   SAVECAP,DCVVLCAP        SAVE VOLUME CAPACITY
          L     R4,DCVVLCAP             LOAD VOLUME CAPACITY
          CVD   R4,WORK1                CONVERT TO DECIMAL
          DP    WORK1,=PL4'100'         DIVIDE BY 100
          MVC   WORK5,WORK2             SAVE QUOTIENT
          XC    WORK2,WORK2             ZERO WORKAREA
          MP    WORK1,WORK4             MULTIPLY CAPACITY BY TARGET %
          CVB   R5,WORK1                CONVERT AMOUNT TO CLEAR TO HEX
          SR    R4,R4                   CLEAR REG 4
          MVC   DDCOLVOL(6),DCVVOLSR    PRIME THE VOLUME FOR DCOLLECT
          OPEN  (SYSIN,(OUTPUT))        OPEN SYSIN FOR DCOLLECT
          PUT   SYSIN,DDCOLCRD          PUT DCOLLECT OUT TO IDCAMS
          CLOSE SYSIN                   CLOSE SYSIN SO IDCAMS CAN READ
          LA    R1,0                    PREPARE FOR IDCAMS LINK
          LINK  EP=IDCAMS               CALL IDCAMS TO DO DCOLLECT
          LTR   R15,R15                 ZERO RC FROM IDCAMS DCOLLECT?
          BZ    CHKFS076                IF YES, CONTINUE
          WTO   '*  NON ZERO DATA DCOLLECT RC, REVIEW SYSPRINT *'
          ABEND 998
CHKFS076  OPEN  DDCOLECT                PREPARE TO READ DCOLLECT DATA
          MVI   JOBFLG,C'0'             INIT JOB SUBMITTED FLAG
CHKFS078  GET   DDCOLECT                READ DATA FROM DCOLLECT
          LA    R9,4(R1)                POINT TO RECORD
          CLI   DCURCTYP,C'D'           DATASET RECORD?
          BNE   CHKFS078                IF NO, DON'T WANT IT
          CLC   DCDERROR,=X'00'         ANY ERRORS?
          BE    CHKFS080                IF YES, DON'T PROCESS
          WTO   ' DCOLLECT ERROR FOR DATASET:' INDICATE ERRORS EXIST
          MVC   WTOLIST7+6(44),DCDDSNAM
          WTO   MF=(E,WTOLIST7)
          B     CHKFS078
CHKFS080  MVC   SAVESER(6),DCDVOLSR     SAVE VOLSER FOR LATER
          LA    R6,DSNSTABL             PREPARE TO CHECK COPY MASKS
          CLI   0(R6),C' '              VALID ENTRY?
          BE    CHKFS094                IF NO, ANY DATASET ELIGIBLE
CHKFS082  LA    R7,44(R6)               ADDRESS OF NEXT MASK
          CLI   0(R6),C' '              VALID ENTRY?
          BE    CHKFS078                IF NO, WE DIDN'T MATCH
          CLC   0(2,R6),=C'XX'          END OF TABLE?
          BE    CHKFS078                IF YES, DIDN'T MATCH
          LA    R8,DCDDSNAM             ADDRESS DCOLLECT DSNAME
          LA    R3,DCDDSNAM+44          END OF DCOLLECT DSNAME
CHKFS084  CLI   0(R6),C'*'              GENERIC TO END OF QUALIFIER?
          BE    CHKFS086                IF YES, GO PROCESS
          CLI   0(R6),C'?'              GENERIC CHARACTER?
          BE    CHKFS090                IF YES, GET NEXT ONE
          CLI   0(R6),C'/'              GENERIC TO END OF DSN?
          BE    CHKFS094                IF YES, IT'S A HIT
          CLC   0(1,R6),0(R8)           MATCH ON THIS CHARACTER?
          BE    CHKFS090                IF YES, GET NEXT ONE
          LR    R6,R7                   LOAD NEXT MASK ADDRESS
          B     CHKFS082                CHECK NEXT MASK
CHKFS086  LA    R8,1(R8)                POSITION TO NEXT CHARACTER
          CLI   0(R8),C'.'              IS IT A .?
          BE    CHKFS092                IF YES, AT END OF QUALIFIER
          CLI   0(R8),C' '              IS IT A BLANK?
          BE    CHKFS088                IF YES, HIT LAST CHARACTER
          CR    R8,R3                   AT END OF DSNAME?
          BL    CHKFS086                IF NO, CONTINUE
CHKFS088  LA    R6,1(R6)                NEXT MASK CHARACTER
          CLI   0(R6),C' '              IS MASK AT BLANK?
          BNE   CHKFS082                IF NO, NOT A HIT
          B     CHKFS094                IT WAS A HIT
CHKFS090  LA    R8,1(R8)                NEXT DCDDSNAM CHARACTER
CHKFS092  LA    R6,1(R6)                NEXT MASK CHARACTER
          B     CHKFS084                GO CHECK FOR A MATCH
CHKFS094  LA    R6,MGMTTABL             CHECK MANAGEMENT CLASSES
          CLI   0(R6),C' '              VALID ENTRY?
          BE    CHKFS098                IF NO, ANY MGMT CLASS ELIGIBLE
CHKFS096  CLC   0(8,R6),DCDMGTCL        IS MGMT CLASS A MATCH?
          BE    CHKFS098                IF YES, CONTINUE
          CLI   0(R6),C' '              MGMT CLASS BLANK?
          BE    CHKFS078                IF YES, DIDN'T MATCH
          CLC   0(2,R6),=C'XX'          END OF TABLE?
          BE    CHKFS078                IF YES, DIDN'T MATCH
          LA    R6,8(R6)                ADDRESS NEXT CLASS
          B     CHKFS096                GO CHECK IT
CHKFS098  CLC   DCDDSNAM(4),=C'SYS1'    SYSTEM DATASET?
          BE    CHKFS078                IF YES, DON'T WANT IT
          TM    DCDFLAG2,DCDINTCG       ICF CATALOG?
          BO    CHKFS078                IF YES, DON'T WANT IT
          TM    DCDFLAG1,DCDTEMP        IS IT TEMPORARY?
          BO    CHKFS078                IF YES, DON'T WANT IT
          CLC   DCDVOLSR,DCDDSSER       MULTIVOLUME, NOT FIRST VOLUME?
          BNE   CHKFS078                IF YES, DON'T WANT IT
          MVI   GDGFLG,C'1'             ASSUME GDG
          TM    DCDFLAG1,DCDGDS         GDG?
          BO    CHKFS099                IF YES, FLAG ALREADY SET
          MVI   GDGFLG,C'0'             IF WASN'T A GDG
CHKFS099  MVC   SAVEALOC,DCDALLSP       SAVE ALLOCATED SPACE
          TM    DCDDSORG,DCDDSGPO+DCDDSGPS IS IT PS OR PO?
          BZ    CHKFS100                IF NOT, CHECK VSAM
          MVC   DSNAME(44),DCDDSNAM     SAVE PO/PS DATASET NAME
          B     CHKFS102                GO PROCESS IT
CHKFS100  TM    DCDDSORG+1,DCDDSGVS     IS IT VSAM?
          BZ    CHKFS078                IF NOT, DON'T WANT IT
          MVC   DSNAME(44),DCDDSNAM     SAVE VSAM DATASET NAME
          GET   DDCOLECT                READ NEXT DCOLLECT RECORD
          LA    R9,4(R1)                POINT TO RECORD
          CLI   DCURCTYP,C'A'           VSAM ASSOCIATED RECORD?
          BNE   CHKFS040                IF NO, SOMETHING'S WRONG
          CLC   DCADSNAM(44),DSNAME     IS IT SAME NAME?
          BNE   CHKFS040                IF NO, SOMETHING'S WRONG
          TM    DCAFLAG1,DCAKSDS        KSDS?
          BZ    CHKFS078                IF NO, DON'T WANT IT
          TM    DCAFLAG1,DCAAIX         ALTERNATE INDEX?
          BO    CHKFS078                IF YES, DON'T WANT IT
          TM    DCAFLAG1,DCADATA        DATA COMPONENT?
          BZ    CHKFS078                IF NO, DON'T WANT IT
          MVC   DSNAME(44),DCAASSOC     SAVE ASSOCIATED BASE NAME
CHKFS102  MVI   MINOR1,C' '             CLEAR SAVEDSN
          MVC   MINOR1+1(L'MINOR1-1),MINOR1
          SR    R7,R7                   CLEAR REG 7
          LA    R8,DSNAME               POINT TO BEGINNING OF DSNAME
CHKFS104  CLI   0(R8),C' '              IS THIS A BLANK?
          BE    CHKFS105                IF YES, END OF DSNAME
          LA    R7,1(,R7)               BUMP COUNT
          LA    R8,1(,R8)               BUMP TO NEXT CHARACTER
          B     CHKFS104                GO CHECK THIS CHARACTER
CHKFS105  ST    R7,DSNLEN               SAVE DSNAME LENGTH
          BCTR  R7,0                    SUBTRACT 1 FOR EXECUTED MOVE
          EX    R7,CHKFS106             MOVE EXACT LENGTH DSNAME
          B     CHKFS107                SKIP OVER THE EXECUTED MOVE
CHKFS106  MVC   MINOR1(0),DSNAME        EXECUTED MOVE
CHKFS107  L     R8,DSNLEN               LOAD DSNAME LENGTH
          ENQ   (MAJOR1,MINOR1,E,(R8),SYSTEM),RET=TEST ENQUEUED?
          LTR   R15,R15                 WAS THE RESOURCE AVAILABLE?
          BNZ   CHKFS078                IF NO, DON'T PROCESS IT
          CLI   GDGFLG,C'1'             WAS IT A GDG?
          BNE   CHKFS109                IF NOT, DON'T CHECK BASE
          S     R7,=F'9'                SUBTRACT 9 FOR BASE MOVE
          MVC   MINOR1(44),BLANKS       BLANK OUT PREVIOUS MINOR
          EX    R7,CHKFS106             MOVE BASE PORTION OF DSNAME
          S     R8,=F'9'                SUBTRACT 9 FOR ENQUEUE TEST
          ENQ   (MAJOR1,MINOR1,E,(R8),SYSTEM),RET=TEST ENQUEUED?
          LTR   R15,R15                 WAS THE RESOURCE AVAILABLE?
          BNZ   CHKFS078                IF NO, DON'T PROCESS IT
CHKFS109  CLI   JOBFLG,C'1'             JOB CARD PREVIOUSLY SUBMITTED?
          BE    CHKFS110                IF YES, DON'T DO IT AGAIN
          PUT   INTRDR,JOBCARD          SUBMIT JOB STATEMENT
          PUT   INTRDR,EXECCARD         SUBMIT EXEC STATEMENT
          PUT   INTRDR,SYSPCARD         SUBMIT SYSPRINT STATEMENT
          PUT   INTRDR,SYSINCRD         SUBMIT SYSIN STATEMENT
          PUT   INTRDR,COPYCRD1         SUBMIT DFDSS COPY STATEMENT
          MVI   JOBFLG,C'1'             INDICATE JOB CARD SUBMITTED
CHKFS110  MVC   COPYDSN,DSNAME          SAVE DATASET FOR DFDSS
          PUT   INTRDR,COPYCRD2         SUBMIT DSNAME FOR DFDSS COPY
          A     R4,SAVEALOC             KEEP TOTAL OF RECLAIMED SPACE
          CR    R4,R5                   COMPARE RECLAIMED/DESIRED
          BL    CHKFS078                IF LESS, GO LOOK FOR MORE
          B     CHKFS112                WE'VE FOUND ENOUGH
CHKFS111  CVD   R4,WORK1                END OF DATA DCOLLECT
          UNPK  SEND1KB(6),WORK5        UNPACK TOTAL RECLAIMED
          OI    SEND1KB+5,X'F0'         MAKE PRINTABLE
CHKFS112  CLOSE DDCOLECT                CLOSE DATA DCOLLECT DD
          CLI   JOBFLG,C'1'             WAS A JOB SUBMITTED?
          BE    CHKFS114                IF YES, THAT'S GOOD
          MVC   SEND2VOL(6),SAVESER     VOLSER BEING PROCESSED
          MODESET KEY=ZERO,MODE=SUP     GET READY FOR SEND
          LA    R1,SEND2TXT             ADDRESS SEND MESSAGE 2
          B     CHKFS118                GO ISSUE SEND
CHKFS114  MVC   COPYVOL,SAVESER         SAVE VOLUME FOR DFDSS
          PUT   INTRDR,COPYCRD3         SUBMIT FINAL COPY STATEMENT
          PUT   INTRDR,EOFCARD          SUBMIT /*EOF SO JOB RUNS
          MVC   SEND1VOL(6),SAVESER     SAVE VOLUME BEING PROCESSED
          CR    R4,R5                   DID WE RECLAIM ENOUGH?
          BL    CHKFS116                IF NO, BETTER TELL SOMEONE
          B     CHKFS072                GOT WHAT WE WERE LOOKING FOR
CHKFS116  MODESET KEY=ZERO,MODE=SUP     GET READY FOR SEND
          LA    R1,SEND1TXT             ADDRESS SEND MESSAGE 1
CHKFS118  SR    R0,R0                   CLEAR R0 PRIOR TO SVC
          SVC   34                      ISSUE SEND
          MODESET KEY=NZERO,MODE=PROB   RESET KEY
          B     CHKFS072                CONTINUE
CHKFS120  CLOSE VDCOLECT                CLOSE VOLUME DCOLLECT DD
CHKFS122  CLI   MODFLG,C' '             WAS THIS A TIMER POP?
          BE    CHKFS124                IF YES, RESET TIMER
          CLI   MODFLG,C'2'             WAS IT A DISPLAY REQUEST?
          BE    CHKFS126                IF YES, DON'T RESET TIMER
CHKFS124  MVI   STIMRECB,X'00'          CLEAR TIMER ECB
          STIMER REAL,POSTTIME,DINTVL=STIME SET TIMER FOR WAIT
CHKFS126  MVI   MODFLG,C' '             RESET MODIFY FLAG
          MODESET KEY=ZERO,MODE=SUP     ENTER SUPERVISOR STATE
          WAIT  1,ECBLIST=ECBLIST,LONG=YES WAIT FOR AN ECB TO POP
          L     R2,CMDECBPT             RETRIEVE COMMAND ECB ADDRESS
          TM    0(R2),X'40'             WAS A COMMAND ENTERED?
          MVI   0(R2),X'00'             CLEAR COMMAND ECB
          BO    CHKFS128                IF YES, GO PROCESS IT
          MODESET KEY=NZERO,MODE=PROB   RETURN TO PROBLEM STATE
          B     CHKFS068                TIMER POPPED, GO ANALYSE DASD
          PUSH  USING                   SAVE BASE REGS
          DROP  R10,R12
POSTTIME  STM   R14,R12,12(R13)         SAVE REGS
          USING POSTTIME,R15            BASE REG FOR SUBROUTINE
          POST  STIMRECB                POST TIME TIMER ECB
          LM    R14,R12,12(R13)         RELOAD REGS
          BR    R14                     GO BACK TO PROGRAM
          POP   USING                   BRING BACK ORIGINAL BASE REGS
CHKFS128  MODESET KEY=NZERO,MODE=PROB   RETURN TO PROBLEM STATE
          L     R2,COMMLPTR             GET COMMAND LIST ADDRESS
          USING COMLIST,R2              ESTABLISH ADDRESSABILITY
          L     R3,COMCIBPT             LOAD COMMAND BUFFER POINTER
          MVC   SAVCIBPT,COMCIBPT       SAVE BUFFER POINTER
          USING CIBNEXT,R3              ESTABLISH BUFFER BASE
          CLI   CIBVERB,CIBMODFY        WAS THIS A MODIFY COMMAND?
          BE    CHKFS132                IF YES, PROCESS ACCORDINGLY
          TTIMER CANCEL                 CANCEL THE STIMER
          QEDIT ORIGIN=COMCIBPT,BLOCK=(3) PURGE CIB QUEUE
          B     CHKFS999                MUST HAVE BEEN A STOP ISSUED
CHKFS132  MVI   COMMDATA,C' '           CLEAR COMM DATA AREA
          MVC   COMMDATA+1(L'COMMDATA-1),COMMDATA
          SR    R5,R5                   CLEAR REG 5
          IC    R5,CIBDATLN+1           GET THE MODIFY DATA LENGTH
          BCTR  R5,R0                   SUBTRACT ONE FOR MOVE
          EX    R5,CHKFS134             SAVE THE MODIFY DATA
          B     CHKFS136                SKIP OVER EXECUTED MOVE
CHKFS134  MVC   COMMDATA(0),CIBDATA     EXECUTED MOVE
          DROP  R3
CHKFS136  QEDIT ORIGIN=COMCIBPT,BLOCK=(3) PURGE COMMAND BUFFER QUE
          DROP  R2
          MVI   MODFLG,C'2'             ASSUME DISPLAY REQUEST
          CLC   COMMDATA(5),=C'DISP '   WAS IT A DISPLAY REQUEST?
          BE    CHKFS044                IF YES, GO PROCESS DISPLAY
          TTIMER CANCEL                 CANCEL THE STIMER
          MVI   MODFLG,C'1'             ASSUME SCAN REQUEST
          CLC   COMMDATA(5),=C'SCAN '   WAS IT A SCAN REQUEST?
          BE    CHKFS044                IF YES, GO PROCESS SCAN
          MVI   MODFLG,C'3'             MUST BE MODIFYING PARAMETERS
          LA    R4,COMMDATA             LOAD ADDRESS OF MODIFY DATA
          LA    R5,1(R5)                THE EXECUTED MOVE SUBTRACTED 1
          B     CHKFS004                GO PROCESS THE PARMS
CHKFS999  CLOSE (INTRDR)                WON'T NEED INTRDR ANYMORE
          L     R13,REGSAVE+4           RELOAD
          ST    R15,16(R13)             STORE RC
          LM    R14,R12,12(R13)         RELOAD REGS
          BR    R14                     GO HOME
          LTORG
          DS    0D
MAJOR1    DC    CL8'SYSDSN'             MAJOR PARM FOR ENQUE
MINOR1    DS    CL44                    MINOR PARM FOR ENQUE
REGSAVE   DS    18F                     REGISTER SAVE AREA
WTOBPARM  WTO   '* BAD PARM DATA STARTING AT XXXXXXXX *',MF=L
WTOLIST0  WTO   'CHKFRSPC RUNNING TEST MODE WITH FOLLOWING PARAMETERS',X
               MF=L
WTOLIST1  WTO   ' FREESPACE PERCENT      : XX',MF=L
WTOLIST2  WTO   ' TARGET PERCENT         : XX',MF=L
WTOLIST3  WTO   ' SLEEP TIME (MINUTES)   : XX',MF=L
WTOLIST4  WTO   ' VOLUME(S)              : XXXXXX',MF=L
WTOLIST5  WTO   ' STORAGE GROUP          : XXXXXXXX',MF=L
WTOLIST6  WTO   ' ELIGIBLE DSNAME(S)     :    ',MF=L
WTOLIST7  WTO   '  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',MF=L
WTOLIST8  WTO   ' ELIGIBLE MGMT CLASS(ES):    ',MF=L
WTOLIST9  WTO   '  XXXXXXXX',MF=L
WTOLISTA  WTO   ' DCOLLECT ERROR FOR VOLUME:       ',MF=L
WORK1     DS    0D
WORK2     DS    F
WORK5     DS    F
WORK3     DS    0D
          DS    F
WORK4     DS    F
DSNLEN    DS    F
WORKPARM  DS    CL2                     WORK AREA FOR NUMERIC PARMS
FPDEFLT   DC    CL2'05'                 DEFAULT FP PARM
FPPARM    DC    CL2'00'                 FPPARM AS GIVEN
TPDEFLT   DC    CL2'08'                 DEFAULT TP PARM
TPPARM    DC    CL2'00'                 TPPARM AS GIVEN
GDGFLG    DC    C' '                    FLAG FOR GDG
MODFLG    DC    C' '                    FLAG FOR MODIFY TYPE
PRIMEFLG  DC    C' '                    DCOLLECT VOLUME PRIME FLAG
NUMICFLG  DC    C' '                    NUMERIC CHECK FLAG
JOBFLG    DC    C' '                    JOB CARD REQUIRED FLAG
ZERO      DC    X'0C'                   USED TO CHECK FOR PARM
SAVESER   DS    CL6                     DATASET SERIAL NUMBER
SAVECAP   DS    F                       VOLUME CAPACITY SAVE
SAVEALOC  DS    F                       DATASET ALLOCATION SAVE
DSNAME    DS    CL44                    DATASET NAME SAVE
SAVCIBPT  DS    F                       CIB POINTER SAVE
COMMLPTR  DC    A(0)                    PTR TO ECB & CIB PTRS
ECBLIST   DS    0F                      BEGINNING OF ECBLIST
CMDECBPT  DC    A(0)                    POINTER TO COMMAND ECB
TIMECBPT  DC    X'80',AL3(STIMRECB)     POINTER TO STIMER ECB
STIMRECB  DC    F'0'                    ECB POSTED BY STIMER EXIT
COMMDATA  DC    CL255' '                OPERATOR COMM DATA SAVE
BLANKS    DC    CL44' '                 BLANKS USED TO RESET TABLES
DSNSTABL  DC    10CL44' '               DATASET COPY TABLE
          DC    C'XX'                   INDICATE END OF TABLE
MGMTTABL  DC    10CL8' '                MANAGEMENT CLASS COPY TABLE
          DC    C'XX'                   INDICATE END OF TABLE
STIME     DC    0D'0',C'00300000'       SLEEP TIME DEFAULT
          ORG   STIME+2
STPARM    DS    CL2                     SLEEP TIME PARM SUPPLIED
          ORG
SEND1TXT  DS    0F                      TEXT FOR SEND MESSAGE 1
          DC    AL2(SEND1LEN)
          DC    AL2(0)
          DC    C'SE ''VOLUME '
SEND1VOL  DS    CL6
          DC    C' FREESPACE IS '
SEND1FP   DS    CL2
          DC    C'%, ONLY '
SEND1KB   DS    CL6
          DC    C'KB FOUND ELIGIBLE TO MOVE'',USER=(TSOID),LOGON'
SEND1LEN  EQU   *-SEND1TXT
SEND2TXT  DS    0F                      TEXT FOR SEND MESSAGE 2
          DC    AL2(SEND2LEN)
          DC    AL2(0)
          DC    C'SE ''VOLUME '
SEND2VOL  DS    CL6
          DC    C' FREESPACE IS '
SEND2FP   DS    CL2
          DC    C'%, NO DATASETS FOUND ELIGIBLE TO MOVE'''
          DC    C',USER=(TSOID),LOGON'
SEND2LEN  EQU   *-SEND2TXT
VDCOLCRD  DC    CL80' '                 IDCAMS VOLUME DCOLLECT CARD
          ORG   VDCOLCRD
          DC    C' DCOLLECT'
          DC    C' OFILE(VDCOLECT)'
VDCOLVL1  DC    CL5' '
VDCOLVL2  DC    CL6' '
VDCOLVL3  DC    C' '
VDCOLSG1  DC    CL6' '
VDCOLSG2  DC    CL8' '
VDCOLSG3  DC    C' '
          DC    C' NODATAINFO'
          ORG
DDCOLCRD  DC    CL80' '                 IDCAMS DATA DCOLLECT CARD
          ORG   DDCOLCRD
          DC    C' DCOLLECT'
          DC    C' OFILE(DDCOLECT)'
          DC    C' VOL('
DDCOLVOL  DC    CL6' '
          DC    C')'
          DC    C' NOVOLUMEINFO'
          ORG
JOBCARD   DC    CL80' '
          ORG   JOBCARD
          DC    C'//JOBID  JOB   ,MSGCLASS=1,CLASS=P'
          DC    C',NOTIFY=TSOID,USER=USERID'
          ORG
EXECCARD  DC    CL37'//STEP1    EXEC PGM=ADRDSSU,REGION=3M'
NORUN     DC    CL20',PARM=''TYPRUN=NORUN'''
          DC    CL23' '
SYSPCARD  DC    CL80'//SYSPRINT DD   SYSOUT=*'
SYSINCRD  DC    CL80'//SYSIN    DD   *'
COPYCRD1  DC    CL80' '                 DFDSS COPY CARD 1
          ORG   COPYCRD1
          DC    C' COPY'
          DC    C' DS(INC('
          DC    C' '
          DC    C'-'
          ORG
COPYCRD2  DC    CL80' '                 DFDSS COPY CARD 2
          ORG   COPYCRD2
          DC    C' '
COPYDSN   DS    CL44
          DC    C' '
          DC    C'-'
          ORG
COPYCRD3  DC    CL80' '                 DFDSS COPY CARD 3
          ORG   COPYCRD3
          DC    C' '
          DC    C'))'
          DC    C' LOGINDYNAM('
COPYVOL   DS    CL6
          DC    C') DELETE PURGE CATALOG ALLD(*) ALLX'
          ORG
EOFCARD   DC    CL80'/*EOF'             EOF CARD
VDCOLECT  DCB   DDNAME=VDCOLECT,DSORG=PS,MACRF=GL,EODAD=CHKFS120
DDCOLECT  DCB   DDNAME=DDCOLECT,DSORG=PS,MACRF=GL,EODAD=CHKFS111
COPYDSNS  DCB   DDNAME=COPYDSNS,DSORG=PS,MACRF=GL,EODAD=CHKFS026
COPYMGMT  DCB   DDNAME=COPYMGMT,DSORG=PS,MACRF=GL,EODAD=CHKFS032
SYSIN     DCB   DDNAME=SYSIN,DSORG=PS,MACRF=PM,                        X
               LRECL=80,BLKSIZE=80,RECFM=F
INTRDR    DCB   DDNAME=INTRDR,DSORG=PS,MACRF=PM,                       X
               LRECL=80,BLKSIZE=80,RECFM=F
          IDCDOUT
          DSECT
          IEZCOM
          DSECT
          IEZCIB
          END


Ernie Ishman
Manager, Systems Support
Geisinger System Services (USA)                                        c Xephon 1994

