Creating SCLM architecture definitions


/* * * * * * * * * * * * * * * * * * * * * * * */
/* THIS MEMBER DEFINES CONTROL VALUES REQUIRED */
/* BY THE EXEC CREARCH                         */
/* * * * * * * * * * * * * * * * * * * * * * * */
ARCHLIB  = 'TSPJH.TEST.ARCHDEF'    /* OUTPUT DATASETS FOR ARCHDEFS    */
SORSLIB  = 'APPL.MLPROD.SORSLIB'   /* SOURCE INPUT DATASET            */
DB2CLIB  = 'TSPJH.TEST.DB2CLIST'   /* OUTPUT DATASET FOR DB2CLISTS    */
PREF     = 'QPS'                   /* MEMBER NAME PREFIX FOR SOURCE DS*/
SPUFIDSN = 'TSPJH.DB2.OUTPUT'      /* SPUFI OUTPUT DATASET NAME       */
TOPMOD   = '$'||PREF
/* * * * * * * * * * * * * * * * * * * * * * * */
/* THE FORMAT OF VARIOUS MEMBER NAMES ARE      */
/* DEFINED BELOW.                              */
/* * * * * * * * * * * * * * * * * * * * * * * */
$COMPARCD = SUBSTR(PROGNAME,1,3)||'K'||SUBSTR(PROGNAME,5)
$LINKARCD = SUBSTR(PROGNAME,1,3)||'L'||SUBSTR(PROGNAME,5)
$BINDARCD = SUBSTR(PLANNAME,1,3)||'Z'||SUBSTR(PLANNAME,5)
$HIGHARCD = SUBSTR(PLANNAME,1,3)||'H'||SUBSTR(PLANNAME,5)
$DB2CNAME = SUBSTR(PLANNAME,1,3)||'C'||SUBSTR(PLANNAME,5)
/* * * * * * * * * * * * * * * * * * * * * * * */
/* DEFINITIONS OF THE 3RD LEVEL QUALIFIERS OF  */
/* THE SCLM DATASETS ARE DEFINED BELOW.        */
/* * * * * * * * * * * * * * * * * * * * * * * */
CICSLOAD = 'PROGLOAD'             /* 3RD QUALIFIER OF CICS LOADLIB   */
BTCHLOAD = 'JOBLIB'               /* 3RD QUALIFIER OF BATCH LOADLIB  */
OBJECT   = 'OBJ'                  /* 3RD QUALIFIER OF OBJECT LIBRARY */
SOURCE   = 'SORSLIB'              /* 3RD QUALIFIER OF SOURCE LIBRARY */
ARCHDEF  = 'ARCHDEF'              /* 3RD QUALIFIER OF ARCHDEF LIB    */
DB2CLIST = 'DB2CLIST'             /* 3RD QUALIFIER OF DB2CLIST LIB   */
DB2OUT   = 'DB2OUT'               /* 3RD QUALIFIER OF DB2OUT  LIB    */


/*REXX*********************************************************/
/*  SCLM DB2CLIST EXEC to bind a plan                         */
/*  generated by SCLMPLAN  on &sysdate at &systime            */
/**************************************************************/
/* Specify DBRM names for the bind member list                */
)SEL &DBRM1 ^= &Z && &XDB1 ^= X
/*    %INCLUDE &dbrm1                                         */
)ENDSEL
)SEL &DBRM2 ^= &Z && &XDB2 ^= X
/*    %INCLUDE &dbrm2                                         */
)ENDSEL
)SEL &DBRM3 ^= &Z && &XDB3 ^= X
/*    %INCLUDE &dbrm3                                         */
)ENDSEL
)SEL &DBRM4 ^= &Z && &XDB4 ^= X
/*    %INCLUDE &dbrm4                                         */
)ENDSEL
)SEL &DBRM5 ^= &Z && &XDB5 ^= X
/*    %INCLUDE &dbrm5                                         */
)ENDSEL
)SEL &DBRM6 ^= &Z && &XDB6 ^= X
/*    %INCLUDE &dbrm6                                         */
)ENDSEL
)SEL &DBRM7 ^= &Z && &XDB7 ^= X
/*    %INCLUDE &dbrm7                                         */
)ENDSEL
)SEL &DBRM8 ^= &Z && &XDB8 ^= X
/*    %INCLUDE &dbrm8                                         */
)ENDSEL
)SEL &DBRM9 ^= &Z && &XDB9 ^= X
/*    %INCLUDE &dbrm9                                         */
)ENDSEL
)SEL &DBRM10 ^= &Z && &XDB10 ^= X
/*    %INCLUDE &dbrm10                                         */
)ENDSEL
/**************************************************************/
/***Convert the parms to REXX ***/
Parse UPPER ARG sclminp
SCLMSTRP sclminp
Pull option group
)SEL &DBRMLIS2 = &Z
Dbrms = '&dbrmlist'
)ENDSEL
)SEL &DBRMLIS2 ^= &Z
Dbrms = '&dbrmlist'
Dbrms = dbrms', &dbrmlis2'
)ENDSEL
/**************************************************************/
/* Select the bind parameters                                 */
/**************************************************************/
Select
    when group = 'MLUAT' then do
       plan  = '&uplan'
       sys   = 'DB2D'
       owner = 'DB2UAT'
       library = '''POPS.MLUAT.DBRM'',
''POPS.MLPREP.DBRM'',''POPS.MLPROD.DBRM'''
       end
    when group = 'MLPREP' then do
       plan  = '&pplan'
       sys   = 'DB2P'
       owner = 'DB2PROD'
       library = '''POPS.MLPREP.DBRM'',''POPS.MLPROD.DBRM'''
       end
    when group = 'MLTEMP' then exit
    when group = 'MLSTG'  then exit
    when group = 'MLPROD' then exit
    otherwise do
       plan  = '&tplan'
       sys   = 'DB2D'
       owner = '&owner'
)SEL &DBRMLIB = &Z
       library = '''POPS.MLUAT.DBRM'',
''POPS.MLPREP.DBRM'',''POPS.MLPROD.DBRM'''
)ENDSEL
)SEL &DBRMLIB ^= &Z
       library = '''&DBRMLIB'',''POPS.MLUAT.DBRM'',
''POPS.MLPREP.DBRM'',''POPS.MLPROD.DBRM'''
)ENDSEL
       end
end
/**************************************************************/
/* INVOKE DSN COMMAND PROCESSOR                               */
/**************************************************************/
fincd = 0
SELECT
   WHEN OPTION = 'BIND' THEN DO
       QUEUE "BIND PLAN("PLAN") OWNER("OWNER") MEMBER("DBRMS"),
)SEL &INCLIB = Y
LIBRARY("LIBRARY")
)ENDSEL
ACTION(REPLACE) RETAIN VALIDATE(BIND) ISOLATION(CS) ACQUIRE(USE)
RELEASE(COMMIT) EXPLAIN(YES)"
       QUEUE "END"
       "DSN SYSTEM("SYS")"
       FINCD = RC
)SEL &ENVIRO = C
       IF FINCD = 0 THEN DO
           SCLMGRNT OWNER PLAN SYS
           FINCD = RC
           END
)ENDSEL
       END
   WHEN OPTION = 'FREE' THEN FINCD = 0
   OTHERWISE FINCD = 316      /* INVALID OPTION */
END
exit fincd


/**REXX***************************************************************/
/***  SCLM ARCHDEF creator - CREARCH                               ***/
/*********************************************************************/
cls
trace off
parse upper arg optsfile
If optsfile = '' then optsfile = '''TSPJH.GEN.CNTL(SCLM)'''
optsst = sysdsn(optsfile)
If optsst = 'OK' then do
    "Alloc f(optsfile) da("optsfile") shr"
    "execio * diskr optsfile (finis"
    "Free f(optsfile)"
    Do until queued() = 0
        pull opt
        if substr(opt,1,1) = '$' then do
            y = substr(opt,2,8)||' = "'||opt'"'
            interpret y
        end
        else interpret opt
    end
end
    else do
    say 'On checking the dataset ' optsfile
    say 'an error 'optsst' occurred'
    Say 'This dataset must be available during execution.'
    exit 10
end
"Free f(sclmout,topmod)"
"Alloc F(SCLMOUT) sysout(2)"
/*********************************************************************/
/*** If no source lib was specified, ask the user for it           ***/
/*********************************************************************/
getsors:
If sorslib = '' then do
    Say 'Enter the source library to be analysed - No quotes'
    Pull sorslib
    sorslib = word(sorslib,1)
end
If sorslib = '' then exit
/*********************************************************************/
/*** Check the given source library exists                         ***/
/*********************************************************************/
sorsst = sysdsn("'"sorslib"'")
If sorsst /= 'OK' then do
    say 'Status ' sorsst ' issued for dataset 'sorslib
    sorslib = ''
    signal getsors
    end
/*********************************************************************/
/*** If the user didn't give a program prefix, ask for one         ***/
/*********************************************************************/
If pref = '' then do
    Say 'Enter the prefix of the programs you wish to analyse '
    Pull pref
    If pref = '' then exit
end
memname = pref
/*********************************************************************/
/*** Open the sorslib dataset                                      ***/
/*********************************************************************/
Address ISPEXEC "LMINIT DATAID(SLIB) DATASET('"sorslib"')",
   "ENQ(SHR)"
Address ISPEXEC "LMOPEN DATAID("slib") OPTION(INPUT)"
/*********************************************************************/
/*** Tell the user what's going on                                 ***/
/*********************************************************************/
Say ' '
Say 'Phase 1 : Begin    : Source code analysis'
Say ' '
cnt = 0
/*********************************************************************/
/*** Start the 'read programs' loop                                ***/
/*********************************************************************/
readmn:
/*********************************************************************/
/*** Get the member name for the next program                      ***/
/*********************************************************************/
Address ISPEXEC "LMMLIST DATAID("slib") MEMBER(memname)"
/*********************************************************************/
/*** If it doesn't match the program prefix we were given,          **/
/***   we can go to the table processing section.                   **/
/*********************************************************************/
If substr(memname,1,length(pref)) /= pref | rc = 8
                    then signal endlist
/*********************************************************************/
/*** Up the counter and set the default values for this table entry***/
/*********************************************************************/
cnt = cnt + 1
mem.cnt = word(memname,1)
dli.cnt = 'N'
db2.cnt = 'N'
cics.cnt = 'N'
calls.cnt = ''
subprog.cnt = 'N'
signal readmn
/*********************************************************************/
/*** We've now loaded all the program names into a table           ***/
/*********************************************************************/
endlist:
items = cnt
/*********************************************************************/
/*** Start processing the source code.                             ***/
/*********************************************************************/
cnt = 0
do until cnt = items
    cnt= cnt +1
/*********************************************************************/
/*** Load the next program into the stack                          ***/
/*********************************************************************/
    "Alloc f(progin) da('"sorslib"("mem.cnt")') SHR"
    "EXecio * diskr progin (finis"
    "Free f(progin)"
/*********************************************************************/
/*** Find the start of the procedure division                      ***/
/*********************************************************************/
    procdiv = 'N'
    do until procdiv = 'Y'
        pull progrec
        if pos('PROCEDURE DIV',progrec) /= 0 then procdiv = 'Y'
        if queued() = 0 then do
            say 'End of program 'mem.cnt' reached before Proc Div found'
            exit 99
            end
    end
/*********************************************************************/
/*** Start analysing the code                                      ***/
/*********************************************************************/
    Do until queued() = 0
        pull progrec
        if substr(progrec,7,1) /= "*" then do
            x = wordpos(' CALL ',progrec)
            If x /= 0 then do
                nm = word(progrec,x+1)
                nm = substr(nm,2,length(nm)-2)
                if nm /= 'CBLTDLI' then calls.cnt = calls.cnt ||' '||nm
            end
            if pos('EXEC CICS',progrec) /= 0 then cics.cnt = 'Y'
            If pos('CBLTDLI',progrec)   /= 0 then dli.cnt = 'Y'
            If pos('EXEC DLI',progrec)  /= 0 then dli.cnt = 'Y'
            If pos('EXEC SQL',progrec)  /= 0 then db2.cnt = 'Y'
        end
    end
    say 'Program 'mem.cnt' analysed.'
    push mem.cnt ' db2='db2.cnt' cics='cics.cnt' dli='dli.cnt
    "Execio 1 diskw sclmout"
    If calls.cnt /= '' then do
        push '          Calls='calls.cnt
        "Execio 1 diskw sclmout"
        end
end
Address ISPEXEC "LMCLOSE DATAID("slib")"
Address ISPEXEC "LMFREE DATAID("slib")"
/*********************************************************************/
/*** Scan the program table and mark all those programs that appear **/
/***   in other programs' calls list as sub programs.              ***/
/*********************************************************************/
say ' '
say '                     Checking program calls'
cnt = 0
Do until cnt = items
    cnt = cnt + 1
    cnt2 = 0
    do until cnt2 = items
        cnt2 = cnt2 + 1
        if wordpos(mem.cnt,calls.cnt2) /= 0 then subprog.cnt = 'Y'
    end
end
say '                     Program calls checked'
say ' '
Say 'Phase 1 : Complete : Source code analysis'
say ' '
say 'Phase 2 : Begin    : Archdef build '
/*********************************************************************/
/*** Allocate a temporary file for us to store high top level      ***/
/***  archdef lines in                                             ***/
/*********************************************************************/
"Alloc F(topmod) unit(sysda) Lrecl(80) recfm(f b) space(1) tracks"
/*********************************************************************/
/*** Get the archdef library name from the user                    ***/
/*********************************************************************/
getarch:
If archlib = '' then do
    Say 'Enter the archdef library name - No quotes'
    Pull archlib
end
If archlib = '' then exit
/*********************************************************************/
/*** Check the archdef library name is valid                       ***/
/*********************************************************************/
archst = sysdsn("'"archlib"'")
If archst /= 'OK' then do
    say 'Status ' archst ' issued for dataset 'archlib
    archlib = ''
    signal getarch
    end
/*********************************************************************/
/*** Allocate the archdef ready for output                         ***/
/*********************************************************************/
Address ISPEXEC "LMINIT DATAID(ALIB) DATASET('"archlib"')",
   "ENQ(EXCLU)"
/*********************************************************************/
/*** Open the archdef dataset                                      ***/
/*********************************************************************/
Address ISPEXEC "LMOPEN DATAID("alib") OPTION(OUTPUT)"
cnt = 0
do until cnt = items
    cnt = cnt + 1
    /**********************************************/
    /*** If its a dli program create a K member ***/
    /***   with the data(24) option             ***/
    /**********************************************/
    if dli.cnt = 'Y' then do
        Queue '***************************************************'
        Queue '**  COMPILE TYPE ARCHDEF FOR 'MEM.CNT
        Queue '**  GENERATED ON 'date()' AT 'TIME()
        Queue '***************************************************'
        Queue 'OBJ   '||mem.cnt||'   'object
        Queue 'SINC  '||mem.cnt||'   'sorslib
        Queue 'PARM1 DATA(24)'
        progname = mem.cnt
        interpret comparcd
        kname = $comparcd
        call ispfadd kname
        push kname 'member 'result' for DLI program ' mem.cnt
        "Execio 1 diskw sclmout"
    end
/*********************************************************************/
/*** if it's a CICS program create the link module                 ***/
/*********************************************************************/
    if cics.cnt = 'Y' then do
        queue '***************************************************'
        queue '**  CICS LINK ARCHDEF FOR 'MEM.CNT'             '
        queue '**  GENERATED ON 'date()' AT 'TIME()
        queue '***************************************************'
        queue 'LOAD  '||mem.cnt||'   'cicsload
        queue 'CMD     INCLUDE SYSLIB(DFHECI)'
        If db2.cnt = 'Y' then queue 'CMD     INCLUDE SYSLIB(DSNCLI)'
        If dli.cnt = 'Y' then queue 'INCL  '||kname||'   'archdef
                         else queue 'INCLD '||mem.cnt||'   'source
        progname = mem.cnt
        interpret linkarcd
        lname = $linkarcd
        call ispfadd lname
        push Lname 'member 'result' for CICS program' mem.cnt
        "Execio 1 diskw sclmout"
/*********************************************************************/
/*** Add the L archdef to the top archdef (the temporary file)     ***/
/***   if the program is not DB2                                   ***/
/*********************************************************************/
        If db2.cnt /= 'Y' then do
            x = 'INCL   'lname'  'archdef
            push x
            "EXECIO 1 diskw topmod"
        end
    end
/*********************************************************************/
/*** If it's a batch prog build the linker archdef module          ***/
/*********************************************************************/
    if cics.cnt = 'N' & subprog.cnt = 'N' then do
        queue '***************************************************'
        queue '**  BATCH LINK ARCHDEF FOR 'MEM.CNT
        queue '**  GENERATED ON 'date()' AT 'TIME()
        queue '***************************************************'
        queue 'LOAD  '||mem.cnt||'   'joblib
        If db2.cnt = 'Y' then queue 'CMD     INCLUDE SYSLIB(DSNELI)'
        If dli.cnt = 'Y' then do
            queue 'CMD     INCLUDE   SYSLIB(DFSLI000)'
            queue 'CMD     ENTRY     DLITCBL'
            queue 'INCL  '||kname||'   'archdef
        end
          else queue 'INCLD '||mem.cnt||'   'source
        wrd = 1
        do while word(calls.cnt,wrd) /= ''
            cnt2 = 0
            calldli = 'N'
            curword = word(calls.cnt,wrd)
            do until cnt2 = items | curword = mem.cnt2
                cnt2 = cnt2 + 1
            end
            if curword = mem.cnt2 then calldli = dli.cnt2
            If calldli = 'Y' then do
                ckname = substr(curword,1,3)||'K'||substr(curword,5)
                queue 'INCL  '||ckname||'   'archdef
            end
            else queue 'INCLD '||curword||'   'source
            wrd = wrd + 1
        end
        progname = mem.cnt
        interpret linkarcd
        lname = $linkarcd
        Call ispfadd lname
        push Lname 'member 'result' for batch program' mem.cnt
        "Execio 1 diskw sclmout"
        If db2.cnt /= 'Y' then do
            x = 'INCL   'lname'  'archdef
            push x
            "EXECIO 1 diskw topmod"
        end
    end
end
say 'Phase 2 : Complete : Archdef build '
say ''
/*********************************************************************/
/*** Ask the user for a plan prefix                                ***/
/*********************************************************************/
say 'Phase 3 : Begin    : DB2CLIST create'
getdb2c:
If db2clib = '' then do
    Say 'Please enter the name of the dataset into which you want the '
    Say 'DB2CLISTs placed - No Quotes'
    Pull db2clib
end
If db2clib = '' then exit
/*********************************************************************/
/*** Check the archdef library name is valid                       ***/
/*********************************************************************/
archst = sysdsn("'"db2clib"'")
If archst /= 'OK' then do
    say 'Status ' archst ' issued for dataset 'db2clib
    db2clib = ''
    signal getdb2c
    end
/*********************************************************************/
/*** Call the routine to analyse the spufi report                  ***/
/*********************************************************************/
Call spufi
say 'rows=' rows
if rows = 0 then do
    say 'No plans found'
    exit 16
    end
If rc > 4 then do
    Say 'A return code of 'rc' was received from DB2'
    Say 'Unable to build DB2CLISTs'
    exit rc
    end
/**************************************************************/
/*** Prepare the dataset for output                         ***/
/**************************************************************/
Address ISPEXEC "LMINIT DATAID(CLIB) DATASET('"db2clib"')",
   "ENQ(EXCLU)"
Address ISPEXEC "LMOPEN DATAID("CLIB") OPTION(OUTPUT)"
/*********************************************************************/
/*** Process the data from DB2                                     ***/
/*********************************************************************/
cnt = 2
Do until cnt > rows+1
    prev = cnt - 1
    If plname.cnt /= plname.prev  then do
        dbrmlist = ''
        dbrmlis2 = ''
        cnt2 = prev
        do until plname.cnt2 /= plname.prev
            cnt2 = cnt2 - 1
        end
        cnt2 = cnt2 + 1
        dbcnt = 0
        do until cnt2 > prev
            dbcnt = dbcnt + 1
            x = 'DBRM'||dbcnt||'='||name.cnt2
            interpret x
            dbrmlist = dbrmlist||', '||name.cnt2
            cnt2 = cnt2 + 1
        end
        tplan = plname.prev
        uplan = substr(plname.prev,1,3)||'U'||substr(plname.prev,5)
        pplan = substr(plname.prev,1,3)||'P'||substr(plname.prev,5)
        owner = qualifier.prev
        enviro = 'B'
        if substr(name.cnt2,4,1)='1' then enviro = 'C'
        sysdate = date()
        systime = time()
/*********************************************************************/
/*** If the dbrmlist is too big to get onto 1 line, split it       ***/
/*********************************************************************/
        dbrmlist = substr(dbrmlist,3)
        if length(dbrmlist) > 70 then do
            w5 = wordindex(dbrmlist,7)
            dbrmlis2 = substr(dbrmlist,w5)
            dbrmlist = substr(dbrmlist,1,w5-3)
            end
/*********************************************************************/
/*** Create DB2clist using the skeleton                            ***/
/*********************************************************************/
        Address ISPEXEC "FTOPEN TEMP"
        Address ISPEXEC "FTINCL SCLMPLAN"
        Address ISPEXEC "FTCLOSE"
        /************************************************************/
        /*** Get the temporary dataset name                       ***/
        /************************************************************/
        Address ISPEXEC "VGET ZTEMPF"
        /*********************************************************/
        /*** Put the created DB2CLIST into the stack.          ***/
        /*********************************************************/
        "ALLOC F(SCLMIN) DA('"ztempf"') SHR"
        "EXECIO * DISKR SCLMIN (FINIS"
        "FREE F(SCLMIN)"
        /***********************************************************/
        /*** Write data out to ISPF                              ***/
        /***********************************************************/
        Do until queued() = 0
            pull inrec
            Address ISPEXEC "LMPUT DATAID("clib") MODE(INVAR),
                            DATALOC(INREC) DATALEN(80)"
        End
        /************************************************************/
        /*** Tell ISPF to add the DB2CLIST member to the PDS      ***/
        /************************************************************/
        planname = plname.prev
        interpret db2cname
        cname = $db2cname
        If sysdsn("'"db2clib"("cname")'") = 'OK' then do
              Address ISPEXEC "LMMREP DATAID("clib") MEMBER("cname")"
              disp = 'replaced'
        end
         else do
              Address ISPEXEC "LMMADD DATAID("clib") MEMBER("cname")"
              disp = 'created'
        end
        queue cname' DB2CLIST has been 'disp' for the following DBRMs'
        queue '           'dbrmlist
        "Execio 2 diskw sclmout"
        If dbrmlis2 /= '' then do
            push '           'dbrmlis2
            "Execio 1 diskw sclmout"
        end
/*********************************************************************/
/*** Create the Z and H archdef modules                            ***/
/*********************************************************************/
        planname = plname.prev
        interpret bindarcd
        zname = $bindarcd
        interpret higharcd
        hname = $higharcd
        lname = substr(plname.prev,1,3)||'L'||substr(plname.prev,5)
/*********************************************************************/
/*** Create the Z archdef for the DB2 bind                         ***/
/*********************************************************************/
        queue '***************************************************'
        queue '**  DB2 bind ARCHDEF FOR 'plname.prev
        queue '**  GENERATED ON 'date()' AT 'TIME()
        queue '***************************************************'
        queue 'SINC  '||cname||'   'db2clist
        queue 'OUT3  '||cname||'   'db2out
        call ispfadd zname
        push zname 'archdef member 'result' for plan 'plname.prev
        "Execio 1 diskw sclmout"
/*********************************************************************/
/*** Create the H archdef which includes the link and bind         ***/
/*********************************************************************/
        queue '***************************************************'
        queue '**  High Level link and bind archdef for 'plname.prev
        queue '**  GENERATED ON 'date()' AT 'TIME()
        queue '***************************************************'
        queue 'INCL  '||lname||'   'archdef
        queue 'INCL  '||zname||'   'archdef
        call ispfadd hname
        push hname 'archdef 'result' for CICS/DB2 program' plname.prev
        "Execio 1 diskw sclmout"
/*********************************************************************/
/*** Add the H archdef to the top archdef                          ***/
/*********************************************************************/
        If db2.cnt /= 'Y' then do
            x = 'INCL   'hname'  'archdef
            push x
            "EXECIO 1 diskw topmod"
        end
        say 'Creates for plan 'plname.prev' done.'
/*********************************************************************/
/***  clear the dbrm fields                                        ***/
/*********************************************************************/
        dbcnt = 0
        do until dbcnt = 10
            dbcnt = dbcnt + 1
            x = 'DBRM'||dbcnt||'=""'
            interpret x
        end
    end
    cnt = cnt + 1
end
Address ISPEXEC "LMCLOSE DATAID("clib")"
Address ISPEXEC "LMFREE DATAID("clib")"
/*********************************************************************/
/*** Close the topmod file                                         ***/
/*********************************************************************/
"Execio 0 diskw topmod (finis"
/*********************************************************************/
/*** Create the topmod archdef                                     ***/
/*********************************************************************/
queue '*************************************************'
queue '* High level archdef modules                   **'
queue '**  GENERATED ON 'date()' AT 'TIME()
queue '*************************************************'
/*********************************************************************/
/*** Read the topmod file into the stack                           ***/
/*********************************************************************/
"Execio * diskr topmod (finis"
call ispfadd topmod
push topmod||' member 'result' for this application'
"Execio 1 diskw sclmout"
"Free f(topmod)"
/*********************************************************************/
/*** Free off the report file                                      ***/
/*********************************************************************/
"Execio 0 diskw sclmout (finis"
"Free f(sclmout)"
/*********************************************************************/
/*** Close the archdef file                                        ***/
/*********************************************************************/
Address ISPEXEC "LMCLOSE DATAID("alib")"
Address ISPEXEC "LMFREE DATAID("alib")"
/*********************************************************************/
/*** Say goodnight                                                 ***/
/*********************************************************************/
say 'Phase 3 : Complete : DB2CLIST create'
say ''
Say 'All processing complete'
exit
/*********************************************************************/
/**** End of main code, start or subroutines                        **/
/*********************************************************************/
/*********************************************************************/
/***  This section is called to add members to the required archdef***/
/***     dataset.                                                  ***/
/*********************************************************************/
  ISPFADD:
/*********************************************************************/
/*** Get the name of the member to be added to the archdef dataset ***/
/*********************************************************************/
Arg xmemname
/*********************************************************************/
/*** Loop round reading each line and writing it out               ***/
/*********************************************************************/
Do until queued() = 0
    Pull xrec
    Address ISPEXEC "LMPUT DATAID("alib") MODE(INVAR)
           DATALOC(XREC) DATALEN(80) NOBSCAN"
End
/*********************************************************************/
/*** Add the member to the dataset                                 ***/
/*********************************************************************/
If sysdsn("'"archlib"("xmemname")'") = 'OK' then do
      Address ISPEXEC "LMMREP DATAID("alib") MEMBER("xmemname")"
      disp = 'replaced'
end
 else do
      Address ISPEXEC "LMMADD DATAID("alib") MEMBER("xmemname")"
      disp = 'added'
end
/*********************************************************************/
/*** Return to caller, passing back a field indicating if the      ***/
/***  member was added or replaced.                                ***/
/*********************************************************************/
Return disp
spufi:
If spufidsn = '' then do
    Say 'Enter the SPUFI output dataset name - No quotes'
    Pull spufidsn
end
If spufidsn = '' then exit
/*********************************************************************/
/*** Check the spufi library name is valid                         ***/
/*********************************************************************/
spufist = sysdsn("'"spufidsn"'")
If spufist /= 'OK' then do
    say 'Status ' spufist ' issued for dataset 'spufidsn
    spufidsn = ''
    signal spufi
    end
/*********************************************************************/
/*** Allocate the SPUFI output dataset                             ***/
/*********************************************************************/
"Free f(spufin)"
"Alloc f(spufin) da('"spufidsn"') shr"
/*********************************************************************/
/*** Read it into the stack                                        ***/
/*********************************************************************/
"Execio * diskr spufin (finis"
"Free f(spufin)"
rows = 0
/*********************************************************************/
/*** read through the SPUFI output dataset, binning the rubbish    ***/
/***   and loading the data into a table                           ***/
/*********************************************************************/
Do while queued() > 0
    pull rec
    if process = 'Y' then do
        x = substr(rec,1,4)
        if x ^= '----' & x ^= 'NAME' & x ^= 'DSNE' then do
            rows = rows + 1
            name.rows = word(rec,3)
            plname.rows = word(rec,1)
            qualifier.rows = word(rec,2)
        end
        if x = 'DSNE' then process = 'N'
    end
    if word(rec,1) = 'NAME' then process = 'Y'
end
return


J L Hedger (UK)                    c Xephon 1996

