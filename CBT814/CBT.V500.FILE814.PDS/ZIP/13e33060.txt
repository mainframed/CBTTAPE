Archiving SYSOUT

We have often experienced the problem of users forgetting
about their SYSOUT output in the held output class, causing it
to accumulate and use up the available spool space. We needed
a way of moving the older SYSOUT off spool onto some less
critical resource from where, if needed, it could later be
retrieved. What was developed was a process that relied on the
TSO OUTPUT command.

The OUTPUT command can be used to transfer the output of a
job to a specific dataset. To do this for one particular job, the
job name and job-id must be supplied. We get this information
from a listing generated by SDSF. Information from this listing
is also used in determining the age of the SYSOUT, building
the name of the dataset that will hold the SYSOUT, and
providing a record of what was archived.

The archiving process is accomplished by two jobs: TS$OFFQ,
which moves the SYSOUT from spool to disk files, and
TS$DUMP, which dumps the disk files to tape.

An inventory is kept of what is archived and is stored in two
files: HOLDQ.@.INVNTORY, which contains an inventory of
SYSOUT currently in disk files (and is cleared each time the
disk files are dumped to tape), and HOLDQ.@.REGISTER,
which is a cumulative inventory. The latter file also contains
the name of each dataset holding the SYSOUT and the tape the
dataset was dumped to. When the tape is scratched, each
record in the register associated with that tape is manually
deleted. Updating the records in the register with the
appropriate tape VOLSER has not yet been automated.
Currently, each time disk files are dumped to tape, records are
added to the register indicating what tape was used. For the
first file, the DCB information is
DCB=(DSORG=PS,RECFM=FB,LRECL=224,BLKSIZE=...);
for the second file, it is DCB=(DSORG=PS,RECFM=FB,
LRECL=173,BLKSIZE=...).

The first job, TS$OFFQ, is run every day. It generates a list,
using SDSF, of all SYSOUT in the held output queue, prints
the list using DFSORT, and invokes the CLIST OFFQ, which
uses the list in moving SYSOUT from spool to disk files.


JOB TS$OFFQ

//TS$OFFQ  JOB ...
//*  DOC:  THIS JOB:
//*          1. GENERATES A LIST OF OUTPUT IN THE "HELD OUTPUT QUEUE"
//*             USING SDSF
//*          2. PRINTS THE "HELD OUTPUT QUEUE" LIST (FROM STEP 1)
//*          3. EXECUTES THE "OFFQ" CLIST
//*             (THE "OFFQ" CLIST REMOVES OLD OUTPUT FROM THE
//*             "HELD OUTPUT QUEUE" AND PUTS IT INTO REGULAR DISK
//*             FILES, WHICH WILL EVENTUALLY BE DUMPED TO TAPE BY
//*             JOB "TS$DUMP".)
//$1LIST   EXEC PGM=SDSF,
//             PARM='++60,228'    <-- SCREEN LENGTH, SCREEN WIDTH
//HASPAC00 DD  DSN=SYS1.JESPACE1,DISP=SHR
//HASPCKPT DD  DSN=SYS1.JESCKPT1,DISP=SHR
//ISFOUT   DD  DSN=&&ISFOUT,DISP=(NEW,PASS),SPACE=(11450,(5,1)),
//             UNIT=VIO,DCB=(RECFM=FB,BLKSIZE=11450,LRECL=229)
//ISFIN    DD  *
  PREFIX
  H ALL
  ++ALL
  END
/*
//$2PRINT  EXEC PGM=ICEMAN
//SYSOUT   DD  SYSOUT=*
//SORTIN   DD  DSN=&&ISFOUT,DISP=(SHR,PASS)
//SORTOUT  DD  SYSOUT=*,DCB=(RECFM=FBA,BLKSIZE=229,LRECL=229)
//SYSIN    DD  *
 OPTION  COPY,SKIPREC=120
/*
//$3OFFQ   EXEC PGM=IKJEFT01,REGION=1M,DYNAMNBR=30
//SYSPROC  DD  DSN=OUR.CLIST.LIBRARY,   <-- Contains CLIST "OFFQ"
//             DISP=SHR
//ISFOUT   DD  DSN=&&ISFOUT,DISP=(OLD,DELETE)
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  *
%OFFQ        /* INVOKE CLIST
END


CLIST OFFQ

PROC   MAX_AGE(2) +
       DEBUG      /*  NOTE:  IF DEBUG IS SELECTED, THEN        */
                  /*         &SYSOUTTRAP SHOULD BE SET TO "2"  */
                  /*         INSTEAD OF "1", AND &SYSOUTLINE2  */
                  /*         SHOULD BE REFERENCED INSTEAD OF   */
                  /*         &SYSOUTLINE1.                     */
/*    DOC:  THIS CLIST IS USED TO REMOVE OLD OUTPUT FROM THE       */
/*          "HELD OUTPUT QUEUE" AND PUT IT INTO REGULAR DISK       */
/*          FILES, WHICH WILL EVENTUALLY BE DUMPED TO TAPE.        */
/*          THE NAMING CONVENTION FOR THE DISK FILES IS:           */
/*              HOLDQ.<CRDATE>.<JOBNAME>.<JOBNUMBER>               */
/*              "PROGRAMMER'S NAME" & "NOTIFY ID" ARE APPENDED     */
/*              TO THE DATASET NAME IF THEY EXIST.                 */
/*          AN INVENTORY OF OUTPUT REMOVED FROM THE QUEUE AND      */
/*          MADE INTO DISK FILES SINCE THE LAST DUMP TO TAPE       */
/*          IS KEPT IN DATASET "HOLDQ.@.INVNTORY".                 */
/*          DATASET "HOLDQ.@.REGISTER" CONTAINS A CUMULATIVE       */
/*          INVENTORY, HOLDING INFORMATION GARNERED FROM THE       */
/*          "HELD OUTPUT QUEUE" SDSF LIST PLUS THE DSNAMES OF      */
/*          THE GENERATED DATASETS.  PROVISION IS MADE FOR THE     */
/*          LATER INCLUSION OF VOLSERS OF THE TAPES WHERE THE      */
/*          DATASETS WILL BE KEPT.                                 */
    CONTROL  MAIN  END(ENDD)  ASIS
    IF &DEBUG=DEBUG  THEN +
        CONTROL  LIST SYMLIST CONLIST
    PROFILE  NOPREFIX
/*                   E R R O R    R O U T I N E                    */
    ERROR +
        DO
            SET &RETURNCD = &LASTCC
            IF &RETURNCD = 400  THEN +
                DO
                SET &EOF  = TRUE
                RETURN
                ENDD
            WRITE *********************************************
            WRITE *   UNEXPECTED CONDITION  --  LASTCC = &RETURNCD   *
            WRITE *********************************************
            WRITE *
            WRITE *   LAST TSO COMMAND:  &SYSPCMD
            WRITE *   LAST TSO SUB-CMD:  &SYSSCMD
            WRITE *
            WRITE *********************************************
            WRITE *
            WRITE *   SDSF LINE &JOBCOUNT == +
                      JOBNAME &SUBSTR(6:13,&ISFOUT) == +
                      JNUM &SUBSTR(20:23,&ISFOUT) == +
                      CR-DATE &SUBSTR(28:35,&ISFOUT)
            WRITE *
            WRITE *********************************************
            SET &ECOUNT = &ECOUNT + 1
            GOTO ENDALL
        ENDD
/*                      M A I N    R O U T I N E                     */
/*                          S T A R T    U P                         */
    WRITE
    WRITE =============================================================+
          ====================
    WRITE |                                                            _
                   |
    WRITE |                                O   F   F     Q             _
                   |
    WRITE |                                                            _
                   |
    WRITE =============================================================+
          ====================
    WRITE
    WRITE                                 DATE:  &SYSDATE
    WRITE                                 TIME:  &SYSTIME
    WRITE                                 USER:  &SYSUID
    WRITE                                TSO/E:  &SYSTSOE
    WRITE
    WRITE =============================================================+
          ====================
    WRITE
    WRITE
/*     TRANSFER OUTPUT FROM "HELD OUTPUT QUEUE" TO DISK FILES         */
/*      ALLOCATE FILE CONTAINING SDSF LIST      */
/*  ALLOC DDNAME(ISFOUT)     *** ALLOCATED IN EXECUTING STEP ***   */
/*      ADVANCE TO "HELD OUTPUT QUEUE" LISTING      */
    OPENFILE ISFOUT  INPUT
    SET &SCREENLENGTH = 60
    SET &TARGET_LINE  = (&SCREENLENGTH * 2) + 1
    SET &LINECOUNT    = 0
    DO WHILE &LINECOUNT < &TARGET_LINE
        SET &LINECOUNT = &LINECOUNT + 1
        GETFILE ISFOUT
        ENDD
/*      EXTRACT JOB TOTAL      */
    SET &LPAREN = &STR((
    SET &RPAREN = )
    SET &COL  = 66
    SET &CHAR = &SUBSTR(&COL,&ISFOUT)
    DO WHILE  &STR(&CHAR) NE &STR(&LPAREN)  AND  &COL < 80
        SET &COL  = &COL + 1
        SET &CHAR = &SUBSTR(&COL,&ISFOUT)
        ENDD
    SET &TOTALJOBS = 0
    SET &COL   = &COL + 1
    SET &CHAR  = &SUBSTR(&COL,&ISFOUT)
    DO WHILE  &STR(&CHAR) NE &STR(&RPAREN)  AND  &COL < 80
        SET &TOTALJOBS = &TOTALJOBS&CHAR
        SET &COL  = &COL + 1
        SET &CHAR = &SUBSTR(&COL,&ISFOUT)
        ENDD
/*      ALLOCATE INVENTORY FILES      */
    ALLOC DDNAME(INVNTORY)  DSNAME('HOLDQ.@.INVNTORY')  +
        MOD   KEEP
    ALLOC DDNAME(REGISTER)  DSNAME('HOLDQ.@.REGISTER')  +
        MOD   KEEP
/*      ADVANCE TO END OF HEADING; SAVE COLUMN HEADINGS      */
    GETFILE ISFOUT
    GETFILE ISFOUT
    OPENFILE INVNTORY  OUTPUT
    SET &INVNTORY = &STR(........................................)+
                    &STR(........................................)+
                    &STR(........................................)+
                    &STR(........................................)+
                    &STR(........................................)
    PUTFILE INVNTORY
    SET &INVNTORY = &STR(<  &SYSDATE  &SYSSTIME  >)+
                    &STR(      FROM HELD OUTPUT QUEUE)
    PUTFILE INVNTORY
    SET &INVNTORY = &SUBSTR(6:229,&ISFOUT)
    PUTFILE INVNTORY
/*      SET UP TABLE FOR DATE CONVERSION      */
    SET &DAYS_YTM1  =   0      /* DAYS IN YEAR UP TO JAN */
    SET &DAYS_YTM2  =  31      /* DAYS IN YEAR UP TO FEB */
    SET &DAYS_YTM3  =  59      /* DAYS IN YEAR UP TO MAR */
    SET &DAYS_YTM4  =  90      /* DAYS IN YEAR UP TO APR */
    SET &DAYS_YTM5  = 120      /* DAYS IN YEAR UP TO MAY */
    SET &DAYS_YTM6  = 151      /* DAYS IN YEAR UP TO JUN */
    SET &DAYS_YTM7  = 181      /* DAYS IN YEAR UP TO JUL */
    SET &DAYS_YTM8  = 212      /* DAYS IN YEAR UP TO AUG */
    SET &DAYS_YTM9  = 243      /* DAYS IN YEAR UP TO SEP */
    SET &DAYS_YTM10 = 273      /* DAYS IN YEAR UP TO OCT */
    SET &DAYS_TYM11 = 304      /* DAYS IN YEAR UP TO NOV */
    SET &DAYS_YTM12 = 334      /* DAYS IN YEAR UP TO DEC */
/*      PROCESS JOBS IN LISTING      */
    SET &THISYEAR = &SUBSTR(1:2,&SYSJDATE)
    SET &THISDAY  = &SUBSTR(4:6,&SYSJDATE)
    SET &RECSIZE   =   133
    SET &BLOCKSIZE = 23408
    SET &RPB = &BLOCKSIZE / &RECSIZE /* RECORDS PER BLOCK */
    SET &BPT = 47476 / &BLOCKSIZE    /* BLOCKS  PER TRACK (3380 DASD) */
    SET &RPT = &RPB * &BPT           /* RECORDS PER TRACK */
    SET &MAXRECS = 100000            /* ASSUMED MAXIMUM RECORDS */
    SET &MAXTRKS = &MAXRECS / &RPT   /* ASSUMED MAXIMUM TRACKS  */
    SET &JOBCOUNT = 0
    SET &TCOUNT   = 0
    SET &WCOUNT   = 0
    SET &ECOUNT   = 0
    OPENFILE REGISTER  OUTPUT
LOOPTOP: +
    DO WHILE &JOBCOUNT < &TOTALJOBS
        /*      TOP OF LOOP      */
        SET &JOBCOUNT = &JOBCOUNT + 1
        GETFILE ISFOUT
        /*      BYPASS HEADING      */
        IF &SUBSTR(8:18,&ISFOUT) = &STR(HELD OUTPUT)  THEN +
            DO
            GETFILE ISFOUT
            GETFILE ISFOUT
            GETFILE ISFOUT
            ENDD
        /*      CHECK OUTPUT CLASS                      */
        /*      (OUR SHOP BYPASSES CLASS D OUTPUT)      */
        SET &CLASS = &SUBSTR(37,&ISFOUT)
        IF &CLASS = &STR(D)  THEN +
            GOTO LOOPBOT
        /*      EDIT END-DATE      */
        SET &CRYEAR = &SUBSTR(191:192,&ISFOUT)
        SET &CRDAY  = &SUBSTR(194:196,&ISFOUT)
        SET &CRDATE = &SUBSTR(191:192,&ISFOUT)+
                      &SUBSTR(194:196,&ISFOUT)
        IF &CRDAY > 0  THEN +
            GOTO COMPUTE_AGE
                             /* ...OTHERWISE THE END-DATE IS ZEROES  */
                             /* AND THEREFORE UNUSABLE, SO THE       */
                             /* CREATION-DATE WILL BE USED INSTEAD.  */
        /*      EDIT CREATION-DATE      */
        SET &CRDATE = &SUBSTR(28:35,&ISFOUT)
        SET &CRMONTH      = &SUBSTR(1:2,&CRDATE)
        SET &CRDAYOFMONTH = &SUBSTR(4:5,&CRDATE)
        SET &CRYEAR       = &SUBSTR(7:8,&CRDATE)
        SET &CRMONTH = &CRMONTH            /* DISCARD LEADING BLANKS */
        SET &DAYS_YTM = &&DAYS_YTM&CRMONTH
        SET &CRDAY    = &DAYS_YTM + &CRDAYOFMONTH
        IF &CRYEAR // 4 = 0  THEN +
            SET &LEAPYEAR = TRUE
        ELSE +
            SET &LEAPYEAR = FALSE
        IF &CRMONTH > 2  AND  &LEAPYEAR = TRUE  THEN +
            SET &CRDAY = &CRDAY + 1      /* ADJUSTMENT FOR LEAP YEAR */
        IF &CRDAY < 10  THEN +
            SET &CRDATE = &CRYEAR+
                          &STR(00&CRDAY)
        ELSE +
            IF &CRDAY < 100  THEN +
                SET &CRDATE = &CRYEAR+
                              &STR(0&CRDAY)
            ELSE +
                SET &CRDATE = &CRYEAR+
                              &CRDAY
        /*      COMPUTE AGE AND TEST      */
COMPUTE_AGE: +
        IF &CRYEAR < &THISYEAR   THEN +
            DO
            IF &CRYEAR // 4 = 0  THEN +
                SET &LEAPYEAR = TRUE
            ELSE +
                SET &LEAPYEAR = FALSE
            IF &LEAPYEAR = TRUE  THEN +
                SET &CRDAY = &CRDAY - 366
            ELSE +
                SET &CRDAY = &CRDAY - 365
            ENDD
        SET &AGE = &THISDAY - &CRDAY
        IF &AGE NG &MAX_AGE  THEN +
            GOTO LOOPBOT
        /*      EDIT PROGRAMMER'S NAME      */
        SET &PNAME1  = &SUBSTR(106:115,&ISFOUT)
        SET &LASTCOL = &LENGTH(&STR(&PNAME1))
        SET &PNAME2 =
        SET &COL        = 0
        DO WHILE &COL < &LASTCOL
            SET &COL  = &COL + 1
            SET &CHAR = &SUBSTR(&COL,&PNAME1)
            IF (&STR(&CHAR) >= A AND &STR(&CHAR) <= Z) OR +
               (&STR(&CHAR) >= 0 AND &STR(&CHAR) <= 9) OR +
               (&STR(&CHAR)  = @) OR +
               (&STR(&CHAR)  = #) OR +
               (&STR(&CHAR)  = $) THEN +
                SET &PNAME2 = &STR(&PNAME2&CHAR)
            ENDD
                                          /* DSN QUALIFIER CANNOT    */
                                          /* BEGIN WITH A NUMERIC    */
        SET &PNAME2 = &PNAME2&STR(        )
        IF &DATATYPE(&SUBSTR(1,&PNAME2)) = NUM      THEN +
            SET &PNAME2 = &STR(#)&SUBSTR(1:7,&PNAME2)
        ELSE +
            SET &PNAME2 = &SUBSTR(1:8,&PNAME2)
         SET &PNAME2 = &STR(.)&PNAME2     /* INCLUDE DELIMITER AND   */
                                          /* DISCARD TRAILING BLANKS */
         /*      EDIT "NOTIFY ID"      */
         SET &NOTIFY1 = &SUBSTR(132:138,&ISFOUT)
         SET &LASTCOL = &LENGTH(&STR(&NOTIFY1))
         SET &NOTIFY2 =
         SET &COL     = 0
         DO WHILE &COL < &LASTCOL
             SET &COL  = &COL + 1
             SET &CHAR = &SUBSTR(&COL,&NOTIFY1)
             IF (&STR(&CHAR) >= A AND &STR(&CHAR) <= Z) OR +
                (&STR(&CHAR) >= 0 AND &STR(&CHAR) <= 9) OR +
                (&STR(&CHAR)  = @) OR +
                (&STR(&CHAR)  = #) OR +
                (&STR(&CHAR)  = $) THEN +
                 SET &NOTIFY2 = &NOTIFY2&CHAR
             ENDD
                                           /* DSN QUALIFIER CANNOT    */
                                           /* BEGIN WITH A NUMERIC    */
         SET &NOTIFY2 = &NOTIFY2&STR(        )
         IF &DATATYPE(&SUBSTR(1,&NOTIFY2)) = NUM     THEN +
             SET &NOTIFY2 = &STR(#)&SUBSTR(1:7,&NOTIFY2)
         ELSE +
             SET &NOTIFY2 = &SUBSTR(1:7,&NOTIFY2)
         SET &NOTIFY2 = &NOTIFY2           /* DISCARD TRAILING BLANKS */
         /*      EDIT JOB NAME      */
         SET &JOBNAME = &SUBSTR(6:13,&ISFOUT)
         IF &DATATYPE(&SUBSTR(1,&JOBNAME)) = NUM    THEN +
             GOTO BAD_JOBNAME
         IF &SUBSTR(1,&JOBNAME) = &STR( )    THEN +
             GOTO BAD_JOBNAME
         DO &LASTCOL = 8 TO 1 BY -1       /* GET LENGTH OF JOBNAME   */+
             WHILE &SUBSTR(&LASTCOL,&JOBNAME) = &STR( )
             ENDD
         SET &JOBNAME   = &SUBSTR(1:&LASTCOL,&JOBNAME)
         SET &LJOBNAME  = &LASTCOL
         SET &JOBNAME_STAT = OK
         DO &COL = 1 TO &LASTCOL  WHILE &JOBNAME_STAT = OK
             SET &CHAR = &SUBSTR(&COL,&JOBNAME)
             IF (&STR(&CHAR) >= A AND &STR(&CHAR) <= Z) OR +
                (&STR(&CHAR) >= 0 AND &STR(&CHAR) <= 9) OR +
                (&STR(&CHAR)  = @) OR +
                (&STR(&CHAR)  = #) OR +
                (&STR(&CHAR)  = $) THEN
             ELSE +
                 SET &JOBNAME_STAT = BAD
             ENDD
         IF &JOBNAME_STAT = OK  THEN +
             GOTO EDIT_JOBID
BAD_JOBNAME: +
        SET &ECOUNT = &ECOUNT + 1
        WRITE
        WRITE -->  INVALID JOBNAME:  +
                  JOBNAME &SUBSTR(6:13,&ISFOUT) == +
                  JNUM &SUBSTR(20:23,&ISFOUT) == +
                  CR-DATE &SUBSTR(28:35,&ISFOUT) == +
                  (SDSF LINE #&JOBCOUNT)
        WRITE
        GOTO LOOPBOT
        /*      EDIT JOB ID      */
EDIT_JOBID: =
        SET &JOBTYPE = &SUBSTR(15:17,&ISFOUT)
        SET &JOBNUM  = &SUBSTR(20:23,&ISFOUT)
        SET &JOBNUM  = &JOBNUM            /* DISCARD LEADING BLANKS  */
        SET &JOBID1  = &JOBTYPE&JOBNUM
        SET &JOBID2  = &SUBSTR(1,&JOBTYPE)&JOBNUM
        /*      EDIT "TOT-REC" AND TEST      */
        SET &TOT_REC = &SUBSTR(62:70,&ISFOUT)
        SET &TOT_REC = &TOT_REC          /* DISCARD LEADING BLANKS */
        SET &LASTCOL = &LENGTH(&TOT_REC)
        SET &RECCNT = 0
        SET &COL    = 0
        DO WHILE &COL < &LASTCOL
            SET &COL  = &COL + 1
            SET &CHAR = &SUBSTR(&COL,&TOT_REC)
            IF &CHAR NE &STR(,)  THEN +
                SET &RECCNT = &RECCNT&CHAR
            ENDD
        IF &RECCNT = 0  THEN       /* A COUNT OF ZERO MAY BE WRONG */ +
            SET &RECCNT = 100000
        /*      BUILD DSNAME FOR DISK FILE      */
        SET &DSN = &STR(HOLDQ.)+
                   &STR(@&CRDATE..)+
                   &STR(&JOBNAME..)+
                   &STR(&JOBID2)
        IF &PNAME2 NE &STR(.)      THEN +
            SET &DSN = &DSN&PNAME2
        IF &NOTIFY2 NE &STR()  THEN +
            SET &DSN = &DSN&STR(.)&NOTIFY2
        IF &LENGTH(&DSN) > 44  THEN +
            SET &DSN = &SUBSTR(1:44,&DSN)
        /*      DUPLICATE DSNAME?      */
        SET &DUPNO   = 1
        SET &ORIGDSN = &STR(&DSN)
DUPDSN: +
        SET &STATUS = &SYSDSN('&DSN')
        IF &STATUS = OK  THEN +
            DO
            SET &WCOUNT = &WCOUNT + 1
            WRITE
            WRITE -->  DUPLICATE DSNAME:  &DSN
            WRITE
            SET &DUPNO = &DUPNO + 1
            IF &LENGTH(&ORIGDSN) > 41 THEN +
                SET &DSN = &SUBSTR(1:41,&ORIGDSN)&STR(.#&DUPNO)
            ELSE +
                SET &DSN = &ORIGDSN&STR(.#&DUPNO)
            GOTO DUPDSN
            ENDD
        /*      CHECK IF OUTPUT STILL ON QUEUE      */
        SET &A = 26 + &LJOBNAME
        SET &B = &A + 14
        SET &C = &A + 8
        SET &SYSOUTTRAP = 1
        STATUS &STR(&JOBNAME)(&JOBID1)
        SET &SYSOUTTRAP = 0
        SET &STATUS = &SYSOUTLINE1&STR(                    )
        IF &SUBSTR(&A:&B,&STATUS) NE &STR(ON OUTPUT QUEUE)  AND  +
           &SUBSTR(&A:&C,&STATUS) NE &STR(EXECUTING)        THEN +
            DO
            SET &ECOUNT = &ECOUNT + 1
            WRITE
            WRITE -->  NOT ON OUTPUT QUEUE:  +
                      JOBNAME &SUBSTR(6:13,&ISFOUT) == +
                      JNUM &SUBSTR(20:23,&ISFOUT) == +
                      CR-DATE &SUBSTR(28:35,&ISFOUT) == +
                      (SDSF LINE #&JOBCOUNT)
            WRITE
            IF &DUPNO > 1  THEN +
                DO
                SET &DSN = &STR(* NOT ON SPOOL)+
                           &STR( - MAY BE IN ANOTHER DATASET *)
                GOTO UPDATE_INV
                ENDD
            ELSE +
                GOTO LOOPBOT
            ENDD
        /*      ALLOCATE DISK FILE      */
        IF &RECCNT > &MAXRECS  THEN +
            SET &TRKS1 = &RECCNT / &RPT   /* USE &RECCNT FOR ALLOC  */
        ELSE +
            SET &TRKS1 = &MAXTRKS         /* USE &MAXRECS FOR ALLOC */
        ALLOC DSNAME('&DSN')                   +
            NEW   CATALOG                      +
            UNIT(DISK)                         +
            VOLUME(DISK01)                     +
            SPACE(&TRKS1,30)  TRACKS  RELEASE  +
            RECFM(F B)  BLKSIZE(&BLOCKSIZE) LRECL(&RECSIZE)
        /*      TRANSFER OUTPUT      */
        SET &SYSOUTTRAP = 1000
        OUTPUT &STR(&JOBNAME)(&JOBID1) PRINT('&DSN')
        SET &LINETOTAL  = &SYSOUTLINE
        SET &SYSOUTTRAP = 0
                                        /* TEST FOR "READ I/O ERROR" */
        IF &LINETOTAL > 1  THEN +
            IF &STR(&SUBSTR(01:09,&SYSOUTLINE1)) = &STR(IKJ56291I) AND +
               &STR(&SUBSTR(72:76,&SYSOUTLINE2)) = &STR(X'04')     AND +
               &STR(&SUBSTR(88:98,&SYSOUTLINE2)) = &STR(X'0000000C') +
            THEN +
                OUTPUT &STR(&JOBNAME)(&JOBID1) DELETE
        SET &LINECOUNT    = 0
        DO WHILE &LINECOUNT  NE  &LINETOTAL
            SET &LINECOUNT = &LINECOUNT + 1
            SET &LINELABEL = &&SYSOUTLINE&LINECOUNT
            WRITE &LINELABEL
            ENDD
        SET &TCOUNT = &TCOUNT + 1
        FREE DSNAME('&DSN')
        /*      UPDATE INVENTORY FILES      */
UPDATE_INV: +
        SET &INVNTORY = &SUBSTR(6:229,&ISFOUT)
        PUTFILE INVNTORY
        SET &REGISTER = &SUBSTR(006:013,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(015:017,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(020:023,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(028:035,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(062:070,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(106:125,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(132:138,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(154:159,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(145:152,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(175:180,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(166:173,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(191:196,&ISFOUT)+
                        &STR( )+
                        &SUBSTR(182:189,&ISFOUT)+
                        &STR(                )+
                        &STR(&DSN)+
                        &STR(                     )+
                        &STR(                      )
        PUTFILE REGISTER
        /*      BOTTOM OF LOOP      */
LOOPBOT: +
        ENDD
    CLOSFILE ISFOUT
    CLOSFILE INVNTORY
    CLOSFILE REGISTER
/*                        E N D    A L L                             */
ENDALL: +
    ERROR OFF
    WRITE
    WRITE
    WRITE TOTAL JOBS PROCESSED = &JOBCOUNT
    WRITE
    WRITE ERRORS ............... &ECOUNT
    WRITE WARNINGS ............. &WCOUNT
    WRITE ATTEMPTED TRANSFERS .. &TCOUNT
    WRITE
    WRITE
    WRITE ............................................................+
          ....................
    WRITE
    WRITE
    WRITE           * * * * * *          PROCESSING ENDED          +
          * * * * * *
    WRITE
    WRITE                      DATE:  &SYSDATE      TIME:  &SYSTIME
    WRITE
    CONTROL  NOMSG
    FREE DDNAME(INVNTORY,REGISTER)
    FREE DSNAME('&DSN')
    EXIT

We shall be concluding this article in next month's issue with the publication of the remaining details.

Paul C Bono
Systems Programmer
NYS Office of Mental Health (USA)                                c Xephon 1993

