*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
SRVPLMVS TITLE 'MVS Print_Line Service Processor'
         SMLIST CONVERT=YES           |
         srvmod name=srvplmvs,dates='1989, 1990, 1995'
         gblc  &srv_modname
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1989, 1990.
*
*  Program     SRVPLMVS, MVS Print_Line Service Processor.
*
*  Abstract    This service processor is MVS dependent and relieves the
*              caller of many chores associated with report writing.
*
*  Parameters:
*
*    PL_Start
*      CALLX SRVPLMVS,(pl_ID,&PL_Start,ESV,DDName,PageSize,MaxLineSize,
*                      SizeLength,Reference)
*
*    PL_Terminate
*      CALLX SRVPLMVS,(pl_ID,&PL_Terminate)
*
*    PL_Set_Header
*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Header,LineNbr,String,StringLen)
*
*    PL_Set_Formatted_Header
*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Formatted_Header,
*                      LineNbr,FormatString,FormatStringLen,PageDisp,
*                      Source(1),...,Source(50))
*
*    PL_Reset_Header
*      CALLX SRVPLMVS,(pl_ID,&PL_Reset_Header,LineNbr)
*
*    PL_Set_Footer
*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Footer,LineNbr,String,StringLen)
*
*    PL_Set_Formatted_Footer
*      CALLX SRVPLMVS,(pl_ID,&PL_Set_Formatted_Footer,
*                      FormatString,FormatStringLen,PageDisp,
*                      Source(1),...,Source(50))
*
*    PL_Reset_Footer
*      CALLX SRVPLMVS,(pl_ID,&PL_Reset_Footer,LineNbr)
*
*    PL_Reserve_Footer
*      CALLX SRVPLMVS,(pl_ID,&PL_Reserve_Footer,Lines)
*
*    PL_Page_Break
*      CALLX SRVPLMVS,(pl_ID,&PL_Page_Break)
*
*    PL_Print
*      CALLX SRVPLMVS,(pl_ID,&PL_Print,String,StringLen)
*
*    PL_Formatted_Print
*      CALLX SRVPLMVS,(pl_ID,&PL_Formatted_Print,
*                      FormatString,FormatStringLen,
*                      Source(1),...,Source(50))
*
*    The meaning of each parameter is explained below.
*
*    pl_ID is a fullword used to uniquely identify the invocation of
*      the Print_Line service processor.  It is initialized during the
*      startup function.
*
*    FunctionCode is a fullword integer that specifies the function to
*      be performed.  Symbolic identifiers are provided for each
*      function and may be accessed by placing a COPY statement for
*      SRVPLMAC in the assembler program.  These symbols should be
*      used in place of actual integer values.  The following
*      FunctionCodes are supported:
*
*      &PL_Start = 1
*        Identify the ddname that points to the report file, set the
*        maximum page and line lengths.
*
*      &PL_Terminate = 2
*        Shutdown this invocation.  This function causes any incomplete
*        pages to be completed and closes the report file.
*
*      &PL_Set_Header              =  3
*        Define a header line.  The LineNum parameter determines the
*        position of the header line in the header.  Respecifying a
*        LineNum parameter causes that header line to be replaced.
*
*      &PL_Set_Formatted_Header    =  4
*        Define a header line to be formatted using the String Format-
*        ter.
*
*      &PL_Reset_Header            =  5
*        Causes one or all header line definitions to be deleted.
*
*      &PL_Set_Footer              =  6
*        Define a footing line.  The LineNum parameter determines the
*        position of the footing line in the footer.  Respecifying a
*        LineNum parameter causes that footer line to be replaced.
*
*      &PL_Set_Formatted_Footer    =  7
*        Define a footing line to be formatted using the String Format-
*        ter.
*
*      &PL_Reset_Footer            =  8
*        Causes one or all footing line definitions to be deleted.
*
*      &PL_Reserve_Footer          =  9
*        Causes a number of lines to be 'reserved' at the bottom of
*        a logical page for the footing.  The number specified is used
*        to determine when end-of-logical-page occurs.
*
*      &PL_Page_Break              =  10
*        Forces a page break, causing the current page to be printed
*        with footing.  If printing continues, the next data line will
*        cause the headers to come out.
*
*      &PL_Print                   =  11
*        Prints a data line as-is.
*
*      &PL_Formatted_Print         =  12
*        Formats and prints a data line based on the user's format
*        specifications.
*
*      &PL_Get_Info  =  14
*        Return requested information.
*
*      &PL_Get_Reference =  15
*        Return reference string.
*
*    ESV is a fullword given to the application by the Server Manager
*      when it was started up.
*
*    DDName specified the DDName of the report file.  This file will
*      be a RECFM=VBA file.  Its blocksize will default to (LRECL+4),
*      unless overridden by JCL.
*
*
*  Return codes:
*
*   &PL_Invalid_Function
*      An invalid function was specified.
*   &PL_Invalid_Number_Of_Parms
*      An invalid number of parameters for a specific function was
*      specified.
*   &PL_Invalid_PL_ID
*      The service processor token does not point to the correct data.
*   &PL_Environment_Support_Error
*      The Environment Support service processor returned an error.
*   &PL_Memory_Manager_Error
*      The Memory Manager service processor returned an error.
*   &PL_String_Handler_Error
*      The String Handler service processor returned an error.
*   &PL_Cannot_Open_DCB
*      A DCB for the DDname provided could not be opened.
*   &PL_Invalid_PageDisp
*      A page displacement value exceeds the number of source parms
*      in a formatted header or footer definition.
*   &PL_Header_Not_Found
*      The line number specified on a reset_header call wasn't found.
*   &PL_Footer_Not_Found
*      The line number specified on a reset_footer call wasn't found.
*   &PL_Print_Line_Truncated
*      The length of the caller-provided string or the formatted string
*      exceeded the maximum line length.  The truncated line is printed
*      before control is returned to the caller.
*
*  Program     Reentrant, problem key and state, server linkage,
*  Attributes  non-authorized, AMODE(31), RMODE(ANY)
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*  Method of
*  Operation   Refer to the code
*
*
*  Special Notes:
*
*---------------------------------------------------------------------*
 space 1                              |
 print off                            |
 copy  smsyms                         | Structured Macros symbols.
 copy  srvesmac                       | Environment support symbols.
 copy  srvmmmac                       | Memory Manager symbols.
 copy  srvstmac                       | String Formatter symbols.
 copy  srvplmac                       | Print Line symbols.
 copy  srvfimac                       | File handler symbols.
 print on,gen                         |
 eject                                |
**--------------------------------------------------------------------*
**
**  Identify the service processors that Print Line will use.
**
**--------------------------------------------------------------------*
       space 1                        |
 es_id         id=ES,                 |                                *
               spepa=pwa_ES_epa,      |                                *
               sptoken=pwa_ES_token,  |                                *
               esva=pwa_esv           |
       space 1                        |
 mm_id         id=MM,                 |                                *
               spepname=&Memory_Manager,                               *
               spepa=pwa_MM_epa,      |                                *
               sptoken=pwa_MM_token,  |                                *
               esid=ES                |
       space 1                        |
 st_id         id=ST,                 |                                *
               spepname=&String_Handler,                               *
               spepa=pwa_ST_epa,      |                                *
               sptoken=pwa_ST_token,  |                                *
               esid=ES                |
       space 1                        |
 fi_id         id=FI,                 |                                *
               spepname=&FI_OS_File_Handler,                           *
               spepa=pwa_FI_epa,      |                                *
               sptoken=pwa_FI_token,  |                                *
               esid=ES                |
       space 1                        |
 eject                                |
 block name=&srv_modname,type=program,amode=31,rmode=any,              +
               options=(*srvprc,long,dyn,main,(parms,(using,r9))),     +
               parmmap=pl_parmlist,                                    +
               subopts=(*swa,loadbase)
* *-------------------------------------------------------------------*
* * Determine how many parameters were passed and load r1 with
* * function code.
* *-------------------------------------------------------------------*
  la    r1,pl_parmlist                | Point r1 to parameter list.
  la    r15,pl_max_#                  | Load r15 with maximum # parms.
  loop bct                            | Loop
   leave loop=*,(tbit,0(r1),x'80')    |  End of parms if high bit set.
   la   r1,4(,r1)                     |  Point to next parm address.
  endloop bct,r15                     | Endloop
  la    r0,pl_max_#+1                 | Calculate number of
  sr    r0,r15                        |  parms.  Ok if 2 <= num <= max
  sth   r0,pwa_number_of_parms        | Save number of parms.
  errexit (ch,r0,lt,=y(pl_min_#)),or,(ch,r0,gt,=y(pl_max_#)),          +
               code=&pl_invalid_number_of_parms
  l     r1,pl_functioncode            | Load the function code into
  l     r1,0(,r1)                     |   a register for testing.
* *-------------------------------------------------------------------*
* * If the function code is something other than start, make sure that
* * the PWA contains the eye-catcher string and the correct value for
* * pl_ID.   If not, then the pl_ID passed in is garbage.
* *-------------------------------------------------------------------*
  if (c,r1,ne,=f'&pl_start')          | If not startup function then
   errexit ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_pl_id)),   +
               code=&pl_invalid_pl_id |  go off and croak.
  endif                               | Endif.
  space 1                             |
  mvi   pwatf,x'00'                   | Clear 'truncation' flag
  rbit  pwaf1wrap                     | Clear 'wrapping' flag       @C2
  eject ,                             |
* *-------------------------------------------------------------------*
* * Select the code to process the function.
* *-------------------------------------------------------------------*
  caseblk reg=r1                      | Start of function case block.
  eject                               |
*  *------------------------------------------------------------------*
*  *
*  * Start function.
*  *
*  *------------------------------------------------------------------*
   case &pl_start                     |  Start function.            @C2
    callsub  start                    |                             @C2
   case &pl_terminate                 |                             @C2
    callsub  terminate                |                             @C2
   case &pl_set_header                |                             @C2
    callsub  set_header               |                             @C2
   case &pl_set_formatted_header      |                             @C2
    callsub  set_formatted_header     |                             @C2
   case &pl_reset_header              |                             @C2
    callsub  reset_header             |                             @C2
   case &pl_set_footer                |                             @C2
    callsub  set_footer               |                             @C2
   case &pl_set_formatted_footer      |                             @C2
    callsub  set_formatted_footer     |                             @C2
   case &pl_reset_footer              |                             @C2
    callsub  reset_footer             |                             @C2
   case &pl_reserve_footer            |                             @C2
    callsub  reserve_footer           |                             @C2
   case &pl_page_break                |                             @C2
    callsub  page_break               |                             @C2
   case &pl_print                     |                             @C2
    callsub  print                    |                             @C2
   case &pl_print_formatted           |                             @C2
    callsub  print_formatted          |                             @C2
   case &pl_query_lines_left          |                             @C2
    callsub  query_lines_left         |                             @C2
   case &pl_get_info                  |                             @C2
    callsub  get_info                 |                             @C2
   case &pl_get_reference             |                             @C2
    callsub  get_reference            |                             @C2
   case other                         | Unknown functioncode?
    errexit code=&pl_invalid_function |  Return error to caller.
  endcase                             |
 space 1                              |
* *-------------------------------------------------------------------*
* *  When exiting, see if we truncated a print line: if so, return a
* *  "truncated" return code, else set returncode zero.
* *-------------------------------------------------------------------*
 errexit       (tbit,pwatfhdr),       |                                *
               code=&pl_header_line_truncated
 errexit       (tbit,pwatfftr),       |                                *
               code=&pl_footer_line_truncated
 errexit       (tbit,pwatflin),       |                                *
               code=&pl_print_line_truncated
 errexit       (tbit,pwaf1wrap),      |  indicate that lines will   @C2*
               code=&pl_line_wrapping |   be wrapped if we continue @C2
 xr    r15,r15                        |  end normally w/RC zero.
 space 1                              |
 endblk block=&srv_modname,rc=(r15)   |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: start
*
*---------------------------------------------------------------------*
 block name=start,type=subroutine     |
* *-------------------------------------------------------------------*
* * Set the eyecatcher and the PL_ID fields.   These are checked
* * each time the PL server is entered to avoid integrity
* * problems.
* *-------------------------------------------------------------------*
  mvc   pwa_visual,eyecatcher         |   Both the eyecatcher and the
  st    r13,pwa_pl_id                 |   PL_ID are for validity checks
  xc    pwa_clear_start(pwa_clear_length),pwa_clear_start
  mvc   pwa_line_count,psd_force_eject  Force pagebreak
* *-------------------------------------------------------------------*
* * Make sure that a valid number of parameters are specified.
* *-------------------------------------------------------------------*
  lh    r3,pwa_number_of_parms        |   Load r3 with number of parms.
  errexit    (ch,r3,lt,=y(pl_start_min_#)),or,    Error if out         +
               (ch,r3,gt,=y(pl_start_max_#)),       of bounds.         +
               code=&pl_invalid_number_of_parms
* *-------------------------------------------------------------------*
* * Get ddname.
* *-------------------------------------------------------------------*
  l     r1,pl_start_ddname            |   Move ddname
  mvc   pwa_ddname,0(r1)              |   to PWA.
* *-------------------------------------------------------------------*
* * Determine if REFERENCE string was specified.
* *-------------------------------------------------------------------*
* lh    r3,pwa_number_of_parms
* if    (ch,r3,ge,=y(pl_start_reference_#))
*  l     r1,pl_start_reference        | Move reference string
*  mvc    pwa_pl_reference,0(r1)      | to pwa.
* else
*  fill   pwa_pl_reference,x'40'      | Fill with blanks.
*  mvc    pwa_pl_ref_part1,=c'DDNAME '
*  mvc    pwa_pl_ref_part2,pwa_ddname
* endif                               |
* *-------------------------------------------------------------------*
* * Copy optional parameters if they're present; else set defaults.
* *-------------------------------------------------------------------*
  la    r1,&pl_default_pagesize       |   Set default pagesize
  if    (ch,r3,ge,=al2(pl_start_pagesize_#))   If PageSize is there
   l     r2,pl_start_pagesize         |     Get it
   l32   r2,0(r2)                     |
   if    nz                           |     If it's nonzero,
    lr    r1,r2                       |      we'll use that.
   endif                              |
  endif                               |
  st    r1,pwa_pagesize               |
       space 1                        |
  la    r1,&pl_default_sizelength     |   Set default sizelength
  if    (ch,r3,ge,=al2(pl_start_sizelength_#)) If sizelength there
   l     r2,pl_start_sizelength       |     Get it
   la    r2,0(r2)                     |     Strip any x'80' VL bit
   if    (treg,r2,nz)                 |     If address present
    l32   r2,0(r2)                    |      Get the value
    errexit (ch,r2,gt,=h'4'),         |      More than 4? Trash!       *
               code=&pl_invalid_sizelength
    if    nz                          |     If it's nonzero,
     lr    r1,r2                      |      we'll use what they said.
    endif                             |
   endif                              |
  endif                               |
  st    r1,pwa_sizelength             | Whatever we decided = sizelen.
  bctr  r1,0                          |  r1 := offset into bit-masks
  la    r1,psd_bit_mask(r1)           |  r1 -> bit-mask for icm/stcm's.
  l8    r0,0(r1)                      |  r0 := bit-mask for icm/stcm's.
  st    r0,pwa_size_mask              |  save for dealing w/ lengths.
       space 1                        |
  la    r1,&pl_default_maxlinesize    |   Set default linesize
  if    (ch,r3,ge,=al2(pl_start_maxlinesize_#)) If lineSize is there
   l     r2,pl_start_maxlinesize      |     Get it
   l32   r2,0(r2)                     |
   if    nz                           |     If it's nonzero,
    lr    r1,r2                       |      we'll use that.
   endif                              |
  endif                               |
  st    r1,pwa_maxlinesize            | Save true MaxLineSize value
* *-------------------------------------------------------------------*
* * Verify that a valid maxlinesize was supplied.  Maxlinesize must
* * be >= 2 to avoid looping in the wrapping code due to the carriage
* * controls and must be <= 32768 in order to avoid line truncation.
* *-------------------------------------------------------------------*
  errexit (clc,pwa_maxlinesize,gt,=f'32768'),or,                    @C2+
               (clc,pwa_maxlinesize,lt,=f'2'),                      @C2+
               code=&pl_invalid_maxlinesize                         @C2
  l     r15,pwa_size_mask             | Get the SizeLength ICM mask
  exi   r15,(stcm,r1,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT
       eject                          |
* *-------------------------------------------------------------------*
* * Start the Memory Manager and String Formatter service processors.
* *-------------------------------------------------------------------*
  l    r1,pl_start_esv                |
  l    r1,0(r1)                       |
  st   r1,pwa_esv                     |
  using esv,r1                        |
  mvc   pwa_es_epa,esvesepa           |
  mvc   pwa_es_token,esvestkn         |
  drop  r1                            |
  ES_Load_Module  id=ES,spid=MM       | Use E.S. to load memory mgr.
  errexit    (treg,r15,nz),           |                                *
               code=&pl_environment_support_error
  MM_Start   ID=MM,                   | Start memory manager.          *
               Increment=4096,        |                                *
               Location=Any           |
  errexit    (treg,r15,nz),           |                                *
               code=&pl_memory_manager_error
         space 1                      |
  ES_Load_Module  id=ES,spid=ST       | Load string formatter.
  errexit    (treg,r15,nz),           |                                *
               code=&pl_environment_support_error
  ST_Start   ID=ST,                   | Start string formatter.        *
               SizeLength=pwa_sizelength
  errexit    (treg,r15,nz),           |                                *
               code=&pl_string_handler_error
* *-------------------------------------------------------------------*
* * Load and start File Handler for print file.
* *
* * Note: A 4 is coded for average record length.  For option fileid,
* * average record length is ignored except to determine the default
* * RECFM.  If the average record length matches the maximum record
* * length, the default RECFM is fixed, otherwise it is variable.
* * The default RECFM for PLMVS should be variable.
* *
* *-------------------------------------------------------------------*
  ES_Load_Module  id=ES,spid=FI       | Use E.S. to load file handler.
  errexit    (treg,r15,nz),           |                                *
               code=&pl_environment_support_error
  fi_start id=fi,                                                      *
               file=pwa_ddname,                                        *
               options=(output,fileid,isocc),                          *
               recordlength=(4,pwa_maxlinesize)
  st     r15,pwa_fi_last_rc           Save return code.
  errexit not,(%fi_success),code=&pl_file_handler_error
* *-------------------------------------------------------------------*
* *  Verify that the LRECL of the DDNAME is the same or greater     @C2
* *  than the specified maxlinesize.  If the lrecl is smaller than  @C2
* *  the specified maxlinesize, then we indicate that wrapping will @C2
* *  occur to the caller and the caller can decide if it is ok to   @C2
* *  continue processing.                                           @C2
* *-------------------------------------------------------------------*
  fi_get_info id=fi,recfm=pwa_recfm,  | get RECFM and LRECL values  @C2+
               lrecl=pwa_lrecl        |                             @C2
  errexit not,(%fi_success),code=&pl_file_handler_error             @C2
  lh    r1,pwa_lrecl                  | r1 := lrecl                 @C2
  errexit (c,r1,lt,=f'2'),code=&pl_invalid_lrecl   lrecl too small  @C2
  if   (clc,pwa_recfm(1),eq,=c'V')    | if recfm = variable         @C2
   sh   r1,=h'4'                      |  r1 := lrecl-4 (adj for RDW)@C2
  endif                               | endif                       @C2
  if   (c,r1,lt,pwa_maxlinesize)      | if lrecl < maxlinesize      @C2
   sbit pwaf1wrap                     |  indicate output wrapping   @C2
   st   r1,pwa_maxlinesize            |  set maxlinesize = lrecl    @C2
  endif                               | endif                       @C2
* *-------------------------------------------------------------------*
* *  Allocate temporary buffers to hold long formatted lines        @C2
* *-------------------------------------------------------------------*
  mvc   pwa_buffer_size,=f'32768'     | allocate 32K                @C2
  mvc   pwa_buffer_data_len,pwa_buffer_size                         @C2
  mm_obtain_storage id=mm,            | obtain the storage          @C2+
               size=pwa_buffer_size,  |                             @C2+
               address=pwa_buffer_data  buffer for data lines       @C2
  errexit not,(%mm_success),code=&pl_memory_manager_error           @C2
  mvc   pwa_buffer_head_len,pwa_buffer_size                         @C2
  mm_obtain_storage id=mm,            | obtain the storage          @C2+
               size=pwa_buffer_size,  |                             @C2+
               address=pwa_buffer_head  buffer for header           @C2
  errexit not,(%mm_success),code=&pl_memory_manager_error           @C2
  mvc   pwa_buffer_foot_len,pwa_buffer_size                         @C2
  mm_obtain_storage id=mm,            | obtain the storage          @C2+
               size=pwa_buffer_size,  |                             @C2+
               address=pwa_buffer_foot  buffer for footer           @C2
  errexit not,(%mm_success),code=&pl_memory_manager_error           @C2
* *-------------------------------------------------------------------*
* * Determine if the FOLD option was specified.
* *-------------------------------------------------------------------*
  lh    r3,pwa_number_of_parms        |
  if    (ch,r3,ge,=y(pl_start_options_#))
   l     r1,pl_start_options          |
   if    (tbit,0(r1),x'80')           |
    sbit  pwaopfld                    |
   endif                              |
  endif                               |
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: terminate
*
*---------------------------------------------------------------------*
 block name=terminate,type=subroutine |
*   *-----------------------------------------------------------------*
*   * Print footers on the current page if necessary.
*   *-----------------------------------------------------------------*
    if    (tbit,pwaf1hdr)             | If header exists on this page
     callsub print_footers            |  Go put footers on it.
    endif                             |
*  *------------------------------------------------------------------*
*  * Release the allocated buffer storage
*  *------------------------------------------------------------------*
    mm_release_storage id=mm,         |                             @C2+
               size=pwa_buffer_size,  |                             @C2+
               address=pwa_buffer_data                              @C2
    errexit not,(%mm_success),code=&pl_memory_manager_error         @C2
    mm_release_storage id=mm,         |                             @C2+
               size=pwa_buffer_size,  |                             @C2+
               address=pwa_buffer_head                              @C2
    errexit not,(%mm_success),code=&pl_memory_manager_error         @C2
    mm_release_storage id=mm,         |                             @C2+
               size=pwa_buffer_size,  |                             @C2+
               address=pwa_buffer_foot                              @C2
    errexit not,(%mm_success),code=&pl_memory_manager_error         @C2
*   *-----------------------------------------------------------------*
*   * Terminate File Handler, Memory Manager and String Formatter.
*   *-----------------------------------------------------------------*
    FI_Terminate id=FI                | Release storage, shut down FI
    ES_Unload_Module  id=ES,spid=FI   | Get rid of FI's loadmodule
           space 1                    |
    MM_Terminate id=MM                | Release storage, shut down MM
    ES_Unload_Module  id=ES,spid=MM   | Get rid of MM's loadmodule
           space 1                    |
    ST_Terminate id=ST                | Shut down string formatter
    ES_Unload_Module  id=ES,spid=ST   | Get rid of ST's loadmodule
*   *-----------------------------------------------------------------*
*   * Indicate PWA should be freed.
*   *-----------------------------------------------------------------*
    smctrl freepwa=yes                |   Free the PWA on return.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: set_header
*
*---------------------------------------------------------------------*
 block name=set_header,type=subroutine
  lh    r3,pwa_number_of_parms        | Ensure right no. of parameters
  errexit    (ch,r3,lt,=y(pl_sethdr_min_#)),or,                        +
               (ch,r3,gt,=y(pl_sethdr_max_#)),                         +
               code=&pl_invalid_number_of_parms
  l     r3,pl_sethdr_linenbr          | Grab the line number
  callsub find_hfd,(pwa_header_anchor,(r3))  See if already exists
  if    (treg,r15,nz)                 | If no HFD for line number
   callsub create_hfd,(pwa_header_anchor,(r3))  Go make one
  endif                               |
  lr    r5,r1                         | HFD addr from either routine
  using hfd,r5                        |  is returned in R1.
  mvc   hfd_iball,=c'HEAD'            | Set eyecatcher.
  mvc   hfd_string,pl_sethdr_string   | Bind string and length
  mvc   hfd_strlen,pl_sethdr_stringlen     addresses.
  sbit  hfdf1hdr                      | Note HFD is for a header.
  drop  r5                            |
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: set_formatted_header
*
*---------------------------------------------------------------------*
 block name=set_formatted_header,type=subroutine
    lh    r3,pwa_number_of_parms      | Validate number of parameters
    errexit    (ch,r3,lt,=y(pl_setfmthdr_min_#)),or,                   +
               (ch,r3,gt,=y(pl_setfmthdr_max_#)),                      +
               code=&pl_invalid_number_of_parms
    if    (ch,r3,gt,=y(pl_setfmthdr_pagedisp_#))   If pagedisp present
     lr    r4,r3                      | Copy # of parms
     sh    r4,=y(pl_setfmthdr_pagedisp_#) Get # source parms
     l     r2,pl_setfmthdr_pagedisp   | Get pointer to pagedisp
     errexit   (c,r4,lt,0(r2)),       | Error if sourceparms < pagedisp*
               code=&pl_invalid_pagedisp
    elseif (eq)                       | Else if only pagedisp present
     l     r2,pl_setfmthdr_pagedisp   |  It better be zero
     l32   r2,0(r2)                   |
     errexit (nz),code=&pl_invalid_pagedisp
     xr    r4,r4                      | OK so far: clear # sourceparms.
    else                              | Else no pagedisp,
     xr    r4,r4                      |  so clear it out.
    endif                             |
    st    r4,pwa_sourceparm_count     | Save
    l     r2,pl_setfmthdr_linenbr     | Point to linenumber
    callsub   find_hfd,(pwa_header_anchor,(r2))  Try to find its HFD
    if    (treg,r15,nz)               | If no HFD exists yet, make one
     callsub  create_hfd,(pwa_header_anchor,(r2),pwa_sourceparm_count)
    else                              | Otherwise (line# has an HFD)
*    *----------------------------------------------------------------*
*    * We found an HFD, but it may not be large enough to hold our
*    * source string.  For that matter, it may be too large.  So, if
*    * it's not the same size, we nuke it and make a new one.
*    *----------------------------------------------------------------*
     if    (ch,r4,ne,hfd_#parms-hfd(r1)) If it isn't the right size
      callsub destroy_hfd,(pwa_header_anchor,(r2))  Make a new one
      callsub create_hfd,(pwa_header_anchor,(r2),pwa_sourceparm_count)
     endif                            |
    endif                             |
    lr    r5,r1                       | HFD address in R1 regardless
    using hfd,r5                      |
    mvc   hfd_iball,=c'HEAD'          | Set eyecatcher.
    mvc   hfd_string,pl_setfmthdr_fmtstring   Bind string and length
    mvc   hfd_strlen,pl_setfmthdr_fmtstring_len    addresses.
    sbit  (hfdf1hdr,hfdf1fmt)         | Note HFD is for a header.
    if    (treg,r4,nz)                | If source parms present:
     lr    r1,r4                      | Get # source parms
     sll   r1,2                       | Multiply by 4, then subtract 1
     bctr  r1,0                       | Use it to move sources to HFD.
     exi   r1,(mvc,hfd_sourcelist(0),pl_setfmthdr_sourcelist)
    endif                             |
    lh    r3,pwa_number_of_parms      |
    if    (ch,r3,ge,=y(pl_setfmthdr_pagedisp_#))   If pagedisp present
     l     r2,pl_setfmthdr_pagedisp   | Get pagedisp address
     l32   r2,0(r2)                   | Get pagedisp value
     if    (nz)                       | If present
      bctr  r2,0                      |  Subtract 1 to displace from 0
      sll   r2,2                      |  Multiply by 4
      la    r2,hfd_sourcelist(r2)     |  Displace into HFD sourcelist
      mvc   hfd_page#,0(r2)           |  Copy n'th sourceparm to page#
      sbit  hfdf1pg#                  |   and note that it's present.
     endif                            |
    endif                             |
    drop  r5                          |
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: reset_header
*
*---------------------------------------------------------------------*
 block name=reset_header,type=subroutine
  lh    r3,pwa_number_of_parms        | Validate number of parameters.
  errexit    (ch,r3,lt,=y(pl_resethdr_min_#)),or,                      *
               (ch,r3,gt,=y(pl_resethdr_max_#)),                       *
               code=&pl_invalid_number_of_parms
  l     r4,pl_resethdr_linenbr        | Get line# to reset
  callsub destroy_hfd,(pwa_header_anchor,(r4))  Nuke that HFD(s)
  errexit    (treg,r15,nz),           | Report error if not found      *
               code=&pl_header_not_found
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: set_footer
*
*---------------------------------------------------------------------*
 block name=set_footer,type=subroutine
  lh    r3,pwa_number_of_parms        | Validate number of parameters.
  errexit    (ch,r3,lt,=y(pl_setftr_min_#)),or,                        +
               (ch,r3,gt,=y(pl_setftr_max_#)),                         +
               code=&pl_invalid_number_of_parms
  l     r3,pl_setftr_linenbr          | Grab the line number
  callsub find_hfd,(pwa_footer_anchor,(r3))  See if already exists
  if    (treg,r15,nz)                 | If HFD not found for line#
   callsub create_hfd,(pwa_footer_anchor,(r3))  Create a new one
  endif                               |
  lr    r5,r1                         | HFD addr from either routine
  using hfd,r5                        |  is returned in R1.
  mvc   hfd_iball,=c'FOOT'            | Set eyecatcher.
  mvc   hfd_string,pl_setftr_string   Bind string and length
  mvc   hfd_strlen,pl_setftr_stringlen     addresses.
  drop  r5                            |
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: set_formatted_footer
*
*---------------------------------------------------------------------*
 block name=set_formatted_footer,type=subroutine
    lh    r3,pwa_number_of_parms      | Validate number of parameters.
    errexit    (ch,r3,lt,=y(pl_setfmtftr_min_#)),or,                   +
               (ch,r3,gt,=y(pl_setfmtftr_max_#)),                      +
               code=&pl_invalid_number_of_parms
    if    (ch,r3,gt,=y(pl_setfmtftr_pagedisp_#))   If pagedisp present
     lr    r4,r3                      | Copy # of parms
     sh    r4,=y(pl_setfmtftr_pagedisp_#) Get # source parms
     l     r2,pl_setfmtftr_pagedisp   | Get pointer to pagedisp
     errexit   (c,r4,lt,0(r2)),       | Error if sourceparms < pagedisp*
               code=&pl_invalid_pagedisp
    elseif (eq)                       | Else if only pagedisp present
     l     r2,pl_setfmtftr_pagedisp   |  It better be zero
     l32   r2,0(r2)                   |
     errexit (nz),code=&pl_invalid_pagedisp
     xr    r4,r4                      | OK so far: clear # sourceparms.
    else                              | Else no pagedisp,
     xr    r4,r4                      |  so clear it out.
    endif                             |
    st    r4,pwa_sourceparm_count     | Save
    l     r2,pl_setfmtftr_linenbr     | Point to linenumber
    callsub   find_hfd,(pwa_footer_anchor,(r2))
    if    (treg,r15,nz)               |
     callsub  create_hfd,(pwa_footer_anchor,(r2),pwa_sourceparm_count)
    else                              |
*    *----------------------------------------------------------------*
*    * We found an HFD, but it may not be large enough to hold our
*    * source string.  For that matter, it may be too large.  So, if
*    * it's not the same size, we nuke it and make a new one.
*    *----------------------------------------------------------------*
     if    (ch,r4,ne,hfd_#parms-hfd(r1)) If it isn't the right size
      callsub destroy_hfd,(pwa_footer_anchor,(r2))  Make a new one.
      callsub create_hfd,(pwa_footer_anchor,(r2),pwa_sourceparm_count)
     endif                            |
    endif                             |
    lr    r5,r1                       |
    using hfd,r5                      |
    mvc   hfd_iball,=c'FOOT'          | Set eyecatcher.
    mvc   hfd_string,pl_setfmtftr_fmtstring   Bind string and length
    mvc   hfd_strlen,pl_setfmtftr_fmtstring_len    addresses.
    sbit  hfdf1fmt                    | Note HFD formatted, not a hdr.
    if    (treg,r4,nz)                |
     lr    r1,r4                      | Get # source parms
     sll   r1,2                       | Multiply by 4, then subtract 1
     bctr  r1,0                       | Use it to move sources to HFD.
     exi   r1,(mvc,hfd_sourcelist(0),pl_setfmtftr_sourcelist)
    endif                             |
    lh    r3,pwa_number_of_parms      |
    if    (ch,r3,ge,=y(pl_setfmtftr_pagedisp_#))   If pagedisp present
     l     r2,pl_setfmtftr_pagedisp   | Get pagedisp address
     l32   r2,0(r2)                   | Get pagedisp value
     if    (nz)                       | If present
      bctr  r2,0                      |  Subtract 1 to displace from 0
      sll   r2,2                      |  Multiply by 4
      la    r2,hfd_sourcelist(r2)     |  Displace into HFD sourcelist
      mvc   hfd_page#,0(r2)           |  Copy n'th sourceparm to page#
      sbit  hfdf1pg#                  |   and note that it's present.
     endif                            |
    endif                             |
    drop  r5                          |
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: reset_footer
*
*---------------------------------------------------------------------*
 block name=reset_footer,type=subroutine
  lh    r3,pwa_number_of_parms        |   Load number of parameters.
  errexit    (ch,r3,lt,=y(pl_resetftr_min_#)),or,                      *
               (ch,r3,gt,=y(pl_resetftr_max_#)),                       *
               code=&pl_invalid_number_of_parms
  l     r4,pl_resetftr_linenbr        | Get line# to reset
  callsub destroy_hfd,(pwa_footer_anchor,(r4))  Nuke that HFD(s)
  errexit    (treg,r15,nz),           | Report error if not found      *
               code=&pl_footer_not_found
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: reserve_footer
*
*---------------------------------------------------------------------*
 block name=reserve_footer,type=subroutine
  lh    r3,pwa_number_of_parms        | Validate number of parameters.
  errexit    (ch,r3,lt,=y(pl_rsvftr_min_#)),or,                        *
               (ch,r3,gt,=y(pl_rsvftr_max_#)),                         *
               code=&pl_invalid_number_of_parms
  l     r2,pl_rsvftr_lines            | Point to # lines to reserve
  mvc   pwa_footer_size,0(r2)         | Copy value to PWA for later.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: page_break
*
*---------------------------------------------------------------------*
 block name=page_break,type=subroutine
  lh    r3,pwa_number_of_parms        |   Load number of parameters.
  errexit    (ch,r3,lt,=y(pl_pagebreak_min_#)),or,                     *
               (ch,r3,gt,=y(pl_pagebreak_max_#)),                      *
               code=&pl_invalid_number_of_parms
       space 1                        |
  if    (tbit,pwaf1hdr)               | If there is a header on page
   callsub print_footers              |  Print the footers
  endif                               |
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: print
*
*---------------------------------------------------------------------*
 block name=print,type=subroutine
  lh    r3,pwa_number_of_parms        | Load number of parameters.
  errexit    (ch,r3,lt,=y(pl_print_min_#)),or,    Exit if wrong no.    *
               (ch,r3,gt,=y(pl_print_max_#)),        of parms.         *
               code=&pl_invalid_number_of_parms
  callsub clear_buffer,(*pwa_buffer_data,pwa_buffer_data_len)       @C2
  l     r2,pl_print_stringlen         | r2 -> address of the length @C2
  xr    r1,r1                         | clear a reg for icm         @cx
  l     r15,pwa_size_mask             | get icm mask for sizelength @cx
  exi   r15,(icm,r1,0,0(r2))          | get the length -> r1        @cx
*>l     r2,0(,r2)                     | r2 := length                @Cx
  st    r1,pwa_buffer_data_len        | Save line length.           @Cx
  callsub copy_buffer,(*pwa_buffer_data,*pl_print_string,           @C2+
               pwa_buffer_data_len)
  if    (tbit,pwaf1hdr,off)           | If page needs a header
   callsub print_headers              |  Give it one.
  endif                               |
  if    (tbit,pwaopfld)               | If folding to uppercase     @C2
   callsub upcase_buffer,(*pwa_buffer_data,pwa_buffer_data_len)     @C2
  endif                               |                             @C2
  callsub  writeline,(*pwa_buffer_data,pwa_buffer_data_len,         @C2+
               psd_print_headers)     |                             @C2
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: print_formatted
*
*---------------------------------------------------------------------*
 block name=print_formatted,type=subroutine
  lh    r3,pwa_number_of_parms        |   Load number of parameters.
  errexit    (ch,r3,lt,=y(pl_printfmt_min_#)),or,   Exit if wrong      *
               (ch,r3,gt,=y(pl_printfmt_max_#)),       no. of parms.   *
               code=&pl_invalid_number_of_parms
  callsub clear_buffer,(*pwa_buffer_data,pwa_buffer_data_len)       @C2
* *-------------------------------------------------------------------*
* *  Build parameter list for string formatter, then call it.
* *-------------------------------------------------------------------*
  l     r2,pl_printfmt_fmtstring      | Point to control string
  l     r3,pl_printfmt_fmtstring_len Point to ctl string's length
  l     r1,pwa_buffer_size            | Point to full buff format
  l     r5,pwa_size_mask              | Get the SizeLength ICM mask
  exi   r5,(stcm,r1,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT
  l     r1,pwa_buffer_data_len
  exi   r5,(stcm,r1,0,&w.datalen_adj) | Save adj. for ST_FORMAT
  if    (ch,r3,gt,=y(pl_printfmt_max_#))  If sourcelist provided.
    la    r4,pl_printfmt_sourcelist     |     r4-> sourceparmlist
    plist (0(r2),0(r3),*pwa_buffer_data,&w.datalen_adj,(r4))
  else
    plist (0(r2),0(r3),*pwa_buffer_data,&w.datalen_adj)
  endif
  callsub format                      | Format it.
  slr   r1,r1                         | Clear before ICM instr.
  exi   r5,(icm,r1,0,&w.datalen_adj)  | Load adj. from ST_FORMAT
  st    r1,pwa_buffer_data_len        | Save fullword length.
  if    (tbit,pwaf1sft)               | If formatter truncated it
   sbit  pwatflin                     |
  endif                               |
  if    (tbit,pwaf1hdr,off)           | If page needs a header
   callsub print_headers              |  Give it one.
  endif                               |
  if    (tbit,pwaopfld)               | If folding to uppercase     @C2
   callsub upcase_buffer,(*pwa_buffer_data,pwa_buffer_data_len)     @C2
  endif                               |                             @C2
  callsub  writeline,(*pwa_buffer_data,pwa_buffer_data_len,         @C2+
               psd_print_headers)     |                             @C2
 endblk                               |
               swa
&w.datalen_adj ds f
               endswa
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: query_lines_left
*
*---------------------------------------------------------------------*
 block name=query_lines_left,type=subroutine
  lh    r3,pwa_number_of_parms        |   Load number of parameters.
  errexit    (ch,r3,lt,=y(pl_qlines_min_#)),or,     Exit if wrong      *
               (ch,r3,gt,=y(pl_qlines_max_#)),         no. of parms.   *
               code=&pl_invalid_number_of_parms
  l     r7,pl_qlines_lines            | Get LINES parameter
  la    r7,0(r7)                      | Strip off the VL bit
  errexit (treg,r7,z),                | If address is zero, required   *
               code=&pl_missing_parameter  parameter is missing.
  if    (clc,pwa_line_count,eq,=f'0'),or, If at bottom of page or      *
               (clc,pwa_line_count,eq,psd_force_eject)   forcing eject
   callsub print_headers              |  Force headers out.
  endif                               |
  l     r1,pwa_pagesize               | Get current pagesize
  s     r1,pwa_footer_size            | Minus footer size (if any)
  s     r1,pwa_line_count             | Minus current line counter
  st    r1,0(r7)                      | Return value to caller.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: get_info
*
*---------------------------------------------------------------------*
 block name=get_info,type=subroutine
    lh     r6,pwa_number_of_parms     |   r6 := total #parms passed in.
    s      r6,=f'2'                   |   subtract token, function-code
    la     r7,pl_gi_function          |   r7 -> 1st info subcode parm.
    using  pl_gi_function,r7          |   Address get_info parms.
    loop   while,(treg,r6,p)          |   Loop while parms remain.
     l       r2,pl_gi_function        |    R2 -> information sub-code.
     l       r1,0(,r2)                |    R1 := information sub-code.
     caseblk reg=r1,wreg=r1,mult=1    |    Case on info sub-code:
     case &pl_gi_lrecl                |    *--------------> LRECL
      if (c,r6,lt,=f'2')              |     If not enough parameters.
        errexit code=&pl_missing_parameter   Complain now.
      endif                           |     EndIf.
      s       r6,=f'2'                |     We'll use 2 parms.
      l       r2,pl_gi_area           |     r2 -> caller area.
      fi_get_info id=fi,lrecl=0(r2)         Return LRECL value.
      st      r15,pwa_fi_last_rc      |     Save return code.
      errexit (not,(%fi_success)),code=&pl_file_handler_error
      la      r7,2*4(,r7)             |     Point r7 past parms used.
     case &pl_gi_recfm                |    *--------------> RECFM.
      if (c,r6,lt,=f'2')              |     If not enough parameters.
        errexit code=&pl_missing_parameter   Complain now.
      endif                           |     EndIf.
      s       r6,=f'2'                |     We'll use 2 parms.
      l       r2,pl_gi_area           |     r2 -> caller area.
      fi_get_info id=fi,recfm=0(r2)         Return recfm value.
      st      r15,pwa_fi_last_rc      |     Save return code.
      errexit (not,(%fi_success)),code=&pl_file_handler_error
      la      r7,2*4(,r7)             |     Point r7 past parms used.
     case &pl_gi_fimsg                |    *-------------------> FIMSG
      if (c,r6,lt,=f'4')              |     If not enough parameters.
        errexit code=&pl_missing_parameter   Complain now.
      endif                           |     EndIf.
      s  r6,=f'4'                     |     We'll use 4 parms.
      lm      r2,r4,pl_gi_area        |     r2/3/4 -> area/size/retlen
      fi_get_info id=fi,msg=(0(r2),0(r3)),msglen=0(r4)
      st      r15,pwa_fi_last_rc      |     Save return code.
      errexit (not,(%fi_success)),code=&pl_file_handler_error
      la      r7,4*4(,r7)             |     Point r7 past parms used.
     case &pl_gi_firc                 |    *-------------------> FIRC
      if (c,r6,lt,=f'2')              |     If not enough parameters.
        errexit code=&pl_missing_parameter   Complain now.
      endif                           |     EndIf.
      s     r6,=f'2'                  |     We'll use 2 parms.
      l     r2,pl_gi_area             |     Return last RC
      mvc   0(4,r2),pwa_fi_last_rc    |     to caller.
      la    r7,2*4(,r7)               |     Point r7 past parms used.
     case other                       |    *-------------------> *ERROR
      errexit code=&pl_invalid_gi_subcode
     endcase                          |    EndCase
    endloop while                     |   EndLoop.
    drop    r7                        |   Drop info subcode parms.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: get_reference
*
*---------------------------------------------------------------------*
 block name=get_reference,type=subroutine
  lh    r3,pwa_number_of_parms        |   Load number of parameters.
  errexit    (ch,r3,lt,=y(pl_qlines_min_#)),or,     Exit if wrong      *
               (ch,r3,gt,=y(pl_qlines_max_#)),         no. of parms.   *
               code=&pl_invalid_number_of_parms
  l     r7,pl_gr_reference            | Get REFERENCE parameter.
  la    r7,0(r7)                      | Strip off the VL bit
  errexit (treg,r7,z),                | If address is zero, required   *
               code=&pl_missing_parameter  parameter is missing.
  fill   pwa_pl_reference,x'40'       | Fill with blanks.
  fi_get_reference id=fi,             |  Get reference string.         +
               reference=pwa_pl_reference
  errexit (not,(%fi_success)),code=&pl_file_handler_error
  mvc   0(L'pwa_pl_reference,r7),pwa_pl_reference
*                                     |   to caller.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Format
*  Purpose:    Call the String Formatter to format the data provided
*              by the caller.  Parameters are:
*                +0 -- Address of format control string
*                +4 -- Address of format control string length
*                +8 -- Address of target string
*               +12 -- Address of target string size
*               +16 -- Address of beginning of source parm list
*  Calls:      String Formatter (external, service processor)
*
*---------------------------------------------------------------------*
 block name=format,type=subroutine    |
  lr    r6,r1                         | Save incoming parmlist address
  lm    r2,r5,0(r1)                   | Grab caller's parms
  rbit  pwaf1sft                      | Clear 'formatter truncated' flg
  plist       (pwa_st_token,          | 1: String Formatter's token    *
               &st_format,            | 2: Function code               *
               0(r4),                 | 3: Target area                 *
               pwa_maxlinesize_adj,   | 4: Adjusted MaxLineSize        *
               pwa_result_length,     | 5: Returned result length      *
               0(r2),                 | 6: Control string              *
               0(r3)),                | 7: Control string length       *
               pl=(pwa_st_format_pl,57),   Build it here,              *
               novl                   | and don't flip no x'80' bits.
  lr    r7,r1                         | Save PLIST's parmlist pointer
  la    r1,28(r1)                     | Point to VL part of parmlist
  if    (tbit,12(r6),x'80',off)       | If targetlen wasn't last parm
   l     r15,16(,r6)                  |
   la    r0,pwa_st_format_ple         |  Point to stg past end of pl.
   st    r0,&w.pl_end                 |    Save for limit-check.
   loop  until                        | Loop thru list til 80 bit found
    errexit (c,r1,ge,&w.pl_end),code=&pl_invalid_number_of_parms
    l     r14,0(r15)                  |  Get a parm
    la    r14,0(r14)                  |  Make sure the 80 bit is off
    st    r14,0(r1)                   |  Save into ST_FORMAT parmlist.
    leave loop=*,(tbit,0(r15),x'80')  |  Quit if we moved the last one
    la    r1,4(r1)                    |  Point to next dest and
    la    r15,4(r15)                  |   next sourceparm
   endloop until,leave                |    and go move them.
   sbit  0(r1),x'80'                  |  Set VL bit at end of VL plist
  else                                | Otherwise (no substitutions)
   sbit  24(r7),x'80'                 |  Set VL at end of fixed plist.
  endif                               |
  callx pwa_st_epa,pl=(pwa_st_format_pl) Call ST_FORMAT w/custom parms.
  if    (treg,r15,nz)                 | If formatter found a problem
   if    (ch,r15,eq,=y(&st_truncated))   Was it truncation?
    sbit  pwaf1sft                    |   Note that it got whacked
   else                               |  Otherwise ...
    errexit code=&pl_string_handler_error              Go choke.
   endif                              |
  endif                               |
  l     r15,pwa_size_mask             | Get the SizeLength ICM mask
  exi   r15,(icm,r1,0,pwa_result_length)  Get the length
  l     r15,12(,r6)                   | Return length as
  st    r1,0(,r15)                    | a parameter.
 endblk                               |
          swa
&w.pl_end ds   a
          endswa
       eject                          |
*---------------------------------------------------------------------*
*
*  Subroutine: Count_Print_Lines
*  Purpose:    Look at carriage control, and decide how many lines
*              are currently on the physical page.  If a page break
*              is needed, r15 will be nonzero upon return.
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- Address of data line to be examined.
*  Returncode: 0 -- Line counts updated.
*              4 -- Page break needed due to page overflow.
*              8 -- Page break forced due to carriage control of C'1'.
*  Calls:      None
*
*---------------------------------------------------------------------*
 block name=Count_Print_Lines,type=subroutine
  l     r2,0(r1)                      |
  la    r1,1                          | Assume single space.
  if    (cli,0(r2),eq,c'0')           | If ASA control '0'
   la    r1,2                         |  Double-space.
  elseif (cli,0(r2),eq,c'-')          | If ASA control = '-'
   la    r1,3                         |  Triple-space.
  elseif (cli,0(r2),eq,c'+')          | If ASA control = '+'
   xr    r1,r1                        |  Overprint.
  elseif (cli,0(r2),eq,c'1')          | If ASA control = '1'
   st    r1,pwa_line_count            | Save F'1' in R1 as linecount
   la    r15,8                        |  Indicate page eject needed
   leave block=*                      |  (page_break sets line count)
  endif                               |
  a    r1,pwa_line_count              | Add existing line count
  l    r3,pwa_footer_size             | See if we blew out footer area
  ar   r3,r1                          |
  if   (c,r3,gt,pwa_pagesize)         | Did we fall off the edge?
   la    r15,4                        |  Need to 'force' an eject.
  else                                | Otherwise (everything looks OK)
   st    r1,pwa_line_count            |  Save updated line count
   xr    r15,r15                      |   and end RC zero.
  endif                               |
 endblk rc=(r15)                      |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Print_Footers
*  Purpose:    Print any footers defined by the caller.
*  Calls:      Count_Print_Lines
*              Format
*              Update_Page_Counts
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=print_footers,type=subroutine
  leave block=*,(clc,pwa_line_count,eq,psd_force_eject)
* *-------------------------------------------------------------------*
* *  See if we need to skip down to where the footers go.
* *-------------------------------------------------------------------*
  l32   r15,pwa_footer_size           |
* leave block=*,(z)                   |
  l     r1,pwa_pagesize               | Get the page size
  sr    r1,r15                        | Get what line footers start on
  s     r1,pwa_line_count             | Get how many lines away we are
  if    (p),and,(treg,r15,nz)         | Do we need to skip any?
   lr    r5,r1                        |  Get divisor
   xr    r4,r4                        |  Clear 1st of reg pair
   d     r4,=f'3'                     |  Divide reg pair by 3
   if    (treg,r5,nz)                 |  If quotient nonzero
    loop  bct                         |  Triple-space that many times.
     fi_writeline id=fi,line=psd_skip_3_lines
     st     r15,pwa_fi_last_rc        |    Save return code.
     errexit not,(%fi_success),code=&pl_file_handler_error
    endloop bct,r5                    |
   endif                              |
   if    (treg,r4,nz)                 |  If remainder nonzero
    loop  bct                         |  Single-space that many times.
     fi_writeline id=fi,line=psd_skip_1_line
     st     r15,pwa_fi_last_rc        |   Save return code.
     errexit not,(%fi_success),code=&pl_file_handler_error
    endloop bct,r4                    |
   endif                              |
  endif                               |
* *-------------------------------------------------------------------*
* *  Now, print all footers that have HFD's.
* *-------------------------------------------------------------------*
  l     r7,pwa_footer_anchor          |
  loop  while,(treg,r7,nz),and,(clc,pwa_footer_size,ne,=f'0')
   callsub clear_buffer,(*pwa_buffer_foot,pwa_buffer_foot_len)      @C2
   using hfd,r7                       | establish hfd addressability
   l     r2,hfd_string                | r2 -> hfd string
   l     r3,hfd_strlen                | r3 -> hfd length
   if    (tbit,hfdf1fmt,off)          |
    xr    r14,r14                     | clear a reg for icm         @cx
    l     r15,pwa_size_mask           | get mask for icm            @cx
    exi   r15,(icm,r14,0,0(r3))       | get the value -> r14        @cx
*>  l     r14,0(,r3)                  | r14 := hfd length           @Cx
    st    r14,pwa_buffer_foot_len     | Save footer size.           @C2
    callsub copy_buffer,(*pwa_buffer_foot,*hfd_string,              @C2+
               pwa_buffer_foot_len)   |
    if    (tbit,pwaopfld)             | If folding to uppercase     @C1
     callsub upcase_buffer,(*pwa_buffer_foot,pwa_buffer_foot_len)   @C2
    endif                             |                             @C1
    callsub writeline,(*pwa_buffer_foot,pwa_buffer_foot_len,        @C2*
               psd_dont_print_headers)                              @C2
   else                               |
    l     r5,pwa_buffer_size          | Point to full buff format
    l     r15,pwa_size_mask           | Get the SizeLength ICM mask
    exi   r15,(stcm,r5,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT
    if    (clc,hfd_#parms,eq,=h'0')   |
     plist  ((r2),(r3),*pwa_buffer_foot,pwa_buffer_foot_len)        @C2
    else                              |
     plist  ((r2),(r3),*pwa_buffer_foot,pwa_buffer_foot_len,        @C2*
               hfd_sourcelist)        |                             @C2
    endif                             |
    callsub format                    |
    if    (tbit,pwaf1sft)             |
     sbit  pwatfftr                   |
    endif                             |
    if    (tbit,pwaopfld)             | If folding to uppercase     @C1
     callsub upcase_buffer,(*pwa_buffer_foot,pwa_buffer_foot_len)   @C2
    endif                             |                             @C1
    callsub writeline,(*pwa_buffer_foot,pwa_buffer_foot_len,        @C2*
               psd_dont_print_headers)                              @C2
   endif                              |
   l     r7,hfd_link                  |
  endloop while                       |
  drop  r7                            |
  rbit  pwaf1hdr                      |
  xc    pwa_line_count,pwa_line_count | Zero line count.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Update_Page_Counts
*  Purpose:    Run through header and footer definitions and increment
*              any page counters defined by the caller.
*  Calls:      None
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=update_page_counts,type=subroutine
  l     r1,pwa_page_count             | Update PL's counter first
  la    r1,1(r1)                      |
  st    r1,pwa_page_count             |
  l32   r7,pwa_header_anchor          | See what headers exist
  if    nz                            | If there are some
   using hfd,r7                       |  Set base
   loop  while,(treg,r7,nz)           |  Loop thru them:
    if    (tbit,hfdf1fmt)             |   If this one uses formatter
     l32   r1,hfd_page#               |    See if there's a page# addr
     if    nz                         |    If so:
      l     r15,0(r1)                 |     Increment it.
      la    r15,1(r15)                |
      st    r15,0(r1)                 |
     endif                            |
    endif                             |
    l     r7,hfd_link                 | Go thru all header HFD's.
   endloop while                      |
   drop  r7                           |
  endif                               |
  l32   r7,pwa_footer_anchor          | Same with footers ....
  if    nz                            | If some exist
   using hfd,r7                       |
   loop  while,(treg,r7,nz)           |  Loop through them
    if    (tbit,hfdf1fmt)             |   If this one's formatted
     l32   r1,hfd_page#               |    Get page# address
     if    nz                         |    If there is one
      l     r15,0(r1)                 |     Increment it.
      la    r15,1(r15)                |
      st    r15,0(r1)                 |
     endif                            |
    endif                             |
    l     r7,hfd_link                 |   Loop thru all footer HFD's.
   endloop while                      |
   drop  r7                           |
  endif                               |
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Print_Headers
*  Purpose:    Print any headers defined by the caller.
*  Calls:      Count_Print_Lines
*              Update_Page_Counts
*              Format
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=print_headers,type=subroutine
  callsub update_page_counts          | Bump all active page counters
  l     r7,pwa_header_anchor          | Get header HFD anchor
  if    (clc,pwa_line_count,eq,psd_force_eject)
   mvc   pwa_line_count,=f'1'         |
  endif                               |
  loop  while,(treg,r7,nz)            | Loop thru all defined HFD's:
   callsub clear_buffer,(*pwa_buffer_head,pwa_buffer_head_len)      @C2
   using hfd,r7                       |
   l     r2,hfd_string                |  Point to header string
   l     r3,hfd_strlen                |   and its length
   if    (tbit,hfdf1fmt,off)          |  If it's not formatted
    xr    r14,r14                     |   Clear a reg for icm       @cx
    l     r15,pwa_size_mask           |   Get mask for icm          @cx
    exi   r15,(icm,r14,0,0(r3))       |   Get the value -> r14      @cx
*>  l     r14,0(,r3)                  |   r14 := hfd length         @Cx
    st    r14,pwa_buffer_head_len     |   Save header size.         @C2
    callsub copy_buffer,(*pwa_buffer_head,*hfd_string,              @C2+
               pwa_buffer_head_len)   |                             @C2
    if    (tbit,pwaopfld)             | If folding to uppercase     @C1
     callsub upcase_buffer,(*pwa_buffer_head,pwa_buffer_head_len)   @C2
    endif                             |                             @C1
    callsub writeline,(*pwa_buffer_head,pwa_buffer_head_len,        @C2*
               psd_dont_print_headers)                              @C2
   else                               | Otherwise (HFD for formatter)
    l     r5,pwa_buffer_size          | Point to full buff format
    l     r15,pwa_size_mask           | Get the SizeLength ICM mask
    exi   r15,(stcm,r5,0,pwa_maxlinesize_adj) Save adj. for ST_FORMAT
    if    (clc,hfd_#parms,eq,=h'0')   |  If no sourceparms
     plist ((r2),(r3),*pwa_buffer_head,   3 parms to "format"       @C2*
               pwa_buffer_head_len)   |                             @C2
    else                              |  Otherwise, send formatter the
     plist ((r2),(r3),*pwa_buffer_head,          sourcelist.        @C2*
               pwa_buffer_head_len,hfd_sourcelist)                  @C2
    endif                             |
    callsub format                    |  Format the stuff out
    if    (tbit,pwaf1sft)             |
     sbit  pwatfhdr                   |
    endif                             |
    if    (tbit,pwaopfld)             | If folding to uppercase     @C1
     callsub upcase_buffer,(*pwa_buffer_head,pwa_buffer_head_len)   @C2
    endif                             |                             @C1
    callsub writeline,(*pwa_buffer_head,pwa_buffer_head_len,        @C2*
               psd_dont_print_headers)                              @C2
   endif                              |  Endif (formatted HFD or not?)
   l     r7,hfd_link                  |  Point to next HFD
  endloop while                       | and do them all.
  drop  r7                            |
  sbit  pwaf1hdr                      | Note that header is on page.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Create_HFD
*  Purpose:    Acquire storage and initialize an HFD.
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- Address of HFD anchor
*                +4 -- Address of fullword line number for header.
*                +8 -- Number of string formatter sources (optional)
*  Returned:   Upon return, R1 will point to the new HFD.
*  Calls:      Memory Manager (external)
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=Create_HFD,type=subroutine
  lm    r4,r5,0(r1)                   |
  if    (tbit,8(r1),x'80')            | If there's a 3rd parm
   l     r6,8(r1)                     |  Get its address
   l     r6,0(r6)                     |  Get # source parms
  else                                | Otherwise
   xr    r6,r6                        |  Set it to zero.
  endif                               |
  lr    r2,r6                         | Get # source parms (if any)
  sll   r2,2                          | Multiply by 4 for fullwords
  la    r2,HFD_Base_Length(r2)        | Add length of base HFD
  st    r2,&s.length                  |
  MM_Obtain_Storage ID=MM,            | Get storage for it             *
               Size=&s.length,        |                                *
               Address=&s.hfdaddr     |
  errexit      (treg,r15,nz),         |                                *
               code=&pl_memory_manager_error
  l     r3,&s.hfdaddr                 | Base on new HFD
  using hfd,r3                        |
  fill  0(r3),x'00',length=((r2),long) Set it all to zeros
  st    r2,hfd_length                 | Set its length
  mvc   hfd_line#,0(r5)               | Copy in the line number
  sth   r6,hfd_#parms                 | Save # source parms
  l32   r7,0(r4)                      | Load anchor word
  if    z                             | If it's zero,
*  *------------------------------------------------------------------*
*  * Anchor word is zero: this is the first HFD on the chain.
*  *------------------------------------------------------------------*
   st    r3,0(r4)                     |  this is the first one.
  else                                | Otherwise, we gotta link it in:
   loop  until                        | Loop thru the HFD chain
*   *-----------------------------------------------------------------*
*   *   R3 points to the new HFD, and is based on it.
*   *   R7 points to the current HFD.
*   *   R8 points to the next HFD, and may contain zero.
*   *-----------------------------------------------------------------*
    l     r8,0(r7)                    | Get address of next HFD
    if    (clc,hfd_line#,lt,hfd_line#-hfd(r7))
*    *----------------------------------------------------------------*
*    * New HFD's line number is less than the 'prior' HFD's, implying
*    * that new HFD should be inserted ahead of 1st HFD on the chain.
*    *----------------------------------------------------------------*
     st    r7,0(r3)                   | Set old 1st HFD link in new HFD
     st    r3,0(r4)                   | Reset anchor -> new HFD
     leave loop=*                     | That's it.
    elseif (treg,r8,z)                | Elseif no 'next' HFD
*    *----------------------------------------------------------------*
*    * We ran the chain without finding a place for this HFD, and the
*    * first check covered the case of the new HFD's linenumber being
*    * less than that of the only HFD on the chain.  Therefore, the
*    * new HFD should go on the end of the chain.
*    *----------------------------------------------------------------*
     st    r3,0(r7)                   | Hang new HFD after last one
     leave loop=*                     |  and leave the loop.
    elseif     (clc,hfd_line#,lt,hfd_line#-hfd(r8)),and,  Else if be-  *
               (clc,hfd_line#,gt,hfd_line#-hfd(r7))       tween 2 HFDs
*    *----------------------------------------------------------------*
*    * New HFD's line number is between that of prior and current HFD.
*    * Insert the new HFD between them.
*    *----------------------------------------------------------------*
     st    r8,0(r3)                   |  Link new HFD to next one,
     st    r3,0(r7)                   |  link current HFD to new one,
     leave loop=*                     |   and get out.
    elseif (eq)                       | There's an error if they match:
*    *----------------------------------------------------------------*
*    * The HFD line number matches either the prior or current HFD's.
*    * This is an ERROR: we're outta here.  R3, R7, R8 point to the
*    * new, current and next HFDs respectively.
*    *----------------------------------------------------------------*
     errexit code=&pl_internal_error  | This is one of those that   @cz
    endif                             |   should never happen!!!
    lr    r7,r8                       |  Update prior HFD address
   endloop until,leave                | Loop until we're done.
  endif                               |
  lr    r1,r3                         | Set new HFD address
  strsa r1                            |  in caller's R1.
  drop  r3                            |
 endblk                               |
         space 1                      |
         swa   ,                      |
&s.hfdaddr  ds a                      |
&s.length   ds a                      |
         endswa ,                     |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Destroy_HFD
*  Purpose:    Track down an HFD, unlink it from the HFD chain it's on,
*              and release its storage.
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- Address of HFD anchor
*                +4 -- Address of fullword line number for header.
*                      If the line number provided is zero, ALL HFD's
*                      chained from the anchor will be deleted.
*  Returned:   R15 will be nonzero if the HFD wasn't found.
*  Calls:      Memory Manager (external)
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=Destroy_HFD,type=subroutine
  lm    r4,r5,0(r1)                   | Get parm addresses
  l     r3,0(r4)                      | Load HFD anchor: -> HFD or zero
  using hfd,r3                        |
  l     r6,0(r5)                      | Get line number for compares
  lr    r7,r4                         | Copy HFD anchor address
         space 1                      |
  loop  until                         |
*  *------------------------------------------------------------------*
*  *   R3 points to the 1st HFD, and is based on it.
*  *   R6 contains the line number to compare for, or zero.
*  *   R7 points to the current HFD.
*  *   R8 points to the next HFD, and may contain zero.
*  *------------------------------------------------------------------*
   l     r8,0(r7)                     | Get address of first | next HFD
   if    (treg,r8,z)                  | If we reached end of chain
    leave loop=*                      |  leave the loop
   elseif      (treg,r6,z),or,        | Else if deleting them all or   *
               (c,r6,eq,hfd_line#-hfd(r8)) we found the one we want:
*   *-----------------------------------------------------------------*
*   * We found the HFD we wanna delete.  Copy its link to the previous
*   * HFD's link (which will be the anchor word if this is the first
*   * HFD on the chain), then release the HFD's storage.
*   *-----------------------------------------------------------------*
    mvc   0(4,r7),0(r8)               |  Move this HFD's link to prev
    st    r8,&s.hfdaddr               |  Save address of stg to release
    MM_Release_Storage ID=MM,         |  Blow it away                  *
               Size=hfd_length-hfd(,r8),                               *
               Address=&s.hfdaddr     |
    leave loop=*,(treg,r6,nz)         | If only zapping one, get out.
   endif                              |
*  *------------------------------------------------------------------*
*  * If we are deleting one HFD, continue looping through the HFD chain
*  * until we nuke the one we're after.  If we're deleting all HFDs,
*  * each 'delete' will take the 1st one off the chain and update the
*  * anchor word, so we reload the anchor address into R7 instead of
*  * the next HFD address.
*  *------------------------------------------------------------------*
   if    (treg,r6,nz)                 | If doing a single HFD
    lr    r7,r8                       |  Copy next HFD addr to current
   else                               | Otherwise (we're doing 'em all)
    lr    r7,r4                       |  Point "next HFD" R7 to anchor.
   endif                              |
  endloop until,leave                 |
        space 1                       |
  if           (treg,r8,z),and,       | If we missed it and we weren't *
               (treg,r6,nz)           |  deleting them all
   la    r15,8                        |  Set 'not-found' returncode
  else                                | Otherwise
   xr    r15,r15                      |  Say we did it all OK.
  endif                               |
  drop  r3                            |
 endblk rc=(r15)                      |
        space 1                       |
        swa   ,                       |
&s.hfdaddr  ds f                      |
        endswa ,                      |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Find_HFD
*  Purpose:    Find an HFD and return its address to the caller via R1.
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- Address of HFD anchor
*                +4 -- Address of fullword line number for header.
*  Returned:   R15 will be nonzero if the HFD wasn't found.
*  Calls:      None
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=Find_HFD,type=subroutine  |
  lm    r4,r5,0(r1)                   | Get parm addresses
  l     r6,0(r5)                      | Get line number
  l     r3,0(r4)                      | Load HFD anchor: -> HFD or zero
  using hfd,r3                        |
  loop  while,(treg,r3,nz)            | Look for matching line#'s
   leave loop=*,(c,r6,eq,hfd_line#)   |  Hop out if we got one,
   l     r3,hfd_link                  | else look at the next one.
  endloop while                       |
  if    (treg,r3,nz)                  | If we got a hit
   lr    r1,r3                        |  Give address to caller via R1
   strsa r1                           |
   xr    r15,r15                      |  and set RC zero
  else                                | Otherwise,
   la    r15,8                        |  set RC 8.
  endif                               |
  drop  r3                            |
 endblk rc=(r15)                      |
 eject                                |
*---------------------------------------------------------------------*
*
*  Errexit:    Unnamed
*  Purpose:    Save debugging information and exit with the return
*              code pointed to by r14 at entry to this exit.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block type=errexit                   |
* *-------------------------------------------------------------------*
* * Save module/offset, registers, return-code.
* *-------------------------------------------------------------------*
  st    r15,pwa_reason                | Save possible return-code.
  stm   r0,r15,gdiregs                | Save registers at time of error
  sm_lal r0,&srv_modname+4            | Point to module identification.
  st    r0,gdimodid                   | Save in general debug area.
  mvc   gdirc,0(r14)                  | Copy return code.
  sl    r14,=a(&srv_modname)          | Calculate offset at time of err
  sth   r14,gdioffst                  | Save in debug area.
  l     r2,pwaaesv                    | Point r2 to ESV.
  using esv,r2                        | Establish base for ESV.
  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)
* *-------------------------------------------------------------------*
* * Look at the error code.  Some errors imply that the DIV Server
* * has lost its cookies and should not attempt to do anything other
* * than shut-down (if it can even do that).
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Get return code.
  caseblk reg=r15,mult=1              | Case on return-code.
*   case x
*     callx esvesepa,(esvestkn,&es_save_debug_info,
*              &es_debug_id_hex,pwa_reason,4,"REASON",6)
    case other                        |  Don't bother w/other errors.
  endcase                             | EndCase.
  drop r2                             |
* *-------------------------------------------------------------------*
* * Set the return-code and exit.
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Set return code.
 endblk                               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: writeline
*  Purpose:    Splits the specified line according to the maximum
*              printable length so that message wrapping can occur.
*              (Created in response to incident V1499)
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- address of the data to print
*                +4 -- length of the data to print
*                +8 -- print header/footer flag
*
*---------------------------------------------------------------------*
 block name=writeline,type=subroutine                               @C2
  mvi   &w.f,x'00'                    | Clear local flag byte.
  lm    r2,r4,0(r1)                   |                             @C2
  st    r2,&w.pos_start               | save the address of the line@C2
  st    r2,&w.pos_start_mark          | keep starting address marker@C2
  l     r3,0(,r3)                     | r3 := length                @C2
  st    r3,&w.length                  | save line length            @C2
  lh    r4,0(,r4)                     | r5 := print header/footer   @C2
  if   (ch,r4,eq,psd_dont_print_headers)                            @C2
   sbit &w.f,&w.f_no_headers          |  don't print headers/footers@C2
  endif                               |                             @C2
  l     r1,&w.pos_start               | r1 := starting position     @C2
  al    r1,pwa_buffer_size            | r1 := end of print line buff@C2
  st    r1,&w.pos_end                 | save end position           @C2
  st    r1,&w.pos_current             | prime current position      @C2
  rbit  &w.f,&w.f_add_cc              | make sure add CC bit is off @C2
* *-------------------------------------------------------------------*
* *  bypass wrapping code if the line doesn't need wrapping         @C2
* *-------------------------------------------------------------------*
  if    (clc,&w.length,le,pwa_maxlinesize)  if len < max print len  @C2
   if    (tbit,&w.f,&w.f_no_headers,off)     want to print headers? @C2
    callsub Count_Print_Lines,(*&w.pos_start)                       @C2
    if    (treg,r15,nz)               |      if needed?             @C2
     if    (ch,r15,eq,=h'4')          | If page overflow            @C2
      callsub print_footers           |  Do controlled page-eject   @C2
     endif                            | Endif                       @C2
     if    (tbit,pwaf1hdr,off)        | If page now needs a header  @C2
      callsub print_headers           |  Give it one.               @C2
     endif                            | Endif                       @C2
     callsub Count_Print_Lines,(*&w.pos_start) Better count'em again@C2
    endif                             |                             @C2
   else                               |                             @C2
    callsub Count_Print_Lines,(*&w.pos_start)                       @C2
   endif                              |                             @C2
   fi_writeline id=fi,                | write the line              @C2+
               line=(*&w.pos_start,&w.length)                       @C2
   st     r15,pwa_fi_last_rc          | Save return code.           @C2
   errexit not,(%fi_success),code=&pl_file_handler_error            @C2
   leave block=*                      | return to the caller        @C2
  endif                               |                             @C2
* *-------------------------------------------------------------------*
* *  Find the middle position of the string                         @C2
* *-------------------------------------------------------------------*
  sr   r8,r8                          | clear r8                    @C2
  l    r9,pwa_maxlinesize             | r9 := dividend              @C2
  d    r8,=f'2'                       | r9 := pwa_maxlinesize / 2   @C2
  st   r9,&w.middlemax                | save middle                 @C2
* *-------------------------------------------------------------------*
* *  loop through the string wrapping print lines that are too long @C2
* *-------------------------------------------------------------------*
  loop until                          | loop until completly wrapped@C2
*  *------------------------------------------------------------------*
*  *  Find the offset to the middle of the string                   @C2
*  *------------------------------------------------------------------*
   l    r1,&w.pos_start               | r1 -> pos_start             @C2
   al   r1,&w.middlemax               | r1 := pos_start + middlemax @C2
   st   r1,&w.pos_middle              | save the middle position    @C2
*  *------------------------------------------------------------------*
*  *  Add control characters if needed                              @C2
*  *------------------------------------------------------------------*
   if    (tbit,&w.f,&w.f_add_cc,on)   | if we need CC character     @C2
    l     r1,&w.pos_start             |  r1 -> start position       @C2
    bctr  r1,0                        |  r1 := position - 1 for CC  @C2
    st    r1,&w.pos_start             |  save adjusted start pos    @C2
    mvc   0(1,r1),=c' '               |  set CC at start position   @C2
    l     r1,&w.length                |  r1 := length remaining     @C2
    al    r1,=f'1'                    |  r1 := length + 1 for CC    @C2
    st    r1,&w.length                |  save the adjusted length   @C2
   endif                              | endif                       @C2
*  *------------------------------------------------------------------*
*  *  See if we need to wrap this line                              @C2
*  *------------------------------------------------------------------*
   if    (clc,&w.length,le,pwa_maxlinesize)  if len < max print len @C2
    mvc   &w.print_length,&w.length   |  set print length           @C2
    mvc   &w.length,=f'0'             |  set remaining length to 0  @C2
   else                               | else line needs to wrap     @C2
*   *-----------------------------------------------------------------*
*   *  Save the address of the current line print boundary          @C2
*   *-----------------------------------------------------------------*
    l     r1,&w.pos_start             |  r1 := starting position    @C2
    al    r1,pwa_maxlinesize          |  r1 -> start + max line len @C2
    st    r1,&w.pos_current           |  save current postion       @C2
    st    r1,&w.pos_line_end          |  save line end postion      @C2
*   *-----------------------------------------------------------------*
*   *  Loop over string until we find whitespace or hit start pos   @C2
*   *-----------------------------------------------------------------*
    loop until                        |  loop over string.          @C2
     l     r1,&w.pos_current          |   r1 := current position    @C2
     leave loop=*,(clc,0(1,r1),eq,=c' '), leave if curr char = space@C2+
               and,(cl,r1,gt,&w.pos_start), and not at start pos    @C2+
               or,(cl,r1,le,&w.pos_start)   or at start             @C2
     bctr  r1,0                       |   r1 := current position-1  @C2
     st    r1,&w.pos_current          |   save new current position @C2
    endloop until,leave               |  endloop.                   @C2
*   *-----------------------------------------------------------------*
*   *  Adjust current pointer back to line end if it is at start    @C2
*   *-----------------------------------------------------------------*
    if    (clc,&w.pos_current,lt,&w.pos_middle)                     @C2
     mvc   &w.pos_current,&w.pos_line_end                           @C2
    endif                             |                             @C2
*   *-----------------------------------------------------------------*
*   *  Calculate the print length (must be in range 2=<len<=max)    @C2
*   *-----------------------------------------------------------------*
    l     r1,&w.pos_current           |  r1 -> current position     @C2
    sl    r1,&w.pos_start             |  r1 := current - start      @C2
    st    r1,&w.print_length          |   save print length         @C2
    if   (clc,&w.print_length,le,=f'2')                             @C2
     mvc  &w.print_length,pwa_maxlinesize                           @C2
     mvc  &w.pos_current,&w.pos_line_end                            @C2
    endif                                                           @C2
*   *-----------------------------------------------------------------*
*   *  Calculate the remaining string length                        @C2
*   *-----------------------------------------------------------------*
    l     r1,&w.length                |  r1 := string length        @C2
    sl    r1,&w.print_length          |  r1 := str len - prt len    @C2
    st    r1,&w.length                |  save the new string length @C2
    sbit  &w.f,&w.f_add_cc            |  next line needs CC inserted@C2
   endif                              | endif                       @C2
*  *------------------------------------------------------------------*
*  *  Write the line and count the lines                            @C2
*  *------------------------------------------------------------------*
   if (tbit,&w.f,&w.f_no_headers,off) | Do we want to print headers @C2
    callsub Count_Print_Lines,(*&w.pos_start)                       @C2
    if    (treg,r15,nz)               |      if needed?             @C2
     if    (ch,r15,eq,=h'4')          | If page overflow            @C2
      callsub print_footers           |  Do controlled page-eject   @C2
     endif                            |                             @C2
     if    (tbit,pwaf1hdr,off)        | If page now needs a header  @C2
      callsub print_headers           |  Give it one.               @C2
     endif                            |                             @C2
     callsub Count_Print_Lines,(*&w.pos_start) Better count'em again@C2
    endif                             |                             @C2
   else                               |                             @C2
    callsub Count_Print_Lines,(*&w.pos_start)                       @C2
   endif                              |                             @C2
   errexit (clc,&w.pos_start,ge,&w.pos_end)                         @C2
   fi_writeline id=fi,                |                             @C2+
               line=(*&w.pos_start,&w.print_length)                 @C2
   st     r15,pwa_fi_last_rc          | Save return code.           @C2
   errexit not,(%fi_success),code=&pl_file_handler_error            @C2
*  *------------------------------------------------------------------*
*  *  Calculate the next starting address                           @C2
*  *------------------------------------------------------------------*
   mvc   &w.pos_start,&w.pos_current  | set next starting position  @C2
   leave loop=*,(clc,&w.pos_start,ge,&w.pos_end),or,            do  @C2+
               (clc,&w.pos_start,le,&w.pos_start_mark),or,    sanity@C2+
               (clc,&w.length,le,=f'0')                     checking@C2
*  *------------------------------------------------------------------*
*  *  remove leading whitespace characters from the continued line  @C2
*  *------------------------------------------------------------------*
   loop until                         | loop over string.           @C2
    l     r1,&w.pos_start             |  r1 := start position       @C2
    leave loop=*,(clc,0(1,r1),ne,=c' '), leave if curr char=space  @C2+
               or,(cl,r1,ge,&w.pos_end)   or we are at the end      @C2
    al    r1,=f'1'                    |  r1 := current position + 1 @C2
    st    r1,&w.pos_start             |  save new start position    @C2
    l     r1,&w.length                |  r1 := length remaining     @C2
    sl    r1,=f'1'                    |  r1 := length - 1           @C2
    st    r1,&w.length                |  save the adjusted length   @C2
   endloop until,leave                | endloop.                    @C2
  endloop until,leave                 |                             @C2
 endblk                               |                             @C2
         swa                          |                             @C2
&w.pos_start    ds    a               | address of start position   @C2
&w.pos_start_mark ds  a               | address of start position   @C2
&w.pos_current  ds    a               | address of current position @C2
&w.pos_middle   ds    a               | address of middle position  @C2
&w.pos_end      ds    a               | address of end position     @C2
&w.pos_line_end ds    a               | address of end position     @C2
&w.pos_last     ds    a               | address of last position    @C2
&w.print_length ds    f               | print length of the line    @C2
&w.length       ds    f               | remaining length to print   @C2
&w.middlemax    ds    f               | middle position             @C2
&w.f            ds    bl1             | writeline flags             @C2
&w.f_add_cc     equ   b'10000000'     | add CC character flag       @C2
&w.f_no_headers equ   b'01000000'     | don't print headers&footers @C2
         endswa                       |                             @C2
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: clear_buffer
*  Purpose:    clears large buffers with spaces
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- address of the buffer to clear
*                +4 -- length to clear
*
*---------------------------------------------------------------------*
 block name=clear_buffer,type=subroutine                            @C2
  l     r2,0(,r1)                     | r2 -> address of buffer     @C2
  l     r3,4(,r1)                     | r3 -> address of the length @C2
  l     r3,0(,r3)                     | r3 := length to clear       @C2
  loop until                          | loop                        @C2
   if (treg,r3,p)                     |  if length > 0              @C2
    if (c,r3,le,=f'256')              |   if length <= 256          @C2
     mvi   0(r2),x'40'                |    blank first character    @C2
     bctr  r3,0                       |    r3 := length - 1         @C2
     if (treg,r3,p)                   |    if length > 0            @C2
      bctr  r3,0                      |     r3 := length - 1 for EX @C2
      exi   r3,(mvc,1(*-*,r2),0(r2))  |     propogate fill character@C2
     endif                            |    endif                    @C2
     leave loop=*                     |    return to caller         @C2
    else                              |   else length > 256         @C2
     mvi   0(r2),x'40'                |    blank first character    @C2
     mvc   1(255,r2),0(r2)            |    propogate fill character @C2
     s     r3,=f'256'                 |    r3 := length - 256       @C2
     la    r2,256(,r2)                |    r2 := buffer addr + 256  @C2
    endif                             |   endif                     @C2
   else                               |  else length <= 0           @C2
    leave loop=*                      |   return to caller          @C2
   endif                              |  endif                      @C2
  endloop until,leave                 | endloop                     @C2
 endblk                               |                             @C2
 eject                                |                             @C2
*---------------------------------------------------------------------*
*
*  Subroutine: copy_buffer
*  Purpose:    copy data to a large data buffer
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- address of the destination buffer
*                +4 -- address of the source to copy from
*                +8 -- length of data to copy
*
*---------------------------------------------------------------------*
 block name=copy_buffer,type=subroutine                             @C2
  l     r2,0(,r1)                     | r2 -> address of buffer     @C2
  l     r3,4(,r1)                     | r3 -> address of source     @C2
  l     r4,8(,r1)                     | r4 -> address of the length @C2
  l     r4,0(,r4)                     | r4 := length to copy        @C2
  loop until                          | loop                        @C2
   if (treg,r4,p)                     |  if length > 0              @C2
    if (c,r4,le,=f'256')              |   if length <= 256          @C2
     bctr  r4,0                       |    r3 := length - 1 for EX  @C2
     exi   r4,(mvc,0(*-*,r2),0(r3))   |    copy data chunk          @C2
     leave loop=*                     |    return to caller         @C2
    else                              |   else length > 256         @C2
     mvc   0(256,r2),0(r3)            |    copy data chunk          @C2
     s     r4,=f'256'                 |    r3 := length - 256       @C2
     la    r2,256(,r2)                |    r2 := buffer addr + 256  @C2
     la    r3,256(,r3)                |    r3 := source addr + 256  @C2
    endif                             |   endif                     @C2
   else                               |  else length <= 0           @C2
    leave loop=*                      |   return to caller          @C2
   endif                              |  endif                      @C2
  endloop until,leave                 | endloop                     @C2
 endblk                               |                             @C2
 eject                                |                             @C2
*---------------------------------------------------------------------*
*
*  Subroutine: upcase_buffer
*  Purpose:    translate the data buffer to all uppercase characters
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- address of the buffer
*                +4 -- length to translate
*
*---------------------------------------------------------------------*
 block name=upcase_buffer,type=subroutine                           @C2
  l     r2,0(,r1)                     | r2 -> address of buffer     @C2
  l     r3,4(,r1)                     | r3 -> address of the length @C2
  l     r3,0(,r3)                     | r3 := length to clear       @C2
  loop until                          | loop                        @C2
   if (treg,r3,p)                     |  if length > 0              @C2
    if (c,r3,le,=f'256')              |   if length <= 256          @C2
     bctr  r3,0                       |    r3 := length - 1 for EX  @C2
     exi   r3,(tr,0(*-*,r2),psd_fold_table)  translate to uppercase @C2
     leave loop=*                     |    return to caller         @C2
    else                              |   else length > 256         @C2
     tr    0(256,r2),psd_fold_table   |    translate to uppercase   @C2
     s     r3,=f'256'                 |    r3 := length - 256       @C2
     la    r2,256(,r2)                |    r2 := buffer addr + 256  @C2
    endif                             |   endif                     @C2
   else                               |  else length <= 0           @C2
    leave loop=*                      |   return to caller          @C2
   endif                              |  endif                      @C2
  endloop until,leave                 | endloop                     @C2
 endblk                               |                             @C2
 eject                                |                             @C2
*---------------------------------------------------------------------*
 title "Program Static Data"          |
                psd                   |
eyecatcher      dc   cl8"PL_SP"       | Eyecatcher value for dumps.
psd_print_headers      dc   h'0'                                    @C2
psd_dont_print_headers dc   h'1'                                    @C2
psd_bit_mask   dc   b'0001',b'0011',b'0111',b'1111'
psd_force_eject dc  f'99999999'       |
psd_skip_3_lines  dc   c'-'
psd_skip_1_line   dc   c' '
          space 1
psd_fold_table   dc   256al1(*-psd_fold_table)
                 org  psd_fold_table+c"a"
                 dc   c'ABCDEFGHI'
                 org  psd_fold_table+c"j"
                 dc   c'JKLMNOPQR'
                 org  psd_fold_table+c"s"
                 dc   c'STUVWXYZ'
                 org  ,
          space 1
                ltorg ,               |
                endpsd                |
*
          title "Dsects"              |
          pl_parmlist ,
          es_esv ,                    |
          eject ,                     |
*---------------------------------------------------------------------*
*
*  DSECT:     Header/Footer Descriptor (HFD)
*
*  Purpose:   Describes headers and footers established by calls to
*             PL_Set_Header, PL_Set_Formatted_Header, PL_Set_Footer
*             and PL_Set_Formatted_Footer.
*
*  Service    . Create_HFD will allocate storage and partially initial-
*  Routines:    ize an HFD.
*             . Destroy_HFD will unlink an HFD and release its storage.
*             . Find_HFD will locate an HFD based on the line number
*               provided by PrintLine's caller.
*
*  Special    Fields marked by <1> are set by Create_HFD, based on
*  Notes:     parms provided by the caller.
*
*---------------------------------------------------------------------*
hfd       dsect ,                     | Header/Footer Descriptor DSECT
hfd_link    ds  a                 <1> | Fwd link to next HFD or zero.
*                                     | This must be the 1st field!
hfd_iball   ds  cl4                   | Eyecatcher "HEAD"/"FOOT"
hfd_length  ds  a                 <1> | Length of this HFD
hfd_line#   ds  f                 <1> | Line number for this HFD
hfd_string  ds  a                     | Addr of string or formatspec
hfd_strlen  ds  a                     | Addr of length of str/fmtspec
hfd_page#   ds  a                     | Address of page# if hfdf1pg# on
hfdf1     ds    c                     | Flags:
hfdf1hdr  equ   x'80'   |1... ....|   | . This HFD describes a header
hfdf1fmt  equ   x'40'   |.1.. ....|   | . HFD_String describes fmtspec
hfdf1pg#  equ   x'20'   |..1. ....|   | . This HFD has a page # assoc'd
*         equ   x'1f'   |...1 1111|   | . Reserved
            ds  c                     | Reserved
hfd_#parms  ds  h                 <1> | No. of parms for formatter
hfd_base_length equ   *-hfd           | Minimum HFD length
hfd_sourcelist  equ   *               | 0 to 50 substitution parms
          title "Program Work Area"   |
               PWA                    |
pwa_area       ds    0f               | Beginning of visible PWA stg.
pwa_visual     ds    cl8              | Character string 'PL_SP'.
pwa_pl_id      ds    a                | Pointer to program work area.
pwa_clear_start equ  *                | This area cleared by PL_START.
pwa_ddname     ds    cl8              | DDname.
pwa_ES_epa     ds    f                | Environment Support EPA.
pwa_ES_token   ds    f                | Environment Support PWA token.
pwa_MM_epa     ds    f                | Memory Manager EPA.
pwa_MM_token   ds    f                | Memory Manager PWA token.
pwa_ST_epa     ds    f                | String Formatter EPA.
pwa_ST_token   ds    f                | String Formatter PWA token.
pwa_FI_epa     ds    f                | File Handler EPA.
pwa_FI_token   ds    f                | File Handler PWA token.
pwa_FI_last_rc ds    f                | File Handler last return code.
pwa_pagesize   ds    f                |
pwa_maxlinesize ds   f                | Max. linesize from PL_START
pwa_maxlinesize_adj  ds  f            | Adjusted max. linesize. Length
*                                     |  is that spec'd by SizeLength.
pwa_sizelength ds    f                |
pwa_footer_size ds   f                | Footer space requested or zero
pwa_header_anchor ds f                | HFD anchor for headers
pwa_footer_anchor ds f                | HFD anchor for footers
pwa_line_count ds    f                | Current line count
pwa_page_count ds    f                | Current page count
pwa_reason     ds    f                |
pwa_size_mask  ds    f                | Mask to load lengths using ICM
pwa_clear_end  equ  *                 | End area cleared by PL_START.
pwa_clear_length   equ   pwa_clear_end-pwa_clear_start
pwa_ESV        ds    f                | Address of ESV.
pwa_number_of_parms ds h              | Number of parms.
pwaf1        ds    x                  | General flag byte:
pwaf1sft     equ   x'80'  |1... ....| | . String formatter truncated
pwaf1hdr     equ   x'40'  |.1.. ....| | . Header on this page
pwaf1wrap    equ   x'20'  |..1. ....| | . Line wrapping will occur  @C2
*            equ   x'1f'  |...1 1111| | . Reserved                  @C2
pwatf        ds    x                  | Truncation flag:
pwatflin     equ   x'80'  |1... ....| | . Print line truncated
pwatfhdr     equ   x'40'  |.1.. ....| | . Header line truncated
pwatfftr     equ   x'20'  |..1. ....| | . Footer line truncated
*            equ   x'1f'  |...1 1111| | . Reserved
pwaop        ds    x                  | OPTIONS flag:
pwaopfld     equ   x'80'  |1... ....| | . FOLD specified
*            equ   x'7f'  |.111 1111| | . Reserved
pwa_result_length   ds f              | Result length from ST_FORMAT.
*                                     |   Actual length is SizeLength.
pwa_sourceparm_count ds f             | Count of parms in sourcelist.
*                                     |   Used by set_fmt_hdr, _ftr.
pwa_st_format_pl  ds    57a           | Parms for string formatter.
pwa_st_format_ple equ   *             |   END-OF-PARMLIST-AREA.
               es_gdi dsect=no        | General debugging information.
pwa_print_len   ds    f               | Print size.
pwa_header_len  ds    f               | Footer size.
pwa_footer_len  ds    f               | Footer size.
pwa_buffer_size ds    f               | allocated buffer size
pwa_buffer_data ds    a               | buffer for data printing
pwa_buffer_data_len   ds f            | data print length
pwa_buffer_head ds    a               | buffer for header printing
pwa_buffer_head_len   ds f            | header print length
pwa_buffer_foot ds    a               | buffer for footer printing
pwa_buffer_foot_len   ds f            | footer print length
pwa_recfm       ds    cl8             | recfm of ddname
pwa_lrecl       ds    h               | lrecl of ddname
pwa_pl_reference ds   cl70            | Reference string for PL_START.
               org pwa_pl_reference
pwa_pl_ref_part1 ds    c'DDNAME '
pwa_pl_ref_part2 ds    cl8
pwa_pl_ref_part3 ds    cl55
               org   ,
               endpwa                 |
               end   ,                |
