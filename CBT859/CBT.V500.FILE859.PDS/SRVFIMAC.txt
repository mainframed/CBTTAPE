*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
 TITLE 'SRVFIMAC: File Handler Service Processor Symbols && Macros.'
*---------------------------------------------------------------------*
*
*  Copy File:  SRVFIMAC
*
*  Purpose:    File Handler service processor symbols and macros.
*
*  Description: See "Service Processors User's Guide and Reference".
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*---------------------------------------------------------------------*
*
***********************************************************************
***********************************************************************
**                                                                   **
**                     Symbol Definitions                            **
**                                                                   **
***********************************************************************
***********************************************************************
 GBLC &FI_OS_FILE_HANDLER
 GBLC &FI_XSUBID_HANDLER
 GBLC &FI_PDF_FILE_HANDLER
 GBLC &FI_SMS_FILE_HANDLER
 GBLA &FI_START,&FI_TERMINATE,&FI_READLINE,&FI_GET_INFO,&FI_GI_MSG
 GBLA &FI_WRITELINE,&FI_READLINE_LOCATE
 GBLA &FI_OPEN,&FI_CLOSE,&FI_DELETE
 GBLA &FI_GI_NAME,&FI_GI_LRECL,&FI_GI_RECFM,&FI_GI_IDSTRING
 GBLA &FI_GI_VOLUME,&FI_GI_DDNAME
 GBLA &FI_OC_INPUT,&FI_OC_OUTPUT,&FI_OC_FILENAME,&FI_OC_FILEID
 GBLA &FI_OC_EXISTING,&FI_OC_NEW,&FI_OC_FIXED,&FI_OC_VARYING
 GBLA &FI_OC_REPLACE,&FI_OC_APPEND
 GBLA &FI_OC_IDENT,&FI_OC_FILETEMPX,&FI_OC_FILETEMP
 GBLA &FI_OC_AUTOOPEN,&FI_OC_MANUALOPEN
 GBLA &FI_OC_XOPT,&FI_OC_XOPTBYTE,&FI_OC_XOPTWORD
 GBLA &FI_OC_RESERVED
 GBLA &FI_OC2_FREE,&FI_OC2_AUTOFREE,&FI_OC2_MANUALFREE
 GBLA &FI_OC2_CC,&FI_OC2_ISOCC
 GBLA &FI_OC2_SYSOUT
 GBLA &FI_OC2_LIBRARY
 GBLA &FI_OC2_RESERVED,&FI_OC32_RESERVED,&FI_OC42_RESERVED
 GBLA &FI_OO_INPUT,&FI_OO_OUTPUT,&FI_OO_DEFAULT
 GBLA &FI_SUCCESS,&FI_NOT_FOUND,&FI_END_OF_FILE,&FI_WARNING
 GBLA &FI_ERROR,&FI_SEVERE,&FI_INVALID_SYNTAX,&FI_INVALID_FILEID
 GBLA &FI_GET_REFERENCE
 GBLA &FI_FIND
 GBLA &FI_SET_STATUS,&FI_SS_END_OF_FILE
 GBLA &FI_OC2_CHKPDSMEMX,&FI_OC2_CHKPDSMEM,&FI_OC2_NOCHKPDSMEM
 GBLA &FI_OC2_ASCII
*
* Entry point names for all file handlers.
*
&FI_OS_FILE_HANDLER     SETC '''SRVFIOS ''' Standard OS file handler.
&FI_XSUBID_HANDLER      SETC '''SRVFIXID''' XsubID file handler.
&FI_PDF_FILE_HANDLER    SETC '''SRVFIPDF''' Ispf/Pdf Edit file handler.
&FI_SMS_FILE_HANDLER    SETC '''SRVFISMS''' Source Management System.
&FI_SUBMIT_HANDLER      SETC '''SRVFISUB''' Job submission handler.
*
* Function codes.
*
&FI_START               SETA 1          Start a file handler session.
&FI_TERMINATE           SETA 2          Terminate a session.
&FI_READLINE            SETA 5          Read next sequential record.
&FI_GET_INFO            SETA 6          Obtain messages & attributes.
&FI_WRITELINE           SETA 7          Append a line to output file.
&FI_SET_STATUS          SETA 8          Set the file's status.
&FI_OPEN                SETA 9          Open the file.
&FI_CLOSE               SETA 10         Close the file.
&FI_DELETE              SETA 11         Delete the file.
&FI_GET_REFERENCE       SETA 12         Get reference string.
&FI_FIND                SETA 13         Find member.
&FI_READLINE_LOCATE     SETA 14         Read-locate next line.
*
* Informational codes for use with FI_GET_INFO.
*
&FI_GI_MSG              SETA 1          Get most recently issued msg.
&FI_GI_NAME             SETA 2          Get the file's full name.
&FI_GI_LRECL            SETA 3          Get the file's logical rec len.
&FI_GI_RECFM            SETA 4          Get the file's record format.
&FI_GI_IDSTRING         SETA 5          Get an 8-character ID string.
&FI_GI_DDNAME           SETA 6          Get DDNAME (SRVFIOS only).
&FI_GI_VOLUME           SETA 7          Get VOLUME (SRVFIOS only).
*
* Status codes used with FI_SET_STATUS
*
&FI_SS_END_OF_FILE      SETA 1          Mark EOF without closing file.
*
* Option codes used during START to indicate how the file will be used.
*
*                            |-BYTE  1-|
&FI_OC_MODE         SETA 128 |X... ....|Bit-mask for INPUT/OUTPUT:
&FI_OC_INPUT        SETA   0 |0... ....|  Read records from file.
&FI_OC_OUTPUT       SETA 128 |1... ....|  Write records to file.
&FI_OC_IDENT        SETA  64 |.X.. ....|Bit-mask for FILENAME/FILEID:
&FI_OC_FILENAME     SETA   0 |.0.. ....|  Identified by name.
&FI_OC_FILEID       SETA  64 |.1.. ....|  Identified by ID (DDNAME).
&FI_OC_DISP         SETA  40 |..X. X...|Bit-mask EXISTING/NEW/REPLACE
&FI_OC_EXISTING     SETA   0 |..0. 0...|  File already exists.
&FI_OC_NEW          SETA  32 |..1. 0...|  File is being created.
&FI_OC_REPLACE      SETA   8 |..0. 1...|  File is being replaced.
&FI_OC_APPEND       SETA  40 |..1. 1...|  File is being appended-to.
&FI_OC_RECFM        SETA  16 |...X ....|Bit-mask for FIXED/VARYING:
&FI_OC_FIXED        SETA   0 |...0 ....|  Create w/fixed length recs.
&FI_OC_VARYING      SETA  16 |...1 ....|  Create w/varying length recs.
&FI_OC_OPEN         SETA   4 |.... .X..|Bit-Mask for OPEN=AUTO/MANUAL.
&FI_OC_AUTOOPEN     SETA   0 |.... .0..|  Start automatically OPENs.
&FI_OC_MANUALOPEN   SETA   4 |.... .1..|  FI_OPEN must be used to OPEN.
&FI_OC_FILETEMPX    SETA   2 |.... ..x.|Bit-mask for FILETEMP:
&FI_OC_FILETEMP     SETA   2 |.... ..1.|  Temporary file.
&FI_OC_XOPT         SETA   1 |.... ...X|Bit-mask for extended options.
&FI_OC_XOPTBYTE     SETA   0 |.... ...0|  Basic options (byte).
&FI_OC_XOPTWORD     SETA   1 |.... ...1|  Extended options (fullword).
&FI_OC_RESERVED     SETA   0 |.... ....|Reserved bits: none.
*                            |         |
*                            |-BYTE  2-|Supplied if FI_OC_XOPTWORD = 1
*                            |         |
&FI_OC2_FREE        SETA 128 |x... ....|Bit-mask for MANUAL/AUTO FREE
&FI_OC2_AUTOFREE    SETA   0 |0... ....|  AUTOFREE.
&FI_OC2_MANUALFREE  SETA 128 |1... ....|  MANUALFREE.
&FI_OC2_CC          SETA  64 |.x.. ....|Bit-mask for control character.
&FI_OC2_ISOCC       SETA  64 |.1.. ....|  Records have ISO/ANSI control
*                            |         |  characters.
&FI_OC2_SYSOUTX     SETA  32 |..x. ....|Bit-mask for SYSOUTX:
&FI_OC2_SYSOUT      SETA  32 |..1. ....|  SYSOUT File.
&FI_OC2_CHKPDSMEMX  SETA  16 |...x ....|Bit-mask for PDS Member Check.
&FI_OC2_CHKPDSMEM   SETA   0 |...0 ....|  Check to see if member exists
&FI_OC2_NOCHKPDSMEM SETA  16 |...1 ....|  Do not check to see if member
*                            |         |    exists.
&FI_OC2_ASCII       SETA   8 |.... 1...|File is ASCII (caller sees only
*                            |         |  EBCDIC).
&FI_OC2_LIBRARY     SETA   4 |.... .1..|This is a read-only library.
*                            |         |  FI_FIND is required.
&FI_OC2_RESERVED    SETA   3 |.... ..00|Reserved bits: must be zero.
*                            |         |
*                            |-BYTE  3-|Supplied if FI_OC_XOPTWORD = 1
*                            |         |
&FI_OC3_RESERVED    SETA 255 |0000 0000|Reserved bits: must be zero.
*                            |         |
*                            |-BYTE  4-|Supplied if FI_OC_XOPTWORD = 1
*                            |         |
&FI_OC4_RESERVED    SETA 255 |0000 0000|Reserved bits: must be zero.
*
*
* Option codes used during OPEN to indicate how the file will be used.
*
&FI_OO_MODE     SETA 192 |XX.. ....|  Bit-mask for INPUT/OUTPUT:
&FI_OO_DEFAULT  SETA   0 |00.. ....|    Default to start option.
&FI_OO_INPUT    SETA 128 |10.. ....|    Read records from file.
&FI_OO_OUTPUT   SETA 192 |11.. ....|    Write records to file.
&FI_OO_RESERVED SETA  63 |..00 0000|  Reserved bits: must be zero.
*
* Return codes.
*   FI_INVALID_SYNTAX is returned by the START function only; it is
*   used when file-servers are being cascaded to indicate that the file
*   name is not for the type of file supported by that particular file
*   server and that the next server should be tried. If file-servers
*   are not being cascaded or if the last one has been tried,
*   FI_INVALID_SYNTAX should be treated in the same manner as FI_ERROR.
*
&FI_SUCCESS             SETA  0         Successful completion.
&FI_NOT_FOUND           SETA  1         Member or record not found.
&FI_END_OF_FILE     SETA  &FI_NOT_FOUND Alternate name for not found.
&FI_WARNING             SETA  2         Non-terminating error occurred.
&FI_ERROR               SETA  3         Terminating error occurred.
&FI_SEVERE              SETA  4         A severe terminating error.
&FI_INVALID_SYNTAX      SETA  5         Unsupported filename syntax.
&FI_INVALID_FILEID      SETA  6         A bad file-token was used.
&FI_CRITICAL            SETA  7         A critical error occured.
 DEFUCOND MACRO=SRV##RC,NAME=FI_SUCCESS
 DEFUCOND MACRO=SRV##RC,NAME=FI_NOT_FOUND
 DEFUCOND MACRO=SRV##RC,NAME=FI_END_OF_FILE
 DEFUCOND MACRO=SRV##RC,NAME=FI_WARNING
 DEFUCOND MACRO=SRV##RC,NAME=FI_ERROR
 DEFUCOND MACRO=SRV##RC,NAME=FI_SEVERE
 DEFUCOND MACRO=SRV##RC,NAME=FI_INVALID_SYNTAX
 DEFUCOND MACRO=SRV##RC,NAME=FI_INVALID_FILEID
 DEFUCOND MACRO=SRV##RC,NAME=FI_CRITICAL
                        EJECT
***********************************************************************
***********************************************************************
**                                                                   **
**                     Macro Definitions                             **
**                                                                   **
***********************************************************************
***********************************************************************
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_ID                                                      *
*                                                                     *
* Purpose: Establish default values for a specific service processor  *
*          and associate them with the specified ID name. The values  *
*          are stored in the following created global variables:      *
*                                                                     *
* Variable Name                     Description                       *
* -------------  ---------------------------------------------------- *
* #$&ID.$#IDMAC  Name of macro that created the ID: FI_ID.            *
* #$&ID.$#ESID   Service processor's Environment Support ID.          *
* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *
* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *
* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *
* #$&ID.$#EMC    Tag for Service processor's Error Macro name.        *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,&ERRMAC=
.*
.* Invoke SRV##ID to create globals used by all ID's.
.*
         SRV##ID SET,                                                  +
               ID=&ID.,IDMAC=FI_ID,ESID=&ESID.,SPEPNAME=&SPEPNAME,     +
               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.,ERRMAC=&ERRMAC
         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_START                                                   *
* Purpose: Generate code to start a new file handler session.         *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&FILE=,&INFO=,&ERRMAC=,+
               &OPTIONS=,&OPTIONVALUE=,                                +
               &RECORDLENGTH=,&FILESIZE=,&REFERENCE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_START                  SETC in open code.
         GBLA  &FI_OC_INPUT,&FI_OC_OUTPUT,&FI_OC_FILENAME,&FI_OC_FILEID
         GBLA  &FI_OC_EXISTING,&FI_OC_NEW,&FI_OC_REPLACE,&FI_OC_APPEND
         GBLA  &FI_OC_AUTOOPEN,&FI_OC_MANUALOPEN
         GBLA  &FI_OC_FILETEMP,&FI_OC2_SYSOUT
         GBLA  &FI_OC_XOPT,&FI_OC_XOPTBYTE,&FI_OC_XOPTWORD
         GBLA  &FI_OC2_FREE,&FI_OC2_AUTOFREE,&FI_OC2_MANUALFREE
         GBLA  &FI_OC2_CC,&FI_OC2_ISOCC
         GBLA  &FI_OC2_CHKPDSMEMX,&FI_OC2_CHKPDSMEM,&FI_OC2_NOCHKPDSMEM
         GBLA  &FI_OC2_LIBRARY
         GBLA  &FI_OC2_RESERVED,&FI_OC32_RESERVED,&FI_OC42_RESERVED
         GBLA  &FI_OC2_ASCII
         LCLC  &L_ADDR,&L_LEN,&L_OPTIONS
         LCLA  &I,&J,&L
         LCLB  &K,&NK
         LCLC  &O_NAME(19)                Option names, paired up.
         LCLB  &O_SET(19)                 Names specified, paired up.
         LCLA  &O_VALUE,&O2_VALUE,&O3_VALUE,&O4_VALUE
         LCLA  &XOPT
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ESVA=&ESVA.,ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.
.*
.* Generate the OPTIONS parameter for FI_START.
.*
.*   The symbols in O_NAME are option keywords that may be specified.
.*
.*   Note: The RECORDLENGTH and FILESIZE checks depend on the position
.*         of INPUT and OUTPUT in the O_NAME list, along with their
.*         respective O_SET bits.
.*
               AIF  ('&OPTIONS' NE '').OPT_KWDS
&L_OPTIONS     SETC '&OPTIONVALUE'
               AGO  .PAST_OPTIONS
.OPT_KWDS      ANOP
&O_NAME(1)     SETC 'INPUT','OUTPUT','FILENAME','FILEID'
&O_NAME(5)     SETC 'EXISTING','NEW','REPLACE'
&O_NAME(8)     SETC 'AUTOOPEN','MANUALOPEN','APPEND','FILETEMP'
&O_NAME(12)    SETC 'AUTOFREE','MANUALFREE','ISOCC','SYSOUT'
&O_NAME(16)    SETC 'CHKPDSMEM','NOCHKPDSMEM','ASCII','LIBRARY'
.*                  1 2 3 4 5 6 7 8 9 + 1 2 3 4 5 6 7 8 9
&O_SET(1)      SETB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
&I             SETA 0
.O_KWD_LOOP    AIF  (&I GE N'&OPTIONS).PAST_OPT
&I             SETA &I+1
&J             SETA 1
.O_NAME_LOOP   AIF  (&J GT N'&O_NAME).PAST_NAME
               AIF  ('&OPTIONS(&I)' EQ '&O_NAME(&J)').PAST_NAME
&J             SETA &J+1
               AGO  .O_NAME_LOOP
.PAST_NAME     AIF   (&J LE N'&O_NAME).O_CHK_SET
               MNOTE 8,'Option &OPTIONS(&I) is invalid.'
               AGO   .O_KWD_LOOP
.O_CHK_SET     AIF   (NOT (&O_SET(&J))).O_SET_OPT
               MNOTE 8,'Option &OPTIONS(&I) already specified.'
               AGO   .O_KWD_LOOP
.O_SET_OPT     ANOP
&O_SET(&J)     SETB  1
               AGO   .O_KWD_LOOP
.PAST_OPT      ANOP
.*
.* If SYSOUT was specified, generate options OUTPUT,NEW,FILEID,ISOCC
.*
               AIF  (NOT &O_SET(15)).PAST_SYSOUT_IMPLY
               MNOTE *,'SYSOUT Implies OUTPUT,NEW,FILEID,ISOCC'
&O_SET(2)      SETB  1     OUTPUT
&O_SET(4)      SETB  1     FILEID
&O_SET(6)      SETB  1     NEW
&O_SET(14)     SETB  1     ISOCC
.PAST_SYSOUT_IMPLY ANOP
.*
.* Check for mutually exclusive keywords and other invalid combos.
.*
&L_OPTIONS SETC  'INPUT and OUTPUT'
           AIF   (&O_SET(1) AND &O_SET(2)).MUTEX  (INPUT OUTPUT)
&L_OPTIONS SETC  'LIBRARY and OUTPUT'
           AIF   (&O_SET(19) AND &O_SET(2)).MUTEX  (LIBRARY OUTPUT)
&L_OPTIONS SETC  'FILENAME and FILEID'
           AIF   (&O_SET(3)  AND &O_SET(4)).MUTEX
&L_OPTIONS SETC  'SYSOUT AND INPUT'
           AIF   (&O_SET(15) AND &O_SET(1)).MUTEX
&L_OPTIONS SETC  'SYSOUT AND FILENAME'
           AIF   (&O_SET(15) AND &O_SET(3)).MUTEX
&L_OPTIONS SETC  'SYSOUT AND EXISTING'
           AIF   (&O_SET(15) AND &O_SET(5)).MUTEX
&L_OPTIONS SETC  'SYSOUT AND REPLACE'
           AIF   (&O_SET(15) AND &O_SET(7)).MUTEX
&L_OPTIONS SETC  'SYSOUT AND APPEND'
           AIF   (&O_SET(15) AND &O_SET(10)).MUTEX
.*
&L_OPTIONS SETC  'EXISTING, NEW, REPLACE, and APPEND'
           AIF   (&O_SET(5)+&O_SET(6)+&O_SET(7)+&O_SET(10) GT 1).MUTEX
&L_OPTIONS SETC  'AUTOOPEN and MANUALOPEN'
           AIF   (&O_SET(8) AND &O_SET(9)).MUTEX  (AUTOOPEN MANUALOPEN)
&L_OPTIONS SETC  'AUTOFREE and MANUALFREE'
           AIF   (&O_SET(12) AND &O_SET(13)).MUTEX
           AGO   .PAST_MUTEX
.MUTEX     MNOTE 8,'Options &L_OPTIONS are mutually exclusive'
.PAST_MUTEX ANOP
            AIF   (&O_SET(2) OR (NOT &O_SET(10))).PAST_APPCHK
            MNOTE 8,'APPEND option only valid for OUTPUT.'
.PAST_APPCHK ANOP
.*
.* Determine if using basic or extended options.
.*
           AIF   (&O_SET(12) OR &O_SET(13) OR &O_SET(14)).XOPT_WORD
           AIF   (&O_SET(15) OR &O_SET(16) OR &O_SET(17)).XOPT_WORD
           AIF   (&O_SET(18) OR &O_SET(19)).XOPT_WORD
&XOPT      SETA  &FI_OC_XOPTBYTE
           AGO   .PAST_XOPT
.XOPT_WORD ANOP
&XOPT      SETA  &FI_OC_XOPTWORD
.PAST_XOPT ANOP
.*
.* Build the option-bytes that will be used.
.*
&O_VALUE       SETA  0
&O_VALUE       SETA  &O_VALUE+(&O_SET(1)*(&FI_OC_INPUT))
&O_VALUE       SETA  &O_VALUE+(&O_SET(2)*(&FI_OC_OUTPUT))
&O_VALUE       SETA  &O_VALUE+(&O_SET(3)*(&FI_OC_FILENAME))
&O_VALUE       SETA  &O_VALUE+(&O_SET(4)*(&FI_OC_FILEID))
&O_VALUE       SETA  &O_VALUE+(&O_SET(5)*(&FI_OC_EXISTING))
&O_VALUE       SETA  &O_VALUE+(&O_SET(6)*(&FI_OC_NEW))
&O_VALUE       SETA  &O_VALUE+(&O_SET(7)*(&FI_OC_REPLACE))
&O_VALUE       SETA  &O_VALUE+(&O_SET(8)*(&FI_OC_AUTOOPEN))
&O_VALUE       SETA  &O_VALUE+(&O_SET(9)*(&FI_OC_MANUALOPEN))
&O_VALUE       SETA  &O_VALUE+(&O_SET(10)*(&FI_OC_APPEND))
&O_VALUE       SETA  &O_VALUE+(&O_SET(11)*(&FI_OC_FILETEMP))
&O_VALUE       SETA  &O_VALUE+&XOPT
               AIF   (&XOPT EQ &FI_OC_XOPTWORD).XOPTWORD
&L_OPTIONS     SETC  '=AL1(&O_VALUE.)'
               AGO   .PAST_OPTIONS
.XOPTWORD      ANOP
&O2_VALUE      SETA  0
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(12)*(&FI_OC2_AUTOFREE))
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(13)*(&FI_OC2_MANUALFREE))
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(14)*(&FI_OC2_ISOCC))
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(15)*(&FI_OC2_SYSOUT))
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(16)*(&FI_OC2_CHKPDSMEM))
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(17)*(&FI_OC2_NOCHKPDSMEM))
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(18)*(&FI_OC2_ASCII))
&O2_VALUE      SETA  &O2_VALUE+(&O_SET(19)*(&FI_OC2_LIBRARY))
&O3_VALUE      SETA  0
&O4_VALUE      SETA  0
&L_OPTIONS     SETC  '=AL1(&O_VALUE.,&O2_VALUE,&O3_VALUE,&O4_VALUE)'
.PAST_OPTIONS  ANOP
.*
.* Decode the FILE= keyword to get an address and length.
.*
              AIF ('&FILE' EQ '').NO_FILE
              AIF ('&FILE'(1,1) EQ '''').FILE_LITERAL
              AIF (N'&FILE EQ 1).FILE_TAGONLY
              AIF (N'&FILE EQ 2).FILE_TAGLEN
              MNOTE 8,'Too many subparameters for FILE keyword.'
              MEXIT
.FILE_TAGLEN  ANOP
&L_ADDR       SETC '&FILE(1)'             | Set addr.
&L_LEN        SETC '&FILE(2)'             | Set len.
              AGO  .PAST_FILE             |
.FILE_TAGONLY ANOP
&L_ADDR       SETC '&FILE'                | Set addr to tag_name.
&L_LEN        SETC '=A(L''&FILE)'         | Set len to L'tag_name.
              AGO  .PAST_FILE             |
.FILE_LITERAL ANOP                        |
&L_ADDR       SETC '&FILE'                | Set addr to actual literal.
&L            SETA 0                      | Length counter = 0.
&I            SETA 2                      | Index counter -> past '.
.FILE_LOOP    AIF  (&I GE K'&L_ADDR).FILE_ELOOP      Loop over FILE.
              AIF  ('&L_ADDR'(&I,1) NE '''').FILE_TXT If doubled quotes
&I            SETA &I+1                   |            Advance past '.
.FILE_TXT     ANOP                        |          EndIf.
&L            SETA &L+1                   |   Add one to length.
&I            SETA &I+1                   |   Advance to next position.
              AGO  .FILE_LOOP             | End of counting loop.
.FILE_ELOOP   ANOP                        |
&L_LEN        SETC '&L'                   | Set length parameter.
              AGO  .PAST_FILE
.NO_FILE      AIF  (&O_SET(11) OR &O_SET(15)).PAST_FILE
  MNOTE 8,'FILE= is required unless FILETEMP or SYSOUT option used.'
              MEXIT
.PAST_FILE    ANOP
.*
.* Make sure RECORDLENGTH is valid:
.*   .. If not specified, parms will not be present or will be zero
.*      addresses if needed as placeholders in parameter list.
.*   .. Ignored if OPTIONS=INPUT specified (warning only)
.*   .. Not valid if there's more than 2 specified.
.*
.RECLEN   ANOP ,
          LCLC  &AVGLRECL,&MAXLRECL
&AVGLRECL SETC  '0'                       Set avg, max LRECL defaults
&MAXLRECL SETC  '0'
          LCLB  &AVGLRECL_P,&MAXLRECL_P
          AIF   ('&RECORDLENGTH' EQ '' AND &O_SET(2)).RLDFLT
          AIF   ('&RECORDLENGTH' NE '' AND &O_SET(1)).RLIGNORE
          AIF   (N'&RECORDLENGTH GT 2).RLTOOMANY
&AVGLRECL SETC  '&RECORDLENGTH(1)'        Set average LRECL
&AVGLRECL_P SETB 1
          AIF   (N'&RECORDLENGTH EQ 1).PAST_RECLEN
&MAXLRECL SETC  '&RECORDLENGTH(2)'
&MAXLRECL_P SETB 1
.RLDFLT   AGO   .PAST_RECLEN
.RLIGNORE MNOTE 4,'RECORDLENGTH parameter will be ignored if OPTIONS=OU*
               TPUT not specified.'
          AGO  .PAST_RECLEN
.RLTOOMANY MNOTE 8,'Too many parameters specified for RECORDLENGTH.'
          MEXIT
.PAST_RECLEN   ANOP
.*
.* Make sure FILESIZE is valid:
.*   .. Defaults if OPTIONS=OUTPUT specified to (1000,1000)
.*   .. Ignored if OPTIONS=INPUT specified (warning only)
.*   .. Not valid if there's more than 2 specified.
.*
.FILESIZE ANOP ,
          LCLC  &FILEINIT,&FILEINCR
&FILEINIT SETC  '0'
&FILEINCR SETC  '0'
          LCLB  &FILEINIT_P,&FILEINCR_P
          AIF   ('&FILESIZE' EQ '' AND &O_SET(2)).FSDFLT
          AIF   ('&FILESIZE' NE '' AND &O_SET(1)).FSIGNORE
          AIF   (N'&FILESIZE GT 2).FSTOOMANY
&FILEINIT SETC  '&FILESIZE(1)'
&FILEINIT_P SETB 1
          AIF   (N'&FILESIZE EQ 1).PAST_FILESZ
&FILEINCR SETC  '&FILESIZE(2)'
&FILEINCR_P SETB 1
.FSDFLT   AGO   .PAST_FILESZ
.FSIGNORE MNOTE 4,'FILESIZE parameter will be ignored if OPTIONS=OUTPUT*
                not specified.'
          AGO  .PAST_FILESZ
.FSTOOMANY MNOTE 8,'Too many parameters specified for FILESIZE.'
          MEXIT
.PAST_FILESZ   ANOP
.*
.* See if REFERENCE was specified.
.*
          LCLB &REFERENCE_P
&REFERENCE_P  SETB 0
              AIF ('&REFERENCE' EQ '').NO_REFERENCE
&REFERENCE_P  SETB 1
.NO_REFERENCE ANOP
.*
.* Build VL PLIST based on what was specified.
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN,&FI_START,&#_IDESVA,&INFO
         ##PLIST PARM,&L_ADDR,&L_LEN,&L_OPTIONS
         AIF   (NOT &O_SET(2)).PLEND
         AIF   (NOT (&AVGLRECL_P OR &MAXLRECL_P OR &FILEINIT_P OR      *
               &FILEINCR_P OR &REFERENCE_P)).PLEND
         ##PLIST PARM,&AVGLRECL
         AIF  (NOT (&MAXLRECL_P OR &FILEINIT_P OR &FILEINCR_P OR       *
               &REFERENCE_P)).PLEND
         ##PLIST PARM,&MAXLRECL
         AIF   (NOT (&FILEINIT_P OR &FILEINCR_P OR &REFERENCE_P)).PLEND
         ##PLIST PARM,&FILEINIT
         AIF   (NOT (&FILEINCR_P OR &REFERENCE_P)).PLEND
         ##PLIST PARM,&FILEINCR
         AIF   (NOT &REFERENCE_P).PLEND
         ##PLIST PARM,&REFERENCE
.PLEND   ANOP ,
         ##PLIST END,VL
.*
.* Generate the FI_START call statement.
.*
         CALLX &#_IDEPA
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_OPEN                                                    *
* Purpose: Generate code to OPEN a file.                              *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_OPEN &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                      +
               &OPTIONS=,&OPTIONVALUE
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_OPEN                   SETC in open code.
         GBLA  &FI_OO_INPUT,&FI_OO_OUTPUT
         LCLC  &O_NAME(2)                 Option names, paired up.
         LCLB  &O_SET(2)                  Names specified, paired up.
         LCLA  &O_VALUE
         LCLC  &L_OPTIONS
.*
.* Obtain service processor ID values and OPEN the file.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Generate the OPTIONS parameter for FI_OPEN.
.*
.*   The symbols in O_NAME are option keywords that may be specified.
.*
               AIF  ('&OPTIONS' NE '').OPT_KWDS
&L_OPTIONS     SETC '&OPTIONVALUE'
               AGO  .PAST_OPTIONS
.OPT_KWDS      ANOP
&O_NAME(1)     SETC 'INPUT','OUTPUT'
&O_SET(1)      SETB 0,0
&I             SETA 0
.O_KWD_LOOP    AIF  (&I GE N'&OPTIONS).PAST_OPT
&I             SETA &I+1
&J             SETA 1
.O_NAME_LOOP   AIF  (&J GT N'&O_NAME).PAST_NAME
               AIF  ('&OPTIONS(&I)' EQ '&O_NAME(&J)').PAST_NAME
&J             SETA &J+1
               AGO  .O_NAME_LOOP
.PAST_NAME     AIF   (&J LE N'&O_NAME).O_CHK_SET
               MNOTE 8,'Option &OPTIONS(&I) is invalid.'
               AGO   .O_KWD_LOOP
.O_CHK_SET     AIF   (NOT (&O_SET(&J))).O_SET_OPT
               MNOTE 8,'Option &OPTIONS(&I) already specified.'
               AGO   .O_KWD_LOOP
.O_SET_OPT     ANOP
&O_SET(&J)     SETB  1
               AGO   .O_KWD_LOOP
.PAST_OPT      ANOP
.*
.* Check for mutually exclusive keywords.
.*
&L_OPTIONS SETC  'INPUT and OUTPUT'
           AIF   (&O_SET(1) AND &O_SET(2)).MUTEX  (INPUT OUTPUT)
           AGO   .SET_OPTION_BYTE
.MUTEX     MNOTE 8,'Options &L_OPTIONS are mutually exclusive'
.*
.* Build the actual option-byte that will be used.
.*
.SET_OPTION_BYTE ANOP
&O_VALUE       SETA  0
&O_VALUE       SETA  &O_VALUE+(&O_SET(1)*(&FI_OO_INPUT))
&O_VALUE       SETA  &O_VALUE+(&O_SET(2)*(&FI_OO_OUTPUT))
&L_OPTIONS     SETC  '=AL1(&O_VALUE.)'
.PAST_OPTIONS  ANOP
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN,&FI_OPEN
         AIF ('&OPTIONS' EQ '' AND '&OPTIONVALUE' EQ '').PLEND
         ##PLIST PARM,&L_OPTIONS
.PLEND   ##PLIST END,VL
.*
.* Generate the FI_START call statement.
.*
         CALLX &#_IDEPA
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_CLOSE                                                   *
* Purpose: Generate code to CLOSE a file.                             *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_CLOSE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_CLOSE                  SETC in open code.
.*
.* Obtain service processor ID values and CLOSE the file.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         CALLX &#_IDEPA,(&#_IDTKN,&FI_CLOSE),VL
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_DELETE                                                  *
* Purpose: Generate code to DELETE a file.                            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_DELETE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_DELETE                 SETC in open code.
.*
.* Obtain service processor ID values and DELETE the file.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         CALLX &#_IDEPA,(&#_IDTKN,&FI_DELETE),VL
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_TERMINATE                                               *
* Purpose: Generate code to terminate a file handler session.         *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_TERMINATE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_TERMINATE              SETC in open code.
.*
.* Obtain service processor ID values and terminate file handler.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         CALLX &#_IDEPA,(&#_IDTKN,&FI_TERMINATE),VL
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_READLINE                                                *
* Purpose: Generate code to read the next sequential input line.      *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_READLINE &ID=,&SPEPA=,&SPTOKEN=,&LINE=,&RESULTLEN=,&ERRMAC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_READLINE
         LCLC  &L_ADDR,&L_LEN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         AIF  ('&RESULTLEN' NE '').PAST_RESULTLEN
         MNOTE 8,'RESULTLEN is a required keyword.'
         MEXIT
.PAST_RESULTLEN ANOP
.*
.* Decode the LINE= keyword to get an address and length.
.*
              AIF ('&LINE' EQ '').NO_LINE
              AIF (N'&LINE EQ 1).LINE_TAGONLY
              AIF (N'&LINE EQ 2).LINE_TAGLEN
              MNOTE 8,'Too many subparameters for LINE keyword.'
              MEXIT
.LINE_TAGLEN  ANOP
&L_ADDR       SETC '&LINE(1)'             | Set addr.
&L_LEN        SETC '&LINE(2)'             | Set len.
              AGO  .PAST_LINE             |
.LINE_TAGONLY ANOP
&L_ADDR       SETC '&LINE'                | Set addr to tag_name.
&L_LEN        SETC '=A(L''&LINE)'         | Set len to L'tag_name.
              AGO  .PAST_LINE             |
.NO_LINE      MNOTE 8,'LINE is a required keyword.'
              MEXIT
.PAST_LINE    ANOP
.*
.* Generate the CALLX to read a line.
.*
         CALLX &#_IDEPA,(&#_IDTKN,&FI_READLINE,&L_ADDR,&L_LEN,         +
               &RESULTLEN),VL
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND

*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_READLINE_LOCATE                                         *
* Purpose: Generate code to read the next sequential input line       *
*          and return it's address and length. Length is optional.    *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_READLINE_LOCATE &ID=,&SPEPA=,&SPTOKEN=,&ADDRESS=,&ERRMAC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_READLINE_LOCATE
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Generate the CALLX to read a line.
.*
         CALLX &#_IDEPA,(&#_IDTKN,&FI_READLINE_LOCATE,&ADDRESS),VL
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_WRITELINE                                               *
* Purpose: Generate code to write a line to the current output file.  *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_WRITELINE &ID=,&SPEPA=,&SPTOKEN=,&LINE=,&ERRMAC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_WRITELINE
         LCLC  &L_ADDR,&L_LEN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         AIF  ('&LINE' NE '').PAST_LINEREQ
         MNOTE 8,'LINE is a required keyword.'
         MEXIT
.PAST_LINEREQ ANOP
.*
.* Decode the LINE= keyword to get an address and length.
.*
              AIF ('&LINE' EQ '').NO_LINE
              AIF (N'&LINE EQ 1).LINE_TAGONLY
              AIF (N'&LINE EQ 2).LINE_TAGLEN
              MNOTE 8,'Too many subparameters for LINE keyword.'
              MEXIT
.LINE_TAGLEN  ANOP
&L_ADDR       SETC '&LINE(1)'             | Set addr.
&L_LEN        SETC '&LINE(2)'             | Set len.
              AGO  .PAST_LINE             |
.LINE_TAGONLY ANOP
&L_ADDR       SETC '&LINE'                | Set addr to tag_name.
&L_LEN        SETC '=A(L''&LINE)'         | Set len to L'tag_name.
              AGO  .PAST_LINE             |
.NO_LINE      MNOTE 8,'LINE is a required keyword.'
              MEXIT
.PAST_LINE    ANOP
.*
.* Generate the CALLX to write a line.
.*
         CALLX &#_IDEPA,(&#_IDTKN,&FI_WRITELINE,&L_ADDR,&L_LEN)
.*
.* If ERRMAC is non-null, generate error-macro instruction.
.*
         AIF   ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_GET_INFO                                                *
* Purpose: Get information about a file handler session.              *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_GET_INFO &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                  +
               &NAME=,&NAMELEN=,                                       +
               &DDNAME=,&DDNAMELEN=,                                   +
               &VOLUME=,&VOLUMELEN=,                                   +
               &MSG=,&MSGLEN=,                                         +
               &LRECL=,&RECFM=,&IDSTRING=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_GET_INFO
         GBLA  &FI_GI_NAME,&FI_GI_MSG,&FI_GI_LRECL,&FI_GI_RECFM
         GBLA  &FI_GI_IDSTRING,&FI_GI_DDNAME,&FI_GI_VOLUME
         LCLC  &L_ADDR,&L_LEN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.*       Generate parameter list prelude code.
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN,&FI_GET_INFO
.*
.* If NAME= was specified, generate code to get NAME information.
.*
              AIF ('&NAME' EQ '').NO_NAME
              AIF (N'&NAME EQ 1).NAME_TAGONLY
              AIF (N'&NAME EQ 2).NAME_TAGLEN
              MNOTE 8,'Too many subparameters for NAME keyword.'
              MEXIT
.NAME_TAGLEN  ANOP
&L_ADDR       SETC '&NAME(1)'             | Set addr.
&L_LEN        SETC '&NAME(2)'             | Set len.
              AGO  .PAST_NAME             |
.NAME_TAGONLY ANOP
&L_ADDR       SETC '&NAME'                | Set addr to tag_name.
&L_LEN        SETC '=A(L''&NAME)'         | Set len to L'tag_name.
.PAST_NAME    AIF  ('&NAMELEN' NE '').CALL_NAME
              MNOTE 8,'NAMELEN must be specified if NAME is specified.'
              MEXIT
.CALL_NAME    ##PLIST PARM,&FI_GI_NAME,&L_ADDR,&L_LEN,&NAMELEN
.NO_NAME      ANOP
.*
.* If DDNAME= was specified, generate code to get DDNAME information.
.*
              AIF ('&DDNAME' EQ '').NO_DDNAME
              AIF (N'&DDNAME EQ 1).DDNAME_TAGONLY
              AIF (N'&DDNAME EQ 2).DDNAME_TAGLEN
              MNOTE 8,'Too many subparameters for DDNAME keyword.'
              MEXIT
.DDNAME_TAGLEN  ANOP
&L_ADDR       SETC '&DDNAME(1)'             | Set addr.
&L_LEN        SETC '&DDNAME(2)'             | Set len.
              AGO  .PAST_DDNAME             |
.DDNAME_TAGONLY ANOP
&L_ADDR       SETC '&DDNAME'                | Set addr to tag_ddname.
&L_LEN        SETC '=A(L''&DDNAME)'         | Set len to L'tag_ddname.
.PAST_DDNAME    AIF  ('&DDNAMELEN' NE '').CALL_DDNAME
        MNOTE 8,'DDNAMELEN must be specified if DDNAME is specified.'
              MEXIT
.CALL_DDNAME  ##PLIST PARM,&FI_GI_DDNAME,&L_ADDR,&L_LEN,&DDNAMELEN
.NO_DDNAME    ANOP
.*
.* If VOLUME= was specified, generate code to get VOLUME information.
.*
              AIF ('&VOLUME' EQ '').NO_VOLUME
              AIF (N'&VOLUME EQ 1).VOLUME_TAGONLY
              AIF (N'&VOLUME EQ 2).VOLUME_TAGLEN
              MNOTE 8,'Too many subparameters for VOLUME keyword.'
              MEXIT
.VOLUME_TAGLEN  ANOP
&L_ADDR       SETC '&VOLUME(1)'             | Set addr.
&L_LEN        SETC '&VOLUME(2)'             | Set len.
              AGO  .PAST_VOLUME             |
.VOLUME_TAGONLY ANOP
&L_ADDR       SETC '&VOLUME'                | Set addr to tag_VOLUME.
&L_LEN        SETC '=A(L''&VOLUME)'         | Set len to L'tag_VOLUME.
.PAST_VOLUME    AIF  ('&VOLUMELEN' NE '').CALL_VOLUME
        MNOTE 8,'VOLUMELEN must be specified if VOLUME is specified.'
              MEXIT
.CALL_VOLUME  ##PLIST PARM,&FI_GI_VOLUME,&L_ADDR,&L_LEN,&VOLUMELEN
.NO_VOLUME    ANOP
.*
.* If MSG= was specified, generate code to get MSG information.
.*
              AIF ('&MSG' EQ '').NO_MSG
              AIF (N'&MSG EQ 1).MSG_TAGONLY
              AIF (N'&MSG EQ 2).MSG_TAGLEN
              MNOTE 8,'Too many subparameters for MSG keyword.'
              MEXIT
.MSG_TAGLEN   ANOP
&L_ADDR       SETC '&MSG(1)'              | Set addr.
&L_LEN        SETC '&MSG(2)'              | Set len.
              AGO  .PAST_MSG              |
.MSG_TAGONLY  ANOP
&L_ADDR       SETC '&MSG'                 | Set addr to tag_MSG.
&L_LEN        SETC '=A(L''&MSG)'          | Set len to L'tag_MSG.
.PAST_MSG     AIF  ('&MSGLEN' NE '').CALL_MSG
              MNOTE 8,'MSGLEN must be specified if MSG is specified.'
              MEXIT
.CALL_MSG     ##PLIST PARM,&FI_GI_MSG,&L_ADDR,&L_LEN,&MSGLEN
.NO_MSG       ANOP
.*
.* If LRECL= was specified, generate code to get LRECL information.
.*
              AIF ('&LRECL' EQ '').NO_LRECL
.CALL_LRECL   ##PLIST PARM,&FI_GI_LRECL,&LRECL
.NO_LRECL     ANOP
.*
.* If RECFM= was specified, generate code to get RECFM information.
.*
              AIF ('&RECFM' EQ '').NO_RECFM
.CALL_RECFM   ##PLIST PARM,&FI_GI_RECFM,&RECFM
.PAST_RECFM   ANOP
.NO_RECFM     ANOP
.*
.* If IDSTRING= was specified, generate code to get IDSTRING info.
.*
              AIF ('&IDSTRING' EQ '').NO_IDSTRING
.CALL_IDSTRING ##PLIST PARM,&FI_GI_IDSTRING,&IDSTRING
.PAST_IDSTRNG ANOP
.NO_IDSTRING  ANOP
.*
.* Complete the parameter list and generate the call.
.*
               ##PLIST END,VL
               CALLX   &#_IDEPA
               AIF   ('&#_IDEMC' EQ '').NO_EMC
               &#_IDEMC.
.NO_EMC        ANOP
.MEXIT         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_GET_REFERENCE                                           *
* Purpose: Get reference string from file handler session.            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_GET_REFERENCE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,             +
               &REFERENCE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_GET_REFERENCE
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         AIF  ('&REFERENCE' EQ '').NO_REF
         CALLX   &#_IDEPA,(&#_IDTKN,&FI_GET_REFERENCE,&REFERENCE),VL
              MEXIT
.NO_REF       MNOTE 8,'REFERENCE is a required keyword.'
.MEXIT         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_SET_STATUS                                              *
* Purpose: Provide information to the file handler on the file's      *
*          current status.                                            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_SET_STATUS &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                +
               &EOF=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_SET_STATUS
         GBLA  &FI_SS_END_OF_FILE
         LCLC  &L_ADDR,&L_LEN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* If EOF= (END_OF_FILE) was specified
.*
              AIF ('&EOF' EQ 'YES').SET_EOF
              AIF ('&EOF' EQ '').NO_EOF
              MNOTE 8,'Invalid value (&EOF) for the EOF keyword.'
              MEXIT
.SET_EOF      ANOP
.CALL_NAME    CALLX &#_IDEPA,(&#_IDTKN,&FI_SET_STATUS,                 +
               &FI_SS_END_OF_FILE)
              AIF   ('&#_IDEMC' EQ '').NO_EMC
              &#_IDEMC.
.NO_EMC       ANOP
.NO_EOF       ANOP
.MEXIT        MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_FIND                                                    *
* Purpose: Specifies the member that should be read.  Resets EOF.     *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_FIND &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                      +
               &MEMBER=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &FI_FIND
         LCLC  &L_MEM,&L_LEN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=FI_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Process MEMBER and call function.
.*
         AIF   ('&MEMBER' EQ '').REQUIRED
&L_MEM   SETC  '&MEMBER(1)'
         AIF   (N'&MEMBER EQ 1).DFLTLEN
         AIF   (N'&MEMBER EQ 2).LENSPEC
         AGO   .ERRMEM
.DFLTLEN ANOP
&L_LEN   SETC  '=A(L''&L_MEM)'
         AGO   .CALL
.LENSPEC ANOP
&L_LEN   SETC '&MEMBER(2)'
.CALL    CALLX &#_IDEPA,(&#_IDTKN,&FI_FIND,                            +
               &L_MEM,&L_LEN)
         AIF   ('&#_IDEMC' EQ '').NO_EMC
         &#_IDEMC.
         MEXIT
.ERRMEM  MNOTE 'MEMBER required.'
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_OS_INFO                                                 *
* Purpose: Generate OS-specific information for an allocation.  The   *
*          macro actually generates SVC 99 textunits for the various  *
*          parameters that it supports.  The textunit keys are hard-  *
*          coded within the macro, so that the caller doesn't have to *
*          include IEFZB4D2 in his code.  FI_OS_INFO and the OS file  *
*          handler currently support 'unit', 'volume' and 'directory  *
*          blocks' as OS_specific file creation parameters.           *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         FI_OS_INFO  &UNIT=,                                           *
               &DDNAME=,                                               *
               &DIRBLKS=,                                              *
               &FREE=,                                                 *
               &SPIN=,                                                 *
               &SYSOUT=,                                               *
               &VOLUME=,                                               *
               &PL=,                                                   *
               &DS=
         LCLA  &L
         AIF   ('&PL' EQ '').PLREQD
.*--------------------------------------------------------------------*
.* First, generate the textunits for the parms we support now.
.*--------------------------------------------------------------------*
           LCLB  &F_UNIT,&F_VOLUME,&F_DIRBLKS
           LCLB  &F_SYSOUT,&F_FREE,&F_SPIN,&F_DDNAME
&F_UNIT    SETB  ('&UNIT' NE '')
&F_VOLUME  SETB  ('&VOLUME' NE '')
&F_DIRBLKS SETB  ('&DIRBLKS' NE '')
&F_SYSOUT  SETB  ('&SYSOUT' NE '')
&F_FREE    SETB  ('&FREE' NE '')
&F_SPIN    SETB  ('&SPIN' NE '')
&F_DDNAME  SETB  ('&DDNAME' NE '')
.*
.UNIT        AIF   (NOT &F_UNIT).END_UNIT
             MVC   ##FI_OS_UNIT_&SYSNDX.(6),=X'001500010008'
             AIF   ('&UNIT'(1,1) EQ '''').UNITLIT
             MVC   ##FI_OS_UNIT_&SYSNDX.+6(8),&UNIT
             AGO   .END_UNIT
.UNITLIT     MVC   ##FI_OS_UNIT_&SYSNDX.+6(8),=CL8&UNIT
.END_UNIT    ANOP
.*
.VOLUME      AIF   (NOT &F_VOLUME).END_VOLUME
             MVC   ##FI_OS_VOLUME_&SYSNDX.(6),=X'001000010006'
             AIF   ('&VOLUME'(1,1) EQ '''').VOLLIT
             MVC   ##FI_OS_VOLUME_&SYSNDX.+6(6),&VOLUME
             AGO   .END_VOLUME
.VOLLIT      MVC   ##FI_OS_VOLUME_&SYSNDX.+6(6),=CL6&VOLUME
.END_VOLUME  ANOP
.*
.DDNAME      AIF   (NOT &F_DDNAME).END_DDNAME
             MVC   ##FI_OS_DDNAME_&SYSNDX.(6),=X'000100010008'
             AIF   ('&DDNAME'(1,1) EQ '''').DDNAMELIT
             MVC   ##FI_OS_DDNAME_&SYSNDX.+6(8),&DDNAME
             AGO   .END_DDNAME
.DDNAMELIT   MVC   ##FI_OS_DDNAME_&SYSNDX.+6(8),=CL8&DDNAME
.END_DDNAME  ANOP
.*
.DIRBLKS     AIF   (NOT &F_DIRBLKS).END_DIRBLKS
             MVC   ##FI_OS_DIRBLKS_&SYSNDX.(6),=X'000C00010003'
             AIF   (T'&DIRBLKS  EQ 'N').DIRLIT
             MVC   ##FI_OS_DIRBLKS_&SYSNDX.+6(3),&DIRBLKS
             AGO   .END_DIRBLKS
.DIRLIT      MVC   ##FI_OS_DIRBLKS_&SYSNDX.+6(3),=AL3(&DIRBLKS)
.END_DIRBLKS ANOP
.*
.SYSOUT      AIF   (NOT &F_SYSOUT).END_SYSOUT
             MVC   ##FI_OS_SYSOUT_&SYSNDX.(6),=X'001800010001'
             AIF   (T'&SYSOUT  EQ 'N').SOLIT
             MVC   ##FI_OS_SYSOUT_&SYSNDX.+6(1),&SYSOUT
             AGO   .END_SYSOUT
.SOLIT       MVC   ##FI_OS_SYSOUT_&SYSNDX.+6(1),=AL3(&SYSOUT)
.END_SYSOUT  ANOP
.*
.FREE        AIF   (NOT &F_FREE).END_FREE
             AIF   ('&FREE' EQ 'END').FREEEND
             AIF   ('&FREE' EQ 'CLOSE').FREECLOSE
             MNOTE 8,'FREE=END|CLOSE.  Value provided invalid.'
             AGO   .END_FREE
.FREEEND     MNOTE *,'FREE=END does not produce any text units.'
.FREECLOSE   MVC   ##FI_OS_FREE_&SYSNDX.(4),=X'001C0000'
.END_FREE    ANOP
.*
.SPIN        AIF   (NOT &F_SPIN).END_SPIN
             AIF   ('&SPIN' EQ 'UNALLOC').SPINUNALC
             AIF   ('&SPIN' EQ 'NO').SPINNO
             MNOTE 8,'SPIN=UNALLOC|NO. Value provided invalid.'
.SPINUNALC   MVC   ##FI_OS_SPIN_&SYSNDX.(7),=X'80130001000180'
             AGO   .END_SPIN
.SPINNO      MVC   ##FI_OS_SPIN_&SYSNDX.(7),=X'80130001000140'
.END_SPIN    ANOP
.*--------------------------------------------------------------------*
.* Generate the PWA fields that the textunits will be built in.
.*--------------------------------------------------------------------*
.GENPWA                  PWA   TYPE=PARTIAL
                         AIF   (NOT &F_UNIT).PWA_E_UNIT
##FI_OS_UNIT_&SYSNDX     DS    CL14
.PWA_E_UNIT              ANOP
                         AIF   (NOT &F_VOLUME).PWA_E_VOLUME
##FI_OS_VOLUME_&SYSNDX   DS    CL12
.PWA_E_VOLUME            ANOP
                         AIF   (NOT &F_DDNAME).PWA_E_DDNAME
##FI_OS_DDNAME_&SYSNDX   DS    CL9
.PWA_E_DDNAME            ANOP
                         AIF   (NOT &F_DIRBLKS).PWA_E_DIRBLKS
##FI_OS_DIRBLKS_&SYSNDX  DS    CL9
.PWA_E_DIRBLKS           ANOP
                         AIF   (NOT &F_SYSOUT).PWA_E_SYSOUT
##FI_OS_SYSOUT_&SYSNDX   DS    CL7
.PWA_E_SYSOUT            ANOP
                         AIF   (NOT &F_FREE).PWA_E_FREE
##FI_OS_FREE_&SYSNDX     DS    CL4
.PWA_E_FREE              ANOP
                         AIF   (NOT &F_SPIN).PWA_E_SPIN
##FI_OS_SPIN_&SYSNDX     DS    CL7
.PWA_E_SPIN              ANOP
.PWAEND                  ENDPWA  ,
.*--------------------------------------------------------------------*
.* Now, generate the parmlist that will point to them.
.*--------------------------------------------------------------------*
.GENPLIST      ANOP ,
               ##PLIST START,PL=&PL,DS=&DS
               AIF     ('&UNIT' EQ '').GEN_E_UNIT
               ##PLIST PARM,##FI_OS_UNIT_&SYSNDX
.GEN_E_UNIT    ANOP
               AIF     ('&VOLUME' EQ '').GEN_E_VOLUME
               ##PLIST PARM,##FI_OS_VOLUME_&SYSNDX
.GEN_E_VOLUME  ANOP
               AIF     ('&DDNAME' EQ '').GEN_E_DDNAME
               ##PLIST PARM,##FI_OS_DDNAME_&SYSNDX
.GEN_E_DDNAME  ANOP
               AIF     ('&DIRBLKS' EQ '').GEN_E_DIRBLKS
               ##PLIST PARM,##FI_OS_DIRBLKS_&SYSNDX
.GEN_E_DIRBLKS ANOP
               AIF     ('&SYSOUT' EQ '').GEN_E_SYSOUT
               ##PLIST PARM,##FI_OS_SYSOUT_&SYSNDX
.GEN_E_SYSOUT  ANOP
               AIF     ('&FREE' EQ '').GEN_E_FREE
               ##PLIST PARM,##FI_OS_FREE_&SYSNDX
.GEN_E_FREE    ANOP
               AIF     ('&SPIN' EQ '').GEN_E_SPIN
               ##PLIST PARM,##FI_OS_SPIN_&SYSNDX
.GEN_E_SPIN    ANOP
               ##PLIST END,VL
.EXIT    MEXIT
.PLREQD  MNOTE 8,'PL= is a required parameter on the FI_OS_INFO macro.'
         MEXIT
         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   FI_PARMLIST                                                *
* Purpose: Generate mapping fields for the parameters accepted by the *
*          File Handler.                                              *
*                                                                     *
*---------------------------------------------------------------------*
                  MACRO
&LABEL            FI_PARMLIST &DSECT=YES
                  LCLC  &NAME
&NAME             SETC  'FI_PARMLIST'
                  AIF   ('&LABEL' EQ '').PAST_LABEL
&NAME             SETC  '&LABEL'
.PAST_LABEL       ANOP
                  AIF   ('&DSECT' EQ 'YES').GEN_DSECT
&NAME             DS    0F         | File Handler Parameter List:
                  AGO .GEN_FIELDS
.GEN_DSECT        ANOP
&NAME             DSECT            | File Handler Parameter List:
.GEN_FIELDS       ANOP ,           |
FI_FILEID         DS  A            |   Token := PWA Base Address.
FI_FUNCTIONCODE   DS  A            |   Function to be performed.
FI_SPECIFIC       EQU *            |   Function-specific parameters.
                  ORG FI_SPECIFIC  |   FI_START parameters:
FI_ESV            DS  A            |     Environment support vector.
FI_INFO           DS  A            |     Information (not used).
FI_FILENAME       DS  A            |     Text of file's name.
FI_NAMELENGTH     DS  A            |     Length of file's name.
FI_OPTIONS        DS  A            |     Option codes.
FI_START_MIN_#_PARMS EQU (*-&NAME.)/4
*                                  | *** The following parameters are
*                                  |     optional FI_START parameters,
*                                  |     and only apply when OPTIONS=
*                                  |     OUTPUT is used.
*                                  |   * Record lengths: If AVG is the
*                                  |     only reclen specified, or AVG
*                                  |     and MAX are both present and
*                                  |     equal, RECFM will be FB: else,
*                                  |     RECFM=VB with LRECL=MAX.
FI_AVG_RECLEN     DS  A            |       Avg. record length.
FI_MAX_RECLEN     DS  A            |       Max. record length
*                                  |   * File sizes: If INITIAL is pre-
*                                  |     sent, INITIAL * MAX_RECLEN is
*                                  |     used to derive primary extent
*                                  |     size.  INCREMENT, is present,
*                                  |     is used similarly to determine
*                                  |     secondary extent size.
FI_SIZE_INITIAL   DS  A            |       Estimated initial # records
FI_SIZE_INCREMENT DS  A            |       Estimated incremental # recs
FI_REFERENCE      DS  A            |     Reference string.
FI_START_MAX_#_PARMS EQU (*-&NAME.)/4
                  ORG FI_SPECIFIC  |   FI_GET_INFO parameters:
FI_GI_FUNCTION    DS  A            |     Information sub-code.
FI_GI_AREA        DS  A            |     Area to return information.
FI_GI_AREA_SIZE   DS  A            |     Length of return area.
FI_GI_LENGTH      DS  A            |     Length of returned info.
                  ORG FI_SPECIFIC  |   FI_SET_STATUS parameters:
FI_SS_FUNCTION    DS  A            |     Status sub-code.
FI_SS_AREA        DS  A            |     Area to return information.
FI_SS_AREA_SIZE   DS  A            |     Length of return area.
FI_SS_LENGTH      DS  A            |     Length of returned info.
                  ORG FI_SPECIFIC  |   FI_GET_REFERENCE parameters:
FI_GR_REFERENCE   DS  A            |     Status sub-code.
                  ORG FI_SPECIFIC  |   FI_READLINE parameters:
FI_RL_AREA        DS  A            |     Target area for reading line.
FI_RL_AREA_SIZE   DS  A            |     Length of target area.
FI_RL_LENGTH      DS  A            |     Length of line just read.
                  ORG FI_SPECIFIC  |   FI_READLINE_LOCATE parms.
FI_RLL_ADDRESS    DS  A            |     Address of line just read.
                  ORG FI_SPECIFIC  |   FI_WRITELINE parameters:
FI_WL_LINE        DS  A            |     Text of output line.
FI_WL_LENGTH      DS  A            |     Length of output line.
                  ORG FI_SPECIFIC  |   FI_FIND parameters:
FI_FD_MEMBER      DS  A            |     Member name.
FI_FD_LENGTH      DS  A            |     Length of member name.
                  ORG FI_SPECIFIC  |   FI_OPEN parameters:
FI_OP_OPTIONS     DS  A            |     Option codes.
                  ORG ,            | Adjust to final parmlist offset.
&NAME._L          EQU *-&NAME.     | Length of File Handler Parmlist.
                  MEND
