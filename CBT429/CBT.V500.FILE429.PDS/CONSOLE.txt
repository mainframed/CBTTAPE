* ----------------------------------------------------------------- *
* THESE  ARE TWO ROUTINES THAT WILL GIVE THE TSO USER FULL CONSOLE  *
* SUPPORT.  IT CAN ME MODIFIED TO RUN XA.                           *
* GIVE THIS COMMAND TO THE GENERAL USER AND YOU HAVE JUST GIVEN UP  *
* CONTROL OF YOUR SYSTEM.                                           *
* ----------------------------------------------------------------- *
DCMS     TITLE 'C O N S O L E - DISPLAY CONSOLE SUPPORT FOR DCMS '
         MACRO
&NAME    PFSELECT &BYTE,&EXIT,&ROUTINE,&DUMMY=NOPFDEF
         LCLA  &I
         LCLC  &C
.*  MACRO - PFSELECT - SELECT A ROUTINE BASED UPON PFK INPUT
.*
.*  CALL SEQUENCE -
.*  NAME PFSELECT BYTE,EXIT-ROUTINE,(ROUTINES,...),DUMMY=DUMMYEXIT
.*  BYTE         - A VALID RX ADDRESS OF THE 3270 AID BYTE
.*  EXIT-ROUTINE - A VALIDRX ADDRESS OF AN EXIT TO  TAKE IF 'BYTE' DOES
.*                 NOT CONTAIN  A  VALID AID ( PF1 - PF12, AND  ENTER )
.*  ROUTINES     - VALID RX ADDRESS OR  NULL , ADDRESS  OF  ROUTINE  TO
.*                 BRANCH  TO  FOR EACH OF THE PF ENTRIES, THERE CAN BE
.*                 UP  TO  THIRTEEN VALID ADDRESSES, FOR THE 12 PF KEYS
.*                 AND THE THIRTEENTH BEING 'ENTER'
.*  DUMMY        - A VALID RX ADDRESS OF AN EXIT TO TAKE IF THERE IS NO
.*                 'ROUTINE' ENTRY FOR THAT PFKEY
.*
.*  EXAMPLE:
.*
.*  SELECT ROUTINE 'HELP' WHEN PF1 IS HIT, AND 'PRINT' WHEN PF4 IS HIT,
.*  WITH ALL OTHER ENTRIES GOING TO 'IGNORE', AID BYTE IS IN IOCBAID.
.*
.*
.*       PFSELECT IOCBAID,IGNORE,(HELP,,,PRINT),DUMMY=IGNORE
.*
.*
&NAME    DS    0H
         CLI   &BYTE,X'7A'         CHECK FOR A PFK
         BL    &EXIT               ...
         CLI   &BYTE,X'F9'         ...
         BH    &EXIT               ...
&I       SETA  1
         XR    R1,R1               GET SET FOR IC
         IC    R1,&BYTE
         LA    R0,15
         NR    R1,R0               ISOLATEINDEXBYTE
         SLL   R1,2                MULTIPLY * 4 USEFUL INDEX
         B     *(R1)               GO TO IT (THE ROUTINE THAT IS )
&I       SETA  1
.X1      ANOP
&C       SETC  '&DUMMY'
         AIF   ('&ROUTINE(&I)' EQ '').XX
&C       SETC  '&ROUTINE(&I)'
.XX      ANOP
         B     &C
&I       SETA  &I+1
         AIF   (&I LT 13).X1
         B     &DUMMY
         MEND
         MACRO
&NAME    SFMT  &BEEP=NO,&RESTORE=YES,&RESET=YES
         GBLA  &SFCOL,&SFROW,&SFLEN,&SFCNT
         GBLA  &SFLTBL(200),&SFSTRT(20),&SFEND(20),&SFFCT,&SFNCT
         GBLB  &SFNUM(200),&SFFLAG,&SFCUR
         GBLC  &SFFNAM(200),&SFNAM(20)
         GBLC  &SFENAM
         LCLB  &BP,&RR,&RS
         AIF   (&SFFLAG).E1
         AIF   (T'&NAME EQ 'O').E2
&SFFLAG  SETB  1
&SFNCT   SETA  &SFNCT+1
         AIF   (&SFNCT GT 20).ERR
&SFNAM(&SFNCT) SETC '&NAME'
&SFSTRT(&SFNCT) SETA &SFFCT+1
         AIF   ('&BEEP' EQ 'NO' OR '&BEEP' EQ 'YES').BEEPOK
         MNOTE 4,' BEEP=&BEEP ASSUMED TO MEAN BEEP=YES'
.BEEPOK  ANOP
&BP      SETB  ('&BEEP' NE 'NO')
         AIF   ('&RESTORE' EQ 'NO' OR '&RESTORE' EQ 'YES').RSTROK
         MNOTE 4,' RESTORE=&RESTORE ASSUMED TO MEAN RESTORE=NO'
.RSTROK  ANOP
&RR      SETB  ('&RESTORE' EQ 'YES')
         AIF   ('&RESET' EQ 'NO' OR '&RESET' EQ 'YES').RSTOK
         MNOTE 4,' RESET=&RESET ASSUMED TO MEAN RESET=NO'
.RSTOK   ANOP
&RS      SETB  ('&RESET' EQ 'YES')
&SFENAM  SETC  'SF&SYSNDX'
&NAME    DC    Y(L&SFENAM,&SFENAM)          LENGTHS
         DC    BL2'00000&BP&RR&RS.00000000' FLAGS
&SFCUR   SETB  0
&SFCNT   SETA  0
&SFLEN   SETA  0
&SFROW   SETA  1                  TOP OF SCREEN
&SFCOL   SETA  2                  POSITION 1 IS AN ATTRIBUTE BYTE
         MEXIT
.E1      MNOTE 8,'OUT OF SEQUENCE'
         MEXIT
.E2      MNOTE 8,'FORMAT NAME REQUIRED'
         MEXIT
.ERR     MNOTE 12,'*** TOO MANY DIFFERENT FORMATS ***'
         MEND
         MACRO
         SFEND
         GBLA  &SFLEN,&SFCNT
         GBLA  &SFLTBL(200),&SFSTRT(20),&SFEND(20),&SFFCT,&SFNCT
         GBLB  &SFNUM(200),&SFFLAG,&SFCUR
         GBLC  &SFFNAM(200),&SFNAM(20)
         GBLC  &SFENAM
         LCLA  &T
         AIF   (&SFFLAG).INITOK
         MNOTE 8,'OUT OF SEQUENCE'
         MEXIT
.INITOK  ANOP
&SFFLAG  SETB  0
&SFEND(&SFNCT) SETA &SFFCT
L&SFENAM EQU   &SFLEN             TOTAL STORAGE REQUIRED FOR IMAGE
&T       SETA  8*&SFCNT+6
&SFENAM  EQU   &T                 TOTAL LENGTH OF FORMAT TABLE
         MEND
         MACRO
&NAME    TRMIO &BLOCK,&TYPE,&FORMAT=,&IMAGE=,&RESTORE=,&RESET=,&BEEP=, X
               &CURSOR=,&WAIT=YES,&ADDR=
         LCLB  &M(8),&A(8)
         AIF   (T'&BLOCK NE 'O').INITOK
         MNOTE 8,' FIRST OPERAND MISSING'
         MEXIT
.INITOK  ANOP
&NAME    IHBINNRA &BLOCK
         AIF   (T'&FORMAT EQ 'O').NOF
         IHBINNRA ,&FORMAT
         ST    0,0(,1)            SET NEW FORMAT
.NOF     AIF   (T'&IMAGE EQ 'O').NOI
         LA    0,&IMAGE
         ST    0,4(,1)            SET NEW IMAGE AREA
.NOI     ANOP
         AIF   (T'&TYPE EQ 'O' OR '&TYPE' EQ 'CONV').ETYP
         AIF   ('&TYPE' NE 'READ').TY1
&M(1)    SETB  1
         AGO   .ETYP
.TY1     AIF   ('&TYPE' NE 'WRITE').TY2
&M(2)    SETB  1
         AGO   .ETYP
.TY2     AIF   ('&TYPE' NE 'WAIT').TY3
&M(1)    SETB  1
&M(2)    SETB  1
         AGO   .ETYP
.TY3     AIF   ('&TYPE' NE 'NEWFMT').TY4
&M(1)    SETB  1
&M(2)    SETB  1
&M(3)    SETB  1
         AGO   .ETYP
.TY4     MNOTE 8,' SECOND ARGUMENT (&TYPE) INVALID, CONV ASSUMED'
.ETYP    ANOP
         AIF   ('&WAIT' EQ 'YES').EWT
         AIF   (&M(1) AND &M(2)).WAITER
&M(3)    SETB  1
         AIF   ('&WAIT' EQ 'NO').EWT
         MNOTE 4,' WAIT=&WAIT ASSUMED TO MEAN WAIT=NO'
         AGO   .EWT
.WAITER  MNOTE 4,'WAIT=&WAIT SHOULD NOT BE CODED WITH THIS TYPE CALL'
.EWT     ANOP
         AIF   (T'&CURSOR EQ 'O').ECUR
&M(4)    SETB  1
         AIF   ('&CURSOR'(1,1) EQ '(').REGCUR
         LH    0,&CURSOR
         STH   0,12(,1)           SET THE CURSOR POSITION
         AGO   .ECUR
.REGCUR  STH   &CURSOR,12(,1)     SET THE NEW CURSOR POSITION
.ECUR    ANOP
         AIF   (T'&BEEP NE 'O').YBEEP
&M(6)    SETB  1
         AGO   .EBEEP
.YBEEP   AIF   ('&BEEP' EQ 'NO').EBEEP
         AIF   ('&BEEP' EQ 'YES').DOBEEP
         MNOTE 4,' BEEP=&BEEP ASSUMED TO MEAN BEEP=YES'
.DOBEEP  ANOP
&A(6)    SETB  1
.EBEEP   ANOP
         AIF   (T'&RESTORE NE 'O').YRST
&M(7)    SETB  1
         AGO   .ERST
.YRST    AIF   ('&RESTORE' EQ 'NO').ERST
         AIF   ('&RESTORE' NE 'YES').BRST
&A(7)    SETB  1
         AGO   .ERST
.BRST    MNOTE 4,' RESTORE=&RESTORE ASSUMED TO MEAN RESTORE=NO'
.ERST    ANOP
         AIF   (T'&RESET NE 'O').YRES
&M(8)    SETB  1
         AGO   .ERES
.YRES    AIF   ('&RESET' EQ 'NO').ERES
         AIF   ('&RESET' EQ 'YES').DORES
         MNOTE 4,' RESET=&RESET ASSUMED TO MEAN RESET=NO'
         AGO   .ERES
.DORES   ANOP
&A(8)    SETB  1
.ERES    ANOP
         MVI   14(1),B'&M(1)&M(2)&M(3)&M(4)&M(5)&M(6)&M(7)&M(8)'  MASK
         AIF   (&M(6) AND &M(7) AND &M(8)).CALLIO
         MVI   15(1),B'00000&A(6)&A(7)&A(8)'       WCC
.CALLIO  ANOP
         AIF   ('&ADDR' EQ '').VCON
         AIF   ('&ADDR'(1,1) EQ '(').REGER
         L     15,&ADDR            LOAD ADDRESS OF TERMIO
         AGO   .BALR
.REGER   LR    15,&ADDR(1)         LOAD ADDRESS OF TERMIO
         AGO   .BALR
.VCON    L     15,=V(TERMIO#)      LOAD ADDRESS OF TERMIO
.BALR    BALR  14,15
         MEND
         MACRO
&NAME    IOCB
&NAME    DS    0F
IOCBFMT  DS    A
IOCBIMG  DS    A
IOCBDECB DS    A
IOCBCUR  DS    H                  CURSOR OFFSET FROM START OF IMAGE
IOCBFLGS DS    X
IOCBFNWR EQU   X'80'              FLAG FOR NO WRITE
IOCBFNRD EQU   X'40'              FLAG FOR NO READ
IOCBFW8  EQU   X'C0'              FLAGS FOR WAIT (CHECK) ONLY
IOCBFNWT EQU   X'20'              FLAG FOR NO WAIT
IOCBFCUR EQU   X'10'              FLAG FOR CURSOR ADDRESS SPECIFIED
IOCBFNBP EQU   X'04'              FLAG FOR BEEP NOT OVERRIDDEN
IOCBFNRR EQU   X'02'              FLAG FOR RESTORE NOT OVERRIDDEN
IOCBFNRS EQU   X'01'              FLAG FOR RESET NOT OVERRIDDEN
IOCBAID  EQU   IOCBFLGS           AID RETURNED AFTER READ
AIDENT   EQU   X'7D'              ENTER KEY AID
AIDPF1   EQU   X'F1'
AIDPF2   EQU   X'F2'
AIDPA1   EQU   X'6C'
AIDPA2   EQU   X'6E'
AIDCAN   EQU   AIDPA2
AIDPA3   EQU   X'6B'
AIDCLR   EQU   X'6D'
IOCBWCC  DS    X                  WRITE CONTROL CHARACTER
IOCBWBP  EQU   X'04'              BEEP
IOCBWRR  EQU   X'02'              WCC RESTORE
IOCBWRS  EQU   X'01'              WCC RESET MDT
         MEND
         MACRO
&NAME    FIELD &LEN,&TYPE,&INTEN=,                                     X
               &MDT=OFF,&CURSOR=NO,&ROW=,&COLUMN=,                     X
               &INTRAN=YES,&OUTTRAN=YES
         GBLA  &SFCOL,&SFROW,&SFLEN,&SFCNT
         GBLA  &SFLTBL(200),&SFSTRT(20),&SFEND(20),&SFFCT,&SFNCT
         GBLB  &SFNUM(200),&SFFLAG,&SFCUR
         GBLC  &SFFNAM(200),&SFNAM(20)
         LCLA  &I,&J,&K
         AIF   (&SFFLAG).INITOK
         MNOTE 8,'OUT OF SEQUENCE'
         MEXIT
.INITOK  ANOP
         AIF   (T'&LEN NE 'N').E1
         AIF   (&LEN LT 1 OR &LEN GT 1900).E1
         AIF   ('&CURSOR' EQ 'NO' OR '&CURSOR' EQ 'YES' OR '&CURSOR' EQX
                'AFTER').CUROK
         MNOTE 4,'CURSOR=&CURSOR ASSUMED TO MEAN CURSOR=YES'
.CUROK   AIF   ('&CURSOR' EQ 'NO').NOCUR
         AIF   (NOT &SFCUR).FIRSTC
         MNOTE 4,' ONLY ONE FIELD MAY HAVE A CURSOR IN IT'
         AGO   .NOCUR
.FIRSTC  ANOP
&SFCUR   SETB  1
         AIF   ('&CURSOR' EQ 'AFTER').CURAFT
&I       SETA  128                FLAGS (CURSOR IN FIELD)
         AGO   .ENDCUR
.CURAFT  ANOP                     FLAGS (CURSOR AFTER DATA IN FIELD)
&I       SETA   128+64
         AGO   .ENDCUR
.NOCUR   ANOP                     FLAGS (NO CURSOR)
&I       SETA  0
.ENDCUR  ANOP
         AIF   ('&INTRAN' EQ 'YES').NOINT
&I       SETA  &I+1               FLAGS (NO TRANSLATE INPUT)
.NOINT   AIF   ('&OUTTRAN' EQ 'YES').NOOUTT
&I       SETA  &I+2               FLAGS (NO TRANSLATE OUTPUT)
.NOOUTT  ANOP
         DC    AL1(&I)            FLAGS (CURSOR, TRANSLATE)
         AIF   (T'&TYPE EQ 'O' OR '&TYPE' EQ 'DISPLAY').DISP
         AIF   ('&TYPE' EQ 'ALPHA').ALPHA
         AIF   ('&TYPE' EQ 'NUMERIC').NUM
         MNOTE 8,' INVALID SECOND ARGUMENT (&TYPE) IGNORED'
         AGO   .DISP
.NUM     ANOP
&I       SETA  16
.ALPHA   AIF   (T'&INTEN NE 'O').CKINT
&I       SETA  &I+4
         AGO   .EINT
.DISP    ANOP
&I       SETA  48
         AIF   (T'&INTEN NE 'O').CKINT
&I       SETA  56
         AGO   .EINT
.CKINT   AIF   ('&INTEN' NE 'OFF').INT1
&I       SETA  &I+12
         AGO   .EINT
.INT1    AIF   ('&INTEN' NE 'LO').INT2
&I       SETA  &I+4
         AGO   .EINT
.INT2    AIF   ('&INTEN' EQ 'HI').INT3
         MNOTE 4,' INTEN=&INTEN ASSUMED TO MEAN INTEN=HI'
.INT3    ANOP
&I       SETA  &I+8
.EINT    ANOP
         AIF   ('&MDT' EQ 'OFF' OR '&MDT' EQ 'ON').MDTOK
         MNOTE 4,' MDT=&MDT ASSUMED TO MEAN MDT=ON'
.MDTOK   AIF   ('&MDT' EQ 'OFF').EMDT
&I       SETA  &I+1
.EMDT    ANOP
&J       SETA  &I-(&I/16)*16
&I       SETA  &I+64
         AIF   (&J GT 9 OR &J EQ 0 OR &I EQ 97).SPEC
&I       SETA  &I+128
.SPEC    DC    AL1(&I)            ATTRIBUTE BYTE
.*
.*       NOW WE MUST FIND THE COLUMN AND ROW THAT THE DATA START IN.
.*       NOTE THAT THE BYTE IN FRONT OF THERE MUST BE FREE FOR THE
.*             ATTRIBUTE BYTE.
.*
&I       SETA  &SFROW
         AIF   (T'&ROW EQ 'O').NOROW
         AIF   (T'&ROW EQ 'N').ROWOK
.BADROW  MNOTE 8,' INVALID ROW=&ROW IGNORED'
&I       SETA  &SFROW
         AGO   .NOROW
.ROWOK   ANOP
         AIF   (&I LT 1 OR &I GT 24).BADROW
&I       SETA  &ROW
         AIF   (&I EQ &SFROW).NOROW
         AIF   (&I GT &SFROW).NEWROW
         MNOTE 8,' ROW=&ROW SPECIFIES ROW ABOVE CURRENT ROW (&SFROW)'
&I       SETA  &SFROW
         AGO   .NOROW
.NEWROW  ANOP
&SFCOL   SETA  1
.NOROW   ANOP
&J       SETA  &SFCOL
         AIF   (T'&COLUMN EQ 'O').NOCOL
         AIF   (T'&COLUMN EQ 'N').COLOK
.BADCOL  MNOTE 8,' INVALID COLUMN=&COLUMN IGNORED'
&J       SETA  &SFCOL
         AGO   .NOCOL
.COLOK   ANOP
&J       SETA  &COLUMN
         AIF   (&J LT 1 OR &J GT 80).BADCOL
         AIF   (&J GE &SFCOL).NOCOL
         AIF   (T'&ROW EQ 'O').BUMPROW
         MNOTE 8,' COLUMN=&COLUMN CAUSES FIELD OVERLAP'
&J       SETA  &SFCOL
         AGO   .NOCOL
.BUMPROW ANOP
&I       SETA  &I+1
.NOCOL   ANOP
         MNOTE *,' &LEN BYTE FIELD IN ROW &I COLUMN &J'
&K       SETA  (&I-1)*80+&J-1
         DC    Y(&K,&SFLEN,&LEN)  BUFF ADDR, IMAGE OFFSET, LENGTH
&SFROW   SETA  &I
&SFCOL   SETA  &J+&LEN+1
.RCTST   AIF   (&SFCOL LE 80).RCUPD
&SFROW   SETA  &SFROW+1
&SFCOL   SETA  &SFCOL-80
         AGO   .RCTST
.RCUPD   ANOP
&SFLEN   SETA  &SFLEN+&LEN
&SFCNT   SETA  &SFCNT+1
&SFFCT   SETA  &SFFCT+1
         AIF   (&SFFCT GT 200).ERR
&SFLTBL(&SFFCT) SETA &LEN
&SFNUM(&SFFCT) SETB ('&TYPE' EQ 'NUMERIC')
&SFFNAM(&SFFCT) SETC '&NAME'
         MEXIT
.E1      MNOTE 8,'INVALID LENGTH SPECIFIED'
         MEXIT
.ERR     MNOTE 12,'*** TOO MANY FIELDS TOTAL IN ALL FORMATS ***'
         MEND
         MACRO
         IEERDCM
*     01/15/73          LEVEL=05                              MB Y02958
DCMTSRT  DSECT DCMTSPTR
DCMADTRN DS    A                   POINTER TO PAGABLE DCM
         DS    CL1                 RESERVED
DCMRFLGS DS    BL1                 FLAGS
DCMDOM   EQU   X'10'               DOM MUST BE TRIED
DCMNIPP  EQU   X'08'               DCM WAS USED BY NIP
DCMLEN   DS    H                   LENGTH OF PAGABLE DCM
DCMADKP  DS    A                   ADDRESS OF ROUTED K COMMAND
*                                   PARAMETER LIST
DCMTOPAR DS    CL1                 TOP DISPLAY AREA DEFINED
DCMTOPDS DS    CL1                 TOP DISPLAY ON SCREEN
         DS    BL1                 RESERVED
DCMDEVTY DS    BL1                 DEVICE TYPE FLAGS
DCMTY60  EQU   X'80'               USABLE FOR SD
DCMTY50  EQU   X'40'               NOT USABLE FOR SD
DCMADSDS DS    A                   POINTER TO FIRST SDS SUPPORT AREA
DCMRMS   DS    CL1                 NUMBER OF CCWS TO WRITE
DCMADRMS DS    AL3                 POINTER TO RMS CCWS
DCMWLAST DS    A                   PT CON Q ENTRY LAST OUT (O-O-L)
DCMRMSAL DS    H                   NUMBER LINES IN MSG AREA
DCMDOMKY DS    H                   CONSOLE DOM ELEMENT        MC XM5812
DCMSUBAD DS    A                   POINTER TO SUB CONTROL BLOCK
DCMADPFK DS    A                   POINTER TO RESIDENT PFK AREA
DCMINTVL DS    H                   INTERVAL FOR THIS DCM
DCMTMCTR DS    H                   TIME COUNTER FOR THIS DCM
DCMR2FLG DS    BL1                 TIMER FLAGS
DCMRXSFL EQU   X'80'               FULL SCREEN FLAG
DCMRXUNV EQU   X'40'               UNVIEWABLE MESSAGE DISPLAYED
DCMRXTMR EQU   X'20'               TIMER FLAG
DCMRXRLL EQU   X'10'               READY TO ROLL
DCMRXDEL EQU   X'08'               PENDING DELETE REQUEST
DCMRXTIM EQU   X'02'               TIMER ELAPSED FOR THIS DISPLAY
DCMR3FLG DS    BL1                 MISC FLAGS
DCMSTSWT EQU   X'80'               CHANGING STATUS OF OUTPUT ONLY CON
DCMKVIP  EQU   X'40'               ENTRY FOR K VARY COMMAND
DCMCLPR  EQU   X'20'               CLOSE IN PROCESS
DCMRXSCN EQU   X'10'               ASY ERROR MESSAGE ON SCREEN
DCMR3PKA EQU   X'08'               DA I/O COMPLETE
DCMRXHMT EQU   X'04'               FULL SCREEN SIMULATED      MC YM4102
         DS    H                   RESERVED
DCMRQDEL DS    A                   DELETE REQUEST BUFFER
         DS    A                   DELETE REQUEST BUFFER
DCMMSGSV DS    A                   POINTER TO SAVED NIP MESSAGES
DCMPACB  EQU   *                   SACB PREFIX
DCMPLN   DS    FL2                 SYSGEN LENGTH OF AREA
DCMPLNPR DS    H                   LENGTH OF SACB PREFIX-IN BYTES
DCMPRSZ  EQU   *-DCMPACB           SIZE OF PREFIX
DCMACB   EQU   *                   SACB
DCMACBNX DS    A                   POINTER TO NEXT SACB
DCMAID   DS    CL1                 AREA ID
DCMASACB DS    BL1                 SACB FLAGS
DCMAUSE  EQU   X'80'               AREA PRESENTLY DEFINED     MB Y02958
*    IF DCMAUSE IS OFF, A SYSGEND AREA HAS BEEN FREED E.G. K A,NONE
DCMAGM   EQU   X'40'               GETMAINED SACB
DCMALN   DS    FL2                 LENGTH OF AREA
DCMATOP  DS    FL1                 TOP ROW OF AREA
DCMACLR  EQU   *                   REINITIALIZED PORTION      MB Y02958
DCMAROW  DS    FL1                 ROW TO BE WRITTEN NEXT
DCMAFR   DS    H                   FRAME ON SCREEN
DCMAMJWQ DS    A                   POINTER TO CON Q ENTRY FOR MAJOR
DCMAMIN  DS    A                   POINTER TO MINOR WQE
DCMATIME DS    F                   TIME CONTROL LINE WAS WRITTEN
DCMAMT   DS    XL2                 RESERVED                   MB Y02958
DCMAFLG1 DS    XL1                 AREA FLAGS1
DCMADISP EQU   X'40'               DISPLAY IN AREA
DCMADEND EQU   X'20'               END OF DISPLAY ON SCREEN
DCMAFRPR EQU   X'10'               FRAMING IN PROGRESS
DCMAFULL EQU   X'08'               FRAME FULL
DCMABL   EQU   X'04'               BLANKING TO BE DONE
DCMAFLG2 DS    XL1                 AREA FLAGS 2
DCMALMIN EQU   X'80'               SAVED POINTER TO LAST MINOR OUTPUT
DCMAWCON EQU   X'40'               WRITE CONTROL LINE
DCMARCON EQU   X'20'               REWRITE CONTROL LINE
DCMAMJFR EQU   X'10'               MAJOR WQE HAS BEEN FOUND
DCMADFLG DS    XL1                 DYNAMIC DISPLAY FLAGS      MB Y02958
DCMADD   EQU   X'80'               TRACK IN AREA              MB Y02958
DCMAHOLD EQU   X'40'               TRACK IN HOLD MODE         MB Y02958
DCMACSIB EQU   X'20'               TRACK WITH CONTINUATION LINE IN     *
                                   SCREEN IMAGE BUFFER        MB Y02958
DCMATRCK DS    X                   TRACK REQUEST INDICATORS   MB Y02958
DCMATJOB EQU   X'80'               TRACK JOBS                 MB Y02958
DCMATJBL EQU   X'40'               TRACK JOBS,LIST            MB Y02958
DCMATTS  EQU   X'08'               TRACK TS                   MB Y02958
DCMATTSL EQU   X'04'               TRACK TS,LIST              MB Y02958
DCMATA   EQU   X'88'               TRACK A                    MB Y02958
DCMATAL  EQU   X'44'               TRACK A,LIST               MB Y02958
DCMAUTME DS    XL2                 UTME=NNN VALUE             MB Y02958
DCMATECB DS    F                   TRACK CANCEL ECB ADDRESS   MB Y02958
DCMAPAD  DS    F                   RESERVED                   MB Y02958
DCMACBND EQU   *                   SACB END
DCMCLRLN EQU   *-DCMACLR           LENGTH FOR REINITIALIZING  MB Y02958
DCMACBSZ EQU   *-DCMACB            SACB SIZE
DCMREND  DS    0C                  END OF DCM
         MEND  , */
         MACRO
         IEETDCM
*     12/15/72          LEVEL=04
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*                         WORK AND SAVE AREAS                         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
DCMSTRT  DSECT DCMSTPTR
         DS    0F                  FULL WORD ALIGNMENT
         DS    H                   DCM LENGTH
         DS    H                   PADDING
         SPACE 4
DCMFLG1  DS    BL1                 DCM AREA INDICATORS
         SPACE 2
DCMOUTPT EQU   X'02'               DCM UPDATED FOR OUTPUT ONLY
         SPACE 4
DCMATI   DC    X'00'               SAVED UCB ATTN INDEX      MC SA55058
         DC    AL2(0)              RESERVED                  MC SA55058
         SPACE 2
DCMWTINT DS    A                   DCMWTINT INITIAL VALUE
DCMLNCNT DS    H                   NUMBER OF LINES TO BLANK  MC SA53462
DCMLNNUM DC    X'00'               FIRST LINE TO BLANK       MC SA53462
         DC    X'00'               RESERVED                  MC SA53462
DCMPACK  DS    F                   AREA TO PLACE NUMBER FOR PACKING
DCMCVBIN DS    F                   AREA FOR CONVERSION TO BINARY
         SPACE 2
DCMTIMES DS    BL1                 TIME RTNS INDICATOR BYTE
         SPACE 2
DCMTIMER EQU   X'80'               TIME ELAPSED FOR THIS DISPLAY
DCMOPTTI EQU   X'40'               OPTIONS TO TI RTN
DCMOTTMM EQU   X'10'               OPTIONS OR TI RTNS TO MSG MODULE
DCMTASYN EQU   X'04'               TIMER SET FOR ASYNC ERROR MSG
DCMOCTTI EQU   X'02'               OPEN-CLOSE TO TI RTN
DCMRMTTI EQU   X'01'               ROLL MODE TO TIMER ROUTINE
         EJECT
         DS    XL1                 UNUSED
         SPACE 2
DCMELGN  DS    H                   ENTRY AREA LAST CHARACTER POINTER
         SPACE 2
DCMBUFAD DS    A                   POINTER TO BUFFER ADDRESS TABLE
DCMDOMPK DS    A                   ADDRESS OF FIRST DOM NUMBER
DCMAMTAB DS    A                   ADDRESS OF FIRST SCT ENTRY
DCMADSEC DS    A                   ADDRESS OF FIRST SSCT ENTRY
DCMADDRL DS    A                   ADDRESS OF LAST SCT ENTRY
DCMASCRN DS    A                   POINTER TO SCREEN IMAGE BUFFER
DCMLSCRN DS    A                   POINTER TO LAST BUFFER LINE
DCMWTBUF DS    A                   SCREEN LENGTH POINTER
DCMAINS  DS    A                   POINTER TO INSTRUCTION LINE
DCMAENTR DS    A                   POINTER TO ENTRY AREA
DCMAWARN DS    A                   POINTER TO WARNING LINE
DCMADCHP DS    A                   ADDRESS OF CHANNEL PROGRAM AREA
DCMPFKLN DS    A                   POINTER TO PFK LINE
DCMCXSVE DS    F                   CXSA SAVE AREA
DCMADOPN DS    A                   ADDRESS OF COMMAND OPERAND
DCMDSAV  DS    5F                  SAVE AND WORK AREA
         SPACE 2
*           INPUT BUFFER FOR ISSUING SVC 34 AND SVC 35                *
*           FIELDS DCMWQEXP THROUGH DCMINPUT MUST REMAIN IN ORDER     *
DCMWQEXP DS    0F                  ENSURE FULL WORD BOUNDARY
DCMINLGN DS    H                   FIELD FOR INPUT LENGTH
DCMMCSFL DS    H                   MCS FLAGS FIELD
DCMINPUT DS    32F                 INPUT MESSAGE TEXT
         SPACE 2
DCMLGNTH DS    H                   LENGTH OF A LINE
DCMBAINC DS    H                   ADDRESS TO INSERT CURSOR
DCMIRCTR DS    H                   INTERVENTION REQ'D MSG COUNTER
DCMBADLN DS    H                   BUFFER ADDR TO BEGIN MSG WRITE
DCMBYTCT DS    H                   NUMBER OF BYTES TO WRITE
DCMADNUM DS    H                   NEXT LINE NUMBER
DCMAXLGN DS    H                   MAXIMUM LINE LENGTH
DCMMSGAL DS    H                   NUMBER OF LINES IN MESSAGE AREA
DCMRMINC DS    H                   INCREMENT INTO RMI
DCMSCTCN DS    H                   LENGTH OF ONE SCT ENTRY
DCMCORLN DS    H                   LENGTH OF DCM LINE IN CORE
         DS    H                   TIME COUNTER
DCMPFKNM DS    XL1                 NUMBER OF KEY BEING PROCESSED
DCMPFKKN DS    XL1                 LIST KEY NUMBER
         EJECT
DCMDEL   DS    CL2                 DEL VALUE
DCMCON   DS    CL1                 CON VALUE
DCMSEG   DS    FL1                 SEG VALUE
DCMDL    DS    FL1                 DISPLAY AREA OPTION
DCMRNUM  DS    FL1                 ROLL NUMBER VALUE
DCMRTME  DS    H                   ROLL TIME VALUE
         SPACE 2
*  DEFAULT VALUES FOR OPTIONS
DCMSEGDF DS    FL1                 SEG DEFAULT
DCMRNUMD DS    FL1                 RNUM DEFAULT
DCMRTMED DS    H                   RTME DEFAULT
         SPACE 2
DCMASKEN DS    XL1                 ENTER MASK
DCMASKCN DS    XL1                 CANCEL MASK
DCMASKCR DS    XL1                 CURSOR MASK
DCMASKLP DS    XL1                 LIGHT PEN MASK
DCMASKPF DS    XL1                 PFK MASK
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*                         COMMUNICATIONS AREA                         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
DCMOPTST DS    BL1                 STATUS OF SCREEN CONTROL OPTIONS
         SPACE 2
DCMOPTVR EQU   X'80'               DELETE VERIFICATION  CON=(Y=1,N=0)
DCMOPTAD EQU   X'40'               AUTOMATIC DELETION   DEL=(Y=1,N=0)
DCMOPTSG EQU   X'20'               DEFAULT SEGMENT SPECIFIED  SEG=(0=0)
DCMOPRLL EQU   X'10'               ROLL MODE  (Y=1,N=0)
         SPACE 4
DCMCS    DS    BL1                 OPEN/CLOSE REQUEST
         SPACE 2
DCMCSC   EQU   X'80'               CLOSE REQUEST
DCMCSO   EQU   X'40'               OPEN REQUEST
         SPACE 4
DCMUTILT DS    BL1                 RESERVED
         SPACE 2
DCMUTILA EQU   X'80'               THESE BITS ARE
DCMUTILB EQU   X'40'                 INITIALIZED AND USED
DCMUTILC EQU   X'20'                 SOLELY WITHIN
DCMUTILD EQU   X'10'                 EACH MODULE
DCMUTILE EQU   X'08'               THEY ARE NEVER
DCMUTILF EQU   X'04'               USED FOR INTERFACE
DCMTEST1 EQU   X'02'               FOR TESTING
DCMTEST2 EQU   X'01'               FOR TESTING
         SPACE 4
DCMDSTAT DS    BL1                 CURRENT DISPLAY STATUS
         SPACE 2
DCMDSTNM EQU   X'20'               MESSAGES ARE NUMBERED
DCMDSTNH EQU   X'10'               MSGS NUMBERED - HOLD OPTION
DCMDSINR EQU   X'08'               INTERVENTION REQ'D DELETION TRIED
DCMDSAUT EQU   X'04'               AUTOMATIC DELETION TRIED
         SPACE 4
DCMMCSST DS    BL1                 MCS INTERFACE BYTE
         SPACE 2
DCMDUSE  EQU   X'80'               OUR SUPPORT IN CONTROL
DCMOOMSS EQU   X'04'               MESSAGE STREAM ENTRY
DCMOOSDS EQU   X'01'               STATUS DISPLAY ENTRY
         SPACE 4
DCMIOUNQ DS    BL1                 UNIQUE IO BYTE
         SPACE 2
*  UNIQUE INTERFACE BITS FOR 2260
DCMIO226 EQU   X'80'               RMI PERFORMED
DCMRPCUR EQU   X'40'               ADVANCE CURSOR TO BLANKS
DCMFRSCN EQU   X'20'               PUT OUTPUT IN HOLD MODE
*  UNIQUE INTERFACE BITS FOR 2250
DCMRDARM EQU   X'10'               PERFORM READ AFTER RMI
DCMW2250 EQU   X'08'               DEVICE IS 2250
DCMINNOR EQU   X'04'               NORMAL INSTRUCTION LINE
DCMINERR EQU   X'02'               ERROR INSTRUCTION LINE
         SPACE 4
DCMIOCM1 DS    BL1                 IO COMMUNICATIONS BYTE 1
         SPACE 2
DCMDORMI EQU   X'80'               ISSUE RMI
DCMSOUND EQU   X'40'               SOUND ALARM
DCMWRWRN EQU   X'20'               WRITE WARNING LINE
DCMWRMSG EQU   X'10'               WRITE FULL MESSAGE AREA
DCMWRPAR EQU   X'08'               WRITE PARTIAL MESSAGE AREA
DCMWRINS EQU   X'04'               WRITE INSTRUCTION LINE
DCMWRENT EQU   X'02'               WRITE ENTRY AREA
DCMINSC  EQU   X'01'               INSERT CURSOR
         EJECT
DCMIOCM2 DS    BL1                 IO COMMUNICATIONS BYTE 2
         SPACE 2
DCMBLENT EQU   X'80'               BLANK ENTRY AREA
DCMBLWRL EQU   X'40'               BLANK LEFT HALF WARNING LINE
DCMBLWRR EQU   X'20'               BLANK RIGHT HALF WARNING LINE
DCMINSSH EQU   X'10'               INIT AND SHIFT INSTRUCTION LINE
DCMWINFD EQU   X'08'               WRITE INFORMATIONAL DISPLAY
DCMERASE EQU   X'04'               PERFORM ERASE
DCMIOCRD EQU   X'02'               PERFORM READ (2250,22DOC)
DCMWRASY EQU   X'01'               WRITE ASYNC ERROR MSG TO MID-SCREEN
         SPACE 4
DCMIOCM3 DS    BL1                 IO COMMUNICATIONS BYTE 3
         SPACE 2
DCMOPRMI EQU   X'80'               RMI AFTER OPEN TO UNLOCK KEYBOARD
DCMSSRG  EQU   X'40'               SUPPRESS START REGENERATION
DCMWRPFK EQU   X'10'               DCM WRITE PFK AREA
DCMPFKAT EQU   X'08'               PFK ATTENTION
DCMRDPFK EQU   X'04'               PFK AREA READ
DCMACPFK EQU   X'02'               TURN ACTIVE PFK LIGHTS ON
DCMLTPFK EQU   X'01'               TURN ALL PFK LIGHTS ON
         SPACE 4
DCMLINEN DS    XL1                 LINE NUMBER TO BEGIN WRITE
         SPACE 2
DCMCULNO DS    XL1                 LINE IN ENTRY AREA TO INSERT CURSOR
         SPACE 2
DCMPOSCU DS    XL1                 POSITION TO INSERT CURSOR
         SPACE 4
DCMASYNC DS    BL1                 ASYN ERROR COMMUNICATIONS/RETRY BYTE
         SPACE 2
DCMASDA  EQU   X'40'               RETRY BIT
DCMASIN  EQU   X'20'               RETRY BIT
DCMASBA  EQU   X'10'               RETRY BIT
DCMASLOG EQU   X'08'               LOG ASYNCHRONOUS ERROR
         EJECT
DCMCOM1  DS    BL1                 COMMUNICATIONS BYTE
         SPACE 2
DCMLPENT EQU   X'80'               ENTER BY LP OR CURSOR
DCMIOPRD EQU   X'40'               READ PERFORMED
DCMCOMRM EQU   X'20'               RMI PERFORMED
DCMCOMAU EQU   X'10'               PERFORM AUTO DELETE
DCMCOMRD EQU   X'08'               PERFORM REGULAR DELETE
DCMCOMNM EQU   X'04'               NUMBER MESSAGES
DCMCANCL EQU   X'01'               INDICATE CANCEL TO COMMAND ROUTINE
         SPACE 3
DCMCOM2  DS    BL1                 COMMUNICATIONS BYTE
         SPACE 2
DCMCM2I  EQU   X'80'               INPUT TO BE PROCESSED
DCMSPLIT EQU   X'40'               MSG TO BE SPLIT
DCMCOMAR EQU   X'20'               ACCEPTED REPLY
DCMERPF  EQU   X'08'               ERASE PERF-PROC CAN NOW CLOSE DEVICE
DCMCMIN5 EQU   X'04'               RETURN TO INTER. 5 FOR BLNK
DCMCBLNK EQU   X'02'               BLANKING REQUIRED
DCMAE    EQU   X'01'               CLEANUP FOR ASY ERROR
         SPACE 3
DCMCOM3  DS    BL1                 COMMUNICATIONS BYTE
         SPACE 2
DCMCDSP3 EQU   X'80'               DISPLAY 3 COMPLETED WORK
DCMRTPFK EQU   X'40'               RETURN TO PFK ROUTINE
DCMVLPFK EQU   X'20'               VERIFYING LAST COMMAND
DCMXINT1 EQU   X'10'               ENTRY FOR INTERFACE 1 ROUTINE
DCMOLUNV EQU   X'08'               O-O-L MSG CAUSED UNVIEW. MSG.
DCMPFKWR EQU   X'04'               WRITE PFK UPDATES TO LIB
DCMOLHLD EQU   X'02'               OUT OF LINE MESSAGES HELD  MB Y02958
DCMCMIN7 EQU   X'01'               RETURN TO INTER. 7 FOR BLANKING
         SPACE 3
DCMCMSG1 DS    BL1                 MSG MODULE COMMUNICATIONS BYTE 1
         SPACE 2
DCMMSGWT EQU   X'80'               MOVE IN MESSAGE WAITING
DCMUNMSG EQU   X'40'               MOVE IN UNVIEWABLE MESSAGE
DCMSTEX  EQU   X'20'               MOVE IN STATUS EXISTS
DCMCHOPT EQU   X'10'               MOVE IN CHANGE OPTIONS
DCMELONG EQU   X'08'               MOVE IN ENTRY TOO LONG
DCMWRCDL EQU   X'04'               MOVE IN CON=N,DEL=Y
DCMDELNT EQU   X'02'               MOVE IN DEL UNCHANGED, NO TIMER
         EJECT
DCMCMSG2 DS    BL1                 MSG MODULE COMMUNICATIONS BYTE 2
         SPACE 2
DCMDLREQ EQU   X'80'               MOVE IN DELETION REQUESTED
DCMRQINC EQU   X'40'               MOVE IN REQUEST INCONSISTENT
DCMMSGCR EQU   X'20'               MOVE IN INVALID CURSOR OPERATION
DCMINVOP EQU   X'10'               MOVE IN INVALID OPERAND
DCMCILLP EQU   X'08'               MOVE IN ILLEGAL LP OPERATION
DCMDELRI EQU   X'04'               MOVE IN DELETE REQUEST INCONSISTANT
DCMASYRT EQU   X'02'               MOVE IN ASYN ERROR RETRYABLE
DCMASYCD EQU   X'01'               MOVE IN ASYN ERROR MAYBE RETRYABLE
         SPACE 4
DCMCMSG3 DS    BL1                 MSG MODULE COMMUNICATIONS BYTE 3
         SPACE 2
DCMCMRLL EQU   X'80'               MOVE IN ROLL MODE MESSAGE
DCMCDLR1 EQU   X'40'               NO DELETABLE MESSAGES
DCMCDLR2 EQU   X'20'               INVALID RANGE
DCMCDLR3 EQU   X'10'               SEG EQU TO ZERO
DCMCDLR4 EQU   X'08'               DISPLAY NOT ON SCREEN
DCMCDLR5 EQU   X'04'               INVALID OPERAND
DCMDTBSY EQU   X'01'               COMMAND REJECTED - TASK BUSY
         SPACE 4
DCMCMSG4 DS    BL1                 MSG MODULE COMMUNICATIONS BYTE 4
         SPACE 2
DCMPFKNA EQU   X'80'               MOVE IN PFK NOT ALLOCATED FOR
DCMPFKND EQU   X'40'               MOVE IN PFK NOT DEFINED
DCMPFKNO EQU   X'20'               MOVE IN NO PFK ALLOCATION
DCMPFKIP EQU   X'10'               MOVE IN PFK IN PROCESS
         SPACE 4
DCMSVC34 DS    BL1                 SVC 34 COMMUNICATION BYTE
         SPACE 2
DCMMYCMD EQU   X'80'               COMMAND TO BE HANDLED BY THIS CONS
DCMINVLD EQU   X'40'               INVALID K COMMAND
DCMTYPE1 EQU   X'20'               K COMMAND IS NOT ROUTABLE
         SPACE 2
DCMPAD   DS    X                   RESERVED COMMUNICATION BYTE   Y02958
DCMIONDX DS    X                   INDEX FOR SELECTING THE    MB Y02958
*                                  APPROPRIATE I/O ROUTINE    MB Y02958
*                                  X'04' - M/165 CONSOLE      MB Y02958
*                                  X'08' - 2250               MB Y02958
*                                  X'0C' - 2260               MB Y02958
*                                  X'10' - 3277               MB Y02958
DCMTEST  DS    H                   RESERVED FOR TESTING       MB Y02958
         EJECT
**                                                                   **
*                        MODULE ADDRESSES                             *
**                                                                   **
         SPACE 1                                              MB Y02958
DCMIORTN DS    F                   APPROIATE I/O ROUTINE      MB Y02958
*                  NAME   TRACE ID   DESCRIPTION              MB Y02958
*                 IEECVETH    EH   3066(M/165) IO ROUTINE     MB Y02958
*                 IEECVETP    EP   2250 IO ROUTINE            MB Y02958
*                 IEECVETR    ER   2260 IO ROUTINE            MB Y02958
*                 IEECVETU    EU   3277 IO ROUTINE            MB Y02958
         SPACE 1                                              MB Y02958
*                  NAME   TRACE ID   DESCRIPTION              MB Y02958
DCMNPRZ  DS    F  IEECVFT1    F1   PROCESSOR 0 LOAD ONE       MB Y02958
DCMNPROC DS    F  IEECVET1    E1   PROCESSOR ROUTINE LOAD ONE MB Y02958
DCMNDSP1 DS    F  IEECVET2    E2   DISPLAY ROUTINE 1          MB Y02958
DCMNDSP2 DS    F  IEECVET3    E3   DISPLAY ROUTINE 2          MB Y02958
DCMNDSP3 DS    F  IEECVFT2    F2   DISPLAY ROUTINE 3          MB Y02958
DCMNCMD1 DS    F  IEECVET4    E4   COMMAND ROUTINE 1          MB Y02958
DCMNDEL1 DS    F  IEECVET6    E6   DELETE ROUTINE 1           MB Y02958
DCMNDEL2 DS    F  IEECVET7    E7   DELETE ROUTINE 2           MB Y02958
DCMNDEL3 DS    F  IEECVET8    E8   DELETE ROUTINE 3           MB Y02958
DCMNDEL4 DS    F  IEECVET9    E9   DELETE ROUTINE 4           MB Y02958
DCMNOPT1 DS    F  IEECVETA    EA   OPTIONS ROUTINE 1          MB Y02958
DCMNPFK1 DS    F  IEECVFTA    FA   PFK ROUTINE 1              MB Y02958
DCMNPFK2 DS    F  IEECVFTB    FB   PFK ROUTINE 2              MB Y02958
DCMNERRO DS    F  IEECVETC    EC   ASYNCHRONOUS ERROR ROUTINE MB Y02958
DCMNMSG1 DS    F  IEECVETD    ED   MESSAGE ROUTINE 1          MB Y02958
DCMNMSG2 DS    F  IEECVETE    EE   MESSAGE ROUTINE 2          MB Y02958
DCMNMSG3 DS    F  IEECVFTD    FD   MESSAGE ROUTINE 3          MB Y02958
DCMNLPCR DS    F  IEECVETF    EF   LIGHT PEN/CURSOR SERVICE   MB Y02958
DCMNOPCL DS    F  IEECVETG    EG   OPEN-CLOSE ROUTINE         MB Y02958
DCMNCLN  DS    F  IEECVFTG    FG   CLEANUP MODULE             MB Y02958
DCMNROLL DS    F  IEECVETJ    EJ   ROLL MODE ROUTINE          MB Y02958
DCMNTIMR DS    F  IEECVETK    EK   TIMER INTERPRETER ROUTINE  MB Y02958
DCMNINT1 DS    F  IEECVFTL    FL   INTERFACE 1 ROUTINE        MB Y02958
DCMNINT2 DS    F  IEECVFTM    FM   INTERFACE 2 ROUTINE        MB Y02958
DCMNINT3 DS    F  IEECVFTN    FN   INTERFACE 3 ROUTINE        MB Y02958
DCMNINT4 DS    F  IEECVFTO    FO   INTERFACE 4 ROUTINE        MB Y02958
DCMNINT5 DS    F  IEECVFTP    FP   INTERFACE 5 ROUTINE        MB Y02958
DCMNINT6 DS    F  IEECVFTQ    FQ   INTERFACE 6 ROUTINE        MB Y02958
DCMNINT7 DS    F  IEECVFTT    FT   INTERFACE 7 ROUTINE        MB Y02958
         SPACE 2
DCMTRACE DS    CL30                DIDOCS MODULE TRACE AREA   MB Y02958
DCMTRAC2 EQU   DCMTRACE+2          TRACE MOVE FROM-ADDRESS    MB Y02958
DCMTRLEN EQU   *-DCMTRACE          LENGTH FOR TRACE MOVE      MB Y02958
DCMTREN1 DS    C                   1ST BYTE OF TRACE ENTRY    MB Y02958
DCMTREN2 DS    C                   2ND BYTE OF TRACE ENTRY    MB Y02958
         EJECT
*  FIRST BYTE OF SCT ENTRIES
DCMMSGWR EQU   X'80'               WTOR MESSAGE DISPLAYED IN LINE
DCMMSGIN EQU   X'40'               MESSAGE DISPLAYED IN LINE
DCMMSGCN EQU   X'20'               MESSAGE CONTINUED ON NEXT LINE
DCMMSGJK EQU   X'10'               TO WRITE OUT-OF-LINE DISPLAY FROM
*                                  MAY CONTAIN JUNK (SDS INTERFACE 2)
DCMMSGAD EQU   X'08'               MESSAGE CAN BE DELETED AUTOMATICALLY
DCMMSGRD EQU   X'04'               REQUEST HAS SPECIFIED MSG BE REMOVED
DCMMSGIF EQU   X'02'               INFORMATIONAL MESSAGE IN LINE
DCMMSGST EQU   X'01'               END OF TABLE INDICATOR
         SPACE 2
*  SECOND BYTE OF SCT ENTRIES
DCMMSGAC EQU   X'80'               ACTION MESSAGE
DCMMSGC7 EQU   X'40'               DESCRIPTOR CODE 7 MESSAGE
DCMMSGDM EQU   X'20'               MESSAGE HAS BEEN DOMMED
DCMMSGAR EQU   X'10'               MESSAGE IS AN ACCEPTED REPLY
DCMMSGIR EQU   X'08'               INTERVENTION REQUIRED MESSAGE
DCMMSGCT EQU   X'04'               CONTINUATION LINE
DCMMSGPP EQU   X'02'               ISSUED BY PROBLEM PROGRAM
DCMMSGCL EQU   X'01'               CONTROL LINE OF IN LINE MLWTO
         SPACE 2
*  SECONDARY SCT ENTRIES
DCMSECCL EQU   X'80'               CONTROL LINE OF OUT OF LINE DISPLAY
DCMSECLL EQU   X'40'               LABEL LINE OF OUT OF LINE DISPLAY
DCMSECDL EQU   X'20'               DATA LINE OF OUT OF LINE DISPLAY
DCMSECBL EQU   X'10'               THIS LINE IS BLANKED
DCMSECDD EQU   X'02'               LINE RESERVED FOR DYNAMIC DISPLAY
DCMSECST EQU   X'01'               END OF TABLE INDICATOR
DCMEND   DS    0C                  END OF DCM
         MEND  , */
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*        THIS PROGRAM WILL DO CONSOLE SIMULATION                      *
*        FOR A TSO TERMINAL.                                          *
*                                                                     *
*        IT GOES OUT AND FINDS A GRAPHICS (3277) ACTIVE CONSOLE       *
*        AND USES THAT CONSOLES SCREEN IMAGE FOR OUTPUT               *
*        AND UCM-ID FOR COMMAND ENTRY.                                *
*        THIS PROGRAM REQUIRES AUTHORIZATION TO USE                   *
*        THE COMMAND ENTRY INTERFACE.                                 *
*                                                                     *
*        TO USE IT SIMPLY SAY.. CONSOLE                               *
*                                                                     *
*        ERROR MESSAGES -                                             *
*              NO ACCEPTABLE (3277) CONSOLES FOUND                    *
*                                                                     *
*        A NULL INPUT CAUSES THE SCREEN TO BE UPDATED.                *
*        YOU CAN USE CONSOLE UNAUTHORIZED AS LONG                     *
*        YOU DON'T TYPE ANYTHING IN.                                  *
*                                                                     *
*                                                                     *
*        ----                                                         *
*       | PA |   TERMINATES CONSOLE WITH PREJUDICE                    *
*       | 1  |                                                        *
*        ----                                                         *
*                                                                     *
*        ----                                                         *
*       | PF |   TERMINATES CONSOLE CLEANLY                           *
*       | 3  |                                                        *
*        ----                                                         *
*                                                                     *
*        ----                                                         *
*       | PF |   RECALLS LAST COMMAND ENTERED                         *
*       | 10 |                                                        *
*        ----                                                         *
*                                                                     *
*        ----                                                         *
*       | PF |   CHOOSES ANOTHER CONSOLE                              *
*       | 12 |                                                        *
*        ----                                                         *
*  CAUTION:                                                           *
*  YOU WILL NEED TO SUPPLY YOUR OWN AUTHORIZATION AND UN-AUTHORIZATION*
*  ROUTINES.                                                          *
*                                                                     *
***********************************************************************
*
         EJECT
CONSOLE  CSECT
         SAVE  (14,12)           SAVE THE REGISTERS
         LR    R12,R15           SET THE REAL BASE
         LA    R11,4095(R15)
         LA    R11,1(R11)
         USING CONSOLE,R12,R11
*
         LA    R2,SAVEAREA       CHAIN
         ST    R13,4(,R2)        THE
         ST    R2,8(,R13)       SAVE
         LR    R13,R2           AREAS
*
*        LOAD  EP=TERMTSO          LOAD TERMIO ROUTINE ADDRESS
         L     R0,=V(TERMIO#)      LOAD TERMIO ROUTINE ADDRESS
         ST    R0,TERMIO           SAVE IT
         AUTHON
*
         MODESET KEY=ZERO,MODE=SUP
*
         LA    R2,1
         AXSET AX=(2)
*
         ESAR  R2                  GET OLD SEC ASID
         STH   R2,SECASID          SAVE OLD SEC ASID
         LH    R2,ASID5            GET ASID FOR COMTASK
         SSAR  R2                  MAKE IT NEW SEC ASID
*
         STIDP CPUID               SAVE CPUID FOR LATER TESTS
*
         SLR   R0,R0               INDICATE FIRST TIME
         BAL   R9,FINDCONS         GO FIND A CONSOLE
*
         LH    R2,SECASID          SAVE OLD SEC ASID
         SSAR  R2                  MAKE IT NEW SEC ASID
*
         SLR   R2,R2
         AXSET AX=(2)
*
***********************************************************************
*                                                                     *
*        A CONSOLE HAS BEEN FOUND                                     *
*        COPY THE SCREEN AND DISPLAY IT FOR THE USER                  *
*                                                                     *
*        R3 ->  UCME                                                  *
*        R10 -> RDCM                                                  *
*        R6 ->  TDCM                                                  *
*                                                                     *
***********************************************************************
*
         USING DCMSTRT,R6
         USING UCMLIST,R3
         USING DCMTSRT,R10
*
GOTONE   DS    0H
         LA    R2,1
         AXSET AX=(2)
         LH    R2,ASID5            GET ASID FOR COMTASK
         SSAR  R2                  MAKE IT NEW SEC ASID
         SLR   R0,R0               CLEAR WORK REG
         LA    R1,L'MCMMSGAL
         MVCP  MCMMSGAL(R1),DCMMSGAL,0
         LA    R1,L'MCMASCRN
         MVCP  MCMASCRN(R1),DCMASCRN,0
         LA    R1,L'MCMAMTAB
         MVCP  MCMAMTAB(R1),DCMAMTAB,0
         LA    R1,L'MCMAINS
         MVCP  MCMAINS(R1),DCMAINS,0
         LA    R1,L'MCMSCTCN
         MVCP  MCMSCTCN(R1),DCMSCTCN,0
         LA    R1,8
         MVCP  MCMDEL(R1),DCMDEL,0
*        LH    R1,MCMMSGAL         NUMBER  OF LINES IN MSG AREA
         LH    R1,=H'19'           BECAUSE MASTER IS BIGGER    PLB
         L     R7,MCMASCRN         POINT TO  THE  FIRST INPUT LINE
         L     R5,MCMAMTAB         POIN TO THE FIRST SCT
         LA    R8,SCREEN           OUTPUT LINE
         SPACE
         L     R14,16              POINT AT THE CVT   *** PAT BURKE ***
         L     R14,0(,R14)         NEW/OLD            *** PAT BURKE ***
         L     R14,4(,R14)         OUR TCB            *** PAT BURKE ***
         L     R14,112(,R14)       FSA                *** PAT BURKE ***
*
***********************************************************************
*                                                                     *
*   AT THIS POINT WE HAVE LOCATED THE FIRST SAVE AREA PROVIDED TO THIS*
*   TASK WHEN IT WAS ATTACHED. NOBODY CARES ABOUT THE REGISTERS THAT  *
*   IT CONTAINS, SO TERMIO USES IT AS THE ANCHOR FOR ITS TABLE.       *
*   USAGE IS AS FOLLOWS:                                              *
*                                                                     *
*        24    ORIGINAL PARM SAVED BY INITIAL ROUTINE (DCB PTR)       *
*        28    'TRIO' IF TERMIO HAS EVER BEEN INVOKED                 *
*        32    POINTER TO PREVIOUS FORMAT TABLE USED.                 *
*        36    POINTER TO CURRENT TERMIO WORK AREA                    *
*                                                                     *
***********************************************************************
*
         XC    32(4,R14),32(R14)   CLEAR SCR FORMAT.  *** PAT BURKE ***
         LA    R14,SCR1+7          LOC OF 1ST C-BYTE. *** PAT BURKE ***
         SPACE
         XC    COUNTACT,COUNTACT   ZERO
         XC    COUNTRPY,COUNTRPY   COUNTERS
         XC    COUNTINT,COUNTINT
*
GOT1     DS    0H
         MVI   0(R14),X'F4'        SET DEFAULT LOW.   *** PAT BURKE ***
         MVC   0(3,R8),=C'   '     BLANK PREFIX
         SLR   R0,R0               CLEAR WORK REG
         LA    R2,74
         MVCP  3(R2,R8),4(R7),0
         LA    R2,L'MAMTAB
         MVCP  MAMTAB(R2),0(R5),0
         TR    3(74,R8),BLANKTAB   GET IT READABLE
*
         TM    MAMTAB,X'80'        TEST FOR WTOR
         BZ    NOTREPLY
         TM    MAMTAB+1,X'20'      STILL OUTSTANDING
         BO    NEXTLINE            BRANCH IF NOT
*
         MVC   0(3,R8),=C'*R*'     FLAG WTOR
         MVI   0(R14),X'F8'        SET HIGH INTENSITY.*** PAT BURKE ***
         TM    MAMTAB+1,X'04'      DO WE COUNT IT
         BO    NEXTLINE            NO WE DON'T
         L     R2,COUNTRPY
         LA    R2,1(,R2)           COUNT IT
         ST    R2,COUNTRPY
         B     NEXTLINE
*
NOTREPLY TM    MAMTAB+1,X'08'      INTERVENTION REQ
         BZ    NOTINTRQ            BRANCH IF
         TM    MAMTAB+1,X'20'      SHOULD I FLAG IT
         BO    NEXTLINE            NO
*
         MVC   0(3,R8),=C'*I*'     FLAG IT
         MVI   0(R14),X'F8'        SET HIGH INTENSITY.*** PAT BURKE ***
         L     R2,COUNTINT         LETS
         LA    R2,1(,R2)           COUNT
         ST    R2,COUNTINT         IT
         B     NEXTLINE
*
NOTINTRQ TM    MAMTAB+1,X'80'      IS IT AN ACTION
         BZ    NEXTLINE
         TM    MAMTAB+1,X'20'      STILL OUTSTANDING
         BO    NEXTLINE
*
         MVC   0(3,R8),=C'*A*'     FLAG ACTION MESSAGE
         MVI   0(R14),X'F8'        SET HIGH INTENSITY.*** PAT BURKE ***
         TM    MAMTAB+1,X'04'      SHOULD I COUNT IT
         BO    NEXTLINE            NO
         L     R2,COUNTACT         COUNT
         LA    R2,1(,R2)           THE
         ST    R2,COUNTACT         DEVIL
*
NEXTLINE LA    R8,79(,R8)          OUR SIZE
         LA    R7,84(,R7)          THEIRS
         AH    R5,MCMSCTCN         ST SIZE
         LA    R14,8(0,R14)        INCR TO NEXT CNTL. *** PAT BURKE ***
         BCT   R1,GOT1             GET EM ALL
*
         LH    R2,SECASID          SAVE OLD SEC ASID
         SSAR  R2                  MAKE IT NEW SEC ASID
*
         SLR   R2,R2
         AXSET AX=(2)
*
         L     R1,MCMAINS
         LA    R8,79(,R8)          SKIP PFK LINE
*
         SLR   R1,R1               ZERO FOR INSERTS
         IC    R1,MCMSEG           SEGMENT SIZE
         BAL   R9,CVTEDIT          EDITABLE NUMBER
         STCM  R15,3,SEG           SET IN MESSAGE
*
         IC    R1,MCMRNUM          ROLL NUMBER
         BAL   R9,CVTEDIT          EDIT IT
         STCM  R15,3,RNUM          SET IN MESSAGE
*
         LH    R1,MCMRTME          ROLL TIME
         BAL   R9,CVTEDIT          EDIT
         STCM  R15,3,RTME          SET IN MESSAGE
*
         MVC   CON,MCMCON          CON=X
         MVC   DEL,MCMDEL          DEL=XX
*
         TIME  DEC                 GET THE TIME
         ST    R0,CVTB             SAVE IT
         MVC   EDITTIME,=X'4021207A20207A2020'
         ED    EDITTIME,CVTB       EDIT THE TIME IN
*
         MVC   0(79,R8),UNITMSG    MOVE BASIC MESSAGE
*
         LA    R8,(2*79)(,R8)      SKIP INPUT LINE
         MVC   0(79,R8),CMNDBUF    SHOW LAST COMMAND ENTERED
*
         LA    R8,79(,R8)          SKIP PFK LINE
*
         L     R1,COUNTACT         GET ACTION MESSAGES
         BAL   R9,CVTEDIT
         STCM  R15,3,ACTIONMS
*
         L     R1,COUNTRPY         GET REPLIES
         BAL   R9,CVTEDIT
         STCM  R15,3,REPLYMS
*
         L     R1,COUNTINT         GET INTERVENTIONS
         BAL   R9,CVTEDIT
         STCM  R15,3,INTERVMS
*
         MVC   0(79,R8),DCMSWARN
*
         BAL   R9,WRITE            DOIT JACK !!!
*
         CLI   CONTFLAG,X'00'      IS CONTINUOUS FLAG ON
         BNE   DELAY               YES THEN BRANCH
*
         CLI   STRTCONT,X'FF'      IS CONTINUOUS FLAG ON
         BNE   DOREAD              YES THEN BRANCH
         MVI   CONTFLAG,X'FF'
*
DOREAD   DS    0H
         BAL   R9,READ             DOIT JACK !!!
*
         CLI   IOCBAID,AIDPA1
         BE    END1
*
         PFSELECT IOCBAID,NOPF,(CONTDISP,STOPCONT,END1,PFK4,           X
               PFK5,PFK6,PFK7,PFK8,                                    X
               PFK9,RECALL,REPEAT,ALTC),DUMMY=NOPF
*
NOPF     EQU   *                   NO PF KEYS DEFINED
         CLI   ENTRLNE,C' '        NULL INPUT ?
         BNE   GOTCMD
         CLC   ENTRLNE+1(78),ENTRLNE
         BE    GOTONE
*
GOTCMD   DS    0H
         MVI   CMNDBUF,C' '
         MVC   CMNDBUF+1(79),CMNDBUF
         MVC   CMNDBUF(79),ENTRLNE
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         OC    CMNDBUF(79),ENTRLNE
*
         CLC   CMNDBUF(3),=C'DEF'  IS THIS A DEFINE COMMAND
         BE    PROCDEFN
*
         CLC   CMNDBUF(5),=C'D PFK'
         BE    LISTDEFN
*
         CLC   CMNDBUF(3),=C'K N'
         BE    DEFMESSN
*
RETDEFN  DS    0H
         MVC   CMNDWTO+4+8(80),CMNDBUF  MOVE THE COMMAND
         L     R1,PSAAOLD-PSA      LOAD ASCB ADDRESS
         USING ASCB,R1
         ICM   R15,15,ASCBJBNI     LOAD JOB NAME
         BNZ   *+8                 BRANCH IF THERE
         ICM   R15,15,ASCBJBNS     LOAD ALTERNATE JOB NAME
         MVC   CMNDWTO+4(7),0(R15) MOVE TSO USER ID
         DROP  R1
*
         SLR   R0,R0
         IC    R0,XUCMID          POINT AT CONSOLE
         WTO   MF=(E,CMNDWTO)     LOG THE COMMAND
*
*        CLI   CMNDBUF,C'#'       IS THIS A VM COMMAND
*        BE    VMCMD               YES THEN BRANCH
*
         LA    R1,CMND             POINT AT USER SERVICES LIST
         XR    R0,R0
         IC    R0,XUCMID           OUR MAN IN THE COMM TASK
*        STM   R0,R1,SVC34PRM
*        LA    R1,SVC235XX
*        SVC   235                 FIRE HIM THRU
         SVC   34                  FIRE HIM THRU     *** A. NICOLAI ***
*
         LTR   R15,R15
         BZ    GOTONE              FIND OUT WUTS HAPPENIN
*
         LR    R1,R15              SHOW R/C
         BAL   R9,CVTPRT           DO IT
         STCM  R15,15,NOTR15  ...
         MVC   ENTRLNE(LNOTAUTH),NOTAUTH
*
PUTLINE  BAL   R9,WRITE            ...
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         B     GOTONE
*
DEFMESSN DS    0H
         MVC   CMNDBUF(LDEFM),DEFMES
         B     GOTONE
*
VMCMD    DS    0H
         CLI   CPUID,X'FF'         ARE WE UNDER VM
         BNE   NOVM                NO, THEN BRANCH
         TR    CMNDBUF,BLANKTAB    CHANGE # TO X'15'
         LRA   R9,CMNDBUF+1        GET REAL ADDRESS OF COMMAND
         L     R10,=A(VMBUF)       GET VIRTUAL ADDRESS OF BUF
         LRA   R10,0(R10)          GET REAL ADDRESS OF REPONSE BUF
         L     R0,LCBUF            GET LENGTH OF BUF + FLAG
         LA    R1,LVMBUF           GET LENGTH OF BUF + FLAG
         DC    X'83900008'         DO THE DIAGNOSE
         BNZ   SETDALLB            MESSAGE TO LARGE FOR BUFFER
STRTWTO  L     R9,=A(VMBUF)        GET VIRTUAL ADDRESS OF BUFF
         SR    R2,R2               CLEAR WORK REG
STRTSCAN LR    R10,R9              SET START ADDRESS
SCANLOOP DS    0H                  SCAN FOR END OF LINE
         CLI   0(R9),X'15'         IS THIS END ON MESSAGE LINE
         BCTR  R1,0                DECREMENT MESSAGE LENGTH
         BE    GODOMVC             YES THEN BRANCH
         LTR   R1,R1               IS IT ZERO
         BNP   GODOMVC             YES THEN BRANCH
         LA    R9,1(R9)            INCR LINE POINTER
         LA    R2,1(R2)            INCR LENGTH COUNTER
         CH    R2,=H'80'           HAVE I GOT A FULL LINE
         BL    SCANLOOP            CONT TO SCAN
         BCTR  R9,0                BACK POINTER UP BY ONE
         BCTR  R2,0                DEC FOR MVC
GODOMVC  DS    0H
         MVI   VMWTO+4+8,C' '      CLEAR WTO MESSAGE
         MVC   VMWTO+4+9(79),VMWTO+4+8 AREA
         EX    R2,WTOMVC           DO THE MOVE
         ST    R1,R1SAVE           SAVE R1 BECAUSE WTO DESTROYS IT
         SLR   R0,R0
         IC    R0,XUCMID
         WTO   MF=(E,VMWTO)
         LA    R9,1(R9)            INCR POINTER
         L     R1,R1SAVE           RESTORE R1
         LTR   R1,R1               IS IT ZERO
         BNP   GOTONE              YES THEN BRANCH
         SLR   R2,R2               ZERO SCANNER COUNT
         B     STRTSCAN            GO FIND END OF NEXT MESSAGE
SETDALLB LA    R1,LVMBUF           GET MAX LENGTH
         B     STRTWTO
WTOMVC   MVC   VMWTO+4+8(0),0(R10)
*
NOVM     MVC   CMNDBUF(LNOVM),NOVMMESS
         B     GOTONE              PUT LINE ON CONSOLE
*
PFK4     DS    0H
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         MVC   ENTRLNE,DPFK4
         CLI   DPFK4-1,X'00'
         BE    GOTCMD
         B     GOTONE
*
PFK5     DS    0H
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         MVC   ENTRLNE,DPFK5
         CLI   DPFK5-1,X'00'
         BE    GOTCMD
         B     GOTONE
*
PFK6     DS    0H
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         MVC   ENTRLNE,DPFK6
         CLI   DPFK6-1,X'00'
         BE    GOTCMD
         B     GOTONE
*
PFK7     DS    0H
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         MVC   ENTRLNE,DPFK7
         CLI   DPFK7-1,X'00'
         BE    GOTCMD
         B     GOTONE
*
PFK8     DS    0H
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         MVC   ENTRLNE,DPFK8
         CLI   DPFK8-1,X'00'
         BE    GOTCMD
         B     GOTONE
*
PFK9     DS    0H
         MVI   ENTRLNE,C' '
         MVC   ENTRLNE+1(78),ENTRLNE RESET INPUT
         MVC   ENTRLNE,DPFK9
         CLI   DPFK9-1,X'00'
         BE    GOTCMD
         B     GOTONE
*
STOPCONT DS    0H
         STAX
         MVI   STRTCONT,X'00'
         MVI   CONTFLAG,X'00'
         B     GOTONE
*
CONTDISP DS    0H
         STAX
         STAX  STAXEXIT,REPLACE=NO,DEFER=NO
         MVI   STRTCONT,X'FF'
         MVI   CONTFLAG,X'FF'
DELAY    DS    0H
         STIMER WAIT,DINTVL=WAITIME
         B     GOTONE
         DS    0D
WAITIME  DC    C'00000100'
*
RECALL   MVC   ENTRLNE(79),CMNDBUF  SET COMMAND BACK
         B     GOTONE
*
REPEAT   MVC   ENTRLNE(79),CMNDBUF  SET COMMAND BACK
         B     NOPF
*
ALTC     LA    R2,1
         AXSET AX=(2)
*
         LH    R2,ASID5            GET ASID FOR COMTASK
         SSAR  R2                  MAKE IT NEW SEC ASID
*
         LR    R0,R3                MOVE THE UCM ADDRESS
         BAL   R9,FINDCONS
*
         LH    R2,SECASID          SAVE OLD SEC ASID
         SSAR  R2                  MAKE IT NEW SEC ASID
*
         SLR   R2,R2
         AXSET AX=(2)
*
         B     GOTONE               AND LOOP
*
PROCDEFN DS    0H
         MVI   CONFLAG,X'00'
         LA    R1,CMNDBUF+4
         CLC   CMNDBUF+4(3),=C'CON'  IS THIS A CONVERSATIONAL COMMAND
         BNE   CONTDEFN               NO BRANCH
         MVI   CONFLAG,X'FF' YES SET FLAG
         LA    R1,CMNDBUF+8
CONTDEFN DS    0H
         CLI   2(R1),C'4'             IS IT A PF4
         BNE   DEFNPF5                NO BRANCH
         MVC   DPFK4(60),4(R1)        MOVE COMMAND TO SAVE AREA
         MVC   DPFK4-1(1),CONFLAG     SET CON FLAG
         B     GOTONE
*
DEFNPF5  DS    0H
         CLI   2(R1),C'5'             IS IT A PF5
         BNE   DEFNPF6                NO BRANCH
         MVC   DPFK5(60),4(R1)        MOVE COMMAND TO SAVE AREA
         MVC   DPFK5-1(1),CONFLAG     SET CON FLAG
         B     GOTONE
*
DEFNPF6  DS    0H
         CLI   2(R1),C'6'             IS IT A PF6
         BNE   DEFNPF7                NO BRANCH
         MVC   DPFK6(60),4(R1)        MOVE COMMAND TO SAVE AREA
         MVC   DPFK6-1(1),CONFLAG     SET CON FLAG
         B     GOTONE
*
DEFNPF7  DS    0H
         CLI   2(R1),C'7'             IS IT A PF7
         BNE   DEFNPF8                NO BRANCH
         MVC   DPFK7(60),4(R1)        MOVE COMMAND TO SAVE AREA
         MVC   DPFK7-1(1),CONFLAG     SET CON FLAG
         B     GOTONE
*
DEFNPF8  DS    0H
         CLI   2(R1),C'8'             IS IT A PF8
         BNE   DEFNPF9                NO BRANCH
         MVC   DPFK8(60),4(R1)        MOVE COMMAND TO SAVE AREA
         MVC   DPFK8-1(1),CONFLAG     SET CON FLAG
         B     GOTONE
*
DEFNPF9  DS    0H
         CLI   2(R1),C'9'             IS IT A PF9
         BNE   RETDEFN                NO BRANCH
         MVC   DPFK9(60),4(R1)        MOVE COMMAND TO SAVE AREA
         MVC   DPFK9-1(1),CONFLAG     SET CON FLAG
         B     GOTONE
*
LISTDEFN DS    0H
         MVC   ENTRLNE(4),=C'PF4='
         MVC   ENTRLNE+4(16),DPFK4
         MVC   ENTRLNE+21(4),=C'PF5='
         MVC   ENTRLNE+25(16),DPFK5
         MVC   ENTRLNE+42(4),=C'PF6='
         MVC   ENTRLNE+46(16),DPFK6
         MVC   CMNDBUF(4),=C'PF7='
         MVC   CMNDBUF+4(16),DPFK7
         MVC   CMNDBUF+21(4),=C'PF8='
         MVC   CMNDBUF+25(16),DPFK8
         MVC   CMNDBUF+42(4),=C'PF9='
         MVC   CMNDBUF+46(16),DPFK9
         B     GOTONE
*
         DC    X'FF'
DPFK4    DC    C'#Q V TA',CL80' '
         DC    X'00'
DPFK5    DC    C'K C,E,1-999',CL80' '
         DC    X'00'
DPFK6    DC    C'D A,L',CL80' '
         DC    X'00'
DPFK7    DC    C'D U,DASD,ONLINE',CL80' '
         DC    X'00'
DPFK8    DC    C'D U,TAPE,ONLINE',CL80' '
         DC    X'00'
DPFK9    DC    C'D R,L',CL80' '
*
END1     DS    0H
         TRMIO IOCB,FORMAT=0,IMAGE=SCREEN,ADDR=TERMIO
*
*END2     DELETE EP=TERMTSO
*
         LH    R2,SECASID          GET OLD SEC ASID
         SSAR  R2                  RESTORE SEC ASID
*
*        ICM   R0,15,=C'KEYR'      GET INTO TCB KEY  *** A. NICOLAI ***
*        SVC   249                                   *** A. NICOLAI ***
*
         MODESET KEY=NZERO,MODE=PROB
*
         AUTHOFF
         L     R13,4(R13)
         RETURN (14,12),RC=0
*
         EJECT
FINDCONS DS    0H
         L     R1,CVTPTR           AND IN THE BEGINNING...
         L     R1,CVTCUCB-CVT(,R1)  ...
         USING UCM,R1
         LM    R3,R5,UCMVEA        R3 -> TO THE FIRST UCME
*                                   R4 CONTAINS UCME LENGTH
*                                    R5 -> TO THE LAST UCME
*
         LTR   R0,R0               CHECK FOR RE-ENTRY TO FIND ALT CON
         BZ    DID0                SCAN IF NOT
         LR    R3,R0               SET CURRENT CONSOLE
         B     DID1                AND SCAN FOR NEXT
*
DID0     DS    0H                  SEARCH FOR SOMETHING USEFUL
         USING UCMLIST,R3
         L     R1,UCMUCB           DEBUGGING
         MVC   UNITXXX(3),13(R1)   ...
*
         TM    UCMATR,UCMUF        IS IT ACTIVE ?
         BZ    DID1                NO.. UNUSEABLE
         L     R10,UCMXB           IS IT GRAPHICS ?
         LTR   R10,R10             ...
         BZ    DID1                NO.. USELESS
         USING DCMTSRT,R10         POINT TO THE DCM
         L     R6,DCMADTRN         FIND  THE PAGEABLE DCM (TDCM)
         LTR   R6,R6               DOES IT EXIST ?
         BZ    DID1                NO...
         SLR   R2,R2               CLEAR WORK REG
         LA    R8,L'MCMIONDX
         MVCP  MCMIONDX(R8),DCMIONDX,2
         CLI   MCMIONDX,X'10'      IS IT A 3270 ?
         MVC   XUCMID,UCMID        SAVE THIS
         BER   R9                  YES BY DINGLES !
*                                      DINGLES ?
DID1     EQU   *
         BXLE  R3,R4,DID0          GET THE NEXT ENTRY
         LTR   R0,R0               TEST FOR SECONDARY ENTRY
         BZ    NOCONSOL            IF NOT, ERROR
         SLR   R0,R0               SET FOR RESCAN FROM BEGINNING
         B     FINDCONS            AND RETRY
*
NOCONSOL MVC   SCREEN(L'ERMSG),ERMSG NO ACCEPTABLE CONSOLES ACTIVE
         BAL   R9,WRITE            WRITE THE SCREEN
         B     END1                FINI
*
         EJECT
CVTPRT   DS    0H
         ST    R1,CVTB
         UNPK  CVTA(9),CVTB(5)
         TR    CVTA(8),HEXTAB
         LM    R14,R15,CVTA
         BR    R9
*
CVTEDIT  DS    0H
         CVD   R1,CVTA
         MVC   CVTB(8),=X'4020202020202120'
         ED    CVTB(8),CVTA+4
         LM    R14,R15,CVTB
         BR    R9
*
WRITE    DS    0H
         TRMIO IOCB,WRITE,FORMAT=SCR1,IMAGE=SCREEN,ADDR=TERMIO
         BR    R9
*
READ     DS    0H
         TRMIO IOCB,READ,FORMAT=SCR1,IMAGE=SCREEN,ADDR=TERMIO
         BR    R9
*
*
         PUSH  USING
         USING STAXEXIT,R15
STAXEXIT DS    0H
         MVI   CONTFLAG,X'00'
         BR    R14
         DROP  R15
         POP   USING
*
CONTFLAG DC    X'00'                  INIT FLAG OFF
CONFLAG  DC    X'00'                  INIT FLAG OFF
STRTCONT DC    X'00'                  INIT FLAG OFF
*
         TITLE 'C O N S O L E - DATA AREAS AND THE LIKE'
SAVEAREA DC    9D'0'               SAVE AREA FOR PROGRAM
*
TERMIO   DC    A(*-*)           ADDRESS OF TERM IO ROUTINE
*
COUNTACT DC    F'0'             ACTION MESSAGES
COUNTRPY DC    F'0'             WTORS
COUNTINT DC    F'0'             INTERVENTIONS
*
CVTB     DC    D'0'
CVTA     DC    D'0',X'0'               PLUS A GARBAGE BYTE
*
HEXTAB   EQU   *-C'0'
         DC    C'0123456789ABCDEF'
*
CPUID    DC    D'0'
*
SECASID  DC    H'0'
ASID5    DC    H'5'
*
ERMSG    DC    C'>>> NO ACCEPTABLE (3277)  CONSOLES FOUND'
*
DCMSWARN DC    CL79' '
         ORG   DCMSWARN
         DC    C'IEE163I MODE= DCMS'
         DC    C'    ACTION MESSAGES='
ACTIONMS DC    C'00'
         DC    C', REPLIES='
REPLYMS  DC    C'00'
         DC    C', INT REQ='
INTERVMS DC    C'00'
         ORG   ,
*
UNITMSG  DC    CL79' '
         ORG   UNITMSG
         DC    C'CONSOLE -'
UNITXXX  DC    CL4' '
         DC    C' RTME='
RTME     DC    C'00'
         DC    C', RNUM='
RNUM     DC    C'00'
         DC    C', SEG='
SEG      DC    C'00'
         DC    C', CON='
CON      DC    C'N'
         DC    C', DEL='
DEL      DC    C'RD'
         DC    C'    DISPLAY TIME='
EDITTIME DC    C' XX:XX:XX'
*
         ORG   ,
*
NOTAUTH  DC    C'*** POSSIBLY NOT AUTHORIZED SVC 34 R/C = '
NOTR15   DC    CL4' '
LNOTAUTH EQU   *-NOTAUTH
*
DEFMES   DC    C'DEF CON,PF#,***COMMAND OR DEF PF#,***COMMAND'
LDEFM    EQU   *-DEFMES
*
NOVMMESS DC    C'*** OPERATING SYSTEM IS NOT UNDER VM *** '
LNOVM    EQU   *-NOVMMESS
*
CMNDWTO  WTO   'USER-ID 12345678901234567890123456789012345678901234567X
               890123456789012345678901234567890',                     X
               DESC=(3,7),MCSFLAG=REG0,MF=L
*
VMWTO    WTO   'VM-RESP 12345678901234567890123456789012345678901234567X
               890123456789012345678901234567890',                     X
               DESC=(3,7),MCSFLAG=REG0,MF=L
*
CMND     DC    H'83',H'0'
CMNDBUF  DC    CL80' '
CMNDLEN  EQU   *-CMND
         DC    X'15'
R1SAVE   DC    A(0)                ALIGN FOR SPEED
LCBUF    DC    X'40',AL3(CMNDLEN)
XUCMID   DC    X'0'
*
         DS    0F
MCMAINS  DC    F'0'
MCMASCRN DC    F'0'
MCMAMTAB DC    F'0'
MCMMSGAL DC    H'0'
MCMSCTCN DC    H'0'
MCMDEL   DC    CL2' '
MCMCON   DC    CL1' '
MCMSEG   DC    X'00'
         DC    X'00'
MCMRNUM  DC    X'00'
MCMRTME  DC    H'0'
MAMTAB   DC    H'0'
*
MCMIONDX DC    X'00'
*
SVC235XX DC    A(SVC34PRM),X'20',AL3(0)
SVC34PRM DS    2A
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
         LTORG
*
BLANKTAB DC    CL256' '
         ORG   BLANKTAB+C''
         DC    C'.<(+|',X'50'
         ORG   BLANKTAB+C'!'
         DC    C'!$*);-/'
         ORG   BLANKTAB+C','
         DC    C',%_>?'
         ORG   BLANKTAB+C':'
         DC    C':',X'15',C'@''="' TRANSLATE # TO X'15'
         ORG   BLANKTAB+X'81'      TRANSLATE LOWER CASE TO UPPER
         DC    C'ABCDEFGHI'
         ORG   BLANKTAB+X'91'      ...
         DC    C'JKLMNOPQR'
         ORG   BLANKTAB+X'A2'      ...
         DC    C'STUVWXYZ '
         ORG   BLANKTAB+C'A'
         DC    C'ABCDEFGHI'
         ORG   BLANKTAB+C'J'
         DC    C'JKLMNOPQR'
         ORG   BLANKTAB+C'S'
         DC    C'STUVWXYZ '
         ORG   BLANKTAB+C'0'
         DC    C'0123456789'
         ORG
*
         EJECT
IOCB     IOCB
*
SCR1     SFMT
*
SCREEN   FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79,INTEN=LO
         FIELD 79
         FIELD 79
         FIELD 79,ALPHA,CURSOR=AFTER
         FIELD 79
         FIELD 79
         SFEND
*
SCREEN   DC    24CL79' '           THISS IS THE MAN
ENTRLNE  EQU   SCREEN+(79*21)      WOOPS
VMBUF    DC    CL256' '
LVMBUF   EQU   *-VMBUF
*
         PRINT NOGEN
*
         IHAASCB
*
         IHAPSA
*
         IEECUCM FORMAT=NEW
*
         IEERDCM
*
         IEETDCM
*
         CVT   DSECT=YES
*
         END   CONSOLE
DATA SET UTILITY - GENERATE

PROCESSING ENDED AT EOD
TRIO     TITLE 'TERMIO# -- 3270 TO USER INTERFACE ROUTINE UNDER TSO'
         MACRO
&NAME    IOCB
&NAME    DS    0F
IOCBFMT  DS    A
IOCBIMG  DS    A
IOCBDECB DS    A
IOCBCUR  DS    H                  CURSOR OFFSET FROM START OF IMAGE
IOCBFLGS DS    X
IOCBFNWR EQU   X'80'              FLAG FOR NO WRITE
IOCBFNRD EQU   X'40'              FLAG FOR NO READ
IOCBFW8  EQU   X'C0'              FLAGS FOR WAIT (CHECK) ONLY
IOCBFNWT EQU   X'20'              FLAG FOR NO WAIT
IOCBFCUR EQU   X'10'              FLAG FOR CURSOR ADDRESS SPECIFIED
IOCBFNBP EQU   X'04'              FLAG FOR BEEP NOT OVERRIDDEN
IOCBFNRR EQU   X'02'              FLAG FOR RESTORE NOT OVERRIDDEN
IOCBFNRS EQU   X'01'              FLAG FOR RESET NOT OVERRIDDEN
IOCBAID  EQU   IOCBFLGS           AID RETURNED AFTER READ
AIDENT   EQU   X'7D'              ENTER KEY AID
AIDPF1   EQU   X'F1'
AIDPF2   EQU   X'F2'
AIDPA1   EQU   X'6C'
AIDPA2   EQU   X'6E'
AIDCAN   EQU   AIDPA2
AIDPA3   EQU   X'6B'
AIDCLR   EQU   X'6D'
IOCBWCC  DS    X                  WRITE CONTROL CHARACTER
IOCBWBP  EQU   X'04'              BEEP
IOCBWRR  EQU   X'02'              WCC RESTORE
IOCBWRS  EQU   X'01'              WCC RESET MDT
         MEND
         EJECT
***********************************************************************
*                                                                     *
*        TERMIO#                                                      *
*        TERMTSO                                                      *
*                                                                     *
*        THIS MODULE IS AN ADAPTATION OF THE ORIGINAL DCTS TERMIO#    *
*        ROUTINE TO PROVIDE A TSO 3270 INTERFACE FOR THE DCTS/DCMS    *
*        PROTOCOL.                                                    *
*                                                                     *
*        ORIGINAL DCTS CODE                                           *
*              STU FEIGAN                                             *
*              FRITZ SCHNEIDER                                        *
*        ORIGINAL TSO INTEFACE                                        *
*              FRED LUDDY                                             *
*        IMPROVED TSO INTERFACE (VTAM, LOWER CASE, DYNAMIC LOAD)      *
*              KEITH MOE                                              *
*                                                                     *
*        THIS MODULE CAN EITHER BE LINK EDITED AS PART OF A           *
*        PROGRAM OR LOADED DYNAMICALLY.  THE TRMIO MACRO IS           *
*        USED TO CALL THIS ROUTINE.                                   *
*                                                                     *
*        THIS MODULE IS RE-ENTRANT.                                   *
*                                                                     *
***********************************************************************
*
TERMIO#  CSECT
         SAVE  (14,12),,*
         LR    R11,R15
         USING TERMIO#,R11
         LR    R10,R1                       SAVE IOCB ADDRESS
         USING IOCB,R10
*
         SLR   R4,R4               INITIALIZE THE FLAGS
*
         L     R2,16                        POINT AT THE CVT
         L     R2,0(,R2)                    NEW/OLD
         L     R2,4(,R2)                    OUR TCB
         L     R2,112(,R2)                  FSA
*
***********************************************************************
*                                                                     *
*   AT THIS POINT WE HAVE LOCATED THE FIRST SAVE AREA PROVIDED TO THIS*
*   TASK WHEN IT WAS ATTACHED. NOBODY CARES ABOUT THE REGISTERS THAT  *
*   IT CONTAINS, SO TERMIO USES IT AS THE ANCHOR FOR ITS TABLE.       *
*   USAGE IS AS FOLLOWS:                                              *
*                                                                     *
*        24    ORIGINAL PARM SAVED BY INITIAL ROUTINE (DCB PTR)       *
*        28    'TRIO' IF TERMIO HAS EVER BEEN INVOKED                 *
*        32    POINTER TO PREVIOUS FORMAT TABLE USED.                 *
*        36    POINTER TO CURRENT TERMIO WORK AREA                    *
*                                                                     *
***********************************************************************
*
         CLC   28(4,R2),=C'TRIO'  IS THIS OUR FIRST TIME THRU
         BE    CONTINUE           NO, PICK UP WORK AREA ADDRESS
         MVC   28(4,R2),=C'TRIO'            MARK FSA AS INITIALISEDK
*
         STFSMODE ON,INITIAL=YES  TURN ON FULL SCREEM MODE
         LTR   R15,R15            DID IT ACCEPT IT
         BNZ   *+8                BRANCH IF NOT
         LA    R4,VTAM            SET THE VTAM FLAG
*
         B     NEWWORK            GO GET A WORK AREA
*
CONTINUE L     R1,36(,R2)         GET OLD WORK AREA
         USING WORK,R1
         CLC   IOCBFMT,32(R2)     HAS HE CHANGED FORMATS
         BNE   CHGFMT             YES, NEED TO CHANGE WORK AREAS
         L     R15,IOCBFMT        POINT AT THE NEW FORMAT
         CLC   FMTHEAD,0(R15)     IS HEADER UNCHANGED
         BNE   CHGFMT             NO, GET NEW WORK AREA
         TM    IOCBFLGS,IOCBFW8+IOCBFNWT    IS IT NEW FORMAT REQUEST
         BNO   RESTART            NO, JUST CONTINUE
*
NEWFMTOK MVI   FLAGS,CLEARED      REQUEST REFORMATTING
         RETURN (14,12),RC=0
*
CHGFMT   L     R0,DSECSIZE        GET SP AND LENGTH
         IC    R4,FLAGS2          SAVE THE SECONDARY FLAGS
         FREEMAIN R,LV=(0),A=(1)
         DROP  R1
         CLC   IOCBFMT,=F'0'      IS FORMAT ADDRESS ZERO
         BNE   NEWWORK            NO, CONTINUE
         STC   R4,IOCBFMT         STORE THE FLAGS
         TM    IOCBFMT,VTAM       TEST FOR VTAM
         BO    VTAMCLR            BRANCH IF SO
         TPUT  TCAMCLR,TCAMCLRL,FULLSCR  CLEAR THE TCAM SCREEN
         B     EXITDONE
*
VTAMCLR  STLINENO LINE=1          PREPARE TO CLEAR THE SCREEN
         STFSMODE OFF             TURN OFF FULL SCREEN MODE
*
EXITDONE MVI   IOCBFMT,0          RESET THE FORMAT TO ZERO
         RETURN (14,15),RC=0
*
NEWWORK  L     R15,IOCBFMT        POINT AT THE NEW FORMAT
         LH    R3,0(,R15)         GET LENGTH OF IMAGE
         LA    R3,WORKLEN(,R3)    ADD SIZE OF REST OF WORK AREA
         ICM   R3,8,=AL1(16)      ASK FOR SP=16
         LR    R0,R3
*
         GETMAIN R,LV=(0)
         ST    R1,36(,R2)         SET POINTER TO THE NEW WORK AREA
         USING WORK,R1
*
         ST    R3,DSECSIZE        SAVE FREEMAIN ARGUMENT
         STC   R4,FLAGS2          SET THE FLAGS
*
         L     R15,IOCBFMT        POINT AT THE NEW FORMAT TABLE
         ST    R15,32(,R2)        PLACE IT IN THE FSA
         MVC   FMTHEAD,0(R15)     SAVE THE HEADER FOR VALIDATION
         MVI   FLAGS,CLEARED      REQUEST A SCREEN RE-FORMAT
*
         TM    IOCBFLGS,IOCBFW8+IOCBFNWT  IS IT A NEW FORMAT REQUEST
         BO    NEWFMTOK
         TM    IOCBFLGS,IOCBFNWR       MUST HAVE A WRITE TO FORMAT TUBE
         BZ    RESTART
         EX    0,BOMB  ATTEMPT TO READ WITH UNFORMATTED SCREEN
         DROP  R1
*
RESTART  ST    R1,8(,R13)         FORWARD CHAIN
         ST    R13,4(,R1)         BACK CHAIN
         LR    R13,R1             ESTABLISH WORK BASE
         USING WORK,R13
*
         L     R15,IOCBFMT        POINT AT THE USERS FORMAT
         LA    R6,8               SET FMT ENTRY LENGTH FOR BXLE
         LH    R7,2(,R15)         GET LENGTH OF FORMAT
         AR    R7,R15             POINT PAST END OF FORMAT
         SR    R7,R6              POINT AT LAST ENTRY
*
         TM    IOCBFLGS,IOCBFNWR  IS A WRITE REQUIRED
         BO    NOWRITE            NO, CHECK FOR OTHER OPTIONS
         LA    R8,BUFFER+4        POINT PAST WCC AND SPF FLAG
         MVC   BUFFER(1),4(R15)   MOVE THE DEFAULT WCC IN
*
         TM    IOCBFLGS,IOCBFNBP+IOCBFNRR+IOCBFNRS  WERE THERE O'RIDES
         BO    WCCOK              NO, USE WCC FROM FORMAT
         NC    BUFFER(1),IOCBFLGS           REMOVE OVERRIDDEN BITS
         OC    BUFFER(1),IOCBWCC            SET THE OVERRIDE VALUES
WCCOK    OI    BUFFER,X'C0'       MAKE THE WCC PRINTABLE
*
         MVC   BUFFER+1(3),=X'115D7F'  SET SPF FLAG FIELD
         LA    R4,6(,R15)         POINT AT FIRST ENTRY
         TM    FLAGS,CLEARED      IS RE-FORMAT NECESSARY
         BZ    UPDATE             NO, JUST THE CHANGED FIELDS
*
         MVC   0(L'CLRORD,8),CLRORD    MOVE IN ORDERS TO CLEAR SCREEN
         LA    R8,L'CLRORD(,R8)        BUMP POINTER OF CLEAR ORDERS
         LH    R3,0(,R15)         GET LENGTH OF LOCAL AREA
         LA    R2,LOCAL           POINT AT LOCAL AREA
         SR    R1,R1              SET UP TO CLEAR THE AREA
         MVCL  R2,R0              ZERO THE WHOLE THING
*
*   BUILD THE ORDERS TO INSERT THE ATTRIBUTE BYTES
*
NXTATR   MVI   0(R8),X'11'        SBA
         LA    R8,1(,R8)
         LH    R1,2(,R4)          GET THE BUFFER ADDRESS
         BCTR  R1,0               BACK UP TO THE ATTRIBUTE BYTE
         BAL   R14,ENCODE         GO SET UP AN ADDRESS
*
         MVI   0(R8),X'1D'        START FIELD
         MVC   1(1,R8),1(R4)      MOVE IN THE ATTRIBUTE BYTE
         LA    R8,2(,R8)
         TM    1(R4),X'30'        IS THIS A DISPLAY FIELD
         BO    NOFILL             YES, IT CAN BE EXTENDED TO COVER FILL
*
         LH    R1,6(,R4)          GET THE FIELD LENGTH
         AH    R1,2(,R4)          COMPUTE THE NEXT ATTRIBUTE BYTE
         LA    R1,1(,R1)          POINT AT THE NEXT DATA BYTE
         CR    R4,R7              IS THERE ANOTHER FIELD
         BNL   DOFILL             NO, MUST LIMIT THIS ONE
*
         CH    R1,10(,R4)         IS NEXT FIELD ADJACENT
         BE    NOFILL             YES, IT WILL PROVIDE A LIMIT
         BL    DOFILL             OTHERWISE CREATE A DUMMY FIELD
         EX    0,BOMB             OVERLAPPING FIELDS IN FORMAT TABLE
*
DOFILL   MVI   0(R8),X'11'        SBA
         LA    R8,1(,R8)          POINT TO NEXT BUFFER BYTE
         BCTR  R1,0               POINT AT THE ATTRIBUTE BYTE
         BAL   R14,ENCODE
*
         MVC   0(2,R8),=X'1D7C'   BLANK PROTECTED FIELD
         LA    R8,2(,R8)
*
NOFILL   BXLE  R4,R6,NXTATR       GO DO THE NEXT FIELD
*
         EJECT
*
*   AT THIS POINT R8 POINTS TO A BUFFER POSITION AT WHICH TO PLACE A
*   SERIES OF ORDERS TO UPDATE THE SCREEN TO LOOK LIKE THE USERS IMAGE.
*   THE ACTUAL CONTENTS ARE IN THE LOCAL IMAGE.
*
UPDATE   SR    R9,R9              INDICATE NO CURRENT BUFFER POSITION
         LA    R4,6(,R15)         POINT AT THE FIRST FORMAT ENTRY
*
NXTFIELD LH    R2,4(R4)           GET IMAGE OFFSET
         LA    R0,LOCAL(R2)       GET POSITION IN LOCAL IMAGE
         A     R2,IOCBIMG         GET POSITION IN USER IMAGE
*
         LH    R3,6(,R4)          GET THE FIELD LENGTH
         LR    R1,R3
         LR    R5,R2              SAVE START OF FIELD
         CLCL  R0,R2              LOOK FOR DIFFERENCES
         BE    MATCH              THEY ARE THE SAME
*
         SH    R1,6(,R4)          NUMBER OF BYTES THAT ARE THE SAME
         LCR   R1,R1
         CH    R1,=H'3'           IS IT WORTH A SBA
         BH    LNGMATCH           YES, GO DO ONE
*
         LR    R2,R5              NO, BACK UP TO START OF FIELD
         AR    R3,R1              RESTORE COUNT
         CH    R9,2(R4)           DID A PREVIOUS COMMAND PLACE US THERE
         BE    NOSBA1             YES, NO NEED TO DO A SBA
*
         MVI   0(R8),X'11'        SBA
         LA    R8,1(,R8)
         LH    R1,2(,R4)          POINT AT FIRST DATA BYTE
         BAL   R14,ENCODE
*
NOSBA1   TM    0(R4),X'C0'        IS A CURSOR NEEDED AT START OF FIELD
         BNM   NOCUR1             NO
         TM    IOCBFLGS,IOCBFCUR  HAS HE OVERRIDDEN THE CURSOR POSITION
         BO    NOCUR1             YES, DON'T NEED ONE HERE
*
         MVI   0(R8),X'13'        INSERT THE CURSOR
         LA    R8,1(,R8)
*
NOCUR1   B     DATAMOVE           GO PLACE THE ACTUAL DATA IN STREAM
*
LNGMATCH LR    R5,R1              SAVE BYTE COUNT REMAINING
         TM    0(R4),X'C0'        DID WE NEED A CURSOR
         BNM   NOCUR2             NO, JUST GO DO THE DATA
         TM    IOCBFLGS,IOCBFCUR  HAS HE OVERRIDDEN THE CURSOR POSITION
         BO    NOCUR2             YES, DON'T HONOR THE FORMAT BYTE
         CH    R9,2(R4)           MAYBE WE ARE ALREADY THERE
         BE    NOSBA2             YES, HOW LUCKY
*
         MVI   0(R8),X'11'        WHAT A LOT OF WORK FOR A MEASLY
         LA    R8,1(,R8)             LITTLE CURSOR.
         LH    R1,2(,R4)          POINT AT THE DATA ADDRESS
         BAL   R14,ENCODE
*
NOSBA2   MVI   0(R8),X'13'        INSERT CURSOR
         LA    R8,1(,R8)
*
NOCUR2   MVI   0(R8),X'11'
         LA    R8,1(,R8)
         LH    R1,2(,R4)          GET FIELD ADDRESS IN 3270
         AR    R1,R5              MOVE TO POINT OF FIRST DIFFERENCE
         BAL   R14,ENCODE
*
*   R8=BUFFER LOCATION  R2=DATA ADDRESS   R3=DATA LENGTH
*
DATAMOVE STM   R2,R3,28(R13)      SAVE INPUT POINTERS
         LH    R1,4(,R4)          GET IMAGE OFFSET
         LA    R0,LOCAL(R1)       COMPUTE LOCAL FIELD START
         LR    R1,R3              GET DATA LENGTH
         SH    R1,6(,R4)          GET COMPLEMENT OF NUMBER OF MATCHES
         SR    R0,R1              BUMP LOCAL FIELD ADDRESS
         LR    R1,R3              GET NUMBER OF BYTES TO MOVE
         MVCL  R0,R2              UPDATE LOCAL IMAGE
         LM    R2,R3,28(R13)      RESTORE THE DATA POINTERS
         BCTR  R2,0               ADJUST FOR REVERSE SCAN
*
BLNKOUT  LA    R5,0(R2,R3)        POINT AT TRAILING BYTE
         CLI   0(R5),C' '         IS IT A BLANK
         BNE   SHORTND            NO, END OF TRUNCATION
         BCT   R3,BLNKOUT         THROW AWAY THE BLANKS
         BCTR  R5,0               ALLOW BLANKING OF 1-BYTE FIELDS
         B     INSPT              JUST WIPE OUT REST OF FIELD
*
SHORTND  LA    R2,1(,R2)          POINT BACK AT FIRST BYTE
         LA    R9,BUFFER+L'BUFFER-16        LAST ALLOWABLE ADDRESS
         SR    R9,R8
         CR    R9,R3              WILL IT FIT
         BH    LENOK
         EX    0,BOMB             GENERATED DATA EXCEEDS BUFFER LENGTH
*
LENOK    LR    R9,R3
         LR    R1,R9              SAVE OUTPUT LENGTH
         MVCL  R8,R2
         LR    R3,R1              RETRIEVE OUTPUT LENGTH
         LR    R2,R8
         SR    R2,R3              COMPUTE OUTPUT ADDRESS
*
         TM    0(R4),X'02'        DO WE WANT LOWER CASE OUTPUT
         BZ    UPCOUTPT           BRANCH IF NOT
         BAL   R14,LOCASE         CONVERT WITH LOWER CASE ALLOWED
         B     INSPT              CONTINUE WITH OUTPUT
*
UPCOUTPT BAL   R14,UPCASE         CONVERT TO UPPER CASE ONLY
*
INSPT    TM    0(R4),X'C0'        DOES HE WANT A CURSOR HERE
         BNO   NOCUR3
         TM    IOCBFLGS,IOCBFCUR  HAS HE OVERRIDDEN THE CURSOR POSITION
         BO    NOCUR3             YES, THEN HE DOESN'T WANT ONE HERE
         MVI   0(R8),X'13'        INSERT CURSOR
         LA    R8,1(,R8)
*
NOCUR3   S     R5,28(,R13)        COMPUTE DISTANCE TO END OF FIELD
         S     R5,32(,R13)        GET -1-REMAINING BYTES
         LCR   R5,R5              THAT MAKES IT REMAINING BYTES + 1
         BCT   R5,*+8             CHECK FOR FULL FIELD
         B     NONULL             IF SO, DO NOT PUT THE NULL IN
*
         MVI   0(R8),0            INSERT A NULL
         LA    R8,1(,R8)
*
NONULL   MVI   0(R8),X'05'        INSERT A PT ORDER
         LA    R8,1(,R8)
         LR    R9,R4              POINT AT CURRENT FMT ENTRY
*
PTSCAN   BXH   R9,R6,NOUNP        POINT TO NEXT FORMAT ENTRY
         TM    1(R9),X'20'        IS THE FIELD UNPROTECTED
         BO    PTSCAN             NO. PT ORDER WILL SKIP IT
         LH    R9,2(,R9)          GET STOPPING POINT FOR PT ORDER
         B     ENDFIELD
*
MATCH    TM    IOCBFLGS,IOCBFCUR  HAS HE OVERRIDDEN THE CURSOR POSITION
         BO    ENDFIELD           YES, THEN WE ARE THROUGH HERE
         TM    0(R4),X'C0'        DID THE FORMAT CALL FOR A CURSOR
         BZ    ENDFIELD           NO, GO TO NEXT FIELD
         BO    MATSCAN            YES, AFTER ALL THE DATA
*
         CH    R9,2(,R4)          IS THE BUFF ADD NOW AT RIGHT POINT
         BE    NOSBA4             YES, HOW FORTUTITOUS
         LH    R1,2(,R4)          GET THE DATA ADDRESS
*
MATSBA   MVI   0(R8),X'11'        SBA
         LA    R8,1(,R8)
         BAL   R14,ENCODE
*
NOSBA4   MVI   0(R8),X'13'        INSERT CURSOR
         LA    R8,1(,R8)
         SR    R9,R9              INDICATE UNKNOWN BUFFER ADDRESS
         B     ENDFIELD
*
MATSCAN  LH    R1,6(,R4)          GET FIELD LENGTH
*
MATSCANL BCTR  R2,0               MOVE POINTER BACK ONE
         CLI   0(R2),C' '         IS THIS A BLANK
         BNE   MATSCANE           YES, PLACE THE CURSOR HERE
         BCT   R1,MATSCANL
*
MATSCANE AH    R1,2(,R4)          COMPUTE CURSOR ADDRESS
         B     MATSBA
*
NOUNP    SR    R9,R9              INDICATE NO FOLLOWING UNPROTECTED
ENDFIELD BXLE  R4,R6,NXTFIELD     GO DO NEXT FIELD
*
*  NOW THAT THE SCREEN HAS BEEN FORMATTED WE CAN PLACE THE SPECIAL
*  FIELD IN THE LOWER RIGHT CORNER FOR ERASE INPUT DETECTION.
*
         MVC   0(7,R8),=X'115D7D1D5D6A6A'  ROW 24 COL  78
         LA    R8,7(,R8)          BUMP THE FIELD POINTER
         TM    IOCBFLGS,IOCBFCUR  HAS HE OVERRIDDEN THE CURSOR POSITION
         BZ    NOCUR4             NO, THEN CURSOR IS ALREADY IN
*
         LH    R1,IOCBCUR         GET IMAGE OFFSET OF CURSOR
         L     R4,IOCBFMT         GET FIRST FORMAT ENTRY
         LA    R4,6(,R4)          SKIP THE HEADER
*
CURSCAN  LH    R2,4(,R4)          GET THE IMAGE OFFSET OF THE FIELD
         AH    R2,6(,R4)          COMPUTE END OF FIELD
         CR    R1,R2              SEE IF CURSOR IS IN FIELD
         BL    CURFND             YES, GO PLACE IT THERE
         BXLE  R4,R6,CURSCAN      GO CHECK THE NEXT ENTRY
         EX    0,BOMB             CURSOR IS BEYOND END OF IMAGE
*
CURFND   SH    R1,4(,R4)          COMPUTE OFFSET IN FIELD
         BNM   CUROK              CHECK FOR INCLUSION
         EX    0,BOMB             CURSOR IS IN IMAGE FILL AREA
*
CUROK    AH    R1,2(,R4)          COMPUTE TUBE ADDRESS
         MVI   0(R8),X'11'        SBA
         LA    R8,1(,R8)
         BAL   R14,ENCODE
*
         MVI   0(R8),X'13'        INSERT CURSOR
         LA    R8,1(,R8)
*
NOCUR4   LA    R9,BUFFER          POINT AT FRONT OF BUFFER
         SR    R8,R9              COMPUTE DATA LENGTH
*
         TPUT  (R9),(R8),FULLSCR
         LTR   R15,R15
         BZ    *+8
         EX    0,BOMB                  ERROR FROM TPUT
*
         MVI   FLAGS,LASTOPW                REMEMBER THE STATUS
         TM    IOCBFLGS,IOCBFNRD  WAS A READ REQUESTED
         BZ    READ               YES, GO ISSUE IT
*
         TM    IOCBFLGS,IOCBFNWT  DID HE WANT ME TO DO THE WAIT
         BZ    EXIT               YES, IT'S ALREADY DONE
         EX    0,BOMB                  NO WAIT REQUESTED
*
NOWRITE  TM    IOCBFLGS,IOCBFW8   WAS A WAIT ONLY REQUESTED
         BO    BADREQST           YES, WE CAN'T DO THAT
         TM    FLAGS,LASTOPW      WAS LAST OPERATION A WRITE
         BO    READ               YES, THEN GO DO THE READ
*
BADREQST EX    0,BOMB             NO, ATTEMPT TO READ TWICE IN A ROW
*
READ     LA    R9,BUFFER
         LA    R8,L'BUFFER
*
         TGET  (R9),(R8),ASIS
         CH    R15,=H'8'               CHECK RESULTS
         BL    TGETOK
         BE    SIMPA1                  ATTN WAS PROCESSED
         EX    0,*
*
SIMPA1   MVI   BUFFER,AIDPA1           SET ATTENTION AID
*
TGETOK   MVI   FLAGS,LASTOPR      INDICATE ALL I/O COMPLETE
         MVC   IOCBAID,BUFFER     SAVE THE ATTENTION DESCRIPTION
*
         CLI   IOCBAID,AIDCLR     DID HE HIT THE CLEAR KEY
         BE    CLEAR              YES, GO INDICATE ZEROED BUFFER
         CLI   IOCBAID,AIDCAN     DID HE HIT CANCEL (PA2)
         BE    CANCEL             YES, GIVE BACK ORIGINAL SCREEN
         CLI   IOCBAID,AIDPA1     IS IT SOME OTHER FUNCTION
         BE    PA1
         CLI   IOCBAID,AIDPA3
         BE    PA3
*
         CLI   IOCBAID,X'01'      TEST FOR TCAM TEST REQ
         BNE   *+8                BRANCH IF NOT
         MVI   IOCBAID,X'F0'      SET REAL TEST REQ
*
         TM    IOCBAID,X'40'      IS IT A VALID AID
         BO    AIDVALID           YES, GO LOOK AT MANUAL INPUT
         EX    0,BOMB             AID BYTE WAS NOT VALID
*
AIDVALID LR    R5,R1              GET LENGTH OF INPUT DATA
         LA    R5,BUFFER-5(R5)    POINT AT LAST 5 BYTES
         CLC   0(5,R5),=X'115D7E6A6A'       IS LAST FIELD EXPECTED ONE
         BE    CNVTCUR            YES, USER DID NOT HIT ERASE INPUT
*
*   THE SPECIAL FIELD THAT WAS PLACED IN THE LOWER RIGHT HAND CORNER
*   OF THE SCREEN WAS TAMPERED WITH. THE ASSUMPTION IS MADE THAT THE
*   USER HIT THE ERASE INPUT FIELD. IF HE WAS JUST FUTZING AROUND,
*   TOO BAD FOR HIM. THE FIELD IS NON-DISPLAY ANAYWAY.
*
         L     R4,IOCBFMT
         LA    R4,6(,R4)          POINT AT HTE FIRST FORMAT ENTRY
*
ERSINP   TM    1(R4),X'20'        IS THIS A PROTECTED FIELD
         BO    ERSPRO             YES, THEN DON'T ERASE IT
         LH    R2,4(,R4)          GET THE IMAGE OFFSET
         LA    R2,LOCAL(R2)       POINT AT THE LOCAL COPY
         LH    R3,6(,R4)          GET THE FIELD LENGTH
         SR    R1,R1              SET UP FOR FIELD ZEROING
         ICM   R1,8,=C' '         MAKE THE FILL CHARACTER A BLANK
         MVCL  R2,R0              BLANK OUT THE FIELD
*
ERSPRO   BXLE  R4,R6,ERSINP       GO DO THE NEXT FIELD
         CLC   0(3,R5),=X'115D7E6A6A'       IS THE FIELD STILL THER
         BE    CNVTCUR            FIELD IS STILL THERE, BUT DIFFERENT
         LA    R5,1(,R5)          MOVE TO LAST POSSIBLE POSITION
         CLC   0(3,R5),=X'115D7E6A6A'       DID HE ONLY DO IN ONE BYTE
         BE    CNVTCUR            YES, IGNORE THAT FIELD
         LA    R5,4(,R5)          FIELD IS GONE COMPLETELY
*
CNVTCUR  LA    R8,BUFFER+1        POINT AT BYTE AFTER THE AID
         BAL   R14,DECODE         GET THE IMAGE OFFSET FOR IT
         STH   R1,IOCBCUR         FEED IT BACK TO THE USER
         CR    R8,R5              IS THE BUFFER EXHAUSTED
         BNL   EOB                IF SO, COPY THE UPDATED BUFFER
         CLI   0(R8),X'11'        VERIFY THAT IT IS A SBA ORDER
         BNE   CLEAR              BUFFER WAS NOT FORMATTED, IGNORE IT
*
INPFIELD LA    R8,1(,R8)          POINT PAST THE SBA
         BAL   R14,DECODE         GET THE IMAGE OFFSET
         CH    R1,4(,R4)          DOES IT POINT TO FIELD START
         BE    ADDROK
         EX    0,BOMB             RETURNED ATTR ADDR+1 WAS NOT VALID
*
ADDROK   LR    R2,R8              GET DATA ADDRESS
         LR    R3,R5              GET EOB ADDRESS
         SR    R3,R2              COMPUTE REMAINING BYTES
         BP    SBALOOP            CHECK FOR LEGAL DATA FORMAT
         LR    R1,R8              USER ERASED THE FIELD
         BZ    FNDSBA             GO COPY NO BYTES TO THE IMAGE
         EX    0,BOMB             INPUT DATA WAS TOO SHORT
*
SBALOOP  CH    R3,=H'256'
         BNH   SHRTRT             IS LENGTH DOWN BELOW 257
         TRT   0(256,R2),TRTSBA   LOOK FOR AN SBA BYTE
         BNZ   FNDSBA             WAS ONE FOUND
         AH    R2,=H'256'         NO, ADVANCE ONE SWATCH
         SH    R3,=H'256'         REDUCE THE COUNT
         B     SBALOOP            GO TRY SOME MORE
*
SHRTRT   BCTR  R3,0               REDUCE COUNT FOR EX
         EX    R3,EXTRT           ONE LAST SCAN
         BNZ   FNDSBA             WAS ONE FOUND
         LA    R1,1(R2,R3)        NO, POINT PAST END OF BUFFER
*
FNDSBA   SR    R1,R8              GET INPUT FIELD LENGTH
         LR    R0,R8              GET FIELD ADDRESS
         AR    R8,R1              POINT AT THE LOCATED BYTE
         LR    R3,R1              SET UP FOR UPCASE ROUTINE
         LH    R2,4(,R4)          GET IMAGE OFFSET
         LA    R2,LOCAL(R2)       POINT AT DESTINATION
         LR    R14,R2
         LH    R15,6(,R4)         GET DESTINATION LENGTH
         ICM   R1,8,=C' '         SET UP THE PAD CHARACTER
         MVCL  R14,R0             COPY INPUT INTO IMAGE
*
         TM    0(R4),X'01'        TEST FOR LOWER CASE TRANSLATION
         BZ    UPCINPUT           BRANCH IF NOT
         BAL   R14,LOCASE         TRANSLATE TO LOWER CASE
         B     INPUTXLT           AND GO CHECK FOR END OF BUFFER
*
UPCINPUT BAL   R14,UPCASE         TRANSLATE TO UPPER CASE
*
INPUTXLT CR    R8,R5              IS THAT END OF BUFFER
         BL    INPFIELD           NO, GO DO THE NEXT ONE
*
EOB      BE    CANCEL             MAKE SURE EOB HIT RIGHT ON
         EX    0,BOMB             END OF INPUT BUFFER WAS MISSED
*
CANCEL   L     R2,IOCBIMG         POINT AT USER IMAGE AREA
         LA    R0,LOCAL           POINT AT OUR IMAGE AREA
         L     R14,IOCBFMT        POINT AT USER FORMAT
         LH    R1,0(,R14)         GET IMAGE LENGTH
         LR    R3,R1
         MVCL  R2,R0              COPY LOCAL IMAGE TO USER IMAGE
         CLI   IOCBAID,AIDCAN     DID WE GET HERE FROM CANCEL KEY
         BNE   EXIT               NO,RETURN TO USER
*
PA1      DS    0H
PA3      DS    0H
CLEAR    MVI   FLAGS,CLEARED      INDICATE THAT TUBE IS NOT FORMATTED
         B     EXIT               RETURN TO USER
*
         EJECT
EXIT     L     R13,4(,R13)        POINT TO CALLERS REGISTERS
         RETURN (14,12),RC=0
*
*   CONVERT A HALF WORD BUFFER ADDRESS TO 3270 FORMAT
*
*        R1 = 12 BIT BUFFER ADDRESS
*        R8 = OUTPUT AREA ADDRESS
*
ENCODE   SLDL  R0,26              GET TWO 6-BIT QUANTITIES
         SRL   R1,2               MAKE THEM 8-BIT QUANTITIES
         SRDL  R0,8               IN THE SAME REGISTER
         STCM  R1,12,0(R8)        PLACE THEM IN THE DATA STREAM
         TR    0(2,R8),TABLENC    MAKE THEM PRINTABLE
         LA    R8,2(,R8)          BUMP THE OUTPUT ADDRESS
         BR    R14                RETURN TO CALLER
*
TABLENC  DC    C' ABCDEFGHI.<(+|&&JKLMNOPQR!$*);-/STUVWXYZ,%_>?01234X
               56789:#@''="'      TABLE TO MAKE ADDRESSES PRINTABLE
*
BOMB     EX    0,BOMB
*
*   ROUTINE TO CONVERT A FIELD TO VALID DISPLAYABLES
*        R2=ADDRESS
*        R3=LENGTH
*        R14=RETURN
*        R15 IS SET TO POINT TO THE PROPER TRANSLATION TABLE
*
LOCASE   LA    R15,LOCTBL         POINT AT LOWER CASE TABLE
         B     UPLOCASE           AND GO TRANSLATE
*
UPCASE   LA    R15,UPCTBL         POINT AT UPPER CASE TABLE
*
UPLOCASE CH    R3,=H'256'         IS IT TOO SHORT FOR A LONG TR
         BL    LASTPASS           YES, GO DO AN EXECUTED ONE
         TR    0(256,R2),0(R15)   CONVERT A SWATCH
         LA    R2,256(,R2)        MOVE TO NEXT SWATCH
         SH    R3,=H'256'         DECREASE REMAINING COUNT
         BNZ   UPLOCASE           GO DO IT AGAIN
*
LASTPASS SH    R3,=H'1'           REDUCE FOR EXECUTE
         BMR   R14                YES, JUST RETURN
         EX    R3,TRUPC           CONVERT TAIL END TO U.C.
         BR    R14
*
TRUPC    TR    0(0,R2),0(R15)     *** EXECUTE ONLY ***
*
UPCTBL   DC    256C'?'                 ALL INVALIDS GO TO QUESTION
         ORG   UPCTBL+C' '
         DC    C' '
         ORG   UPCTBL+C''
         DC    C'.<(+|&&'
         ORG   UPCTBL+C'!'
         DC    C'!$*);-/'
         ORG   UPCTBL+C','
         DC    C',%_>?'
         ORG   UPCTBL+C':'
         DC    C':#@''="'
         ORG   UPCTBL+X'81'
         DC    C'ABCDEFGHI'
         ORG   UPCTBL+X'91'
         DC    C'JKLMNOPQR'
         ORG   UPCTBL+X'A2'
         DC    C'STUVWXYZ'
         ORG   UPCTBL+C'A'
         DC    C'ABCDEFGHI'
         ORG   UPCTBL+C'J'
         DC    C'JKLMNOPQR'
         ORG   UPCTBL+C'S'
         DC    C'STUVWXYZ'
         ORG   UPCTBL+C'0'
         DC    C'0123456789'
         ORG
*
LOCTBL   DC    256C'?'                 ALL INVALIDS GO TO QUESTION
         ORG   LOCTBL+C' '
         DC    C' '
         ORG   LOCTBL+C''
         DC    C'.<(+|&&'
         ORG   LOCTBL+C'!'
         DC    C'!$*);-/'
         ORG   LOCTBL+C','
         DC    C',%_>?'
         ORG   LOCTBL+C':'
         DC    C':#@''="'
         ORG   LOCTBL+X'81'
         DC    X'818283848586878889'
         ORG   LOCTBL+X'91'
         DC    X'919293949596979899'
         ORG   LOCTBL+X'A2'
         DC    X'A2A3A4A5A6A7A8A9'
         ORG   LOCTBL+C'A'
         DC    C'ABCDEFGHI'
         ORG   LOCTBL+C'J'
         DC    C'JKLMNOPQR'
         ORG   LOCTBL+C'S'
         DC    C'STUVWXYZ'
         ORG   LOCTBL+C'0'
         DC    C'0123456789'
         ORG
*
*   ROUTINE TO FIND THE IMAGE OFFSET FOR A BUFFER ADDRESS
*   INPUT:  R8=ADDRESS OF INPUT,  R6 AND R7 SET UP FOR BXLE THROUGH FMT
*   OUTPUT:  R1= IMAGE OFFSET, R4 POINTS AT FORMAT ENTRY
*      R1 = -1 IF BUFFER ADDRESS IS OUTSIDE OF THE IMAGE
*
DECODE   L     R4,IOCBFMT
         LA    R4,6(,R4)          POINT AT FIRST FORMAT
         IC    R0,1(,R8)          GET THE SECOND BYTE
         SLL   R0,2               REMOVE HIGH TWO BITS
         ICM   R0,2,0(R8)         TACK ON THE FIRST BYTE
         SRL   R0,2               PUT IT IN LOW 12 BITS
         LA    R1,4095            SET MASK FOR 12 BITS
         NR    R1,R0              GET THE BINARY BUFFER OFFSET
         LA    R8,2(,R8)          BUMP THE SCAN POINTER
*
DECDL    LH    R0,2(,R4)          GET FIELD START
         CR    R0,R1              IS THIS IT
         BE    DECDF              YES, RIGHT ON THE DOT
         BH    DECDERR            FIELD IS NOT DEFINED
         AH    R0,6(,R4)          POINT AT END OF FIELD
         CR    R0,R1              CHECK FOR INCLUSION
         BH    DECDF              YES, GOT IT
         BXLE  R4,R6,DECDL        GO TRY NEXT FIELD
*
DECDERR  LH    R1,=H'-1'          SET ERROR INDICATION
         BR    R14
*
DECDF    SH    R1,2(,R4)          GET RELATIVE POSITION IN FIELD
         AH    R1,4(,R4)          POINT INTO IMAGE INSTEAD
         BR    R14                RETURN TO CALLER
*
         EJECT
LITERALS LTORG
*
TCAMCLR  DC    X'C3',X'11',X'5D',X'7E'
*              WCC   SBA   R24   C79
         DC    X'11',X'40',X'40',X'3C',X'40',X'40',X'00'
*              SBA   R1    C1    RA    R1    C1    NULL
         DC    X'11',X'40',X'40',X'13'
*              SBA   R1    C1    IC
TCAMCLRL EQU   *-TCAMCLR
*
CLRORD   DC    X'1140403C404000'       ORDERS TO CLEAR SCREEN
*                SBA,R1C1,RA,R1C1,NULL
*
EXTRT    TRT   0(0,R2),TRTSBA     SCAN FOR SBA
*
TRTSBA   DC    XL17'0',X'01',XL238'0'       TRT TABLE FOR SBA ORDER
*
PATCH    DS    XL50'0'
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
IOCB     DSECT
         IOCB
*
WORK     DSECT
         DS    9D                 SAVE AREA
FLAGS    DS    X
CLEARED  EQU   X'20'
LASTOPR  EQU   X'10'
LASTOPW  EQU   X'08'
FLAGS2   DS    X
VTAM     EQU   X'80'              VTAM IS TERMINAL ACCESS METHOD
FMTHEAD  DS    CL6
DSECSIZE DS    F
BUFFER   DS    CL3072
LOCAL    DS    0D
WORKLEN  EQU   *-WORK
         END
