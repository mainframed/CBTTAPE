/* REXX */
/*                        */
/* AUTHOR: Mark Zelden    */
/*                        */
/* Trace ?r */
/*********************************************************************/
/* This exec will show the MEMLIMIT and 64-bit storage allocation    */
/* for all tasks running in the system.  The allocation numbers      */
/* come from the RSM Address Space Block Extension (RAX).            */
/*                                                                   */
/* For z/OS 1.5 and above, 64-bit shared memory allocations are      */
/* included as well as system wide 64-bit shared memory usage.       */
/*                                                                   */
/* For z/OS 1.9 and above, 64-bit large memory allocations are       */
/* included as well as system wide 64-bit large memory usage.        */
/*                                                                   */
/* For z/OS 1.10 and above, 64-bit common memory allocations are     */
/* included as well as system wide 64-bit common memory usage.       */
/*                                                                   */
/* For z/OS 1.12 and above, 64-bit large memory usage High Water     */
/* Mark (HWM) is displayed in the summary.  You can get this         */
/* display on z/OS 1.10 and z/OS 1.11 if you have APAR OA31116       */
/* installed.  See comments in source code for what you need         */
/* to change if you have this APAR installed and want the HWM.       */
/*                                                                   */
/* The system wide 64-bit shared memory and 64-bit common usage      */
/* numbers come from the RSM Control and Enumeration Area (RCE).     */
/*                                                                   */
/* See MVS Data Areas manual and SYS1.MODGEN(IARRAX)                 */
/*                           and SYS1.MODGEN(IARRCE)                 */
/*********************************************************************/
/* Be sure OA02888 is applied (z/OS 1.2, 1.3 and 1.4) or RAXLVGBYTES */
/* will not be cleared between job steps that run in an initiator.   */
/*********************************************************************/
/* SEE OA14391 for an explanation of MEMSRC.10 (IEFUSI + REGION=0)   */
/* After this APAR you won't see REG=0 as a reason if IEFUSI         */
/* changes your REGION without touching MEMLIMIT.                    */
/*********************************************************************/
/* TSO execution syntax: TSO %RXSTOR64                               */
/*                       TSO %RXSTOR64 ALL                           */
/*                       TSO %RXSTOR64 NODETAIL                      */
/*                                                                   */
/* By default, only tasks that have memory objects allocated will    */
/* be displayed unless the "ALL" option is used.  A system wide      */
/* summary of usage for HVSHARE/HVCOMMON/LFAREA is displayed at      */
/* the end. You can use the "NODETAIL" option if you only want       */
/* to see the summary informaion. Note that NODETAIL can be          */
/* abbreviated using one or more of its characters.                  */
/*********************************************************************/
Arg OPT
/*********************************************************************/
LASTUPD = '08/27/2016'              /* date of last update           */
/*********************************************************************/
Signal On  Syntax  name SIG_ALL     /* trap syntax errors            */
Signal On  Novalue name SIG_ALL     /* trap uninitialized variables  */
/*********************************************************************/
/* "NODETAIL" option - system wide totals only ??                    */
/*********************************************************************/
DETAIL = 'YES'
If Abbrev('NODETAIL',Translate(OPT),1) <> 0 then DETAIL = 'NO'

Numeric digits 20                           /* dflt of 9 not enough  */

CVT      = C2d(Storage(10,4))               /* point to CVT          */
CVTFLAG2 = Storage(D2x(CVT+377),1)          /* CVT flag byte 2       */
CVTOSLV3 = Storage(D2x(CVT+1267),1)         /* byte 3 of CVTOSLVL    */
CVTOSLV5 = Storage(D2x(CVT+1269),1)         /* byte 5 of CVTOSLVL    */
CVTOSLV6 = Storage(D2x(CVT + 1270),1)       /* Byte 6 of CVTOSLVL    */
RCE      = C2d(Storage(D2x(CVT + 1168),4))  /* point to RCE          */
FLCARCH  = Storage('A3',1)                  /* FLCARCH in PSA        */
If bitand(CVTOSLV3,'10'x) <> '10'x | ,      /* z/OS 1.2 or above ?   */
   C2d(FLCARCH) = 0 then do                 /* 0 means not z/Arch.   */
  Say 'System must be at least z/OS 1.2 and running in'
  Say 'z/Architecture mode to use this exec.'
  Exit 12
End
If bitand(CVTOSLV3,'02'x) = '02'x then ,    /* z/OS 1.5 and above?   */
   HVSHARE = 1                              /* set HVSHARE avail flag*/
  Else HVSHARE = 0                          /* below z/OS 1.5        */
If Bitand(CVTOSLV5,'10'x) = '10'x &     ,   /* z/OS 1.9 and above &  */
   Bitand(CVTFLAG2,'01'x) = '01'x then ,    /*  CVTEDAT on (z10 >)?  */
   LARGEMEM = 1                             /* set LARGEMEM avail flg*/
  Else LARGEMEM = 0                         /* < z/OS 1.9/no hw supt */
If bitand(CVTOSLV5,'08'x) = '08'x then ,    /* z/OS 1.10 and above   */
   HVCOMMON = 1                             /* set HVCOMMON avail flg*/
  Else HVCOMMON = 0                         /* below z/OS 1.10       */
If Bitand(CVTOSLV6,'80'x) = '80'x then ,    /* z/OS 2.1 and above    */
   PL = 1                                   /* pageable1m            */
  Else PL = 0                               /* no pageable1m         */
 /* HVSHARE = 0  */ /* force 0 for testing  - must set others to 0   */
 /* LARGEMEM = 0 */ /* force 0 for testing */
 /* HVCOMMON = 0 */ /* force 0 for testing */

CVTASVT  = C2d(Storage(D2x(CVT+556),4))     /* point to ASVT         */
ASVTMAXU = C2d(Storage(D2x(CVTASVT+516),4)) /* max number of entries */


If LARGEMEM = 1 then do                        /* z/OS 1.9 and above */
  RCEReconLFASize  = C2d(Storage(D2x(RCE + 760),8)) /* recon lfarea  */
  RCENonReconLFASize = C2d(Storage(D2x(RCE + 768),8)) /*  LFAREA     */
 /* Comment out or delete the next 2 lines of code if you want the   */
 /* large memory displays even if you specified or defaulted to      */
 /* LFAREA=0M (z/OS 1.9 & above) and have the hardware support.      */
  If RCEReconLFASize = 0 & RCENonReconLFASize = 0 then ,  /* both 0? */
   LARGEMEM = 0                         /* set LARGEMEM not avail flg*/
  If Bitand(CVTOSLV6,'80'x) = '80'x then do /* z/OS 2.1 and above    */
    /*****************/
    /* 2G frame code */
    /*****************/
    RCE2GMemoryObjects          = ,
     C2d(Storage(D2x(RCE + 1256),8))    /* Number of 2G objects      */
    RCE2GNonReconLFASize        = ,
     C2d(Storage(D2x(RCE + 1272),8))    /* 2G frame area in 2G units */
    RCE2GNonReconLFAUsed        = ,
     C2d(Storage(D2x(RCE + 1280),8))    /* used 2G frames            */
    RCE2GHWM                    = ,
     C2d(Storage(D2x(RCE + 1288),4))    /* 2G used frames HWM        */
    If RCE2GNonReconLFASize <> 0 then LARGEMEM = 1  /* lfarea used   */
  End
End /* If LARGEMEM = 1 */

If HVSHARE = 1 then do                         /* z/OS 1.5 and above */
   /* Memlimit Source Table */
  MEMSRC.0  = '       '
  MEMSRC.1  = '  SMF  '
  MEMSRC.2  = '  JCL  '
  MEMSRC.3  = ' REG=0 '
  MEMSRC.4  = ' IEFUSI'
  MEMSRC.5  = 'OMVSSEG'
  MEMSRC.6  = 'SETRLIM'
  MEMSRC.7  = ' SPAWN '
  MEMSRC.8  = 'SETOMVS'
  MEMSRC.9  = 'AUTHPGM'
  MEMSRC.10 = 'USIREG0'
If DETAIL = 'YES' then do
  If HVCOMMON = 1 & LARGEMEM = 1 then do       /* z/OS 1.10 & above  */
                                               /* + largemem support */
    Queue '                                6 4 - B I T  ' ,
          '  S T O R A G E     A L L O C A T I O N'
    Queue '  '
    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,
        ' GUARDED   HWM   SHARE   SHARE   SHARE  LARGE   LARGE' ,
        ' COMMN   COMMN   COMMN'
    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,
        '   MEM     MEM   # OBJ   ALLOC    HWM   # OBJ   ALLOC' ,
        ' # OBJ   ALLOC    HWM '
    Queue '--------  -------  -------  -----  ------' ,
        ' ------  ------  -----  ------  ------  -----  ------' ,
        ' -----  ------  ------'
  End /* If HVCOMMON = 1 & LARGEMEM = 1 */
  Else if HVCOMMON = 1 & LARGEMEM = 0 then do  /* z/OS 1.10 & above  */
                                               /* no largemem support*/
    Queue '                         6 4 - B I T  ' ,
          '  S T O R A G E     A L L O C A T I O N'
    Queue '  '
    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,
        ' GUARDED   HWM   SHARE   SHARE   SHARE  COMMN   COMMN' ,
        '  COMMN'
    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,
        '   MEM     MEM   # OBJ   ALLOC    HWM   # OBJ   ALLOC' ,
        '   HWM '
    Queue '--------  -------  -------  -----  ------' ,
        ' ------  ------  -----  ------  ------  -----  ------' ,
        ' ------'
  End /* If HVCOMMON = 1 & LARGEMEM = 0 */
  Else if LARGEMEM = 1 then do                 /* z/OS 1.9 & above   */
    Queue '                     6 4 - B I T     S T O R A G E  ' ,
          '  A L L O C A T I O N'
    Queue '  '
    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,
        ' GUARDED   HWM   SHARE   SHARE   SHARE  LARGE   LARGE'
    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,
        '   MEM     MEM   # OBJ   ALLOC    HWM   # OBJ   ALLOC'
    Queue '--------  -------  -------  -----  ------' ,
        ' ------  ------  -----  ------  ------  -----  ------'
  End /* if LARGEMEM = 1 */
  Else Do
    Queue '             6 4 - B I T     S T O R A G E  ' ,
          '  A L L O C A T I O N'
    Queue '  '
    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,
        ' GUARDED   HWM   SHARE   SHARE   SHARE'
    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,
        '   MEM     MEM   # OBJ   ALLOC    HWM '
    Queue '--------  -------  -------  -----  ------' ,
        ' ------  ------  -----  ------  ------'
  End /* else do */
End /* If DETAIL = 'YES' then do */
Else do
    Queue '6 4 - B I T    S T O R A G E ' ,
          '  A L L O C A T I O N    S U M M A R Y'
End
End /* if HVSHARE = 1 */
Else Do                                         /* below z/os 1.5    */
   /* Memlimit Source Table */
  MEMSRC.0  = '              '
  MEMSRC.1  = '     SMF      '
  MEMSRC.2  = '     JCL      '
  MEMSRC.3  = '   REGION=0   '
  MEMSRC.4  = '    IEFUSI    '
  MEMSRC.5  = ' OMVS SEGMENT '
  MEMSRC.6  = 'UNIX SETRLIMIT'
  MEMSRC.7  = '  UNIX SPAWN  '
  MEMSRC.8  = ' SETOMVS CMD  '
  MEMSRC.9  = ' AUTH PROGRAM '
  MEMSRC.10 = 'IEFUSI + REG=0'
  If DETAIL = 'YES' then do
  Queue '        6 4 - B I T     S T O R A G E     A L L O C A T I O N'
  Queue '  '
  Queue '  TASK      MEMORY      MEMLIMIT       NUM     ALLOC' ,
      '  GUARDED    HWM '
  Queue '  NAME      LIMIT        SOURCE        OBJ      MEM ' ,
      '    MEM      MEM '
  Queue '--------   -------   --------------   -----   ------' ,
      '  ------   ------'
  End /* If DETAIL = 'YES' then do */
End /* else do */

NUMOBJ  = 0     /* total number of tasks with private memory objects */
NUMSHR  = 0     /* total number of tasks with shared memory objects  */
NUMLRG  = 0     /* total number of tasks with large memory objects   */
NUMCOMN = 0     /* total number of tasks with common memory objects  */
Do I = 0 to ASVTMAXU-1 /* start at 0 so I*4 bumps to next entry      */
  ASVTENTY = Storage(D2x(CVTASVT+528+(I*4)),4)  /* cur ASVT entry    */
  ASVT_USED = Storage(D2x(CVTASVT+528+(I*4)),1) /* in use byte       */
  If Bitand(ASVT_USED,'80'x) == '80'x then iterate  /* avail, skip   */
  ASCB     = C2d(ASVTENTY)     /* change to decimal for code below   */
  ASCBRSME = C2d(Storage(D2X(ASCB+364),4))      /* point to RAX      */
  RAX      = ASCBRSME                           /* more readable     */
  If RAX   = 0 then iterate                /* Skip broken / NF asid? */
  ASCBJBN  = C2d(Storage(D2x(ASCB+172),4))      /* ASCBJBNI          */
  If ASCBJBN  = 0 then ,    /* not a job - must be START/LOGON/MOUNT */
     ASCBJBN  = C2d(Storage(D2x(ASCB+176),4))   /* ASCBJBNS          */

  TASKNAME    = Storage(D2x(ASCBJBN),8)         /* task name         */

  RAXLVNMOMB = C2d(Storage(D2x(RAX + 188),4))   /* number of objects */
  /* RAXLVNMOMB = 0 */   /* force 0 for testing */
  If RAXLVNMOMB <> 0 then ,
     NUMOBJ = NUMOBJ+1                      /* # tasks with objects  */

  If HVSHARE = 1 then do                       /* z/OS 1.5 & above   */
    RAXLVSHRNMOMB = C2d(Storage(D2x(RAX + 216),8)) /* # shr objects  */
  /* RAXLVSHRNMOMB = 1 */  /* force 1 for testing */
    If RAXLVSHRNMOMB <> 0 then ,
       NUMSHR = NUMSHR+1                    /* # tasks with shr objs */
  End /* if HVSHARE = 1 */
  Else RAXLVSHRNMOMB = 0  /* never any shared objects below z/OS 1.5 */

  If LARGEMEM = 1 then do                      /* z/OS 1.9 & above   */
    RAXLargeMemoryObjects =C2d(Storage(D2x(RAX+248),8)) /*# lrg objs */
  /* RAXLargeMemoryObjects = 1 */  /* force 1 for testing */
    If RAXLargeMemoryObjects <> 0 then ,
       NUMLRG = NUMLRG+1                    /* # tasks with shr objs */
  End /* if LARGEMEM = 1 */
  Else RAXLargeMemoryObjects=0    /* no large memory below z/OS 1.9  */

  If HVCOMMON = 1 then do                      /* z/OS 1.10 & above  */
    RAXHVCommonNMOMB = C2d(Storage(D2x(RAX + 280),8)) /* # comn objs */
  /* RAXHVCommonNMOMB = 1 */  /* force 1 for testing */
    If RAXHVCommonNMOMB <> 0 then ,
       NUMCOMN = NUMCOMN+1                  /* # tasks with comn objs*/
  End /* if HVCOMMON = 1 */
  Else RAXHVCommonNMOMB = 0       /* no shared common below z/OS 1.10*/

  If OPT <> 'ALL' & ,
    (RAXLVNMOMB=0 & RAXLVSHRNMOMB=0 & ,
     RAXLargeMemoryObjects=0 & RAXHVCommonNMOMB=0) then iterate

  RAXLVMEMLIM = C2d(Storage(D2x(RAX+152),8))    /* MEMLIMIT in MB    */
  RAXLVMEMLIM = FORMAT_MEMSIZE(RAXLVMEMLIM)     /* format size       */

  RAXLVMEMLIMS = C2d(Storage(D2x(RAX + 184),1)) /* MEMLIMIT source   */

  RAXLVABYTES = C2d(Storage(D2x(RAX + 160),8))  /* bytes allocated   */
  RAXLVABYTES = RAXLVABYTES/1024/1024           /* change to MB      */
  RAXLVABYTES = FORMAT_MEMSIZE(RAXLVABYTES)     /* format size       */

  RAXLVHBYTES = C2d(Storage(D2x(RAX + 168),8))  /* bytes guarded     */
  RAXLVHBYTES = RAXLVHBYTES/1024/1024           /* change to MB      */
  RAXLVHBYTES = FORMAT_MEMSIZE(RAXLVHBYTES)     /* format size       */

  RAXLVGBYTES = C2d(Storage(D2x(RAX + 176),8))  /* high water mark   */
  RAXLVGBYTES = RAXLVGBYTES/1024/1024           /* change to MB      */
  RAXLVGBYTES = FORMAT_MEMSIZE(RAXLVGBYTES)     /* format size       */

  If HVSHARE = 1 then do                       /* z/OS 1.5 & above   */
    RAXLVSHRBYTES = C2d(Storage(D2x(RAX + 200),8)) /* shr bytes alloc*/
    RAXLVSHRBYTES = RAXLVSHRBYTES/1024/1024        /* change to MB   */
    RAXLVSHRBYTES = FORMAT_MEMSIZE(RAXLVSHRBYTES)  /* format size    */

    RAXLVSHRGBYTES = C2d(Storage(D2x(RAX + 208),8)) /* shr bytes HWM */
    RAXLVSHRGBYTES = RAXLVSHRGBYTES/1024/1024       /* change to MB  */
    RAXLVSHRGBYTES = FORMAT_MEMSIZE(RAXLVSHRGBYTES) /* format size   */
  End /* if HVSHARE = 1 */

  If LARGEMEM = 1 then do                       /* z/OS 1.9 & above  */
    RAXLargePagesBackedinReal = ,
     C2d(Storage(D2x(RAX + 256),8))             /* large obj pages   */
    RAXLargePagesBackedinReal = ,
     FORMAT_MEMSIZE(RAXLargePagesBackedinReal)  /* format size       */
  End /* if LARGEMEM = 1 */

  If HVCOMMON = 1 then do                      /* z/OS 1.10 & above  */
    RAXHVCommonBytes = C2d(Storage(D2x(RAX + 264),8)) /*cmn bytes alc*/
    RAXHVCommonBytes = RAXHVCommonBytes/1024/1024     /* chg to MB   */
    RAXHVCommonBytes = FORMAT_MEMSIZE(RAXHVCommonBytes) /*format size*/

    RAXHVCommonHWMBytes = C2d(Storage(D2x(RAX + 272),8)) /*common HWM*/
    RAXHVCommonHWMBytes = RAXHVCommonHWMBytes/1024/1024  /* chg to MB*/
    RAXHVCommonHWMBytes = FORMAT_MEMSIZE(RAXHVCommonHWMBytes) /* fmt */

  End /* if HVCOMMON = 1 */

  If DETAIL = 'YES' then do

  If HVCOMMON = 1 & LARGEMEM = 1 then do       /* z/OS 1.10 & above  */
                                               /* + largemem support */

  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,
           ' 'MEMSRC.RAXLVMEMLIMS ,
           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,
              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,
           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,
              Right(RAXLVSHRGBYTES,7) ,
           ' 'Right(RAXLargeMemoryObjects,5) ,
              Right(RAXLargePagesBackedinReal,7) ,
           ' 'Right(RAXHVCommonNMOMB,5) Right(RAXHVCommonBytes,7) ,
              Right(RAXHVCommonHWMBytes,7)
  End /* If HVCOMMON = 1 & LARGEMEM = 1 */
  Else If HVCOMMON = 1 & LARGEMEM = 0 then do  /* z/OS 1.10 & above  */
                                               /* no largemem support*/
  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,
           ' 'MEMSRC.RAXLVMEMLIMS ,
           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,
              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,
           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,
              Right(RAXLVSHRGBYTES,7) ,
           ' 'Right(RAXHVCommonNMOMB,5) Right(RAXHVCommonBytes,7) ,
              Right(RAXHVCommonHWMBytes,7)
  End /* If HVCOMMON = 1 & LARGEMEM = 0 */
  Else if LARGEMEM = 1 then do                 /* z/OS 1.9 & above   */
  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,
           ' 'MEMSRC.RAXLVMEMLIMS ,
           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,
              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,
           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,
              Right(RAXLVSHRGBYTES,7) ,
           ' 'Right(RAXLargeMemoryObjects,5) ,
              Right(RAXLargePagesBackedinReal,7)
  End /* if HVSHARE = 1 */
  Else if HVSHARE = 1 then do                  /* z/OS 1.5 & above   */
  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,
           ' 'MEMSRC.RAXLVMEMLIMS ,
           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,
              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,
           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,
              Right(RAXLVSHRGBYTES,7)
  End /* if HVSHARE = 1 */
  Else Do                                      /* below z/os 1.5     */
  Queue TASKNAME '  'Right(RAXLVMEMLIM,7) ,
           '  'MEMSRC.RAXLVMEMLIMS ,
          '  'Right(RAXLVNMOMB,5)   ' 'Right(RAXLVABYTES,7) ,
           ' 'Right(RAXLVHBYTES,7)  ' 'Right(RAXLVGBYTES,7)
  End /* else do */

  End /* If DETAIL = 'YES' then do  */

End  /* Do I = 0 to ASVTMAXU-1 */


If (NUMOBJ = 0 & NUMSHR = 0 & ,
    NUMLRG = 0 & NUMCOMN = 0) & OPT <> 'ALL' then do
  Queue ' '
  Queue '** No tasks have memory objects allocated **'
  Queue '**    Use the "ALL" option for details    **'
  Queue ' '
End
Else do
  If HVSHARE = 1 then do                       /* z/OS 1.5 & above   */
    /**********************************/
    /* System wide totals for HVSHARE */
    /**********************************/
    RCELVSHRSTRT   = C2d(Storage(D2x(RCE + 544),8)) /* low virt addr */
                                                    /* for 64-bit shr*/
    RCELVSHRSTRT_D = C2x(Storage(D2x(RCE + 544),8)) /* make readable */
    VSHRSTRT_D     = Substr(RCELVSHRSTRT_D,1,8) ,   /*  address range*/
                     Substr(RCELVSHRSTRT_D,9,8)     /*   display     */

    RCELVHPRSTRT   = C2d(Storage(D2x(RCE + 552),8)) /* low virt addr */
                                                    /* for 64-bit prv*/
    RCELVHPRSTRT_D = C2d(Storage(D2x(RCE + 552),8))-1 /*make readable*/
    RCELVHPRSTRT_D = Right(D2x(RCELVHPRSTRT_D),16,'0') /* address    */
    VHPRSTRT_D     = Substr(RCELVHPRSTRT_D,1,8) ,    /*    range     */
                     Substr(RCELVHPRSTRT_D,9,8)      /*     display  */

    TOTAL_VHSHR    = RCELVHPRSTRT - RCELVSHRSTRT     /* total shared */
    TOTAL_VHSHR    = TOTAL_VHSHR/1024/1024           /* change to MB */
    TOTAL_VHSHR    = FORMAT_MEMSIZE(TOTAL_VHSHR)     /* format size  */

    RCELVSHRSTRT   = RCELVSHRSTRT/1024/1024          /* change to MB */
    RCELVSHRSTRT   = FORMAT_MEMSIZE(RCELVSHRSTRT)    /* format size  */

    RCELVHPRSTRT   = RCELVHPRSTRT/1024/1024          /* change to MB */
    RCELVHPRSTRT   = FORMAT_MEMSIZE(RCELVHPRSTRT)    /* format size  */

    RCELVSHRPAGES  = C2d(Storage(D2x(RCE + 584),8))  /* shr pages    */
    RCELVSHRPAGES  = (RCELVSHRPAGES*4)/1024          /* change to MB */
    RCELVSHRPAGES  = FORMAT_MEMSIZE(RCELVSHRPAGES)   /* format size  */

    RCELVSHRGBYTES = C2d(Storage(D2x(RCE + 592),8))  /* shr bytes HWM*/
    RCELVSHRGBYTES = RCELVSHRGBYTES/1024/1024        /* change to MB */
    RCELVSHRGBYTES = FORMAT_MEMSIZE(RCELVSHRGBYTES)  /* format size  */

    RCELVSHRNMOMB  = C2d(Storage(D2x(RCE + 600),4))  /* tot shr objs */

    Queue '   '
    Queue '   '
    Queue '   '
    Queue '64-BIT SHARED VIRTUAL STORAGE (HVSHARE) - SYSTEM WIDE USAGE'
    Queue '-----------------------------------------------------------'
    Queue '   '
    Queue 'SHARED STORAGE TOTAL:' TOTAL_VHSHR
    Queue 'SHARED STORAGE RANGE:' RCELVSHRSTRT'-'RCELVHPRSTRT ,
          '('VSHRSTRT_D' - 'VHPRSTRT_D')'
    Queue 'SHARED STORAGE ALLOCATED:' RCELVSHRPAGES
    Queue 'SHARED STORAGE ALLOCATED HWM:' RCELVSHRGBYTES
    Queue 'SHARED OBJECTS ALLOCATED:' RCELVSHRNMOMB
  End /* if HVSHARE = 1 */
  End /* if LARGEMEM = 1 */
  If HVCOMMON = 1 then do                      /* z/OS 1.10 & above  */
    /***********************************/
    /* System wide totals for HVCOMMON */
    /***********************************/
    RCEHVCommonStrt = C2d(Storage(D2x(RCE + 872),8)) /*low virt addr */
                                                     /*for 64-bit cmn*/
    CommonStrt_D   = C2x(Storage(D2x(RCE + 872),8))  /*make readable */
    CommonStrt_D   = Substr(CommonStrt_D,1,8) ,      /* address range*/
                     Substr(CommonStrt_D,9,8)        /*  display     */

    RCEHVCommonEnd = C2d(Storage(D2x(RCE + 880),8))  /*high virt addr*/
                                                     /*for 64-bit cmn*/
    RCEHVCommonEnd = RCEHVCommonEnd + 1              /* Add 1 to addr*/
    CommonEnd_D    = C2x(Storage(D2x(RCE + 880),8))  /*make readable */
    CommonEnd_D    = Substr(CommonEnd_D,1,8) ,       /* address range*/
                     Substr(CommonEnd_D,9,8)         /*  display     */

    TOTAL_VHCOMN   = RCEHVCommonEnd-RCEHVCommonStrt  /* total common */
    TOTAL_VHCOMN   = TOTAL_VHCOMN/1024/1024          /* change to MB */
    TOTAL_VHCOMN   = FORMAT_MEMSIZE(TOTAL_VHCOMN)    /* format size  */

    RCEHVCommonStrt = RCEHVCommonStrt/1024/1024      /* chg to MB    */
    RCEHVCommonStrt = FORMAT_MEMSIZE(RCEHVCommonStrt) /* format size */

    RCEHVCommonEnd = RCEHVCommonEnd/1024/1024        /* chg to MB    */
    RCEHVCommonEnd = FORMAT_MEMSIZE(RCEHVCommonEnd)  /* format  size */

    RCEHVCommonPAGES = C2d(Storage(D2x(RCE + 888),8)) /* comn pages  */
    RCEHVCommonPAGES = (RCEHVCommonPAGES*4)/1024      /* chg to MB   */
    RCEHVCommonPAGES = FORMAT_MEMSIZE(RCEHVCommonPAGES) /*format size*/

    RCEHVCommonHWMBytes = C2d(Storage(D2x(RCE + 896),8)) /* comn HWM */
    RCEHVCommonHWMBytes = RCEHVCommonHWMBytes/1024/1024  /*chg to MB */
    RCEHVCommonHWMBytes = FORMAT_MEMSIZE(RCEHVCommonHWMBytes) /* fmt */

    RCEHVCommonNMOMB = C2d(Storage(D2x(RCE + 904),8)) /*tot comn objs*/

    Queue '   '
    Queue '   '
    Queue '   '
    Queue '64-BIT COMMON VIRTUAL STORAGE (HVCOMMON) - SYSTEM' || ,
          ' WIDE USAGE'
    Queue '-------------------------------------------------' || ,
          '-----------'
    Queue '   '
    Queue 'COMMON STORAGE TOTAL:' TOTAL_VHCOMN
    Queue 'COMMON STORAGE RANGE:' RCEHVCommonStrt'-'RCEHVCommonEnd ,
          '('CommonStrt_D' - 'CommonEnd_D')'
    Queue 'COMMON STORAGE ALLOCATED:' RCEHVCommonPAGES
    Queue 'COMMON STORAGE ALLOCATED HWM:' RCEHVCommonHWMBytes
    Queue 'COMMON OBJECTS ALLOCATED:' RCEHVCommonNMOMB
  End /* if HVCOMMON = 1 */
  If LARGEMEM = 1 then do                      /* z/OS 1.10 & above  */
    /***********************************/
    /* System wide totals for LARGEMEM */
    /***********************************/
    RCELargeMemoryObjects = ,
     C2d(Storage(D2x(RCE + 744),8))             /*tot large mem objs */
    RCELargePagesBackedinReal = ,
     C2d(Storage(D2x(RCE + 752),8))             /* tot lrg obj pages */
    RCELFAvailGroups          = ,
     C2d(Storage(D2x(RCE + 796),4))             /* avial lrg frames  */
 /* RCEReconLFAUsed             = ,
     C2d(Storage(D2x(RCE + 776),8)) */ /* # recon 1M frames alloc    */
    RCENonReconLFAUsed          = ,
     C2d(Storage(D2x(RCE + 784),8))    /* # nonrecon 1M frames alloc */

 /* LFASize = RCEReconLFASize + RCENonReconLFASize */  /* LFAREA size*/
    LFASize = RCENonReconLFASize                       /* LFAREA size*/
 /* LFA_Used = RCEReconLFAUsed + RCENonReconLFAUsed */
    LFA_Used    = RCENonReconLFAUsed                   /* used LFAREA*/
    LFA_Alloc1M = RCELargePagesBackedinReal            /* 1M alloc   */
    LFA_Alloc4K = LFA_Used - LFA_Alloc1M               /* 4K alloc   */

    If PL = 1 then do                       /* pageable1m support    */
      RCELargeUsed4K              = ,
       C2d(Storage(D2x(RCE + 1032),4))      /* 4K used for 1M req    */
      LFA_Alloc4K = RCELargeUsed4K     /* chg var name for old code  */
      RceLargeAllocatedPL         = ,
       C2d(Storage(D2x(RCE + 1244),4))      /* # used pageable1m     */
      RceLargeUsedPLHWM           = ,
       C2d(Storage(D2x(RCE + 1252),4))      /* pageable1m HWM        */
    End

    LFASize     = FORMAT_MEMSIZE(LFASize)          /* format size    */
    LFA_Avail   = FORMAT_MEMSIZE(RCELFAvailGroups) /* format size    */
    LFA_Alloc1M = FORMAT_MEMSIZE(LFA_Alloc1M)      /* format size    */
    LFA_Alloc4K = FORMAT_MEMSIZE(LFA_Alloc4K)      /* format size    */

    If PL = 1 then do            /* z/OS 2.1 + pageable1m support    */
      RceLargeAllocatedPL = FORMAT_MEMSIZE(RceLargeAllocatedPL)
      RceLargeUsedPLHWM   = FORMAT_MEMSIZE(RceLargeUsedPLHWM)
      /*****************/
      /* 2G frame code */
      /*****************/
      LFA2G_Size  = FORMAT_MEMSIZE(RCE2GNonReconLFASize*2048)
      LFA2G_Used  = FORMAT_MEMSIZE(RCE2GNonReconLFAUsed*2048)
      LFA2G_avail = ((RCE2GNonReconLFASize-RCE2GNonReconLFAUsed)*2048)
      LFA2G_avail = FORMAT_MEMSIZE(LFA2G_avail)
      LFA2G_Max   = RCE2GHWM*2048
      LFA2G_Max   = FORMAT_MEMSIZE(LFA2G_Max)
    End
    /**************************************************************/
    /* If APAR OA31116 has been applied to your z/OS 1.10 or 1.11 */
    /* system you can change the check below to x'04' for 1.11    */
    /* or x'08' for 1.10.  Chg display about 25 lines below also. */
    /**************************************************************/

 /* If Bitand(CVTOSLV5,'08'x) = '08'x then do */ /* z/OS 1.10+OA31116*/
 /* If Bitand(CVTOSLV5,'04'x) = '04'x then do */ /* z/OS 1.11+OA31116*/
 /* If Bitand(CVTOSLV5,'02'x) = '02'x then do */ /* z/OS 1.12        */
    If Bitand(CVTOSLV5,'02'x) = '02'x then do /* z/OS 1.12 and above */
      RceLargeUsed1MHWM           = ,
       C2d(Storage(D2x(RCE + 804),4)) /*large pg HWM alloc behalf 1M */
      RceLargeUsed4KHWM           = ,
       C2d(Storage(D2x(RCE + 808),4)) /*large pg HWM alloc behalf 4K */
      LFA_Max1M = FORMAT_MEMSIZE(RceLargeUsed1MHWM)  /* format size  */
      LFA_Max4K = FORMAT_MEMSIZE(RceLargeUsed4KHWM)  /* format size  */
    End

    Queue '   '
    Queue '   '
    Queue '   '
    Queue '64-BIT LARGE MEMORY VIRTUAL STORAGE (LFAREA) - SYSTEM' || ,
          ' WIDE USAGE'
    Queue '-----------------------------------------------------' || ,
          '-----------'
    Queue '   '
    If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */
      Queue 'LARGE MEMORY AREA (LFAREA):' LFASize ',' LFA2G_Size
      Queue 'LARGE MEMORY STORAGE AVAILABLE:' LFA_Avail ',' ,
                 LFA2G_avail
    End
    Else do
      Queue 'LARGE MEMORY AREA (LFAREA):' LFASize
      Queue 'LARGE MEMORY STORAGE AVAILABLE:' LFA_Avail
    End
    Queue 'LARGE MEMORY STORAGE ALLOCATED (1M):' LFA_Alloc1M
    Queue 'LARGE MEMORY STORAGE ALLOCATED (4K):' LFA_Alloc4K
 /* If Bitand(CVTOSLV5,'08'x) = '08'x then do */ /* z/OS 1.10+OA31116*/
 /* If Bitand(CVTOSLV5,'04'x) = '04'x then do */ /* z/OS 1.11+OA31116*/
 /* If Bitand(CVTOSLV5,'02'x) = '02'x then do */ /* z/OS 1.12        */
    If Bitand(CVTOSLV5,'02'x) = '02'x then do /* z/OS 1.12 and above */
      Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (1M):' LFA_Max1M
      Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (4K):' LFA_Max4K
      If PL = 1 then do                     /* pageable1m support    */
        Queue 'LARGE MEMORY STORAGE ALLOCATED (PAGEABLE1M):' ,
         RceLargeAllocatedPL
        Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (PAGEABLE1M):' ,
         RceLargeUsedPLHWM
        Queue 'LARGE MEMORY STORAGE ALLOCATED (2G):' LFA2G_Used ,
              '/' RCE2GNonReconLFAUsed 'pages'
        Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (2G):' LFA2G_Max ,
              '/' RCE2GHWM 'PAGES'
      End

    End
    Queue 'LARGE MEMORY OBJECTS ALLOCATED:' RCELargeMemoryObjects
    If PL = 1 then ,             /* z/OS 2.1 / pageable1m support    */
      Queue 'LARGE MEMORY OBJECTS ALLOCATED (2G):' RCE2GMemoryObjects
End

/*****************************************************************/
/* Done processing. If ISPF is active, browse output.  Otherwise */
/* write to the terminal via "SAY".                              */
/*****************************************************************/
Queue ''  /* null queue to end stack   */
If Sysvar('SYSISPF')='ACTIVE' then call BROWSE_ISPF
Else do queued()
 Parse pull line
 Say line
End
Exit 0

FORMAT_MEMSIZE:
/****************************************************************/
/* The following code is used to display the storage size in    */
/* the largest possible unit.  For example, 1023G and 1025G are */
/* displayed as 1023G and 1025G, but 1024G is displayed as 1T.  */
/* The size passed to the routine must be in MB.                */
/****************************************************************/
Arg SIZE_IN_MB
Select
   When SIZE_IN_MB < 1024 then do
     MUNITS = 'M'
   End
   When SIZE_IN_MB >= 1024 & SIZE_IN_MB < 1048576 then do
     If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do
       SIZE_IN_MB = SIZE_IN_MB/1024
       MUNITS = 'G'
     End
     Else MUNITS = 'M'
   End
   When SIZE_IN_MB >= 1048576 & SIZE_IN_MB < 1073741824 then do
     If SIZE_IN_MB/1048576 == TRUNC(SIZE_IN_MB/1048576) then do
       SIZE_IN_MB = SIZE_IN_MB/1048576
       MUNITS = 'T'
     End
     Else do
       If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do
         SIZE_IN_MB = SIZE_IN_MB/1024
         MUNITS = 'G'
       End
       Else MUNITS = 'M'
     End
   End
   When SIZE_IN_MB >= 1073741824 & ,
        SIZE_IN_MB <= 17591112302592 then do
     If SIZE_IN_MB/1073741824 == TRUNC(SIZE_IN_MB/1073741824) ,
        then do
       SIZE_IN_MB = SIZE_IN_MB/1073741824
       MUNITS = 'P'
     End
     Else do
       SIZE_IN_MB = SIZE_IN_MB/1048576
       MUNITS = 'T'
     End
   End
   When SIZE_IN_MB = 17592186040320 then do
       SIZE_IN_MB = 'NOLIMIT'   /* 16384P */
       MUNITS = ''
   End
   When SIZE_IN_MB > 17592186040320 then do
       SIZE_IN_MB = '*NOLIMT'   /* >16384P  (16EB) ?? */
       MUNITS = ''
   End
   Otherwise do
     Queue ' '
     Queue 'Error in FORMAT_MEMSIZE code. Contact Mark Zelden.'
     Queue 'SIZE_IN_MB=' SIZE_IN_MB
     Queue ' '
     SIZE_IN_MB = '*ERROR*'
     MUNITS = ''
   End
End /* select */
STOR_SIZE =  SIZE_IN_MB || MUNITS
Return STOR_SIZE

BROWSE_ISPF: /* Browse output if ISPF is active          */
/*********************************************************************/
/* Browse results                                                    */
/*********************************************************************/
Queue ''  /* null queue to end stack   */
Address ISPEXEC "CONTROL ERRORS RETURN"
Address ISPEXEC "VGET ZENVIR"
Address TSO
prefix = sysvar('SYSPREF')        /* tso profile prefix            */
uid    = sysvar('SYSUID')         /* tso userid                    */
If prefix = '' then prefix = uid  /* use uid if null prefix        */
If prefix <> '' & prefix <> uid then /* different prefix than uid  */
   prefix = prefix || '.' || uid /* use  prefix.uid                */
ddnm1 = 'DDO'||random(1,99999)   /* choose random ddname           */
ddnm2 = 'DDP'||random(1,99999)   /* choose random ddname           */
junk = msg('off')
If HVCOMMON = 1 & LARGEMEM = 1 then ,          /* z/OS 1.10 & above  */
                                               /* + largemem support */
  "ALLOC FILE("||ddnm1||") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)",
      " DELETE REUSE LRECL(118) RECFM(F B) BLKSIZE(3068)"
Else if HVCOMMON = 1 & LARGEMEM = 0 then ,     /* z/OS 1.10 & above  */
  "ALLOC FILE("||ddnm1||") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)",
      " DELETE REUSE LRECL(103) RECFM(F B) BLKSIZE(3090)"
                                               /* no largemem support*/
Else if LARGEMEM = 1 then,
  "ALLOC FILE("||ddnm1||") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)",
      " DELETE REUSE LRECL(95) RECFM(F B) BLKSIZE(3135)"
Else ,
  "ALLOC FILE("||ddnm1||") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)",
      " DELETE REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)"
"ALLOC FILE("||ddnm2||") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE",
      " REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)"
junk = msg('on')
"Newstack"
/*************************/
/* REXX64P Panel source */
/*************************/
If Substr(ZENVIR,6,1) >= 4 then
  Queue ")PANEL KEYLIST(ISRSPBC,ISR)"
Queue ")ATTR"
Queue "  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)" ,
      "FORMAT(&MIXED)"
Queue "  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)"
Queue "  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)"
Queue "  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)"
Queue "  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)"
Queue "  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)"
Queue " 01 TYPE(DATAOUT) INTENS(LOW)"
Queue " 02 TYPE(DATAOUT) INTENS(HIGH)"
Queue " 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)"
Queue " 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)"
Queue " 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)"
Queue " 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)"
Queue " 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)"
Queue " 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)"
Queue ")BODY  EXPAND(//) WIDTH(&ZWIDTH)"
Queue "%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+"
Queue "%Command ===>_ZCMD / /           %Scroll ===>_Z   +"
Queue "|ZDATA ---------------/ /-------------------------|"
Queue "|                     / /                         |"
Queue "| --------------------/-/-------------------------|"
Queue ")INIT"
Queue "  .HELP = ISR10000"
Queue "  .ZVARS = 'ZSCBR'"
Queue "  &ZTITLE = 'Mark''s MVS Utilities - RXSTOR64'"
Queue "  &MIXED = MIX"
Queue "  IF (&ZPDMIX = N)"
Queue "   &MIXED = EBCDIC"
Queue "  VGET (ZSCBR) PROFILE"
Queue "  IF (&ZSCBR = ' ')"
Queue "   &ZSCBR = 'CSR'"
Queue ")REINIT"
Queue "  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)"
Queue ")PROC"
Queue "  &ZCURSOR = .CURSOR"
Queue "  &ZCSROFF = .CSRPOS"
Queue "  &ZLVLINE = LVLINE(ZDATA)"
Queue "  VPUT (ZSCBR) PROFILE"
Queue ")END"
Queue ""
/*                                    */
Address ISPEXEC "LMINIT DATAID(PAN) DDNAME("ddnm2")"
Address ISPEXEC "LMOPEN DATAID("pan") OPTION(OUTPUT)"
Do queued()
   Parse pull panline
   Address ISPEXEC "LMPUT DATAID("pan") MODE(INVAR)" ,
           "DATALOC(PANLINE) DATALEN(80)"
End
Address ISPEXEC "LMMADD DATAID("pan") MEMBER(REXX64P)"
Address ISPEXEC "LMFREE DATAID("pan")"
"Delstack"
"EXECIO * DISKW" ddnm1 "(FINIS"
If (NUMOBJ = 0 & NUMSHR = 0 & ,
    NUMLRG = 0 & NUMCOMN = 0) then zedsmsg = 'No memory objects'
                else zedsmsg = 'Tasks found with objects'
If HVCOMMON = 1 & LARGEMEM = 1 then do         /* z/OS 1.10 & above  */
                                               /* + largemem support */
  zedlmsg = NUMOBJ 'tasks with private,' NUMSHR 'tasks' ,
            'with shared,' NUMLRG 'tasks' ,
            'with large and' NUMCOMN 'tasks' ,
            'with common memory objects found.' ,
            'RXSTOR64 - Last updated on' ,
             LASTUPD ||'. Written by' ,
            'Mark Zelden. Mark''s MVS Utilities -' ,
            'http://www.mzelden.com/mvsutil.html'
End /* If HVCOMMON = 1 */
Else if HVCOMMON = 1 & LARGEMEM = 0 then do    /* z/OS 1.10 & above  */
                                               /* no largemem support*/
  zedlmsg = NUMOBJ 'tasks with private,' NUMSHR 'tasks' ,
            'with shared and' NUMCOMN 'tasks' ,
            'with common memory objects found.' ,
            'RXSTOR64 - Last updated on' ,
             LASTUPD ||'. Written by' ,
            'Mark Zelden. Mark''s MVS Utilities -' ,
            'http://www.mzelden.com/mvsutil.html'
End /* If HVCOMMON = 1 */
Else if LARGEMEM = 1 then do                   /* z/OS 1.9 and above */
  zedlmsg = NUMOBJ 'tasks with private,' NUMSHR 'tasks' ,
            'with shared and' NUMLRG 'tasks' ,
            'with large memory objects found.' ,
            'RXSTOR64 - Last updated on' ,
             LASTUPD ||'. Written by' ,
            'Mark Zelden. Mark''s MVS Utilities -' ,
            'http://www.mzelden.com/mvsutil.html'
End /* If LARGEMEM = 1 */
Else if HVSHARE = 1 then do                    /* z/OS 1.5 and above */
  zedlmsg = NUMOBJ 'tasks with private and' NUMSHR 'tasks' ,
            'with shared memory objects found.' ,
            'RXSTOR64 - Last updated on' ,
             LASTUPD ||'. Written by' ,
            'Mark Zelden. Mark''s MVS Utilities -' ,
            'http://www.mzelden.com/mvsutil.html'
End   /* If HVSHARE = 1*/
Else do
  zedlmsg = NUMOBJ 'tasks with memory objects found.' ,
            'RXSTOR64 - Last updated on' ,
             LASTUPD ||'. Written by' ,
            'Mark Zelden. Mark''s MVS Utilities -' ,
            'http://www.mzelden.com/mvsutil.html'
End
Address ISPEXEC "LIBDEF ISPPLIB LIBRARY ID("ddnm2") STACK"
If OPT <> 'ALL' & (NUMOBJ = 0 & NUMSHR = 0) then ,
  Address ISPEXEC "SETMSG MSG(ISRZ001)"  /* msg - with alarm  */
Else ,
  Address ISPEXEC "SETMSG MSG(ISRZ000)"  /* msg - no alarm    */
Address ISPEXEC "LMINIT DATAID(TEMP) DDNAME("ddnm1")"
Address ISPEXEC "BROWSE DATAID("temp") PANEL(REXX64P)"
Address ISPEXEC "LMFREE DATAID("temp")"
Address ISPEXEC "LIBDEF ISPPLIB"
junk = msg('off')
"FREE FI("ddnm1")"
"FREE FI("ddnm2")"
Return

SIG_ALL:
SIGTYPE = Condition('C')                   /* condition name         */
If SIGTYPE   = 'SYNTAX' then ,             /* SYNTAX error ?         */
  SIGINFO    = Errortext(RC)               /* rexx error message     */
Else SIGINFO = Condition('D')              /* condition description  */
SIGLINE      = Strip(Sourceline(SIGL))     /* error source code      */
Say 'SIGNAL -' SIGTYPE 'ERROR:' SIGINFO ,  /* display the error info */
    'on source line number' SIGL':'        /*   and line number      */
Say '"'SIGLINE'"'                          /* error source code      */
"Delstack"                                 /* delete data stack      */
Exit 16                                    /* exit RC=16             */
