/* REXX                                  */
/*                                       */
/* AUTHOR: Mark Zelden                   */
/* Last Updated 01/03/2019               */
/************************************************************/
/* CMD34 - Process commands against an ISPF 3.4 type DSLIST */
/*                                                          */
/* SYNTAX:   TSO %CMD34 DSN_LVL COMMAND                     */
/*                                                          */
/*  If slashes are found as part of the command the data    */
/*  set name will be substituted in place of the slashes    */
/*  similar to what ISPF 3.4 does. The data set names are   */
/*  always enclosed in single quotes when passed to the     */
/*  command (just like ISPF 3.4 does).                      */
/*                                                          */
/*  Prior to the command(s) being executed you are shown    */
/*  a sample of what the command will look like and must    */
/*  respond with "YES" or "REVerse" to actually issue       */
/*  the command against the data set list. Note that        */
/*  "REVERSE" can be abbreviated using 3 or more letters    */
/*  and that case does not matter in the response.          */
/*                                                          */
/*  "REVerse" mode is useful when you are trying to delete  */
/*  GDGs plus the GDG base(s) in the data set list,         */
/*  otherwise the command will fail against the GDG base    */
/*  since there are still GDGs that exist in the base.      */
/*                                                          */
/*                                                          */
/* Examples: TSO %CMD34 SYS2.OLD.PRODUCT.HLQ HMIG           */
/*           TSO %CMD34 SOME.HLQ* LISTC ENT(/) VOL          */
/*           TSO %CMD34 HLQ.OLD.JUNK DEL /                  */
/*                                                          */
/************************************************************/
Arg lvl cmd
If lvl = '' | cmd = '' then do
  Say 'Missing DSN_LVL or COMMAND to execute.'
  Say ' '
  Say 'SYNTAX:   TSO %CMD34 DSN_LVL COMMAND'
  Say ' '
  Say 'Examples: TSO %CMD34 SYS2.OLD.PRODUCT.HLQ HMIG  '
  Say '          TSO %CMD34 SOME.HLQ* LISTC ENT(/) VOL '
  Say '          TSO %CMD34 HLQ.OLD.JUNK DEL /         '
  exit 12
End
 /*                                                         */
 /* Quick ISPF save of data set names. This is much quicker */
 /* than using OPT 3.4, because it does not do an obtain    */
 /* for each data set in the list because of STATS(NO).     */
 /* The dsn created will be userid.CMD34.DATASETS           */
 /*                                                         */
Address ISPEXEC "CONTROL ERRORS RETURN"
Address ISPEXEC "LMDINIT LISTID(LISTID) LEVEL("lvl")"
Address ISPEXEC ,
  "LMDLIST LISTID("listid") OPTION(SAVE) STATS(NO) GROUP(CMD34)"
If rc=4 then do
  say 'No data sets matched specified search criteria.'
  Address ISPEXEC "LMDFREE LISTID("listid")"
  exit 12
End
Address ISPEXEC "LMDFREE LISTID("listid")"

uid = sysvar('SYSUID')
revmode = 0  /* do commands against dsn list in reverse */

/* allocate dsn list file and read it */
"ALLOC FI(INPUT) DA('" || uid || ".CMD34.DATASETS') SHR REUSE"
"EXECIO * DISKR INPUT (STEM INREC. FINIS"
If revmode = 0 then do
  Do I=1 to INREC.0
    dsn = word(inrec.i,1)
    If pos('/',cmd) <> 0 then do
      cmdn = cmd
      Do until pos('/',cmdn) = 0
        cmd1 = Substr(cmdn,1,pos('/',cmdn)-1)
        cmd2 = Substr(cmdn,pos('/',cmdn)+1,Length(cmdn)-Length(cmd1)-1)
        cmdn = cmd1 || "'" || dsn || "'" || cmd2
      End /* do until */
      If I = 1 then call Show_Sample
      If revmode = 1 then leave
      Address TSO cmdn
    End /* if pos */
    Else do
      If I = 1 then call Show_Sample
      If revmode = 1 then leave
      Address TSO cmd "'" || dsn || "'"
    End
  End /* do I */
End /* if revmode = 0 */
If revmode = 1 then do
  Do I=INREC.0 to 1 by -1
    dsn = word(inrec.i,1)
    If pos('/',cmd) <> 0 then do
      cmdn = cmd
      Do until pos('/',cmdn) = 0
        cmd1 = Substr(cmdn,1,pos('/',cmdn)-1)
        cmd2 = Substr(cmdn,pos('/',cmdn)+1,Length(cmdn)-Length(cmd1)-1)
        cmdn = cmd1 || "'" || dsn || "'" || cmd2
      End /* do until */
      Address TSO cmdn
    End /* if pos */
    Else do
      Address TSO cmd "'" || dsn || "'"
    End
  End /* do I */
End /* if revmode = 0 */

junk = msg(off)
"DELETE '" || uid || ".CMD34.DATASETS'"
junk = msg(on)
Exit 0

Show_Sample:
Say 'Sample command(s) to be entered:'
Say ' '
If pos('/',cmd) <> 0 then Say 'TSO 'cmdn
 Else say 'TSO' cmd "'" || dsn || "'"
Say ' '
Say 'Are you sure? Enter "YES" or "REVerse" to execute.'
Parse upper pull resp
If resp = 'YES' then return  /* YES - go issue commands    */
If Abbrev('REVERSE',resp,3) = 1 then do
  revmode = 1
  Return
End
 Else Exit 0                 /* anything else - forget it! */
