/* REXX                                  */
/*                                       */
/* AUTHOR: Mark Zelden                   */
/* Last Updated 08/27/2016               */
/*********************************************************************/
/* This exec will show the virtual storage usage of the task that    */
/* invokes the REXX exec.  This could be an interactive TSO user, a  */
/* batch TSO step, or even a Unix System Services user / Web server. */
/* For z/OS 1.2 and above running in z/Architecture mode, it will    */
/* also display the MEMLIMIT and the MEMLIMIT source.                */
/*********************************************************************/
/* SEE OA14391 for an explanation of MEMSRC.10                       */
/*********************************************************************/
Numeric digits 14                            /* dflt of 9 not enough!*/
ASCB     = C2d(Storage(224,4))               /* current ASCB         */
LDA      = C2d(Storage(D2x(ASCB + 48),4))    /* local data area      */
LDASIZA  = C2d(storage(D2x(LDA + 64),4))     /* <16m max priv size   */
LDASIZA  = Right(LDASIZA/1024,9)             /* convert to kbytes    */
LDAESIZA = C2d(storage(D2x(LDA + 80),4))     /* >16m max priv size   */
LDAESIZA = Right(LDAESIZA/1024,9)            /* convert to kbytes    */
LDAREGRQ = C2d(storage(D2x(LDA + 204),4))    /* region requested     */
LDAREGRQ = LDAREGRQ/1024                     /* convert to kbytes    */
LDALIMIT = C2d(storage(D2x(LDA + 208),4))    /* <16m reg limit       */
LDALIMIT = Right(LDALIMIT/1024,9)            /* convert to kbytes    */
LDAVVRG  = C2d(storage(D2x(LDA + 212),4))    /* <16m reg size        */
LDAVVRG  = Right(LDAVVRG/1024,9)             /* convert to kbytes    */
LDAELIM  = C2d(storage(D2x(LDA + 216),4))    /* >16m reg limit       */
LDAELIM  = Right(LDAELIM/1024,9)             /* convert to kbytes    */
LDAEVVRG = C2d(storage(D2x(LDA + 220),4))    /* >16m reg size        */
LDAEVVRG = Right(LDAEVVRG/1024,9)            /* convert to kbytes    */
LDALOAL  = C2d(storage(D2x(LDA + 232),4))    /* <16m reg alloc       */
LDALOAL  = Right(LDALOAL/1024,9)             /* convert to kbytes    */
LDAHIAL  = C2d(storage(D2x(LDA + 236),4))    /* <16m lsqa alloc      */
LDAHIAL  = Right(LDAHIAL/1024,9)             /* convert to kbytes    */
LDAELOAL = C2d(storage(D2x(LDA + 240),4))    /* >16m reg alloc       */
LDAELOAL = Right(LDAELOAL/1024,9)            /* convert to kbytes    */
LDAEHIAL = C2d(storage(D2x(LDA + 244),4))    /* >16m lsqa alloc      */
LDAEHIAL = Right(LDAEHIAL/1024,9)            /* convert to kbytes    */
 /* AVAIL    = Right(LDALIMIT-LDALOAL,9) */  /* available <16M       */
 /* EAVAIL   = Right(LDAELIM-LDAELOAL,9) */  /* available >16M       */
AVAIL    = Min(LDAVVRG,LDASIZA-LDAHIAL) - LDALOAL      /* avail <16M */
AVAIL    = Right(AVAIL,9)                              /* format     */
EAVAIL   = Min(LDAEVVRG,LDAESIZA-LDAEHIAL) - LDAELOAL  /* avail >16M */
EAVAIL   = Right(EAVAIL,9)                             /* format     */
/*********************************************************************/
/* MEMLIMIT code                                                     */
/*********************************************************************/
Show_MEMLIMIT_Display = 0    /* Init flag to "false" - used later    */
CVT      = C2d(Storage(10,4))                /* point to CVT         */
CVTOSLV3 = Storage(D2x(CVT+1267),1)          /* byte 3 of CVTOSLVL   */
FLCARCH  = Storage(A3,1)                     /* FLCARCH in PSA       */
If bitand(CVTOSLV3,'10'x) = '10'x & ,        /* z/OS 1.2 64-bit srvs */
   C2d(FLCARCH) <> 0 then do                 /* non-zero is z/Arch.  */
  Show_MEMLIMIT_Display = 1                  /* Set FLAG to "true"   */
  RAX      = C2d(Storage(D2X(ASCB+364),4))   /* point to RAX         */
  RAXLVMEMLIM = C2d(Storage(D2x(RAX+152),8)) /* MEMLIMIT in MB       */
  MEMLIM=FORMAT_MEMSIZE(RAXLVMEMLIM)         /* Format MEMLIMIT size */
  RAXLVMEMLIMS= C2d(Storage(D2x(RAX+184),1)) /* MEMLIMIT Source      */
End /* If bitand(CVTOSLV3,'10'x) */
/* Memlimit Source Table */
MEMSRC.0  = ' '
MEMSRC.1  = 'SMF'
MEMSRC.2  = 'JCL'
MEMSRC.3  = 'REGION=0'
MEMSRC.4  = 'IEFUSI'
MEMSRC.5  = 'OMVS SEGMENT'
MEMSRC.6  = 'UNIX SETRLIMIT'
MEMSRC.7  = 'UNIX SPAWN'
MEMSRC.8  = 'SETOMVS CMD'
MEMSRC.9  = 'AUTH PROGRAM'
MEMSRC.10 = 'IEFUSI + REGION=0'
/*********************************************************************/
/* Display results                                                   */
/*********************************************************************/
Say ''
Say '                       V I R T U A L    S T O R A G E' || ,
    '    U S A G E'
Say '                       ------------------------------' || ,
    '-------------'
Say ' '
Say ' '
Say '                             Region requested:' LDAREGRQ'K'
Say ' '
Say '             Max Priv     Region     Region     Region' || ,
    '       LSQA     Region'
Say '             Reg Size      Limit       Size     In-Use' || ,
    '     In-Use      Avail'
Say '             --------   --------   --------   --------' || ,
    '   --------   --------'
Say 'Below 16M:' LDASIZA'K'  LDALIMIT'K'  LDAVVRG'K' ,
       LDALOAL'K' LDAHIAL'K' AVAIL'K'
Say 'Above 16M:' LDAESIZA'K' LDAELIM'K'   LDAEVVRG'K' ,
       LDAELOAL'K' LDAEHIAL'K' EAVAIL'K'
If Show_MEMLIMIT_Display = 1 then do         /* FLAG set to "true"?  */
  Say ' '
  Say 'Above 2G :' Right(MEMLIM,10) ,
      '    (64-bit MEMLIMIT)'
  Say 'MEMLIMIT Source: ' MEMSRC.RAXLVMEMLIMS
End
Exit 0

FORMAT_MEMSIZE:
/****************************************************************/
/* The following code is used to display the storage size in    */
/* the largest possible unit.  For example, 1023G and 1025G are */
/* displayed as 1023G and 1025G, but 1024G is displayed as 1T.  */
/* The size passed to the routine must be in MB.                */
/****************************************************************/
Arg SIZE_IN_MB
Select
   When SIZE_IN_MB < 1024 then do
     MUNITS = 'M'
   End
   When SIZE_IN_MB >= 1024 & SIZE_IN_MB < 1048576 then do
     If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do
       SIZE_IN_MB = SIZE_IN_MB/1024
       MUNITS = 'G'
     End
     Else MUNITS = 'M'
   End
   When SIZE_IN_MB >= 1048576 & SIZE_IN_MB < 1073741824 then do
     If SIZE_IN_MB/1048576 == TRUNC(SIZE_IN_MB/1048576) then do
       SIZE_IN_MB = SIZE_IN_MB/1048576
       MUNITS = 'T'
     End
     Else do
       If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do
         SIZE_IN_MB = SIZE_IN_MB/1024
         MUNITS = 'G'
       End
       Else MUNITS = 'M'
     End
   End
   When SIZE_IN_MB >= 1073741824 & ,
        SIZE_IN_MB <= 17591112302592 then do
     If SIZE_IN_MB/1073741824 == TRUNC(SIZE_IN_MB/1073741824) ,
        then do
       SIZE_IN_MB = SIZE_IN_MB/1073741824
       MUNITS = 'P'
     End
     Else do
       SIZE_IN_MB = SIZE_IN_MB/1048576
       MUNITS = 'T'
     End
   End
   When SIZE_IN_MB = 17592186040320 then do
       SIZE_IN_MB = 'NOLIMIT'   /* 16384P */
       MUNITS = ''
   End
   When SIZE_IN_MB > 17592186040320 then do
       SIZE_IN_MB = '*NOLIMT'   /* >16384P  (16EB) ?? */
       MUNITS = ''
   End
   Otherwise do
     Say ' '
     Say 'Error in FORMAT_MEMSIZE code. Contact Mark Zelden.'
     Say 'SIZE_IN_MB=' SIZE_IN_MB
     Say ' '
     SIZE_IN_MB = '*ERROR*'
     MUNITS = ''
   End
End /* select */
STOR_SIZE =  SIZE_IN_MB || MUNITS
Return STOR_SIZE
