BSPSSADD TITLE 'B S P A D D S S  ***  Add and initialize subsystems'
         PUNCH '  ORDER BSPSSADD(P)'  EASIER DUMPS              GP05060
         PUNCH '  SETCODE AC(1) '                               GP05060
***********************************************************************
*                                                                     *
*  This program will search file PARMLIB for members with the name    *
*  IEFSSNxx (where xx is optional if not 00), and will build an SSCT  *
*  and optionally initialize it. If the SSCT exists, it is ignored.   *
*                                                                     *
*  These definitions are not permanent.  In other words, this         *
*  program should be run on every IPL, preferably via a start         *
*  command in SYS1.PARMLIB(COMMND00)                                  *
*                                                                     *
*  JCL Execution Parameters are specified via the                     *
*  PARM statement on the EXEC card:                                   *
*                                                                     *
*       PARM=NOUPDATE:  (default) - SSCTs will not be updated, the    *
*                       IEFSSNxx members in PARMLIB will only be      *
*                       checked for correct syntax                    *
*       PARM=UPDATE:    The IEFSSNxx members will be syntax-checked,  *
*                       and updates will be made to the SSCT chain.   *
*                       The operator will be prompted to allow this.  *
*       PARM=NOREPLYU:  The IEFSSNxx members will be syntax-checked,  *
*                       and updates will be made without confirmation *
*                       request to the operator                       *
*                                                                     *
* When running with PARM=UPDATE or PARM=NOREPLYU then the program     *
* needs to run authorized                                             *
*                                                                     *
*  Required DD statement: none                                        *
*                                                                     *
*  Optional DD statements:                                            *
*           PARMLIB  -  PDS containing the IEFSSNxx members to be     *
*                       processed. Default: SYS1.PARMLIB              *
*                       Optionally may specify a member name or mask. *
*                       Unchecked mask positions are defined by a     *
*                       pound sign (#).                               *
*                                                                     *
*           SYSPRINT -  Output queue for BSPSSADD messages.           *
*                       Default: SYSOUT=X                             *
*                       (for batch job only.  for STC we use WTOs)    *
*                                                                     *
*           SYSUDUMP -  Output queue for dumps (which, of course,     *
*                       will never happen). Default: SYSOUT=A         *
*                       (for batch job only)                          *
*                                                                     *
*           SYSMDUMP -  Output file for dumps. The default is         *
*                       SYS1.BSPSSADD.SYSMDUMP                        *
*                       (for STC only)                                *
*                                                                     *
*           SNAPDUMP -  Internal snap files for debugging             *
*                                                                     *
* SYS1.PARMLIB(IEFSSNxX) RECORD LAYOUT:                               *
* An asterisk (*) in column 1 indicates a comment line, this line     *
* will be ignored                                                     *
*                                                                     *
*  Cards are free format, and may be continued without a continuation *
*  indicator. Operands are blank separated.                           *
*  SUBSYS            Defines a new subsystem entry:                   *
*  SUBNAME(name)     required - specifies 1-4 character subsys name   *
*  INITRTNE(module)  Optional: module to be invoked for initializa-   *
*                    tion. Entered in key 0, possibly unauthorized.   *
*  INITPARM('text')  Optional: quoted text string to be passed as     *
*                    PARM to the initialization routine. Max is 60    *
*                    characters (may not be continued or split)       *
* PRIMARY(YES)       optional: for JES2 or JES3 primary. For MVS 3.8j *
*                    will be ignored, since primary will already be   *
*                    defined when we get executed.                    *
* START(YES) Â¦ START(NO)  optional: whether to start the subsys       *
*                    - currently ignored                              *
* CONSNAME(xxxxxxxx) optional: ignored under MVS 3.8j                 *
*                                                                     *
***********************************************************************
*   FRAMEWORK CODE DERIVED FROM VOLKER BANDKE'S BSPSETPF PROGRAM,     *
*   BUT MACROS REMOVED OR REPLACED WITH LOCAL ONES.        GYP 05188  *
*                                                                     *
***********************************************************************
         SPACE 1
         COPY  OPTIONGB      COPY ASSEMBLY OPTIONS
         GBLC  &LRECL
         GBLC  &BLKSIZE
         GBLC  &DEBUG
         GBLC  &TUMAXLN
         COPY  BSPGLBLS
         COPY  BSPSGLBL
         SPACE 1
         SYSPARM LIST=YES    SET ASSEMBLY OPTIONS
&TUMAXLN SETC  '100'
&LRECL   SETC  '133'                  , record length for sysprint
&BLKSIZE SETC  '&LRECL.0'             , blocksize for sysprint
&DEBUG   SETC  'NO'                   , debug code not included
&BSPAUTH SETC  'V. Bandke && G. Postpischil'                    GP05060
         PRINT ON,NOGEN
         TITLE 'Main Processing'
BSPSSADD PGMHEAD BASE=(R10,R11,R12),BNDRY=PAGE,PARM=R1          GP05188
DIRPTR   EQU   R4                     , pointer to directory entry
         USING PDS2,DIRPTR            , tell assembler          GP05060
*BLKPTR  EQU   R6                     , current BSAM block      GP05060
RECOFFST EQU   R7                     , record pointer within block
RECPTR   EQU   R8                     , address of current record
***********************************************************************
* Main processing                                                     *
***********************************************************************
*DEBUG*  PRINT ON,GEN
         BAL   R14,SETINIT            , go for setup and init calls
         BAL   R14,ALCPRINT           , go allocate SYSPRINT
         BAL   R14,OPNPRINT           , go open SYSPRINT
         BAL   R14,ALCUDUMP           , go allocate SYSUDUMP
         AIF   ('&DEBUG' EQ 'NO').NOSNAP1
         BAL   R14,ALCPDUMP           , go allocate SNAPDUMP
         BAL   R14,OPNPDUMP           , go open SNAPDUMP
.NOSNAP1 ANOP
         BAL   R14,PROCPARM           , go analyse PARM statement
         BAL   R14,REPTPARM           , report effective PARM
         BAL   R14,ALCPALIB           , Allocate PARMLIB
         BAL   R14,OPNPAPDS           , Open PARMLIB as a PDS
         BAL   R14,OPNPADIR           , Open PARMLIB as a PS
         BAL   R14,GETBUFF            , Get member buffer       GP05060
         LR    R6,R1                  , R6 points to IO buffer
***********************************************************************
* Read a directory block and test if the requested member (IEFSSNxx)  *
* can be in this block.  If not, loop until found                     *
***********************************************************************
         SPACE 1
DIR0100  DS    0H                     , read directory block
         DBGMSG TUPLDDNM,=CL8'RDDIRBLK'
         READ  DIRDECB,SF,PARMDIR,DIRAREA,'S',MF=E
         CHECK DIRDECB                , wait for I/O completion
         LA    R4,DIRAREA+10          , point to area
         CLC   =CL6'IEFSSN',PDSKEY    , block reached already
         BH    DIR0100                , then try next block
         SPACE 1
***********************************************************************
*  If a IEFSSNxx member exists, it is in this (and possibly the       *
*  following) blocks.  There may also be more members IEFSSNxx        *
*  around.  We will now test the entries one by one against the       *
*  default mask of IEFSSN## or a member name on the PARMLIB DD        *
***********************************************************************
         SPACE 1
DIR0200  DS    0H                     , read directory record
         DBGMSG TUPLDDNM,=CL8'RDDIRREC'
         CLC   PDS2NAME,=XL8'FFFFFFFFFFFFFFFF' EOD?             GP05060
         BE    EXIT                   , term at last member
         LA    R14,PDS2NAME  NAME OF CURRENT MEMBER             GP05060
         LA    R15,MEMMASK   NAME OF MASK                       GP05060
         LA    R0,L'PDS2NAME  LENGTH OF NAME AND MASK           GP05060
MASKLOOP CLI   0(R15),C'#'   WILDCARD ?                         GP05060
         BE    MASKMASK      YES; TRY NEXT ONE                  GP05060
         CLC   0(1,R14),0(R15)  BYTE MATCHES ?                  GP05060
         BE    MASKBUMP      YES; TRY NEXT ONE                  GP05060
         BH    EXIT          PAST LAST POSSIBLE MATCH?          GP05060
         BL    EOMEM         NOT YET; DO ANOTHER MEMBER         GP05060
MASKBUMP LA    R14,1(,R14)   ADVANCE                            GP05060
         LA    R15,1(,R15)     POINTERS                         GP05060
         BCT   R0,MASKLOOP       UNTIL DONE                     GP05060
         B     PROCMEM       PROCESS THIS MEMBER                GP05060
MASKMASK LA    R14,1(,R14)   ADVANCE                            GP05060
         LA    R15,1(,R15)     POINTERS                         GP05060
         BCT   R0,MASKPAST   PAST WILD CARD                     GP05060
         B     PROCMEM       PROCESS THIS MEMBER                GP05060
MASKPAST CLC   0(1,R14),0(R15)  BYTE MATCHES ?                  GP05060
         BE    MASKMASK      YES; TRY NEXT ONE                  GP05060
         CLI   0(R15),C'#'   WILDCARD ?                         GP05060
         BE    MASKMASK      YES; TRY NEXT ONE                  GP05060
         B     EOMEM         NO; TRY ANOTHER MEMBER             GP05060
         SPACE 1
***********************************************************************
*  Process this member except when the PARM is UPDATE, in which case  *
*  we let the user/operator decide via WTOR for permission to process *
*  the member. Skip WTOR if no PARM, or PARM not UPDATE.              *
***********************************************************************
PROCMEM  OI    PROCFLAG,HAVEMEM   MATCHING MEMBER NAME FOUND    GP05060
         NI    PROCFLAG,255-MEMPOS-MEMKEY  RESET TEXT FORMAT    GP05060
         TM    PARMFLAG,PARMSET   UPDATE REQUESTED ?
         BZ    PROCFND       NO; INFORMATIONAL PROCESSING ONLY
         TM    PARMFLAG,PARMNORU  WITHOUT PROMPTING ?
         BNZ   PROCFND       YES; PROCESS
         BLANK WTORTEXT      PREPARE WTOR
         MVC   WTORTEXT(L'MSG16D),MSG16D  MOVE MESSAGE
         MVC   MSG16D1,PDS2NAME  IDENTIFY THE MEMBER
         LA    R0,L'MSG16D+4      TEXT LENGTH
         STH   R0,THEWTOR+8       INTO WTOR
LOOPWTOR XC    WTOREPLY,WTOREPLY  CLEAR THE REPLY
         XC    WTOECB,WTOECB      CLEAR THE ECB (JUST IN CASE?) GP05060
* Note: Default Rout/Desc causes reply text suppression         GP05060
         MVI   THEWTOR+10,X'80'   DESC/ROUT PRESENT             GP05060
         LH    R15,THEWTOR+8  GET TEXT LENGTH                   GP05060
         LA    R15,THEWTOR+8(R15)  END OF TEXT                  GP05060
         MVC   0(4,R15),=X'40008000'  DESC=2/ROUT=1             GP05060
         WTOR  ,WTOREPLY,L'WTOREPLY,WTOECB,MF=(E,THEWTOR) ISSUE REQUEST
         WAIT  ECB=WTOECB    WAIT FOR RESPONSE
         OI    WTOREPLY,C' ' MAKE UPPER-CASE                    GP05060
         CLI   WTOREPLY,C'U'  WAS IT 'U'?                       GP05060
         BE    PROCFND       YES; PROCESS                       GP05060
         CLI   WTOREPLY,C'Y'  WAS IT 'Y'?                       GP05060
         BE    PROCFND       YES; PROCESS                       GP05060
         CLI   WTOREPLY,C'N'  WAS IT 'N'?                       GP05060
         BE    REJMEM        YES; SKIP                          GP05060
         CLI   WTOREPLY,C'C'  WAS IT 'C'?                       GP05060
         BNE   LOOPWTOR      NO; ASK AGAIN
         SPACE 1
REJMEM   DS    0H                     , Operator rejected request
         BAL   R14,MAKESSCT  PROCESS IT NOW                     GP05060
         MSGPUT MSG12E               , point to msg text
         MVC   MSG12E1,PDS2NAME       , rejected member         GP05060
         BAL   R14,PUTPUT             , show message            GP05060
EOMEM    DS    0H                     , end of member reached
         BAL   R14,MAKESSCT  PROCESS IT NOW                     GP05060
         IF    (TM,PROCFLAG,MEMFOUND,O) End of file on a member
          MSGPUT MSG98I
          L     R15,MEMCC             , get return code
          CVD   R15,DBL               , make a number
          UNPK  MSG98I1,DBL+5(3)      , make printable
          OI    MSG98I1+L'MSG98I1-1,C'0'  last digit printable
          BAL   R14,PUTPUT            , write last message
          XC    MEMCC,MEMCC           , reset CC for the new member
         ENDIF (TM,PROCFLAG,MEMFOUND,O) End of file on a member
         CLC   PDS2NAME,PDSKEY        , last member in block    GP05060
         BE    DIR0100                , then get next directory block
         XR    R1,R1                  , clear workreg
         NI    PDS2INDC,PDS2LUSR      , retain only length bits GP05060
         IC    R1,PDS2INDC            , number of data halfwords
         SLL   R1,1                   , number of bytes
         LA    DIRPTR,12(R1,DIRPTR)   , point to next entry     GP05060
         B     DIR0200                , and process entry
         TITLE  'Process a IEFSSNxx member'
PROCFND  DS    0H                     , process IEFSSNxx member
         DBGMSG PDS2NAME,=CL8'BSAMREAD'                         GP05060
         OI    PROCFLAG,MEMFOUND      , indicate member found
         MVC   SAVMEMBR,PDS2NAME      , save member name and suffix
         ZAP   LINENUM,=P'100'        , force page break for new membr
         MSGPUT MSG21I                , insert message body
         MVC   MSG21I1,SAVMEMBR       , insert member name
         BAL   R14,PUTPUT             , issue message
***********************************************************************
*  Try to find the member                                             *
***********************************************************************
         SPACE 1
         FIND  PARMLIB,PDS2NAME,D     , look for member in parmlib
         LTR   R15,R15                , member in PDS?
         BZ    FOUNDMEM               , BIF yes
         MSGPUT MSG07E                , point to error message
         MVC   MSG07E1,PDS2NAME       , insert member name      GP05060
         BAL   R14,PUTERR             , Display error message
         SETMAXCC 8                   , indicate a warning level
         B     EOMEM                  , go around again
         SPACE 1
***********************************************************************
*   Process member text                                               *
***********************************************************************
FOUNDMEM DS    0H
         XC    READDECB,READDECB
READBLCK DS    0H                     , read one block from member
         DBGMSG SAVMEMBR,=CL8'READBLCK'
         PUSH  PRINT
         PRINT ON,GEN
         AIF   ('&DEBUG' EQ 'NO').NOSNAP2
         B     DOSNAP1
HDR1     DC    AL1(11),C'PARMLIB DCB'
HDR2     DC    AL1(11),C' IO Buffer '
HDR3     DC    AL1(11),C' READ DECB '
DOSNAP1  DS    0H
         LA    R1,PARMLIB             , beginning
         ST    R1,SNAPLIST            ,
         LA    R1,SNAPDLEN(R1)        , end end of PARMLIB DCB
         ST    R1,SNAPLIST+4
         LR    R1,R6                  , beginning
         ST    R1,SNAPLIST+8
         AH    R1,DCBBLKSI-IHADCB+PARMLIB   end of IO buffer    GP05060
         ST    R1,SNAPLIST+12
         LA    R1,READDECB            , beginning
         ST    R1,SNAPLIST+16
         LA    R1,READDCBE            , and end of READ DECB
         ICM   R1,B'1000',=X'80'      , end of list
         ST    R1,SNAPLIST+20
         LA    R1,HDR1
         ST    R1,HDRLIST
         LA    R1,HDR2
         ST    R1,HDRLIST+4
         LA    R1,HDR3
         ICM   R1,B'1000',=X'80'
         ST    R1,HDRLIST+8
         SNAP  DCB=SNAPDUMP,                                           +
               LIST=SNAPLIST,                                          +
               STRHDR=HDRLIST,                                         +
               MF=(E,THESNAP)
*             PDATA=(PSW,REGS,SPLS),                                  +
*             SDATA=(DM,IO),                                          +
.NOSNAP2 ANOP
         READ  READDECB,SF,PARMLIB,(R6),MF=E
         CHECK READDECB               , wait for IO completion
         POP   PRINT
         LH    R0,DCBBLKSI-IHADCB+PARMLIB   ds blocksize        GP05060
         L     R1,READDECB+16         , point to iob
         SH    R0,14(,R1)             , subtract residual block length
         STH   R0,BLOCKLEN            , save actual block length read
         XR    RECOFFST,RECOFFST      , clear offset register
         SPACE 1
***********************************************************************
*    Get a record from the directory block                            *
*                                                                     *
*   1) Skip record if all blank or has asterisk in column 1           *
*                                                                     *
*   2) Record has a comma prior to the first blank in column 2-5,     *
*      we are looking at a positional record. Process all fields      *
*      and invoke MAKESSCT                                            *
*                                                                     *
*   3) Otherwise the member uses keywords. If so:                     *
*     a) A record containing SUBSYS as the first operand begins       *
*        a new set. Invoke MAKESSCT for a prior request               *
*     b) Parse and save data, but defer processing until EOF or       *
*        next subsystem record.                                       *
*                                                                     *
***********************************************************************
         SPACE 1
READREC  LA    RECPTR,0(RECOFFST,R6) get record at spec. offset GP05060
         LA    R1,72(,RECPTR)   IN CASE NO NON-BLANK            GP05060
         SR    R2,R2         FOR STOPPER TEST                   GP05060
         TRT   0(71,RECPTR),TRTNBLK  LOOK FOR A NON-BLANK       GP05060
         LTR   R2,R2         ALL BLANK?                         GP05060
         BZ    COMMPUT       YES; IGNORE                        GP05060
         CLI   0(R1),C'*'    COMMENT ?                          GP05060
         BE    COMMPUT       YES; IGNORE                        GP05060
         CLC   =C'SUBSYS ',0(R1)  KEYWORD MODE?                 GP05060
         BE    SETKEYFM      YES; TERMINATE PRIOR SS SET        GP05060
         TM    PROCFLAG,MEMKEY  PRIOR KEYWORD DETECTED?         GP05060
         BNZ   COMMPUT       YES; PARSE IT                      GP05060
         TM    PROCFLAG,MEMPOS  PRIOR POSITIONAL MODE ?         GP05060
         BNZ   ENDPRIOR      YES; SCAN IT                       GP05060
         CLC   =C'/*',0(R1)  KEYWORD MODE COMMENT ?             GP05060
         BE    SETKEYFM      YES; TERMINATE PRIOR SS SET        GP05060
***********************************************************************
*   Positional check. Format is:                                      *
*    ssnm,initrtne,parm,PRIMARY,NOSTART  comments                     *
*    where all fields other than ssnm are option - blank terminates   *
***********************************************************************
         LR    R14,R1        SAVE START COLUMN                  GP05060
         TRT   0(5,R1),TRTBCOM  LOOK FOR BLANK OR COMMA         GP05060
         LTR   R2,R2         BLANK OR COMMA IN FIRST FIVE COLUMNS?
         BZ    COMMPUT       NO; ERROR OR KEYWORD CARD          GP05060
         LR    R15,R1        COPY END COLUMN                    GP05060
         SR    R15,R14       SS NAME LENGTH                     GP05060
         LR    R1,R14        RESTORE SCAN START COLUMN          GP05060
         BNP   COMMPUT       NOT POSITIONAL OR ERROR            GP05060
         CH    R15,=AL2(L'SSNAME)  NOT TOO LONG ?               GP05060
         BH    COMMPUT       NOT POSITIONAL OR ERROR            GP05060
         OI    PROCFLAG,MEMPOS   POSITIONAL CARD                GP05060
         B     ENDPRIOR      CONTINUATIONS INVALID              GP05060
         SPACE 1                                                GP05060
SETKEYFM OI    PROCFLAG,MEMKEY  SHOW KEYWORD FORMAT             GP05060
ENDPRIOR BAL   R14,MAKESSCT  PROCESS PREVIOUS REQUEST           GP05060
DONPRIOR BLANK SSCLEAR       RESET JUST IN CASE                 GP05060
         SPACE 1                                                GP05060
COMMPUT  MSGPUT MSG08I                , set msg body            GP05060
         MVC   MSG08I1,0(RECPTR)      , insert card image
         BAL   R14,PUTSAV             , show card image         GP05060
         TITLE 'Process a record from IEFSSNxx member'
***********************************************************************
* test for (and ignore) comments                                      *
***********************************************************************
         SPACE 1                                                GP05060
         CLI   0(R1),C'*'             , COMMENT INDICATOR       GP05060
         BE    NEXTCARD               , if so, get next card    GP05060
         TM    PROCFLAG,MEMPOS  POSITIONAL MODE?                GP05060
         BZ    KEYLOOK       NO; PROCESS KEYWORDS               GP05060
         LA    R15,SSNAME    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSNAME   SET MAX LENGTH                     GP05060
         BAL   R14,FINDFLD   MOVE TEXT TO NEXT ,                GP05060
         CLI   SSNAME,C' '   DID WE FIND SOMETHING ?            GP05060
         BH    POSTSSNM      YES                                GP05060
         OI    FLAG,FGSYNT   NO; LEADING COMMA ?                GP05060
POSTSSNM MVC   SSCURR,SSNAME   PRESERVE FOR MESSAGES            GP05060
         LA    R15,SSINIT    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSINIT   SET MAX LENGTH                     GP05060
         BAL   R14,FINDFLD   MOVE TEXT TO NEXT ,                GP05060
         LA    R15,SSPARM    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSPARM   SET MAX LENGTH                     GP05060
         BAL   R14,FINDFLD   MOVE TEXT TO NEXT ,                GP05060
         STH   R0,SSPLEN     SET INIT FIELD LENGTH              GP05060
         LA    R15,SSPRIM    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSPRIM   SET MAX LENGTH                     GP05060
         BAL   R14,FINDFLD   MOVE TEXT TO NEXT ,                GP05060
         LA    R15,SSSTRT    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSSTRT   SET MAX LENGTH                     GP05060
         BAL   R14,FINDFLD   MOVE TEXT TO NEXT ,                GP05060
         TM    FLAG,FGERMSK  ANY ERRORS ?                       GP05060
         BNZ   POSTMARK      YES; SKIP                          GP05060
         BAL   R14,MAKESSCT  BUILD THIS ENTRY                   GP05060
POSTMARK BLANK SSCLEAR       CLEAR FOR NEXT TIME                GP05060
         B     NEXTCARD      AND READ NEXT                      GP05060
         SPACE 1                                                GP05060
***********************************************************************
*   FINDFLD - identify and move a comma delimited field               *
*     special handling if quoted                                      *
*   R1-parse point R0-max len r15-o/p field                           *
*     returns updated R1; if blank, just returns                      *
***********************************************************************
FINDFLD  STM   R14,R3,SETISAVE  SAVE A LITTLE                   GP05060
         SR    R3,R3         SET LENGTH                         GP05060
         CLI   0(R1),C''''   QUOTED STRING ?                    GP05060
         BE    FINDQUO       YES; SPECIAL HANDLING              GP05060
         LR    R15,R0        SAVE FIELD LENGTH                  GP05060
         CLI   0(R1),C' '    PRIOR OPERAND END ?                GP05060
         BE    FINDFEX       YES; JUST IGNORE THIS ONE          GP05060
         LR    R14,R1        SAVE SCAN START                    GP05060
         SR    R2,R2                                            GP05060
         EX    R15,EXTRTCOM  LOOK FOR BLANK OR COMMA            GP05060
         LTR   R2,R2         FOUND END?                         GP05060
         BZ    FINDFOO       NO; ERROR                          GP05060
         LR    R15,R1        COPY END                           GP05060
         SR    R15,R14       LESS START                         GP05060
         LR    R3,R15        RETURN LENGTH IN R0                GP05060
         SH    R15,=H'1'     MAKE MOVE LENGTH                   GP05060
         BM    FINDFUP       NONE ?                             GP05060
         L     R2,SETISAVE+4  GET FIELD ADDRESS                 GP05060
         EX    R15,EXMVCSCN  MOVE TEXT                          GP05060
         B     FINDFUP                                          GP05060
EXTRTCOM TRT   0(0,R1),TRTBCOM  LOOK FOR COMMA OR BLANK         GP05060
         SPACE 1                                                GP05060
FINDQUO  DS    0H                                               GP05060
FINDQUOI LA    R1,1(,R1)     SKIP STARTING QUOTE                GP05060
FINDQUOL CLI   0(R1),C''''   INT. OR FINAL QUOTE?               GP05060
         BNE   FINDQUOM      NEITHER; MOVE BYTE                 GP05060
         CLI   1(R1),C''''   INTERNAL DOUBLED QUOTE?            GP05060
         LA    R1,1(,R1)     SKIP FIRST OF PAIR                 GP05060
         BNE   FINDFUP       NO; END                            GP05060
FINDQUOM MVC   0(1,R15),0(R1)  PROPAGATE                        GP05060
         LA    R15,1(,R15)   ADVANCE O/P CURSOR                 GP05060
         LA    R3,1(,R3)     ALSO BUMP LENGTH                   GP05060
         BCT   R0,FINDQUOI   DO ANOTHER                         GP05060
         B     FINDFOO       MALFORMED                          GP05060
         SPACE 1                                                GP05060
FINDFOO  OI    FLAG,FGSYNT   SYNTAX ERROR - FIELD TOO LONG      GP05060
FINDFUP  CLI   0(R1),C','    FIELD ENDS IN COMMA ?              GP05060
         BNE   FINDFEX       NO                                 GP05060
         LA    R1,1(,R1)     SKIP IT FOR NEXT SCAN              GP05060
FINDFEX  ST    R1,SETISAVE+12  RETURN NEW R1                    GP05060
         ST    R3,SETISAVE+8  RETURN LENGTH IN R0               GP05060
         LM    R14,R3,SETISAVE                                  GP05060
         BR    R14                                              GP05060
         SPACE 2                                                GP05060
***********************************************************************
* Look for SUBSYS text, then SUBNAME                                  *
***********************************************************************
KEYLOOK  LA    R2,1          SET SCAN INCREMENT                 GP05060
         LA    R3,71-6(,RECPTR)  SCAN STOPPER                   GP05060
TEXTLOOP CLC   =C'SUBSYS ',0(R1)   NEW SUBSYS - PROCESS OLD ONE GP05060
         BE    TEXTSUB       PROCESS OLD ENTRY, IF ANY          GP05060
         CLC   =C'SUBNAME(',0(R1)  NEW NAME ?                   GP05060
         BE    TEXTNAME      ADD NAME                           GP05060
         CLC   =C'INITRTN(',0(R1)  INIT PGM NAME ?              GP05060
         BE    TEXTINIT      ADD INIT RTN                       GP05060
         CLC   =C'INITPARM(',0(R1)  INIT PARM ?                 GP05060
         BE    TEXTPARM      YES                                GP05060
         CLC   =C'START(',0(R1)  START ?                        GP05060
         BE    TEXTSTRT      IGNORE FOR NOW                     GP05060
         CLC   =C'PRIMARY(',0(R1)  PRIMARY SS?                  GP05060
         BE    TEXTPRIM      YES; ALREADY DONE ?                GP05060
         CLC   =C'/*',0(R1)  COMMENTS ?                         GP05060
         BE    TEXTCOMM                                         GP05060
         CLC   =C'CONSNAME(',0(R1)  NAMED CONSOLES NOT SUPPORTED IN 3.8
         BE    TEXTCONS      CONS NAME                          GP05060
         CLI   0(R1),C' '    NON-BLANK ?                        GP05060
         BE    TEXTBUMP      NO                                 GP05060
         OI    FLAG,FGCRUD   UNRECOGNIZED TEXT                  GP05060
         MVC   TEXTICLE,0(R1)  SAVE FOR MESSAGE                 GP05060
TEXTBUMP BXLE  R1,R2,TEXTLOOP  LOOK AGAIN                       GP05060
         B     NEXTCARD      NO MATCH ???                       GP05060
         SPACE 1                                                GP05060
TEXTCOMM LA    R1,2(,R1)     SKIP /*                            GP05060
TEXTCOML CLC   =C'*/',0(R1)  COMMENT END ?                      GP05060
         BNE   TEXTCOMB      NO; DO MORE                        GP05060
         LA    R1,1(,R1)     POSITION CORRECTLY                 GP05060
         B     TEXTBUMP      YES; LOOK FOR OPERANDS             GP05060
TEXTCOMB BXLE  R1,R2,TEXTCOML  LOOP SOME MORE                   GP05060
         B     NEXTCARD      COMMENTS CAN'T BE CONTINUED???     GP05060
         SPACE 1                                                GP05060
TEXTSUB  LA    R1,6(,R1)     ALREADY PROCESSED BEFORE PRINTING  GP05060
         B     TEXTBUMP                                         GP05060
         SPACE 1                                                GP05060
TEXTNAME LA    R15,SSNAME    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSNAME   SET MAX LENGTH                     GP05060
         LA    R1,8(,R1)     SKIP KEYWORD AND (                 GP05060
         BAL   R14,FINDLEN   MOVE TEXT TO NEXT )                GP05060
         MVC   SSCURR,SSNAME  PRESERVE FOR MESSAGES             GP05060
         B     TEXTBUMP                                         GP05060
         SPACE 1                                                GP05060
TEXTINIT LA    R15,SSINIT    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSINIT   SET MAX LENGTH                     GP05060
         LA    R1,8(,R1)     SKIP KEYWORD AND (                 GP05060
         BAL   R14,FINDLEN   MOVE TEXT TO NEXT )                GP05060
         B     TEXTBUMP                                         GP05060
         SPACE 1                                                GP05060
TEXTPARM LA    R15,SSPARM    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSPARM   SET MAX LENGTH                     GP05060
         LA    R1,9(,R1)     SKIP KEYWORD AND (                 GP05060
         BAL   R14,FINDLEN   MOVE TEXT TO NEXT )                GP05060
         STH   R0,SSPLEN     SET INIT FIELD LENGTH              GP05060
         B     TEXTBUMP                                         GP05060
         SPACE 1                                                GP05060
TEXTSTRT LA    R15,SSSTRT    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSSTRT   SET MAX LENGTH                     GP05060
         LA    R1,6(,R1)     SKIP KEYWORD AND (                 GP05060
         BAL   R14,FINDLEN   MOVE TEXT TO NEXT )                GP05060
         LA    R14,=CL7'NOSTART'                                GP05060
         CLC   =C'NO ',SSSTRT  SHORT FORM                       GP05060
         BE    TEXTSTRX      YES; CHANGE TO LONG FORM           GP05060
         LA    R14,=CL7'START  '                                GP05060
         CLC   =C'YES ',SSSTRT  SHORT FORM                      GP05060
         BNE   TEXTBUMP      NO; LEAVE AS IS                    GP05060
TEXTSTRX MVC   SSSTRT,0(R14)  CHANGE TO LONG FORM               GP05060
         B     TEXTBUMP                                         GP05060
         SPACE 1                                                GP05060
TEXTPRIM LA    R15,SSPRIM    SET OUTPUT FIELD                   GP05060
         LA    R0,L'SSPRIM   SET MAX LENGTH                     GP05060
         LA    R1,8(,R1)     SKIP KEYWORD AND (                 GP05060
         BAL   R14,FINDLEN   MOVE TEXT TO NEXT )                GP05060
         CLI   SSPRIM,C'Y'   PRIMARY ?                          GP05060
         BNE   TEXTBUMP      NP                                 GP05060
         MVC   SSPRIM,=CL7'PRIMARY'                             GP05060
         B     TEXTBUMP                                         GP05060
         SPACE 1                                                GP05060
TEXTCONS LA    R1,8(,R1)     SKIP KEYWORD AND (                 GP05060
         LA    R15,DBL       SET OUTPUT FIELD                   GP05060
         LA    R0,L'DBL      SET MAX LENGTH                     GP05060
         BAL   R14,FINDLEN   MOVE TEXT TO NEXT )                GP05060
         B     TEXTBUMP                                         GP05060
         SPACE 1                                                GP05060
FINDLEN  STM   R14,R5,SETISAVE                                  GP05060
         SR    R3,R3         RETURN LENGTH                      GP05060
         CLI   0(R1),C''''   QUOTED STRING ?                    GP05060
         BE    FINDAPO       YES; SPECIAL HANDLING              GP05060
         LR    R14,R1        SAVE SCAN START                    GP05060
         LR    R15,R0        SAVE FIELD LENGTH                  GP05060
         SR    R2,R2                                            GP05060
         EX    R15,EXTRTSCN  LOOK FOR TRAILING PARENTHESIS (MAY FAIL)
         CLM   R2,1,TRTSCN+C')'  FOUND END PARENTHESIS?         GP05060
         BNE   FINDLERR      NO; ERROR                          GP05060
         LR    R15,R1        COPY END                           GP05060
         SR    R15,R14       LESS START                         GP05060
         LR    R3,R15        RETURN LENGTH                      GP05060
         SH    R15,=H'1'     MAKE MOVE LENGTH                   GP05060
         BM    FINDLERR      NONE ?                             GP05060
         L     R2,SETISAVE+4  GET FIELD ADDRESS                 GP05060
         EX    R15,EXMVCSCN  MOVE TEXT                          GP05060
         B     FINDLENX                                         GP05060
FINDAPO  DS    0H                                               GP05060
FINDAPOI LA    R1,1(,R1)     SKIP STARTING APOTE                GP05060
FINDAPOL CLI   0(R1),C''''   INT. OR FINAL APOTE?               GP05060
         BNE   FINDAPOM      NEITHER; MOVE BYTE                 GP05060
         CLI   1(R1),C''''   INTERNAL DOUBLED APOTE?            GP05060
         LA    R1,1(,R1)     SKIP FIRST OF PAIR                 GP05060
         BNE   FINDLENX      NO; END                            GP05060
FINDAPOM MVC   0(1,R15),0(R1)  PROPAGATE                        GP05060
         LA    R15,1(,R15)   ADVANCE O/P CURSOR                 GP05060
         LA    R3,1(,R3)     ALSO BUMP LENGTH                   GP05060
         BCT   R0,FINDAPOI   DO ANOTHER                         GP05060
         SPACE 1                                                GP05060
FINDLERR OI    FLAG,FGSYNT   SYNTAX ERROR - FIELD TOO LONG      GP05060
FINDLENX ST    R1,SETISAVE+12  RETURN NEW R1                    GP05060
         ST    R3,SETISAVE+8  RTURN LENGTH IN R0                GP05060
         LM    R14,R5,SETISAVE                                  GP05060
         BR    R14                                              GP05060
EXTRTSCN TRT   0(0,R14),TRTSCN  SCAN FOR )                      GP05060
EXMVCSCN MVC   0(0,R2),0(R14)   MOVE TXT                        GP05060
         TITLE 'NEXTCARD - Read the next card'
***********************************************************************
* Before we read the next card we first issue all the error message   *
* that are needed for the last card.  The error causes are setup      *
* in byte FLAG.  There might be more than one error code set          *
***********************************************************************
NEXTCARD DS    0H                     , Get next statement from mbr
         TM    FLAG,FGERMSK           , any error flags set?    GP05060
         BZ    NEXTCINF               , bif no error
         SPACE 1
***********************************************************************
* Input records have been stacked or printed. Unstack/print, and      *
* append the appropriate error message(s).                            *
***********************************************************************
         SPACE 1
         SETMAXCC 8          INDICATE ERROR
*WHY*    MSGPUT MSG13E                , display error indicator msg
*WHY*    BAL   R14,PUTERR             , on sysprint
         BLANK SSCLEAR       PREVENT PROCESSING                 GP05060
         TM    FLAG,FGSYNT   SYNTAX ERROR?                      GP05060
         BZ    NEXTC010      NO                                 GP05060
         MSGPUT MSG19E       FIELD TOO LONG                     GP05060
         BAL   R14,PUTERR             , show message
NEXTC010 TM    FLAG,FGCRUD            , BAD TEXT ?              GP05060
         BZ    NEXTC020      NO                                 GP05060
         MSGPUT MSG24E       GARBAGE TEXT                       GP05060
         MVC   MSG24E1,TEXTICLE  SHOW BAD TEXT                  GP05060
         BAL   R14,PUTERR             , show message            GP05060
NEXTC020 MVI   FLAG,X'0'              , re-initialize flagbyte
NEXTCINF LA    RECOFFST,80(,RECOFFST) , next card
         CH    RECOFFST,BLOCKLEN      , end of block?
         BE    READBLCK               , Then read next block
         B     READREC                , else get next record
         TITLE 'CLOSE - Leave with error code set'
***********************************************************************
* General "leave after error" routine                                 *
***********************************************************************
         SPACE 1
EXIT12   DS    0H
         SETMAXCC 12                  , Set retrun code
EXIT     TM    PROCFLAG,HAVEMEM   FOUND ANY MEMBERS ?           GP05060
         BNZ   EXITMM        YES                                GP05060
         MSGPUT MSG97W       WRITE WARNING                      GP05060
         MVC   MSG97W1,MEMMASK  WHAT'S MISSING                  GP05060
         BAL   R14,PUTERR    TOO BAD                            GP05060
         SETMAXCC 4          NOT TOO BAD ?                      GP05060
EXITMM   MSGPUT MSG99I                , insert message
         L     R15,MAXCC              , get return code
         CVD   R15,DBL                , make a number
         UNPK  MSG99I1,DBL+5(3)       , make printable
         OI    MSG99I1+L'MSG99I1-1,C'0'      last digit printable
         BAL   R14,PUTINF             , write last message
         ICM   R1,15,JFCBSAVE+12      , address of buffer       GP05060
         BZ    SKIPFRMN      NONE GOTTEN ?                      GP05060
         L     R0,JFCBSAVE+8          , length of buffer
         FREEMAIN R,LV=(0),A=(1)                                GP05060
SKIPFRMN DS    0H                                               GP05060
         IF    (TM,DCBOFLGS-IHADCB+PARMDIR,DCBOFOPN,O) close PARMDIR if
          DBGMSG =CL8'PARMDIR',=CL8'CLOSE'
          LA   R3,PARMDIR             , point to DCB
          MVC   OCLIST,THELIST
          CLOSE ((R3),FREE),MF=(E,OCLIST)  , and close it
         ENDIF
         IF    (TM,DCBOFLGS-IHADCB+PARMLIB,DCBOFOPN,O) close PARMLIB if
          DBGMSG =CL8'PARMLIB',=CL8'CLOSE'
          LA   R3,PARMLIB             , point to DCB
          MVC   OCLIST,THELIST
          CLOSE ((R3),FREE),MF=(E,OCLIST)  , and close it
         ENDIF (TM,DCBOFLGS-IHADCB+PARMLIB,DCBOFOPN,O) close PARMDIR if
         IF    (TM,DCBOFLGS-IHADCB+SNAPDUMP,DCBOFOPN,O) close SNAPDIR
          DBGMSG =CL8'SNAPDUMP',=CL8'CLOSE'
          LA   R3,SNAPDUMP            , point to DCB
          MVC   OCLIST,THELIST
          CLOSE ((R3)),MF=(E,OCLIST)  , and close it
         ENDIF
         IF    (TM,DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN,O) close printer
          DBGMSG =CL8'SYSPRINT',=CL8'CLOSE'
          LA   R3,SYSPRINT            , point to DCB
          MVC   OCLIST,THELIST
          CLOSE ((R3)),MF=(E,OCLIST)  , and close it
         ENDIF
         L     R15,MAXCC              , get return code
         BSPRET RC=(15)               , and return with rc in r15
         TITLE 'Subroutine NUMTEST - Test if valid zoned numeric field'
***********************************************************************
*                                                                     *
* Registers on Entry:      R1  =   address of field to test           *
*                          R0  =   Length to test                     *
*                          R14 =   Return address                     *
*                                                                     *
* Registers on Exit:      R15 = 0 ===> Field is numeric               *
*                         R15 = 4 ===> Field is NOT numeric           *
*                                                                     *
***********************************************************************
         SPACE 1
NUMTEST  DS    0H                     , test vor valis zoned numeric
         STM   R14,R3,NUMSAVE         , save register
         LR    R3,R0                  , R0 = length, provided by caller
         BCTR  R3,0                   , Decrement for excecute
         SR    R2,R2                  , clear for IC            GP05060
         EX    R3,NUMTESTT            , test for numeric
         ST    R2,NUMSAVE+4           , set caller's R15        GP05060
         LM    R14,R3,NUMSAVE         , restore register
         BR    R14
NUMTESTT TRT   0(*-*,R1),TESTNUMT     , Do the translate
TESTNUMT DC    256XL1'04'             , Init table to 04s       GP05060
         ORG   TESTNUMT+C'0'          , Position to first valid num
         DC    10XL1'00'              , set OK code
         ORG   ,                      , reset location counter
         TITLE 'Subroutines: SETINIT - Initialize some variables'
***********************************************************************
* Setup and Initialization                                            *
* Note: I modified BSPENTER to clear the work area, hence XCs are     *
*       not required.                                           G.P.  *
*                                                                     *
* Registers on Entry:  R14 = Return address                           *
*                                                                     *
* Registers on Exit:   unchanged                                      *
*                                                                     *
***********************************************************************
SETINIT  DS    0H
         STM   R14,R5,SETISAVE        , save registers
         BLANK PARMAREA               , clear parm text area
         MVC   MEMMASK,=CL8'IEFSSN##'  DESIRED MEMBERS          GP05060
         ZAP   LINENUM,=P'100'        , force page break
         ZAP   PAGENUM,=P'0'          , init page number
*DONE    XC    FLAG,FLAG              , init flag byte
*DONE    XC    MAXCC,MAXCC            , clear RC area
*DONE    XC    LASTCC,LASTCC          , clear RC area
*DONE    XC    MEMCC,MEMCC            , clear RC area
*DONE    XC    PARMFLAG,PARMFLAG      , clear parm flag
*DONE    XC    PROCFLAG,PROCFLAG      , clear parm flag
*DONE    XC    JFCBAREA,JFCBAREA      , clear JFCB
         TESTENV                      , STC? BATCH? TSO?
         IF    (CH,R1,EQ,=H'0')       , is this a batch job
          OI   PROCFLAG,ISJOB         , remember in process option flag
         ELSEIF (CH,R1,EQ,=H'4')      , is this an STC
          OI   PROCFLAG,ISSTC         , put indicator to flag
         ELSE                         , it is not supported
          BLANK MSGTEXT
          MSGPUT MSG14E               ,  insert message text
          BAL  R14,PUTERR             , issue message
          B    EXIT12                 , get out with RC=12
         ENDIF
         LM    R14,R5,SETISAVE        , restore registers
         BR    R14                    , and return to caller
         TITLE 'Subroutines: MAKESSCT - BUILD SSN ENTRY'
***********************************************************************
* Locate the subsystem entry. If not found, build one                 *
*                                                                     *
* Data on entry:  SSNAME - subsystem to be located/built              *
*                 SSINIT - optional initialization module             *
*                 SSPARM - optional PARM value (0-60 bytes)           *
*                                                                     *
* Return R15 :    0 - R0=0 SSN already exists   R0=SSCT built/init'd  *
*                 4 - R0=SSCT   built, but init failed                *
*                 8 - error                                           *
*                                                                     *
***********************************************************************
         PUSH  USING                                            GP05060
MAKESSCT LA    R15,8         PRESET FOR ERROR                   GP05060
         SR    R0,R0         AND NO SSCT                        GP05060
         STM   R14,R9,SETISAVE        , save registers          GP05060
         CLI   SSNAME,C' '   UNPROCESSED REQUEST ?              GP05060
         BNH   MAKESSEZ      NO                                 GP05060
         SR    R9,R9         SET NO GETMAIN FLAG                GP05060
         TM    PARMFLAG,PARMCHCK  TEST MODE ?                   GP05060
         BNZ   MAKESSLK      YES; RUN AS IS                     GP05060
         MODESET KEY=ZERO    GET PRIVIED                        GP05060
MAKESSLK L     R8,CVTPTR     GET THE CVT                        GP05060
         ICM   R8,15,CVTJESCT-CVTMAP(R8)  GET THE JES VECTOR TABLE
         BZ    MAKESSEX      FAIL                               GP05060
         USING JESCT,R8      DECLARE IT                         GP05060
         LA    R7,JESSSCT-JESCT-(SSCTSCTA-SSCT)(,R8)  HEAD OF CHAIN
MAKESSLP LR    R6,R7         SAVE ANCHOR                        GP05060
         USING SSCT,R7       DECLARE SSCVT                      GP05060
         ICM   R7,15,SSCTSCTA  GET NEXT SSCT                    GP05060
         BZ    MAKESSAG      NONE; MAKE ONE                     GP05060
         CLC   SSNAME,SSCTSNAM  OUR SSN ?                       GP05060
         BNE   MAKESSLP      NO; LOOK AGAIN                     GP05060
         XC    SETISAVE+4(4),SETISAVE+4  SET RETURN FOUND       GP05060
         MSGPUT MSG03W       TELL USER                          GP05060
         MVC   MSG03W1,SSCURR                                   GP05060
         BAL   R14,PUTINF             , show message            GP05060
         B     MAKESSEX      HAVE IT                            GP05060
MAKESSAG LTR   R9,R9         GOTTEN BEFORE ?                    GP05060
         BNZ   MAKESSKP      YES; SKIP IT                       GP05060
         TM    PARMFLAG,PARMCHCK  TEST MODE ?                   GP05060
         BZ    MAKESSNU      NO; ADD                            GP05060
         MSGPUT MSG04I       TELL USER                          GP05060
         MVC   MSG04I1,SSCURR                                   GP05060
         BAL   R14,PUTPUT             , show message            GP05060
         XC    SETISAVE+4(4),SETISAVE+4  SET RETURN OK          GP05060
         B     MAKESSEX                                         GP05060
MAKESSNU GETMAIN RC,SP=241,LV=SSCTSIZE  SHOULD BE KEY 1         GP05060
         BXH   R15,R15,MAKESSEX  TOO BAD                        GP05060
         LR    R9,R1         COPY ADDRESS                       GP05060
         DROP  R7                                               GP05060
         USING SSCT,R9       DECLARE NEW SSCT                   GP05060
MAKESSKP XC    0(SSCTSIZE,R9),0(R9)  CLEAR IT                   GP05060
         MVC   SSCTSNAM,SSNAME  IDENTIFY IT                     GP05060
         MVC   SSCTID,SSCTID-SSCT(R6)  COPY ID                  GP05060
         SLR   R2,R2         JUST IN CASE                       GP05060
         CS    R2,R1,SSCTSCTA-SSCT(R6)  MAKE END OF CHAIN       GP05060
         BNE   MAKESSLK      NO; CHASE THE CHAIN ALL OVER AGAIN GP05060
         L     R1,=X'00010000'  JESNRSS IS LEFT HALFWORD        GP05060
*MVSSP+  CSADD JESNRSS,INC=(R1)  UPDATE SUBSYSTEM COUNT         GP05060
         ST    R9,SETISAVE+8  SET R0 RETURN                     GP05060
         SR    R9,R9         SHOW AREA USED                     GP05060
         MSGPUT MSG05I       SHOW SUBSYSTEM ADDED               GP05060
         MVC   MSG05I1,SSCURR                                   GP05060
***********************************************************************
*                                                                     *
*   Requested SubSytem entry added                                    *
*                                                                     *
*   If initialization routine was specified, schedule a request       *
*     into the Master address space     ***DEFERRED***                *
*                                                                     *
*   If not the primary subsystem, and START(YES) spcified, issue      *
*     a start command                                                 *
*                                                                     *
***********************************************************************
         CLC   =C'PRIMARY',SSPRIM  PRIMARY SUBSYSTEM ?          GP05060
         BE    MAKESSAM      YES; DON'T TOUCH                   GP05060
         CLI   SSINIT,C' '   INIT ROUTINE ?                     GP05060
         BNH   MAKESSST      NO; TEST FOR START                 GP05060
*   BUILD AND SCHEDULE A CIRB ???                               GP05060
MAKESSST CLC   =C'START',SSSTRT  START REQUESTED ?              GP05060
         BNE   MAKESSAM      NO; JUST MESSAGE                   GP05060
         MVC   SSMGCR(6),=X'000A0000E240'  START AND PREFIX     GP05060
         MODESET KEY=ZERO,MODE=SUP   GET VEY PRIVILEGED         GP05060
         SR    R0,R0                                            GP05060
         MGCR  SSMGCR        ISSUE START                        GP05060
         MODESET KEY=NZERO,MODE=PROB  GET BACK TO NORMAL        GP05060
         MVC   MSG05IS(9),=C', started'                         GP05060
MAKESSAM BAL   R14,PUTPUT             , show message            GP05060
         DROP  R9            NO NEED FOR MAPPING                GP05060
MAKESSEX LTR   R9,R9         UNUSED AREA GOTTEN ?               GP05060
         BZ    MAKESSEY      NO                                 GP05060
         FREEMAIN R,LV=SSCTSIZE,SP=241,A=(R9)                   GP05060
MAKESSEY TM    PARMFLAG,PARMCHCK  TEST MODE ?                   GP05060
         BNZ   MAKESSEZ      YES; RUN AS IS                     GP05060
         MODESET KEY=NZERO    GET UNPRIVIED                     GP05060
MAKESSEZ BLANK SSCLEAR       RE-INIT                            GP05060
         LM    R14,R9,SETISAVE        , RESTORE REGISTERS       GP05060
         BR    R14                    , and return to caller    GP05060
         TITLE 'Subroutines: PUTMSG - Display an error message'
***********************************************************************
*   In batch mode all messages are printed.                           *
*   In STC mode:                                                      *
*     PUTSAV - append message to stack                                *
*     PUTINF - clear stack and skip this message                      *
*     PUTPUT - clear stack and print this message                     *
*     PUTERR - print stack and this message                           *
*                                                                     *
***********************************************************************
PUTSAV   TM    DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN  PRINT OR WTO ?
         BNZ   PUTMSG        PRINT - PROCESS ALL MESSAGES       GP05060
         STM   R14,R3,SPUTSAVE  SAVE A LITTLE                   GP05060
         L     R15,NUMSTACK  GET CURRENT STACK SIZE             GP05060
         LA    R15,1(,R15)   NEXT SLOT                          GP05060
         C     R15,=A(MAXSTACK)                                 GP05060
         BNL   PUTNOT        NO ROOM; IGNORE IT                 GP05060
         ST    R15,NUMSTACK  UPDATE IT                          GP05060
         MH    R15,=AL2(L'MSGTEXT)  DISPLACEMENT                GP05060
         LA    R15,MSGSTACK-L'MSGTEXT(R15)    ADDRESS           GP05060
         MVC   0(L'MSGTEXT,R15),MSGTEXT  SAVE THIS ENTRY        GP05060
PUTNOT   BLANK MSGTEXT       CLEAR TEXT AREA FOR NEXT MESSAGE   GP05060
         LM    R14,R3,SPUTSAVE  RESTORE                         GP05060
         BR    R14           AND RETURN                         GP05060
         SPACE 2                                                GP05060
PUTINF   TM    DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN  PRINT OR WTO ?
         BNZ   PUTMSG        PRINT - PROCESS ALL MESSAGES       GP05060
         STM   R14,R3,SPUTSAVE  SAVE A LITTLE                   GP05060
         XC    NUMSTACK,NUMSTACK  RESET STACKED MSG COUNT       GP05060
         B     PUTNOT        BUT CLEAR THIS MSG                 GP05060
         SPACE 2                                                GP05060
PUTPUT   XC    NUMSTACK,NUMSTACK  RESET STACKED MSG COUNT       GP05060
         B     PUTMSG        AND PRINT                          GP05060
         SPACE 2                                                GP05060
PUTERR   TM    DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN  PRINT OR WTO ?
         BNZ   PUTMSG        PRINT - PROCESS ALL MESSAGES       GP05060
         ICM   R0,15,NUMSTACK   GET MESSAGE COUNT               GP05060
         BZ    PUTMSG        NONE; JUST DO THIS ONE             GP05060
         STM   R14,R3,SPUTSAVE  SAVE A LITTLE                   GP05060
         LR    R3,R0                                            GP05060
         LA    R2,MSGSTACK                                      GP05060
         MVC   MSGHOLD,MSGTEXT  PRESERVE THIS MESSAGE           GP05060
PUTERRL  MVC   MSGTEXT,0(R2)  COPY STACKED ENTRY                GP05060
         MVC   THEWTO(2),=AL2(4+L'MSGTEXT)                      GP05060
         BAL   R14,PUTMSG    WRITE IT                           GP05060
         LA    R2,L'MSGTEXT(,R2)  BUMP                          GP05060
         BCT   R3,PUTERRL                                       GP05060
         XC    NUMSTACK,NUMSTACK  RESET STACKED MSG COUNT       GP05060
         MVC   MSGTEXT,MSGHOLD                                  GP05060
         LM    R14,R3,SPUTSAVE  RESTORE REGS AND FALL THROUGH   GP05060
***********************************************************************
* Routine to display an error message. The error message is assumed   *
* to be stored in the MSGTEXT area (and is at most 124 bytes long)    *
* The messages will be written to SYSPRINT DD if available and open.  *
* If not, the messages will be isssued via WTO                        *
*                                                                     *
* Registers on Entry: R14 = Return address                            *
***********************************************************************
         SPACE 1
PUTMSG   DS    0H                     , output message on sysprint
         XR    R15,R15                , clear RC                GP05060
         STM   R14,R3,PUTMSAVE        , save registers
         IF    (TM,DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN,O) SYSPRINT avail?
          IF   (CP,LINENUM,GT,=PL2'55') end of page reached?
           MVC PRNTLINE,HEAD001       , Put in page header
           ZAP LINENUM,=P'12'         , reinit line number
           AP  PAGENUM,=P'1'          , increment page number
           MVC HEAD0011,=X'202120'    , insert edit mask        GP05060
           ED  HEAD0011-1(4),PAGENUM  , beautify page number
           PUT SYSPRINT,PRNTLINE      , write title line
           MVI PRNTCC,C' '   SINGLE SPACE REGULAR TEXT          GP05060
           LA  R2,=A(HEAD0C1,HEAD0C2,HEAD0C3,HEAD0C4,HEAD0C5,HEAD0C6)
           LA  R3,6          SIX LINES                          GP05060
PUTMSGLP   L   R0,0(,R2)     NEXT LINE ADDRESS                  GP05060
           PUT SYSPRINT,(0)  WRITE NEXT LINE                    GP05060
           LA  R2,4(,R2)     POSITION TO NEXT LINE              GP05060
           BCT R3,PUTMSGLP   DO ALL                             GP05060
          ENDIF
          BLANK PRNTTEXT              , erase any garbage
          MVC   PRNTTEXT(L'MSGTEXT),MSGTEXT
          PUT   SYSPRINT,PRNTLINE
         ELSE                         , no SYSPRINT, use WTO instead
*DEFER*   MVI  THEWTO+2,X'80'   DESC/ROUT PRESENT               GP05060
*DEFER*   LH   R15,THEWTO     GET TEXT LENGTH                   GP05060
*DEFER*   LA   R15,THEWTO(R15)     END OF TEXT                  GP05060
*DEFER*   MVC  0(4,R15),=X'40008000'  DESC=2/ROUT=1             GP05060
          WTO  MF=(E,THEWTO)
         ENDIF
         LM    R14,R3,PUTMSAVE        , restore return address
         BR    R14                    , and return
         TITLE 'Allocate SYSUDUMP for JOB if needed'
***********************************************************************
* Allocate SYSUDUMP DD if not already present                         *
***********************************************************************
         SPACE 1
ALCUDUMP DS    0H                     , allocate SYSUDUMP
         STM   R14,R1,ALCUSAVE        , save registers
         MVC   TEMPDDN,TUSDDDNM       , insert DDNAME into msg text
         MVC   SVC99WA(TUSDLEN),TUSDPTR move text units to WS
         LA    R1,SVC99WA+TUSDDDN-TUSDPTR  point to DDNAME
         ST    R1,SVC99P1             , put into TU list
         LA    R1,SVC99WA+TUSDCLS-TUSDPTR  , point to CLASS parm
         ICM   R1,B'1000',=XL1'80'    , indicate last parm
         ST    R1,SVC99P2             , put into TU list
         LA    R1,SVC99WA             , point to work area
         BAL   R14,DOSVC99            , go and do it
         IF    (LTR,R15,R15,NZ)       , Error on DYNALLOC?
          WTO  MF=(E,THEWTO)          , tell the user
          B    EXIT12                 , and end with RC=12
         ENDIF (LTR,R15,R15,NZ)       , Error on DYNALLOC
         LM    R14,R1,ALCUSAVE        , restore registers
         BR    R14                    , return to caller
***********************************************************************
* SYSUDUMP DYNALLOC parameters                                        *
***********************************************************************
         SPACE 1
TUSDPTR  DS    0F                     , text unit pointers
         DC    A(TUSDDDN)             , address of DDNAME
         DC    X'80'                  , end of list indicator
         DC    AL3(TUSDCLS)           , address of SYSOUT CLASS info
TUSDDDN  DC    AL2(DALDDNAM)          , key for DDNAME
         DC    AL2(1)                 , number of entries
         DC    AL2(8)                 , length od 1 entry
TUSDDDNM DC    CL8'SYSUDUMP'          , contens of entry
TUSDCLS  DC    AL2(DALSYSOU)          , key for SYSOUT
         DC    AL2(1)                 , number of entries
         DC    AL2(1)                 , length of 1 entry
         DC    C'X'                   , sysout class            GP05060
TUSDLEN  EQU   *-TUSDPTR
         TITLE 'Subroutines: DOSVC99 - Perform DYNALLOC functions'
***********************************************************************
* Allocate a file to the current JOB/STC using SVC99.                 *
*                                                                     *
* Registers on entry:  R1 --->  Text Unit parameter list              *
*      field TEMPDDN:  DDNAME to be allocated                         *
*                                                                     *
* Registers on exit:   R15 = Retrun code                              *
*                        0 : Allocation successful                    *
*                  nonzero : RC from DYNALLOC call                    *
*      field MSGTEXT: error message text                              *
***********************************************************************
DOSVC99  DS    0H                     , perform DYNALLOC functions
         STM   R14,R3,DOSVSAVE        , save registers
         LR    R3,R1                  , point to Text Unit Pointerlist
         DBGMSG TEMPDDN,=CL8'DYNALLOC'
         DEVTYPE TEMPDDN,DEVTYPE      , Test for DD card
         IF    (LTR,R15,R15,NZ)       , if no DD card
          LA   R2,REQBLK              , point to request block
          USING S99RB,R2              , tell assembler
          XC   REQBLK,REQBLK          , clear RB
          MVI  S99RBLN,REQBLKLN       , set up length
          MVI  S99VERB,S99VRBAL       , indicate ALLOC function
          ST   R3,S99TXTPP            , put into Request block
          LA   R3,RBPTR               , Point to RB pointer
          USING S99RBP,R3             , tell assembler
          ST   R2,S99RBPTR            , st RB address into RB PTR
          OI   S99RBPTR,S99RBPND      , turn on high order bit
          LA   R1,RBPTR               , get addres of RB pointer
          DYNALLOC                    , issue SVC 99
          ST   R15,DOSVSAVE+4         , set caller's R15
          XR   R15,R15                , clear R15
          ICM  R15,B'0011',S99ERROR   , get error code
          ST   R15,DOSVSAVE+8         , place into caller's R0
          MSGPUT MSG01E               , insert message text
          MVC  MSG01E1,TEMPDDN        , insert DDNAME into message
          X2CHRTRN MSG01E2,DOSVSAVE+06,LEN=2
          X2CHRTRN MSG01E3,DOSVSAVE+10,LEN=2
         ELSE
          ST   R15,DOSVSAVE+4         , set caller's R15
          MSGPUT MSG20I               , set up message text
         ENDIF
         LM    R14,R3,DOSVSAVE        , restore return address
         BR    R14                    , and retrun to caller
         DROP  R2,R3                  , not needed any more
         TITLE 'Allocate SNAPDUMP'
***********************************************************************
* Allocate SNAPDUMP DD if not already present                         *
***********************************************************************
         SPACE 1
ALCPDUMP DS    0H                     , allocate SNAPDUMP
         STM   R14,R1,ALCSSAVE        , save registers
*        IF    (TM,PROCFLAG,ISJOB,O)  , Is this a batch job?
          MVC  TEMPDDN,TUSNDDNM       , insert DDNAME into msg text
          MVC  SVC99WA(TUSNLEN),TUSNPTR move text units to WS
          LA   R1,SVC99WA+TUSNDDN-TUSNPTR  point to DDNAME
          ST   R1,SVC99P1             , put into TU list
          LA   R1,SVC99WA+TUSNCLS-TUSNPTR  , point to CLASS parm
          ICM  R1,B'1000',=XL1'80'    , indicate last parm
          ST   R1,SVC99P2             , put into TU list
          LA   R1,SVC99WA             , point to work area
          BAL  R14,DOSVC99            , go and do it
          IF   (LTR,R15,R15,NZ)       , Error on DYNALLOC?
           WTO MF=(E,THEWTO)          , tell the user
           B   EXIT12                 , and end with RC=12
          ENDIF (LTR,R15,R15,NZ)      , Error on DYNALLOC
*        ENDIF (TM,PROCFLAG,ISJOB)    , Is this a batch job?
         LM    R14,R1,ALCSSAVE        , restore registers
         BR    R14                    , return to caller
         SPACE 2
***********************************************************************
* SNAPDUMP DYNALLOC parameters                                        *
***********************************************************************
         SPACE 1
TUSNPTR  DS    0F                     , text unit pointers
         DC    A(TUSNDDN)             , address of DDNAME
         DC    X'80'                  , end of list indicator
         DC    AL3(TUSNCLS)           , address of SYSOUT CLASS info
TUSNDDN  DC    AL2(DALDDNAM)          , key for DDNAME
         DC    AL2(1)                 , number of entries
         DC    AL2(8)                 , length od 1 entry
TUSNDDNM DC    CL8'SNAPDUMP'          , contens of entry
TUSNCLS  DC    AL2(DALSYSOU)          , key for SYSOUT
         DC    AL2(1)                 , number of entries
         DC    AL2(1)                 , length of 1 entry
         DC    C'X'                   , sysout class            GP05060
TUSNLEN  EQU   *-TUSNPTR
         TITLE 'Allocate SYSPRINT for JOB if needed'
***********************************************************************
* Allocate SYSPRINT DD if not already present                         *
***********************************************************************
         SPACE 1
ALCPRINT DS    0H                     , allocate SYSPRINT DD
         STM   R14,R1,ALCPSAVE        , save the registers
         IF    (TM,PROCFLAG,ISJOB,O)  , Is this a batch job?
          MVC  TEMPDDN,TUSPDDNM       , insert DDNAME into msg text
          MVC  SVC99WA(TUSPLEN),TUSPPTR move text units to WS
          LA   R1,SVC99WA+TUSPDDN-TUSPPTR  point to DDNAME
          ST   R1,SVC99P1             , put into TU list
          LA   R1,SVC99WA+TUSPCLS-TUSPPTR  , point to CLASS parm
          ICM  R1,B'1000',=XL1'80'    , indicate last parm
          ST   R1,SVC99P2             , put into TU list
          LA   R1,SVC99WA             , point to work area
          BAL  R14,DOSVC99            , go and do it
          IF   (LTR,R15,R15,NZ)       , Error on DYNALLOC?
           WTO MF=(E,THEWTO)          , tell the user
           B   EXIT12                 , and end with RC=12
          ENDIF (LTR,R15,R15,NZ)      , Error on DYNALLOC?
         ENDIF (TM,PROCFLAG,ISJOB)    , Is this a batch job?
         LM    R14,R1,ALCPSAVE        , restore the registers
         BR    R14                    , and return to caller
         SPACE 2
***********************************************************************
* SYSPRINT DYNALLOC parameters                                        *
***********************************************************************
         SPACE 1
TUSPPTR  DS    0F                     , text unit pointers
         DC    A(TUSPDDN)             , address of DDNAME
         DC    X'80'                  , end of list indicator
         DC    AL3(TUSPCLS)           , address of SYSOUT CLASS info
TUSPDDN  DC    AL2(DALDDNAM)          , key for DDNAME
         DC    AL2(1)                 , number of entries
         DC    AL2(8)                 , length od 1 entry
TUSPDDNM DC    CL8'SYSPRINT'          , contens of entry
TUSPCLS  DC    AL2(DALSYSOU)          , key for SYSOUT
         DC    AL2(1)                 , number of entries
         DC    AL2(1)                 , length of 1 entry
         DC    C'X'                   , sysout class            GP05060
TUSPLEN  EQU   *-TUSPPTR
         TITLE 'Subroutines: OPNPRINT - Open SYSPRINT'
***********************************************************************
* Open SYSPRINT DD for output processing (for a job)                  *
***********************************************************************
         SPACE 1
OPNPRINT DS    0H                     , open SYSPRINT
         STM   R14,R1,OPNPSAVE        , save registers
         IF    (TM,PROCFLAG,ISJOB,O)  , Is this a batch job?
          MVC  SYSPRINT,SYSPRDCB      , move DCB to reentrant storage
          LA   R1,SYSPRINT            , point to SYSPRINT DCB
          BAL  R14,OPENFILE           , go open the file
         ENDIF (TM,PROCFLAG,ISJOB)    , Is this a batch job?
         LM    R14,R1,OPNPSAVE        , restore registers
         BR    R14                    , return to caller
         PUSH  PRINT
         PRINT NOGEN
SYSPRDCB DCB   DDNAME=SYSPRINT,       , ddname for this file           -
               DSORG=PS,              , file is sequential             -
               LRECL=&LRECL,          , record length                  -
               BLKSIZE=&BLKSIZE,      , and blocksize                  -
               MACRF=(PM),            , will be opened for output      -
               RECFM=FBA              , fixed block, ansi cntlchars
SYSPRLEN EQU   *-SYSPRDCB             , length of DCB
         TITLE 'Subroutines: OPNSNAPD - Open SNAPDUMP'
***********************************************************************
* Open SNAPDUMP for SNAP SVC processing                               *
***********************************************************************
         SPACE 1
OPNPDUMP DS    0H                     , open SYSPRINT
         STM   R14,R1,OPNSSAVE        , save registers
*        IF    (TM,PROCFLAG,ISJOB,O)  , Is this a batch job?
          MVC  SNAPDUMP,SNAPDDCB      , move DCB to reentrant storage
          LA   R1,SNAPDUMP            , point to SYSPRINT DCB
          BAL  R14,OPENFILE           , go open the file
*        ENDIF (TM,PROCFLAG,ISJOB)    , Is this a batch job?
         LM    R14,R1,OPNSSAVE        , restore registers
         BR    R14                    , return to caller
         PUSH  PRINT
         PRINT NOGEN
SNAPDDCB DCB   DDNAME=SNAPDUMP,       , ddname for this file           -
               DSORG=PS,              , file is sequential             -
               LRECL=125,             , record length                  -
               BLKSIZE=1632,          , and blocksize                  -
               MACRF=W,               , will be opened for output      -
               RECFM=VBA              , fixed block, ansi cntlchars
SNAPDLEN EQU   *-SNAPDDCB             , length of DCB
         POP   PRINT
         TITLE 'Subroutine OPENFILE - Open files as needed'
***********************************************************************
* Open a file, report any errors ifopen fails                         *
*   If input file (PARMLIB directory or member), use TYPE=J           *
*                                                                     *
* Registers on entry:  R1  = address of DCB to be opened              *
*                      R14 = Return address                           *
*                                                                     *
* Registers on exit:   R15 = Returncode                               *
*                        0 ==> OPEN successful                        *
*                        8 ==> OPEN failed                            *
***********************************************************************
         SPACE 1
OPENFILE DS    0H                     , Open routine
         STM   14,3,OPENSAVE          , save registers
         LR    R3,R1                  , Point to DCB
         USING IHADCB,R3              , tell assembler
         DBGMSG DCBDDNAM,=CL8'OPEN'
         MSGPUT MSG02E                , insert message body
         MVC   MSG02E1,DCBDDNAM       , insert DD name into msg
         MVC   OCLIST,THELIST         , Set up open/close list
         IF    (CLC,DCBDDNAM,EQ,TUSPDDNM),OR,     SYSPRINT?            +
               (CLC,DCBDDNAM,EQ,TUSNDDNM)         SNAPDUMP
          OPEN ((R3),OUTPUT),MF=(E,OCLIST)
         ELSE
          OPEN ((R3),INPUT),MF=(E,OCLIST),TYPE=J                GP05060
         ENDIF
         IF    (TM,DCBOFLGS,DCBOFOPN,O) if open was successful
          XR   R15,R15                , clear return code
         ELSE                         , when open failed
          BAL R14,PUTERR              , issue the message
          LA  R15,8                   , load error RC
         ENDIF (TM,DCBOFLGS,DCBOFOPN,O) if open was okay
         ST    R15,OPENSAVE+4         , set caller's R15
         LM    14,3,OPENSAVE          , restore registers
         BR    R14                    , and return to caller
         DROP  R3                 , not needed outside this module
         TITLE 'Analyze JCL PARM value'
***********************************************************************
* Analyse the JCL EXEC parameter                                      *
***********************************************************************
PROCPARM DS    0H                     , analyse PARM statement
         STM   R14,R1,PROCSAVE        , Save registers
         L     R1,4(,R13)             , Get old save area       GP05060
         L     R1,24(,R1)             , Address of passed parm  GP05060
         L     R1,0(,R1)              , Point to parm           GP05060
         LH    R15,0(0,R1)            , R15 = Length of parameters
         IF    (LTR,R15,R15,Z)        , if no parameter was given
          OI   PARMFLAG,PARMCHCK      , set default of NOUPDATE
         ELSEIF (CH,R15,GT,=H'8')     , if parm string too long
          OI   PARMFLAG,PARMLONG      , indicate in flag
          LA   R15,8                  , load maximum allowed length
         ENDIF (LTR,R15,R15,Z)        , if no parameter was given
         IF    (LTR,R15,R15,NZ)       , if a parameter was given
         BCTR  R15,0                  , minus one for EX
         OC    PARMAREA(*-*),2(R1)    , move in parameters      GP05060
         EX    R15,*-6                , via EX
         IF    (CLC,PARMAREA,EQ,=CL8'NOUPDATE'),OR,(CLC,PARMAREA,EQ,=CL*
               8'CHECK')     MAKE IT BEHAVE AS COMMENTED        GP05060
          OI   PARMFLAG,PARMCHCK      , indicate PARM=NOUPDATE
         ELSEIF (CLC,PARMAREA,EQ,=CL8'NOREPLYU')
          OI   PARMFLAG,PARMNORU      , indicate in action flag
          OI   PARMFLAG,PARMSET       , turn on SET flag
         ELSEIF (CLC,PARMAREA,EQ,=CL8'UPDATE')
          OI   PARMFLAG,PARMSET       , by setting bit flag
         ELSE
          OI   PARMFLAG,PARMINV       , indicate invalid parm
         ENDIF
         TESTAUTH FCTN=1     ARE WE AUTHORIZED?                 GP05060
         IF    (LTR,R15,R15,NZ),AND,(TM,PARMFLAG,PARMCHCK,Z)    GP05060
          OI   PARMFLAG,PARMCHCK  RUN IN CHECK MODE             GP05060
          NI   PARMFLAG,255-PARMNORU-PARMSET  RESET CHANGES     GP05060
          SETMAXCC 16        SET MAJOR ERROR                    GP05060
          MSGPUT MSG47E      AND LET USER KNOW                  GP05060
          BAL    R14,PUTERR  SPIT IT OUT                        GP05060
         ENDIF (LTR,R15,R15,NZ),AND,(TM,PARMFLAG,PARMCHCK,Z)    GP05060
         ENDIF (LTR,R15,R15,Z)        , if no parameter was given
         LM    R14,R1,PROCSAVE        , restore registers
         BR    R14                    , return to caller
         TITLE 'Allocate and open PARMLIB'
***********************************************************************
* Allocate PARMLIB DD if not already present                          *
***********************************************************************
         SPACE 1
ALCPALIB DS    0H                     , allocate PARMLIB DD
         STM   R14,R12,ALCPASAV       , save registers
         MVC   TEMPDDN,TUPLDDNM       , insert DDNAME into msg text
         MVC   SVC99WA(TUPLLEN),TUPLPTR move text units to WS
         LA    R1,SVC99WA+TUPLDDN-TUPLPTR  point to DDNAME
         ST    R1,SVC99P1             , put into TU list
         LA    R1,SVC99WA+TUPLDSN-TUPLPTR  , point to DSN parm
         ST    R1,SVC99P2             , put into TU list
         LA    R1,SVC99WA+TUPLSTAT-TUPLPTR  , point to DISP parm
         ICM   R1,B'1000',=XL1'80'    , indicate last parm
         ST    R1,SVC99P3             , put into TU list
         LA    R1,SVC99WA             , point to work area
         BAL   R14,DOSVC99            , go and do it
         IF    (LTR,R15,R15,NZ)       , Error on DYNALLOC?
          BAL  R14,PUTERR             , tell the user
          B    EXIT12                 , and end with RC=12
         ENDIF (LTR,R15,R15,NZ)       , Error on DYNALLOC
         LM    R14,R12,ALCPASAV       , restore registers
         BR    R14                    , return to caller
         SPACE 2
***********************************************************************
* PARMLIB DYNALLOC parameters                                         *
***********************************************************************
         SPACE 1
TUPLPTR  DS    0F                     , text unit pointers
         DC    A(TUPLDDN)             , address of DDNAME
         DC    A(TUPLDSN)             , address of DSNAME
         DC    X'80'                  , end of list indicator
         DC    AL3(TUPLSTAT)          , address of STATUS
TUPLDDN  DC    AL2(DALDDNAM)          , key for DDNAME
         DC    AL2(1)                 , number of entries
         DC    AL2(8)                 , length od 1 entry
TUPLDDNM DC    CL8'PARMLIB '        '          , contens of entry
TUPLDSN  DC    AL2(DALDSNAM)          , key for DDNAME
         DC    AL2(1)                 , number of entries
         DC    AL2(44)                , length od 1 entry
         DC    CL44'SYS1.PARMLIB'     , contens of entry
TUPLSTAT DC    AL2(DALSTATS)          , key for STATUS (initial DISP)
         DC    AL2(1)                 , number of entries
         DC    AL2(1)                 , length od 1 entry
         DC    X'08'                  , X'08' = OLD
*                                     , X'04' = NEW
*                                     , X'02' = MOD
*                                     , X'01' = OLD
TUPLLEN  EQU   *-TUPLPTR
         TITLE 'Subroutines: OPNPAPDS - Open PARMLIB as a PDS'
***********************************************************************
* Open PARMLIB as PDS                                                 *
*   Note: We read the JFCB prior to open. If a member name/mask is    *
*        present, use it instead of IEFSSN##. To make this work, we   *
*        remove the name and flag from the JFCB, and use OPEN TYPE=J  *
*        for both directory and member DCBs.                          *
***********************************************************************
         SPACE 1
OPNPAPDS DS    0H                     , open PARMLIB as a PDS
         STM   R14,R1,OPNPASAV        , save registers
         MVC   PARMLIB,PARMLDCB       , move DCB to reentrant storage
         LA    R1,PARMLIB             , point to DCB
         USING IHADCB,R1
         LA    R15,JFCBAREA           , point to JFCB input area
         ICM   R15,B'1000',=X'87'     , indicate JFCB exit
         ST    R15,EXLST              , put into exit list
         LA    R15,EXLST              , get address of list
         STCM  R15,B'0111',DCBEXLSA   , and put into DCB
         DROP  R1
         RDJFCB (PARMLIB),MF=(E,OCLIST)  get the JFCB           GP05060
         TM    JFCBIND1,JFCPDS  MEMBER NAME/MASK PRESENT ?      GP05060
         BZ    PDSNOMSK      NO                                 GP05060
         MVC   MEMMASK,JFCBELNM  MOVE TO MASK AREA              GP05060
         XC    JFCBELNM,JFCBELNM  CLEAR THE NAME                GP05060
         NI    JFCBIND1,255-JFCPDS  RESET MEMBER NAME           GP05060
         OI    JFCBTSDM,JFCNWRIT+JFCNDCB                        GP05060
         NI    JFCBTSDM,255-JFCNDSCB  ALLOW MERGE               GP05060
PDSNOMSK LA    R1,PARMLIB             , point to DCB
         BAL   R14,OPENFILE           , go open the file
         IF    (LTR,R15,R15,NZ)       , if not successful
           BAL R14,PUTERR             , show the error message
           B   EXIT12                 , exit with RC=12
         ENDIF (LTR,R15,R15,Z)        , if successful
         LM    R14,R1,OPNPASAV        , restore registers
         BR    R14
         PUSH  PRINT
         PRINT NOGEN
PARMLDCB DCB   DDNAME=PARMLIB,        , ddname for this file           -
               DSORG=PO,              , file is partitioned            -
               MACRF=R,               , will be opened for input       -
               EODAD=EOMEM            , return on eof
PARMLLEN EQU   *-PARMLDCB             , length of DCB
         POP   PRINT
         TITLE 'Subroutines: OPNPADIR - Open PARMLIB as a PS'
***********************************************************************
* Open PARMLIB as PS (for reading the directory)                      *
***********************************************************************
         SPACE 1
OPNPADIR DS    0H                     , open PARMDIR
         STM   R14,R1,OPNPDSAV        , save registers
         MVC   PARMDIR,PARMDDCB       , move DCB to reentrant storage
         LA    R1,PARMDIR             , point to PARMDIR DCB
         USING IHADCB,R1                                        GP05060
         LA    R15,EXLST              , get address of list     GP05060
         STCM  R15,B'0111',DCBEXLSA   , and put into DCB        GP05060
         DROP  R1                                               GP05060
         BAL   R14,OPENFILE           , go open the file
         IF    (LTR,R15,R15,NZ)       , if open was unsuccessful
           BAL R14,PUTERR             , show error message
           B   EXIT12                 , exit with RC=12
         ENDIF (LTR,R15,R15,Z)        , if open was successful
         LM    R14,R1,OPNPDSAV        , restore registers
         BR    R14                    , return to caller
         PUSH  PRINT
         PRINT NOGEN
PARMDDCB DCB   DDNAME=PARMLIB,        , ddname for this file           -
               DSORG=PS,              , file is sequential             -
               LRECL=256,             , record length                  -
               BLKSIZE=256,           , and blocksize                  -
               KEYLEN=8,              , in order to get record key     -
               MACRF=R,               , will be opened for input       -
               RECFM=F                , fixed block
PARMDLEN EQU   *-PARMDDCB             , length of DCB
         POP   PRINT
         TITLE 'Subroutines: GETBUFF: Get buffer for member DECB'
***********************************************************************
*  Get a read buffer for member I/O (RDJFCB now in PARMLIB open)      *
***********************************************************************
         SPACE 1
GETBUFF  STM   R14,R1,JFCBSAVE        , save registers          GP05060
         DBGMSG TUPLDDNM,=CL8'GETBUFF'                          GP05060
          LH   R0,DCBBLKSI-IHADCB+PARMLIB  BLOCK SIZE FROM DCB  GP05060
          ST   R0,JFCBSAVE+8          , save in caller's R0
          GETMAIN R,LV=(0)            , get area from MVS
          ST   R1,JFCBSAVE+12         , put into caller's R1
          MSGPUT MSG22I               , insert body part of message
          MVC  MSG22I1,JFCBDSNM       , insert dsname
          BAL  R14,PUTERR             , show message
          MSGPUT MSG23I               , insert body part of message
          MVC  MSG23I1,JFCBVOLS       , insert dsname
          BAL  R14,PUTINF             , show message
         LM    R14,R1,JFCBSAVE        , rstore registers
         BR    R14                    , and back to caller
         TITLE 'Subroutines: REPTPARM - Report PARM setting'
***********************************************************************
* Fill in messages BSPAS9xI and report PARM setting                   *
* If no parm is given, or an invalid parm, use the default of         *
* PARM=NOUPDATE                                                       *
***********************************************************************
REPTPARM DS    0H                     , report PARM settings
         STM   R14,R1,REPTSAVE        , save the registers
         MSGPUT MSG91I                , setup MSG91I
         MVC   MSG91I1,PARMAREA       , insert variable part
         BAL   R14,PUTINF             , show message
         IF    (TM,PARMFLAG,PARMLONG,O) Parm too long
          MSGPUT MSG95W               , insert message
          SETMAXCC 4                  , insert return code
          BAL  R14,PUTERR             , and display message text
         ENDIF (TM,PARMFLAG,PARMLONG,O) Parm too long
         IF    (TM,PARMFLAG,PARMSET,O)  PARM=UPDATE?
          MSGPUT MSG93I               , or PARM=NOREPLYU
          BAL  R14,PUTINF             , and display message text
         ELSEIF (TM,PARMFLAG,PARMCHCK,O) PARM=CHECK
          MSGPUT MSG92I               , insert message
          BAL  R14,PUTINF             , and display message text
         ELSE
          MSGPUT MSG94W               , point to warning message
          BAL  R14,PUTERR             , display message
          OI   PARMFLAG,PARMCHCK      , turn of TEST FLAG
         ENDIF                        , and do PARM=CHECK process
         LM    R14,R1,REPTSAVE        , restore the registers
         BR    R14                    , and return to caller
         TITLE 'Constants and L-Form macro instructions skeletons'
THELIST  OPEN  (,),MF=L               , Open close RDJFCB list
AWTO     WTO   ' ',MF=L
AWTOL    EQU   *-AWTO
         SPACE 2
         LTORG
         TITLE 'Reentrant Storage - Message Display variables'
WORKAREA DSECT
***********************************************************************
* The description of a few variables has been placed here because     *
* IFOX00 doesn't easily allow certain forward references in the EQU   *
* statement.                                                          *
***********************************************************************
         READ  DIRDECB,SF,,,'S',MF=L
         PUSH  PRINT
         PRINT GEN
         READ  READDECB,SF,,,'S',MF=L
READDCBE EQU   *
         POP   PRINT
THEWTO   WTO   '----+----1----+----2----+----3----+----4----+----5----+-
               ----6----+----7----+----8----+----9----+----0----+----1--
               ---+----2----',MF=L
         DS    XL4           ROOM FOR DESCRIPTOR/ROUTING CODES  GP05060
MSGTEXT  EQU   THEWTO+4,124           , area for message texts
THEWTOR  WTOR  '---------1---------2---------3---------4---------5------
               ----6---------7---------8---------9---------0---------1--
               --------2-',,,,MF=L
         DS    XL4           ROOM FOR DESCRIPTOR/ROUTING CODES  GP05060
WTORTEXT EQU   THEWTOR+12,121
PRNTLINE DS    0CL(&LRECL)            , line to SYSPRINT
PRNTCC   DS    CL1                    , control character
PRNTTEXT DS    CL(&LRECL-1)           , text to be printed
BSPSSADD CSECT
         TITLE 'Constants - Report Header Lines'
**********************************************************************
*  BSPSSADD Version 1.0
*
*          |l      _,,,---,,_
*    ZZZzz /,:.-':''  . -.  ;-;;,
*         |,4-  ) )-,_. ,( (  :'-
*        '---''(_/--'  :-')_)
*
*  Placed into the Hercules Domain
*  by Volker Bandke, BSP GmbH'
*
*  Volume: MVSRES   Dataset: SYS1.PARMLIB
**********************************************************************
         SPACE 1
HEAD001  DS    0CL(&LRECL)
         DC    C'1BSPSSADD Version &BSPVER..&BSPMOD'
         FILL  HEAD001                ,
         ORG   HEAD001+&LRECL-8
         DC    C'PAGE '
HEAD0011 EQU   PRNTLINE+&LRECL-3,3                              GP05060
         ORG   ,                      ,
HEAD0C1  DS    0CL(&LRECL)
         DC    CL60'0'
         DC    C'       _,,---,,,_      A'
         FILL  HEAD0C1
HEAD0C2  DS    0CL(&LRECL)
         DC    CL60' '
         DC    C'   _,;;-;  .-    '':''-.:,\  zzZZZ'
         FILL  HEAD0C2
HEAD0C3  DS    0CL(&LRECL)
         DC    CL60' '
         DC    C'  ''-''''  ) ), ._,-( (  -o,|'
         FILL  HEAD0C3
HEAD0C4  DS    0CL(&LRECL)
         DC    CL60' '
         DC    C'       (_(''-:  ''--\_)''''--.>'
         FILL  HEAD0C4
HEAD0C5  DS    0CL(&LRECL)
         DC    CL60'0'
         DC    C' Placed into the Hercules Domain'
         FILL  HEAD0C5
HEAD0C6  DS    0CL(&LRECL)
         DC    CL60' '
         DC    C' by Gerhard Postpischil, E.S.P.'
         FILL  HEAD0C6
         DS    0CL(&LRECL)
         TITLE 'Constants - Error and status messages'
**********************************************************************
*   BSPAS01E - xxxxxxxx DD statement not allocated
*   BSPAS02E - Open failed for DD xxxxxxxx
*   BSPAS03W - Subsystem XXXX already defined. Skipped
*   BSPAS04I - Subsystem XXXX not found. Elegible for add
*   BSPAS05I - Subsystem XXXX definition added'
*   BSPAS06E - RDJFCB failed for DD xxxxxxxx
*   BSPAS07E - Find failed for member mmmmmmm
*   BSPAS08I - control statement image
*   BSPAS11I - PARM=NOREPLYU specified.
*   BSPAS12E - Operator rejectected update request.  PARM=NOUPDATE set
*   BSPAS13E - Error found processing above statement
*   BSPAS14E - Environment not BATCH or STC
*   BSPAS16D - Reply 'U' to process IEFSSNxx
*   BSPAS17W - Invalid processing flag, assuming 'Y'
*   BSPAS18E - Invalid continuation'
*   BSPAS19E - Invalid operand length
*   BSPAS47E - Module unauthorized - PARM=CHECK used
*   BSPAS91I - Parm passed: xxxx'
*   BSPAS92I - PARMLIB members will be checked, but not applied
*   BSPAS93I - IEFSSNxx member specified changes will be made.....
*   BSPAS94W - Invalid PARM, PARM=CHECK assumed
*   BSPAS97W - No members matching mask XXXXXXXX
*   BSPAS99W - PARM longer than 8 bytes, trailer ignored
*   BSPAS99I - End of processing
**********************************************************************
*        DC    C'-----+----1----+----2----+----3----+----4----+----5---
MSG01E   DC    C'BSPAS01E - Allocation failed for XXXXXXXX, RC=XXXX, S9+
               9ERROR=XXXX'
MSG01E1  EQU   MSGTEXT+33,8
MSG01E2  EQU   MSGTEXT+46,4
MSG01E3  EQU   MSGTEXT+61,4
MSG02E   DC    C'BSPAS02E - Open failed for DD statement XXXXXXXX'
MSG02E1  EQU   MSGTEXT+40,8
MSG03W   DC    C'BSPAS03W - Subsystem XXXX already defined. Skipped'
MSG03W1  EQU   MSGTEXT+21,4                                     GP05060
MSG04I   DC    C'BSPAS04I - Subsystem XXXX not found. Eligible for add'
MSG04I1  EQU   MSGTEXT+21,4                                     GP05060
MSG05I   DC    C'BSPAS05I - Subsystem XXXX definition added'    GP05060
MSG05I1  EQU   MSGTEXT+21,4                                     GP05060
MSG05IS  EQU   MSGTEXT+42,15          , ADDITIONAL STATUS       GP05060
MSG06E   DC    C'BSPAS06E - RDJFCB failed for PARMLIB, function termina-
               ted'
MSG06E1  EQU   MSGTEXT+29,8
MSG07E   DC    C'BSPAS07E - Find failed for member xxxxxxxx. Ignored'
MSG07E1  EQU   MSGTEXT+34,8
MSG08I   DC    C'BSPAS08I       ----+----1----+----2----+----3----+----*
               4----+----5----+----6----+----7--'
MSG08I1  EQU   MSGTEXT+15,72          ,
MSG11I   DC    C'BSPAS11I - PARM=NOREPLYU specified.'
MSG12E   DC    C'BSPAS12E - Operator rejected member XXXXXXXX processin-
               g.'                                              GP05060
MSG12E1  EQU   MSGTEXT+36,8,C'C'                                GP05060
MSG13E   DC    C'BSPAS13E - Error encountered processing statement'
MSG14E   DC    C'BSPAS14E - Environment not BATCH or STC'
*        DC    C'-----+----1----+----2----+----3----+----4----+----5---
MSG15I   DC    C'BSPAS15I - Debug: File XXXXXXXX, Function ffffffff'
MSG15I1  EQU   MSGTEXT+23,8
MSG15I2  EQU   MSGTEXT+42,8
MSG16D   DC    C'BSPAS16D - Reply ''U'' to process IEFSSNxx, or ''C'' t+
               o skip this member.'                             GP05060
MSG16D1  EQU   WTORTEXT+32,8,C'C'                               GP05060
MSG17W   DC    C'BSPAS17W - Invalid processing flag, assuming ''Y'''
MSG18E   DC    C'BSPAS18E - Invalid continuation'
MSG19E   DC    C'BSPAS19E - Invalid operand length'
MSG20I   DC    C'BSPAS20I - DD already allocated, no allocation done'
MSG21I   DC    C'BSPAS21I - Member being processed: mmmmmmmm'
MSG21I1  EQU   MSGTEXT+35,8
*        DC    C'-----+----1----+----2----+----3----+----4----+----5---
MSG22I   DC    C'BSPAS22I - Dataset processed:                         +
                                   '
MSG22I1  EQU   MSGTEXT+30,44
*        DC    C'-----+----1----+----2----+----3----+----4----+----5---
MSG23I   DC    C'BSPAS23I - on volume vvvvvv'
MSG23I1  EQU   MSGTEXT+21,06
MSG24E   DC    C'BSPAS24E - Unrecognized text XXXXXXXX'         GP05060
MSG24E1  EQU   MSGTEXT+29,8,C'C'                                GP05060
MSG47E   DC    C'BSPAS47E - Module unauthorized - PARM=CHECK used'
MSG91I   DC    C'BSPAS91I - Parms passed: xxxxxxxx'
MSG91I1  EQU   MSGTEXT+25,8
MSG92I   DC    C'BSPAS92I - IEFSSNxx member will be checked, but not ap-
               plied'                                           GP05060
MSG93I   DC    C'BSPAS93I - IEFSSNxx member specified changes will be m*
               ade'                                             GP05060
MSG94W   DC    C'BSPAS94W - Invalid parm, PARM=CHECK assumed'
MSG95W   DC    C'BSPAS95W - Parm was too long, truncated'
*        DC    C'-----+----1----+----2----+----3----+----4----+----5---
MSG97W   DC    C'BSPAS97W - No members found matching XXXXXXXX' GP05060
MSG97W1  EQU   MSGTEXT+37,8,C'C'                                GP05060
MSG98I   DC    C'BSPAS98I - Member processed, LASTCC=xxxx'
MSG98I1  EQU   MSGTEXT+36,4
MSG99I   DC    C'BSPAS99I - End of processing, MAXRC=xxxx'
MSG99I1  EQU   MSGTEXT+36,4
         SPACE 1
TRTSCN   DC    256AL1(0)     TRT TABLE                          GP05060
         ORG   TRTSCN+C')'   FOR END OPERAND SCAN               GP05060
         DC    C')'                                             GP05060
         ORG   ,                                                GP05060
         SPACE 1                                                GP05060
TRTNBLK  DC    256AL1(4)     TRT TABLE                          GP05060
         ORG   TRTNBLK+C' '  FOR BEGIN OPERAND SCAN             GP05060
         DC    X'00'         IGNORE BLANKS                      GP05060
         ORG   ,                                                GP05060
         SPACE 1                                                GP05060
TRTBCOM  DC    256AL1(0)     TRT TABLE                          GP05060
         ORG   TRTBCOM+C' '   FOR POSITIONAL SCAN               GP05060
         DC    X'04'         STOP ON BLANK                      GP05060
         ORG   TRTBCOM+C','   FOR POSITIONAL SCAN               GP05060
         DC    X'08'         PAUSE ON COMMA                     GP05060
         ORG   ,                                                GP05060
         TITLE 'Variables - Workspace'
***********************************************************************
* Workspace SSCT variables and related stuff                          *
***********************************************************************
         SPACE 1
WORKAREA DSECT
DBL      DS    D                        A WORK AREA
SVC99WA  DS    CL(&TUMAXLN)           , parameter area for SVC99
SVC99P1  EQU   SVC99WA+0,4            , SVC 99 parameter 1
SVC99P2  EQU   SVC99WA+4,4            , SVC 99 parameter 2
SVC99P3  EQU   SVC99WA+8,4            , SVC 99 parameter 3
         SPACE 1                                                GP05060
SSCURR   DS    CL4           CURRENT SUBSYSTEM NAME             GP05060
SSMGCR   DS    0A(0),AL2(6+4,0),C'S '  MGCR START        1/2    GP05060
SSNAME   DS    CL4           SUBSYSTEM NAME                     GP05060
SSINIT   DS    CL8           SS INITIALIZATION ROUTINE          GP05060
SSPLEN   DS    H'0'          PARM LENGTH                        GP05060
SSPARM   DS    CL60          SS INITIALIZATION PARM             GP05060
SSSTRT   DS    CL7           NOSTART OR SOMETHING ELSE          GP05060
SSPRIM   DS    CL7           PRIMARY OR SOMETHING ELSE          GP05060
SSCLEAR  EQU   SSNAME,*-SSNAME,C'C'  FIELD TO BLANK             GP05060
         SPACE 2
         TITLE 'Variables - Dynalloc request block'
***********************************************************************
* SVC 99 Request Block                                                *
***********************************************************************
         SPACE 1
         PUSH  PRINT
         PRINT NOGEN
         IEFZB4D0                     , dynalloc dsects
         IEFZB4D2                     , and equates
WORKAREA DSECT
         POP   PRINT
RBPTR    DS    F                      , request block pointer
REQBLK   DS    CL(S99RBEND-S99RB)     , Request block
REQBLKLN EQU   L'REQBLK               , length of request block
         SPACE 1
         TITLE 'Subroutine Save Areas'
***********************************************************************
* Subroutine save areas                                               *
***********************************************************************
ALCMSAVE DS    4F                     , ALCMDUMP save area R14 - R1
ALCPASAV DS    4F                     , ALCPALIB save area R14 - R1
ALCPSAVE DS    4F                     , ALCPRINT save area R14 - R1
ALCSSAVE DS    4F                     , ALCSDUMP save area R14 - R1
ALCUSAVE DS    4F                     , ALCUDUMP save area R14 - R1
GETSAVE  DS    9F                     , GETCONS  save area R14 - R6
JFCBSAVE DS    4F                     , READJFCB save area R14 - R1
NUMSAVE  DS    6F                     , NUMTEST  save area R14 - R3
OPNPASAV DS    4F                     , OPNPAPDS save area R14 - R1
OPNPDSAV DS    4F                     , OPNPADIR save area R14 - R1
OPNPSAVE DS    4F                     , OPNPRINT save area R14 - R1
OPNSSAVE DS    4F                     , OPNSNAPD save area R14 - R1
PROCSAVE DS    4F                     , PROCPARM save area R14 - R1
REPTSAVE DS    4F                     , REPTPARM save area R14 - R1
SETISAVE DS    13A  MAKESSCT R14-R9   , SETINIT  save area R14 - R1
DOSVSAVE DS    6F                     , DOSVC99  save area R14 - R3
OPENSAVE DS    6F                     , OPENFILE save area R14 - R3
SPUTSAVE DS    6F                     , PUTERR/INF/SAV area R14 - R3
PUTMSAVE DS    6F                     , PUTMSG   save area R14 - R3
UPDTSAVE DS    9F                     , UPDTPFK  save area R14 - R6
         AIF   ('&DEBUG' EQ 'NO').NOSNAP3
         PUSH  PRINT
         PRINT GEN
THESNAP  SNAP  DCB=,SDATA=,PDATA=,LIST=,STRHDR=,MF=L
         POP   PRINT
.NOSNAP3 ANOP
         TITLE 'Miscellaneous Variables'
LASTCC   DC    F'0'                   , returncode given to caller
MAXCC    DC    F'0'                   , returncode given to caller
MEMCC    DC    F'0'                   , returncode for this member
DEVTYPE  DC    6F'0'                  , for devtype macro
EXLST    DS    F                      ,DCB Exit List
WTOECB   DC    F'0'                   , ECB we are waiting for
WTOREPLY DC    CL4' '                 , reply we are waiting for
PAGENUM  DC    PL2'0'                 , Page number in report
LINENUM  DC    PL2'100'               , Line number on page
FLAG     DC    XL1'00'                , status flag
FGSYNT   EQU   B'10000000'            , X'80' - Syntax error    GP05060
FGCRUD   EQU   B'01000000'            , X'40' - Invalid text    GP05060
INVCONT  EQU   B'00100000'            , X'20' - Invalid continuation
NEEDCONT EQU   B'00010000'            , X'10' - Continuation requested
FGERMSK  EQU   255             MASK FOR ERROR MESSAGE BITS      GP05060
         DS    0F                     , align JFCB area
JFCBAREA DS    0CL176                 , we need JFCB info
         IEFJFCBN ,                   ,
DIRAREA  DS    0CL264' '              , Area for reading PDS dir info
PDSKEY   DC    CL8' '                 ,
PDSCOUNT DC    XL2'00'                ,
         FILL  DIRAREA                ,
BLOCKLEN DC    H'0'                   ,
PARMFLAG DC    XL1'0'                 , Flag byte for PARM date
PARMSET  EQU   B'10000000'            , X'80' - build SSCTs     GP05060
PARMNORU EQU   B'01000000'            , X'40' - don't issue WTOR
PARMCHCK EQU   B'00100000'            , X'20' - Check IEFSSNxx
PARMDBUG EQU   B'00010000'            , X'10' - SNAPDUMP available
PFMEMMSK EQU   B'00001000'            , X'08' - HAVE A MEMBER MASK  GP
PARMLONG EQU   B'00000100'            , X'04' - Invalid parms given
PARMINV  EQU   B'00000010'            , X'02' - Invalid parms given
PARMNONE EQU   B'00000001'            , X'01' - No parms given
PROCFLAG DS    XL1                    , Processing control flag
MEMFOUND EQU   B'10000000'            , MEMBER NAME MATCHED
MEMPOS   EQU   B'01000000'            , TEXT IS POSITIONAL      GP05060
MEMKEY   EQU   B'00100000'            , TEXT IS KEYWORD         GP05060
ISJOB    EQU   B'00000100'            , running as a batch job
ISSTC    EQU   B'00000010'            , running as a started task
HAVEMEM  EQU   B'00000001'            , We found a member       GP05060
OCLIST   OPEN  (,),MF=L               , OPEN/CLOSE parameter list
SNAPLIST DS    20F
HDRLIST  DS    10F
SAVMEMBR DS    CL8
TEXTICLE DS    CL8           INVALID TEXT                       GP05060
MEMMASK  DS    CL8           IEFSSN## or PARMLIB DD member      GP05060
PARMAREA DS    CL8
TEMPDDN  DS    CL8                    , slot for saving DDNAMES
         DS    0D
SNAPDUMP DS    CL(SNAPDLEN)           , area for SNAPDUMP DCB
         DS    0D
SYSPRINT DS    CL(SYSPRLEN)           , area for SYSPRINT DCB
         DS    0D
PARMLIB  DS    CL(PARMLLEN)           , area for PARMLIB  DCB
         DS    0D
PARMDIR  DS    CL(PARMDLEN)           , area for PARMDIR  DCB
         TITLE 'DSECTS: DSDIRDS - Directory record rayout'
         IHAPDS PDSBLDL=NO   MAP A DIRECTORY ENTRY              GP05060
PDSPREFX EQU   PDS2NAME,6,C'C'        , Prefix, 6 characters    GP05060
PDSSUFFX EQU   PDS2NAME+6,2,C'C'      , Suffix, 2 characters    GP05060
         PRINT NOGEN
         CVT   SYS=AOS1,DSECT=YES     , create CVT DSECT
         IEFJESCT ,
         IEFJSCVT ,          SSCT
         PRINT ON,NOGEN      SAVE A TREE                        GP05060
         DCBD  DSORG=(PO,PS),DEVD=DA  , DCB layout
         SPACE 2
WORKAREA DSECT ,             TACK ONTO THE VERY END             GP05060
NUMSTACK DS    F'0'          NUMBER OF STACKED MESSAGES         GP05060
MSGHOLD  DS    CL(L'MSGTEXT)    HOLD MSG OVER STACK PRINTING    GP05060
MSGSTACK DS    20CL(L'MSGTEXT)  STACK UP TO TWENTY MESSAGES     GP05060
MAXSTACK EQU   (*-MSGSTACK)/L'MSGTEXT  ENTRY COUNT              GP05060
         BSPEND                       , of module
