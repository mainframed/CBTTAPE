RECV380  TITLE 'R E C V 3 8 0  ***  RECEIVE SINGLE TRANSMIT FILE'
         MACRO ,
&NM      KDEF  &VAL,&ID,&TYPE,&V=0
         GBLB  &ZZKDEF
         LCLC  &LTYP,&L
&L       SETC  'L'''
&LTYP    SETC  '&TYPE'
         AIF   ('&LTYP' NE '').HAVETYP
&LTYP    SETC  'X'           ASSUME HEX DEFAULT
.HAVETYP AIF   (N'&V EQ 2).EXPLEN
         AIF   ('&V' EQ '' OR '&V' EQ '0').NULLV
&NM      DC    XL2'&VAL',CL6'&ID ',AL1(KDEF&LTYP),SL2(&V),AL1(&L&V)
         AGO   .COMDEF
.EXPLEN  ANOP  ,
&NM      DC    XL2'&VAL',CL6'&ID ',AL1(KDEF&LTYP),SL2(&V(1)),AL1(&V(2))
         AGO   .COMDEF
.NULLV   ANOP  ,
&NM      DC    XL2'&VAL',CL6'&ID ',AL1(KDEF&LTYP),SL2(0),AL1(0)
.COMDEF  AIF   (&ZZKDEF).MEND
KDEFCL   EQU   3             CHARACTER DATA; LEFT JUSTFIED (NORMAL)
KDEFCR   EQU   1             CHARACTER DATA; RIGHT JUST
KDEFB    EQU   0             BINARY; RIGHT ADJUSTED
KDEFX    EQU   0             HEX
KDEFXL   EQU   2             HEX; LEFT ADJUSTED
KDEFLEFT EQU   2             LEFT JUSTIFY
KDEFDSN  EQU   4             DATA SET NAME SPECIAL
&ZZKDEF  SETB  1
.MEND    MEND  ,
         PUNCH ' ORDER RECV380(P) '    EASIER DUMPS
         PUNCH ' SETCODE AC(1) '  required for IEBCOPY invocation
         COPY  OPTIONGB
         SPACE 1
         SYSPARM LIST=YES
***********************************************************************
*                                                                     *
*   RECF380 restores data sets from files created by IBM TRANSMIT,    *
*   Jim Morrison's XMIT370, and XMIT390.                              *
*                                                                     *
*   Currently limited to one file, either PS or PO. The file is       *
*   allocated and written in this run, without needing to know which  *
*   DS organization it has.                                           *
*                                                                     *
*                                                                     *
*   JCL:// EXEC PGM=RECV380,PARM= {DEBUG,TEST,MERGE,REPLACE,DELETE}   *
*       //SYSTERM  DD SYSOUT=*    program messages                    *
*       //SYSPRINT DD SYSOUT=*    (usually, for IEBCOPY output)       *
*       //XMITIN   DD ...input file in XMIT format...                 *
*       //PATTERN  DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=serial,          *
*       //            DSN=data.set.name.option                        *
*       //SYSIN    DD DUMMY       (IECOPY)                            *
*       //SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,(10))                     *
*       //SYSUT4   DD UNIT=SYSDA,SPACE=(CYL,(10))                     *
*                                                                     *
*   The program will allocate SYSUT1 (temporary) and SYSUT2 (output   *
*     file) with the appropriate parameters and space, as needed.     *
*   SYSUT1 and SYSUT2 may be defined by the user (either or both),    *
*     but must have adequate SPACE to avoid abends.                   *
*                                                                     *
*   The XMITIN file may be specified with any (valid) DCB parameters, *
*   that are otherwise ignored. Input is treated as stream data, and  *
*   any block and record descriptors are skipped. This supports the   *
*   special RDW-only format used by Paul Edwards for the GCC project. *
*                                                                     *
*   The PATTERN DSN may be omitted (use sender's name), or contain    *
*   a DSN construct that must end in .RENAME .PREFIX or .NEWDSN       *
*   The actual name may not be used due to Dynamic Allocation design  *
*   (claims DSN is a duplicate). .NEWDSN is stripped to construct     *
*   the name, .PREFIX uses the prior text to prefix the sender's,     *
*   .RENAME replaces the number of index levels in sender's name      *
*   with the corresponding number (x.y.rename for golob.cbt249.file10 *
*   becomes x.y.file10). If original too short, appends X             *
*                                                                     *
*   PARM values:   DELETE    deletes output file if cataloged in the  *
*                            system, and on the output pack. A new    *
*                            file is allocated on the PATTERN pack.   *
*                  REPLACE   fails if output file is cataloged on     *
*                            another pack. Otherwise deletes file     *
*                            from PATTERN pack and allocates new.     *
*                  MERGE     for sequential, fails if cataloged else- *
*                            where, else deletes and allocates new.   *
*                            for partitioned, fails if cataloged on   *
*                            another pack, allocates if not found,    *
*                            or re-uses if found on pack (adds new    *
*                            members, but leaves other members alone, *
*                            even if changed)                         *
*                  none of the above - fails if data set exists.      *
*                                                                     *
*                  TEST      tests input data, but writes no output   *
*                  DEBUG     prints input and output data in hex and  *
*                            text (dump) format.                      *
*                                                                     *
***********************************************************************
*  Maintenance:                                                       *
*  2012-05-31 GYP Use DSCREST by default rather than IEBCOPY. Added   *
*                   PARM=IBM to force IEBCOPY.                        *
*                                                                     *
***********************************************************************
         EJECT ,
         PRINT &PRTSOR
         EXTRN SUBALLOC      DYNAMIC ALLOCATION ROUTINE
         EXTRN SUBBLKSZ      BLOCK SIZE CALCULATOR
         EXTRN SUBDSCB1      FIND DATA SET CONTROL BLOCK
         EXTRN SUBDSDEL      DATA SET DELETE/UNCATALOG
         EXTRN SUBLOCAT      DATA SET CATALOG LOOKUP
         EXTRN SUBPDUMP      HEX DUMP FORMAT & PRINT
         EXTRN SUBTIODD      FIND TIOT ENTRY FOR DD NAME
         EXTRN SUBUCBLK      UCB SCAN FOR STORAGE VOLUME
         EXTRN SUBVERB       VERB TABLE LOOKUP
RECV380  PGMHEAD ZERO31,BASE=(R11,R12),PARM=R9,BNDRY=PAGE
         SPACE 1
         LA    R10,DYNWORK   SAVE AREA AFTER SAVE AREAS
         DROP  R13
         USING DYNWORK,R10
         MVI   BLANKS,C' '                                      GP09236
         MVC   BLANKS+1(L'BLANKS-1),BLANKS  BUILD 'CONSTANT'    GP09236
         LA    R0,MYJFCB                                        GP09236
         STCM  R0,7,INEXLIST+1                                  GP09236
         SPACE 1
         SERVINIT ,
         SERVLOAD @PARSER,@PRINTER
         PRTOPEN SYSTERM     ISSUE WTO IF MISSING, BUT KEEP RUNNING
         PRTL  '#R E C V 3 8 0                *** SUPER-DUPER RECEIVE',*
               TITLE=1
         MVC   OUTDSN,BLANKS
         MVC   OUTSER,BLANKS
         MVC   OUTUTIL,BLANKS
         MVC   WRKDSN,BLANKS
         MVC   WRKUTIL,BLANKS
         PARMLOAD R8         LOAD PARM ADDR/LEN INTO R8,R9      GP09247
         LTR   R9,R9
         BZ    DONEPARM      SKIP IF NONE
         PARSE 0(R8),(R9),OPT=COMMA  ACCEPT COMMA AND BLANK SEPARATED
         LTR   R15,R15
         BZ    TESTPARM
         PRTDATA '*** PARM field PARSE failed ***'
PARMBADC PRTCLOSE ,
         ABEND 1052,DUMP
         SPACE 1
TESTPARM ICM   R3,15,PAR@TABL     TEST RESULTS
         BZ    DONEPARM
         USING PRSDSECT,R3        DECLARE RETURN ENTRY
PARMFLD  OC    PRS$TEXT,BLANKS    UPPER CASE
         PARFGSET PARMOPTS,ERR=PARMBAD,DONE=PARMNEXT
PARMNEXT ICM   R3,15,PRSLINK
         BNZ   PARMFLD
         B     DONEPARM
         SPACE 1
PARMBAD  PRTDATA '*** Invalid PARM:',(PRS$TEXT,DEB,PAD),'***'  09235
         B     PARMBADC
         SPACE 1
PARMOPTS PARKEYBX PARMOP
PARMOP   PARKEYFG 'TEST',OPTFLAGS,0,FGTEST            TEST MODE
PARMOP2  PARKEYFG 'DEBUG',OPTFLAGS,0,FGBUG            DEBUG MODE
         PARKEYFG 'MERGE',OPTFLAGS,FGDFLT,FGMERGE     MERGE PO, NEW PS
         PARKEYFG 'REPLACE',OPTFLAGS,FGDFLT,FGREP     REPLACE PS & PO
         PARKEYFG 'DELETE',OPTFLAGS,FGDFLT,FGDEL      REPLACE ALL
         PARKEYFG 'NOTV',PROFLAGS,0,FGNOTV   NO BDW/RDW IN DATA GP12152
PARMOPN  PARKEYFG 'IBM',PROFLAGS,0,FGIBM     USE IEBCOPY        GP12152
         SPACE 1
MSGOPTS  FDPRT '       Options now on are : ',NL
         FDTM   OPTFLAGS,FGTEST+FGBUG+FGREP+FGMERGE,BZ=MSGOPTS0
         FDFLAG OPTFLAGS,TABLE=OPTSHO,SPACE=1,LEN=80
         FDGOTO MSGOPTSF
MSGOPTS0 FDPRT 'all off'
MSGOPTSF FDTM   OPTFLAGS,FGREP+FGMERGE,BNZ=MSGOPTEX
         FD    '*** Run may fail if output data set exists ***',NL
MSGOPTEX FD    *END
         SPACE 1
OPTSHO   FLGTAB FGDEL,'Delete',MLEN=1
         FLGTAB FGREP,'Replace'
         FLGTAB FGMERGE,'Merge'
         FLGTAB FGTEST,'Test-mode'
         FLGTAB FGBUG,'Debug-mode'
         FLGTAB *END
         DROP  R3
         SPACE 1
DONEPARM PRTLIST MSGOPTS
         SPACE 1
         RDJFCB XMITIN
         CLI   JFCBDSNM,C' ' DID IT WORK ?
         BH    OPENIN
         PRTDATA '*** Unable to open XMITIN DD ***'
         B     PGMEXIT8      STOP NOW
         SPACE 1
*---------------------------------------------------------------------*
*   Read the XMIT format input file. Note that record format is not   *
*   relevant; the code reads block by block, and an item too long to  *
*   fit causes the buffer fragment to be moved down, and another      *
*   read issued following that.                                       *
*                                                                     *
*   Segments are identified as control vs. data                       *
*---------------------------------------------------------------------*
OPENIN   OPEN  MF=(E,DCBOXMIT)
 PRTDATA '   --- Reading',(JFCBDSNM,DEB,PAD),'from',(JFCBVOLS,6,PAD,DEB*
               ),'---'
         LA    R6,INBUFF
         SR    R7,R7         INITIAL BUFFER DATA
         LR    R1,R6
         A     R1,=A(OUTRDW-INBUFF)    GET ADDRESS OF OUTPUT AREA
         LA    R2,4(,R1)
         STM   R1,R2,@OUTRDW      SET RDW AND BUFFER ADDRESSES
         MVC   0(2,R2),=H'4'      SET OUTPUT EMPTY
         LA    R1,SYSOUT     OUTPUT DATA SET (TO BE ALLOCATED)
         ST    R1,@OUTDCB
         SPACE 1
GETLOOP  LA    R2,INBUFF     MOVE DATA TO BOTTOM OF BUFFER
         LR    R3,R7         SIZE TO MOVE
         LR    R0,R6         FROM ADDRESS
         LR    R1,R7         FROM LENGTH; NO PADDING
         MVCL  R2,R0         MOVE DATA DOWN
GETANEW  READ  RECB,SF,XMITIN,(R2),'S'
         CHECK RECB               ALL DONE (EOF OR ERROR)
         INC   NUMBLK        NUMBER OF BLOCKS
         LA    R6,INBUFF     NEW PROCESSING START
         LH    R15,XMITIN+DCBLRECL-IHADCB  LENGTH OF BLOCK      GP09236
         LTR   R15,R15       VALID LENGTH ?                     GP09236
         BNP   GETANEW       NO; IGNORE                         GP09236
         AR    R7,R15                                           GP09236
         TM    OPTFLAGS,FGBUG     DEBUG MODE ?
         BZ    TESTBDW
         LR    R8,R15        SAVE OVER MSG                      GP09236
         PRTDATA ' ',('Block',NL,PADR),(NUMBLK,I,PAD),' length',(XMITIN*
               +DCBLRECL-IHADCB,2,I,PAD)
         LR    R15,R8        RESTORE LENGTH                     GP09236
TESTBDW  LR    R14,R2        PRESERVE APPEND START              GP09236
         TM    PROFLAGS,FGNOTV    NO BDW/RDWS IN DATA?          GP11057
         BNZ   SEGLOOP         IF SO; SKIP                      GP11057
         CH    R15,0(,R14)   POSSIBLE BDW ?                     GP09236
         BNE   SEGLOOPF      NO; WE'RE SET                      GP11057
         LA    R0,4          ADJUSTMENT                         GP09236
         AR    R14,R0                                           GP09236
         SR    R15,R0        SKIP BDW                           GP09236
         BNP   GETANEW       NOT BDW/RDW IF NEGATIVE            GP09236
         CH    R15,0(,R14)   POSSIBLE RDW ?                     GP09236
         BNE   SKIPBDW       NO; WE'RE SET                      GP09236
         LA    R0,4          ADJUSTMENT                         GP09236
         AR    R14,R0                                           GP09236
         SR    R15,R0        SKIP RDW                           GP09236
         BNP   GETANEW       SKIP ZERO LENGTH ?                 GP09236
         SR    R7,R0         ADJUST RESULT LENGTH FOR RDW       GP09236
SKIPBDW  SR    R7,R0         ADJUST RESULT LENGTH FOR BDW       GP09236
         LR    R3,R15        SIZE TO MOVE                       GP09236
         LR    R0,R9         FROM ADDRESS                       GP09236
         LR    R1,R7         FROM LENGTH; NO PADDING            GP09236
         MVCL  R2,R0         MOVE DATA OVER BDW/RDW             GP09236
         B     SEGLOOP                                          GP11057
SEGLOOPF OI    PROFLAGS,FGNOTV    SET NOT V FORMAT              GP11057
SEGLOOP  SR    R8,R8         WILL HOLD LENGTH OF SEGMENT
         USING RCVDSECT,R6   DECLARE IT
         IC    R8,RCVLEN     GET LENGTH OF RECORD
         CR    R8,R7         SEGMENT FITS IN RECORD ?
         BH    GETLOOP       NO; READ AGAIN
         INC   NUMSEG        NUMBER OF SEGMENTS
         CH    R0,=H'1'
         BNE   NOTFIRST
         CLC   =X'E0C9D5D4D9F0F1',1(R6)     CORRECT HEADER?
         BE    NOTFIRST      YES; PROCESS
         PRTL  '0***** INCORRECT HEADER DATA *****',CC=ASA      GP10232
         SR    R2,R2         OFFSET
         SUBCALL SUBPDUMP,((R2),(R6),(R3),@PRINTER),MF=(E,CALLPARM)
         MVICC 16
         B     PGMEXIT       TOO BAD
NOTFIRST TM    OPTFLAGS,FGBUG     DEBUG MODE ?
         BZ    SKIPDUMP
         ST    R8,DB+4       QUICK SAVE OF LENGTH
         PRTDATA ' ',('Segment',NL,PADR),(NUMSEG,I,DEB),'  length',(DB+*
               4,4,I,PAD,DEB)
         LR    R3,R8
         TM    RCVTYPE,RCVTCNTL   CONTROL RECORD ?
         BNZ   DBFULL        YES; DUMP IN FULL
         MINH  (R3),=H'64'   ARBITRARY DATA DUMP SIZE
DBFULL   SR    R2,R2         OFFSET
         SUBCALL SUBPDUMP,((R2),(R6),(R3),@PRINTER),MF=(E,CALLPARM)
*---------------------------------------------------------------------*
*   Check segment type                                                *
*---------------------------------------------------------------------*
SKIPDUMP TM    RCVTYPE,RCVTCNTL   CONTROL RECORD ?
         BZ    HAVEDATA      NO; DO DATA
         INC   NUMCTL        COUNT CONTROL RECORDS
         CLC   =C'INMR',RCVNAME        DATA SET DESCRIPTOR?
         BNE   LOOKKEYS                NO
         CLC   =C'06',RCVNAME+4        LOGICAL DATA SET END?
         BE    EODADL                  YES; POST-PROCESS
         CLC   =C'03',RCVNAME+4        FUNNY DATA SET HEADER?
         BE    BUMPRCRD                YES; IGNORE
         TM    PROFLAGS,FGDAT          AFTER DATA RECORD ?
         BNZ   EODADL                  YES; LOGICAL END FILE
         CLC   =C'02',RCVNAME+4        DATA SET HEADER?
         BNE   LOOKKEYS                NO; NO HEADER
         PRTLIST KEYHEAD               IDENTIFY FOR USER
LOOKKEYS BAL   R14,KEYLOOK             EXAMINE THE KEYS
           B   PGMEXIT8                BAD KEY FOUND
         CLC   =C'INMR02',RCVNAME      DATA SET DESCRIPTOR ?
         BNE   BUMPRCRD
         OI    PROFLAGS,FGDS1          HAVE MAIN DATA SET ATTRIBUTES
         B     BUMPRCRD
         SPACE 1
KEYHEAD  FDOPT NL,CC=C'0'
         FD    'Detail information for'
         FDTM  PROFLAGS,FGDS1,BO=KEYHEAD2
         FD    'source',PAD
         FDGOTO KEYHEAD3
KEYHEAD2 FD    'temporary work',PAD
KEYHEAD3 FD    'data set'
         FD    *END
         SPACE 1
*---------------------------------------------------------------------*
*   Data record read. For simple sequential, allocate the SYSUT2 file,*
*   and use PUT to store the assembled data record.                   *
*                                                                     *
*   For a PDS, allocate a temporary SYSUT1 file, and SYSUT2 output.   *
*   For SYSUT2, we look for a PATTERN DD card. It supplies the output *
*   volume serial, and either an overriding DS name, or a pattern:    *
*   DSN=a.b.c.PREFIX  uses the original dsn prefixed by a.b.c.        *
*   DSN=a.b.RENAME replace the leading two indices by a.b.            *
*---------------------------------------------------------------------*
HAVEDATA TM    OPTFLAGS,FGALLOC   DID WE ALLOCATE NECESSARY FILES ?
         BNZ   HAVEALLO
         OI    OPTFLAGS,FGALLOC   SHOW ALLOCATED
         L     R1,OUTDSSIZ   GET DATA SET SIZE IN BYTES
         SR    R0,R0
         LH    R2,OUTBLKSZ   GET BLOCK SIZE
         AR    R1,R2         ADD A LITTLE
         DR    R0,R2         GET NEEDED BLOCKS
         ST    R1,CNTBLOCK   SET COUNT FOR ALLOCATION
         ST    R2,SIZBLOCK   AND SIZE FOR ALLOCATION
         LA    R1,=CL8'PATTERN '
         SUBCALL SUBTIODD    LOOK FOR DD CARD
         LTR   R1,R1
         BZ    MISSPATT      PATTERN DD MISSING                 GP09236
         USING TIOENTRY,R1   DECLARE RETURN
         ICM   R3,7,TIOEFSRT   GET THE UCB
         BZ    MSGBDPAT      OR OUT
         LR    R4,R0         COPY THE JFCB ADDRESS
         USING UCBOB,R3
         TM    UCBTBYT3,UCB3TAPE+UCB3DACC   TAPE DISK, OR DRUM ?
         BNM   MSGBDPAT      NO; CAN'T USE
         CLC   =C'SYS',0(R4)      TEMP DSN IN PATTERN JFCB ?
         BNE   HAVEDPAT
         CLC   =C'.T',8(R4)       T TIME ?
         BNE   HAVEDPAT           NO
         CLI   16(R4),C'.'        .RA OR WHATNOT?
         BNE   HAVEDPAT
         MVC   DB(5),3(R4)        PORTION AFTER SYS
         NC    DB(5),=8C'0'       KILL NUMERICS
         CLC   DB(5),=8C'0'       FULL ZONES ?
         BNE   HAVEDPAT           NO, NOT TEMP
         MVC   DB(7),10(R4)       PORTION AFTER .T
         NC    DB(7),=8C'0'       KILL NUMERICS
         CLC   DB(7),=8C'0'       FULL ZONES ?
         BE    HAVEPSER           HAVE A TEMP DSN; USE ORIGINAL NAME
HAVEDPAT LOCBYTE 0(R4),LEN=44     FIND SIGNIFICANT DSN LENGTH
         SR    R15,R14
         CH    R15,=H'8'
         BL    HAVEDBAD           TOO SHORT  FOR XYZ.PATTERN
         LA    R14,0(R15,R4)      POINT TO DSN END
         SH    R14,=H'8'          BACKUP A BIT
         CLC   =C'.PREFIX',1(R14)    PREFIX REQUEST ?
         BE    HAVEDPFX                YES
         CLC   =C'.RENAME',1(R14)    RENAME REQUEST ?
         BE    HAVEDREN                YES
         CLC   =C'.NEWDSN',1(R14)    NEW DSN REQUEST ?
         BE    HAVEDNEW                YES
         MVC   OUTDSN,BLANKS CLEAR                              GP09247
         OC    OUTDSN,0(R4)       UPPER-CASE JFCB NAME          GP09247
         CLC   OUTDSN,0(R4)       SAME BEFORE/AFTER ?           GP09247
         BNE   HAVEPSER      NO; USE IT                         GP09247
HAVEDBAD PRTDATA '*** The PATTERN DD must omit the DSN, or specify one *
               that ends in .NEWDSN, .PREFIX, or .RENAME'
         B     PGMEXIT8
         SPACE 1
*---------------------------------------------------------------------*
*   SVC 99 fails on 4/448 because there is a SYSDSN ENQ on the name   *
*   on the PATTERN DD. So we require the true name to be suffixed by  *
*   .NEWDSN, stripped here.                                           *
*---------------------------------------------------------------------*
HAVEDNEW MVC   OUTDSN,BLANKS
         SH    R15,=H'8'     EXECUTE LENGTH
         EX    R15,EXMVCPAT  USE PATTERN NAME
         B     HAVEPSER           NOW GET SERIAL
EXMVCPAT MVC   OUTDSN(0),0(R4)
*---------------------------------------------------------------------*
*   User requested a RENAME operation. Count index levels and skip    *
*   that many in the original name. If not enough, treat as PREFIX    *
*---------------------------------------------------------------------*
HAVEDREN L     R2,@OUTBUFF        GET WORK SPACE
         MVC   0(44,R2),0(R4)     MOVE PREFIX
         LA    R1,0(R15,R2)       SKIP SOME
         SH    R1,=H'6'           BACK TO INDEX
         LA    R14,0(,R4)         POINT TO START OF NAME
         SR    R0,R0
FINDRINX CLI   0(R14),C'.'        INDEX POINT ?
         BNE   FINDRINB           NO
         AH    R0,=H'1'           UP COUNT
FINDRINB LA    R14,1(,R14)        TRY NEXT
         BCT   R15,FINDRINX       AND AGAIN
         LA    R5,OUTDSN          NOW DO IT FOR OUTPUT
         LA    R15,L'OUTDSN-1
FINDOINX CLI   0(R5),C'.'         INDEX ?
         BE    FINDOPER
FINDOINB LA    R5,1(,R5)
         BCT   R15,FINDOINX
         MVC   0(2,R1),=C'.X'     ARBITRARY NAME
         B     FINDOAPS           NOT ENOUGH LEVELS - MAKE PREFIX
FINDOPER BCT   R0,FINDOINB        SKIP SAME NUMBER OF INDICES
FINDOAPP MVC   0(44,R1),1(R5)     APPEND ORIGINAL NAME
FINDOAPS MVC   OUTDSN,0(R2)       AND MOVE NEW NAME BACK
         CLI   OUTDSN+43,C'.'
         BNE   HAVEPSER
         MVI   OUTDSN+43,C' '
         B     HAVEPSER
*---------------------------------------------------------------------*
*   PREFIX original name by specified indices; truncate if > 44.      *
*---------------------------------------------------------------------*
HAVEDPFX L     R2,@OUTBUFF        GET WORK SPACE
         MVC   0(44,R2),0(R4)     MOVE PREFIX
         LA    R1,0(R15,R2)       SKIP SOME
         SH    R1,=H'6'           BACK TO INDEX
         MVC   0(44,R1),OUTDSN    APPEND ORIGINAL NAME
         MVC   OUTDSN,0(R2)       AND MOVE NEW NAME BACK
         CLI   OUTDSN+43,C'.'
         BNE   HAVEPSER
         MVI   OUTDSN+43,C' '
         B     HAVEPSER
         SPACE 1
*---------------------------------------------------------------------*
*   PATTERN DD card missing. If the data set exists, use the same     *
*     volume. Otherwise loop through the UCBs to look for a storage   *
*     volume with the largest track capacity.                         *
*---------------------------------------------------------------------*
         PUSH  USING                                            GP09236
         DROP  R3                                               GP09236
MISSPATT L     R2,@OUTBUFF   POINTTO WORK AREA                  GP09236
         PRTDATA '   === PATTERN DD missing; will allocate as',(OUTDSN,*
               DEB,PAD),'==='                                   GP09236
         SUBCALL SUBLOCAT,(OUTDSN,(R2)),VL,MF=(E,CALLPARM)      GP09236
         LTR   R15,R15       CATALOGED ?                        GP09236
         BNZ   MISSPNEW      NO                                 GP09236
         CLC   =H'1',44(R2)  AT LEAST ONE VOLUME ?              GP09236
         BH    MISSPNEW      NO; FIND A VOLUME                  GP09236
         MVC   OUTSER,44+2+4(R2)  COPY SERIAL                   GP09236
         SR    R1,R1         LOOP THROUGH UCBS                  GP09236
MISSFIND SUBCALL SUBUCBLK    NEXT UCB                           GP09236
         LTR   R3,R1         ALL DONE ?                         GP09236
         BZ    MISSEND       YES; NO PLACE TO STORE             GP09236
         USING UCBOB,R3                                         GP09236
         CLI   UCBTBYT3,UCB3DACC  DASD ?                        GP09236
         BNE   MISSFIND      NO                                 GP09236
         CLC   OUTSER,UCBVOLI     DESIRED VOLUME ?              GP09236
         BNE   MISSFIND      NO                                 GP09236
         TM    UCBSTAT,UCBONLI    ON-LINE ?                     GP09236
         BZ    MISSFIND                                         GP09236
         PRTDATA '   === PATTERN DD missing; will use cataloged volume'*
               ,(UCBVOLI,PAD,DEB),'==='                         GP09247
         B     HAVEPSER      USE IT                             GP09236
         DROP  R3                                               GP09236
         SPACE 1
MISSPNEW SR    R1,R1         LOOP THROUGH ALL UCBS              GP09236
         SR    R3,R3         RESET OPTIMUM FOUND                GP09236
MISSLOOP SUBCALL SUBUCBLK    REQUEST NEXT UCB                   GP09236
         LTR   R2,R1         ALL DONE ?                         GP09236
         BZ    MISSEND       YES; NO PLACE TO STORE             GP09236
         USING UCBOB,R2                                         GP09236
         CLI   UCBTBYT3,UCB3DACC  DASD ?                        GP09236
         BNE   MISSLOOP      NO                                 GP09236
         TM    UCBSTAB,UCBBSTR    STORAGE ?                     GP09236
         BZ    MISSLOOP      NO                                 GP09236
         TM    UCBSTAT,UCBONLI    ON-LINE ?                     GP09236
         BZ    MISSLOOP                                         GP09236
         LR    R0,R2         COPY UCB ADDRESS                   GP09236
         SUBCALL SUBBLKSZ    GET SIZES FOR THIS VOLUME          GP09236
*        C     R0,DEVDFLT    LARGER THAN PRIOR ?                GP09236
*        BNH   MISSLOOP      NO; TRY ANOTHER                    GP09236
         CH    R0,OUTBLKSZ   LARGER ENOUGH FOR DATA?            GP09236
         BL    MISSLOOP      NO; TRY ANOTHER                    GP09236
         ST    R0,DEVDFLT    REMEMBER IT                        GP09236
         ST    R1,DEVMAX      AND MAXIMUM BLOCK SIZES           GP09236
         LR    R3,R2         REMEMBER THIS UCB                  GP09236
         B     MISSLOOP      BUT KEEP LOOKING                   GP09236
         POP   USING                                            GP09236
*   LETS HOPE IT'S BIG ENOUGH                                   GP09236
MISSEND  LTR   R3,R3         DID WE FIND ONE ?                  GP09236
         BZ    MSGBDPAT      NO; TOO BAD                        GP09236
*   TEST NON-SPECIFIC ALLOCATION                                GP09236
         MVC   OUTSER,BLANKS      JUST IN CASE                  GP09236
         B     PATTDONE      DO DEV CAP, ETC. LATER             GP09236
         SPACE 1
*---------------------------------------------------------------------*
*   Get volume serial, calculate space and block size.                *
*---------------------------------------------------------------------*
HAVEPSER MVC   OUTSER,UCBVOLI     SAVE SERIAL
         LR    R0,R3         PASS UCB ADDRESS
         SR    R1,R1         CLEAR KEY LENGTH
         SUBCALL SUBBLKSZ    GET BLOCK SIZE FOR DEVICE
         ST    R0,DEVDFLT    SAVE OPTIMUM                       GP09236
         ST    R1,DEVMAX      AND MAXIMUM BLOCK SIZES           GP09236
         DROP  R1,R3
PATTDONE CLI   OUTDSORG+1,0       ANY FUNNIES (VSAM, ETC.) ?
         BNE   HAVEBORG           YES; NOT SUPORTED
         CLI   OUTDSORG,0         UNINITIATED ?
         BNE   *+8                NO
         MVI   OUTDSORG,JFCORGPS     DEFAULT TO SEQUENTIAL
         TM    OUTDSORG,JFCORGPS     SEQUENTIAL ?
         BO    HAVEASEQ
         TM    OUTDSORG,JFCORGPO     PARTITIONED?
         BO    HAVEAPDS
HAVEBORG PRTDATA '*** Unsupported DSORG',(OUTDSORG,HEX,PAD),'***'
         B     PGMEXIT8
         SPACE 1
*---------------------------------------------------------------------*
*   Data set is a PDS. Allocate a temporary file to copy the IEBCOPY  *
*   unloaded data set to, then join common to allocate output SYSUT2. *
*---------------------------------------------------------------------*
HAVEAPDS OI    PROFLAGS,FGPDS     SHOW PDS NEEDED
         MVI   SYSOUT+DCBDDNAM-IHADCB+5,C'1'      CHANGE DD TO SYSUT1
         SUBCALL SUBTIODD,=CL8'SYSUT1'      DID USER PRE-ALLOCATE?
         LTR   R1,R1
         BZ    NEEDUT1       NO; ALLOCATE IT NOW
        PRTDATA '   --- Work file SYSUT1 preallocated; using as-is ---'
         B     HAVEACOM
NEEDUT1  MVI   ALLOPARM,C' '    CLEAR ALL
         MVC   ALLOPARM+1(ALLOPLEN-1),ALLOPARM
         MVC   PRMUNIT(5),=CL5'SYSDA'  TEMP SPACE
         MVC   PRMDDNAM,=CL8'SYSUT1 '  TEMPORARY DATA SET
         MVC   PRMSTATS,=C'NEW'
         MVC   PRMNDISP,=CL8'DELETE'
         MVC   PRMCDISP,=CL8'DELETE'
         MVC   PRMSPC+2(6),=X'402020202120'
         L     R1,SIZBLOCK
         CVD   R1,DB
         ED    PRMSPC+2(6),DB+5
         L     R1,CNTBLOCK   NUMBER OF BLOCKS
         MVC   PRMPRIME,=X'4020202020202120'
         CVD   R1,DB
         ED    PRMPRIME,DB+4
         MVC   PRMSECND,=CL8'     100' JUST IN CASE?
         LH    R1,WRKBLKSZ   BLOCK SIZE
         STH   R1,SYSOUT+DCBBLKSI-IHADCB
         MVC   PRMBLKSZ-1(6),=X'402020202120'
         CVD   R1,DB
         ED    PRMBLKSZ-1(6),DB+5
         LH    R1,WRKLRECL
         STH   R1,SYSOUT+DCBLRECL-IHADCB
         MVC   PRMLRECL-1(6),=X'402020202120'
         CVD   R1,DB
         ED    PRMLRECL-1(6),DB+5
         MVC   PRMRECFM(2),=C'VS'
         MVI   SYSOUT+DCBRECFM-IHADCB,DCBRECV+DCBRECSB   VS
         L     R2,@OUTBUFF
         SUBCALL SUBALLOC,((R2),ALLOPARM)
         LTR   R15,R15
         BP    MSGBDAL1
         PRTDATA '   --- SYSUT1 work file',(PRMDSNAM,DEB,PAD),'allocate*
               d on',(PRMVLSER,6,PAD,DEB),'---'
         B     HAVEACOM
         SPACE 1
HAVEASEQ MVI   SYSOUT+DCBDDNAM-IHADCB+5,C'2'      CHANGE DD TO SYSUT2
*MERGE*  MVC   SYSOUT+DCBBLKSI-IHADCB(2),OUTBLKSZ
*MERGE*  MVC   SYSOUT+DCBLRECL-IHADCB(2),OUTLRECL
*MERGE*  MVC   SYSOUT+DCBRECFM-IHADCB(1),OUTRECFM
         SPACE 1
*---------------------------------------------------------------------*
*   If the user has supplied a SYSUT2 DD card, use it. Hope that the  *
*   space allocation is adequate and matches PS/PO type.              *
*---------------------------------------------------------------------*
HAVEACOM SUBCALL SUBTIODD,=CL8'SYSUT2'  SEE WHETHER PRE-ALLOCATED
         LTR   R1,R1         ANY TIOT ENTRY ?
         BZ    NEEDALLO      NO; ALLOCATE ONE
         PRTDATA '   --- Output file preallocated; using as-is ---'
         B     NEEDOPEN
         SPACE 1
*---------------------------------------------------------------------*
*   Allocate the output file                                          *
*   PARM=          attempt allocation only                            *
*   PARM=REPLACE   unconditionally delete/uncatalog file on OUTVOL    *
*   PARM=MERGE     delete old file if sequtial. For PDS, allocate if  *
*                  it does not exist, else keep with DISP=OLD         *
*---------------------------------------------------------------------*
NEEDALLO TM    OPTFLAGS,FGTEST   TEST MODE ?
         BZ    HAVEALLD      YES; SKIP DELETES AND ALLOCATION
         PRTDATA '   --- Deletion and allocation of',(OUTDSN,DEB,PAD),'*
               on',(OUTSER,DEB,PAD),'bypassed - TEST mode ---'
         B     HAVEALLO
         SPACE 1
HAVEALLD TM    OPTFLAGS,FGDEL  DELETE IF IT'S ANYWHERE IN THE SYSTEM?
         BZ    NEEDCATO      NO; CHECK OTHER OPTIONS
         SUBCALL SUBDSDEL,(OUTDSN,'*'),VL,MF=(E,CALLPARM)  DEL CATLG
NEEDCATO TM    OPTFLAGS,FGREP  DELETE IF IT EXISTS ?
         BNZ   NEEDELET      YES; REMOVE OLD FILE
         TM    PROFLAGS,FGPDS     DOING A PDS?
         BNZ   NEEDALLS      YES
         TM    OPTFLAGS,FGMERGE   DELETE PS ONLY ?
         BZ    NEEDALLS
NEEDELET SUBCALL SUBDSDEL,(OUTDSN,OUTSER),VL,MF=(E,CALLPARM)
         LTR   R15,R15       DID SOMETHING
         BZ    NEEDALLS      OLD DELETED OR NOT THERE
TEEDOFF  STM   R15,R0,DB
 PRTDATA '=== Delete/Uncat RC=',(DB,4,I,DEB,PADR),' Rsn=',(DB+4,4,I,DEB*
               ,PADR),'==='
NEEDALLS MVI   ALLOPARM,C' '    CLEAR ALL
         MVC   ALLOPARM+1(ALLOPLEN-1),ALLOPARM
         MVC   PRMDSNAM,OUTDSN
         MVC   PRMDDNAM,=CL8'SYSUT2 '  FINAL DATA SET
         MVC   PRMSTATS,=C'NEW'
         MVC   PRMNDISP,=CL8'CATALOG'
         MVC   PRMCDISP,=CL8'DELETE'
         MVC   PRMSPC+2(6),=X'402020202120'
         L     R1,SIZBLOCK
         CVD   R1,DB
         ED    PRMSPC+2(6),DB+5
         L     R1,CNTBLOCK   NUMBER OF BLOCKS
         MVC   PRMPRIME,=X'4020202020202120'
         CVD   R1,DB
         ED    PRMPRIME,DB+4
         MVC   PRMSECND,=CL8'     100' JUST IN CASE?
         L     R1,OUTDIRB    NUMBER OF BLOCKS
         LTR   R1,R1
         BZ    SKIPDIRB
         MVC   PRMDIR,=X'4020202020202120'
         CVD   R1,DB
         ED    PRMDIR,DB+4
         MVC   PRMDSORG(2),=C'PO'
         TM    OPTFLAGS,FGMERGE   MERGE WITH OLD PDS ?
         BZ    SKIPDIRB
         SUBCALL SUBDSCB1,(OUTDSN,OUTSER,LOCWORK),VL,MF=(E,CALLPARM)
         LTR   R15,R15       DOES IT EXIST ?
         BNZ   SKIPDIRB      NO; ALLOCATE IT NOW
         MVC   PRMSTATS,=C'OLD'   RE-USE EXISTING ONE
SKIPDIRB MVC   PRMVLSER,OUTSER
         TM    OPTFLAGS,FGTEST    TEST MODE?
         BNZ   SKIPALL2
         L     R2,@OUTBUFF
         SUBCALL SUBALLOC,((R2),ALLOPARM)
         LTR   R15,R15
         BP    MSGBDALL
         CLI   OUTSER,C' '   NON-SPECIFIC ALLOCATION ?          GP09236
         BH    SPECALL       NO
         L     R2,@OUTBUFF   POINT TO WORK AREA                 GP09236
         SUBCALL SUBLOCAT,(OUTDSN,(R2)),VL,MF=(E,CALLPARM)      GP09236
         LTR   R15,R15       CATALOGED ?                        GP09236
         BNZ   SPECALL       NO                                 GP09236
         CLC   =H'1',44(R2)  AT LEAST ONE VOLUME ?              GP09236
         BH    SPECALL       BUT HOW ?                          GP09236
         MVC   OUTSER,44+2+4(R2)  COPY SERIAL                   GP09236
         SR    R1,R1         LOOP THROUGH UCBS                  GP09236
ALLOFIND SUBCALL SUBUCBLK    NEXT UCB                           GP09236
         LTR   R3,R1         ALL DONE ?                         GP09236
         BZ    SPECALL       YES; NO PLACE TO STORE             GP09236
         USING UCBOB,R3                                         GP09236
         CLI   UCBTBYT3,UCB3DACC  DASD ?                        GP09236
         BNE   ALLOFIND      NO                                 GP09236
         CLC   OUTSER,UCBVOLI     DESIRED VOLUME ?              GP09236
         BNE   ALLOFIND      NO                                 GP09236
         LR    R0,R3         PASS UCB ADDRESS                   GP09236
         SR    R1,R1         CLEAR KEY LENGTH                   GP09236
         SUBCALL SUBBLKSZ    GET BLOCK SIZE FOR DEVICE          GP09236
         ST    R0,DEVDFLT    SAVE OPTIMUM                       GP09236
         ST    R1,DEVMAX      AND MAXIMUM BLOCK SIZES           GP09236
         DROP  R3                                               GP09236
         SPACE 1
SPECALL  PRTDATA '   --- Output data set',(OUTDSN,DEB,PAD),'allocated o*
               n',(OUTSER,PAD,DEB),'---'
         B     NEEDOPEN
SKIPALL2 PRTDATA '   --- Output data set',(OUTDSN,DEB,PAD),'not allocat*
               ed on',(OUTSER,PAD,DEB),'TEST mode ---'
         B     HAVEALLO
NEEDOPEN L     R2,@OUTRDW    GET RDW ADDRESS
         MVC   0(2,R2),=H'4'      SET OUTPUT EMPTY
         L     R0,=F'32760'       MAX OS SIZE                   GP09236
         STMIN R0,DEVMAX          FIX OVERLY AMBITIOUS SIZE     GP09236
*   ALLOCATE STUFF
         OPEN  MF=(E,DCBOUT1)     OPEN OUTPUT
         TM    OCLFLAG,FG2BIG     PROPER DEVICE?
         BZ    HAVEALLO
         PRTDATA '*** Output device size too small for data; may fail **
               **'
         SPACE 1
*---------------------------------------------------------------------*
*   Assemble data segments; after doing last (x'40'),                 *
*   PUT assembled blocks into SYSout; at EOF invoke IEBCOPY.          *
*---------------------------------------------------------------------*
HAVEALLO OI    PROFLAGS,FGDAT     SHOW DATA RECORD PROCESSED
         LR    R15,R8        COPY SEGMENT LENGTH
         SH    R15,=H'2'     ALLOW FOR LENGTH AND TYPE
         BNP   BUMPRCRD      IGNORE
********* THE NEW (zOS 1.13 IEBCOPY USES A DIFFERENT RECORD 1 FORMAT **
********* I TRIED MESSING WITH IT, BUT GAVE UP, AND WROTE DSCREST    **
*********  INSTEAD                                                   **
*LATER*  TM    PROFLAGS,FGPDS+FGPDS13  PDS AND FIRST TIME?      GP12152
*LATER*  BNM   SKIPADJ         NO                               GP12152
*LATER*  OI    PROFLAGS,FGPDS13        SHOW ADJUSTMENT DONE     GP12152
*LATER*  CH    R15,=X'0038'  NEW FORMAT ?                       GP12152
*LATER*  B     SKIPADJ  **********TRIED BNE*************        GP12152
*LATER*  L     R1,@OUTRDW    GET OUTPUT BUFFER                  GP12152
*LATER*  LH    R2,0(,R1)     OLD LENGTH                         GP12152
*LATER*  LA    R14,0(R2,R1)  NEW DESTINATION                    GP12152
*LATER*  MVC   20(16,R14),=X'0459000FE5A2000000100000000F0594E000'
*LATER*  XC    36(16,R14),36(R14)  CLEAR NEW DATA               GP12152
*LATER*  BCTR  R15,0                                            GP12152
*LATER*  EX    R15,EXMVCOUT  MOVE DATA TO OUTPUT BUFFER         GP12152
*LATER*  LA    R15,1(R2,R15)    NEW LENGTH                      GP12152
*LATER*  STH   R15,0(,R1)    UPDATE LENGTH FOR NEXT TIME        GP12152
*LATER*  B     DONEADJ                                          GP12152
         SPACE 1
SKIPADJ  L     R1,@OUTRDW    GET OUTPUT BUFFER
         LH    R2,0(,R1)     OLD LENGTH
         LA    R14,0(R2,R1)  NEW DESTINATION
         BCTR  R15,0
         EX    R15,EXMVCOUT  MOVE DATA TO OUTPUT BUFFER
         LA    R15,1(R2,R15)    NEW LENGTH
         STH   R15,0(,R1)    UPDATE LENGTH FOR NEXT TIME
DONEADJ  TM    RCVTYPE,RCVTEND    LAST SEGMENT ?
         BZ    BUMPRCRD      NO; WAIT FOR MORE
PUTAREC  L     R2,@OUTRDW    GET OUTPUT RDW/BUFFER ADDRESS
         LH    R3,0(,R2)     LOAD CURRENT LENGTH
         CH    R3,=H'4'      DO NOT WRITE NULL RECORDS
         BNH   BUMPRCRD        IGNORE IT
         INC   NUMREC        WRITING A RECORD
         L     R4,@OUTDCB    GET OUTPUT DCB ADDRESS
         USING IHADCB,R4     DECLARE IT
         TM    DCBRECFM,DCBRECF   U OR F vs. V ?
         BZ    PUTVAR        V
         LA    R2,4(,R2)     SKIP RDW
         SH    R3,=H'4'        OMIT FROM LENGTH
         TM    DCBRECFM,DCBRECU   WHO NEEDS U?
         BNO   PUTPUT        LENGTH HAD BETTER MATCH DCB
PUTVAR   STH   R3,DCBLRECL   V/U - SET CURRENT LENGTH
PUTPUT   TM    OPTFLAGS,FGTEST    TEST MODE ?
         BNZ   PUTNPUT       YES; IGNORE PUT
         PUT   (R4),(R2)     WRITE THE CURRENT RECORD
PUTNPUT  TM    OPTFLAGS,FGBUG     DEBUG MODE?
         BZ    PUTCLEAR
         PRTDATA 'Output record',(NUMREC,I,PAD)
         SR    R4,R4
         SUBCALL SUBPDUMP,((R4),(R2),(R3),@PRINTER),MF=(E,CALLPARM)
PUTCLEAR L     R2,@OUTRDW
         MVC   0(2,R2),=H'4'   RE-INITIALIZE BUFFER
         SPACE 1
BUMPRCRD AR    R6,R8         SKIP CURRENT SEGMENT
         SR    R7,R8         ADJUST LENGTH
         BP    SEGLOOP
         SR    R7,R7         DON'T GO NEGATIVE
         B     GETLOOP
EXMVCOUT MVC   0(0,R14),2(R6)     MOVE SEGMENT DATA
         SPACE 1
*---------------------------------------------------------------------*
*   End of data set found. If we have been writing to SYSUT1, we need *
*   to close it and invoke the proper post-processing program.        *
*---------------------------------------------------------------------*
EODADL   OI    PROFLAGS,FGEOF     SHOW EOF
EODAD    TM    PROFLAGS,FGEOF     LOGICAL EOF FOUND?
         BNZ   EODADOK            YES; WHOOPPEE
         PRTL  '0*** Premature end of input - no INMR06 record found. C*
               heck your file transfer for problems (B37 abend?) ***'
         MVICC 16
         B     PGMEXIT       DON'T WASTE TIME?
EODADOK  CLI   OUTUTIL,C' '  INVOKE SOMETHING?
         BNH   PGMEXIT       NO; DONE
         TM    OPTFLAGS,FGTEST
         BNZ   PGMEXIT
         CLOSE MF=(E,DCBOUT1)
         SPACE 1
         L     R1,@OUTDCB
         CLI   DCBDDNAM-IHADCB+5(R1),C'2'  DID WE JUST WRITE SYSUT2?
         BE    PGMEXIT       YES; DONE
         TM    PROFLAGS,FGIBM     USE IBM METHOD ?              GP12152
         BNZ   OLDCOPY       YES; NEED MORE FILES               GP12152
         MVC   OUTUTIL,=CL8'DSCREST '  USE MY COPY PROGRAM      GP12152
         LA    R1,UTILPARM                                      GP12152
         B     LINKWPRM      USE MY PROGRAM                     GP12152
         SPACE 1
OLDCOPY  DEVTYPE =CL8'SYSIN ',DB                                GP09236
         BXLE  R15,R15,HAVESYN    OK? SHOULD BE DUMMY OR TEMP   GP09236
         MVI   ALLOPARM,C' '    CLEAR ALL                       GP09236
         MVC   ALLOPARM+1(ALLOPLEN-1),ALLOPARM                  GP09236
         MVC   PRMDDNAM,=CL8'SYSIN  '  TEMPORARY DATA SET       GP09236
         MVC   PRMDSNAM(8),=C'NULLFILE'                         GP09236
         L     R2,@OUTBUFF                                      GP09236
         SUBCALL SUBALLOC,((R2),ALLOPARM)                       GP09236
         SPACE 1
HAVESYN  DEVTYPE =CL8'SYSUT3 ',DB                               GP09236
         BXLE  R15,R15,HAVEUT3    OK? SHOULD BE TEMP            GP09236
         MVI   ALLOPARM,C' '    CLEAR ALL                       GP09236
         MVC   ALLOPARM+1(ALLOPLEN-1),ALLOPARM                  GP09236
         MVC   PRMDDNAM,=CL8'SYSUT3 '  TEMPORARY DATA SET       GP09236
         MVC   PRMSPC(3),=C'CYL'                                GP09236
         MVI   PRMPRIME+L'PRMPRIME-1,C'9'   NINE CYLINDERS?     GP09236
         L     R2,@OUTBUFF                                      GP09236
         SUBCALL SUBALLOC,((R2),ALLOPARM)                       GP09236
         SPACE 1
HAVEUT3  DEVTYPE =CL8'SYSUT4 ',DB                               GP09236
         BXLE  R15,R15,LINKUTIL   OK? SHOULD BE TEMP            GP09236
         MVI   ALLOPARM,C' '    CLEAR ALL                       GP09236
         MVC   ALLOPARM+1(ALLOPLEN-1),ALLOPARM                  GP09236
         MVC   PRMDDNAM,=CL8'SYSUT4 '  TEMPORARY DATA SET       GP09236
         MVC   PRMSPC(3),=C'CYL'                                GP09236
         MVI   PRMPRIME+L'PRMPRIME-1,C'9'   NINE CYLINDERS?     GP09236
         L     R2,@OUTBUFF                                      GP09236
         SUBCALL SUBALLOC,((R2),ALLOPARM)                       GP09236
         SPACE 1
LINKUTIL LA    R1,NULLPARM
LINKWPRM LA    R2,OUTUTIL
         LA    R3,DB+4       ECB ADDRESS                        GP12157
         SR    R0,R0
         ST    R0,0(,R3)     CLEAR ECB                          GP12157
*OLD*    LINK  EPLOC=(R2)    FAILS ON DSCREST (@PRT CLOSED?)
         ATTACH EPLOC=(R2),ECB=(R3)         EXECUTE THE UTILITY GP12157
         ST    R1,DB         SAVE THE TCB                       GP12157
         WAIT  ECB=(R3)      WAIT FOR COMPLETION                GP12157
         L     R1,DB         GET TCB BACK                       GP12157
         L     R15,TCBCMP-TCB(,R1)                              GP12157
         LR    R5,R15        SAVE RETURN CODE                   GP12157
         STCM  R15,7,RETCODE+1                                  GP12157
         ST    R0,RSNCODE
         DETACH DB           CLEAN UP                           GP12157
         LTR   R5,R5                                            GP12157
         BZ    GOODUTIL
         PRTLIST MSGBDUTL
         B     PGMEXIT
GOODUTIL PRTDATA '   --- Utility',(OUTUTIL,DEB,PAD),'RC=0 ---'
         SPACE 1
PGMEXIT  PRTLIST STATUS
         CLOSE MF=(E,DCBOXMIT)
         CLOSE MF=(E,DCBOUT1)
         SERVTERM ,
EXITCODE PGMEXIT RC=RETCODE  RETURN WITH CONDITION
         SPACE 1
MSGBDPAT STM   R15,R0,DB
         PRTDATA '*** PATTERN DD missing or not usable ***'     GP09236
         B     PGMEXIT8      BUT USE NORMAL TERMINATION
         SPACE 1
MSGBDAL1 STM   R15,R0,DB
         PRTDATA '*** SYSUT1 allocation failed',(PRMDSNAM,DEB,PAD),(PRM*
               VLSER,6,DEB,PADL),'; RC=',(DB,4,I,DEB,PADR),' reason=',(*
               DB+4,4,HEX,PADR),'***'
         B     PGMEXIT8
         SPACE 1
MSGBDALL STM   R15,R0,DB
         PRTDATA '*** SYSUT2 allocation failed',(PRMDSNAM,DEB,PAD),(PRM*
               VLSER,6,DEB,PADL),'; RC=',(DB,4,I,DEB,PADR),' reason=',(*
               DB+4,4,HEX,PADR),'***'
PGMEXIT8 OICC  8             SET EROR
         B     PGMEXIT       BUT USE NORMAL TERMINATION
         SPACE 2
*---------------------------------------------------------------------*
*   Subroutine to handle key extraction                               *
*                                                                     *
*   Returns 0(R14) on bad key; 4(R14) when done                       *
*---------------------------------------------------------------------*
         PUSH  USING
KEYLOOK  SUBHEAD R2,R14      DYNAMIC SUBROUTINE
*   REUSE R6 AND R7 FOR KEY SCANNING
         USING RCVDSECT,R6   DECLARE IT
         LR    R7,R8
         CLC   =C'INMR02',RCVNAME   FILE HEADER?
         BNE   KEYNCTL       NO
         LA    R6,4(,R6)     SKIP FILE NUMBER
         SH    R7,=H'4'      ADJUST REMAINING LENGTH
KEYNCTL  LA    R6,RCVKEY     POINT TO FIRST KEY
         SH    R7,=AL2(RCVKEY-RCVDSECT)
         BNP   KEYLOOX       EMPTY (6?)
         USING RCVKEY,R6
KEYNEXT  ICM   R2,3,RCVKEY  LOAD KEY
         LM    R3,R5,KDEFTAB   LOOK AT DEFINITIONS
         USING KDFDSECT,R3
         TM    PROFLAGS,FGDS1     HAVE PRODUCTION FILE DATA?
         BZ    KEYLOOP            NO; USE SHORT TABLE
         LA    R3,KDEFTWO         START WITH UTILITY TABLE
KEYLOOP  CLM   R2,3,KDFKEY        MATCHING KEY ?
         BE    KEYFIND      YES
         BXLE  R3,R4,KEYLOOP      LOOK AGAIN
         PRTDATA '*** Unknown key',(RCVKEY,HEX,PAD),'***'
         OICC  4             SET ERROR
         SUBRET ,            VECTORED RETURN +0
         SPACE 1
KEYFIND  LH    R8,RCVKLEN
         LH    R5,RCVKNUM    REPETITIONS?
         LTR   R5,R5         ANY AT ALL?
         BP    KEYREPT       YES
         PRTDATA C7,KDFNAM,(RCVKEY,HEX,PAD),(RCVKNUM,HEX)
         SH    R6,=H'2'      NO LENGTH FIELD
         LA    R7,2(,R7)
         SR    R8,R8
         B     KEYBUMP
         SPACE 1
KEYREPT  TM    KDFMSK,KFGCHAR          CARACTER DATA ?
         BNZ   KEYCHAR       YES; DIFFERENT O/P FORMAT
      PRTDATA C7,KDFNAM,(RCVKEY,HEX,PAD),(RCVKNUM,HEX),(RCVKLEN,HEX,PAD*
               ),(RCVKDATA,(R8),HEX)
         B     KEYCOMM
KEYCHAR  PRTDATA C7,KDFNAM,(RCVKEY,HEX,PAD),(RCVKNUM,HEX),(RCVKLEN,HEX,*
               PAD),(RCVKDATA,(R8))
*NEXT*   B     KEYCOMM
KEYCOMM  SR    R4,R4
         ICM   R4,1,KDFSIZ   DESTINATION LENGTH
         BNP   KEYBUMP       SKIP EMPTY DESTINATION
         LA    R14,DB+8
         SR    R14,R8        LESS DATA LENGTH
         MVC   FUNLA+2(2),KDFSET  GET DESTINATION FIELD
FUNLA    LA    R2,*-*        DESTINATION
KEYPLOOP LA    R15,RCVKDATA
         TM    KDFMSK,KDEFLEFT    LEFT JUSTIFY ?
         BNZ   KEYPLEFT
         XC    DB,DB
         EX    R8,EXMVCDB2   MOVE DATA TO TEMP
         LA    R14,DB+8
         SR    R14,R4        LESS DATA LENGTH
         BCTR  R4,0
         EX    R4,EXMVCDB
         B     KEYPBUMP
KEYPLEFT LR    R4,R8         COPY LENGTH
         BCTR  R4,0          ADJUST FOR EXECUTE
         EX    R4,EXMVCDBL   MOVE LEFT JUSTIFIED
KEYPBUMP SH    R5,=H'1'      HOW MANY FIELDS?
         BNP   KEYBUMP       ONE, OR DONE
         LA    R8,2(,R8)     NEXT ENTRY
         AR    R6,R8
         SR    R7,R8
         LH    R8,RCVKLEN    LENGTH OF NEXT FIELD
         LA    R2,1(R4,R2)   POINT TO NEXT OUTPUT
         STM   R14,R1,DB     SAVE OVER PRT
         TM    KDFMSK,KFGCHAR    CHARACTER DATA ?
         BNZ   KEYPCHAR      YES; DIFFERENT O/P FORMAT
     PRTDATA   C17,(RCVKLEN,HEX),(RCVKDATA,(R8),HEX,PAD)
         B     KEYPCOMM
KEYPCHAR PRTDATA C17,(RCVKLEN,HEX),(RCVKDATA,(R8),PAD)
KEYPCOMM LM    R14,R1,DB     RESTORE
         TM    KDFMSK,KDEFDSN     IS THIS A DSN ?
         BZ    KEYPLOOP      NO; ADJOINING MOVES
         MVI   0(R2),C'.'    MAKE INDEX POINT
         LA    R2,1(,R2)
         B     KEYPLOOP
KEYBUMP  LA    R8,RCVKDATA-RCVKEY(,R8) ENTRY LENGTH
         AR    R6,R8
         SR    R7,R8
         BP    KEYNEXT
KEYLOOX  SLR   R15,R15
         SUBRET VECT=4       RETURN TO CALLER; RESTORE STACK
EXMVCDB2 MVC   0(0,R14),0(R15)
EXMVCDB  MVC   0(0,R2),0(R14)
EXMVCDBL MVC   0(0,R2),0(R15)
C7       DC    0CL7' '
C17      DC    CL24' '
         POP   USING
         LTORG ,
         SPACE 1
QMAJ     DC    CL8'SYSDSN'   ENQ
SYSTERM  PRTWORK SYSTERM,TITLE=3
         SPACE 1
DCBOUT1  OPEN  (SYSOUT,OUTPUT),MF=L
SYSOUT   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM,EXLST=OUTXLIST
         SPACE 1
DCBOXMIT OPEN  (XMITIN,INPUT),MF=L
XMITIN   DCB   DDNAME=XMITIN,DSORG=PS,MACRF=R,EODAD=EODAD,             *
               EXLST=INEXLIST,RECFM=U,BLKSIZE=32760
         SPACE 1
OUTXLIST DC    0A(0),X'85',AL3(ODSNMERG)   1/2
INEXLIST DC    0A(0),X'87',AL3(MYJFCB-MYJFCB)     2/2           GP09236
NULLPARM DC    0A(0),X'80',AL3(*+3),AL2(0)
UTILPARM DC    0A(0),X'80',AL3(*+3),AL2(5),C'DEB=4'
         SPACE 1
STATUS   FDOPT NL,CC=C'0'
         FD    'Return code',NL
         FD    RETCODE,I,PAD,DEB
         FD    NUMBLK,I,NL,RADJ,PADR,LEN=10
         FD    'blocks read'
         FD    NUMSEG,I,NL,RADJ,PADR,LEN=10
         FD    'segments read'
         FD    NUMCTL,I,NL,RADJ,PADR,LEN=10
         FD    'control segments read'
         FD    NUMREC,I,NL,RADJ,PADR,LEN=10
         FD    'data records written'
         FD    *END
         SPACE 1
MSGBDUTL FDOPT NL,CC=C'0'
         FD    '***'
         FD    OUTUTIL,DEB,PAD
         FD    'failed; RC='
         FD    RETCODE,I,DEB
         FD    '('
         FD    RETCODE,HEX
         FD    ')',PADR
*IEBCOPY FD    ' reason='
*IEBCOPY FD    RSNCODE,HEX,DEB,PADR
MSGBDUTT FD    '***'
         FDOPT NL
         FD    *END
         SPACE 1
*---------------------------------------------------------------------*
*   The KDEF table defines data keys, and links them to (optional)    *
*     variables data are to be extracted two. TRANSMIT generates the  *
*     same keys for both source/destination data set, and the temp.   *
*     utility data set, so we use the first table for the secon ds.   *
*---------------------------------------------------------------------*
KDEFTAB  PARKEYBX KDEFDEF
KDEFTWO  KDEF  0002,DSname,CL+KDEFDSN,V=WRKDSN    INTERMEDIATE DATA SET
         KDEF  000C,DirBlk,X,V=WRKDIRB      (NEVER HAPPEN?)
         KDEF  0030,BlkSze,X,V=WRKBLKSZ
         KDEF  003C,DSOrg,X,V=WRKDSORG
         KDEF  0042,LRecL,X,V=WRKLRECL
         KDEF  0049,RecFm,XL,V=WRKRECFM
         KDEF  1028,Util,CL,V=WRKUTIL
         KDEF  102C,DSSize,X,V=WRKDSSIZ
         KDEF  8012,DSType,X
KDEFDEF  KDEF  0002,DSname,CL+KDEFDSN,V=OUTDSN
KDEFDEF2 KDEF  000C,DirBlk,X,V=OUTDIRB
         KDEF  0030,BlkSze,X,V=OUTBLKSZ
         KDEF  003C,DSOrg,X,V=OUTDSORG
         KDEF  0042,LRecL,X,V=OUTLRECL
         KDEF  0049,RecFm,XL,V=OUTRECFM
         KDEF  1001,ToNode,CL
         KDEF  1002,ToUId,CL
         KDEF  1011,FrNode,CL
         KDEF  1012,FrUId,CL
         KDEF  1024,DaTime,CL
         KDEF  1026,AckReq,X
         KDEF  1028,Util,CL,V=OUTUTIL
         KDEF  102C,DSSize,X,V=OUTDSSIZ
         KDEF  102F,NumDS,X,V=CNTFILE
KDEFDEFN KDEF  8012,DSType,X
         EJECT ,
         SPACE 1
*---------------------------------------------------------------------*
*   BSAM DCB OPEN EXIT                                                *
*   SUPPLIES DEFAULT RECFM, LRECL, AND BLOCKSI IF NOT SPECIFIED BY    *
*   USER ON JCL                                                       *
*---------------------------------------------------------------------*
         PUSH  USING
         DROP  ,
         USING ODSNMERG,R15
         USING IHADCB,R1
ODSNMERG N     R1,=X'00FFFFFF'    KILL OPEN BITS (AM31 ???)
         SR    R2,R2              FOR DIVIDE
         SR    R3,R3
         ICM   R3,3,DCBBLKSI USER'S JCL BLOCK SIZE
         SR    R4,R4
         ICM   R4,3,DCBLRECL GET USER'S RECORD LENGTH
         TM    DCBRECFM,X'C0'     RECFM=U?
         BO    ODSNURCF      YES; JUST CHECK BLOCK SIZE
         BM    ODSNMERV      F OR V (F WILL FAIL)
         TM    DCBRECFM,X'20'     RECFM=D ?
         BNZ   ODSNVRCF      YES; TREAT AS V
         MVC   DCBRECFM,OUTRECFM  SET FROM SOURCE
         TM    DCBRECFM,X'C0'     RECFM=U?
         BO    ODSNURCF      YES; JUST CHECK BLOCK SIZE
ODSNMERV TM    DCBRECFM,X'80'     IS IT F?
         BZ    ODSNVRCF           NO; V OR D
*---------------------------------------------------------------------*
*   RECFM=F   complete LRECL if 0, complete BLKSI w/multiple of LRECL *
*---------------------------------------------------------------------*
ODSNFRCF LTR   R4,R4         HAVE RECORD LENGTH ?
         BNZ   ODSNFRCL        YES
         LH    R4,OUTLRECL   USE SOURCE SIZE
ODSNFRCL LTR   R3,R3         HAVE BLOCK SIZE ?
         BNZ   ODSNMERX      YES; EXIT
         L     R3,DEVDFLT    USE DEVICE DEFAULT                 GP09236
         CR    R3,R4         LARGER THAN RECORD?
         BH    *+8           YES
         L     R3,DEVMAX     ELSE USE DEVICE MAX                GP09236
         DR    R2,R4         DIVIDE BY LRECL
         MR    R2,R4         AND MAKE MULTIPLE OF RECORD LENGTH
         B     ODSNMERX
         SPACE 1
*---------------------------------------------------------------------*
*   RECFM=V  complete LRECL, set BLKSI to user's, default, or devmax  *
*---------------------------------------------------------------------*
ODSNVRCF LTR   R4,R4         HAVE RECORD LENGTH ?
         BP    ODSNCRCL        YES
         LH    R4,OUTLRECL   USE SOURCE SIZE
ODSNCRCL LTR   R3,R3         HAVE A BLOCK SIZE ?
         BP    ODSNMERX      YES; GET OUT
         L     R3,DEVDFLT    GET DEVICE DEFAULT                 GP09236
         LA    R2,4(,R4)     GET MINIMUM BLOCK
         CR    R3,R4         WILL IT FIT ?
         BNL   ODSNMERX      YES
         L     R3,DEVMAX     GET DEVICE MAX                     GP09236
         CR    R3,R4         WILL IT FIT NOW?
         BNL   ODSNMERX      YES
         OI    DCBRECFM,DCBRECSB  SET SPANNING ON
         B     ODSNMERX
         SPACE 1
*---------------------------------------------------------------------*
*   RECFM=U  set BLKSI to user's, LRECL, default, or devmax           *
*---------------------------------------------------------------------*
ODSNURCF LTR   R3,R3         HAVE BLOCK SIZE ?
         BNZ   ODSNMERX      YES; EXIT
         LTR   R3,R4         IS THERE A USER RECORD LENGTH?
         BNZ   ODSNMERX
         LH    R3,OUTBLKSZ   USE SOURCE SIZE
*NEXT*   B     ODSNMERX
         SPACE 1
ODSNMERX STH   R3,DCBBLKSI
         STH   R4,DCBLRECL        UPDATE POSSIBLY MODIFIED VALUES
         C     R3,DEVMAX     WILL IT FIT ?                      GP09236
         BNHR  R14           YES
         OI    OCLFLAG,FG2BIG
         BR    R14           RETURN TO OPEN
         POP   USING
         SPACE 1
         LTORG ,
DEVDFLT  DC    F'0'          PREFERRED BLOCK SIZE FOR DEVICE    GP09236
DEVMAX   DC    F'0'          MAXIMUM BLOCK FOR DEVICE           GP09236
OCLFLAG  DC    X'00'
FG2BIG   EQU   X'80'
         SPACE 1
*   DATA FOR THE SOURCE/DESTINATION FILE
OUTDSN   DS    CL44          SOURCE DSN
OUTDSSIZ DS    F             DATA SET SIZE
OUTDIRB  DS    F             SPACE - NUMER OF DIRECTORY BLOCKS
OUTUTIL  DS    CL8           IEBCOPY/IEBGENER/processor name
OUTDSORG DS    XL2           DATA SET ORGANIZATION
OUTBLKSZ DS    H             BLOCK SIZE
OUTLRECL DS    H             RECORD LENGTH
OUTRECFM DS    X             RECORD FORMAT
         SPACE 1
*   DATA FOR THE SOURCE/DESTINATION FILE
WRKDSN   DS    CL44          SOURCE DSN
WRKDSSIZ DS    F             DATA SET SIZE
WRKDIRB  DS    F             SPACE - NUMER OF DIRECTORY BLOCKS
WRKUTIL  DS    CL8           IEBCOPY/IEBGENER/processor name
WRKDSORG DS    XL2           DATA SET ORGANIZATION
WRKBLKSZ DS    H             BLOCK SIZE
WRKLRECL DS    H             RECORD LENGTH
WRKRECFM DS    X             RECORD FORMAT
         SPACE 1
RCVDSECT DSECT ,
RCVLEN   DS    X             LENGTH OF SEGMENT
RCVTYPE  DS    X             TYPE OF SEGMENT
RCVTBEG  EQU   X'80'           BEGINNING OF RECORD IN THIS SEGMENT
RCVTEND  EQU   X'40'           END OF RECORD IN THIS SEGMENT
RCVTCNTL EQU   X'20'           CONTROL DATA
RCVNAME  DS    CL6           INMRnn  01-FileHead  02-DSdata  03-DSinfo
RCVKEY   DS    XL2           CONTROL ENTRY KEY
RCVKNUM  DS    XL2           NUMBER OF ENTRIES
RCVKLEN  DS    XL2           LENGTH OF THIS ENTRY
RCVKDATA DS    0X            DATA FOR ENTRY
         SPACE 1
KDFDSECT DSECT ,
KDFKEY   DS    XL2           KEY ID
KDFNAM   DS    CL6           KEY NAME
KDFMSK   DS    X             TYPE/#LEN FIELDS
KFGCHAR  EQU   X'01'           CHARACTER FIELD
KDFSET   DS    SL2           OUTPUT DATA FIELD
KDFSIZ   DS    X             OUTPUT FIELD SIZE
         SPACE 1
SAVE     DSECT ,
LOCSAVE  DS    18A           SUBROUTINE SAVE STACK
LOCSAVE1 DS    18A           SUBROUTINE SAVE STACK
DYNWORK  DS    0D            COMMON ADDRESSING
DB       DS    2D
DB2      DS    D
ZEROES   DS    D             CONSTANT
BLANKS   DC    CL64' '       CONSTANT BLANKS                    GP09236
         SERVDEFS ,          EXPAND SERVICE ADDRESSES
NUMBLK   DS    F             NUMBER OF BLOCKS READ
NUMSEG   DS    F             NUMBER OF DATA SEGMENTS
NUMCTL   DS    F             NUMBER OF CNTL SEGMENTS
NUMREC   DS    F             NUMBER OF DATA RECORDS WRITTEN
         SPACE 1
@OUTDCB  DS    A             ADDRESS OF REAL OUTPUT, OR IEBCOPY TEMP
@OUTRDW  DS    A             RDW ADDRESS
@OUTBUFF DS    A             ADDRESS OF OUTPUT BUFFER
         SPACE 1
*   DATA EXTRACTED OR DERIVED FROM KEYS
CNTFILE  DS    F             NUMBER OF FILES INCLUDED
CNTBLOCK DS    F             SPACE - NUMBER OF BLOCKS
SIZBLOCK DS    F             SPACE - SIZE OF BLOCKS
OUTSER   DS    CL6           OUTPUT VOLUME
         SPACE 1
OPTFLAGS DS    X             PROCESSING FLAGS
FGBUG    EQU   X'80'           DEBUG MODE
FGTEST   EQU   X'40'           TEST MODE - NO ALLOCATION, NO WRITES
FGALLOC  EQU   X'20'           OUTPUT & TEMP DATA SETS ALLOCATED
FGUTIL   EQU   X'10'           AT EOF, INVOKE UTILITY
FGMERGE  EQU   X'08'           MERGE W/EXISTNG PDS
FGREP    EQU   X'04'           REPLACE PS OR PO
FGDEL    EQU   X'02'           DELETE VIA CAT AND ON VOL
FGDFLT   EQU   FGMERGE+FGREP+FGDEL     RESET
FGONE    EQU   X'01'           OUTPUT RECORD WRITTEN
         SPACE 1
PROFLAGS DS    X             PROCESSING FLAGS
FGDS1    EQU   X'80'           PROCESSED DATA SET HEADER
FGPDS    EQU   X'40'           OUTPUT IS PARTITIONED
FGPDS13  EQU   X'20'           SPECIAL CODE FOR zOS 13 OUTPUT   GP12152
FGIBM    EQU   X'10'           USE IEBCOPY                      GP12152
FGNOTV   EQU   X'04'           NO BDW OR RDWS IN DATA           GP11057
FGDAT    EQU   X'02'           DATA RECORD FOUND
FGEOF    EQU   X'01'           INPUT END-FILE; PROCESS RESIDUAL DATA
         SPACE 1
ALLOPARM MAPSBALL PFX=PRM,DSECT=NO
ALLOPLEN EQU   *-ALLOPARM,,C'C'
         SPACE 1
         ORG   ALLOPARM
         MAPPARSE DSECT=NO
         ORG   ,
         SPACE 1
MYJFCB   DS    0D
         IEFJFCBN ,
         SPACE 1
LOCWORK  DS    XL184
         SPACE 1
INBUFF   DS    128XL256      BIG BUFFER
         SPACE 1
OUTRDW   DS    H,H           RDW FOR IEBCOPY FILE
OUTBUFF  DS    128XL256      BIG BUFFER
SAVEEND  EQU   *
         SPACE 1
         PRINT NOGEN
         MAPPARST ,
         DCBD  DSORG=PS,DEVD=DA
MYTIOT   DSECT ,
         IEFTIOT1 ,
MYUCB    DSECT ,
         IEFUCBOB ,
         IKJTCB ,
         IHAPSA ,
         END   ,
