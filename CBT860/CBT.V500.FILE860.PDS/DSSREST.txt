DSSREST  TITLE 'D S S R E S T  ***  RESTORE ADRDSSU DUMP TAPES ON MVS'
***********************************************************************
*                                                                     *
*        COPYRIGHT 2009       Charlie Brint                           *
*                             1269 Rideout Cres.                      *
*                             Ottawa, Ont. K2C 2X9                    *
*                             Charlie@Brint.ca                        *
*        ALL RIGHTS RESERVED                                          *
*                                                                     *
*   Not-for-profit use permitted, and distribution rights granted to  *
*   Hercules and CBT projects.                                        *
*                                                                     *
***********************************************************************
* *
* * PROGRAM: DSSREST
* *
* * PURPOSE: Restore a dataset from a DFDSS (ADRDSSU) logical dump
* *
* *
* * LIMITATIONS: -Doesn't handle VSAM or extended format datasets.
* *              -Doesn't write R0 on tracks (may not matter)
* *              -Input may be on tape or DASD.  Tape input may have a
* *               blksize of up to 65520 bytes.
* *               ADRDSSU dumps are RECFM=U but this program will also
* *               accept RECFM=F(B) or RECFM=V(B)(S) as input.
* *
* *               Note: file tapeconv.jcl in the Hercules distribution
* *               can be used to convert ADRDSSU dumps into Hercules
* *               AWS emulated tape format; once converted, these dumps
* *               can be binary downloaded to the machine you are
* *               running Hercules on and used directly as input
* *               to DSSREST.  For example, to move datasets to a
* *               Hercules/MVS38J system:
* *                 - on big IRON, run ADRDSSU and create the dump
* *                 - run the dump through tapeconv.jcl and create
* *                   the AWS image of the dump
* *                 - binary ftp the AWS image to your PC
* *                 - run your DSSREST job on MVS38J under Hercules
* *                 - on the Hercules console issue the command:
* *                   DEVINIT 480 C:\AWSIMAGE.bin
* *                   to mount the "tape" for your DSSREST run.
* *                   (note: device # 480 is just an example above)
* *
* *              -Output should be on same disk device type as
* *               it resided on when DFDSS dumped it.  You may be
* *               able to restore to a device with a larger track
* *               size but definitely not to one with a smaller
* *               track size.
* *
* * USES:    - enable recovery of data from existing logical dumps on
* *            MVS 3.8J (i.e. when licensed ADRDSSU isn't available)
* *          - potentially easier to import data into MVS 3.8J by
* *            using power of ADRDSSU on z/OS to create a single
* *            package of data to transport over to MVS 3.8J
* *          - can also be run on z/OS or OS/390 as a tool to look at
* *            what is contained in a dump; potentially provides more
* *            info than ADRDSSU provides in this regard (for non-VSAM)
* *            and checks the dump for logical consistency.
* *
* * SAMPLE JCL:
* *
* *            Here is a sample of JCL to run the utility on the MVS38J
* *            Turnkey system but please read the documentation first:
* *
* *     //DSSREST JOB
* *     //DOIT   EXEC PGM=DSSREST,REGION=4096K,PARM='USERID.JCL.CNTL'
* *     //STEPLIB  DD DSN=HERC01.DSSREST.LOAD,DISP=SHR
* *     //SYSPRINT DD SYSOUT=*
* *     //REPORT   DD SYSOUT=*
* *     //SYSUT1   DD UNIT=480,DISP=OLD,LABEL=(1,NL),VOL=SER=123456
* *     //SYSUT2   DD DSN=HERC01.RESTORE.CNTL,DISP=(,CATLG),UNIT=3390,
* *     //            SPACE=(CYL,(5,5,1)),
* *     //            DCB=(DSORG=PO,LRECL=80,BLKSIZE=6160,RECFM=FB)
* *     //
* *
* * PROCESSING:
* *
* *          Start off by closely checking the dump header recs
* *          to make sure we are really dealing with a valid DFDSS
* *          logical dump.  From there we build a table of DSNs
* *          found in the DSNlist segments; this table will accumulate
* *          any pertinent information about the files in the dump.
* *
* *          Next we start getting the Dataset Header segment and
* *          Volume Definition segment; these describe the dumped
* *          dataset which follows in sufficient detail for us to
* *          decide if we can indeed restore the dataset.  Info from
* *          these segments is also retained in the DSN table.
* *
* *          Next are the track image records.  If we are actually
* *          restoring a file we have to open the SYSUT2 DD statement
* *          and construct CCW chains for each track to be restored.
* *          When we encounter the dataset trailer segment we
* *          do the final updates to SYSUT2 DCB and close it.
* *
* *          One of the design points of this program is to check
* *          as much as we can in the dump regardless of whether or not
* *          we intend to restore the dataset.  For example, each
* *          track in the dump is checked for consistency regardless
* *          of whether or not we intend to restore the dataset.
* *
* *          One of the last orders of business is to print out the DSN
* *          table to give a summary of what was found in the dump.
* *          This report is written out to the REPORT DD statement
* *          if one exists.  Note: the DSN table is printed in the
* *          sequence the names appeared in the DSName/Catlg List
* *          section of the dump headers.  It is possible that the
* *          summary may indicate datasets that were listed in the
* *          DSNlist segments but not found in the dump; the most
* *          common cause for this is datasets which were selected
* *          for dumping but failed serialisation when the actual
* *          dump of the dataset was attempted.
* *
* *          The final task is to generate the sample SYSUT2 DD
* *          statements on the JCLOUT DD statement if it exists.
* *          Note that these statements will be generated in exactly
* *          the same sequence as the files are found in the dump
* *          to guarantee they match up correctly when used as
* *          skeleton JCL for a multiple (PARM='*') restore.
* *
* * INPUTS:  SYSUT1 - Input file, it may be on tape or DASD
* *
* *          EXEC PARM - If no parm is given, the pgm just runs thru
* *          the dump and prints a bunch of information about the
* *          files contained in the dump.
* *
* * CONTROLLING DSSREST:
* *
* *          If a parm is given, it may be the DSN of one of the
* *          datasets contained in the dump.  This dataset is then
* *          restored to the DDNAME SYSUT2.  SYSUT2 should be
* *          coded with the desired DSN and have correct information
* *          provided for UNIT, SPACE, and DCB parameters.  E.g.
* *
* *          //SYSUT2 DD DSN=MY.RESTORED.CNTL,DISP=(,CATLG),
* *          //          UNIT=3390,SPACE=(CYL,(3,1,1)),
* *          //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160,DSORG=PO)
* *
* *
* *          Note: In this example, the number of directory blocks
* *                specified in the SPACE is irrelevant, it just has
* *                to be non-zero for a PDS.
* *
* *          Another feature is the ability to have the word DEBUG
* *          as the first (or only) item in the parm.  This will cause
* *          the program to issue all kinds of rather cryptic info
* *          regarding its processing.  If you really like lots
* *          of messages, use DEBU2 instead of DEBUG and you get
* *          all the DEBUG messages plus messages about the
* *          track structure of each track in the dump.  DEBUG or DEBU2
* *          must be the first parm.  A comma after DEBUG/DEBU2 is
* *          optional if additional parms are specified however if the
* *          DSN starts with DEBUG/DEBU2, precede the DSN with a comma.
* *          A leading comma is allowed (allows symbols in PARM field)
* *
* *          (After optional debug, VOL (only) or VOL, requests that
* *          generated SYSUT2 JCL include the sender's VOL=SER  GP09329
* *
* *          The parm may be coded as "DYNALLOC" or "DYNALLOC,prefix".
* *          This will instruct the pgm to restore all datasets found
* *          in the dump and use dynamic allocation to create the
* *          restored datasets.  The optional "prefix" is used to
* *          alter the DSNAMES of the dumped datasets by replacing the
* *          high level qualifier of the dumped dataset with the
* *          "prefix" you specify.  For example, if you specify the
* *          PARM='DYNALLOC,USERABC' and the dump contains the dataset
* *          'SYS1.PROCLIB' then the restored dataset will have the
* *          name 'USERABC.PROCLIB'.  When you use DYNALLOC, you can
* *          not use the asterisk (see below) or a specific DSN.
* *          The prefix can be a maximum of 8 characters long.
* *
* *          One other feature is that the DSN may be specified as
* *          as '*'.  This indicates the pgm is to try to restore
* *          all (non-VSAM,non-PDSE/HFS) datasets it encounters. To use
* *          this feature, code multiple SYSUT2 DD statements; one per
* *          dataset that will be restored.  You MUST code
* *
* *             FREE=CLOSE
* *
* *          on each DD statement; this will allow the program to
* *          tumble through the DDs in the sequence in which they were
* *          coded.  To help make this feature much more friendly,
* *          the JCLOUT DD statement can be used to get skeleton JCL
* *          that will contain SYSUT2 DD statements (in the correct
* *          order) that can subsequently tailored and used to do
* *          a "*" restore-all run.  Any file you don't want to restore
* *          can just have its corresponding SYSUT2 DD statement
* *          dummied out.  If you need to alter allocation info, change
* *          dataset names or do a bunch of selection about which
* *          datasets to restore this is probably the best method
* *          to use.  The following is an example of the sort
* *          of JCL that will be generated by the program:
* *
* *     //DSSREST JOB  TIME=1440
* *     //RESTORE EXEC PGM=DSSREST,REGION=8000K,TIME=1440,PARM='*'
* *     //STEPLIB  DD  DSN=HERC01.DSSREST.LOAD,DISP=SHR
* *     //SYSPRINT DD  SYSOUT=*
* *     //REPORT   DD  SYSOUT=*
* *     //SYSUT1   DD  UNIT=480,DISP=OLD,LABEL=(1,NL),VOL=SER=000001
* *     //*
* *     //SYSUT2 DD DSN=SOFTESA.DSSREST.LOAD,               /*1*/
* *     //          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PO,
* *     //          RECFM=U,LRECL=0,BLKSIZE=7294),
* *     //          UNIT=3390,SPACE=(TRK,(1,1,1)) VOL=SER=SMP667
* *     //SYSUT2 DD DSN=SOFTESA.DSSREST.XMI,                /*2*/
* *     //          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PS,
* *     //          RECFM=FB,LRECL=80,BLKSIZE=3120),
* *     //          UNIT=3390,SPACE=(TRK,(2,1)) VOL=SER=SMP360
* *     //SYSUT2 DD DSN=SOFTESA.IDTF.LOG,                   /*3*/
* *     //          DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORG=PS,
* *     //          RECFM=VB,LRECL=255,BLKSIZE=3120),
* *     //          UNIT=3390,SPACE=(TRK,(1,1)) VOL=SER=SMP172
* *
* *
* *          Note: VOL=SER is included on the SYSUT2 DD statements just
* *              to let you know where the dataset originally came from
* *
* *          No DCB info is required on the JCLOUT DD statement, it
* *          assumes the output will be RECFM=FB,LRECL=80.  If output
* *          is directed to an existing dataset, the BLKSIZE from
* *          that dataset will be retained, otherwise the pgm forces
* *          a blksize.
* *
* * TYPICAL USAGE: To restore several datasets from a DFDSS backup,
* *          you would first run DSSREST against the backup tape
* *          with no PARM specified and supplying both the REPORT
* *          and JCLOUT DD statements; direct JCLOUT to a dataset
* *          that you can subsequently edit to change dataset names
* *          for the restored datasets (or whatever else you wish
* *          to tailor).  Any datasets you don't wish to restore
* *          can have their corresponding SYSUT2 DD statement dummied
* *          out.  Then submit this tailored JCL to do the restore.
* *
* * OUTPUTS: SYSPRINT Message file, no DCB attributes required.
* *
* *          SYSUT2 - Receives the restored dataset if the EXEC PARM
* *                   contained a dataset name (or *).  In the case
* *                   of PARM='*', there will likely be multiple
* *                   SYSUT2 statements (you will then want to use the
* *                   JCLOUT feature to have these statements generated
* *                   in the correct order for a restore run, remember
* *                   that any file you wish to skip the restore for
* *                   can just have its SYSUT2 DD statement dummied
* *                   out).
* *
* *                   SYSUT2 should contain all DCB and allocation
* *                   information required for the file to be created.
* *                   When restoring a PDS, just set the number of
* *                   directory blocks to 1 to indicate a PDS (the pgm
* *                   will restore all the directory blocks that were
* *                   in the original).
* *
* *          REPORT - Optional file to receive summary report of
* *                   what was in the DFDSS dump.  No DCB parms
* *                   are required (note: a BLKSIZE value is forced).
* *                   Here is an example of the output sent to REPORT
* *                   (the lines have been split since the report has
* *                   a line length of 133 and it won't fit here)
* *
* *   DSSREST - Summary of dump file contents
* *   ---------------------------------------
* *
* *   DFDSS dump header indicated there are 3 datasets in the dump
* *
* *   #ofTrks DS                    Key  RKP Opt HiUsed Track  Creation
* *   in dump Org Rcfm Blksz  Lrecl Len  RKP CD  TTR    Balnce Date
* *   ------- --- ---- -----  ----- --- ---- --- ------ ------ --------
* *
* *   SOFTESA.DSSREST.LOAD
* *         1 PO  U    7,294      0   0     0 00 000017 14,790 2005.361
* *   SOFTESA.DSSREST.XMI
* *         1 PS  FB   3,120     80   0     0 00 000009 26,452 2005.361
* *   SOFTESA.IDTF.LOG
* *         1 PS  VB   3,120    255   0     0 00 00000C 46,546 1989.109
* *
* *
* *
* *    Expiry  LastUsed #of        Device Primary   Secondary Restore
* *    Date    Date     Ext VolSer Type   Allocated Alloc.    Status
* *   -------- -------- --- ------ ------ --------- --------- -------
* *
* *
* *   ****.*** 2005.361   1 SMP667  3390       1Trk      4Blk
* *
* *   ****.*** 2005.361   1 SMP360  3390       2Trk      8Blk
* *
* *   ****.*** 2005.361   1 SMP172  3390       1Trk      1Trk
* *
* *
* *          JCLOUT - Optional file to receive skeleton JCL containing
* *                   model SYSUT2 DD statements that could be tailored
* *                   and used for a subsequent "*" restore-all run.
* *
* *
* * OUTSTANDING ISSUES:
* *
* *       - In the FMT1 DSCB there is a field DS1NOBDB (number of bytes
* *         used in last directory block) - there is nothing in place
* *         to ensure this value gets written in the DSCB of the
* *         restored dataset - don't know if it matters.
* *       - The code will attempt to restore an Indexed Sequential
* *         dataset but this hasn't been tested and there may be issues
* *         It is not expected to work because ISAM uses R0 data.
* *         Some cases of BDAM may also need R0 data.
* *
* * AUTHOR:  Charlie Brint (Charlie@Brint.ca), December 2005
* *
* *         Re-vamped in November 2009 by Gerhard Postpischil.
* *
* * CREDITS:
* *
* *       1) The #MSG and #MSGRTN code was adapted from the
* *          CCKDDUMP utility created by
* *
* *             Greg Smith
* *             gsmith@nc.rr.com
* *
* *          This utility is distributed by WWW.CBTTAPE.ORG on
* *          CBT file #541
* *
* *       2) A helpful professional who will remain unnamed (but you
* *          know who you are) who took the time to help me understand
* *          some of the anomalies/features of DFDSS dumps.
* *
* *  CHANGE HISTORY:
* *
* *       29Mar06 - Charlie Brint
* *               - Added note at DSS305 about possible error in
* *                 held segment processing
* *
* *       16May06 - Charlie Brint
* *               - Added ability to decompress track images
* *
* *       13Nov09 - Gerhard Postpischil
* *               - Added DASD support; added RECFM=FB|VBS      GP09317
* *                 JCL output re-organized                     GP09317
* *                 LABEL=SUL treated as SL (user label track   GP09317
* *                   not in DEB, would need authorization).    GP09317
* *                 #MSG macro and #MSGRTNE revised; freed a    GP09317
* *                   base register and shrank program size.    GP09317
* *                 Redid PARM processing; allow leading comma. GP09317
* *                 Joined macros and pgm for easier distributn GP09317
* *
* *       24Nov09 - Charlie Brint
* *               - Added copyright/re-distribution notice
* *               - Sundry clean-up to remove unused code and clean
* *                 up some of the comments/documentation.
* *               - suppressed some msgs to only show with DEBUG
* *               - Reverted VOL=SER in JCLOUT SYSUT2 DDs to just
* *                 being a comment indicating what the corresponding
* *                 volume was when the dataset was dumped.
* *
* *       25Nov09 - Gerhard Postpischil
* *               - Fixed stupid, fatal error in my SYSPRINT    GP09329
* *                   and REPORT processing with RECFM=Vnn      GP09329
* *               - DEBU2 also sets DEBUG for shorter tests     GP09329
* *
* *       08Jun10 - Gerhard Postpischil
* *               - Fixed stupid error handling RECFM other     GP10159
* *                   than U. Made R4 variable to reduce        GP10159
* *                   data movement (keep in SYSUT1 buffer)     GP10159
* *               - Corrected a few spelling errors.            GP10159
* *
* *       18Nov11 - Gerhard Postpischil
* *               - Added FREE option to SYSUT2 CLOSE macros;   GP11322
* *                   permits plain DD DUMMY (previously failed GP11322
* *                   to restore all data sets after DUMMY      GP11322
* *               - Corrected a spelling error.                 GP11322
* *
* *********************************************************************
*
         MACRO ,                                                GP09317
&NM      #MSG  &TEXT,&OP1,&OP2                                  GP09317
         GBLA  &MSG#ID                                          GP09317
         LCLC  &SECT,&VAR                                       GP09317
         LCLA  &I,&J,&N                                         GP09317
&N       SETA  N'&SYSLIST                                       GP09317
&MSG#ID  SETA  &MSG#ID+1     NEXT MESSAGE ID                    GP09317
&NM      LH    R1,=AL2(ZZ#&MSG#ID-MSG#SECT) OFFSET TO MSG       GP09317
         AIF   (N'&SYSLIST(1) EQ 1).CALL                        GP09317
         LA    R15,&SYSLIST(1,1)   MESSAGE                      GP09317
         MVC   4(&SYSLIST(1,2),R1),0(R15)                       GP09317
.CALL    L     R15,=A(MSG#RTN)    MESSAGE WRITER                GP09317
         BALR  R14,R15            CALL WRITER                   GP09317
&SECT    SETC  '&SYSECT'                                        GP09317
MSG#SECT CSECT ,             MESSAGE COLLECTOR                  GP09317
&I       SETA  1             ALLOWANCE FOR TEXT OPERAND         GP09317
         AIF   (N'&SYSLIST(1) EQ 1).CHAR                        GP09317
ZZ#&MSG#ID DC  Y(&TEXT(2)-1,&N-1)  MSG LEN / # OF INSERTS       GP09317
ZZT&MSG#ID DC  CL(&TEXT(2))' '                                  GP09317
         AGO   .LOOP                                            GP09317
.CHAR    ANOP  ,                                                GP09317
ZZ#&MSG#ID DC  Y(L'ZZT&MSG#ID-1,&N-1)  MSG LEN / # OF INSERTS   GP09317
ZZT&MSG#ID DC  C&TEXT                                           GP09317
.LOOP    AIF   (&I GE &N).DONE                                  GP09317
&I       SETA  &I+1                                             GP09317
         DC    SL2(&SYSLIST(&I))                                GP09317
         AGO   .LOOP                                            GP09317
.DONE    ANOP  ,                                                GP09317
&SECT    CSECT ,                                                GP09317
         MEND  ,                                                GP09317
         SPACE 1
         MACRO
         ADRTAPB
*
* * Skeleton version of an ADRTAPB MACRO
* *
* * This maps the data structures within a DFDSS (ADRDSSU) logical
* * dump dataset.
*
ADRTAPB  DSECT
*
* * Header Record
*
DTPSEQNO DS    F           Segment sequence number
DTPNOSEG DS    XL1         Number of segments per record
DTPSEGNO DS    XL1         Segment number of record
DTPSEGLN DS    XL2         Segment length including prefix
DTPPFXLN DS    XL1         Length of prefix (constant 16)
DTPDMPID DS    XL1         Type of dump
DTPLOGCL EQU   X'10'         Logical dump
DTPRCID1 DS    XL1         Record Identifier 1
DTPTHDR  EQU   X'80'         Tape Header (see DTHDR)
DTPDSNL  EQU   X'40'         DSName/Catalog Lst (see DTLDSN)
DTPDSHDR EQU   X'20'         Dataset Header (see DTDSHDR)
DTPVOLD  EQU   X'10'         Volume Definition (see DTMVOL)
DTPDATA  EQU   X'08'         Data Track (see  DTTTRK)
DTPDTRLR EQU   X'04'         Dataset Trailer (see DTRTLR)
DTPRCFL1 DS    XL1         Flag Byte
DTPDDISP EQU   X'80'         If on, 16 bytes of track data has been
*                            displaced from this segment to the end of
*                            the last segment for this track.  This was
*                            done so the ADRTAPB segment header could
*                            be inserted directly into the "read track"
*                            data buffer and then broken into data
*                            blocks in the dump.
* * Tape header record
*
         ORG   ADRTAPB
DTHTIMD  DS    CL8         Date & time of dump
DTHIND2  DS    XL1         Dataset type indicators
DTHGNVI  EQU   X'80'         no non-VSAM datasets
DTHGVI   EQU   X'40'         no VSAM datasets
DTHGT64K EQU   X'20'         more than 65535 datasets on volume
DTHLEN   DS    XL2         Header length
DTHVERNO DS    XL1         DSS Version number
DTHLVLNO DS    XL1         DSS modification number (level)
DTHBLKSZ DS    XL2         Maximum blksize
DTHNDS   DS    XL2         Number of datasets in list
DTHIND1  DS    XL1         Indicators
DTHFCMP  EQU   X'80'         file compressed
DTHUNLCD EQU   X'40'         unallocated space dumped
DTHSFER  EQU   X'20'         sphere option
*
* * Dataset Header record
*
         ORG   ADRTAPB
DTDLEN   DS    XL1         Length of dataset name
DTDCATLN DS    XL1         Length of catalog name
DTDDSORG DS    XL2         Dataset org (from FMT 1)
DTDOPTCD DS    XL1         Dataset option code (from FMT 1)
DTDNVOL  DS    XL1         Number of volumes for dataset
DTDIND   DS    XL1         Dataset indicator
DTDALIAS EQU   X'04'         User catalog alias
DTDSPER  EQU   X'02'         Sphere record follows
DTDSMS   EQU   X'01'         SMS Managed dataset
         DS    XL8         pswd
         DS    CL44        catlg name
DTDDSN   DS    CL44        dataset name
*DTDVOLCT DS    XL2         SMS volume count (from BCS)
**** Note: the above field doesn't appear to exist in dumps!!
DTDVCTD  DS    XL1         Volume count for non-vsam
         DS    XL1         VSAM index component vol cnt or zero
DTDIND2  DS    XL1
DTDAIXSP EQU   X'80'       AIX and part of a sphere
DTDCDF   EQU   X'40'       Common format dataset
DTDPDSE  EQU   X'20'       PDSE dataset
DTDNTALL EQU   X'10'       Dumped without ALLD or ALLX
DTDSAI   EQU   X'08'       DS additional information
DTDNOIDX EQU   X'04'       VSAM indexed DS dumped using VALIDATE
DTDPDSET EQU   X'02'       PDSE dumped as track images
DTDSDM   EQU   X'01'       Use system data mover
*
* * Volume Definition Record (1 per volume)
*
         ORG   ADRTAPB
DTMVOL   EQU   *
DTMVSERL DS    CL6         Volume serial number
DTMDEVTY DS    XL4         DEVTYPE (UCBTBYT4)
         DS    XL2
DTMTRKCP DS    XL4         Bytes per track
DTMLOGCY DS    XL2         Cylinders per volume
DTMTRKCY DS    XL2         Tracks per cylinder
         DS    XL2         max compress buffer in words
         DS    XL2         flags
DTM#VVRS DS    XL1         Number of VVRS/NVRS dumped
DTM#DSCB DS    XL1         Number of DSCBs dumped
DTM#EXT  DS    XL1         Number of extents dumped
DTMMODNO DS    XL1         Model number (looks like zero for logical)
DTMDSCB  EQU   *           Start of DSCB(s)
*
* * Data Track Record
*
         ORG   ADRTAPB
DTTTRK   EQU   *
DTTTRKLN DS    XL2         Length of data on track
DTTTRKID DS    XL1         Track indicators
DTTIOER  EQU   X'80'         I/O Error
DTTTROVF EQU   X'40'         Last rec on trk is overflow record
DTTTCMP  EQU   X'20'         Track compressed
DTTVFRST EQU   X'10'         First VVDS record
DTTINVT  EQU   X'08'         Invalid track format
DTTSTAT  EQU   X'04'         User statisical record
DTTCCHH  DS    XL4         CCHH of track
         DS    XL4         VSAM stuff
         DS    XL5         reserved
DTTR0DAT DS    XL8         Record 0 data
*
* * Dataset Trailer record
*
         ORG   ADRTAPB
DTRDLR   EQU   *
*
         MEND
         SPACE 1
         PUNCH ' ORDER DSSREST(P) '    EASIER DUMP READING      GP09317
         SPACE 1
DSSREST  START 0                                                GP09317
         PRINT NOGEN
R0       EQU   0                      scratch
R1       EQU   1                      scratch
R2       EQU   2                      scratch
R3       EQU   3                      scratch
R4       EQU   4                      GETDATA data buffer
*                                     Mapped by ADRTAPB macro
R5       EQU   5                      Dataset name table entry ptr
R6       EQU   6                      Track image buffer ptr
R7       EQU   7                      R7 - very seldom used
R8       EQU   8                      Internal linkage
R9       EQU   9                      First pgm base reg
R10      EQU   10                     Second
R11      EQU   11                     Third
R12      EQU   12                     Fourth
R13      EQU   13                     Savearea ptr
R14      EQU   14                     scratch
R15      EQU   15                     scratch
*
*SSREST  RMODE 24                     ** Ultimate target is
*SSREST  AMODE 24                     ** MVS 3.8J
         B     BEGIN-*(,R15)      SKIP ID                       GP09317
         DC    AL1(17),CL17'DSSREST &SYSDATE'    DUMP ID        GP09317
BEGIN    STM   14,12,12(13)           save caller's regs
         LA    R12,2048               adder                     GP09317
         LR    R9,R15                 get start address
         LA    R10,2048(R12,R9)       compute a second          GP09317
         LA    R11,2048(R12,R10)      compute a third           GP09317
         LA    R12,2048(R12,R11)      compute a fourth          GP09317
         USING DSSREST,R9,R10,R11,R12        and set up new base.
         ST    R13,SAVEAREA+4         save A(HSA)
         LR    R14,R13                and again
         LA    R13,SAVEAREA           point to my savearea
         ST    R13,8(0,R14)           and chain saveareas.
         L     R6,0(,R1)              r1-> exec parm            GP09317
         MVC   PARMLENG,0(R6)         save parm length          GP09317
*
* * set up SYSPRINT message file
*
         OPEN  (SYSPRINT,(OUTPUT))
         LA    R1,SYSPRINT
         USING IHADCB,R1
         TM    DCBOFLGS,DCBOFOPN      Did SYSPRINT open OK?
         BO    DSS001                 Yes, skip
         DROP  R1
BADPRINT WTO   'DSSREST - Unable to open SYSPRINT, pgm ending.',ROUTCDEX
               =11
         MVI   RETCODE,16             Set RC                    GP09317
         B     EXITX                  No SYSPRINT, end with bad RC
DSS001   DS    0H
         BAL   R8,FMTTIME             Get formatted date/time
         #MSG  'DSSREST - Version 1.3 (November 2009) %S17:17',TIMEFMT
         #MSG '-------------------------------------------------------'
         #MSG  ' '
         #MSG  'Copyright November 2009 by Charlie Brint, all rights reX
               served.'
         #MSG  '  Commercial use prohibited.  Not-for-profit use permitX
               ted.'
         #MSG  '  Comments/questions may be addressed to os_390@hotmailX
               .com'
         #MSG  ' '
*
* * check for and "consume" debug/debu2 option
*
         LH    R7,0(,R6)              Load PARM length          GP09317
         LTR   R7,R7                  Any PARM ?                GP09317
         BM    PARMBAD                No                        GP09317
         BZ    PARMSAVE               None                      GP09317
         LA    R5,5                   Set length of debug       GP09317
         CR    R7,R5                  Long enough for debug?    GP09317
         BL    DSS005                 No; check comma           GP09317
         OI    CONTROL,CDEBUG         Set debug mode on         GP09317
         CLC   =C'DEBUG',2(R6)        is it DEBUG?              GP09317
         BE    DSS004                 Yes; adjust               GP09317
         NI    CONTROL,255-CDEBUG     Reset debug mode          GP09317
         CLC   =C'DEBU2',2(R6)        is it DEBU2?
         BNE   DSS005                 nope, skip
         OI    CONTROL,CDEBU2+CDEBUG  Set level 2 debug mode    GP09329
DSS004   AR    R6,R5                  Adjust                    GP09317
         SR    R7,R5                  Residual length           GP09317
         BNP   PARMSAVE               No more                   GP09317
DSS005   LA    R5,1                   Could there be a comma?   GP09317
         CLI   2(R6),C','             Is there a comma?         GP09317
         BE    DSS004                 Yes; trim it              GP09317
         LA    R5,3                   Set length of VOL         GP09329
         CR    R7,R5                  Long enough?              GP09329
         BL    PARMSAVE               No                        GP09329
         SPACE 1
DSS005U  CLC   =C'VOL',2(R6)          Possible VOL parameter?   GP09329
         BNE   PARMSAVE               No                        GP09329
         CR    R7,R5                  Exactly VOL ?             GP09329
         BE    DSS005V                Yes; flag it              GP09329
         CLI   5(R6),C','             VOL, ?                    GP09329
         BNE   PARMSAVE               No; may be DSN?           GP09329
         B     DSS005                 Get rid of comma          GP09329
DSS005V  OI    PROFLAGS,PFVOL         Show user requested VOL   GP09329
         AR    R6,R5                  Adjust pointer            GP09329
         SR    R7,R5                  Adjust length             GP09329
PARMSAVE STH   R7,PARMLENG                length                GP09317
         TM    CONTROL,CDEBUG         Debugging?
         BNO   DSS005M                No, skip msgs
         L     R1,=AL4(4096*4-(#MSGRTNE-DSSREST))
         ST    R1,WORK
         #MSG  'Note: %D bytes of addressability remain in this programX
               .',WORK
         ST    R7,WORK                Set for display           GP09317
         MVC   DBLWRD,BLANKS          Don't show garbage        GP09317
         LTR   R15,R7                 Any PARM left ?           GP09317
         BNP   DSS005A                Skip erroneous text       GP09317
         CH    R15,=H'8'              Max field length          GP09317
         BNH   *+8                                              GP09317
         LA    R15,8                  Truncate                  GP09317
         BCTR  R15,0                  Exec length               GP09317
         EX    R15,EXMVCDBL           Move PARM fragment        GP09317
DSS005A  #MSG  'Exec parm length (after DEBUG)=%D, 1st 8 bytes of parm:X
                ''%S8:8''',WORK,DBLWRD                          GP09317
         #MSG  ' '
*
* * Check if a DSN was given in the parm field
*
DSS005M  LTR   R7,R7                  Possible DSN ?            GP09317
         BP    DSS006                 yes, skip
         #MSG  'No DSN given on EXEC parm, dump info will be printed buX
               t no file will be restored to SYSUT2'
         B     DSS009
DSS006   CH    R7,=H'44'              Reasonable ?              GP09317
         BNH   DSS007                 Yes
PARMBAD  #MSG  'DSN specified on EXEC parm is longer than 44 charactersX
               '
         B     EXITRC12
DSS007   LR    R1,R7                                            GP09317
         BCTR  R1,0                   minus one
         EX    R1,EXMVCDSN                                      GP09317
         CLI   DSN,C' '               DSN start with blank?
* note: we should really do a better job of editing DSN
         BNE   DSS0071                no, skip                  GP09317
         #MSG  'DSN specified on EXEC parm is blank/invalid'
         B     EXITRC12
DSS0071  DS    0H                                               GP09317
         OI    CONTROL,CREST          Set restore operation
         CLC   =C'* ',DSN             Is it an asterisk?        GP09317
         BE    DSS0079                yep, skip
         CLC   =C'DYNALLOC',DSN       is it a dynalloc request? GP09317
         BNE   DSS0072                No                        GP09317
         CLI   DSN+8,C','             dynalloc with prefix?     GP09317
         BE    DSS0073                yes, get it
         CLI   DSN+8,C' '             dynalloc without ?        GP09317
         BE    DSS0076                yes, skip prefixing
DSS0072  #MSG  'EXEC parm specified dataset %S:44 is to be restored froX
               m the dump to SYSUT2 DD',DSN
         B     DSS009
DSS0073  DS    0H
         CLC   DSN+9(8),BLANKS        Is prefix blank           GP09317
         BNE   DSS0074                no, skip
         #MSG  'EXEC parm indicated DYNALLOC HLQ prefixing but prefix iX
               s missing'
         B     EXITRC12
DSS0074  DS    0H
         CLI   DSN+17,C' '            This should be blank
         BE    DSS0075                good, skip
         #MSG  'EXEC parm DYNALLOC HLQ prefix value specified is longerX
                than 8 bytes'
         B     EXITRC12
DSS0075  DS    0H
         MVC   PREFIX,DSN+9           Save the prefix from PARM
         #MSG  'EXEC parm requested DYNALLOC using prefix %S:8',PREFIX
         B     DSS0077
DSS0076  DS    0H
         #MSG  'EXEC parm requested DYNALLOC, no prefix was given.'
DSS0077  DS    0H
         OI    CONTROL2,CDYNALLO      Indicate we will do DYNALLOCs
         B     DSS009
EXMVCDSN MVC   DSN(*-*),2(R6)         EXEC'ed to capture DSN    GP09317
EXMVCDBL MVC   DBLWRD(0),2(R6)        Should be readable now?   GP09317
DSS0079  DS    0H
         #MSG  'EXEC parm "*" specified, will attempt to restore all poX
               ssible datasets from dump to SYSUT2 DD statements'
*
* * Start checking out SYSUT1
*
DSS009   DS    0H
         OI    PROFLAGS,PFDASD    Preset for DASD input         GP09317
         DEVTYPE DCBDDNAM-IHADCB+SYSUT1,DEVTAREA                GP09317
         LTR   R15,R15                Was it OK?
         BZ    DSS010                 yep, skip
         MVC   DCBDDNAM-IHADCB+SYSUT1,=CL8'TAPE ' MATCH DSSDUMP GP09317
         MVC   DCBDDNAM-IHADCB+EXCPDCB,=CL8'TAPE '      DSSDUMP GP09317
         DEVTYPE DCBDDNAM-IHADCB+SYSUT1,DEVTAREA                GP09317
         LTR   R15,R15                Was it OK?                GP09317
         BZ    DSS010                 yep, skip                 GP09317
DSS009M  ST    R15,WORK
         #MSG  'DEVTYPE failed for SYSUT1, RC=%D',WORK
         B     EXITRC16
DSS010   CLI   DEVTTYPE+2,UCB3DACC    Direct Access input ?     GP09317
         BE    DSS015                 Yes; all set              GP09317
         NI    PROFLAGS,255-PFDASD    Reset DASD mode; use EXCP GP09317
         MVC   SYSUT1(EXCPDCBL),EXCPDCB     Overlay with EXCP   GP09317
         CLI   DEVTTYPE+2,UCB3TAPE    Is it a tape device?      GP09317
         BE    DSS015                 yep, thats OK             GP09317
         #MSG  'SYSUT1 must be on tape or DASD'                 GP09317
         B     EXITRC16
*
* * See if we can open SYSUT1
*
DSS015   DS    0H
         OPEN  (SYSUT1,(INPUT))
         LA    R1,SYSUT1
         USING IHADCB,R1
         TM    DCBOFLGS,DCBOFOPN      Did SYSUT1 open OK?
         BO    DSS020                 Yes, skip
         DROP  R1
         #MSG  'Unable to open SYSUT1'
         B     EXITRC16               No SYSUT1, end with bad RC
DSS020   DS    0H
         OI    CONTROL,CUT1OPEN       Say that SYSUT1 has been opened
*
* * get SYSUT1 input buffer, GETDATA routine's "output" buffer,
* * Track output buffer for SYSUT2 and "holding" buffer for
* * "out of sequence" segments
*
         L     R2,=F'65520'           Get SYSUT1 max blksize
         TM    PROFLAGS,PFDASD        DASD input ?              GP09317
         BZ    *+8                    No                        GP09317
         LH    R2,DCBBLKSI-IHADCB+SYSUT1    DASD needs less     GP09317
         LR    R3,R2                  Save bottom size          GP10159
         A     R2,=F'65520'           Allow for work space      GP10159
         ST    R2,WORK
         GETMAIN RC,LV=(R2),BNDRY=PAGE                          GP10159
         LTR   R15,R15
         BZ    DSS025
         #MSG  'Unable to getmain %D5 byte SYSUT1 input buffer',WORK
         B     EXITRC16
DSS025   AR    R3,R1                  Move limit                GP10159
         ST    R1,UT1BUFFA            Save address of SYSUT1 buffer
         ST    R3,UT1@HWM             Save address of low HWM   GP10159
         LR    R4,R1                  Save address of GETDATA buffer
         ST    R1,UT1@NXT             Next tank address         GP10159
         ST    R1,UT1@TOP             Next read address         GP10159
*
         L     R2,=F'65536'           Big enough to hold whole track
         GETMAIN RC,LV=(R2),BNDRY=PAGE                          GP10159
         LTR   R15,R15
         BZ    DSS035
         #MSG  'Unable to getmain 65536 byte SYSUT2 track output buff'
         B     EXITRC16
DSS035   DS    0H
         ST    R1,UT2BUFFA            Save track output buffer
*
         L     R2,=F'65536'           Big enough to hold largest
*                                     segment we may encounter
         GETMAIN RC,LV=(R2)
         LTR   R15,R15
         BZ    DSS040
         #MSG  'Unable to getmain 65536 byte segment holding buffer'
         B     EXITRC16
DSS040   DS    0H
         ST    R1,HOLDBUFA            Save holding buffer address
*
         L     R2,=F'65536'           Big enough to hold largest
*                                     track image we may encounter
         GETMAIN RC,LV=(R2),BNDRY=PAGE                          GP10159
         LTR   R15,R15
         BZ    DSS045
         #MSG  'Unable to getmain 65536 byte decompression buffer'
         B     EXITRC16
DSS045   DS    0H
         ST    R1,DCOMPBUF            Save holding buffer address
*
* * * Initialisation complete, start analysing the dump on SYSUT1
*
*
* * Check the type of dump and make sure there are no weird flags set
*
         USING ADRTAPB,R4             Map the GETDATA output area
         #MSG  ' '
         TM    CONTROL,CDEBUG         Verbose?
         BNO   DSS050                 nope, skip
         #MSG  'Initialisation complete, checking dump type'
         #MSG  ' '
DSS050   LA    R2,16                  Get the segment prefix
         BAL   R8,GETDATA             from SYSUT1
         MVC   SEGNUM,=F'1'           Initialise segment number
         CLC   DTPSEQNO,SEGNUM        Check segment sequence number
         BE    DSS100
         #MSG  'Segment seq # 1 missing, found x%X8:4',DTPSEQNO
         B     EXITRC12
DSS100   DS    0H
         CLI   DTPPFXLN,X'10'         Is seg prefix leng 16?
         BE    DSS102
         #MSG  'Segment prefix is not 16 bytes, len=%D:1',DTPPFXLN
         B     EXITRC12
DSS102   DS    0H
         CLI   DTPDMPID,DTPLOGCL      Is this a logical dump
         BE    DSS110                 yes, skip
         TM    DTPDMPID,DTPLOGCL      was there just other bits set?
         BO    DSS105                 yes, give a warning
         #MSG  'This is not a LOGICAL DUMP, DTPDMPID=x%X2:1',DTPDMPID
         B     EXITRC12
DSS105   DS    0H
         #MSG  'WARNING - This may not be a LOGICAL DUMP, will attempt X
               processing anyway, DTPDMPID=x%X2:1',DTPDMPID
         OI    RETCODE,4                                        GP09317
DSS110   DS    0H
         CLI   DTPRCID1,DTPTHDR       Is this a tape header
         BE    DSS115
         #MSG  'First segment is not a tape header'
         B     EXITRC12
DSS115   DS    0H
         CLI   DTPRCFL1,X'00'         Are any weird flags set?
         BE    DSS120
         #MSG  'WARNING - DTPRCFL1 flags are not zero, may cause weird X
               results, flgs=x%X2:1',DTPRCFL1
         OI    RETCODE,4                                        GP09317
DSS120   DS    0H
         CLC   DTPSEGLN,UT1READL+2    *** Sanity check, should be 1 seg
         BE    DSS122                 *** per block read on first segs.
         #MSG  'WARNING, DTPSEGLN was %D:2 but block length was %D on sX
               egment 1',DTPSEGLN,UT1READL
         TM    PROFLAGS,PFBDW+PFRDW   RECFM=Vnn input ?         GP10159
         BZ    DSS122                 No                        GP09329
         #MSG  '  This is normal when RECFM is not U'           GP10159
DSS122   DS    0H
         LH    R2,DTPSEGLN            Get segment length
         SH    R2,=H'16'              minus prefix length
         STH   R2,DSSCHECK            save computed leng of tape header
         BAL   R8,GETDATA             Get rest of tape header
*
* * Check rest of the tape header segment then getmain data area for
* * the DSN table to hold the details about the datasets in the dump.
* * Check a few flags to see if we can process the dump.
*
         LH    R1,DTHTIMD+2           Get DDDS part of date
         O     R1,=X'0000000F'        ensure no 0C7
         ICM   R1,B'1000',=X'19'      Assume 19xx
         CLI   DTHTIMD,X'00'          Is it?
         BE    DSS125                 yes, skip
         ICM   R1,B'1000',=X'20'      No, just assume 20xx
DSS125   ICM   R1,B'0100',DTHTIMD+1   get YY part of date
         ST    R1,WORK                save it
         UNPK  DBLWRD(7),WORK(4)      unpk into temp area
         MVC   TIMEFMT(4),DBLWRD      insert YYYY
         MVI   TIMEFMT+4,C'.'         insert the period
         MVC   TIMEFMT+5(3),DBLWRD+4  inserd DDD
         OI    DTHTIMD+7,X'0F'        overlay 'h' with sign nibble
         UNPK  DBLWRD(7),DTHTIMD+4(4) unpack the digits
         MVC   TIMEFMT+9(2),DBLWRD    move
         MVC   TIMEFMT+12(2),DBLWRD+2   into
         MVC   TIMEFMT+15(2),DBLWRD+4     formatted area
         SR    R0,R0                  Packed version ?          GP09317
         IC    R0,DTHVERNO            Yes                       GP09317
         SRL   R0,4                   Skip sign                 GP09317
         STC   R0,WORK                Stash                     GP09317
         IC    R0,DTHLVLNO            Get level                 GP09317
         SRDL  R0,32                  Prepare for divide        GP09317
         D     R0,=F'10'              Split mod                 GP09317
         STC   R1,WORK+1                                        GP09317
         STC   R0,WORK+2                                        GP09317
         #MSG  'DFDSS dump version %D:1 mod %D:1.%D:1; logical dump wriX
               tten %S17:17',WORK,WORK+1,WORK+2,TIMEFMT         GP09317
         TM    DTHIND2,DTHGNVI        Any non-VSAM datasets?
         BNO   DSS130                 yes, skip
         #MSG  'Dump does not contain any non-VSAM datasets'
         B     EXITRC12
DSS130   DS    0H
         TM    DTHIND2,DTHGVI         Any VSAM datasets?
         BO    DSS135                 no, skip
         #MSG  'WARNING - Dump contains VSAM datasets, these will not bX
               e analysed/restored'
         OI    RETCODE,4                                        GP09317
DSS135   DS    0H
         XC    DSSNFILE,DSSNFILE      Clear number of files
         TM    DTHIND2,DTHGT64K       More than 65535 datasets ?
         BNO   DSS140                 no, skip
         MVI   DSSNFILE+1,X'01'       yes, prime fullword with 64K
DSS140   DS    0H
         MVC   DSSNFILE+2(2),DTHNDS   fill in number of files in dump
         XC    DSSMAXB,DSSMAXB        clear max blksize
         MVC   DSSMAXB+2(2),DTHBLKSZ  fill in max blksize of dump
         #MSG  'Dump contains %D file(s) and has a max blksize of %D',DX
               SSNFILE,DSSMAXB
         LA    R3,DSNTABEL            Get DSN table entry length
         M     R2,DSSNFILE            times number of files
         ST    R3,WORK                save table leng in case needed
         GETMAIN RC,LV=(R3)
         LTR   R15,R15
         BZ    DSS142
         #MSG  'Unable to getmain %D byte dataset name table area',    X
               WORK
         B     EXITRC16
DSS142   DS    0H
         ST    R1,DSNTABA             Save DSN table address
         LR    R5,R1                  Copy table addr to R5
         USING DSNTAB,R5              & establish addressability to it
*        TM    DTHIND1,DTHFCMP        Is compressed indicator on?
*        BNO   DSS145                 nope, skip
*       #MSG  'Dump contains compressed files, these cannot be processX
*              ed'
*        B     EXITRC12
DSS145   DS    0H
         TM    DTHIND1,DTHUNLCD       Is unallocated space dumped?
         BNO   DSS150                 no, skip
         #MSG  'WARNING - unallocated space included in dump, this shouX
               ld not be set for logical dumps'
         OI    RETCODE,4                                        GP09317
DSS150   DS    0H
         TM    DTHIND1,DTHSFER        Is sphere option used?
         BNO   DSS155                 no, skip
         #MSG  'WARNING - SPHERE option indicated on dump, what is thatX
               ?'
         OI    RETCODE,4                                        GP09317
DSS155   DS    0H
         CLC   DSSCHECK,DTHLEN        Sanity check on header length
         BE    DSS160                 equal, ok
       #MSG  'Incorrect tape header length, expected %D:2 but got %D:2'X
               ,DSSCHECK,DTHLEN
         B     EXITRC12
DSS160   DS    0H
*
* * Now its time to fill in the DSN table with names of datasets
* * we expect to find in this dump.
* *
* * Read and check next segment header - should be DSName/Catlg Lst
*
         SLR   R3,R3                  R3 will count DSNs
DSS200   DS    0H                     Loops back here if > 1 DSNlst seg
         L     R1,SEGNUM              bump segment number
         AH    R1,=H'1'
         ST    R1,SEGNUM
         LA    R2,16                  Get segment prefix
         BAL   R8,GETDATA             go read it
         CLC   DTPSEQNO,SEGNUM        Is segment sequence number OK?
         BE    DSS205                 yes, skip
         #MSG  'Sequence error, segment # %D found, expected segment # X
               %D',DTPSEQNO,SEGNUM
         B     EXITRC12
DSS205   DS    0H
         CLI   DTPRCID1,DTPDSNL       Is this a DSName/Catlg lst ?
         BE    DSS210
         #MSG  'Expected a DSName list segment but found type x%X2:1, sX
               egment number %D',DTPRCID1,SEGNUM
         B     EXITRC12
DSS210   DS    0H
         CLI   DTPRCFL1,X'00'         Are the flags zero?
         BE    DSS215                 Yep, skip
         #MSG  'Unknown DTPRCFL1 flgs on DSNlist seg # %D, flgs=x%X2:1'X
               ,SEGNUM,DTPRCFL1
         B     EXITRC12
DSS215   CLC   DTPSEGLN,UT1READL+2    *** Sanity check, should be 1 seg
         BE    DSS220                 *** per block read at this point.
         #MSG  'WARNING, DTPSEGLN was %D:2 but block length was %D on sX
               egment %D',DTPSEGLN,UT1READL,SEGNUM
DSS220   DS    0H
*
* * Loop thru DSN entries in this segment & put DSNs in DSN table
*
         SLR   R2,R2                  Clear R2
         ICM   R2,B'0011',DTPSEGLN    Get segment length
         SH    R2,=H'16'              minus (assumed) prefix length
         BAL   R8,GETDATA             Read the rest of the segment
         LA    R7,ADRTAPB             R7 will address entries in seg
DSS225   DS    0H
         CLI   0(R7),X'00'            End of DSNs in this segment?
         BE    DSS250                 yes, skip
         CLI   0(R7),44               Is length normal?
         BNH   DSS230                 yes, skip
         MVC   WORK(1),0(R7)
         #MSG  'DSName too long (%D:1) in DSNlist segment # %D',WORK,  X
               SEGNUM
         B     EXITRC12
DSS230   DS    0H
         LR    R1,R7                  Copy input data pointer
         SR    R1,R4                  minus start of buffer
         C     R1,UT1READL            have I gone way past the data?
         BL    DSS235                 no, skip
         #MSG  'Logic error in DSNlist segment # %D',SEGNUM
         B     EXITRC12
DSS235   DS    0H
         SLR   R2,R2
         IC    R2,0(,R7)              R2=DSN Length
         BCTR  R2,0                   decrement for exec
         LA    R3,1(,R3)              bump DSN counter
         C     R3,DSSNFILE            is it too high?
         BNH   DSS240                 no, skip
         #MSG  'Too many DSNlist entries found, only expected %D',DSSNFX
               ILE
         B     EXITRC12
DSS240   DS    0H
         XC    DSNTAB(DSNTABEL),DSNTAB Zero out the entry
         MVC   DSNTDSN,BLANKS         Clear the table entry DSN GP09317
         EX    R2,DSS245              Move DSN in
         LA    R7,46(R2,R7)           Bump input pointer
         LA    R5,DSNTABEL(R5)        Bump table pointer
         B     DSS225                 process rest of entries
DSS245   MVC   DSNTDSN(*-*),45(R7)    EXEC'ed to move DSN into DSNTAB
*
* * end of DSNs in this segment, check if I should expect more
*
DSS250   DS    0H
         C     R3,DSSNFILE            Do I have them all yet?
         BL    DSS200                 nope, go get some more
*
         TM    CONTROL,CDEBUG         verbose?
         BNO   DSS260                 nope, skip
         ST    R3,WORK
         #MSG  'DSN table of %D entries successfully built',WORK
         #MSG  ' '
*
DSS260   MVI   STATE,STDSHDR          Indicate a dataset header
*                                     is the only segment type expected
*
****************************************************************
*
* * Now we start processing segments according to what segment
* * types we find, STATE will indicate what segment types are
* * allowable at any given point in time.
* *
* * For each segment we read on SYSUT1 we will start off
* * by saving a copy of the segment prefix for later then
* * check segment sequence numbers and repair known anomalies.
* *
* * One anomaly that cropped up late in development was DFDSS's ability
* * to generate out-of-sequence track data segments.  For example,
* * you may encounter segments 11, 12, 14, 13, 15, 16 .... where
* * segments 13 & 14 are swapped.  The assumption is that this out-of-
* * sequence behaviour doesn't get any worse than this simple swapping.
* * Code was added to stash the current segment in a holding buffer
* * when the out-of-sequence is encountered, grab the next segment and
* * return to the segment in the holding buffer afterwards.  If the
* * code for this looks like an afterthought patch thats because it is.
* *
* * Next determine what type of segment we have and check STATE
* * to see of that type of segment is acceptable at this point.
* *
* * Note that the processing rtns for each segment type maintain
* * the STATE to indicate what kind of segments may follow
* *
****************************************************************
DSS300   DS    0H
         L     R1,SEGNUM              bump segment number
         AH    R1,=H'1'
         ST    R1,SEGNUM
         TM    CONTROL2,CHELDSEG      Do we have a held segment?
         BNO   DSS301                 no, go read a new segment
         NI    CONTROL2,255-CHELDSEG  yep, reset the held seg flag
         OI    CONTROL2,CHELDSG2      and set stage 2 held seg flag
         TM    CONTROL,CDEBU2         Debug on?
         BNO   DSS3005                No, skip
         #MSG  'Processing held segment'
DSS3005  DS    0H
         L     R1,HOLDBUFA            point to held seg prefix
         MVC   ADRTAPB(16),0(R1)      put in input buffer
         B     DSS302                 and skip the read
         SPACE 1
*---------------------------------------------------------------------*
*   READ 16 BYTE HEADER SEGMENT FROM NEXT RECORD                      *
*---------------------------------------------------------------------*
DSS301   LA    R2,16                  Get segment prefix
         BAL   R8,GETDATA             go read it
DSS302   MVC   DSSPREFX,ADRTAPB       Save a copy of the prefix
         CLC   DTPSEQNO,SEGNUM        Is segment sequence number OK?
         BE    DSS310                 yes, skip
         CLI   DTPRCID1,DTPDTRLR      no, is this a dataset trailer?
         BNE   DSS305                 no, needs more checks then
         L     R1,SEGNUM              get segment number
         LA    R1,1(,R1)              bump it
         C     R1,DTPSEQNO            equal now?
         BNE   DSS308                 no, give up
         ST    R1,SEGNUM              DSS appears to rather consistntly
*                                     skip a segment at EOF so
         B     DSS310                 just ignore it
         SPACE 1
DSS305   TM    CONTROL2,CHELDSG2      Processing a held segment?
         BO    DSS308                 yep, give up then
*************************************
* I think there's a bug here, we could have just finished
* holding a segment and now we're about to try holding another
* one - that isn't right! - it leads to wild loops and overly
* big segments being moved that can possibly cause overlays
*************************************
*
* * sequence error occurred, hold this segment and get the next
* * segment then go back to re-try the segment sequence check
*
         TM    CONTROL,CDEBU2         Is debug mode on?
         BNO   DSS306                 nope, skip
         #MSG  'Note - Holding segment # %D',DTPSEQNO
DSS306   DS    0H
         L     R1,HOLDBUFA            Get address of hold buffer
         MVC   0(16,R1),ADRTAPB       save the segment prefix
         SLR   R2,R2                  Clear R2
         ICM   R2,B'0011',DTPSEGLN    Get segment length
         SH    R2,=H'16'              minus (assumed) prefix length
         ST    R2,HOLDSEGL            Save this segment length
         BAL   R8,GETDATA             Read the rest of the segment
         L     R1,HOLDBUFA            Address hold buffer
         LA    R0,16(,R1)             point past saved prefix
         L     R1,HOLDSEGL            Get seg length (minus prefix len)
         LR    R3,R1                  copy it for MVCL
         LA    R2,ADRTAPB             address the source segment
         MVCL  R0,R2                  move segment to hold buffer
         OI    CONTROL2,CHELDSEG      Set held segment flag
         B     DSS301                 go ack and re-try sequence test
*
* * note: one more check could be inserted here, apparently sometimes
* *       the last segment for the last data track is off by one,
* *       for example when processing data track segments you get like
* *       seg 11, 12, 13, 15 then get dataset trailer segment (with
* *       seg # 17 probably 'cause DSS likes to skip a number before
* *       the trailer).  Segment # 14 never shows up.  This is a known
* *       anomaly apparently and this code will blow up if it is
* *       encountered.
*
DSS308   #MSG  'Sequence Error, seg # %D found, expected seg %D, seg tyX
               pe x%X2:1, UT1blk %D',                                  X
               DTPSEQNO,SEGNUM,DTPRCID1,UT1NBLKS
         B     EXITRC12
*
* * should have seg sequence taken care of, get the segment data
*
DSS310   DS    0H
         MVC   DSSSEGTY,DTPRCID1      Save the segment type
         TM    CONTROL2,CHELDSG2      Using a saved segment?
         BNO   DSS315                 no, go read the segment then
         NI    CONTROL2,255-CHELDSG2  yep, reset the flag
         L     R1,HOLDBUFA            address held seg buffer
         LA    R0,16(,R1)             point past prefix
         L     R1,HOLDSEGL            get held seg leng (minus prefix)
         LR    R3,R1                  copy for MVCL
         LA    R2,ADRTAPB             destination address
         MVCL  R2,R0                  move held seg to input buffer
         L     R1,HOLDSEGL            get that length again
         LA    R1,16(,R1)             tack on prefix length
         ST    R1,DSSSEGLN            save overall segment length
         B     DSS317                 skip the segment read
DSS315   DS    0H
         SLR   R2,R2                  Clear R2
         ICM   R2,B'0011',DTPSEGLN    Get segment length
         ST    R2,DSSSEGLN            Save this segment length
         SH    R2,=H'16'              minus (assumed) prefix length
         BAL   R8,GETDATA             Read the rest of the segment
*
* * We finally have the right sequence number segment to process,
* * check if this segment type is allowed at this point and
* * go process it.
*
DSS317   DS    0H
         CLI   DSSSEGTY,DTPDSHDR      Is it a Dataset Header seg?
         BNE   DSS325                 nope, skip
         TM    STATE,STDSHDR          yep, is that OK?
         BO    DSS320                 yep, skip
         #MSG  'Found an unexpected Dataset Header segment, seg # %D, UX
               T1blk %D',SEGNUM,UT1NBLKS
         B     EXITRC12
DSS320   DS    0H
         BAL   R8,DSHDR               Go process dataset header
         B     DSS300                 continue looping
DSS325   DS    0H
         CLI   DSSSEGTY,DTPVOLD       Is it a volume definition seg?
         BNE   DSS335                 nope, skip
         TM    STATE,STVOLDEF         yep, is that OK?
         BO    DSS330                 yep, skip
         #MSG  'Found an unexpected Volume Definition segment, seg # %DX
               , UT1blk %D',SEGNUM,UT1NBLKS
         B     EXITRC12
DSS330   DS    0H
         BAL   R8,VOLDEF              Go process volume definition
         B     DSS300                 continue looping
DSS335   DS    0H
         CLI   DSSSEGTY,DTPDATA       Is it a Data Track seg?
         BNE   DSS345                 nope, skip
         TM    STATE,STDATATR         yep, is that OK?
         BO    DSS340                 yep, skip
         #MSG  'Found an unexpected Data Track segment, seg # %D, UT1blX
               k %D',SEGNUM,UT1NBLKS
         B     EXITRC12
DSS340   DS    0H
         BAL   R8,DATATRK             Go process volume definition
         B     DSS300                 continue looping
DSS345   DS    0H
         CLI   DSSSEGTY,DTPDTRLR      Is it a Dataset Trailer seg?
         BNE   DSS355                 nope, skip
         TM    STATE,STDATATL         yep, is that OK?
         BO    DSS350                 yep, skip
         TM    STATE,STVOLDEF         Was I after a Volume def seg?
         BO    DSS347                 yes, skip
         #MSG  'Found an unexpected Dataset Trailer seg, seg # %D, UT1bX
               lk %D',SEGNUM,UT1NBLKS
         B     EXITRC12
DSS347   DS    0H
         #MSG  'No vol def or data tracks found for %S:44',DSNTDSN
         MVI   STATE,STDATATL+STDATAT2 Reset state, insist on a second
*                                     dataset trailer
         B     DSS300                 and keep looping.
DSS350   DS    0H
         BAL   R8,DSTRAIL             Go process dataset trailer
         B     DSS300                 continue looping
DSS355   DS    0H
         #MSG  'Unknown segment type x%X2:1 found, segment # %D, UT1blkX
                %D',DSSSEGTY,SEGNUM,UT1NBLKS
         B     EXITRC12
***********************************************************************
*
* * Process Dataset Header Segment
*
*   Find the DSN table entry for this dataset and check if we are
*   going to try and restore this dataset.  Then check if this is
*   one of the DSORGs that we will attempt to process (anything
*   that smells of VSAM or extended format is just skipped).
*
***********************************************************************
*
****** just a bit of FMT1 DSCB mapping for your info
****** The field DTDDSORG uses these mappings to show DSORG
*  *
*  *                    FIRST BYTE OF DS1DSORG
*  DS1DSGIS EQU   X'80'  1... ....    IS - INDEXED SEQUENTIAL
*  *                                  ORGANIZATION
*  DS1DSGPS EQU   X'40'  .1.. ....    PS - PHYSICAL SEQUENTIAL
*  *                                  ORGANIZATION
*  DS1DSGDA EQU   X'20'  ..1. ....    DA - DIRECT ORGANIZATION
*  DS1DSGCX EQU   X'10'  ...1 ....    CX - BTAM OR QTAM LINE GROUP
*  *        EQU   X'08'  .... 1...    CQ - QTAM DIRECT ACCESS MSG QUE
*  *        EQU   X'04'  .... .1..    MQ - QTAM PROBLEM PROG MSG QUEUE
*  DS1DSGPO EQU   X'02'  .... ..1.    PO - PARTITIONED ORGANIZATION
*  DS1DSGU  EQU   X'01'  .... ...1    U - UNMOVABLE, THE DATA SET
*  *                                      CONTAINS LOCATION DEPENDENT
*  *                                      INFORMATION
*  *
*  *                     SECOND BYTE OF DS1DSORG
*  DS1DSGGS EQU   X'80'  1... ....    GS - GRAPHICS ORGANIZATION
*  DS1DSGTX EQU   X'40'  .1.. ....    TX - TCAM LINE GROUP
*  DS1DSGTQ EQU   X'20'  ..1. ....    TQ - TCAM MESSAGE QUEUE
*  *        EQU   X'10'  ...1 ....    RESERVED
*  DS1ACBM  EQU   X'08'  .... 1...    AM - ACCESS METHOD CONTROL BLOCK
*  DS1ORGAM EQU   X'08'  .... 1...    AM - VSAM DATA SET/SPACE
*  DS1DSGTR EQU   X'04'  .... .1..    TR - TCAM 3705
*  *        EQU   X'02'  .... ..X.    RESERVED
*  *        EQU   X'01'  .... ...X    RESERVED
*  *
DSHDR    DS    0H
         MVI   STATE,STVOLDEF         Only volume def'n rec is OK now
         NI    CONTROL,255-CVOLDEF    Say vol def not yet found
*                                     (used later to check if more than
*                                     one vol def segment is found)
         L     R5,DSNTABA             Point to DSN table
         L     R3,DSSNFILE            get # of entries
DSH000   DS    0H
         CLC   DTDDSN,DSNTDSN         Is this the correct dataset?
         BE    DSH005                 yes, skip
         LA    R5,DSNTABEL(R5)        next table entry
         BCT   R3,DSH000              search whole table
         #MSG  'Cannot find dataset %S:44 in DSN table',DTDDSN
         B     EXITRC12
DSH005   DS    0H
         XC    DSNTTRKC,DSNTTRKC      Clear out track count for this DS
         XC    DSSTRKSG,DSSTRKSG      Clear out track segment cnt 4  DS
         XC    DSSNR0NZ,DSSNR0NZ      Clear # non-zero R0's found
         OI    DSNTFLGS,DSNTFFND      Indicate I found this dataset
         OI    CONTROL,CSKIP          Assume I will skip this file
         MVC   DSNTDSOB,DTDDSORG      Save binary DSORG from DShdr
         TM    DTDDSORG+1,X'08'       Is it VSAM?
         BNO   DSH010
         MVC   DSNTDSOR,=C'VS '       Put DSORG in DSN tab
         #MSG  'Skipping VSAM file %S:44',DTDDSN
         BR    R8
DSH010   DS    0H
         TM    DTDDSORG,X'80'         Is it ISAM
         BNO   DSH015
         MVC   DSNTDSOR,=C'IS '
         B     DSH035
DSH015   DS    0H
         TM    DTDDSORG,X'40'         Is it Sequential
         BNO   DSH020
         MVC   DSNTDSOR,=C'PS '
         B     DSH035
DSH020   DS    0H
         TM    DTDDSORG,X'20'         Is it DA
         BNO   DSH025
         MVC   DSNTDSOR,=C'DA '
         B     DSH035
DSH025   DS    0H
         TM    DTDDSORG,X'02'         Is it PO
         BNO   DSH030
         MVC   DSNTDSOR,=C'PO '
         B     DSH035
DSH030   DS    0H
         #MSG  'File %S:44 has unknown DSORG x%X4:2, skipped',DTDDSN,DTX
               DDSORG
         MVC   DSNTDSOR,=CL3'?? '     Put DSORG in DSN tab
         BR    R8
DSH035   DS    0H
         MVC   DSNTVOLC,DTDVCTD       Save volume count
         TM    DTDIND2,DTDPDSE+DTDPDSET PDSE?
         BZ    DSH040
         MVC   DSNTDSOR,=CL3'EF '     Put DSORG in DSN tab
         #MSG  'File %S:44 is a extended format (PDSE, HFS,..), skippedX
               ',DTDDSN
         BR    R8
DSH040   DS    0H
         TM    DTDIND2,DTDAIXSP       AIX sphere?
         BNO   DSH045
         MVC   DSNTDSOR,=CL3'AIX'     Put DSORG in DSN tab
         #MSG  'File %S:44 is a AIX + part of sphere, skipped',DTDDSN
         BR    R8
DSH045   DS    0H
         TM    DTDIND2,DTDNOIDX       VSAM indexed DS dumped w/VALIDATE
         BNO   DSH050
         MVC   DSNTDSOR,=CL3'VAL'     Put DSORG in DSN tab
         #MSG  'File %S:44 is VSAM VALIDATE stuff, skipped',DTDDSN
         BR    R8
DSH050   DS    0H
*
* * We now know that this is a (non-VSAM) dataset that we will process
* * Update the chain of restore candidates in the DSN table
* * then go and check for and warn about any funny stuff
*
         NI    CONTROL,255-CSKIP      Set skip bit off
         L     R1,DSNTA#1             Get chain anchor
         LTR   R1,R1                  Is it initialised?
         BNZ   DSH0505                yes, skip
         ST    R5,DSNTA#1             no, anchor is this DSNtab entry
         B     DSH0508                skip
DSH0505  DS    0H
         L     R1,DSNTPREV            get address of previous entry
         ST    R5,DSNTANXT-DSNTAB(,R1) forward chain it to this entry
DSH0508  DS    0H
         ST    R5,DSNTPREV            Set up "prev" entry pointer
         TM    CONTROL,CDEBUG         Debug run?
         BNO   DSH051                 nope, skip
         #MSG  '------ Processing %S44:44',DSNTDSN
DSH051   DS    0H
         TM    CONTROL,CREST          Is this a restore run?
         BNO   DSH053                 Nope, skip
         NI    CONTROL,255-CDOREST    Reset "do restore" indicator
         CLC   DSN(2),=CL2'* '        Restore ALL datasets?
         BE    DSH052                 yes, skip
         TM    CONTROL2,CDYNALLO      All datasets using DYNALLOC?
         BO    DSH052                 yes, skip
         CLC   DTDDSN,DSN             This the file we want restored?
         BNE   DSH053                 No, skip
DSH052   DS    0H
         #MSG  'Restore of %S:44 in progress',DSNTDSN
         OI    CONTROL,CDOREST        Indicate restore is to be done
         OI    DSNTFLGS,DSNTFRES      Flag it in DSN table as well
DSH053   DS    0H
         TM    DTDDSORG,X'01'         Unmoveable?
         BNO   DSH055
         #MSG  'WARNING, dataset %S:44 is marked unmoveable, may be unuX
               sable',DTDDSN
         MVI   DSNTDSOR+2,C'U'        Say so in DSORG
         OI    RETCODE,4                                        GP09317
DSH055   DS    0H
         TM    CONTROL,CDEBUG         Is debug on?
         BNO   DSH057                 nope, skip
         #MSG  '%S:44 is DSORG %S3:3, volume count=%D:1',              X
               DTDDSN,DSNTDSOR,DTDVCTD
DSH057   DS    0H
         TM    DTDIND2,DTDCDF         common format dataset?
         BNO   DSH060
         #MSG  'File %S:44 is a common format dataset, CURIOUS',DTDDSN
DSH060   DS    0H
         TM    DTDIND2,DTDNTALL       Was ALLD or ALLX used ?
         BO    DSH065
         #MSG  'File %S:44 was dumped with ALLDATA keyword',DTDDSN
DSH065   DS    0H
         TM    DTDIND2,DTDSDM         System data mover indicated?
         BNO   DSH070
         #MSG  'File %S:44 has Use System Data Mover bit set',DTDDSN
DSH070   DS    0H                                               GP09317
         CLC   DSSPREFX+(DTPSEGLN-ADRTAPB)(2),=H'122' Check leng of seg
         BE    DSH075
         #MSG  'Warning, DS header segment was %D:2 long but I expectedX
                122, UT1blk %D',DSSPREFX+(DTPSEGLN-ADRTAPB),UT1NBLKS
DSH075   DS    0H
         BR    R8                     Return
***********************************************************************
*
*   Process Volume Definition Segment
*
*   See if there are multiple Volume def segs and warn if so.
*
*   Examine the FMT1DSCB info and save the info from it in the DSN tab
*   Compute number of tracks the dataset occupies and save in DSN tab
*
*   If this is a dataset we want to restore, then open SYSUT2
*
***********************************************************************
VOLDEF   DS    0H
         MVI   STATE,STDATATR+STVOLDEF Indicate we expect data trk next
*                                     but we'll accept a vol def seg
         TM    CONTROL,CSKIP          Are we processing this dataset?
         BOR   R8                     No, so just return
         TM    CONTROL,CVOLDEF        Have we had a volume def seg yet
         BNO   VOL005
         #MSG  'WARNING - Additional Volume Definition segment ignored X
               for %S:44',DSNTDSN
         OI    RETCODE,4                                        GP09317
         BR    R8
VOL005   DS    0H
         MVC   DSNTTRCY,DTMTRKCY      Save Tracks/Cyl for later calc.
         MVC   DSNTDEV,DTMDEVTY       Save device type
         MVC   DSNTMDL,DTMMODNO       and model number
         MVC   DSNTVOLS,DTMVSERL      Save volser
         XC    DBLWRD,DBLWRD          Clear work area
         MVC   DBLWRD+2(2),DTMLOGCY   # cyls/vol
         MVC   DBLWRD+6(2),DTMTRKCY   # trk/cyl
         TM    CONTROL,CDEBUG         In debug mode?
         BNO   VOL010                 nope, skip
         #MSG  'Vol=%S6:6, Dev=x%X8:4, Mdl=x%X2:1, TrkL=%D, Cyl/Vol=%D,X
                Trk/Cyl=%D, #NVRS=x%X2:1, #DSCB=x%X2:1, #EXT=x%X2:1',  X
               DTMVSERL,DTMDEVTY,DTMMODNO,DTMTRKCP,DBLWRD,DBLWRD+4,    X
               DTM#VVRS,DTM#DSCB,DTM#EXT
VOL010   DS    0H
         LA    R3,DTMDSCB             Address the (first?) DSCB
         USING IECSDSL1,R3            Addressability to DSCB
         CLC   DS1DSNAM,DSNTDSN       Do names match?
         BE    VOL020                 Yep, skip
         #MSG  'DSCB DSN %S:44 does not match DSheader segment DSN',DS1X
               DSNAM
         B     EXITRC12
VOL020   DS    0H
         CLI   DS1FMTID,C'1'          Is this really a FMT1 DSCB
         BE    VOL025
         #MSG  'Invalid FMT1 DSCB, %S:44 DS1FMTID=x%X2:1, UT1blk %D',  X
               DSNTDSN,DS1FMTID,UT1NBLKS
         B     EXITRC12
VOL025   DS    0H
         MVC   DSNTCRDT,DS1CREDT      Save creation date
         MVC   DSNTEXPD,DS1EXPDT      expiration date,
         MVC   DSNTLUDT,DS1REFD       last used (last referenced) date.
***      MVC   DSNTSSFL,DS1SCXTF      Secondary space flags
* note: this line had to be changed for MVS 3.8J version of FMT1 DSCB
         MVC   DSNTSSFL,DS1REFD+4     DS1SCXTF didn't exist in 3.8J
***      MVC   DSNTSSVL,DS1SCXTV      Secondary space val
* note: this line had to be changed for MVS 3.8J version of FMT1 DSCB
         MVC   DSNTSSVL,DS1REFD+5     DS1SCXTV didn't exist in 3.8J
         TM    CONTROL,CDEBUG         Is debug on?
         BNO   VOL027                 nope, skip
         ICM   R0,B'0111',DS1CREDT    Creation date             GP09317
         BAL   R14,FMTDSDAT           format it
         MVC   CL24(8),DBLWRD         save it
         ICM   R0,B'0111',DS1EXPDT    Expiration date           GP09317
         BAL   R14,FMTDSDAT           format it
         MVC   CL24+8(8),DBLWRD       save it
         ICM   R0,B'0111',DS1REFD     Last Referenced Date      GP09317
         BAL   R14,FMTDSDAT           format it
         MVC   CL24+16(8),DBLWRD      save it
         #MSG  'Created %S8:8, Expires %S8:8, Last Referenced %S8:8',CLX
               24,CL24+8,CL24+16
         #MSG  'Secondary space flags=x%X2:1, value=x%X4:2',DSNTSSFL,DSX
               NTSSVL
VOL027   DS    0H
         CLC   DS1DSORG,DSNTDSOB      Is the DSORG what I expected?
         BE    VOL030
         #MSG  'DSORG mismatch, DSheader seg is %S3:3 x%X4:2 but FMT1 DX
               SCB says x%X4:2 for %S:44',DSNTDSOR,DSNTDSOB,DS1DSORG,  X
               DSNTDSN
         B     EXITRC12
VOL030   DS    0H
         MVC   DSNTRECF,DS1RECFM      Save recfm
         IC    R2,DS1RECFM            Put in parm reg
         BAL   R14,FMTRECFM           Convert to char
         MVC   DSNTRECC,WORK          Save in DSN tab
         MVC   DSNTOPTC,DS1OPTCD      Save Optcd
         MVC   DSNTBLKS,DS1BLKL       Save block length/max blksize
         MVC   DSNTLREC,DS1LRECL      Save lrecl
         MVC   DSNTKEYL,DS1KEYL       Save key length
         MVC   DSNTRKP,DS1RKP         Save relative key pos'n
         MVC   DSNTEXT,DS1NOEPV       SAve # extents
         TM    CONTROL,CDEBUG         Is debug active?
         BNO   VOL032                 no, skip
         XC    DBLWRD,DBLWRD
         MVC   DBLWRD+2(2),DS1BLKL
         MVC   DBLWRD+6(2),DS1LRECL
         #MSG  'RECFM=x%X4:2 %S4:5,lrecl=%D,blksize=%D,keylen=x%X2:1,RKX
               P=x%X4:2,Optcd=x%X2:1',DS1RECFM,DSNTRECC,DBLWRD+4,DBLWRDX
               ,DS1KEYL,DS1RKP,DS1OPTCD                         GP09317
         #MSG  'Number of extents=%D:1, # bytes used in last dir blk=%DX
               :1',DS1NOEPV,DS1NOBDB                            GP09317
VOL032   DS    0H
*** These lines removed 'cause it looks like this bit is never set
***      TM    DS1DSIND,DS1IND80      Last volume of this dataset?
***      BNO   VOL035
***     #MSG  'Note    - last vol indicator not set in FMT1 DSCB, addiX
***            tional DSCBs may exist and are not processed'
***      OI    RETCODE,4                                        GP09317
VOL035   DS    0H
         MVC   DSNTTBAL,DS1TRBAL      Save track balance (inserted in
*                                     SYSUT2 DCB at close time)
         MVC   DSNTHTTR,DS1LSTAR      Save last used TTR (checked for
*                                     consistency when we close the
*                                     dataset)
*****    MVC   DSNTSAL1,DS1SCAL1      Save secondary alloc flags
* note: MVS 3.8J FMT1 DSCB mac doesn't have DS1SCAL1 & 3
*******  MVC   DSNTSAL3,DS1SCAL3      and secondary alloc values
         MVC   DSNTSAL1,DS1SCALO      and secondary alloc values
         MVC   DSNTSAL3,DS1SCALO+1    and secondary alloc values
         TM    CONTROL,CDEBUG         Is debug active
         BNO   VOL037                 nope, skip
         #MSG  'Track balance is x%X4:2, last used TTR is x%X6:3',DSNTTX
               BAL,DSNTHTTR
         #MSG  'First extent info    = flg x%X2:1,seq x%X2:1,low CCHH xX
               %X8:4, hi CCHH x%X8:4',DS1EXT1,DS1EXT1+1,DS1EXT1+2,DS1EXX
               T1+6
         #MSG  'Secondary alloc info = x%X2:1 %X6:3',DSNTSAL1,DSNTSAL3
VOL037   XC    WORK(4*4),WORK         Reuse for work            GP09317
         LA    R14,DS1EXT1            Point to first extent     GP09317
         CLI   DS1EXT1,X'40'          Label track               GP09317
         BNE   VOL037SL               No                        GP09317
         LA    R14,DS1EXT2            Yes; use data extent      GP09317
         OI    DSNTFLGS,DSNTFSUL      Show user labels present  GP09317
VOL037SL MVC   WORK+2(2),DS1EXT1-DS1EXT1+2(R14)  LOW CYL        GP09317
         MVC   WORK+6(2),DS1EXT1-DS1EXT1+4(R14)  LOW TRK        GP09317
         MVC   WORK+10(2),DS1EXT1-DS1EXT1+6(R14)  HI CYL        GP09317
         MVC   WORK+14(2),DS1EXT1-DS1EXT1+8(R14)  HI TRK        GP09317
         L     R15,WORK+8             End cyl                   GP09317
         S     R15,WORK               less start                GP09317
         L     R1,WORK+12             End trk                   GP09317
         S     R1,WORK+4              less start                GP09317
         AH    R1,=H'1'               Relativity                GP09317
         MH    R15,DSNTTRCY           * #tracks/cyl             GP09317
         AR    R1,R15                                           GP09317
         ST    R1,DSNTPTRK            Save # primary tracks
         TM    CONTROL,CDEBUG         Is debug on?
         BNO   VOL045                 no, skip
         ST    R14,WORK               Save extent pointer       GP09317
         #MSG  'This dataset has a primary allocation of %D track(s)', X
               DSNTPTRK
         L     R14,WORK               Load extent pointer       GP09317
VOL045   DS    0H
         TM    DS1EXT1-DS1EXT1(R14),X'81'  Cylinder allocation? GP09317
         BNO   VOL050                 No, skip
         OI    DSNTFLGS,DSNTFCYL      Yes, set cylinder flag
VOL050   DS    0H
         DROP  R3                     Done with R3
*
* * Check if this is the dataset we're interested in restoring
* * if we are going to try and restore check the SYSUT2 device type
*

         TM    CONTROL,CDOREST        Are we doing restore?
         BNOR  R8                     no, just return
         TM    CONTROL2,CDYNALLO      Doing DYNALLOC?
         BO    VOL075                 yes, skip
         DEVTYPE DCBDDNAM-IHADCB+SYSUT2,DEVTAREA                GP09317
         LTR   R15,R15                Was it OK?
         BZ    VOL060                 yep, skip
         ST    R15,WORK               no,give warning and let something
*                                     else blow up later
         #MSG  'Warning: DEVTYPE failed for SYSUT2, RC=%D',WORK
         OI    RETCODE,4                                        GP09317
         B     VOL080                 skip device check
VOL060   DS    0H
         TM    DEVTTYPE+2,X'20'       Is it a disk device?
         BO    VOL070                 yep, thats OK
         CLI   DEVTTYPE+2,X'00'       Is it DD DUMMY?
         BNE   VOL065                 no, skip to error
         OI    DSNTFLGS,DSNTFDUM      yes, say SYSUT2 was dummy
         NI    CONTROL,255-CDOREST    reset the restore indicator
         #MSG  'SYSUT2 is DD DUMMY, no restore will be done'
         OPEN  (DUMMY2,(OUTPUT))      Open & close SYSUT2 to allow
         CLOSE (DUMMY2,FREE)          FREE=CLOSE to take effect GP11322
         BR    R8                     and just return
VOL065   DS    0H
         #MSG  'Error, SYSUT2 is not a disk device, DEVTYPE+2=x%X2:1', X
               DEVTTYPE+2
         B     EXITRC12
VOL070   DS    0H
* sloppy compare on device types
         SLR   R1,R1                  Clear
         IC    R1,DEVTTYPE+3          Get device code on SYSUT2
         N     R1,=XL4'0000000F'      only last nibble
         SLL   R1,2                   times 4
         LA    R1,DEVNAMT(R1)         point to device name
         MVC   WORK,0(R1)             get it
         SLR   R1,R1                  Clear
         IC    R1,DSNTDEV+3           Get device code from dump
         N     R1,=XL4'0000000F'      only last nibble
         SLL   R1,2                   times 4
         LA    R1,DEVNAMT(R1)         point to device name
         MVC   WORK2,0(R1)            get it
         CLC   WORK,WORK2             Are device types equal?
         BE    VOL080                 yes, skip
         #MSG  'Warning, SYSUT2 is %S4:4 device but %S:44 resided on a X
               %S4:4, restore may fail',WORK,DSNTDSN,WORK2
         OI    RETCODE,4                                        GP09317
         B     VOL080                 skip
*
VOL075   DS    0H                     Do DYNALLOC stuff
         ST    R5,DYNSP01             Put DSNTAB entry addr in parms
         MVC   DYNSP07,PREFIX         Put HLQ perfix (or blank) in parm
         LA    R1,DYNSUBP             Point to DYNALLO parms
         L     R15,=A(DYNALLO)        Address DYNALLO
         BALR  R14,R15                Invoke DYNALLO
         LTR   R15,R15                All OK?
         BZ    VOL079                 yes, skip
         #MSG  'DYNALLOC failed, SVC99 RC=%D, S99ERROR=%D (x%X8:4)',   X
               DYNSP02,DYNSP03,DYNSP03
         CLC   DYNSP04,=F'0'          Any msgs?
         BNE   VOL076                 Yes, skip
         #MSG  'No error messages were returned by DYNALLO'
         B     VOL078
VOL076   DS    0H
         #MSG  (DYNSP05,133)          Get print buffer          GP09317
         CLC   DYNSP04,=F'1'          More than one message?
         BNH   VOL078                 No, skip
         #MSG  (DYNSP06,133)          Get print buffer          GP09317
VOL078   DS    0H
         #MSG  'Error - unable to open SYSUT2 for EXCP processing,'
         #MSG  'Skipping restore of %S due to DYNALLOC error.',DSNTDSN
         NI    CONTROL,255-CDOREST    Reset DO RESTORE flag
         MVI   RETCODE,8              Set bad RC                GP09317
         BR    R8                     and return
*
VOL079   DS    0H
         MVC   SYSUT2+(DCBDDNAM-IHADCB)(8),DYNSP07 Insert DDNAME we got
*                                     from DYNALLO into SYSUT2 DCB
VOL080   DS    0H
         TM    CONTROL,CDEBUG         Is debug on?
         BNO   VOL110                 no, skip
         #MSG  'Opening SYSUT2 DD statement for restore'
VOL110   DS    0H
         OPEN  (SYSUT2,(OUTPUT))      Now open the DCB
         LA    R1,SYSUT2
         USING IHADCB,R1              and establish addressability
         TM    DCBOFLGS,DCBOFOPN      Did SYSUT2 open OK?
         BO    VOL120                 Yes, skip
         DROP  R1
         #MSG  'Error - unable to open SYSUT2 for EXCP processing,'
         #MSG  'will skip restore of %S',DSNTDSN
         NI    CONTROL,255-CDOREST    Reset DO RESTORE flag
         MVI   RETCODE,8              Set bad RC                GP09317
         BR    R8                     and return
VOL120   DS    0H
         OI    CONTROL,CUT2OPEN       Set flag to show SYSUT2 opened
         NI    CONTROL2,255-CUT2CLOS  Reset flag for SYSUT2 closed
         TM    CONTROL,CDEBUG         Debug active?
         BNOR  R8                     no, just return
         #MSG  'SYSUT2 successfully opened'
         BR    R8                     Return
***********************************************************************
*
*   Process a Data Track segment
*
*   Each track in the dump may span multiple segments.  Whenever there
*   are multiple segs for a trk we run into the situation where DFDSS
*   displaces 16 bytes of data to the end of the track (it looks like
*   DFDSS had done a read-track then just carves this up into segments
*   and displaces 16 bytes as required to make room to insert the
*   segment prefixes - these displaced 16 byte chunks are then added to
*   the end of the original track data).
*
*   When we build our track buffer we will leave 16 byte "holes" when
*   we see the displaced data indicator and keep track of where these
*   holes are so we can relocate the displaced data back into the holes
*
*   Once we have collected all the segments for a track into the
*   track buffer we process the displaced data and move them back to
*   where it should have existed in the track.  Then we run through the
*   track to update the CCHHs in the count fields and build a channel
*   program to write the track out.  The last step is to see if we are
*   really restoring this dataset and issue the EXCP to write the
*   track if so.
*
***********************************************************************
DATATRK  DS    0H
         MVI   STATE,STDATATR+STDATATL Data Trk or Dataset Trailer OK
         TM    CONTROL,CSKIP          Are we processing this one?
         BOR   R8                     no, just exit
* Check the DSSDUMP prefix we saved for this segment to
* see if there was anything we should have been concerned about
         TM    DSSPREFX+(DTPRCFL1-ADRTAPB),255-DTPDDISP Any flags in
*                                     the prefix that we don't know
*                                     how to handle?
         BZ    DAT005                 No, skip
         #MSG  'WARNING - unknown DTPRCFL1 flags x%X2:1 in data track sX
               egment, ignored,',DSSPREFX+(DTPRCFL1-ADRTAPB)
         #MSG  '          dataset %S:44, UT1BLK %D',DSNTDSN,UT1NBLKS
         OI    RETCODE,4                                        GP09317
DAT005   DS    0H
*
* *
* * For first seg of this track check the track segment headers for
* * bad stuff then initialise displaced data indicators
* * and clear counters etc to receive full track image. For subsequent
* * segments check for and save info about displaced data indicators.
* * (It would seem any segment following the first will have the
* * displaced data indicator set)
* *
*
         CLC   DSSTRKSG,=F'0'         Is this the first track segment?
         BNE   DAT010                 No, subsequent track seg, skip
*
* * Check the Track Indicators to see if we should warn about any
* * irregularities
*
         CLC   DSSPREFX+(DTPSEGNO-ADRTAPB)(1),=X'01' Is this segment #1
*                                     for this track?
         BE    DAT0502                yes, skip
         #MSG  'Warning, expecting segment #1 for track %D but go seg xX
               %X2:1 (%S:44)',DSNTTRKC,DSSPREFX+(DTPSEGNO-ADRTAPB),    X
               DSNTDSN
         OI    RETCODE,4                                        GP09317
DAT0502  DS    0H
         XC    DSSTRKNS,DSSTRKNS
         MVC   DSSTRKNS+3(1),DSSPREFX+(DTPNOSEG-ADRTAPB) # segments to
*                                     expect for this track
         TM    DTTTRKID,DTTIOER       I/O error occurred on this track?
         BNO   DAT0505                no, skip
         #MSG  'Warning - Track header has I/O error indicator, TRK %D,X
               DSN %S:44',DSNTTRKC,DSNTDSN
         OI    RETCODE,4                                        GP09317
DAT0505  DS    0H
         TM    DTTTRKID,DTTTROVF      Is track overflow set?
         BNO   DAT0515                no, skip
         #MSG  'Warning - Track header says last rec on trk is overflowX
                record, TRK=%D, DSN %S:44',DSNTTRKC,DSNTDSN
         OI    RETCODE,4                                        GP09317
DAT0515  DS    0H
         TM    DTTTRKID,DTTVFRST      First VVDS record?
         BNO   DAT0520                no, skip
         #MSG  'Warning - Track header has first VVDSrec bit on,TRK %D,X
                DSN %S:44',DSNTTRKC,DSNTDSN
         OI    RETCODE,4                                        GP09317
DAT0520  DS    0H
         TM    DTTTRKID,DTTINVT       Invalid track format bit set?
         BNO   DAT0525                no, skip
         #MSG  'Warning - Track header has invalid track format bit setX
                for TRK %D, DSN %S:44',DSNTTRKC,DSNTDSN
         OI    RETCODE,4                                        GP09317
DAT0525  DS    0H
         TM    DTTTRKID,DTTSTAT       User statistical record (huh!)?
         BNO   DAT0530                no, skip
         #MSG  'Warning - Track header has user stat rec bit on TRK %D,X
                DSN %S:44',DSNTTRKC,DSNTDSN
         OI    RETCODE,4                                        GP09317
DAT0530  DS    0H
         CLI   DSSPREFX+(DTPRCFL1-ADRTAPB),X'00' Were any flags set in
*                                     the segment prefix?
         BE    DAT0535                No, skip
         #MSG  'Warning, unknown DTPRCFL1 flgs = x%X2:1 on trk %D, DSN X
               %S:44',DSSPREFX+(DTPRCFL1-ADRTAPB),DSNTTRKC,DSNTDSN
         OI    RETCODE,4                                        GP09317
DAT0535  DS    0H
         MVC   DSSTRKSG,=F'1'         Indicate first track segment
         XC    DSSTRKDC,DSSTRKDC      Clear track data counter
         L     R1,DSNTTRKC            Bump track counter
         LA    R1,1(,R1)
         ST    R1,DSNTTRKC
         XC    DSSDISPF,DSSDISPF      clear displaced data indicators
         XC    DSSTRKLN,DSSTRKLN      clear track length
         MVC   DSSTRKLN+2(2),DTTTRKLN Track length
         TM    CONTROL,CDEBU2         Debug on?
         BNO   DAT0540                no, skip
         #MSG  'TRACK len=%D,seg len=%D,flgs=x%X2:1,CCHH=x%X8:4,R0=x%X8X
               :4 %X8:4,#segs=%D',                                     X
               DSSTRKLN,DSSSEGLN,DTTTRKID,DTTCCHH,DTTR0DAT,DTTR0DAT+4, X
               DSSTRKNS
DAT0540  DS    0H
         NI    CONTROL2,255-CTRKCOMP  Assume no compression
         TM    DTTTRKID,DTTTCMP       Is track compressed?
         BNO   DAT0545                no, skip
         OI    CONTROL2,CTRKCOMP      yes, note this fact
         TM    CONTROL,CDEBU2         Verbose?
         BNO   DAT0545                nope, skip
         #MSG  'Note: This track image is compressed'
DAT0545  DS    0H
         LA    R2,DTTR0DAT            Point to start of the data (R0)
         L     R3,DSSSEGLN            Get segment length
         SH    R3,=H'32'              minus seg prefix & trk prefix
         L     R6,UT2BUFFA            Initialise track buffer ptr
         B     DAT020                 Skip to common code
*
* * do setup on track segments 2 and up - check segment # x of y for
* * this track segment to see if they are valid
*
DAT010   DS    0H
         L     R1,DSSTRKSG            no, bump segment count
         LA    R1,1(,R1)
         ST    R1,DSSTRKSG
         CLC   DSSTRKSG+3(1),DSSPREFX+(DTPSEGNO-ADRTAPB) Is this the
*                                     correct segment number?
         BE    DAT012                 yes, skip
         #MSG  'Logic error in dump, segment seq err on trk %D, ExpecteX
               d x%X2:1, got x%X2:1 in DTPSEGNO',DSNTTRKC,DSSTRKSG+3,DSX
               SPREFX+(DTPSEGNO-ADRTAPB)
         #MSG  '    DSN %S:44, UT1 blk %D',DSNTDSN,UT1NBLKS     GP09317
         B     EXITRC12
DAT012   DS    0H
*
* * Check the saved DSSDUMP prefix for displaced track data now and
* * leave a "hole" in track buffer if there were data displaced
*
         TM    DSSPREFX+(DTPRCFL1-ADRTAPB),DTPDDISP   Are any data
*                                     displaced to end of track?
         BNO   DAT015                 no, skip
         BCTR  R1,0                   yes,make seg num relative to zero
         LA    R15,DSSDISPF(R1)       and point to flag for this seg
         MVI   0(R15),X'FF'           indicate displaced data on trk
         SLL   R1,2                   multiply (seg # - 1) by 4
         ST    R6,DSSDISPP(R1)        save ptr in trk buf for disp data
         LA    R6,16(,R6)             skip forward in trk buffer
DAT015   DS    0H
*                                     R6 points to dest in trk buff
         LA    R2,DTTTRK              point to start of data
         L     R3,DSSSEGLN            get segment length
         SH    R3,=H'16'              minus trk record prefix length
*
* * Common code for all track segments, accumulate the data in the
* * track buffer until we have all the segments for this track.
*
DAT020   DS    0H
         LR    R0,R6                  Copy track buff ptr
         LR    R1,R3                  Copy length to move
         LR    R14,R3                 Save a copy of the length
         MVCL  R0,R2                  Move track data to buffer
         LR    R6,R0                  Copy updated destination address
         A     R14,DSSTRKDC           Update track data counter
         ST    R14,DSSTRKDC
         TM    CONTROL,CDEBU2         Is debug on?
         BNO   DAT025                 no, skip
         #MSG  'Moved track data, hdr trk len=%D,moved len=%D,trk=%D,UTX
               1blk=%D',DSSTRKLN,DSSTRKDC,DSNTTRKC,UT1NBLKS
DAT025   DS    0H
         CLC   DSSTRKNS+3(1),DSSPREFX+(DTPSEGNO-ADRTAPB) Is this the
*                                     last segment for the track
         BNH   DAT027                 probably, skip
*        #MSG  'getting another segment for this track'
         BR    R8                     Go get another segment
DAT027   DS    0H
         CLC   DSSTRKNS+3(1),DSSPREFX+(DTPSEGNO-ADRTAPB) Is this the
*                                     segment we expected?
         BE    DAT029                 yep, skip
         #MSG  'Logic error, only expected %D segments for trk %D but gX
               ot x%X2:1 segments',DSSTRKNS,DSNTTRKC,                  X
               DSSPREFX+(DTPSEGNO-ADRTAPB)
         #MSG  '    DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         B     EXITRC12
DAT029   DS    0H
         CLC   DSSTRKDC,DSSTRKLN      Have I got the all the data?
         BE    DAT030                 Yes
         BH    DAT050                 More, bad, see if we can fix it
*                                       (see if known anomaly).
*                                     Less, thats an error
         #MSG  'Logic error - expected %D bytes for trk %D but only gotX
                %D',DSSTRKLN,DSNTTRKC,DSSTRKDC
         #MSG  '    DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         B     EXITRC12
*
* * I have all the segs for this track, process displaced data (if any)
*
DAT030   DS    0H
*        #MSG  'got exactly the trk data length I needed'
DAT031   DS    0H     Retry after getting too much data
         CLC   DSSDISPF,=XL24'00'     Any displacement flgs
         BE    DAT100                 no, skip
         TM    CONTROL,CDEBU2         Is debug on?
         BNO   DAT032                 no, skip
         #MSG  'processing displaced track data'
         LR    R1,R6
         S     R1,UT2BUFFA
         ST    R1,WORK
         #MSG  'Buffer length=%D, DISP FLGS=%X8:4 %X8:4 %X8:4 %X8:4 %X8X
               :4 %X8:4',WORK,DSSDISPF,DSSDISPF+4,DSSDISPF+8,DSSDISPF+1X
               2,DSSDISPF+16,DSSDISPF+20
DAT032   DS    0H
         LA    R1,24                  R1 will step thru disp flags
         LA    R2,DSSDISPP+(23*4)     R2-> last disp data pointer
DAT035   DS    0H
         LA    R15,DSSDISPF-1(R1)     Address flag
         CLI   0(R15),X'00'           Is it set?
         BE    DAT040                 no, skip
         L     R15,0(,R2)             yes, get destination address
         SH    R6,=H'16'              point to last displaced data
         MVC   0(16,R15),0(R6)        replace displaced data
***debug
*        MVC   DBLWRD,0(R6)
*        ST    R1,WORK
*        ST    R2,WORK2
*        #MSG  'moved displaced data %S8:8',DBLWRD
*        L     R1,WORK
*        L     R2,WORK2
***debug
DAT040   DS    0H
         SH    R2,=H'4'               previous displaced data ptr
         BCT   R1,DAT035              check all displacement flags
*
* * Done processing displaced data, see if track looks OK
*
         S     R6,UT2BUFFA            R6=length of track data now
         ST    R6,WORK                save temp
         C     R6,DSSTRKLN            is this the length I expected
         BE    DAT100                 yes, skip to write
         #MSG  'Logic error, processed data displacements and got a badX
                track data length after,'
         #MSG  'track # %D, expected trk len=%D but got len=%D',DSNTTRKX
               C,DSSTRKLN,WORK
         #MSG  '  DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         B     EXITRC12
*
DAT050   DS    0H
*
* * got more track data than track length indicated, this can happen
* * when only a small amount of data remain for the track.  DFDSS
* * appears to dislike writing less than a 32 byte block so we have to
* * fix this up if that appears to be the case.
* *
* * To fix it, we will pretend the displaced data flag was not set on
* * this segment and shift the data for this segment 16 bytes left
* * in the input buffer.  Then we compute how much data there really
* * were in this last segment (should be from 1 to 15 bytes) and adjust
* * the input buffer ptr (R6) so it points just past the last valid
* * byte of data.  Then we force the track data counter DSSTRKDC
* * to be equal to the expected length DSSTRKLN.
* *
*
         TM    DSSPREFX+(DTPRCFL1-ADRTAPB),DTPDDISP Was the displaced
*                                     data flag on this segment
         BNO   DAT060                 No, then I don't know whats wrong
         CLC   DSSSEGLN,=F'32'        Segment greater than 32 bytes?
         BH    DAT060                 yep, that looks like an error
         L     R1,DSSTRKDC            get our data count
         S     R1,DSSTRKLN            minus expected data length
         ST    R1,WORK                save the difference
         TM    CONTROL,CDEBU2         Is debug on?
         BNO   DAT055                 no, skip
         #MSG  'Logic Note - Recovering from short track data segment, X
               trk # %D, len %D, dropped %D bytes',                    X
               DSNTTRKC,DSSTRKLN,WORK
DAT055   DS    0H
         L     R1,DSSTRKSG            Get this segment number
         BCTR  R1,0                   make it relative to zero
         LA    R15,DSSDISPF(R1)       Point to displaced flag for seg
         MVI   0(R15),X'00'           and reset that flag.
         SH    R6,=H'32'              Move pointer back to where the
*                                     reserved space for restoring
*                                     displaced data for this segment
*                                     are in the buffer
         MVC   0(16,R6),16(R6)        Shift the data back in the buff
         LA    R6,16(,R6)             Point past the 16 shifted bytes
         S     R6,WORK                drop the excess data from buff
         MVC   DSSTRKDC,DSSTRKLN      Force data count = trk leng
         B     DAT031                 and retry the operation
DAT060   DS    0H
         #MSG  'Logic Error - I got too much track data, wanted %D got X
               %D, trk # %D',DSSTRKLN,DSSTRKDC,DSNTTRKC         GP09317
         #MSG  '   DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         B     EXITRC12
*
* * Ready to write the track out now.
* *
* * Well, almost ready, do the decompress of the track image first
* *
* * If we are restoring this one, convert the track number to an
* * actual MBBCCHHR, if not restoring just skip the convert.
* * Next we go through all the blocks in this track and update
* * all the count fields with the target CCHH; while
* * we are doing that, validate the R in the count fields and build
* * up the channel program.  At the last minute, check if we are
* * actually doing the restore and issue the EXCP if so.
*
DAT100   DS    0H
         XC    DSSTRKSG,DSSTRKSG      Clear out track segment counter
*                                     because we expect a track header
*                                     to be found next
*
         TM    CONTROL,CDOREST        Are we restoring this one?
         BNO   DAT115                 No, skip the convert rtn
         STM   R1,R14,12(R13)         Save regs before doing convert
         L     R0,DSNTTRKC            Get track number
         SH    R0,=H'1'               minus 1 to make it relative
         SLL   R0,16                  Now R0 is TTRZ for convert rtn
         ST    R0,WORK                debug move
         L     R1,SYSUT2+(DCBDEBAD-IHADCB) Point to DEB
         LA    R2,MBBCCHHR            Output Area
         LR    R3,R13                 Remember R13
         L     R15,CVTPTR             Get CVT Addr
         L     R15,CVTPCNVT-CVTMAP(,R15)  TTR -> MBCCHHR        GP09317
         BALR  R14,R15                Invoke convert routine
         LM    R1,R14,12(R3)          Restore regs after convert
         LTR   R15,R15                Converted OK?
         BZ    DAT110                 Yes, skip
         ST    R15,WORK               No, may be error, save code
         CLC   WORK,=F'4'             was it RC 4
         BNE   DAT105                 no, problem then
         #MSG  'Invoking EOV to get another extent on SYSUT2'
         EOV   SYSUT2
         B     DAT100
DAT105   DS    0H
         #MSG  'Convert routine failed, RC=%D.,TRK=%D',WORK,DSNTTRKC
         #MSG  '   DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         B     EXITRC12               get out
*
DAT110   DS    0H
         TM    CONTROL,CDEBU2         Is debug on?
         BNO   DAT115                 no, skip
         #MSG  'Converted TTRZ %X8:4 to Seek Addr=%X8:4 %X8:4.',WORK,MBX
               BCCHHR,MBBCCHHR+4
DAT115   DS    0H
         TM    CONTROL2,CTRKCOMP      Is track image compressed?
         BNO   DAT1159                Nope, skip
         L     R0,DCOMPBUF            * Move the entire
         L     R1,DSSTRKLN            *     track buffer
         LR    R3,R1                  *       to the
         L     R2,UT2BUFFA            *         input area for
         MVCL  R0,R2                  *           decompress rtn
         MVC   DCOMPOUT,UT2BUFFA      Put decomp O/P area addr in parms
         MVC   DCOMPILN,DSSTRKLN      Put I/P leng in parms
         MVC   DCOMPOLN,=F'65536'     Put O/P buff leng in parms
         L     R15,=A(ADRDCOMP)       Point to decompress rtn
         LA    R1,DCOMPARM            Point to parm list
         BALR  R14,R15                Do the decompress into trackbuff
         LTR   R15,R15                All OK?
         BZ    DAT1155                Yep, skip
         #MSG  'Error - Bad RC from ADRDCOMP decompress routine'
         B     EXITRC16
DAT1155  DS    0H
         MVC   DSSTRKLN,DCOMPOLN      Update uncompressed track leng
         TM    CONTROL,CDEBU2         Verbose?
         BNO   DAT1159                nope, skip
         #MSG  'Decompressed, ILEN=%D,OLEN=%D',DCOMPILN,DCOMPOLN
DAT1159  DS    0H
*
* * go thru track buffer and update CCHHR in count fields, update
* * CCW data address, length and chaining flags in channel pgm
*
         L     R6,UT2BUFFA            R6 will scan track buffer
         CLC   0(8,R6),=XL8'00'       Is R0 data field zeros ?
         BE    DAT120                 yep, skip
         MVC   DBLWRD,0(R6)           no, save in case we issue msg
         TM    CONTROL,CDEBU2         Is debug on?
         BNO   DAT117                 no, skip
         #MSG  'Warning, Trk %D contains non-zero Record Zero data x%X8X
               :4 %X8:4',DSNTTRKC,DBLWRD,DBLWRD+4
DAT117   DS    0H
         L     R1,DSSNR0NZ            Bump non-zero
         LA    R1,1(,R1)                R0
         ST    R1,DSSNR0NZ                counter.
         OI    DSNTFLGS,DSNTFR0N      Flag fact it was found
         OI    RETCODE,4                                        GP09317
DAT120   DS    0H
         LA    R1,1                   R1 will be R (record number)
         LA    R6,8(,R6)              Point past R0 data
         LA    R2,8                   Amount of trk data processed
         LA    R3,BLK1                R3 will address CCWs
DAT130   DS    0H
         C     R2,DSSTRKLN            done track?
         BE    DAT200                 yep, skip to EXCP
         BL    DAT140                 nope,go insert CCHHR in count fld
         ST    R2,WORK                save calc leng for msg
         #MSG  'Logic error- too much data in trk image, key+data lengtX
               hs may be bad, Trk %D got %D wanted %D',DSNTTRKC,WORK,DSX
               STRKLN
         #MSG  '   DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         B     EXITRC12
DAT140   DS    0H
         SLR   R14,R14                key length
         SLR   R15,R15                data length
         IC    R14,5(,R6)             pick up key length
         ICM   R15,B'0011',6(R6)      and data length
         MVC   0(4,R6),MBBCCHHR+3     put CCHH in count field
         STC   R1,WORK                save my R count
         CLC   WORK(1),4(R6)          is it the same as R in the dump?
         BE    DAT145                 yep, skip
         MVC   WORK+1(1),4(R6)        nope, save old for msg
         STM   R1,R2,DBLWRD           save while writing message
         #MSG  'Warning, in dump CCHHR, R was x%X2:1 but I computed x%XX
               2:1 and will force that value',WORK+1,WORK
         #MSG  '   DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         LM    R1,R2,DBLWRD           restore
         OI    RETCODE,4                                        GP09317
         MVC   4(1,R6),WORK           force R in count field
*
* * build the channel program
*
DAT145   DS    0H
         MVI   0(R3),X'1D'            Write CKD cmd code
         STCM  R6,B'0111',1(R3)       data address
         MVI   4(R3),X'40'            command chaining flag
         LA    R0,8(R14,R15)          data length for CCW
         STCM  R0,B'0011',6(R3)       put data length in CCW
         ST    R0,WORK                save in case we're debugging
         AR    R6,R0                  update track buffer scan
         AR    R2,R0                  update leng of data processed
         LA    R3,8(,R3)              point to next CCW
         TM    CONTROL,CDEBU2         Is debug mode on?
         BNO   DAT150                 no, skip
         STM   R1,R2,DBLWRD           save regs
         #MSG  'TRK %D, BLK %D, CCW data leng (Count+Key+Data) %D, LengX
               th processed so far %D',DSNTTRKC,DBLWRD,WORK,DBLWRD+4
         LM    R1,R2,DBLWRD           restore regs
DAT150   DS    0H
         LA    R1,1(,R1)              bump record number
         B     DAT130                 go see if more data to process
*
* * channel pgm complete, append a no-op to it and do EXCP
*
DAT200   DS    0H
         MVI   0(R3),X'03'            no-operation cmd code
         MVC   1(7,R3),=XL7'00000020000001' SLI set + leng=1
*                                     Some DASD control units give a
*                                     chan pgm check if leng=0 for NOOP
         BCTR  R1,0                   get actual record count
         ST    R1,WORK                Save for debug/msg code
         TM    CONTROL,CDEBU2         Is debug mode on?
         BNO   DAT202                 no, skip
         #MSG  'Track prep done, %D records to write in track %D',WORK,X
               DSNTTRKC
DAT202   DS    0H
*
* * If there were no records to write, just write an EOF mark on trk
*
         CLC   WORK,=F'0'             Any records to write on track?
         BNZ   DAT205                 yes, skip
         TM    CONTROL,CDEBU2         Is debug mode on?
         BNO   DAT203                 no, skip
         #MSG  'Inserting EOF CCW, TRK %D',DSNTTRKC
DAT203   DS    0H
*                                     CCW PTR is at the no-op now
         MVI   0(R3),X'1D'            Write CKD command code
         LA    R1,0(,R6)              Data address (use track buffer)
         STCM  R1,B'0111',1(R3)       put in CCW
         MVC   4(4,R3),=X'00000008'   flags (00) and leng=8
         MVC   0(4,R6),MBBCCHHR+3     put CCHH in count field
         MVC   4(4,R6),=XL4'01000000' R=01 K=00 and L=0000
DAT205   DS    0H
* dump channel pgm and data areas
         B     DATENDD                Skip over channel pgm dump
*                                     Zap it to dump chan pgm
         L     R3,WORK
         LA    R3,3(,R3)              R3=# of CCWs to dump
         LA    R7,WRITE               R7 will address them
DAT210   DS    0H
         MVC   DBLWRD,0(R7)
         #MSG  'CCW OP=%X2:1 ADDR=%X6:3 FLAG=%X2:1 LEN=%X4:2',DBLWRD,DBX
               LWRD+1,DBLWRD+4,DBLWRD+6
         C     R7,=A(BLK1)
         BL    DAT220
         USING DUMMY,R2
         L     R2,0(,R7)
         #MSG  '   (CCHH %X8:4 R %X2:1 K %X2:1 L %X4:2 DAT=.%S32:32.',DX
               ,D+4,D+5,D+6,D+8
         DROP  R2
DAT220   DS    0H
         LA    R7,8(,R7)
         BCT   R3,DAT210
DATENDD  DS    0H
*---------------------------------------------------------------------*
*   N.B.: I changed the code to process LABEL=SUL, only to find that  *
*   it won't work. OPEN writes a label track, but doesn't include it  *
*   in the DEB extents. So I added the following bypass, and changed  *
*   DOJCL =SUL to a comment. If this program ever gets support for    *
*   running with authorization, the code should be changed to get the *
*   correct extent (DSCB1?), clobber the DEB, and write the labels. GP*
*---------------------------------------------------------------------*
         TM    DSNTFLGS,DSNTFSUL      User label track ?        GP09317
         BZ    DAT801                 No, process               GP09317
         L     R0,DSNTTRKC            Get track number          GP09317
         SH    R0,=H'1'               minus 1                   GP09317
         ST    R0,DSNTTRKC            fix track number          GP09317
         NI    DSNTFLGS,255-DSNTFSUL  No more                   GP09317
         BR    R8                     Just ignore it            GP09317
*** end of channel pgm dump
*
* * Write out the track if we're restoring the dataset
*
DAT801   TM    CONTROL,CDOREST        Are we restoring this one?
         BNOR  R8                     No, just exit now
         LA    R3,UT2IOB
         USING IOBSTDRD,R3            Using std section of IOB
         OI    IOBFLAG1,IOBCMDCH      Command chaining used
         OI    IOBFLAG1,IOBUNREL      IOB unrelated flg (I.E. non-seq)
         MVC   IOBECBPB,=AL3(UT2ECB)  ECB addr
         MVC   IOBDCBPB,=AL3(SYSUT2)  DCB Addr
         MVC   IOBSEEK,MBBCCHHR       Seek address
         MVC   IOBSTRTB,=AL3(WRITE)   Select a channel program
         EXCP  UT2IOB
         WAIT  ECB=UT2ECB
         CLI   UT2ECB,X'7F'           Was the write successful?
         BE    DAT225                 yes, skip
         #MSG  'Error writing track, ECB=%X8:4.',UT2ECB
         #MSG  'IOBSENS=%X2:1 %X2:1.',IOBSENS0,IOBSENS1
         #MSG  'IOBCSW =%X6:3 %X4:2 %X4:2.',IOBCSW,IOBCSW+3,IOBCSW+5
         #MSG  'DSN %S:44, UT1blk %D',DSNTDSN,UT1NBLKS
         DROP  R3
         B     EXITRC12
DAT225   DS    0H
         BR    R8
***********************************************************************
*
*   Process Dataset Trailer segment
*
*   If we were processing this dataset, indicate how many track images
*   we went through.  If SYSUT2 was open then we have to update the
*   DCB with MBBCCHHR of the last block used in the dataset.  To do
*   this, we get the hi used TTR we saved from FMT1DSCB and run it
*   through the convert routine to get the MBBCCHHR to put in the DCB
*   and we insert saved track balance we got from the FMT1DSCB into DCB
*
***********************************************************************
DSTRAIL  DS    0H
         TM    STATE,STDATAT2         Did I just hit a DS trailer
         BNO   DST005                 no, skip
         MVI   STATE,STEOF+STDSHDR    yes, Reset state indicators
         BR    R8                     and just exit
DST005   DS    0H
         MVI   STATE,STDATATL+STDATAT2 Reset state indicators, we
*                                     insist on a second DS trailer
         TM    CONTROL,CSKIP          Did we process this dataset?
         BNO   DST007                 yep, skip
         OI    DSNTFLGS,DSNTFSKP      no, indicate it was skipped
         BR    R8                     and just exit
DST007   DS    0H
         TM    CONTROL,CDEBUG         Verbose?
         BNO   DST008                 nope, skip
         #MSG  '%D track images in dump for %S:44',DSNTTRKC,DSNTDSN
DST008   CLC   DSSNR0NZ,=F'0'         Any non-zero R0's?
         BE    DST010                 no, skip
         #MSG  'Warning, %D tracks had non-zero record zero data for %SX
               44:44',DSSNR0NZ,DSNTDSN
         OI    RETCODE,4                                        GP09317
DST010   DS    0H
         TM    CONTROL,CUT2OPEN       Is SYSUT2 open?
         BNOR  R8                     no, just exit
*
* * update DCB fields to have the correct DS1LSTAR and DS1TRBAL set
* * in the FMT1 DSCB for the dataset when we close the output
*
         STM   R1,R14,12(R13)         Save regs before doing convert
         SLR   R0,R0                  Set R0 to TTRZ for last TTR used
         ICM   R0,B'1110',DSNTHTTR    insert saved TTR from FMT1 DSCB
         ST    R0,WORK                debug move
         L     R1,SYSUT2+(DCBDEBAD-IHADCB) Point to DEB
         LA    R2,MBBCCHHR            Output Area
         LR    R3,R13                 Remember R13
         L     R15,CVTPTR             Get CVT Addr
         L     R15,CVTPCNVT-CVTMAP(,R15)  TTR -> MBCCHHR        GP09317
         BALR  R14,R15                Invoke convert routine
         LM    R1,R14,12(R3)          Restore regs after convert
         LTR   R15,R15                Converted OK?
         BZ    DST020                 Yes, skip
         ST    R15,WORK               No, may be error, save code
         #MSG  'EOF Convert rtn failed RC=%D.,TTR=x%X4:2',WORK,DSNTHTTR
         #MSG  'while restoring %S:44',DSNTDSN
         B     EXITRC12               get out
*
DST020   DS    0H
         TM    CONTROL,CDEBUG         Is debug mode on?
         BNO   DST025                 no, skip
         #MSG  'EOF Convrt TTRZ %X8:4 to MBBCCHHR=%X8:4 %X8:4.',WORK,MBX
               BCCHHR,MBBCCHHR+4
DST025   DS    0H
         LA    R1,SYSUT2
         USING IHADCB,R1
         MVC   DCBFDAD,MBBCCHHR       Put in MBBCCHH that I computed
         MVC   DCBTRBAL,DSNTTBAL      Add in track balance from the
*                                     FMT1 DSCB (because I am too lazy
*                                     to do all the TRKCALCs needed to
*                                     compute this myself)
         DROP  R1
         CLOSE (SYSUT2,FREE)          Close and free that puppy GP11322
         NI    CONTROL,255-CUT2OPEN   And say we did so
         OI    CONTROL2,CUT2CLOS      Indicate successfully closed
         OI    DSNTFLGS,DSNTFROK      Flag in table as well
         #MSG  'Dataset %S:44 has been successfully restored to SYSUT2,X
                %D tracks written',DSNTDSN,DSNTTRKC
         BR    R8
***********************************************************************
*
* * EODAD routine for SYSUT1 - triggered by issuance of EOV macro
* * in GETDATA routine if this was the last volume on SYSUT1.
*
***********************************************************************
UT1EODAD DS    0H
         #MSG  ' '
         #MSG  'End of file reached on SYSUT1'
         TM    STATE,STEOF            Was it OK to hit EOF?
         BO    EXIT                   Yes, just exit
         #MSG  'ERROR, unexpected SYSUT1 EOF, the backup file is eitherX
                corrupted,'
         #MSG  'is incomplete or there has been a pgm logic error.'
         MVI   RETCODE,16                                       GP09317
         B     EXIT
***********************************************************************
*
* * normal program exit, print out counts
*
***********************************************************************
EXIT     CLC   RETC,=F'4'             Check return code
         BH    EXIT1                  bad, skip
         #MSG  'Program ending normally.'
EXITA    DS    0H
         #MSG  ' '
         LM    R6,R7,UT1BYTES         compute Kbytes read
         A     R7,=F'512'             round to nearest K
         BNO   *+8
         LA    R6,1(,R6)
         D     R6,=F'1024'
         ST    R7,WORK
         #MSG  '%D blocks (%D:4 KBytes) read from input DFDSS dump.',  X
               UT1NBLKS,WORK
         B     EXIT2
EXITRC16 DS    0H
         MVI   RETCODE,16                                       GP09317
         B     EXIT1
EXITRC12 MVI   RETCODE,12                                       GP09317
EXIT1    DS    0H
         #MSG  'Terminating due to error.'
EXIT2    DS    0H
         TM    CONTROL,CUT2OPEN        Is SYSUT2 open?
         BNO   EXIT4                   no, skip
         #MSG  'Warning, SYSUT2 was left open, closing it (poorly) now'
         CLOSE (SYSUT2)
EXIT4    DS    0H
         TM    CONTROL,CREST           Was this a restore run?
         BNO   EXIT4A                  no, skip
         TM    CONTROL2,CUT2CLOS       Did we fully process restore
         BO    EXIT4A                  yes, skip
         #MSG  'Error - dataset %S:44 was not successfully restored',DSX
               N
         MVI   RETCODE,16                                       GP09317
EXIT4A   DS    0H
         TM    CONTROL,CUT1OPEN        Is SYSUT1 open?
         BNO   EXIT5                   no, skip
         CLOSE (SYSUT1)
EXIT5    DS    0H
         BAL   R8,FMTTIME
         #MSG  ' '
         #MSG  'Ending at %S17:17.',TIMEFMT
         CLOSE (SYSPRINT)
         FREEPOOL SYSPRINT                                      GP09317
         BAL   R8,REPORT               Go print the DSN table
         L     R15,=A(DOJCL)           point to JCL dump rtn
         BALR  R8,R15                  Go dump sample JCL
*
EXITX    L     R15,RETC
         L     R13,SAVEAREA+4
         RETURN (14,12),T,RC=(15)     RETURN
*
**********************************************************************
*                                                                    *
* REPORT - Check if the REPORT DD statement is there and if so       *
*          dump all entries we have in the DSN table in a hopefully  *
*          human readable format.                                    *
*                                                                    *
*          Note: we re-use the SYSPRINT DCB and just change the      *
*                DDNAME in order to use #MSG and MSG#RTN             *
*                                                                    *
*          no input args,                                            *
*          Return via R8                                             *
*                                                                    *
**********************************************************************
REPORT   LA    R7,SYSPRINT                                      GP09317
         USING IHADCB,R7                                        GP09317
         SR    R0,R0                                            GP09317
         STC   R0,DCBRECFM            Clear SYSPRINT info       GP09317
         STH   R0,DCBLRECL                                      GP09317
         STH   R0,DCBBLKSI                                      GP09317
         MVC   DCBDDNAM,=CL8'REPORT'  Change DDNAME             GP09317
         OPEN  (SYSPRINT,(OUTPUT))
         TM    DCBOFLGS,DCBOFOPN      Did SYSPRINT open OK?
         BO    REP010                 Yes, skip
         DROP  R7
         WTO   'DSSREST - No REPORT DD statement, report not generated'X
               ,ROUTCDE=11
         BR    R8                     Just forget about it
*OLD*    B     REPXIT                 No SYSPRINT, end with bad RC
REP010   DS    0H
         #MSG  'DSSREST - Summary of dump file contents'
         #MSG  '---------------------------------------'
         #MSG  ' '
         L     R7,DSSNFILE            Get number of files in table
         LTR   R7,R7                  Any?
         BNZ   REP020                 yep, skip
         #MSG  'There are no dataset entries available to be printed'
         B     REPXIT                 skip to exit
REP020   DS    0H
         #MSG  'DFDSS dump header indicated there are %D datasets in thX
               e dump',DSSNFILE
         #MSG  ' '
         #MSG  '#ofTrks DS                      Key  RKP Opt HiUsed TraX
               ck  Creation  Expiry  LastUsed #of        Device PrimaryX
                  Secondary Restore'                            GP09317
         #MSG  'in dump Org Recfm  Lrecl  Blksz Len  RKP CD  TTR    BalX
               nce Date      Date    Date     Ext VolSer Type   AllocatX
               ed Alloc.    Status'                             GP09317
         #MSG  '------- --- -----  -----  ----- --- ---- --- ------ ---X
               --- -------- -------- -------- --- ------ ------ -------X
               -- --------- -------'                            GP09317
         #MSG  ' '
         L     R5,DSNTABA             Point to first DSN table entry
REP050   DS    0H
         TM    DSNTFLGS,DSNTFFND      Did we find this dataset in dump?
         BO    REP051                 yes, skip
         #MSG  '%S44:44 (not found, was in dump directory but was not fX
               ound in dump)',DSNTDSN
         B     REP070                 Don't print details line
REP051   DS    0H
         TM    DSNTFLGS,DSNTFSKP      Did we skip this dataset?
         BNO   REP058                 no, print details
         MVC   CL24,=CL24'but do not know why!)' Default skip reason
         CLC   DSNTDSOR,=CL3'VS '     VSAM?
         BNE   REP052                 nope, skip
         MVC   CL24,=CL24'VSAM dataset)'
         B     REP057                 skip to print
REP052   DS    0H
         CLC   DSNTDSOR,=CL3'EF '     extended format (HFS, etc)
         BNE   REP053                 nope, skip
         MVC   CL24,=CL24'Extended Format dataset)'
         B     REP057                 skip to print
REP053   DS    0H
         CLC   DSNTDSOR,=CL3'?? '     Unknown?
         BNE   REP054                 nope, skip
         MVC   CL24,=CL24'unknown DSORG)'
         B     REP057                 skip to print
REP054   DS    0H
         CLC   DSNTDSOR,=CL3'AIX'     AIX + part of sphere?
         BNE   REP055                 nope, skip
         MVC   CL24,=CL24'AIX + sphere dataset)'
         B     REP057                 skip to print
REP055   DS    0H
         CLC   DSNTDSOR,=CL3'VAL'     VSAM validate stuff?
         BNE   REP057                 nope, keep the default msg
         MVC   CL24,=CL24'VSAM validate indicated)'
REP057   DS    0H
         #MSG  '%S44:44 (skipped, %S24:24',DSNTDSN,CL24
         B     REP070                 Don't print details line
REP058   DS    0H
         #MSG  '%S44:44',DSNTDSN      Put out dataset name line
         ICM   R0,B'0111',DSNTCRDT    Creation date             GP09317
         BAL   R14,FMTDSDAT           format it
         MVC   CL24(8),DBLWRD         save it
         ICM   R0,B'0111',DSNTEXPD    Expiration date           GP09317
         BAL   R14,FMTDSDAT           format it
         MVC   CL24+8(8),DBLWRD       save it
         ICM   R0,B'0111',DSNTLUDT    Last Referenced Date      GP09317
         BAL   R14,FMTDSDAT           format it
         MVC   CL24+16(8),DBLWRD      save it
*
         MVC   TIMEFMT(3),=C'Trk'     Use this fld to assume TRK
         MVC   WORK,DSNTPTRK          get number of tracks
         TM    DSNTFLGS,DSNTFCYL      is it cyls?
         BNO   REP060                 no, skip
         MVC   TIMEFMT(3),=C'Cyl'     yes, say cylinders
         SLR   R0,R0
         L     R1,WORK                get R0,R1=#tracks
         CLC   DSNTTRCY,=XL2'00'      avoid 0C9 (improbable)
         BE    REP060                 skip on zero
         XC    WORK2,WORK2            clear fullword
         MVC   WORK2+2(2),DSNTTRCY    # tracks per cyl
         D     R0,WORK2               R1=# cyls
         ST    R1,WORK                replace track count
REP060   DS    0H
*
* * try to format out secondary space alloc
* *     as 132,000XXX there XXX=Trk, Cyl, Blk (for average blk)
* * if we run into any trouble, just let XXX=???
* * Note: not attempt is made to print out DS1SCXTV and secondary
* *       allocation quantity will be wrong if its greater than 999,999
*
         MVC   WORK2(3),BLANKS        Default no secondary spc  GP09317
         CLC   DSNTSAL3,=XL3'00'      Is there a value there?
         BE    REP065                 no, leave units blank
         MVC   WORK2(3),=C'???'       Default unknown type if non-zero
*****    TM    DSNTSAL1,DS1CYL        Cylinders?
         TM    DSNTSAL1,X'C0'         MVS 3.8J doesn't have DS1CYL
         BNO   REP062                 nope, skip
         MVC   WORK2(3),=C'Cyl'
         B     REP065
REP062   DS    0H
*****    TM    DSNTSAL1,DS1TRK        Tracks?
         TM    DSNTSAL1,X'80'         MVS 3.8J doesn't have DS1TRK
         BNO   REP063                 nope, skip
         MVC   WORK2(3),=C'Trk'
         B     REP065
REP063   DS    0H
*****    TM    DSNTSAL1,DS1AVR        Avg blk leng request?
         TM    DSNTSAL1,X'40'         MVS 3.8J doesn't have DS1AVR
         BNO   REP065                 no, give up
         MVC   WORK2(3),=C'Blk'
REP065   DS    0H
*
* * format out device type and we're ready to print
*
         MVC   DBLWRD(4),=CL4'????'   Assume device type unknown
         CLI   DSNTDEV+2,X'20'        Is device class Disk?
         BNE   REP066                 no, don't know then
         TM    DSNTDEV+3,X'F0'        Is first nibble zeros?
         BNZ   REP066                 No, I'm confused then
         SLR   R1,R1                  Clear R1
         IC    R1,DSNTDEV+3         get device code
         SLL   R1,2                   times 4
         LA    R1,DEVNAMT(R1)         pick up device name address
         MVC   DBLWRD(4),0(R1)        save name for message
REP066   DS    0H
*
* * do restore status and non-zero R0 data found flag
*
         MVC   TIMEAREA(7),BLANKS     blank the status field    GP09317
         TM    DSNTFLGS,DSNTFRES      trying a restore?
         BNO   REP068                 no, skip
         MVC   TIMEAREA(5),=CL5'Error' assume error
         TM    DSNTFLGS,DSNTFROK      was it actually OK?
         BNO   REP067                 no, check for dummy
         MVC   TIMEAREA(5),=CL5'OK'   say it was OK
         B     REP068                 and skip
REP067   DS    0H
         TM    DSNTFLGS,DSNTFDUM      was SYSUT2 DD DUMMY?
         BNO   REP068                 no, leave status as Error
         MVC   TIMEAREA(5),=C'Dummy'  indicate DD dummy was there
REP068   DS    0H
         TM    DSNTFLGS,DSNTFR0N      was there non-zero R0s?
         BNO   REP069                 no, skip
         MVI   TIMEAREA+6,C'Z'        yes, give indication
REP069   DS    0H
         #MSG '%D7:4 %S3:3 %S5:5 %D6:2 %D6:2 %D3:1%D5:2  %X2:1 %X6:3 %DX
               6:2 %S8:8 %S8:8 %S8:8 %D3:1 %S6:6  %S4:4 %D7:4%S3:3%D7:3X
               %S3:3 %S7:7',                                           X
               DSNTTRKC,DSNTDSOR,DSNTRECC,DSNTLREC,DSNTBLKS,DSNTKEYL,  X
               DSNTRKP,DSNTOPTC,DSNTHTTR,DSNTTBAL,                     X
               CL24,CL24+8,CL24+16,DSNTEXT,                            X
               DSNTVOLS,DBLWRD,WORK,TIMEFMT,                           X
               DSNTSAL3,WORK2,TIMEAREA                          GP09317
REP070   DS    0H
         LA    R5,DSNTABEL(R5)        Address next table entry
         BCT   R7,REP050              Loop thru all entries
*
REPXIT   DS    0H
         CLOSE (SYSPRINT)             Close report file
         FREEPOOL SYSPRINT                                      GP09317
         BR    R8                     and return
         EJECT ,
*---------------------------------------------------------------------*
* GETDATA: Routine to read (R2) bytes from SYSUT1 into the input      *
*          buffer behind previous data.  The address of the text      *
*          is returned in R4. When the start exceeds the block size   *
*          shift text down to buffer start.                           *
*                                                                     *
*           R2 = Number of bytes to get from SYSUT1 (not preserved)   *
*           Data are returned in getmained area, always pointed to    *
*           by R4                                                     *
*           Return is via R8                                          *
*                                                                     *
* Reg Usage: (all these regs restored before return)                  *
*           R3 - scratch                                              *
*           R4 - returned record pointer                              *
*           R5 - Length of data left in UT1 input buff                *
*           R6 - scratch                                              *
*           R7 - scratch                                              *
*           R8 - Pointer to buffer read location                      *
*                                                                     *
* Note: On EOF for SYSUT1, control returns to the EODAD address for   *
*       SYSUT1 (UT1EODAD) - this is triggered by the issuance of      *
*       an EOV macro when we have finished the last volume on SYSUT1  *
*---------------------------------------------------------------------*
GETDATA  STM   R2,R8,GETDS28          Save regs I use           GP10159
         L     R5,UT1@TOP             Get next input position   GP10159
         L     R4,UT1@NXT             less bottom               GP10159
         SR    R5,R4                  Size available            GP10159
*DEFER*  BNP   GETD050                  No; read some           GP10159
         C     R4,UT1@HWM             Time to clean buffer?     GP10159
         BL    GETD030                Not yet                   GP10159
         LR    R7,R5                  Copy length               GP10159
         L     R6,UT1BUFFA            Set bottom                GP10159
         ST    R6,UT1@NXT             Set as next address       GP10159
         MVCL  R6,R4                  Move data down            GP10159
         ST    R6,UT1@TOP             New top                   GP10159
GETD030  L     R5,UT1@TOP             Get next input position   GP10159
         L     R4,UT1@NXT             less bottom               GP10159
         SR    R5,R4                  Size available            GP10159
         BP    GETD100                Yes, go process them      GP10159
         SPACE 1
*---------------------------------------------------------------------*
*   Read the next block at the end of the prior one.F                 *
*---------------------------------------------------------------------*
GETD050  L     R8,UT1@TOP             R8 -> input buffer
         TM    PROFLAGS,PFDASD        Using BSAM ?              GP09317
         BZ    GETDEXCP               No                        GP09317
         READ  DECB,SF,,(R8),MF=E     Read a block              GP09317
         CHECK DECB                   No overlap                GP09317
         LH    R5,DCBLRECL-IHADCB+SYSUT1    Get block size      GP09317
         ST    R5,UT1READL            Pass it on                GP09317
         B     GETD060                Join regular processing   GP09317
         SPACE 1
GETDEXCP LA    R3,UT1IOB              Address the IOB
         USING IOBSTDRD,R3            Using standard section of IOB
         OI    IOBFLAG1,IOBUNREL      IOB unrelated flg (I.E. non-seq)
         MVC   IOBECBPB,=AL3(UT1ECB)  ECB addr
         MVC   IOBDCBPB,=AL3(SYSUT1)  DCB Addr
         MVC   IOBSTRTB,=AL3(UT1READ) Select a channel program
         MVC   IOBINCAM,=H'1'         Increment blk cnt by 1 per EXCP
         STCM  R8,B'0111',UT1READ+1   Put buff addr in CCW
         EXCP  UT1IOB                 Issue the EXCP
         WAIT  ECB=UT1ECB             and await the result.
         CLI   UT1ECB,X'7F'           Check the return code
         BE    GETD055                OK, skip
***** try to decode the error
         CLI   UT1ECB,X'41'           perm I/O error ?
         BNE   GETDBAD                nope, something else
         CLC   IOBCSW+3(2),=XL2'0D00' chan end, dev end, unit excepton?
         BNE   GETDBAD                nope, give up
         CLC   IOBCSW+5(2),=XL2'FFF0' Is residual byte count 65520
*                                     (i.e. zero bytes were read)
         BNE   GETDBAD                nope, give up
* What we have here is a tape mark, do an EOV to either trigger
* the EODAD exit or to begin processing with next volume
         L     R1,SYSUT1+(DCBBLKCT-IHADCB) *  Decrement the block
         BCTR  R1,0                        ** count in DCB since last
         ST    R1,SYSUT1+(DCBBLKCT-IHADCB) ***read found only tape mark
         OI    SYSUT1+(DCBOFLGS-IHADCB),X'04' Set tape mark found bit
         STM   R2,R8,GETDS28B         Save my regs              GP10159
         LM    R2,R8,GETDS28          Restore originals in case GP10159
*                                     we trigger EODAD on SYSUT1
         EOV   SYSUT1                 Give this a try
         LM    R2,R8,GETDS28B         we are on another volume, restore
*                                     my working copy of the regs
         B     GETD050                and see if we can read now
*
GETDBAD  #MSG  'DSSREST - Error reading SYSUT1, ECB=%X8:4, Sense=%X4:2,X
                Status=%X4:2, Count=x%X4:2',UT1ECB,IOBSENS0,IOBCSW+3,IOX
               BCSW+5
         LM    R2,R8,GETDS28          Restore regs I clobbered  GP10159
         B     EXITRC16               Set bad RC and exit
         SPACE 1
GETD055  L     R5,=F'65520'           Length we were trying to read
         XC    WORK,WORK              clear a fullword
         MVC   WORK+2(2),IOBCSW+5        insert residual byte count
         DROP  R3
         S     R5,WORK                compute length read       GP09317
         ST    R5,UT1READL            save temp for debug msg   GP09317
         BP    GETD060                yes, skip                 GP09317
         #MSG  'Error reading SYSUT1, zero byte block read'
         LM    R2,R8,GETDS28          Restore regs I clobbered  GP10159
         B     EXITRC16
         SPACE 1
*---------------------------------------------------------------------*
*   In addition to the normal ADRDSSU RECFM=U, DSSREST supports files *
*   converted to RECFM=V(B)(S). V-format is used to preserve block    *
*   sizes over ftp transmission. Files with RDWs and no BDW are valid *
*---------------------------------------------------------------------*
GETD060  L     R1,UT1NBLKS            Bump block counter
         LA    R1,1(,R1)
         ST    R1,UT1NBLKS
         C     R1,=F'1'               First block?              GP10159
         BNE   GETD068                  No                      GP10159
         CLC   =X'002A0000',0(R8)     Standard BWD ?            GP10159
         BNE   *+8                      No                      GP10159
         OI    PROFLAGS,PFBDW         Set BDW format            GP10159
         CLC   =X'00260000',0(R8)     Funny RDW only ?          GP10159
         BNE   *+8                      No                      GP10159
         OI    PROFLAGS,PFRDW         Set RDW format            GP10159
GETD068  TM    CONTROL,CDEBU2         Want some debug msgs?
         BNO   GETD070                not now thanks
         #MSG  'GETDATA Read Done,LEN=%D,BLK=%D.',UT1READL,UT1NBLKS
         MVC   DBLWRD,0(R8)
         #MSG  'GETDATA READ DATA = %X8:4 %x8:4',DBLWRD,DBLWRD+4
         MVC   DBLWRD,8(R8)
         #MSG  '                    %X8:4 %x8:4',DBLWRD,DBLWRD+4
         SPACE 1
GETD070  L     R5,UT1READL            Get length back           GP10159
         L     R1,UT1BYTES+4          bump input byte count     GP09317
         ALR   R1,R5                                            GP09317
         ST    R1,UT1BYTES+4
         BNO   GETD075                skip if no overflow       GP10159
         L     R1,UT1BYTES
         LA    R1,1(,R1)
         ST    R1,UT1BYTES
GETD075  L     R1,UT1@TOP             Get prior top             GP10159
         AR    R1,R5                  adjust                    GP10159
         ST    R1,UT1@TOP             Set new top               GP10159
         LR    R5,R1                  Get next input position   GP10159
         L     R4,UT1@NXT             less bottom               GP10159
         SR    R5,R4                  Size available            GP10159
         BNP   GETD050                Null buffer?              GP10159
         SPACE 1
*---------------------------------------------------------------------*
*   When the request is for 16 bytes (header) and we have enough      *
*   data in the buffer, check whether the block begins with a BDW     *
*   and/or an RDW. If so, adjust length and start address.            *
*---------------------------------------------------------------------*
GETD100  CR    R2,R5                  Do I have enough data?    GP10159
         BH    GETD050                No, do segmented acquire  GP10159
         CH    R2,=H'16'              Reading prefix?           GP10159
         BNE   GETD180                  No                      GP10159
         TM    PROFLAGS,PFBDW+PFRDW   Any fixup ?               GP10159
         BZ    GETD180                  No                      GP10159
         CLC   UT1NBLKS,0(R4)         Expected block?           GP10159
         BE    GETD180                  Yes, not BDW/RDW        GP10159
         SR    R14,R14                For block length          GP10159
         ICM   R15,3,2(R4)            Possible BDW/RDW?         GP10159
         BNZ   GETD180                  No                      GP10159
         LA    R0,4                   Set adjust value          GP10159
         ICM   R14,3,0(R4)            Load length               GP10159
         TM    PROFLAGS,PFBDW         Any fixup ?               GP10159
         BZ    GETD175                  No                      GP10159
         ICM   R15,3,6(R4)            Possible BDW/RDW?         GP10159
         BNZ   GETD175                  No                      GP10159
         LA    R0,8                   Set adjust value          GP10159
         ICM   R14,3,4(R4)            Load length               GP10159
GETD175  SR    R5,R0                  BDW/RDW length to skip    GP10159
         AR    R4,R0                  Adjust adress             GP10159
         SH    R14,=H'4'              Data length               GP10159
         ST    R14,UT1READL           Fake it                   GP10159
         TM    CONTROL,CDEBU2         Want some debug msgs?     GP10159
         MVC   DBLWRD,0(R4)                                     GP10159
         BNO   GETD180                not now thanks            GP10159
         #MSG  'GETDATA AFTER RDW = %X8:4 %x8:4',DBLWRD,DBLWRD+4
         MVC   DBLWRD,4(R8)                                     GP10159
         #MSG  '                    %X8:4 %x8:4',DBLWRD,DBLWRD+4
         SPACE 1
GETD180  CR    R2,R5                  Do I have enough data in buff?
         BH    GETD050                No, do segmented acquire
         ST    R4,GETDS28+8           Return new record         GP10159
         LA    R3,0(R2,R4)            Account for used portion  GP10159
         ST    R3,UT1@NXT             Set for next call         GP10159
         LM    R2,R8,GETDS28          Restore regs I clobbered
         BR    R8                     and return
*
*--------------------------------------------------------------------*
* FMTRECFM - subroutine to format recfm.                             *
*            R2 low  byte contains recfm on input                    *
*            WORK fullword contains 5 byte char recfm on output      *
*            R14 is return address                                   *
*            WORK2, R1 used as scratchpads                           *
*--------------------------------------------------------------------*
FMTRECFM STC   R2,WORK2+1        Save recfm                     GP09317
         UNPK  WORK+1(3),WORK2(2) Unpack                        GP09317
         MVI   WORK,C'x'         Set output to 'xXX' where XX is hex
         MVC   WORK+3(2),BLANKS  Clear                          GP09317
         TR    WORK+1(2),FTAB-C'0'      Make printable          GP09317
         TM    WORK2+1,X'01'     Keylength set?                 GP09317
         BOR   R14               yes, leave as Xxx format
         TM    WORK2+1,X'06'     both ASA and machine CC set?   GP09317
         BOR   R14               yes, leave as Xxx format
         CLI   WORK2+1,0         Anything at all?               GP09317
         BER   R14               No, leave as Xxx format        GP09317
*
         MVC   WORK(5),BLANKS    Clear output                   GP09317
         LA    R1,WORK                                          GP09317
         LA    R15,RECFMTAB           Point to standard table   GP09317
         LA    R0,RECFMCNT            Entry count               GP09317
         TM    WORK2+1,DCBRECU        U, F, or V ?              GP09317
         BNZ   RECFM010               Yes, handle               GP09317
         LA    R15,RECFMTA2-RECFMTAB(,R15)  Space to 'D' table  GP09317
         LA    R0,RECFMCN2            Adjust count              GP09317
RECFM010 MVC   WORK2+2(1),WORK2+1     Test pattern              GP09317
         NC    WORK2+2(1),1(R15)      Test pattern              GP09317
         CLC   WORK2+2(1),1(R15)      Test pattern              GP09317
         BNE   RECFM020               Not a match; try again    GP09317
         MVC   0(1,R1),0(R15)         Add this one              GP09317
         LA    R1,1(,R1)              And bump output pointer   GP09317
         MVI   WORK2+2,X'FF'                                    GP09317
         XC    WORK2+2(1),1(R15)      Invert test bits          GP09317
         NC    WORK2+1(1),WORK2+2     Prevent false match (UV)  GP09317
RECFM020 LA    R15,2(,R15)            Next table entry          GP09317
         BCT   R0,RECFM010            Exhaust entries           GP09317
         BR    R14                    Return                    GP09317
         SPACE 1
RECFMTAB DC    CL1'U',AL1(DCBRECU)                              GP09317
RECFMLNG EQU   *-RECFMTAB              LENGTH OF ONE ENTRY      GP09317
         DC    CL1'F',AL1(DCBRECF)                              GP09317
         DC    CL1'V',AL1(DCBRECV)                              GP09317
         DC    CL1'T',AL1(DCBRECTO)                             GP09317
         DC    CL1'B',AL1(DCBRECBR)                             GP09317
RECFMTA2 DC    CL1'D',AL1(DCBRECD)    ASCII VARIABLE (D) FORMAT GP09317
         DC    CL1'S',AL1(DCBRECSB)                             GP09317
         DC    CL1'A',AL1(DCBRECCA)                             GP09317
         DC    CL1'M',AL1(DCBRECCM)                             GP09317
RECFMCNT EQU   (*-RECFMTAB)/RECFMLNG   COUNT OF U/V/F ENTRIES   GP09317
RECFMCN2 EQU   (*-RECFMTA2)/RECFMLNG   COUNT OF D/... ENTRIES   GP09317
*
FTAB     DC    C'0123456789ABCDEF'
*
*--------------------------------------------------------------------*
* FMTDSDAT - subroutine to format DSCB date into DBLWRD as YYYY.DDD  *
*            Return via R14, R0 contains DSCB date in right 3 bytes  *
*   Code modified to window old/new dates: year < 65 bytes is 20nn   *
*--------------------------------------------------------------------*
FMTDSDAT MVC   DBLWRD,=CL8'****.***'
         N     R0,=X'00FFFFFF'                                  GP09317
         BZR   R14                                              GP09317
         SRDL  R0,16                  Shift day to R1           GP09317
         SRL   R1,16                  Right justify day         GP09317
         CH    R0,=H'65'              Need extra century?       GP09317
         BNL   *+8                    No                        GP09317
         AH    R0,=H'100'             Chg 1900-1965->2000-2065  GP09317
         AH    R0,=H'1900'
         CVD   R0,DBLWRD
         UNPK  TIMEAREA(5),DBLWRD+5(3)
         CVD   R1,DBLWRD
         UNPK  TIMEAREA+6(3),DBLWRD+6(2)
         MVC   DBLWRD(4),TIMEAREA+1
         OI    DBLWRD+3,X'F0'
         MVI   DBLWRD+4,C'.'
         MVC   DBLWRD+5(3),TIMEAREA+6
         OI    DBLWRD+7,X'F0'
         BR    R14
*
*--------------------------------------------------------------------*
* FMTTIME  - subroutine to get and format the date/time into TIMEFMT *
*            Return via R8, uses WORK & DBLWRD as scratchpad         *
*--------------------------------------------------------------------*
FMTTIME  DS    0H
*****    MVC   TIMEAREA+12(4),=F'0'   Clear 4th word as per docs
*****    TIME  DEC,TIMEAREA,LINKAGE=SYSTEM,DATETYPE=YYYYDDD
* TIMEAREA= HHMMSSth miju0000 0YYYYDDD xxxxxxxx
* we want  'YYYYDDD HH:MM:SS'
**** revert to older format for MVS 3.8J
         TIME  DEC
         ST    R0,TIMEAREA            Save HHMMSSth
         STC   R1,TIMEAREA+4          Save 0C of 0CYYDDDF temporarily
         SRL   R1,4                   Shift digits over the F
         N     R1,=XL4'000FFFFF'      clear leading 0YY
         TM    TIMEAREA+4,X'00'       Is century indicator zero?
         BNO   FMTT10                 no, skip
         O     R1,=XL4'01900000'      Assume 19xx for year
         B     FMTT20                 skip
FMTT10   DS    0H
         O     R1,=XL4'02000000'      Assume 20xx for year
FMTT20   DS    0H
         ST    R1,TIMEAREA+8          Save 0YYYDDD
**** end of patch for MVS 3.8J time format
         L     R1,TIMEAREA+8          Get date portion
         SLL   R1,4                   Shift left a nibble
         O     R1,=XL4'0000000F'      insert sign
         ST    R1,WORK                save it
         UNPK  DBLWRD(7),WORK(4)      unpk into temp area
         MVC   TIMEFMT(4),DBLWRD      put YYYY in fmt area
         MVI   TIMEFMT+4,C'.'         pun in the dot
         MVC   TIMEFMT+5(3),DBLWRD+4  put DDD in fmt area
         OI    TIMEAREA+3,X'0F'       overlay 'h' with sign nibble
         UNPK  DBLWRD(7),TIMEAREA(4)  unpack the digits
         MVC   TIMEFMT+9(2),DBLWRD
         MVC   TIMEFMT+12(2),DBLWRD+2
         MVC   TIMEFMT+15(2),DBLWRD+4
         BR    R8
*
         LTORG ,                                                GP09317
*
* * program work areas
*
UT1BYTES DC    D'0'                   SYSUT1 bytecount
DBLWRD   DS    D                      work area
SAVEAREA DS    18F
BLANKS   DC    CL44' '                Constant                  GP09317
RETC     DC    0F'0',XL3'0'  1/2      Program return code       GP09317
RETCODE  DC    X'00'                  For shorter setting       GP09317
TIMEAREA DC    XL16'00'               Workarea for TIME macro
TIMEFMT  DC    CL17'YYYY.DDD HH:MM:SS' Formatted datetime from FMTTIME
CL24     DS    CL24                   Temp workarea
PARMLENG DS    H                      Leng of EXEC PARM
WORK     DS    F                      work area
WORK2    DS    F                      work area
GETDS28  DS    7F                     GETDATA save area
GETDS28B DS    7F                     GETDATA save area (for EOV use)
DSNTABA  DS    F                      Address of DSN table
DSNTA#1  DC    F'0'                   Address of DSN tab entry for
*                                     first file found in dump (used
*                                     to build a sequenced chain of
*                                     files) Note: we only chain those
*                                     files which are potential restore
*                                     candidates.
DSNTPREV DS    F                      Temp save previous DSNtab ent adr
HOLDBUFA DS    F                      Address of out-of-seq seg holding
HOLDSEGL DS    F                      Leng of held seg (minus prefix)
SEGNUM   DS    F                      Segment number being processed
DSN      DC    CL44' '                Dataset name to restore
PREFIX   DC    CL8' '                 Prefix for DSN HLQ tailoring
*
* * control info from dump file
*
DSSCHECK DS    H                      Used to check length fields
DSSNFILE DC    F'0'                   Number of files in the dump
DSSMAXB  DS    F                      Max blksize of dump
DSSSEGLN DS    F                      Current segment length
DSSSEGTY DS    XL1                    Current segment type
DSSPREFX DS    XL16                   Last segmentprefix that was read
DSSTRKSG DS    F                      # track segs read 4 this track
DSSTRKNS DS    F                      # track segs expected 4 this trk
DSSTRKLN DS    F                      Track len from track header
DSSTRKDC DS    F                      Track len counter
DSSNR0NZ DS    F                      # non-zero R0's in this dataset
DSSDISPF DS    XL24                   Track data displacement flags
*                                     Min ADRDSSU blksize is 7892,
*                                     7892*24=more than enough flags
*                                     to cover off the worst possible
*                                     segmentation of track data
DSSDISPP DS    24F                    Displacement pointers
*
DYNSUBP  DS    0F                     Parm list for DYNALLO subrtn
DYNSP01  DC    F'0'                   Addr of DSNTAB entry
DYNSP02  DC    F'0'                   SVC99 return code
DYNSP03  DC    F'0'                   S99ERROR returned value
DYNSP04  DC    F'0'                   # messages returned
DYNSP05  DC    F'0'                   Addr of MSG1
DYNSP06  DC    F'0'                   Addr of MSG2
DYNSP07  DC    CL8' '                 Passed HLQ, Returned DDNAME
*
* * CONTROL flagbyte and state indicator
*
CONTROL  DC    X'00'                  Program control flags
CDEBUG   EQU   X'80'                    Print debug messages
CDEBU2   EQU   X'40'                    Print LOTS of debug msgs
CUT2OPEN EQU   X'20'                    Sysut2 is open
CUT1OPEN EQU   X'10'                    Sysut1 is open
CSKIP    EQU   X'08'                    Skip this file in the dump
CVOLDEF  EQU   X'04'                    Found Vol Def seg already
CREST    EQU   X'02'                    Restore dataset type run
CDOREST  EQU   X'01'                    Restoring THIS dataset
*
CONTROL2 DC    X'00'                  More control flags
CHELDSEG EQU   X'80'                    Have a held seg awaiting use
CHELDSG2 EQU   X'40'                    Second stage of using held seg
CUT2CLOS EQU   X'20'                    Successful restore SYSUT2closed
CDYNALLO EQU   X'10'                    Using DYNALLOC
CTRKCOMP EQU   X'08'                    Track data are compressed
*
STATE    DC    X'00'                  State flag
STDSHDR  EQU   X'80'                    Dataset Header seg is OK
STVOLDEF EQU   X'40'                    Volume Definition seg is OK
STDATATR EQU   X'20'                    Data Track seg is OK
STDATATL EQU   X'10'                    Dataset Trailer Segment is OK
STDATAT2 EQU   X'02'                    1st data trailer was found
STEOF    EQU   X'01'                    Hitting EOF is OK
*
PROFLAGS DC    X'00'                  Processing flags          GP09317
PFDASD   EQU   X'80'                    SYSUT1 uses BSAM        GP09317
PFBDW    EQU   X'10'                    BDW/RDW found in input  GP09329
PFRDW    EQU   X'08'                    BDW/RDW mode forced     GP10159
PFVOL    EQU   X'04'         Use sender's VOL=SER on SYSUT2     GP09329
*
DCOMPARM DS    0F                     Decompress routine parm list
DCOMPBUF DS    F                        Address of getmained I/P buff
DCOMPOUT DS    F                        Addr of O/P buff
DCOMPILN DS    F                        I/P leng
DCOMPOLN DS    F                        O/P buf len,decomp len returned
*
* * message file DCB
*
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,EXLST=EXLSTPRT GP09317
MAXLRECL DC    F'0'          LRECL AT OPEN TIME                 GP09329
EXLSTPRT DC    0A(0),X'85',AL3(PRTEXIT)                         GP09317
*
*
* * SYSUT1 work areas, and data management control blocks
*
UT1READL DS    F                      Leng of block read on SYSUT1
UT1BUFFA DS    A                      Address of getmained SYSUT1 buff
UT1@NXT  DS    A                      Address of next record    GP10159
UT1@TOP  DS    A                      Address of next read      GP10159
UT1@HWM  DS    A                      Trigger address to move   GP10159
UT1NBLKS DC    F'0'                   SYSUT1 block counter
EXCPDCB  DCB   DDNAME=SYSUT1,MACRF=E,EODAD=UT1EODAD,DSORG=PS,DEVD=TA
EXCPDCBL EQU   *-EXCPDCB                                        GP09317
SYSUT1   DCB   DDNAME=SYSUT1,MACRF=R,EODAD=UT1EODAD,DSORG=PS,DEVD=DA,  *
               RECFM=U,BLKSIZE=32760                            GP09317
*
         READ  DECB,SF,SYSUT1,*-*,'S',MF=L  BSAM DECB           GP09317
*
DEVTAREA DS    0D
DEVTTYPE DS    F                      UCBTYP info
         DS    6F                     Padding, not sure of exact leng
*                                     that DEVTYPE will return in 38J
*
* * EXCP areas for SYSUT1
*
UT1ECB   DS    F                      ECB for SYSUT1 EXCP
         DS    D
UT1IOB   DS    XL32'00'               SYSUT1 IOB
         DS    D
UT1READ  CCW   2,0,X'20',65520        Read a tape block, SILI bit set
*                                     Note: data adress will be set
*                                     in this CCW before it gets used!
*
* * SYSUT2 WORK areas, and data management control blocks
*
UT2BUFFA DS    F                      Adr of getmained SYSUT2 trk buf
*
SYSUT2   DCB   DDNAME=SYSUT2,MACRF=E, ** used for EXCP processing      X
               DEVD=DA,DSORG=PS
SYSUT2L  EQU   *-SYSUT2            DCB Length
*
* * The following DCB is only used to OPEN/CLOSE a DUMMY SYSUT2 DD
*
DUMMY2   DCB   DDNAME=SYSUT2,MACRF=PL,DSORG=PS,RECFM=FB,LRECL=80,BLKSIZX
               E=800
*
MBBCCHHR DC    D'0'                Actual disk address from convert rtn
*
UT2ECB   DC    F'0'                   ECB for EXCP
UT2IOB   DC    XL40'00'               IOB for SYSUT2 (40 byte for disk)
*
* * note: there are 100 Write CKD cmds in this table, a 3390 can have
* *       a maximum of 86 blocks per track so we should never run
* *       run out of CCWs in this channel pgm.
*
WRITE    DS    0D                     Channel pgm to write track
         CCW   X'31',MBBCCHHR+3,X'40',5  Search ID eql,cmd chain
*******                               =
* Note: under z/OS & OS/390 the length on the above CCW may be 4 or 5
*       but with MVS 3.8J it must be 5.  Why?  Dunno, tell me why.
*******
         CCW   X'08',WRITE,0,0          TIC back to WRITE
BLK1     CCW   X'1D',0,X'40',0          Write CKD,dat adr,cmd chain,len
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
         CCW   X'1D',0,X'40',0
*
* * Device type name table, 16 entries corresponding to last nibble of
* * the device code in the device type field
*
DEVNAMT  DS    0H
         DC    C'????'    0
         DC    CL4'2311'  1
         DC    CL4'2301'  2
         DC    CL4'2303'  3
*OLD*    DC    CL4'2302'  4
         DC    CL4'9345'  4                                     GP09317
         DC    CL4'2321'  5
         DC    CL4'2305'  6
         DC    CL4'2305'  7
         DC    CL4'2314'  8
         DC    CL4'3330'  9
         DC    CL4'3340'  A
         DC    CL4'3350'  B
         DC    CL4'3375'  C
         DC    CL4'3330'  D
         DC    CL4'3380'  E
         DC    CL4'3390'  F
*/* ----------------------------------------------------------------
* *  Note: the following label can be used to see how much addressabil-
* *      ity remains in the pgm since MSGS don't need to be within the
* *      range of any base regs nor do any subroutines that follow
* * ---------------------------------------------------------------- */
#MSGRTNE  EQU   *
         DROP  R9,R10,R11,R12 , no longer of any use but not altered
         EJECT ,                                                GP09317
*/* ----------------------------------------------------------------
* *      subroutine to issue messages
* * ---------------------------------------------------------------- */
MSG#RTN  STM   R0,R15,MRSAVE-MSG#RTN(R15)  SAVE IN ORDER        GP09317
         BALR  R12,0         NEW BASE                           GP09317
         USING *,R12                                            GP09317
         L     R8,=A(SYSPRINT)                                  GP09317
          USING IHADCB,R8
          TM   DCBOFLGS,DCBOFOPN
          BNO  MRRET                RETURN IF NO MESSAGE FILE
          LR   R4,R1         OFFSET TO MESSAGE ENTRY            GP09317
          A    R4,=A(MSG#SECT)    MESSAGE ENTRY                 GP09317
          LH   R5,0(,R4)     LENGTH-1 OF MESSAGE                GP09317
          LA   R3,5(R5,R4)   POINTER TO PARAMETERS              GP09317
          LH   R9,2(,R4)     NUMBER OF PARAMETERS               GP09317
          LA   R4,4(,R4)     SKIP MESSAGE PREFIX                GP09317
          LA   R6,MSG
          MVC  MSG(L'MSG),MSG-1   CLEAR TO BLANKS               GP09317
          SPACE 1
MRLOOP    LTR  R5,R5
          BM   MREXIT
          LA   R1,1(R4,R5)
          SLR  R2,R2
          EX   R5,MRTRT1
          SR   R1,R4                LENGTH SCANNED
          BNP  MRSKIP1
          LR   R15,R1
          BCTR R15,0
          EX   R15,MRMVC1            COPY LITERAL TEXT
          AR   R6,R1
MRSKIP1   AR   R4,R1
          SR   R5,R1
          BM   MREXIT
          BP   MRSKIP2
          MVC  0(1,R6),0(R4)        STRING ENDS IN SPECIAL CHAR
          LA   R6,1(,R6)
          B    MREXIT
MRSKIP2   B    *(R2)                BR ON SPECIAL CHAR TYPE
          B    MRPCT                '%'
          B    MRBS                 '\'
MRPCT    ICM   R7,3,0(R3)    GET NEXT OPERAND OFFSET            GP09317
         LR    R15,R7        COPY                               GP09317
         N     R7,=X'00000FFF'    ISOLATE DISPLACEMENT          GP09317
         N     R15,=X'0000F000'   ISOLATE REGISTER              GP09317
         BZ    MRPNOREL           BASE=R0                       GP09317
         SRL   R15,12-2           MAKE OFFSET IN SAVE AREA      GP09317
         A     R7,MRSAVE(R15)     RELOCATE                      GP09317
MRPNOREL LA    R3,2(,R3)          NEXT OPERAND OFFSET           GP09317
         BCTR  R9,0               OPERAND COUNTER               GP09317
          CLI  1(R4),C's'                                       GP09317
          BE   MRPCTS
          CLI  1(R4),C'S'
          BE   MRPCTS
          CLI  1(R4),C'x'
          BE   MRPCTX
          CLI  1(R4),C'X'
          BE   MRPCTX
          CLI  1(R4),C'd'
          BE   MRPCTD
          CLI  1(R4),C'D'
          BE   MRPCTD
          MVC  0(1,R6),0(R4)        TREAT '%' AS ANY OTHER CHAR
          LA   R6,1(,R6)
          LA   R4,1(,R4)
          BCTR R5,0
          B    MRLOOP
MRPCTS    LA   R4,2(,R4)            POINT PAST '%S'
          SH   R5,=Y(2)
          BAL  R14,MROP             R1 - TARGET LEN, R2 - SOURCE LEN
          LTR  R2,R2
          BNZ  MRPCTS3
          LR   R2,R7                SOURCE LEN = 0, FIND END OF STRING
MRPCTS1   CLI  0(R2),C' '
          BNH  MRPCTS2
          LA   R2,1(,R2)
          B    MRPCTS1
MRPCTS2   SR   R2,R7
          BNP  MRLOOP
MRPCTS3   LR   R15,R2                COPY SOURCE STRING TO THE MSG
          BCTR R15,0
          EX   R15,MRMVC2
          LTR  R1,R1
          BNZ  MRPCTS5
          AR   R6,R2                 TRUNCATE TRAILING SPACES IF
MRPCTS4   BCTR R6,0                  TARGET LEN IS 0
          CLI  0(R6),C' '
          BNH  MRPCTS4
          LA   R6,1(,R6)
          B    MRLOOP
MRPCTS5   CR   R1,R2
          BH   MRPCTS6
          AR   R6,R1                 TRUNCATE THE STRING
          B    MRLOOP
MRPCTS6   AR   R6,R2                 PAD STRING WITH TRAILING BLANKS
          SR   R1,R2
MRPCTS7   MVI  0(R6),C' '
          LA   R6,1(,R6)
          BCT  R1,MRPCTS7
          B    MRLOOP
MRPCTX    LA   R4,2(,R4)            POINT PAST '%X'
          SH   R5,=Y(2)
          BAL  R14,MROP             R1 - TARGET LEN, R2 - SOURCE LEN
          LTR  R2,R2
          BNZ  *+8
          LA   R2,4                 DEFAULT SOURCE LEN IS 4
          EX   R2,MRPCTXU
          TR   DW,MRHEXTAB
          LTR  R1,R1
          BNZ  MRPCTX1
          LA   R1,8                 DETERMINE DEFAULT TARGET LEN
          CLC  =C'00',DW
          BNE  MRPCTX1
          LA   R1,6
          CLC  =C'0000',DW
          BNE  MRPCTX1
          LA   R1,4
          CLC  =C'000000',DW
          BNE  MRPCTX1
          LA   R1,2
MRPCTX1   LA   R7,DW+8              COPY THE HEX STRING TO THE MSG
          SR   R7,R1
          BCTR R1,0
          EX   R1,MRMVC2
          LA   R6,1(R1,R6)
          B    MRLOOP
MRPCTD    LA   R4,2(,R4)            POINT PAST '%D'
          SH   R5,=Y(2)
          BAL  R14,MROP             R1 - TARGET LEN, R2 - SOURCE LEN
          LTR  R2,R2
          BNZ  *+8
          LA   R2,4                 DEFAULT SOURCE LEN IS 4
          LA   R15,4
          SR   R15,R2
          LA   R14,15
          SRL  R14,0(R15)
          EX   R14,MRPCTDI
          CVD  R15,DW
          MVC  DW2(20),=X'402020206B2020206B2020206B2020206B202120'
          ED   DW2(20),DW
          LTR  R1,R1
          BNZ  MRPCTD2
          LA   R15,DW2+20            DEFAULT LENGTH -
MRPCTD1   BCTR R15,0                 TRUNCATE LEADING SPACES
          CLI  0(R15),C' '
          BH   MRPCTD1
          LA   R1,DW2+19
          SR   R1,R15
MRPCTD2   LA   R7,DW2+20
          SR   R7,R1
          BCTR R1,0
          EX   R1,MRMVC2
          LA   R6,1(R1,R6)
          B    MRLOOP
MRBS      MVC  0(1,R6),1(R4)        COPY CHAR FOLLOWING '\'
          LA   R6,1(,R6)
          LA   R4,2(,R4)
          SH   R5,=Y(2)
          B    MRLOOP
MREXIT    LA   R4,MSG               START                       GP09329
          LR   R5,R6                HWM                         GP09329
          SR   R5,R4                CALCULATE MSG LENGTH        GP09329
          BNP  MRRET
          TM   DCBRECFM,DCBRECCA+DCBRECCM
          BZ   MREXITNC                                         GP09317
          BCTR R4,0                 BACK SPACE                  GP09317
          LA   R5,1(,R5)            INCREMENT FOR CARRIAGE CONTROL
          TM   DCBRECFM,DCBRECCA                                GP09317
          BO   MREXITNC                                         GP09317
          MVI  0(R4),X'09'                                      GP09317
MREXITNC  TM   DCBRECFM,DCBRECU
          BO   MRU
          TM   DCBRECFM,DCBRECF
          BO   MRF
MRU       CH   R5,DCBBLKSI
          BNH  *+8
          LH   R5,DCBBLKSI
         TM    DCBMACF2,DCBMRLCP    LOCATE MODE?                GP09329
         BZ    MRULEN                                           GP09317
         C     R5,MAXLRECL-SYSPRINT(,R8)    FITS?               GP09329
         BNH   *+8                  YES                         GP09329
         L     R5,MAXLRECL-SYSPRINT(,R8)    TRUNCATE            GP09329
         LA    R3,4(,R5)            DATA + RDW LENGTH           GP09329
         STH   R3,DCBLRECL                                      GP09329
         PUT   IHADCB               GET A RECORD                GP09329
         SLL   R3,16                                            GP09329
         STCM  R3,15,0(R1)          BUILD RDW                   GP09329
         LA    R0,4(,R1)                                        GP09329
         LR    R1,R5                                            GP09329
         MVCL  R0,R4                MOVE DATA TO BUFFER         GP09329
         B     MRFCC                                            GP09317
MRULEN    STH  R5,DCBLRECL
MRF      LR    R0,R4                RECORD ADDRESS              GP09317
          PUT  IHADCB,(0)                                       GP09317
MRFCC     MVI  MSG-1,C' '           RESTORE                     GP09317
MRRET     LM   R0,R15,MRSAVE                                    GP09317
          BR   R14
          DROP R8

*/* ----------------------------------------------------------------
* *       message subroutine to get operand lengths
* * ---------------------------------------------------------------- */

MROP      SLR  R1,R1
          SLR  R2,R2
         LA    R0,15                CONSTANT                    GP09317
MROP1     LTR  R5,R5                FIRST NUMBER IS TARGET LENGTH
          BMR  R14
          CLI  0(R4),C'0'
          BL   MROP2
          IC   R15,0(,R4)
          NR   R15,R0               ISOLATE NYBBLE              GP09317
          MH   R1,=Y(10)
          AR   R1,R15
          LA   R4,1(,R4)
          BCTR R5,0
          B    MROP1
MROP2     CLI  0(R4),C':'          SECOND NUMBER FOLLOWS A ':'
          BNER R14
MROP3     LA   R4,1(,R4)           SECOND NUMBER IS SOURCE LENGTH
          SH   R5,=Y(1)
          BMR  R14
          CLI  0(R4),C'0'
          BLR  R14
          IC   R15,0(,R4)
          NR   R15,R0               ISOLATE NYBBLE              GP09317
          MH   R2,=Y(10)
          AR   R2,R15
          B    MROP3

*/* ---------------------------------------------------------------- */

MRMVC1    MVC  0(0,R6),0(R4)
MRTRT1    TRT  0(0,R4),MRTAB1
MRMVC2    MVC  0(0,R6),0(R7)
MRMVC3    MVC  0(0,R1),MSG
MRPCTXU   UNPK DW(9),0(0,R7)
MRPCTDI   ICM  R15,0,0(R7)
MRTAB1    DC   XL256'0'
          ORG  MRTAB1+C'%'
          DC   AL1(4)
          ORG  MRTAB1+C'\'
          DC   AL1(8)
          ORG  MRTAB1+256
MRHEXTAB  EQU  *-240
          DC   C'0123456789ABCDEF'
          LTORG ,

*/* ----------------------------------------------------------------
* *   NONDYNAMIC STORAGE
* * ---------------------------------------------------------------- */

MRSAVE   DS    16F                                              GP09317
         DC    C' '               1/2                           GP09317
MSG      DS    CL256              2/2                           GP09317
DW                DS  D
DW2               DS  D
DW3               DS  D            DW3 & DW4 NOT REFERENCED BUT
DW4               DS  D            THEY ARE USED!
DWCB              DS  F            CB PUT COMMAS IN EDIT MASK ADD 4BYTS
         DROP R12                All done with MSGRTN base
         SPACE 2                                                GP09317
*---------------------------------------------------------------------*
*                                                                     *
*   DCB OPEN EXIT FOR OUTPUT PRINTING:                                *
*      DEFAULT TO FBA,133,1330   USING MOVE MODE                      *
*      IF OUTPUT IS V, CHANGE TO LOCATE MODE                          *
*                                                                     *
*---------------------------------------------------------------------*
         PUSH  USING                                            GP09317
         DROP  ,                                                GP09317
         USING PRTEXIT,R15                                      GP09317
         USING IHADCB,R1                                        GP09317
PRTEXIT  N     R1,=X'00FFFFFF'    KILL OPEN FLAGS               GP09317
         SR    R2,R2              CLEAR FOR DIVIDE              GP09317
         SR    R3,R3              BLOCK SIZE                    GP09317
         SR    R4,R4              RECORD LENGTH                 GP09317
         ICM   R4,3,DCBLRECL      LOAD RECORD LENGTH            GP09317
         ICM   R3,3,DCBBLKSI      LOAD BLOCK SIZE               GP09317
         TM    DCBRECFM,DCBRECLA  ANY RECORD FORMAT ?           GP09317
         BNZ   PRTEXITR           YES; KEEP                     GP09317
         OI    DCBRECFM,DCBRECF+DCBRECBR+DCBRECCA  DEFAULT FBA  GP09317
PRTEXITR MVI   DCBMACF2,DCBMRPUT+DCBMRMVP   SET MOVE MODE       GP09317
         TM    DCBRECFM,DCBRECF   IS IT F OR U VS. V OR D?      GP09317
         BNZ   PRTEXITM           YES; USE MOVE MODE            GP09317
         MVI   DCBMACF2,DCBMRPUT+DCBMRLCP   SET LOCATE          GP09329
PRTEXITM LTR   R4,R4              ANY RECORD LENGTH ?           GP09317
         BNZ   PRTEXITL           YES                           GP09317
         LA    R4,132             SET DEFAULT TEXT LENGTH       GP09317
         TM    DCBRECFM,DCBRECF   U OR F?                       GP09317
         BNZ   *+8                YES                           GP09317
         LA    R4,4(,R4)          ALLOW FOR RDW                 GP09317
         TM    DCBRECFM,DCBRECCC  CARRIAGE CONTROL ?            GP09317
         BZ    PRTEXITL           NO                            GP09317
         LA    R4,1(,R4)          ALLOW FOR IT                  GP09317
PRTEXITL LTR   R3,R3              ANY BLOCKSIZE?                GP09317
         BNZ   PRTEXITB           YES; CHECK LRECL IF F         GP09317
         LA    R3,1374            ARBITRARY                     GP09317
PRTEXITB TM    DCBRECFM,DCBRECF   F OR U ?                      GP09317
         BZ    PRTEXITV           NO; V OR D                    GP09317
         TM    DCBRECFM,DCBRECU   U?                            GP09317
         BO    PRTEXITX           YES; KEEP IT                  GP09317
         DR    R2,R4              GET BLOCKING FACTOR           GP09317
         LTR   R3,R3              AT LEAST ONE ?                GP09317
         BP    *+8                YES                           GP09317
         LA    R3,1               SET TO ONE                    GP09317
         MR    R2,R4              GET NEW BLOCK SIZE            GP09317
         B     PRTEXITX           STASH BACK                    GP09317
PRTEXITV LA    R2,4(,R4)     LRECL+4                            GP09317
         CR    R2,R3         COMPARE TO BLOCK                   GP09317
         BNH   PRTEXITX      OK                                 GP09317
         OI    DCBRECFM,DCBRECSB  NEED SPANNED OR LARGER BLOCK  GP09317
PRTEXITX STH   R3,DCBBLKSI   SET NEW BLOCK SIZE                 GP09317
         STH   R4,DCBLRECL      AND RECORD LENGTH               GP09317
         ST    R4,MAXLRECL-SYSPRINT(,R1)  SAVE FOR LOCATE MODE  GP09329
         BR    R14           AND RETURN TO OPEN                 GP09317
         LTORG ,                                                GP09317
         POP   USING                                            GP09317
         EJECT ,                                                GP09317
**********************************************************************
*                                                                    *
* DOJCL  - Check if the JCLOUT DD statement is there and if so       *
*          dump out the sample JCL                                   *
*          ** this routine establishes its own base reg as R7 **     *
*          no input args,                                            *
*          Return via R8                                             *
*                                                                    *
**********************************************************************
*
DOJCL    LR    R7,R15                 We will use R7 as our base
         USING DOJCL,R7
         DEVTYPE DCBDDNAM-IHADCB+JCLOUT,WURK                    GP09317
         BXH   R15,R15,DOJ009                                   GP09317
         OPEN  (JCLOUT,(OUTPUT))
         TM    DCBOFLGS-IHADCB+JCLOUT,DCBOFOPN  Did it open?    GP09317
         BO    DOJ010                 Yes, skip
DOJ009   L     R1,=A(PARMLENG)                                  GP09317
         ICM   R0,3,PARMLENG-PARMLENG(R1)  Any restore parm?    GP09317
         BNZR  R8                     Yes; don't need JCL       GP09317
         WTO   'DSSREST - No JCLOUT DD statement, sample JCL not generaX
               ted',ROUTCDE=11
         BR    R8                     Just forget about it
*
DOJ010   BAL   R14,DOJCLEAR           Just in case              GP09317
         MVC   CARD+2(23),=C'DSSREST  JOB  TIME=1440'           GP09317
         L     R14,PSATOLD-PSA        Get TCB                   GP09317
         L     R14,TCBTIO-TCB(,R14)   Get TIOT                  GP09317
         MVC   CARD+2(8),0(R14)       Copy job name             GP09317
         BAL   R14,PUTJCL                                       GP09317
         MVC   CARD+2(48),=C'RESTORE EXEC PGM=DSSREST,REGION=8000K,TIMEX
               =1440,'                                          GP09317
         BAL   R14,PUTJCL                                       GP09317
         MVC   CARD+15(8),=C'PARM=''*'''    Room for DSN        GP09317
         BAL   R14,PUTJCL                                       GP09317
         L     R14,PSATOLD-PSA        Get TCB                   GP09317
         ICM   R14,7,TCBJLB-TCB+1(R14)  Is there a STEPLIB ?    GP09317
         BZ    SKPSTEPL               No, so don't gen one      GP09317
         MVC   CARD+2(45),=C'STEPLIB  DD  DISP=SHR,DSN=HERC01.DSSREST.L*
               OAD'                   May get replaced          GP09317
         LA    R1,CARD+2              Point to DD name STEPLIB  GP09317
         BAL   R14,GETJFCB            Find the JFCB, if any     GP09317
           B   SKPSTEPA               May be JOBLIB or task lib GP09317
         B     SKPSTEPC               Have STEPLIB              GP09317
SKPSTEPA LA    R1,=CL8'JOBLIB '       Point to DD name JOBLIB   GP09317
         BAL   R14,GETJFCB            Find the JFCB, if any     GP09317
           B   SKPSTEPD               May be JOBLIB or task lib GP09317
SKPSTEPC MVC   CARD+28(44),0(R1)      Copy DSN                  GP09317
SKPSTEPD BAL   R14,PUTJCL                                       GP09317
SKPSTEPL MVC   CARD+2(21),=C'SYSPRINT DD  SYSOUT=*'
         BAL   R14,PUTJCL                                       GP09317
         MVC   CARD+2(21),=C'REPORT   DD  SYSOUT=*'
         BAL   R14,PUTJCL                                       GP09317
         MVC   CARD+2(64),=C'SYSUT1   DD  DISP=OLD,UNIT=480,LABEL=(1,NLX
               ),VOL=SER=000001 <=CHK'
         L     R1,=A(SYSUT1)          Check for DD name replace GP09317
         LA    R1,DCBDDNAM-IHADCB(,R1)    DD name supplied      GP09317
         BAL   R14,GETJFCB            Get JFCB and DEVTYPE      GP09317
           B   SKPUT1                 None ??? Make default     GP09317
         PUSH  USING                                            GP09317
         LR    R5,R1                  Save JFCB address         GP09317
         USING INFMJFCB,R5            Declare it                GP09317
         BAL   R14,DOJCLEAR           Clear card image          GP09317
         MVC   CARD+2(22),=C'SYSUT1   DD  DISP=OLD,UNIT=480,LABEL=(1,NLX
               ),VOL=SER=000001 <=CHK'   Use partial string     GP09317
         CLI   DORK+2-DYNMSG1(R5),UCB3DACC   DASD ?             GP09317
         BNE   UT1TAPE                No                        GP09317
         MVC   CARD+20(3),=C'SHR'                               GP09317
UT1TAPE  MVC   CARD+24(4),=C'DSN='                              GP09317
         MVC   CARD+28(44),JFCBDSNM   Copy DSN                  GP09317
         TRT   CARD+28(45),TRTBLANK   Find end                  GP09317
         TM    JFCBIND1,JFCPDS        Member?                   GP09317
         BZ    UT1NMEM                No                        GP09317
         MVI   0(R1),C'('                                       GP09317
         MVC   1(8,R1),JFCBELNM       Add member name           GP09317
         TRT   CARD+24(45),TRTBLANK   Find end                  GP09317
         MVI   0(R1),C')'                                       GP09317
         LA    R1,1(,R1)                                        GP09317
UT1NMEM  MVI   0(R1),C','                                       GP09317
         BAL   R14,PUTJCL                                       GP09317
         TM    JFCBTSDM,JFCCAT        Cataloged ?               GP09317
         BNZ   UT1SKPUV               Yes; skip unit/volser     GP09317
         CLI   JFCBVLCT,0             Any volume serials?       GP09317
         BE    UT1SKPUV               No                        GP09317
         MVC   CARD+15(9),=C'UNIT=TAPE'                         GP09317
         CLI   DORK+2-DYNMSG1(R5),UCB3DACC   DASD ?             GP09317
         BNE   UT1TAP2                No                        GP09317
         MVC   CARD+20(8),=C'SYSALLDA'                          GP09317
UT1TAP2  TRT   CARD+15(65),TRTBLANK   I got lazy                GP09317
         MVC   0(10,R1),=C',VOL=SER=('                          GP09317
         LA    R1,10(,R1)                                       GP09317
         LA    R15,JFCBVOLS           Point to first            GP09317
         SR    R4,R4                  Clear for volume count    GP09317
         ICM   R4,1,JFCBNVOL          Number of serials         GP09317
         BNZ   *+8                                              GP09317
         LA    R4,1                   Force at least one        GP09317
         CH    R4,=H'5'               Not too many ?            GP09317
         BNH   UT1VOLLP               OK                        GP09317
         LA    R4,5                   Force at least one        GP09317
UT1VOLLP CLI   0(R15),C' '            Blank ?                   GP09317
         BNH   UT1VOLND               Yes; done                 GP09317
         MVC   0(6,R1),0(R15)         Copy one serial           GP09317
         TRT   CARD+25(58),TRTBLANK   Find end                  GP09317
         MVI   0(R1),C','                                       GP09317
         LA    R15,6(,R15)                                      GP09317
         LA    R1,1(,R1)              Skip comma                GP09317
         BCT   R4,UT1VOLLP                                      GP09317
UT1VOLND BCTR  R1,0                   Back over comma           GP09317
         MVC   0(2,R1),=C'),'                                   GP09317
         BAL   R14,PUTJCL                                       GP09317
UT1SKPUV MVC   CARD+15(7),=C'LABEL=('                           GP09317
         LA    R4,CARD+22             Next position             GP09317
         SR    R1,R1                                            GP09317
         ICM   R1,3,JFCBFLSQ          Any file sequence ?       GP09317
         BZ    UT1SKPFL               No                        GP09317
         BAL   R14,DOJINSRT           Add it                    GP09317
UT1SKPFL MVC   0(4,R4),=C',SL)'       Default                   GP09317
         TM    JFCBLTYP,X'77'         Any LABEL spec?           GP09317
         BZ    SKPUT1                 No; done                  GP09317
         LM    R15,R1,=A(TAPLAB,TAPLAB2-TAPLAB,TAPLABN)         GP09317
UT1LABLP IC    R14,3(,R15)            Load mask                 GP09317
         EX    R14,EXLABTM            Match ?                   GP09317
         BO    UT1LABTP               Yes                       GP09317
         BXLE  R15,R0,UT1LABLP        Try again                 GP09317
         B     SKPUT1                 Keep default              GP09317
         SPACE 1
EXLABTM  TM    JFCBLTYP,*-*                                     GP09317
TAPLAB   DC    CL3'AUL',AL1(JFCBAL+8)                           GP09317
TAPLAB2  DC    CL3'AL ',AL1(JFCBAL)                             GP09317
         DC    CL3'LTM',AL1(JFCBLTM)                            GP09317
         DC    CL3'BLP',AL1(JFCBLP)                             GP09317
         DC    CL3'SUL',AL1(JFCSUL)                             GP09317
         DC    CL3'NSL',AL1(JFCNSL)                             GP09317
         DC    CL3'SL ',AL1(JFCSL)                              GP09317
TAPLABN  DC    CL3'NL ',AL1(JFCNL)                              GP09317
         SPACE 1
UT1LABTP MVC   1(3,R4),0(R15)         Move label type           GP09317
         CLI   3(R4),C' '             2 or 3 byte ?             GP09317
         BNE   *+6                                              GP09317
         BCTR  R4,0                                             GP09317
         MVI   4(R4),C')'             Close                     GP09317
SKPUT1   BAL   R14,PUTJCL                                       GP09317
         POP   USING                                            GP09317
         MVI   CARD+2,C'*'
         BAL   R14,PUTJCL                                       GP09317
         L     R1,=A(DSNTA#1)         Get addr DSN table chain anchor
         L     R5,0(,R1)              Point to first DSN table entry
         LTR   R5,R5                  Any chain established?
         BNZ   DOJ020                 yep, skip
         MVC   CARD(45),=C'*error* no datasets were eligible for restorX
               e'
         BAL   R14,PUTJCL                                       GP09317
         B     DOJ900
DOJ020   DS    0H
         SLR   R6,R6                  R6 will count datasets
*
* * loop through chained entries in DSNtable generating JCL
*
DOJ030   DS    0H
         LA    R6,1(,R6)              Bump dataset counter
*WHY?*   BAL   R14,DOJCLEAR            Clear card
         MVC   CARD+2(14),=C'SYSUT2 DD DSN='
         MVC   CARD+16(44),DSNTDSN    Insert DSN
         LA    R1,CARD+17             Init scan reg
DOJ035   DS    0H
         CLI   0(R1),C' '             end of DSN?
         BE    DOJ040                 yes, skip
         LA    R1,1(,R1)              no, bump ptr
         B     DOJ035                 keep looking
DOJ040   DS    0H
         MVI   0(R1),C','             comma after DSN
         MVC   CARD+63(2),=C'/*'
         LA    R4,CARD+65             insert sequence # here
         LR    R1,R6                  # to insert
         BAL   R14,DOJINSRT            put in message
         MVC   0(2,R4),=C'*/'
         BAL   R14,PUTJCL                                       GP09317
*
         MVC   CARD+12(43),=C'DISP=(,CATLG,DELETE),FREE=CLOSE,DCB=(DSORX
               G='
         MVC   CARD+55(2),DSNTDSOR    insert DSORG (first 2 chars)
         MVI   CARD+57,C','
         BAL   R14,PUTJCL                                       GP09317
*
         MVC   CARD+12(6),=C'RECFM='
         MVC   CARD+18(5),DSNTRECC    Insert character version of RECFM
         TRT   CARD+18(6),TRTBLANK    last byte of recfm        GP09317
         LR    R4,R1                  blank                     GP09317
         CLI   DSNTRECC,C'U'          RECFM=U?                  GP09317
         BE    SKPRECF                Yes; no LRECL             GP09317
         MVC   0(7,R4),=C',LRECL='                              GP09317
         LA    R4,7(,R4)              point to start of lrecl value
         SLR   R1,R1
         ICM   R1,B'0011',DSNTLREC    get lrecl value
         BAL   R14,DOJINSRT            put in card
SKPRECF  MVC   0(9,R4),=C',BLKSIZE='
         LA    R4,9(,R4)              start of blksize value
         SLR   R1,R1
         ICM   R1,B'0011',DSNTBLKS    get blksize value
         BAL   R14,DOJINSRT            put in card
* decide if we will close off the DCB info or continue on another card
         CLI   DSNTKEYL,X'00'
         BNE   DOJ060                 add another card
         CLC   DSNTRKP,=XL2'00'
         BNE   DOJ060
         TM    DSNTOPTC,X'DE'         any optcd (other than junk)
         BNZ   DOJ060
* no need for another card, close this card and skip
         MVC   0(2,R4),=C'),'
         BAL   R14,PUTJCL                                       GP09317
         B     DOJ080                 skip next card
* add extra card if keys or optcode was detected
DOJ060   DS    0H
         MVI   0(R4),C','             comma after blksize value
         BAL   R14,PUTJCL                                       GP09317
         LA    R4,CARD+12             Initialise dest ptr if needed
         CLI   DSNTKEYL,X'00'         key leng?
         BNE   DOJ065                 yep, generate key stuff
         CLC   DSNTRKP,=XL2'00'       nope, are you sure no key stuff?
         BE    DOJ070                 no key stuff,must have been optcd
DOJ065   DS    0H
         MVC   CARD+12(7),=C'KEYLEN='
         SLR   R1,R1
         IC    R1,DSNTKEYL            get key length
         LA    R4,CARD+19             point where it goes
         BAL   R14,DOJINSRT            put in card
         SLR   R1,R1
         MVC   0(5,R4),=C',RKP='
         LA    R4,5(,R4)              point to where value goes
         ICM   R1,B'0011',DSNTRKP     get value
         BAL   R14,DOJINSRT            put in card
         TM    DSNTOPTC,X'DE'         any optcd (other than junk)
         BZ    DOJ075                 no, skip to close DCB field
         MVI   0(R4),C','             yes, put in a comma
         LA    R4,1(,R4)              bump dest
DOJ070   DS    0H
         TM    DSNTOPTC,X'DE'         any optcd (other than dumb stuff)
         BZ    DOJ075                 no, skip
* need more code here for OPTCD
         MVC   0(33,R4),=C'OPTCD=check-this-field-in-report,'
         LA    R4,33(,R4)
DOJ075   DS    0H
         MVC   0(2,R4),=C'),'         Close out the DCB field
         BAL   R14,PUTJCL                                       GP09317
* get track capacity; check for user labels                     GP09317
DOJ080   MVC   TRKCAPSV,=F'4096'      with a default track capacity
         CLI   DSNTDEV+2,X'20'        Is device class Disk?
         BNE   DOJ081                 no, don't know then
         TM    DSNTDEV+3,X'F0'        Is first nibble zeros?
         BNZ   DOJ081                 No, I'm confused then
         SLR   R1,R1                  Clear R1
         IC    R1,DSNTDEV+3           get device code
         SLL   R1,3                   times 8
         LA    R1,DEVNAMC(R1)         pick up device name address
         MVC   TRKCAPSV,4(R1)         save track capacity for later
DOJ081   TM    DSNTFLGS,DSNTFSUL      User labels?              GP09317
         BZ    DOJ082                 No                        GP09317
*fails*  MVC   CARD+12(13),=C'LABEL=(,SUL),'                    GP09317
* space
DOJ082   TRT   CARD+12(60),TRTBLANK                             GP09317
         MVC   0(10,R1),=C'SPACE=(TRK'                          GP09317
*                                     get numbr of tracks in 1st extent
*                                     Rather than using the primary
*                                     allocation that was computed
*                                     from the first extent description
*                                     in the FMT1DSCB (and possibly
*                                     forcing use of secondary extents)
*                                     we will instead force the primary
*                                     allocation to equal the number of
*                                     tracks (or cyls) we actually saw
*                                     in the dump.  This may cause more
*                                     problems than it avoids . . .
*                                            time will tell.
         L     R15,DSNTTRKC           Number of tracks          GP09317
         TM    DSNTFLGS,DSNTFSUL      Label track?              GP09317
         BZ    *+6                    No                        GP09317
         BCTR  R15,0                  Allow for labels          GP09317
         ST    R15,WURK               Save data track count     GP09317
*
*                                     BUT if first extent was larger
*                                     than # track images we will keep
*                                     the first extent size as
*                                     primary allocation
*
         CLC   DSNTPTRK,WURK          Is 1st ext larger than trks used
         BNH   DOJ087                 yes, keep this value      GP09317
         MVC   WURK,DSNTPTRK          no, get actual number of tracks
DOJ087   LA    R4,7(,R1)              Space to CYL position     GP09317
         TM    DSNTFLGS,DSNTFCYL      is it cyls?
         BNO   DOJ090                 no, skip
         MVC   0(3,R4),=C'CYL'        yes, say cylinders        GP09317
         SLR   R0,R0
         L     R1,WURK                get R0,R1=#tracks
         CLC   DSNTTRCY,=XL2'00'      avoid 0C9 (improbable)
         BE    DOJ090                 skip on zero
         XC    WURK2,WURK2            clear fullword
         MVC   WURK2+2(2),DSNTTRCY    # tracks per cyl
         D     R0,WURK2               R1=# cyls
         ST    R1,WURK                replace track count
         LTR   R0,R0                  was there a remainder
         BZ    DOJ090                 no, skip
         LA    R1,1(,R1)              yes, bump up # cyls
         ST    R1,WURK                and save it.
DOJ090   DS    0H
         L     R1,WURK                pick up primary allocation
         MVC   3(2,R4),=C',('                                   GP09317
         LA    R4,5(,R4)              point to dest             GP09317
         BAL   R14,DOJINSRT            insert primary alloc
*
* * Check out secondary space value.  Adjust whatever we found to
* * to match the TRK,CYL units put in the primary.
*
         CLC   DSNTSAL3,=XL3'00'      Is there a value there?
         BNE   DOJ095                 yep, process it
         CLC   DSNTDSOR(2),=C'PO'     do we need to add directory blks?
         BNE   DOJ110                 no, we can close out space parm
         MVI   0(R4),C','             yes, comma says secondary missing
         LA    R4,1(,R4)              bump dest pointer
         B     DOJ105                 and insert ",1" dir blk alloc
DOJ095   DS    0H
         MVI   0(R4),C','             comma before secondary value
         LA    R4,1(,R4)              bump dest
         XC    WURK,WURK              Assume secondary alloc is zero
*****    TM    DSNTSAL1,DS1CYL        Cylinders?
         TM    DSNTSAL1,X'C0'         MVS 3.8J doesn't have DS1CYL
         BNO   DOJ096                 nope, skip
         MVC   WURK+1(3),DSNTSAL3     yep, get secondary value
         TM    DSNTFLGS,DSNTFCYL      was primary in cyls
         BO    DOJ100                 yes, just insert value we found
*                                     if not, we had primary as trks so
*                                     we must multiply by # trk/cyl
         LH    R1,DSNTTRCY            # trk/cyl
         M     R0,WURK                times secondary value
         ST    R1,WURK                gives new secondary value
         B     DOJ100                 go insert it
DOJ096   DS    0H
*****    TM    DSNTSAL1,DS1TRK        Secondary in Tracks?
         TM    DSNTSAL1,X'80'         MVS 3.8J doesn't have DS1TRK
         BNO   DOJ097                 nope, skip
         MVC   WURK+1(3),DSNTSAL3     yep, get secondary value
         TM    DSNTFLGS,DSNTFCYL      was primary in cyls
         BNO   DOJ100                 no, just insert value we found
*                                     if yes, we had primary as cyls so
*                                     we must divide by # trk/cyl
         SLR   R0,R0
         L     R1,WURK                get R0,R1=#tracks
         CLC   DSNTTRCY,=XL2'00'      avoid 0C9 (improbable)
         BE    DOJ100                 skip on zero
         XC    WURK2,WURK2            clear fullword
         MVC   WURK2+2(2),DSNTTRCY    # tracks per cyl
         D     R0,WURK2               R1=# cyls
         ST    R1,WURK                replace track count with # cyls
         LTR   R0,R0                  was there a remainder?
         BZ    DOJ100                 no, go insert value
         LA    R1,1(,R1)              yes, round up 1 cyl
         ST    R1,WURK                save the value and
         B     DOJ100                 go insert it
DOJ097   DS    0H
*****    TM    DSNTSAL1,DS1AVR        Avg blk leng request?
         TM    DSNTSAL1,X'40'         MVS 3.8J doesn't have DS1AVR
         BO    DOJ098                 yes, skip
         MVC   0(3,R4),=C'???'        no, I'm confused then so give up
         LA    R4,3(,R4)              bump dest
         B     DOJ102                 skip over value insert
DOJ098   DS    0H
* secondary was in blks, we have to convert that to trks using the
* track length for the device in question then we (potentially) have
* to change the value to cyls if we are doing cylinder allocation
         SLR   R0,R0
         L     R1,TRKCAPSV            get R0,R1=saved track capacity
         XC    WURK2,WURK2            clear fullword
         OC    WURK2+2(2),DSNTBLKS    get blocksize             GP09317
         BZ    DOJ0981                Avoid 0C9                 GP09317
         D     R0,WURK2               R1=# blocks/trk
         LTR   R1,R1                  is it at least 1?
         BNZ   DOJ0983                yes, skip
DOJ0981  DS    0H
         LA    R1,1                   default 1 block per track
DOJ0983  DS    0H
         ST    R1,WURK                save # blocks per track
         SLR   R0,R0
         SLR   R1,R1
         ICM   R1,B'0111',DSNTSAL3    get secondary quantity
         D     R0,WURK                R1=# tracks for secondary
         TM    DSNTFLGS,DSNTFCYL      was primary in cyls
         BNO   DOJ099                 no, just insert value we found
         CLC   DSNTTRCY,=XL2'00'      avoid 0C9 (improbable)
         BE    DOJ099                 skip on zero
         XC    WURK,WURK
         MVC   WURK+2(2),DSNTTRCY     get trks/cyl
         SLR   R0,R0
         D     R0,WURK                R1=#full cyls
         LTR   R0,R0                  was it even # (remainder zero?)
         BZ    DOJ099                 yes, skip
         LA    R1,1(,R1)              no, round up to 1 more cyl
DOJ099   DS    0H
         ST    R1,WURK                save secondary value
         LTR   R1,R1                  look at secondary value
         BNZ   DOJ100                 ok, it's non-zero
         MVC   WURK,=F'1'             at least put 1 in after that work
*
DOJ100   DS    0H
         L     R1,WURK                get the secondary value we chose
         BAL   R14,DOJINSRT            put in card
DOJ102   DS    0H
         CLC   DSNTDSOR(2),=C'PO'     was it partitioned?
         BNE   DOJ110                 no, skip the dir blks
DOJ105   DS    0H
         MVC   0(2,R4),=C',1'         "token" val of 1 dir blk for PO
         LA    R4,2(,R4)              bump dest
DOJ110   MVC   0(3,R4),=C')),'        Close SPACE               GP09317
         BAL   R14,PUTJCL             Write it                  GP09317
         SPACE 1
         MVC   CARD+12(5),=C'UNIT='
         MVC   CARD+17(4),=CL4'????'  Assume device type unknown
         CLI   DSNTDEV+2,X'20'        Is device class Disk?
         BNE   DOJ115                 no, don't know then
         TM    DSNTDEV+3,X'F0'        Is first nibble zeros?
         BNZ   DOJ115                 No, I'm confused then
         SLR   R1,R1                  Clear R1
         IC    R1,DSNTDEV+3           get device code
         SLL   R1,3                   times 8
         LA    R1,DEVNAMC(R1)         pick up device name address
         MVC   CARD+17(4),0(R1)       save name
DOJ115   TRT   CARD+17(55),TRTBLANK                             GP09317
*                         *********
         MVC   1(8,R1),=C'VOL=SER='   close out unit parm       GP09329
*                         *********   Insert VOL=SER as comment only
         L     R14,=A(PROFLAGS)       unless requested by user  GP09329
         TM    PROFLAGS-PROFLAGS(R14),PFVOL   with PARM=VOL     GP09329
         BZ    *+8                                              GP09329
         MVI   0(R1),C','             Include original serial   GP09329
         MVC   9(6,R1),DSNTVOLS       insert the original volser
         BAL   R14,PUTJCL             Last card of DD           GP09317
*
* * see if there are more datasets to process
*
         L     R5,DSNTANXT            Follow forward chain
         LTR   R5,R5                  any more ?
         BNZ   DOJ030                 yep, go spit it out
         BAL   R14,PUTJCL             Last card of job          GP09317
*
DOJ900   DS    0H
         CLOSE (JCLOUT)               Close JCLOUT file
         BR    R8                     and return
*
* * Subroutines to PUT card image to JCL out, and clear card
*
PUTJCL   ST    R14,DBLWRK             Remember return           GP09317
         PUT   JCLOUT,CARD            Write the card image      GP09317
         L     R14,DBLWRK             Remember return           GP09317
DOJCLEAR MVC   CARD(3),=C'// '
         MVC   CARD+3(76),CARD+2
         BR    R14
*
* * subrtn to insert integer contained in R1 into location pointed
* * to by R4, R4 updated to point past integer
*
DOJINSRT DS    0H
         CVD   R1,DBLWRK
         UNPK  CL16,DBLWRK
         OI    CL16+15,X'F0'          Fix final sign
         LA    R2,15                  Skip up to 15 leading zeros
         LA    R1,CL16-1              Point to input - 1
DOJI05   DS    0H
         LA    R1,1(,R1)              next input byte
         CLI   0(R1),C'0'             zero?
         BNE   DOJI10                 no, begin moving
         BCT   R2,DOJI05              yes, skip up to 15 leading zeros
         LA    R1,1(,R1)              point to 16th digit
DOJI10   DS    0H
         LA    R2,1(,R2)              adjust counter
DOJI15   DS    0H
         MVC   0(1,R4),0(R1)          move a digit
         LA    R4,1(,R4)              bump destination
         LA    R1,1(,R1)              bump source
         BCT   R2,DOJI15              do all remaining digits
         BR    R14                    and return
*
CARD     DC    CL80'//'               JCL card buffer
TRKCAPSV DS    F                      Saved track capacity
WURK     DS    F                      Work
WURK2    DS    F                      Work
DBLWRK   DS    D                      Work
CL16     DS    CL16                   Work
JCLOUT   DCB   DDNAME=JCLOUT,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,      X
               EXLST=JCLXLIST
*
JCLXLIST DC    0A(0),X'85',AL3(JCLOXIT)  JCLOUT OPEN exit       GP09317
         SPACE 1
TRTBLANK DC    256AL1(0)     TRT TABLE TO FIND BLANKS           GP09317
         ORG   TRTBLANK+C' '                                    GP09317
         DC    X'40'                                            GP09317
         ORG   ,                                                GP09317
         SPACE 1
*---------------------------------------------------------------------*
* * JCLOUT Open Exit, ensure there is a blksize on JCLOUT             *
* *  (we didn't put one in DCB in case output was an existing dataset)*
*---------------------------------------------------------------------*
         PUSH  USING                                            GP09317
         DROP  ,                                                GP09317
         USING JCLOXIT,R15                                      GP09317
         USING IHADCB,R1
JCLOXIT  CLC   DCBBLKSI,=H'0'         Is blksize zero?
         BNER  R14                    no, assume its good and exit
         MVC   DCBBLKSI,=H'3040'      force a low but reasonable blksze
         BR    R14
         POP   USING                                            GP09317
         DROP  R7                     Get rid of JCL dump rtn base
*
DEVNAMC  DS    0F Table of device types and track capacities
         DC    CL4'????',F'4096' fake        0
         DC    CL4'2311',F'3625'             1                  GP09317
         DC    CL4'2301',F'20483'            2                  GP09317
         DC    CL4'2303',F'4892'             3                  GP09317
*OLD*    DC    CL4'2302',F'4096' fake        4                  GP09317
         DC    CL4'9345',F'27998'            4                  GP09317
         DC    CL4'2321',F'4096' fake        5
         DC    CL4'2305',F'14136'            6                  GP09317
         DC    CL4'2305',F'14660'            7                  GP09317
         DC    CL4'2314',F'7294'             8
         DC    CL4'3330',F'13030'            9                  GP09317
         DC    CL4'3340',F'8368'            10                  GP09317
         DC    CL4'3350',F'19069'           11                  GP09317
         DC    CL4'3375',F'17600'           12                  GP09317
         DC    CL4'3330',F'13030'           13                  GP09317
         DC    CL4'3380',F'23476'           14                  GP09317
         DC    CL4'3390',F'27998'           15                  GP09317
         LTORG ,                      For JCL dump routine literals
         SPACE 1
         PUSH  USING                                            GP09317
         DROP  ,                                                GP09317
GETJFCB  BALR  R15,0                                            GP09317
         USING *,R15                                            GP09317
GETJFCB2 STM   R2,R15,DYNSAREA        Save return info          GP09317
         LR    R12,R15                Better base               GP09317
         DROP  R15                                              GP09317
         USING GETJFCB2,R12                                     GP09317
         LR    R5,R1                  Save DD name pointer      GP09317
         DEVTYPE 0(R5),DORK           Is DD present ?           GP09317
         BXH   R15,R15,GETJFCB0       No                        GP09317
         MVC   DCBJFCB+DCBDDNAM-IHADCB(8),0(R5)  Stick DD name  GP09317
         MVI   DYNMSG1,0              Zero to check             GP09317
         RDJFCB (DCBJFCB)             Get JFCB                  GP09317
         CLI   DYNMSG1,0              Any DD name ?             GP09317
         BE    GETJFCB0               No; take +0 exit          GP09317
         LA    R1,DYNMSG1             Point to JFCB             GP09317
         LM    R2,R15,DYNSAREA        Reload registers          GP09317
         B     4(,R14)                Good return               GP09317
GETJFCB0 SR    R1,R1                  No JFCB                   GP09317
         LM    R2,R15,DYNSAREA        Reload registers          GP09317
         BR    R14                    Bad return                GP09317
         SPACE 1
DCBJFCB  DCB   DDNAME=*,DSORG=PS,MACRF=GL,EXLST=DCBJEXIT        GP09317
DCBJEXIT DC    0A(0),X'87',AL3(DYNMSG1)     JFCB                GP09317
         POP   USING                                            GP09317
         SPACE 1
*
*
* * Subroutine to do the dynamic allocation.
* *
* * Note: This is a full-fledged subroutine that will save/restore
* *       regs plus provide its own addressability
* *
* * On entry, R1 points to a parm area with the following format:
* *
* *    1) DSNTAB entry for file to be allocated
* *    2) Dynalloc RC (fullword)
* *    3) S99ERROR    (fullword)
* *    4) # messages returned (halfword)
* *    5) address of MSG1 (returned value)
* *    6) address of MSG2 (returned value)
* *    7) Input High Level Qualifier (or blanks),
* *       To allow some tailoring of dataset names, this field can
* *       be set to a non-blankl value which will be used to replace
* *       the highest level qualifier in the DSNTDSN.  Useful when
* *       you want to change the HLQ on all datasets in the dump.
* *       Be careful if this qualifier is longer than the original
* *       as it could cause dataset names to exceed 44 bytes.
* *
* *       On return it contains the DDNAME allocated (8 chars)
* *
* * On return, R15=0 Allocation successful
* *            R15>0 Errors occurred, check returned messages
*
DYNALLO  DS    0H
         STM   14,12,12(13)           save caller's regs
         LR    R9,R15                 get start address
         LA    R10,4095(,R9)
         LA    R10,1(,R10)            compute second base (not needed)
         USING DYNALLO,R9,R10         set up my base regs.
         ST    R13,DYNSAREA+4         save A(HSA)
         LR    R14,R13                and again
         LA    R13,DYNSAREA           point to my savearea
         ST    R13,8(0,R14)           and chain saveareas.
*
* * Set up parm addresses for this invocation + initialise stuff
*
         L     R5,0(,R1)              DSN table entry pointer
         USING DSNTAB,R5
         LA    R6,4(,R1)              R6->SVC99 RC area
         XC    0(8,R6),0(R6)            clear it & S99ERROR field
         LA    R7,12(,R1)             R7-># messages returned
         XC    0(4,R7),0(R7)            clear it
         LA    R2,DYNMSG1             Point to MSG1 area
         ST    R2,4(,R7)              return in parms
         MVI   0(R2),C' '
         MVC   1(132,R2),0(R2)        Clear MSG1 area
         LA    R2,DYNMSG2             Point to MSG2 area
         ST    R2,8(,R7)              return in parms
         MVI   0(R2),C' '
         MVC   1(132,R2),0(R2)        Clear MSG2 area
         LA    R8,24(,R1)             R8->HLQ to substitute (also
*                                     doubles as area to return DDNAME)
*
* * Go through and insert values in the text units.  Some TUs are
* * optional, if they are used then insert their address in the
* * list of TU pointers; if unused set the corresponding TO ptr to zero
* *
* * Note: This code is very similar to the "DOJCL" routine in terms of
* *       how it interprets the DSN table entry.  In particular, the
* *       way it calculates SPACE values is the same.  (actually
* *       coded this by copying DOJCL as a base to work from)
*
* * First order of business is to set up the DSN.  Apply the
* * change to High Level Qualifier if requested
*
         CLC   0(8,R8),=CL8' '        Is HLQ blank?
         BE    DYN090                 Yes, no need to substitute
         LA    R2,TUVDSNAM+6          Address target DSN area
         MVI   0(R2),C' '
         MVC   1(43,R2),0(R2)         Blank out DSN
         LA    R4,44                  Max length of DSN
         LR    R3,R8                  Point to HLQ
         LA    R1,8                   Max HLQ leng
DYN050   DS    0H
         CLI   0(R3),C' '             End of HLQ?
         BE    DYN055                 yes, skip
         MVC   0(1,R2),0(R3)          move HLQ byte
         LA    R2,1(,R2)              next target byte
         LA    R3,1(,R3)              next source byte
         BCTR  R4,0                   decrement DSN space left
         BCT   R1,DYN050              do up to 8 bytes of HLQ
DYN055   DS    0H
         LA    R1,9                   Max prefix leng on DSNTDSN
         LA    R15,44                 Max source DSN length
         LA    R3,DSNTDSN             Point to source
DYN060   DS    0H
         CLI   0(R3),C' '             End of source?
         BE    DYN065                 yes, that's strange
         CLI   0(R3),C'.'             End of source HLQ?
         BE    DYN065                 yes, that's normal
         LA    R3,1(,R3)              next source byte
         BCTR  R15,0                  decrement source leng left
         BCT   R1,DYN060              do up to 9 bytes of HLQ
DYN065   DS    0H
         CLI   0(R3),C'.'             End of source?
         BE    DYN070                 Yep, skip
         MVC   DYNMSG1(26),=C'Error applying DSN prefix,'
         MVC   DYNMSG2(30),=C'DSN blank or single level DSN.'
         B     DYNRET2                Return error
DYN070   DS    0H
* R2->target, R3->source, R4=target space left, R15=source chars left
         CLI   0(R3),C' '             End of source
         BE    DYN100                 Yes, all done
         BCT   R4,DYN075              check target space
         B     DYN080                 out of space
DYN075   DS    0H
         MVC   0(1,R2),0(R3)          move byte to target
         LA    R2,1(,R2)              next target byte
         LA    R3,1(,R3)              next source byte
         BCT   R15,DYN070             go till end of source
         B     DYN100                 all finished prefixing
DYN080   DS    0H
         MVC   DYNMSG1(26),=C'Error applying DSN prefix,'
         MVC   DYNMSG2(30),=C'resulting DSN > 44 chars long.'
         B     DYNRET2                Return error
*
DYN090   DS    0H
         MVC   TUVDSNAM+6(44),DSNTDSN no prefixing, just copy DSN to TU
*
DYN100   DS    0H
*
         MVC   TUVDSORG+6(2),DSNTDSOB insert DSORG (FMT1 DSCB bin val)
*
         MVC   TUVRECFM+6(1),DSNTRECF insert bin RECFM
*
         MVC   TUVLRECL+6(2),DSNTLREC insert LRECL
*
         MVC   TUVBLKSZ+6(2),DSNTBLKS insert BLKSIZE
*
         CLI   DSNTKEYL,X'00'         Is there a key length?
         BE    DYN110                 no, skip
         CLC   DSNTRKP,=XL2'00'       Yes, is there a relative key pos
         BE    DYN105                 no, good, skip
         MVC   DYNMSG1(27),=C'Error, dataset has keys and'
         MVC   DYNMSG2(31),=C'relative key position is not 0.'
         B     DYNRET2                Return error
DYN105   DS    0H
         MVC   TUPKYLEN,=AL4(TUVKYLEN) activate key length TU
         MVC   TUVKYLEN+6(1),DSNTKEYL place key leng in TU
         B     DYN115
DYN110   DS    0H
         XC    TUPKYLEN,TUPKYLEN      deactivate key leng TU
DYN115   DS    0H
*
         TM    DSNTOPTC,X'DE'         any optcd (other than junk)
         BZ    DYN120
         MVC   TUPOPTCD,=AL4(TUVOPTCD) activate OPTCD TU
         MVC   TUVOPTCD+6(1),DSNTOPTC insert OPTCD value
         B     DYN125
DYN120   DS    0H
         XC    TUPOPTCD,TUPOPTCD      disable optcd TU
DYN125   DS    0H
*
         CLI   DSNTDEV+2,X'20'        Is device class Disk?
         BNE   DYN130                 no, don't know then
         TM    DSNTDEV+3,X'F0'        Is first nibble zeros?
         BNZ   DYN130                 No, I'm confused then
         SLR   R1,R1                  Clear R1
         IC    R1,DSNTDEV+3           get device code
         SLL   R1,3                   times 8
         L     R2,=A(DEVNAMC)         get address of name/capacity tab
         LA    R1,0(R1,R2)            pick up device name address
         MVC   TUVUNIT+6(4),0(R1)     save name in UNIT TU
         MVC   DYNTRKCP,4(R1)         save track capacity
         B     DYN135
DYN130   DS    0H
         MVC   DYNMSG1(37),=C'Error, unable to determine unit type.'
         B     DYNRET1                Return error
DYN135   DS    0H
         MVC   TUPTRK,=AL4(TUVTRK)    Assume doing TRK allocation
         XC    TUPCYL,TUPCYL          so clear CYL TU.
         MVC   DORK,DSNTPTRK          get numbr of tracks in 1st extent
*
*   Note: this space calculation is different for DYNALLOC than
*         for when we generate JCL.  Here, we MUST use the first
*         extent description in the FMT1DSCB because we don't know
*         yet how many track images are in the dump.
*
*         Here is the documentation from the JCL method:
*                                     Rather than using the primary
*                                     allocation that was computed
*                                     from the first extent description
*                                     in the FMT1DSCB (and possibly
*                                     forcing use of secondary extents)
*                                     we will instead force the primary
*                                     allocation to equal the number of
*                                     tracks (or cyls) we actually saw
*                                     in the dump.  This may cause more
*                                     problems than it avoids . . .
*                                            time will tell.
*
*                                     BUT if first extent was larger
*                                     than # track images we will keep
*                                     the first extent size as
*                                     primary allocation
*
         TM    DSNTFLGS,DSNTFCYL      is it cyls?
         BNO   DYN140                 no, skip
         MVC   TUPCYL,=AL4(TUVCYL)    activate CYL allocation
         XC    TUPTRK,TUPTRK          so clear TRK TU.
         SLR   R0,R0
         L     R1,DORK                get R0,R1=#tracks
         CLC   DSNTTRCY,=XL2'00'      avoid 0C9 (improbable)
         BE    DYN140                 skip on zero
         XC    DORK2,DORK2            clear fullword
         MVC   DORK2+2(2),DSNTTRCY    # tracks per cyl
         D     R0,DORK2               R1=# cyls
         ST    R1,DORK                replace track count
         LTR   R0,R0                  was there a remainder
         BZ    DYN140                 no, skip
         LA    R1,1(,R1)              yes, bump up # cyls
         ST    R1,DORK                and save it.
DYN140   DS    0H
         MVC   TUVPRIME+6(3),DORK+1   move 3 byte primary allocation
*
* * Check out secondary space value.  Adjust whatever we found to
* * to match the TRK,CYL units put in the primary.
*
         XC    TUPSECND,TUPSECND      disable secondary space TU
         CLC   DSNTSAL3,=XL3'00'      Is there a value there?
         BE    DYN210                 no
         XC    DORK,DORK              Assume secondary alloc is zero
*****    TM    DSNTSAL1,DS1CYL        Cylinders?
         TM    DSNTSAL1,X'C0'         MVS 3.8J doesn't have DS1CYL
         BNO   DYN150                 nope, skip
         MVC   DORK+1(3),DSNTSAL3     yep, get secondary value
         TM    DSNTFLGS,DSNTFCYL      was primary in cyls
         BO    DYN200                 yes, just insert value we found
*                                     if not, we had primary as trks so
*                                     we must multiply by # trk/cyl
         LH    R1,DSNTTRCY            # trk/cyl
         M     R0,DORK                times secondary value
         ST    R1,DORK                gives new secondary value
         B     DYN200                 go insert it
DYN150   DS    0H
*****    TM    DSNTSAL1,DS1TRK        Secondary in Tracks?
         TM    DSNTSAL1,X'80'         MVS 3.8J doesn't have DS1TRK
         BNO   DYN160                 nope, skip
         MVC   DORK+1(3),DSNTSAL3     yep, get secondary value
         TM    DSNTFLGS,DSNTFCYL      was primary in cyls
         BNO   DYN200                 no, just insert value we found
*                                     if yes, we had primary as cyls so
*                                     we must divide by # trk/cyl
         SLR   R0,R0
         L     R1,DORK                get R0,R1=#tracks
         CLC   DSNTTRCY,=XL2'00'      avoid 0C9 (improbable)
         BE    DYN200                 skip on zero
         XC    DORK2,DORK2            clear fullword
         MVC   DORK2+2(2),DSNTTRCY    # tracks per cyl
         D     R0,DORK2               R1=# cyls
         ST    R1,DORK                replace track count with # cyls
         LTR   R0,R0                  was there a remainder?
         BZ    DYN200                 no, go insert value
         LA    R1,1(,R1)              yes, round up 1 cyl
         ST    R1,DORK                save the value and
         B     DYN200                 go insert it
DYN160   DS    0H
*****    TM    DSNTSAL1,DS1AVR        Avg blk leng request?
         TM    DSNTSAL1,X'40'         MVS 3.8J doesn't have DS1AVR
         BO    DYN170                 yes, skip
         MVC   DYNMSG1(49),=C'Error, unable to determine secondary spacX
               e units.'
         B     DYNRET1                Return error
DYN170   DS    0H
* secondary was in blks, we have to convert that to trks using the
* track length for the device in question then we (potentially) have
* to change the value to cyls if we are doing cylinder allocation
         SLR   R0,R0
         L     R1,DYNTRKCP            get R0,R1=saved track capacity
         XC    DORK2,DORK2            clear fullword
         MVC   DORK2+2(2),DSNTBLKS    get blocksize
         CLC   DSNTBLKS,=XL2'00'      avoid 0C9
         BE    DYN175
         D     R0,DORK2               R1=# blocks/trk
         LTR   R1,R1                  is it at least 1?
         BNZ   DYN180                 yes, skip
DYN175   DS    0H
         LA    R1,1                   default 1 block per track
DYN180   DS    0H
         ST    R1,DORK                save # blocks per track
         SLR   R0,R0
         SLR   R1,R1
         ICM   R1,B'0111',DSNTSAL3    get secondary quantity
         D     R0,DORK                R1=# tracks for secondary
         TM    DSNTFLGS,DSNTFCYL      was primary in cyls
         BNO   DYN185                 no, just insert value we found
         CLC   DSNTTRCY,=XL2'00'      avoid 0C9 (improbable)
         BE    DYN185                 skip on zero
         XC    DORK,DORK
         MVC   DORK+2(2),DSNTTRCY     get trks/cyl
         SLR   R0,R0
         D     R0,DORK                R1=#full cyls
         LTR   R0,R0                  was it even # (remainder zero?)
         BZ    DYN185                 yes, skip
         LA    R1,1(,R1)              no, round up to 1 more cyl
DYN185   DS    0H
         ST    R1,DORK                save secondary value
         LTR   R1,R1                  look at secondary value
         BNZ   DYN200                 ok, it's non-zero
         MVC   DORK,=F'1'             at least put 1 in after that work
*
DYN200   DS    0H
         MVC   TUPSECND,=AL4(TUVSECND) activate secondary space TU
         MVC   TUVSECND+6(3),DORK+1   move in 3 byte secondary quantity
DYN210   DS    0H
*
         XC    TUPDIR,TUPDIR          disable directory blks TU
         CLC   DSNTDSOR(2),=C'PO'     do we need to add directory blks?
         BNE   DYN220                 no, skip
         MVC   TUPDIR,=AL4(TUVDIR)    yes, activate di blks TU
DYN220   DS    0H
*
* * The text units are all set up now try to do the DYNALLOC
*
         XC    RBLK,RBLK              Clear out Request Block
         LA    1,RBLK                 RB addressability
         USING S99RB,R1
         MVI   S99RBLN,RBLEN          Set RB length
         MVI   S99VERB,S99VRBAL       Verb = Allocate
         MVC   S99TXTPP,=AL4(TUPS)    Set ptr to text units
         DROP  1
         LA    1,RBPTR                Address the RB
         DYNALLOC                     Do the Dynalloc
*
         ST    R15,0(,R6)             Save DYNALLOC RC in caller's parm
         LTR   R15,R15                Was DYNALLOC OK?
         BZ    DYNRET0                yes, return with RC=0
         LA    R1,RBLK                Address RB
         USING S99RB,R1
         MVC   6(2,R6),S99ERROR       Insert S99 error code
         DROP  R1
* Prepare for DAIRFAIL interface call
         MVC   DFS99RBP,=A(RBLK)      Insert address of RB
         ST    R6,DFRCP               Address of SVC99 RC
         MVC   DFJEFF02,=A(ZEROS)     point to zeros, ikjeff02 msg rtn
*                                     will not be used
         MVC   DFIDP,=A(DFIDPVAL)     Halfword flags
         XC    DFCPPLP,DFCPPLP        Don't have a CPPL address
         MVC   DFBUFP,=A(DFBUFS)      Point to extract buffs
         LA    R1,DFPARMS             Address the parm list
         LINK  EP=IKJEFF18            and invoke DAIRFAIL
         ST    R15,DORK               save RC
*
         LTR   R15,R15                Was DAIRFAIL OK?
         BZ    DYN650                 Yep, skip
         CVD   R15,DYNDWRD            Make RC decimal
         UNPK  DYNMSG1+38(5),DYNDWRD+5(3) Make it display
         OI    DYNMSG1+42,X'F0'
         MVC   DYNMSG1(38),=C'DAIRFAIL failed, no msg available, RC='
         B     DYNRET1                Return error
DYN650   DS    0H
         LH    R1,DFBUFL1             Get message 1 length
         LTR   R1,R1                  Any message?
         BNZ   DYN660                 yep, skip
         MVC   DYNMSG1(40),=C'Error, no DAIRFAIL level 1 msg available'
         B     DYN670                 skip msg move
DYN660   DS    0H
         SH    R1,=H'5'               MsgLeng - LL00 flds - 1 for exec
         CH    R1,=H'131'             Too long?                 GP09317
         BNH   DYN665                 no, OK
         LA    R1,131                 yep, truncate             GP09317
DYN665   DS    0H
         LA    R2,DFBUFT1             Point to message 1 text
         EX    R1,DYN680              move msg to buffer 1
DYN670   DS    0H
         LH    R1,DFBUFL2             Get message 2 length
         LTR   R1,R1                  Any message?
         BZ    DYNRET1                no, exit saying 1 msg available
         SH    R1,=H'5'               MsgLeng - LL00 flds - 1 for exec
         CH    R1,=H'131'             Too long?                 GP09317
         BNH   DYN675                 no, OK
         LA    R1,131                 yep, truncate             GP09317
DYN675   DS    0H
         LA    R2,DFBUFT2             Point to message 2 text
         EX    R1,DYN685              move msg to buffer 2
         B     DYNRET2                exit saying 2 msgs available
*
DYN680   MVC   DYNMSG1(*-*),0(R2)     Move DAIRFAIL message to buffer 1
DYN685   MVC   DYNMSG2(*-*),0(R2)     Move DAIRFAIL message to buffer 2
*
DYNRET0  DS    0H
         MVC   0(8,R8),TURETDDN       Move returned DDNAME to parm area
         SLR   R15,R15                Say everything was OK
         B     DYNEXIT                and exit
DYNRET1  DS    0H
         LA    R15,4                  Set error RC
         MVC   0(4,R7),=F'1'          Say one message returned
         B     DYNEXIT
DYNRET2  DS    0H
         LA    R15,4                  Set error RC
         MVC   0(4,R7),=F'2'          Say one message returned
DYNEXIT  DS    0H
         L     R13,DYNSAREA+4         Restore higher SA address
         RETURN (14,12),T,RC=(15)     Return to caller
*
DYNSAREA DS    18F                    Savearea for this rtn
DYNMSG1  DS    CL133                  Returned messages
DYNMSG2  DS    CL133
ZEROS    DC    F'0'                   Just a FW of zeros
DORK     DS    F                      Work
DORK2    DS    F                      Work
DYNDWRD  DS    D                      Work
DYNTRKCP DS    F                      saved track capacity
*
DFIDPVAL DC    X'4032'     DAIRFAIL flags=Extract msgs + SVC99source
*
         IKJEFFDF DFDSECT=NO,DFDSEC2=NO  DAIRFAIL blocks
*
RBPTR    DC    X'80',AL3(RBLK)        SVC99 Parm list
*
* * Note: the IEFZB DSECTS must preceed RBLK so size will be known when
* *       assembling with the old assembler.
*
         IEFZB4D0                     Dynalloc parm list
         IEFZB4D2                     Text unit equates etc
DSSREST  CSECT                        , Resume pgm CSECT
DYNRC    DS    F                      Dynalloc RC
RBLEN    EQU   (S99RBEND-S99RB)       Dynalloc RB Length
RBLK     DS    CL(RBLEN)              Dynalloc Request Block
*
TUPS     DS    0F                     Dynalloc Text Unit Pointers
* Note, TUs which only get used sometimes are labeled and have a value
*   of zero; they are filled in when required.  TUs that are always
*   used do not have labels.
*
         DC    AL4(TUVDSNAM)          DSNAME allocation
         DC    AL4(TUVCLOSE)          FREE=Close
         DC    AL4(TUVSTATS)          DISP=(NEW
         DC    AL4(TUVNDISP)          DISP=    ,CATLG
         DC    AL4(TUVCDISP)          DISP=          ,DELETE)
         DC    AL4(TUVUNIT)           UNIT=
TUPTRK   DC    AL4(0)                 SPACE=(TRK
TUPCYL   DC    AL4(0)                 SPACE=(CYL
         DC    AL4(TUVPRIME)          SPACE=    ,(nnn
TUPSECND DC    AL4(0)                 SPACE=    ,(   ,nnn
TUPDIR   DC    AL4(0)                 SPACE=    ,(   ,   ,1) (dir blks)
         DC    AL4(TUVDSORG)          DSORG=
         DC    AL4(TUVRECFM)          RECFM=
         DC    AL4(TUVLRECL)          LRECL=
         DC    AL4(TUVBLKSZ)          BLKSIZE=
TUPOPTCD DC    AL4(0)                 OPTCD=
TUPKYLEN DC    AL4(0)                 KEYLEN=
         DC    X'80',AL3(TUVRTDDN)    End of list, note: return ddname
*                                     text unit is always used.
*
TUVDSNAM DC    AL2(DALDSNAM)          DSNAME text unit
         DC    X'0001'                # of values
         DC    X'002C'                Length of value
         DC    CL44'XXXXXXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX'
TUVCLOSE DC    AL2(DALCLOSE)          FREE=CLOSE
         DC    X'0000'
TUVSTATS DC    AL2(DALSTATS)          DISP
         DC    X'0001'
         DC    X'0001'
         DC    X'04'                  DISP=NEW
TUVNDISP DC    AL2(DALNDISP)          DISP
         DC    X'0001'
         DC    X'0001'
         DC    X'02'                  DISP=(   ,CATLG
TUVCDISP DC    AL2(DALCDISP)          DISP
         DC    X'0001'
         DC    X'0001'
         DC    X'04'                  DISP=(         ,DELETE)
TUVUNIT  DC    AL2(DALUNIT)           UNIT
         DC    X'0001'
         DC    X'0004'
         DC    C'XXXX'                UNIT=XXXX
TUVTRK   DC    AL2(DALTRK)            SPACE=(TRK
         DC    X'0000'
TUVCYL   DC    AL2(DALCYL)            SPACE=(CYL
         DC    X'0000'
TUVPRIME DC    AL2(DALPRIME)          SPACE=(   ,(nnn
         DC    X'0001'
         DC    X'0003'
         DC    XL3'000000'            Primary space quantity
TUVSECND DC    AL2(DALSECND)          SPACE=(   ,(   ,nnn
         DC    X'0001'
         DC    X'0003'
         DC    XL3'000000'            Secondary space quantity
TUVDIR   DC    AL2(DALDIR)            SPACE=(   ,(   ,   ,1))
         DC    X'0001'
         DC    X'0003'
         DC    XL3'000001'            One directory block
TUVDSORG DC    AL2(DALDSORG)          DSORG=
         DC    X'0001'
         DC    X'0002'
         DC    XL2'0000'
TUVRECFM DC    AL2(DALRECFM)          RECFM=
         DC    X'0001'
         DC    X'0001'
         DC    XL1'00'
TUVLRECL DC    AL2(DALLRECL)          LRECL=
         DC    X'0001'
         DC    X'0002'
         DC    XL2'0000'
TUVBLKSZ DC    AL2(DALBLKSZ)          BLKSIZE=
         DC    X'0001'
         DC    X'0002'
         DC    XL2'0000'
TUVOPTCD DC    AL2(DALOPTCD)          OPTCD=
         DC    X'0001'
         DC    X'0001'
         DC    XL1'00'
TUVKYLEN DC    AL2(DALKYLEN)          KEYLEN=
         DC    X'0001'
         DC    X'0001'
         DC    XL1'00'
TUVRTDDN DC    AL2(DALRTDDN)          Return DDNAME
         DC    X'0001'
         DC    X'0008'
TURETDDN DS    CL8                    Returned DDNAME
*
         DROP  R9,R10
*
         LTORG ,                      For DYNALLO literals
*
* ADRDCOMP - DECOMPRESS ADRDSSU "COMPRESSED" DATA.
*
* +0  -> I/P DATA
* +4  -> O/P BUFFER
* +8  =  INPUT LENG
* +C  =  OUTPUT BUFF LENG, RETURNED DECOMPACTED LENGTH
*
* RC=0 OK,
*    4 Ouput buffer overrun
*
* Algorithm:
*
* Every "chunk" has a 1-byte indicator to say what to generate:
*
* X'00' -> X'7F' = 1 to 256 clear text bytes follow
* X'80' -> X'BF' = 3 to  66 repeats to do, rep char follows
* X'C0' -> X'DF' = 3 to  34 binary zeros are to be generated
* X'E0' -> X'FF' = 3 to  34 blanks are to be generated
*
*
ADRDCOMP DS    0H                         ENTRY
         STM   R14,R12,8(R13)             Save regs
         LR    R12,R15                    Copy entry address
         USING ADRDCOMP,R12               New addressability
         L     R10,0(,R1)                 R10=Input ptr
         LR    R7,R10                         Copy it
         A     R7,8(,R1)                  R7 = Input limit
         SLR   R11,R11                    R11 is MVCL in  leng
         SLR   R9,R9                      R9  IS MVCL out leng
         L     R8,4(,R1)                  R8 =Output ptr
         LR    R6,R8                          Copy it
         A     R6,12(,R1)                 R6 =Limit value for O/P
         SLR   R5,R5                      Used for "Chunk" action
*
ADLOOP   DS    0H
         IC    R5,0(,R10)                 Get chunk action
         LA    R10,1(,R10)                Advance input pointer
         CLM   R5,B'0001',=X'80'          Is it clear text?
         BNL   AD300                      Nope, skip
         LA    R11,1(,R5)                 R11=# clear bytes to move
         LR    R9,R11                     ditto that for output leng
         LA    R1,0(R8,R9)                R1->next O/P if we do move
         CR    R1,R6                      Will we overrun output?
         BNL   ADOPERR                    Yep, give up
         MVCL  R8,R10                     no, move clear text bytes
         CR    R10,R7                     Any input left?
         BL    ADLOOP                     Yep, keep on trucking
         B     ADEXIT                     Nope, we're done
AD300    DS    0H
         CLM   R5,B'0001',=X'C0'          Is it plain repeated chars?
         BNL   AD500                      Nope, keep guessing
         SH    R5,HWX007D                 R5=# repeats to do
         LA    R1,0(R8,R5)                R1-> next O/P if we insert
         CR    R1,R6                      Will we overrun output?
         BNL   ADOPERR                    yep, thats a bad
         LR    R9,R5                      Output move leng
         SLR   R3,R3                      zero input move leng
         ICM   R3,B'1000',0(R10)          Grab char to repeat
         MVCL  R8,R2                      Insert repeated character
         LA    R10,1(,R10)                We used 1 more input char
         CR    R10,R7                     Any input left?
         BL    ADLOOP                     yeah, still more work
         B     ADEXIT                     Nope, we're done
AD500    DS    0H
         CLM   R5,B'0001',=X'E0'          Is it binary zero repeats?
         BNL   AD700                      Nope, must be blank repeats
         SH    R5,HWX00BD                 R5=# bin 0 to insert
         LA    R1,0(R8,R5)                R1-> next O/P if we insert
         CR    R1,R6                      Will we overrun output?
         BNL   ADOPERR                    yep, thats a looser
         LR    R9,R5                      Output move leng
         SLR   R3,R3                      zero input move leng
*                                         also leaves pad char as X00
         MVCL  R8,R2                      Insert them bin zeros
         CR    R10,R7                     Any input left?
         BL    ADLOOP                     yeah, still more work
         B     ADEXIT                     Nope, we're done

AD700    DS    0H                         Do blank repeats
         SH    R5,HWX00DD                 R5=# blank to insert
         LA    R1,0(R8,R5)                R1-> next O/P if we insert
         CR    R1,R6                      Will we overrun output?
         BNL   ADOPERR                    yep, thats a looser
         LR    R9,R5                      Output move leng
         SLR   R3,R3                      zero input move leng
         ICM   R3,B'1000',=X'40'          Padd char is blank
         MVCL  R8,R2                      Insert blank space
         CR    R10,R7                     Any input left?
         BL    ADLOOP                     yeah, still more work
         B     ADEXIT                     Nope, we're done
*
ADEXIT   DS    0H                         Exit RC=0
         L     R1,20(,R13)                Original R1
         L     R2,4(,R1)                  O/P buff ptr
         SR    R8,R2                      minus pos'n in O/P buff
         ST    R8,12(,R1)                 Save O/P data leng returned
         L     R14,8(,R13)                Restore return address
         LM    R0,R12,16(R13)             Restore other regs
         SLR   R15,R15                    Give good RC
         BR    R14                        And return
*
ADOPERR  DS    0H                         EXIT RC=4 buff overrun
         L     R1,20(,R13)                Original R1
         XC    12(4,R1),12(R1)            Zero output leng returned
         L     R14,8(,R13)                Restore return address
         LA    R15,4                      Set RC=4
         LM    R0,R12,16(R13)             Restore other regs
         BR    R14                        And return
*
HWX007D  DS    0H
         DC    X'007D'
HWX00BD  DS    0H
         DC    X'00BD'
HWX00DD  DS    0H
         DC    X'00DD'
*
         DROP  R12
         LTORG
*
DSSRESTE EQU   *         Total DSSREST CSECT length (just for interest)
*
********************************************************************
* * Dataset name table - one entry per DSN found in dump dataset
* *                      list segment(s)
********************************************************************
*
DSNTAB   DSECT
DSNTDSN  DS    CL44      Dataset name
DSNTDSOR DS    CL3       Dsorg (IS, PS, DA, PO, VS (VSAM),
*                        or EF (extended format)) from Dataset Hdr Seg
*                        3rd pos'n is U if unmoveable
DSNTRECC DS    CL5       Recfm in character representation      GP09317
DSNTDEV  DS    XL4       Device type
DSNTMDL  DS    XL1       Device model number
DSNTTRCY DS    H         Tracks/Cyl from DSheader seg
* The following fields are all from the FMT1 DSCB
DSNTDSOB DS    XL2       Dsorg (binary, from DShdr which= DSCB1 val)
DSNTRECF DS    XL1       Recfm (binary from FMT1 DSCB)
DSNTLREC DS    XL2       Lrecl
DSNTBLKS DS    XL2       Blksize
DSNTKEYL DS    X         Key Length
DSNTRKP  DS    XL2       Relative Key Position
DSNTOPTC DS    X         Optcde
DSNTVOLC DS    XL1       Volume count
DSNTTBAL DS    XL2       Track Balance
DSNTHTTR DS    XL3       Last used TTR
DSNTCRDT DS    XL3       Creation date
DSNTEXPD DS    XL3       Expiration date
DSNTLUDT DS    XL3       Date last used (last referenced)
DSNTSSFL DS    XL1       Secondary space flags ** not used really, **
DSNTSSVL DS    XL2       Secondary space value ** but gets printed **
*                                              ** in debug mode    **
DSNTEXT  DS    XL1       # extents (on first volume)
DSNTSAL1 DS    XL1       Secondary allocation flag
DSNTSAL3 DS    XL3       Secondary allocation value
* End of FMT1 DSCB fields
DSNTPTRK DS    F         # Primary tracks (calculated from 1st extent)
DSNTTRKC DS    F         # track images in dump
DSNTANXT DS    F         address of next DSNtab entry in sequence
*                        encountered in the dump or zero on last.
DSNTVOLS DS    CL6       Volser of dataset
DSNTFLGS DS    XL1       Flags
DSNTFFND EQU   X'80'       Found this dataset in the dump
DSNTFCYL EQU   X'40'       Pri allocation was in cylinders
DSNTFSKP EQU   X'20'       Dataset was not processed (VSAM, HFS, etc..)
DSNTFRES EQU   X'10'       Attempt restore of this dataset
DSNTFROK EQU   X'08'       Restore was successful
DSNTFR0N EQU   X'04'       Non-zero R0s found in dataset
DSNTFDUM EQU   X'02'       SYSUT2 was DUMMY for restoring this dataset
DSNTFSUL EQU   X'01'       Data set has LABEL track             GP09317
DSNTABEL EQU   *-DSNTAB  Table entry length
*
* * dummy dsect (useful for debugging msgs)
*
DUMMY    DSECT
D        EQU   *
*
* * mapping macros
*
         PRINT GEN
         ADRTAPB         , My hacked up version of an ADRTAPB DSECT
         PRINT NOGEN                                            GP09317
FORMAT1  DSECT           , IECSDSL1 doesn't generate a DSECT
         IECSDSL1 1      Format 1 DSCB mapping
         DCBD  DSORG=PS,DEVD=(DA,TA)
         PRINT NOGEN
         IEZIOB
         IEFUCBOB ,                                             GP09317
         IHAPSA ,                                               GP09317
         IKJTCB ,                                               GP09317
MYJFCB   DSECT ,                                                GP09317
         IEFJFCBN ,                                             GP09317
         CVT   DSECT=YES                                        GP09317
         END
