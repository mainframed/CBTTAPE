         TITLE 'XPROC copyright notice'
***********************************************************************
*                                                                     *
*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *
*                                                                     *
*   This program is provided on an "as is" basis.  It may be freely   *
*   distributed as long as it is not offered for commercial sale,     *
*   and as long as this copyright notice is included.                 *
*                                                                     *
***********************************************************************
         TITLE 'XPROC macros'
         MACRO
&SYM     ERROR &MSG,&FLUSH=YES
&SYM     L     R1,=A(&MSG)         Get address of error message
         LA    R0,L'&MSG           Get length of error message
         BAL   R14,PUTLINE         Display error message
         AIF   ('&FLUSH' EQ 'NO').MEND
         B     FLUSHIT             Fail
.MEND    MEND
         TITLE 'XPROC - CLIST-style command line parser for REXX'
***********************************************************************
*                                                                     *
* XPROC    - CLIST-style command line parser for REXX                 *
*                                                                     *
* Author:  S. Bacher 06/89                                            *
*                                                                     *
* Syntax:  XPROC {inputvar} number {positional-parameter-variables}*  *
*                                  {keyword-and-maybe-value-specs}*   *
*                                                                     *
*        where: "inputvar" is a valid CLIST/REXX variable name        *
*               and the part of the command that follows "inputvar"   *
*               looks exactly like the syntax of the CLIST "PROC"     *
*               statement.                                            *
*                                                                     *
* Example: /* REXX */                                                 *
*          PARSE ARG OPERANDS                                         *
*          "XPROC OPERANDS 2 FILE DSN VOL() SHR COUNT(1) KEY('A B')"  *
*                                                                     *
*          Note that everything, including "inputvar", must be quoted *
*          under REXX to prevent substitution.                        *
*                                                                     *
* Function:  To parse the value of a string (accessed as "inputvar")  *
*            according to the PROC-style specifications and place     *
*            the results in REXX variables.  If "inputvar" is         *
*            omitted, the argument to the REXX exec is parsed.        *
*                                                                     *
* Return codes:                                                       *
*                                                                     *
* 0 - normal operation                                                *
* 12 - error(s) occurred, prompting not possible                      *
*                                                                     *
* Note:  This can be used in CLISTs as well.  One use might be to     *
*        parse a non-command-buffer line, e.g. edit macro text.       *
*                                                               #TSO147
* Change activity:                                              #TSO147
*                                                               #TSO147
* 10/24/89 - SEB1525 - Bug fix when bigger keyword area needed. #TSO147
* 01/30/91 - SEB1525 - Extended to permit the specification of        *
*                      options via the syntax keyword/option.         *
*                      First option so supported is lowercase.        *
* 04/13/92 - SEB1525 - Bug fix when prototype has quoted data.  #TSO159
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    Used by SCAN and PUTLINE; other temporary uses
R4       EQU   4    Positional parameter info
R5       EQU   5    Positional parameter info
R6       EQU   6    Keyword count
R7       EQU   7    Address of IKJPARS PDL answer area
R8       EQU   8    Used to loop through parameters
R9       EQU   9    Dynamic base register
R10      EQU   10   Static base register
R11      EQU   11   Static base register
R12      EQU   12   Static base register
R13      EQU   13   Save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
XPROC    CSECT
XPROC    AMODE 31
XPROC    RMODE ANY
         SAVE  (14,12),,XPROC_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XPROC,R12
         LA    R11,4095(,R12)
         USING XPROC+4095,R11
         LA    R10,4095(,R11)
         USING XPROC+4095+4095,R10
*
* Allocate storage to hold work area plus copies of positional and
* keyword parameters.  Since the maximum length required to hold
* all the parameters is obviously the length of the command buffer,
* use that as the amount to add.
*
         LR    R2,R1               Save input parameter address
         LA    R4,SIZDATD            Get length of basic workarea
         L     R3,CPPLCBUF-CPPL(,R2) Point to command buffer
         AH    R4,0(,R3)             Add length of command buffer
         LR    R0,R4
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         LR    R9,R13
         USING DATD,R9
         ST    R4,DATDLEN          Save length of getmained area
         LA    R0,WORDCOPY         Point to variable area
         ST    R0,WORDPTR          Save address of it
         MVC   CPPL(16),0(R2)      Set up our copy of CPPL
         MVC   IOPLUPT,CPPLUPT     Pointer TO UPT
         MVC   IOPLECT,CPPLECT     Pointer TO ECT
         LA    R0,ECB
         ST    R0,IOPLECB          Pointer to user's ECB
         MVC   PTLIST(LENPUTL),MPTLIST Set up PUTLINE list form
         LA    R0,1                Define 1 message segment
         LA    R1,MSGHDR
         STM   R0,R1,OLD           Make PUTLINE output line descriptor
*                                  Initialize other data areas
         STM   R11,R12,MYBASES     Base registers used in PARSE exits
         MVI   FLAGS,X'00'         Clear flags
         XR    R0,R0               Make a zero
         ST    R0,APOSD
         ST    R0,LPOSD
         ST    R0,AKEYD
         ST    R0,LKEYD
         ST    R0,AKEYE
         ST    R0,POSCOUNT
         ST    R0,KEYCOUNT
         ST    R0,PWADDR
         ST    R0,PWLEN
         ST    R0,VBUFADDR
         ST    R0,VBUFLEN
         ST    R0,ARGADDR
         ST    R0,ARGLEN
*
         EJECT
*
***********************************************************************
*
* First, set things up so that SCAN can start scanning.  On entry to
* the command, CPPLCBUF points to the command buffer.  Halfword 1 is
* the length of the buffer plus 4, and halfword 2 is the offset of the
* first operand (if any) past the command name in the buffer (set by
* TSO's call to IKJSCAN).
*
***********************************************************************
*
         L     R2,CPPLCBUF
         LR    R1,R2
         AH    R1,0(,R2)
         ST    R1,SCANEPTR         Save end of command buffer
         LA    R1,4(,R2)
         AH    R1,2(,R2)
         ST    R1,SCANPTR          Initialize scan pointer
         XR    R0,R0
         ST    R0,PARCOUNT         Initialize parenthesis count
*
***********************************************************************
*                                                                     *
* Scan command buffer for first operand - must be input variable name *
*                                                                     *
***********************************************************************
*
         BAL   R14,SCAN            Return R15 -> arg
         B     NOOPERANDS          No value
         B     ARG1OK              Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     ERROR_NO_WANT_LP    "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     ERROR_NO_WANT_SL    "/" found
         SPACE 1
ARG1OK   DS    0H
         SPACE 1
*
***********************************************************************
*                                                                     *
* Validate first argument as a variable name so that it can be used   *
* to retrieve CLIST/REXX variable value.                              *
*                                                                     *
* We may not really have to do that here - just verify that it's not  *
* a positional count.  If it is a positional count, set the address   *
* and length of the input variable to zero (extension to XPROC will   *
* get value to parse from REXX argument string in that case).         *
*                                                                     *
***********************************************************************
*
         LR    R3,R1               Save address
         LR    R4,R2               Save length
         CH    R2,=H'256'          If it's too long for EX instruction
         BH    ERROR_FIRST_ARG     then first arg is invalid
         BCTR  R2,0                Reduce for execute
         EX    R2,TRTPOSCT         Scan for numerics
         BNZ   NOTPOSCOUNT         If any non-numerics, not a count
         XR    R0,R0               Else make a zero
         ST    R0,PVARADDR         Clear address of the variable
         ST    R0,PVARLEN          Clear length of the variable
         B     ISACOUNT            Process this as the pos parm count
         SPACE 1
NOTPOSCOUNT DS 0H                  Not a count - assume a variable name
         LR    R14,R3              Get address of variable name
         LA    R1,PVAR             Point to place to build var name
         ST    R1,PVARADDR         Save address of the variable
         ST    R4,PVARLEN          Save length of the variable
         BCTR  R4,0                Reduce for execute
         EX    R4,MVCWORD          Move word to PVAR
         EX    R4,UPWORD           Translate to uppercase
         SPACE 1
*
***********************************************************************
*                                                                     *
* Scan command buffer for next operand - must be count of positionals *
*                                                                     *
***********************************************************************
*
         BAL   R14,SCAN
         B     NOPOSCOUNT          No value
         B     ARG2OK              Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     ERROR_NO_WANT_LP    "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     ERROR_NO_WANT_SL    "/" found
         SPACE 1
ARG2OK   DS    0H                  We have what should be a count...
         LR    R3,R1               Get address of argument
         LR    R4,R2               Get length of argument
ISACOUNT DS    0H                  Here for first non-alpha arg...
*
***********************************************************************
*                                                                     *
* Validate this argument as a number so that it can be used to count  *
* the number of positional parameters.                                *
*                                                                     *
***********************************************************************
*
         BCTR  R4,0                Reduce for execute
         CH    R4,=H'7'            If positional count more than 8 digs
         BH    BADPOSCOUNT         then invalid value
         EX    R4,TRTPOSCT         Scan for numerics
         BNZ   BADPOSCOUNT         If any non-numerics, invalid value
         EX    R4,PACKIT           Convert to numeric
         CVB   R0,DOUBLE           Get binary value
         ST    R0,POSCOUNT         Store positional parameter count
         SPACE 1
*
***********************************************************************
*                                                                     *
* We are about to start collecting all parameter names, both          *
* positional and keyword.  While we do this, we determine how much    *
* space will be needed for IKJPARS control blocks.                    *
*                                                                     *
* Compute storage needed for the PCL (built by us):                   *
*                                                                     *
*   For initial overhead:            7                                *
*   For each positional parameter:   56 + (2 * length(min(name,234))) *
*   For each keyword with a value:   66 + (2 * length(min(name,237))) *
*                                       + length(name)                *
*   For each keyword without value:  11 + length(name)                *
*                                                                     *
* Compute storage reserved for the PDL (built by IKJPARS):            *
*                                                                     *
*   For initial overhead:            8                                *
*   For each positional parameter:   8                                *
*   For each keyword:                2                                *
*   For each value subfield:         8                                *
*                                                                     *
***********************************************************************
*
         LA    R0,7                Set PCL amount to initial value
         ST    R0,PCLLEN
         XR    R0,R0               Set quoted-value-strings length
         ST    R0,QVALLEN
         LA    R0,8                Set PDL initial total length
         ST    R0,PDLLEN
*
***********************************************************************
*                                                                     *
* Get storage to hold information for as many positional parameters   *
* as we have defined.                                                 *
*                                                                     *
***********************************************************************
*
         ICM   R5,15,POSCOUNT      Get count of positional parameters
         BZ    NOPOZZES            If zero, no positional parameters
         MH    R5,=Y(POSDDATL)     Get total length to acquire
         GETMAIN RC,LV=(R5),LOC=ANY Get storage
         LTR   R15,R15             If GETMAIN failed,
         BNZ   BADPOSCOUNT         then positional count too big
         ST    R1,APOSD            Save address of this area
         ST    R5,LPOSD            Save length of this area
         LR    R4,R1               Address first entry in area
         USING POSDDATA,R4
*
***********************************************************************
*                                                                     *
* Loop (positional-parameter-count) times, collecting variable names. *
*                                                                     *
***********************************************************************
*
         NI    FLAGS,255-FLAGPOSD  Not currently processing anything
         NI    FLAGS,255-FLAGKEYD
         XR    R0,R0               Zero out error fields
         ST    R0,LASTADDR
         ST    R0,LASTLEN
         ST    R0,LASTAREA
         L     R8,POSCOUNT         Get count of positional parameters
PPLOOP   DS    0H                  R5 contains count of parms to get
         BAL   R14,SCAN            Get a positional parame
         B     PPMISSING           No value
         B     PPADD               Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     PPLP                "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     PPSLASH             "/" found
         SPACE 1
PPLP     DS    0H                  "(" found when a positional expected
         C     R8,POSCOUNT         If no pos. parms found yet
         BE    ERROR_NO_WANT_LP    then this is truly an error; else
*                                  (future extension, but error now)
         L     R3,LASTADDR         Get address of last processed P.P.
         L     R2,LASTLEN          Get length of last processed P.P.
         B     ERROR_PP_WITH_LP    say value spec not allowed
         SPACE 1
PPSLASH  DS    0H                  "/" found when a positional expected
         BAL   R14,DOOPTS          Process options
         B     PPLOOP
         SPACE 1
PPADD    DS    0H                  Add a positional parameter
*
* Check parameter for validity, and (if it's OK) make uppercase copy
* of it in our area.
*
         CH    R2,=H'255'          If too long
         BH    ERROR_PARM_TOO_LONG then error
         LR    R14,R1              Address
         LR    R15,R2              Length
         BCTR  R15,0               Reduce length for execute
         EX    R15,VERIFYP         Check syntax of parameter
         BNZ   ERROR_PARM_INVALID  If bad, error
         CLI   0(R14),C'0'         Must not begin with numeric
         BNL   ERROR_PARM_INVALID  If bad, error
         L     R1,WORDPTR          Get next available word slot
         EX    R15,MVCWORD         Move word to slot
         EX    R15,UPWORD          Translate to uppercase
         LA    R0,1(R15,R1)        Update slot pointer
         ST    R0,WORDPTR          for next time
*
* Check for duplicates. R1 -> new word, R15 = length-1
*
         L     R2,APOSD            Get address of first positional
         LA    R0,1(,R15)          Get true length
CDPPLOOP DS    0H                  Loop to check for duplicates
         CR    R2,R4               until we hit current PP slot
         BNL   CDPPLEND
         C     R0,POSDLEN-POSDDATA(,R2)
         BNE   CDPPNEXT            If lengths don't match, continue
         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter
         EX    R15,COMPWORD        If values are equal,
         BE    ERROR_PARM_DUPLICATE then error
CDPPNEXT LA    R2,POSDDATL(,R2)    Else continue
         B     CDPPLOOP
CDPPLEND DS    0H                  End loop to check for duplicates
         LA    R2,1(,R15)          Get length
         ST    R1,POSDADDR         Save address of this pos. parm.
         ST    R2,POSDLEN          Save length of this pos. parm.
         XR    R0,R0               Clear other fields
         ST    R0,POSDPCEA
         MVI   POSDFLGS,0
         ST    R4,LASTAREA         Save for option/error processing
         ST    R1,LASTADDR         Save for option/error processing
         ST    R2,LASTLEN          Save for option/error processing
         OI    FLAGS,FLAGPOSD      Say currently processing positional
         NI    FLAGS,255-FLAGKEYD
*
* PCE length for positional param: 56 + (2 * length(min(name,234)))
* PDE length for positional param: 8
*
         LR    R15,R2              Get length of positional parm name
         CH    R15,=H'234'         If longer than 255-21
         BNH   *+8                 then
         LA    R15,255-21           set length to 255-21
         ST    R15,POSDMAXL        Store this length
         SLA   R15,1               2 * length(min(name,234))
         LA    R15,56(,R15)        56 + (2 * length(min(name,234)))
         ST    R15,POSDPCEL        Set length of PCE for this parameter
         A     R15,PCLLEN          Accumulate PCL length
         ST    R15,PCLLEN
         LA    R1,8                Length of PDE for positional = 8
         A     R1,PDLLEN           Accumulate PDL length
         ST    R1,PDLLEN
         LA    R4,POSDDATL(,R4)    Bump pointer
         BCT   R8,PPLOOP           Loop until count exhausted
         SPACE 1
NOPOZZES DS    0H                  Here if no positional parameters
         SPACE 1
*
***********************************************************************
*                                                                     *
* Get storage to hold information for keyword and value parameters.   *
* We don't know how much we'll need yet, so we'll get a chunk of it   *
* and hope for the best.                                              *
*                                                                     *
***********************************************************************
*
         L     R5,KEYDINCR         Get estimated initial length
         GETMAIN RC,LV=(R5),LOC=ANY Get storage
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         ST    R1,AKEYD            Save address of this area
         ST    R5,LKEYD            Save length of this area
         XR    R4,R4               Start things off
         USING KEYDDATA,R4
         LA    R0,0(R1,R5)         Point to end of area
         ST    R0,AKEYE            Save address of end
*
***********************************************************************
*                                                                     *
* Loop collecting keywords and keyword/value pairs.                   *
*                                                                     *
***********************************************************************
*
         XR    R6,R6               Clear keyword count
KVLOOP   DS    0H
         BAL   R14,SCAN            Get a keyword parameter
         B     KVEND               No more
         B     KVADD               Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     KVLP                "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     KVSLASH             "/" found
         SPACE 1
KVLP     DS    0H                  "(" found when a keyword expected
         LTR   R6,R6               If we've seen keyword parms already
         BNZ   ERROR_NO_WANT_LP    then this is truly an error
         ICM   R0,15,POSCOUNT      Else if no positional parameters
         BZ    ERROR_NO_WANT_LP    then this is truly an error.  Else,
*                                  (future extension, but error now)
         L     R3,LASTADDR         Get address of last processed P.P.
         L     R2,LASTLEN          Get length of last processed P.P.
         B     ERROR_PP_WITH_LP    say value spec w/p.p. not allowed
         SPACE 1
KVSLASH  DS    0H                  "/" found when a keyword expected
         BAL   R14,DOOPTS          Process options
         B     KVLOOP
         SPACE 1
KVADD    DS    0H                  Add a keyword parameter
         OI    FLAGS,FLAGKEYD      Say we're currently processing
         NI    FLAGS,255-FLAGPOSD  keyword/value parameters
         LTR   R4,R4               If we haven't got any keywords yet
         BNZ   KVNZ                then
         L     R4,AKEYD             point to first entry in area
         B     KVA                  and do our stuff.
KVNZ     DS    0H                  Else...
         LA    R4,KEYDDATL(,R4)    Bump pointer
         C     R4,AKEYE            If this takes us past end of buffer
         BL    KVA                 then...                      #TSO147
         STM   R1,R2,SCANRES       Store result of scan
         L     R5,LKEYD             get length of current area
         A     R5,KEYDINCR          increment it
         GETMAIN RC,LV=(R5),LOC=ANY get storage
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         LR    R2,R1               Address of new key area
         LR    R0,R2               Address of new key area
         L     R14,AKEYD           Address of old key area
         L     R1,LKEYD            Length of old key area
         LR    R15,R1              Length of old key area
         MVCL  R0,R14              Move old key data to new key data
         LR    R4,R0               Point to slot in new key area
         L     R1,AKEYD            Address of old key area
         L     R0,LKEYD            Length of old key area
         FREEMAIN RC,LV=(0),A=(1)  Free the old key area
         ST    R2,AKEYD            Save address of new area
         ST    R5,LKEYD            Save length of new area
         LA    R0,0(R2,R5)         Point to end of area
         ST    R0,AKEYE            Save address of end
         LM    R1,R2,SCANRES       Load results of scan
KVA      DS    0H
*
* Check parameter for validity, and (if it's OK) make uppercase copy
* of it in our area.
*
         CH    R2,=H'255'          If too long
         BH    ERROR_PARM_TOO_LONG then error
         LR    R14,R1              Address
         LR    R15,R2              Length
         BCTR  R15,0               Reduce length for execute
         EX    R15,VERIFYP         Check syntax of parameter
         BNZ   ERROR_PARM_INVALID  If bad, error
         CLI   0(R14),C'0'         Must not begin with numeric
         BNL   ERROR_PARM_INVALID  If bad, error
         L     R1,WORDPTR          Get next available word slot
         EX    R15,MVCWORD         Move word to slot
         EX    R15,UPWORD          Translate to uppercase
         LA    R0,1(R15,R1)        Update slot pointer
         ST    R0,WORDPTR          for next time
*
* Check for duplicates. R1 -> new word, R15 = length-1
*
         ICM   R8,15,POSCOUNT      Get count of positionals
         BZ    KVPPLEND            If none, don't check 'em, obviously
         L     R2,APOSD            Get address of first positional
         LA    R0,1(,R15)          Get true length
KVPPLOOP DS    0H                  Loop to check for duplicates
         C     R0,POSDLEN-POSDDATA(,R2)
         BNE   KVPPNEXT            If lengths don't match, continue
         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter
         EX    R15,COMPWORD        If values are equal,
         BE    ERROR_PARM_DUPLICATE then error
KVPPNEXT LA    R2,POSDDATL(,R2)    Else continue
         BCT   R8,KVPPLOOP         until no more positionals
KVPPLEND DS    0H                  End loop to check for duplicates
*                                  Now check against keywords so far
         LTR   R8,R6               Get count of keywords
         BZ    KVKWLEND            If none so far, don't check 'em
         L     R2,AKEYD            Get address of first keyword
         LA    R0,1(,R15)          Get true length
KVKWLOOP DS    0H                  Loop to check for duplicates
         C     R0,KEYWORDL-KEYDDATA(,R2)
         BNE   KVKWNEXT            If lengths don't match, continue
         L     R14,KEYWORDA-KEYDDATA(,R2) Point to old parameter
         EX    R15,COMPWORD        If values are equal,
         BE    ERROR_PARM_DUPLICATE then error
KVKWNEXT LA    R2,KEYDDATL(,R2)    Else continue
         BCT   R8,KVKWLOOP         until no more keywords
KVKWLEND DS    0H                  End loop to check for duplicates
         LA    R6,1(,R6)           Increment keyword count
         LA    R2,1(,R15)          Get length
         ST    R1,KEYWORDA         Save address of this pos. parm.
         ST    R2,KEYWORDL         Save length of this pos. parm.
         ST    R4,LASTAREA         Save for option/error processing
         ST    R1,LASTADDR         Save for option/error processing
         ST    R2,LASTLEN          Save for option/error processing
         XR    R0,R0               Clear other keyword/value fields
         ST    R0,KEYDVALA
         ST    R0,KEYDVALL
         ST    R0,KEYDPCEA
         ST    R0,KEYDPCEL
         ST    R0,KEYDMAXL
         ST    R0,KEYSUBOF
         MVI   KEYFLAGS,0
KVOLOOP  DS    0H
*
* Now get the next thing, which might be a parenthesized default value
* or a slashed keyword processing option
*
         BAL   R14,SCAN            Get a keyword parameter
         B     KVFINEND            No more
         B     KVFINADD            Unquoted name, it's another keyword
         B     ERROR_NO_WANT_QS    Quoted string found
         B     KVVALUE             "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     KVOPTION            "/" found
         SPACE 1
KVOPTION DS    0H                  We (probably) have a /option...
         BAL   R14,DOOPTS          Process options
         B     KVOLOOP
         SPACE 1
KVVALUE  DS    0H                  We (probably) have a value...
         SPACE 1
*
* Scan for the value (can be any kind of string).
*
         BAL   R14,SCAN            Get a value string
         B     KVNULL              End of buffer, value is null
         B     KVWORD              Unquoted name, it's a value
         B     KVSTRING            Quoted string found, it's a value
         B     KVERROR             "(" found, should never happen
         B     KVNULL              ")" found, value is null
         B     KVERROR             "/" found, should never happen
         SPACE 1
KVWORD   DS    0H                  Unquoted word is the value
         ST    R1,KEYDVALA         Store address of default value
         ST    R2,KEYDVALL         Store length of default value
         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present
         B     KVGETRP             Go get right paren
         SPACE 1
KVSTRING DS    0H                  Quoted string is the value
         ST    R1,KEYDVALA         Store address of default value
         ST    R2,KEYDVALL         Store length of default value
         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present
         OI    KEYFLAGS,KEYFQUOT   Indicate it's a quoted string
         B     KVGETRP             Go get right paren
         SPACE 1
KVGETRP  DS    0H                  Time to terminate the value...
*
* Scan for the right parenthesis that ends the value spec
*
         BAL   R14,SCAN            Get a value string
         B     KVFINEND            End of buffer
         B     KVEXTRA             Unquoted name, shouldn't be there
         B     KVEXTRA             Quoted string, shouldn't be there
         B     KVERROR             "(" found, should never happen
         B     KVFINLOP            ")" found, OK, continue looping
         B     KVERROR             "/" found, should never happen
         SPACE 1
KVEXTRA  DS    0H
*                                  (future extension, but for now)
         LR    R3,R1               Get address of extraneous data
******** LR    R2,R2               Get length of extraneous data
         LA    R1,MSG_EXTRANEOUS   Ignore extraneous info
         LA    R0,L'MSG_EXTRANEOUS
         BAL   R14,PUTLINE
         B     KVGETRP             Keep looking for that right paren
         SPACE 1
KVNULL   DS    0H
         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present
         LA    R14,KVLOOP          (but it's null)
         B     KVACCUM             Accumulate length, then get next KW
         SPACE 1
KVFINLOP DS    0H                  End keyword(value), another follows
         LA    R14,KVLOOP          Proceed to KVLOOP after doing...
         B     KVACCUM             accumulation for this keyword
         SPACE 1
KVFINADD DS    0H                  End this keyword, another follows
         LA    R14,KVADD           Proceed to KVADD after doing...
         B     KVACCUM             accumulation for this keyword
         SPACE 1
KVFINEND DS    0H                  End this keyword, no more follow
         LA    R14,KVEND           Proceed to KVEND after doing...
******** B     KVACCUM             accumulation for this keyword
         SPACE 1
KVACCUM  DS    0H
*
*   Calculate PCE and PDE lengths for keyword parameter
*   For each keyword with a value:
*     66 + (2 * length(min(name,237))) + length(name)
*   For each keyword without value:
*     11 + length(name)
*
* We're going to use the same storage to build unquoted values of
* keywords, so add that length in too.
*
         STM   R1,R2,SCANRES       Save results of scan
         L     R15,KEYWORDL        Get length of keyword name
         TM    KEYFLAGS,KEYFDVAL   If a value specified
         BNO   PCKWNVAL            then...
         CH    R15,=H'237'         min(name,237)
         BNH   *+8
         LA    R15,237
         ST    R15,KEYDMAXL        Save this length
         SLA   R15,1               2 * length(min(name,237))
         LA    R15,66(,R15)        66 + (2 * length(min(name,237)))
         A     R15,KEYWORDL        66 + ... + length(name)
         LA    R1,8                Accumulate PDL length for subfield
         A     R1,PDLLEN
         ST    R1,PDLLEN
         TM    KEYFLAGS,KEYFQUOT   If value is quoted string
         BNO   PCKWNEXT            then...
         L     R1,KEYDVALL          accumulate value length
         A     R1,QVALLEN
         ST    R1,QVALLEN          (actual'll be less, but never more)
         B     PCKWNEXT
PCKWNVAL DS    0H                  No value specified...
         LA    R15,11(,R15)        just 11 + length(name)
PCKWNEXT DS    0H
         ST    R15,KEYDPCEL        Save PCE length
         A     R15,PCLLEN          Accumulate PCL length for keyword
         ST    R15,PCLLEN
         LA    R1,2                Accumulate PDL length for keyword
         A     R1,PDLLEN
         ST    R1,PDLLEN
         LM    R1,R2,SCANRES       Load results of scan
         BR    R14                 Go to KVADD or KVEND or KVLOOP
         SPACE 1
KVEND    DS    0H                  No more parameters of any kind
         SPACE 1
         ST    R6,KEYCOUNT         Save number of keywords
         SPACE 1
         EJECT
***********************************************************************
*                                                                     *
* Prepare to build control blocks for IKJPARS for the parameters,     *
* like so:                                                            *
*                                                                     *
*          IKJPARM                                                    *
*                                                                     *
*   For each positional parameter "pp":                               *
*                                                                     *
*          IKJIDENT 'POSITIONAL PARAMETER pp',                        *
*                ASIS,   /* only if the /ASIS option is specified */  *
*                CHAR,   /* only if /QUOTABLE option is specified */  *
*                FIRST=ANY,OTHER=ANY,                                 *
*                PROMPT='POSITIONAL PARAMETER pp'                     *
*                                                                     *
*   For each keyword parameter "kv" with a value "val";               *
*                                                                     *
*          IKJKEYWD                                                   *
*          IKJNAME 'kv',SUBFLD=kvsubfld                               *
*                                                                     *
*   For each keyword parameter "kw" without a value:                  *
*                                                                     *
*          IKJKEYWD                                                   *
*          IKJNAME 'kv'                                               *
*                                                                     *
*   For each keyword parameter "kv" with a value "val", as above:     *
*                                                                     *
* kvsubfld IKJSUBF                                                    *
*          IKJIDENT 'VALUE FOR KEYWORD kv',                           *
*                ASIS,   /* only if the /ASIS option is specified */  *
*                CHAR,                                                *
*                PROMPT='VALUE FOR KEYWORD kv'                        *
*                                                                     *
*          IKJENDP                                                    *
*                                                                     *
* Note that the default value from the specifications is not part of  *
* the IKJPARS parameters.  Rather, the absence of the keyword is      *
* detected after the call to PARSE and, at that point, the default    *
* value is used if the terminal user did not provide one.             *
*                                                                     *
* Compute storage needed for the PCL (built by us):                   *
*                                                                     *
*   For initial overhead:            7                                *
*   For each positional parameter:   56 + (2 * length(name))          *
*   For each keyword with a value:   66 + (3 * length(name))          *
*   For each keyword without value:  11 + length(name)                *
*                                                                     *
* Compute storage reserved for the PDL (built by IKJPARS):            *
*                                                                     *
*   For initial overhead:            8                                *
*   For each positional parameter:   8                                *
*   For each keyword:                2                                *
*   For each value subfield:         8                                *
*                                                                     *
* We're going to use the same storage to build unquoted values of     *
* keywords, so add that length in too.  Also, we want to include      *
* storage for the final call to IKJCT441 to update all parameters.    *
* How much storage is needed to build the parameter list:  9 words    *
* for each parameter, plus 4 extra words = 13*4.                      *
*                                                                     *
***********************************************************************
         EJECT
*
* Get storage for the PCL plus dequoted value strings plus IKJCT441 PL
*
         L     R1,PDLLEN
         LA    R1,7(,R1)           Round PDL length
         N     R1,=X'FFFFFFF8'      up to doubleword boundary
         ST    R1,PDLLEN           Store length of PDL
         LA    R1,8
         A     R1,QVALLEN          Quoted-string-length + fudge factor
         ST    R1,QVALLEN          Store length of quoted-value area
         A     R1,PCLLEN           Get length of PCL plus quoted area
         L     R0,POSCOUNT         Get count of positional parameters
         A     R0,KEYCOUNT         Add count of positional parameters
         MH    R0,=Y(13*4)         Compute # of plists required
         ST    R0,VUPLEN           Store length of IKJCTT41 parm list
         AR    R0,R1               Add to total length
         ST    R0,PWLEN            Store length of this area
         GETMAIN RC,LV=(0),LOC=ANY Get it
         LTR   R15,R15             If didn't get it, error
         BNZ   GETMAIN_FAILURE
         ST    R1,PWADDR           Save address thereof
         LR    R4,R1               Initialize PCL entry pointer
         LA    R5,8                Initialize PDL offset value
         XR    R0,R0               Clear other PCE-related junk
         ST    R0,FIRSTKEY
         ST    R0,SUBTOSET
*
* Build the IKJPARM part of the PCL.
*
* PCE contents:  +0 (2)  Length of entire PCL
*                +2 (2)  Length of PDL returned by PARSE
*                +4 (2)  Offset in PDL to first IKJKEYWD PCE
*                        (or to end-of-field indicator, i.e.
*                        the x'0000' in an IKJSUBF or IKJENDP)
*
*        ...   ..,0(,R4)           Leave this unset for now...
         L     R0,PDLLEN
         STH   R0,2(,R4)           IKJPARM +2 (2) Length of PDL
*        ...   ..,4(,R4)           Leave this unset for now...
         LA    R4,6(,R4)           Bump past this PCE
*
* For each positional parameter, build an IKJIDENT PCE.
*
* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)
*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)
*                +2 (2)  Length of this PCE: 56 + 2*length(name)
*                +4 (2)  Offset in PDL to PDE for this parameter
*                +6 (1)  Flags:  B'0000 x000' (x = 1 if CHAR, else 0)
*                +7 (1)  X'00' (FIRST=ANY)
*                +8 (1)  X'00' (OTHER=ANY)
*                +9 (2)  Length of 'POSITIONAL PARAMETER pp' + 4
*                                  (25 + length(name))
*                +B (2)  X'0012'
*                +D (*)  'POSITIONAL PARAMETER pp' (21 + length(name))
*                +* (1)  Length of 'POSITIONAL PARAMETER pp' - 1
*                                  (20 + length(name))
*                +* (*)  'POSITIONAL PARAMETER pp' (21 + length(name))
*
         ICM   R8,15,POSCOUNT      Get count of positionals
         BZ    PBPPLEND            If none, skip
         L     R2,APOSD            Get address of first positional
PBPPLOOP DS    0H                  Loop to build PCE's
         ST    R4,POSDPCEA-POSDDATA(,R2) Set address of PCE for this
         MVI   0(R4),B'10010100'   +0 (1) Flags
         TM    POSDFLGS-POSDDATA(R2),POSDASIS If /ASIS option given
         BZ    PBPPNASI                       then
         MVI   1(R4),B'01000000'   +1 (1) Flags
         B     PBPPAEND                       else
PBPPNASI MVI   1(R4),B'00000000'   +1 (1) Flags
PBPPAEND DS    0H
         L     R14,POSDPCEL-POSDDATA(,R2) Get length of PCE
         STH   R14,2(,R4)          +2 (2) Length of this PCE
         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this
         TM    POSDFLGS-POSDDATA(R2),POSDCHAR If /QUOTABLE option given
         BZ    PBPPNCHA                       then
         MVI   6(R4),B'00001000'   +6 (1) Flags
         B     PBPPCEND                       else
PBPPNCHA MVI   6(R4),B'00000000'   +6 (1) Flags
PBPPCEND DS    0H
         MVI   7(R4),X'00'         +7 (1) X'00' (FIRST=ANY)
         MVI   8(R4),X'00'         +8 (1) X'00' (OTHER=ANY)
         L     R15,POSDMAXL-POSDDATA(,R2) Get length of name for prompt
         LA    R0,25(,R15)         21 + length(name) + 4
         STH   R0,9(,R4)           +9 (2) Length of '...' + 4
         MVC   11(2,R4),=X'0012'   +B (2) X'0012'
         MVC   13(21,R4),=C'POSITIONAL PARAMETER '
         LA    R4,13+21(,R4)       Point to where to move param name
         BCTR  R15,0               Reduce length for execute
         L     R1,POSDADDR-POSDDATA(,R2) Get address of parameter name
         EX    R15,MVCTOPCE        Move parameter name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R0,21(,R15)         21 + length(name) - 1
         STC   R0,0(,R4)           Length of prompt data
         MVC   1(21,R4),=C'POSITIONAL PARAMETER '
         LA    R4,1+21(,R4)        Point to where to move param name
         EX    R15,MVCTOPCE        Move parameter name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R5,8(,R5)           Increment PDE offset
         LA    R2,POSDDATL(,R2)    Continue
         BCT   R8,PBPPLOOP          until no more positionals
PBPPLEND DS    0H                  End loop
*
* For each keyword parameter, build an IKJKEYWD PCE.
*
* PCE contents:  +0 (1)  Flags:  B'0100 0000' (IKJKEYWD)
*                +1 (1)  Flags:  B'0000 0000'
*                +2 (2)  Length of this PCE: 6
*                +4 (2)  Offset in PDL to PDE for this parameter
*
* If the keyword has a value, build an IKJNAME PCE as follows:
*
* PCE contents:  +0 (1)  Flags:  B'0110 0100' (IKJNAME, has subfield)
*                +1 (1)  Flags:  B'0000 0000'
*                +2 (2)  Length of this PCE: 7 + length(name)
*                +4 (1)  Length of keyword name minus 1
*                +5 (*)  the keyword name
*                +* (2)  offset (plus 1) in PCL to subfield PCE
*
* A subfield will be built as well.  But not now.
*
* If the keyword doesn't have a value, build an IKJNAME PCE as follows:
*
* PCE contents:  +0 (1)  Flags:  B'0110 0000' (IKJNAME, no subfield)
*                +1 (1)  Flags:  B'0000 0000'
*                +2 (2)  Length of this PCE: 5 + length(name)
*                +4 (1)  Length of keyword name minus 1
*                +5 (*)  the keyword name
*
         ICM   R8,15,KEYCOUNT      Get count of keywords
         BZ    PBKWLEND            If none, skip
         L     R2,AKEYD            Get address of first keyword
PBKWLOOP DS    0H                  Loop to build PCE's
*
* Build IKJKEYWD PCE
*
         ICM   R0,15,FIRSTKEY      If this is first keyword
         BNZ   *+8                 then
         ST    R4,FIRSTKEY         set address of first keyword PCE
         ST    R4,KEYDPCEA-KEYDDATA(,R2) Set address of PCE for this
         MVI   0(R4),B'01000000'   +0 (1) Flags (IKJKEYWD)
         MVI   1(R4),B'00000000'   +1 (1) Flags
         LA    R0,6
         STH   R0,2(,R4)           +2 (2) Length of this PCE
         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this
         LA    R4,6(,R4)           Bump PCE pointer
*
* Build IKJNAME PCE, format of which depends if with value or not.
*
         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If a value specified
         BNO   PBKWNVAL            then...
         MVI   0(R4),B'01100100'   +0 (1) Flags (IKJNAME, has subfield)
         MVI   1(R4),B'00000000'   +1 (1) Flags
         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name
         LA    R0,7(,R15)                7 + length(name)
         STH   R0,2(,R4)           +2 (2) Length of this PCE
         BCTR  R15,0               Length minus 1 for store & execute
         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1
         LA    R4,5(,R4)           Point to where to move keyword name
         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCE
         LA    R4,1(R15,R4)        Bump past name
         ST    R4,KEYSUBOF-KEYDDATA(,R2) Save where to set subfield off
*        ...   ...0(,R4)           Leave subfield offset out for now
         LA    R4,2(,R4)           Bump to end of PCE
         B     PBKWNEXT
PBKWNVAL DS    0H                  No value specified...
         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS was specified
         BO    ERROR_ASIS_NEEDS_VAL           then error
         MVI   0(R4),B'01100000'   +0 (1) Flags (IKJNAME, no subfield)
         MVI   1(R4),B'00000000'   +1 (1) Flags
         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name
         LA    R0,5(,R15)                5 + length(name)
         STH   R0,2(,R4)           +2 (2) Length of this PCE
         BCTR  R15,0               Length minus 1 for store & execute
         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1
         LA    R4,5(,R4)           Point to where to move keyword name
         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCE
         LA    R4,1(R15,R4)        Bump past name
******** LA    R4,0(,R4)           Bump to end of PCE
PBKWNEXT DS    0H
         LA    R5,2(,R5)           Increment PDE offset
         LA    R2,KEYDDATL(,R2)    Continue
         BCT   R8,PBKWLOOP          until no more keywords
PBKWLEND DS    0H                  End loop
*
* For each keyword parameter with a value, build subfield PCE's.
*
* Build an IKJSUBF PCE.
*
* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)
*                +1 (2)  Offset in PCL to next end-of-field indicator
*                        (either the next IKJSUBF or the IKJENDP).
*                        If the subfield had keywords, this would have
*                        to point to the next IKJKEYWD PCE therein.
*
* Build an IKJIDENT PCE for the keyword value.
*
* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)
*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)
*                +2 (2)  Length of this PCE: 50 + 2*length(name)
*                +4 (2)  Offset in PDL to PDE for this parameter
*                +6 (1)  Flags:  B'0000 1000' (CHAR)
*                +7 (1)  X'01' (FIRST= is not applicable)
*                +8 (1)  X'01' (OTHER= is not applicable)
*                +9 (2)  Length of 'VALUE FOR KEYWORD pp' + 4
*                                  (22 + length(name))
*                +B (2)  X'0012'
*                +D (*)  'VALUE FOR KEYWORD pp' (18 + length(name))
*                +* (1)  Length of 'VALUE FOR KEYWORD pp' - 1
*                                  (17 + length(name))
*                +* (*)  'VALUE FOR KEYWORD pp' (18 + length(name))
*
         ICM   R8,15,KEYCOUNT      Get count of keywords
         BZ    PSKWLEND            If none, skip
         L     R2,AKEYD            Get address of first keyword
PSKWLOOP DS    0H                  Loop to build subfield PCE's
         ICM   R14,15,KEYSUBOF-KEYDDATA(R2) Get where to put sub offset
         BZ    PSNOSUB             If none, skip
         LA    R0,1(,R4)           Get address of PCE we're building
         S     R0,PWADDR           Convert to offset plus 1
         STH   R0,0(,R14)          Set keyword PCE's subfield offset
*
* Build IKJSUBF PCE
*
         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE
         BZ    PSNSUBST            to set, then
         LR    R0,R4                get address of this IKJSUBF PCE
         S     R0,PWADDR            convert to offset
         STH   R0,1(,R1)            set offset to next subfield
PSNSUBST DS    0H
         ST    R4,SUBTOSET         Set address of subfield to set
         MVI   0(R4),B'00000000'   +0 (1) Flags (end-of-field indicator
*        ...   ...,1(,R4)          +1 (1) Offset of next SUBF or ENDP
         LA    R4,3(,R4)           Bump PCE pointer
         MVI   0(R4),B'10010100'   +0 (1) Flags (IKJIDENT, PROMPT)
         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS option given
         BZ    PSNASIS                        then
         MVI   1(R4),B'01000000'   +1 (1) Flags
         B     PSNAEND                        else
PSNASIS  MVI   1(R4),B'00000000'   +1 (1) Flags
PSNAEND  DS    0H
         L     R15,KEYDMAXL-KEYDDATA(,R2) Get length of name for prompt
         LR    R14,R15
         SLA   R14,1               2 * length(name)
         LA    R14,50(,R14)        50 + (2 * length(name))
         STH   R14,2(,R4)          +2 (2) Length of this PCE
         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this
         MVI   6(R4),B'00001000'   +6 (1) Flags (CHAR)
         MVI   7(R4),X'01'         +7 (1) X'01' (FIRST=n/a)
         MVI   8(R4),X'01'         +8 (1) X'01' (OTHER=n/a)
         LA    R0,22(,R15)         18 + length(name) + 4
         STH   R0,9(,R4)           +9 (2) Length of '...' + 4
         MVC   11(2,R4),=X'0012'   +B (2) X'0012'
         MVC   13(18,R4),=C'VALUE FOR KEYWORD '
         LA    R4,13+18(,R4)       Point to where to move keyword name
         BCTR  R15,0               Length minus 1 for store & execute
         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R0,18(,R15)         18 + length(name) - 1
         STC   R0,0(,R4)           Length of prompt data
         MVC   1(18,R4),=C'VALUE FOR KEYWORD '
         LA    R4,1+18(,R4)        Point to where to move keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R5,8(,R5)           Increment PDE offset
PSNOSUB  DS    0H
         LA    R2,KEYDDATL(,R2)    Continue
         BCT   R8,PSKWLOOP          until no more keywords
PSKWLEND DS    0H                  End loop
         SPACE 1
*
* Build the IKJENDP part of the PCL.
*
* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)
*
         MVI   0(R4),B'00000000'   +0 (1) Flags
         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE
         BZ    PENSUBST            to set, then
         LR    R0,R4                get address of this IKJENDP PCE
         S     R0,PWADDR            convert to offset
         STH   R0,1(,R1)            set offset to next subfield
PENSUBST DS    0H
         ICM   R1,15,FIRSTKEY      If no keyword PCE built
         BNZ   PEGOTKEY            then
         ST    R4,FIRSTKEY          make this the one
PEGOTKEY DS    0H
         L     R15,PWADDR          Get address of start of PCE
         L     R0,FIRSTKEY         Load offset of first key/or/etc.PCE
         SR    R0,R15              Convert to offset
         STH   R0,4(,R15)          Set offset in IKJPARM PCE
         LA    R4,1(,R4)           Bump past this PCE
         LR    R0,R4
         S     R0,PWADDR           Convert to offset
         ST    R0,PCLLEN           Set actual PCL length
         L     R1,PWADDR           Get address of IKJPARM PCE
         STH   R0,0(,R1)           IKJPARM +0 (2) Length of PCL
         ST    R4,QOFF             Save address of where to build
*                                   unquoted strings
*
* Note that unquoted strings won't be built until/unless we assign
* default values from them after a successful parse of the arguments.
*
         EJECT
*
* Next steps:  If initial variable specified, use IKJCT441 to get its
*              value.  Otherwise use REXX call to get at arguments.
*              Make a command buffer out of this and call IKJPARS.
*              If parsing successful, go thru each positional and
*              keyword parameter, getting its value, and assign all
*              the values using IKJCT441.
*
         ICM   R0,15,PVARADDR      Get address of first-arg variable
         BZ    NOVAR               If none, try REXX arg call
         ST    R0,CVNAMEA          Set address of variable name
         L     R0,PVARLEN          Get length of first-arg variable
         ST    R0,CVNAMEL          Set length of variable name
         LA    R0,TSVERETR         Return variable value
*                                  (create variable if doesn't exist)
         ST    R0,CVENTRY          Set entry code
         XR    R0,R0
         ST    R0,CVVALUEA         Address of variable value
         ST    R0,CVVALUEL         Length of variable value
         ST    R0,CVTOKEN          Token
         LA    R14,CVENTRY         Store into IKJCT441 parameter list
         LA    R15,CVNAMEA
         LA    R0,CVNAMEL
         LA    R1,CVVALUEA
         LA    R2,CVVALUEL
         LA    R3,CVTOKEN
         STM   R14,R3,CVPARMS
         OI    CVPARM6,X'80'       Set VL bit
         LA    R1,CVPARMS          Point to parameter list
         L     R15,X'10'               Get address of CVT
         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table
         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441
         BALR  R14,R15             Call variable access routine
         CH    R15,=H'4'           Get return code
         BNH   GETVAROK            If not 0 or 4, error
         BAL   R14,ERROR_GETTING_VAR
         B     FLUSHIT
         SPACE 1
NOVAR    DS    0H                  No variable, try REXX arg call
         SPACE 1
*
***********************************************************************
*                                                                     *
* Invoke the IRXEXCOM routine to fetch the ARG information.           *
*                                                                     *
* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *
*                                                                     *
***********************************************************************
*
* Build the SHVBLOCK
*
* To store the argument value, we try using ARGWA, a 512-byte area
* that is already part of our workarea, to avoid unnecessary GETMAINs.
*
* If that doesn't turn out to be big enough, we'll have to GETMAIN,
* but it's best to avoid that.
*
         XC    SHVBLOCK(SHVBLEN),SHVBLOCK
         MVI   SHVCODE,SHVPRIV     Fetch private information
         LA    R1,L'ARGWA
         ST    R1,SHVBUFL          Length of 'fetch' value buffer
         LA    R1,ARGWA
         ST    R1,SHVVALA          Address of value buffer
         LA    R1,=C'ARG'          Name of thing to be fetched
         ST    R1,SHVNAMA          Address of variable name
         LA    R1,3                Length('ARG')
         ST    R1,SHVNAML          Length of variable name
         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1
         XR    R15,R15             IRXEXCOM parm 2
         LR    R0,R15              Parm 3 must be same as Parm 2
         LA    R1,SHVBLOCK         IRXEXCOM parm 4
         STM   R14,R1,IRPARMS
         OI    IRPARM4,X'80'
RETRYIRX DS    0H
         XR    R0,R0               Don't specify an environment block
         LA    R1,IRPARMS          Point to parameter list
         L     R15,X'10'               Get address of CVT
         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table
         L     R15,TSVTEXCO-TSVT(,R15) Get address of IRXEXCOM
         BALR  R14,R15             Call REXX arg access routine
         LTR   R15,R15             If rc zero
         BZ    OKIRX               then OK
         CH    R15,=Y(SHVTRUNC)    If value was truncated
         BE    OOPSIRX             then need more room to hold value
         B     ERROR_IRXEXCOM      Else error
OOPSIRX  DS    0H                  Not enough room to hold value
         ICM   R1,15,ARGADDR       Get address of arg buffer
         BZ    NOARGYET            If nonzero, then...
         L     R0,ARGLEN           Get length
         FREEMAIN RC,LV=(0),A=(1)
NOARGYET DS    0H
         LA    R0,1024             Increment arg len so far
         A     R0,ARGLEN
         ST    R0,ARGLEN
         ST    R0,SHVBUFL          Reset length of fetch buffer
         GETMAIN RC,LV=(0),LOC=ANY
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         ST    R1,ARGADDR
         ST    R1,SHVVALA          Reset address of value buffer
         B     RETRYIRX            Try again
OKIRX    DS    0H                  Everything OK
         MVC   CVVALUEL,SHVVALL    Set length of arg value
         MVC   CVVALUEA,SHVVALA    Set address of arg value
         SPACE 1
GETVAROK DS    0H
         EJECT
*
***********************************************************************
*                                                                     *
* Build a fake command buffer containing the value of the variable,   *
* for use by IKJPARS.  Format:                                        *
* ___________________________________________________________________ *
* |            |       |                                            | *
* | valuelen+4 | zero  |  value text                                | *
* |____________|_______|____________________________________________| *
*                                                                     *
***********************************************************************
*
         LA    R2,4                Get 4 + ...
         A     R2,CVVALUEL             length of variable value
         ST    R2,VBUFLEN          Save length
         GETMAIN RC,LV=(R2),LOC=ANY Get a fake command buffer
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         ST    R1,VBUFADDR         Save address of fake command buffer
         SLL   R2,16               Make buffer prefix
         ST    R2,0(,R1)           Store into fake command buffer
         LA    R2,4(,R1)           Address of fake command buffer text
         L     R14,CVVALUEA        Address of variable value
         L     R15,CVVALUEL        Length of variable value
         LR    R3,R15              Length of fake command buffer text
         MVCL  R2,R14              Move variable value to fake buffer
*
***********************************************************************
*                                                                     *
* Set up to call IKJPARS.                                             *
*                                                                     *
***********************************************************************
*
         XC    ANSWER,ANSWER       Clear PDL address field
         MVC   PPLUPT,CPPLUPT      Address of UPT
         MVC   PPLECT,CPPLECT      Address of ECT
         LA    R14,ECB             Address of ECB
         L     R15,PWADDR          Address of the PCL we built
         LA    R0,ANSWER           Address of PARSE answer area
         L     R1,VBUFADDR         Address of our fake command buffer
         STM   R14,R1,PPLECB       Set rest of PPL
         ST    R9,PPLUWA           User work area = "DATD"
         ST    R9,PPLVEWA          (we don't use verify exit, but...)
         SPACE 1
         CALLTSSR EP=IKJPARS,MF=(E,PPL)
         LTR   R15,R15
         BNZ   ERROR_PARSE_FAILURE
         EJECT
*
***********************************************************************
*                                                                     *
* Now that PARSE has successfully gotten values for all parameters,   *
* go through them and retrieve their values, which will be used to    *
* set variables via IKJCT441.                                         *
*                                                                     *
***********************************************************************
*
         L     R7,ANSWER           Get address of PDL
         L     R5,PWADDR           Get address of PCL-et-al work area
         A     R5,PCLLEN           Bump past PCL part
         A     R5,QVALLEN          Bump past unquoted-string part
         LA    R5,3(,R5)           Round up to
         N     R5,=X'FFFFFFFC'      fullword boundary
         ST    R5,VUPADDR          Save address of this plist
*
* Format of each block of IKJCT441 parameter list:
*
*  +00 -> Entry code (TSVEUPDT)
*  +04 -> Address of variable name
*  +08 -> Length of variable name
*  +0C -> Address of variable value
*  +10 -> Length of variable value
*  +14 -> Token (zero, not used)
*  +18 -> ECT (X'FFFFFFFF', not used)
*  +1C -> Return code from IKJCT441
*  +20 -> Address of next block of this parameter list or X'80000000'
*  +24 ... not part of plist, but space to hold the address of value
*  +28 ... not part of plist, but space to hold the length of value
*  +2C ... not part of plist, but space to hold the return code
*  +30 ... not part of plist, but space to hold the address of link
*
         XR    R0,R0
         ST    R0,CVTOKEN
         MVC   CVECT,=X'FFFFFFFF'
         LA    R15,TSVEUPDT        Entry code = update variable
         ST    R15,CVENTRY         Set entry code
         L     R4,POSCOUNT         Get # of positionals
         A     R4,KEYCOUNT           + # of keywords
         BZ    NOUPDATE            If no parameters, no updating.
         L     R15,VUPADDR         Get address of the plist
BPLOOP   DS    0H
         LR    R5,R15              Point to this element of parm list
         LA    R15,CVENTRY
         ST    R15,X'00'(,R5)      Parameter 1: entry code
*                                  Set later...
*        ST       ,X'04'(,R5)      Parameter 2: address of var name
*                                  Set later...
*        ST       ,X'08'(,R5)      Parameter 3: length of var name
         LA    R15,X'24'(,R5)      Value address slot
         ST    R15,X'0C'(,R5)      Parameter 4: address of var value
         LA    R15,X'28'(,R5)      Value length slot
         ST    R15,X'10'(,R5)      Parameter 5: length of var value
         LA    R15,CVTOKEN         Dummy token
         ST    R15,X'14'(,R5)      Parameter 6: token (not used)
         LA    R15,CVECT           Dummy ECT
         ST    R15,X'18'(,R5)      Parameter 7: ECT (not used)
         LA    R15,X'2C'(,R5)      Return code slot
         ST    R15,X'1C'(,R5)      Parameter 8: IKJCT441 return code
         LA    R15,X'30'(,R5)      Link slot
         ST    R15,X'20'(,R5)      Parameter 9: next element in list
         LA    R15,X'34'(,R5)
         ST    R15,X'30'(,R5)      Address of next plist block
         OI    X'20'(R5),X'80'     Set VL bit
         BCT   R4,BPLOOP           Continue
         L     R0,=X'00000000'     At end,
         ST    R0,X'30'(,R5)       clear last link pointer in list
         L     R5,VUPADDR          Point to first plist block again
         EJECT
*
***********************************************************************
*                                                                     *
* Now go through positional parameters, setting things up.            *
*                                                                     *
* Format of PDE for a positional parameter (IKJIDENT):                *
*                                                                     *
* +0 (4) Pointer to the positional operand                            *
* +4 (2) Length thereof                                               *
* +6 (1) Flags                                                        *
* +7 (1) Reserved                                                     *
*                                                                     *
* Meaning of flags:  0... ....  The operand is not present.           *
*                    1... ....  The operand is present.               *
*                    .xxx xxxx  Reserved bits.                        *
*                                                                     *
***********************************************************************
*
         ICM   R8,15,POSCOUNT      Get count of positionals
         BZ    BPPPLEND            If none, skip
         L     R2,APOSD            Get address of first positional
BPPPLOOP DS    0H                  Loop to fill in IKJCT441 plist
         LA    R15,POSDADDR-POSDDATA(,R2) Get address of param name
         ST    R15,X'04'(,R5)      Parameter 2: address of var name
         LA    R15,POSDLEN-POSDDATA(,R2) Get length of param name
         ST    R15,X'08'(,R5)      Parameter 3: length of var name
         L     R15,POSDPCEA-POSDDATA(,R2) Get address of PCE
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
*
* Note: Of course it's impossible for the operand not to be present
*       under the current implementation.  But a future extension
*       might make this possible.
*
         TM    6(R1),X'80'         If operand is not present,
         BO    BPPPPRES            then...
         XR    R14,R14              say it's set to a null value
         XR    R15,R15              say it's set to a null value
         B     BPPPSET             else...
BPPPPRES DS    0H                  (operand is present)
         L     R14,0(,R1)           get address of value
         LH    R15,4(,R1)           get length of value
BPPPSET  DS    0H                  else (operand is present)
         ST    R14,X'24'(,R5)      Set address of variable value
         ST    R15,X'28'(,R5)      Set length of variable value
         L     R5,X'20'(,R5)       Go to
         L     R5,0(,R5)                 next element of param list
         LA    R2,POSDDATL(,R2)    Continue
         BCT   R8,BPPPLOOP          until no more positionals
BPPPLEND DS    0H                  End loop
         EJECT
*
***********************************************************************
*                                                                     *
* Now go through keyword parameters, setting things up.               *
*                                                                     *
* Format of PDE for a keyword parameter (IKJKEYWD):                   *
*                                                                     *
* +0 (2) Number (0 if not specified, 1 if specified)                  *
*                                                                     *
***********************************************************************
*                                                                     *
* Format of PDE for a keyword value parameter (IKJIDENT):             *
*                                                                     *
* +0 (4) Pointer to the positional operand                            *
* +4 (2) Length thereof                                               *
* +6 (1) Flags                                                        *
* +7 (1) Reserved                                                     *
*                                                                     *
* Meaning of flags:  0... ....  The operand is not present.           *
*                    1... ....  The operand is present.               *
*                    .xxx xxxx  Reserved bits.                        *
*                                                                     *
***********************************************************************
*
         ICM   R8,15,KEYCOUNT      Get count of keywords
         BZ    BPKWLEND            If none, skip
         L     R2,AKEYD            Get address of first keyword
BPKWLOOP DS    0H                  Loop to fill in IKJCT441 plist
         ST    R2,SAVER2           Save register to protect from TRT's
         LA    R15,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         ST    R15,X'04'(,R5)      Parameter 2: address of var name
         LA    R15,KEYWORDL-KEYDDATA(,R2) Get length of keyword name
         ST    R15,X'08'(,R5)      Parameter 3: length of var name
         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If keyword(value),
         BO    BPKWDVAL            then process value subfield
*
* Keyword without value is set to keyword name if specified, else null
*
         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
         CLC   0(2,R1),=X'0000'    If keyword is not specified,
         BNE   BPKWWPRS            then...
         XR    R15,R15              say it's set to a null value
         ST    R15,X'24'(,R5)       set address of variable value
         ST    R15,X'28'(,R5)       set length of variable value
         B     BPKWNEXT            else...
BPKWWPRS DS    0H                  (operand is present)
         L     R14,X'04'(,R5)       get address of variable name
         L     R15,X'08'(,R5)       get length of variable name
         ST    R14,X'0C'(,R5)      Parameter 4: address of var value
         ST    R15,X'10'(,R5)      Parameter 5: length of var value
         B     BPKWNEXT
         SPACE 1
BPKWDVAL DS    0H                  Else keyword with a value specified
*
* Keyword with value:  If keyword is present, set from value subfield
* (which must be present according to the PARS rules).  Otherwise,
* set value from default from XPROC statement, unquoting if needed.
*
         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
         CLC   0(2,R1),=X'0000'    If keyword is not specified,
         BNE   BPKWVPRS            then...
         L     R14,KEYDVALA-KEYDDATA(,R2) get address of default value
         L     R15,KEYDVALL-KEYDDATA(,R2) get length of default value
         TM    KEYFLAGS-KEYDDATA(R2),KEYFQUOT If value is quoted,
         BNO   BPKWVSET            then...
*                                   unquote it
         LA    R1,1(,R14)          Get address of quoted string + 1
         LR    R3,R15              Get length of quoted string
         SH    R3,=H'2'            minus 2 to get length between quotes
         BZ    BPKWNULL            If '', set variable to null value
         LR    R15,R1
         LR    R14,R1              Save address of string input
         ST    R14,SCANPTR
         AR    R14,R3              Save address of end of it
         ST    R14,SCANEPTR
         L     R14,QOFF            Get where to build unquoted string
         LA    R0,256              Make a constant value of 256
BPGOTQL  CR    R3,R0               If length greater than 256
         BNH   BPGOTQX             then...
         TRT   0(256,R15),STBLQUOT  scan for "'"
         BNZ   BPGOTQT              If we found it, go. Else
         MVC   0(256,R14),0(R15)    copy unquoted data to area
         AR    R14,R0               Increment output pointer by 256
         AR    R15,R0               Increment input pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    BPGOTQL              Either continue scanning
         B     BPGOTQE              or, if length zero, finished
BPGOTQX  DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,BPGQTRT           Scan for "'"
         BNZ   BPGOTQT              If found something, go
         B     BPGOTQE              else end of string
BPGOTQT  DS    0H                  Reached "'"
         CLI   1(R1),C''''         Another "'" has to follow
         BNE   0(0)                (else abend)
         LR    R3,R1               Get length we just scanned
         SR    R3,R15
         EX    R3,BPGQMVC          Move data so far (R15 -> it)
BPGQNMV  DS    0H                  (including quote, so no BCTR)
         LA    R14,1(R14,R3)       Bump past it and following quote
         LA    R15,2(,R1)          Bump to location past "''"
         L     R3,SCANEPTR
         SR    R3,R15              R3 := length remaining to scan
         BP    BPGOTQL             If something left, continue scan
BPGOTQE  DS    0H                  End of quoted string
         L     R3,SCANEPTR
         SR    R3,R15              Get length remaining to move
         BZ    BPGENMV             If zero, skip move
         EX    R3,BPGQMVC          Move data so far (R15 -> it)
BPGENMV  DS    0H                  (including quote, so no BCTR)
         LA    R14,0(R14,R3)       Bump past it
         LR    R15,R14
         S     R15,QOFF            Get length of unquoted string
         L     R1,QOFF             Get address of unquoted string
         ST    R14,QOFF            Update where to build next string
         LR    R14,R1
         B     BPKWDSET            Set address and length of string
BPKWVSET DS    0H                  else (operand is present)
         ST    R14,X'24'(,R5)      Set address of variable value
         ST    R15,X'28'(,R5)      Set length of variable value
         B     BPKWNEXT
BPKWVPRS DS    0H                  (operand is present)
         L     R15,KEYSUBOF-KEYDDATA(,R2) Get where subfield offset is
         LH    R15,0(,R15)         Get offset+1 of IKJSUBF PCE
         LA    R15,2(,R15)         Bump to associated IKJIDENT PCE
         A     R15,PWADDR          Convert to address of subfield
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
*
* Note: Of course it's impossible for the operand not to be present
*       under the current implementation.  But a future extension
*       might make this possible.
*
         TM    6(R1),X'80'         If operand is not present,
         BO    BPKWDPRS            then...
BPKWNULL DS    0H
         XR    R14,R14              say it's set to a null value
         XR    R15,R15              say it's set to a null value
         B     BPKWDSET            else...
BPKWDPRS DS    0H                  (operand is present)
         L     R14,0(,R1)           get address of value
         LH    R15,4(,R1)           get length of value
BPKWDSET DS    0H                  else (operand is present)
         ST    R14,X'24'(,R5)      Set address of variable value
         ST    R15,X'28'(,R5)      Set length of variable value
BPKWNEXT DS    0H                  Continue
         L     R5,X'20'(,R5)       Go to
         L     R5,0(,R5)                 next element of param list
         L     R2,SAVER2           Restore register clobbered by TRT
         LA    R2,KEYDDATL(,R2)    Continue
         BCT   R8,BPKWLOOP          until no more positionals
BPKWLEND DS    0H                  End loop
*
* Now call IKJCT441 to do all the variable updates.
*
         L     R1,VUPADDR          Point to parameter list
         L     R15,X'10'               Get address of CVT
         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table
         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441
         BALR  R14,R15             Call variable access routine
         L     R5,VUPADDR
RCLOOP   DS    0H
         LA    R5,0(,R5)           Clear VL bit if any
         LTR   R5,R5
         BZ    RCEND
         L     R15,X'2C'(,R5)      Get return code set by IKJCT441
         CH    R15,=H'4'           If return code
         BNH   RCNEXT              If not 0 or 4, error
         BAL   R14,ERROR_PUTTING_VAR
         OI    FLAGS,FLAGPUTE
RCNEXT   L     R5,X'20'(,R5)       Go to
         L     R5,0(,R5)                 next element of param list
         B     RCLOOP
RCEND    DS    0H
         TM    FLAGS,FLAGPUTE      If a variable update error,
         BO    FLUSHIT             then flush
         SPACE 1
NOUPDATE DS    0H                  Here if no call to IKJCT441 needed
         SPACE 1
         B     RETURN0             Everything fine, return code(0)
         EJECT
*
TRTPOSCT TRT   0(*-*,R3),NUMTBL    Executed: scan word for numerics
PACKIT   PACK  DOUBLE(8),0(*-*,R3) Executed: convert word to decimal
VERIFYP  TRT   0(*-*,R14),VERTBL   Executed: verify syntax of parameter
MVCWORD  MVC   0(*-*,R1),0(R14)    Executed: move parameter to wordarea
UPWORD   TR    0(*-*,R1),UPTBL     Executed: translate to uppercase
COMPWORD CLC   0(*-*,R1),0(R14)    Executed: compare parameters
MVCTOPCE MVC   0(*-*,R4),0(R1)     Executed: move parameter name to PCE
BPGQTRT  TRT   0(*-*,R15),STBLQUOT Executed: scan for "'" mark
BPGQMVC  MVC   0(*-*,R14),0(R15)   Executed: copy unquoted data to area
*
         EJECT
*
***********************************************************************
*                                                                     *
* Various error conditions.                                           *
*                                                                     *
***********************************************************************
*
ERROR_GETTING_VAR DS 0H
         ST    R14,E44114          Save return register
         ST    R15,RC441           Save IKJCT441 return code
         L     R2,CVNAMEL          Length of variable name
         L     R3,CVNAMEA          Address of variable name
         ERROR MSG_GETTING_VAR,FLUSH=NO
         B     ERROR441
         SPACE 1
ERROR_PUTTING_VAR DS 0H
         ST    R14,E44114          Save return register
         ST    R15,RC441           Save IKJCT441 return code
         L     R2,X'08'(,R5)       -> Length of variable name
         L     R2,0(,R2)           Length of variable name
         L     R3,X'04'(,R5)       -> Address of variable name
         L     R3,0(,R3)           Address of variable name
         ERROR MSG_PUTTING_VAR,FLUSH=NO
******** B     ERROR441
         SPACE 1
ERROR441 DS    0H
         XR    R2,R2               No additional information for...
         XR    R3,R3
         L     R4,RC441            Load IKJCT441 return code
         CH    R4,=H'81'           Check IKJCT441 return code
         BH    ERROR441_MISC       > 81
         BE    ERROR441_RC81       = 81
         B     *(R4)               Else branch based on return code
         B     ERROR441_MISC       04: Variable cannot be rescanned
*                                  (not treated as an error here)
         B     ERROR441_RC08       08: Variable is a CLIST BIF
         B     ERROR441_RC12       12: Variable is a CLIST label
         B     ERROR441_RC16       16: Variable is unmodifiable
         B     ERROR441_MISC       20: n/a
         B     ERROR441_RC24       24: Variable is a CLIST subprocedure
         B     ERROR441_MISC       28: n/a
         B     ERROR441_RC32       32: GETMAIN/FREEMAIN failure
         B     ERROR441_RC36       36: Variable length is invalid
         B     ERROR441_RC40       40: Not in CLIST or REXX environment
         B     ERROR441_MISC       44: invalid entry code
         B     ERROR441_MISC       48: n/a
         B     ERROR441_MISC       52: n/a
         B     ERROR441_MISC       56: n/a
         B     ERROR441_MISC       60: n/a
         B     ERROR441_MISC       64: n/a
         B     ERROR441_MISC       68: n/a
         B     ERROR441_MISC       72: n/a
         B     ERROR441_RC76       76: Variable is undefined &SYSX...
         B     ERROR441_RC80       80: Variable name invalid for REXX
ERROR441_RC08 ERROR MSG_IKJCT441_RC08,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC12 ERROR MSG_IKJCT441_RC12,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC16 ERROR MSG_IKJCT441_RC16,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC24 ERROR MSG_IKJCT441_RC24,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC32 ERROR MSG_IKJCT441_RC32,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC36 ERROR MSG_IKJCT441_RC36,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC40 ERROR MSG_IKJCT441_RC40,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC76 ERROR MSG_IKJCT441_RC76,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC80 ERROR MSG_IKJCT441_RC80,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC81 ERROR MSG_IKJCT441_RC81,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_MISC DS 0H
         CVD   R4,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         LA    R2,2                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_IKJCT441_RC,FLUSH=NO
         L     R14,E44114
         BR    R14
         SPACE 1
NOOPERANDS DS  0H                  No input variable
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_OPERANDS
         SPACE 1
NOPOSCOUNT DS  0H                  No count of positional parameters
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_POS_COUNT
         SPACE 1
BADPOSCOUNT DS 0H                  Bad count of positional parameters
         LA    R2,1(,R4)           Get length of bad data
         ERROR MSG_BAD_POS_COUNT
         SPACE 1
ERROR_NO_WANT_LP DS 0H             Left parenthesis found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_LP
         SPACE 1
ERROR_NO_WANT_RP DS 0H             Right parenthesis found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_RP
         SPACE 1
ERROR_NO_WANT_QS DS 0H             Quoted string found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_QS
         SPACE 1
ERROR_NO_WANT_SL DS 0H             Slash found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_SL
         SPACE 1
PPMISSING DS   0H                  Positional parm not found, expected
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_TOO_FEW_PPARMS
         SPACE 1
ERROR_PARM_TOO_LONG DS 0H
         LA    R2,252              Display only up to maximum length
         LR    R3,R1               Address of offending parameter
         ERROR MSG_PARM_TOO_LONG
         SPACE 1
ERROR_PARM_INVALID DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_PARM_INVALID
         SPACE 1
ERROR_PARM_DUPLICATE DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_PARM_DUPLICATE
         SPACE 1
ERROR_OPT_TOO_LONG DS 0H
         LA    R2,L'OPTION         Display only up to maximum length
         LR    R3,R1               Address of offending parameter
         ERROR MSG_OPT_TOO_LONG
         SPACE 1
ERROR_OPT_INVALID DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_OPT_INVALID
         SPACE 1
ERROR_OPT_POS_ONLY DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_OPT_POS_ONLY
         SPACE 1
ERROR_ASIS_NEEDS_VAL DS 0H
         L     R3,KEYWORDA-KEYDDATA(,R2)
         L     R2,KEYWORDL-KEYDDATA(,R2)
         ERROR MSG_ASIS_NEEDS_VAL
         SPACE 1
ERROR_PP_WITH_LP DS 0H             Positional parm with left paren
         ERROR MSG_PP_WITH_LP
         SPACE 1
ERROR_FIRST_ARG DS 0H              Bad first argument
         LR    R2,R4               Length of offending parameter
         ERROR MSG_VAR_TOO_LONG
         SPACE 1
ERROR_IRXEXCOM DS 0H               IRXEXCOM failed
         C     R15,=F'-2'          Insufficient storage?
         BE    GETMAIN_FAILURE
         C     R15,=F'-1'          No valid REXX environment?
         BE    ERROR_REXX_REQUIRED
         CVD   R15,DOUBLE
         UNPK  DOUBLE(3),DOUBLE(8)
         OI    DOUBLE+2,X'F0'
         LA    R2,3                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_IRXEXCOM_FAIL
         SPACE 1
ERROR_REXX_REQUIRED DS 0H
         XR    R2,R2
         XR    R3,R3
         ERROR MSG_REXX_REQUIRED
ERROR_PARSE_FAILURE DS 0H          IKJPARS failed
         CH    R15,=H'4'
         BE    FLUSHIT
         CH    R15,=H'20'
         BE    FLUSHIT
         CH    R15,=H'32'
         BE    FLUSHIT
         CVD   R15,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         LA    R2,2                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_PARSE_FAILURE
         SPACE 1
GETMAIN_FAILURE DS 0H              Insufficient storage
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_GETMAIN_FAIL
         SPACE 1
KVERROR  DS    0H                  This should never happen
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_KV_ERROR
         SPACE 1
FLUSHIT  DS    0H                  Return in failure
         SPACE 1
         TCLEARQ INPUT             Flush terminal input
         MVC   FLUSH(LENFLUSH),MFLUSH Set up STACK list form
         XC    ECB,ECB             Clear ECB and flush the input stack
         STACK PARM=FLUSH,MF=(E,IOPL)
         LTR   R15,R15             If STACK failed,
         BZ    RETURN12            then...
         CVD   R15,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         LA    R2,2                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_STACK_ERROR,FLUSH=NO
RETURN12 DS    0H
         LA    R2,12               Set return code to 12
         B     RETURN
         SPACE 1
RETURN0  DS    0H                  Return with code 0
         XR    R2,R2               Set return code to zero
******** B     RETURN
         SPACE 1
RETURN   DS    0H                  R2 contains return code
         SPACE 1
         ICM   R1,15,PWADDR        If there was a parse work area
         BZ    NOFREEPW            then free it
         L     R0,PWLEN
         FREEMAIN RC,LV=(0),A=(1)
NOFREEPW DS    0H
         SPACE 1
         ICM   R1,15,VBUFADDR      If there was a fake command buffer
         BZ    NOFREEVBUF          then free it
         L     R0,VBUFLEN
         FREEMAIN RC,LV=(0),A=(1)
NOFREEVBUF DS  0H
         SPACE 1
         ICM   R1,15,ARGADDR       If there was an arg buffer
         BZ    NOFREEARG           then free it
         L     R0,ARGLEN           Get length
         FREEMAIN RC,LV=(0),A=(1)
NOFREEARG DS   0H
         SPACE 1
         ICM   R1,15,AKEYD         If there was a keyword/value area
         BZ    NOFREEKEYD          then free it
         L     R0,LKEYD
         FREEMAIN RC,LV=(0),A=(1)
NOFREEKEYD DS  0H
         SPACE 1
         ICM   R1,15,APOSD         If there was a pos parm area,
         BZ    NOFREEPOSD          then free it
         L     R0,LPOSD
         FREEMAIN RC,LV=(0),A=(1)
NOFREEPOSD DS  0H
         SPACE 1
         IKJRLSA ANSWER            Free IKJPARS storage if any
         SPACE 1
         L     R0,DATDLEN          Get length of work area
         LR    R1,R13              Get address of work area
         L     R13,4(,R13)         Unchain save area
         ST    R2,16(,R13)         Store return code in save area
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* Subroutines                                                         *
***********************************************************************
         EJECT
DOOPTS   DS    0H                  Process options following "/"
         SPACE 1
         ST    R14,DOOPT14         Save return address
         TM    FLAGS,FLAGPOSD+FLAGKEYD Must be processing either a
         BZ    ERROR_NO_WANT_SL    positional or a keyword
*
* Process the option following the slash.
*
         BAL   R14,SCAN            Scan for option name
         B     DOOPTRET            None, skip
         B     OPTNAME             Unquoted name, process
         B     ERROR_NO_WANT_QS    Quoted string found
         B     ERROR_NO_WANT_LP    "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     ERROR_NO_WANT_SL    "/" found
         SPACE 1
OPTNAME  DS    0H                  Option name found
*
* Validate option name and process it.
*
         CH    R2,=Y(L'OPTION)     If too long
         BH    ERROR_OPT_TOO_LONG  then error
         MVI   OPTION,C' '         Clear option field to blanks
         MVC   OPTION+1(L'OPTION-1),OPTION
         LR    R14,R1              Address
         LR    R15,R2              Length
         BCTR  R15,0               Reduce length for execute
         LA    R1,OPTION           Point to place to move option name
         EX    R15,MVCWORD         Move option name to option area
         EX    R15,UPWORD          Translate to uppercase
*
* Time to process the options
*
         TM    FLAGS,FLAGPOSD      If currently processing positional
         BO    DOOPTP              then check positional options
         B     DOOPTK              else check keyword options
         SPACE 1
DOOPTP   DS    0H
         L     R1,LASTAREA         Point to current PP area
******** CLC   =C'OPTIONAL ',OPTION
******** BE    DOOPTP_OPTIONAL
         CLC   =C'ASIS ',OPTION
         BE    DOOPTP_ASIS
         CLC   =C'QUOTABLE ',OPTION
         BE    DOOPTP_CHAR
         B     ERROR_OPT_INVALID   All other options are bad, error
         SPACE 1
DOOPTP_OPTIONAL DS 0H
         OI    POSDFLGS-POSDDATA(R1),POSDOPT
         B     DOOPTRET
         SPACE 1
DOOPTP_ASIS     DS 0H
         OI    POSDFLGS-POSDDATA(R1),POSDASIS
         B     DOOPTRET
         SPACE 1
DOOPTP_CHAR     DS 0H
         OI    POSDFLGS-POSDDATA(R1),POSDCHAR
         B     DOOPTRET
         SPACE 1
DOOPTK   DS    0H
         L     R1,LASTAREA         Point to current KV area
         CLC   =C'ASIS ',OPTION
         BE    DOOPTK_ASIS
         CLC   =C'QUOTABLE ',OPTION
         BE    ERROR_OPT_POS_ONLY
         B     ERROR_OPT_INVALID   All other options are bad, error
         SPACE 1
DOOPTK_ASIS    DS 0H
         OI    KEYFLAGS-KEYDDATA(R1),KEYFASIS
         B     DOOPTRET
         SPACE 1
DOOPTRET DS    0H
         L     R14,DOOPT14
         BR    R14
         EJECT
SCAN     DS    0H
*
***********************************************************************
*                                                                     *
* This routine scans the command buffer for operands.  It returns the *
* address of the next operand in R1 and its length in R2 (when there  *
* are no more operands, R1 and R2 are zeroed).  The operand may be a  *
* name, a number, a parenthesis, or a quoted string. If it's a quoted *
* string, it will be returned as is, quotes and all.                  *
*                                                                     *
* Return is as follows:                                               *
*                                                                     *
* To return address + 0  ... no value found                           *
* To return address + 4  ... unquoted string found                    *
* To return address + 8  ... quoted string found                      *
* To return address + 12 ... left parenthesis found                   *
* To return address + 16 ... right parenthesis found                  *
*                                                                     *
* SCANPTR -> area to scan; SCANEPTR -> end thereof                    *
*                                                                     *
***********************************************************************
*
         L     R1,SCANPTR          Point to data to scan
         XR    R2,R2               Clear TRT register
         L     R3,SCANEPTR         Point to end of data to scan
         SR    R3,R1               Get length of data to scan
         LA    R0,256              Set up constant 256
         LTR   R3,R3               If length is zero
         BZ    SCANEND             then finished, return no value
SCANLOOP DS    0H                  Do TRT for remaining length
         CR    R3,R0               If length greater than 256
         BNH   SCANLEFF            then...
         TRT   0(256,R1),STBL0      scan for important characters
         BNZ   SCANGOT1             If we found something, process it
         AR    R1,R0                Else increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    SCANLOOP             Either continue scanning
         B     SCANEND              or exit (no value), length now zero
SCANLEFF DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,SCANTRT           Scan for important characters
         BNZ   SCANGOT1             If we found something, process it
******** B     SCANEND              If none found, exit in failure
SCANEND  DS    0H                  Reached end of data
         XR    R1,R1               Clear scanning registers
         XR    R2,R2
         BR    R14                 Return with no value
SCANGOT1 DS    0H                  R1 -> something we found
         L     R3,SCANEPTR
         SR    R3,R1               R3 := length remaining to scan
         B     *(R2)               R2 tells what kind it is
         B     GOTWORD             4:  Found nonblank
         B     GOTLP               8:  Found (
         B     GOTRP               12: Found )
         B     GOTSLASH            16: Found /
         B     GOTQUOTE            20: Found '
         SPACE 1
GOTWORD  DS    0H                  Found a nonblank (word)
*                                  R1 -> it, R3 = length to scan
*
* Scan for end-of-word
*
         LR    R15,R1              Save address of the word
GOTWORDL CR    R3,R0               If length greater than 256
         BNH   GOTWORDX            then...
         TRT   0(256,R1),STBLWORD   scan for important characters
         BNZ   GOTWORDT             If we found it, go. Else
         AR    R1,R0                Increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    GOTWORDL             Either continue scanning
         B     GOTWORDE             or go if length zero
GOTWORDX DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,GOTWTRT           Scan for important characters
         BNZ   GOTWORDT             If found something, go
         L     R1,SCANEPTR          Else end of text = end of word
         B     GOTWORDE
GOTWORDT L     R3,SCANEPTR         R3 := length remaining to scan
         SR    R3,R1               R1 -> character
         B     *(R2)               Branch depending on R2
         B     GOTWORDE            4:  Found whitespace, end of word
         B     GOTWLP              8:  Found (
         B     GOTWRP              12: Found )
         B     GOTWS               16: Found /
         SPACE 1
GOTWORDE DS    0H                  Found whitespace or end of word
         LR    R2,R1               Set length of word found
         SR    R2,R15
         ST    R1,SCANPTR          Set scan pointer for next scan
         LR    R1,R15              Set pointer to found item
         B     4(,R14)             Return to caller with unquoted word
GOTWLP   DS    0H                  Found "(" in word
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BZ    GOTWORDE            If was zero, not nested, end of word
         LA    R2,1(,R2)           Increment it
         ST    R2,PARCOUNT
         B     GOTWNEXT            Else process as constituent char
GOTWRP   DS    0H                  Found a right parenthesis ")"
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BZ    GOTWORDE            If was zero, not nested, end of word
         BCTR  R2,0                Decrement count
         ST    R2,PARCOUNT
         LTR   R2,R2
         BZ    GOTWORDE            If now zero, not nested, end of word
         B     GOTWNEXT            Else process as constituent char
GOTWS    DS    0H                  Found a slash "/"
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BNZ   GOTWNEXT            If inside (), treat as constituent
         B     GOTWORDE            Else treat as end of word
         SPACE 1
GOTWNEXT LA    R1,1(,R1)           Bump text pointer
         BCT   R3,GOTWORDL         Decrement count, scan if nonzero
         B     GOTWORDE            end of word
         SPACE 1
GOTLP    DS    0H                  Found a left parenthesis "("
*                                  R1 -> it, R3 = length to scan
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BNZ   GOTWORD             If count was nonzero, start of word
         LA    R2,1(,R2)           Increment it
         ST    R2,PARCOUNT
         LA    R2,1                Else set length to 1
         LA    R15,1(,R1)          Set pointer past it
         ST    R15,SCANPTR         Update scan pointer
         B     12(,R14)            Return single left parenthesis
         SPACE 1
GOTRP    DS    0H                  Found a right parenthesis ")"
*                                  R1 -> it, R3 = length to scan
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BZ    SCANRETP            If was zero, not nested, return ")"
         BCTR  R2,0                Decrement count
         ST    R2,PARCOUNT
         LTR   R2,R2
         BNZ   GOTWORD             If now nonzero, part of word
SCANRETP DS    0H                  Return the parenthesis
         LA    R2,1                Set length to 1
         LA    R15,1(,R1)          Set pointer past it
         ST    R15,SCANPTR         Update scan pointer
         B     16(,R14)            Return single right parenthesis
         SPACE 1
GOTQUOTE DS    0H                  Found a single quote "'"
*                                  R1 -> it, R3 = length to scan
         LR    R15,R1              Save address of the quoted string
         LA    R1,1(,R1)           Bump past initial quote
         BCT   R3,GOTQL            Decrement length to scan
         B     ERRQUOTE            If nothing left, error
GOTQL    CR    R3,R0               If length greater than 256
         BNH   GOTQX               then...
         TRT   0(256,R1),STBLQUOT   scan for "'"
         BNZ   GOTQT                If we found it, go. Else
         AR    R1,R0                Increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    GOTQL                Either continue scanning
         B     ERRQUOTE             or, if length zero, error
GOTQX    DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,GOTQTRT           Scan for "'"
         BNZ   GOTQT                If found something, go
         B     ERRQUOTE             Else error
GOTQT    DS    0H                  Reached "'"
         L     R3,SCANEPTR
         SR    R3,R1               R3 := length remaining to scan
         BNP   GOTQE               If zero, it's the ending quote
         CLI   1(R1),C''''         If not "''"
         BNE   GOTQE               then it's the ending quote
         LA    R1,2(,R1)           Else bump past "''"
         SH    R3,=H'2'            Decrement scan length
         BP    GOTQL               If something left, continue scan
         B     ERRQUOTE            Else error
GOTQE    DS    0H                  End of quoted string
         LA    R1,1(,R1)           Bump past final quote mark
         LR    R2,R1               Set length of string including "'"s
         SR    R2,R15
         ST    R1,SCANPTR          Set scan pointer for next scan
         LR    R1,R15              Set pointer to found item
         B     8(,R14)             Return quoted string to caller
         SPACE 1
GOTSLASH DS    0H                  Found a slash "/"
*                                  R1 -> it, R3 = length to scan
         CH    R3,=H'2'            If not enough room for "/*"
         BL    GOTSL               then treat as real slash
         CLI   1(R1),C'*'          If not "/*"
         BNE   GOTSL               then treat as real slash
         LA    R1,2(,R1)           Else start of comment: bump text ptr
         SH    R3,=H'2'            Decrement length to scan
         BNP   SCANEND             If nothing left, end of text
GOTCOMML CR    R3,R0               If length greater than 256
         BNH   GOTCOMMX            then...
         TRT   0(256,R1),STBLCOMM   scan for "*"
         BNZ   GOTCOMME             If we found it, go. Else
         AR    R1,R0                Increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    GOTCOMML             Either continue scanning
         B     SCANEND              or, if length zero, end of text
GOTCOMMX DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,GOTCTRT           Scan for "*"
         BNZ   GOTCOMME             If found something, go
         B     SCANEND              Else end of text
GOTCOMME DS    0H                   Reached an "*"
         L     R3,SCANEPTR
         SR    R3,R1               R3 := length remaining to scan
         CH    R3,=H'2'            If not enough room for "*/"
         BL    GOTCOMMC            then continue scanning for it
         CLI   1(R1),C'/'          If not "*/"
         BNE   GOTCOMMC            then continue scanning for it
         LA    R1,2(,R1)           Else bump past "*/"
         SH    R3,=H'2'            Decrement scan length
         BP    SCANLOOP            If something left, continue scan
         B     SCANEND             Else end of text
GOTCOMMC DS    0H                  "*" but no "/"
         LA    R1,1(,R1)           Bump past "*"
         BCT   R3,GOTCOMML         Decrement length, continue if nzero
         B     SCANEND             Else end of text
GOTSL    DS    0H                  Found a slash "/" without a "*"
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BNZ   GOTWORD             If inside (), treat as constituent
RETSLASH DS    0H                  Else treat as single slash "/"
         LA    R2,1                Set length to 1
         LA    R15,1(,R1)          Set pointer past it
         ST    R15,SCANPTR         Update scan pointer
         B     20(,R14)            Return single slash
         SPACE 1
ERRQUOTE DS    0H                  Mismatched quotes
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_QUOTE_ERROR
         SPACE 1
SCANTRT  TRT   0(*-*,R1),STBL0      (Executed instruction)
GOTWTRT  TRT   0(*-*,R1),STBLWORD   (Executed instruction)
GOTCTRT  TRT   0(*-*,R1),STBLCOMM   (Executed instruction)
GOTQTRT  TRT   0(*-*,R1),STBLQUOT   (Executed instruction)
         SPACE 1
STBL0    DC    256YL1(4)           Table to scan for good stuff
         ORG   STBL0+C' '          Blank
         DC    YL1(0)              is whitespace
         ORG   STBL0+C','          Comma
         DC    YL1(0)              is whitespace
         ORG   STBL0+X'05'         Tab
         DC    YL1(0)              is whitespace
         ORG   STBL0+C'('          Left parenthesis
         DC    YL1(8)              is special
         ORG   STBL0+C')'          Right parenthesis
         DC    YL1(12)             is special
         ORG   STBL0+C'/'          Slash
         DC    YL1(16)             might be part of /*
         ORG   STBL0+C''''         Quote
         DC    YL1(20)             is special
         ORG   ,
         SPACE 1
STBLWORD DC    256YL1(0)           Table to scan for end of word
         ORG   STBLWORD+C' '       Blank
         DC    YL1(4)              is whitespace
         ORG   STBLWORD+C','       Comma
         DC    YL1(4)              is whitespace
         ORG   STBLWORD+X'05'      Tab
         DC    YL1(4)              is whitespace
         ORG   STBLWORD+C'('       Left parenthesis
         DC    YL1(8)              is special
         ORG   STBLWORD+C')'       Right parenthesis
         DC    YL1(12)             is special
         ORG   STBLWORD+C'/'       Slash
         DC    YL1(16)             might be part of /*
         ORG   ,
         SPACE 1
STBLCOMM DC    256YL1(0)           Table to scan for "*/"
         ORG   STBLCOMM+C'*'
         DC    1YL1(1)
         ORG   ,
         SPACE 1
STBLQUOT DC    256YL1(0)           Table to scan for "'"
         ORG   STBLQUOT+C''''
         DC    1YL1(1)
         ORG   ,
VERTBL   DC    256YL1(1)           Table to verify parameter syntax
         ORG   VERTBL+C'_'         Underscore is valid (?)
         DC    YL1(0)               valid?
         ORG   VERTBL+C'@'         National character is valid (?)
         DC    YL1(0)
         ORG   VERTBL+C'#'         National character is valid (?)
         DC    YL1(0)
         ORG   VERTBL+C'$'         National character is valid (?)
         DC    YL1(0)
         ORG   VERTBL+C'a'         Lower case alphabetics are valid
         DC    9YL1(0)
         ORG   VERTBL+C'j'
         DC    9YL1(0)
         ORG   VERTBL+C's'
         DC    8YL1(0)
         ORG   VERTBL+C'A'         Upper case alphabetics are valid
         DC    9YL1(0)
         ORG   VERTBL+C'J'
         DC    9YL1(0)
         ORG   VERTBL+C'S'
         DC    8YL1(0)
         ORG   VERTBL+C'0'         Numerics are valid (except 1st pos)
         DC    10YL1(0)
         ORG   ,
UPTBL    DC    256YL1(*-UPTBL)     Table to translate to uppercase
         ORG   UPTBL+C'a'
         DC    C'ABCDEFGHI'
         ORG   UPTBL+C'j'
         DC    C'JKLMNOPQR'
         ORG   UPTBL+C's'
         DC    C'STUVWXYZ'
         ORG   ,
         EJECT
PUTLINE  DS    0H
*
***********************************************************************
*                                                                     *
* This routine displays messages to the TSO user using the TSO        *
* PUTLINE service routine.  At entry R1 contains the address of the   *
* message to be displayed, and R0 contains the length of the message. *
* R3 points to additional data to be displayed, and R2 is its length. *
* If R1 is zero, the message has already been built in the workarea   *
* MSGWA.  The message is assumed to begin with a message ID unless    *
* the first character is blank, in which case the initial blank is    *
* stripped off by PUTLINE anyhow.                                     *
*                                                                     *
***********************************************************************
*
         ST    R14,PUTL14          Save return register
         LTR   R15,R0              Load length value
         BNP   PUTLRET             If zero, don't do anything
         BCTR  R15,0               Else reduce length for execute
         LTR   R1,R1               If R1 is zero,
         BZ    PUTIT               then message already set up.
         EX    R15,MVCPUT          Else move message to work area
         LTR   R2,R2               If additional data,
         BZ    PUTIT               then
         LA    R1,MSGWA+1(R15)      Point to end of message
         CH    R2,=H'256'           (Use max length of 256)
         BNH   *+8
         LA    R2,256
         BCTR  R2,0                 Reduce data length for execute
         EX    R2,MVCPUT2           Move additional data to work area
         LA    R15,1(R15,R2)        Add length of data to msg length
PUTIT    DS    0H
         LA    R15,5(,R15)         Restore length + 4 for header
         SLL   R15,16              Shift length into left half of hdr
         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr
PUTLINE_RETRY DS 0H
         XC    ECB,ECB             Clear ECB
         PUTLINE PARM=PTLIST,                                          X
               MF=(E,IOPL),                                            X
               OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15             If PUTLINE OK
         BZ    PUTLRET             then return
         CH    R15,=H'8'           Else if attention interrupt
         BE    PUTLRET             then OK
         CH    R15,=H'12'          Else if pending 2nd level message
         BE    PUTL12              then OK
PUTERROR DS    0H                  Else PUTLINE error
         CVD   R15,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         MVC   MSGWA+1(L'MSG_PUTLINE_FAILURE1),MSG_PUTLINE_FAILURE1
         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1(2),DOUBLE
         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1+2(L'MSG_PUTLINE_FAILURE2)X
               ,MSG_PUTLINE_FAILURE2
         TPUT  MSGWA+1,L'MSG_PUTLINE_FAILURE1+2+L'MSG_PUTLINE_FAILURE2
         LA    R1,MSGWA
         LH    R0,MSGHDR
         SH    R0,=H'4'
         TPUT  (1),(0),R           Try to display original message
PUTLRET  L     R14,PUTL14          Restore return register
         BR    R14                 Return
*
PUTL12   DS    0H                  Try putting out pending 2nd level ms
         XC    ECB,ECB             Clear ecb
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)
         B     PUTLINE_RETRY
*
MVCPUT   MVC   MSGWA(*-*),0(R1)    Executed
MVCPUT2  MVC   0(*-*,R1),0(R3)     Executed
         EJECT
MFLUSH   STACK MF=L,DELETE=ALL
LENFLUSH EQU   *-MFLUSH
*
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
*
         EJECT
         LTORG
         EJECT
***********************************************************************
* Messages                                                            *
***********************************************************************
         SPACE 1
MSG_NO_OPERANDS    DC C'XPROC001 No operands specified.'
MSG_REXX_REQUIRED  DC C'XPROC002 Not in REXX: input variable required.'
MSG_NO_POS_COUNT   DC C'XPROC003 Missing positional parameter count.'
MSG_BAD_POS_COUNT  DC C'XPROC004 Invalid positional parameter count: '
MSG_QUOTE_ERROR    DC C'XPROC005 Missing end quote.'
MSG_NO_WANT_LP     DC C'XPROC006 "(" found where not expected.'
MSG_NO_WANT_RP     DC C'XPROC007 ")" found where not expected.'
MSG_NO_WANT_QS     DC C'XPROC008 Quoted string in invalid position.'
MSG_TOO_FEW_PPARMS DC C'XPROC009 Fewer positional parms than expected.'
MSG_PP_WITH_LP     DC C'XPROC010 Value not allowed on positional: '
MSG_PARM_TOO_LONG  DC C'XPROC011 Parameter name too long (> 255): '
MSG_PARM_INVALID   DC C'XPROC012 Invalid syntax in parameter name: '
MSG_PARM_DUPLICATE DC C'XPROC013 Duplicate parameter name: '
MSG_EXTRANEOUS     DC C'XPROC014 Extraneous data ignored in value: '
MSG_VAR_TOO_LONG   DC C'XPROC015 Variable name too long (> 256): '
MSG_GETTING_VAR    DC C'XPROC016 Error accessing value of variable: '
MSG_PUTTING_VAR    DC C'XPROC017 Error storing value of variable: '
MSG_IKJCT441_RC    DC C'XPROC018 IKJCT441 return code is: '
MSG_PARSE_FAILURE  DC C'XPROC019 PARSE service routine failure, code: '
MSG_GETMAIN_FAIL   DC C'XPROC020 Not enough main storage to execute.'
MSG_IRXEXCOM_FAIL  DC C'XPROC021 IRXEXCOM failure, error code: '
MSG_STACK_ERROR    DC C'XPROC022 STACK service routine failure, code: '
MSG_NO_WANT_SL     DC C'XPROC023 "/" found where not expected.'
MSG_OPT_TOO_LONG   DC C'XPROC024 Option name too long: '
MSG_OPT_INVALID    DC C'XPROC025 Invalid option name: '
MSG_ASIS_NEEDS_VAL DC C'XPROC026 ASIS invalid with valueless keyword: '
MSG_OPT_POS_ONLY   DC C'XPROC027 Option valid only for positional: '
*
MSG_KV_ERROR       DC C'XPROC999 Internal error in keyword value scan.'
*
MSG_PUTLINE_FAILURE1 DC C'*** XPROC: PUTLINE error code '
MSG_PUTLINE_FAILURE2 DC C' trying to issue the following message:'
*
ISMSG    DC    C'*** XPROC ignoring slash after this parameter: ' dummy
         SPACE 1
         EJECT
***********************************************************************
* Constants                                                           *
***********************************************************************
         SPACE 1
KEYDINCR DC    A(100*KEYDDATL)     Initial & increment key area length
         SPACE 1
NUMTBL   DC    256YL1(1)           Table to validate numerics
         ORG   NUMTBL+C'0'
         DC    10YL1(0)
         ORG   ,
         EJECT
MSG_IKJCT441_RC08 DC C'XPROC508 Variable is a CLIST built-in function.'
MSG_IKJCT441_RC12 DC C'XPROC512 Variable is a CLIST label.'
MSG_IKJCT441_RC16 DC C'XPROC516 CLIST variable cannot be updated.'
MSG_IKJCT441_RC24 DC C'XPROC524 Variable is a CLIST subprocedure.'
MSG_IKJCT441_RC32 DC C'XPROC532 GETMAIN or FREEMAIN storage failure.'
MSG_IKJCT441_RC36 DC C'XPROC536 Variable name or value too long.'
MSG_IKJCT441_RC40 DC C'XPROC540 No valid CLIST or REXX environment.'
MSG_IKJCT441_RC76 DC C'XPROC576 Undefined &&SYSX CLIST variable.'
MSG_IKJCT441_RC80 DC C'XPROC580 Variable name invalid for REXX.'
MSG_IKJCT441_RC81 DC C'XPROC581 Internal REXX routine failure.'
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
         SPACE 1
SAVEAREA DS    18F                 OS save area
SAVE2    DS    18F                 Save area for PARSE exit routines
DOUBLE   DS    D                   Conversion work area
DATDLEN  DS    F                   Length of this work area
PUTL14   DS    F                   Return register save
E44114   DS    F                   Return register save
DOOPT14  DS    F                   Return register save
SAVER2   DS    A                   Save for TRT register
MYBASES  DS    2A                  Base regs for IKJPARS exit routines
SCANRES  DS    2A                  Used to save output from SCAN
WORDPTR  DS    A                   Address of next slot for word copy
PWADDR   DS    A                   Address of IKJPARS PCL area
PWLEN    DS    F                   Length of IKJPARS PCL area
PCLLEN   DS    F                   Actual length of the IKJPARS PCL
QOFF     DS    A                   Address of quoted-value-string area
QVALLEN  DS    F                   Length of quoted-value-string area
VUPADDR  DS    F                   Address of IKJCT441 update parm list
VUPLEN   DS    F                   Length of IKJCT441 update parm list
PDLLEN   DS    F                   Length of the IKJPARS PDL
VBUFADDR DS    A                   Address of fake command buffer
VBUFLEN  DS    A                   Length of fake command buffer
ARGADDR  DS    A                   Address of ARG buffer
ARGLEN   DS    F                   Length of ARG buffer
SCANPTR  DS    A                   Scanning pointer
SCANEPTR DS    A                   Scanning end pointer
PARCOUNT DS    F                   Parenthesis count
PVARADDR DS    A                   Address of input variable name
PVARLEN  DS    F                   Length of input variable name
POSCOUNT DS    F                   Positional parameter count
KEYCOUNT DS    F                   Keyword count
LASTAREA DS    A                   Address of last pos or key area
LASTADDR DS    A                   Address of last processed thing
LASTLEN  DS    F                   Length of last processed thing
APOSD    DS    A                   Address of positional parm area
LPOSD    DS    A                   Length of positional parm area
AKEYD    DS    A                   Address of keyword/value area
LKEYD    DS    A                   Length of keyword/value area
AKEYE    DS    A                   Address of end of keyword/value area
FIRSTKEY DS    A                   Address of first IKJKEYWD PCE
SUBTOSET DS    A                   Address of previous IKJSUBF PCE
FLAGS    DS    X                   Flags
FLAGPUTE EQU   B'10000000'         1 = error putting variable values
FLAGPOSD EQU   B'01000000'         1 = currently processing positionals
FLAGKEYD EQU   B'00100000'         1 = currently processing keywords
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
*
ECB      DS    F                   ECB for TSO routines
*
OLD      DS    0F                  PUTLINE output line descriptor
OLDF1    DS    F'1'                Number of message segments
OLDMSG   DS    A(*-*)              Address of the first message segment
*
MSGHDR   DS    F                   PUTLINE message header
MSGWA    DS    CL512               PUTLINE message work area
ARGWA    DS    CL512               ARG message work area
*
FLUSH    STACK MF=L,DELETE=ALL
*
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
*
CPPL     DS    0A
***********************************************************************
*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *
*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *
***********************************************************************
*
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
*
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
*
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
*
PPL      DS    0A
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
PPLVEWA  DS    A        PTR TO USER WORK AREA FOR VERIFY EXITS
*
ANSWER   DS    F                   ANSWER AREA FOR PARSE
         SPACE 1
CVPARMS  DS    0F                  Variable access facility parm list
CVPARM1  DS    A                   Parameter 1: entry code
CVPARM2  DS    A                   Parameter 2: address of var name
CVPARM3  DS    A                   Parameter 3: length of var name
CVPARM4  DS    A                   Parameter 4: address of var value
CVPARM5  DS    A                   Parameter 5: length of var value
CVPARM6  DS    A                   Parameter 6: token (not used)
*
CVENTRY  DS    A                   Entry code
CVNAMEA  DS    A                   Address of variable name
CVNAMEL  DS    A                   Length of variable name
CVVALUEA DS    A                   Address of variable value
CVVALUEL DS    A                   Length of variable value
CVTOKEN  DS    A                   Token (not used)
CVECT    DS    A                   ECT (not used)
*
RC441    DS    F                   Return code from IKJCT441
         SPACE 1
         SPACE 1
IRPARMS  DS    0F                  IRXEXCOM parameter list
IRPARM1  DS    A                   Parameter 1: CL8'IRXEXCOM'
IRPARM2  DS    A                   Parameter 2: same as parameter 3
IRPARM3  DS    A                   Parameter 3: same as parameter 2
IRPARM4  DS    A                   Parameter 4: SHVBLOCK
*
***********************************************************************
*                                                                     *
* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *
*                                                                     *
***********************************************************************
*
SHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK
SHVNEXT  DS  A                        Chain pointer to next SHVBLOCK
SHVUSER  DS  F                        Used during "FETCH NEXT"
*                                      Contains length of buffer
*                                      pointed to by SHVNAMA
SHVCODES DS  0F
SHVCODE  DS  CL1                      Function code - indicates type
*                                      of variable access request
SHVRET   DS  XL1                      Return codes
         DS  H'0'                     Reserved (should be 0)
SHVBUFL  DS  F                        Length of fetch value buffer
SHVNAMA  DS  A                        Address of variable name
SHVNAML  DS  F                        Length of variable name
SHVVALA  DS  A                        Address of value buffer
SHVVALL  DS  F                        Length of value buffer
*                                      (Set on fetch)
SHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK
         SPACE 1
**********************************************************************/
*   SHARED VARIABLE REQUEST BLOCK - function codes                   */
**********************************************************************/
         SPACE 1
SHVFETCH EQU   C'F'            Copy value of shared variable
SHVSTORE EQU   C'S'            Set variable from given value
SHVDROPV EQU   C'D'            Drop variable
SHVSYFET EQU   C'f'            Symbolic name retrieve
SHVSYSET EQU   C's'            Symbolic name set
SHVSYDRO EQU   C'd'            Symbolic name drop
SHVNEXTV EQU   C'N'            Fetch "next" variable
SHVPRIV  EQU   C'P'            Fetch private information
         SPACE 1
**********************************************************************/
*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */
**********************************************************************/
        SPACE 1
SHVCLEAN EQU   X'00'           Execution was OK
SHVNEWV  EQU   X'01'           Variable did not exist
SHVLVAR  EQU   X'02'           Last variable transferred ("N")
SHVTRUNC EQU   X'04'           Truncation occurred for "Fetch"
SHVBADN  EQU   X'08'           Invalid variable name
SHVBADV  EQU   X'10'           Invalid value specified
SHVBADF  EQU   X'80'           Invalid function code (SHVCODE)
         SPACE 1
**********************************************************************/
*        R15 return codes                                            */
**********************************************************************/
         SPACE 1
SHVRCOK  EQU    0              Entire Plist chain processed
SHVRCINV EQU   -1              Invalid entry conditions
SHVRCIST EQU   -2              Insufficient storage available
         SPACE
*
PVAR     DS    CL256               Area to build input variable name
OPTION   DS    CL16                Area to build option name
         SPACE 1
SIZDATD  EQU   *-DATD              Length of fixed part of work area
         SPACE 1
WORDCOPY EQU   *                   Area to put copies of keyword names
         EJECT
POSDDATA DSECT ,                   Info on positional parameter specs
         SPACE 1
*                                  (POSCOUNT) occurrences of...
*
POSDADDR DS    A                   Address of positional parameter name
POSDLEN  DS    A                   Length of positional parameter name
POSDPCEA DS    A                   Address of PCE for this parameter
POSDPCEL DS    A                   Length of PCE for this parameter
POSDMAXL DS    A                   Maximum length for prompting message
POSDFLGS DS    X                   Flags
POSDOPT  EQU   B'10000000'          1 = parameter is optional
POSDCHAR EQU   B'01000000'          1 = value is possibly-quoted string
POSDASIS EQU   B'00100000'          1 = value is to be processed asis
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
         DS    0D                  Round to doubleword length
         SPACE 1
POSDDATL EQU   *-POSDDATA          Length of an occurrence
         EJECT
KEYDDATA DSECT ,                   Info on keyword/value specs
         SPACE 1
*                                  some # of occurrences of...
*
KEYWORDA DS    A                   Address of keyword
KEYWORDL DS    A                   Length of keyword
KEYDVALA DS    A                   Address of keyword's default value
KEYDVALL DS    A                   Length of keyword's default value
KEYDPCEA DS    A                   Address of PCE for this parameter
KEYDPCEL DS    A                   Length of PCE for this parameter
KEYDMAXL DS    A                   Maximum length for prompting message
KEYSUBOF DS    A                   Where to store subfield offset
KEYFLAGS DS    X                   Flags
KEYFDVAL EQU   B'10000000'          1 = a default value was specified
KEYFQUOT EQU   B'01000000'          1 = default value is quoted string
KEYFASIS EQU   B'00100000'          1 = value is to be processed asis
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
         DS    0D                  Round to doubleword length
         SPACE 1
KEYDDATL EQU   *-KEYDDATA          Length of an occurrence
         EJECT
***********************************************************************
* Macro expansions                                                    *
***********************************************************************
         SPACE 1
         IKJTSVT
         SPACE 1
         CVT   DSECT=YES
         END
