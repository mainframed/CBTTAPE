   TITLE 'VTT2DISK -- READ A REAL TAPE AND CREATE FB-80 AWS FILE'
**************************************************************
**************************************************************
**                                                          **
**                                                          **
**  MODULE:  VTT2DISK.   Written by Sam Golob               **
**                                                          **
**       Copyright (c) 2001-2005 by Sam Golob               **
**                                                          **
**       A component of the:                                **
**       Virtual Tape Transportation System (VTTS)          **
**                                                          **
**  PURPOSE:  Program to read in a tape, and create an      **
**            MVS disk file in "folded FB-80 AWS format".   **
**                                                          **
**     The output of this program is intended to be input   **
**     for the VTT2TAPE program.  These two programs,       **
**     VTT2DISK and VTT2TAPE, are designed to work          **
**     together, as paired and opposite programs.           **
**                                                          **
**  OBSERVATION:  Although this program is purely an MVS    **
**                program, the AWS-format output of this    **
**     program can be downloaded to other systems where     **
**     the file can actually be interpreted as an emulated  **
**     tape.  This is one way of transferring tape data to  **
**     other MVS systems that can read AWS-format tape      **
**     files directly, as though they were tapes.           **
**                                                          **
**     For example, you can take mainframe-based tapes      **
**     on real cartridges and create AWS-format tape        **
**     files that can be read on a FLEX-ES system, a P/390  **
**     or a Hercules-based MVS system.                      **
**                                                          **
**     Arbitrary chunk sizes for the AWS-format tape files  **
**     are now supported.  If you are reading the output    **
**     file on a Hercules-based system, you should          **
**     rename its file name as *.het , because the HET      **
**     emulator on Hercules recognizes chunked blocks.      **
**                                                          **
**  METHOD:                                                 **
**                                                          **
**     Tape data is read into a data buffer in this         **
**     program.  Each block is read in, and its size        **
**     is determined.  This size is compared to the         **
**     chunk size, and a decision is made as to what        **
**     to do.  An AWS header is made for each chunk.        **
**     Each AWS header is folded into FB-80 output,         **
**     and then the data is folded in afterward, until      **
**     the block, and its associated AWS headers, are       **
**     all folded in.  Then another tape block is read      **
**     into the buffer, and the process repeats.            **
**                                                          **
**     When the tape file ends, and a tape mark is read     **
**     in, an X'40' format AWS header is constructed.       **
**     It is then folded into the FB-80 output dataset,     **
**     after the last data.                                 **
**                                                          **
**     At the end of the tape, an end-of-tape AWS           **
**     header is appended to the end of the output          **
**     file and folded in.  The last FB-80 record           **
**     is completed with hex zeros, if necessary.           **
**                                                          **
**     As a controversial measure, a full 80-byte record    **
**     of hexzeros is appended at the end of the file.      **
**                                                          **
**     All of the "FB-80 folding" work is now done by the   **
**     sub-program called FOLDEM.  The FOLDEM program       **
**     operation is completely controlled by a control      **
**     block called the FLDAREA control block, which does   **
**     all of the communication between the main program    **
**     and the FOLDEM sub-program.  Therefore, monitoring   **
**     of the folding process is now possible purely by     **
**     displaying the current status of the FLDAREA         **
**     fields.  A convenient routine for displaying the     **
**     status of the FLDAREA fields is the FLDIMAGE         **
**     routine in either program, which is invoked by:      **
**                                                          **
**     BAL   R9,FLDIMAGE                                    **
**                                                          **
**     Therefore the fold monitoring displays that used     **
**     to be in the SYSMOVED DD name, are now obsolete.     **
**                                                          **
**     There are two more fields in the FLDAREA control     **
**     block than in the UNFAREA control block of the       **
**     UNFOLDEM sub-program that VTT2TAPE uses.  These      **
**     are:                                                 **
**                                                          **
**           FLDBYTOT - bytes left in buffer after the      **
**                      last chunk of data was folded       **
**           FLDREADF - propagation of the "read only"      **
**                      flag into the sub-program           **
**                                                          **
**     These extra fields are obviously not required by     **
**     the unfolding process.  The first one is not         **
**     required because you're doing "unchunking" instead   **
**     of "chunking", and you read the existing chunks      **
**     as they come in; you're not required to create       **
**     them.  The second one is not required because the    **
**     main program writes the output (a tape) instead of   **
**     the sub-program writing the output (an FB-80 file).  **
**     So in our case, if no output is to be written, the   **
**     sub-program must know about it.                      **
**                                                          **
**  OPTIONAL DDNAMES:                                       **
**                                                          **
**     In order to make sure that the VTT2DISK program      **
**     is doing its job properly, it produces a lot of      **
**     trace data and status data, as it is creating        **
**     the folded FB-80 AWS format tape.  In order not      **
**     to clutter the summary report, most of this          **
**     data is written to "Optional DDNAMEs".  Starting     **
**     with version 1.12 of this program, most of the       **
**     trace data now consists of the state of the FLDAREA  **
**     control block fields at various stages of program    **
**     execution.                                           **
**                                                          **
**     If you have access to the source code (you are       **
**     reading it), you can introduce an instruction:       **
**                                                          **
**           BAL   R9,FLDIMAGE                              **
**                                                          **
**     at any point in the program, as long as SYSPRINT     **
**     is open.  This should produce any diagnostics you    **
**     may need, because all FLDAREA fields are displayed.  **
**                                                          **
**     Optional DDNAMEs don't have to be coded in the       **
**     JCL.  But if they are coded, they will contain       **
**     the extra trace data which VTT2DISK produces,        **
**     and the SYSFILES ddname will contain a detailed      **
**     "file by file" report.                               **
**                                                          **
**     The SYSFILES report is very useful if you want       **
**     to do a "dry run", with the READ parameter.  If      **
**     you want to know the structure of a tape without     **
**     creating the FB-80 output file, the SYSFILES         **
**     report will tell you what files are on the tape.     **
**     It will also give you an indication of how big an    **
**     FB-80 output file you will need on an MVS disk,      **
**     to contain all the tape data.  See below for         **
**     details.                                             **
**                                                          **
**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **
**     and SYSIN.  SYSMOVED is now obsolete, although       **
**     it will produce a dummy report if it is present      **
**     in the JCL.                                          **
**                                                          **
**     SYSIN data is necessary if optional parameters       **
**     are to be entered, such as:                          **
**                                                          **
**     CHUNKSIZE=nnnn                                       **
**     NEWVOL=volser                                        **
**     READ                                                 **
**     IDRCOFF                                              **
**                                                          **
**     SYSIN keywords have to start in column 1.            **
**                                                          **
**     Either READ or IDRCOFF can also be entered in the    **
**     PARM field of the EXEC card in the JCL.              **
**                                                          **
**     Full JCL to run the VTT2DISK program is as           **
**     follows:                                             **
**                                                          **
**     //   jobcard                                         **
**     //AWSREAD  EXEC PGM=VTT2DISK                         **
**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **
**     //*AWSOUT   DD  DSN=fb80.folded.aws.file,DISP=SHR    **
**     //*        .... if the file is preallocated ....     **
**     //AWSOUT    DD  DSN=fb80.folded.aws.file,            **
**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **
**     //          VOL=SER=volxxx,                          **
**     //          SPACE=(CYL,(mm,nn),RLSE)                 **
**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **
**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **
**     //          LABEL=(1,BLP,EXPDT=98000)                **
**     //SYSPRINT  DD  SYSOUT=*                             **
**     //SYSFILES  DD  SYSOUT=*                             **
**     //SYSTRACE  DD  SYSOUT=*                             **
**     //SYSUDUMP  DD  SYSOUT=*                             **
**     //SYSIN     DD  *                                    **
**     keywords in column 1                                 **
**     /*                                                   **
**                                                          **
**     where you can leave out SYSTRACE and SYSUDUMP        **
**     if you want to.  I'd strongly suggest including      **
**     (at least) SYSFILES, though.                         **
**                                                          **
**     SYSTRACE takes a picture of the tape buffer at       **
**     READ time, and takes a picture of the AWS headers    **
**     and the FLDAREA control block fields at the time     **
**     the headers are made.  Since the folding is now      **
**     done by the FOLDEM subprogram, SYSMOVED, which       **
**     used to track the data folding process, is now       **
**     not necessary.  Of course SYSUDUMP is there to       **
**     contain the MVS-produced dump, upon any abnormal     **
**     termination of the program.                          **
**                                                          **
**     SYSFILES gives you block counts and byte counts      **
**     for all files read and written.                      **
**                                                          **
**     In the SYSPRINT report, there is a count of total    **
**     number of 80-byte records which the program will     **
**     (or has) put out.  If you are doing a READ only      **
**     run, and want to allocate an output file which is    **
**     the right size, you might use this number, together  **
**     with the BLKnnnn command from File 296 of the CBT    **
**     Tape, to produce the following result:               **
**                                                          **
**     Say, our program produces:                           **
**                                                          **
**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **
**                                                          **
**     And you want to allocate space on a 3390.  So you    **
**     would say:                                           **
**                                                          **
**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **
**                                                          **
**     Which comes up with the result:                      **
**                                                          **
** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **
**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **
**                                                          **
**  CHANGE LOG:                                             **
**                                                          **
**    Version 1.1 - Make sure program works properly        **
**       folding the data from the input buffer into FB-80. **
**                                                          **
**    Version 1.2 - Level number in the report headings.    **
**                                                          **
**    Version 1.3 - Not stopped by null SL tape file.       **
**                                                          **
**    Version 1.4 - Byte count and cum byte count report    **
**       in SYSFILES.  Differentiate between label bytes    **
**       and data bytes in the reports.                     **
**                                                          **
**    Version 1.5 - Block counts for each file and for the  **
**       entire tape.                                       **
**                                                          **
**    Version 1.6 - Fix a reporting problem with block      **
**       counting.                                          **
**                                                          **
**    Version 1.7 - Allow PARM=READ, just to get stats.     **
**                                                          **
**    Version 1.8 - Make file-level stats reporting into    **
**       a subroutine.  Fix a bug in cumulative data byte   **
**       reporting.                                         **
**                                                          **
**    Version 1.9 - End program if error on input tape.     **
**       If input tape is AWS with bad headers, break the   **
**       loop upon thinking you have an infinite number of  **
**       tape marks on input.                               **
**                                                          **
**    Version 1.9A - Accommodate 4 character version level. **
**       Add extra line of ASCII blanks (X'20') to the      **
**       output, to make Hercules happy, and to detect      **
**       end-of-tape more easily.                           **
**                                                          **
**    Version 1.10 - PARM of IDRCOFF will turn off IDRC     **
**       indicators in the VOL1, HDR2, EOF2, EOV2 labels.   **
**                                                          **
**    Version 1.11 - Last line has hexzeros instead of      **
**       hex 20 as fillers.  It makes Hercules happier.     **
**                                                          **
**    Version 1.12 - Re-architected program to use FOLDEM   **
**       sub-program for data moves.  The FOLDEM program    **
**       is driven by the FLDAREA control block, so the     **
**       trace data consists mostly of the state of the     **
**       FLDAREA control block fields.  A routine called    **
**       FLDIMAGE will print all the FLDAREA control block  **
**       fields on a single SYSPRINT line.                  **
**                                                          **
**       Added the possibility of coding program options    **
**       in the SYSIN DD, which is used if it is present    **
**       in the JCL.  SYSIN keywords, which must be coded   **
**       to start in column 1, are currently:               **
**                                                          **
**       CHUNKSIZE=nnnn                                     **
**       NEWVOL=volser                                      **
**       READ                                               **
**       IDRCOFF                                            **
**                                                          **
**       Added CHUNKSIZE=nnnn SYSIN keyword to allow the    **
**       creation of "chunked AWS tape files by this        **
**       program.  The AWS tape file architecture allows    **
**       for unlimited tape block sizes, if the blocks      **
**       are broken into "chunks" of 65535 bytes or less,   **
**       separated by AWS headers.  IBM's original AWS      **
**       tape standard used to require a maximum chunk      **
**       size of only 4096 bytes.  In this program, 65535   **
**       bytes is the default chunk size, but this value    **
**       can be adjusted at assembly time by setting a      **
**       global variable.                                   **
**                                                          **
**       The NEWVOL=volser keyword in SYSIN, allows you     **
**       to change the volser in the VOL1 label of the      **
**       output AWS-format tape file.                       **
**                                                          **
**       Now, the READ and IDRCOFF keywords of the EXEC     **
**       PARM field, can also be coded in SYSIN.  They      **
**       must begin in column 1.  READ allows a dry run     **
**       of the program which reads the input tape and      **
**       reports statistics, but which does not produce     **
**       an output FB-80 AWS file.                          **
**                                                          **
**       IDRCOFF looks in the tape standard labels, if      **
**       there are any, and turns off any "P" indicators    **
**       which tell MVS that this tape was produced on      **
**       an IDRC-enabled tape drive.  Since the output      **
**       FB-80 file is not compressed anyway, one wants     **
**       the power to read the AWS-format tape file on a    **
**       logical 3420 or 3480 tape drive, without MVS       **
**       telling you that "the tape has compressed files    **
**       and I can't read it" on this particular drive.     **
**                                                          **
**                                                          **
**************************************************************
         EJECT
**************************************************************
         MACRO
*  ---------------------------------------------------------------  *
*    This macro is used to display hex values in a printed report.  *
*  ---------------------------------------------------------------  *
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         ST    R4,SAVER4B
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER4B
         LM    15,1,HEXSAVE
         MEND
         SPACE
**************************************************************
         GBLC  &LLEV
         GBLC  &DEFCHKC
         GBLA  &DEFCHNK
&LLEV    SETC  '1.12'
* ------------------------------------------------------------------ *
*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *
*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *
* ------------------------------------------------------------------ *
&DEFCHNK SETA  65535
&DEFCHKC SETC  '&DEFCHNK'
         YREGS
         EJECT
** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **
VTT2DISK CSECT
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
VTT2DISK AMODE 24
VTT2DISK RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'VTT2DISK - REAL TAPE TO FOLDED FB-80 AWS DISK FILE - '
         DC    C'LEVEL '
SYSLEV   DC    C'&LLEV'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME ',C'--- '
         DC    C'Copyright (c) 2001-2005 by Sam Golob '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         SAVE  (14,12)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING VTT2DISK,R12,R11,R10,R8,R7
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LA    R8,4095(,R10)
         LA    R8,1(,R8)
         LA    R7,4095(,R8)
         LA    R7,1(,R7)
         LR    R1,R5                 RESTORE PARM POINTER
*
* ----- >                            Parms          <--- below
         L     R1,0(R1)              Get PARM field
         CLC   =C'READ',2(R1)        Is it "READ" only?
         BE    COPYREAD              Yes. Turn on indicator.
         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?
         BE    COPYIDRF              Yes. Say that.
         B     COPYTAPE              No. Just go on with processing.
COPYREAD DS    0H                    READ only?
         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.
         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.
         B     COPYTAPE
COPYIDRF DS    0H                    IDRC indicators off?
         OI    IDRCFLAG,X'01'        Yes. Turn on flag.
         B     COPYTAPE
*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.
COPYTAPE DS    0H
* ----- >                            Parms          <--- above
*
***********************************************************************
* GET SYSTEM DATE AND TIME - A standard way to get date and time      *
***********************************************************************
         STM   R14,R2,SAVE1402
         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY
         OI    DATE+4,X'0F'
         UNPK  DATED,DATE
         OI    TIME+3,X'0F'
         UNPK  TIMED,TIME
*                          FILL HEADDATE AREA WITH INFO TO REUSE
         MVC   HEADDATE(2),DATED
         MVI   HEADDATE+2,C'/'
         MVC   HEADDATE+3(2),DATED+2
         MVI   HEADDATE+5,C'/'
         MVC   HEADDATE+6(4),DATED+4
         MVC   HEADDATE+12(2),TIMED
         MVI   HEADDATE+14,C':'
         MVC   HEADDATE+15(2),TIMED+2
         MVI   HEADDATE+17,C':'
         MVC   HEADDATE+18(2),TIMED+4
         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time
         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.
         MVC   MESSAGE3+88(31),HEADDLIT
         MVC   MESSAGE4+88(31),HEADDLIT
         LM    R14,R2,SAVE1402
***********************************************************************
         MVC   LEVDATE(8),SYSDAT
***********************************************************************
         MVC   MESSAGE1+61(21),LEVELLIT    Program level and
         MVC   MESSAGE2+61(21),LEVELLIT      assembly date
         MVC   MESSAGE3+61(21),LEVELLIT
         MVC   MESSAGE4+61(21),LEVELLIT
***********************************************************************
* ----------------------------------------------------------------- *
INITEM   DS    0H                    Initialize some constants
         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.
         MVC   FULLHIGH(2),=X'0000'
         MVC   CURRBYTE(2),=X'0000'
         MVC   LASTBYTE(2),=X'0000'
         MVC   HDRSIZE(4),=F'6'      Set size of header globally.
         MVC   FLDOFFST(4),=F'0'     Offset is initially zero
         LA    R1,OUTCARD            Let FOLDEM know about AWSOUT area
         ST    R1,FLDSCARD           Beginning of card image output
         ST    R1,SVBEGCRD
         LA    R1,80(,R1)            Find end of card
         ST    R1,FLDECARD           And store it away for the duration
         ST    R1,SVENDCRD
         L     R1,=A(INAREA)         Get address of input buffer
         ST    R1,SVBFAREA           And save it away.
         ST    R1,FLDBUFFR           Prime these fields
         ST    R1,FLDBSTRT
         L     R0,=F'&DEFCHNK'       Set default chunk size.
         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.
         ZAP   FLDOUTCT,=P'0'        Zero count of AWSOUT records.
* ----------------------------------------------------------------- *
TIOTSCAN DS    0H             Determine the presence of Optional
*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES
* ----->                      and open them if there is JCL for them.
* ----------------------------------------------------------------- *
         L     R5,16          R5=CVT
         L     R5,0(,R5)      R5=TCB WORDS
         L     R5,4(,R5)      R5=MY TCB
         L     R5,12(,R5)     R5=TIOT
         LA    R5,24(,R5)     R5=FIRST DD ENTRY
TIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?
         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES
         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?
         BNE   TIOTMOVD       NO
         OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD
         B     TIOTNEXT       CONTINUE
TIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?
         BNE   TIOTFILE
         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD
         B     TIOTNEXT
TIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?
         BNE   TIOTSYSN
         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD
         B     TIOTNEXT
TIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?
         BNE   TIOTNEXT
         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD
         B     TIOTNEXT
TIOTNEXT SR    R3,R3
         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY
         AR    R5,R3          R5=NEXT DD ENTRY
         B     TIOTLOOP       GO CHECK IT
TIOTSEND DS    0H
* ----------------------------------------------------------------- *
* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *
* ----------------------------------------------------------------- *
*
         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.
*
* ----------------------------------------------------------------- *
***********************************************************************
*    Now OPEN the files and start the processing.
***********************************************************************
* - - - ->  Chunk Size Message - - - ->   below
*    The purpose of this code is to fill MESSAG14 with information.
         L     R1,CHNKSIZE                  Load binary Chunk Size
         XC    DWORD,DWORD                  Clear DWORD to zeros.
         CVD   R1,DWORD                     Convert to decimal.
         OI    DWORD+7,X'0F'                Make sign readable.
         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message
         ED    MESSAG14+28(8),DWORD+4       Edit the number
         B     AFCHKDSP                     Branch past constant
CHPATTRN DC    X'4020202020202120'          8 bytes of pattern
AFCHKDSP DS    0H
* - - - ->  Chunk Size Message - - - ->   above
         TM    READFLAG,X'01'        Read Only run?
         BO    NOAWSOUT              Yes. Don't OPEN AWSOUT.
         OPEN  (AWSOUT,(OUTPUT))
NOAWSOUT DS    0H
         OPEN  (SYSPRINT,(OUTPUT))
         OPEN  (TAPIN,(INPUT))
*--->>
         MVC   MSGLINE1,MSGLINE1-1   Clear optional
         MVC   MSGLINE2,MSGLINE2-1      message lines
READIDRC DS    0H
         TM    READFLAG,X'01'        READ only run?
         BZ    IDRCMSG
READMSG  DS    0H
         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'
IDRCMSG  DS    0H
         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?
         BZ    ENDEXMSG
         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'
ENDEXMSG DS    0H
*--->>
TRACERPT DS    0H
         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?
         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSTRACE,(OUTPUT))
         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE      Blank Line
         PUT   SYSTRACE,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    TRACENOI
         PUT   SYSTRACE,MSGLINE2     IDRC remove message
TRACENOI DS    0H
         PUT   SYSTRACE,MESSAG14
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
TRACDESC DS    0H
         PUT   SYSTRACE,MESSAGE8
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAGE5
         PUT   SYSTRACE,MESSAGE6
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAG11
         PUT   SYSTRACE,MESSAG12
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAGE7
*--->>
MOVEDRPT DS    0H
         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?
         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSMOVED,(OUTPUT))
         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE      Blank Line
         PUT   SYSMOVED,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    MOVEDNOI
         PUT   SYSMOVED,MSGLINE2     IDRC remove message
MOVEDNOI DS    0H
         PUT   SYSMOVED,MESSAG14
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
         PUT   SYSMOVED,MESSAGE9
         PUT   SYSMOVED,MESSAG10
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
         PUT   SYSMOVED,MESSAG11
         PUT   SYSMOVED,MESSAG12
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
*--->>
FILESRPT DS    0H
         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?
         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSFILES,(OUTPUT))
         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSFILES,OUTLINE      Blank Line
         PUT   SYSFILES,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    FILESNOI
         PUT   SYSFILES,MSGLINE2     IDRC remove message
FILESNOI DS    0H
         PUT   SYSFILES,MESSAG14
*--->>
NOSYSFIL DS    0H
* ----------------------------------------------------------------- *
*   Now do the same for SYSPRINT report, which is always there.
* ----------------------------------------------------------------- *
         PUT   SYSPRINT,MESSAGE1
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         PUT   SYSPRINT,OUTLINE      Blank Line
         PUT   SYSPRINT,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    PRINTNOI
         PUT   SYSPRINT,MSGLINE2     IDRC remove message
PRINTNOI DS    0H
         PUT   SYSPRINT,MESSAG14
*--->>
*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.
*        BAL   R9,FLDIMAGE
*--->>
* ----------------------------------------------------------------- *
TAPEREAD DS    0H                      READ a new tape block.
* ----------------------------------------------------------------- *
*   You come here every time you do a tape READ.
* ----------------------------------------------------------------- *
         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks
         BAL   R9,READBLOK             Read a block of data
         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?
         BO    MAINTPMK                Yes. Take appropriate action.
* --- >
         L     R1,CURRBFUL             Fullword number of bytes read
         C     R1,CHNKSIZE             Bigger than chunk size?
         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.
         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.
         NI    BUFINISH,FF-X'01'       Turn "buffer finished" flag off
         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer
         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved
         B     AFTRCHNK                Jump over other alternative
NOCHUNKS DS    0H
         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.
         OI    BUFINISH,X'01'          Buffer is finished in one shot.
         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total
         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total
* --- >                                Label check if HDR - below
AFTRCHNK DS    0H
         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?
         BNE   MAINNOTL                No. Can't be a label.
         BAL   R9,LABELCHK             Check for labels and their kind.
         TM    ISLBLFLG,X'01'          Is this record a label?
         BZ    MAINNOTL                No. Bypass flag setting.
         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?
         BZ    MAINNOTH                Neither. Check if EOF or EOV.
         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.
MAINNOTH DS    0H
         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?
         BZ    MAINNOTL                No. Don't turn off flag.
         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.
MAINNOTL DS    0H
* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW
** -->              stuff below is only done per READ.
         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3
         L     R2,CURRBFUL          Load Current READ Byte Count
         LA    R3,DBOUTF            Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DBOUT             Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
** -->   label byte counts and data byte counts  <-- **  below
         TM    ISLBLFLG,X'01'       This is a label file?
         BO    ADLABCNT             If so, go count its bytes
         LA    R3,DAIN              This is a data file--count bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         B     NOLABCNT             Don't count twice
ADLABCNT DS    0H
         LA    R3,LBIN              Count the label file's bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
NOLABCNT DS    0H
         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3
** -->              stuff above is only done per READ.
* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE
* --- >                                Label check if HDR - above
**-------------------------------------------------------------------**
FOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL
*                                   THE BUFFER IS EXHAUSTED.
         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields
         MVC   FLDECARD,SVENDCRD
         L     R3,=A(INAREA)           Point to the data buffer
         ST    R3,FLDBUFFR             Initialize
         ST    R3,FLDBSTRT                 FLDAREA fields
         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA
*                                      because we'll have to fold the
*                                      newly manufactured header.
**-------------------------------------------------------------------**
FOLDLOOP DS    0H
         L     R1,FLDBYTOT          Compare bytes remaining to fold
         C     R1,CHNKSIZE          To the chunk size.
         BH    FOLDNCHK             If now less than or equal
         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off
         OI    BUFINISH,X'01'       And turn "buffer finished" flag on
         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.
FOLDNCHK DS    0H
         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA
         BAL   R9,MAKEHEDR             Create a header with READ info
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER               Point to address of this header
         ST    R3,FLDBUFFR             Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF             And fold it into FB-80.
         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.
         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA
         MVC   FLDBYMVD,=F'0'          Initialize bytes folded
         BAL   R9,FOLDBUFF             And fold it into the output.
         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block
** ---------- >>    Record the number of bytes folded - below
         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3
         L     R2,FLDBYMVD          Load Current folded Byte Count
         LA    R3,DBOUTFM           Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DBOUTM            Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
NOFLDCNT DS    0H
         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2
** ---------- >>    Record the number of bytes folded - above
         TM    CHNKFLAG,X'01'          Are we doing chunks?
         BZ    TAPEREAD                No. Do another tape read.
         TM    BUFINISH,X'01'          Have we finished this block?
         BO    TAPEREAD                Yes. Read another block.
         B     FOLDLOOP                No. Fold more chunks.
*
MAINTPMK DS    0H                   Last read was a T.M.
         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count
         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk
         BAL   R9,MAKEHEDR          Make a header to show EOF.
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER            Load address of header
         ST    R3,FLDBUFFR          Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF          Fold the header into the output
         MVC   SAVOFFST,FLDOFFST    Offset has to be current
         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header
         BAL   R9,REPTFILE          Report Block and Byte Counts
*--->>
         MVC   DBOUTF(8),=D'0'      Zero File Byte Count
         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count
         ZAP   BLOCKCNT,=P'0'       Zero File Block Count
*--->>
         B     TAPEREAD             Read in another tape block.
*
* ---------------------------------------------------------------- *
*          END OF INPUT AWS DATA                                   *
* ---------------------------------------------------------------- *
FIN      DS    0H                   PROGRAM EXIT ROUTINE
         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk
         OI    TPMKFLAG,X'01'       Force Tape Mark indication.
         BAL   R9,MAKEHEDR          Make EOT header
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER            Load address of header
         ST    R3,FLDBUFFR          Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF          Fold the header into the output
BREAKLUP DS    0H
         MVC   SAVOFFST,FLDOFFST    Offset has to be current
         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk
         TM    READFLAG,X'01'       READ only?
         BO    NOPUT01              Yes. No output to AWSOUT.
         PUT   AWSOUT,OUTCARD       And write out the last buffer.
         MVC   OUTCARD(80),LASTLINE Add an extra card of hex zeroes
         PUT   AWSOUT,OUTCARD       And put it out too.
NOPUT01  DS    0H
         AP    FLDOUTCT,=P'1'       Count the record PUT out.
         AP    FLDOUTCT,=P'1'       Count the extra record of blanks
WRITSUMM DS    0H
         BAL   R9,SUMMREPT          Print the summary report.
* ---------------------------------------------------------------- *
*     Close the files that were OPENed
* ---------------------------------------------------------------- *
CLOSEMAL DS    0H                   Close em all.....
         CLOSE TAPIN
         TM    READFLAG,X'01'       Is this a READ only run?
         BO    NOAWSCLS             Can't CLOSE what ain't OPEN.
         CLOSE AWSOUT
NOAWSCLS DS    0H
         CLOSE SYSPRINT
         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?
         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSTRACE
SYSTRNOP DS    0H
         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?
         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSMOVED
SYSFILNO DS    0H
         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSMOVED DDNAME?
         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSFILES
SYSMVDNO DS    0H
FIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM
         L     R13,4(,R13)
         RETURN (14,12),RC=0
         EJECT
* ----------------------------------------------------------------- *
* ---       SUBROUTINES                                         --- *
* ----------------------------------------------------------------- *
*
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
SCNSYSIN DS    0H                 Routine to extract info from SYSIN.
         ST    R9,SAVER9SC
* -------------- >>>>>>   Look for SYSIN cards            - BELOW
         TM    FLAGSYST,X'08'       Is SYSIN there?
         BZ    SCNSYSIE             No. Then can't open it. So get out.
         OPEN  (SYSIN,(INPUT))
SYSINLUP DS    0H
         GET   SYSIN,GETSYSIN
         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?
         BE    SYSNWVOL              Yes. Go process the new volume.
         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?
         BE    SYSCHUNK                    Looks that way.....
         CLC   =C'READ ',GETSYSIN
         BE    SYSREAD
         CLC   =C'IDRCOFF ',GETSYSIN
         BE    SYSIDRCO
         B     SYSINLUP              Look for another card.
SYSNWVOL DS    0H
         CLI   GETSYSIN+7,C' '       Is the next letter a blank?
         BE    SYSINLUP              Yes. Ignore this card.
         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.
         B     SYSINLUP
SYSCHUNK DS    0H
         CLI   GETSYSIN+10,C' '  Is the first number value blank?
         BE    SYSINLUP          Yes. Ignore entire card.
         CLI   GETSYSIN+10,X'F0' Smaller than zero?
         BL    SYSINLUP          Yes. Get another card.
         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?
         BH    SYSINLUP          Yes. Get another card.
         OI    FLAGCHNK,X'01'    Show chunk size default was changed.
         LA    R15,GETSYSIN+10   Now get the number that was coded.
         LR    R1,R15            Load R1 with beginning of the number.
SYSCHNUM DS    0H
         LA    R15,1(,R15)       Bump to next character.
         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?
         BH    SYSCHGNM          Yes. Go get the number.
         CLI   0(R15),C' '       Not end of card. But is it a blank?
         BE    SYSCHGNM          Yes. Then get the number.
         B     SYSCHNUM          Not a blank yet. Step up one place.
SYSCHGNM DS    0H
         SR    R15,R1            How many digits is the number?
         BCTR  R15,0             Lower it by one for EXECUTE.
         EX    R15,PACK          Copy the number to work area.
         CVB   R0,WORKA          Convert it to a binary number.
         ST    R0,CHNKSIZE       And store the value for later use.
SYSCHCLG DS    0H
         B     SYSINLUP          Go look for another card.
SYSREAD  DS    0H
         OI    READFLAG,X'01'
         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.
         B     SYSINLUP
SYSIDRCO DS    0H
         OI    IDRCFLAG,X'01'
         B     SYSINLUP
SYSINEND DS    0H                No more cards. Close SYSIN DCB.
         CLOSE SYSIN
* -------------- >>>>>>   Look for SYSIN cards            - ABOVE
SCNSYSIE DS    0H
         L     R9,SAVER9SC
         BR    R9
* - - >
PACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>
WORKA    DC    D'0'
* - - >
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
*     Routine to read a block of data from the input tape
*     and save byte counts from it, to make the AWS headers.
* ----------------------------------------------------------------- *
READBLOK DS    0H
         ST    R9,SAVER9RB        Save BAL register
         ST    R2,SAVER2R         Store work registers
         ST    R3,SAVER3R
         MVC   INECB,=F'0'        Initialize IN's ECB
         EXCP  INIOB              Read
         WAIT  ECB=INECB          Wait for Read
         TM    INCSW+4,X'01'      Was TM Read?
         BO    READTPMK           Yes
         CLI   INECB,X'7F'        Did Read complete normally?
         BNE   INERR              No -- error
         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.
         AP    BLOCKCNT,=P'1'
         AP    BLOCKTOT,=P'1'
         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read
         XC    FULLWORK,FULLWORK   Clear area completely
         MVC   HALFWORK(2),INCCW+6   Read length
         L     R2,FULLWORK           Load R2 with full low order
         MVC   HALFWORK(2),INCSW+6   Residual byte count
         L     R3,FULLWORK           Load R3 with full low order
         SR    R2,R3              R2=Actual length read
         STH   R2,BYTESCOP        Save quantity of bytes copied
         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block
         NI    ISLBLFLG,X'FF'-X'01'  Turn off "IS LABEL" flag
         OI    NWBLKFLG,X'01'        Turn on "new block" flag
         B     READNOTM           This READ was not a Tape Mark
*
READTPMK DS    0H                 This READ was a Tape Mark
         TM    TPMKFLAG,X'01'     Check if there was another TM before
         BZ    READTFST           No. First one.
         OI    TPMKFLAG,X'02'     If two in a row, flag that situation
READTFST DS    0H
         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?
*
* --- >                           Null SL file is not EOT - below
         BNO   NOFIN1               Not 2 T.M. in a row. Go on.
         TM    FLAGHDRL,X'01'       Test if HDR label was last seen
         BO    NOFIN0               Yes. Must be null SL file.
         B     FIN                  Otherwise, valid 2 TMs and EOT.
NOFIN0   DS    0H
         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.
NOFIN1   DS    0H
* --- >                           Null SL file is not EOT - above
*
         AP    FILCOUNT,=P'1'     Add 1 to File Count.
         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.
         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.
READNOTM DS    0H
* ---->     for the trace            All READ results should come here
         MVC   LINE,LINE-1           Clear output line
         MVC   LINE+1(16),READTRMS   Put in Read Trace message
         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?
         BZ    ITSABLOC              No. Mark trace as for a block.
         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.
         B     ITSATPMK              And go farther.
ITSABLOC DS    0H
         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block
ITSATPMK DS    0H
         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ
         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header
         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header
         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag
         HEX   LINE+40,6,HEADER      Show the Header last constructed
         HEX   LINE+56,30,INAREA     Show first 20 bytes of Input Area
         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?
         BNO   NOREADT1              No. Can't print trace line.
         PUT   SYSTRACE,LINE
NOREADT1 DS    0H                    Trace is finished.
* ---->     for the trace
         L     R2,SAVER2R         Restore work registers
         L     R3,SAVER3R
         B     READBEND           and exit normally.
* -----
INERR    DS    0H                 READ error on input tape
         MVC   LINE,LINE-1        Clear print line
         TM    INCSW+4,X'02'      Unit Check?
         BZ    INERR1             No - Assume Data Check
         MVC   LINE(133),INEQC    Set Error Message
         B     INERR2             Continue
INERR1   MVC   LINE(133),INDCK    Set Error Message
INERR2   PUT   SYSPRINT,LINE      Write Error Message
         L     R2,SAVER2R         Restore work registers
         L     R3,SAVER3R         Rewind the tape, and exit.
         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload
         MVC   INECB,=F'0'        Initialize IN's ECB
         EXCP  INIOB              Rewind and Unload
         WAIT  ECB=INECB          Wait for Rewind and Unload
         B     WRITSUMM           Write summary of what was done,
*                                  and get out of the program.
READBEND DS    0H
         L     R9,SAVER9RB        Restore BAL register
         BR    R9
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
MAKEHEDR DS    0H
         ST    R9,SAVER9MH
* ----------------------------------------------------------------- *
*     We are forming the new header in the field HEADER.
*     We assume that the TAPEREAD subroutine was executed first.
*     We assume that the FLDAREA was previously saved to SAVAREA.
* ----------------------------------------------------------------- *
         MVC   HEADER(6),=XL6'00'      Start fresh.
         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header
         MVC   HDRNSTOR(1),SAVBYTES+3     Reverse
         MVC   HDRNSTOR+1(1),SAVBYTES+2      bytes
         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot
MAKEWHAT DS    0H                      Manufacture the proper hdr flags
         TM    TPMKFLAG,X'01'          Has a tape mark been read?
         BO    MAKE40                  First test. Make a X'40' header
         TM    NWBLKFLG,X'01'          First chunk of current block?
         BO    MAKE80                  Yes. Turn on X'80' bit.
         TM    BUFINISH,X'01'          Last chunk of current block?
         BO    MAKE20                  Yes. Turn on X'20' bit.
         B     MAKE00                  No. Don't turn on any flag bits.
MAKE80   DS    0H
         OI    HDRFLAG1,X'80'          Turn on X'80'
         B     MAKE20                  And see if X'20' also, or not.
MAKE00   DS    0H                      No HDRFLAG1 bits to be turned on
         B     MAKEHDEN                And just get out.
MAKE20   DS    0H
         TM    BUFINISH,X'01'          Test again for last chunk.
         BZ    MAKEHDEN                It isn't, so only X'80' is on.
         OI    HDRFLAG1,X'20'          It is. So turn on X'20'.
         B     MAKEHDEN
MAKE40   DS    0H                      Tape mark has been read.
         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.
         MVI   HDRFLAG1,X'40'          HDRFLAG1 has to be X'40'
MAKEHDEN DS    0H
         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN
         AP    OUTHDRS,=P'1'           Count this header we've made.
*----------------------------------------------------------------- *
*   Now that we've made a header, we count how many of each type.
*----------------------------------------------------------------- *
KINDAHDR DS    0H
         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?
         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK
         AP    OUTTYPE3,=P'1'         YES. COUNT THIS TYPE
         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE
KCHKBEG  DS    0H
         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?
         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.
         AP    OUTTYPE1,=P'1'         YES. COUNT THIS TYPE
KCHKEND  DS    0H
         TM    HDRFLAG1,X'20'         END OF BLOCK?
         BNO   KINDAH40               NO. CHECK IF END OF FILE
         AP    OUTTYPE2,=P'1'         YES. COUNT THIS TYPE
KINDAHA0 DS    0H
         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?
         BNE   KINDAH40               NO. TEST FOR EOF HEADER.
         AP    OUTTYPE5,=P'1'         YES. COUNT IT FOR REPORTING.
         B     KINDAHEN               AND DON'T TEST MORE BITS.
KINDAH40 DS    0H
         TM    HDRFLAG1,X'40'         END OF FILE HEADER?
         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.
         AP    OUTTYPE4,=P'1'         YES. COUNT THIS TYPE
*
KINDAHEN DS    0H
         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?
         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION
         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE
         MVC   OUTLINE+2(4),=C'hdr:'
         HEX   OUTLINE+8,6,HEADER     FLDAREA at MAKEHEDR time display
         HEX   OUTLINE+28,4,FLDSCARD                            .
         HEX   OUTLINE+38,4,FLDECARD                            .
         HEX   OUTLINE+48,4,FLDOFFST                            .
         HEX   OUTLINE+58,4,FLDBYTES                            .
         HEX   OUTLINE+68,4,FLDBYTOT                            .
         HEX   OUTLINE+78,4,FLDBYMVD                            .
         HEX   OUTLINE+88,4,FLDBUFFR                            .
         HEX   OUTLINE+98,4,FLDBSTRT                            .
         HEX   OUTLINE+108,7,FLDOUTCT                           .
         HEX   OUTLINE+124,1,FLDREADF
         HEX   OUTLINE+22,1,HDRFLAG1                            .
         PUT   SYSTRACE,OUTLINE
NOSYSTR1 DS    0H
MAKEHEND DS    0H
         L     R9,SAVER9MH
         BR    R9
* ----------------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
*                                                           *
*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *
*                                                           *
*    All FLDAREA field required for call have to be         *
*    filled in:                                             *
*                                                           *
*    FLDSCARD - Initialized to OUTCARD at beg of program    *
*    FLDECARD - Initialized to OUTCARD+80                   *
*    FLDOFFST - Initialized to 0, updated by each call      *
*    FLDBYTES - Set before each call                        *
*    FLDBYTOT - Set before each call                        *
*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *
*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *
*    FLDBSTRT - Start of input buffer                       *
*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *
*    FLDREADF - READFLAG, copied into FLDAREA control blk   *
*                                                           *
* --------------------------------------------------------- *
FOLDBUFF DS    0H
         ST    R9,SAVER9FB              Save BAL register
         MVC   LINE,LINE-1
*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call
*        BAL   R9,FLDIMAGE
         LA    R1,FLDAREA
         L     R15,=V(FOLDEM)           Entry point of FOLDEM program
         BALR  R14,R15                  Call it.
*                                       Copy back FLDAREA from FOLDEM
         ST    R1,NEWFLDA               Save new FLDAREA address
         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours
         MVC   LINE,LINE-1
*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call
*        BAL   R9,FLDIMAGE
FOLDBUFE DS    0H
         L     R9,SAVER9FB              Restore BAL register
         BR    R9                       Return to caller
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
* --------------------------------------------------------- *
FLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently
*
         ST    R9,SAVER9FI
         HEX   LINE+10,4,FLDSCARD
         HEX   LINE+20,4,FLDECARD
         HEX   LINE+30,4,FLDOFFST
         HEX   LINE+40,4,FLDBYTES
         HEX   LINE+50,4,FLDBYTOT
         HEX   LINE+60,4,FLDBYMVD
         HEX   LINE+70,4,FLDBUFFR
         HEX   LINE+80,4,FLDBSTRT
         HEX   LINE+90,7,FLDOUTCT
         HEX   LINE+106,1,FLDREADF
         PUT   SYSPRINT,LINE
         MVC   LINE,LINE-1
         L     R9,SAVER9FI
         BR    R9
* --------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ
*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED
* --------------------------------------------------------- *
ADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE
         ST    R9,SAVER9AD         Save BAL register
         STM   R4,R5,SAVEADDC      Save work registers
         L     R4,0(,R3)           Load high order counter
         L     R5,4(,R3)           Load low order counter
         AR    R5,R2               Add to byte count
         BNO   ADDCNOOV            No overflow, then branch
         LA    R4,1(,R4)           else, overflow to high word
         X     R5,=X'7FFFFFFF'     Get rid of sign bit
ADDCNOOV DS    0H
         ST    R4,0(,R3)           Put updated counter in storage
         ST    R5,4(,R3)           Put updated counter in storage
         LM    R4,R5,SAVEADDC      Restore work registers
ADDCOUNE DS    0H                  END OF ROUTINE - RETURN
         L     R9,SAVER9AD         Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
LABELCHK DS    0H         Check for the presence of tape labels
*                         and set label flags, accordingly,
*                         in the LBLFLAG byte.
*
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
*
* --------------------------------------------------------- *
         ST    R9,SAVER9LB          Save BAL register
         NI    ISLBLFLG,FF-X'01'    Turn off "Is Label" flag at start
         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?
         BE    CVOL1                Process THE VOL1
         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?
         BE    CHDR1                Process HDR1
         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?
         BE    CHDR2                Process HDR2
         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?
         BE    CEOF1                Process EOF1
         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?
         BE    CEOF2                Process EOF2
         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?
         BE    CEOV1                Process EOV1
         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?
         BE    CEOV2                Process EOV2
         CLC   INAREA(3),=C'UHL'    This a User Header Label?
         BE    CUHL                 Process UHL
         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?
         BE    CUTL                 Process UTL
         B     NOTLABEL             80 byte record is not an IBM SL
*        ------------------------------------------------------ *
CVOL1    DS    0H                   PROCESS VOL1 LABEL
* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRCV             NO. SKIP ROUTINE.
         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRCV DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE
         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
* ----- >    CHANGE OUTPUT VOLUME NAME - below
         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?
         BE    NOCHGVOL                  YES. DON'T CHANGE.
         LA    R1,INAREA                 Point to INAREA
         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.
         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.
         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.
         TM    FLAGSYST,X'02'
         BZ    NCHGMOVD
         PUT   SYSMOVED,MESSAG13
NCHGMOVD DS    0H
         TM    FLAGSYST,X'04'            SYSFILES here?
         BZ    NCHGFILE                  Nope. Skip a PUT to it.
         PUT   SYSFILES,MESSAG13         VOLSER overridden message.
         MVC   OUTLINE,OUTLINE-1         Blank line to separate
         PUT   SYSFILES,OUTLINE             from the rest of output.
NCHGFILE DS    0H
NOCHGVOL DS    0H                        Kludge extra blank like
         TM    FLAGSYST,X'04'            Is SYSFILES here?
         BZ    KLUDGE01                  Nope. No PUTs to it.
         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?
         BNE   KLUDGE01                  Is overridden, no extra blank.
         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank
         PUT   SYSFILES,OUTLINE
KLUDGE01 DS    0H
* ----- >    CHANGE OUTPUT VOLUME NAME - above
         B     LABCHEND
CHDR1    DS    0H
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS
         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.
         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?
         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET
         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE
CHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CHDR2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRH2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRH2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRH2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2
         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOF1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1
         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOF2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRF2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRF2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRF2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2
         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOV1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1
         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOV2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRv2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRV2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRV2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2
         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *
CUHL     DS    0H                   HANDLE USER HEADER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CUTL     DS    0H                   HANDLE USER TRAILER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *
NOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF "IS LABEL" FLAG
LABCHEND DS    0H                   Return to caller
         L     R9,SAVER9LB          Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
SUMMREPT DS    0H                        Write Summary Totals
         ST    R9,SAVER9SR               Save BAL Register
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG01
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG02
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG03
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG04
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG05
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE3   MIDDLE OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG06
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE4   END OF FILE HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG07
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE5   X'A0' HEADERS - BEG and END
         PUT   SYSPRINT,OUTLINE
* >---->                                 Display tape total counts
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTMH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST
         L     R4,DBOUTML                LOAD REG WITH LOW ORDER
         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD               AND ADD IT IN
         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM01
         PUT   SYSFILES,CNTLINE
NOSUMM01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM02
         PUT   SYSFILES,CNTLINE
NOSUMM02 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,LBINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM03
         PUT   SYSFILES,CNTLINE
NOSUMM03 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG06       Total bytes read for data
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DAINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM04
         PUT   SYSFILES,CNTLINE
NOSUMM04 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape
         MVC   FILEBYTE,BYTESPAT
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKTOT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM05
         PUT   SYSFILES,CNTLINE
NOSUMM05 DS    0H
* >---->
SUMMREND DS    0H                  END OF ROUTINE - RETURN
         L     R9,SAVER9SR         Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
REPTFILE DS    0H       Routine to write block and byte counts
*                       for each file in the SYSFILES ddname.
* --------------------------------------------------------- *
*----------->>
         ST    R9,SAVER9RF
*--->                   Block counts first  -  below
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG07
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKCNT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         MVC   CNTLINE+90(11),BLOKPAT
         ED    CNTLINE+90(11),BLOCKTOT+2
         MVC   CNTLINE+102(10),=C'Cum Blocks'
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE00
         PUT   SYSFILES,CNTLINE
NOFILE00 DS    0H
* >---->
*--->                   Block counts first  -  above
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG01
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTFMH        Bytes folded counts for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
* >--->
         TM    ISLBLFLG,X'01'
         BO    DISLABLS
         MVC   DATBYTES,BYTESPAT
         L     R4,DAINH           Data bytes written cumulative to here
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(38),DATDISPL
         B     DISPDATA
* >--->
DISLABLS DS    0H
         MVC   LABBYTES,BYTESPAT
         L     R4,LBINH           Label bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(38),LABDISPL
         B     DISPDATA
* >--->
DISPDATA DS    0H
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE01
         PUT   SYSFILES,CNTLINE
NOFILE01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG02
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTFH         Bytes written for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
* >--->
         CLC   DBOUTF(8),DBOUTFM
         BE    RIGHTBYT
         MVI   CNTLINE+72,C'*'
RIGHTBYT DS    0H
* >--->
         MVC   CUMBYTES,BYTESPAT
         L     R4,DBOUTH          Bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(43),CUMDISPL
* >--->
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE02
         PUT   SYSFILES,CNTLINE
NOFILE02 DS    0H
         L     R4,SAVER4Q
         MVC   CNTLINE,CNTLINE-1
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE03
         PUT   SYSFILES,CNTLINE
NOFILE03 DS    0H
*----------->>
REPTFEND DS    0H
         L     R9,SAVER9RF
         BR    R9
         EJECT
* ----------------------------------------------------------------- *
*      CCWs and IOB for the EXCP operations.
* ----------------------------------------------------------------- *
*              read,addr of data,flags,64K bytes
RUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW
         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW
INCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW
INECB    DC    F'0'
INIOB    DC    X'02000000'
         DC    A(INECB)
INCSW    DC    2F'0'
INCCWPT  DC    A(INCCW)
INDCBPT  DC    A(TAPIN)
         DC    F'0'
         DC    X'00010000'
         DC    XL44'00'            Padding
         SPACE 3
* ----------------------------------------------------------------- *
         ENTRY AWSOUT
AWSOUT   DCB   DDNAME=AWSOUT,MACRF=PM,DSORG=PS,LRECL=80
TAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U
         ENTRY SYSPRINT
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X
               EODAD=SYSINEND
         DC    CL8' '
FF       EQU   X'FF'
* ----------------------------------------------------------------- *
*
* AWSTAPE BLOCK HEADER
*
* ----------------------------------------------------------------- *
HEADER   DS    0CL6                     BLOCK HEADER
HDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH
HDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH
HDRFLAG1 DC    X'00'                    FLAGS BYTE 1...
HDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD
HDRF1TMK EQU   X'40'                    ...TAPE MARK
HDRF1EOR EQU   X'20'                    ...END OF RECORD
HDRFLAG2 DC    X'00'                    FLAGS BYTE 2
*
         DC    XL80'00'                 PADDING
OUTHEADR DC    XL6'00'
* ----------------------------------------------------------------- *
         DC    XL12'00'                 PADDING
HALFZERO DC    XL2'00'
         DC    XL12'00'                 PADDING
HDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF
HDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF
         DC    XL12'00'                 PADDING
BYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT
CURRBFUL DS    0F
         DC    H'0'
CURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT
LASTBFUL DS    0F
         DC    H'0'
LASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT
PARTBFUL DS    0F
         DC    H'0'
PARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT
ZEROCARD DC    80X'00'
* -------------------------------------------- *
* ---------- *      F L A G S     * ---------- *
* -------------------------------------------- *
* ---------- *
READFLAG DC    X'00'         This run is "READ ONLY"  ?
*              X'01'         Yes, read only.
* ---------- *
NWBLKFLG DC    X'00'         We have just read a new block.
*              X'01'         Turned off after first chunk write.
* ---------- *
IDRCFLAG DC    X'00'         This run is "IDRC Fix"  ?
*              X'01'         Turn off IDRC indicator
* ---------- *
FLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED
*              X'01'          CHUNK SIZE IS NOT BLANK
* ---------- *
FLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE
*              X'01'          //SYSTRACE DD IS THERE
*              X'02'          //SYSMOVED DD IS THERE
*              X'04'          //SYSFILES DD IS THERE
*              X'08'          //SYSIN    DD IS THERE
* ---------- *
CHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?
*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE
* ---------- *
BUFINISH DC    X'00'          Have we finished folding entire buffer?
*              X'01'          Yes. We are now finishing the buffer.
* ---------- *
LBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
* ---------- *
ISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL
*              X'00'          DATA IS NOT A LABEL
*              X'01'          DATA IS A LABEL
* ---------- *
TPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark
*              X'01'          We just read a Tape Mark
*              X'02'          We previously read a Tape Mark
* ---------- *
FLAGHDRL DC    X'00'          Header label flag - Last label was a hdr
*              X'01'          EOT HEADER is following a HDR1 or HDR2
* ---------- *
* -------------------------------------------- *
FULLWORK DS    0F
FULLHIGH DC    H'0'
HALFWORK DC    H'0'                HALFWORD WORK AREA
         DC    2F'0'               Padding
FOLDBREG DS    0F                  Fullword - no of bytes to fold
FOLDHIGH DC    XL2'00'             High order - should be zeros
HDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD
HDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED
HDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVF  DC    XL2'00'
HDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED
HDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRLENFL DC    XL2'00'
HDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER
HDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVFL DC    XL2'00'
HDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER
OUTCCWST DC    XL2'00'
         DC    XL2'00'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
         BR    R4                  RETURN TO CALLER
HEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
SVNEWVOL DC    CL6' '              SAVED NEW VOLUME
CHNKSIZE DC    F'65535'            Default is maximum halfword
LASTLINE DS    0CL80
LASTHX00 DC    80X'00'
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
DWORD    DC    D'0'
QWORD    DS    PL16
TWO31    DC    P'2147483648'       2 TO THE 31ST
OUTHDRS  DC    PL7'0'
OUTTYPE1 DC    PL7'0'
OUTTYPE2 DC    PL7'0'
OUTTYPE3 DC    PL7'0'
OUTTYPE4 DC    PL7'0'
OUTTYPE5 DC    PL7'0'
FILCOUNT DC    PL7'0'
BLOCKCNT DC    PL7'0'
BLOCKTOT DC    PL7'0'
TPMKCNT  DC    PL7'0'
DECVALUE DS    CL8
FILEPAT  DC    X'402020202020202120'
BLOKPAT  DC    X'4020202020202020212020'
EDPAT    DC    X'40206B2020206B2020206B2020206B202120'
BYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'
FILEBYT  DS    0CL32
FILEBYTE DC    C' 9,999,999,999,999,999,999'
         DC    C' Bytes'
CUMDISPL DS    0CL43
CUMBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Total Bytes'
LABDISPL DS    0CL38
LABBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Labels'
DATDISPL DS    0CL38
DATBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Data  '
*
SVBEGCRD DS    F
SVENDCRD DS    F
SVBFAREA DS    F                Address of input buffer
*
SAVER2R  DS    F                Save work regs during tape read.
SAVER3R  DS    F                Save work regs during tape read.
SAVER4B  DS    F                Register Save for HEX routine
SAVER4Q  DS    F                Register Save for byte count reperting
SAVEFOLD DS    6F               Register Save for FOLDEM routine
SAVEADDC DS    3F               Register Save for ADDCOUNT routine
SAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE
SAVER9AD DS    F                Register Save for ADDCOUNT routine
SAVER9RB DS    F                Register Save for READBLOK routine
SAVER9RF DS    F                Register Save for REPTFILE routine
SAVER9LB DS    F                Register Save for LABELCHK routine
SAVER9SR DS    F                Register Save for SUMMREPT routine
SAVER9FB DS    F                Register Save for FOLDBUFF routine
SAVER9FI DS    F                Register Save for FLDIMAGE routine
SAVER9SC DS    F                Register Save for SCNSYSIN routine
SAVER9MH DS    F                Register Save for MAKEHEDR routine
NEWFLDA  DS    F
HDRSIZE  DC    F'6'             SIZE OF A HEADER
SVBEGDAT DS    F
*  -----------------
ZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1
*  -----------------     JFCB if we'll need RDJFCB later - not used now
JFCB1    DC    X'87'
         DC    AL3(INFMJFCB)
         IEFJFCBN LIST=YES
         DC    C' '
*
*  -----------------            Summary Totals Message Texts
PRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '
PRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '
PRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS    : '
PRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '
PRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '
PRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '
PRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '
*
*  -----------------            Byte Count Message Texts
CTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '
CTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '
CTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '
CTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '
CTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '
CTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '
CTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '
CTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '
*
*  -----------------            Header Message Texts
MESSAGE1 DC    CL133'1VTT2DISK - REAL TAPE TO FB-80 AWS CONVERSION PROG-
               RAM  '
MESSAGE2 DC    CL133'1VTT2DISK  -  AWS TAPE HEADER TRACE REPORT  '
MESSAGE3 DC    CL133'1VTT2DISK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-
               R REPORT  '
MESSAGE4 DC    CL133'1VTT2DISK - TAPE TO AWS FILE REPORT - READ AND FOL-
               D STATS  '
MESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -
               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-
               '
MESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-
               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-
               '
MESSAGE7 DS    0CL133
         DC    CL8'  hdr:  '
         DC    CL12'HEADER TEXT '
         DC    CL1' '
         DC    CL4'TYPE'
         DC    CL3' '
         DC    CL10'FLDSCARD'
         DC    CL10'FLDECARD'
         DC    CL10'FLDOFFST'
         DC    CL10'FLDBYTES'
         DC    CL10'FLDBYTOT'
         DC    CL10'FLDBYMVD'
         DC    CL10'FLDBUFFR'
         DC    CL10'FLDBSTRT'
         DC    CL14'FLDINRCD'
         DC    CL11' '
MESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-
                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-
               DE. '
MESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2DISK, THE SYSMOV-
               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-
                 '
MESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-
               EPORT.  BOTH "TAPE READ" AND "FOLD DATA" ARE AVAILABLE T-
               HERE.'
MESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -
               HAVE SOURCE CODE, THEN UNCOMMENT THE "BEFCALL-" AND "AFT-
               CALL-" '
MESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-
               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -
                    '
MESSAG13 DC    CL133'    VOLSER Overridden to:    '
MESSAG14 DC    CL133'    Chunk Size is set to:    '
*  -----------------            Error Message Texts
ERRMESS1 DC    CL133'    OFFSET ERROR           '
INEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '
         DC    C'TERMINATED '
         DC    76C'*'
INDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '
         DC    82C'*'
*  -----------------            Trace Message Texts
READTRMS DC    CL16'READ TRACE:     '
FOLDTRMS DC    CL16'FOLD TRACE:     '
MHDRTRMS DC    CL16'MAKEHEDR TRACE: '
OSETTRMS DC    CL16'OFFSET TRACE:   '
BBLKTRMS DC    CL16'BLOCK TRACE:    '
*    ------------------------ >   Output Line Buffers  -  below
         DC    C' '
CNTLINE  DC    CL133' '
         DC    C' '
OUTLINE  DC    CL133' '
         DC    C' '
LINE     DC    CL133' '           For error messages
         DC    C' '
PRTLINE  DC    CL133' '
         DC    C' '
MSGLINE1 DC    CL133' '           For READ only message
         DC    C' '
MSGLINE2 DC    CL133' '           For IDRC remove message
*    ------------------------ >   Output Line Buffers  -  above
         LTORG
SAVEHDR  DC    XL6'000000000000'
EOTMARK  DC    XL6'000000004000'
* - - - - >
*
FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
FLDSCARD DC    F'0'         Start address of 80-byte card
FLDECARD DC    F'0'         End address of 80-byte card
FLDOFFST DC    F'0'         OFFSET of data in the card
FLDBYTES DC    F'0'         Number of bytes to be folded now
FLDBYTOT DC    F'0'         Batch total of bytes left to move
FLDBYMVD DC    F'0'         Number of bytes folded now
FLDBUFFR DC    F'0'         Current data start address
FLDBSTRT DC    F'0'         Original start data address
FLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records
FLDREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
FLDLENTH EQU   *-FLDAREA
*
* - - - - >
*         Saved Copy of FLDAREA Control Block
* - - - - >
*
SAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
SAVSCARD DC    F'0'         Start address of 80-byte card
SAVECARD DC    F'0'         End address of 80-byte card
SAVOFFST DC    F'0'         OFFSET of data in the card
SAVBYTES DC    F'0'         Number of bytes to be folded now
SAVBYTOT DC    F'0'         Batch total of bytes left to move
SAVBYMVD DC    F'0'         Number of bytes folded now
SAVBUFFR DC    F'0'         Current data start address
SAVBSTRT DC    F'0'         Original start data address
SAVOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records
SAVREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
SAVLENTH EQU   *-SAVAREA
*
* - - - - >
*    ------------------------ >   Byte Count Save Areas - below
*
*                          -- These are doubleword counters --
*
DBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ
DBOUTFH  DC    F'0'
DBOUTFL  DC    F'0'
DBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED
DBOUTFMH DC    F'0'
DBOUTFML DC    F'0'
DBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ
DBOUTH   DC    F'0'
DBOUTL   DC    F'0'
DBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED
DBOUTMH  DC    F'0'
DBOUTML  DC    F'0'
LBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES
LBINH    DC    F'0'
LBINL    DC    F'0'
DAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES
DAINH    DC    F'0'
DAINL    DC    F'0'
         DC    CL8' '      Extra padding for safety
*
*    ------------------------ >   Constants for Date and Time - below
SAVE1402 DS    6F                 ONE MORE FOR SAFETY
TIMED    DS    CL7
DATED    DS    CL9
DATETIME DS    4F
         ORG   DATETIME
TIME     DS    CL4
         DS    CL4
DATE     DS    CL5
         DS    CL3
HEADDLIT DS    0CL31              Literal for headings - date and time
         DC    CL6'Today:'
         DC    CL2' '
HEADDATE DC    CL23' '
LEVELLIT DS    0CL21              Level number display for headings
         DC    CL6'Level '
LEVELL   DC    CL4'&LLEV'
         DC    CL2' ('
LEVDATE  DC    CL8' '             Assembly date for this program
         DC    CL1')'
*    ------------------------ >   Constants for Date and Time - above
         DC    F'0'               Align, just for the heck of it
GETSYSIN DC    CL80' '
OUTCARDP DC    XL80'00'           Previous card-image read
OUTCARD  DC    XL80'00'           Current  card-image read
OUTCAEND EQU   *
         DC    XL80'00'           Room for another card-image
         DS    0F
         DC    CL8' '
INAREA   DS    CL65535            Buffer to hold tape blocks
         DS    CL800              Padding, so as not to overrun
*                                 somebody else's storage by mistake.
         END
   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'
FOLDEM   CSECT
*  ---------------------------------------------------------------  *
*
*   AUTHOR:       Sam Golob
*
*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,
*                 subject to express permissions from the author
*                 to use this software.  This software is part
*                 of VTTS (Virtual Tape Transportation System).
*
*                 Permission is granted by the author for all
*                 parts of the VTTS package which are distributed
*                 on the CBT Tape collection, to be used by
*                 anyone for their own use, but not for resale
*                 or for reincorporation within commercial code.
*
*                           -------------------------------------
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
*                           -------------------------------------
*                           We do want old MVS systems to be able
*                           to run this routine.
*                           -------------------------------------
*
*  ---------------------------------------------------------------  *
*                                                                   *
*  SUBROUTINE:    FOLDEM                                            *
*                                                                   *
*  DESCRIPTION:                                                     *
*                                                                   *
*      This program is the heart of the process of creating an      *
*      AWS-format disk file from a real tape file.  The disk        *
*      file is data that has been folded over from a buffer,        *
*      into an FB-80 dataset.                                       *
*                                                                   *
*      This program takes buffer data and folds it into FB-80       *
*      data, starting from a given buffer address, for a given      *
*      number of bytes.  The data is folded into an 80-byte         *
*      workarea starting from a given OFFSET address (+0 to +79)    *
*      into the workarea.  When the workarea has been completely    *
*      filled and more data is to be written, a PUT is done to      *
*      write out the data from the 80-byte workarea, and then       *
*      the workarea is cleared with binary zeros before any         *
*      additional data is written to it.  An incompletely filled    *
*      workarea is not written out, and the same is true if the     *
*      workarea is full but no more data is to be written out.      *
*      So in that case, the location of the workarea is returned    *
*      to the caller in field FLDSCARD, and it is the caller's      *
*      responsibility to do the PUT for the last card.              *
*                                                                   *
*  INPUTS and OUTPUTS:                                              *
*                                                                   *
*      This program is driven by a control block called FLDAREA,    *
*      which is updated by both this program and by the caller.     *
*      See below for more details.                                  *
*                                                                   *
*  FILES NEEDED:                                                    *
*                                                                   *
*      This program assumes that the caller has opened DCBs for     *
*      an FB-80 file called AWSOUT, which receives the output       *
*      "virtual tape" data, and for SYSPRINT.  This program         *
*      needs to do PUTs to AWSOUT, and if necessary, it needs       *
*      to write messages to SYSPRINT.  Therefore the caller has     *
*      to provide ENTRY AWSOUT and ENTRY SYSPRINT statements in     *
*      front of its AWSOUT and SYSPRINT DCBs, respectively.         *
*                                                                   *
*  METHOD OF OPERATION:                                             *
*                                                                   *
*      This program operates using a control block, called the      *
*      FLDAREA, which is passed from the caller and back to the     *
*      caller.  Both the caller and this program update the         *
*      FLDAREA.  Upon entry to this program, R1 is expected to      *
*      point to the caller's copy of FLDAREA, and upon return,      *
*      R1 is pointed to the updated copy of FLDAREA in this         *
*      subroutine.  So the caller has to copy it back over its      *
*      own instance of FLDAREA after the return.                    *
*                                                                   *
*      The caller does one tape read, or read of data into a        *
*      buffer.  From the number of bytes read, and possibly from    *
*      the given chunk size also, the caller will construct an      *
*      AWS header which will determine how many bytes should be     *
*      folded into the FB-80 disk dataset.  This AWS header is      *
*      also folded in by a call to this program, and then the       *
*      tape data is folded in afterward, for the number of bytes    *
*      required either by the chunk size or by the block size.      *
*                                                                   *
*      This program does one or more PUTs into the FB-80 file,      *
*      until the request for the number of bytes to be folded,      *
*      is satisfied.  A PUT is done whenever the FB-80 work area    *
*      has been filled.  At the end of the fold operation, the new  *
*      OFFSET into the FB-80 workarea (that has not yet been        *
*      written out to disk), the number of bytes that have been     *
*      folded, and the projected start of the next data to be       *
*      folded, are returned in the fields of the FLDAREA control    *
*      block.                                                       *
*                                                                   *
*      The following is the layout of the FLDAREA.  Fields          *
*      marked with an arrow must be supplied upon input to this     *
*      program.                                                     *
*                                                                   *
*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *
*      *                         ------ ---- ------- -----          *
*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *
*  --> FLDECARD DC    F'0'       End address of 80-byte card        *
*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *
*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *
*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *
*      FLDBYMVD DC    F'0'       Number of bytes folded now         *
*  --> FLDBUFFR DC    F'0'       Current data start address         *
*  --> FLDBSTRT DC    F'0'       Original start data address        *
*      FLDOUTCT DC    PL7'0'     Number of PUTs for AWSOUT records  *
*  --> FLDREADF DC    X'00'      This run is "READ ONLY"  ?         *
*      *              X'01'      Yes, read only. (Copied from the   *
*                                READFLAG byte in the caller.)      *
*      FLDLENTH EQU   *-FLDAREA                                     *
*                                                                   *
*      The rest of the fields are calculated by this program        *
*      and returned to the caller.                                  *
*                                                                   *
*      FLDBUFFR and FLDOFFST are updated by this program, and       *
*      upon return to the caller, they point to the input data      *
*      and output data positions, respectively, that are just       *
*      after the moved data, to anticipate the next call, so as     *
*      to be able to move more data.  FLDBSTRT preserves the        *
*      very beginning address of the input buffer, whereas          *
*      FLDBUFFR is a place somewhere within the buffer, which       *
*      is the start from where the new data is expected to be       *
*      moved.                                                       *
*                                                                   *
*      A new field, FLDBYTOT, makes it easier to create chunked     *
*      AWS-format tape files, when the chunksize is less than       *
*      the blocksize.  This field originally (after a block is      *
*      read into the buffer from the tape) contains the number      *
*      of bytes in the entire block.  After each chunk of data      *
*      is written, this field gets decremented by the number of     *
*      bytes in the chunk just written.                             *
*                                                                   *
*      Since both the caller and this program do PUT operations     *
*      to the output FB-80 file, the count of the number of PUTs    *
*      done, FLDOUTCT, is updated by BOTH the caller and by this    *
*      program.                                                     *
*                                                                   *
*  ---------------------------------------------------------------  *
         MACRO
*  ---------------------------------------------------------------  *
*    This macro is used to display hex values in a printed report.
*  ---------------------------------------------------------------  *
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         ST    R4,SAVER04
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER04
         LM    15,1,HEXSAVE
         MEND
         SPACE
         YREGS
FOLDEM   AMODE 24
FOLDEM   RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'FOLDEM'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         STM   R14,R12,12(R13)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING FOLDEM,R12,R11
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LR    R1,R5                 RESTORE PARM POINTER
         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA
         L     R0,SYSPRINV           SYSPRINT DCB address in caller
         ST    R0,SYSPRDCB             store for the program's use
         L     R0,AWSOUTV            AWSOUT   DCB address in caller
         ST    R0,AWOUTDCB             store for the program's use
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                                                                   *
*   Routine to fold buffer data into an FB-80 file, starting at     *
*   a given location in the buffer, for a certain number of bytes,  *
*   and starting at a given OFFSET in the 80-byte workarea to       *
*   which the buffer data will be written.  When the 80-byte        *
*   workarea is filled up, a PUT is done to AWSOUT, and the         *
*   workarea is cleared with binary zeros for more data to be       *
*   written.                                                        *
*                                                                   *
*   Input:   FLDAREA fields are all supplied by the calling         *
*            program, except for FLDBYMVD which is calculated       *
*            by this program and returned to the caller.  The       *
*            caller's copy of FLDAREA is pointed to by Register 1.  *
*                                                                   *
*            The buffer area containing the data to be folded       *
*            is supplied by the calling program, as well as the     *
*            number of bytes that is expected to be folded.         *
*                                                                   *
*   Output:  Data from the buffer will be moved into the 80-byte    *
*            workarea until the workarea is filled.  When the       *
*            workarea is filled, a PUT will be done to AWSOUT,      *
*            and the workarea is cleared to X'00's to make room     *
*            for more data, when more data is to be written.        *
*                                                                   *
*            Ending OFFSET into the 80-byte workarea, pointing to   *
*            just after the data which has been moved, is returned  *
*            in the FLDOFFST field.  Upon return to the caller,     *
*            the FLDBUFFR field is updated to point to the place    *
*            in the buffer just after the data which has been       *
*            moved.  The FLDBSTRT field always should point to the  *
*            beginning of the data buffer, but this is at the       *
*            discretion of the calling program.                     *
*                                                                   *
*            A count of bytes actually moved from the buffer to     *
*            the 80-byte workarea (and written out by PUTs to the   *
*            AWSOUT DD name as is necessary) is calculated by this  *
*            program and returned in the FLDBYMVD field.  Upon      *
*            return, the number in the FLDBYMVD field should match  *
*            the number in the FLDBYTES field.                      *
*                                                                   *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* <--------- SET UP LOOP TO START MOVING THE DATA ------->
FOLDIT   DS    0H
         L     R1,SAVEPARM          Load address of caller's FLDAREA
         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA
         USING FLDBLOCK,R2
         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours
* - - - - - - - - - -      Load the buffer quantities
         L     R7,FLDBUFFR          Initialize start of buffer data
         L     R8,FLDBYTES          Bytes to be moved
         AR    R8,R7                Add in start buffer address
         ST    R8,HYPOENDB          Hypothetical end-of-buffer address
*                                   which is probably the real
*                                   end-of-data to be moved.
* - - - - - - - - - -      Load the card quantities
         MVC   SAVEBEGC,FLDSCARD    Save "start of card" address
         MVC   SAVEENDC,FLDECARD    Save "end of card" address
         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved
         L     R7,FLDSCARD          Point to beginning of card
         A     R7,FLDOFFST          Add OFFSET to start of output
         ST    R7,SAVEBEGO          Save where output starts
         L     R8,SAVEBEGO          Copy beg of output address
         A     R8,FLDBYTES          Make hypothetical end address,
*                                   by adding the bytes to be moved.
         ST    R8,HYPOENDC          Store hypothetical card end address
*                                   (This may be way past end of card.)
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  Cases:  1.  Current move is to within the current card.        *
*              Covered by LOOPSHRT routine.                       *
*                                                                 *
*          2.  Current move is past the current card.             *
*              Covered by LOOPMORE routine.  So we have to do     *
*              iterations.                                        *
*                                                                 *
*        R6 always contains the number of bytes to be moved       *
*        for this segment.                                        *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
LOOPINIT DS    0H
         L     R7,SAVEBEGO          Beginning of CARD data
         L     R8,HYPOENDC          Hypothetical end of CARD data
         L     R3,FLDBUFFR          Prime R3 with start of buffer data
         C     R8,SAVEENDC          Is R8 past the end-of-card?
         BH    LOOPMORE             Yes. Do multiple moves and PUTs.
LOOPSHRT DS    0H                   No. Do the one move only.
         LR    R6,R8                Get byte count to move NOW.
         SR    R6,R7                Bytes to move from buffer to card
         C     R6,=F'80'            More than 80?
         BH    LOOPERR1             Yes. Has to be error, so flag it.
         BCTR  R6,0                 No. One less for EXECUTE.
         EX    R6,MOVEBUFF          Move the data from buffer to card.
         LA    R6,1(,R6)            Restore count of bytes moved
         L     R1,FLDBYMVD          Increment
         AR    R1,R6                  total bytes moved.
         ST    R1,FLDBYMVD          Store it away for later.
         LA    R3,0(R6,R3)          Bop past beginning buffer address.
*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R3,HYPOENDB          Not equal to predicted end?
         BNE   LOOPERR2             Error, so flag it.
         ST    R3,FLDBUFFR          Return modified new buffer address.
         LR    R6,R8                Calculate new OFFSET -
         S     R6,FLDSCARD          Subtract beginning of card address
         ST    R6,FLDOFFST          Store the result as new OFFSET
* -- >
LOOPTS50 DS    0H
*                                   If OFFSET > X'4F', card is complete
         C     R6,=F'80'            Is the new offset exactly X'50'?
         BNE   LOOPNT50             No. Then current card not complete.
*                                   Yes. Then PUT out card and init it.
         S     R8,=F'80'            -80 bytes because new card PUT out
         ST    R10,SAVER10          Save register for safety
         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller
         L     R1,FLDSCARD          Load address of card
         MVC   WORKAREA(80),0(R1)   Move full card image to workarea
         TM    FLDREADF,X'01'       Is this a READ only run?
         BO    NOPUT001             Yes. Can't PUT to AWSOUT.
         PUT   (10),WORKAREA        PUT the card image to output file
NOPUT001 DS    0H
         L     R10,SAVER10          Restore R10
         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written
         L     R7,SAVEBEGC          Point to beginning address of card
         MVC   0(80,R7),ZEROCARD    Initialize card image for next move
         XR    R6,R6                Clear R6
         ST    R6,FLDOFFST          New offset is 0, not X'50'
LOOPNT50 DS    0H
* -- >
         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT
         S     R1,FLDBYMVD          And subtract bytes already moved
         ST    R1,FLDBYTOT          To show new total buffer byte count
*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         B     RETURN
*
LOOPMORE DS    0H                   Data move if more than one card
*
         L     R6,SAVEENDC          We're going past end-of-card
         SR    R6,R7                Subtract beg address of data
         C     R6,=F'80'            Still bigger than 80?
         BH    LOOPERR1             Yes. Has to be error.
         BCTR  R6,0                 Subtract one for EXECUTE
         EX    R6,MOVEBUFF          Move data into buffer
         LA    R6,1(,R6)            Restore byte count
         L     R1,FLDBYMVD          Increment
         AR    R1,R6                  total
         ST    R1,FLDBYMVD              bytes moved
         LA    R3,0(R6,R3)          Bop past data moved in buffer
*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R3,HYPOENDB          Test if past end of buffer
         BH    LOOPERR3             Yes. Has to be an error.
         ST    R3,FLDBUFFR          Re-point current buffer address.
         S     R8,=F'80'            -80 bytes because new card PUT out
         ST    R10,SAVER10          Save register for safety
         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller
         L     R1,FLDSCARD          Load address of card
         MVC   WORKAREA(80),0(R1)   Move full card image to workarea
         TM    FLDREADF,X'01'       Is this a READ only run?
         BO    NOPUT002             Yes. Then don't produce AWSOUT.
         PUT   (10),WORKAREA        PUT the card image to output file
NOPUT002 DS    0H
         L     R10,SAVER10          Restore R10
         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written
         L     R7,SAVEBEGC          Point to beginning address of card
         MVC   0(80,R7),ZEROCARD    Initialize card image for next move
*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R8,SAVEENDC          Is R8 within the card image end?
         BH    LOOPMORE             No. Do the LOOPMORE routine.
         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.
         SPACE 3
* ----------------------------------------------------------------- *
MOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>
* --------------------------------------------------------- *
LOOPERR1 DS    0H                   Error entry location
         MVC   LINE,LINE-1             **  Diagnostic  **
         MVC   LINE+1(9),=C'LOOPERR1 '
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR2 DS    0H                   Error entry location
         MVC   LINE,LINE-1             **  Diagnostic  **
         MVC   LINE+1(9),=C'LOOPERR2 '
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR3 DS    0H                   Error entry location
         MVC   LINE,LINE-1
         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
* --------------------------------------------------------- *
RETURN   DS    0H                   RETURN TO THE CALLER
         ST    R10,SAVER10          Save register for safety
         L     R10,SAVEPARM         Address of FLDAREA in caller
         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back
         L     R10,SAVER10          Restore R10
         L     R13,4(,R13)
         MVC   16(4,R13),=F'0'      Load Maximum Return Code
         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
* --------------------------------------------------------- *
* --------------------------------------------------------- *
* ---      S U B R O U T I N E S                        --- *
* --------------------------------------------------------- *
FLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently
*
         HEX   LINE+10,4,FLDSCARD
         HEX   LINE+20,4,FLDECARD
         HEX   LINE+30,4,FLDOFFST
         HEX   LINE+40,4,FLDBYTES
         HEX   LINE+50,4,FLDBYTOT
         HEX   LINE+60,4,FLDBYMVD
         HEX   LINE+70,4,FLDBUFFR
         HEX   LINE+80,4,FLDBSTRT
         HEX   LINE+90,7,FLDOUTCT
         HEX   LINE+106,1,FLDREADF
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
         BR    R9
* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *
FLDBLOCK CSECT
FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
FLDSCARD DC    F'0'         Start address of 80-byte card
FLDECARD DC    F'0'         End address of 80-byte card
FLDOFFST DC    F'0'         OFFSET of data in the card
FLDBYTES DC    F'0'         Number of bytes to be folded now
FLDBYTOT DC    F'0'         Batch total of bytes left to move
FLDBYMVD DC    F'0'         Number of bytes folded now
FLDBUFFR DC    F'0'         Current data start address
FLDBSTRT DC    F'0'         Original start data address
FLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records
FLDREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
FLDLENTH EQU   *-FLDAREA
*
FOLDEM   CSECT
WORKAREA DS    CL80                 Card image work area
         DC    CL4' '               Padding
         DC    C' '
LINE     DC    CL133' '             Output line
         DC    C' '
LINE2    DC    CL133' '             Second output line if needed
*
FF       EQU   X'FF'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEXSAVE  DS    3F                    Register save for HEX macro
SAVER04  DS    H                     Register save for HEX macro
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ZEROCARD DC    80X'00'
SAVEBEGO DC    F'0'                 Save beg address of card output
SAVEBEGC DC    F'0'                 Save beg address of card
SAVEENDC DC    F'0'                 Save end address of card
SAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address
HYPOENDC DC    F'0'                 Hypothetical end address after card
HYPOENDB DC    F'0'                 Calculated end of buffer address
SYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB
AWSOUTV  DC    V(AWSOUT)            Address of AWSOUT DCB
SYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here
AWOUTDCB DC    F'0'                 AWSOUT DCB address stored here
SAVER10  DC    F'0'
         END
