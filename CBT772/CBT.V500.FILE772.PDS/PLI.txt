./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00043-00043-00000-SEB
------------------------------------------------------------------------
Name:     PBRHELP
Type:     PLI
Purpose:  Use BRIF to display TSO command output under ISPF.
Requires: INCLUDE XTSOVAR
          ASM     XTSOVAR
          ASM     PBRHLPA
          PLI     PBRHLPR
Used by:  CLIST BRHELP
Comments:
------------------------------------------------------------------------
Name:     PBRHLPR
Type:     PLI
Purpose:  Use BRIF to display TSO command output under ISPF.
Requires: INCLUDE XTSOVAR
          ASM     XTSOVAR
          ASM     PBRHLPA
          PLI     PBRHELP
Used by:  CLIST BRHELP
Comments:
------------------------------------------------------------------------
Name:     PLICOMP
Type:     PLI
Purpose:  Compare two data sets.
Requires: INCLUDE DCLDCB (q.v.)
Used by:  CLIST COMP (q.v.)
Comments:
------------------------------------------------------------------------
Name:     PLIXXC
Type:     PLI
Purpose:  Do hex calculations.
Requires: INCLUDE XTSOVAR (q.v.)
          ASM XGET, XPUT, XTSOVAR
Used by:  CLIST HEXADD, HEXSUB, IPCSEQP, SBA
Comments:
------------------------------------------------------------------------
Name:     XDIS
Type:     PLI
Purpose:  Disassemble load module CSECTs.
Requires:
Used by:  CLIST COMPDIS (q.v.)
Comments:
------------------------------------------------------------------------
./ ADD NAME=PBRHELP  0100-07332-07332-0900-00064-00064-00000-SEB
 PBRHELP: Proc(PARM) options(main);

 Dcl PARM char(100) var;
 Dcl ISPLINK entry external options(assembler inter retcode);
 Dcl PBRHLPA entry external options(assembler inter retcode);
 Dcl (PLIRETV, Addr, Bin, Substr, Verify) builtin;
 Dcl PLIXOPT ext char(2) var init('NR');
 Dcl LINES (*) char(72) ctl;
 Dcl I fixed(31) bin;
 Dcl BRHELPLINE       fixed(31) bin static init(-1);

 Dcl 1 DIALOG_DATA,
       2 LINECOUNT fixed(31) bin,
       2 LINEARRAY ptr;

 %INCLUDE XTSOVAR;

 Fetch ISPLINK;

 BRHELPLINE = GET_LAST_LINE();

 Allocate LINES (BRHELPLINE);

 Do I = 1 to BRHELPLINE;
  LINES(I) = GET_LINE(I);
 End;

 LINECOUNT = BRHELPLINE;
 LINEARRAY = Addr(LINES);

 Call ISPLINK ('BRIF ',
               'HELP_DATA ',
               'F ',
               Bin(72,31),
               PBRHLPA,
               ' ', /* cmd-routine */
               Addr(DIALOG_DATA),
               'BRHELP  ', /* panel name */
               ' ',        /* format name        */
               ' ');       /* no DBCS data       */

 Free LINES;



 GET_LAST_LINE: Proc returns(fixed(31) bin);
  Dcl BRHELPLINE_VALUE static char(10) var;
  Call XTSOVAR('R','BRHELPLINE',BRHELPLINE_VALUE);
  Return(BRHELPLINE_VALUE);
 End GET_LAST_LINE;

 GET_LINE: Proc(NUM) returns(char(72));
  Dcl NUM fixed(31) bin;
  Dcl CNUM static char(11);
  Dcl THE_LINE static char(72) var;
  Put string(CNUM) edit(NUM) (X(1),P'ZZZZZZZZZ9');
  CNUM = Substr(CNUM,Verify(CNUM,' '));
  Call XTSOVAR('R','SYSOUTLINE'||CNUM,THE_LINE);
  Return(THE_LINE);
 End GET_LINE;

 End PBRHELP;


./ ADD NAME=PBRHLPR  0100-07332-07332-0900-00043-00043-00000-SEB

 PBRHLPR: Proc (PDATA, /* pointer to output from read rte */
                LDATA, /* length if RECFM = V... or U */
                RRNUM, /* relative record number */
                PDDAT) /* dialog data area address */
         options(fortran /* retcode is invalid with fortran */)
         returns(fixed(31) bin);

 Dcl PDATA ptr,
     LDATA fixed(31) bin,
     RRNUM fixed(31) bin,
     PDDAT ptr;

 Dcl LINES(32767) char(72) based(LINEARRAY);

 Dcl 1 DIALOG_DATA based(PDDAT),
       2 LINECOUNT fixed(31) bin,
       2 LINEARRAY ptr;

 Dcl DATA_LINE        char(72) static;
 Dcl LAST_LINE        char(72) static init(
 '********************* END OF HELP DATA *****************************'
                                          );
 Dcl (ADDR, PLIRETC, VERIFY, SUBSTR) builtin;

 %INCLUDE XTSOVAR;

 If RRNUM > LINECOUNT then do;
  RRNUM = LINECOUNT;
  PDATA = ADDR(LINES(LINECOUNT));
  Call PLIRETC(8);
  Return(8);
 End;

 Else do;
  PDATA = Addr(LINES(RRNUM));
  Call PLIRETC(0);
  Return(0);
 End;


 End PBRHLPR;

./ ADD NAME=PLICOMP  0100-07332-07332-0900-00247-00247-00000-SEB
*PROCESS MACRO;
 PLICOMP: Proc(PARM) options(main);
 Dcl
          PARM                           char(100) var;
 Dcl
          RECORD_SIZE       (2)   static fixed(31) bin,
          LOOKASIDE_INDEX   (2)   static fixed(15) bin init(0),
          LOOKASIDE_MAX     (2)   static fixed(15) bin init(0),
          START_COLUMN            static fixed(15) bin init(0),
          END_COLUMN              static fixed(15) bin init(0),
          MISMATCH_COUNT          static fixed(15) bin init(0),
          RECORD_LENGTH           static fixed(15) bin,
          COMPARE_LENGTH          static fixed(15) bin,
          (I,J,K)                 static fixed(15) bin;
 Dcl
          RECORD            (2)          char(256) var,
          SAVE_RECORD       (2)          char(256) var,
          MISMATCH          (2,*) ctl    char(256) var,
          LOOKASIDE         (2,*) ctl    char(256) var;
 Dcl
          (INDD1, INDD2)          file   record    input,
          INDD              (2)   file   variable  init(INDD1,INDD2),
          SYSPRINT                file   stream    output;
 Dcl
          PHYSICAL_EOF      (2)   static bit(1)    init((2)(1)'0'B),
          LOGICAL_EOF       (2)   static bit(1)    init((2)(1)'0'B),
          RECFM_V           (2)   static bit(1)    init((2)(1)'0'B),
          MATCH                   static bit(1)    init('0'B),
          INDDDCB           (2)   static ptr,
          REC_PTR                 static ptr,
          DCBPTR                  static ptr,
          UNMATCHED               static fixed dec init(0),
          RECNO                   static fixed dec init(0),
          RECNO_V                 static char(8)   var,
          RECNO_P                 static pic'ZZZZZZ9',
          RECNO_C                        char(7)   def RECNO_P,
          INPUT_REC                      char(256) based(REC_PTR);
 Dcl
          TRANSLATE_ARRAY   (16) static  char(16)
                     init('................',  /* 00 - 0F */
                          '................',  /* 10 - 1F */
                          '................',  /* 20 - 2F */
                          '................',  /* 30 - 3F */
                          ' ...........<(+|',  /* 40 - 4F */
                          '&.........!$*);^',  /* 50 - 5F */
                          '-/.........,%_>?',  /* 60 - 6F */
                          '.........`:#@''="', /* 70 - 7F */
                          '.abcdefghi......',  /* 80 - 8F */
                          '.jklmnopqr......',  /* 90 - 9F */
                          '.~stuvwxyz......',  /* A0 - AF */
                          '................',  /* B0 - BF */
                          '{ABCDEFGHI......',  /* C0 - CF */
                          '}JKLMNOPQR......',  /* D0 - DF */
                          '\.STUVWXYZ......',  /* E0 - EF */
                          '0123456789......'), /* F0 - FF */

          TRANS_TABLE                   char(256) def TRANSLATE_ARRAY;
 Dcl
          DCBADDR        external entry(file) returns(ptr),
          (Index,Length,Max,Min,Substr,Translate,Unspec,Verify)
                         builtin,
          PLIXOPT static external char(2) var init('NR');

 %INCLUDE SYSLIB(DCLDCB);

 On Endfile(INDD1) PHYSICAL_EOF(1) = '1'B;
 On Endfile(INDD2) PHYSICAL_EOF(2) = '1'B;

 Get string(PARM) list(START_COLUMN, END_COLUMN, MISMATCH_COUNT);

 Open file(INDD1) input, file(INDD2) input;

 Do I = 1 to 2;
   DCBPTR = DCBADDR(INDD(I));
   INDDDCB(I) = DCBPTR;
   RECORD_SIZE(I) = DCBLRECL;
   RECFM_V(I) = DCBRECL = DCBRECV;
 End;

 RECORD_LENGTH = Min(RECORD_SIZE(1),RECORD_SIZE(2));

 If START_COLUMN = 0 then START_COLUMN = 1;

 If END_COLUMN = 0 then
   COMPARE_LENGTH = RECORD_LENGTH - START_COLUMN + 1;
 Else
   COMPARE_LENGTH = Min(END_COLUMN,RECORD_LENGTH) - START_COLUMN + 1;

 If COMPARE_LENGTH < 0 then do;
   Put skip(1) list('Invalid parameters - column conflicts');
   Return;
 End;

 Put skip(1) list('...File compare begins...');

 Put edit('Record size of file 1 is:',RECORD_SIZE(1)) (R(FMT));
 Put edit('Record size of file 2 is:',RECORD_SIZE(2)) (R(FMT));
 Put edit('Compare length is:       ',COMPARE_LENGTH) (R(FMT));
 Put skip(1);

 FMT: Format(Skip,A(25),P'ZZZZZ9');

 If MISMATCH_COUNT ^= 0 then do;
   Allocate MISMATCH(2,MISMATCH_COUNT);
   Allocate LOOKASIDE(2,MISMATCH_COUNT);
 End;

 LOOP:  Do until (LOGICAL_EOF(1) | LOGICAL_EOF(2)) ;

   Call GET_RECORD(1);
   Call GET_RECORD(2);

   If LOGICAL_EOF(1) & LOGICAL_EOF(2) then Leave LOOP;
   IF LOGICAL_EOF(1) then do;
     Put skip(2) list('More records on file 2 than file 1');
     Do until (LOGICAL_EOF(2));
       Put skip(1) list(Translate(RECORD(2),TRANS_TABLE));
       Call GET_RECORD (2);
     End;
     Leave LOOP;
   End;
   IF LOGICAL_EOF(2) then do;
     Put skip(2) list('More records on file 1 than file 2');
     Do until (LOGICAL_EOF(1));
       Put skip(1) list(Translate(RECORD(1),TRANS_TABLE));
       Call GET_RECORD (1);
     End;
     Leave LOOP;
   End;
   RECNO = RECNO + 1;
   MATCH = '0'B;
   If RECORD(1) ^= RECORD(2) then do;
     SAVE_RECORD(1) = RECORD(1);
     SAVE_RECORD(2) = RECORD(2);
     If MISMATCH_COUNT ^= 0 then do;
       Do I = 1 to MISMATCH_COUNT until (LOGICAL_EOF(1) | MATCH);
         Call GET_RECORD (1);
         MISMATCH(1,I) = RECORD(1);
         If RECORD(1) = RECORD(2) & ^ LOGICAL_EOF(1) then
           MATCH = '1'B;
       End;
       If ^ MATCH then do;
         LOOKASIDE_MAX(1) = I-1;
         Do K = 1 to LOOKASIDE_MAX(1);
           LOOKASIDE(1,K) = MISMATCH(1,K);
         End;
         LOOKASIDE_INDEX(1) = 1;
         LOGICAL_EOF(1) = '0'B;
         RECORD(1) = SAVE_RECORD(1);
         Do I = 1 to MISMATCH_COUNT until (LOGICAL_EOF(2) | MATCH);
           Call GET_RECORD (2);
           MISMATCH(2,I) = RECORD(2);
           If RECORD(1) = RECORD(2) & ^LOGICAL_EOF(2) then
             MATCH = '1'B;
         End;
         If ^ MATCH then do;
           LOOKASIDE_MAX(2) = I-1;
           Do K = 1 to LOOKASIDE_MAX(2);
             LOOKASIDE(2,K) = MISMATCH(2,K);
           End;
           LOOKASIDE_INDEX(2) = 1;
           LOGICAL_EOF(2) = '0'B;
           RECORD(2) = SAVE_RECORD(2);
           RECNO_P = RECNO;
           RECNO_V = Substr(RECNO_C,Verify(RECNO_C,' '));
           Put skip(2)
               list('Record number '||RECNO_V||' unmatched...');
           Put skip list (Translate(RECORD(1),TRANS_TABLE));
           Put skip list (Translate(RECORD(2),TRANS_TABLE));
           UNMATCHED = UNMATCHED + 1;
         End;
         Else do;
           Put skip(2) list('Records not in file 1 found in file 2');
           Put skip(1) list(Translate(SAVE_RECORD(2),TRANS_TABLE));
           Do J = 1 to I-1;
             Put skip(1)
                 list(Translate(MISMATCH(2,J),TRANS_TABLE));
           End;
         End;
       End;
       Else do;
         Put skip(2) list('Records found in file 1 but not file 2');
         Put skip(1) list(Translate(SAVE_RECORD(1),TRANS_TABLE));
         Do J = 1 to I-1;
           Put skip(1)
               list(Translate(MISMATCH(1,J),TRANS_TABLE));
         End;
       End;
     End;
     Else do;
       RECNO_P = RECNO;
       RECNO_V = Substr(RECNO_C,Verify(RECNO_C,' '));
       Put skip(2) list('Record number '||RECNO_V||' unmatched...');
       Put skip list (Translate(RECORD(1),TRANS_TABLE));
       Put skip list (Translate(RECORD(2),TRANS_TABLE));
       UNMATCHED = UNMATCHED + 1;
     End;
   End;

 End LOOP;

 Close file(INDD1), file(INDD2);

 Put skip(2) edit('Total records read........',RECNO)
                 (A,P'ZZZZZ9');

 Put skip(1) edit('Total unmatched records...',UNMATCHED)
                 (A,P'ZZZZZ9');

 /*******************************************************************/

 GET_RECORD: Proc (N);

 Dcl N fixed(15) bin,
     L fixed(15) bin;

 If LOOKASIDE_MAX(N) ^= 0 then do;

   RECORD(N) = LOOKASIDE(N,LOOKASIDE_INDEX(N));
   LOOKASIDE_INDEX(N) = LOOKASIDE_INDEX(N) + 1;
   If LOOKASIDE_INDEX(N) > LOOKASIDE_MAX(N) then do;
     LOOKASIDE_INDEX(N) = 0;
     LOOKASIDE_MAX(N) = 0;
   End;

 End;

 Else do;

   If ^ PHYSICAL_EOF(N) then Read file(INDD(N)) set(REC_PTR);

   If PHYSICAL_EOF(N) then LOGICAL_EOF(N) = '1'B;
   Else do;
     LOGICAL_EOF(N) = '0'B;
     If RECFM_V(N) then
       L = Max(0,
           Min(INDDDCB(N)->DCBLRECL-START_COLUMN+1-4,COMPARE_LENGTH));
     Else
       L = COMPARE_LENGTH;
     RECORD(N) = Substr(INPUT_REC,START_COLUMN,L);
   End;

 End;

 End GET_RECORD;

 End PLICOMP;
./ ADD NAME=PLIXXC   0100-07332-07332-0900-00371-00371-00000-SEB
*PROCESS OPT(TIME);
 /* PLIXXC: Program to do hex calculations */

 /* Note: E-level diagnostics will occur due to overlay defining. */

 PLIXXC:Proc(PARM) options(Main) reorder;

 Dcl
   PARM                        char(100) var,
   EXPRESSION           static char(100)    ,
   (VALUE1,VALUE2)      static fixed(31) bin init( 0  ),
   OPERATOR             static char  (3) var init(''  ) ,
   RESULT               static fixed(31) bin init( 0  ),
   CHAR_RESULT          static char (16) var init(''  ),
   BAD                  static bit   (1)     init('0'B),
   DECIMAL_INPUT        static bit   (1)     init('0'B),
   SYSDVAL_MUST_BE_SET  static bit   (1)     init('0'B),
   EFFBITS    (12)      static bit   (8)     init('11111010'B,
                                                  '11111011'B,
                                                  '11111100'B,
                                                  '11111101'B,
                                                  '11111110'B,
                                                  '11111111'B,
                                                  '11111010'B,
                                                  '11111011'B,
                                                  '11111100'B,
                                                  '11111101'B,
                                                  '11111110'B,
                                                  '11111111'B),
   EFFS         char(12) def EFFBITS,
   FAFBFCFDFEFF char (6) def EFFBITS;

 Dcl
   XGET        external entry(char(*), fixed(15) bin)
                                                 options(Asm Inter),
   XPUT        external entry(char(*) var)
                                                 options(Asm Inter),
   PLIXOPT     external char (2) var             init('NR');

 %INCLUDE XTSOVAR;

 Dcl
    (Length,Substr,Translate,Char,Verify,
     Mod,Unspec,Bool,Index,Null,Hbound)
      builtin;


 On Size begin;
   Call XPUT('Number is too large');
   BAD = '1'B;
 End;

 On Fixedoverflow begin;
   Call XPUT('Requested computation caused overflow');
   BAD = '1'B;
 End;

 On Overflow begin;  /* For exponentiation - uses floating point */
   Call XPUT('Requested computation caused overflow');
   BAD = '1'B;
 End;

 On Underflow begin;  /* For exponentiation - uses floating point */
   Call XPUT('Requested computation caused underflow');
   BAD = '1'B;
 End;

 On Zerodivide begin;
   Call XPUT('Division by zero is not possible');
   BAD = '1'B;
 End;

 MAINLOOP:Do until (Length(PARM) > 0);
  AN_INVOCATION_OF_MAINLOOP: Do;
   BAD = '0'B;
   If Length(PARM) > 0 then do;
    If Substr(PARM,1,1) = '=' then do;
     EXPRESSION = Substr(PARM,2);
     SYSDVAL_MUST_BE_SET = '1'B;
    End;
    Else do;
     EXPRESSION = PARM;
     SYSDVAL_MUST_BE_SET = '0'B;
    End;
     If EXPRESSION = '?' then do;
      Call HELP_FOR_XXC;
     End;
   End;
   Else do;
     Call XPUT('Enter hex expression (? for help)');
     Call XGET(EXPRESSION,Length(EXPRESSION));
     EXPRESSION = Translate(EXPRESSION,
                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                  'abcdefghijklmnopqrstuvwxyz');
     If EXPRESSION = '?' then do;
       Call HELP_FOR_XXC;
       Leave AN_INVOCATION_OF_MAINLOOP;
     End;
     If EXPRESSION = '' | EXPRESSION = 'END' then do;
       If ^ SYSDVAL_MUST_BE_SET then Call XPUT('End of program');
       Leave MAINLOOP;
     End;
     Select (EXPRESSION);
       When ('','END') do;
         If ^ SYSDVAL_MUST_BE_SET then
          Call XPUT('End of program');
         Else Call XPUT('No operand specified');
         Leave MAINLOOP;
       End;
       When ('N') do;
         CHAR_RESULT = RESULT;
         CHAR_RESULT = Substr(CHAR_RESULT,Verify(CHAR_RESULT,' '));
         If ^ SYSDVAL_MUST_BE_SET then
          Call XPUT('Decimal: '||CHAR_RESULT);
         Else Call SET_SYSDVAL(CHAR_RESULT);
         Leave AN_INVOCATION_OF_MAINLOOP;
       End;
       Otherwise;
     End;
   End;

   VALUE1 = HEXIN(GETVALUE(' +-*/|&'));
   If BAD then Leave AN_INVOCATION_OF_MAINLOOP;

   OPERATOR = GETVALUE(' 0123456789ABCDEF');

   If OPERATOR ^= '' then do;
     VALUE2 = HEXIN(GETVALUE(' +-*/|&'));
     If BAD then Leave AN_INVOCATION_OF_MAINLOOP;
   End;

   If GETVALUE(' ') ^= '' then do;
     If OPERATOR = '' then
       Call XPUT ('Missing operator');
     Else
       Call XPUT ('Too many operands');
     If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL ('');
     Leave AN_INVOCATION_OF_MAINLOOP;
   End;

   Select (Char(OPERATOR,3));
     When ('   ') do;
       RESULT = VALUE1;
       If DECIMAL_INPUT then do;
         CHAR_RESULT = HEXOUT(RESULT);
         If ^ SYSDVAL_MUST_BE_SET then
          Call XPUT ('Hex: '||CHAR_RESULT);
       End;
       Else do;
         CHAR_RESULT = RESULT;
         CHAR_RESULT = Substr(CHAR_RESULT,Verify(CHAR_RESULT,' '));
         If ^ SYSDVAL_MUST_BE_SET then
          Call XPUT('Decimal: '||CHAR_RESULT);
       End;
       If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL(CHAR_RESULT);
       Leave AN_INVOCATION_OF_MAINLOOP;
     End;
     When ('+  ') RESULT = VALUE1 + VALUE2;
     When ('-  ') RESULT = VALUE1 - VALUE2;
     When ('*  ') RESULT = VALUE1 * VALUE2;
     When ('/  ') RESULT = VALUE1 / VALUE2;
     When ('** ') RESULT = VALUE1 ** VALUE2;
     When ('// ') RESULT = Mod(VALUE1,VALUE2);
     When ('|  ') Unspec(RESULT) = Unspec(VALUE1) | Unspec(VALUE2);
     When ('&  ') Unspec(RESULT) = Unspec(VALUE1) & Unspec(VALUE2);
     When ('&& ') Unspec(RESULT) =
      Bool(Unspec(VALUE1),Unspec(VALUE2),'0110'B); /* Exclusive OR */
     Otherwise do;
       Call XPUT ('Invalid expression');
       If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL ('');
       Leave AN_INVOCATION_OF_MAINLOOP;
     End;
   End;

   If BAD then do;
    If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL ('');
    Leave AN_INVOCATION_OF_MAINLOOP;
   End;

   CHAR_RESULT = HEXOUT(RESULT);
   If SYSDVAL_MUST_BE_SET then Call SET_SYSDVAL (CHAR_RESULT);
   Else Call XPUT (HEXOUT(VALUE1)||' '||OPERATOR||' '||
                   HEXOUT(VALUE2)||' = '|| CHAR_RESULT);

  End AN_INVOCATION_OF_MAINLOOP;
 End MAINLOOP;

 Return;


 /********************************************************************/

 %PAGE;

 GETVALUE: Proc(DELIMS) returns(char(16) var) reorder;

 /* This subroutine extracts the next character value from the
    input expression and removes it from the expression.    */
 /* Note: This function has side effects!!! */

 Dcl DELIMS  char(*) var,
     I,J     fixed(15) bin,
     NEWEXPR char(16) var;

 I = Verify(EXPRESSION,' '); /* point to first nonblank character */
 If I = 0 then
   Return('');   /* return null string if no nonblanks */
 EXPRESSION = Substr(EXPRESSION,I);      /* delete leading blanks */
 If Length(DELIMS) = 1 then
   J = Index(EXPRESSION||DELIMS,DELIMS); /* scan for delimiting char */
 Else
   Do J = 1 to Length(EXPRESSION)        /* scan for delimiting char */
      while (Index(DELIMS,Substr(EXPRESSION,J,1)) = 0);
 End;
 NEWEXPR = Substr(EXPRESSION,1,J-1); /* extract character string */
 If J > Length(EXPRESSION) then EXPRESSION = '';
 Else
   EXPRESSION = Substr(EXPRESSION,J);  /* delete it from expression */

 Return(NEWEXPR);

 End GETVALUE;

 /********************************************************************/

 %PAGE;

   SET_SYSDVAL: Proc (OUTPUT_VALUE);

   Dcl OUTPUT_VALUE char(*) var;

    Call XTSOVAR  ('W','SYSDVAL',OUTPUT_VALUE);

   End SET_SYSDVAL;

 /********************************************************************/

 %PAGE;

   HELP_FOR_XXC: Proc;

    Dcl I fixed(15) bin static init(0);

    Dcl
        HELP_MESSAGES (30) char (72) var static init(
 ' ',
 ' XXC - Hex converter/calculator program',
 ' ',
 '       The following entries are valid:',
 ' ',
 '       (null entry) terminates this program',
 '       END     ...  terminates this program',
 '       ?       ...  produces this help display',
 '       hhh     ...  a hex number (1-8 characters) to be converted',
 '                    to decimal',
 '       dddN    ...  a decimal number (no sign permitted) to be',
 '                    converted to hex',
 '       N       ...  (the single letter N) converts the last',
 '                    result displayed to decimal',
 '       x op y  ...  a simple expression where:',
 '                      x is a number of the form hhh or dddN',
 '                      y is a number of the form hhh or dddN',
 '                      op is one of the following:',
 '                         +    ...  addition',
 '                         -    ...  subtraction',
 '                         *    ...  multiplication',
 '                         /    ...  division',
 '                         **   ...  exponentiation',
 '                         //   ...  remainder',
 '                         |    ...  bitwise OR',
 '                         &    ...  bitwise AND',
 '                         &&   ...  bitwise EXCLUSIVE OR',
 ' ',
 '       All operations take place on fixed-point fullword integers.',
 ' '
                                                   );
    Do I = 1 to Hbound(HELP_MESSAGES,1);

     Call XPUT(HELP_MESSAGES(I));

    End;

   End HELP_FOR_XXC;

 /********************************************************************/

 %PAGE;

 HEXIN: Proc (EXPR) returns(fixed(31) bin) reorder;

 /* This subroutine takes a character string consisting of hex
    character representations and returns a binary fullword
    containing the hexadecimal data. */

 Dcl
    EXPR                char(*) var,
    CHAREXPR9    static pic '(9)9',
    CHAREXPRX           char  (8)     def CHAREXPR9,
    BITPACKED    static fixed (9) dec,
    BITWORD      unal   fixed(31) bin def BITPACKED,
    L            static fixed(15) bin;

 L = Length(EXPR);
 BAD, DECIMAL_INPUT = '0'B;

 If L = 0 then do;
   Call XPUT('Missing value');
   BAD = '1'B;
   Return(0);
 End;

 If Substr(EXPR,L,1) = 'N' then do;
   If L < 2 | L > 11 |
    Verify(Substr(EXPR,1,L-1),'0123456789') ^= 0 then do;
     Call XPUT('Invalid value');
     BAD = '1'B;
     Return(0);
   End;
   DECIMAL_INPUT = '1'B;
   (Size):Return (Substr(EXPR,1,L-1));
 End;

 If L > 8 then do;
   Call XPUT('Value too long');
   BAD = '1'B;
   Return(0);
 End;

 CHAREXPRX = '';
 Substr(CHAREXPRX,9-L,L) = EXPR;

 If Verify(CHAREXPRX,' 0123456789abcdefABCDEF') ^= 0 then do;
   Call XPUT('Invalid hex characters entered');
   BAD = '1'B;
   Return(0);
 End;

 CHAREXPRX = Translate(CHAREXPRX,EFFS,'abcdefABCDEF');

 BITPACKED = CHAREXPR9;

 Return(BITWORD);

 End HEXIN;

 /********************************************************************/

 %PAGE;

 HEXOUT:Proc(NUMBER) returns(char(8) var) reorder;

 /* This subroutine takes a binary fullword and returns the
    character representation of the hexadecimal data therein. */

 Dcl NUMBER               fixed(31) bin,
     PACKED_DATA   static fixed(9) dec,
     PACKED_FOUR_BYTES    fixed(31) bin unaligned def PACKED_DATA,
     HEXUNPACKED9  static pic '(9)9',
     HEXSTRING            char(8)   def HEXUNPACKED9;

 PACKED_FOUR_BYTES = NUMBER;
 HEXUNPACKED9 = PACKED_DATA;
 HEXSTRING = Translate(HEXSTRING,'ABCDEF',FAFBFCFDFEFF);

 Return(Substr(HEXSTRING,Verify(Substr(HEXSTRING,1,7)||' ','0')));

 End HEXOUT;

 /********************************************************************/

 End PLIXXC;
./ ADD NAME=XDIS     0100-07332-07332-0900-03254-03254-00000-SEB
*PROCESS OPT(TIME);
 XDIS: Proc (PARM) options(main) reorder; /* Disassembler for XA */

 /*******************************************************************/
 /*                                                                 */
 /* Copyright (c) 1988 The Charles Stark Draper Laboratory, Inc.    */
 /*                                                                 */
 /* This program is provided on an "as is" basis.  It may be freely */
 /* distributed as long as it is not offered for commercial sale,   */
 /* and as long as this copyright notice is included.               */
 /*                                                                 */
 /* Warning:  Use of this program on licensed object code from IBM  */
 /* or other software vendors may be subject to criminal or other   */
 /* penalties.  Consult your customer representative for the facts. */
 /*                                                                 */
 /*******************************************************************/


 /********************************************************************/
 /*                                                                  */
 /* Change activity:                                                 */
 /*                                                                  */
 /* 05/17/89 - Support for EXTRN + A(xxx+nnn) constant specs.        */
 /* 12/15/89 - Fixed bug with 0C4 with data at end of module.        */
 /* 12/19/89 - Handles complexly relocatable A(EXTRN2-EXTRN1) adcons.*/
 /* 12/26/89 - ESA support.                                          */
 /*                                                                  */
 /********************************************************************/

 Dcl
     PARM                               char(100) var;

 Dcl
     COPYRIGHT_NOTICE_AND_DISCLAIMER (9) char(64) static init(
   'Copyright (c) 1988 The Charles Stark Draper Laboratory, Inc.',
   '',
   'This program is provided on an "as is" basis.  It may be freely',
   'distributed as long as it is not offered for commercial sale,',
   'and as long as this copyright notice is included.',
   '',
   'Warning:  Use of this program on licensed object code from IBM',
   'or other software vendors may be subject to criminal or other',
   'penalties.  Consult your customer representative for the facts.'
                                              );

 Dcl
     LOAD_PTR                    static ptr       init(Null),
     CESD_PTR                    static ptr       init(Null),
     CONTROL_PTR                 static ptr       init(Null),
     RLD_PTR                     static ptr       init(Null),
     RLD_SUB_PTR                 static ptr       init(Null),
     TEXT_PTR                    static ptr       init(Null),
     TEMP_PTR                    static ptr       init(Null),
     END_PTR                     static ptr       init(Null),
     OP_PTR                      static ptr       init(Null),
     RETCODE                     static fixed(31) bin init(0),
     CSECT_OFFSET                static fixed(31) bin init(0),
     CSECT_LENGTH                static fixed(31) bin init(0),
     TEXT_MOVE_OFFSET            static fixed(31) bin init(0),
     TEXT_MOVE_SOURCE            static fixed(31) bin init(0),
     TEXT_MOVE_LENGTH            static fixed(31) bin init(0),
     BLOCK_LENGTH                static fixed(31) bin init(0),
     IOFF                        static fixed(31) bin,
     SAVE_IOFF                   static fixed(31) bin,
     ILEN                        static fixed(31) bin,
     I                           static fixed(31) bin,
     J                           static fixed(31) bin,
     K                           static fixed(31) bin,
     L                           static fixed(31) bin,
     PAGENUM                     static fixed(31) bin init(0),
     CESD_ESDID                  static fixed(15) bin init(0),
     ESDID                       static fixed(15) bin init(0),
     OP_INDEX                    static fixed(15) bin,
     OP_INDEX_LIMIT              static fixed(15) bin,
     1 MISC_FLAGS      unaligned static,
       2 DLOAD_EOF                      bit(1)    init('0'B),
       2 PUNCH                          bit(1)    init('0'B),
       2 TEXT                           bit(1)    init('0'B),
       2 LAST_TEXT                      bit(1)    init('0'B),
       2 MOVE_TEXT                      bit(1)    init('0'B),
       2 GOT_SEGTAB                     bit(1)    init('0'B),
       2 VALID_INST                     bit(1)    init('0'B),
       2 VALID_CHAIN                    bit(1)    init('0'B),
       2 RECOGNIZED_INST                bit(1)    init('0'B),
       2 XA_MODULE                      bit(1)    init('0'B),
       2 PRIVATE_CODE                   bit(1)    init('0'B),

     ESD_ID                      static char(4),
     ESD_ADDR                    static char(6),
     ESD_LEN                     static char(6),
     ESD_LDID                    static char(4),
     ESD_FLAGS                   static char(2),

     TYPE                        static char(1),
     CONDITION_CODE              static char(1)   init(' '),
     OPERATION                   static char(5),
     MNEMONIC_OPER               static char(5) var,
     MNEMONIC_STRING             static char(4)   init('    '),
     AMODE                       static char(3)   init('   '),
     RMODE                       static char(3)   init('   '),
     CSECT_NAME                  static char(8)   init(' '),
     CSECT_LABEL                 static char(8)   init(' '),
     NAME9                       static char(9)   init(' '),
     NAME                               char(8) def NAME9 pos(1),
     OPERANDS                    static char(64) var,
     IMAGE                       static char(64) var,
     TRANS_ARRAY (16) static char(16)   init((15)(16)' ',
                                             '0123456789ABCDEF'),
     TRANS_TABLE             char(256)  def TRANS_ARRAY,

     SYSDATE                     static char(6),
     TODAY                       static char(8),

 /********************************************************************
    The following are fields that may be modified by "get data"
    style specifications on the DISPARM file.  Meanings are:

     ESA = 'Y' / 'N'  ... whether to use the MVS/ESA instruction set
     XA  = 'Y' / 'N'  ... whether to use the MVS/XA instruction set
     SP1 = 'Y' / 'N'  ... whether to use the MVS/SP1.3 cross memory
                          and other new instructions
     VF  = 'Y' / 'N'  ... whether to use the 3090 Vector instructions
     ESD = 'Y' / 'N'  ... whether to print a listing of the composite
                          external symbol dictionary (CESD) entries
                          for the load module
     INCREMENT = number / 1000 ... sequence number increment for
                                   generated source records
     OPSCAN = number / 32 ... the maximum number of instructions to be
                          scanned in a pass through a section of code
                          to determine whether it consists of machine
                          instructions or data (this represents a
                          limit - scans are terminated by branch
                          instructions, relocatable address constants
                          or other known points in any case).

    The default values are the second alternatives shown above.

   *******************************************************************/

     ESA                         static char(1) init('N'),
     XA                          static char(1) init('N'),
     SP1                         static char(1) init('N'),
     VF                          static char(1) init('N'),
     ESD                         static char(1) init('N'),
     INCREMENT                   static fixed (7) dec init(1000),
     OPSCAN                      static fixed(31) bin init(32),

   /*Dummy based variables used as "templates" for data manipulation*/

     N                           based  fixed(31) bin,
     ADCON2                      based  fixed(15) bin,
     ADCON3                      based  bit(24),
     ADCON4                      based  fixed(31) bin,

   /* Tables which define MVS operation codes and their attributes  */

     OP_CODE_LOOKUP (0:255) static fixed(15) bin init(

   999,180,999,999,  1,  2,  3,  4,  5,  6,  7,172,173,170,  8,  9,
    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
    58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,171, 71, 72,
    73,181,999,999, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
    86,999,999,999,999,999,999, 87, 88, 89, 90, 91, 92, 93, 94, 95,
    96,999,999,999,999,999,999,999, 97, 98, 99,100,101,102,103,104,
   105,999,106,999,107,108,109,110,111,112,113,114,115,116,117,118,
   119,120,121,122,123,124,125,126,127,174,182,183,128,129,130,131,
   999,999,999,999,176,177,178,999,999,999,999,999,132,133,134,135,
   999,136,137,999,999,999,138,139,999,999,140,141,999,142,143,144,
   999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,
   999,145,146,147,148,149,150,151,999,166,167,168,152,153,154,155,
   999,999,999,999,179,169,999,999,175,999,999,999,999,999,999,999,
   156,157,158,159,999,999,999,999,160,161,162,163,164,165,999,999),


 /********************************************************************/
 /*                                                                  */
 /* OP_TABLE format is as follows:                                   */
 /*                                                                  */
 /*  OP_NAME - 5 characters - the assembler mnemonic (opcode).       */
 /*                                                                  */
 /*  OP_FORMAT - 3 characters - the instruction format (RR,RS,etc).  */
 /*                                                                  */
 /*  OP_AUX - 1 character - an index into a table of op codes for    */
 /*                         the extended op codes (B2, etc.).        */
 /*                         Note that OP_AUX is mutually exclusive   */
 /*                         with all the other fields.               */
 /*                                                                  */
 /*  OP_TYPE - 1 character - if not blank, means the following:      */
 /*                                                                  */
 /*            "B" - this is a branch instruction with special       */
 /*                  mnemonics based on condition code (BC, BCR).    */
 /*                                                                  */
 /*            "C" - the immediate data in the instruction is        */
 /*                  probably character data and should be           */
 /*                  formatted as such (e.g. for MVI and CLI).       */
 /*                                                                  */
 /*            "P" - privileged instruction                          */
 /*                  or                                              */
 /*                  semiprivileged instruction                      */
 /*                                                                  */
 /*  OP_CC   - 1 character - what the instruction does to the        */
 /*                          condition code.  This is used to        */
 /*                          determine what mnemonic to use when     */
 /*                          disassembling a subsequent BC or BCR.   */
 /*                                                                  */
 /*           blank - no effect on condition code.                   */
 /*                                                                  */
 /*            "A" - arithmetic (BZ, BM, BP, BO)                     */
 /*                                                                  */
 /*            "C" - comparison (BE, BL, BH)                         */
 /*                                                                  */
 /*            "D" - affects the condition code but no mnemonics     */
 /*                  are defined.  Includes instructions like BAL    */
 /*                  which go off and cause random code to execute.  */
 /*                                                                  */
 /*            "Z" - zero/nonzero (BZ)                               */
 /*                                                                  */
 /*                                                                  */
 /*  OP_SPEC - 1 character - additional information determining if   */
 /*                          this is a valid op code.  If this is    */
 /*                          non-blank, certain fields of the        */
 /*                          instruction are checked for values      */
 /*                          which they must contain for it to be    */
 /*                          valid - otherwise it must be data.      */
 /*                                                                  */
 /* The following conventions apply herein for nibble descriptions:  */
 /*                                                                  */
 /* . - any value from 0-F is valid.                                 */
 /* 0 - the nibble must contain 0.                                   */
 /* E - the nibble must be even.                                     */
 /* D - the nibble must contain 0, 2, 4, or 6 (floating-point reg).  */
 /* Q - the nibble must contain 0 or 4 (extended-precision float).   */
 /*                                                                  */
 /*                                                                  */
 /*   "C" - ..0.....  MC                                             */
 /*   "D" - ..QQ      AXR, etc.                                      */
 /*   "E" - ..DD      ADR, etc.                                      */
 /*   "F" - ..D.....  AD, etc.                                       */
 /*   "G" - ..Q.....  MXD                                            */
 /*   "H" - ..QD      MXDR                                           */
 /*   "L" - ..EE....  MVCL, CLCL, CDS                                */
 /*   "M" - ..E.....  MR, DR, M, D                                   */
 /*   "N" - ....0000  IPK, PTLB, CSCH, HSCH, SAL, RSCH, RCHP, etc.   */
 /*   "S" - ..00....  SSM, LPSW, TS, TCH                             */
 /*   "X" - ....00.0  IAC, SSAR, EPAR, ESAR, MSTA                    */
 /*   "Y" - ....00..  IPTE, IPM, IVSK, PT, ISKE, RRBE, SSKE, etc.    */
 /*   "1" - ...0....  SPM, SRL, SLL, SRA, SLA                        */
 /*   "2" - ..E0....  SRDL, SLDL, SRDA, SLDA                         */
 /*                                                                  */
 /********************************************************************/

   1 OP_TABLE      based(OP_PTR),
     2 OP_NAME     char(5),
     2 OP_FORMAT   char(3),
     2 OP_AUX      char(1),
     2 OP_TYPE     char(1),
     2 OP_CC       char(1),
     2 OP_SPEC     char(1),

   1 OP_TABLE_ENTRIES static,
     2 OP_TABLE001 char(12) init('SPM  SPM   1'),
     2 OP_TABLE002 char(12) init('BALR RR   D '),
     2 OP_TABLE003 char(12) init('BCTR RR     '),
     2 OP_TABLE004 char(12) init('BCR  RR  B  '),
     2 OP_TABLE005 char(12) init('SSK  RR  P  '),
     2 OP_TABLE006 char(12) init('ISK  RR  P  '),
     2 OP_TABLE007 char(12) init('SVC  I      '),
     2 OP_TABLE008 char(12) init('MVCL RR   CL'),
     2 OP_TABLE009 char(12) init('CLCL RR   CL'),
     2 OP_TABLE010 char(12) init('LPR  RR   A '),
     2 OP_TABLE011 char(12) init('LNR  RR   A '),
     2 OP_TABLE012 char(12) init('LTR  RR   A '),
     2 OP_TABLE013 char(12) init('LCR  RR   A '),
     2 OP_TABLE014 char(12) init('NR   RR   Z '),
     2 OP_TABLE015 char(12) init('CLR  RR   C '),
     2 OP_TABLE016 char(12) init('OR   RR   Z '),
     2 OP_TABLE017 char(12) init('XR   RR   Z '),
     2 OP_TABLE018 char(12) init('LR   RR     '),
     2 OP_TABLE019 char(12) init('CR   RR   C '),
     2 OP_TABLE020 char(12) init('AR   RR   A '),
     2 OP_TABLE021 char(12) init('SR   RR   A '),
     2 OP_TABLE022 char(12) init('MR   RR    M'),
     2 OP_TABLE023 char(12) init('DR   RR    M'),
     2 OP_TABLE024 char(12) init('ALR  RR   D '),
     2 OP_TABLE025 char(12) init('SLR  RR   D '),
     2 OP_TABLE026 char(12) init('LPDR RR  FAE'),
     2 OP_TABLE027 char(12) init('LNDR RR  FAE'),
     2 OP_TABLE028 char(12) init('LTDR RR  FAE'),
     2 OP_TABLE029 char(12) init('LCDR RR  FAE'),
     2 OP_TABLE030 char(12) init('HDR  RR  F E'),
     2 OP_TABLE031 char(12) init('LRDR RR  F E'),
     2 OP_TABLE032 char(12) init('MXR  RR  F D'),
     2 OP_TABLE033 char(12) init('MXDR RR  F H'),
     2 OP_TABLE034 char(12) init('LDR  RR  F E'),
     2 OP_TABLE035 char(12) init('CDR  RR  FCE'),
     2 OP_TABLE036 char(12) init('ADR  RR  FAE'),
     2 OP_TABLE037 char(12) init('SDR  RR  FAE'),
     2 OP_TABLE038 char(12) init('MDR  RR  F E'),
     2 OP_TABLE039 char(12) init('DDR  RR  F E'),
     2 OP_TABLE040 char(12) init('AWR  RR  FAE'),
     2 OP_TABLE041 char(12) init('SWR  RR  FAE'),
     2 OP_TABLE042 char(12) init('LPER RR  FAE'),
     2 OP_TABLE043 char(12) init('LNER RR  FAE'),
     2 OP_TABLE044 char(12) init('LTER RR  FAE'),
     2 OP_TABLE045 char(12) init('LCER RR  FAE'),
     2 OP_TABLE046 char(12) init('HER  RR  F E'),
     2 OP_TABLE047 char(12) init('LRER RR  F E'),
     2 OP_TABLE048 char(12) init('AXR  RR  FAD'),
     2 OP_TABLE049 char(12) init('SXR  RR  FAD'),
     2 OP_TABLE050 char(12) init('LER  RR  F E'),
     2 OP_TABLE051 char(12) init('CER  RR  FCE'),
     2 OP_TABLE052 char(12) init('AER  RR  FAE'),
     2 OP_TABLE053 char(12) init('SER  RR  FAE'),
     2 OP_TABLE054 char(12) init('MER  RR  F E'),
     2 OP_TABLE055 char(12) init('DER  RR  F E'),
     2 OP_TABLE056 char(12) init('AUR  RR  FAE'),
     2 OP_TABLE057 char(12) init('SUR  RR  FAE'),
     2 OP_TABLE058 char(12) init('STH  RX     '),
     2 OP_TABLE059 char(12) init('LA   RX     '),
     2 OP_TABLE060 char(12) init('STC  RX     '),
     2 OP_TABLE061 char(12) init('IC   RX     '),
     2 OP_TABLE062 char(12) init('EX   RX   D '),
     2 OP_TABLE063 char(12) init('BAL  RX   D '),
     2 OP_TABLE064 char(12) init('BCT  RX     '),
     2 OP_TABLE065 char(12) init('BC   RX  B  '),
     2 OP_TABLE066 char(12) init('LH   RX     '),
     2 OP_TABLE067 char(12) init('CH   RX   C '),
     2 OP_TABLE068 char(12) init('AH   RX   A '),
     2 OP_TABLE069 char(12) init('SH   RX   A '),
     2 OP_TABLE070 char(12) init('MH   RX     '),
     2 OP_TABLE071 char(12) init('CVD  RX     '),
     2 OP_TABLE072 char(12) init('CVB  RX     '),
     2 OP_TABLE073 char(12) init('ST   RX     '),
     2 OP_TABLE074 char(12) init('N    RX   Z '),
     2 OP_TABLE075 char(12) init('CL   RX   C '),
     2 OP_TABLE076 char(12) init('O    RX   Z '),
     2 OP_TABLE077 char(12) init('X    RX   Z '),
     2 OP_TABLE078 char(12) init('L    RX     '),
     2 OP_TABLE079 char(12) init('C    RX   C '),
     2 OP_TABLE080 char(12) init('A    RX   A '),
     2 OP_TABLE081 char(12) init('S    RX   A '),
     2 OP_TABLE082 char(12) init('M    RX    M'),
     2 OP_TABLE083 char(12) init('D    RX    M'),
     2 OP_TABLE084 char(12) init('AL   RX   D '),
     2 OP_TABLE085 char(12) init('SL   RX   D '),
     2 OP_TABLE086 char(12) init('STD  RX  F F'),
     2 OP_TABLE087 char(12) init('MXD  RX  F G'),
     2 OP_TABLE088 char(12) init('LD   RX  F F'),
     2 OP_TABLE089 char(12) init('CD   RX  FCF'),
     2 OP_TABLE090 char(12) init('AD   RX  FAF'),
     2 OP_TABLE091 char(12) init('SD   RX  FAF'),
     2 OP_TABLE092 char(12) init('MD   RX  F F'),
     2 OP_TABLE093 char(12) init('DD   RX  F F'),
     2 OP_TABLE094 char(12) init('AW   RX  FAF'),
     2 OP_TABLE095 char(12) init('SW   RX  FAF'),
     2 OP_TABLE096 char(12) init('STE  RX  F F'),
     2 OP_TABLE097 char(12) init('LE   RX  F F'),
     2 OP_TABLE098 char(12) init('CE   RX  FCF'),
     2 OP_TABLE099 char(12) init('AE   RX  FAF'),
     2 OP_TABLE100 char(12) init('SE   RX  FAF'),
     2 OP_TABLE101 char(12) init('ME   RX  F F'),
     2 OP_TABLE102 char(12) init('DE   RX  F F'),
     2 OP_TABLE103 char(12) init('AU   RX  FAF'),
     2 OP_TABLE104 char(12) init('SU   RX  FAF'),
     2 OP_TABLE105 char(12) init('SSM  S   P S'),
     2 OP_TABLE106 char(12) init('LPSW S   PDS'),
     2 OP_TABLE107 char(12) init('WRD  SI  P  '),
     2 OP_TABLE108 char(12) init('RDD  SI  P  '),
     2 OP_TABLE109 char(12) init('BXH  RS     '),
     2 OP_TABLE110 char(12) init('BXLE RS     '),
     2 OP_TABLE111 char(12) init('SRL  RSS  A1'),
     2 OP_TABLE112 char(12) init('SLL  RSS  A1'),
     2 OP_TABLE113 char(12) init('SRA  RSS  A1'),
     2 OP_TABLE114 char(12) init('SLA  RSS  A1'),
     2 OP_TABLE115 char(12) init('SRDL RSS  A2'),
     2 OP_TABLE116 char(12) init('SLDL RSS  A2'),
     2 OP_TABLE117 char(12) init('SRDA RSS  A2'),
     2 OP_TABLE118 char(12) init('SLDA RSS  A2'),
     2 OP_TABLE119 char(12) init('STM  RS     '),
     2 OP_TABLE120 char(12) init('TM   SI   A '),
     2 OP_TABLE121 char(12) init('MVI  SI  C  '),
     2 OP_TABLE122 char(12) init('TS   S    DS'),
     2 OP_TABLE123 char(12) init('NI   SI   Z '),
     2 OP_TABLE124 char(12) init('CLI  SI  CC '),
     2 OP_TABLE125 char(12) init('OI   SI   Z '),
     2 OP_TABLE126 char(12) init('XI   SI   Z '),
     2 OP_TABLE127 char(12) init('LM   RS     '),
     2 OP_TABLE128 char(12) init('        1   '), /* 9Cxxxxxx */
     2 OP_TABLE129 char(12) init('        2   '), /* 9Dxxxxxx */
     2 OP_TABLE130 char(12) init('        3   '), /* 9Exxxxxx */
     2 OP_TABLE131 char(12) init('TCH  S   PDS'),
     2 OP_TABLE132 char(12) init('STNSMSI  P  '),
     2 OP_TABLE133 char(12) init('STOSMSI  P  '),
     2 OP_TABLE134 char(12) init('SIGP RS  PD '),
     2 OP_TABLE135 char(12) init('MC   SI    C'),
     2 OP_TABLE136 char(12) init('LRA  RX  PD '),
     2 OP_TABLE137 char(12) init('        4   '), /* B2xxxxxx */
     2 OP_TABLE138 char(12) init('STCTLRS  P  '),
     2 OP_TABLE139 char(12) init('LCTL RS  P  '),
     2 OP_TABLE140 char(12) init('CS   RS   D '),
     2 OP_TABLE141 char(12) init('CDS  RS   DL'),
     2 OP_TABLE142 char(12) init('CLM  RS   C '),
     2 OP_TABLE143 char(12) init('STCM RS     '),
     2 OP_TABLE144 char(12) init('ICM  RS   A '),
     2 OP_TABLE145 char(12) init('MVN  SS1    '),
     2 OP_TABLE146 char(12) init('MVC  SS1    '),
     2 OP_TABLE147 char(12) init('MVZ  SS1    '),
     2 OP_TABLE148 char(12) init('NC   SS1  Z '),
     2 OP_TABLE149 char(12) init('CLC  SS1  C '),
     2 OP_TABLE150 char(12) init('OC   SS1  Z '),
     2 OP_TABLE151 char(12) init('XC   SS1  Z '),
     2 OP_TABLE152 char(12) init('TR   SS1    '),
     2 OP_TABLE153 char(12) init('TRT  SS1  D '),
     2 OP_TABLE154 char(12) init('ED   SS1  A '),
     2 OP_TABLE155 char(12) init('EDMK SS1  A '),
     2 OP_TABLE156 char(12) init('SRP  SS3  A '),
     2 OP_TABLE157 char(12) init('MVO  SS2    '),
     2 OP_TABLE158 char(12) init('PACK SS2    '),
     2 OP_TABLE159 char(12) init('UNPK SS2    '),
     2 OP_TABLE160 char(12) init('ZAP  SS2  A '),
     2 OP_TABLE161 char(12) init('CP   SS2  C '),
     2 OP_TABLE162 char(12) init('AP   SS2  A '),
     2 OP_TABLE163 char(12) init('SP   SS2  A '),
     2 OP_TABLE164 char(12) init('MP   SS2    '),
     2 OP_TABLE165 char(12) init('DP   SS2    '),
     2 OP_TABLE166 char(12) init('MVCK SS4  D '),
     2 OP_TABLE167 char(12) init('MVCP SS4  D '),
     2 OP_TABLE168 char(12) init('MVCS SS4  D '),
     2 OP_TABLE169 char(12) init('        5   '), /* E5xxxxxxxxxx */
     2 OP_TABLE170 char(12) init('BASR RR     '),
     2 OP_TABLE171 char(12) init('BAS  RX     '),
     2 OP_TABLE172 char(12) init('BSM  RR   D '),
     2 OP_TABLE173 char(12) init('BASSMRR   D '),
     2 OP_TABLE174 char(12) init('TRACERS  P  '),
     2 OP_TABLE175 char(12) init('MVCINSS1    '),
     2 OP_TABLE176 char(12) init('        6   '), /* A4xxxxxx */
     2 OP_TABLE177 char(12) init('        7   '), /* A5xxxxxx */
     2 OP_TABLE178 char(12) init('        8   '), /* A6xxxxxx */
     2 OP_TABLE179 char(12) init('        9   '), /* E4xxxxxxxxxx */
     2 OP_TABLE180 char(12) init('        0   '), /* 01xx */
     2 OP_TABLE181 char(12) init('LAE  RX     '),
     2 OP_TABLE182 char(12) init('LAM  RS     '),
     2 OP_TABLE183 char(12) init('STAM RS     '),

   1 OP_TABLE0 (183) char(12) def OP_TABLE_ENTRIES,

   1 AUX_OP_ARRAY (0:255) char(12) based,

   1 AUX_OP_TABLE0_ENTRIES static, /* for op code 01 */
     2 AUX_OP0_TABLE00 char(12) init('            '),
     2 AUX_OP0_TABLE01 char(12) init('PR   N    D '),
     2 AUX_OP0_TABLE02 char(12) init('UPT  N    D '),

   1 AUX_OP_TABLE0 (0:2) char(12) def AUX_OP_TABLE0_ENTRIES,

   1 AUX_OP_TABLE1_ENTRIES static, /* for op code 9C */
     2 AUX_OP1_TABLE00  char(12) init('SIO  S   PD '),
     2 AUX_OP1_TABLE01  char(12) init('SIOF S   PD '),

   1 AUX_OP_TABLE1 (0:1) char(12) def AUX_OP_TABLE1_ENTRIES,

   1 AUX_OP_TABLE2_ENTRIES static, /* for op code 9D */
     2 AUX_OP1_TABLE00  char(12) init('TIO  S   PD '),
     2 AUX_OP1_TABLE01  char(12) init('CLRIOS   PD '),

   1 AUX_OP_TABLE2 (0:1) char(12) def AUX_OP_TABLE2_ENTRIES,

   1 AUX_OP_TABLE3_ENTRIES static, /* for op code 9E */
     2 AUX_OP1_TABLE00  char(12) init('HIO  S   PD '),
     2 AUX_OP1_TABLE01  char(12) init('HDV  S   PD '),

   1 AUX_OP_TABLE3 (0:1) char(12) def AUX_OP_TABLE3_ENTRIES,

   1 AUX_OP_TABLE4_ENTRIES static, /* for op code B2 */
     2 AUX_OP1_TABLE00  char(12) init('CONCSS   P  '),
     2 AUX_OP1_TABLE01  char(12) init('DISCSS   P  '),
     2 AUX_OP1_TABLE02  char(12) init('STIDPS   P  '),
     2 AUX_OP1_TABLE03  char(12) init('STIDCS   PD '),
     2 AUX_OP1_TABLE04  char(12) init('SCK  S   PD '),
     2 AUX_OP1_TABLE05  char(12) init('STCK S      '),
     2 AUX_OP1_TABLE06  char(12) init('SCKC S   P  '),
     2 AUX_OP1_TABLE07  char(12) init('STCKCS   P  '),
     2 AUX_OP1_TABLE08  char(12) init('SPT  S   P  '),
     2 AUX_OP1_TABLE09  char(12) init('STPT S   P  '),
     2 AUX_OP1_TABLE0A  char(12) init('SPKA S   P  '),
     2 AUX_OP1_TABLE0B  char(12) init('IPK  N   P N'),
     2 AUX_OP1_TABLE0C  char(12) init('            '),
     2 AUX_OP1_TABLE0D  char(12) init('PTLB N   P N'),
     2 AUX_OP1_TABLE0E  char(12) init('            '),
     2 AUX_OP1_TABLE0F  char(12) init('            '),
     2 AUX_OP1_TABLE10  char(12) init('SPX  S   P  '),
     2 AUX_OP1_TABLE11  char(12) init('STPX S   P  '),
     2 AUX_OP1_TABLE12  char(12) init('STAP S   P  '),
     2 AUX_OP1_TABLE13  char(12) init('RRB  S   PD '),
     2 AUX_OP1_TABLE14  char(12) init('            '),
     2 AUX_OP1_TABLE15  char(12) init('            '),
     2 AUX_OP1_TABLE16  char(12) init('            '),
     2 AUX_OP1_TABLE17  char(12) init('            '),
     2 AUX_OP1_TABLE18  char(12) init('PC   S      '),
     2 AUX_OP1_TABLE19  char(12) init('SAC  S      '),
     2 AUX_OP1_TABLE1A  char(12) init('CFC  S      '),
     2 AUX_OP1_TABLE1B  char(12) init('            '),
     2 AUX_OP1_TABLE1C  char(12) init('            '),
     2 AUX_OP1_TABLE1D  char(12) init('            '),
     2 AUX_OP1_TABLE1E  char(12) init('            '),
     2 AUX_OP1_TABLE1F  char(12) init('            '),
     2 AUX_OP1_TABLE20  char(12) init('            '),
     2 AUX_OP1_TABLE21  char(12) init('IPTE RR2   Y'),
     2 AUX_OP1_TABLE22  char(12) init('IPM  RR1   Y'),
     2 AUX_OP1_TABLE23  char(12) init('IVSK RR2   Y'),
     2 AUX_OP1_TABLE24  char(12) init('IAC  RR1  DX'),
     2 AUX_OP1_TABLE25  char(12) init('SSAR RR1   X'),
     2 AUX_OP1_TABLE26  char(12) init('EPAR RR1   X'),
     2 AUX_OP1_TABLE27  char(12) init('ESAR RR1   X'),
     2 AUX_OP1_TABLE28  char(12) init('PT   RR2   Y'),
     2 AUX_OP1_TABLE29  char(12) init('ISKE RR2   Y'),
     2 AUX_OP1_TABLE2A  char(12) init('RRBE RR2 PDY'),
     2 AUX_OP1_TABLE2B  char(12) init('SSKE RR2 P Y'),
     2 AUX_OP1_TABLE2C  char(12) init('TB   RR2 PDY'),
     2 AUX_OP1_TABLE2D  char(12) init('DXR  RR2 F Y'),
     2 AUX_OP1_TABLE2E  char(12) init('            '),
     2 AUX_OP1_TABLE2F  char(12) init('            '),
     2 AUX_OP1_TABLE30  char(12) init('CSCH N   PDN'),
     2 AUX_OP1_TABLE31  char(12) init('HSCH N   PDN'),
     2 AUX_OP1_TABLE32  char(12) init('MSCH S   PD '),
     2 AUX_OP1_TABLE33  char(12) init('SSCH S   PD '),
     2 AUX_OP1_TABLE34  char(12) init('STSCHS   PD '),
     2 AUX_OP1_TABLE35  char(12) init('TSCH S   PD '),
     2 AUX_OP1_TABLE36  char(12) init('TPI  S   PD '),
     2 AUX_OP1_TABLE37  char(12) init('SAL  N   P N'),
     2 AUX_OP1_TABLE38  char(12) init('RSCH N   PDN'),
     2 AUX_OP1_TABLE39  char(12) init('STCRWS   PD '),
     2 AUX_OP1_TABLE3A  char(12) init('STCPSS   P  '),
     2 AUX_OP1_TABLE3B  char(12) init('RCHP N   PDN'),
     2 AUX_OP1_TABLE3C  char(12) init('SCHM N   P N'),
     2 AUX_OP1_TABLE3D  char(12) init('            '),
     2 AUX_OP1_TABLE3E  char(12) init('            '),
     2 AUX_OP1_TABLE3F  char(12) init('            '),
     2 AUX_OP1_TABLE40  char(12) init('BAKR RR2  DY'),
     2 AUX_OP1_TABLE41  char(12) init('            '),
     2 AUX_OP1_TABLE42  char(12) init('            '),
     2 AUX_OP1_TABLE43  char(12) init('            '),
     2 AUX_OP1_TABLE44  char(12) init('            '),
     2 AUX_OP1_TABLE45  char(12) init('            '),
     2 AUX_OP1_TABLE46  char(12) init('STURARR2   Y'),
     2 AUX_OP1_TABLE47  char(12) init('MSTA RR1   X'),
     2 AUX_OP1_TABLE48  char(12) init('PALB N     N'),
     2 AUX_OP1_TABLE49  char(12) init('EREG RR2   Y'),
     2 AUX_OP1_TABLE4A  char(12) init('ESTA RR2  DY'),
     2 AUX_OP1_TABLE4B  char(12) init('LURA RR2   Y'),
     2 AUX_OP1_TABLE4C  char(12) init('TAR  RR2  DY'),
     2 AUX_OP1_TABLE4D  char(12) init('CPYA RR2   Y'),
     2 AUX_OP1_TABLE4E  char(12) init('SAR  RR2   Y'),
     2 AUX_OP1_TABLE4F  char(12) init('EAR  RR2   Y'),

   1 AUX_OP_TABLE4 (0:60) char(12) def AUX_OP_TABLE4_ENTRIES,

   1 AUX_OP_TABLE5_ENTRIES static, /* for op code E5 */
     2 AUX_OP5_TABLE00  char(12) init('LASP SSE PD '),
     2 AUX_OP5_TABLE01  char(12) init('TPROTSSE PD '),
     2 AUX_OP5_TABLE02  char(12) init('            '),
     2 AUX_OP5_TABLE03  char(12) init('            '),
     2 AUX_OP5_TABLE04  char(12) init('            '),
     2 AUX_OP5_TABLE05  char(12) init('            '),
     2 AUX_OP5_TABLE06  char(12) init('            '),
     2 AUX_OP5_TABLE07  char(12) init('            '),
     2 AUX_OP5_TABLE08  char(12) init('            '),
     2 AUX_OP5_TABLE09  char(12) init('            '),
     2 AUX_OP5_TABLE0A  char(12) init('            '),
     2 AUX_OP5_TABLE0B  char(12) init('            '),
     2 AUX_OP5_TABLE0C  char(12) init('            '),
     2 AUX_OP5_TABLE0D  char(12) init('            '),
     2 AUX_OP5_TABLE0E  char(12) init('MVCSKSSE    '),
     2 AUX_OP5_TABLE0F  char(12) init('MVCDKSSE    '),

   1 AUX_OP_TABLE5 (0:15) char(12) def AUX_OP_TABLE5_ENTRIES,

   1 AUX_OP_TABLE6_ENTRIES static, /* for op code A4 */
     2 AUX_OP6_TABLE00 char(12) init('VAE  VST    '),
     2 AUX_OP6_TABLE01 char(12) init('VSE  VST    '),
     2 AUX_OP6_TABLE02 char(12) init('VME  VST    '),
     2 AUX_OP6_TABLE03 char(12) init('VDE  VST    '),
     2 AUX_OP6_TABLE04 char(12) init('VMAE VST    '),
     2 AUX_OP6_TABLE05 char(12) init('VMSE VST    '),
     2 AUX_OP6_TABLE06 char(12) init('VMCE VST    '),
     2 AUX_OP6_TABLE07 char(12) init('VACE VS3    '),
     2 AUX_OP6_TABLE08 char(12) init('VCE  VST    '),
     2 AUX_OP6_TABLE09 char(12) init('VL   VS3    '),
     2 AUX_OP6_TABLE0A char(12) init('VLM  VS3    '), /* also VLME  */
     2 AUX_OP6_TABLE0B char(12) init('VLY  VS3    '), /* also VLYE  */
     2 AUX_OP6_TABLE0C char(12) init('            '),
     2 AUX_OP6_TABLE0D char(12) init('VST  VS3    '), /* also VSTE  */
     2 AUX_OP6_TABLE0E char(12) init('VSTM VS3    '), /* also VSTME */
     2 AUX_OP6_TABLE0F char(12) init('VSTK VS3    '), /* also VSTKE */
     2 AUX_OP6_TABLE10 char(12) init('VAD  VST    '),
     2 AUX_OP6_TABLE11 char(12) init('VSD  VST    '),
     2 AUX_OP6_TABLE12 char(12) init('VMD  VST    '),
     2 AUX_OP6_TABLE13 char(12) init('VDD  VST    '),
     2 AUX_OP6_TABLE14 char(12) init('VMAD VST    '),
     2 AUX_OP6_TABLE15 char(12) init('VMSD VST    '),
     2 AUX_OP6_TABLE16 char(12) init('VMCD VST    '),
     2 AUX_OP6_TABLE17 char(12) init('VACD VS3    '),
     2 AUX_OP6_TABLE18 char(12) init('VCD  VST    '),
     2 AUX_OP6_TABLE19 char(12) init('VLD  VS3    '),
     2 AUX_OP6_TABLE1A char(12) init('VLMD VS3    '),
     2 AUX_OP6_TABLE1B char(12) init('VLYD VS3    '),
     2 AUX_OP6_TABLE1C char(12) init('            '),
     2 AUX_OP6_TABLE1D char(12) init('VSTD VS3    '),
     2 AUX_OP6_TABLE1E char(12) init('VSTMDVS3    '),
     2 AUX_OP6_TABLE1F char(12) init('VSTKDVS3    '),
     2 AUX_OP6_TABLE20 char(12) init('VA   VST    '),
     2 AUX_OP6_TABLE21 char(12) init('VS   VST    '),
     2 AUX_OP6_TABLE22 char(12) init('VM   VST    '),
     2 AUX_OP6_TABLE23 char(12) init('            '),
     2 AUX_OP6_TABLE24 char(12) init('VN   VST    '),
     2 AUX_OP6_TABLE25 char(12) init('VO   VST    '),
     2 AUX_OP6_TABLE26 char(12) init('VX   VST    '),
     2 AUX_OP6_TABLE27 char(12) init('            '),
     2 AUX_OP6_TABLE28 char(12) init('VC   VST    '),
     2 AUX_OP6_TABLE29 char(12) init('VLH  VS3    '),
     2 AUX_OP6_TABLE2A char(12) init('VLINTVS3    '),
     2 AUX_OP6_TABLE2B char(12) init('            '),
     2 AUX_OP6_TABLE2C char(12) init('            '),
     2 AUX_OP6_TABLE2D char(12) init('VSTH VS3    '),
     2 AUX_OP6_TABLE2E char(12) init('            '),
     2 AUX_OP6_TABLE2F char(12) init('            '),
     2 AUX_OP6_TABLE30 char(12) init('            '),
     2 AUX_OP6_TABLE31 char(12) init('            '),
     2 AUX_OP6_TABLE32 char(12) init('            '),
     2 AUX_OP6_TABLE33 char(12) init('            '),
     2 AUX_OP6_TABLE34 char(12) init('            '),
     2 AUX_OP6_TABLE35 char(12) init('            '),
     2 AUX_OP6_TABLE36 char(12) init('            '),
     2 AUX_OP6_TABLE37 char(12) init('            '),
     2 AUX_OP6_TABLE38 char(12) init('            '),
     2 AUX_OP6_TABLE39 char(12) init('            '),
     2 AUX_OP6_TABLE3A char(12) init('            '),
     2 AUX_OP6_TABLE3B char(12) init('            '),
     2 AUX_OP6_TABLE3C char(12) init('            '),
     2 AUX_OP6_TABLE3D char(12) init('            '),
     2 AUX_OP6_TABLE3E char(12) init('            '),
     2 AUX_OP6_TABLE3F char(12) init('            '),
     2 AUX_OP6_TABLE40 char(12) init('            '),
     2 AUX_OP6_TABLE41 char(12) init('            '),
     2 AUX_OP6_TABLE42 char(12) init('            '),
     2 AUX_OP6_TABLE43 char(12) init('            '),
     2 AUX_OP6_TABLE44 char(12) init('            '),
     2 AUX_OP6_TABLE45 char(12) init('            '),
     2 AUX_OP6_TABLE46 char(12) init('            '),
     2 AUX_OP6_TABLE47 char(12) init('            '),
     2 AUX_OP6_TABLE48 char(12) init('            '),
     2 AUX_OP6_TABLE49 char(12) init('            '),
     2 AUX_OP6_TABLE4A char(12) init('            '),
     2 AUX_OP6_TABLE4B char(12) init('            '),
     2 AUX_OP6_TABLE4C char(12) init('            '),
     2 AUX_OP6_TABLE4D char(12) init('            '),
     2 AUX_OP6_TABLE4E char(12) init('            '),
     2 AUX_OP6_TABLE4F char(12) init('            '),
     2 AUX_OP6_TABLE50 char(12) init('            '),
     2 AUX_OP6_TABLE51 char(12) init('            '),
     2 AUX_OP6_TABLE52 char(12) init('            '),
     2 AUX_OP6_TABLE53 char(12) init('            '),
     2 AUX_OP6_TABLE54 char(12) init('            '),
     2 AUX_OP6_TABLE55 char(12) init('            '),
     2 AUX_OP6_TABLE56 char(12) init('            '),
     2 AUX_OP6_TABLE57 char(12) init('            '),
     2 AUX_OP6_TABLE58 char(12) init('            '),
     2 AUX_OP6_TABLE59 char(12) init('            '),
     2 AUX_OP6_TABLE5A char(12) init('            '),
     2 AUX_OP6_TABLE5B char(12) init('            '),
     2 AUX_OP6_TABLE5C char(12) init('            '),
     2 AUX_OP6_TABLE5D char(12) init('            '),
     2 AUX_OP6_TABLE5E char(12) init('            '),
     2 AUX_OP6_TABLE5F char(12) init('            '),
     2 AUX_OP6_TABLE60 char(12) init('            '),
     2 AUX_OP6_TABLE61 char(12) init('            '),
     2 AUX_OP6_TABLE62 char(12) init('            '),
     2 AUX_OP6_TABLE63 char(12) init('            '),
     2 AUX_OP6_TABLE64 char(12) init('            '),
     2 AUX_OP6_TABLE65 char(12) init('            '),
     2 AUX_OP6_TABLE66 char(12) init('            '),
     2 AUX_OP6_TABLE67 char(12) init('            '),
     2 AUX_OP6_TABLE68 char(12) init('            '),
     2 AUX_OP6_TABLE69 char(12) init('            '),
     2 AUX_OP6_TABLE6A char(12) init('            '),
     2 AUX_OP6_TABLE6B char(12) init('            '),
     2 AUX_OP6_TABLE6C char(12) init('            '),
     2 AUX_OP6_TABLE6D char(12) init('            '),
     2 AUX_OP6_TABLE6E char(12) init('            '),
     2 AUX_OP6_TABLE6F char(12) init('            '),
     2 AUX_OP6_TABLE70 char(12) init('            '),
     2 AUX_OP6_TABLE71 char(12) init('            '),
     2 AUX_OP6_TABLE72 char(12) init('            '),
     2 AUX_OP6_TABLE73 char(12) init('            '),
     2 AUX_OP6_TABLE74 char(12) init('            '),
     2 AUX_OP6_TABLE75 char(12) init('            '),
     2 AUX_OP6_TABLE76 char(12) init('            '),
     2 AUX_OP6_TABLE77 char(12) init('            '),
     2 AUX_OP6_TABLE78 char(12) init('            '),
     2 AUX_OP6_TABLE79 char(12) init('            '),
     2 AUX_OP6_TABLE7A char(12) init('            '),
     2 AUX_OP6_TABLE7B char(12) init('            '),
     2 AUX_OP6_TABLE7C char(12) init('            '),
     2 AUX_OP6_TABLE7D char(12) init('            '),
     2 AUX_OP6_TABLE7E char(12) init('            '),
     2 AUX_OP6_TABLE7F char(12) init('            '),
     2 AUX_OP6_TABLE80 char(12) init('VAES QST    '),
     2 AUX_OP6_TABLE81 char(12) init('VSES QST    '),
     2 AUX_OP6_TABLE82 char(12) init('VMES QST    '),
     2 AUX_OP6_TABLE83 char(12) init('VDES QST    '),
     2 AUX_OP6_TABLE84 char(12) init('VMAESQST    '),
     2 AUX_OP6_TABLE85 char(12) init('VMSESQST    '),
     2 AUX_OP6_TABLE86 char(12) init('            '),
     2 AUX_OP6_TABLE87 char(12) init('            '),
     2 AUX_OP6_TABLE88 char(12) init('VCES QST    '),
     2 AUX_OP6_TABLE89 char(12) init('            '),
     2 AUX_OP6_TABLE8A char(12) init('            '),
     2 AUX_OP6_TABLE8B char(12) init('            '),
     2 AUX_OP6_TABLE8C char(12) init('            '),
     2 AUX_OP6_TABLE8D char(12) init('            '),
     2 AUX_OP6_TABLE8E char(12) init('            '),
     2 AUX_OP6_TABLE8F char(12) init('            '),
     2 AUX_OP6_TABLE90 char(12) init('VADS QST    '),
     2 AUX_OP6_TABLE91 char(12) init('VSDS QST    '),
     2 AUX_OP6_TABLE92 char(12) init('VMDS QST    '),
     2 AUX_OP6_TABLE93 char(12) init('VDDS QST    '),
     2 AUX_OP6_TABLE94 char(12) init('VMADSQST    '),
     2 AUX_OP6_TABLE95 char(12) init('VMSDSQST    '),
     2 AUX_OP6_TABLE96 char(12) init('            '),
     2 AUX_OP6_TABLE97 char(12) init('            '),
     2 AUX_OP6_TABLE98 char(12) init('VCDS QST    '),
     2 AUX_OP6_TABLE99 char(12) init('            '),
     2 AUX_OP6_TABLE9A char(12) init('            '),
     2 AUX_OP6_TABLE9B char(12) init('            '),
     2 AUX_OP6_TABLE9C char(12) init('            '),
     2 AUX_OP6_TABLE9D char(12) init('            '),
     2 AUX_OP6_TABLE9E char(12) init('            '),
     2 AUX_OP6_TABLE9F char(12) init('            '),
     2 AUX_OP6_TABLEA0 char(12) init('VAS  QST    '),
     2 AUX_OP6_TABLEA1 char(12) init('VSS  QST    '),
     2 AUX_OP6_TABLEA2 char(12) init('VMS  QST    '),
     2 AUX_OP6_TABLEA3 char(12) init('            '),
     2 AUX_OP6_TABLEA4 char(12) init('VNS  QST    '),
     2 AUX_OP6_TABLEA5 char(12) init('VOS  QST    '),
     2 AUX_OP6_TABLEA6 char(12) init('VXS  QST    '),
     2 AUX_OP6_TABLEA7 char(12) init('            '),
     2 AUX_OP6_TABLEA8 char(12) init('VCS  QST    '),

   1 AUX_OP_TABLE6 (0:168) char(12) def AUX_OP_TABLE6_ENTRIES,

   1 AUX_OP_TABLE7_ENTRIES static, /* for op code A5 */
     2 AUX_OP7_TABLE00 char(12) init('VAER VV     '),
     2 AUX_OP7_TABLE01 char(12) init('VSER VV     '),
     2 AUX_OP7_TABLE02 char(12) init('VMER VV     '),
     2 AUX_OP7_TABLE03 char(12) init('VDER VV     '),
     2 AUX_OP7_TABLE04 char(12) init('            '),
     2 AUX_OP7_TABLE05 char(12) init('            '),
     2 AUX_OP7_TABLE06 char(12) init('VMCERVV     '),
     2 AUX_OP7_TABLE07 char(12) init('VACERVV2    '),
     2 AUX_OP7_TABLE08 char(12) init('VCER VV     '),
     2 AUX_OP7_TABLE09 char(12) init('VLR  VV2    '), /* also VLER  */
     2 AUX_OP7_TABLE0A char(12) init('VLMR VV2    '), /* also VLMER */
     2 AUX_OP7_TABLE0B char(12) init('VLZR VV1    '), /* also VLZER */
     2 AUX_OP7_TABLE0C char(12) init('            '),
     2 AUX_OP7_TABLE0D char(12) init('            '),
     2 AUX_OP7_TABLE0E char(12) init('            '),
     2 AUX_OP7_TABLE0F char(12) init('            '),
     2 AUX_OP7_TABLE10 char(12) init('VADR VV     '),
     2 AUX_OP7_TABLE11 char(12) init('VSDR VV     '),
     2 AUX_OP7_TABLE12 char(12) init('VMDR VV     '),
     2 AUX_OP7_TABLE13 char(12) init('VDDR VV     '),
     2 AUX_OP7_TABLE14 char(12) init('            '),
     2 AUX_OP7_TABLE15 char(12) init('            '),
     2 AUX_OP7_TABLE16 char(12) init('VMCDRVV     '),
     2 AUX_OP7_TABLE17 char(12) init('VACDRVV2    '),
     2 AUX_OP7_TABLE18 char(12) init('VCDR VV     '),
     2 AUX_OP7_TABLE19 char(12) init('VLDR VV2    '),
     2 AUX_OP7_TABLE1A char(12) init('VLMDRVV2    '),
     2 AUX_OP7_TABLE1B char(12) init('VLZDRVV1    '),
     2 AUX_OP7_TABLE1C char(12) init('            '),
     2 AUX_OP7_TABLE1D char(12) init('            '),
     2 AUX_OP7_TABLE1E char(12) init('            '),
     2 AUX_OP7_TABLE1F char(12) init('            '),
     2 AUX_OP7_TABLE20 char(12) init('VAR  VV     '),
     2 AUX_OP7_TABLE21 char(12) init('VSR  VV     '),
     2 AUX_OP7_TABLE22 char(12) init('VMR  VV     '),
     2 AUX_OP7_TABLE23 char(12) init('            '),
     2 AUX_OP7_TABLE24 char(12) init('VNR  VV     '),
     2 AUX_OP7_TABLE25 char(12) init('VOR  VV     '),
     2 AUX_OP7_TABLE26 char(12) init('VXR  VV     '),
     2 AUX_OP7_TABLE27 char(12) init('            '),
     2 AUX_OP7_TABLE28 char(12) init('VCR  VV     '),
     2 AUX_OP7_TABLE29 char(12) init('            '),
     2 AUX_OP7_TABLE2A char(12) init('            '),
     2 AUX_OP7_TABLE2B char(12) init('            '),
     2 AUX_OP7_TABLE2C char(12) init('            '),
     2 AUX_OP7_TABLE2D char(12) init('            '),
     2 AUX_OP7_TABLE2E char(12) init('            '),
     2 AUX_OP7_TABLE2F char(12) init('            '),
     2 AUX_OP7_TABLE30 char(12) init('            '),
     2 AUX_OP7_TABLE31 char(12) init('            '),
     2 AUX_OP7_TABLE32 char(12) init('            '),
     2 AUX_OP7_TABLE33 char(12) init('            '),
     2 AUX_OP7_TABLE34 char(12) init('            '),
     2 AUX_OP7_TABLE35 char(12) init('            '),
     2 AUX_OP7_TABLE36 char(12) init('            '),
     2 AUX_OP7_TABLE37 char(12) init('            '),
     2 AUX_OP7_TABLE38 char(12) init('            '),
     2 AUX_OP7_TABLE39 char(12) init('            '),
     2 AUX_OP7_TABLE3A char(12) init('            '),
     2 AUX_OP7_TABLE3B char(12) init('            '),
     2 AUX_OP7_TABLE3C char(12) init('            '),
     2 AUX_OP7_TABLE3D char(12) init('            '),
     2 AUX_OP7_TABLE3E char(12) init('            '),
     2 AUX_OP7_TABLE3F char(12) init('            '),
     2 AUX_OP7_TABLE40 char(12) init('VLPERVV2    '),
     2 AUX_OP7_TABLE41 char(12) init('VLNERVV2    '),
     2 AUX_OP7_TABLE42 char(12) init('VLCERVV2    '),
     2 AUX_OP7_TABLE43 char(12) init('            '),
     2 AUX_OP7_TABLE44 char(12) init('            '),
     2 AUX_OP7_TABLE45 char(12) init('            '),
     2 AUX_OP7_TABLE46 char(12) init('            '),
     2 AUX_OP7_TABLE47 char(12) init('            '),
     2 AUX_OP7_TABLE48 char(12) init('            '),
     2 AUX_OP7_TABLE49 char(12) init('            '),
     2 AUX_OP7_TABLE4A char(12) init('            '),
     2 AUX_OP7_TABLE4B char(12) init('            '),
     2 AUX_OP7_TABLE4C char(12) init('            '),
     2 AUX_OP7_TABLE4D char(12) init('            '),
     2 AUX_OP7_TABLE4E char(12) init('            '),
     2 AUX_OP7_TABLE4F char(12) init('            '),
     2 AUX_OP7_TABLE50 char(12) init('VLPDRVV2    '),
     2 AUX_OP7_TABLE51 char(12) init('VLNDRVV2    '),
     2 AUX_OP7_TABLE52 char(12) init('VLCDRVV2    '),
     2 AUX_OP7_TABLE53 char(12) init('            '),
     2 AUX_OP7_TABLE54 char(12) init('            '),
     2 AUX_OP7_TABLE55 char(12) init('            '),
     2 AUX_OP7_TABLE56 char(12) init('            '),
     2 AUX_OP7_TABLE57 char(12) init('            '),
     2 AUX_OP7_TABLE58 char(12) init('            '),
     2 AUX_OP7_TABLE59 char(12) init('            '),
     2 AUX_OP7_TABLE5A char(12) init('            '),
     2 AUX_OP7_TABLE5B char(12) init('            '),
     2 AUX_OP7_TABLE5C char(12) init('            '),
     2 AUX_OP7_TABLE5D char(12) init('            '),
     2 AUX_OP7_TABLE5E char(12) init('            '),
     2 AUX_OP7_TABLE5F char(12) init('            '),
     2 AUX_OP7_TABLE60 char(12) init('VLPR VV2    '),
     2 AUX_OP7_TABLE61 char(12) init('VLNR VV2    '),
     2 AUX_OP7_TABLE62 char(12) init('VLCR VV2    '),
     2 AUX_OP7_TABLE63 char(12) init('            '),
     2 AUX_OP7_TABLE64 char(12) init('            '),
     2 AUX_OP7_TABLE65 char(12) init('            '),
     2 AUX_OP7_TABLE66 char(12) init('            '),
     2 AUX_OP7_TABLE67 char(12) init('            '),
     2 AUX_OP7_TABLE68 char(12) init('            '),
     2 AUX_OP7_TABLE69 char(12) init('            '),
     2 AUX_OP7_TABLE6A char(12) init('            '),
     2 AUX_OP7_TABLE6B char(12) init('            '),
     2 AUX_OP7_TABLE6C char(12) init('            '),
     2 AUX_OP7_TABLE6D char(12) init('            '),
     2 AUX_OP7_TABLE6E char(12) init('            '),
     2 AUX_OP7_TABLE6F char(12) init('            '),
     2 AUX_OP7_TABLE70 char(12) init('            '),
     2 AUX_OP7_TABLE71 char(12) init('            '),
     2 AUX_OP7_TABLE72 char(12) init('            '),
     2 AUX_OP7_TABLE73 char(12) init('            '),
     2 AUX_OP7_TABLE74 char(12) init('            '),
     2 AUX_OP7_TABLE75 char(12) init('            '),
     2 AUX_OP7_TABLE76 char(12) init('            '),
     2 AUX_OP7_TABLE77 char(12) init('            '),
     2 AUX_OP7_TABLE78 char(12) init('            '),
     2 AUX_OP7_TABLE79 char(12) init('            '),
     2 AUX_OP7_TABLE7A char(12) init('            '),
     2 AUX_OP7_TABLE7B char(12) init('            '),
     2 AUX_OP7_TABLE7C char(12) init('            '),
     2 AUX_OP7_TABLE7D char(12) init('            '),
     2 AUX_OP7_TABLE7E char(12) init('            '),
     2 AUX_OP7_TABLE7F char(12) init('            '),
     2 AUX_OP7_TABLE80 char(12) init('VAEQ QV     '),
     2 AUX_OP7_TABLE81 char(12) init('VSEQ QV     '),
     2 AUX_OP7_TABLE82 char(12) init('VMEQ QV     '),
     2 AUX_OP7_TABLE83 char(12) init('VDEQ QV     '),
     2 AUX_OP7_TABLE84 char(12) init('VMAEQQV     '),
     2 AUX_OP7_TABLE85 char(12) init('VMSEQQV     '),
     2 AUX_OP7_TABLE86 char(12) init('            '),
     2 AUX_OP7_TABLE87 char(12) init('            '),
     2 AUX_OP7_TABLE88 char(12) init('VCEQ QV     '),
     2 AUX_OP7_TABLE89 char(12) init('VLEQ QV2    '),
     2 AUX_OP7_TABLE8A char(12) init('VLMEQQV2    '),
     2 AUX_OP7_TABLE8B char(12) init('            '),
     2 AUX_OP7_TABLE8C char(12) init('            '),
     2 AUX_OP7_TABLE8D char(12) init('            '),
     2 AUX_OP7_TABLE8E char(12) init('            '),
     2 AUX_OP7_TABLE8F char(12) init('            '),
     2 AUX_OP7_TABLE90 char(12) init('VADQ QV     '),
     2 AUX_OP7_TABLE91 char(12) init('VSDQ QV     '),
     2 AUX_OP7_TABLE92 char(12) init('VMDQ QV     '),
     2 AUX_OP7_TABLE93 char(12) init('VDDQ QV     '),
     2 AUX_OP7_TABLE94 char(12) init('VMADQQV     '),
     2 AUX_OP7_TABLE95 char(12) init('VMSDQQV     '),
     2 AUX_OP7_TABLE96 char(12) init('            '),
     2 AUX_OP7_TABLE97 char(12) init('            '),
     2 AUX_OP7_TABLE98 char(12) init('VCDQ QV     '),
     2 AUX_OP7_TABLE99 char(12) init('VLDQ QV2    '),
     2 AUX_OP7_TABLE9A char(12) init('VLMDQQV2    '),
     2 AUX_OP7_TABLE9B char(12) init('            '),
     2 AUX_OP7_TABLE9C char(12) init('            '),
     2 AUX_OP7_TABLE9D char(12) init('            '),
     2 AUX_OP7_TABLE9E char(12) init('            '),
     2 AUX_OP7_TABLE9F char(12) init('            '),
     2 AUX_OP7_TABLEA0 char(12) init('VAQ  QV     '),
     2 AUX_OP7_TABLEA1 char(12) init('VSQ  QV     '),
     2 AUX_OP7_TABLEA2 char(12) init('VMQ  QV     '),
     2 AUX_OP7_TABLEA3 char(12) init('            '),
     2 AUX_OP7_TABLEA4 char(12) init('VNQ  QV     '),
     2 AUX_OP7_TABLEA5 char(12) init('VOQ  QV     '),
     2 AUX_OP7_TABLEA6 char(12) init('VXQ  QV     '),
     2 AUX_OP7_TABLEA7 char(12) init('            '),
     2 AUX_OP7_TABLEA8 char(12) init('VCQ  QV     '),
     2 AUX_OP7_TABLEA9 char(12) init('VLQ  QV2    '),
     2 AUX_OP7_TABLEAA char(12) init('VLMQ QV2    '),

   1 AUX_OP_TABLE7 (0:170) char(12) def AUX_OP_TABLE7_ENTRIES,

   1 AUX_OP_TABLE8_ENTRIES static, /* for op code A6 */
     2 AUX_OP8_TABLE00 char(12) init('VMXSEVR     '),
     2 AUX_OP8_TABLE01 char(12) init('VMNSEVR     '),
     2 AUX_OP8_TABLE02 char(12) init('VMXAEVR     '),
     2 AUX_OP8_TABLE03 char(12) init('            '),
     2 AUX_OP8_TABLE04 char(12) init('            '),
     2 AUX_OP8_TABLE05 char(12) init('            '),
     2 AUX_OP8_TABLE06 char(12) init('            '),
     2 AUX_OP8_TABLE07 char(12) init('            '),
     2 AUX_OP8_TABLE08 char(12) init('VLELEVR     '),
     2 AUX_OP8_TABLE09 char(12) init('VXELEVR     '),
     2 AUX_OP8_TABLE0A char(12) init('            '),
     2 AUX_OP8_TABLE0B char(12) init('            '),
     2 AUX_OP8_TABLE0C char(12) init('            '),
     2 AUX_OP8_TABLE0D char(12) init('            '),
     2 AUX_OP8_TABLE0E char(12) init('            '),
     2 AUX_OP8_TABLE0F char(12) init('            '),
     2 AUX_OP8_TABLE10 char(12) init('VMXSDVR     '),
     2 AUX_OP8_TABLE11 char(12) init('VMNSDVR     '),
     2 AUX_OP8_TABLE12 char(12) init('VMXADVR     '),
     2 AUX_OP8_TABLE13 char(12) init('            '),
     2 AUX_OP8_TABLE14 char(12) init('            '),
     2 AUX_OP8_TABLE15 char(12) init('            '),
     2 AUX_OP8_TABLE16 char(12) init('            '),
     2 AUX_OP8_TABLE17 char(12) init('            '),
     2 AUX_OP8_TABLE18 char(12) init('VLELDVR     '),
     2 AUX_OP8_TABLE19 char(12) init('VXELDVR     '),
     2 AUX_OP8_TABLE1A char(12) init('VSPSDVR2    '),
     2 AUX_OP8_TABLE1B char(12) init('VZPSDVR1    '),
     2 AUX_OP8_TABLE1C char(12) init('            '),
     2 AUX_OP8_TABLE1D char(12) init('            '),
     2 AUX_OP8_TABLE1E char(12) init('            '),
     2 AUX_OP8_TABLE1F char(12) init('            '),
     2 AUX_OP8_TABLE20 char(12) init('            '),
     2 AUX_OP8_TABLE21 char(12) init('            '),
     2 AUX_OP8_TABLE22 char(12) init('            '),
     2 AUX_OP8_TABLE23 char(12) init('            '),
     2 AUX_OP8_TABLE24 char(12) init('            '),
     2 AUX_OP8_TABLE25 char(12) init('            '),
     2 AUX_OP8_TABLE26 char(12) init('            '),
     2 AUX_OP8_TABLE27 char(12) init('            '),
     2 AUX_OP8_TABLE28 char(12) init('VLEL VR     '),
     2 AUX_OP8_TABLE29 char(12) init('VXEL VR     '),
     2 AUX_OP8_TABLE2A char(12) init('            '),
     2 AUX_OP8_TABLE2B char(12) init('            '),
     2 AUX_OP8_TABLE2C char(12) init('            '),
     2 AUX_OP8_TABLE2D char(12) init('            '),
     2 AUX_OP8_TABLE2E char(12) init('            '),
     2 AUX_OP8_TABLE2F char(12) init('            '),
     2 AUX_OP8_TABLE30 char(12) init('            '),
     2 AUX_OP8_TABLE31 char(12) init('            '),
     2 AUX_OP8_TABLE32 char(12) init('            '),
     2 AUX_OP8_TABLE33 char(12) init('            '),
     2 AUX_OP8_TABLE34 char(12) init('            '),
     2 AUX_OP8_TABLE35 char(12) init('            '),
     2 AUX_OP8_TABLE36 char(12) init('            '),
     2 AUX_OP8_TABLE37 char(12) init('            '),
     2 AUX_OP8_TABLE38 char(12) init('            '),
     2 AUX_OP8_TABLE39 char(12) init('            '),
     2 AUX_OP8_TABLE3A char(12) init('            '),
     2 AUX_OP8_TABLE3B char(12) init('            '),
     2 AUX_OP8_TABLE3C char(12) init('            '),
     2 AUX_OP8_TABLE3D char(12) init('            '),
     2 AUX_OP8_TABLE3E char(12) init('            '),
     2 AUX_OP8_TABLE3F char(12) init('            '),
     2 AUX_OP8_TABLE40 char(12) init('VTVM RRZ    '),
     2 AUX_OP8_TABLE41 char(12) init('VCVM RRZ    '),
     2 AUX_OP8_TABLE42 char(12) init('VCZVMRRE    '),
     2 AUX_OP8_TABLE43 char(12) init('VCOVMRRE    '),
     2 AUX_OP8_TABLE44 char(12) init('VXVC RRE    '),
     2 AUX_OP8_TABLE45 char(12) init('VLVCURRE    '),
     2 AUX_OP8_TABLE46 char(12) init('VXVMMRRE    '),
     2 AUX_OP8_TABLE47 char(12) init('            '),
     2 AUX_OP8_TABLE48 char(12) init('VRRS RRE    '),
     2 AUX_OP8_TABLE49 char(12) init('VRSVCRRE    '),
     2 AUX_OP8_TABLE4A char(12) init('VRSV RRE    '),
     2 AUX_OP8_TABLE4B char(12) init('            '),
     2 AUX_OP8_TABLE4C char(12) init('            '),
     2 AUX_OP8_TABLE4D char(12) init('            '),
     2 AUX_OP8_TABLE4E char(12) init('            '),
     2 AUX_OP8_TABLE4F char(12) init('            '),
     2 AUX_OP8_TABLE50 char(12) init('            '),
     2 AUX_OP8_TABLE51 char(12) init('            '),
     2 AUX_OP8_TABLE52 char(12) init('            '),
     2 AUX_OP8_TABLE53 char(12) init('            '),
     2 AUX_OP8_TABLE54 char(12) init('            '),
     2 AUX_OP8_TABLE55 char(12) init('            '),
     2 AUX_OP8_TABLE56 char(12) init('            '),
     2 AUX_OP8_TABLE57 char(12) init('            '),
     2 AUX_OP8_TABLE58 char(12) init('            '),
     2 AUX_OP8_TABLE59 char(12) init('            '),
     2 AUX_OP8_TABLE5A char(12) init('            '),
     2 AUX_OP8_TABLE5B char(12) init('            '),
     2 AUX_OP8_TABLE5C char(12) init('            '),
     2 AUX_OP8_TABLE5D char(12) init('            '),
     2 AUX_OP8_TABLE5E char(12) init('            '),
     2 AUX_OP8_TABLE5F char(12) init('            '),
     2 AUX_OP8_TABLE60 char(12) init('            '),
     2 AUX_OP8_TABLE61 char(12) init('            '),
     2 AUX_OP8_TABLE62 char(12) init('            '),
     2 AUX_OP8_TABLE63 char(12) init('            '),
     2 AUX_OP8_TABLE64 char(12) init('            '),
     2 AUX_OP8_TABLE65 char(12) init('            '),
     2 AUX_OP8_TABLE66 char(12) init('            '),
     2 AUX_OP8_TABLE67 char(12) init('            '),
     2 AUX_OP8_TABLE68 char(12) init('            '),
     2 AUX_OP8_TABLE69 char(12) init('            '),
     2 AUX_OP8_TABLE6A char(12) init('            '),
     2 AUX_OP8_TABLE6B char(12) init('            '),
     2 AUX_OP8_TABLE6C char(12) init('            '),
     2 AUX_OP8_TABLE6D char(12) init('            '),
     2 AUX_OP8_TABLE6E char(12) init('            '),
     2 AUX_OP8_TABLE6F char(12) init('            '),
     2 AUX_OP8_TABLE70 char(12) init('            '),
     2 AUX_OP8_TABLE71 char(12) init('            '),
     2 AUX_OP8_TABLE72 char(12) init('            '),
     2 AUX_OP8_TABLE73 char(12) init('            '),
     2 AUX_OP8_TABLE74 char(12) init('            '),
     2 AUX_OP8_TABLE75 char(12) init('            '),
     2 AUX_OP8_TABLE76 char(12) init('            '),
     2 AUX_OP8_TABLE77 char(12) init('            '),
     2 AUX_OP8_TABLE78 char(12) init('            '),
     2 AUX_OP8_TABLE79 char(12) init('            '),
     2 AUX_OP8_TABLE7A char(12) init('            '),
     2 AUX_OP8_TABLE7B char(12) init('            '),
     2 AUX_OP8_TABLE7C char(12) init('            '),
     2 AUX_OP8_TABLE7D char(12) init('            '),
     2 AUX_OP8_TABLE7E char(12) init('            '),
     2 AUX_OP8_TABLE7F char(12) init('            '),
     2 AUX_OP8_TABLE80 char(12) init('VLVM VS     '),
     2 AUX_OP8_TABLE81 char(12) init('VLCVMVS     '),
     2 AUX_OP8_TABLE82 char(12) init('VSTVMVS     '),
     2 AUX_OP8_TABLE83 char(12) init('            '),
     2 AUX_OP8_TABLE84 char(12) init('VNVM VS     '),
     2 AUX_OP8_TABLE85 char(12) init('VOVM VS     '),
     2 AUX_OP8_TABLE86 char(12) init('VXVM VS     '),
     2 AUX_OP8_TABLE87 char(12) init('            '),
     2 AUX_OP8_TABLE88 char(12) init('            '),
     2 AUX_OP8_TABLE89 char(12) init('            '),
     2 AUX_OP8_TABLE8A char(12) init('            '),
     2 AUX_OP8_TABLE8B char(12) init('            '),
     2 AUX_OP8_TABLE8C char(12) init('            '),
     2 AUX_OP8_TABLE8D char(12) init('            '),
     2 AUX_OP8_TABLE8E char(12) init('            '),
     2 AUX_OP8_TABLE8F char(12) init('            '),
     2 AUX_OP8_TABLE90 char(12) init('            '),
     2 AUX_OP8_TABLE91 char(12) init('            '),
     2 AUX_OP8_TABLE92 char(12) init('            '),
     2 AUX_OP8_TABLE93 char(12) init('            '),
     2 AUX_OP8_TABLE94 char(12) init('            '),
     2 AUX_OP8_TABLE95 char(12) init('            '),
     2 AUX_OP8_TABLE96 char(12) init('            '),
     2 AUX_OP8_TABLE97 char(12) init('            '),
     2 AUX_OP8_TABLE98 char(12) init('            '),
     2 AUX_OP8_TABLE99 char(12) init('            '),
     2 AUX_OP8_TABLE9A char(12) init('            '),
     2 AUX_OP8_TABLE9B char(12) init('            '),
     2 AUX_OP8_TABLE9C char(12) init('            '),
     2 AUX_OP8_TABLE9D char(12) init('            '),
     2 AUX_OP8_TABLE9E char(12) init('            '),
     2 AUX_OP8_TABLE9F char(12) init('            '),
     2 AUX_OP8_TABLEA0 char(12) init('            '),
     2 AUX_OP8_TABLEA1 char(12) init('            '),
     2 AUX_OP8_TABLEA2 char(12) init('            '),
     2 AUX_OP8_TABLEA3 char(12) init('            '),
     2 AUX_OP8_TABLEA4 char(12) init('            '),
     2 AUX_OP8_TABLEA5 char(12) init('            '),
     2 AUX_OP8_TABLEA6 char(12) init('            '),
     2 AUX_OP8_TABLEA7 char(12) init('            '),
     2 AUX_OP8_TABLEA8 char(12) init('            '),
     2 AUX_OP8_TABLEA9 char(12) init('            '),
     2 AUX_OP8_TABLEAA char(12) init('            '),
     2 AUX_OP8_TABLEAB char(12) init('            '),
     2 AUX_OP8_TABLEAC char(12) init('            '),
     2 AUX_OP8_TABLEAD char(12) init('            '),
     2 AUX_OP8_TABLEAE char(12) init('            '),
     2 AUX_OP8_TABLEAF char(12) init('            '),
     2 AUX_OP8_TABLEB0 char(12) init('            '),
     2 AUX_OP8_TABLEB1 char(12) init('            '),
     2 AUX_OP8_TABLEB2 char(12) init('            '),
     2 AUX_OP8_TABLEB3 char(12) init('            '),
     2 AUX_OP8_TABLEB4 char(12) init('            '),
     2 AUX_OP8_TABLEB5 char(12) init('            '),
     2 AUX_OP8_TABLEB6 char(12) init('            '),
     2 AUX_OP8_TABLEB7 char(12) init('            '),
     2 AUX_OP8_TABLEB8 char(12) init('            '),
     2 AUX_OP8_TABLEB9 char(12) init('            '),
     2 AUX_OP8_TABLEBA char(12) init('            '),
     2 AUX_OP8_TABLEBB char(12) init('            '),
     2 AUX_OP8_TABLEBC char(12) init('            '),
     2 AUX_OP8_TABLEBD char(12) init('            '),
     2 AUX_OP8_TABLEBE char(12) init('            '),
     2 AUX_OP8_TABLEBF char(12) init('            '),
     2 AUX_OP8_TABLEC0 char(12) init('VSRSVSV     '),
     2 AUX_OP8_TABLEC1 char(12) init('VMRSVSV     '),
     2 AUX_OP8_TABLEC2 char(12) init('VSRRSSV     '),
     2 AUX_OP8_TABLEC3 char(12) init('VMRRSSV     '),
     2 AUX_OP8_TABLEC4 char(12) init('VLVCASV     '),
     2 AUX_OP8_TABLEC5 char(12) init('VRCL SV     '),
     2 AUX_OP8_TABLEC6 char(12) init('VSVMMSV     '),
     2 AUX_OP8_TABLEC7 char(12) init('            '),
     2 AUX_OP8_TABLEC8 char(12) init('VSTVPSV     '),
     2 AUX_OP8_TABLEC9 char(12) init('            '),
     2 AUX_OP8_TABLECA char(12) init('VACSVSV     '),
     2 AUX_OP8_TABLECB char(12) init('VACRSSV     '),

   1 AUX_OP_TABLE8 (0:203) char(12) def AUX_OP_TABLE8_ENTRIES,

   1 AUX_OP_TABLE9_ENTRIES static, /* for op code E4 */
     2 AUX_OP9_TABLE00 char(12) init('VLI  RSE    '), /* also VLIE  */
     2 AUX_OP9_TABLE01 char(12) init('VSTI RSE    '), /* also VSTIE */
     2 AUX_OP9_TABLE02 char(12) init('            '),
     2 AUX_OP9_TABLE03 char(12) init('            '),
     2 AUX_OP9_TABLE04 char(12) init('            '),
     2 AUX_OP9_TABLE05 char(12) init('            '),
     2 AUX_OP9_TABLE06 char(12) init('            '),
     2 AUX_OP9_TABLE07 char(12) init('            '),
     2 AUX_OP9_TABLE08 char(12) init('            '),
     2 AUX_OP9_TABLE09 char(12) init('            '),
     2 AUX_OP9_TABLE0A char(12) init('            '),
     2 AUX_OP9_TABLE0B char(12) init('            '),
     2 AUX_OP9_TABLE0C char(12) init('            '),
     2 AUX_OP9_TABLE0D char(12) init('            '),
     2 AUX_OP9_TABLE0E char(12) init('            '),
     2 AUX_OP9_TABLE0F char(12) init('            '),
     2 AUX_OP9_TABLE10 char(12) init('VLID RSE    '),
     2 AUX_OP9_TABLE11 char(12) init('VSTIDRSE    '),
     2 AUX_OP9_TABLE12 char(12) init('            '),
     2 AUX_OP9_TABLE13 char(12) init('            '),
     2 AUX_OP9_TABLE14 char(12) init('            '),
     2 AUX_OP9_TABLE15 char(12) init('            '),
     2 AUX_OP9_TABLE16 char(12) init('            '),
     2 AUX_OP9_TABLE17 char(12) init('            '),
     2 AUX_OP9_TABLE18 char(12) init('            '),
     2 AUX_OP9_TABLE19 char(12) init('            '),
     2 AUX_OP9_TABLE1A char(12) init('            '),
     2 AUX_OP9_TABLE1B char(12) init('            '),
     2 AUX_OP9_TABLE1C char(12) init('            '),
     2 AUX_OP9_TABLE1D char(12) init('            '),
     2 AUX_OP9_TABLE1E char(12) init('            '),
     2 AUX_OP9_TABLE1F char(12) init('            '),
     2 AUX_OP9_TABLE20 char(12) init('            '),
     2 AUX_OP9_TABLE21 char(12) init('            '),
     2 AUX_OP9_TABLE22 char(12) init('            '),
     2 AUX_OP9_TABLE23 char(12) init('            '),
     2 AUX_OP9_TABLE24 char(12) init('VSRL RSE    '),
     2 AUX_OP9_TABLE25 char(12) init('VSLL RSE    '),
     2 AUX_OP9_TABLE26 char(12) init('            '),
     2 AUX_OP9_TABLE27 char(12) init('            '),
     2 AUX_OP9_TABLE28 char(12) init('VLBIXRSE    '),

   1 AUX_OP_TABLE9 (0:40) char(12) def AUX_OP_TABLE9_ENTRIES,


     AUX_OP_TABLE_PTR (0:9)   static  ptr,
     AUX_OP_TABLE_DIM (0:9)   static  fixed(15) bin,


     DLOAD                       file   record input env(U),
     DISPARM                     file   input,
     DPRINT                      file   print,
     DPUNCH                      file   record output env(F
                                                      recsize(80)
                                                      blksize(6160));

 Dcl
     TEXT_BUFFER                        char(*) ctl;

 Dcl
     1 LOAD_RECORD       aligned based(LOAD_PTR),
       2 LOAD_TYPE       unaligned,
         3 LOAD_IDR                     bit(1),
         3 LOAD_SYM                     bit(1),
         3 LOAD_CESD                    bit(1),
         3 LOAD_SCATTER                 bit(1),
         3 LOAD_END_OF_MODULE           bit(1),
         3 LOAD_END_OF_SEGMENT          bit(1),
         3 LOAD_RLD                     bit(1),
         3 LOAD_CONTROL                 bit(1);
 Dcl
     1 CESD_RECORD       aligned based(LOAD_PTR),
       2 CESD_PREFIX,
         3 CESD_IDENTIFICATION          bit(8),
         3 CESD_FORMERLY_SPARE unaligned,
           4 CESD_XA                    bit(1),
           4 CESD_SPARE                 bit(23),
         3 CESD_FIRST_ESDID             fixed(15) bin,
         3 CESD_COUNT                   fixed(15) bin,
       2 CESD_DATA                      char(16),

     1 CESD_ENTRY        aligned based(CESD_PTR),
       2 CESD_NAME                      char(8),
       2 CESD_TYPE                      bit(8),
       2 CESD_ADDRESS                   bit(24),
       2 CESD_SEGMENT                   bit(8),
       2 CESD_LENGTH                    bit(24), /* ID when labelref */

     1 CESD_ENTRY2       aligned based(CESD_PTR),
       2 CESD_NAME2                     char(8),
       2 CESD_TYPE2    unaligned,
         3 CESD_TYPE_BITS           (8) bit(1),
       2 CESD_ADDRESS2                  bit(24),
       2 CESD_SEGMENT2 unaligned,
         3 CESD_XA_RESERVED             bit(4),
         3 CESD_XA_RSECT                bit(1),
         3 CESD_XA_RMODE                bit(1),
         3 CESD_XA_AMODE                bit(2),
       2 CESD_LENGTH2,
         3 CESD_XA_LENGTH_FILLER        char(1),
         3 CESD_XA_IDREF                fixed(15) bin,

     1 CONTROL_RECORD    aligned based(LOAD_PTR),
       2 CONTROL_PREFIX,
         3 CONTROL_IDENTIFICATION       bit(8),
         3 CONTROL_SPARE                bit(24),
         3 CONTROL_CONTROL_COUNT        fixed(15) bin,
         3 CONTROL_RLD_COUNT            fixed(15) bin,
         3 CONTROL_CCW,
           4 CONTROL_CCW_FLAGS1         bit(8),
           4 CONTROL_CCW_ADDRESS        bit(24),
           4 CONTROL_CCW_FLAGS2         bit(16),
           4 CONTROL_CCW_LENGTH         fixed(15) bin,
       2 CONTROL_DATA                   char(240),

     1 CONTROL_ENTRY     aligned based(CONTROL_PTR),
       2 CONTROL_ESDID                  fixed(15) bin,
       2 CONTROL_LENGTH                 fixed(15) bin,

     1 TEXT_RECORD        aligned based(LOAD_PTR),
       2 TEXT_DATA                      char(32760),

     1 RLD_RECORD        aligned based(LOAD_PTR),
       2 RLD_PREFIX,
         3 RLD_IDENTIFICATION           bit(8),
         3 RLD_SPARE                    bit(24),
         3 RLD_CONTROL_COUNT            fixed(15) bin,
         3 RLD_RLD_COUNT                fixed(15) bin,
         3 RLD_CCW                      char(8),
       2 RLD_DATA                       char(240),

     1 RLD_ENTRY         aligned based(RLD_PTR),
       2 RLD_RELOCATION_POINTER         fixed(15) bin,
       2 RLD_POSITION_POINTER           fixed(15) bin,
       2 RLD_SUBDATA                    char(240),

     1 RLD_SUBENTRY      aligned based(RLD_SUB_PTR),
       2 RLD_FLAG      unaligned,
         3 RLD_TYPE                     bit(4),
         3 RLD_LENGTH                   bit(2),
         3 RLD_NEGATIVE                 bit(1),
         3 RLD_SAME_RP                  bit(1),
       2 RLD_ADDRESS                    bit(24),

     1 QUEUE             aligned static,
       2 FIRST                          ptr init(Null),
       2 LAST                           ptr init(Null),
       2 MOST_RECENT                    ptr init(Null),

     1 CEQ            like QUEUE static, /* ESD entry queue */
     1 RAQ            like QUEUE static, /* RLD entry queue */
     1 SPQ            like QUEUE static, /* start point queue */
     1 LQ             like QUEUE static, /* label queue */
     1 IQ             like QUEUE static, /* instruction queue */

     CEQP                        static ptr,
     RAQP                        static ptr,
     SPQP                        static ptr,
     LQP                         static ptr,
     IQP                         static ptr,

     1 CEQE                      based(CEQP),  /* ESD entry element */
       2 CEQE_NEXT                      ptr,
       2 CEQE_PREV                      ptr,
       2 CEQE_ESDID                     fixed(31) bin, /* argument */
       2 CEQE_NAME                      char(8),
       2 CEQE_ADDRESS                   fixed(31) bin,
       2 CEQE_LENGTH                    fixed(31) bin,
       2 CEQE_IDREF                     fixed(31) bin, /* LR only */
       2 CEQE_TYPE                      char(2),
       2 CEQE_FLAGS                     bit(8),

     1 RAQE                      based(RAQP),  /* RLD entry element */
       2 RAQE_NEXT                      ptr,
       2 RAQE_PREV                      ptr,
       2 RAQE_ADDRESS                   fixed(31) bin, /* argument */
       2 RAQE_LENGTH                    fixed(31) bin,
       2 RAQE_RELOCATION                fixed(31) bin,
       2 RAQE_NAME                      char(8),
       2 RAQE_TYPE                      char(1),
       2 RAQE_FLAGS,
         3 RAQE_FLAGS_BITS unaligned,
           4 RAQE_NEGATIVE              bit(1),
           4 RAQE_UNRESOLVED            bit(1),
           4 RAQE_FLAG3                 bit(1),
           4 RAQE_FLAG4                 bit(1),
           4 RAQE_FLAG5                 bit(1),
           4 RAQE_FLAG6                 bit(1),
           4 RAQE_FLAG7                 bit(1),
           4 RAQE_FLAG8                 bit(1),

     1 LQE                       based(LQP),   /* Label element */
       2 LQE_NEXT                       ptr,
       2 LQE_PREV                       ptr,
       2 LQE_ADDRESS                    fixed(31) bin, /* argument */
       2 LQE_NAME                       char(8),
       2 LQE_FLAGS,
         3 LQE_FLAGS_BITS unaligned,
           4 LQE_ENTRY                  bit(1), /* entry (RLD LR)    */
           4 LQE_CSECT                  bit(1), /* name of csect     */
           4 LQE_GENERATED              bit(1), /* generated name    */
           4 LQE_SYM                    bit(1), /* from symbol table */
           4 LQE_FLAG5                  bit(1),
           4 LQE_FLAG6                  bit(1),
           4 LQE_FLAG7                  bit(1),
           4 LQE_FLAG8                  bit(1),

     1 SPQE                      based(SPQP),  /* Restart point */
       2 SPQE_NEXT                      ptr,
       2 SPQE_PREV                      ptr,
       2 SPQE_ADDRESS                   fixed(31) bin, /* argument */
       2 SPQE_LENGTH                    fixed(31) bin,
       2 SPQE_RELOCATION                fixed(31) bin,
       2 SPQE_LABEL                     char(8),
       2 SPQE_NAME                      char(8),
       2 SPQE_NAME2                     char(8),
       2 SPQE_TYPE                      char(1),
       2 SPQE_TYPE2                     char(1),
       2 SPQE_FLAGS,
         3 SPQE_FLAGS_BITS unaligned,
           4 SPQE_EOM                   bit(1),/* end of csect       */
           4 SPQE_COMPLEX               bit(1),/* complex relocation */
           4 SPQE_ENTRY                 bit(1),/* external entry     */
           4 SPQE_RLD                   bit(1),/* relocated address  */
           4 SPQE_RLDEND                bit(1),/* end of reloc addr  */
           4 SPQE_TOP                   bit(1),/* beginning of csect */
           4 SPQE_FLOW                  bit(1),/* known good opcodes */
           4 SPQE_RESERVED              bit(1),/* reserved           */

     1 SP             static,
       2 SP_NEXT                        ptr,
       2 SP_PREV                        ptr,
       2 SP_ADDRESS                     fixed(31) bin, /* argument */
       2 SP_LENGTH                      fixed(31) bin,
       2 SP_RELOCATION                  fixed(31) bin,
       2 SP_LABEL                       char(8),
       2 SP_NAME                        char(8),
       2 SP_NAME2                       char(8),
       2 SP_TYPE                        char(1),
       2 SP_TYPE2                       char(1),
       2 SP_FLAGS,
         3 SP_FLAGS_BITS unaligned,
           4 SP_EOM                     bit(1),/* end of csect       */
           4 SP_COMPLEX                 bit(1),/* complex relocation */
           4 SP_ENTRY                   bit(1),/* external entry     */
           4 SP_RLD                     bit(1),/* relocated address  */
           4 SP_RLDEND                  bit(1),/* end of reloc addr  */
           4 SP_TOP                     bit(1),/* beginning of csect */
           4 SP_FLOW                    bit(1),/* known good opcodes */
           4 SP_RESERVED                bit(1),/* reserved           */

     IPTR                        static ptr,
     SAVE_IPTR                   static ptr,

     1 INSTRUCTION_CHAR                 char(64) based(IPTR),
     1 INSTRUCTION_BITS                 bit(48)  based(IPTR),

     1 INSTRUCTION     unaligned based(IPTR),
       2 OPCODE                         bit(8),
       2 SUBOPCODE                      bit(8),

     1 BRANCH_INST     unaligned based(IPTR),
       2 BRANCH_OPCODE                  bit(8),
       2 CONDMASK                       bit(4),

 /********************************************************************/
 /*                                                                  */
 /* The following operation code formats are defined:                */
 /*                                                                  */
 /*          _____________________________                           */
 /*  I      |           |                 |                          */
 /*         | Op Code   | Immediate Data  |                          */
 /*         |___________|_________________|                          */
 /*         0           8                16                          */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  N      |                             |                      |   */
 /*         | Op Code (2 bytes)           | //////////////////// |   */
 /*         |_____________________________|______________________|   */
 /*         0                            16                     32   */
 /*                                                                  */
 /*          _____________________________                           */
 /*  RR     |           |        |        |                          */
 /*         | Op Code   |   R1   |   R2   |                          */
 /*         |___________|________|________|                          */
 /*         0           8       12       16                          */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  RR1    |           |                 |          |     |     |   */
 /*         | Op Code   | Sub-opcode      | //////// | R1  | /// |   */
 /*         |___________|_________________|__________|_____|_____|   */
 /*         0           8                16         24    28    32   */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  RR2    |           |                 |          |     |     |   */
 /*         | Op Code   | Sub-opcode      | //////// | R1  | R2  |   */
 /*         |___________|_________________|__________|_____|_____|   */
 /*         0           8                16         24    28    32   */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  RS     |           |        |        |      |               |   */
 /*         | Op Code   |   R1   |   R3   |  B2  |  D2           |   */
 /*         |___________|________|________|______|_______________|   */
 /*         0           8       12       16     20              32   */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  RSS    |           |        |        |      |               |   */
 /*         | Op Code   |   R1   | ////// |  B2  |  D2           |   */
 /*         |___________|________|________|______|_______________|   */
 /*         0           8       12       16     20              32   */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  RX     |           |        |        |      |               |   */
 /*         | Op Code   |   R1   |  X2    |  B2  |  D2           |   */
 /*         |___________|________|________|______|_______________|   */
 /*         0           8       12       16     20              32   */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  S      |           |                 |      |               |   */
 /*         | Op Code   | /////////////// |  B1  |  D1           |   */
 /*         |___________|_________________|______|_______________|   */
 /*         0           8                16     20              32   */
 /*                                                                  */
 /*          ____________________________________________________    */
 /*  SI     |           |                 |      |               |   */
 /*         | Op Code   | Immediate Data  |  B1  |  D1           |   */
 /*         |___________|_________________|______|_______________|   */
 /*         0           8                16     20              32   */
 /*                                                                  */
 /*          _____________________________                           */
 /*  SPM    |           |        |        |                          */
 /*         | Op Code   |   R1   | ////// |                          */
 /*         |___________|________|________|                          */
 /*         0           8       12       16                          */
 /*                                                                  */
 /*          ______________________________________________________  */
 /*  SSE    |        |         |    |            |    |            | */
 /*         | Opcode | Subop   | B1 |  D1        | B2 |  D2        | */
 /*         |________|_________|____|____________|____|____________| */
 /*         0        8       16   20           32   36           48  */
 /*                                                                  */
 /*          ______________________________________________________  */
 /*  SS1    |        |         |    |            |    |            | */
 /*         | Opcode |  L1     | B1 |  D1        | B2 |  D2        | */
 /*         |________|_________|____|____________|____|____________| */
 /*         0        8       16   20           32   36           48  */
 /*                                                                  */
 /*          ______________________________________________________  */
 /*  SS2    |        |    |    |    |            |    |            | */
 /*         | Opcode | L1 | L2 | B1 |  D1        | B2 |  D2        | */
 /*         |________|____|____|____|____________|____|____________| */
 /*         0        8   12  16   20           32   36           48  */
 /*                                                                  */
 /*          ______________________________________________________  */
 /*  SS3    |        |    |    |    |            |    |            | */
 /*         | Opcode | L1 | I3 | B1 |  D1        | B2 |  D2        | */
 /*         |________|____|____|____|____________|____|____________| */
 /*         0        8   12  16   20           32   36           48  */
 /*                                                                  */
 /*          ______________________________________________________  */
 /*  SS4    |        |    |    |    |            |    |            | */
 /*         | Opcode | R1 | I3 | B1 |  D1        | B2 |  D2        | */
 /*         |________|____|____|____|____________|____|____________| */
 /*         0        8   12  16   20           32   36           48  */
 /*                                                                  */
 /*                                                                  */
 /*                                                                  */
 /* ...and, for the new vector instructions:                         */
 /*                                                                  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  QST    |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | QR3  | RT2  | VR1  | RS2  |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  QV     |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | QR3  | //// | VR1  | VR2  |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  QV2    |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | QR2  | //// | VR1  | //// |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VST    |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | VR3  | RT2  | VR1  | RS2  |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VS3    |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | //// | RT2  | VR1  | RS2  |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VV     |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | VR3  | //// | VR1  | VR2  |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VV1    |           '             |             |      |      |  */
 /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | //// |  */
 /*         |___________'_____________|_____________|______|______|  */
 /*         0           8            16            24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VV2    |           '             |             |      |      |  */
 /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | VR2  |  */
 /*         |___________'_____________|_____________|______|______|  */
 /*         0           8            16            24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  RRE    |           '             |             |      |      |  */
 /*         | Op Code   ' Sub-opcode  | /////////// | GR1  | //// |  */
 /*         |___________'_____________|_____________|______|______|  */
 /*         0           8            16            24     28     32  */
 /*                                                                  */
 /*          ______________________________________________________  */
 /*  RSE    |        '         |    |    |    |    |    |          | */
 /*         | Opcode ' Sub-op. | R3 |////| VR1|////| B2 |    D2    | */
 /*         |________'_________|____|____|____|____|____|__________| */
 /*         0        8       16   20   24   28   32   36         48  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  SV     |           '             |      |                    |  */
 /*         | Op Code   ' Sub-opcode  |  B2  |        D2          |  */
 /*         |___________'_____________|______|____________________|  */
 /*         0           8            16     20                   32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VR     |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | QR3  | //// | VR1  | GR2  |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VR1    |           '             |             |      |      |  */
 /*         | Op Code   ' Sub-opcode  | /////////// | VR1  | //// |  */
 /*         |___________'_____________|_____________|______|______|  */
 /*         0           8            16            24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VR2    |           '             |      |      |      |      |  */
 /*         | Op Code   ' Sub-opcode  | FR2  | //// | VR1  | //// |  */
 /*         |___________'_____________|______|______|______|______|  */
 /*         0           8            16     20     24     28     32  */
 /*                                                                  */
 /*          _____________________________________________________   */
 /*  VS     |           '             |                    |      |  */
 /*         | Op Code   ' Sub-opcode  |    ////////////    | RS2  |  */
 /*         |___________'_____________|____________________|______|  */
 /*         0           8            16                   28     32  */
 /*                                                                  */
 /*                                                                  */
 /********************************************************************/

     1 RR_INSTRUCTION  aligned based(IPTR),
       2 RR_OPCODE     bit(8),
       2 RR_REGISTERS  unaligned,
         3 RR_R1       bit(4),
         3 RR_R2       bit(4),

     1 RR_FLOAT_INST   aligned based(IPTR),
       2 RR_FLOATCODE  bit(8),
       2 RR_FLOATREGS  bit(8),

     1 I_INSTRUCTION   aligned based(IPTR),
       2 I_OPCODE      bit(8),
       2 I_I           bit(8),

     1 RX_INSTRUCTION  aligned based(IPTR),
       2 RX_OPCODE     bit(8),
       2 RX_REGISTERS  unaligned,
         3 RX_R1       bit(4),
         3 RX_X2       bit(4),
       2 RX_B2D2       char(2),

     1 S_INSTRUCTION   aligned based(IPTR),
       2 S_OPCODE      bit(8),
       2 S_ZEROES      bit(8),
       2 S_B2D2        char(2),

     1 N_INSTRUCTION   aligned based(IPTR),
       2 N_OPCODE      bit(16),
       2 N_ZEROES,
         3 N_ZEROES1   bit(8),
         3 N_ZEROES2   bit(8),

     1 RS_INSTRUCTION  aligned based(IPTR),
       2 RS_OPCODE     bit(8),
       2 RS_REGISTERS  unaligned,
         3 RS_R1       bit(4),
         3 RS_R3       bit(4),
       2 RS_B2D2       char(2),

     1 SI_INSTRUCTION  aligned based(IPTR),
       2 SI_OPCODE     bit(8),
       2 SI_I2         char(1),
       2 SI_B1D1       char(2),

     1 SS1_INSTRUCTION aligned based(IPTR),
       2 SS1_OPCODE    bit(8),
       2 SS1_L1        bit(8),
       2 SS1_B1D1      char(2),
       2 SS1_B2D2      char(2),

     1 SS2_INSTRUCTION aligned based(IPTR),
       2 SS2_OPCODE    bit(8),
       2 SS2_LENGTHS   unaligned,
         3 SS2_L1      bit(4),
         3 SS2_L2      bit(4),
       2 SS2_B1D1      char(2),
       2 SS2_B2D2      char(2),

     1 SS3_INSTRUCTION aligned based(IPTR),
       2 SS3_OPCODE    bit(8),
       2 SS3_LENGTHS   unaligned,
         3 SS3_L1      bit(4),
         3 SS3_I3      bit(4),
       2 SS3_B1D1      char(2),
       2 SS3_B2D2      char(2),

     1 SS4_INSTRUCTION aligned based(IPTR),
       2 SS4_OPCODE    bit(8),
       2 SS4_REGS      unaligned,
         3 SS4_R1      bit(4),
         3 SS4_I3      bit(4),
       2 SS4_B1D1      char(2),
       2 SS4_B2D2      char(2),

     1 RR1_INSTRUCTION aligned based(IPTR),
       2 RR1_OPCODE    bit(8),
       2 RR1_SUBOP     bit(8),
       2 RR1_ZEROES1   bit(8),
       2 RR1_REGISTERS unaligned,
         3 RR1_R1      bit(4),
         3 RR1_ZEROES2 bit(4),

     1 RR2_INSTRUCTION aligned based(IPTR),
       2 RR2_OPCODE    bit(8),
       2 RR2_SUBOP     bit(8),
       2 RR2_ZEROES    bit(8),
       2 RR2_REGISTERS unaligned,
         3 RR2_R1      bit(4),
         3 RR2_R2      bit(4),

     1 SSE_INSTRUCTION aligned based(IPTR),
       2 SSE_OPCODE    bit(8),
       2 SSE_SUBOP     bit(8),
       2 SSE_B1D1      char(2),
       2 SSE_B2D2      char(2),

     1 QST_INSTRUCTION aligned based(IPTR),
       2 QST_OPCODE    bit(8),
       2 QST_SUBOP     bit(8),
       2 QST_REGISTERS unaligned,
         3 QST_QR3     bit(4),
         3 QST_RT2     bit(4),
         3 QST_VR1     bit(4),
         3 QST_RS2     bit(4),

     1 QV_INSTRUCTION  aligned based(IPTR),
       2 QV_OPCODE     bit(8),
       2 QV_SUBOP      bit(8),
       2 QV_REGISTERS  unaligned,
         3 QV_QR3      bit(4),
         3 QV_ZEROES   bit(4),
         3 QV_VR1      bit(4),
         3 QV_VR2      bit(4),

     1 QV2_INSTRUCTION  aligned based(IPTR),
       2 QV2_OPCODE     bit(8),
       2 QV2_SUBOP      bit(8),
       2 QV2_REGISTERS  unaligned,
         3 QV2_QR2      bit(4),
         3 QV2_ZEROES1  bit(4),
         3 QV2_VR1      bit(4),
         3 QV2_ZEROES2  bit(4),

     1 VST_INSTRUCTION aligned based(IPTR),
       2 VST_OPCODE    bit(8),
       2 VST_SUBOP     bit(8),
       2 VST_REGISTERS unaligned,
         3 VST_VR3     bit(4),
         3 VST_RT2     bit(4),
         3 VST_VR1     bit(4),
         3 VST_RS2     bit(4),

     1 VS3_INSTRUCTION aligned based(IPTR),
       2 VS3_OPCODE    bit(8),
       2 VS3_SUBOP     bit(8),
       2 VS3_REGISTERS unaligned,
         3 VS3_ZEROES  bit(4),
         3 VS3_RT2     bit(4),
         3 VS3_VR1     bit(4),
         3 VS3_RS2     bit(4),

     1 VV_INSTRUCTION  aligned based(IPTR),
       2 VV_OPCODE     bit(8),
       2 VV_SUBOP      bit(8),
       2 VV_REGISTERS  unaligned,
         3 VV_VR3      bit(4),
         3 VV_ZEROES   bit(4),
         3 VV_VR1      bit(4),
         3 VV_VR2      bit(4),

     1 VV1_INSTRUCTION  aligned based(IPTR),
       2 VV1_OPCODE     bit(8),
       2 VV1_SUBOP      bit(8),
       2 VV1_REGISTERS  unaligned,
         3 VV1_ZEROES1  bit(8),
         3 VV1_VR1      bit(4),
         3 VV1_ZEROES2  bit(4),

     1 VV2_INSTRUCTION  aligned based(IPTR),
       2 VV2_OPCODE     bit(8),
       2 VV2_SUBOP      bit(8),
       2 VV2_REGISTERS  unaligned,
         3 VV2_ZEROES   bit(8),
         3 VV2_VR1      bit(4),
         3 VV2_VR2      bit(4),

     1 RRE_INSTRUCTION aligned based(IPTR),
       2 RRE_OPCODE    bit(8),
       2 RRE_SUBOP     bit(8),
       2 RRE_REGISTERS unaligned,
         3 RRE_ZEROES1 bit(8),
         3 RRE_GR1     bit(4),
         3 RRE_ZEROES2 bit(4),

     1 RSE_INSTRUCTION aligned based(IPTR),
       2 RSE_OPCODE    bit(8),
       2 RSE_SUBOP     bit(8),
       2 RSE_REGISTERS unaligned,
         3 RSE_R3      bit(4),
         3 RSE_ZEROES1 bit(4),
         3 RSE_VR1     bit(4),
         3 RSE_ZEROES2 bit(4),
         3 RSE_B2D2    char(2),

     1 SV_INSTRUCTION  aligned based(IPTR),
       2 SV_OPCODE     bit(8),
       2 SV_SUBOP      bit(8),
       2 SV_B1D1       char(2),

     1 VR_INSTRUCTION  aligned based(IPTR),
       2 VR_OPCODE     bit(8),
       2 VR_SUBOP      bit(8),
       2 VR_REGISTERS  unaligned,
         3 VR_QR3      bit(4),
         3 VR_ZEROES   bit(4),
         3 VR_VR1      bit(4),
         3 VR_GR2      bit(4),

     1 VR1_INSTRUCTION  aligned based(IPTR),
       2 VR1_OPCODE     bit(8),
       2 VR1_SUBOP      bit(8),
       2 VR1_REGISTERS  unaligned,
         3 VR1_ZEROES1  bit(8),
         3 VR1_VR1      bit(4),
         3 VR1_ZEROES2  bit(4),

     1 VR2_INSTRUCTION  aligned based(IPTR),
       2 VR2_OPCODE     bit(8),
       2 VR2_SUBOP      bit(8),
       2 VR2_REGISTERS  unaligned,
         3 VR2_FR2      bit(4),
         3 VR2_ZEROES1  bit(4),
         3 VR2_VR1      bit(4),
         3 VR2_ZEROES2  bit(4),

     1 VS_INSTRUCTION  aligned based(IPTR),
       2 VS_OPCODE     bit(8),
       2 VS_SUBOP      bit(8),
       2 VS_REGISTERS  unaligned,
         3 VS_ZEROES   bit(12),
         3 VS_RS1      bit(4),


     INVLMOD                     condition,

     (Date,Null,PLIDUMP,PLIRETC,Time,
      Addr,Allocation,Dim,Hbound,High,Index,Lbound,Length,Low,
      Max,Min,Mod,Repeat,String,Substr,Translate,Verify,Unspec)
                                 builtin,
     PLIXOPT            external static char(2) var init('NR');

 /*******************************************************************/
1
 On Endfile(DLOAD)
   DLOAD_EOF = '1'B;

 On Undefinedfile(DLOAD) begin;
   Put file(DPRINT) edit('XDIS0002S File DISLOAD unavailable')
                          (Skip(3),A);
   Put file(DPRINT) edit('XDIS0003S Processing cannot continue')
                          (Skip(1),A);
   Call PLIRETC(16);
   Stop;
 End;

 On Undefinedfile(DPUNCH) begin;
   Put file(DPRINT) edit('XDIS0004W File DISPUNCH unavailable')
                          (Skip(3),A);
   Put file(DPRINT)
      edit('XDIS0005W Processing continues without a PUNCH file')
                          (Skip(1),A);
   PUNCH = '0'B;
 End;

 On Undefinedfile(DISPARM)
   Goto NO_DISPARM;

 On Name(DISPARM) begin;
   Put file(DPRINT)
      edit('XDIS0010W Unrecognized parameter ignored in DISPARM input')
                          (Skip(3),A);
 End;

 On Condition(INVLMOD) begin;
   Put file(DPRINT)
   edit('XDIS0007S Invalid load module - processing terminated')
                          (Skip(3),A);
   Call PLIRETC(12);
   Stop;

 End;

 /*******************************************************************/
1
 AUX_OP_TABLE_PTR(0) = Addr(AUX_OP_TABLE0);
 AUX_OP_TABLE_PTR(1) = Addr(AUX_OP_TABLE1);
 AUX_OP_TABLE_PTR(2) = Addr(AUX_OP_TABLE2);
 AUX_OP_TABLE_PTR(3) = Addr(AUX_OP_TABLE3);
 AUX_OP_TABLE_PTR(4) = Addr(AUX_OP_TABLE4);
 AUX_OP_TABLE_PTR(5) = Addr(AUX_OP_TABLE5);
 AUX_OP_TABLE_PTR(6) = Addr(AUX_OP_TABLE6);
 AUX_OP_TABLE_PTR(7) = Addr(AUX_OP_TABLE7);
 AUX_OP_TABLE_PTR(8) = Addr(AUX_OP_TABLE8);
 AUX_OP_TABLE_PTR(9) = Addr(AUX_OP_TABLE9);
 AUX_OP_TABLE_DIM(0) = Hbound(AUX_OP_TABLE0,1);
 AUX_OP_TABLE_DIM(1) = Hbound(AUX_OP_TABLE1,1);
 AUX_OP_TABLE_DIM(2) = Hbound(AUX_OP_TABLE2,1);
 AUX_OP_TABLE_DIM(3) = Hbound(AUX_OP_TABLE3,1);
 AUX_OP_TABLE_DIM(4) = Hbound(AUX_OP_TABLE4,1);
 AUX_OP_TABLE_DIM(5) = Hbound(AUX_OP_TABLE5,1);
 AUX_OP_TABLE_DIM(6) = Hbound(AUX_OP_TABLE6,1);
 AUX_OP_TABLE_DIM(7) = Hbound(AUX_OP_TABLE7,1);
 AUX_OP_TABLE_DIM(8) = Hbound(AUX_OP_TABLE8,1);
 AUX_OP_TABLE_DIM(9) = Hbound(AUX_OP_TABLE9,1);

 /*******************************************************************/

 Open file(DPRINT) title('DISPRINT') linesize(150),
      file(DLOAD)  title('DISLOAD');

 Put file(DPRINT) skip(2);
 Do I = 1 to Hbound(COPYRIGHT_NOTICE_AND_DISCLAIMER,1);
  Put file(DPRINT) skip(1)
      edit(COPYRIGHT_NOTICE_AND_DISCLAIMER(I)) (A);
 End;
 Put file(DPRINT) skip(3);

 CSECT_NAME = PARM;

 If CSECT_NAME = '' then do;
   Put file(DPRINT)
       edit(
 'XDIS0006I No control section specified, CESD entries will be listed')
           (Skip(2),A);
   ESD = 'Y';
 End;

 Else do;
  Get file(DISPARM) data(ESA,XA,SP1,VF,ESD,INCREMENT,OPSCAN);
  Unspec(ESA) = Unspec(ESA) | '01000000'B;
  Unspec(XA)  = Unspec(XA)  | '01000000'B;
  Unspec(SP1) = Unspec(SP1) | '01000000'B;
  Unspec(VF)  = Unspec(VF)  | '01000000'B;
  Unspec(ESD) = Unspec(ESD) | '01000000'B;
  If  ESA ^= 'Y' then ESA = 'N';
  If  XA  ^= 'Y' then XA  = 'N';
  If  SP1 ^= 'Y' then SP1 = 'N';
  If  VF  ^= 'Y' then VF  = 'N';
  If  ESD ^= 'Y' then ESD = 'N';

  If ESA = 'Y' then XA  = 'Y';
  If VF  = 'Y' then XA  = 'Y';
  If XA  = 'Y' then SP1 = 'Y';

 End;

 NO_DISPARM:

 If ESA = 'Y' then do;
                       OP_INDEX_LIMIT = 183; /* but what about VF? */
                       AUX_OP_TABLE_DIM(4) = 79; /* B24F */
                       AUX_OP_TABLE_DIM(5) = 15; /* E50F */
 End;
 Else if VF  = 'Y' then do;
                       OP_INDEX_LIMIT = 179;
                       AUX_OP_TABLE_DIM(4) = 60; /* B23C */
                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */
 End;
 Else if XA  = 'Y' then do;
                       OP_INDEX_LIMIT = 175;
                       AUX_OP_TABLE_DIM(4) = 60; /* B23C */
                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */
 End;
 Else if SP1 = 'Y' then do;
                       OP_INDEX_LIMIT = 169;
                       AUX_OP_TABLE_DIM(4) = 44; /* B22C */
                       AUX_OP_TABLE_DIM(5) =  1; /* E501 */
 End;
 Else do;
                       OP_INDEX_LIMIT = 165;
                       AUX_OP_TABLE_DIM(4) = 19; /* B213 */
                    /* AUX_OP_TABLE_DIM(5) irrelevant    */
 End;

 If ESA ^= 'Y' then do;
   AUX_OP1_TABLE1A = '';   /* no CFC unless ESA, just like UPT */
 End;
 Else If ESA = 'Y' & VF = 'N' then do;
   OP_TABLE176 = '';
   OP_TABLE177 = '';
   OP_TABLE178 = '';
   OP_TABLE179 = '';
 End;

 READ_LOAD: Do while (^ DLOAD_EOF);

   Read file(DLOAD) set(LOAD_PTR);

   If DLOAD_EOF then Leave READ_LOAD;

   If TEXT then do;
     Call PROCESS_TEXT;
     TEXT = '0'B;
     If LAST_TEXT then DLOAD_EOF = '1'B;
   End;

   Else do;

     If LOAD_END_OF_MODULE then LAST_TEXT = '1'B;

     If LOAD_CESD then do;
       If LOAD_SYM | LOAD_CONTROL | LOAD_RLD then
         Signal condition(INVLMOD);
       Call PROCESS_CESD;
     End;

     If LOAD_SYM then do;
       If LOAD_CONTROL | LOAD_RLD then
         Signal condition(INVLMOD);
     End;

     If LOAD_CONTROL then do;
       TEXT = '1'B;
       Call PROCESS_CONTROL;
     End;

     If LOAD_RLD then do;
       Call PROCESS_RLD;
     End;

   End;

 End READ_LOAD;

 Close file(DLOAD);

 /* Now...set up start point queue entries. */

 /* Add a start point entry for the physical end of the csect. */
 Call ADD_START_POINT (CSECT_LENGTH);
 SPQE_EOM = '1'B;

 /* Create a start point for the beginning of the module. */
 Call ADD_START_POINT (0);
 SPQE_LABEL = CSECT_NAME;
 SPQE_TOP = '1'B;

 Do CEQP = CEQ.FIRST repeat CEQE_NEXT while (CEQP ^= Null);
   If CEQE_TYPE = 'LR' & CEQE_IDREF = ESDID then do;
    /* For each label reference in our csect (i.e. entry point name) */
    /* create a start point and a label element */
     Call ADD_START_POINT (CEQE_ADDRESS - CSECT_OFFSET);
     SPQE_LABEL = CEQE_NAME;
     SPQE_ENTRY = '1'B;
     If CEQE_NAME ^= CSECT_NAME then do;
       Allocate LQE set(LQP);
       LQE_ADDRESS = SPQE_ADDRESS;
       LQE_NAME = CEQE_NAME;
       String(LQE_FLAGS) = '00000000'B;
       LQE_ENTRY = '1'B;
       Call INSERT(LQP,Addr(LQ));
     End;
   End;
 End;

 Do RAQP = RAQ.FIRST repeat RAQE_NEXT while (RAQP ^= Null);
   /* For each relocated addr in our csect, create a start point */
   /* If already an entry, assume a label entry and modify it. */
   Call ADD_START_POINT (RAQE_ADDRESS);
   SPQE_RLD = '1'B;
   /* If this is a negative value, this must be a complexly
      relocatable address constant, and there must be 2 entries
      with the same address (the existing one will be updated). */
   If RAQE_NEGATIVE then do;
    SPQE_NAME2 = RAQE_NAME;
    SPQE_TYPE2 = RAQE_TYPE;
    SPQE_RLD = '1'B;
    SPQE_COMPLEX = '1'B;
   End;
   Else do;
    SPQE_LENGTH = RAQE_LENGTH;
    SPQE_RELOCATION = RAQE_RELOCATION;
    SPQE_NAME = RAQE_NAME;
    SPQE_TYPE = RAQE_TYPE;
    SPQE_RLD = '1'B;
   End;
   /* Do the same to mark the end of each relocated address      */
   /* If already an entry, assume a label entry and modify it. */
   Call ADD_START_POINT (RAQE_ADDRESS + RAQE_LENGTH);
   SPQE_RLDEND = '1'B;
 End;

 /* Free the ESD queue and display entries if requested */

 If ESD = 'Y' then do;
   On ENDPAGE(DPRINT) begin;
     PAGENUM = PAGENUM + 1;
     Put file(DPRINT) page
         edit(CSECT_NAME,' - COMPOSITE EXTERNAL SYMBOL DICTIONARY',
              'PAGE ',NUMOUT(PAGENUM))
             (X(18),A(8),A,X(40),A,A(5));
     Put file(DPRINT) skip(3)
         list('SYMBOL   TYPE  ID   ADDR  LENGTH LRID FLAGS');
     Put file(DPRINT) skip(2);
   End;
   Signal ENDPAGE(DPRINT);
 End;
 Do CEQP = CEQ.FIRST repeat TEMP_PTR while (CEQP ^= Null);
   If ESD = 'Y' then do;
     ESD_ID   = Substr(HEXNUM(CEQE_ESDID),5,4);
     ESD_LEN  = '';
     Unspec(ESD_LDID) = Unspec('    ');
     Unspec(ESD_FLAGS) = Unspec('  ');
     If CEQE_TYPE = 'ER' |
        CEQE_TYPE = 'NL' |
        CEQE_TYPE = 'WX' then
       ESD_ADDR = '';
     Else do;
       ESD_ADDR = Substr(HEXNUM(CEQE_ADDRESS),3,6);
       If CEQE_TYPE = 'LR' then
         ESD_LDID = Substr(HEXNUM(CEQE_IDREF),5,4);
       Else
         ESD_LEN  = Substr(HEXNUM(CEQE_LENGTH),3,6);
     End;
     If CEQE_TYPE = 'SD' |
        CEQE_TYPE = 'PC' then
       ESD_FLAGS = Substr(HEXNUM(CEQE_FLAGS),7,2);
     Put file(DPRINT)
         list(CEQE_NAME||'  '||CEQE_TYPE||'  '||ESD_ID  ||' '  ||
              ESD_ADDR ||' ' ||ESD_LEN  ||' ' ||ESD_LDID||'   '||
              ESD_FLAGS);
     Put file(DPRINT) skip(1);
   End;
   TEMP_PTR = CEQE_NEXT;
   Free CEQE;
 End;

 /* Free the RLD queue */

 Do RAQP = RAQ.FIRST repeat TEMP_PTR while (RAQP ^= Null);
   TEMP_PTR = RAQE_NEXT;
   Free RAQE;
 End;

 If CSECT_NAME = '' then do;
   RETCODE = 4;
   Goto FIN;
 End;

 If CSECT_LENGTH = 0 then do;
   Put file(DPRINT) skip(2)
       list('XDIS0008E Requested control section '||CSECT_NAME||
       ' not found in load module');
   RETCODE = 12;
   Goto FIN;
 End;
 Else if CSECT_LENGTH < 0 then do;
   Put file(DPRINT) skip(2)
       list('XDIS0011E Requested control section '||CSECT_NAME||
       ' unresolved in load module');
   RETCODE = 12;
   Goto FIN;
 End;

 PUNCH = '1'B; /* set to '0'B if undefined file occurs */

 Open file(DPUNCH) title('DISPUNCH');

 IOFF = 0;

 SYSDATE = Date;
 TODAY = Substr(SYSDATE,3,2)||'/'||Substr(SYSDATE,5,2)||'/'||
         Substr(SYSDATE,1,2);

 Call OUTPUT('','TITLE',
             ''''||CSECT_NAME||' - source generated by XDIS on '||
             TODAY||'''');

 If PRIVATE_CODE then CSECT_LABEL = '';
 Else CSECT_LABEL = CSECT_NAME;

 Call OUTPUT(CSECT_LABEL,'CSECT','');

 If AMODE ^= '   ' then Call OUTPUT(CSECT_LABEL,'AMODE',AMODE);
 If RMODE ^= '   ' then Call OUTPUT(CSECT_LABEL,'RMODE',RMODE);

 DOIT_LOOP:Do while (SPQ.FIRST ^= Null);

   SPQP = SPQ.FIRST;
   SP = SPQE;
   Call DELETE(SPQP,Addr(SPQ));
   If SP_EOM then Leave DOIT_LOOP;

   BLOCK_LENGTH = SP_NEXT->SPQE_ADDRESS - SP_ADDRESS;
   IOFF = SP_ADDRESS;
   Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;

   Do LQP = Locate(Addr(LQ),IOFF) repeat LQE_NEXT
            while (LQP ^= Null & LQE_ADDRESS = IOFF);
     If LQE_ENTRY then
       Call OUTPUT('        ','ENTRY',LQE_NAME);
     Call OUTPUT (LQE_NAME,'EQU  ','*');
     SP_LABEL = '';
   End;

   If SP_LABEL = CSECT_NAME then SP_LABEL = '';

   If SP_RLD then do;
     CONDITION_CODE = ' ';
     VALID_INST = '0'B;
     RECOGNIZED_INST = '0'B;
     NAME = SP_NAME;
     ILEN = SP_LENGTH;
     IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));
     Select (ILEN);
       When (2) I = IPTR->ADCON2 - SP_RELOCATION;
       When (3) I = IPTR->ADCON3 - SP_RELOCATION;
       When (4) I = IPTR->ADCON4 - SP_RELOCATION;
       Otherwise;
     End;
     If SP_TYPE = 'Q' then
       Call OUTPUT(SP_LABEL,'DS   ','QL'||NUMOUT(ILEN));
     Else do;
       TYPE = SP_TYPE;
       If TYPE = 'W' then do;
        TYPE = 'A';
        Call OUTPUT_XTRN ('WXTRN',SP_NAME);
       End;
       Else if TYPE = 'X' then do;
        TYPE = 'A';
        Call OUTPUT_XTRN ('EXTRN',SP_NAME);
       End;
       If SP_TYPE2 = 'W' then do;
        Call OUTPUT_XTRN ('WXTRN',SP_NAME2);
       End;
       Else if SP_TYPE2 = 'X' then do;
        Call OUTPUT_XTRN ('EXTRN',SP_NAME2);
       End;

       If ILEN = 4 & Mod(IOFF,4) = 0 then
        OPERANDS = TYPE || '(' ||
                   Substr(NAME9,1,Index(NAME9,' ')-1);
       Else
        OPERANDS = TYPE || 'L' || NUMOUT(ILEN) || '(' ||
                   Substr(NAME9,1,Index(NAME9,' ')-1);
       If SP_COMPLEX then do;
        NAME = SP_NAME2;
        OPERANDS = OPERANDS || '-' ||
                   Substr(NAME9,1,Index(NAME9,' ')-1);
       End;
       If I = 0 then OPERANDS = OPERANDS || ')';
       Else if I = -2147483648 then /* XA pointer-defined linkage */
        OPERANDS = OPERANDS || '+X''80000000'')';
       Else if I < 0 then do;
        If I < -2130706432 then do; /* 80000000 thru 80ffffff */
         Unspec(I) = Unspec(I) & '01111111111111111111111111111111'B;
         OPERANDS = OPERANDS || '+' || NUMOUT(I) || '+X''80000000'')';
        End;
        Else do; /* 81000000 thru 8fffffff */
         OPERANDS = OPERANDS || '-' || NUMOUT(-I) || ')';
        End;
       End;
       Else OPERANDS = OPERANDS || '+' || NUMOUT(I) || ')';
       Call OUTPUT(SP_LABEL,'DC   ',OPERANDS);
     End;
     SP_LABEL = '';
   End;

   Else
   OTHER_THAN_RLD:Do;
     If SP_FLOW then VALID_INST = '1'B;
     Else
     DETERMINE_IF_FLOW:Do;
       SAVE_IOFF = IOFF;
       SAVE_IPTR = IPTR;
       VALID_CHAIN = '0'B;
       FIND_GOOD_OPCODE_CHAIN:
       Do I = 0 to BLOCK_LENGTH/2*2-1 by 2 until(VALID_CHAIN);
         VALID_CHAIN = '1'B;
         J = BLOCK_LENGTH - I;
         IOFF = SAVE_IOFF + I;
         RUN_OPCODE_CHAIN:
         Do K = 1 to OPSCAN while (VALID_CHAIN);
           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;
           If IOFF = SAVE_IOFF + BLOCK_LENGTH then do;
             If SPQ.FIRST->SPQE_RLD |
                SPQ.FIRST->SPQE_ENTRY /* added 12/19/89 */ |
                SPQ.FIRST->SPQE_EOM then VALID_CHAIN = '0'B;
             Leave RUN_OPCODE_CHAIN;
           End;
           Else if IOFF > SAVE_IOFF + BLOCK_LENGTH then
             VALID_CHAIN = '0'B;
           Else do;
             TEMP_PTR = OP_CODE_LOCATOR(IPTR,J);
             If TEMP_PTR = Null then do;
               VALID_CHAIN = '0'B;
               Leave RUN_OPCODE_CHAIN;
             End;
             L = OPLENGTH(IPTR);
             If I ^= 0 & K = 1 & Verify(Substr(INSTRUCTION_CHAR,1,L),
               'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$') = 0 then
               VALID_CHAIN = '0'B;
             Else if VALID_BRANCH_CODE(IPTR,J) then do;
               IOFF = IOFF + L;
               Leave RUN_OPCODE_CHAIN;
             End;
             Else do;
               IOFF = IOFF + L;
               J = J - L;
             End;
           End;
         End RUN_OPCODE_CHAIN;
       End FIND_GOOD_OPCODE_CHAIN;
       If VALID_CHAIN then do;
         Call ADD_START_POINT (IOFF);
         If I ^= 0 then do;
           VALID_INST = '0'B;
           Call ADD_START_POINT (SAVE_IOFF + I);
           SPQE_FLOW = '1'B;
         End;
         Else do;
           VALID_INST = '1'B;
           SP_FLOW = '1'B;
         End;
       End;
       Else do;
         VALID_INST = '0'B;
         SP_FLOW = '0'B;
       End;
       IPTR = SAVE_IPTR;
       IOFF = SAVE_IOFF;
     End DETERMINE_IF_FLOW;

     BLOCK_LENGTH = SPQ.FIRST->SPQE_ADDRESS - SP_ADDRESS;
     DO_A_BUNCH:
     Do while (BLOCK_LENGTH > 0);
       Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;
       If VALID_INST then do;
         ILEN = OPLENGTH(IPTR);
         If ILEN > BLOCK_LENGTH then do;
           VALID_INST = '0'B;
           ILEN = BLOCK_LENGTH;
         End;
         IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));
         RECOGNIZED_INST = VALID_INST;
           /*******************************************************/
         OP_PTR = OP_CODE_LOCATOR(IPTR,(BLOCK_LENGTH));
         If OP_PTR = Null then do;
           Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');
           CONDITION_CODE = ' ';
         End;
         Else GENERATE_INSTRUCTION:do;


           OPERATION = OP_NAME;
           Select (OP_FORMAT);
             When ('RR ') do;
               OPERANDS = NUMOUT((RR_R1))||','||NUMOUT((RR_R2));
             End;
             When ('I  ') do;
               OPERANDS = NUMOUT((I_I));
             End;
             When ('SPM') do;
               OPERANDS = NUMOUT((RR_R1));
             End;
             When ('RX ') do;
               OPERANDS = NUMOUT((RX_R1)) || ',' ||
                          GEN_EFF_ADDR(RX_B2D2,(RX_X2),'I');
             End;
             When ('S  ') do;
               OPERANDS = GEN_EFF_ADDR(S_B2D2,0,' ');
             End;
             When ('N  ') do;
               OPERANDS = '';
             End;
             When ('RS ') do;
               OPERANDS = NUMOUT((RS_R1))||','||NUMOUT(RS_R3)||','||
                          GEN_EFF_ADDR(RS_B2D2,0,' ');
             End;
             When ('RSS') do;
               OPERANDS = NUMOUT((RS_R1)) || ',' ||
                          GEN_EFF_ADDR(RS_B2D2,0,'S');
             End;
             When ('SI ') do;
               If OP_TYPE = 'C' & Verify(SI_I2,
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./') = 0
               then
               OPERANDS = GEN_EFF_ADDR(SI_B1D1,0,' ') || ',' ||
                          'C'''||SI_I2 ||'''';
               Else
               OPERANDS = GEN_EFF_ADDR(SI_B1D1,0,' ') || ',' ||
                          'X'''||HEXOUT(SI_I2)||'''';
             End;
             When ('SS1') do;
               OPERANDS = GEN_EFF_ADDR(SS1_B1D1,(SS1_L1),'L') || ',' ||
                          GEN_EFF_ADDR(SS1_B2D2,0,' ');
             End;
             When ('SS2') do;
               OPERANDS = GEN_EFF_ADDR(SS2_B1D1,(SS2_L1),'L') || ',' ||
                          GEN_EFF_ADDR(SS2_B2D2,(SS2_L2),'L');
             End;
             When ('SS3') do;
               OPERANDS = GEN_EFF_ADDR(SS3_B1D1,(SS3_L1),'L') || ',' ||
                          GEN_EFF_ADDR(SS3_B2D2,0,'S')        || ',' ||
                          NUMOUT((SS3_I3));
             End;
             When ('SS4') do;
               OPERANDS = GEN_EFF_ADDR(SS4_B1D1,(SS4_R1),'M') || ',' ||
                          GEN_EFF_ADDR(SS4_B2D2,0,'S')        || ',' ||
                          NUMOUT((SS4_I3));
             End;
             When ('RR1') do;
               OPERANDS = NUMOUT((RR1_R1));
             End;
             When ('RR2') do;
               OPERANDS = NUMOUT((RR2_R1))||','||NUMOUT((RR2_R2));
             End;
             When ('SSE') do;
               OPERANDS = GEN_EFF_ADDR(SSE_B1D1,0,' ') || ',' ||
                          GEN_EFF_ADDR(SSE_B2D2,0,' ');
             End;
             When ('QST') do;
               OPERANDS = NUMOUT((QST_VR1)) || ',' ||
                          NUMOUT((QST_QR3)) || ',' ||
                          NUMOUT((QST_RS2)) || '(' ||
                          NUMOUT((QST_RT2)) || ')';
             End;
             When ('QV ') do;
               OPERANDS = NUMOUT((QV_VR1)) || ',' ||
                          NUMOUT((QV_QR3)) || ',' ||
                          NUMOUT((QV_VR2));
             End;
             When ('QV2') do;
               OPERANDS = NUMOUT((QV2_VR1)) || ',' ||
                          NUMOUT((QV2_QR2));
             End;
             When ('VST') do;
               OPERANDS = NUMOUT((VST_VR1)) || ',' ||
                          NUMOUT((VST_VR3)) || ',' ||
                          NUMOUT((VST_RS2)) || '(' ||
                          NUMOUT((VST_RT2)) || ')';
             End;
             When ('VS3') do;
               OPERANDS = NUMOUT((VS3_VR1)) || ',' ||
                          NUMOUT((VS3_RS2)) || '(' ||
                          NUMOUT((VS3_RT2)) || ')';
             End;
             When ('VV ') do;
               OPERANDS = NUMOUT((VV_VR1)) || ',' ||
                          NUMOUT((VV_VR3)) || ',' ||
                          NUMOUT((VV_VR2));
             End;
             When ('VV1') do;
               OPERANDS = NUMOUT((VV1_VR1));
             End;
             When ('VV2') do;
               OPERANDS = NUMOUT((VV2_VR1)) || ',' ||
                          NUMOUT((VV2_VR2));
             End;
             When ('RRE') do;
               OPERANDS = NUMOUT((RRE_GR1));
             End;
             When ('RRZ') do;
               OPERANDS = '';
             End;
             When ('RSE') do;
               OPERANDS = NUMOUT((RSE_VR1)) || ',' ||
                          NUMOUT((RSE_R3))  || ',' ||
                          GEN_EFF_ADDR(RSE_B2D2,0,' ');
             End;
             When ('SV ') do;
               OPERANDS = GEN_EFF_ADDR(SV_B1D1,0,' ');
             End;
             When ('VR ') do;
               OPERANDS = NUMOUT((VR_VR1)) || ',' ||
                          NUMOUT((VR_QR3)) || ',' ||
                          NUMOUT((VR_GR2));
             End;
             When ('VR1') do;
               OPERANDS = NUMOUT((VR1_VR1));
             End;
             When ('VR2') do;
               OPERANDS = NUMOUT((VR2_VR1)) || ',' ||
                          NUMOUT((VR2_FR2));
             End;
             When ('VS ') do;
               OPERANDS = NUMOUT((VS_RS1));
             End;
             Otherwise
               RECOGNIZED_INST = '0'B;
           End;
           If (RECOGNIZED_INST) & (OP_TYPE = 'B') then
           PROCESS_MNEMONIC:do;
             MNEMONIC_OPER = '?';
             Select (CONDITION_CODE);
               When ('A')
                 MNEMONIC_STRING = 'ZMPO';
               When ('C')
                 MNEMONIC_STRING = 'ELH?';
               When ('Z')
                 MNEMONIC_STRING = 'Z???';
               Otherwise
                 MNEMONIC_STRING = '????';
             End;
             Select(CONDMASK);
               When ('0000'B)
                 MNEMONIC_OPER = 'NOP';
               When ('1111'B)
                 MNEMONIC_OPER = 'B';
               When ('1000'B)
                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,1,1);
               When ('0100'B)
                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,2,1);
               When ('0010'B)
                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,3,1);
               When ('0001'B)
                 MNEMONIC_OPER = 'B'||Substr(MNEMONIC_STRING,4,1);
               When ('0111'B)
                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,1,1);
               When ('1011'B)
                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,2,1);
               When ('1101'B)
                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,3,1);
               When ('1110'B)
                 MNEMONIC_OPER = 'BN'||Substr(MNEMONIC_STRING,4,1);
               Otherwise
                 MNEMONIC_OPER = '?';
             End;
             If Index(MNEMONIC_OPER,'?') = 0 then do;
               If OP_FORMAT = 'RR ' then do;
                 MNEMONIC_OPER = MNEMONIC_OPER || 'R';
                 OPERANDS = NUMOUT((RR_R2));
               End;
               Else do;
                 OPERANDS = GEN_EFF_ADDR(RX_B2D2,(RX_X2),'I');
               End;
               OPERATION = MNEMONIC_OPER;
             End;
           End PROCESS_MNEMONIC;
           If RECOGNIZED_INST then
             Call OUTPUT(SP_LABEL,OPERATION,OPERANDS);
           Else
             Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');
           If OP_CC ^= ' ' then CONDITION_CODE = OP_CC;
         End GENERATE_INSTRUCTION;
         SP_LABEL = '';
         BLOCK_LENGTH = BLOCK_LENGTH - ILEN;
         IOFF = IOFF + ILEN;
       End;
       Else NOT_INSTRUCTIONS:do;
         RECOGNIZED_INST = '0'B;
         CONDITION_CODE = ' ';
         PROCESS_DEECEES: Do while (BLOCK_LENGTH > 0);
           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;
           K = Min(32,BLOCK_LENGTH);
           ILEN = Verify(Substr(INSTRUCTION_CHAR,1,K),
             'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./');
           If ILEN = 0 then ILEN = K;
           Else ILEN = ILEN - 1;
           If ILEN ^= 0 then do;
             IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));
             Call OUTPUT(SP_LABEL,'DC   ','C'''||
                         Substr(INSTRUCTION_CHAR,1,ILEN)||'''');
             SP_LABEL = '';
           End;
           BLOCK_LENGTH = BLOCK_LENGTH - ILEN;
           IOFF = IOFF + ILEN;
           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;
           K = Min(8,BLOCK_LENGTH);
           Do ILEN = 1 to K while (Index(
             'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 @#$%*()-+=,./',
              Substr(INSTRUCTION_CHAR,ILEN,1)) = 0);
           End;
           ILEN = ILEN - 1;
           If ILEN ^= 0 then do;
             IMAGE = HEXOUT(Substr(INSTRUCTION_CHAR,1,ILEN));
             Call OUTPUT(SP_LABEL,'DC   ','X'''||IMAGE||'''');
             SP_LABEL = '';
           End;
           BLOCK_LENGTH = BLOCK_LENGTH - ILEN;
           IOFF = IOFF + ILEN;
           Addr(IPTR)->N = Addr(TEXT_PTR)->N + IOFF;
         End PROCESS_DEECEES;
       End NOT_INSTRUCTIONS;
     End DO_A_BUNCH;
   End OTHER_THAN_RLD;

 End DOIT_LOOP;

 Call OUTPUT('        ','END  ','');

 FIN:

 If RETCODE ^= 0 then
   Put file(DPRINT) skip(2)
     list('XDIS0001I Processing terminated, highest return code is ' ||
     NUMOUT(RETCODE));

 If PUNCH then Close file(DPUNCH);
 Close file(DPRINT);

 Call PLIRETC(RETCODE);

 Return;

 /*******************************************************************/
1
 OUTPUT_XTRN: Proc(XTRN,NAME);

  Dcl XTRN              char (5),
      NAME              char (8);
  Dcl (NP,NEWP)         ptr;
  Dcl NAMELIST_PTR      static ptr init(Null());
  Dcl 1 NAMELIST based,
        2 NAMELIST_NEXT ptr,
        2 NAMELIST_NAME char(8);

  /* See if NAME is already on the list. */
  Do NP = NAMELIST_PTR repeat (NP->NAMELIST_NEXT)
                       while  (NP ^= Null());
   If NP->NAMELIST_NAME = NAME then return; /* don't generate stmt */
  End;
  Allocate NAMELIST set(NEWP);
  NEWP->NAMELIST_NEXT = NAMELIST_PTR;
  NEWP->NAMELIST_NAME = NAME;
  NAMELIST_PTR = NEWP;
  Call OUTPUT ('        ',XTRN,NAME);

 End OUTPUT_XTRN;

 /*******************************************************************/
1
 OUTPUT:Proc(LABEL,OPERATION,OPERANDS) reorder;

 Dcl LABEL              char  (8),
     OPERATION          char  (5),
     OPERANDS           char (56) var,
     LOC8        static char(8),
     LOC                char(6) def LOC8 pos(3),
     RE_LOC8     static char(8),
     RE_LOC             char(6) def RE_LOC8 pos(3),
     LINE        static char (80),
     OBJECT_DUMP static char (16),
     IMAGE_TEMP  static char (12),
     CURRENT_STATEMENT_NUMBER
                 static fixed (5) dec init(0),
     STMTNO             pic '99999',
     SEQNUM      static fixed (8) dec init(0),
     SEQUENCE           pic   '99999999' def LINE pos(73),
     HEADING     static char(48) var init('');

 LOC8 = HEXNUM(IOFF);
 RE_LOC8 = HEXNUM(IOFF+CSECT_OFFSET);

 If OPERATION = 'END  '
  | OPERATION = 'ENTRY'
  | OPERATION = 'TITLE'
  | OPERATION = 'WXTRN'
  | OPERATION = 'EXTRN'
  | OPERATION = 'AMODE'
  | OPERATION = 'RMODE'
                        then do;
   LOC = '';
   RE_LOC = '';
   OBJECT_DUMP = '';
 End;
 Else if OPERATION = 'EQU  '
       | OPERATION = 'CSECT'
                             then do;
   OBJECT_DUMP = '';
 End;
 Else if RECOGNIZED_INST then do;
   IMAGE_TEMP = IMAGE;
   OBJECT_DUMP = Substr(IMAGE_TEMP,1,4)||' '||Substr(IMAGE_TEMP,5,4)||
                 ' '|| Substr(IMAGE_TEMP,9,4);
 End;
 Else do;
   OBJECT_DUMP = Substr(IMAGE,1,Min(16,Length(IMAGE)));
 End;

 LINE = LABEL||' '||OPERATION||' '||OPERANDS;
 SEQNUM = SEQNUM + INCREMENT;
 SEQUENCE = SEQNUM;
 CURRENT_STATEMENT_NUMBER = CURRENT_STATEMENT_NUMBER + 1;
 STMTNO = CURRENT_STATEMENT_NUMBER;

 If PUNCH then
   Write file(DPUNCH) from(LINE);

 On ENDPAGE(DPRINT) begin;
   PAGENUM = PAGENUM + 1;
   Put file(DPRINT) page edit(HEADING,'PAGE ',NUMOUT(PAGENUM))
                             (X(18),A,X(47),A,A(5));
   Put file(DPRINT) skip(3)
   list('LM-LOC CS-LOC  OBJECT CODE         STMT   SOURCE STATEMENT');
   Put file(DPRINT) skip(2);
 End;

 If OPERATION = 'TITLE' then do;
   Get string(OPERANDS) list(HEADING);
   Signal ENDPAGE(DPRINT);
 End;

 Else Put file(DPRINT) /* skip(1) */
   list(RE_LOC||' '||LOC||'  '||OBJECT_DUMP||'   '||STMTNO||' '||LINE);

 End OUTPUT;

 /*******************************************************************/
1
 OPLENGTH: Proc(IPTR) returns(fixed(15) bin) reorder;

 Dcl IPTR   ptr,
     RETURN_VALUE static fixed(15) bin,
     OPCODE_BITS bit(8) based(IPTR);

 Select (OPCODE_BITS & '11000000'B);
   When ('00000000'B) RETURN_VALUE = 2;
   When ('11000000'B) RETURN_VALUE = 6;
   Otherwise          RETURN_VALUE = 4;
 End;

 Return(RETURN_VALUE);

 End OPLENGTH;

 /*******************************************************************/
1
 OP_CODE_LOCATOR: Proc(IPTR,J) returns(ptr) reorder;

 Dcl IPTR              ptr,
     J                 fixed(15) bin,
     SAVE_AUX9  static pic '9',
     SAVE_AUX          char(1) def SAVE_AUX9,
     AUX        static fixed(15) bin,
     RETURN_PTR static ptr,
     1 OPCODE  aligned based(IPTR),
       2 OPCODE1       bit(8),
       2 OPCODE2       bit(8);

 If J < OPLENGTH(IPTR) then Return(Null);  /* bug fixed 12/15/89 */

   OP_INDEX = OP_CODE_LOOKUP(OPCODE1);
   If OP_INDEX > OP_INDEX_LIMIT then Return(Null);
   OP_PTR = Addr(OP_TABLE0(OP_INDEX));
   If OP_AUX ^= ' ' then do;
     SAVE_AUX = OP_AUX;
     AUX = SAVE_AUX9;
     OP_INDEX = OPCODE2;
     If OP_INDEX > AUX_OP_TABLE_DIM(AUX) then Return(Null);
     OP_PTR = Addr(AUX_OP_TABLE_PTR(AUX)->AUX_OP_ARRAY(OP_INDEX));
   End;
   RETURN_PTR = OP_PTR;
   Select (OP_SPEC);
     When (' ') do;
     End;
     When ('E') do;
       If ((RR_FLOATREGS & '10011001'B) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('D') do;
       If ((RR_FLOATREGS & '10111011'B) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('F') do;
       If ((RR_FLOATREGS & '10010000'B) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('G') do;
       If ((RR_FLOATREGS & '10110000'B) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('H') do;
       If ((RR_FLOATREGS & '10111001'B) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('M') do;
       If (Substr(RR_R1,4,1)) then
         RETURN_PTR = Null;
     End;
     When ('L') do;
       If (Substr(RR_R1,4,1) | Substr(RR_R2,4,1)) then
         RETURN_PTR = Null;
     End;
     When ('S') do;
       If ((S_ZEROES) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('N') do;
       If ((N_ZEROES1) ^= '00000000'B) |
          ((N_ZEROES2) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('1') do;
       If ((RS_R3) ^= '0000'B) then RETURN_PTR = Null;
     End;
     When ('2') do;
       If ((RR_FLOATREGS & '00011111'B) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('C') do;
       If ((Unspec(SI_I2) & '11110000'B) ^= '00000000'B) then
         RETURN_PTR = Null;
     End;
     When ('X') do;
       If ((RR1_ZEROES1) ^= '00000000'B) |
          ((RR1_ZEROES2) ^= '0000'B) then
         RETURN_PTR = Null;
     End;
     When ('Y') do;
       If ((RR2_ZEROES) ^= '00000000'B) then RETURN_PTR = Null;
     End;
     Otherwise do;
       RETURN_PTR = Null;
     End;
   End;

 Return (RETURN_PTR);

 End OP_CODE_LOCATOR;

 /*******************************************************************/
1
 VALID_BRANCH_CODE: Proc(IPTR,REMAINING_LENGTH) returns(bit(1)) reorder;

 Dcl IPTR                 ptr,
     REMAINING_LENGTH     fixed(15) bin,
     RETURN_VALUE  static bit(1),
     OPDATA               char(6) based(IPTR),
     DOUBLEOPCODE         bit(16) based(IPTR),
     1 OPCODE            aligned  based(IPTR),
       2 OPCODE1          bit(8),
       2 OPCODE2          bit(8),
     1 BRANCHOPCODES     aligned  based(IPTR),
       2 BRANCHOPCODE     bit(8),
       2 BRANCHSTUFF   unaligned,
         3 BRANCHMASK     bit(4),
         3 BRANCHREG      bit(4);

 If REMAINING_LENGTH < OPLENGTH(IPTR) then RETURN_VALUE = '0'B;

 Else if (
    ((OPCODE1) = '01000101'B)           /* 45 - BAL                */ |
    ((OPCODE1) = '01001101'B)           /* 4D - BAS                */ |
    ((OPCODE1) = '00001011'B)           /* 0B - BSM                */ |
    ((OPCODE1) = '00001100'B)           /* 0C - BASSM              */ |
    (((OPCODE1)='00000101'B) & ((BRANCHREG) ^='0000'B)) /* 05 BALR */ |
    (((OPCODE1)='00001101'B) & ((BRANCHREG) ^='0000'B)) /* 0D BASR */ |
    (((OPCODE1)='00000111'B) & ((BRANCHMASK)^='0000'B)) /* 07 BCR  */ |
    (((OPCODE1)='01000111'B) & ((BRANCHMASK)^='0000'B)) /* 47 BC   */ |
    ((DOUBLEOPCODE) = '0000101000000011'B)   /*  0A03 - EXIT       */ |
    ((DOUBLEOPCODE) = '0000101000000111'B)   /*  0A07 - XCTL       */ |
    ((DOUBLEOPCODE) = '0000101000001101'B)   /*  0A0D - ABEND      */ |
    ((DOUBLEOPCODE) = '1000001000000000'B)   /*  8200 - LPSW       */ |
    ((DOUBLEOPCODE) = '0000000100000001'B)   /*  0101 - PR         */ |
    (((DOUBLEOPCODE)='1011001001000000'B) & ((BRANCHREG)^='0000'B))
                                             /*  B240 - BAKR       */
                  ) then RETURN_VALUE = '1'B;
 Else RETURN_VALUE = '0'B;

 Return (RETURN_VALUE);

 End VALID_BRANCH_CODE;

 /*******************************************************************/
1
 GEN_EFF_ADDR: Proc (SCON,R3,FLAG) returns(char(32) var) reorder;

 Dcl SCON              char(2),
     R3                fixed(31) bin,
     FLAG              char(1),
     SYMBOL     static char(32) var,
     BASEANDDISPLACEMENT static bit(16),
     1 B2D2            def BASEANDDISPLACEMENT,
       2 B2D2UN unaligned,
         3 B2          bit(4),
         3 D2          bit(12),
     BASEREG    static fixed(31) bin,
     BASE       static char(16) var,
     DISPL      static char(16) var,
     DISPL_TEMP static fixed(15) bin;

 BASEANDDISPLACEMENT = Unspec(SCON);
 BASEREG  = (B2);
 BASE     = NUMOUT((BASEREG));
 Unspec(DISPL_TEMP) = BASEANDDISPLACEMENT & '0000111111111111'B;
 DISPL    = NUMOUT((DISPL_TEMP));

 Select (FLAG);
   When ('I') do;
     If BASEREG = 0 & R3 = 0 then SYMBOL = DISPL;
     Else if BASEREG = 0 then SYMBOL = DISPL || '(' ||NUMOUT(R3)|| ')';
     Else if R3 = 0      then SYMBOL = DISPL || '(,'|| BASE     || ')';
     Else SYMBOL = DISPL || '(' ||NUMOUT(R3) || ',' || BASE     || ')';
   End;
   When ('L') do;
     SYMBOL = DISPL || '(' || NUMOUT(R3+1) || ',' || BASE || ')' ;
   End;
   When ('M') do;
     SYMBOL = DISPL || '(' || NUMOUT(R3) || ',' || BASE || ')' ;
   End;
   When ('S') do;
     If BASEREG = 0 then SYMBOL = DISPL;
     Else SYMBOL = DISPL || '(' || BASE || ')' ;
   End;
   Otherwise do;
     SYMBOL = DISPL || '(' || BASE || ')' ;
   End;
 End;

 Return (SYMBOL);

 End GEN_EFF_ADDR;

 /*******************************************************************/
1
 ADD_START_POINT: Proc (ADDRESS) reorder;

 Dcl ADDRESS fixed(31) bin;

 SPQP = LOCATE (Addr(SPQ),ADDRESS);
 If SPQP = Null then do;
   Allocate SPQE set(SPQP);
   SPQE_ADDRESS     = ADDRESS;
   SPQE_LENGTH      = 0;
   SPQE_RELOCATION  = 0;
   SPQE_LABEL       = '';
   SPQE_NAME        = '';
   SPQE_NAME2       = '';
   SPQE_TYPE        = '';
   SPQE_TYPE2       = '';
   String(SPQE_FLAGS) = '00000000'B;
   Call INSERT (SPQP,Addr(SPQ));
 End;

 SPQ.MOST_RECENT = SPQP;

 Return;

 End ADD_START_POINT;

 /*******************************************************************/
1
 PROCESS_CESD: Proc;

 CESD_ESDID = CESD_FIRST_ESDID;

 XA_MODULE = (CESD_XA);

 Addr(CESD_PTR)->N = Addr(LOAD_PTR)->N + 8; /* Bump past CESD_PREFIX */
 Addr(END_PTR)->N = Addr(CESD_PTR)->N + CESD_COUNT;

 LOOP_CESD: Do while (Addr(CESD_PTR)->N < Addr(END_PTR)->N);

   Allocate CEQE set(CEQP);  /* Create a CESD queue entry */
   CEQE_ESDID = CESD_ESDID;
   CEQE_NAME = CESD_NAME;
   CEQE_ADDRESS = CESD_ADDRESS;
   CEQE_LENGTH = CESD_LENGTH;
   CEQE_IDREF = 0;
   CEQE_FLAGS = CESD_SEGMENT;

   Select (CESD_TYPE & '00001111'B);

     When ('00000000'B) do;  /* Section definition */
       CEQE_TYPE = 'SD';
     End;

     When ('00000011'B) do;  /* Label reference */
       CEQE_TYPE = 'LR';
       CEQE_IDREF = CESD_XA_IDREF;
     End;

     When ('00000100'B) do;  /* Private code    */
       If ^ CESD_TYPE_BITS(4) then do;
         CEQE_NAME = '$PRIVATE';
         PRIVATE_CODE = '1'B;
       End;
       CEQE_TYPE = 'PC';
     End;

     When ('00000101'B) do;  /* Common          */
       CEQE_TYPE = 'CM';
     End;

     When ('00000110'B) do;  /* Pseudo register */
       CEQE_TYPE = 'PR';
     End;

     When ('00000111'B) do;  /* Null            */
       CEQE_TYPE = 'NL';
     End;

     When ('00000010'B) do;  /* External reference      */
       CEQE_TYPE = 'ER';
     End;

     When ('00001010'B) do;  /* Weak external reference */
       CEQE_TYPE = 'WX';
     End;

     Otherwise do;
       CEQE_TYPE = '??';
       Put file(DPRINT) skip(1)
             list('XDIS0009S Invalid CESD entry type '|| CESD_TYPE);
     End;

   End;

   If CSECT_NAME = CEQE_NAME & Index('SD PC ER WX',CEQE_TYPE) ^= 0
      then do; /* Establish our csect */
     ESDID = CESD_ESDID;
     If CEQE_TYPE = 'ER' | CEQE_TYPE = 'WX' then do;
       CSECT_LENGTH = -1;
     End;
     Else do;
       CSECT_LENGTH = CESD_LENGTH;
       CSECT_OFFSET = CESD_ADDRESS;
       If ((XA_MODULE) & (CESD_SEGMENT ^= '00000000'B)) then do;
         If CESD_XA_RMODE then RMODE = 'ANY';
         Else                  RMODE = '24 ';
         Select ((CESD_SEGMENT & '00000011'B));
           When ('00000010'B)  AMODE = '31 ';
           When ('00000011'B)  AMODE = 'ANY';
           Otherwise           AMODE = '24 ';
         End;
       End;
     End;
   End;

   Call INSERT(CEQP,Addr(CEQ));  /*  Add CESD entry to queue */

   CESD_ESDID = CESD_ESDID + 1;
   Addr(CESD_PTR)->N = Addr(CESD_PTR)->N + Length(CESD_DATA);

 End LOOP_CESD;

 End PROCESS_CESD;

 /*******************************************************************/
1
 PROCESS_CONTROL: Proc;

 MOVE_TEXT = '0'B;
 Addr(CONTROL_PTR)->N = Addr(LOAD_PTR)->N + 16 /* Length of prefix */
                        + CONTROL_RLD_COUNT;  /* in case combo rec */
 Addr(END_PTR)->N = Addr(CONTROL_PTR)->N + CONTROL_CONTROL_COUNT;
 CONTROL_FIND_CSECT:
 Do while(Addr(CONTROL_PTR)->N < Addr(END_PTR)->N);
   If CONTROL_ESDID = ESDID then do;
     If TEXT_PTR = Null then do;
       Allocate TEXT_BUFFER char(((CSECT_LENGTH+7)/8)*8);
       TEXT_PTR = Addr(TEXT_BUFFER);
     End;
     TEXT_MOVE_OFFSET = Max(0, CONTROL_CCW_ADDRESS - CSECT_OFFSET);
     TEXT_MOVE_SOURCE = Max(0, CSECT_OFFSET - CONTROL_CCW_ADDRESS);
     TEXT_MOVE_LENGTH = CONTROL_LENGTH;
     MOVE_TEXT = '1'B;
     Leave CONTROL_FIND_CSECT;
   End;
  Addr(CONTROL_PTR)->N = Addr(CONTROL_PTR)->N + 4;
 End CONTROL_FIND_CSECT;

 End PROCESS_CONTROL;

 /*******************************************************************/
1
 PROCESS_TEXT: Proc;

 If MOVE_TEXT then do;

   Substr(TEXT_BUFFER,TEXT_MOVE_OFFSET+1,TEXT_MOVE_LENGTH) =
     Substr(TEXT_DATA,TEXT_MOVE_SOURCE+1,TEXT_MOVE_LENGTH);

 End;

 End PROCESS_TEXT;

 /*******************************************************************/
1
 PROCESS_RLD: Proc;

 Addr(RLD_PTR)->N = Addr(LOAD_PTR)->N + 16 /* Length of RLD_PREFIX */;
 Addr(END_PTR)->N = Addr(RLD_PTR)->N + RLD_RLD_COUNT;
 LOOP_RLD: Do while (Addr(RLD_PTR)->N < Addr(END_PTR)->N);

   PROCESS_RLD_SUBENTRIES:
   Do Addr(RLD_SUB_PTR)->N = Addr(RLD_PTR)->N + 4
                             repeat Addr(RLD_SUB_PTR)->N + 4;
     If RLD_POSITION_POINTER = ESDID then do;
       Allocate RAQE set(RAQP);
       RAQE_ADDRESS = RLD_ADDRESS - CSECT_OFFSET;
       RAQE_LENGTH = RLD_LENGTH+1;
       TEMP_PTR = LOCATE(Addr(CEQ),RLD_RELOCATION_POINTER);
       If TEMP_PTR = Null then do;
         RAQE_NAME = '';
         RAQE_RELOCATION = 0;
       End;
       Else do;
         RAQE_NAME = TEMP_PTR->CEQE_NAME;
         RAQE_RELOCATION = TEMP_PTR->CEQE_ADDRESS;
       End;
       String(RAQE_FLAGS) = '00000000'B;
       If RLD_NEGATIVE then RAQE_NEGATIVE = '1'B;
       RAQE_UNRESOLVED = (Substr(RLD_TYPE,1,1));
       RAQE_TYPE = Substr('AVPQ    AV      ',RLD_TYPE+1,1);
       If RAQE_TYPE = 'A' then do;
        If TEMP_PTR->CEQE_TYPE = 'WX' then RAQE_TYPE = 'W';
        Else if TEMP_PTR->CEQE_TYPE = 'ER' then RAQE_TYPE = 'X';
       End;
       Call INSERT(RAQP,Addr(RAQ));
     End;
     If ^ RLD_SAME_RP then Leave PROCESS_RLD_SUBENTRIES;
   End PROCESS_RLD_SUBENTRIES;

   Addr(RLD_PTR)->N = Addr(RLD_SUB_PTR)->N + 4;

 End LOOP_RLD;

 End PROCESS_RLD;

 /*******************************************************************/
1
 INSERT: Proc(E_PTR,Q_PTR) reorder;

 /* This subroutine inserts an element into a queue. */

 Dcl (E_PTR, Q_PTR) ptr,
     P                    static ptr,
     1 Q     like QUEUE          based(Q_PTR),
     1 E                         based(E_PTR),
       2 E_NEXT                  ptr,
       2 E_PREV                  ptr,
       2 E_ARG                   fixed(31) bin;

 P = Q.MOST_RECENT;
 If P ^= Null &
    E_ARG >= P->E_ARG &
    (P->E_NEXT = Null | P->E_NEXT->E_ARG > E_ARG)
   then;
 Else do P = Q.LAST repeat P->E_PREV while (P ^= Null);
   If E_ARG >= P->E_ARG &
      (P->E_NEXT = Null | P->E_NEXT->E_ARG > E_ARG)
     then Leave;
 End;
 E_PREV = P;
 If P ^= Null then do;  /* not at top of queue */
   E_NEXT = P->E_NEXT;
   P->E_NEXT = E_PTR;
 End;
 Else do;               /* top of queue */
   E_NEXT = Q.FIRST;
   Q.FIRST = E_PTR;
 End;
 If E_NEXT = Null then Q.LAST = E_PTR;
 Else E_NEXT->E_PREV = E_PTR;

 End INSERT;

 /*******************************************************************/
1
 DELETE: Proc(E_PTR,Q_PTR) reorder;

 /* This subroutine deletes an element from a queue. */

 Dcl (E_PTR, Q_PTR) ptr,
     1 Q     like QUEUE          based(Q_PTR),
     1 E                         based(E_PTR),
       2 E_NEXT                  ptr,
       2 E_PREV                  ptr;

 If E_PREV = Null then Q.FIRST = E_NEXT;
 Else E_PREV->E_NEXT = E_NEXT;

 If E_NEXT = Null then Q.LAST = E_PREV;
 Else E_NEXT->E_PREV = E_PREV;

 Free E;

 End DELETE;

 /*******************************************************************/
1
 LOCATE: Proc(Q_PTR,ARG) returns(ptr) reorder;

 /* This subroutine locates an element in a queue. */

 Dcl (Q_PTR) ptr,
     ARG    fixed(31) bin,
     P                    static ptr,
     1 Q     like QUEUE          based(Q_PTR),
     1 E                         based(P),
       2 E_NEXT                  ptr,
       2 E_PREV                  ptr,
       2 E_ARG                   fixed(31) bin;

 Do P = Q.FIRST repeat E_NEXT while (P ^= Null);
   If E_ARG = ARG then Leave;
 End;

 Q.MOST_RECENT = P;  /* Set ptr for easy access to element */

 Return(P);

 End LOCATE;

 /*******************************************************************/
1
 NUMOUT: Proc(N) returns(char(14) var) reorder;

 Dcl N              fixed(31) bin,
     N_CHAR  static char(14),
     N_CHAR_VAR     char(14) var;

 N_CHAR = N;

 N_CHAR_VAR = Substr(N_CHAR,Verify(N_CHAR,' '));

 Return (N_CHAR_VAR);

 End NUMOUT;

 /*******************************************************************/
1
 HEXNUM:Proc(NUMBER) returns(char(8)) reorder;

 /* This subroutine takes a binary fullword and returns the
    character representation of the hexadecimal data therein. */

 Dcl NUMBER               fixed(31) bin,
     PACKED_DATA   static fixed(9) dec,
     PACKED_FOUR_BYTES    fixed(31) bin unaligned based,
     HEXUNPACKED9  static pic '(9)9',
     HEXSTRING            char(8)   def HEXUNPACKED9;

 Addr(PACKED_DATA)->PACKED_FOUR_BYTES = NUMBER;
 HEXUNPACKED9 = PACKED_DATA;
 HEXSTRING = Translate(HEXSTRING,TRANS_TABLE);

 Return(HEXSTRING);

 End HEXNUM;

 /*******************************************************************/
1
 HEXOUT:Proc(INPUT) returns(char(1024) var) reorder;

 /* This subroutine takes a character string and returns the
    character representation of the hexadecimal data therein. */

 Dcl INPUT                   char(*)    var,
     PACKEDVALUE      static fixed (9)  dec unaligned,
     HEXVALUE         based  char  (4)      unaligned,
     HEXUNPACKED9     static pic '(9)9',
     HEXDATA                 char(9)    def HEXUNPACKED9,
     I                static fixed(15)  bin,
     HEXSTRING               char(2*Length(INPUT)+4) var init('');

 Do I = 1 to Length(INPUT) by 4;

   Addr(PACKEDVALUE)->HEXVALUE = Substr(INPUT,I);
   HEXUNPACKED9 = PACKEDVALUE;
   HEXSTRING = HEXSTRING || Translate(Substr(HEXDATA,1,8),TRANS_TABLE);

 End;

 Return(Substr(HEXSTRING,1,2*Length(INPUT)));

 End HEXOUT;

 /*******************************************************************/


 End XDIS;

