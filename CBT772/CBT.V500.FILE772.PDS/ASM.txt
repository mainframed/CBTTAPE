./ ADD NAME=$$$INDEX 0100-07332-07332-0900-00464-00464-00000-SEB
------------------------------------------------------------------------
Name:     BLOWJOB
Type:     ASM
Purpose:  Program to force job to ABEND.  Parm passed = desired code.
Requires:
Used by:
Comments: Same as BLOWUP except that it causes a STEP ABEND.
------------------------------------------------------------------------
Name:     BLOWUP
Type:     ASM
Purpose:  Program to force a user ABEND.  Parm passed = desired code.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     DCBADDR
Type:     ASM
Purpose:  Subroutine to return address of a DCB to a PL/1 program.
Requires: INCLUDE DCLDCB
Used by:
Comments: See comment block in source for usage from PL/1.
------------------------------------------------------------------------
Name:     DRIVERFS
Type:     ASM
Purpose:  Driver program for ACF82SCR full-screen logon module
Requires:
Used by:
Comments: ACF2
------------------------------------------------------------------------
Name:     DRIVERSU
Type:     ASM
Purpose:  Driver program for IKJEFF10 TSO SUBMIT exit routine
Requires:
Used by:
Comments: Better than IBM's driver.
------------------------------------------------------------------------
Name:     EJECT
Type:     ASM
Purpose:  TSO command to perform a page eject in background TMP
Requires:
Used by:
Comments: This stopped working as of TSO/E Version 2 because of the use
          of key 1 storage for TSO control blocks.  Otherwise, was very
          useful in conjunction with XTERMOUT.
------------------------------------------------------------------------
Name:     FSOFF
Type:     ASM
Purpose:  Program to turn full screen mode off under TSO/VTAM.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     FSON
Type:     ASM
Purpose:  Program to turn full screen mode on under TSO/VTAM.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     GETDSN
Type:     ASM
Purpose:  Routine to return a DSNAME given a DDNAME
Requires:
Used by:
Comments: Callable from FORTRAN or PL/1
          Requires SWA=BELOW
------------------------------------------------------------------------
Name:     GETJID
Type:     ASM
Purpose:  Routine to return JES2 JOBID
Requires:
Used by:
Comments: Callable from FORTRAN or PL/1
          Requires ACF2
------------------------------------------------------------------------
Name:     GETPGM
Type:     ASM
Purpose:  Routine to return name of executing program
Requires:
Used by:
Comments: Callable from FORTRAN or PL/1
          Requires ACF2
------------------------------------------------------------------------
Name:     H
Type:     ASM
Purpose:  Subcommand to execute TSO commands or CLISTs under TSO TEST
Requires:
Used by:
Comments: Not as much needed as it once was.  Patterned after the old
          Program Control Facility "X" subcommand.
------------------------------------------------------------------------
Name:     IKJEFF10
Type:     ASM
Purpose:  TSO SUBMIT exit routine
Requires:
Used by:
Comments: Assumes ACF2 in use.  Contains hardcoded defaults for JOB card
          parameters like TIME and REGION.
------------------------------------------------------------------------
Name:     IUCVUDP
Type:     ASM
Purpose:  Program to demonstrate TCP/IP UDP via IUCV
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     PBRHLPA
Type:     ASM
Purpose:  Use BRIF to display TSO command output under ISPF.
Requires: INCLUDE XTSOVAR
          ASM     XTSOVAR
          PLI     PBRHELP
          PLI     PBRHLPR
Used by:  CLIST BRHELP
Comments:
------------------------------------------------------------------------
Name:     PROMPT
Type:     ASM
Purpose:  TSO command to test the PUTGET PROMPT function.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     RECSIZE
Type:     ASM
Purpose:  Subroutine to return record size of a file to a PL/1 program.
Requires:
Used by:
Comments: See comment block in source for usage from PL/1.
------------------------------------------------------------------------
Name:     TCBMAP
Type:     ASM
Purpose:  Program to map TCB tree system control blocks.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     TMPOFF
Type:     ASM
Purpose:  Program to turn Session Manager mode off via STTMPMD.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     TMPON
Type:     ASM
Purpose:  Program to turn Session Manager mode on via STTMPMD.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     VITWHR
Type:     ASM
Purpose:  IPCS TCB exit to return WHERE an address is, in ISPF variables
Requires:
Used by:  CLIST IPRB
Comments: IPCS,ISPF
------------------------------------------------------------------------
Name:     VMCFTCP
Type:     ASM
Purpose:  Program to demonstrate TCP/IP via VMCF
Requires:
Used by:
Comments: Some source code lifted from IBM PASCAL files
------------------------------------------------------------------------
Name:     VMCFUDP
Type:     ASM
Purpose:  Program to demonstrate UDP via VMCF
Requires:
Used by:
Comments: Some source code lifted from IBM PASCAL files
------------------------------------------------------------------------
Name:     XABDGET
Type:     ASM
Purpose:  Interface module for IPCS verb exits / TSO command processors
Requires:
Used by:  ASM XIP*
Comments: Requires IPCS, but is designed to enable other ASM routines to
          function as either IPCS verb exits or TSO command processors.
          Thus, they can collect and display data either from an IPCS
          dump or the live session.
------------------------------------------------------------------------
Name:     XACF2
Type:     ASM
Purpose:  Program to test ACF2 access
Requires:
Used by:
Comments: ACF2
------------------------------------------------------------------------
Name:     XALCMOD
Type:     ASM
Purpose:  TSO command to modify allocations
Requires:
Used by:
Comments: Requires SWA=BELOW
------------------------------------------------------------------------
Name:     XALCUNIT
Type:     ASM
Purpose:  TSO command to return allocation info about a unit address
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XALLOCSV
Type:     ASM
Purpose:  TSO command to save current allocation info in a data set
Requires:
Used by:
Comments: Requires SWA=BELOW
------------------------------------------------------------------------
Name:     XAMODE
Type:     ASM
Purpose:  Function that returns current AMODE to FORTRAN or PL/1 program
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XCLIST
Type:     ASM
Purpose:  Subroutine to run a TSO command or CLIST from a PL/1 program
Requires: ASM XTSEXEC
Used by:
Comments:
------------------------------------------------------------------------
Name:     XCONCAT
Type:     ASM
Purpose:  TSO command to concatenate 2 or more preallocated files
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XDECONC
Type:     ASM
Purpose:  TSO command to deconcatenate a concatenated file name
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XFINDM
Type:     ASM
Purpose:  Program to tell where member is in PDS concatenation
Requires:
Used by:  CLIST FINDMEM
Comments: When there are too many libraries in the linklist (for when
          no DDNAME is given), or too many datasets allocated to a given
          DDNAME, ABEND S013-E4 results due to too many extents.  Hence
          the FINDMEM2 CLIST replaced the FINDMEM CLIST and doesn't use
          the XFINDM routine at all.
------------------------------------------------------------------------
Name:     XGET
Type:     ASM
Purpose:  Subroutine to do a TGET from a PL/1 program
Requires:
Used by:  lots of PLI programs
Comments:
------------------------------------------------------------------------
Name:     XIPMAP
Type:     ASM
Purpose:  IPCS verb exit to map TCB tree control blocks
Requires: ASM XABDGET
Used by:
Comments: Can be used on TSO or under IPCS (see XABDGET).
------------------------------------------------------------------------
Name:     XIPSWHR
Type:     ASM
Purpose:  IPCS verb exit to return "where" information about an address
Requires:
Used by:
Comments: Not flexible like XIPWHR, but supports searching IPCS NUCMAP.
------------------------------------------------------------------------
Name:     XIPWHR
Type:     ASM
Purpose:  IPCS verb exit to return "where" information about an address
Requires: ASM XABDGET
Used by:
Comments: Can be used on TSO or under IPCS (see XABDGET).
------------------------------------------------------------------------
Name:     XITMAP
Type:     ASM
Purpose:  IPCS TCB exit to map RB control blocks
Requires: ASM XABDGET
Used by:
Comments: Can be used on TSO or under IPCS (see XABDGET).
------------------------------------------------------------------------
Name:     XITSAV
Type:     ASM
Purpose:  IPCS TCB exit to display save area trace
Requires: ASM XABDGET
Used by:
Comments: Can be used on TSO or under IPCS (see XABDGET).
------------------------------------------------------------------------
Name:     XITWHR
Type:     ASM
Purpose:  IPCS TCB exit to tell "where" an address is
Requires: ASM XABDGET
Used by:
Comments: Can be used on TSO or under IPCS (see XABDGET).
------------------------------------------------------------------------
Name:     XLBRKS
Type:     ASM
Purpose:  TSO TEST subcommand to list breakpoints
Requires: MACRO TCOMTAB
Used by:
Comments: See note under MACLIB TCOMTAB.  You may not be legally able
          to assemble this routine!
          Should be aliased to LISTBRKS, unless you use a REXX exec by
          that name to invoke it, which may be necessary to get TSO TEST
          to treat it as a subcommand.  You could also use the "H" hack
          (see H) to run it.
------------------------------------------------------------------------
Name:     XLL
Type:     ASM
Purpose:  Program to scan load modules for character strings
Requires:
Used by:
Comments: Has an ISPF interface (see ...)
------------------------------------------------------------------------
Name:     XLNKLST
Type:     ASM
Purpose:  TSO command to allocate the link list
Requires: HELP XLNKLST
Used by:  CLIST ALLOCLNK
Comments: (See HELP XLNKLST)
------------------------------------------------------------------------
Name:     XLSYMS
Type:     ASM
Purpose:  TSO TEST subcommand to list equated symbols
Requires: MACRO TCOMTAB
Used by:
Comments: See note under MACLIB TCOMTAB.  You may not be legally able
          to assemble this routine!
          Should be aliased to LISTSYMS, unless you use a REXX exec by
          that name to invoke it, which may be necessary to get TSO TEST
          to treat it as a subcommand.  You could also use the "H" hack
          (see H) to run it.
------------------------------------------------------------------------
Name:     XPROC
Type:     ASM
Purpose:  TSO command to emulate CLIST PROC statement for REXX
Requires: ...
Used by:  lots of CLIST members
Comments: This is also on the CBT tape in File 431.
------------------------------------------------------------------------
Name:     XPUT
Type:     ASM
Purpose:  Subroutine to do a TPUT from a PL/1 program
Requires:
Used by:  lots of PLI programs
Comments: There is also an XPUTLINE routine, but it's not mine and I may
          not have the freedom to distribute it.
------------------------------------------------------------------------
Name:     XRXDEQ
Type:     ASM
Purpose:  REXX module to do a DEQ
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XRXENQ
Type:     ASM
Purpose:  REXX module to do an ENQ
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XTSEXEC
Type:     ASM
Purpose:  Run time TSO command or CLIST executor
Requires:
Used by:  ASM XCLIST
Comments:
------------------------------------------------------------------------
Name:     XQSCAN
Type:     ASM
Purpose:  TSO command to display ENQ information.
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XRXVARS
Type:     ASM
Purpose:  REXX utility to display values of REXX variables
Requires:
Used by:  CLIST SYSCALL
Comments:
------------------------------------------------------------------------
Name:     XTSOVAR
Type:     ASM
Purpose:  Function used by PL/I programs to access CLIST variables
Requires: INCLUDE XTSOVAR
Used by:  PLI PBRHELP
Comments: Also see XTSVAR,XTSVARV
------------------------------------------------------------------------
Name:     XTSVAR
Type:     ASM
Purpose:  Function used by FORTRAN programs to access CLIST variables
Requires:
Used by:
Comments: Same as XTSOVAR (q.v.).
------------------------------------------------------------------------
Name:     XTSVARV
Type:     ASM
Purpose:  Function used by PL/I programs to access CLIST variables
Requires: INCLUDE XTSOVAR
Used by:
Comments: Also see XTSVAR,XTSOVAR.  Looks substantially same as XTSOVAR
------------------------------------------------------------------------
Name:     XUSERS
Type:     ASM
Purpose:  TSO command to display users logged on
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XUSING
Type:     ASM
Purpose:  TSO command to display who is using a volume or unit
Requires:
Used by:
Comments:
------------------------------------------------------------------------
Name:     XVOLUME
Type:     ASM
Purpose:  Display UCB information about devices
Requires:
Used by:  CLIST DU
Comments:
------------------------------------------------------------------------
Name:     XVX
Type:     ASM
Purpose:  ISPF dialog program to display virtual storage
Requires: PANEL XVX*, TXVX*
          MSG XVX*
Used by:
Comments:
------------------------------------------------------------------------
Name:     XWRITENR
Type:     ASM
Purpose:  REXX function to emulate CLIST XWRITENR statement for REXX
Requires: ...
Used by:  lots of CLIST members
Comments: This is also on the CBT tape in File 431.
------------------------------------------------------------------------
Name:     YITADDR
Type:     ASM
Purpose:  IPCS TCB exit to return a hex address as a CLIST variable
Requires:
Used by:
Comments: IPCS
------------------------------------------------------------------------
Name:     YITSAV
Type:     ASM
Purpose:  IPCS TCB exit to display save area trace
Requires:
Used by:
Comments: IPCS
------------------------------------------------------------------------
Name:     YITWHR
Type:     ASM
Purpose:  IPCS TCB exit to return where an address is as CLIST variable
Requires:
Used by:
Comments: IPCS
------------------------------------------------------------------------
./ ADD NAME=BLOWJOB  0100-07332-07332-0900-00095-00095-00000-SEB
         TITLE 'BLOWJOB - MODULE TO CAUSE JOB TO ABEND'
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
BLOWJOB  CSECT
         SAVE  (14,12),,BLOWJOB_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING BLOWJOB,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
         L     R2,0(,R2)           GET ADDRESS OF PARM STRING
         LH    R3,0(,R2)           GET LENGTH OF PARM STRING
         LTR   R3,R3               IF NULL PARM STRING
         BNZ   GETCODE             THEN
         XR    R1,R1                USE USER CODE OF ZERO
         B     ABEND               ELSE
GETCODE  CH    R3,=H'3'            IF CODE LENGTH IS 3
         BNE   NOT0CX              AND
         CLC   2(2,R2),=C'0C'      CODE BEGINS WITH 0C
         BNE   NOT0CX              THEN
         MVC   ABCODE,4(R2)         GET PROGRAM CHECK CODE
         TR    ABCODE,TRTBL         TRANSLATE TO BINARY NUMERIC
         XR    R1,R1                CLEAR INSERT REG
         IC    R1,ABCODE            GET NUMERIC ABEND CODE
         LA    R1,X'0C0'(,R1)       ADD 0C TO GET ABEND CODE
         SLL   R1,12                MAKE IT OCX000
         B     ABEND
NOT0CX   DS    0H
         BCTR  R3,0                REDUCE PARM LENGTH FOR EXECUTE
         EX    R3,PACK             PACK PARM INTO CONVERSION DOUBLEWORD
         CVB   R1,DOUBLE           PICK UP ABEND CODE
ABEND    DS    0H
         SPACE 1
         ABEND (1),DUMP,STEP
         SPACE 1
         EJECT
***********************************************************************
* EXECUTED INSTRUCTION                                                *
***********************************************************************
PACK     PACK  DOUBLE(8),2(0,R2)  PACK PARM INTO DOUBLEWORD
         SPACE 1
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
TRTBL    DC    256YL1(*-TRTBL)
         ORG   TRTBL+C'0'
         DC    YL1(0,1,2,3,4,5,6,7,8,9)
         ORG   TRTBL+C'A'
         DC    YL1(10,11,12,13,14,15)
         ORG
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
ABCODE   DS    C
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         END
./ ADD NAME=BLOWUP   0100-07332-07332-0900-00099-00099-00000-SEB
         TITLE 'BLOWUP - MODULE TO CAUSE AN ABEND'
***********************************************************************
*                                                                     *
* BLOWUP - MODULE TO CAUSE A USER ABEND                               *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
BLOWUP   CSECT
         SAVE  (14,12),,BLOWUP_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING BLOWUP,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
         L     R2,0(,R2)           GET ADDRESS OF PARM STRING
         LH    R3,0(,R2)           GET LENGTH OF PARM STRING
         LTR   R3,R3               IF NULL PARM STRING
         BNZ   GETCODE             THEN
         XR    R1,R1                USE USER CODE OF ZERO
         B     ABEND               ELSE
GETCODE  CH    R3,=H'3'            IF CODE LENGTH IS 3
         BNE   NOT0CX              AND
         CLC   2(2,R2),=C'0C'      CODE BEGINS WITH 0C
         BNE   NOT0CX              THEN
         MVC   ABCODE,4(R2)         GET PROGRAM CHECK CODE
         TR    ABCODE,TRTBL         TRANSLATE TO BINARY NUMERIC
         XR    R1,R1                CLEAR INSERT REG
         IC    R1,ABCODE            GET NUMERIC ABEND CODE
         LA    R1,X'0C0'(,R1)       ADD 0C TO GET ABEND CODE
         SLL   R1,12                MAKE IT OCX000
         B     ABEND
NOT0CX   DS    0H
         BCTR  R3,0                REDUCE PARM LENGTH FOR EXECUTE
         EX    R3,PACK             PACK PARM INTO CONVERSION DOUBLEWORD
         CVB   R1,DOUBLE           PICK UP ABEND CODE
ABEND    DS    0H
         SPACE 1
         ABEND (1),DUMP
         SPACE 1
         EJECT
***********************************************************************
* EXECUTED INSTRUCTION                                                *
***********************************************************************
PACK     PACK  DOUBLE(8),2(0,R2)  PACK PARM INTO DOUBLEWORD
         SPACE 1
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
TRTBL    DC    256YL1(*-TRTBL)
         ORG   TRTBL+C'0'
         DC    YL1(0,1,2,3,4,5,6,7,8,9)
         ORG   TRTBL+C'A'
         DC    YL1(10,11,12,13,14,15)
         ORG
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
ABCODE   DS    C
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         END
./ ADD NAME=DCBADDR  0100-07332-07332-0900-00045-00045-00000-SEB
***********************************************************************
*                                                                     *
* PROCEDURE NAME:  DCBADDR                                            *
*                                                                     *
* FUNCTION:  TO RETURN A POINTER TO THE DCB OF A PL/1 FILE.           *
*                                                                     *
* DECLARATION:                                                        *
*                                                                     *
*     DCL DCBADDR EXTERNAL ENTRY(FILE) RETURNS(PTR);                  *
*                                                                     *
* SAMPLE INVOCATION:                                                  *
*                                                                     *
*     %INCLUDE SYSLIB(DCLDCB);  /* DECLARE DCB ATTRIBUTES */          *
*                                                                     *
*     DCL    SYSPRINT_DCB CHAR(96) BASED(DCBPTR),                     *
*            DCBPTR       PTR;                                        *
*                                                                     *
*     DCBPTR = DCBADDR(SYSPRINT);                                     *
*                                                                     *
*     IF DCBPTR ^= NULL THEN                                          *
*       BLOCKSIZE = DCBPTR -> DCBBLKSI;                               *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE
DCBADDR  CSECT
         USING DCBADDR,15
         STM   14,4,12(13)
         LM    2,3,0(1)            R2 -> ADDR(DCLCB), R3 -> RETURN AREA
         L     2,0(,2)             R2 -> DCLCB
         L     1,4(,12)            R1 -> PRV
         AH    1,2(,2)              ADD OFFSET OF FCB PTR IN PRV
         ICM   4,15,0(1)           R4 -> FCB
         BZ    NODCB               IF NO FCB, RETURN(NULL)
         ICM   4,15,20(4)          R4 -> DCB
         BZ    NODCB               IF NO DCB, RETURN(NULL)
         LA    0,0(,4)             R0 = ADDR(DCB)
         B     RETURN
NODCB    DS    0H                  NO DCB, USE NULL BUILT-IN FUNCTION
         LA    0,255               R0 = X'000000FF'
         SLL   0,24                R0 = X'FF000000'
RETURN   ST    0,0(,3)             STORE RESULT IN RETURN AREA
         LM    14,4,12(13)
         BR    14
         END
./ ADD NAME=DRIVERFS 0100-07332-07332-0900-00382-00382-00000-SEB
         TITLE 'DRIVERFS - ACF2 FULL-SCREEN LOGON DRIVER'
***********************************************************************
*                                                                     *
* DRIVERFS - ACF2 FULL-SCREEN LOGON DRIVER                            *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    MISCELLANEOUS USES
R4       EQU   4    .
R5       EQU   5    Address of buffer to hold menu
R6       EQU   6    Length of full screen logon menu
R7       EQU   7    Length of buffer to hold menu
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   Address of ACF82SCR
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
DRIVERFS CSECT
         SAVE  (14,12),,DRIVERFS_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING DRIVERFS,R12
*
* THIS PROGRAM IS NOT REENTRANT.
* THEREFORE THE SAVE AREA IS INLINE.
*
         LA    R14,SAVEAREA
         ST    R13,4(,R14)
         ST    R14,8(,R13)
         LR    R13,R14
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* Load the ACF2 full-screen logon module, ACF82SCR.                   *
*                                                                     *
***********************************************************************
         SPACE 1
         LOAD  EPLOC==CL8'ACF82SCR'
         LR    R11,R0              Save its address
         SPACE 1
***********************************************************************
*                                                                     *
*  The layout of ACF82SCR is as follows:                              *
*                                                                     *
*  +00   4    C'OSCR'                                                 *
*  +04   4    Offset to screen definition                             *
*  +08   4    Length of output screen                                 *
*  +0C   *    Field definitions.  Each is 12 bytes long as follows:   *
*                                                                     *
*    +00  4   Field identifier                                        *
*    +04  4   Offset into ACF82SCR of field                           *
*    +08  4   Length of field                                         *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R6,8(,R11)          Get length of output screen
         LA    R7,16(,R6)          Add some slack bytes
         GETMAIN R,LV=(R7)
         LR    R5,R1
         SPACE 1
         MVC   0(L'INTRO,R5),INTRO Move in TPUT FULLSCR header
         SPACE 1
         L     R14,4(,R11)         Load offset of screen definition
         AR    R14,R11             Convert to absolute address
         ST    R14,ENDFLD          Save as end of field definitions
         LA    R0,L'INTRO(,R5)     Point into getmained buffer
         LR    R1,R6               Get length to move
         LR    R15,R6
         MVCL  R0,R14              Move ACF82SCR menu to getmained menu
         SPACE 1
         SPACE 1
***********************************************************************
*                                                                     *
* Process the field definitions.  For each field definition, we find  *
* the entry in our own table that matches the field identifier, and   *
* move the corresponding data to the menu in the buffer.              *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R4,12(,R11)         Point to first field definition
FLDLOOP  DS    0H
         C     R4,ENDFLD           until end of field definitions
         BNL   FLDEND
         L     R8,0(,R4)           Load character field identifier
         LA    R9,ENTRIES          Start looking at our entries
ENTLOOP  DS    0H
         C     R9,=A(ENDENTRS)
         BNL   NOTFOUND
         CL    R8,0(,R9)
         BE    FOUND
         LA    R9,12(,R9)
         B     ENTLOOP
FOUND    DS    0H
         L     R14,4(,R4)          Get offset of menu field
         LA    R14,2(R5,R14)       Convert to address in menu buffer
         L     R2,4(,R9)           Get address of our field data
         L     R3,8(,R9)           Get length of our field data
         L     R15,8(,R4)          Get length of their field data
         TM    4(R9),X'80'         If this is a field to move directly
         BZ    NOTDIREC            then
         LTR   R15,R15              if the field length is zero (CURS)
         BNZ   NOTZERO              then
         LR    R15,R3                load field length from ours
NOTZERO  DS    0H
         MVCL  R14,R2              Move our field data to menu buffer
         B     FLDCONT
NOTDIREC DS    0H                  else
         TM    8(R9),X'80'         If this is a boolean field
         BZ    NOTBOOL             then
         LH    R3,10(,R9)           reload length
         LA    R14,3+2+3(,R14)      reload address
         MVCL  R14,R2              Move our field data to menu buffer
         B     FLDCONT
NOTBOOL  DS    0H
         LA    R14,3+3+10+4+2+3(,R14) reload address
         MVCL  R14,R2              Move our field data to menu buffer
         B     FLDCONT
NOTFOUND DS    0H                  else
         LA    R14,3+3+10+4+2+3(,R14) reload address
         XR    R2,R2
         XR    R3,R3
         ICM   R15,B'1000',=CL1'?'
         MVCL  R14,R2              Move our field data to menu buffer
         B     FLDCONT
FLDCONT  DS    0H
         LA    R4,12(,R4)          Continue with next menu field
         B     FLDLOOP
FLDEND   DS    0H
         SPACE 1
*                                  Convert all row-and-column specs
*                                  to true 3270 buffer addresses
         LA    R15,L'INTRO+1(,R5)  Point to beginning of TPUT data
         LA    R14,L'INTRO(,R6)    Get length of menu plus intro
         AR    R14,R15             Point to end of menu
SBALOOP  DS    0H
         CR    R15,R14             Loop until hit end of buffer
         BNL   SBAEND
         CLI   0(R15),X'11'
         BE    CONVSBA
         CLI   0(R15),X'3C'
         BE    CONVRA
         CLI   0(R15),X'1D'
         BE    CONVSF
         LA    R15,1(,R15)
         B     SBALOOP
CONVSBA  DS    0H
         LA    R1,1(,R15)          Point to buffer address
         BAL   R2,CONVERT
         LA    R15,3(,R15)
         B     SBALOOP
CONVRA   DS    0H
         LA    R1,1(,R15)          Point to buffer address
         BAL   R2,CONVERT
         LA    R15,4(,R15)
         B     SBALOOP
CONVSF   DS    0H                  Just skip over it
         LA    R15,2(,R15)
         B     SBALOOP
         SPACE 1
SBAEND   DS    0H
         SPACE 1
         XC    AREA,AREA           Clear TGET area
         SPACE 1
RESHOWF  DS    0H
         STFSMODE ON,INITIAL=YES
RESHOW   DS    0H
         TCLEARQ INPUT
         LA    R0,L'INTRO(,R6)     Get length of menu plus intro
         TPUT  (R5),(0),FULLSCR
         TGET  AREA,L'AREA,ASIS
         SPACE 1
         CH    R15,=H'8'           If ATTN was hit
         BE    RESHOWF             then reset full screen env, reshow.
         SPACE 1
         CLI   AREA,X'6E'          If PA2 hit
         BE    RESHOW              then reshow the panel.
         CLI   AREA,X'F3'          If PF3 hit
         BE    EXIT                then exit.
         CLI   AREA,X'C3'          If PF15 hit
         BE    EXIT                then exit.
*        ...                       Else do stuff
         B     RESHOW              and reshow.
         SPACE 1
EXIT     DS    0H
         SPACE 1
         STFSMODE OFF
         SPACE 1
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
***********************************************************************
*                                                                     *
* Cleanup.                                                            *
*                                                                     *
***********************************************************************
         SPACE 1
         FREEMAIN R,LV=(R7),A=(R5)
         SPACE 1
         DELETE EPLOC==CL8'ACF82SCR'
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
CONVERT  DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine converts a row-and-column to 3270 SBA at R1?.       *
*                                                                     *
***********************************************************************
*
         CLI   0(R1),X'40'         Only convert "r-c" values
         BNLR  R2
         XR    R0,R0
         IC    R0,0(,R1)           Get row number
         BCTR  R0,0                Convert to absolute
         MH    R0,=H'80'
         MVI   0(R1),X'00'
         AH    R0,0(,R1)           Add column number
         BCTR  R0,0                Convert to absolute
         STH   R0,0(,R1)           Use absolute as buffer address
         BR    R2                  Return to caller
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
INTRO    DC    X'27F5'             Escape plus erase-write-alternate
         SPACE 1
ENTRIES  DS    0A                  Start of field entry table
         DC    CL4'    '           Field ID
         DC    A(*-*)              Address of data area
         DC    A(0)                Length
         DC    CL4' LID'             FIELD IDENTIFIER           ACF 400
         DC    A($LID)               OFFSET INTO CSECT OF FIELD ACF 400
         DC    A(L'$LID)             LENGTH OF FIELD            ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'SRCE'             FIELD ID                   ACF 400
         DC    A($SRCE)              OFFSET                     ACF 400
         DC    A(L'$SRCE)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4' GRP'             FIELD ID                   ACF 400
         DC    A($GRP)
         DC    A(L'$GRP)             LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'PROC'             FIELD ID                   ACF 400
         DC    A($PROC)
         DC    A(L'$PROC)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'MSGC'             FIELD ID                   ACF 400
         DC    A($MSGC)
         DC    A(L'$MSGC)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'UNIT'             FIELD ID                   ACF 400
         DC    A($UNIT)              OFFSET                     ACF 400
         DC    A(L'$UNIT)            LENGTH                     TS79674
         SPACE 1                                                ACF 400
         DC    CL4'TIME'             FIELD ID                   ACF 400
         DC    A($TIME)              OFFSET                     ACF 400
         DC    A(L'$TIME)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'SIZE'             FIELD ID                   ACF 400
         DC    A($SIZE)              OFFSET                     ACF 400
         DC    A(L'$SIZE)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'ACCT'             FIELD ID                   ACF 400
         DC    A($ACCT)              OFFSET                     ACF 400
         DC    A(L'$ACCT)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'PERF'             FIELD ID                   ACF 400
         DC    A($PERF)              OFFSET                     ACF 400
         DC    A(L'$PERF)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'MAIL'             FIELD ID                   ACF 400
         DC    A($MAIL)              OFFSET                     ACF 400
         DC    X'8000'
         DC    Y(L'$MAIL)
         SPACE 1                                                ACF 400
         DC    CL4'NOTC'             FIELD ID                   ACF 400
         DC    A($NOTC)              OFFSET                     ACF 400
         DC    X'8000'
         DC    Y(L'$NOTC)
         SPACE 1                                                ACF 400
         DC    CL4'RECV'             FIELD ID                   ACF 400
         DC    A($RECV)              OFFSET                     ACF 400
         DC    X'8000'
         DC    Y(L'$RECV)
         SPACE 1                                                ACF 400
         DC    CL4'RECN'             FIELD ID                   ACF 400
         DC    A($RECN)
         DC    X'8000'
         DC    Y(L'$RECN)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'USER'             FIELD ID                   ACF 400
         DC    A($USER)              OFFSET                     ACF 400
         DC    A(L'$USER)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'CURS'             FIELD ID                   ACF 400
         DC    A($CURS+X'80000000')  AREA TO PLACE CURSOR ADDRESS
         DC    A(L'$CURS)            FLD HAS NO CORRESPONDING INPUT FLD
         SPACE 1                                                ACF 400
         DC    CL4'RLSE'             FIELD ID                   ACF 400
         DC    A($RELS+X'80000000')  ADDRESS OF RELEASE AREA    ACF 400
         DC    A(L'$RELS)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'MSG1'             FIELD ID                   ACF 400
         DC    A($MSG1+X'80000000')
         DC    A(L'$MSG1)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'MSG2'             FIELD ID                   ACF 400
         DC    A($MSG2+X'80000000')
         DC    A(L'$MSG2)            LENGTH                     ACF 400
         SPACE 1                                                ACF 400
         DC    CL4'MSG3'             FIELD ID                   ACF 400
         DC    A($MSG3+X'80000000')
         DC    A(L'$MSG3)            LENGTH                     ACF 400
ENDENTRS DS    0A                  End of field entry table
         SPACE 2
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
* NON-REENTRANT INLINE SAVE AREA FOLLOWS
         SPACE 1
SAVEAREA DS    18F
ENDFLD   DS    A                   Address of end of field definitions
$LID     DC    C'SEB1525'
$SRCE    DC    C'LOCFUBAR'
$GRP     DC    C'THE FUGS'
$PROC    DC    C'MAIN    '
$MSGC    DC    C'H'
$UNIT    DC    C'SYSALLDA'
$TIME    DC    C'(2,30)'
$SIZE    DC    C'6144K'
$ACCT    DC    C'(9050-00,3333)'
$PERF    DC    C'NONE'
$MAIL    DC    C'YES'
$NOTC    DC    C'YES'
$RECV    DC    C'NO '
$RECN    DC    C'NO '
$USER    DC    C'ROOM(UP) /* whatever you want to insert here */'
$CURS    DC    X'114040'           Cursor position
$RELS    DC    C'4.1.0'
$MSG1    DC    C'This is message number 1.'
$MSG2    DC    C'This is message number 2.'
$MSG3    DC    C'This is message number 3.'
         SPACE 1
AREA     DS    CL256               Area for TGETs
         SPACE 2
*
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         END
./ ADD NAME=DRIVERSU 0100-07332-07332-0900-00845-00845-00000-SEB
         TITLE 'DRIVERSU - SUBMIT EXIT DRIVER (INSTEAD OF DRIVER10)'
***********************************************************************
*                                                                     *
* DRIVERSU - SUBMIT EXIT DRIVER (INSTEAD OF DRIVER10)                 *
*                                                                     *
***********************************************************************
*                                                                     *
* LINKAGE EDITOR ATTRIBUTES: NORENT, NOREUS, NCAL                     *
*                                                                     *
***********************************************************************
*                                                                     *
* THIS IS A DRIVER FOR SUBMIT EXIT IKJEFF10.  IT WAS WRITTEN BECAUSE  *
* THE IPO-SUPPLIED DRIVER (DRIVER10) DOESN'T SEEM TO WORK.  THIS ONE  *
* IS USED TO TEST OUT CHANGES TO THE SUBMIT EXIT.  IT READS THE INPUT *
* JCL FROM DDNAME SUBMIT, CALLS THE EXIT WHERE APPROPRIATE, AND       *
* DISPLAYS THE OUTPUT JCL AT THE TERMINAL AND INDICATES WHETHER THE   *
* JOB WOULD HAVE BEEN SUBMITTED OR NOT.  THE EXIT MAY BE LINKEDITED   *
* WITH THIS MODULE OR DYNAMICALLY LOADED.  NOTE THAT ANY INSTRUCTIONS *
* WHICH ARE DEPENDENT ON SUPERVISOR STATE (E.G. MODESET'S) MUST BE    *
* BYPASSED WHEN RUNNING UNDER THIS DRIVER.                            *
*                                                                     *
***********************************************************************
*                                                                     *
* EVERY ATTEMPT HAS BEEN MADE TO SIMULATE THE ACTUAL PROCESSING OF    *
* THE SUBMIT COMMAND, WARTS AND ALL, WITHIN CERTAIN LIMITATIONS.      *
* NOTE: AT THIS TIME THE DRIVER DOES NOT HANDLE CERTAIN CONDITIONS.   *
* LOGON COMMANDS (WHICH CAUSE SUBMIT TO GENERATE TMP-IN-BATCH JCL)    *
* ARE NOT SCANNED FOR.  THE PROBLEM WHEREBY JCL BEGINNING WITH A JES2 *
* CARD IS NOT PROCESSED CORRECTLY BY SUBMIT IS NOT "SIMULATED" HERE.  *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
DRIVERSU CSECT
         SAVE  (14,12),,DRIVERSU_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING DRIVERSU,R12
*
* THIS PROGRAM IS NOT REENTRANT.
* THEREFORE THE SAVE AREA IS INLINE.
*
         LA    R14,SAVEAREA
         ST    R13,4(,R14)
         ST    R14,8(,R13)
         LR    R13,R14
         EJECT
         ICM   R15,15,EFF10ADR     IF IKJEFF10 NOT LINKED WITH US
         BNZ   GOTIT               THEN
         LOAD  EP=IKJEFF10          LOAD IT
         ST    R0,EFF10ADR          AND SAVE ITS ADDRESS
GOTIT    DS    0H
         TPUT  ASKVER,L'ASKVER
         TGET  ANSWER,1
         TCLEARQ INPUT
         OI    ANSWER,X'40'
         CLI   ANSWER,C'Y'
         BE    YESVER
         CLI   ANSWER,C'N'
         BE    NOVER
         B     GOTIT
YESVER   DS    0H
         MVI   NEWVER,1
         B     LETSGO
NOVER    DS    0H
         MVI   NEWVER,0
         B     LETSGO
LETSGO   DS    0H
         L     R15,X'21C'          TCB
         L     R15,X'B4'(,R15)     JSCB
         L     R15,X'15C'(,R15)    ACTIVE JSCB
         L     R7,X'108'(,R15)     PSCB
         USING PSCB,R7
         MVC   DEFCLASS,PSCBSUBC   SUBMIT CLASS FOR DEFAULT JOBCARD
         MVC   USERID,BLANKS
         XR    R14,R14
         ICM   R14,1,PSCBUSRL      LENGTH OF USERID
         BZ    NOUSERID            IF NONZERO,
         BCTR  R14,0               THEN
         EX    R14,MOVEUID          MOVE USERID FROM PSCB TO USERID
NOUSERID DS    0H
         MVC   JOBCARD1+2(7),USERID SET UP USER'S ID FOR JOB CARDS
         MVC   JOBCARD2+15(7),USERID
         MVC   JOBCARD3+22(7),USERID
         SPACE 1
REPEAT   DS    0H
         SPACE 1
         NI    SWITCH,255-CONTINUE-INSTREAM-SLASHEND  TURN OFF FLAGS
         OI    SWITCH,STARTJOB     INDICATE BEGINNING OF A JOB
         OPEN  (SUBMIT)            OPEN INPUT JCL DATASET
         TM    SUBMIT+48,X'10'     IF OPEN FAILED
         BO    OPENOK              THEN
         TPUT  OPENMSG,L'OPENMSG    TELL ABOUT IT
         B     RETURN               AND RETURN IN FAILURE
OPENOK   DS    0H                  OTHERWISE INPUT SUBMIT DATASET OPEN
         MVC   JOBNAME(8),BLANKS   CLEAR JOB NAME
         XC    IESUBCTD(4),IESUBCTD CLEAR SWITCHES
         OI    IETAKEEX,IETJOB     BUT ALWAYS START TAKING JOBCARDS
         XC    IECARDP,IECARDP     CLEAR CARD POINTER
         XC    IEMSGP,IEMSGP       CLEAR MESSAGE POINTER
         XC    IEREPLYP,IEREPLYP   CLEAR REPLY POINTER
         LA    R15,USERID          GET ADDRESS OF USERID
         ST    R15,IEUSRIDP        STORE IT
         LA    R15,IESUBCTD        ADDRESS OF CONTROL SWITCHES
         ST    R15,IESUBCTP        STORE POINTER
         XC    IEEXITWD,IEEXITWD   CLEAR EXIT WORD
         LA    R15,ACCTSTUF
         ST    R15,IEACCTIP        SET ADDRESS OF ACCOUNTING DATA
         LA    R15,ACCTSTFL
         ST    R15,IEACCTLP        SET ADDRESS OF ACCOUNTING DATA
         XC    SAVECONT,SAVECONT
*
* WE'LL HAVE TO STICK IN THE ACCOUNT INFO BY CHASING CONTROL BLOCKS.
* WILL DO LATER
*
         SPACE 1
         TPUT  STAAHT,L'STAAHT
         SPACE 1
         TPUT  COLS,L'COLS
         SPACE 1
READ     DS    0H
         SPACE 1
         GET   SUBMIT              READ A JCL CARD
         LR    R3,R1               R3 POINTS TO JCL RECORD
         XR    R6,R6               CLEAR OPERATION CODE LENGTH
         SPACE 1
***********************************************************************
*                                                                     *
* DETERMINE WHAT KIND OF CARD THIS IS                                 *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    SWITCH,INSTREAM     IF WE ARE IN INSTREAM JCL
         BO    CKDLM               THEN EXIT DOESN'T GET IT
         SPACE 1
REALJCL  DS    0H
         SPACE 1
         CLI   0(R3),C'/'          IF NOT A REAL JCL CARD
         BNE   NOEXIT              THEN EXIT DOESN'T GET IT
         CLI   1(R3),C'*'          ELSE IF /* CARD
         BE    JES2CARD            THEN GO SCAN COMMENT OR JES2 CARD
         CLI   1(R3),C'/'          ELSE IF // CARD
         BNE   NOEXIT              THEN
         CLI   2(R3),C'*'           IF //* CARD
         BE    JES3CARD             THEN SCAN COMMENT OR JES3 CARD
         NI    IESTMTYP,255-IESCONTN-IESOPCON-IESSCON
*                                  ELSE INITIALIZE CONTINUATIONAL BITS
         SPACE 1
***********************************************************************
*                                                                     *
* ELSE SCAN FOR WHAT KIND OF CARD THIS IS                             *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    SWITCH,CONTINUE     IF CONTINUATION WAS EXPECTED
         BZ    NOTCCCCC            THEN
         OC    IESTMTYP,SAVECONT    restore bits of what was
         OI    IESTMTYP,IESCONTN    INDICATE CONTINUATION
         XC    IESTMTP2,IESTMTP2    INDICATE NOT COMMENT OR JES
         LA    R4,2(,R3)            START SCAN FOR OPERAND FIELD
         B     OPNLOOP              AND PROCESS OPERAND FIELD ONLY
NOTCCCCC DS    0H                  ELSE (NOT A CONTINUATION)...
         XC    IESTMTYP(2),IESTMTYP CLEAR STATEMENT TYPE
         LA    R4,2(,R3)           START SCAN FOR LABEL
         LA    R0,71-3             SET UP BCT REGISTER
LBLLOOP  DS    0H
         CLI   0(R4),C' '          SCAN FOR FIRST NONBLANK
         BE    ENDLBL
         LA    R4,1(,R4)
         BCT   R0,LBLLOOP
ENDLBL   DS    0H                  END OF STATEMENT LABEL FOUND
         LTR   R0,R0               IF END OF CARD ALSO
         BNP   NOEXIT              THEN CARD IS INVALID
OPLOOP   DS    0H                  ELSE SCAN FOR OPERATION FIELD
         CLI   0(R4),C' '
         BNE   BEGINOP
         LA    R4,1(,R4)
         BCT   R0,OPLOOP
BEGINOP  DS    0H                  BEGINNING OF OPERATION CODE FOUND
         LTR   R0,R0               IF NO OPERATION CODE FOUND
         BNP   NULLCARD            THEN NULL JCL CARD "//  "
         LR    R5,R4               ELSE SAVE ADDRES OF OPERATION CODE
OP2LOOP  DS    0H                  SCAN FOR END OF OPERATION FIELD
         CLI   0(R4),C' '
         BE    ENDOP
         LA    R4,1(,R4)
         BCT   R0,OP2LOOP
ENDOP    DS    0H                  END OF OPERATION CODE
         LTR   R0,R0               IF NO OPERATION CODE FOUND
         BNP   NOEXIT              THEN INVALID CARD
         LR    R6,R4               ELSE
         SR    R6,R5               R6 = LENGTH OF OPERATION
OPNLOOP  DS    0H                  SCAN FOR OPERANDS
         CLI   0(R4),C' '
         BNE   BEGINOPN
         LA    R4,1(,R4)
         BCT   R0,OPNLOOP
BEGINOPN DS    0H                  BEGINNING OF OPERANDS
         MVI   IEOPRAND,0          INIT OPERAND COLUMN = 0
         LTR   R0,R0               IF NO OPERATION FOUND
         BNP   NOPERAND            THEN NO OPERANDS
         LA    R14,1(,R4)          ELSE
         SLR   R14,R3               COMPUTE COLUMN OF OPERAND DATA
         STC   R14,IEOPRAND         SET UP OPERAND COLUMN
NOPERAND DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* NOW SEE WHAT KIND OF CARD IT IS                                     *
*                                                                     *
***********************************************************************
         SPACE 1
         LTR   R6,R6               IF NO OPERATION CODE
         BZ    GOCALL              THEN DON'T CHECK CARD TYPE
         CH    R6,=H'2'            IF LENGTH IS 2
         BE    TRYDD               THEN IT MIGHT BE DD STATEMENT
         CH    R6,=H'3'            IF LENGTH IS 3
         BE    TRYJOB              THEN IT MIGHT BE JOB STATEMENT
         CH    R6,=H'4'            IF LENGTH IS 4
         BE    TRYEXEC             THEN IT MIGHT BE EXEC STATEMENT
         B     CMDCARD             ELSE CAN'T BE ANYTHING ELSE, COMMAND
TRYDD    DS    0H                  LENGTH IS 2
         CLC   0(2,R5),=C'DD'      IF IT'S DD
         BE    DDCARD              THEN PROCESS DD STATEMENT
         B     CMDCARD             ELSE MUST BE COMMAND
TRYJOB   DS    0H                  LENGTH IS 2
         CLC   0(3,R5),=C'JOB'     IF IT'S JOB
         BE    JOBCARD             THEN PROCESS JOB STATEMENT
         B     CMDCARD             ELSE MUST BE COMMAND
TRYEXEC  DS    0H                  LENGTH IS 2
         CLC   0(4,R5),=C'EXEC'    IF IT'S EXEC
         BE    EXECCARD            THEN PROCESS EXEC STATEMENT
******** B     CMDCARD             ELSE MUST BE COMMAND
CMDCARD  DS    0H                  ELSE MUST BE COMMAND
         MVI   IESTMTYP,IESCMD     INDICATE COMMAND RECORD
         MVI   RECTYPE,IESCMD      INDICATE COMMAND RECORD
         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES
         B     TESTJOB
JOBCARD  DS    0H
         MVI   IESTMTYP,IESJOB     INDICATE JOB CARD
         MVI   RECTYPE,IESJOB      INDICATE JOB CARD
         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES
         NI    SWITCH,255-STARTJOB INDICATE JOB ALREADY STARTED
         B     GOCALL
EXECCARD DS    0H
         MVI   IESTMTYP,IESEXEC    INDICATE EXEC CARD
         MVI   RECTYPE,IESEXEC     INDICATE EXEC CARD
         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES
         B     TESTJOB
DDCARD   DS    0H
         MVI   IESTMTYP,IESDD      INDICATE DD CARD
         MVI   RECTYPE,IESDD       INDICATE DD CARD
         B     TESTJOB
TESTDLM  DS    0H                  TEST FOR INSTREAM REQUEST
         CLI   0(R4),C'*'          IF // DD *
         BNE   TRYDATA             THEN
         OI    SWITCH,SLASHEND      INDICATE // CAN END INSTREAM
         LA    R4,1(,R4)            POINT TO WHERE NEXT KWD MAY BE
         B     DDIN                 AND INDICATE INSTREAM DATA
TRYDATA  DS    0H
         CLC   0(4,R4),=C'DATA'    ELSE IF // DD DATA
         BNE   TESTJOB             THEN
         NI    SWITCH,255-SLASHEND  // CANNOT TERMINATE INSTREAM
         LA    R4,4(,R4)            POINT TO WHERE NEXT KWD MAY BE
DDIN     DS    0H                  INSTREAM DATA FOLLOWING DD * OR DATA
         OI    SWITCH,INSTREAM     SHOW INSTREAM DATA
         CLC   0(5,R4),=C',DLM='   IF A DELIMITER WAS SPECIFIED
         BNE   DEFDLM              THEN
         CLI   5(R4),C''''          IF QUOTED DELIMITER VALUE
         BE    QUOTEDLM             THEN
         MVC   DLM,5(R4)             SET NEW DELIMITER
         B     TESTJOB              ELSE
QUOTEDLM MVC   DLM,6(R4)             MOVE UNQUOTED DELIMITER VALUE
         B     TESTJOB             ELSE
DEFDLM   MVC   DLM,=C'/*'           USE DEFAULT DELIMITER
         B     TESTJOB             AND CONTINUE
         SPACE 1
NULLCARD DS    0H
         SPACE 1
         MVI   IESTMTYP,IESNULL    INDICATE NULL CARD
         MVI   RECTYPE,IESNULL     INDICATE NULL CARD
         XC    IESTMTP2,IESTMTP2   INDICATE NOT COMMENT OR JES
         MVI   IEOPRAND,0          INDICATE NO OPERAND FIELD
         B     TESTJOB
         SPACE 1
JES2CARD DS    0H                  /* ... CARD
         SPACE 1
         CLI   2(R3),C' '          IF /* FOLLOWED BY BLANK
         BE    COMMENTC            THEN IT IS A COMMENT CARD
         MVI   IESTMTP2,IESJES     ELSE INDICATE JES2 CARD
         MVI   IESTMTYP,X'00'      CLEAR OTHER BITS
******** NI    IESTMTYP,255-IESCONTN-IESOPCON-IESSCON
********************************** CLEAR CONTINUATIONAL BITS
         LA    R1,3(,R3)           START OF SCAN
         B     JESSCAN             GO TO SCAN IT
         SPACE 1
JES3CARD DS    0H                  //* ... CARD
         SPACE 1
         CLI   3(R3),C' '          IF //* FOLLOWED BY BLANK
         BE    COMMENTC            THEN IT IS A COMMENT CARD
         MVI   IESTMTP2,IESJES3    ELSE INDICATE JES3 CARD
         MVI   IESTMTYP,X'00'      CLEAR OTHER BITS
******** NI    IESTMTYP,255-IESCONTN-IESOPCON-IESSCON
********************************** CLEAR CONTINUATIONAL BITS
         LA    R1,4(,R3)           START OF SCAN
         B     JESSCAN             GO TO SCAN IT
         SPACE 1
COMMENTC DS    0H                  /* COMMENTS...
         SPACE 1
         OI    IESTMTP2,IESCOMNT   INDICATE COMMENT CARD
         CLI   NEWVER,1            If emulating fix for OY37954
         BNE   NOT37954            then
         MVI   IESTMTYP,X'00'      CLEAR OTHER BITS
         NI    IESTMTP2,IESCOMNT   (all except comment bit)
NOT37954 DS    0H                  else don't wipe out the other bits
         MVI   IEOPRAND,0          INDICATE NO OPERAND FIELD
         B     NOCONS
         SPACE 1
JESSCAN  DS    0H                  FIND JES OPERAND FIELD
         SPACE 1
         LA    R0,71-3             END OF SCAN FOR BCT
JESLOOP  DS    0H                  FIND BLANK FOLLOWING JES PARM
         CLI   0(R1),C' '
         BE    JESEND1
         LA    R1,1(,R1)
         BCT   R0,JESLOOP
         MVI   IEOPRAND,0
         B     TESTJOB
JESEND1  DS    0H
         LA    R1,1(,R1)
JESLOOP2 DS    0H                  FIND NONBLANK FOR OPERAND STUFF
         CLI   0(R1),C' '
         BNE   JESEND2
         LA    R1,1(,R1)
         BCT   R0,JESLOOP2
         MVI   IEOPRAND,0
         B     TESTJOB
JESEND2  DS    0H
         LA    R14,1(,R1)          GET OFFSET = ADDR(END)-ADDR(START)
         SR    R14,R3
         STC   R14,IEOPRAND        SET UP OPERAND COLUMN
         SPACE 1
TESTJOB  DS    0H
         SPACE 1
         TM    SWITCH,STARTJOB     IF START OF JOB BUT NO JOB CARD
         BZ    GOCALL              THEN
         NI    SWITCH,255-STARTJOB  RESET START-OF-JOB FLAG
         MVC   SAVETYPE,RECTYPE     SAVE CARD TYPE
         MVC   SAVEBITS(3),IESUBCTD+1 SAVE INPUT CARD BIT SETTINGS
         MVI   RECTYPE,IESJOB       SET CARD TYPE = JOB CARD
         MVC   IESUBCTD+1(3),BITS1
         MVC   TEMPCARD,JOBCARD1
         LA    R1,TEMPCARD
         BAL   R14,CALLEXIT
         MVC   IESUBCTD+1(3),BITS2
         MVC   TEMPCARD,JOBCARD2
         LA    R1,TEMPCARD
         BAL   R14,CALLEXIT
         MVC   IESUBCTD+1(3),BITS3
         MVC   TEMPCARD,JOBCARD3
         LA    R1,TEMPCARD
         BAL   R14,CALLEXIT
         MVC   IESUBCTD+1(3),BITS4
         MVC   TEMPCARD,JOBCARD4
         LA    R1,TEMPCARD
         BAL   R14,CALLEXIT
         MVC   RECTYPE,SAVETYPE    RESTORE CARD TYPE
         MVC   IESUBCTD+1(3),SAVEBITS RESTORE BITS
         SPACE 1
GOCALL   DS    0H
         SPACE 1
         TM    SWITCH,CONTINUE     If card not following continuer,
         BO    NOSAVECO            then...
         MVC   SAVECONT,IESTMTYP    Save what-kind-it's-been bits...
         NI    SAVECONT,IESJOB+IESEXEC+IESDD+IESCMD+IESNULL only these
NOSAVECO DS    0H
         NI    IESTMTYP,255-IESSCON INIT CARD NOT TO BE CONTINUED
         CLI   71(R3),C' '         IF CONTINUATION COLUMN NONBLANK
         BE    COL72BLK            THEN
         OI    IESTMTYP,IESSCON     INDICATE STMT TO BE CONTINUED
         OI    SWITCH,CONTINUE
COL72BLK DS    0H
         NI    IESTMTYP,255-IESOPCON INIT OPERAND NOT TO BE CONTINUED
         CLI   IEOPRAND,0          IF THERE ARE OPERANDS
         BE    AFTCON              THEN
         LA    R1,71(,R3)           SCAN FOR LAST NONBLANK IN THEM
CONTLOOP DS    0H
         CLI   0(R1),C' '
         BNE   SEEIFCNT
         BCTR  R1,0
         B     CONTLOOP
SEEIFCNT DS    0H
         CLI   0(R1),C','          IF LAST NONBLANK IS A COMMA
         BNE   AFTCON              THEN
         OI    IESTMTYP,IESOPCON    SCAN FOR LAST NONBLANK IN THEM
AFTCON   DS    0H
         NI    SWITCH,255-CONTINUE THIS CARD WILL NOT BE CONTINUED
         TM    IESTMTYP,IESOPCON+IESSCON UNLESS ONE OF THESE BITS IS ON
         BZ    NOCONS
         OI    SWITCH,CONTINUE
NOCONS   DS    0H
         LR    R1,R3               POINT TO CURRENT CARD
         BAL   R14,CALLEXIT        INVOKE EXIT FOR THE CARD
         B     READ                GO TO GET NEXT CARD
         EJECT
CKDLM    DS    0H                  INSTREAM DATA:
         SPACE 1
         TM    SWITCH,SLASHEND     IF // CAN TERMINATE INSTREAM
         BZ    NOT6161              AND
         CLC   0(2,R3),=C'//'        // WAS FOUND
         BNE   NOT6161                THEN TERMINATE INSTREAM
         NI    SWITCH,255-INSTREAM-SLASHEND
         B     REALJCL                 AND PROCESS THIS CARD AS READ.
NOT6161  DS    0H
         CLC   0(2,R3),DLM         ELSE IF DELIMITER FOUND
         BNE   NOEXIT              THEN
OUTOFIT  NI    SWITCH,255-INSTREAM-SLASHEND NO LONGER IN INSTREAM
NOEXIT   DS    0H
         LA    R1,0(,R3)           WRITE OUT THE JCL TO TERMINAL
         LA    R0,79
         TPUT  (1),(0),R
         B     READ                GO GET ANOTHER CARD
         EJECT
EOF      DS    0H                  END OF FILE ON DD SUBMIT
         SPACE 1
         CLOSE (SUBMIT)
         SPACE 1
         CLC   JOBNAME,BLANKS      IF JOB NAME NOT BLANK
         BE    NOEOFJOB            THEN
         TPUT  JOBMSG,JOBMSGL       SAY 'JOB XXXXXXXX SUBMITTED'
NOEOFJOB DS    0H
         TPUT  ASKRPT,L'ASKRPT
         TGET  ANSWER,1
         TCLEARQ INPUT
         OI    ANSWER,X'40'
         CLI   ANSWER,C'R'
         BNE   RETURN
         B     REPEAT
         EJECT
CALLEXIT DS    0H
         SPACE 1
         ST    R14,SAVE14
         ST    R1,IECARDP          STORE ADDRESS OF CARD TO BE USED
         NI    SWITCH,255-JOBSUBD
         TM    RECTYPE,IESJOB      IF THIS IS A JOB CARD
         BZ    CXNOTJOB            THEN
         TM    IETAKEEX,IETJOB      IF EXIT ACCEPTS JOB CARDS
         BO    RPEATXIT             THEN GO TO CALL THE EXIT
         B     BYPASSEX             ELSE BYPASS EXIT
CXNOTJOB DS    0H
         TM    RECTYPE,IESCMD      IF THIS IS A COMMAND CARD
         BZ    CXNOTCMD            THEN
         TM    IETAKEEX,IETCMD      IF EXIT ACCEPTS COMMAND CARDS
         BO    RPEATXIT             THEN GO TO CALL THE EXIT
         B     BYPASSEX             ELSE BYPASS EXIT
CXNOTCMD DS    0H
         TM    RECTYPE,IESEXEC     IF THIS IS A EXEC CARD
         BZ    CXNOTEX             THEN
         TM    IETAKEEX,IETEXEC     IF EXIT ACCEPTS EXEC CARDS
         BO    RPEATXIT             THEN GO TO CALL THE EXIT
         B     BYPASSEX             ELSE BYPASS EXIT
CXNOTEX  DS    0H
         TM    RECTYPE,IESDD       IF THIS IS A DD CARD
         BZ    CXNOTDD             THEN
         TM    IETAKEEX,IETDD       IF EXIT ACCEPTS DD CARDS
         BO    RPEATXIT             THEN GO TO CALL THE EXIT
         B     BYPASSEX             ELSE BYPASS EXIT
CXNOTDD  DS    0H
         TM    RECTYPE,IESNULL     IF THIS IS A NULL CARD
         BZ    CXNOTNL             THEN
         TM    IETAKEEX,IETNULL     IF EXIT ACCEPTS NULL CARDS
         BO    RPEATXIT             THEN GO TO CALL THE EXIT
         B     BYPASSEX             ELSE BYPASS EXIT
CXNOTNL  DS    0H
         TM    IESTMTP2,IESJES     IF THIS IS A JES2 CARD
         BZ    CXNOTJ2             THEN
         TM    IETAKEEX,IETJES      IF EXIT ACCEPTS JES2 CARDS
         BO    RPEATXIT             THEN GO TO CALL THE EXIT
         B     BYPASSEX             ELSE BYPASS EXIT
CXNOTJ2  DS    0H
         TM    IESTMTP2,IESJES3    IF THIS IS A JES3 CARD
         BZ    CXNOTJ3             THEN
         TM    IETAKEEX,IETJES3     IF EXIT ACCEPTS JES3 CARDS
         BO    RPEATXIT             THEN GO TO CALL THE EXIT
         B     BYPASSEX             ELSE BYPASS EXIT
CXNOTJ3  DS    0H
         TM    IESTMTP2,IESCOMNT   IF THIS IS A COMMENT CARD
         BZ    BYPASSEX            THEN BYPASS EXIT
         TM    IETAKEEX,IETCOMNT   IF EXIT DOESN'T TAKE COMMENTS
         BZ    BYPASSEX            THEN BYPASS EXIT. ELSE...
RPEATXIT DS    0H
         UNPK  DISPHEX(9),IETAKEEX(5)
         TR    DISPHEX(8),HEXTBL
         TPUT  DISPMSG,L'DISPMSG
         L     R15,EFF10ADR        GET ADDRESS OF IKJEFF10
         LA    R1,PARMADDR         POINT TO PARAMETER LIST
         BALR  R14,R15             CALL THE EXIT
         SPACE 1
***********************************************************************
*                                                                     *
* PROCESS RESULTS OF EXIT                                             *
*                                                                     *
***********************************************************************
         SPACE 1
         LTR   R15,R15
         BZ    EXIT0
         BM    RCERR
         CH    R15,=H'4'
         BE    EXIT4
         CH    R15,=H'8'
         BE    EXIT8
         CH    R15,=H'12'
         BE    EXIT12
         CH    R15,=H'16'
         BE    EXIT16
RCERR    DS    0H
         TPUT  BADRC,L'BADRC
         B     EOF
         SPACE 1
EXIT4    DS    0H                  IKJEFF10 RETURN CODE 4
         SPACE 1
         ICM   R10,15,IECARDP
         BZ    NOCARD
         TM    SWITCH,JOBSUBD      IF JOB SUBMITTED MESSAGE DISPLAYED
         BO    DISPLAY4            THEN BYPASS. ELSE...
         TM    RECTYPE,IESJOB      IF THIS IS A JOB CARD
         BZ    DISPLAY4             AND
         TM    IESTMTYP,IESCONTN     NOT A CONTINUATION
         BO    DISPLAY4               THEN
         CLC   JOBNAME,BLANKS          IF JOB NAME NOT BLANK
         BE    NOSAYJB4                 THEN
         TPUT  BLANKS,1                  DISPLAY A BLANK LINE
         TPUT  JOBMSG,JOBMSGL            SAY 'JOB XXXXXXXX SUBMITTED'
         TPUT  BLANKS,1                  DISPLAY ANOTHER BLANK LINE
NOSAYJB4 DS    0H
         MVC   JOBNAME,2(R10)      MOVE JOB NAME TO JOB NAME
         OI    SWITCH,JOBSUBD      INDICATE JOB SUBMITTED MSG
DISPLAY4 DS    0H
         LA    R1,0(,R10)          DISPLAY PROCESSED JCL CARD
         LA    R0,79
         TPUT  (1),(0),R
         SPACE 1
NOCARD   DS    0H
         SPACE 1
         XC    IECARDP,IECARDP
         B     RPEATXIT            CALL EXIT AGAIN TO INSERT CARD
         SPACE 1
EXIT8    DS    0H
         SPACE 1
         MVC   MSGID,=C'IKJ56283I '
         MVI   MESSAGE,C' '
         MVC   MESSAGE+1(255),MESSAGE
         ICM   R14,15,IEMSGP       LOAD MESSAGE POINTER
         BNZ   MSGPOK              CHECK IF NONZERO
         TPUT  EXIT8NG,L'EXIT8NG
         B     EXITRET
MSGPOK   DS    0H
         LH    R15,0(,R14)         GET "LL" MESSAGE LENGTH
         BCTR  R15,0               SUBTRACT 2
         BCTR  R15,0
         LTR   R15,R15             LENGTH BETTER BE POSITIVE
         BP    MSGPOK2             OR ELSE
         CH    R15,=H'246'         LENGTH BETTER BE 246 OR LESS
         BNH   MSGPOK2             OR ELSE
         TPUT  EXIT8NG2,L'EXIT8NG2
         B     EXITRET
MSGPOK2  DS    0H
         LR    R2,R15              SAVE MESSAGE LENGTH
         BCTR  R15,0
         EX    R15,MOVE8
         LA    R1,MSGID
         LA    R0,L'MSGID
         AR    R0,R2
         TPUT  (1),(0),R
         B     EXITRET
         SPACE 1
EXIT12   EQU   EXIT8
         SPACE 1
EXIT16   DS    0H
         SPACE 1
         TPUT  TERM,L'TERM
         B     EOF
         SPACE 1
BYPASSEX DS    0H
         SPACE 1
EXIT0    EQU   BYPASSEX
         SPACE 1
         ICM   R10,15,IECARDP      IF A JCL CARD IS TO BE PROCESSED
         BZ    EXITRET             THEN
         TM    SWITCH,JOBSUBD       IF JOB SUBMITTED MSG DISPLAYED
         BO    DISPLAY0             THEN BYPASS. ELSE...
         TM    RECTYPE,IESJOB       IF THIS IS A JOB CARD
         BZ    DISPLAY0             THEN
         TM    IESTMTYP,IESCONTN     IF NOT A CONTINUATION
         BO    DISPLAY0              THEN
         CLC   JOBNAME,BLANKS         IF JOB NAME NOT BLANK
         BE    NOSAYJOB               THEN
         TPUT  BLANKS,1                DISPLAY A BLANK LINE
         TPUT  JOBMSG,JOBMSGL          SAY 'JOB XXXXXXXX SUBMITTED'
         TPUT  BLANKS,1                DISPLAY ANOTHER BLANK LINE
         SPACE 1
NOSAYJOB DS    0H
         SPACE 1
         MVC   JOBNAME,2(R10)      MOVE JOB NAME TO JOB NAME
         OI    SWITCH,JOBSUBD      INDICATE JOB SUBMITTED MESSAGE
         SPACE 1
DISPLAY0 DS    0H
         SPACE 1
         LA    R1,0(,R10)          DISPLAY THE JCL CARD
         LA    R0,79
         TPUT  (1),(0),R
******** B     EXITRET             AND RETURN.
         SPACE 1
EXITRET  DS    0H
         SPACE 1
         L     R14,SAVE14          RETURN TO CALLER
         BR    R14
         EJECT
RETURN   DS    0H
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 1
MOVEUID  MVC   USERID(0),PSCBUSER
MOVE8    MVC   MESSAGE(0),2(R14)
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
         WXTRN IKJEFF10
*FF10ADR DC    V(IKJEFF10)         ADDRESS OF SUBMIT EXIT
EFF10ADR DC    A(0)                ADDRESS OF SUBMIT EXIT
         SPACE 1
SAVE14   DS    A                   RETURN ADDRESS FOR SUBROUTINE
SWITCH   DC    X'00'
INSTREAM EQU   B'10000000'          1 = IN SYSIN DD * OR DATA STREAM
CONTINUE EQU   B'01000000'          1 = CONTINUATION EXPECTED
STARTJOB EQU   B'00100000'          1 = BEGINNING OF A JOB
SLASHEND EQU   B'00010000'          1 = // CAN END INSTREAM (DD *)
JOBSUBD  EQU   B'00001000'          1 = JOB SUBMITTED MSG DISPLAYED
*        EQU   B'00000100'          1 = RESERVED
*        EQU   B'00000010'          1 = RESERVED
*        EQU   B'00000001'          1 = RESERVED
USERID   DS    CL8                 USERID
BLANKS   DC    CL8' '              GENERAL PURPOSE BLANKS
DLM      DC    C'/*'               INSTREAM JCL DELIMITER
ANSWER   DC    C' '                REPLY TO REPEAT REQUEST
PARMADDR DC    A(IEEXITL)          ADDRESS OF PARAMETER LIST
         SPACE 1
***********************************************************************
*                                                                     *
* THE FOLLOWING STOLEN FROM 'SYS1.MACLIB(IKJEFFIE)' BECAUSE THOSE     *
* TURDBRAINS INSIST ON MAKING IT A DSECT!                             *
*                                                                     *
***********************************************************************
         SPACE 1
IEDSECTD DS    0F         .REGISTER 1 -> POINTER -> IEEXITL
         DS    0F
IEEXITL  EQU   *          .EXITLIST = PARAMETER LIST TO SUBMIT'S
*                         .   INSTALLATION EXIT, IKJEFF10
IECARDP  DS    A          .CARDPTR = POINTER TO CURRENT JCL STATEMENT.
*                         .   IF ZERO, EXIT IS BEING REENTERED TO GET
*                         .   A NEW STATEMENT.  THE EXIT MAY ZERO THIS
*                         .   FIELD TO DELETE THE CURRENT STATEMENT
*                         .   OR IT MAY CHANGE THIS STATEMENT.
IEMSGP   DS    A          .MESSAGEP = ZERO ON ENTRY TO EXIT.  NOTE --
*                         .   EXIT MUST PLACE POINTER TO MESSAGE HERE
*                         .   IF RETURNING CODE = 8 OR 12 TO COMMAND
*                         .  (MESSAGE FORMAT IS LL-TEXT; WHERE LL IS A
*                         .   TWO-BYTE LENGTH FIELD WITH LENGTH OF THE
*                         .   MESSAGE, INCLUDING LENGTH OF LL FIELD).
*                         .   MAXIMUM MESSAGE TEXT LENGTH IS 246 BYTES.
IEREPLYP DS    A          .REPLYP = ZERO ON FIRST ENTRY TO THE EXIT
*                         .   AND = POINTER TO REPLY OBTAINED BY THE
*                         .   COMMAND IF EXIT HAD SPECIFIED RETURN CODE
*                         .   12 (NOTE -- REPLY HAS SAME SETUP AS MSG).
*                         .   SUBMIT WILL FREE THE REPLY BUFFER.
IEUSRIDP DS    A          .USERIDPT = POINTER TO 8-BYTE USERID FIELD
*                         .   (PADDED ON THE RIGHT WITH BLANKS)
IESUBCTP DS    A          .SWITSPT = POINTER TO JCL SWITCH BYTES AND
*                         .   COLUMN OF OPERAND FIELD ON JCL CARD
IEEXITWD DS    F          .EXITWORK = WORD FOR EXIT'S USE.  IT IS
*                         .   INITIALIZED TO ZEROES AND RETAINS
*                         .   WHATEVER VALUE THE EXIT GIVES IT THRU
*                         .   THE DURATION OF THE SUBMIT COMMAND.
IEACCTIP DS    A          .ACCTIPT = POINTER TO USER'S ACCOUNTING
*                         .   INFORMATION (RECONSTRUCTED FROM ACCOUNT
*                         .   CONTROL TABLE, ACT, BUILT AT LOGON).
*                         .   THIS ACCOUNT INFORMATION IS PLACED ON
*                         .   JOB CARDS GENERATED BY SUBMIT.
IEACCTLP DS    A          .ACCTLPT = POINTER TO TWO-BYTE LENGTH FIELD
*                         .   FOR THE ACCOUNTING INFORMATION.
*                         .  (HAVE  0 < LENGTH < 191 -- MAXIMUM OF 142
*                         .   CHARACTERS PLUS DELIMITERS.)
         SPACE 3
***********************************************************************
* RETURN CODES FROM IKJEFF10 INSTALLATION EXIT TO THE COMMAND         *
***********************************************************************
IECONTIN EQU   0          .CONTINUE - COMPLETE PROCESSING CURRENT
*                         .   STATEMENT AND READ THE NEXT
IERETURN EQU   4          .PROCESS CURRENT STATEMENT AND RETURN TO EXIT
*                         .   FOR ANOTHER STATEMENT
IEMSG    EQU   8          .ISSUE MESSAGE IKJ56283I FOR EXIT AND REENTER
*                         .   EXIT.  EXIT MUST OBTAIN MESSAGE TEXT AREA
*                         .   AND MAY FREE IT WHEN REENTERED.
IEPROMPT EQU   12         .ISSUE PROMPT MESSAGE IKJ56280A FOR EXIT AND
*                         .   RETURN THE REPLY TO EXIT.  IKJEFF02
*                         .   MESSAGE ISSUER ROUTINE OBTAINS THE
*                         .   REPLY AREA AND IKJEFF09 WILL FREE IT.
*                         .IF USER IN NOPROMPT MODE, SUBMIT ISSUES
*                         .   ERROR MESSAGE IKJ56282I AND ABORTS.
IEABORT  EQU   16         .TERMINATE THE SUBMIT COMMAND.  RETURN CODE 8
*                         .   SHOULD BE USED FIRST TO ISSUE AN ERROR
*                         .   MESSAGE TO THE TSO USER.
         SPACE 3
***********************************************************************
* DSECT WITH SUBMIT JCL CONTROL INFORMATION PASSED TO EXIT            *
***********************************************************************
IESUBCTD DS    0B         .TO USE THIS DSECT, CODE --
*                         .   L YOURREG,IESUBCTP
*                         .   USING IESUBCTD,YOURREG
         DS    0B         .DATA IS ON BYTE BOUNDARY
IETAKEEX DS    B          .SWITCHES WHICH CONTROL WHEN EXIT IS ENTERED
*                         .   <<THESE SWITCHES MAY BE CHANGED BY THE
*                         .   EXIT - IBM EXIT TURNS ALL SWITCHES OFF>>
IETJOB   EQU   X'80'      .ON IF TAKE EXIT FOR JOB CARDS (DEFAULT = ON)
IETEXEC  EQU   X'40'      .ON IF TAKE EXIT FOR EXEC CARDS (DEFAULT=OFF)
IETDD    EQU   X'20'      .                    DD                  OFF
IETCMD   EQU   X'10'      .                    COMMAND             OFF
IETNULL  EQU   X'08'      .                    NULL                OFF
IETJES   EQU   X'04'      .                    /*NONBLANK (JES2)   OFF
IETCOMNT EQU   X'02'      .                    //* (COMMENT)       OFF
IETJES3  EQU   X'01'      .                    //*NONBLANK (JES3) OFF
IEOPRAND DS    XL1        .COLUMN OF OPERAND FIELD ON CURRENT CARD, IF
*                         .   ONE EXISTS (ONE-ORIGINED COLUMN NUMBER)
IESTMTYP DS    B          .SWITCHES WHICH INDICATE TYPE OF CURRENT
*                         .   JCL STATEMENT.  JCL STATEMENTS IN DATA
*                         .   STREAM FOLLOWING A DD DATA STATEMENT
*                         .   (OR /*NONBLANK, FOLLOWING A DD *) ARE
*                         .   NOT PASSED TO THE EXIT.
IESJOB   EQU   X'80'      .ON IF STATEMENT IS JOB STATEMENT
IESEXEC  EQU   X'40'      .                   EXEC (PGM OR PROC)
IESDD    EQU   X'20'      .                   DD
IESCMD   EQU   X'10'      .                   COMMAND
IESNULL  EQU   X'08'      .                   NULL
IESOPCON EQU   X'04'      .      OPERAND TO BE CONTINUED
IESSCON  EQU   X'02'      .      STATEMENT TO BE CONTINUED
IESCONTN EQU   X'01'      .      STATEMENT IS A CONTINUATION
IESTMTP2 DS    B          .SWITCHES, CONTINUED
IESJES   EQU   X'80'      .ON IF STATEMENT IS /*NONBLANK STATEMENT
*                         .   (JOB ENTRY SUBSYSTEM CONTROL CARDS)
IESCOMNT EQU   X'40'      .ON IF STATEMENT IS COMMENT STATEMENT, //*
*                         .   (OR MAY BE JES3 CONTROL CARD)
IESJES3  EQU   X'20'      .ON IF STATEMENT IS //*NONBLANK STATEMENT
*                         .   (JES3 CONTROL CARD)
         SPACE 2
SAVEBITS DS    XL3                 SAVED BIT SETTING FOR FIRST CARD
RECTYPE  DS    X          WE MAINTAIN CARD TYPE BETTER THAN SUBMIT DOES
SAVETYPE DS    X                   SAVED CARD TYPE FOR FIRST CARD
SAVECONT DS    X
NEWVER   DS    X
MSGHDR   DS    2Y
MSGID    DS    CL10
MESSAGE  DS    CL256
         EJECT
SUBMIT   DCB   DDNAME=SUBMIT,DSORG=PS,MACRF=GL,LRECL=80,EODAD=EOF
         EJECT
COLUMNS  DC    C'----+----1----+----2----+----3----+----4----+----5'
         DC    C'----+----6----+----7----+---'
COLS     EQU   COLUMNS,*-COLUMNS,C'C'
STAAHT   DC    C'****DRIVERSU - SUBMIT EXIT TEST DRIVER - STARTING'
ASKRPT   DC    C'****ENTER R TO REPEAT OR PRESS ENTER TO TERMINATE'
OPENMSG  DC    C'****UNABLE TO OPEN DDNAME SUBMIT, REQUIRED FOR DRIVER'
BADRC    DC    C'****INVALID RETURN CODE FROM EXIT, DRIVER TERMINATING'
TERM     DC    C'****EXIT REQUESTED TERMINATION, DRIVER TERMINATING'
EXIT8NG  DC    C'****EXIT RETURNED CODE 8 BUT SET NO MESSAGE POINTER'
EXIT8NG2 DC    C'****EXIT RETURNED CODE 8 BUT MESSAGE LENGTH INVALID'
*
ASKVER   DC    C'**** Do you want to emulate the fix for OY37954, whereX
               in comment cards between JOB cards clear the JOB bit?'
*
JOBMSG   DC    C'****JOB '
JOBNAME  DC    CL8' '
         DC    C' SUBMITTED'
JOBMSGL  EQU   *-JOBMSG
         SPACE 1
ACCTSTUF DC    C'(9050-00,3333)'
ACCTSTFL DC    Y(L'ACCTSTUF)
         SPACE 1
JOBCARD1 DC    CL80'//USER-IDX  JOB ,'
JOBCARD2 DC    CL80'//             USER-ID,'
JOBTHREE DC    C'//             NOTIFY=USER-ID,CLASS='
DEFCLASS DC    C' '
         DC    CL(80-(*-JOBTHREE))','
JOBCARD3 EQU   JOBTHREE,80,C'C'
JOBCARD4 DC    CL80'//             MSGLEVEL=(1,1)'
TEMPCARD DS    CL80
BITS1    DC    YL1(17,IESJOB+IESOPCON,0)
BITS2    DC    YL1(16,IESJOB+IESOPCON+IESCONTN,0)
BITS3    DC    YL1(16,IESJOB+IESOPCON+IESCONTN,0)
BITS4    DC    YL1(16,IESJOB+IESCONTN,0)
         SPACE 1
DISPMSG1 DC    C'Bits: '
DISPHEX  DC    CL9' '
DISPMSG  EQU   DISPMSG1,*-DISPMSG1-1,C'C'
         SPACE 1
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         SPACE 1
SAVEAREA DS    18F
         SPACE 2
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJPSCB
         SPACE 1
         END
./ ADD NAME=EJECT    0100-07332-07332-0900-00029-00029-00000-SEB
*
***********************************************************************
*                                                                     *
* This command no longer works as of TSO/E Version 2, because of the  *
* key-1 storage now used by TSO control blocks.   0C4 results.        *
*                                                                     *
***********************************************************************
*
         TITLE 'EJECT - COMMAND PROCESSOR FOR USE IN TSO BATCH OUTPUT'
         SPACE
***********************************************************************
* THIS COMMAND CAUSES A PAGE-EJECT CONDITION IN AN OUTPUT FILE OF A   *
* STACK DATASET ELEMENT BY UPDATING THE INTERNAL LINE COUNT FIELD TO  *
* FORCE A NEW-PAGE CONDITION.  IF THE BOTTOM ELEMENT OF THE CURRENT   *
* TSO SESSION IS NOT A DATASET ELEMENT NO ACTION IS PERFORMED.        *
***********************************************************************
         SPACE
EJECT    CSECT
         L     15,12(,1)           ADDRESS OF ECT
         L     15,4(,15)           ADDRESS OF INPUT STACK (IOSRL)
         L     15,4(,15)           BOTTOM STACK ELEMENT
         TM    0(15),X'10'         DATASET ELEMENT?
         BNOR  14                  NO, DO NOTHING
         ICM   15,7,1(15)          DSD
         BZR   14                  ZERO, DO NOTHING
         MVI   3(15),254           SET MAXIMUM LINE COUNT
         XR    15,15               SET RETURN CODE TO ZERO
         BR    14                  RETURN
         END
./ ADD NAME=FSOFF    0100-07332-07332-0900-00012-00012-00000-SEB
FSOFF    CSECT
         SPACE
         STM   14,12,12(13)
         LR    12,15
         USING FSOFF,12
         TPUT  OFFSTRM,L'OFFSTRM,FULLSCR,HOLD
         L     14,12(,13)
         LM    0,12,20(13)
         BR    14
         SPACE
OFFSTRM  DC    X'277E40115D7E11404013'
         END
./ ADD NAME=FSON     0100-07332-07332-0900-00013-00013-00000-SEB
FSON     CSECT
         SPACE
         STM   14,12,12(13)
         LR    12,15
         USING FSON,12
         TPUT  ONSTRM,L'ONSTRM,FULLSCR,HOLD
         L     14,12(,13)
         LM    0,12,20(13)
         BR    14
         SPACE
*ONSTRM  DC    X'277E40115D7F11404013'
ONSTRM   DC    X'27F140115D7F114040'
         END
./ ADD NAME=GETDSN   0100-07332-07332-0900-00337-00337-00000-SEB
         TITLE 'GETDSN   - ROUTINE TO RETURN A DSNAME GIVEN DDNAME'
***********************************************************************
*                                                                     *
* GETDSN   - ROUTINE TO RETURN A DSNAME GIVEN DDNAME                  *
*                                                                     *
* THIS SUBROUTINE IS CALLABLE FROM A FORTRAN PROGRAM OR PL/1 PROGRAM  *
* THAT PASSES IT THREE CHARACTER STRING AREAS AS FOLLOWS:             *
*                                                                     *
* (1) CHARACTER(8) - THE DDNAME TO SEARCH FOR.                        *
* (2) CHARACTER(44) - FILLED IN WITH THE DSNAME.                      *
* (3) CHARACTER(8) - FILLED IN WITH THE MEMBER NAME IF ANY.           *
*                                                                     *
* RETURN CODES:                                                       *
*                                                                     *
*   0 - EVERYTHING OK.  DSNAME AND MEMBER SET.                        *
*   4 - REQUESTED FILENAME IS A CONCATENATION.  ONLY THE FIRST        *
*       DSNAME AND MEMBER ARE RETURNED.                               *
*   8 - THE FILENAME IS NOT ALLOCATED OR IS INVALID.                  *
*                                                                     *
* FORTRAN INVOCATION:                                                 *
*                                                                     *
*       CHARACTER*8 DDNAME                                            *
*       CHARACTER*8 SAMPDD                                            *
*       CHARACTER*44 DSNAME                                           *
*       CHARACTER*8 MEMBER                                            *
*       INTEGER*4 GETDSN                                              *
*       INTEGER*4 RC                                                  *
*       DATA SAMPDD/'FT06F001'                                        *
*       DDNAME = SAMPDD                                               *
*       RC=GETDSN(DDNAME,DSNAME,MEMBER)                               *
*       IF(RC.EQ.0) GOTO 10                                           *
*       IF(RC.EQ.4) GOTO 14                                           *
*       IF(RC.EQ.8) GOTO 18                                           *
*    10 WRITE (6,*) DSNAME,'(',MEMBER,')'                             *
*       GOTO 9999                                                     *
*    14 WRITE (6,*) DSNAME,'(',MEMBER,') - BUT CONCATENATED...'       *
*       GOTO 9999                                                     *
*    18 WRITE (6,*) 'FILE NAME IS NOT ALLOCATED OR IS INVALID'        *
*       GOTO 9999                                                     *
*                                                                     *
* PL/1 INVOCATION:                                                    *
*                                                                     *
*  DCL DDNAME CHAR(8),                                                *
*      DSNAME CHAR(44),                                               *
*      MEMBER CHAR(8),                                                *
*      PLIRETV BUILTIN;                                               *
*  DCL GETDSN ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *
*  DDNAME = 'SYSPRINT';                                               *
*  CALL GETDSN(DDNAME,DSNAME,MEMBER);                                 *
*  SELECT (PLIRETV());                                                *
*    WHEN (0) BEGIN;                                                  *
*               PUT LIST(DSNAME || '(' MEMBER || ')');                *
*             END;                                                    *
*    WHEN (4) BEGIN;                                                  *
*               PUT LIST(DSNAME || '(' MEMBER || ')');                *
*               PUT LIST('...BUT CONCATENATED');                      *
*             END;                                                    *
*    WHEN (8) BEGIN;                                                  *
*               PUT LIST('FILE NAME NOT ALLOCATED OR INVALID');       *
*             END;                                                    *
*  END;                                                               *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
*  12/16/87 - SEB1525 - RMODE=ANY AND AMODE=ANY SUPPORT ADDED.        *
*                                                                     *
*  01/14/88 - SEB1525 - (1) Returns 'TERMFILE' instead of 'NULLFILE'  *
*                           for a file allocated to the terminal.     *
*                                                                     *
*                       (2) Returns SYSOUT=c, where c is the SYSOUT   *
*                           class, for SYSOUT files.                  *
*                                                                     *
*  10/03/89 - SEB1525 - Fixed "NO SIOT found" with multiple job steps *
*                                                                     *
*  11/30/89 - SEB1525 - Added optional 4th parameter to return volser *
*                                                                     *
* CHANGES NEVER IMPLEMENTED:                                          *
*                                                                     *
*                       (1) Use system macros instead of chasing      *
*                           control block pointers to find the JFCB.  *
*                           This will permit SWA-above-the-line to    *
*                           be implemented by Systems if desired.     *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    TIOT ENTRY POINTER
R4       EQU   4    USED TO INCREMENT TIOT POINTER
R5       EQU   5    JFCB POINTER
R6       EQU   6    ADDRESS OF PARM 1 - DDNAME
R7       EQU   7    ADDRESS OF PARM 2 - DSNAME
R8       EQU   8    ADDRESS OF PARM 3 - MEMBER
R9       EQU   9    SUBSYSTEM FLAG
R10      EQU   10   SUBSYSTEM FLAG
R11      EQU   11   UCB POINTER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
GETDSN   CSECT
GETDSN   RMODE ANY
GETDSN   AMODE ANY
         SAVE  (14,12),,GETDSN_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING GETDSN,R12
*
* THIS PROGRAM NEEDS NO SAVE AREA.
*
         SPACE 1
         TM    8(R1),X'80'         If 3 parameters passed,
         BZ    FOURPRMS            then...
         LM    R6,R8,0(R1)          load pointers to 3 parameters
         XR    R9,R9                clear 4th parameter address
         B     AFTPARMS            else...
FOURPRMS DS    0H                   (4 parameters passed)...
         LM    R6,R9,0(R1)          load pointers to 4 parameters
         MVC   0(6,R9),=CL8' '     Clear returned volser to blanks
AFTPARMS DS    0H
         XR    R10,R10             Clear subsystem flag
         CLC   0(8,R6),=CL8' '     IF DDNAME IS BLANK
         BE    RETURN8             THEN INVALID FILE NAME, RETURN 8
         L     R3,540              GET ADDRESS OF TCB
         USING TCB,R3
         L     R3,TCBTIO           GET ADDRESS OF TIOT
         DROP  R3
         USING TIOT1,R3
         LA    R3,TIOENTRY         POINT TO FIRST TIOT ENTRY
         XR    R4,R4               CLEAR REG USED TO INSERT LENGTH
LOOP     DS    0H
         USING TIOENTRY,R3
         TM    TIOESTTA,TIOSLTYP   IF ENTRY NOT IN USE
         BO    SKIP                THEN SKIP IT
         CLC   TIOEDDNM(8),0(R6)   IF DDNAMES MATCH
         BE    FOUNDIT             THEN WE GOT IT
SKIP     DS    0H
         IC    R4,TIOELNGH         ELSE GET LENGTH OF THIS ENTRY
         ALR   R3,R4               ADD LENGTH TO GET TO NEXT ENTRY
         CLI   TIOELNGH,0          IF THIS IS THE END OF THE TIOT
         BE    RETURN8             THEN FILE NOT FOUND, RETURN CODE 8
         B     LOOP                ELSE CONTINUE SEARCHING
         SPACE 1
FOUNDIT  DS    0H                  WE FOUND THE TIOT ENTRY...
*
* Before getting the JFCB, check the bits in the TIOT entry to see
* what kind of file this is, and return appropriate information.
*
         TM    TIOELINK,TIOTTERM   If this is a terminal
         BO    DOTERM              then process terminal data set
         TM    TIOELINK,TIOESSDS   If this is a subsystem data set
         BO    DOSUBSYS            then process subsystem data set
*                                  Else assume it's a normal data set
*----------------------------------------------------------------------
* No good if SWA above the line!
*----------------------------------------------------------------------
         XR    R5,R5               PREPARE REGISTER FOR 24-BIT ADDRESS
         ICM   R5,7,TIOEJFCB       GET ADDRESS OF JFCB
         LA    R5,16(,R5)          Point to actual JFCB (past prefix)
*----------------------------------------------------------------------
         USING JFCB,R5
         MVC   0(44,R7),JFCBDSNM   MOVE DSNAME FROM JFCB TO PARM 2
         MVC   0(8,R8),JFCBELNM    MOVE MEMBER FROM JFCB TO PARM 3
         B     AFTJFCB
         SPACE 1
DOTERM   DS    0H                  Process terminal data set
         MVC   0(8,R7),=CL8'TERMFILE'  Set returned DSNAME
         MVI   8(R7),C' '
         MVC   9(44-8-1,R7),8(R7)  Clear rest of dsname to blanks
         MVC   0(8,R8),=CL8' '     Clear returned member to blanks
         B     AFTJFCB
         SPACE 1
DOSUBSYS DS    0H                  Process
         MVI   0(R7),C' '
         MVC   1(43,R7),0(R7)      Clear returned dsname to blanks
         MVC   0(8,R8),=CL8' '     Clear returned member to blanks
*
* If this is a subsystem data set, it is either a SYSOUT data set
* or an instream (DD * or DD DATA) data set.
*
* If the former, how do we find the SYSOUT class?
* If the latter, how do we tell?
*
*
* If this is a SYSOUT data set, we must search the SIOT to find the
* entry corresponding to this DDNAME to get the SYSOUT class.
*
         L     R15,540             Get TCB address
         USING TCB,R15
         L     R15,TCBJSCB         Get JSCB address
         DROP  R15
         USING IEZJSCB,R15
         L     R15,JSCBACT         Get active JSCB address 10/03/89
*----------------------------------------------------------------------
* No good if SWA above the line!
*----------------------------------------------------------------------
         XR    R14,R14                                     10/03/89
         ICM   R14,7,JSCSCTP       Get SCT pointer         10/03/89
         LA    R15,16(,R14)        Bump past SWA prefix    10/03/89
*                                                  Deleted 10/03/89
*----------------------------------------------------------------------
* No good if SWA above the line!
*----------------------------------------------------------------------
*        XR    R14,R14
*        ICM   R14,7,JSCBJCTA      Get JCT pointer
*        LA    R15,16(,R14)        Bump past SWA prefix
*----------------------------------------------------------------------
*        DROP  R15
*        USING JCT,R15
*----------------------------------------------------------------------
* No good if SWA above the line!
*----------------------------------------------------------------------
*        XR    R14,R14
*        ICM   R14,7,JCTSDKAD      Get SCT pointer
*        LA    R15,16(,R14)        Bump past SWA prefix
*----------------------------------------------------------------------
*                                              End Deleted 10/03/89
         DROP  R15
         USING SCT,R15
*----------------------------------------------------------------------
* No good if SWA above the line!
*----------------------------------------------------------------------
         XR    R14,R14
         ICM   R14,7,SCTFSIOT      Get SIOT pointer
         LA    R10,16(,R14)        Bump past SWA prefix
*----------------------------------------------------------------------
         DROP  R15
         USING SIOT,R10
LOOPSIOT DS    0H                  Loop through SIOT's
         CLC   SCTDDNAM(8),0(R6)    until we find one for this DDNAME
         BE    GOTSIOT              at which point go process it
*----------------------------------------------------------------------
* No good if SWA above the line!
*----------------------------------------------------------------------
         ICM   R14,15,SIOTNPTR     Get next SIOT pointer in chain
         BZ    ERRSIOT             If none, disastrous error
         LA    R10,0(,R14)         There's no SWA prefix this time!
*----------------------------------------------------------------------
         B     LOOPSIOT            Continue searching
ERRSIOT  DS    0H                  Error - SIOT not found
         WTO   ROUTCDE=11,                                             X
               'GETDSN: No SIOT found for requested SYSIN/SYSOUT DD.'
         MVC   0(8,R7),=CL8'SYSOUT=?'  Set returned DSNAME
         B     NOSUBSYS            Go with what we got so far...
GOTSIOT  DS    0H                  We found the SIOT for this ddname...
         CLI   SCTOUTPN,C' '       If SYSOUT class is filled in,
         BNH   NOSYSOUT            then...
         MVC   0(7,R7),=CL7'SYSOUT=' set returned DSNAME
         MVC   7(1,R7),SCTOUTPN      move in SYSOUT class
         B     NOSUBSYS            else...
NOSYSOUT DS    0H                   this must be SYSIN...
         MVC   0(8,R7),=CL8'SYSIN=* ' set returned DSNAME
NOSUBSYS DS    0H
         SPACE 1
AFTJFCB  DS    0H                  Got DSN/member, now check to see if
*                                  we need to return a volume serial
         LTR   R9,R9               If we didn't get a volser parameter
         BZ    AFTVSER             then skip this stuff. Else.. .
         XR    R11,R11             Clear register before loadin g
         ICM   R11,7,TIOEFSRT      Get UCB address
         BZ    AFTVSER             If none, skip, let volser be blanks
         USING UCBCMSEG,R11
         MVC   0(6,R9),UCBVOLI     Move volume serial to parameter 4
         SPACE 1
AFTVSER  DS    0H                  Got everything, now check to see if
*                                  there's a concatenated DD following
         IC    R4,TIOELNGH         GET LENGTH OF THIS ENTRY
         ALR   R3,R4               ADD LENGTH TO GET TO NEXT ENTRY
         CLI   TIOELNGH,0          IF THIS IS THE END OF THE TIOT
         BE    RETURN0             THEN NOT CONCATENATED, RETURN CODE 0
         TM    TIOESTTA,TIOSLTYP   IF FOLLOWING ENTRY NOT IN USE
         BO    RETURN0             THEN NOT CONCATENATED, RETURN CODE 0
         CLC   TIOEDDNM(8),=CL8' ' IF FOLLOWING DDNAME IS BLANK
         BE    RETURN4             THEN IT'S A CONCATENATION, RETURN 4
         B     RETURN0             ELSE IT'S ALONE, RETURN CODE 0
         SPACE 1
RETURN8  DS    0H                  FAILURE
         SPACE 1
         LA    R15,8               SET RETURN CODE TO 8
         B     RETURN
         SPACE 1
RETURN4  DS    0H                  CONCATENATED
         SPACE 1
         LA    R15,4               SET RETURN CODE TO 4
         B     RETURN
         SPACE 1
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LR    R0,R15              SET RETURN CODE FOR FORTRAN
         L     R14,12(,R13)
         LM    R1,R12,24(R13)
         BR    R14
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
*                                                                     *
* MACRO EXPANSIONS                                                    *
*                                                                     *
* Note:  DST1.AMODGEN is required for most of these macros.           *
*                                                                     *
***********************************************************************
         EJECT
JFCB     DSECT
         IEFJFCBN ,                Map the JFCB
         EJECT
TIOT     DSECT
         IEFTIOT1 ,                Map the TIOT
         EJECT
UCB      DSECT
         IEFUCBOB ,                Map the UCB
         EJECT
JCT      DSECT
         IEFAJCTB                  Map the JCT
         EJECT
SCT      DSECT
         IEFASCTB                  Map the SCT
         EJECT
SIOT     DSECT
         IEFASIOT                  Map the SIOT
         EJECT
         PRINT NOGEN
         SPACE 2
         IKJTCB                    Map the TCB
         IEZJSCB                   Map the JSCB
         END
./ ADD NAME=GETJID   0100-07332-07332-0900-00106-00106-00000-SEB
         TITLE 'GETJID   - ROUTINE TO RETURN JES2 JOB ID'
***********************************************************************
*                                                                     *
* GETJID   - Subroutine to return JES2 job id (e.g. "JOB  123")       *
*                                                                     *
* This subroutine is callable from a FORTRAN program or PL/1 program  *
* that passes it one character string areas as follows:               *
*                                                                     *
* (1) CHARACTER(8) - filled in with the 8-character JES2 job ID.      *
*                                                                     *
* FORTRAN INVOCATION:                                                 *
*                                                                     *
*       CHARACTER*8 JOBID                                             *
*       CALL GETJID(JOBID)                                            *
*       WRITE (6,*) 'JES2 JOB ID IS ',JOBID                           *
*                                                                     *
* PL/1 INVOCATION:                                                    *
*                                                                     *
*  DCL JOBID CHAR(8);                                                 *
*  DCL GETJID ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *
*  CALL GETJID(JOBID);                                                *
*  PUT LIST('JES2 JOB ID IS ' || JOBID);                              *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 1
GETJID   CSECT
GETJID   AMODE ANY
GETJID   RMODE ANY
         SAVE  (14,12),,GETJID_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING GETJID,R12
*
* THIS PROGRAM NEEDS NO SAVE AREA.
*
         SPACE 1
         L     R6,0(,R1)           Get pointer to parm 1 (char*8)
         MVC   0(8,R6),DEFAULT     Move default name if not known
         L     R2,X'10'            Get CVT address
         USING CVT,R2
         L     R2,CVTJESCT         Get CVTJESCT
         USING JESCT,R2
         L     R2,JESSSCT          Get addr of subsystem control table
         USING SSCT,R2
SSNLOOP  DS    0H
         LTR   R2,R2               If no more subsystems
         BZ    NOACF2              then ACF2 not active, give up
         CLC   8(4,R2),=C'ACF2'    Search for ACF2 subsystem
         BE    GOTACF2
         L     R2,SSCTSCTA         If not found, get next subsystem
         B     SSNLOOP
GOTACF2  DS    0H                  R2 -> ACF2 subsystem table
         ICM   R3,15,SSCTSUSE      Get address of ACCVT
         BZ    NOACF2
         USING ACCVT,R3
         ICM   R4,15,ACCASVT       Get address of beginning of ACFASVT
         BZ    NOACF2
         USING ACFASVT,R4
         L     R5,X'224'           Get current ASCB address
         USING ASCB,R5
         LH    R1,ASCBASID         Get current ASID
         SLA   R1,5                Convert to index to ACFASVT
         AR    R4,R1               Point to ACFASVT for this user
         MVC   0(8,R6),ASVJID      Move JES2 job ID to parm 1
         B     RETURN
NOACF2   DS    0H
         WTO   'GETJID: ACF2 control blocks not available, cannot get JX
               ES2 job id for this job.'
RETURN   DS    0H
         XR    R15,R15             Set return code to zero
         LR    R0,R15              Set return code for FORTRAN (?)
         L     R14,12(,R13)
         LM    R1,R12,24(R13)
         BR    R14
         SPACE 1
DEFAULT  DC    CL8' '              Default name if can't find it
         SPACE 1
         LTORG
         SPACE 1
         DROP  R12
         EJECT
         IKJTCB
         IHAASCB
         ACCVT
         ACFASVT
         IEFJESCT
         IEFJSCVT
         CVT   DSECT=YES
         SPACE 1
         END
./ ADD NAME=GETPGM   0100-07332-07332-0900-00090-00090-00000-SEB
         TITLE 'GETPGM   - ROUTINE TO RETURN EXECUTING PROGRAM NAME'
***********************************************************************
*                                                                     *
* GETPGM   - Subroutine to return name of executing program           *
*                                                                     *
* This subroutine is callable from a FORTRAN program or PL/1 program  *
* that passes it one character string areas as follows:               *
*                                                                     *
* (1) CHARACTER(8) - filled in with the name of the executing program.*
*                                                                     *
* FORTRAN INVOCATION:                                                 *
*                                                                     *
*       CHARACTER*8 PGMNAM                                            *
*       CALL GETPGM(PGMNAM)                                           *
*       WRITE (6,*) 'NAME OF PROGRAM IS ',PGMNAM                      *
*                                                                     *
* PL/1 INVOCATION:                                                    *
*                                                                     *
*  DCL PGMNAM CHAR(8);                                                *
*  DCL GETPGM ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *
*  CALL GETPGM(PGMNAM);
*  PUT LIST('NAME OF PROGRAM IS ' || PGMNAM);                         *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 1
GETPGM   CSECT
GETPGM   AMODE ANY
GETPGM   RMODE ANY
         SAVE  (14,12),,GETPGM_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING GETPGM,R12
*
* THIS PROGRAM NEEDS NO SAVE AREA.
*
         SPACE 1
         L     R6,0(,R1)           Get pointer to parm 1 (char*8)
         MVC   0(8,R6),DEFAULT     Move default name if not known
         L     R7,X'21C'           Get current TCB address
         USING TCB,R7              Establish addressability
         XR    R4,R4
         ICM   R4,7,1(R7)          Get TCB's RB address
RBLOOP   DS    0H
         LTR   R8,R4
         BZ    RETURN              If no RB available, return
         TM    X'B'(R8),X'80'      If this RB points to TCB
         BO    LASTRB              then it's the last one
         XR    R4,R4               else
         ICM   R4,7,X'1D'(R8)      get next RB address
         B     RBLOOP              and continue
LASTRB   DS    0H                  This is the RB to look at
         ICM   R9,R15,X'C'(R8)     Get CDE address
         BZ    RETURN              If none, skip
         MVC   0(8,R6),8(R9)       Move CDE name to parm 1
RETURN   DS    0H
         XR    R15,R15             Set return code to zero
         LR    R0,R15              Set return code for FORTRAN (?)
         L     R14,12(,R13)
         LM    R1,R12,24(R13)
         BR    R14
         SPACE 1
DEFAULT  DC    CL8' '              Default name if can't find it
         SPACE 1
         LTORG
         SPACE 1
         DROP  R12
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         EJECT
         IKJTCB
         SPACE 1
         END
./ ADD NAME=H        0100-07332-07332-0900-01361-01361-00000-SEB
     TITLE 'HELPEXIT - FRONT END TO HELP COMMAND FOR COMMAND INTERFACE'
***********************************************************************
*                                                                     *
* THIS MODULE IS LINKEDITED WITH THE TSO HELP COMMAND.  IT ACTS AS A  *
* FRONT-END INTERCEPT IN SUBCOMMAND MODE TO ENABLE A TSO USER TO      *
* EXECUTE TSO COMMANDS FROM WITHIN SUBCOMMAND MODE.  A TSO USER MAY   *
* EXECUTE A COMMAND OR CLIST FROM SUBCOMMAND MODE BY ENTERING:        *
*                                                                     *
*    HELP X COMMAND OPERANDS ...                                      *
* OR                                                                  *
*    HELP XX COMMAND OPERANDS ...                                     *
*                                                                     *
* IF THE COMMAND IS A CLIST, THEN IF "HELP X ..." IS SPECIFIED THE    *
* CLIST WILL BE EXECUTED AS A LIST OF COMMANDS; IF "HELP XX ..." IS   *
* SPECIFIED THE CLIST WILL BE EXECUTED AS A LIST OF SUBCOMMANDS.      *
* THE HELP SUBCOMMAND ENTERED IN ANY OTHER FORMAT WILL EXECUTE IN THE *
* NORMAL FASHION.  THIS IS DONE BY TRANSFERRING CONTROL TO TRUE ENTRY *
* POINT IKJEFH01.                                                     *
*                                                                     *
*  LINKAGE EDITOR ATTRIBUTES:  REENTRANT, REUSABLE (SAME AS FOR HELP) *
*  MACRO LIBRARIES REQUIRED:  DST1.AMODGEN                            *
*                                                                     *
***********************************************************************
*                                                                     *
* REGISTER USAGE:                                                     *
*                                                                     *
*   R3  -->  CPPL (COMMAND PROCESSOR PARAMETER LIST)                  *
*   R4  -->  ECT (ENVIRONMENT CONTROL TABLE)                          *
*   R5  -->  CBUF (COMMAND BUFFER)                                    *
*   R6  -->  LIST SOURCE DESCRIPTOR FOR COMMAND TO BE STACKED         *
*   R7  -->  (AVAILABLE)                                              *
*   R8  -->  STATIC BASE REGISTER FOR PUTLINE SUBROUTINE              *
*   R9  -->  ADDRESS OF TCOMTAB IF UNDER TEST, ELSE ZEROES            *
*   R10 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 0                      *
*   R11 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 1                      *
*   R12 -->  STATIC BASE REGISTER                                     *
*   R13 -->  SAVE AREA POINTER                                        *
*                                                                     *
***********************************************************************
         SPACE 2
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
HELPEXIT CSECT
         SAVE  (14,12),,HELPEXIT_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING HELPEXIT,R12
         LR    R3,R1               SAVE PARAMETER LIST ADDRESS
         USING CPPL,R3
         XR    R11,R11             CLEAR SUBPOOL 1 STORAGE REGISTER
         LA    R0,SIZDATD0         GET LENGTH OF SUBPOOL 1 STORAGE
         GETMAIN R,LV=(0)          GET SUBPOOL 1 STORAGE
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         LR    R10,R1              ADDRESS SUBPOOL 0 STORAGE
         USING DATD0,R10
         SPACE
         L     R4,CPPLECT          ADDRESS ENVIRONMENT CONTROL TABLE
         USING ECT,R4
         CLC   ECTPCMD(5),=CL8'HELP '  IF PRIMARY COMMAND IS HELP
         BE    REALHELP                THEN THIS IS TRUE HELP COMMAND
         CLC   ECTPCMD(2),=CL2'H '     IF PRIMARY COMMAND IS H
         BE    REALHELP                THEN THIS IS TRUE HELP COMMAND
         SPACE 2
***********************************************************************
* ALLOCATE SUBPOOL 1 STORAGE FOR SCAN SERVICE ROUTINE                 *
***********************************************************************
         SPACE
         GETMAIN R,LV=SIZDATD1,SP=1    GET SUBPOOL 1 STORAGE
         LR    R11,R1              ADDRESS SUBPOOL 1 STORAGE
         USING DATD1,R11
         EJECT
***********************************************************************
* INITIALIZE WORK AREAS                                               *
***********************************************************************
         SPACE
         L     R5,CPPLCBUF
         ST    R5,D0ORGBUF         SAVE ADDR OF ORIGINAL HELP COMMAND
         L     R14,CPPLUPT
         L     R15,CPPLECT
         LA    R0,D0ECB
         STM   R14,R0,IOPLUPT      SET UP IKJPUTL PARAMETER LIST
         LA    R1,D1CSFLG
         LA    R2,CSOA
         STM   R14,R2,CSPL         SET UP IKJSCAN PARAMETER LIST
         L     R1,CPPLPSCB
         LA    R2,DAPB2C
         STM   R14,R2,DAPLUPT      SET UP IKJDAIR PARAMETER LIST
         LA    R0,X'2C'            DAIR ENTRY CODE TO MARK NOT IN USE
         SLL   R0,16               SHIFT INTO LEFT HALF FOR DAIR CB
         STCM  R0,15,DA2CCD        AND PUT ZEROES INTO FLAG FIELD
         MVI   DA2CDDN,C' '        CLEAR DDNAME TO BLANKS
         MVC   DA2CDDN+1(7),DA2CDDN
         MVC   D0PREFIX,0(R5)      SAVE ORIGINAL BUFFER PREFIX
         MVC   D0CMDS,ECTPCMD      SAVE ORIGINAL PRIMARY & SUBCOMMAND
         MVC   D0BLDL(4),=Y(1,12)  INITIALIZE BLDL LIST FOR CMDCHK
         MVC   D0ATTACH(LATTACHL),LATTACH  SET UP ATTACH LIST FORM
         MVC   PTPB(12),LPUTLINE           SET UP PUTLINE LIST FORM
         MVC   PGPB(LPUTGETL),LPUTGET      SET UP PUTGET LIST FORM
         MVC   STPB(LSTACKL),LSTACK        SET UP STACK LIST FORM
         MVC   D0ESTAE(LESTAEL),LESTAE     SET UP ESTAE LIST FORM
         MVC   D0STAX(LSTAXL),LSTAX        SET UP STAX LIST FORM
         LA    R0,1
         LA    R1,D0MSGHDR
         XR    R2,R2
         STM   R0,R2,D0MSGOLD      INITIALIZE PUTLINE WORK AREA
         LA    R1,D0PGHDR
         STM   R0,R1,D0PGOLD       INITIALIZE PUTGET MODE MSG AREA
         LA    R1,D0PGOLD
         ST    R1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK
         LA    R1,D0MSGOLD
         ST    R1,PTPBOPUT         STORE ADDR OF O.L.D. IN PARM BLOCK
         LA    R0,D0CMDECB
         LA    R1,D0ATNECB
         STM   R0,R1,D0ECBLST      INITIALIZE ECB LIST
         OI    D0ECBLST+4,X'80'
*** NOTE: R2 CONTAINS ZEROES FROM ABOVE INSTRUCTIONS.
         ST    R2,DA2CTCB          TCB ADDRESS TO MARK DSE'S NOT IN USE
         ST    R2,D0RETCD          INITIALIZE RETURN CODE TO ZERO
         MVI   D1CSFLG,0           PREPARE TO SYNTAX CHECK COMMAND
         MVI   D0FLAGS,0           INITIALIZE FLAGS
*** SET ADDRESS OF TCOMTAB IF INVOKED UNDER TEST
         XR    R9,R9               INITIALIZE TEST COMM TABLE REGISTER
         CLC   D0CMDS(5),=CL5'TEST '  IF ORIGINAL COMMAND WAS TEST,
         BNE   NTCOM                  THEN
         L     R9,X'21C'               GET ADDRESS OF TCB
         L     R9,X'84'(,R9)           GET TCB OF MOTHER TASK (TEST)
         L     R9,X'14'(,R9)           TCBTRN FIELD = ADDR OF TCOMTAB
NTCOM    DS    0H
         SPACE 2
***********************************************************************
* SET UP ESTAE (ABEND) AND STAX (ATTENTION) EXIT ROUTINES.            *
* NOTE: THE DATD0 DSECT IS PASSED TO BOTH ROUTINES.  SINCE THE        *
*       ADDRESS OF DATD0 IS IN R10, THAT REGISTER IS USED AS THE      *
*       PARAMETER ADDRESS IN THE ESTAE AND STAX MACRO INSTRUCTIONS.   *
***********************************************************************
         SPACE
         LA    R0,PUTLINE          ADDRESSS OF PUTLINE SUBROUTINE
         ST    R0,D0PLADDR         SAVE IT FOR EXIT ROUTINES
         ESTAE STAEEXIT,PARAM=(R10),MF=(E,D0ESTAE)
         LTR   R15,R15             IF ESTAE FAILED,
         BZ    ESTAEOK             THEN
         LA    R1,=C'ESTAE'         BLOW UP
         LA    R0,5
         B     ERROR
ESTAEOK  OI    D0FLAGS,D0ESTON     ELSE INDICATE ESTAE IS ACTIVE
         STAX  STAXEXIT,USADDR=(R10),REPLACE=NO,MF=(E,D0STAX)
         CH    R15,=H'4'           IF STAX FAILED,
         BNH   STAXOK              THEN
         LA    R1,=C'STAX'          BLOW UP
         LA    R0,4
         B     ERROR
STAXOK   OI    D0FLAGS,D0STXON     ELSE INDICATE STAX IS ACTIVE
         SPACE 2
***********************************************************************
* SCAN INPUT COMMAND TO SEE IF IT IS "HELP X ..." OR "HELP XX ..."    *
***********************************************************************
         SPACE
         LR    R1,R5               POINT TO COMMAND BUFFER
         BAL   R14,SCAN            SCAN THE COMMAND
         LTR   R15,R15             IF NO VALID OPERAND FOLLOWS,
         BNZ   REALHELP            THEN PROCESS AS NORMAL HELP
         CLC   D0COMMND(3),=C'XX ' IF FIRST OPERAND IS "XX"
         BE    PROCX2              THEN PROCESS "HELP XX" ROUTINE
         CLC   D0COMMND(2),=C'X '  ELSE SEE IF FIRST OPERAND IS "X"
         BNE   REALHELP            IF NOT, GO TO TRUE HELP ROUTINE.
         OI    D0FLAGS,D0X1        ELSE INDICATE "HELP X"
         MVC   D0CPPL(16),CPPL     COPY CPPL INTO WORK AREA
         L     R14,ECTIOWA         GET ADDRESS OF INPUT STACK
         LM    R1,R2,0(R14)        GET PTRS TO TOP & BOTTOM ELEMENTS
         LA    R1,0(,R1)           PURIFY TOP-OF-STACK ADDRESS
         LA    R2,0(,R2)           PURIFY BOTTOM-OF-STACK ADDRESS
         SR    R1,R2               TOS - BOS = STACK LEVEL (* 4)
         STH   R1,D0STKLVL         SAVE ORIGINAL STACK LEVEL (* 4)
         EJECT
PROCX2   DS    0H
         SPACE
***********************************************************************
* PROCESSING FOR "HELP XX ..." SUBCOMMAND:                            *
* THE REST OF THE SUBCOMMAND BUFFER IS SCANNED AS A TSO COMMAND, THE  *
* NEXT OPERAND IS CHECKED TO SEE IF IT IS A VALID TSO COMMAND OR      *
* CLIST, AND IF SO, IT IS THEN INVOKED.  CONTROL THEN RETURNS         *
* IMMEDIATELY TO SUBCOMMAND MODE.                                     *
***********************************************************************
         SPACE
         MVC   D0OFFSET,2(R5)      SAVE POSSIBLE CLIST NAME OFFSET
         LR    R1,R5               POINT TO COMMAND BUFFER
         BAL   R14,SCAN            SCAN NEXT OPERAND IN COMMAND BUFFER
         B     GOSCAN(R15)         BRANCH BASED ON RETURN CODE
GOSCAN   B     SCAN0               RC=0 - VALID COMMAND NAME
         B     SCAN4               RC=4 - NO COMMAND NAME
         B     SCAN8               RC=8 - INVALID COMMAND NAME
         LH    R15,D0SCANRC        RC=12 - SCAN ERROR
         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP
         LA    R0,4
         B     ERROR
         SPACE
SCAN8    DS    0H                  COMMAND IS SYNTACTICALLY INVALID
         LA    R1,SYNMSG
         LA    R0,L'SYNMSG
         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK
         B     RETURN
         SPACE
SCAN4    DS    0H                  NO COMMAND NAME WAS FOUND
*
* NOTE: THE FOLLOWING CODE MAY BE DELETED IF "HELP X" OR "HELP XX"
*       BY ITSELF IS TO BE PERMITTED AS A HELP REQUEST FOR A SUBCOMMAND
*       NAMED "X" OR "XX".  OTHERWISE "HELP X" OR "HELP XX" WILL BE
*       INTERPRETED AS A READY-MODE HELP COMMAND FOR INFORMATION
*       CONTAINED IN MEMBER "X" OR "XX" OF THE SYSTEM HELP DATA SET.
*
         OI    D0FLAGS,D0ECTMOD    INDICATE THAT ECT HAS BEEN CHANGED
         MVC   ECTPCMD,=CL8'HELP'  SPECIFY HELP COMMAND
         NI    ECTSWS,255-ECTNOPD  INDICATE THAT AN OPERAND IS PRESENT
*
* THIS MARKS THE END OF THE CODE WHICH YOU MAY WISH TO DELETE.
*
         B     REALHELP            GO TO PROCESS AS TRUE HELP COMMAND
         SPACE
SCAN0    DS    0H                  COMMAND NAME IS SYNTACTICALLY OK
         BAL   R14,CKCMD           CHECK EXISTENCE OF COMMAND
         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,
         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE
         LTR   R15,R15             IF COMMAND IS NOT SUPPORTED
         BNZ   RETURN              THEN RETURN WITHOUT INVOKING IT
         BAL   R14,ATTACH          ELSE ATTACH THE COMMAND
         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,
         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE
         TM    D0FLAGS,D0X1        IF "HELP X ..." WAS ENTERED,
         BO    PROCX1              THEN GO PROCESS ADD'L STACKED CMD'S
         SPACE
***********************************************************************
* IF THE "HELP XX ..." SUBCOMMAND WAS ENTERED UNDER TEST, AND A CLIST *
* WAS SPECIFIED, SPECIAL PROCESSING MUST BE DONE TO INSURE THAT THE   *
* CLIST EXECUTES PROPERLY.  TEST'S COMMUNICATION AREA (TCOMTAB,       *
* POINTED TO BY REGISTER 9 UNDER TEST) CONTAINS A BIT CALLED TSTA,    *
* WHICH SPECIFIES WHETHER TEST WAS ENTERED VIA A CLIST OR FROM THE    *
* TERMINAL.  IF THIS BIT IS ON, SUBCOMMANDS OF TEST THAT CAUSE THE    *
* PROBLEM PROGRAM TO GET CONTROL (GO, CALL, LOAD, GETMAIN, ETC.) CAN  *
* CAUSE TEST TO STACK AN ADDITIONAL TERMINAL ELEMENT, STOPPING THE    *
* CLIST.  TO PREVENT THIS, WE SET OFF THE BITS THAT SPECIFY THAT A    *
* TERMINAL ELEMENT SHOULD BE ADDED (AND REMOVED AT END TIME).         *
* NOTE:  IT IS POSSIBLE THAT DIFFICULTIES COULD OCCUR IF A CLIST      *
* EXECUTED UNDER TEST VIA "HELP XX" ISSUES THE END SUBCOMMAND.        *
***********************************************************************
* NOTE: THIS MAY NOT APPLY TO TSO/E ... REMAINS TO BE SEEN.           *
***********************************************************************
         SPACE
         LTR   R9,R9               IF ORIGINAL COMMAND WAS "TEST",
         BZ    ENDCMDS             THEN
         NI    X'9B'(R9),B'00111111' TURN OFF TSTA AND TSTB BITS.
         B     ENDCMDS             FINISH UP
         EJECT
REALHELP DS    0H                  PROCESS TRUE HELP COMMAND
         TM    D0FLAGS,D0BUFMOD    IF COMMAND BUFFER WAS ALTERED,
         BZ    *+10                THEN
         MVC   0(4,R5),D0PREFIX     RESTORE COMMAND BUFFER PREFIX.
         LTR   R1,R11              IF SUBPOOL 1 STORAGE ALLOCATED,
         BZ    NOFREE1             THEN
         FREEMAIN R,LV=SIZDATD1,A=(1),SP=1  FREE SUBPOOL 1 STORAGE
         XR    R11,R11              INDICATE SUBPOOL 1 STORAGE FREED
NOFREE1  DS    0H
         LR    R1,R3               RESTORE CPPL ADDRESS
*---THIS CODE EFFECTS THE FRONT ENDING--------------------------------*
*        L     R15,=V(IKJEFH01)    GET ADDRESS OF TRUE HELP ENTRY POINT
*        BALR  R14,R15             CALL IKJEFH01 TO DO HELP
*---END OF FRONT ENDING CODE------------------------------------------*
* THIS CODE IS IN USE HERE
* FOR THE PURPOSES OF MY USAGE AT DRAPER, I HAVE SET UP THIS VERSION  *
* OF THE "H" COMMAND SO THAT IT WORKS IN COMPATIBILITY WITH THE       *
* THROWN-TOGETHER INTERFACE TO XCMD, I.E. IF HELP AAA (SUCH THAT AAA  *
* IS NEITHER X NOR XX) IS SPECIFIED, I INVOKE XCMD RATHER THAN HELP.  *
         NI    ECTSWS,255-ECTNOPD  TURN OFF ERRONEOUS NO-OPERANDS BIT
         LINK  EP=XCMD             LINK TO XCMD TO DO SIMILAR THINGS
* END OF CODE IN USE HERE
         ST    R15,D0RETCD         SAVE RETURN CODE FROM HELP
         B     AFTFREE1            AND RETURN TO SUBCOMMAND MODE
         EJECT
RETURN   DS    0H
         SPACE
***********************************************************************
*           *** RETURN TO SUBCOMMAND MODE - BUT FIRST: ***            *
* THE FOLLOWING CODE IS EXECUTED AT THIS POINT BECAUSE CERTAIN        *
* SUBCOMMAND ENVIRONMENTS (SUCH AS TESTCOB) SCAN THE SUBCOMMAND       *
* BUFFER SEVERAL TIMES TO PROCESS SUBCOMMANDS.  THIS IS BECAUSE THE   *
* SUBCOMMAND MAY BE A SERIES OF SEPARATE SUBCOMMANDS SEPARATED BY     *
* SEMICOLONS (GENERALLY CONTAINED IN A SUBCOMMAND LIST TO BE EXECUTED *
* AT A BREAKPOINT).  IN THE CASE OF TESTCOB, THE COMMAND BUFFER       *
* OFFSET IS USED TO DETERMINE THE STARTING POINT OF EACH SCAN.  THIS  *
* OFFSET IS GENERALLY SET TO POINT TO THE END OF THE COMMAND BUFFER   *
* BY THE PARSE SERVICE ROUTINE.  IN CASES WHERE THE COMMAND BUFFER IS *
* NOT PARSED, HOWEVER, THE COMMAND BUFFER OFFSET IS NOT UPDATED AND   *
* THE SUBCOMMAND PROCESSOR ATTEMPTS TO INVOKE THE KEYWORD PORTION OF  *
* THE COMMAND AS ANOTHER SUBCOMMAND.                                  *
* TO PREVENT THIS, WE CHECK THE COMMAND BUFFER OFFSET OF THE ORIGINAL *
* "HELP X ..." COMMAND TO SEE IF (1) IT DOES NOT POINT TO THE END OF  *
* THE COMMAND BUFFER AND (2) IT DOES NOT POINT TO A BYTE IMMEDIATELY  *
* FOLLOWING A SEMICOLON, WHICH WOULD INDICATE A NEW SUBCOMMAND.  IF   *
* THESE TWO CONDITIONS ARE TRUE, THE COMMAND BUFFER OFFSET FIELD IS   *
* UPDATED TO POINT TO THE END OF THE COMMAND BUFFER OR A SEMICOLON,   *
* IF ONE EXISTS FOLLOWING THE CURRENT COMMAND BUFFER OFFSET LOCATION. *
* THE COMMAND BUFFER IS SCANNED FROM THE CURRENT OFFSET LOCATION TO   *
* THE END FOR A SEMICOLON.  FOR CONSISTENCY WITH GENERAL PRACTICE, A  *
* SEMICOLON IS TREATED AS ONE ONLY IF IT DOES NOT OCCUR WITHIN        *
* QUOTES, PARENTHESES, OR A COMMENT SEQUENCE.                         *
***********************************************************************
         SPACE
         L     R5,D0ORGBUF         GET ADDRESS OF ORIGINAL HELP COMMAND
         LH    R15,0(,R5)          R15 = COMMAND BUFFER LENGTH
         LH    R1,2(,R5)           R1  = COMMAND BUFFER OFFSET
         LA    R0,0(R15,R5)        R0 -> END OF COMMAND BUFFER
         BCTR  R0,0                R0 -> LAST BYTE IN COMMAND BUFFER
         LA    R1,4(R1,R5)         R1 -> BUFFER OFFSET LOCATION
         CR    R1,R0               IF WE'RE AT END OF BUFFER ALREADY
         BH    AFTBUFF             THEN CURRENT OFFSET IS OK.  ELSE...
         BCTR  R1,0                LOOK AT PREVIOUS CHARACTER IN BUFFER
         CLI   0(R1),C';'          IF IT IS A SEMICOLON
         BE    AFTBUFF             THE CURRENT OFFSET IS OK.  ELSE...
         XR    R14,R14             CLEAR PARENTHESIS COUNT
BUFFINCR LA    R1,1(,R1)           START SCANNING BUFFER FOR SEMICOLON
         CR    R1,R0               SCAN UNTIL END OF COMMAND BUFFER
         BH    GOTBUFF             (AT END WILL BE NEW OFFSET)
         CLI   0(R1),C''''         IF QUOTE FOUND,
         BNE   NOTQUOTE            THEN (";" IGNORED INSIDE QUOTES)...
QUOTLOOP LA    R1,1(,R1)            SCAN FOR END QUOTE ONLY
         CR    R1,R0                AT END OF BUFFER,
         BH    GOTBUFF              WE WILL HAVE OFFSET ANYWAY
         CLI   0(R1),C''''          ELSE IF ANOTHER QUOTE FOUND
         BE    BUFFINCR             THEN CONTINUE NORMAL SCAN
         B     QUOTLOOP             ELSE CONTINUE QUOTED SCAN
NOTQUOTE DS    0H                  ELSE SEE IF INSIDE COMMENTS
         CR    R1,R0               IF WE'RE NOT AT THE LAST BYTE YET
         BNL   NOTCOMNT            THEN
         CLC   0(2,R1),=C'/*'       IF AT BEGINNING OF COMMENT SEQUENCE
         BNE   NOTCOMNT             THEN
         LA    R1,2(,R1)             POINT TO BYTE FOLLOWING /*
COMNTLP  CR    R1,R0                 SCAN UNTIL END OF BUFFER
         BNL   BUFFINCR              IF AT END, TERMINATE SCAN
         CLC   0(2,R1),=C'*/'        IF NOT END OF COMMENT SEQUENCE
         BE    ENDCOMNT              THEN
         LA    R1,1(,R1)              CONTINUE SCAN FOR END COMMENT
         B     COMNTLP               ELSE
ENDCOMNT LA    R1,1(,R1)              BUMP POINTER PAST */
         B     BUFFINCR               AND CONTINUE SCAN.
NOTCOMNT DS    0H                  ELSE SEE IF WITHIN PARENTHESES
         CLI   0(R1),C'('          IF LEFT PARENTHESIS FOUND,
         BNE   NOLP                THEN
         LA    R14,1(,R14)          INCREMENT PARENTHESIS COUNT
         B     BUFFINCR             AND CONTINUE SCAN.  ELSE...
NOLP     LTR   R14,R14             IF ALREADY INSIDE PARENTHESES,
         BZ    NOPARENS            THEN
         CLI   0(R1),C')'           IF RIGHT PARENTHESIS FOUND
         BNE   BUFFINCR             THEN
         BCTR  R14,0                 DECREMENT PARENTHESIS COUNT
         B     BUFFINCR              AND CONTINUE SCAN.  ELSE...
NOPARENS CLI   0(R1),C';'          IF A SEMICOLON IS REALLY FOUND,
         BNE   BUFFINCR            THEN
         LA    R1,1(,R1)            BUMP TO POSITION FOLLOWING IT
GOTBUFF  DS    0H                  WE NOW HAVE THE NEW OFFSET LOCATION
         LA    R0,4(,R5)           GET ADDRESS OF START OF COMMAND
         SLR   R1,R0               LOC - START = NEW OFFSET VALUE
         STH   R1,2(,R5)           STORE NEW COMMAND BUFFER OFFSET
AFTBUFF  DS    0H
         EJECT
***********************************************************************
* NOW FREE STORAGE AND EXIT                                           *
***********************************************************************
         SPACE
         LTR   R1,R11              IF SUBPOOL 1 STORAGE ALLOCATED,
         BZ    AFTFREE1            THEN
         FREEMAIN R,LV=SIZDATD1,A=(1),SP=1  FREE SUBPOOL 1 STORAGE
         XR    R11,R11              INDICATE SUBPOOL 1 STORAGE FREED
AFTFREE1 DS    0H
         TM    D0FLAGS,D0ECTMOD    IF ECTPCMD OR ECTSCMD WAS ALTERED,
         BZ    *+10                THEN
         MVC   ECTPCMD(16),D0CMDS   RESTORE ECTPCMD AND ECTSCMD.
         TM    D0FLAGS,D0STXON     IF STAX IS ACTIVE
         BNO   OFFSTAX             THEN
         STAX  ,                    CANCEL STAX
OFFSTAX  DS    0H
         TM    D0FLAGS,D0ESTON     IF ESTAE IS ACTIVE
         BNO   OFFESTAE            THEN
         ESTAE 0                    CANCEL ESTAE
OFFESTAE DS    0H
         SPACE
FINALRET DS    0H
         L     R15,D0RETCD         PICK UP RETURN CODE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        PASS BACK RETURN CODE IN R15
         FREEMAIN R,LV=SIZDATD0,A=(1)  FREE SUBPOOL 0 STORAGE
         LM    R14,R12,12(R13)
         BR    R14
         SPACE 2
LPUTLINE PUTLINE MF=L,OUTPUT=(*-*,TERM,SINGLE,INFOR)
LPUTGET  PUTGET  MF=L,OUTPUT=(*-*,,MODE)
LPUTGETL EQU   *-LPUTGET
FLUSHALL STACK MF=L,DELETE=ALL     NORMAL STACK FLUSH LIST FORM
FLUSHTOP STACK MF=L,DELETE=TOP     ATTN STACK FLUSH LIST FORM
LSTACK   STACK MF=L,STORAGE=*-*    STACK NEW COMMAND LIST FORM
LSTACKL  EQU   *-LSTACK
LATTACH  ATTACH SF=L,SHSPV=78,SZERO=NO
LATTACHL EQU   *-LATTACH
LESTAE   ESTAE MF=L
LESTAEL  EQU   *-LESTAE
LSTAX    STAX  MF=L,REPLACE=NO
LSTAXL   EQU   *-LSTAX
         SPACE
MODEDATA DC    Y(MODELEN,0)
MODEMSG  DC    C' HELP X'          LEADING BLANK REQUIRED - NO MSGID
MODELEN  EQU   *-MODEDATA
         SPACE
***********************************************************************
* MESSAGES                                                            *
***********************************************************************
         SPACE
SYNMSG   DC    C'XHX001I INVALID COMMAND SYNTAX'
ERRMSG1  DC    C'XHX005I COMMAND INTERFACE FAILED, '
ERRMSG2  DC    C' ERROR CODE '
         SPACE
         LTORG
         TITLE 'HELPEXIT - HELP X PROCESSING'
PROCX1   DS    0H
         SPACE
***********************************************************************
*                   "HELP X ..." PROCESSING                           *
* FOR "HELP X ...", ALL COMMANDS PLACED ON THE INPUT STACK BY THE     *
* CURRENT COMMAND (E.G. A CLIST) ARE EXECUTED FROM THIS INTERFACE.    *
* THE END OF THE CLIST OR STACK ELEMENT IS DETERMINED BY COMPARING    *
* THE STACK LEVEL WITH THE ORIGINAL STACK LEVEL.                      *
* NOTE: WHEN THE END OF A CLIST IS REACHED, THE PUTGET SERVICE        *
* ROUTINE AUTOMATICALLY GOES TO THE NEXT LOWER ELEMENT ON THE STACK   *
* TO RETRIEVE THE NEXT COMMAND.  NO NOTIFICATION IS RECEIVED BY THE   *
* CALLER OF PUTGET THAT THIS HAS HAPPENED.  TO GET AROUND THIS        *
* PROBLEM, WE ISSUE A PUTGET WITH A BAD MODE MESSAGE SO THAT THE      *
* PUTGET WILL COMPLETE SUCCESSFULLY AS LONG AS IT GETS A COMMAND FROM *
* A CLIST, BUT NOT WHEN IT TRIES TO GET A COMMAND FROM THE TERMINAL   *
* (IT WILL RETURN A CODE OF 24 IN THIS CASE).  (THIS IDEA CAME        *
* ORIGINALLY FROM SPF MODULE ISPCAT (OR CAT).)  WHEN THIS SITUATION   *
* IS DETECTED, THE INPUT STACK LEVEL IS CHECKED; IF THE STACK LEVEL   *
* IS STILL HIGHER THAN THE ORIGINAL STACK LEVEL (I.E. THE LEVEL WHEN  *
* THE "HELP X ..." COMMAND WAS STARTED), IT IS PROBABLE THAT A TERMIN *
* COMMAND PROCEDURE STATEMENT HAS BEEN EXECUTED, SO THE PUTGET IS     *
* REISSUED WITH A GOOD MODE MESSAGE TO PERMIT TERMIN FUNCTIONING.     *
* OTHERWISE WE KNOW THAT THE CLIST HAS COME TO AN END AND WE          *
* TERMINATE.                                                          *
* THERE IS ONE MORE PROBLEM AREA:  WHAT IF THE "HELP X ..." COMMAND   *
* WAS INVOKED FROM A CLIST TO BEGIN WITH?  IN THIS CASE PUTGET WILL   *
* SUCCESSFULLY RETRIEVE SUBCOMMANDS IN THE SAME CLIST FOLLOWING THE   *
* "HELP X ..." COMMAND, WHICH IS NOT WHAT WE WANT.  TO SOLVE THIS     *
* PROBLEM, WE CHECK THE STACK LEVEL FOLLOWING EVERY COMMAND THAT WE   *
* RETRIEVED.  IF WE ARE BACK TO THE ORIGINAL STACK LEVEL OR LOWER, WE *
* KNOW THAT THE COMMAND WE GOT DOESN'T BELONG TO US, SO WE "GIVE IT   *
* BACK" BY COPYING THE COMMAND INTO STORAGE AND ADDING IT TO THE      *
* INPUT STACK AS AN IN-STORAGE LIST, AND THEN WE TERMINATE.  THE      *
* SUBCOMMAND ENVIRONMENT RECEIVES CONTROL AGAIN, AND WHEN IT REQUESTS *
* ANOTHER SUBCOMMAND IT PICKS UP THAT COMMAND WE HAVE JUST STACKED.   *
***********************************************************************
         SPACE
***********************************************************************
* WHILE THE CURRENT STACK LEVEL IS HIGHER THAN THE ORIGINAL LEVEL,    *
* RETRIEVE COMMANDS USING PUTGET, SCAN THEM AND ATTACH THE COMMANDS   *
* WHEN VALID.  NOTE THAT STACK FLUSHING MAY CAUSE THE CURRENT STACK   *
* LEVEL TO REVERT TO THE ORIGINAL LEVEL, TERMINATING OUR PROCESSING   *
* OF COMMANDS; THIS IS A NORMAL WAY OF CLIST TERMINATION UNDER TSO.   *
***********************************************************************
         SPACE
         TM    D0FLAGS,D0GOTLN     IF LINE HAS BEEN OBTAINED BY PUTGET,
         BZ    X1GET               THEN
         LR    R1,R5                GET ADDRESS OF PUTGET BUFFER
         LA    R0,1                 GET SUBPOOL NUMBER
         SLL   R0,24                SHIFT INTO HIGH-ORDER BYTE
         AH    R0,0(,R5)            ADD IN LENGTH OF PUTGET BUFFER
         FREEMAIN R,LV=(0),A=(1)    FREE THE PUTGET INPUT BUFFER
         NI    D0FLAGS,255-D0GOTLN  INDICATE NO MORE PUTGET BUFFER
         SPACE
X1GET    DS    0H
         SPACE
***********************************************************************
* AT THIS POINT WE ARE READY TO GET THE NEXT COMMAND, BUT ONLY IF A   *
* NEW ELEMENT HAS BEEN PLACED ON THE INPUT STACK AND/OR THE STACK     *
* LEVEL AT THIS POINT IS HIGHER THAN THE ORIGINAL STACK LEVEL.  SUCH  *
* CAN OCCUR IF WE HAVE EXECUTED A CLIST OR IF WE HAVE INVOKED A       *
* COMMAND THAT STACKS OTHER COMMANDS.  WE KEEP PROCESSSING COMMANDS   *
* UNTIL THE STACK LEVEL BECOMES LESS THAN OR EQUAL TO THE LEVEL AT    *
* WHICH THE ORIGINAL "HELP X ..." COMMAND WAS ISSUED.  NOTE THAT ANY  *
* ERROR ENCOUNTERED DURING A PREVIOUS PASS THROUGH THIS LOOP WILL     *
* HAVE CAUSED US TO ISSUE A STACK FLUSH, WHICH WILL RESULT IN         *
* TERMINATION OF NEW STACK ELEMENTS (AND EXIT FROM LOOP) UNLESS THE   *
* ELEMENT IS A CLIST WITH CONTROL MAIN OR CONTROL NOFLUSH ACTIVE.     *
***********************************************************************
         SPACE
         L     R14,ECTIOWA         GET ADDRESS OF THE INPUT STACK
         LM    R1,R2,0(R14)        GET T.O.S. AND B.O.S POINTERS
         LA    R1,0(,R1)           PURIFY TOP-OF-STACK POINTER
         LA    R2,0(,R2)           PURIFY BOTTOM-OF-STACK POINTER
         SR    R1,R2               GET CURRENT STACK LEVEL (* 4)
         CH    R1,D0STKLVL         IF WE'RE DOWN TO ORIGINAL OR LOWER,
         BNH   ENDCMDS             THEN END OUR PROCESSING.
         SPACE
***********************************************************************
* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *
***********************************************************************
         SPACE
         LA    R3,D0CPPL           POINT TO OUR CPPL NOW
         XC    D0PGHDR(4),D0PGHDR  SET UP BAD (NULL) MODE MESSAGE
         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE
         CH    R15,=H'24'          IF INVALID PARAMETERS ON PUTGET,
         BNE   PUTGETOK            THEN (TERMINAL IS CURRENT ELEMENT)..
         L     R14,ECTIOWA          GET ADDRESS OF THE INPUT STACK
         LM    R1,R2,0(R14)         GET T.O.S. AND B.O.S POINTERS
         LA    R1,0(,R1)            PURIFY TOP-OF-STACK POINTER
         LA    R2,0(,R2)            PURIFY BOTTOM-OF-STACK POINTER
         SR    R1,R2                GET CURRENT STACK LEVEL (* 4)
         CH    R1,D0STKLVL          IF WE'RE DOWN TO ORIGINAL OR LOWER,
         BNH   ENDCMDS              THEN END OUR PROCESSING.
         SPACE
***********************************************************************
* ELSE WE ASSUME A TERMIN STATEMENT WAS EXECUTED AND WE ACCEPT INPUT. *
***********************************************************************
         SPACE
         MVC   D0PGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE
         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG                OR
         CH    R15,=H'24'            INVALID PARAMETERS ON PUTGET,
         BNE   PUTGETOK               THEN (REALLY BAD PUTGET)...
BADPG    LA    R1,=C'PUTGET'           BLOW UP
         LA    R0,6
         B     ERROR
PUTGETOK DS    0H
         CLI   D0STATUS,D0ATTN     IF ATTENTION INTERRUPT OCCURRED,
         BNE   PGNOATTN            THEN
         LA    R1,FLUSHTOP          FLUSH THE STACK (EVEN IF
         BAL   R14,FLUSH             CONTROL NOFLUSH IS ACTIVE)
         B     PROCX1               AND CONTINUE
PGNOATTN DS    0H                  ELSE PROCESS INPUT...
         L     R5,PGPBIBUF         GET ADDRESS OF PUTGET INPUT BUFFER
         LTR   R15,R15             IF PUTGET RC=0, LINE CAME FROM THE
         BZ    PROCLINE             TERMINAL (PROB. TERMIN), SO PROCESS
         SPACE
***********************************************************************
* ELSE PUTGET RETURN CODE = 4 - CHECK WHERE WE ARE ON THE INPUT STACK *
***********************************************************************
         SPACE
         L     R14,ECTIOWA          GET ADDRESS OF THE INPUT STACK
         LM    R1,R2,0(R14)         GET T.O.S. AND B.O.S POINTERS
         LA    R1,0(,R1)            PURIFY TOP-OF-STACK POINTER
         LA    R2,0(,R2)            PURIFY BOTTOM-OF-STACK POINTER
         SR    R1,R2                GET CURRENT STACK LEVEL (* 4)
         CH    R1,D0STKLVL          IF WE'RE STILL ABOVE ORIGINAL LEVEL
         BH    PROCLINE             THEN IT'S OURS, WE CAN PROCESS IT
         SPACE
***********************************************************************
* ELSE THIS COMMAND, EVEN THOUGH FROM A CLIST, WAS FROM A CLIST AT    *
* OUR ORIGINAL STACK LEVEL OR LOWER.  THEREFORE, WE HAVE TO GIVE THIS *
* COMMAND BACK TO THE SUBCOMMAND UNDER WHICH WE WERE INVOKED.  WE DO  *
* THIS BY STACKING THE COMMAND IN STORAGE AND TERMINATING SO THAT THE *
* SUBCOMMAND PROCESSOR PICKS UP THE COMMAND AS THE NEXT SUBCOMMAND.   *
***********************************************************************
         SPACE
         L     R0,=X'4E000010'     SUBPOOL 78 + 16 (LENGTH OF AN LSD)
         AH    R0,0(,R5)           ADD LENGTH OF THE PUTGET BUFFER
         GETMAIN R,LV=(0)          GET A BUFFER FROM SUBPOOL 78
         LR    R6,R1               SAVE BUFFER ADDRESS
         LA    R14,16(,R6)         ADDRESS OF COMMAND IN STORAGE
         LH    R15,0(,R5)          LENGTH OF COMMAND BUFFER
*
* LEFT HALF OF R15 IS ZERO FOR VARIABLE RECORD LENGTH
* RIGHT HALF OF R15 IS LENGTH OF THE IN-STORAGE LIST
*
         LR    R0,R14              ADDRESS OF FIRST COMMAND IN THE LIST
         XR    R1,R1               RESERVED FOR EXEC COMMAND, N/A HERE
         STM   R14,R1,0(R6)        SET UP LSD (LIST SOURCE DESCRIPTOR)
         BCTR  R15,0               USING COMMAND BUFFER LENGTH,
         EX    R15,MVINSTOR        MOVE COMMAND TO IN-STORAGE LIST
*** ASSUME R1 = 0
         ST    R1,D0ECB            CLEAR ECB
         SPACE
***********************************************************************
* PUT COMMAND ON STACK TO BE PROCESSED AS NEXT SUBCOMMAND         .   *
***********************************************************************
         SPACE
         STACK PARM=STPB,STORAGE=((R6),SOURCE),MF=(E,IOPL)
         LTR   R15,R15             IF STACK SUCCESSFUL,
         BZ    ENDCMDS             THEN TERMINATE OUR PROCESSING.
         LA    R1,=C'STACK'        ELSE BLOW UP
         LA    R0,5
         B     ERROR
         SPACE
PROCLINE DS    0H                  GO AHEAD AND PROCESS THIS LINE
         ST    R5,D0CBUF           SET CPPL COMMAND BUFFER ADDRESS
         XC    D0OFFSET,D0OFFSET   SET COMMAND BUFFER OFFSET TO ZERO
         LR    R1,R5               POINT TO THE COMMAND BUFFER
         BAL   R14,SCAN            SCAN NEXT OPERAND OF THE COMMAND
         B     GOSCANX(R15)        BRANCH BASED ON RETURN CODE
GOSCANX  B     SCANX0              RC=0 - VALID COMMAND NAME
         B     PROCX1              RC=4 - NO COMMAND NAME
         B     SCANX8              RC=8 - INVALID COMMAND NAME
         LH    R15,D0SCANRC        RC=12 - SCAN ERROR
         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP
         LA    R0,4
         B     ERROR
         SPACE
SCANX8   DS    0H                  COMMAND IS SYNTACTICALLY INVALID
         LA    R1,SYNMSG
         LA    R0,L'SYNMSG
         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK
         B     PROCX1
         SPACE
SCANX0   DS    0H                  COMMAND IS SYNTACTICALLY OK
         BAL   R14,CKCMD           CHECK VALIDITY OF COMMAND
         LTR   R15,R15             IF COMMAN IS NOT VALID,
         BNZ   PROCX1              THEN CONTINUE WITH THE NEXT ONE
         BAL   R14,ATTACH          ELSE INVOKE THE COMMAND
         TM    D0FLAGS,D0SUBER     IF SUBROUTINE ERROR,
         BO    ERROR               THE GO TO DISPLAY MESSAGE
         B     PROCX1              ELSE GO TO GET THE NEXT COMMAND
         EJECT
ENDCMDS  DS    0H                  NO MORE COMMANDS TO PROCESS
         XR    R15,R15
         ICM   R15,7,ECTRTCD       PICK UP RETURN CODE FROM ECT
         ST    R15,D0RETCD         SAVE THE RETURN CODE
         SPACE
***********************************************************************
* AT THIS POINT, TO INSURE CORRECT COMMAND STATISTICAL RECORDING, WE  *
* DO VARIOUS STUFF FOR TSO/MON.  SINCE TSO/MON IS NOT INSTALLED AT    *
* DRAPER, I HAVE OMITTED THIS CODE, BUT MAY ADD SVC109 INTERFACE SOON.*
***********************************************************************
         SPACE
         B     RETURN              RETURN TO SUBCOMMAND MODE
         SPACE 2
MVINSTOR MVC   16(0,R6),0(R5)      MOVE COMMAND TO IN-STORAGE LIST
         EJECT
ERROR    DS    0H                  DISPLAY ERROR MESSAGE AND END
         SPACE
***********************************************************************
* MISCELLANEOUS ERROR DISPLAY.                                        *
* R0 CONTAINS LENGTH OF NAME OF FUNCTION THAT FAILED                  *
* R1 CONTAINS ADDRESS OF NAME OF FUNCTION THAT FAILED                 *
* R15 CONTAINS RETURN CODE FROM FAILED FUNCTION                       *
***********************************************************************
         SPACE
         MVC   D0MSG(L'ERRMSG1),ERRMSG1  SET UP FIRST PART OF MESSAGE
         LTR   R14,R0              GET LENGTH OF FUNCTION TYPE
         BNP   AFTFUNC             IF NONE, BYPASS
         BCTR  R14,0               ELSE REDUCE LENGTH FOR EXECUTE
         EX    R14,MOVEFUNC        MOVE FUNCTION NAME TO ERROR MESSAGE
AFTFUNC  LA    R1,D0MSG+L'ERRMSG1+1(R14)  POINT TO NEXT PART OF MESSAGE
         MVC   0(L'ERRMSG2,R1),ERRMSG2    SET UP SECOND PART OF MESSAGE
         CVD   R15,D0DOUBLE               CONVERT ERROR CODE TO DISPLAY
         UNPK  L'ERRMSG2(2,R1),D0DOUBLE
         OI    L'ERRMSG2+1(R1),X'F0'
         LA    R0,L'ERRMSG1+L'ERRMSG2+3(R14)  GET LENGTH OF MSG IN R0
         XR    R1,R1               INDICATE MESSAGE ALREADY IN WORKAREA
         BAL   R14,PUTLINE         DISPLAY THE MESSAGE
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           FLUSH THE INPUT STACK
         B     RETURN              RETURN TO SUBCOMMAND MODE
         SPACE
MOVEFUNC MVC   D0MSG+L'ERRMSG1(0),0(R1)  MOVE FUNCTION TO ERROR MESSAGE
         TITLE 'HELPEXIT - SCAN SUBROUTINE'
***********************************************************************
* THE SCAN SUBROUTINE INVOKES THE IKJSCAN TSO SERVICE ROUTINE TO      *
* DETERMINE THE NATURE OF THE NEXT OPERAND IN THE HELP SUBCOMMAND     *
* BUFFER.  ON ENTRY R1 CONTAINS THE ADDRESS OF THE COMMAND BUFFER TO  *
* BE SCANNED.  ON RETURN THE FIELD D0COMMND CONTAINS THE OPERAND,     *
* BLANK PADDED AND JUSTIFIED LEFT, UNLESS THE OPERAND IS MISSING OR   *
* SYNTACTICALLY INVALID.  R15 IS SET TO ZERO IF THE OPERAND IS A      *
* SYNTACTICALLY VALID COMMAND NAME, 4 IF IT IS MISSING, 8 IF IT IS    *
* SYNTACTICALLY INVALID, 12 IF AN ERROR RETURN CODE IS PASSED BACK    *
* FROM IKJSCAN.  IF THE OPERAND WAS PRECEDED BY A PERCENT SIGN (%),   *
* THE FLAG D0EXEC IS SET ON; OTHERWISE IT IS SET OFF.  IF THERE ARE   *
* NO FURTHER OPERANDS IN THE HELP SUBCOMMAND BUFFER FOLLOWING THE     *
* CURRENT ONE, THE ECTNOPD FLAG IN THE ECT IS SET ON.                 *
***********************************************************************
         SPACE
SCAN     DS    0H
         ST    R14,D0SCAN14        SAVE RETURN REGISTER
         MVI   D0COMMND,C' '       SET COMMAND NAME FIELD TO BLANKS
         MVC   D0COMMND+1(7),D0COMMND
         NI    D0FLAGS,255-D0EXEC  ASSUME NOT AN IMPLICIT EXEC FOR NOW
         NI    ECTSWS,255-ECTNOPD  SET ECT NO-OPERANDS BIT OFF
         ST    R1,CSPLCBUF         SET COMMAND BUFFER ADDRESS FROM PARM
         OI    D0FLAGS,D0BUFMOD    INDICATE COMMAND BUFFER MODIFIED
         XC    D0ECB,D0ECB         CLEAR ECB
         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  CALL IKJSCAN TO SCAN BUFFER
         STH   R15,D0SCANRC        SAVE IKJSCAN RETURN CODE
         LTR   R15,R15             IF SCAN FAILED,
         BZ    SCANOK              THEN...
         LA    R15,12               INDICATE SCAN FAILURE
         B     SCANRET              AND RETURN. ELSE...
SCANOK   DS    0H                  CHECK RESULTS OF SCAN
         TM    CSOAFLG,CSOANOC     IF NO OPERAND WAS FOUND,
         BNO   NOTNOC              THEN...
         OI    ECTSWS,ECTNOPD       INDICATE ECT NO OPERANDS
         LA    R15,4                RETURN INDICATING NOTHING FOUND
         B     SCANRET             ELSE...
NOTNOC   DS    0H                  (AN OPERAND EXISTS)
         LH    R1,CSOALNM          PICK UP LENGTH OF OPERAND
         LTR   R1,R1               IF LENGTH IS ZERO,
         BP    NOTBAD              THEN...
         LA    R15,8                RETURN INDICATING BAD SYNTAX
         B     SCANRET             ELSE...
NOTBAD   DS    0H
         L     R15,CSOACNM         GET ADDRESS OF OPERAND
         BCTR  R1,0                REDUCE OPERAND LENGTH FOR EXECUTE
         EX    R1,MOVECMD          MOVE OPERAND TO COMMAND NAME AREA
         XR    R15,R15             INDICATE VALID COMMAND NAME
         TM    CSOAFLG,CSOAEXEC    IF COMMAND PRECEDED BY % SIGN,
         BZ    *+8                 THEN...
         OI    D0FLAGS,D0EXEC       INDICATE IMPLICIT EXEC
         TM    CSOAFLG,CSOAVNP     IF THERE ARE NO FURTHER OPERANDS,
         BNO   *+8                 THEN...
         OI    ECTSWS,ECTNOPD       SAY SO IN ECT
         SPACE
SCANRET  L     R14,D0SCAN14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE 2
MOVECMD  MVC   D0COMMND(0),0(R15)  MOVE COMMAND NAME TO NAME AREA
         SPACE
         LTORG
         TITLE 'HELPEXIT - CKCMD SUBROUTINE'
CKCMD    DS    0H
         SPACE
         ST    R14,D0CKCM14        SAVE RETURN REGISTER
         NI    D0FLAGS,255-D0SUBER TURN OFF ERROR INDICATOR
         TM    D0FLAGS,D0EXEC      IF IMPLICIT %CLIST,
         BO    IMPLICIT            THEN PROCESS AS ONE. ELSE...
         CLC   D0COMMND(5),=CL5'TEST '     IF COMMAND = TEST
         BE    NGCMD                       THEN REJECT
         CLC   D0COMMND(6),=CL6'LOGON '    IF COMMAND = LOGON
         BE    NGCMD                       THEN REJECT
         CLC   D0COMMND(7),=CL7'LOGOFF '   IF COMMAND = LOGOFF
         BE    NGCMD                       THEN REJECT
         MVC   D0MODULE,D0COMMND   ELSE SET COMMAND NAME = SAME NAME
         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED
         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME
         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS
         MVC   ECTSCMD+1(7),ECTSCMD
         CLC   =C'TIME ',D0MODULE  IF COMMAND = TIME
         BNE   NOTTIME             THEN
         MVC   D0MODULE,=CL8'IKJEFT25' SET MODULE NAME = IKJEFT25
         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING
NOTTIME  CLC   =C'CALL ',D0MODULE  IF COMMAND = CALL
         BNE   NOTCALL             THEN
         MVC   D0MODULE,=CL8'ISPCALL ' SET MODULE NAME = ISPCALL
         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING
NOTCALL  DS    0H                  ELSE SEARCH FOR COMMAND NAME
         SPACE
***********************************************************************
* NOTE: AT THIS POINT IT IS POSSIBLE TO INSERT SOME ALTERNATE COMMAND *
* VALIDATION CODE SUCH AS AN ACF2 COMMAND VALIDATION SVC.  HOWEVER,   *
* WE WILL EMULATE THE TMP AND SPF COMMAND SEARCH CODE INSTEAD.        *
***********************************************************************
         SPACE
         STM   R3,R9,32(R13)       SAVE REGISTERS USED BY LPA SEARCH
         LM    R0,R1,D0MODULE      LOAD COMMAND NAME INTO PARM REGS
         L     R3,16               R3 = CVT ADDRESS
         L     R15,X'160'(,R3)     R15 -> LPA DIRECTORY SEARCH ROUTINE
         BALR  R14,R15             CALL LPA DIRECTORY SEARCH
***********************************************************************
* IF THE COMMAND NAME IS FOUND IN THE LPA DIRECTORY, CONTROL RETURNS  *
* TO THE NEXT SEQUENTIAL INSTRUCTION AND R14 IS SET TO ZERO.  IF THE  *
* COMMAND NAME HAS NOT BEEN FOUND, CONTROL RETURNS TO THE INSTRUCTION *
* AT +4 PAST HERE AND R14 IS NONZERO.                                 *
***********************************************************************
         LA    R14,0               IF SUCCESSFUL, SET R14 = 0
         LM    R3,R9,32(R13)       RESTORE REGISTERS USED BY LPA SEARCH
         LTR   R14,R14             IF COMMAND NAME WAS FOUND,
         BZ    TSEVENT             THEN GO AHEAD AND USE IT. ELSE...
         LA    R0,D0MODULE         SET EPLOC PARAMETER FOR IDENTIFY
         XR    R1,R1               SET ENTRY ADDRESS PARM FOR IDENTIFY
         IDENTIFY ENTRY=(1),EPLOC=(0) SEE IF ENTRY NAME IS AROUND
         CH    R15,=H'8'           IF RC=8, COMMAND IS IN JPA
         BE    TSEVENT             SO GO USE IT
         CH    R15,=H'20'          IF RC=20, COMMAND IS IN JPA
         BE    TSEVENT             SO GO USE IT
         BLDL  0,D0BLDL            IF NONE OF THE ABOVE, TRY BLDL
         LTR   R15,R15             SEE IF BLDL SUCCESSFUL
         BZ    TSEVENT             IF BLDL SUCCESSFUL, IT IS A COMMAND
******** BNZ   IMPLICIT            IF BLDL FAILED, IT MUST BE A CLIST
         SPACE
IMPLICIT DS    0H                  LOAD MODULE NOT FOUND, MUST BE CLIST
         MVC   D0MODULE,=CL8'EXEC' SET COMMAND NAME = "EXEC"
         LH    R15,D0OFFSET        PICK UP OFFSET OF CLIST NAME
         LTR   R15,R15             IF ZERO OFFSET, THEN IGNORE
         BNP   AFTBLNKX
         BCTR  R15,0               REDUCE FOR EXECUTE
         BCTR  R15,0               AND FOR MOVE CHARACTERS
         MVI   4(R5),C' '          SET BUFFER PRECEDING CLIST NAME
         EX    R15,MVCBLANK         TO BLANKS
AFTBLNKX XC    2(2,R5),2(R5)       SET COMMAND BUFFER OFFSET = ZERO
         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED
         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME
         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS
         MVC   ECTSCMD+1(7),ECTSCMD
         SPACE
TSEVENT  DS    0H                  NOW WE ARE READY TO ISSUE COMMAND
         SPACE
***********************************************************************
* ISSUE TSVENT (SYSEVENT 0) TO TELL SYSTEM ABOUT COMMAND.             *
* NOTE: SVC 109 INTERFACE IS A POSSIBILITY HERE. HOWEVER, EXISTING    *
* TSO MONITORING PRODUCTS USE THE SVC 95 INTERFACE ONLY, EVEN THOUGH  *
* THE SVC 109 INTERFACE IS PARTICULARLY SUITED FOR APPLICATIONS SUCH  *
* AS THIS UTILITY WHICH CREATE STACKS OF NESTED COMMAND INVOCATIONS.  *
***********************************************************************
         SPACE
         L     R1,ECTPCMD
         L     R15,ECTPCMD+4
         TSEVENT PPMODE            TELL SRM ABOUT THE COMMAND
         XR    R15,R15             INDICATE COMMAND IS OK
         B     CKCMDRET            AND RETURN
         SPACE
NGCMD    DS    0H                  COMMAND NOT VALID (TEST, ETC.)
         MVC   D0MSG(L'TESTMSG1),TESTMSG1  MOVE BEGINNING OF MESSAGE
         MVC   D0MSG+L'TESTMSG1(8),D0COMMND  MOVE IN COMMAND NAME
         LA    R1,D0MSG+L'TESTMSG1 POINT TO BEGINNING OF NAME
         LA    R14,8               MAX COUNT FOR NAME LENGTH
NGLOOP   CLI   0(R1),C' '          SCAN FOR FIRST BLANK
         BE    NGBLANK              FOLLOWING COMMAND NAME
         LA    R1,1(,R1)             UNTIL
         BCT   R14,NGLOOP             LENGTH OF NAME EXHAUSTED
NGBLANK  DS    0H
         MVC   0(L'TESTMSG2,R1),TESTMSG2  MOVE END OF MESSAGE
         LA    R0,L'TESTMSG2(,R1)  END OF MESSAGE
         LA    R14,D0MSG           MINUS BEGINNING OF MESSAGE
         SLR   R0,R14              GIVES LENGTH OF MESSAGE
         XR    R1,R1               INDICATE MESSAGE ALREADY BUILT
         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK
         LA    R15,8               INDICATE COMMAND INVALID
CKCMDRET L     R14,D0CKCM14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
MVCBLANK MVC   5(0,R5),4(R5)       FINISH MOVING BLANKS INTO CMD BUFFER
         SPACE
TESTMSG1 DC    C'XHX004I COMMAND INTERFACE DOES NOT SUPPORT THE '
TESTMSG2 DC    C' COMMAND'
         SPACE
         LTORG
         TITLE 'HELPEXIT - ATTACH SUBROUTINE'
ATTACH   DS    0H
         SPACE
         ST    R14,D0ATT14         SAVE RETURN REGISTER
         LR    R1,R3               POINT TO CPPL
         XC    D0CMDECB,D0CMDECB   CLEAR ATTACH ECB
         XC    D0ATNECB,D0ATNECB   CLEAR ATTENTION ECB
         NI    D0FLAGS,255-D0SUBER CLEAR ERROR FLAG
         MVI   D0STATUS,D0NORMAL   CLEAR COMMAND STATUS FLAG
         ATTACH EPLOC=D0MODULE,SF=(E,D0ATTACH),ECB=D0CMDECB,           X
               STAI=(STAIEXIT,DATD0)     ATTACH THE COMMAND
         LTR   R15,R15             IF ATTACH FAILED,
         BZ    ATTACHOK            THEN
         LA    R1,=C'ATTACH'        BLOW UP
         LA    R0,6
         OI    D0FLAGS,D0SUBER
         B     ATTRET
ATTACHOK DS    0H
         ST    R1,DA2CTCB          SAVE TCB ADDRESS
         WAIT  1,ECBLIST=D0ECBLST  WAIT FOR COMPLETION OR ATTENTION
         L     R1,DA2CTCB          GET TCB ADDRESS
         MVC   ECTRTCD,17(R1)      MOVE TCB COMPLETION CODE TO ECT
         MVI   ECTRCDF,0           INIT ECT CP = NOT ABENDED
         XC    D0ECB,D0ECB         CLEAR ECB
         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)  MARK DATA SETS NOT IN USE
         ST    R15,D0DAIRRC        SAVE DAIR RETURN CODE
         LA    R1,DA2CTCB
         DETACH (1),STAE=YES       DETACH THE COMMAND
         CH    R15,=H'4'           IF DETACH FAILED,
         BNH   DETACHOK
         LA    R1,=C'DETACH'        BLOW UP
         LA    R0,6
         OI    D0FLAGS,D0SUBER
         B     ATTRET
DETACHOK DS    0H                  NOW, CHECK DAIRRC AFTER DETACH
         ICM   R15,15,D0DAIRRC     IF DAIR RETURN CODE NOT ZERO,
         BZ    DAIROK              THEN...
         LA    R1,=C'DAIR'          BLOW UP
         LA    R0,4
         OI    D0FLAGS,D0SUBER
         B     ATTRET
DAIROK   DS    0H
         SPACE
         CLI   D0STATUS,D0ATTN     IF COMMAND TERMINATED BY ATTENTION,
         BE    ATTFLUSH            THEN FLUSH THE INPUT STACK
         CLI   D0STATUS,D0ABEND    ELSE IF THE COMMAND ABENDED,
         BNE   ATTRET              THEN
         OI    ECTRCDF,X'80'        INDICATE CP ABENDED IN ECT
         LA    R1,FLUSHALL          FOR ABEND, DO NORMAL STACK FLUSH
         B     FLUSHCMD             AND FLUSH THE INPUT STACK.
ATTFLUSH LA    R1,FLUSHTOP         FOR ATTN, DO EVEN IF CONTROL=NOFLUSH
FLUSHCMD BAL   R14,FLUSH           FLUSH THE INPUT STACK
ATTRET   L     R14,D0ATT14         RESTORE RETURN REGISTER
         BR    R14                 RETURN
         TITLE 'HELPEXIT - PUTGET SUBROUTINE'
***********************************************************************
* THIS SUBROUTINE ISSUES A PUTGET MACRO INSTRUCTION TO DISPLAY A MODE *
* MESSAGE (WHERE APPROPRIATE) AND RETRIEVE A COMMAND LINE FROM THE    *
* CURRENT SOURCE OF INPUT.  IF THE PUTGET RETURNS WITH A CODE OF 12   *
* (MEANING THAT A SECOND-LEVEL MESSAGE CHAIN IS AVAILABLE BUT THE     *
* USER IS IN A CLIST AND THE "NOPAUSE" PROFILE OPTION IS ACTIVE), IT  *
* IS RETRIED AFTER SETTING THE BIT IN THE ECT WHICH PURGES            *
* SECOND-LEVEL MESSAGES.  IF IT RETURNS WITH A CODE OF 24 (INVALID    *
* PARAMETERS), CONTROL IS RETURNED WITHOUT AN ERROR INDICATION - THIS *
* IS USED TO DETERMINE IF A CLIST HAS TERMINATED.  THIS "TRICK" WAS   *
* USED IN SPF MODULE ISPCAT TO DETERMINE THE END OF A CLIST.          *
***********************************************************************
         SPACE
PUTGET   DS    0H
         ST    R14,D0PG14          SAVE RETURN REGISTER
PGRETRY  DS    0H
         XC    D0ECB,D0ECB         CLEAR ECB
         PUTGET PARM=PGPB,MF=(E,IOPL)  ISSUE PUTGET
         CH    R15,=H'24'          IF RETURN CODE GREATER THAN 24,
         BH    PGERROR              THEN BLOW UP
         B     PGGO(R15)           ELSE PROCESS EACH POSSIBLE R.C.
PGGO     B     PGGOTLN         0 = LINE CAME FROM TERMINAL
         B     PGGOTLN         4 = LINE CAME FROM IN-STORAGE LIST
         B     PUTGET8         8 = ATTENTION INTERRUPTION
         B     PUTGET12       12 = NO LINE DUE TO SECOND-LEVEL MESSAGE
         B     PGERROR        16 = ERROR
         B     PGERROR        20 = ERROR
         B     PGRETURN       24 = BAD MODE MESSAGE - TERMINAL INPUT
         SPACE
PUTGET8  MVI   D0STATUS,D0ATTN     RC=8: INDICATE ATTENTION INTERRUPT
         B     PGRETURN              AND RETURN
PUTGET12 TM    ECTMSGF,X'80'       RC=12: IF 2ND-LVL MSGS ALRDY PURGED,
         BO    PGERROR                    THEN UNRECOVERABLE ERROR
         OI    ECTMSGF,X'80'         ELSE PURGE 2ND-LEVEL MESSAGE CHAIN
         B     PGRETRY                AND REISSUE PUTGET
PGERROR  OI    D0FLAGS,D0SUBER     BAD RETURN CODE, UNRECOVERABLE ERROR
         B     PGRETURN            SO JUST RETURN.
PGGOTLN  OI    D0FLAGS,D0GOTLN     INDICATE A PUTGET BUFFER OBTAINED
PGRETURN L     R14,D0PG14          RESTORE RETURN REGISTER
         BR    R14                 RETURN
         TITLE 'HELPEXIT - PUTLINE SUBROUTINE'
***********************************************************************
* THIS ROUTINE DISPLAYS MESSAGES TO THE TSO USER USING THE TSO        *
* PUTLINE SERVICE ROUTINE.  AT ENTRY R1 CONTAINS THE ADDRESS OF THE   *
* MESSAGE TO BE DISPLAYED, AND R0 CONTAINS THE LENGTH OF THE MESSAGE. *
* IF R1 IS ZERO, THE MESSAGE HAS ALREADY BEEN BUILT IN THE WORKAREA   *
* D0MSG.  THE MESSAGE IS ASSUMED TO BEGIN WITH A MESSAGE ID UNLESS    *
* THE FIRST CHARACTER IS BLANK, IN WHICH CASE THE INITIAL BLANK IS    *
* STRIPPED OFF BY PUTLINE ANYHOW.                                     *
* NOTE THAT THIS SUBROUTINE ESTABLISHES ITS OWN BASE REGISTER.  THIS  *
* IS BECAUSE THIS SUBROUTINE IS REFERENCED BY INTERCEPT ROUTINES      *
* WHERE THE NORMAL BASE REGISTER IS UNAVAILABLE.                      *
***********************************************************************
         SPACE
PUTLINE  DS    0H
         ST    R14,D0PUTL14        SAVE RETURN REGISTER
         BALR  R8,0                SET UP LOCAL ADDRESSABILITY
         USING *,R8
         DROP  R12
         LTR   R15,R0              LOAD LENGTH VALUE
         BNP   PUTLRET             IF ZERO, DON'T DO ANYTHING
         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTE
         LTR   R1,R1               IF R1 IS ZERO,
         BZ    PUTIT               THEN MESSAGE ALREADY SET UP. ELSE...
         EX    R15,MOVEPUT         MOVE MESSAGE TO WORK AREA
PUTIT    DS    0H
         LA    R15,5(,R15)         RESTORE LENGTH + 4 FOR HEADER
         SLL   R15,16              SHIFT LENGTH INTO LEFT HALF OF HDR
         STCM  R15,15,D0MSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR
         XC    D0ECB,D0ECB         CLEAR ECB
         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE
         LTR   R15,R15             IF PUTLINE OK
         BZ    PUTLRET             THEN RETURN
         CH    R15,=H'8'           ELSE IF ATTENTION INTERRUPT
         BNE   PUTERROR            THEN
         MVI   D0STATUS,D0ATTN      INDICATE SO
         B     PUTLRET             ELSE PUTLINE ERROR
PUTERROR LA    R1,BADPUT
         LA    R0,L'BADPUT
         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT
PUTLRET  L     R14,D0PUTL14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
MOVEPUT  MVC   D0MSG(0),0(R1)      MOVE MESSAGE TO WORK AREA
BADPUT   DC    C'*** COMMAND INTERFACE PUTLINE FAILURE ***'
         SPACE
         LTORG
         SPACE
         USING HELPEXIT,R12
         DROP  R8
         TITLE 'HELPEXIT - FLUSH SUBROUTINE'
***********************************************************************
* THIS ROUTINE DELETES ELEMENTS FROM THE INPUT STACK.  IT IS USED     *
* WHEN AN ERROR OCCURS THAT WOULD REQUIRE THAT NO MORE COMMANDS IN A  *
* CLIST BE EXECUTED.  IT ALSO CLEARS THE TERMINAL INPUT QUEUE SO THAT *
* ADDITIONAL SUBCOMMANDS "STACKED" WITH FIELD MARKS ARE NOT EXECUTED. *
* ON ENTRY TO THIS SUBROUTINE R1 POINTS TO THE LIST FORM OF THE STACK *
* MACRO INSTRUCTION TO BE EXECUTED.  NORMALLY STACK DELETE=ALL WILL   *
* BE USED; THIS FLUSHES ALL ELEMENTS FROM THE STACK EXCEPT (1) THE    *
* BOTTOM ELEMENT, (2) ANY CLISTS WHICH HAVE CONTROL NOFLUSH OR        *
* CONTROL MAIN ACTIVE.  FOR ATTENTION-PROVOKED FLUSHES, WE USE STACK  *
* DELETE=TOP.  THIS DELETES THE TOP ELEMENT FROM THE STACK UNLESS IT  *
* IS A CLIST WITH CONTROL MAIN ACTIVE.                                *
***********************************************************************
         SPACE
FLUSH    DS    0H
         ST    R14,D0FLSH14        SAVE RETURN REGISTER
         MVC   D0STACK(LSTACKL),0(R1)  SET UP STACK LIST FORM
         TCLEARQ INPUT             CLEAR TERMINAL INPUT QUEUE
         XC    D0ECB,D0ECB         CLEAR ECB
         STACK PARM=D0STACK,MF=(E,IOPL)  FLUSH THE STACK
         LTR   R15,R15             IF STACK FAILED
         BZ    FLUSHRET            THEN SAY SO
         LA    R1,BADSTACK
         LA    R0,L'BADSTACK
         BAL   R14,PUTLINE
FLUSHRET MVC   D0RETCD,=F'12'      SET RETURN CODE TO 12 WHEN FLUSHING
         L     R14,D0FLSH14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
BADSTACK DC    C'XHX007I COMMAND INTERFACE STACK ERROR'
         SPACE
         LTORG
         SPACE
         DROP  R11,R12
         TITLE 'HELPEXIT - STAI EXIT FOR ABENDING COMMANDS'
STAIEXIT DS    0H
         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER
         USING STAIEXIT,R12
         LA    R3,12               CHECK IF REGISTER 0 = "12"
         CR    R0,R3               IF AN SDWA IS AVAILABLE,
         BE    NOSDWA              THEN...
         LM    R10,R11,0(R1)        R10 -> WORKAREA, R11 = ABEND CODE
         B     AFTSDWA             ELSE...
NOSDWA   LR    R10,R2               R10 -> WORKAREA
         LR    R11,R1               R11 = ABEND COMPLETION CODE
AFTSDWA  DS    0H
         ST    R14,D0STAI14        SAVE RETURN REGISTER
         L     R4,IOPLECT          ESTABLISH ADDRESSABILITY TO ECT
         MVI   D0STATUS,D0ABEND    INDICATE COMMAND ABENDED
         STCM  R11,7,D0ABCODE      STORE ABEND CODE
         SPACE
***********************************************************************
* DISPLAY "ENDED DUE TO ERROR" MESSAGE                                *
***********************************************************************
         SPACE
         MVC   D0MSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE
         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   D0MSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE
         CLC   D0ABCODE,=X'000FFF'          IF CODE GREATER THAN 4095
         BNH   USRABEND                     THEN MUST BE A SYSTEM ABEND
         MVC   D0MSG2(6),=C'SYSTEM'         SO SAY SO
         MVC   D0MSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         UNPK  D0SYSTEM(3),D0ABCODE(2)      PUT ABEND CODE IN HEX IN
         MVZ   D0SYSTEM(3),=X'000000'
         TR    D0SYSTEM(3),=C'0123456789ABCDEF'
         LA    R0,D0SYSL                    GET LENGTH OF MESSAGE
         B     ANYABEND                     GO TO DISPLAY IT
USRABEND MVC   D0MSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND
         MVC   D0MSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         XR    R0,R0
         ICM   R0,7,D0ABCODE                GET NUMERIC USER ABEND CODE
         CVD   R0,D0DOUBLE                  CONVERT TO DISPLAY
         UNPK  D0USER(4),D0DOUBLE
         OI    D0USER+3,X'F0'
         LA    R0,D0USERL                   GET LENGTH OF MESSAGE
ANYABEND DS    0H
         XR    R1,R1               INDICATE MESSAGE SET UP
         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE
         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE
         LA    R15,16              LET ABEND CONTINUE WITHOUT ESTAI
         L     R14,D0STAI14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
ABEMSGID DC    C'XHX003I '
ABEMSG1  DC    C' ENDED DUE TO ERROR, '
ABEMSG2  DC    C' ABEND CODE '
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'HELPEXIT - STAE EXIT FOR INTERNAL ABEND'
STAEEXIT DS    0H
         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER
         USING STAEEXIT,R12
         LA    R3,12               CHECK IF REGISTER 0 = "12"
         CR    R0,R3               IF AN SDWA IS AVAILABLE,
         BE    NOSDWAE             THEN...
         L     R10,0(,R1)           R10 -> WORKAREA
         B     AFTSDWAE            ELSE...
NOSDWAE  LR    R10,R2               R10 -> WORKAREA
AFTSDWAE DS    0H
         L     R15,IOPLECT         ESTABLISH ADDRESSABILITY TO ECT
         USING ECT,R15
         MVC   ECTPCMD(16),D0CMDS  RESTORE ECT COMMAND/SUBCOMMAND NAMES
         XR    R15,R15             CONTINUE WITH ABNORMAL TERMINATION
         BR    R14                 AND RETURN
         SPACE
         LTORG
         SPACE
         DROP  R12,R15
         TITLE 'HELPEXIT - STAX EXIT FOR ATTENTION INTERRUPT'
STAXEXIT DS    0H
         SPACE
         LR    R12,R15             SAVE ENTRY ADDRESS
         USING STAXEXIT,R12
         L     R10,8(,R1)          GET ADDRESS OF USER PARAMETER LIST
         LR    R7,R14              SAVE RETURN ADDRESS
         STATUS STOP               MAKE SUBTASK NONDISPATCHABLE
         MVI   D0STATUS,D0ATTN     INDICATE ATTENTION OCCURRED
         POST  D0ECB,0             POST SERVICE ROUTINES ECB
         POST  D0ATNECB,0          POST ECB FOR COMMAND ATTACH
         BR    R7                  RETURN TO SYSTEM
         SPACE
         LTORG
         SPACE
         DROP  R12
         USING HELPEXIT,R12
         USING DATD1,R11
         TITLE 'HELPEXIT - DATA AREAS'
DATD0    DSECT
         SPACE
D0SAVE   DS    9D                  OS SAVE AREA
D0DOUBLE DS    D                   FOR NUMERIC CONVERSIONS
D0SCAN14 DS    A                   SAVE AREA FOR SCAN SUBROUTINE
D0CKCM14 DS    A                   SAVE AREA FOR CKCMD SUBROUTINE
D0ATT14  DS    A                   SAVE AREA FOR ATTACH SUBROUTINE
D0PUTL14 DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE
D0PG14   DS    A                   SAVE AREA FOR PUTGET SUBROUTINE
D0FLSH14 DS    A                   SAVE AREA FOR FLUSH SUBROUTINE
D0STAI14 DS    A                   SAVE AREA FOR STAI EXIT ROUTINE
D0ECB    DS    F                   ECB FOR TSO SERVICE ROUTINES
D0CMDECB DS    F                   ECB FOR ATTACHED COMMANDS
D0ATNECB DS    F                   ECB FOR ATTENTION INTERRUPTIONS
D0ECBLST DS    2A                  ECB LIST
D0PLADDR DS    A                   ADDRESS OF PUTLINE SUBROUTINE
         SPACE
D0CPPL   DS    4A                  CPPL FOR ADDITIONAL COMMANDS
         ORG   D0CPPL
D0CBUF   DS    A                   ADDRESS OF COMMAND BUFFER
         DS    3A                  REST OF CPPL
         SPACE
IOPL     DS    0F
         SPACE
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE
         SPACE
PTPB     DS    0F
         SPACE
***********************************************************************
*    THE PUTLINE PARAMETER BLOCK (PTPB) IS POINTED TO BY THE PARAM.   *
*    LIST PASSED TO PUTLINE.  IT IS USED TO RETURN PERTINENT INFO.    *
*    AS WELL AS CONTROL PUTLINE FUNCTIONS                             *
***********************************************************************
         SPACE
         DS    0F
         DS    CL4      INTERNAL PUTLINE USAGE
PTPBOPUT DS    A        ADDRESS OF OUTPUT LINE DESCRIPTOR OR DATA LINE
PTPBFLN  DS    A        PTR TO FORMATTED LINE RETURNED WHEN OUTPUT=
*                       ADDR,FORMAT) IS SPECIFIED
         SPACE
PGPB     DS    0H
         SPACE
***********************************************************************
*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *
*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *
*    RETURNING INFORMATION.                                           *
***********************************************************************
         SPACE
         DS    0F
         DS    CL12     INTERNAL TO GETLINE/PUTLINE
PGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE
         SPACE
STPB     DS    0F
         SPACE
***********************************************************************
*    THE STACK PARAMETER BLOCK (STPB) IS A BLOCK POINTED TO BY THE    *
*    STPL.  STACK USES IT TO STORE THE ADDRESS OF THE (STORAGE) LIST  *
*    THE STACK PARAMETER BLOCK (STPB) IS A BLOCK POINTED TO BY THE    *
*    STPL.  STACK USES IT TO STORE THE ADDRESS OF THE (STORAGE) LIST  *
*    SOURCE DESCRIPTOR (LSD), INPUT AND OUTPUT DDNAMES, AS WELL AS    *
*    FOR CONTROL.                                                     *
***********************************************************************
         SPACE
         DS    CL4      INTERNAL TO STACK
STPBALSD DS    A        ADDR OF (STORAGE) LIST SOURCE DESCRIPTOR
STPBINDD DS    A        ADDR OF INPUT DDNAME
STPBOTDD DS    A        ADDR OF OUTPUT DDNAME
STPBMBRN DS    A        ADDR OF MEMBER NAME
         SPACE
DAPL     DS    0F
         SPACE
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
         SPACE
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
         SPACE
DAPB2C   DS    0F
         SPACE
***********************************************************************
* THIS OPERATION CODE ALLOWS FOR RE-USE  OF TIOT ENTRIES              *
* IT IS USED BY THE TMP BEFORE DETACHING A TASK, AND BY ANY  TASK     *
* WHICH ATTACHES SUB-TASKS                                            *
***********************************************************************
         SPACE
DA2CCD   DS    CL2      DAIR ENTRY CODE
DA2CFLG  DS    H        FLAG FIELD
DA2CTCB  DS    A        TCB ADDR OF DSE ENTRIES MARKED NOT IN USE
DA2CDDN  DS    CL8        DDNAME
         SPACE
D0STACK  STACK MF=L,DELETE=ALL
         SPACE
D0ATTACH ATTACH SF=L
         SPACE
D0ESTAE  ESTAE MF=L
         SPACE
D0STAX   STAX  MF=L
         SPACE
D0PREFIX DS    F                   SAVED COMMAND BUFFER PREFIX
D0ORGBUF DS    F                   ADDRESS OF "HELP X" COMMAND BUFFER
D0RETCD  DS    F                   RETURN CODE FROM COMMAND
D0DAIRRC DS    F                   RETURN CODE FROM IKJDAIR
D0SCANRC DS    H                   RETURN CODE FROM IKJSCAN
D0STKLVL DS    H                   ORIGINAL STACK LEVEL (* 4)
D0OFFSET DS    H                   SAVED OFFSET OF POSSIBLE CLIST NAME
D0CMDS   DS    CL16                SAVED ECT COMMAND AND SUBCOMMAND
D0COMMND DS    CL8                 COMMAND NAME FROM SCAN
         CNOP  4,8                 FORCE D0MODULE ALIGNMENT
D0BLDL   DS    Y(1,12)             BLDL LIST FOR COMMAND CHECK
D0MODULE DS    CL8                 MODULE NAME FOR COMMAND
         DS    XL4                 FILLER FOR BLDL
D0ABCODE DS    XL3                 ABEND CODE STORED BY STAI EXIT
D0FLAGS  DS    X                   FLAGS
D0X1     EQU   B'10000000'          1 = HELP X (NOT XX) WAS ENTERED
D0EXEC   EQU   B'01000000'          1 = IMPLICIT EXEC COMMAND (%)
D0BUFMOD EQU   B'00100000'          1 = COMMAND BUFFER WAS ALTERED
D0ECTMOD EQU   B'00010000'          1 = ECT PCMD/SCMD WAS ALTERED
D0ESTON  EQU   B'00001000'          1 = ESTAE SUCCESSFUL
D0STXON  EQU   B'00000100'          1 = STAX SUCCESSFUL
D0SUBER  EQU   B'00000010'          1 = SEVERE ERROR IN SUBROUTINE
D0GOTLN  EQU   B'00000001'          1 = PUTGET BUFFER TO BE FREED
D0STATUS DS    X                   COMMAND STATUS FLAG
D0NORMAL EQU   0                    COMMAND COMPLETED NORMALLY
D0ATTN   EQU   1                    ATTENTION INTERRUPT OCCURRED
D0ABEND  EQU   2                    ABNORMAL TERMINATION OCCURRED
         SPACE
***********************************************************************
* PUTGET MODE MESSAGE AREA                                            *
***********************************************************************
         SPACE
D0PGOLD  DS    A(1)                NUMBER OF MESSAGE SEGMENTS
D0PGPTR  DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT
D0PGHDR  DS    2Y                  MESSAGE HEADER
D0PGMODE DS    CL(L'MODEMSG)       MESSAGE TEXT
         SPACE
***********************************************************************
* WORKAREA FOR CONSTRUCTING PUTLINE MESSAGES                          *
* NOTE: THIS IS SET UP FOR SINGLE-LEVEL INFORMATIONAL MESSAGES ONLY.  *
***********************************************************************
         SPACE
D0MSGOLD DS    A(1)                NUMBER OF MESSAGE SEGMENTS
D0MSGPTR DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT
D0MSGHDR DS    2Y                  MESSAGE HEADER
D0MSG    DS    CL128               MESSAGE TEXT
D0MSG1   EQU   D0MSG+L'ABEMSGID    OFFSET OF "ENDED DUE TO ERROR"
D0MSG2   EQU   D0MSG1+8+L'ABEMSG1  OFFSET OF "SYSTEM" OR "USER"
D0SYSTEM EQU   D0MSG2+6+L'ABEMSG2  OFFSET OF SYSTEM ABEND CODE
D0USER   EQU   D0MSG2+4+L'ABEMSG2  OFFSET OF USER ABEND CODE
D0SYSL   EQU   D0SYSTEM+3-D0MSG    LENGTH OF SYSTEM ABEND MESSAGE
D0USERL  EQU   D0USER+4-D0MSG      LENGTH OF USER ABEND MESSAGE
         SPACE 2
SIZDATD0 EQU   *-DATD0
         EJECT
DATD1    DSECT
         SPACE
***********************************************************************
* ALL STORAGE USED BY IKJSCAN IS ALLOCATED IN SUBPOOL 1 BECAUSE       *
* THAT'S WHAT WE WERE TOLD TO DO BY THE GUIDE TO WRITING A TMP OR A   *
* COMMAND PROCESSOR.                                                  *
***********************************************************************
         SPACE
CSPL     DS    0D
         SPACE
***********************************************************************
*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *
*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *
***********************************************************************
         SPACE
CSPLUPT  DS    A        PTR TO  UPT
CSPLECT  DS    A        PTR TO  ECT
CSPLECB  DS    A        PTR TO  CP'S ECB
CSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED
*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF
*                       COMMAND NAME.
CSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)
CSPLCBUF DS    A        PTR TO COMMAND BUFFER
         SPACE
CSOA     DS    0H
         SPACE
***********************************************************************
*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *
*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *
*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *
***********************************************************************
         SPACE
CSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME
CSOALNM  DS    H        LENGTH OF CMD NAME
CSOAFLG  DS    X        FLAGS
CSOAVWP  EQU   X'80'    VALID WITH PARAMETERS
CSOAVNP  EQU   X'40'    VALID NO   PARAMS
CSOAQM   EQU   X'20'    QUESTION MARK
CSOANOC  EQU   X'10'    NO COMMAND
CSOABAD  EQU   X'08'    BAD CMD NAME
CSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME              Y30PQJN
         DS    CL1      RESERVED
         SPACE
D1CSFLG  DS    F                   COMMAND SCAN FLAG WORD
         SPACE 2
SIZDATD1 EQU   *-DATD1
         EJECT
HELPEXIT CSECT
         IKJCPPL
HELPEXIT CSECT
         IKJECT
HELPEXIT CSECT
         CVT   DSECT=YES
         END
./ ADD NAME=IKJEFF10 0100-07332-07332-0900-02393-02393-00000-SEB
         TITLE 'IKJEFF10 - TSO SUBMIT INSTALLATION EXIT ROUTINE'
         MACRO
&SYM     EMIT  ,
         LCLC  &LABEL
&LABEL   SETC  'EMIT&SYSNDX'
&SYM     ST    R6,JWASAVE6
         LA    R14,&LABEL
         ST    R14,JWARET            Save continuation address
         BAL   R14,INSERTOP          Try to insert the operand
         ICM   R0,15,JWAUPTR         If it wasn't all moved
         BNZ   CRETURN               then return to try it on next card
&LABEL   DS    0H                    Resume processing here once OK
         MEND
         EJECT
         MACRO
&SYM     NEXT  ,
&SYM     L     R6,JWAONEXT           Get address of end of prev operand
         LA    R6,1(,R6)             Bump to next operand
         BAL   R14,SCANCOMA          Get a JCL operand
         ST    R15,JWAONEXT          Save address of following operand
         MEND
         EJECT
         MACRO
&SYM     TELL  &MSG
&SYM     L     R1,=A(&MSG)
         LA    R0,L'&MSG
         TPUT  (1),(0),R
         MEND
         TITLE 'IKJEFF10 - TSO SUBMIT INSTALLATION EXIT ROUTINE'
***********************************************************************
*                                                                     *
* IKJEFF10 - TSO SUBMIT INSTALLATION EXIT ROUTINE                     *
*                                                                     *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
*  Module:  IKJEFF10                                                  *
*                                                                     *
*  Version:  5                                                        *
*  Mod:      0                                                        *
*                                                                     *
*  This is a TOTAL REWRITE of the Draper SUBMIT exit.                 *
*                                                                     *
*  Previous Status:                                                   *
*                                                                     *
*    VERSION 1 MOD 0     21 MARCH 1977     OS/VS2 RELEASE 1           *
*    VERSION 2 MOD 0        MAY   1979     OS/VS2 RELEASE 1           *
*     (A MAJOR REWRITE TO SUPPORT ACCT * AND USERIDS OF LESS          *
*     THAN 7 CHARACTERS.  ORIGINAL ROUTINE WAS HACKED TO              *
*     PIECES BY THIS REWRITE.)                                        *
*    VERSION 3 MOD 0        JULY  1980     HSM/EASY READER SUPPORT    *
*    VERSION 3 MOD 0        JAN 5,1982 INSTALLED INTO SP1.1. IPO      *
*                           WITHOUT MODIFICATION                      *
*    VERSION 3 MOD 1        OCTOBER 1982   FIXED THE FOLLOWING BUGS:  *
*                        GENERATED JOB STATEMENT CHECK CORRECTED TO   *
*                        LOOK FOR THE CORRECT LITERAL IN COLUMN 31    *
*    VERSION 4 MOD 0        JULY 1983      ADDED NEW FUNCTION TO      *
*                        PROMPT FOR PASSWORD AND INSERT IT WHEN A     *
*                        /*PASSWORD CARD WITH NO PASSWORD IS FOUND    *
*    VERSION 4 MOD 0        AUG 16,1984 INSTALLED INTO SP2.1.2 (XA)   *
*                           WITHOUT MODIFICATION                      *
*                                                                     *
*    Version 5 Mod 0     January 1987                                 *
*                                                                     *
*                        Rewritten to handle any number of            *
*                        transformations of the operands on the       *
*                        JOB statement, including but not limited to: *
*                                                                     *
*                        Replacing "*" with full account information  *
*                        in the accounting field                      *
*                                                                     *
*                        Replacing "*" with full programmer name in   *
*                        the programmer name field                    *
*                                                                     *
*                        Replacing "*" with the userid in the         *
*                        NOTIFY field                                 *
*                                                                     *
*                        Inserting default TIME and REGION values     *
*                        if not present on the JOB card               *
*                                                                     *
*  Note that the above items contain the feature of being able to     *
*  generate a valid JOB card when none is provided by the user.       *
*                                                                     *
* Authors:                                                            *
*                                                                     *
*    DAVID A. LYNDE     C. S. DRAPER LABORATORY     CAMBRIDGE, MASS.  *
*    GARY VINING (VERSION 2)                                          *
*    STEVE PATTON (VERSION 3)                                         *
*    STEVE BACHER (VERSION 3 MOD 1)                                   *
*    STEVE BACHER (VERSION 4)                                         *
*    Steve Bacher (Version 5)                                         *
*                                                                     *
*  Function:                                                          *
*                                                                     *
*  (1) To insure that the jobname conforms to installation convention *
*      and to fill in defaulted information for programmer ease.      *
*                                                                     *
*  (2) To insure the availability of datasets referenced via          *
*      //PROCLIB DD statements for EasyReader.                        *
*                                                                     *
*  (3) To prompt for ACF2 passwords in print-inhibit mode when a      *
*      /*PASSWORD card is found, insuring integrity of the JCL.       *
*                                                                     *
*  Installation Jobname Conventions:                                  *
*                                                                     *
*      The first n-1 characters of the jobname must be comprised of   *
*      the characters of the submitter's userid.                      *
*                                                                     *
*      If the accounting information is set to "*" or omitted, the    *
*      logon account number and room ID are inserted in its place.    *
*                                                                     *
*      If the programmer name field is set to "*" or omitted, the     *
*      TSO userid is inserted in its place.                           *
*                                                                     *
*      If the value in the NOTIFY field is "*", the TSO userid is     *
*      inserted in its place.                                         *
*                                                                     *
*      If the TIME operand is missing, a default value is provided.   *
*                                                                     *
*      If the REGION operand is missing, a default value is provided. *
*                                                                     *
*  EasyReader Support:                                                *
*                                                                     *
*      If an EasyReader //PROCLIB DD statement is used in the         *
*      submitted JCL, the proclib(s) is/are recalled if it is         *
*      HSM migrated.  The proclib is allocated and opened to          *
*      set the reference date to today's date.                        *
*                                                                     *
*  /*PASSWORD Processing:                                             *
*                                                                     *
*      If a /*PASSWORD card is found and it contains no password,     *
*      and the foreground terminal is available, the user is prompted *
*      (in print-inhibit mode, naturally) to enter the password,      *
*      which will be inserted on the card.                            *
*                                                                     *
***********************************************************************
*                                                                     *
*  Entry Point:  IKJEFF10                                             *
*                                                                     *
*  Linkage:      Loaded (by IKJEFF04) and called (by IKJEFF09)        *
*                                                                     *
*  Input:                                                             *
*                                                                     *
*     Register 1 points to a word which points to the following list: *
*                                                                     *
*     +00  IECARDP   Pointer to current statement                     *
*     +04  IEMSGP    Pointer to message                               *
*     +08  IEREPLYP  Pointer to response                              *
*     +0C  IEUSRIDP  Pointer to userid                                *
*     +10  IESUBCTP  Pointer to JCL exit switch bytes                 *
*     +14  IEEXITWD  Word for exit's use (initially zero,             *
*                    retains value assigned by the exit)              *
*     +18  IEACCTIP  Pointer to accounting information                *
*     +1C  IEACCTLP  Pointer to 2-byte length of accounting info      *
*                                                                     *
*  JCL exit switch bytes at +10 (IESUBCTP->IESUBCTD) are as follows:  *
*                                                                     *
*     +0  IETAKEEX  Take exit for statement if corresponding bit is 1 *
*                                                                     *
*   IETJOB   (B'10000000')  -  JOB          (// JOB      )            *
*   IETEXEC  (B'01000000')  -  EXEC         (// EXEC     )            *
*   IETDD    (B'00100000')  -  DD           (// DD       )            *
*   IETCMD   (B'00010000')  -  Command      (// command  )            *
*   IETNULL  (B'00001000')  -  Null         (//          )            *
*   IETJES   (B'00000100')  -  JES2 Command (/*nonblank  )            *
*   IETCOMNT (B'00000010')  -  Comment      (//*         )            *
*   IETJES3  (B'00000001')  -  JES3 Command (//*nonblank )            *
*                                                                     *
*     +1  IEOPRAND  If nonzero, gives the card image column that the  *
*                   operand field starts in (one-origined)            *
*                                                                     *
*     +2  IESTMTYP  Current statement switches                        *
*                                                                     *
*   IESJOB   (B'10000000')  -  JOB          (// JOB      )            *
*   IESEXEC  (B'01000000')  -  EXEC         (// EXEC     )            *
*   IESDD    (B'00100000')  -  DD           (// DD       )            *
*   IESCMD   (B'00010000')  -  Command      (// command  )            *
*   IESNULL  (B'00001000')  -  Null         (//          )            *
*   IESOPCON (B'00000100')  -  Operand to be continued                *
*   IESSCON  (B'00000010')  -  Statement to be continued              *
*   IESCONTN (B'00000001')  -  Statement is a continuation            *
*                                                                     *
*     +3  IESTMTP2  Current statement switches, continued             *
*                                                                     *
*   IESJES   (B'10000000')  -  JES2 Command (/*nonblank  )            *
*   IESCOMNT (B'01000000')  -  Comment      (//*         )            *
*   IESJES3  (B'00100000')  -  JES3 Command (//*nonblank )            *
*                                                                     *
*            (B'00011111') reserved.                                  *
*                                                                     *
*  Output:                                                            *
*                                                                     *
*     A completely new JOB card is constructed from the contents of   *
*     the existing (or SUBMIT-generated) JOB card.  All of the        *
*     operands from the JOB card and its continuations are read into  *
*     a buffer; when the last such card is read, a series of new      *
*     JOB cards and continuations are constructed with the operands   *
*     collected, any transformations or additions being handled at    *
*     this point.  Thus, the new JOB card shares nothing with the     *
*     old, other than its contents.                                   *
*                                                                     *
*     The jobname constructed by this routine consists of N           *
*     characters with the first N-1 of them equal to the userid       *
*     and the last character the same as the last character of        *
*     the original user-supplied jobname.                             *
*                                                                     *
*     If an ACF2 "PASSWORD" card with no password on it appears in    *
*     the input stream, this exit will prompt the user to enter the   *
*     password (in print-inhibit mode, naturally) and the password    *
*     will be placed on the output card.  Note that ACF2 recognizes   *
*     only the following forms of the "PASSWORD" card:                *
*                                                                     *
*        /*PASSWORD     (with no intervening blanks)                  *
*        //*PASSWORD    (with no intervening blanks)                  *
*        // PASSWORD    (with one intervening blank)                  *
*                                                                     *
*     Since JES2 flags the last as a JCL error, only the first two    *
*     forms are valid and are the only ones checked by this exit.     *
*                                                                     *
*  Exit:                                                              *
*                                                                     *
*     Return to IKJEFF09 with one of the following return codes:      *
*                                                                     *
*     RC=0  IECONTIN  Exit processing complete                        *
*                                                                     *
*     RC=4  IERETURN  Additional job card created, return for         *
*                     continuation of JOB statement                   *
*                                                                     *
*     RC=8  IEMSG     Exit routine is returning a message to be       *
*                     issued                                          *
*                                                                     *
*     RC=12 IEPROMPT  Issue message IKJ56283I for exit and reenter    *
*                     exit.  Exit must obtain message text area and   *
*                     may free it when reentered.                     *
*                                                                     *
*     RC=16 IEABORT   Terminate the SUBMIT command.  Return code 8    *
*                     should be used first to issue an error message. *
*                                                                     *
*  External References:                                               *
*                                                                     *
*     Routines - none                                                 *
*     Data Areas - Parameters passed in parameter list                *
*                                                                     *
*  Data areas:                                                        *
*                                                                     *
*     Work area for communication between calls to this exit          *
*     Work area for building JOB statement                            *
*                                                                     *
*  Macros:                                                            *
*                                                                     *
*     The usual gang of idiots                                        *
*                                                                     *
*  Attributes:                                                        *
*                                                                     *
*     RENT, REUS                                                      *
*                                                                     *
*  Notes:                                                             *
*                                                                     *
*     This exit may be tested with a driver available from IPO, or    *
*     alternatively with the DRIVERSU driver.  Inquiries should be    *
*     directed to SEB1525.                                            *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*  Change Activity                                                    *
*                                                                     *
*     05/19/87 - Added check for JOB card continuations that    #EXIT28
*                are not satisfied, since these produce         #EXIT28
*                obscure failures if such a job gets submitted. #EXIT28
*                                                                     *
*     10/11/88 - Change /*PASSWORD to //*PASSWORD to avoid      #EXIT32
*                loss of support and/or integrity due to        #EXIT32
*                JES2 exit 4 peculiarities.                     #EXIT32
*                                                                     *
*     10/27/88 - When allocating the data set specified on a    #EXIT33
*                //PROCLIB DD statement to force HSM recall,    #EXIT33
*                use DISP of SHR rather than OLD.               #EXIT33
*                                                                     *
*     04/20/89 - Fixed 0C4 when many JOB continuations used.    #EXIT34
*                The userid must be copied into the JWA; it     #EXIT34
*                is not sufficient to store the pointer.        #EXIT34
*                                                               #EXIT34
*                                                                     *
*     05/17/89 - Changed region supplied from 6M to 9M.         #EXIT35
*     08/07/89 - Changed region supplied from 9M to 10M.        #EXIT36
*                                                               #EXIT42
*     11/19/90 - Small fix to see if the problem introduced by  #EXIT42
*                IBM PTF UY39507 can be averted.  This has to   #EXIT42
*                do with comments between parts of job cards.   #EXIT42
*                                                               #EXIT42
*     11/26/90 - Extend /*PASSWORD prompting to the PASSWORD=   #EXIT43
*                operand of the JOB statement.                  #EXIT43
*                                                               #EXIT43
*     05/06/92 - React to IBM fix for APAR OY37954.  SUBMIT no  #EXIT48
*                longer sets the JOB bit on for comment cards   #EXIT48
*                in the middle of a JOB continuation sequence.  #EXIT48
*                                                               #EXIT48
***********************************************************************
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    JOB card operand pointer
R4       EQU   4    Miscellaneous uses
R5       EQU   5    Miscellaneous uses
R6       EQU   6    Used for scanning JOB card operands
R7       EQU   7    Base register for SUBMIT JCL control information
R8       EQU   8    Pointer to TSO userid; pointer to JOB operands
R9       EQU   9    Current JCL card base register
R10      EQU   10   Work area base register
R11      EQU   11   Parameter list base register
R12      EQU   12   Static program base register
R13      EQU   13   Dynamic base register and save area pointer
R14      EQU   14
R15      EQU   15
         EJECT
IKJEFF10 CSECT
         SAVE  (14,12),,IKJEFF10_&SYSDATE._&SYSTIME             #EXIT32
         LR    R12,R15             Set program base
         USING IKJEFF10,R12
         L     R11,0(,R1)          Get address of parameter list
         USING IEDSECTD,R11
         L     R7,IESUBCTP         Get address of JCL control switches
         USING IESUBCTD,R7
         SPACE 1
         USING JWA,R10             Workarea address always in R10
         SPACE 1
***********************************************************************
*                                                                     *
* Determine which path to take.                                       *
*                                                                     *
***********************************************************************
*                                                                     *
* Test message pointer.  If it is nonzero, we are being called to     *
* display a message - which means that this exit detected an error    *
* the last time it was called and had returned code 8 or 12.          *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   R1,15,IEMSGP        If message pointer is nonzero, then
         BNZ   MSGRTN              this is reentry to return message
         SPACE 1
***********************************************************************
*                                                                     *
* Otherwise, the message pointer is zero, meaning that either this    *
* is the first call to the exit or the previous call returned a code  *
* of 0 or 4.                                                          *
*                                                                     *
* We check the card pointer.  If it is zero, we are expected to       *
* generate a new card and return it (the previous call returned code  *
* 4).  If it is nonzero, we are expected to inspect the card and      *
* proceed accordingly (the previous call returned code 0).            *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   R9,15,IECARDP       If current statement pointer is zero
         BZ    CONTCARD            then this is reentry to get new card
*                                  else this is reentry for an old card
         USING CARDSECT,R9
         SPACE 1
***********************************************************************
*                                                                     *
* Entry to process an input JCL card.                                 *
*                                                                     *
* Test JCL switches to determine what kind of card this is.           *
*                                                                     *
***********************************************************************
         SPACE 1
JOBSTMT  DS    0H
         SPACE 1
         TM    IESTMTYP,IESJOB     If this is a JOB statement
         BO    PJOB                then process JOB statement
*                                  Else not JOB statement...    #EXIT28
         ICM   R10,15,IEEXITWD     Get address of work area     #EXIT28
         BZ    TRYCMD              If none, no JOB card yet, OK #EXIT28
         TM    JWAFLAGS,JWAJCONT   If JOB continuation expected #EXIT28
         BO    BADCJOB             then error - bad JOB card    #EXIT28
TRYCMD   DS    0H                  Else valid non-JOB card      #EXIT28
         TM    IESTMTYP,IESCMD     if this is a command statement
         BZ    TRYEXEC             then...
         TM    IESTMTYP,IESCONTN    if it's a continuation of command
         BO    RETURN0              then just return (we don't care)
         B     PCMD                 else go to process command card
TRYEXEC  DS    0H                  else (not command statement)...
         TM    IESTMTYP,IESEXEC    if this is an EXEC statement
         BZ    TRYDD               then...
*                                   turn off all return flags except
         MVI   IETAKEEX,IETJOB      for the one that requests JOB
         B     RETURN0              statements, and return
TRYDD    DS    0H                  else (not EXEC statement)...
         TM    IESTMTYP,IESDD      if this is a DD statement
         BZ    TRYJES2             then...
         CLI   CURRCARD+2,C' '      if this DD card is a concatenation
*                                       or a continuation of a previous
         BE    SETRFDT                   PROCLIB DD card, or
         CLC   CURRCARD+2(7),=C'PROCLIB'  the DDNAME is PROCLIB,
         BE    SETRFDT              then go to process PROCLIB DD
         MVI   IETAKEEX,IETJOB      else come back just for JOB cards
         B     RETURN0              and return to get another card
         SPACE 1
TRYJES2  DS    0H                  else (not DD statement)...
         TM    IESTMTP2,IESJES     if this is a JES2 control statement
         BZ    TRYJES3             then...
*                                   see if it's an ACF2 PASSWORD card
         CLC   CURRCARD+2(9),PASWORDB                           #EXIT32
         BNE   RETURN0              if not, then return to get another
         B     CKBLNKPW             else process /*PASSWORD card
TRYJES3  DS    0H                  else (not JES2 statement)...
         TM    IESTMTP2,IESJES3+IESCOMNT if not a //* statement
         BZ    RETURN0                    or it's //* but not
         CLC   CURRCARD+3(9),PASWORDB        a //*PASSWORD card #EXIT32
         BNE   RETURN0                  then return to get another
*                                       else it's a //*PASSWORD card
CKBLNKPW DS    0H                  Process ACF2 PASSWORD statement
         SPACE 1
*                                                               #EXIT32
*************************************************************** #EXIT32
*                                                               #EXIT32
* At this point CURRCARD contains either /*PASSWORD ... or      #EXIT32
* //*PASSWORD ..., and there may or may not be a password       #EXIT32
* present on the card.  We do two things:                       #EXIT32
*                                                               #EXIT32
*  (1) If there is no password, we prompt for one.              #EXIT32
*                                                               #EXIT32
*  (2) If the card is /*PASSWORD, we change it to //*PASSWORD.  #EXIT32
*                                                               #EXIT32
*************************************************************** #EXIT32
*                                                               #EXIT32
         CLC   CURRPSWD-1(60),BLANKS If there's already a password on
         BNE   FIXPWDCD              the card, then go fix card #EXIT32
         LA    R3,CURRPSWD           Else show where to fill in #EXIT43
         BAL   R14,FILLINPW           the password and do it    #EXIT43
*                                                               #EXIT32
         SPACE 1                                                #EXIT32
FIXPWDCD DS    0H                  Here to fix up PASSWORD card #EXIT32
         SPACE 1                                                #EXIT32
         TM    IESTMTP2,IESJES     If this is not a JES2 /* c'd #EXIT32
         BZ    RETURN0             then return, no need to fix  #EXIT32
         CLI   CURRCARD+11,C' '    If /*PASSWORD xxx (1 blank)  #EXIT32
         BE    FIXPN1B             then (assume <= 8 bytes)...  #EXIT32
         MVC   CURRLST9,CURRCARD+11 move password to temp area  #EXIT32
         MVC   CURRCARD+12(9),CURRLST9 move back shifted over 1 #EXIT32
         MVC   CURRLST9,BLANKS     blank out temp area          #EXIT32
FIXPN1B  DS    0H                                               #EXIT32
         MVC   CURRCARD(12),CSSSPASS Make it //*PASSWORD        #EXIT32
         B     RETURN0             Return with good card        #EXIT32
         EJECT
PJOB     DS    0H                  Process JOB statement
         SPACE 1
***********************************************************************
*                                                                     *
* First of all, if this is a comment embedded in a JOB statement,     *
* throw it away.                                                      *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    IESTMTP2,IESCOMNT   If this is a //* inside JOB stuff
         BO    THROWCOM            then return asking for more  #EXIT42
         SPACE 1
***********************************************************************
*                                                                     *
* JOB statement or continuation thereof.  There are four states:      *
*                                                                     *
*  (1) First card of a JOB statement (IESCONTN=0)                     *
*      which is not to be continued  (IESOPCON=0,IESSCON=0)           *
*                                                                     *
*      (in other words, a wholly self-contained single JOB card)      *
*                                                                     *
*  (2) First card of a JOB statement (IESCONTN=0)                     *
*      which is to be continued  (IESOPCON=1 or IESSCON=1)            *
*                                                                     *
*      (e.g. //ABC1234A JOB blah,blah,blah,                   X)      *
*                                                                     *
*  (3) Continuation of a JOB statement (IESCONTN=1)                   *
*      which is not to be continued  (IESOPCON=0,IESSCON=0)           *
*                                                                     *
*      (e.g. //             NOTIFY=ABC1234                     )      *
*                                                                     *
*  (4) Continuation of a JOB statement (IESCONTN=1)                   *
*      which is to be continued  (IESOPCON=1 or IESSCON=1)            *
*                                                                     *
*      (e.g. //             MSGCLASS=H,                       X)      *
*                                                                     *
*  Logic:                                                             *
*                                                                     *
*  (a) If this is the first or only card of a JOB statement, then     *
*      allocate a new JOB statement workarea and place its address    *
*      in IEEXITWD.  (If there's already a pointer to a workarea      *
*      there, this is an internal error, but let it go - just be      *
*      a nice fellow and freemain it.)                                *
*                                                                     *
*      Otherwise, this is a continuation card of a JOB statement,     *
*      so we should already have seen the first card.  IEEXITWD       *
*      must have a pointer in it, otherwise we have an internal       *
*      error - we must blow up.                                       *
*                                                                     *
*  (b) Again, if this is the first or only JOB card, start by         *
*      picking off the jobname (and checking for the presence of      *
*      the 'JOB' verb just to be sure).  Begin picking off the        *
*      operands, remembering that the first 2 are positional          *
*      (the accounting information and the programmer name).          *
*                                                                     *
*  (c) Whether this is the first JOB card or a continuation,          *
*      pick off all the operands, doing necessary processing for      *
*      them as we go.                                                 *
*                                                                     *
*  (d) If this is the last or only JOB card (i.e. it is not being     *
*      continued), then finish up the collecting of operands,         *
*      first by adding any that were not provided and should be       *
*      defaulted, and then by commencing card-insertion mode.         *
*                                                                     *
*      Up till now, we have been returning code 0 to ask for the      *
*      next card, and setting IECARDP to zero to tell SUBMIT not      *
*      to include these JOB cards in the output.  At this point,      *
*      we start generating our own JOB cards - as many as it takes    *
*      to hold all the operands - by building each card and returning *
*      with code 4 to ask for another chance to insert a card.        *
*                                                                     *
*      When we finish, we return with code 0 instead of 4 to show     *
*      that we have no more to insert.  At this point, free the       *
*      workarea that we've been using.                                *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    IESTMTYP,IESCONTN   If first card of JOB statement
         BO    PJOBCONT            then...
         SPACE 1
         ICM   R10,15,IEEXITWD      Get address of work area
         BNZ   GOTTEN               If we don't have one, then...
         LA    R2,JWADATA-JWA+JWAINCR Load initial work area size
         LR    R0,R2                 Get into register for GETMAIN
         GETMAIN R,LV=(0)            Acquire a work area
         LR    R10,R1                Get its address
         ST    R10,IEEXITWD          Store in exit parameter list
         ST    R2,JWALEN             Store length in workarea
GOTTEN   DS    0H                   We have a workarea...
         XR    R0,R0                Make a zero
         ST    R0,JWAOFF            Initialize operand offset to 0
         ST    R0,JWACOUNT          Initialize output JCL card count
         ST    R0,JWALSTOP          Initialize last-operand pointer
         XC    JWAFLAGS,JWAFLAGS    Clear flags
         MVC   JWANAME,BLANKS       Clear jobname
         SPACE 1
***********************************************************************
*                                                                     *
* Set flag to take exit for EXEC, DD, /*JES2 and //*JES3 statements   *
*                                                                     *
***********************************************************************
         SPACE 1
         OI    IETAKEEX,IETEXEC+IETDD+IETJES+IETCOMNT+IETJES3
         SPACE 1
***********************************************************************
*                                                                     *
* Extract the jobname and make sure this is really a JOB card         *
*                                                                     *
* IECARDP  is the address of the card image                           *
* IEUSRIDP is the address of the TSO userid (good to build JOB card)  *
* IESUBCTP is how to get to the column of the operand field on card   *
* IEACCTIP is the address of the user's accounting information        *
* IEACCTLP is the address of the halfword length of that information  *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R8,IEUSRIDP         Get address of TSO userid
         USING USERSECT,R8
         LA    R4,USERID+6         Get pointer to end of userid
UIDLOOP  DS    0H                  Loop back until last nonblank found
         CLI   0(R4),C' '
         BNE   UIDEND
         BCT   R4,UIDLOOP
UIDEND   DS    0H
         LA    R1,USERID
         SR    R4,R1               Compute length of userid minus 1
         ST    R4,JWAUIDL          Save length of userid minus 1
         EX    R4,MVCUID           Move userid to JWAUID        #EXIT34
         SPACE 1
***********************************************************************
*                                                                     *
* Initialize card scan pointer and locate last character of input     *
* jobname (if any)                                                    *
*                                                                     *
***********************************************************************
         SPACE 1
INITSCAN DS    0H
         SPACE 1
         LA    R1,CURRCARD+1       Initialize card scan pointer
         BAL   R14,SCANBLAN        Locate blank which delimits jobname
         BCTR  R15,0               Decrement card scan ptr to last char
         SPACE 1
***********************************************************************
*                                                                     *
* If the jobname found on the card is valid, save it.                 *
* Otherwise set new jobname from userid plus last character of        *
* jobname if it is valid, else a default jobname character.           *
*                                                                     *
***********************************************************************
         SPACE 1
         EX    R4,UIDCOMP1         If jobname matches userid
         BNE   NEWJOBCH             and
         TRT   0(1,R15),JCHARTBL     the jobname character is valid
         BNZ   NEWJOBCH               then
         IC    R6,0(,R15)               use last char of input jobname
         B     NEWJOBNM            else...
NEWJOBCH DS    0H
         LA    R6,C'$'              replace with default char "$"
NEWJOBNM DS    0H                  Generate new job name
         EX    R4,UIDMOVE1         Move userid to work area jobname
         STC   R6,JWANAME+1(R4)    Store our job character in name
         SPACE 1
***********************************************************************
*                                                                     *
* Locate verb field - make sure it says "JOB"                         *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,1(,R15)          Advance card scan pointer to blank
         BAL   R14,SKIPBLAN        Scan to verb
         LTR   R15,R15             If no verb,
         BZ    BADJOB               then invalid job card
         CLC   0(L'CJOB,R15),CJOB  If a verb, it'd better be "JOB"
         BNE   BADJOB              or else invalid job card
         SPACE 1
***********************************************************************
*                                                                     *
* Insure presence of operand field                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,3(,R15)          Advance card scan pointer past "JOB"
         BAL   R14,SKIPBLAN        Scan to operand field
         LR    R3,R15              Save operand pointer
         B     COLLECT             Go to collect operands from card
         SPACE 1
PJOBCONT DS    0H                  Here if JOB continuation card...
         SPACE 1
         ICM   R10,15,IEEXITWD     Get work area address
         BZ    DISASTER            If none, lose badly
         XR    R3,R3               Clear insert register
         ICM   R3,1,IEOPRAND       Get operand column number
         BZ    NOJOPS              If zero, no operands
         BCTR  R3,0                Convert column number to offset
         A     R3,IECARDP          and then to pointer into card
******** B     COLLECT             Go to collect operands from card
         SPACE 1
COLLECT  DS    0H                  Collect JOB statement operands
         SPACE 1
***********************************************************************
*                                                                     *
* Move the entire operand field as a whole to our work area.          *
*                                                                     *
***********************************************************************
         SPACE 1
         LTR   R1,R3               Initialize pointer to operand field
         BZ    NOJOPS              If none, skip operand movement
         BAL   R14,SCANBLAN        Locate blank which delimits operands
*
* At this point R15 -> the character position following the end of the
* operand field.  R3 -> the start of the operand field.
*
         LR    R5,R15
         SR    R5,R3               Get length of operand data
         LA    R2,JWADATA          Point to operand data area
         A     R2,JWAOFF           Add offset of last moved operands
         LA    R14,0(R5,R2)        Add in length of new operand data
         SR    R14,R10             Compute length we'll need
         C     R14,JWALEN          If length still available
         BL    PJROOM              then fine. Else...
         LA    R2,JWAINCR          Get length increment
         A     R2,JWALEN           Add to current length
         LR    R0,R2               Use that length for new getmain
         GETMAIN R,LV=(0)
         LR    R4,R1               Save its address
         LR    R0,R1               Destination address in new area
         L     R1,JWALEN           Length of data to be moved
         LR    R14,R10             Source address in old area
         LR    R15,R1              Length of data to be moved
         MVCL  R0,R14              Move data from old area to new area
         LR    R1,R10              Get address of old area to free
         L     R0,JWALEN           Get length of old area to free
         FREEMAIN R,LV=(0),A=(1)
         LR    R10,R4              Save address of new area
         ST    R10,IEEXITWD        Set in exit parameter list
         ST    R2,JWALEN           Set new work area length
         LA    R2,JWADATA          Point to operand data area
         A     R2,JWAOFF           Add offset of last moved operands
PJROOM   DS    0H
         BCTR  R5,0                Reduce length for execute
         EX    R5,MOVEJWA          Move operand field to JOB work area
         LA    R5,1(,R5)           Restore correct length
         A     R5,JWAOFF           Increment operand offset
         ST    R5,JWAOFF            by length of data just moved
         SPACE 1
NOJOPS   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Tell SUBMIT not to process this card by setting pointer to zero     *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R0,R0               Make a zero
         ST    R0,IECARDP          Zero out card pointer
         SPACE 1
***********************************************************************
*                                                                     *
* If this statement is going to be continued, then just return.       *
* Otherwise this is the last card of the JOB statement, so ask the    *
* caller to start calling us for the purpose of generating new JOB    *
* cards.                                                              *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    IESTMTYP,IESOPCON+IESSCON  If more JOB cards coming
         BZ    LASTJOB              then                        #EXIT28
         OI    JWAFLAGS,JWAJCONT    show continuation expected  #EXIT28
         B     RETURN0              and return asking for more  #EXIT28
LASTJOB  DS    0H                  Else last card of a JOB stmt #EXIT28
         NI    JWAFLAGS,255-JWAJCONT Show continuation satisf'd #EXIT28
         LA    R15,JWADATA         Compute address of end of
         A     R15,JWAOFF           operands by adding offset to
         ST    R15,JWAEND            address of start of operands
         XR    R0,R0               Make a zero
         ST    R0,JWAOFF           Set offset to zero
         LA    R0,JSTART
         ST    R0,JWARET           Set initial processing address
         B     RETURN4             and return asking to insert cards
         EJECT
PCMD     DS    0H                  Process // unknown (CMD) statement
         SPACE 1
***********************************************************************
*                                                                     *
* "// xxx " statement found - assumed by the system to be a command.  *
*                                                                     *
* Determine whether this statement is actually a JOB statement with   *
* a blank jobname field.  (This shouldn't be the case, but the code   *
* must have been in here for a reason, so it's possible that the      *
* SUBMIT command makes mistakes sometimes.)                           *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,CURRCARD+2       Initialize card scan pointer
         BAL   R14,SKIPBLAN        Locate verb
         LTR   R15,R15             If no verb,
         BZ    BADJOB               then blow up
         CLC   0(L'CJOB,R15),CJOB  If verb = 'JOB'
         BE    PJOB                then process as JOB statement
         B     RETURN0             else process normally
         EJECT
         DROP  R10,R8
         EJECT
SETRFDT  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Routine to scan each DD statement before the first EXEC for a       *
*   PROCLIB DD statement.  If a PROCLIB DD statement is found,        *
*   the dsname is allocated, opened, closed, and freed to recall      *
*   the proclib if migrated, and update the refdate in the dscb.      *
*                                                                     *
***********************************************************************
         SPACE 1
*              R2 = "SCANLENG"     Length of scan field
*              R3 = "SCANPTR"      Current byte of scan in opcode field
*              R4 = "SCANMAX"
         SPACE 1
***********************************************************************
*                                                                     *
* Check PROCLIB DD statement for dsname                               *
*                                                                     *
***********************************************************************
*                                                                     *
* Load the offset of the operand in the JCL card                      *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R3,R3               Clear the index register
         ICM   R3,1,IEOPRAND       Insert the offset of the operand
         BZ    RETURN0             Return if no operand field
         BCTR  R3,0                Decrement offset by 1 for zero base
         SPACE 1
***********************************************************************
*                                                                     *
* Load the address of the start of the JCL card                       *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R4,IECARDP          Load the address of the current card
         LA    R4,0(,R4)           Zero the high order bit{s}
         LTR   R4,R4               Test value of address
         BNP   RETURN0             Return if address is zero
         AR    R3,R4               Add offset & card addr for op addr
         LA    R4,66(,R4)          Only scan up to col 66 for DSN= key
         BCTR  R3,0                Decrement base by 1 to set up loop
FINDDSN  DS    0H
         LA    R3,1(,R3)           Increment base pointer by 1
         CR    R3,R4               If we're past end of the op field
         BH    RETURN0              or
         CLI   0(R3),C' '            this character is a blank
         BE    RETURN0                then return, never found dsname
FINDDSN1 DS    0H
         CLC   0(4,R3),=C'DSN='    If this is a DSN= keyword
         BNE   FINDDSN2               then
         LA    R3,4(,R3)              increment scan base
         B     GETNAME                and go get the dsname field
FINDDSN2 DS    0H                    else
         CLC   0(7,R3),=C'DSNAME='  if this is a DSNAME= keyword
         BNE   FINDDSN                   then
         LA    R3,7(,R3)                 increment scan base
         B     GETNAME                   and go get the dsname field
*                                    else keep scanning.
GETNAME  DS    0H                  We found DSN{AME}=; R3 -> name
         L     R4,IECARDP          Load the address of the current card
         LA    R4,71(,R4)          Max col for dsname scan (inc col72)
         CR    R3,R4               If we're past end of the op field
         BH    RETURN0             then return
         LR    R2,R4               Init scan length to max address
         SR    R2,R3               Find the remaining length minus 1
         XR    R1,R1               Clear work register
         EX    R2,SCANDSN          Look for end of dsname
         BNZ   GETSIZE             If end found, R1 has address of end
         LR    R1,R4               If end ^found, assume end in col 72
GETSIZE  DS    0H
         SR    R1,R3               Find the length of the dsname field
         BNP   RETURN0             Return if zero length
         LR    R2,R1               Set the scan length if GT than 0
         SPACE 1
***********************************************************************
*                                                                     *
* Allocate dsname                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
ALLOCDSN DS    0H
         SPACE 1
         LA    R0,LDWORK           Amount of storage for work area
         GETMAIN R,LV=(0)          Get a DD statement work area
         ST    R1,IEEXITWD         Save address of work area
         LR    R10,R1              Establish addressability
         USING DWORK,R10
         LA    R8,DYNAREA          Address dynamic allocation work area
         USING S99RBP,R8
         LA    R4,S99RBPTR+4       Address RB pointer
         USING S99RB,R4
         ST    R4,S99RBPTR         Make RBPTR point to RB
         OI    S99RBPTR,S99RBPND   Turn on VL bit
         XC    S99RB(RBLEN),S99RB  Zero out RB
         MVI   S99RBLN,RBLEN       Initialize RB length field
         MVI   S99VERB,S99VRBAL    Init verb field to allocation
         OI    S99FLAG1,S99NOCNV   Do not use existing allocation
         LA    R5,S99RB+RBLEN      Point past RB to text unit area
         USING S99TUPL,R5
         ST    R5,S99TXTPP         Initialize text pointer address
         LA    R6,S99TUPL+12       Point past the 3 text unit pointers
         USING S99TUNIT,R6
         ST    R6,S99TUPTR         Init pointer to first text unit
         LA    R7,DALDSNAM         Get the key for DSNAME
         STH   R7,S99TUKEY         Store in text unit key field
         LA    R7,1                Indicate 1 parameter for dsname key
         STH   R7,S99TUNUM         Store in text unit number field
         LR    R7,R2               Get the length of the dsname
         STH   R7,S99TULNG         Store in text unit length field
         BCTR  R7,0                Decrement length for execute
         EX    R7,MVCTUPAR         Move dsname to text unit
         LA    R7,1(,R7)           Restore true dsname length
         LA    R6,S99TUPAR         Point to start of dsn in text unit
         AR    R6,R7               Add dsn length to point to text TU
         LA    R5,S99TUPL+4        Locate second text unit pointer
         ST    R6,S99TUPTR         Init second text unit pointer
         LA    R7,DALSTATS         Get key for status specification
         STH   R7,S99TUKEY         Store in text unit key field
         LA    R7,1                Indicate 1 parameter for status key
         STH   R7,S99TUNUM         Set text unit number field to 1
         STH   R7,S99TULNG         Set text unit length field to 1
         MVI   S99TUPAR,X'08'      Set parm to indicate SHR    #EXIT33
         LA    R6,S99TUNIT+7       Point just past the second text unit
         LA    R5,S99TUPL+4        Locate third text unit pointer
         ST    R6,S99TUPTR         Init third text unit pointer
         OI    S99TUPTR,S99TUPLN   Turn on VL bit for last pointer
         LA    R7,DALRTDDN         Get key for returning ddname
         STH   R7,S99TUKEY         Store key in text unit field
         LA    R7,1                Indicate only 1 parameter
         STH   R7,S99TUNUM         Store in text unit number field
         LA    R7,8                Set length of return ddname to 8
         STH   R7,S99TULNG         Store in text unit length field
         LA    R1,DYNAREA          Set parameter for SVC 99
ALLOCATE DS    0H                  Invoke dynamic allocation
         DYNALLOC
         LTR   R15,R15             Test return code
         BNZ   FREEMAIN            Return if terminating error
         CH    R15,S99ERROR        Test error code
         BNE   FREEMAIN            Return if not zero
         CH    R15,S99INFO         Test information code
         BNE   FREE                If zero error, but nonzero info,
*                                  then just free the dsn (don't open)
         MVC   DDNAME(8),S99TUPAR  Store ddname returned from DYNALLOC
         SPACE 1
***********************************************************************
*                                                                     *
* Data set allocated - open it                                        *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,=A(MODELDCB)     (Needed due to nonaddressability)
         MVC   DCB(DCBSIZE),0(R1)   Initialize DCB with model
         MVC   DCB+40(8),DDNAME    Insert ddname returned from alloc.
         MVC   OPEN(OPENSIZE),OPENM Construct OPEN parameter list
         LA    R2,DCB              Specify address of DCB
         LA    R1,OPEN              and address of parameter list
OPENIT   DS    0H                  Open data set
         OPEN  ((R2)),MF=(E,(1))
         LTR   R15,R15             If error opening data set,
         BNZ   FREE                then just free the data set
         SPACE 1
***********************************************************************
*                                                                     *
* Close DCB and free file                                             *
*                                                                     *
***********************************************************************
         SPACE 1
         MVC   CLOSE(CLOSESIZ),CLOSEM Get model CLOSE parameter list
         LA    R2,DCB              Specify address of DCB
         LA    R1,CLOSE             and address of parameter list
CLOSEIT  DS    0H                  Close data set
         CLOSE ((R2)),MF=(E,(1))
         SPACE 1
***********************************************************************
*                                                                     *
* Free file, even if previous errors have been encountered            *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R4,S99RBPTR+4       Establish addressability to RBPTR
         USING S99RB,R4
         ST    R4,S99RBPTR         Make RBPTR point to RB
         OI    S99RBPTR,S99RBPND   Turn on VL bit
         XC    S99RB(RBLEN),S99RB  Zero out RB
         MVI   S99RBLN,RBLEN       Initialize RB length field
         MVI   S99VERB,S99VRBUN    Init verb field to unallocation
         OI    S99FLAG1,S99NOCNV   Do not use existing allocation
         LA    R5,S99RB+RBLEN      Point past RB to text unit area
         USING S99TUPL,R5
         ST    R5,S99TXTPP         Initialize text pointer address
         LA    R6,S99TUPL+42       Point past the 1 text unit pointer
         USING S99TUNIT,R6
         ST    R6,S99TUPTR         Init pointer to first text unit
         OI    S99TUPTR,S99TUPLN   Turn on VL bit for last pointer
         LA    R7,DUNDDNAM         Get key for ddname
         STH   R7,S99TUKEY         Store key in text unit field
         LA    R7,1                Indicate only 1 parameter
         STH   R7,S99TUNUM         Store in text unit number field
         LA    R7,8                Get length of ddname field
         STH   R7,S99TULNG         Store in text unit length field
         MVC   S99TUPAR(8),DDNAME  Move ddname to text unit parm field
         LA    R1,DYNAREA          Set parameter for SVC 99
FREE     DS    0H                  Invoke dynamic allocation
         DYNALLOC
*                                  {Ignore unallocation errors}
         B     FREEMAIN            Free storage and return
         EJECT
FREEMAIN DS    0H
         SPACE 1
         ICM   R1,15,IEEXITWD
         BZ    RETURN0
         LA    R0,LDWORK
         FREEMAIN R,A=(1),LV=(0)
         XR    R0,R0
         ST    R0,IEEXITWD
         B     RETURN0
         EJECT
CONTCARD DS    0H
         SPACE 1
*              R0
*              R1
*              R2    Miscellaneous uses
*              R3    Address of the operand to output
*              R4    Length of the operand to output
*              R5    Length of the collected operand
*              R6    Pointer to operands collected from input
*              R7    Base register for SUBMIT JCL control information
*              R8    Pointer to where to put operands on JCL card
*              R9    Pointer to last available column on JCL card
*              R10   Work area base register
*              R11   Parameter list base register
*              R12   Static program base register
*              R13   Dynamic base register and save area pointer
*              R14
*              R15
         SPACE 1
***********************************************************************
*                                                                     *
* Get-a-card reentry:                                                 *
*                                                                     *
* If we're finished processing JOB card stuff, just free the workarea *
* and return without adding any more cards.  Then ask for more cards  *
* from the input dataset.                                             *
*                                                                     *
* Return a JOB continuation card.  If this is to be the last card in  *
* the sequence, then also free the JOB card work area.                *
*                                                                     *
* We may be being called at any point in our processing of the JOB    *
* statement operands saved from input JOB statement processing.       *
*                                                                     *
* First of all, if there are any pending unmoved operands or          *
* suboperands, we process them first.  Then...                        *
*                                                                     *
* We decide what to do by interrogating JWARET, which contains the    *
* address of the place to resume processing of JOB card operands once *
* any data to be moved to the card has been fully taken care of.      *
*                                                                     *
***********************************************************************
         SPACE 1
         USING JWA,R10
         SPACE 1
         ICM   R10,15,IEEXITWD     Get address of JOB card work area
         BZ    DISASTER            If none, disaster
         SPACE 1
***********************************************************************
*                                                                     *
* See if we're doing JOB card finish-up.                              *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    JWAFLAGS,JWADONE    If JOB card generation finished,
         BO    FREEJWA             then go free the JWA and return.
         SPACE 1
***********************************************************************
*                                                                     *
* Initialize the job card depending on the card count.                *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R9,JWACARD+71       Point to last available col for ops
         ICM   R2,15,JWACOUNT      Get card count so far
         BNZ   NOT1STJ             If zero, then...
*                                   Initialize JCL card area
         MVC   JWASLSL,=C'//'       Put slash-slash
*                                   (Jobname is already there)
         MVC   JWABJOBB,CBJOBB      Put "JOB" verb
         MVC   JWAJOBOP,BLANKS      Put blanks in rest of card
         LA    R8,JWAJOBOP          Point to where operands will start
         LR    R0,R9               End-start tells us how long the
         SR    R0,R8                max operand can be on this card
         ST    R0,JWAMAX           Set max length of an operand
         B     JDOIT                Go to process state
         SPACE 1
NOT1STJ  DS    0H                  Else not the first output card
         SPACE 1
         MVC   JWASLSL,=C'//'       Initialize continuation card
         MVC   JWACARD+2(78),BLANKS Put blanks in rest of card
         LA    R8,JWAOPS            Point to where operands will start
         SPACE 1
JDOIT    DS    0H                  Job card initialized, proceed
         SPACE 1
         LA    R2,1(,R2)
         ST    R2,JWACOUNT         Increment output card count
         SPACE 1
***********************************************************************
*                                                                     *
* If there are any unmoved operands waiting to be processed, do 'em.  *
*                                                                     *
***********************************************************************
         SPACE 1
         ICM   R3,15,JWAUPTR       If there are any unmoved operands
         BZ    NOUNMOVD            then...
*                                   R3 -> unmoved operand
         L     R4,JWAUEND           End minus start...
         SR    R4,R3                R4 = length of the unmoved operand
         BAL   R14,INSERTOP        Try to add unmoved operands
         ICM   R0,15,JWAUPTR       If still unmoved stuff left
         BNZ   CRETURN             then return to try next time
*                                  If succeeded, we're ready to proceed
NOUNMOVD DS    0H                  No unmoved operands...
         SPACE 1
         L     R6,JWASAVE6         Restore regs left by INSERTOP
         L     R15,JWARET          Get continuation address
         BR    R15                 Branch to where we're supposed to go
         EJECT
JSTART   DS    0H                  Initial state - process input op's
         SPACE 1
***********************************************************************
*                                                                     *
* Processing:                                                         *
*                                                                     *
*  Get first operand (by calling SCANCOMA).                           *
*                                                                     *
*  (1) Looking-for-accounting-info.                                   *
*                                                                     *
*      Case:                                                          *
*           (no operand) - emit default accounting info               *
*                          emit default programmer name               *
*                          go to no-more-operands                     *
*           (x=y)        - emit default accounting info               *
*                          emit default programmer name               *
*                          go to process-keyword-operands             *
*           "*",""       - emit default accounting info               *
*                          get next operand by calling SCANCOMA       *
*                          go to looking-for-programmer-name          *
*           other        - emit this operand for accounting info      *
*                          get next operand by calling SCANCOMA       *
*                          go to looking-for-programmer-name          *
*                                                                     *
*  (2) Looking-for-programmer-name.                                   *
*                                                                     *
*      Case:                                                          *
*           (no operand) - emit default programmer name               *
*                          go to no-more-operands                     *
*           (x=y)        - emit default programmer name               *
*                          go to process-keyword-operands             *
*           "*",""       - emit default programmer name               *
*                          get next operand by calling SCANCOMA       *
*                          go to process-keyword-operands             *
*           other        - emit this operand for programmer name      *
*                          get next operand by calling SCANCOMA       *
*                          go to process-keyword-operands             *
*                                                                     *
*  (3) Process-keyword-operands.                                      *
*                                                                     *
*      Turn JWACKLST bit on: checking for last JOB card operand,      *
*      which the emit process will save instead of emitting.          *
*                                                                     *
*      Case:                                                          *
*           (no operand) - go to no-more-operands                     *
*           (x=y)        - emit this operand                          *
*                          get next operand by calling SCANCOMA       *
*                          go to process-keyword-operands             *
*           "*",""       - flag as an error                           *
*                          but emit this operand anyway               *
*                          get next operand by calling SCANCOMA       *
*                          go to process-keyword-operands             *
*           other        - flag as an error                           *
*                          but emit this operand anyway               *
*                          get next operand by calling SCANCOMA       *
*                          go to process-keyword-operands             *
*                                                                     *
*  (4) No-more-operands.                                              *
*                                                                     *
*      Turn JWACKLST bit off.                                         *
*                                                                     *
*      For each operand in required-operand-list,                     *
*      if operand has not been encountered, emit default operand.     *
*                                                                     *
*  (5) Process-last-operand.                                          *
*                                                                     *
*      Emit the last keyword operand (if there was one), which was    *
*      saved during keyword operand processing instead of being       *
*      emitted.                                                       *
*                                                                     *
*  (6) Finished.                                                      *
*                                                                     *
***********************************************************************
*                                                                     *
*  Note:  The reason we save the last operand and put it out last is  *
*         in case the last JOB statement operand takes up 68 bytes    *
*         on the input JOB card image.  In such a case, we would not  *
*         have room to insert a comma after it, and so we must make   *
*         it the last operand on our generated JOB card as well.      *
*                                                                     *
***********************************************************************
         EJECT
         SPACE 1
         LA    R6,JWADATA          Point to where to get first input
         BAL   R14,SCANCOMA        Get a JCL operand
         ST    R15,JWAONEXT        Save address of next operand
         LTR   R15,R15             If none,
         BNZ   L1A1                then
         L     R3,IEACCTIP          get address of default account info
         L     R4,IEACCTLP          get -> len of default account info
         LH    R4,0(,R4)            get length of default account info
         EMIT  ,                    Output the operand
         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34
         L     R4,JWAUIDL           get length of default prgrmr name
         LA    R4,1(,R4)            unreduce for non-execute
         EMIT  ,                    Output the operand
         B     LNOMORE              go to no-more-operands
L1A1     DS    0H                  Else we got an operand.
         L     R5,JWAONEXT
         SR    R5,R6               R5 = length of input operand
         BAL   R14,SCANEQAL        See if operand contains an "="
         LTR   R15,R15             If it does,
         BZ    L1NEQ               then...
         L     R3,IEACCTIP          get address of default account info
         L     R4,IEACCTLP          get -> len of default account info
         LH    R4,0(,R4)            get length of default account info
         EMIT  ,                    Output the operand
         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34
         L     R4,JWAUIDL           get length of default prgrmr name
         LA    R4,1(,R4)            unreduce for non-execute
         EMIT  ,                    Output the operand
         B     LKEYWORD             go to process keyword operands
L1NEQ    DS    0H                  Else (it doesn't contain "=")
         CH    R5,=H'1'            Check length of value
         BL    L1DEFLT             If value = ""
         BH    L1NSTAR              or
         CLI   0(R6),C'*'            value = '*'
         BNE   L1NSTAR                then
L1DEFLT  DS    0H                   (generate default value)
         L     R3,IEACCTIP          get address of default account info
         L     R4,IEACCTLP          get -> len of default account info
         LH    R4,0(,R4)            get length of default account info
         EMIT  ,                       Output the operand
         NEXT  ,                       Get next JCL operand
         B     LPRGRMR                 Go to look for programmer name
L1NSTAR  DS    0H                  Else...
         LR    R3,R6               Get address of this operand
         LR    R4,R5               Get length of this operand
         EMIT  ,                   Emit this one for accounting info
         NEXT  ,                   Get next JCL operand
         B     LPRGRMR             Go to look for programmer name.
         SPACE 1
LPRGRMR  DS    0H                  Looking for programmer name.
         SPACE 1
*
* At this point we have just scanned up the next JCL operand.
*
         ICM   R15,15,JWAONEXT     If no operand
         BNZ   L2A1                then
         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34
         L     R4,JWAUIDL           get length of default prgrmr name
         LA    R4,1(,R4)            unreduce for non-execute
         EMIT  ,                    Output the operand
         B     LNOMORE              Go to no-more-operands
L2A1     DS    0H                  Else (an operand was found)...
         L     R5,JWAONEXT
         SR    R5,R6               R5 = length of input operand
         BAL   R14,SCANEQAL        See if operand contains an "="
         LTR   R15,R15             If it does,
         BZ    L2NEQ               then...
         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34
         L     R4,JWAUIDL           get length of default prgrmr name
         LA    R4,1(,R4)            unreduce for non-execute
         EMIT  ,                    Output the operand
         B     LKEYWORD             Go to process keyword operands
L2NEQ    DS    0H                  Else (no "=") ...
         SPACE 1
         CH    R5,=H'1'            Check length of value
         BL    L2DEFLT             If value = ""
         BH    L2NSTAR              or
         CLI   0(R6),C'*'            value = '*'
         BNE   L2NSTAR                then
L2DEFLT  DS    0H                   (generate default value)
         LA    R3,JWAUID            get addr of deflt pgmr name #EXIT34
         L     R4,JWAUIDL           get length of default prgrmr name
         LA    R4,1(,R4)            unreduce for non-execute
         EMIT  ,                    Output the operand
         NEXT  ,                    Get next JCL operand
         B     LKEYWORD            else go to process keyword operands
L2NSTAR  DS    0H                  Else...
         LR    R3,R6               Get address of this operand
         LR    R4,R5               Get length of this operand
         EMIT  ,                   Emit this one for programmer name
         NEXT  ,                   Get next JCL operand
         B     LKEYWORD            else go to process keyword operands
         SPACE 1
LKEYWORD DS    0H                  Process keyword=value operands
         SPACE 1
         OI    JWAFLAGS,JWACKLST   Start checking for last operand.
         SPACE 1
*
* At this point we have just scanned up the next JCL operand.
*
         ICM   R5,15,JWAONEXT      If no operand
         BZ    LNOMORE             then go to no-more-operands
         SR    R5,R6               Else R5 = length of input operand
         BAL   R14,SCANEQAL        See if operand contains an "="
         LTR   R15,R15             If it does,
         BZ    L3NEQ               then...
*                                  R15 -> value following "=" sign
*                                  R1 = length of keyword before "="
*                                  R2 = length of value after "="
*                                  R5 = length of entire operand
*                                  R6 -> entire operand, keyword
         LR    R14,R1              Get length of keyword
         CH    R14,=H'8'           If longer than 8
         BH    UNKKWD              then assume unknown keyword
         MVC   JWAKEY,BLANKS       Clear keyword test area
         BCTR  R14,0               Else reduce for execute
         EX    R14,MVCKEY          Move keyword to test area
         SPACE 1
         LA    R14,KEYTABLE        Start searching keyword table
KEYLOOP  DS    0H
         C     R14,=A(KEYTBEND)    Loop until end of keyword table
         BNL   UNKKWD              at which point keyword is unknown
         CLC   JWAKEY,0(R14)       If keyword matches this one
         BE    KEYFOUND            then we got it
         LA    R14,12(,R14)        else bump to next table entry
         B     KEYLOOP             and keep searching
KEYFOUND DS    0H                  Found a key
         L     R14,8(,R14)         Get address of associated processor
         BR    R14                 Go to it
         SPACE 1
KTIME    DS    0H                  Processor for TIME=
         SPACE 1
         OI    JWAFLAGS,JWATIME    Indicate TIME keyword found
         B     UNKKWD              Emit like any other keyword
         SPACE 1
KREGION  DS    0H                  Processor for REGION=
         SPACE 1
         OI    JWAFLAGS,JWAREGN    Indicate REGION keyword found
         B     UNKKWD              Emit like any other keyword
         SPACE 1
*MSGCLAS DS    0H                  Processor for MSGCLASS=
*        SPACE 1
*        OI    JWAFLAGS,JWAMSGC    Indicate MSGCLASS keyword found
*        B     UNKKWD              Emit like any other keyword
*        SPACE 1
KNOTIFY  DS    0H                  Processor for NOTIFY=
         SPACE 1
         CH    R2,=H'1'            If value length is 1
         BNE   UNKKWD               and
         CLI   0(R15),C'*'           value = '*'
         BNE   UNKKWD                 then
         MVC   JWABUILD(7),=C'NOTIFY=' start to build new operand
*                                      (deleted by usermod...)  #EXIT34
         L     R14,JWAUIDL             get length to execute
         EX    R14,KNMOVE              move userid to JWABUILD+7
         LA    R3,JWABUILD             get address of new operand
         LA    R4,7+1(,R14)            get length of new operand
         B     KEMIT                   emit NOTIFY=userid
         SPACE 1
KPASSWOR DS    0H                  Processor for PASSWORD=      #EXIT43
         SPACE 1                                                #EXIT43
         LTR   R2,R2               If value length is nonzero   #EXIT43
         BP    UNKKWD              then don't do anything else  #EXIT43
         MVC   JWABUILD(9),=C'PASSWORD=' Start to build new op  #EXIT43
         LA    R3,JWABUILD+9       New password will go here    #EXIT43
         BAL   R14,FILLINPW        Make user fill in password   #EXIT43
         LA    R3,JWABUILD         Get address of new operand   #EXIT43
         LA    R4,9(,R15)          Get length of new operand    #EXIT43
         B     KEMIT               Emit PASSWORD=password       #EXIT43
         SPACE 1                                                #EXIT43
*                                  else emit like any other keyword
         SPACE 1
UNKKWD   DS    0H                  Unknown keyword - just put it out
         SPACE 1
         LR    R3,R6               Get address of this operand
         LR    R4,R5               Get length of this operand
         SPACE 1
KEMIT    DS    0H                  Branch here to emit keyword
         SPACE 1
         EMIT  ,                   Emit this one for programmer name
         NEXT  ,                   Get next JCL operand
         B     LKEYWORD            Go to process next keyword operand
L3NEQ    DS    0H                  Else (no "=") ...
         TELL  BADOPMSG            Tell user it's a bad operand
         LR    R1,R6               Get address of this operand
         LR    R0,R5               Get length of this operand
         TPUT  (1),(0),R           Show user the bad operand
*                                  But emit it anyway...
         LR    R3,R6               Get address of this operand
         LR    R4,R5               Get length of this operand
         EMIT  ,                   Emit this one for programmer name
         NEXT  ,                   Get next JCL operand
         B     LKEYWORD            Go to process next keyword operand
         SPACE 1
LNOMORE  DS    0H                  No more input operands to process.
         SPACE 1
         NI    JWAFLAGS,255-JWACKLST Stop checking for last operand.
         SPACE 1
*
* Add any additional operands we might want to add, like default
* values for TIME and REGION or whatever.
*
         SPACE 1
         TM    JWAFLAGS,JWATIME    If no TIME= specified by user
         BO    NODTIME             then
         LA    R3,DFLTTIME
         LA    R4,L'DFLTTIME
         EMIT  ,                   Output the operand
         SPACE 1
NODTIME  DS    0H
         SPACE 1
         TM    JWAFLAGS,JWAREGN    If no REGION= specified by user
         BO    NODREGN             then
         LA    R3,DFLTREGN
         LA    R4,L'DFLTREGN
         EMIT  ,                   Output the operand
         SPACE 1
NODREGN  DS    0H
*        SPACE 1
*        TM    JWAFLAGS,JWAMSGC    If no MSGCLASS= specified by user
*        BO    NODMSGC             then
*        LA    R3,DFLTMSGC
*        LA    R4,L'DFLTMSGC
*        EMIT  ,                   Output the operand
*        SPACE 1
*ODMSGC  DS    0H
         SPACE 1
* OK, no more special requests, time to put out the last operand.
         SPACE 1
         ICM   R3,15,JWALSTOP      Get address of saved last operand
         BZ    NOMOREOP            If none, bypass this
         L     R4,JWALSTOL         Get length of saved last operand
         EMIT  ,                   Output the last operand
NOMOREOP DS    0H
         SPACE 1
* OK, nothing more to do, this is the last card.
         SPACE 1
         BCTR  R8,0                Bump back to last generated char
         CLI   0(R8),C','          If there was a comma,
         BNE   NOBLKCOM             then
         MVI   0(R8),C' '            blank it out
NOBLKCOM DS    0H
         SPACE 1
         LA    R15,JWACARD
         ST    R15,IECARDP         Set pointer to our JCL card
         SPACE 1
***********************************************************************
*                                                                     *
* At this point we have nothing more to do except return the last     *
* JOB statement card and free the workarea.  Of course, we can't      *
* free the workarea while we're returning a JCL card in it            *
* (he realizes now).  So, we ask to insert one more card, which is    *
* actually a lie, because that time we're going to get control only   *
* to FREEMAIN the JWA and return with no card at all.                 *
*                                                                     *
***********************************************************************
         SPACE 1
         OI    JWAFLAGS,JWADONE    Indicate we're finished generating
         B     RETURN4             Return asking to insert another card
         EJECT
CRETURN  DS    0H                  Here when returning for continuation
         SPACE 1
***********************************************************************
*                                                                     *
* This is where we come when we've squeezed as many operands on a     *
* new JCL card as will fit.  We finish up the card, save values in    *
* the work area, and return, asking SUBMIT to give us another chance  *
* to insert a card.  We will come back in the state of processing we  *
* left in, to insert the operand we were trying to when we found we   *
* didn't have room.                                                   *
*                                                                     *
***********************************************************************
         SPACE 1
*
* Set new value for maximum length of an operand for a card
*
         LA    R0,JWACARD+71-JWAOPS
         ST    R0,JWAMAX           Set max length of an operand
         SPACE 1
         LA    R15,JWACARD
         ST    R15,IECARDP         Set pointer to our JCL card
         B     RETURN4             Return asking for another insert
         EJECT
BADJOB   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Error in job card - display message and return                      *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R0,=A(BADJMSG)      Get address of message area
         ST    R0,IEMSGP           Store address of message area
         LA    R15,IEMSG           RC = issue message and reenter exit
         B     RETURN              Return
         EJECT
BADCJOB  DS    0H
         SPACE 1                                                #EXIT48
****************************************************************#EXIT48
*                                                               #EXIT48
* Non-JOB card found when JOB card continuation expected.       #EXIT48
*                                                               #EXIT48
* If this is a comment card between pieces of a JOB statement,  #EXIT48
* which can happen only when the fix for APAR OY37954 is on,    #EXIT48
* then do the same as we do if both JOB and COMMENT bits are on #EXIT48
* - in other words, throw away the comment card.                #EXIT48
*                                                               #EXIT48
****************************************************************#EXIT48
         SPACE 1                                                #EXIT48
         TM    IESTMTP2,IESCOMNT   If this is a //* inside JOB  #EXIT48
         BO    THROWCOM            then return asking for more  #EXIT48
         SPACE 1
***********************************************************************
*                                                                     *
* Error in job card continuation - display message and return         *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R0,=A(BADJCMSG)     Get address of message area
         ST    R0,IEMSGP           Store address of message area
         LA    R15,IEMSG           RC = issue message and reenter exit
         B     RETURN              Return
         EJECT
MSGRTN   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Message return entry:                                               *
*                                                                     *
* Clear IECARDP and IEMSGP, signal submit abort, and return           *
*                                                                     *
***********************************************************************
         SPACE 1
         SR    R0,R0
         ST    R0,IECARDP          Clear statement pointer
         ST    R0,IEMSGP           Clear message pointer
         MVI   IETAKEEX,X'00'      Turn off all "take exit" switches
         LA    R15,IEABORT         Load abort return code
         B     RETURN              Return
         EJECT
DISASTER DS    0H                  Severe internal error
         SPACE 1
         TELL  DISMSG
         SPACE 1
         LA    R15,16
         B     RETURN
         EJECT
THROWCOM DS    0H                  //* between JOB cards        #EXIT42
         SPACE 1                                                #EXIT42
         SR    R0,R0                                            #EXIT42
         ST    R0,IECARDP          Clear statement pointer      #EXIT42
         LA    R15,IECONTIN        Set return code to request   #EXIT42
         B     RETURN              another card and return      #EXIT42
         SPACE 1                                                #EXIT42
RETURN0  DS    0H                  Return(0) - just gimme next card
         SPACE 1
***********************************************************************
*                                                                     *
* Normal return when requesting to receive the next JCL card          *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R15,IECONTIN        Set return code to request another
         B     RETURN              card and return to caller
         EJECT
RETURN4  DS    0H                  Return(4) - call me to give you one
         SPACE 1
***********************************************************************
*                                                                     *
* Normal return when requesting to generate the next card myself      *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R15,IERETURN        Set return code to get to insert a
         B     RETURN              card next time and return to caller
         EJECT
RETURN   DS    0H                  Return to caller of SUBMIT exit
         SPACE 1
         ST    R15,16(,R13)        Store return code into save area
*                                  (it will be loaded by LM below)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* Subroutines                                                         *
*                                                                     *
***********************************************************************
         SPACE 1
         EJECT
FILLINPW DS    0H                  Fill in ungiven password     #EXIT43
*                                                               #EXIT43
*************************************************************** #EXIT43
*                                                               #EXIT43
* This routine is called whenever there is a password parameter #EXIT43
* that needs to have a password filled in.  The user is given a #EXIT43
* print-inhibited prompt to type the password for the "card".   #EXIT43
*                                                               #EXIT43
* On entry, R3 points to the place to store the password.       #EXIT43
* This place must be 8 bytes long.                              #EXIT43
*                                                               #EXIT43
* On return, R15 contains the length of the specified password. #EXIT43
*                                                               #EXIT43
*************************************************************** #EXIT43
*                                                               #EXIT43
         ICM   R15,15,IEUSRIDP       Else get address of userid
         BZR   R14                   If none,                   #EXIT43
         CLC   0(7,R15),BLANKS        or userid is blank,
         BER   R14                     then nobody to prompt    #EXIT43
         SPACE 1
TPROMPT  DS    0H                    Else prompt to enter a password
         L     R1,=A(GETPSWD)                                   #EXIT32
         L     R0,=A(GETPSWDL)                                  #EXIT32
         TPUT  (1),(0),ASIS        Ask user to enter password   #EXIT32
TGET     DS    0H
         MVC   0(8,R3),BLANKS      Clear input area             #EXIT43
         TCLEARQ INPUT             Flush any outstanding terminal input
         TGET  (R3),8              Read the password from the terminal
         CH    R15,=H'12'          If TGET RC = 12 (input too long),
         BNE   TGETN12             then
         TELL  PSWDERR              tell user password's no good
         B     TPROMPT               and retry
TGETN12  DS    0H                  else
         CH    R15,=H'8'           if TGET RC = 8 (attention hit),
         BE    FIXPWDCD            then return without password #EXIT32
TGETOK   DS    0H                  else presume TGET was OK
         CLC   0(8,R3),BLANKS      If tgotten passwd yet blank  #EXIT43
         BE    TPROMPT             then prompt for it again
         OC    0(8,R3),BLANKS      else translate to upper case #EXIT43
*                                  Now figure out how long the  #EXIT43
         LA    R15,0(,R3)          new password is.  Initialize #EXIT43
         LA    R0,8                pointers and count.          #EXIT43
TGOTLOOP DS    0H                  Loop searching for blank     #EXIT43
         CLI   0(R15),C' '         When blank found             #EXIT43
         BE    TGOTBLAN            then we are done             #EXIT43
         LA    R15,1(,R15)         Else bump pointer            #EXIT43
         BCT   R0,TGOTLOOP         loop till count exhausted    #EXIT43
TGOTBLAN DS    0H                  Blank or EOPW found          #EXIT43
         SR    R15,R3              Return length in R15         #EXIT43
         BR    R14                 Return to caller             #EXIT43
         EJECT
FREEJWA  DS    0H                  Here if called to free JWA
         SPACE 1
         LR    R1,R10              Free the JOB card work area
         L     R0,JWALEN
         FREEMAIN R,A=(1),LV=(0)
         XR    R0,R0
         ST    R0,IEEXITWD         Clear exit work area pointer
         ST    R0,IECARDP          Not returning a JCL card this time
         B     RETURN0             Return asking for next card, please
         EJECT
SKIPBLAN DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*  Subroutine to scan current card for a non-blank character          *
*                                                                     *
*  Entry point:  SKIPBLAN                                             *
*                                                                     *
*  Input:                                                             *
*                                                                     *
*     R1 = pointer to where scan for a nonblank is to begin           *
*    R14 = return address                                             *
*                                                                     *
*  Output:                                                            *
*                                                                     *
*    R15 = pointer to where the first nonblank was found              *
*                                                                     *
*  Exit:                                                              *
*                                                                     *
*    Normal -                                                         *
*      Return with R15 -> where first nonblank was found              *
*    Error (non-blank not found on current card) -                    *
*      Return with R15 = 0                                            *
*                                                                     *
***********************************************************************
         SPACE 1
         USING CARDSECT,R9
         SPACE 1
         LR    R15,R1              Get card scan pointer
         LA    R0,1                Set card scan pointer increment
         LA    R1,CURRCARD+71      Set card scan limit
         CR    R15,R1              If already past it
         BH    SKBLERR              then return in failure
SKBLLOOP DS    0H                  Loop until R15 -> a nonblank
         CLI   0(R15),C' '          or we hit column 71
         BNER  R14                 When nonblank found, success
         BXLE  R15,R0,SKBLLOOP     Loop until blank found or...
SKBLERR  XR    R15,R15             ...end of card
         BR    R14                 Error exit - nonblank not found
         EJECT
SCANBLAN DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*  Subroutine to scan current card for a blank character              *
*                                                                     *
*  Entry point:  SCANBLAN                                             *
*                                                                     *
*  Input:                                                             *
*                                                                     *
*     R1 = pointer to where scan for a blank is to begin              *
*    R14 = return address                                             *
*                                                                     *
*  Output:                                                            *
*                                                                     *
*    R15 = pointer to where the first blank was found                 *
*                                                                     *
*  Exit:                                                              *
*                                                                     *
*    Normal -                                                         *
*      Return with R15 = pointer to first blank (or column 72)        *
*    Error (blank not found on current card) -                        *
*      Return with R15 = 0                                            *
*                                                                     *
***********************************************************************
         SPACE 1
         USING CARDSECT,R9
         SPACE 1
         LR    R15,R1              Get card scan pointer
         LA    R0,1                Set card scan pointer increment
         LA    R1,CURRCARD+71      Set card scan limit
CKBLANK  DS    0H                  Loop until R15 -> a nonblank
         CLI   0(R15),C' '         When blank found,
         BER   R14                 exit with success
         CLI   0(R15),C''''        When apostrophe found,
         BE    QUOTLOOP             go to scan quoted data
         B     BLANLOOP            Otherwise continue loop
CKQUOTE  DS    0H                  Looping inside quoted string...
         CLI   0(R15),C''''        When closing apostrophe found,
         BE    BLANLOOP             exit to blank-scanning loop
QUOTLOOP DS    0H                  Otherwise
         BXLE  R15,R0,CKQUOTE       scan for closing quote only
         BR    R14                 Exit as if blank found if at col 71
BLANLOOP DS    0H
         BXLE  R15,R0,CKBLANK      Scan for blank until column 71
         BR    R14                 Exit as if blank found if at col 71
         EJECT
SCANCOMA DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*  Subroutine to scan collected operands for an operand string        *
*  delimited by a comma                                               *
*                                                                     *
*  Entry point:  SCANCOMA                                             *
*                                                                     *
*  Input:                                                             *
*                                                                     *
*     R6 = pointer to the current operand to start scanning from      *
*    JWAEND points to the end of all input operands.                  *
*    R14 = return address                                             *
*                                                                     *
*  Output:                                                            *
*                                                                     *
*    R15 = pointer to character position following end of operand     *
*          (either pointer to a comma or equal to end of operands)    *
*                                                                     *
*  Exit:                                                              *
*                                                                     *
*    Normal -                                                         *
*      Return with R15 -> character position following end of operand *
*    Error (no more operands to process) -                            *
*      Return with R15 = 0                                            *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R15,R15             Provisionally clear return pointer
         LR    R1,R6               Get pointer to this operand
         C     R1,JWAEND           If already at end of operands
         BNLR  R14                 then return "no more" error
         XR    R2,R2               Clear parenthesis count
         LR    R15,R1              Get operand scan pointer
         LA    R0,1                Set operand scan pointer increment
         L     R1,JWAEND           Set operand scan limit
         BCTR  R1,0                Decrement for stupid BXLE loop
         SPACE 1
SCLOOP   DS    0H                  Loop looking for terminating comma
         SPACE 1
         CLI   0(R15),C','         When comma found,
         BE    SCCOMMLP            process it.
         CLI   0(R15),C''''        When apostrophe found,
         BE    SCQUOTLP            switch to inside-quoted-string scan
         CLI   0(R15),C'('         When left parenthesis found,
         BE    SCLPLOOP            make a note of it
         CLI   0(R15),C')'         When right parenthesis found,
         BE    SCRPLOOP            make a note of it
         B     SCCONT              Otherwise continue loop
         SPACE 1
SCCOMMLP DS    0H                  Comma found
         LTR   R2,R2               If parenthesis count is zero
         BZR   R14                 then exit with success
         B     SCCONT              else continue looping
SCLPLOOP DS    0H                  Left parenthesis found
         LA    R2,1(,R2)           Increment parenthesis count
         B     SCCONT              Continue scan
SCRPLOOP DS    0H                  Right parenthesis found
         LTR   R2,R2               If unmatched parenthesis,
         BNP   SCCONT              then treat as normal char anyhow
         BCTR  R2,0                Else decrement parenthesis count
         B     SCCONT              and continue looping
SCQUOTE  DS    0H                  Looping inside quoted string...
         CLI   0(R15),C''''        When closing apostrophe found,
         BE    SCCONT               exit to normal loop
SCQUOTLP DS    0H                  Otherwise
         BXLE  R15,R0,SCQUOTE       scan for closing quote only
         BR    R14                 If at end, return success anyhow
SCCONT   DS    0H                  Normal continuation
         BXLE  R15,R0,SCLOOP       Scan for comma until operand end
         BR    R14                 If at end, return success anyhow
         EJECT
SCANCOM2 DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*  Subroutine to scan a single operand for suboperands                *
*  delimited by commas                                                *
*                                                                     *
*  Entry point:  SCANCOM2                                             *
*                                                                     *
*  Input:                                                             *
*                                                                     *
*     R3 = pointer to the current operand to start scanning from      *
*     JWAUEND points to the end of the whole operand.                 *
*    R14 = return address                                             *
*                                                                     *
*  Output:                                                            *
*                                                                     *
*    R15 = pointer to character position following a suboperand       *
*          (either pointer to a comma or equal to end of operand)     *
*                                                                     *
*  Exit:                                                              *
*                                                                     *
*    Normal -                                                         *
*      Return with R15 set to pointer to position following operand   *
*    Error (no more operands to process) -                            *
*      Return with R15 = 0                                            *
*                                                                     *
*  Note:  This is functionally identical to SCANCOMA (modulo          *
*         register assignments, etc.) except that it ignores          *
*         parentheses.  Hence, its ability to break up operands       *
*         in a  way compatible with JCL parsing.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R15,R15             Provisionally clear return pointer
         LR    R1,R3               Get pointer to this operand
         C     R1,JWAUEND          If already at end of operands
         BNLR  R14                 then return "no more" error
         LR    R15,R1              Get operand scan pointer
         LA    R0,1                Set operand scan pointer increment
         L     R1,JWAUEND          Set operand scan limit
         BCTR  R1,0                Decrement for stupid BXLE loop
         SPACE 1
S2LOOP   DS    0H                  Loop looking for terminating comma
         SPACE 1
         CLI   0(R15),C','         When comma found,
         BER   R14                 return.
         CLI   0(R15),C''''        When apostrophe found,
         BE    S2QUOTLP            switch to inside-quoted-string scan
         B     S2CONT              Otherwise continue loop
         SPACE 1
S2QUOTE  DS    0H                  Looping inside quoted string...
         CLI   0(R15),C''''        When closing apostrophe found,
         BE    S2CONT               exit to normal loop
S2QUOTLP DS    0H                  Otherwise
         BXLE  R15,R0,S2QUOTE       scan for closing quote only
         BR    R14                 If at end, return success anyhow
S2CONT   DS    0H                  Normal continuation
         BXLE  R15,R0,S2LOOP       Scan for comma until operand end
         BR    R14                 If at end, return success anyhow
         EJECT
SCANEQAL DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*  Subroutine to scan current operand for an equal sign               *
*                                                                     *
*  Entry point:  SCANEQAL                                             *
*                                                                     *
*  Input:                                                             *
*                                                                     *
*     R6 = pointer to where scan for an "=" is to begin               *
*     R5 = length of operand to scan                                  *
*    R14 = return address                                             *
*                                                                     *
*  Output:                                                            *
*                                                                     *
*    R15 = pointer to the operand following the "=" sign              *
*    R1  = length of keyword preceding "=" sign                       *
*    R2  = length of operand following "=" sign                       *
*                                                                     *
*  Exit:                                                              *
*                                                                     *
*    Normal -                                                         *
*      Return with R15 = pointer to operand                           *
*    Error (operand does not contain "=" -                            *
*      Return with R15 = 0                                            *
*                                                                     *
*  Notes:                                                             *
*                                                                     *
*    Since valid JCL keywords cannot contain quotes or parentheses    *
*    in their names, it is assumed that if a quote or parenthesis is  *
*    found before an = is found, there will be no =, and the operand  *
*    will be treated as a positional operand.                         *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R15,R6              Get card scan pointer
         LTR   R0,R5               Get operand length for count
         BZ    SCEQFAIL            If zero, no "="
SCEQLOOP DS    0H
         CLI   0(R15),C'='         When equals sign found
         BE    SCEQSUCC            go process it
         CLI   0(R15),C''''        When quote found
         BE    SCEQFAIL            then assume not valid
         CLI   0(R15),C'('         When left parenthesis found
         BE    SCEQFAIL            then assume not valid
         LA    R15,1(,R15)
         BCT   R0,SCEQLOOP
         B     SCEQFAIL
SCEQSUCC DS    0H
         LR    R1,R15
         SR    R1,R6               Get length of keyword before "="
         BNP   SCEQFAIL            If not positive, error
         LA    R15,1(,R15)         Bump past comma
         LR    R2,R5               Get length of entire operand
         SR    R2,R1               Subtract length of keyword
         BCTR  R2,0                Subtract 1
         BR    R14                 Return with operand length in R2
         SPACE 1
SCEQFAIL DS    0H                  No "="
         XR    R15,R15             Set all return pointers to zero
         XR    R1,R1
         XR    R2,R2
         BR    R14
         EJECT
INSERTOP DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
*  Subroutine to add an operand to the existing JCL card.             *
*                                                                     *
*  Entry point:  INSERTOP                                             *
*                                                                     *
*  Input:                                                             *
*                                                                     *
*     R3 = pointer to the operand to insert on the current JCL card   *
*     R4 = length of that operand                                     *
*     R8 = pointer to the location on the card to insert an operand   *
*     R9 = pointer to the last available column on that card          *
*    R14 = return address                                             *
*                                                                     *
*  Output:                                                            *
*                                                                     *
*    Data is moved to the card as requested                           *
*    R8 is updated to point to the next available column on card      *
*                                                                     *
*  Exit:                                                              *
*                                                                     *
*    Normal -                                                         *
*      Return via R14 with JWAUPTR = zero                             *
*    Error (no room to insert the  entire operand) -                  *
*      Return via R14 with JWAUPTR -> unmoved portion of operand      *
*                                                                     *
*  Processing:                                                        *
*                                                                     *
*    If the operand to be printed on the JCL card is longer than      *
*    71-3 (68) bytes, it can't be fit on a card in one piece.         *
*    In this case, it is scanned for commas (where the operand        *
*    can be broken up) and each piece goes through the following      *
*    handling.  Otherwise the entire operand goes through the         *
*    following handling:                                              *
*                                                                     *
*    If there is enough room on the output JCL card to hold the       *
*    entire operand as is, it is moved to the card.  Otherwise,       *
*    this routine returns in failure, which means that the current    *
*    JCL card must be returned to the caller and another one set      *
*    up on the next call to hold this operand.  However, if this      *
*    operand is longer than 68 bytes, it can't be put on the card     *
*    and an internal error must be signalled.                         *
*                                                                     *
*    When this routine must return in failure, the address of the     *
*    start and end of the operand that it couldn't put on the card    *
*    are saved in the work area so that the next call to this exit    *
*    will know that this needs to be taken care of before anything    *
*    else.                                                            *
*                                                                     *
***********************************************************************
         SPACE 1
***********************************************************************
*     R3 = pointer to the operand to insert on the current JCL card   *
*     R4 = length of that operand                                     *
*     R8 = pointer to the location on the card to insert an operand   *
*     R9 = pointer to the last available column on that card          *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
* Set the address of the end of the operand string being processed    *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R15,0(R3,R4)        Address + length = end
         ST    R15,JWAUEND         Store end-of-operand address
         SPACE 1
***********************************************************************
*                                                                     *
* If this is the last operand found on the input JOB statements, and  *
* we are also checking for the last operand, then don't emit it now.  *
* Instead, save its address and length so that it can be emitted when *
* asked for again.                                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         C     R15,JWAEND          If end of operand is the same as
         BNE   NOTLSTOP             the end of all the operands,
         TM    JWAFLAGS,JWACKLST     and we are checking for the last
         BZ    NOTLSTOP               JOB operand, then...
         ST    R3,JWALSTOP             save address of this operand
         ST    R4,JWALSTOL             save length of this operand
         XR    R0,R0                   make a zero
         ST    R0,JWAUPTR              clear unmoved stuff pointer
         BR    R14                     return to caller
         SPACE 1
NOTLSTOP DS    0H                  Else not last operand to be saved...
         SPACE 1
***********************************************************************
*                                                                     *
* If the complete operand is too long to fit on a JCL card, even by   *
* itself, then start breaking it up at commas and process the pieces. *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,JWAMAX           Get value of max operand length
*                                  (even tho we're about to chAnge it)
*
* Set new value for maximum length of an operand for a card
* (after the first operand, all the rest can fill up a whole card -
* only the first one (after JOB) must fit on first card)
*
         LA    R0,JWACARD+71-JWAOPS
         ST    R0,JWAMAX           Set max length of an operand
         SPACE 1
         CR    R4,R1               If length of operand is less'n max
         BL    INNOBRK             then process as is
*                                  Otherwise break it up
         SPACE 1
         ST    R14,JWASAVE         Save return register
         SPACE 1
COM2LOOP DS    0H                  Loop processing suboperands
         SPACE 1
*                                  R3 -> next suboperand to scan
         BAL   R14,SCANCOM2        Find next break point of operand
         LTR   R15,R15             R15 -> comma or end of operand
         BZ    COM2FIN             If no more operands, finished
         SPACE 1
***********************************************************************
*                                                                     *
*     R15 -> end of operand (either comma or end of whole thing)      *
*     R3 = pointer to the operand and suboperand                      *
*     R15-R3, therefore, = length of that suboperand                  *
*     R8 = pointer to the location on the card to insert an operand   *
*     R9 = pointer to the last available column on that card          *
*                                                                     *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
* If the operand was terminated by a comma, include the comma in the  *
* length so that the comma gets moved too.                            *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   0(R15),C','         If the operand is terminated by a
         BNE   COM2NOTC             comma, then include the comma in
         LA    R15,1(,R15)           the length of the operand 2 move.
COM2NOTC DS    0H
         SPACE 1
         LR    R4,R15              Compute end - start giving...
         SR    R4,R3                length of this suboperand
         BNP   COM2SKIP            If not positive, bypass it
         C     R4,JWAMAX           If length of operand is more'n max
         BH    COM2DIE             then give up this whole JCL card
         ST    R3,JWAUPTR          Store pointer in case we fail
         LR    R1,R8               Output operand loc plus our length
         AR    R1,R4               gives location of last output col
         CR    R1,R9               If that's past last column
         BH    COM2FAIL            then return failure - no room
         LR    R1,R4               Get length of data to move
         BCTR  R1,0                Reduce length for execute
         EX    R1,INSMVC           Move operand to output JCL card
         AR    R8,R4               Bump output pointer by operand len
COM2SKIP DS    0H
         LR    R3,R15              Point to suboperand following comma
         B     COM2LOOP            Go scan this next suboperand
         SPACE 1
COM2FIN  DS    0H                  Succeeded in moving all pieces
         SPACE 1
         XR    R14,R14             Make a zero
         ST    R14,JWAUPTR         Clear unmoved operand address
         L     R14,JWASAVE         Reload return address
         BR    R14                 Return in success
         SPACE 1
COM2FAIL DS    0H                  Failed to move all pieces
         SPACE 1
         ST    R3,JWAUPTR          Set address of unmoved operand
         L     R14,JWASAVE         Reload return address
         BR    R14                 Return in failure
         SPACE 1
COM2DIE  DS    0H                  Even suboperands are too long!!!
         SPACE 1
***********************************************************************
*                                                                     *
* Even suboperands are too long - display message and return          *
*                                                                     *
***********************************************************************
         SPACE 1
         TELL  DIEMSG              Display error message
         LR    R1,R3               Get address of bad operand
         LR    R0,R4               Get length of bad operand
         TPUT  (1),(0),R           Show user the bad operand
         L     R0,=A(DIEJMSG)      Get address of message area
         ST    R0,IEMSGP           Store address of message area
         LA    R15,IEMSG           RC = issue message and reenter exit
         B     RETURN              Return
         SPACE 1
INNOBRK  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Since the whole operand we were asked to move is not greater than   *
* 68 bytes in length, we can definitely move it to a JCL card...      *
* if not this one, then the next one.  We see if we can fit it on     *
* the remainder of the current card.  If so, fine.  If not, we tell   *
* SUBMIT to accept this card and let us insert another one, which     *
* will start with this operand that we couldn't process yet.          *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R15,R8              Output operand loc plus our length
         AR    R15,R4              gives location of last output col
         CR    R15,R9              If that's past last column
*                                  (or even =, since we need "," after)
         BNL   INSFAIL             then return failure - no room
         LTR   R15,R4              Get length of data to move
         BNP   INSKIPMV            If zero, skip move
         BCTR  R15,0               Reduce length for execute
         EX    R15,INSMVC          Move operand to output JCL card
INSKIPMV DS    0H
         AR    R8,R4               Bump output pointer by operand len
         MVI   0(R8),C','          Move a comma to the output
         LA    R8,1(,R8)           Bump past comma
         XR    R0,R0               Make a zero
         ST    R0,JWAUPTR          Clear unmoved-operand pointer
         BR    R14                 Return success
         SPACE 1
INSFAIL  DS    0H                  Unable to move this operand
         SPACE 1
         ST    R3,JWAUPTR          Set pointer to unmoved data
         BR    R14                 Return in failure
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* Executed instructions                                               *
*                                                                     *
***********************************************************************
         SPACE 1
         USING USERSECT,R8
         SPACE 1
UIDMOVE1 MVC   JWANAME(*-*),USERID      Move userid to jobname area
UIDCOMP1 CLC   CURRCARD+2(*-*),USERID   Compare jobname to userid
MOVEJWA  MVC   0(*-*,R2),0(R3)     Move operands to JOB stmt work area
SCANDSN  TRT   0(*-*,R3),CHARTBL        Find end of dsname
MVCTUPAR MVC   S99TUPAR(*-*),0(R3)      Move dsname to text unit
INSMVC   MVC   0(*-*,R8),0(R3)     Executed: move operand to JCL card
MVCKEY   MVC   JWAKEY(*-*),0(R6)   Executed: move keyword to test area
KNMOVE   MVC   JWABUILD+7(*-*),JWAUID Move uid to op build area #EXIT34
MVCUID   MVC   JWAUID(*-*),USERID  Executed: move userid to JWA #EXIT34
         SPACE 1
         DROP  R8
         SPACE 1
***********************************************************************
*                                                                     *
* Constants                                                           *
*                                                                     *
***********************************************************************
         SPACE 1
CBJOBB   DC    CL5' JOB '
CJOB     EQU   CBJOBB+1,4,C'C'     JOB card verb
CSSSPASS DC    C'//*PASSWORD '     PASSWORD card stuff          #EXIT32
PASWORDB EQU   CSSSPASS+3,9,C' '   C'PASSWORD '                 #EXIT32
BLANKS   DC    CL80' '             General purpose blanks
         SPACE 1
*QUALTBL DC    256X'00'            TRT table to scan for equal  #EXIT32
*        ORG   EQUALTBL+C'='                                    #EXIT32
*        DC    X'01'                                            #EXIT32
*        ORG   ,                                                #EXIT32
         SPACE 1
CHARTBL  DC    256XL1'01'          TRT table to find end of dsname
         ORG   CHARTBL+C'.'
         DC    X'00'               Period
         ORG   CHARTBL+C'$'
         DC    X'00'               Dollar sign
         ORG   CHARTBL+C'#'
         DC    X'00'               Sharp sign (gridlet)
         ORG   CHARTBL+C'@'
         DC    X'00'               At sign
         ORG   CHARTBL+C'A'
         DC    XL9'00'             A thru I
         ORG   CHARTBL+C'J'
         DC    XL9'00'             J thru R
         ORG   CHARTBL+C'S'
         DC    XL8'00'             S thru Z
         ORG   CHARTBL+C'0'
         DC    XL10'00'            0 thru 9
         ORG   ,
         SPACE 1
JCHARTBL DC    256XL1'01'          TRT table to validate jobname
         ORG   JCHARTBL+C'$'
         DC    X'00'               Dollar sign
         ORG   JCHARTBL+C'#'
         DC    X'00'               Sharp sign (gridlet)
         ORG   JCHARTBL+C'@'
         DC    X'00'               At sign
         ORG   JCHARTBL+C'A'
         DC    XL9'00'             A thru I
         ORG   JCHARTBL+C'J'
         DC    XL9'00'             J thru R
         ORG   JCHARTBL+C'S'
         DC    XL8'00'             S thru Z
         ORG   JCHARTBL+C'0'
         DC    XL10'00'            0 thru 9
         ORG   ,
         SPACE 1
DFLTTIME DC    C'TIME=1'           Default value for TIME= parameter
DFLTREGN DC    C'REGION=10240K'    Default value for REGION= parameter
*FLTMSGC DC    C'MSGCLASS=H'       Default value for MSGCLASS= parm
         SPACE 1
OPENM    OPEN  (0,(INPUT)),MF=L
CLOSEM   CLOSE (0),MF=L
         SPACE 1
         LTORG
         SPACE 1
KEYTABLE DS    0A
         DC    CL8'TIME    ',A(KTIME)
         DC    CL8'REGION  ',A(KREGION)
*        DC    CL8'MSGCLASS',A(KMSGCLAS)
         DC    CL8'NOTIFY  ',A(KNOTIFY)
         DC    CL8'PASSWORD',A(KPASSWOR)                        #EXIT43
KEYTBEND EQU   *
         SPACE 1
GETPSWD  DC    C'Enter password for job being submitted:'
         DC    X'24'               Print-bypass character
GETPSWDL EQU   *-GETPSWD           Length of message for TPUT
         SPACE 1
BADJMSG  DS    0H
         DC    Y(BADJTEXT-BADJMSG+L'BADJTEXT) Length of error message
BADJTEXT DC    C'Invalid or missing JOB statement - SUBMIT processing tX
               erminated.'
         SPACE 1
BADJCMSG DS    0H
         DC    Y(BDJCTEXT-BADJCMSG+L'BDJCTEXT) Length of error message
BDJCTEXT DC    C'Missing JOB statement continuation - SUBMIT processingX
                terminated.'
         SPACE 1
DIEJMSG  DS    0H
         DC    Y(DIEJTEXT-DIEJMSG+L'DIEJTEXT) Length of error message
DIEJTEXT DC    C'Unable to generate JOB statement - SUBMIT processing tX
               erminated.'
         SPACE 1
PSWDERR  DC    C'Password too long!'
DIEMSG   DC    C'SUBMIT failed, operand too long to fit on JCL card:'
BADOPMSG DC    C'SUBMIT JOB card syntax error - invalid operand:'
DISMSG   DC    C'IKJEFF10 SUBMIT exit internal error finding workarea'
         SPACE 1
         PUSH  PRINT
         PRINT NOGEN
MODELDCB DCB   MACRF=E,DSORG=PO,   Treat all datasets as PO            X
               DDNAME=X            DDNAME not specified
         POP   PRINT
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* IKJEFF10 Dynamic Work Areas                                         *
*                                                                     *
* Work areas are allocated as follows:                                *
*                                                                     *
*  (1) For the duration of JOB card processing, to build the new      *
*      JOB card and write it out in 80-byte chunks                    *
*                                                                     *
*  (2) For PROCLIB DD statement processing, to do dynamic allocation  *
*                                                                     *
***********************************************************************
         SPACE 1
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* IKJEFF10 JOB Card Work Area                                         *
*                                                                     *
*  For the duration of JOB card processing, to build the new          *
*  JOB card and write it out in 80-byte chunks                        *
*                                                                     *
***********************************************************************
         SPACE 1
JWA      DSECT ,                   Work area for JOB card processing
         SPACE 2
JWALEN   DS    A                   Length of this work area
JWASAVE  DS    A                   A save area for subroutine calls
JWAOFF   DS    A                   Offset of where we are in operands
JWAEND   DS    A                   Address of end of collected operands
JWARET   DS    A                   Continuation of output processing
JWAONEXT DS    A                   Address of next operand to process
JWAUPTR  DS    A                   Address of unmoved operand
JWAUEND  DS    A                   Address of end of unmoved operand
JWACOUNT DS    A                   Card count
JWAMAX   DS    A                   Maximum size of an operand
JWASAVE6 DS    A                   Another register save area
*        DS    A                   (Deleted by usermod...)      #EXIT34
JWAUIDL  DS    A                   Length of the userid minus 1
JWALSTOP DS    A                   Address of last JOB stmt operand
JWALSTOL DS    A                   Length of last JOB stmt operand
JWAFLAGS DS    X
JWATIME  EQU   B'10000000'         1 = TIME= found
JWAREGN  EQU   B'01000000'         1 = REGION= found
*WAMSGC  EQU   B'00100000'         1 = MSGCLASS= found
JWADONE  EQU   B'00010000'         1 = finished processing JOB card
JWACKLST EQU   B'00001000'         1 = checking for last operand
JWAJCONT EQU   B'00000100'         1 = JOB card cont. expected  #EXIT28
JWAKEY   DS    CL8                 Keyword from X=Y syntax
JWAUID   DS    CL8                 Userid                       #EXIT34
JWABUILD DS    CL80                Area to build new JCL operands
JWACARD  DS    CL80                Area to build new JCL JOB cards
         ORG   JWACARD             Map individual portions thereof
JWASLSL  DS    C'//'
JWANAME  DS    CL8                 Jobname
JWABJOBB DS    C' JOB '
JWAJOBOP DS    CL(80-(*-JWACARD))  First operands go here
JWAOPS   EQU   JWACARD+3,80-3      Other operands go here
         ORG   ,
JWADATA  DS    0C                  Area to build JOB card...
         SPACE 2
JWAINCR  EQU   512                 JOB card work area size increment
         EJECT
***********************************************************************
*                                                                     *
* IKJEFF10 DD Card Work Area                                          *
*                                                                     *
*  For PROCLIB DD statement processing, to do dynamic allocation      *
*                                                                     *
***********************************************************************
         SPACE 1
DWORK    DSECT ,                   Work area for DD card processing
         SPACE 2
SAVEAREA DS    18F                 Register save area
         SPACE 1
DDNAME   DS    CL8                 DD name
         SPACE 1
         PUSH  PRINT
         PRINT NOGEN
DCB      DCB   MACRF=E,DSORG=PO,   Treat all datasets as PO            X
               DDNAME=X            DDNAME not specified
         POP   PRINT
DCBSIZE  EQU   *-DCB
OPEN     OPEN  (0,(INPUT)),MF=L
OPENSIZE EQU   *-OPEN
CLOSE    CLOSE (0),MF=L
CLOSESIZ EQU   *-CLOSE
         SPACE 1
DYNAREA  DS    CL120               Work area for dynamic allocation
         SPACE 1                                                #EXIT32
WORKEND  DS    0D                  Round to next doubleword
         SPACE 2
LDWORK   EQU   *-DWORK             Length of DD card workarea
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* DSECT describing current JCL statement (pointed to by IECARDP)      *
*                                                                     *
***********************************************************************
         SPACE 1
CARDSECT DSECT
         SPACE 2
CURRCARD DS    CL80
CURRPSWD EQU   CURRCARD+12,8,C'C'  Area to read in the password
CURRLST9 EQU   CURRCARD+71,9,C'C'  Area to move data around     #EXIT32
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* DSECT describing submitter's TSO userid (pointed to by IEUSRIDP)    *
*                                                                     *
***********************************************************************
         SPACE 1
USERSECT DSECT
         SPACE 2
USERID   DS    CL8
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* System macro expansions                                             *
*                                                                     *
***********************************************************************
*                                                                     *
* This system mapping macro formats the parameter list and assigns    *
* equates for the fields passed to this exit.                         *
*                                                                     *
***********************************************************************
         SPACE 1
         IKJEFFIE IETYPE=SUBMIT
         SPACE 1
***********************************************************************
*                                                                     *
* Dynamic allocation control block definitions and equates            *
*                                                                     *
***********************************************************************
         SPACE 1
         IEFZB4D0
         SPACE 2
         IEFZB4D2
         SPACE 2
RBLEN    EQU   (S99RBEND-S99RB)
         SPACE 3
         END
./ ADD NAME=IUCVUDP  0100-07332-07332-0900-01245-01245-00000-SEB
         TITLE 'IUCVUDP  - Macros'
         MACRO
&SYM     TELL  &MSG,&MSGLEN
         LCLC  &L
&L       SETC  '&MSGLEN'
         AIF   ('&L' NE '').GOTLEN
&L       SETC  'L''&MSG'
.GOTLEN  ANOP
&SYM     LA    R1,&MSG
         LA    R0,&L
         TPUT  (1),(0),R
         MEND
         EJECT
         MACRO
&SYM     IPTELL &A,&B
&SYM     TM    &A,&B
         BNO   NOT_&B
         TELL  MSG_&B
NOT_&B   DS    0H
         MEND
         EJECT
         MACRO
&SYM     SHOWX &WHAT
&SYM     XR    R0,R0
         IC    R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(3),DOUBLE
         OI    NUMAREA+3-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(3),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+3
         MEND
         EJECT
         MACRO
&SYM     SHOWA &WHAT
&SYM     ICM   R0,15,&WHAT
         ST    R0,DOUBLE
         UNPK  NUMAREA(9),DOUBLE(5)
         TR    NUMAREA(8),HEXTBL
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(8),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+8
         MEND
         EJECT
         MACRO
&SYM     SHOWB &WHAT
&SYM     XR    R0,R0
         XR    R1,R1
         ICM   R1,B'1000',&WHAT
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVC   MSGAREA+L'MSG_SHOW_&WHAT.(3),=C' B"'
         LA    R14,MSGAREA+L'MSG_SHOW_&WHAT+3
         LA    R15,8
LOOP&SYSNDX DS 0H
         XR    R0,R0
         SLDL  R0,1
         STC   R0,0(,R14)
         OI    0(R14),X'F0'
         LA    R14,1(,R14)
         BCT   R15,LOOP&SYSNDX
         MVI   0(R14),C'"'
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+3+9
         MEND
         EJECT
         MACRO
&SYM     SHOWH &WHAT
&SYM     LH    R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(5),DOUBLE
         OI    NUMAREA+5-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(5),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+5
         MEND
         EJECT
         MACRO
&SYM     SHOWF &WHAT
&SYM     L     R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(11),DOUBLE
         OI    NUMAREA+11-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(11),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+11
         MEND
         EJECT
         MACRO
&SYM     SHOWC &WHAT,&HOWLONG
&SYM     MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),&WHAT
         TR    MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),TRTBL
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+&HOWLONG
         MEND
         MACRO
&SYM     ISEND &WHAT,&BUFA,&BUFL,&ANSL
         LCLC  &AL,&BL
&AL      SETC  '&ANSL'
&BL      SETC  '&BUFL'
         AIF   ('&AL' NE '').AOK
&AL      SETC  '256'
.AOK     ANOP
         AIF   ('&BL' NE '').BOK
&BL      SETC  '40'
.BOK     ANOP
&SYM     DS    0H
         TELL  MSG_&WHAT
         AIF   ('&BL' EQ '0').NOMBUF
         MVC   MYBUFFER(&BL),&BUFA
.NOMBUF  ANOP  ,
         MVC   MYBUFLEN,=Y(&BL)
         MVC   MYANSLEN,=Y(&AL)
         LA    R0,&WHAT
         BAL   R14,SENDIUCV
         MEND
         MACRO
&SYM     CKAUD &WHAT
&SYM     LA    R8,MYEXTBUF
         ICM   R15,7,IPAUDIT
.******* N     R15,=B'11111110111111001111000000000000'
         BZ    OK&SYSNDX
         TELL  MSG_&WHAT._FAILED
         B     SHOW_IPAUDIT_FIELDS
OK&SYSNDX DS   0H
         MEND
         EJECT
         MACRO
&SYM     CKRET &WHAT
&SYM     TM    ARETURN,X'80'
         BZ    OL&SYSNDX
         TELL  MSG_&WHAT._FAILED
         B     SHOW_REASON
OL&SYSNDX DS   0H
         MEND
         EJECT
         TITLE 'IUCVUDP  - Program to demonstrate TCP/IP UDP via IUCV'
***********************************************************************
*                                                                     *
* IUCVUDP  - Program to demonstrate TCP/IP UDP via IUCV               *
*                                                                     *
* Reference:                                                          *
*                                                                     *
*       TCP/IP Version 2 for MVS Programmer's Reference (SC31-6087-0) *
*                                                                     *
*       TCP/IP for MVS Version 2:                                     *
*       Using TCP/IP Sockets Using the MVS/Assembler/IUCV Interface   *
*       Draft                                                         *
*       Ron Lane, IBM T.J. Watson Research Center, TCP/IP Development *
*       Yorktown Heights, NY                                          *
*       Presented at SHARE 78, Anaheim, CA, March 1992                *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    MYEXTBUF
R7       EQU   7    External interrupt buffer base register
R8       EQU   8    IPARML base register
R9       EQU   9    Yet another static base register
R10      EQU   10   Another static base register
R11      EQU   11   .
R12      EQU   12   Static base register
R13      EQU   13   Save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
IUCVUDP  CSECT
IUCVUDP  AMODE 31
IUCVUDP  RMODE 24
         SAVE  (14,12),,IUCVUDP_&SYSDATE._&SYSTIME
         LR    R12,R15
         LA    R10,4095(,R12)
         LA    R10,1(,R10)
         LA    R9,4095(,R10)
         LA    R9,1(,R9)
         USING IUCVUDP,R12,R10,R9
         XR    R7,R7               Clear external interrupt buffer addr
         LR    R2,R1               Save input parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         LA    R0,AREA_TO_CLEAR
         LA    R1,LENGTH_OF_AREA_TO_CLEAR
         XR    R14,R14
         XR    R15,R15
         MVCL  R0,R14              Clear getmained area
         LR    R1,R2               Restore input parameter address
         ST    R12,SAVER12
         ST    R10,SAVER10
         ST    R9,SAVER9
         EJECT
         TELL  MSG_HELLO
         EJECT
*
***********************************************************************
*                                                                     *
* Store PC numbers into areas that IUCV can use.                      *
*                                                                     *
***********************************************************************
*
         LA    R1,IUCVPTRS         Point to area to fill in
         L     R15,=V(SNMPGPCN)    Routine to get the PC numbers
         BALR  R14,R15             Go get the PC numbers
         BNZ   NOPCNUMS            If error, no PC numbers
*
***********************************************************************
*                                                                     *
* Specify the External Interrupt Buffer used for IUCV calls.          *
*                                                                     *
***********************************************************************
*
         GETMAIN R,LV=EXTBUFDL
         LR    R7,R1
         ST    R7,EXTBUFAD         Set address of buffer for IUCV
         XC    0(EXTBUFDL,R7),0(R7)
         USING EXTBUFD,R7
         ST    R13,EXTDATD
         MVC   EXTSTUFF,=CL8'EXTSTUFF'
         LA    R6,MYEXTBUF
         LA    R8,MYEXTBUF
         USING IPARML,R8           Field defined by SNMPPCN macro
         ST    R6,@IPARML
         SHOWA EXTBUFAD
         SHOWA @IPARML
         ST    R6,IUCVDBFR         Field defined by SNMPPCN macro
*
GO       DS    0H
*
         TELL  MSG_IUCV_DCLB
*
         IUCV  DCLBFR,                                                 X
               PRMLIST=(R6),                                           X
               BUFFER=(R6),                                            X
               CONTROL=NO,                                             X
               MF=L
*
* Register me to GCS as an IUCV user.
*
         MVC   MYNAME,=CL8'SEBTEST '
         MVC   MYUSERID,=CL8'TCPIP '
         LA    R2,MYNAME
*
         TELL  MSG_MINI_SET
         IUCVMINI SET,                                                 X
               NAME=(R2),          pick an 8-byte task-unique name     X
               EXIT=IUCVIR,        routine to handle "interrupts"      X
               UWORD=EXTSTUFF,     address passed to exit routine      X
               ERROR=NOGCSSET
*
         LTR   R15,R15
         BNZ   SETFAIL
*
* Connect me to TCP/IP
*
         MVC   MYUSRDTA(16),ZEROES
         MVC   MYMSGLIM,=F'2'
         LA    R6,MYEXTBUF
         ST    R6,@IPARML
         SHOWA @IPARML
*
         TELL  MSG_IUCV_CONN
*
         IUCV  CONNECT,                                                X
               PRMLIST=(R6),                                           X
               USERID=MYUSERID,                                        X
               USERDTA=MYUSRDTA,                                       X
               MSGLIM=MYMSGLIM,                                        X
               PRMDATA=YES,                                            X
               CONTROL=NO,                                             X
               PRTY=NO,                                                X
               MF=L
*
         LA    R2,MYNAME
*
         TELL  MSG_MCOM_CONN
*
         IUCVMCOM CONNECT,                                             X
               NAME=(R2),                                              X
               PRMLIST=(R6),       IPARML formatted by IUCV MF=L call  X
               ERROR=NOGCSCON
*
         LTR   R15,R15
         BNZ   CONFAIL
*
* PATHID should be in IPARML now (first 2 bytes thereof, and also the
* first 2 bytes of External Interrupt Buffer).
*
         SHOWH IPPATHID
*
* Now wait for interrupt routine to respond.  It needs to do nothing,
* just notify me that it was invoked as a Connection Complete interrupt
* which it can verify in IR by: CLI IPTYPE,IPTYPCC...
*
         BAL   R14,WAIT            Wait for Connection Complete
*
* Now send a message to TCP/IP that we intend to do Socket Programming.
*
         XC    SOCKETNO,SOCKETNO   Preset socket number to zero
         XC    MESSAGE1(MESSAGE1_LENGTH),MESSAGE1
         MVC   APICONST,=CL8'IUCVAPI ' Say we want to send more msgs
         XC    MAXSOCK,MAXSOCK     Max # sockets (<= 2000, 0=deflt=50)
         MVC   FLAG,=H'2'          Say we want to do sockets
         UNPK  SUBTSKID+1(7),X'21D'(4) TCB address
         TR    SUBTSKID+1(6),HEXTBL
         MVI   SUBTSKID+0,C'T'
         MVI   SUBTSKID+7,C' '
         SHOWC SUBTSKID,8
*
         ISEND TCPIP_SEND_INITIAL,MESSAGE1,MESSAGE1_LENGTH,8
         CKAUD TCPIP_SEND_INITIAL
         CKRET TCPIP_SEND_INITIAL
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
*
* On return the reply buffer + 4 contains the maximum socket number.
*
         MVC   MAXSOCK#,AREASON
         SHOWF MAXSOCK#
*
* Try some random stuff.
*
         ISEND TCPIP_GETHOSTID,0,0,8
         CKAUD TCPIP_GETHOSTID
         SHOWA ARETURN
         MVC   MYIPADDR(4),ARETURN
         SHOWA MYIPADDR
*
NAMELEN  EQU   64
*
         ISEND TCPIP_GETHOSTNAME,0,0,NAMELEN+8
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
         CKAUD TCPIP_GETHOSTNAME
         SHOWC AHOSTNAM,NAMELEN
*
* Send "socket" message to TCP/IP.
*
         MVC   MESSAGE1+0(4),=A(PF_INET)     domain
******** MVC   MESSAGE1+4(4),=A(SOCK_DGRAM)  type:stream=tcp,dgram=udp
         MVC   MESSAGE1+4(4),=A(SOCK_STREAM) type:stream=tcp,dgram=udp
         MVC   MESSAGE1+8(4),=A(0)           protocol ???
         MVC   MESSAGE1+12(4),=A(3)          choose a socket number?
*
         ISEND TCPIP_SOCKET,MESSAGE1,16,16
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
         CKAUD TCPIP_SOCKET
*
* On return the reply buffer + 0 contains the socket number.
*
         L     R15,ARETURN         TCP/IP ANSBUF first word = socket #
         STH   R15,SOCKETNO
         SHOWH SOCKETNO
*
* Send "bind" message to TCP/IP.
* Must specify IP address of my own machine.  This was obtained
* via "gethostid".
*
         MVC   MESSAGE1+0(2),=Y(PF_INET)  sin_family
         MVC   MESSAGE1+2(2),=Y(0)        sin_port
         MVC   MESSAGE1+4(4),MYIPADDR     sin_addr
         MVC   MESSAGE1+8(8),ZEROES       sin_zero
*
BIND     DS    0H
*
         ISEND TCPIP_BIND,MESSAGE1,16,16
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
         CKAUD TCPIP_BIND
         CKRET TCPIP_BIND
*
* Send "connect" message to TCP/IP.
* Must specify IP address of the other machine.  There is no support
* for "gethostbyname"  :-(
*
         MVC   YRIPADDR(4),=YL1(140,102,17,232) SecurID CISCO
         MVC   PORT,=Y(3020)
*
         MVC   MESSAGE1+0(2),=Y(PF_INET)  sin_family
         MVC   MESSAGE1+2(2),PORT         sin_port
         MVC   MESSAGE1+4(4),YRIPADDR     sin_addr
         MVC   MESSAGE1+8(8),ZEROES       sin_zero
*
CONNECT  DS    0H
*
         ISEND TCPIP_CONNECT,MESSAGE1,16,16
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
         CKAUD TCPIP_CONNECT
         CKRET TCPIP_CONNECT
*
* loop
*
*   "send hi there"
*   "receive 1000"
*   "quit"
*
*   ask "Send, receive, or quit?"
*   get answer
*   case answer
*         "send"    -> ask data-to-send, call send data-to-send
*         "receive" -> ask length-to-receive, call receive length---
*         "quit"    -> exit loop
*
*
LOOP     DS    0H
         TELL  MSG_ASK_SEND_RECEIVE_OR_QUIT
         TCLEARQ INPUT
         TGET  ANSWER,L'ANSWER
         LA    R1,ANSWER
         LA    R0,ANSWER+L'ANSWER
ALOOP1   DS    0H                  Scan for first word of answer
         CR    R1,R0
         BNL   NOANSWER
         CLI   0(R1),C' '
         BE    ANEXT1
         CLI   0(R1),C's'
         BE    ASEND
         CLI   0(R1),C'S'
         BE    ASEND
         CLI   0(R1),C'r'
         BE    ARECV
         CLI   0(R1),C'R'
         BE    ARECV
         CLI   0(R1),C'q'
         BE    AQUIT
         CLI   0(R1),C'Q'
         BE    AQUIT
         B     ABAD
ANEXT1   LA    R1,1(,R1)
         B     ALOOP1
ABAD     DS    0H
         TELL  MSG_BAD_ANSWER
         B     LOOP
NOANSWER DS    0H
         B     LOOP
ASEND    DS    0H
ANEXT2   LA    R1,1(,R1)
ALOOP2   CR    R1,R0
         BNL   ASKSEND
         CLI   0(R1),C' '
         BNE   ANEXT2
ANEXT3   LA    R1,1(,R1)
ALOOP3   CR    R1,R0
         BNL   ASKSEND
         CLI   0(R1),C' '
         BE    ANEXT3
GOTSEND  DS    0H
         LR    R15,R0
         BCTR  R15,0
ALOOP4   CLI   0(R15),C' '
         BNE   AEND4
         BCT   R15,ALOOP4
AEND4    DS    0H
*                                  R1 ->  first nonblank data
*                                  R15 -> last  nonblank data
         LA    R14,1(,R15)
         SR    R14,R1              R0 = length to send
         B     SEND
ASKSEND  DS    0H
         TELL  MSG_ASK_DATA_TO_SEND
         TCLEARQ INPUT
         TGET  ANSWER,L'ANSWER
         LA    R1,ANSWER
         LA    R14,L'ANSWER
         B     SEND
SEND     DS    0H
         XC    SENDPRE(L'SENDPRE),SENDPRE
         MVI   SENDBUF,C' '
         MVC   SENDBUF+1(L'SENDBUF-1),SENDBUF
         BCTR  R14,0
         EX    R14,MVCSEND
         LA    R1,SENDBUF+L'SENDBUF-2
         MVI   0(R1),X'0D'         Carriage return
         MVI   1(R1),X'25'         Line feed
         SHOWC SENDBUF,L'SENDBUF
         TR    SENDBUF,EBCDIC_TO_ASCII
         SHOWC SENDBUF,L'SENDBUF
*
* Send "write" message to TCP/IP.
*
         ISEND TCPIP_WRITE,SENDPRE,L'SENDBUF+L'SENDPRE,8
         CKAUD TCPIP_WRITE
         CKRET TCPIP_WRITE
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
         B     LOOP
*
MVCSEND  MVC   SENDBUF(*-*),0(R1)
*
ARECV    DS    0H
*
*
* Send "receive" message to TCP/IP.
*
RECEIVE_LENGTH EQU 128
*
RECEIVE  DS    0H
*
         ISEND TCPIP_READ,0,0,RECEIVE_LENGTH+24
         CKAUD TCPIP_READ
         CKRET TCPIP_READ
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
*                                  ANSBUF + 8 = source address & port
*                                  for RECEIVE only, not READ
         SHOWF IPBFLN1F
         SHOWF IPBFLN2F
         SHOWC ARECDATA,RECEIVE_LENGTH
* Translate from ASCII to EBCDIC.
         MVC   ERECDATA,ARECDATA
         TR    ERECDATA,ASCII_TO_EBCDIC
         SHOWC ERECDATA,RECEIVE_LENGTH
         B     LOOP
*
AQUIT    DS    0H
*
*
* Send "close"  message to TCP/IP.
*
         ISEND TCPIP_CLOSE,0,0,8
         CKAUD TCPIP_CLOSE
         CKRET TCPIP_CLOSE
         SHOWF ARETURN             ANSBUF + 0 = return code
         SHOWF AREASON             ANSBUF + 4 = reason code
         SHOWA AREASON             ANSBUF + 4 = reason code
*
* On return the reply buffer...?
*
*
* ---
*
* other things that we will want to do
*
*        ISEND TCPIP_SEND,
*        ISEND TCPIP_RECV,
*
* ---
*
         EJECT
         B     RETURN0             Return with code 0
         EJECT
SHOW_IPAUDIT_FIELDS DS 0H
         SPACE 1
         IPTELL IPAUDIT1,IPADRPLE
         IPTELL IPAUDIT1,IPADSNPX
         IPTELL IPAUDIT1,IPADSNAX
         IPTELL IPAUDIT1,IPADANPX
         IPTELL IPAUDIT1,IPADANAX
         IPTELL IPAUDIT1,IPADRJCT
         IPTELL IPAUDIT1,IPADPRMD
         IPTELL IPAUDIT2,IPADRCPX
         IPTELL IPAUDIT2,IPADRCAX
         IPTELL IPAUDIT2,IPADRPPX
         IPTELL IPAUDIT2,IPADRPAX
         IPTELL IPAUDIT2,IPADSVRD
         IPTELL IPAUDIT2,IPADRLST
         IPTELL IPAUDIT3,IPADBLEN
         IPTELL IPAUDIT3,IPADALEN
         IPTELL IPAUDIT3,IPADBTOT
         IPTELL IPAUDIT3,IPADATOT
         SPACE 1
         SHOWB IPAUDIT1
         SHOWB IPAUDIT2
         SHOWB IPAUDIT3
         B     RETURN12
         EJECT
SHOW_REASON DS 0H
         SPACE 1
         SHOWF AREASON
         L     R15,AREASON
         CH    R15,=H'999'
         BH    RETURN12
         SLL   R15,4
         LA    R2,TCPERRAD(R15)
         MVC   TCPERROR(16),0(R2)
         SHOWC TCPERROR,16
         B     RETURN12
         EJECT
NOPCNUMS DS    0H                  Cannot find PC numbers
         SPACE 1
         TELL  MSG_NOPCNUMS
         B     RETURN12
         EJECT
NOGCSSET DS    0H
         ST    R15,MYERROR
         SHOWF MYERROR
         TELL  MSG_NOGCSSET
         B     RETURN12
         EJECT
NOGCSCON DS    0H
         ST    R15,MYERROR
         SHOWF MYERROR
         TELL  MSG_NOGCSCON
         B     RETURN12
         EJECT
SETFAIL  DS    0H
         SPACE 1
         TELL  MSG_SETFAIL
         B     RETURN12
         EJECT
CONFAIL  DS    0H
         SPACE 1
         TELL  MSG_CONFAIL
         B     RETURN12
         EJECT
RETURN12 DS    0H
         TELL  MSG_FAILED
         LA    R15,12              Set return code to 12
         B     RETURN
         SPACE 1
RETURN0  DS    0H
         TELL  MSG_GOODBY
         XR    R15,R15             Set return code to zero
         B     RETURN
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LTR   R1,R7
         BZ    NOFREEXB
         LA    R0,EXTBUFDL
         FREEMAIN R,LV=(0),A=(1)   Free the external interrupt buffer
NOFREEXB DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
WAIT     DS    0H
*
         ST    R14,WAIT_R14
         CLC   ECB(4),=F'0'
         BNE   NOWAIT
         TELL  MSG_WAITING
         CLC   ECB(4),=F'0'
         BNE   NOWAIT
         WAIT  ECB=ECB             Wait for interrupt
         TELL  MSG_WAITED
NOWAIT   DS    0H
         L     R14,WAIT_R14
         BR    R14
         EJECT
SENDIUCV DS    0H
*
***********************************************************************
*                                                                     *
* Called for every TCP/IP request.  On entry it is assumed that the   *
* fields BUFFER and BUFLEN are set.  R0 contains the request number.  *
*                                                                     *
***********************************************************************
*
         ST    R14,SENDIUCV_R14    Save return address
         XC    IPAUDIT(3),IPAUDIT  Clear error flags
         LA    R2,MYNAME
         LA    R6,MYEXTBUF
         LA    R4,MYBUFFER
         LH    R5,MYBUFLEN
         STH   R0,TARGCLAS         target class
*
*              DATA=PRMMSG,        code this if data inline
*              PRMMSG=........,    code this if data inline
*
         TELL  MSG_IUCV_SEND
*
         LTR   R5,R5
         BZ    SEND_WITH_DATA_PRMMSG
*
         IUCV SEND,                                                    X
               PRMLIST=(R6),       formatted by IUCV MF=L              X
               TRGCLS=TARGCLAS,    fullword with operation & socket #  X
               DATA=BUFFER,        code this if data in buffer         X
               BUFFER=(R4),                                            X
               BUFLEN=(R5),                                            X
               ANSBUF=MYANSBUF,                                        X
               ANSLEN=MYANSLEN,                                        X
               TYPE=2WAY,                                              X
               PRTY=NO,                                                X
               MF=L
         B     RIUCVSEN
*
SEND_WITH_DATA_PRMMSG DS 0H
*
         IUCV SEND,                                                    X
               PRMLIST=(R6),       formatted by IUCV MF=L              X
               TRGCLS=TARGCLAS,    fullword with operation & socket #  X
               DATA=PRMMSG,                                            X
               PRMMSG=ZEROES,                                          X
               ANSBUF=MYANSBUF,                                        X
               ANSLEN=MYANSLEN,                                        X
               TYPE=2WAY,                                              X
               PRTY=NO,                                                X
               MF=L
         B     RIUCVSEN
*
RIUCVSEN DS    0H
*
         XC    ECB,ECB
*
         TELL  MSG_MCOM_SEND
*
         IUCVMCOM SEND,                                                X
               NAME=(R2),                                              X
               PRMLIST=(R6),       formatted by IUCV MF=L              X
               ERROR=BADISEND
*
         LTR   R15,R15
         BNZ   ICFAIL
*
* Wait for TCP/IP to return reply via interrupt.
*
         BAL   R14,WAIT            Wait for interrupt response
         B     SENDIUCR
*
BADISEND DS    0H
         ST    R15,MYERROR
         SHOWF MYERROR
         TELL  MSG_SENDFAIL
         B     SENDIUCR
ICFAIL   DS    0H
         TELL  MSG_ICFAIL
         B     SENDIUCR
*
SENDIUCR DS    0H
         L     R14,SENDIUCV_R14    Load return address
         BR    R14                 Return to caller
         EJECT
         DROP  R7,R8,R9,R10,R12,R13
         EJECT
IUCVIR   DS    0H
*
***********************************************************************
*                                                                     *
* This is the routine that handles simulated external interrupts,     *
* which is how TCP/IP passes information back to this program.        *
*                                                                     *
* On entry, R1 points to 4 bytes in front of the UWORD location.      *
*                                                                     *
***********************************************************************
*
         STM   R14,R12,12(R13)
         L     R15,4(,R1)
         L     R7,0(,R15)          R7 = UWORD = address of MYEXTBUF
         USING EXTBUFD,R7
         L     R11,EXTDATD
         USING DATD,R11
         L     R12,SAVER12
         L     R10,SAVER10
         L     R9,SAVER9
         USING IUCVUDP,R12,R10,R9
         TELL  MSG_IR_CALLED
         LA    R6,MYEXTBUF         MYEXTBUF
         LR    R8,R6               MYEXTBUF
         USING IPARML,R8
         ST    R8,@IPARML
         SHOWA @IPARML
         CLC   EXTSTUFF(8),=CL8'EXTSTUFF'
         BE    EXTSTUFF_OK
         SHOWC EXTSTUFF,8
EXTSTUFF_OK DS 0H
         TELL  MSG_FROM_EXTBUF
         SHOWB IPTYPE
*
         POST  ECB                 Post ECB
*
         TELL  MSG_ECBPOSTED
         LM    R14,R12,12(R13)
         BR    R14                 Return to caller
         EJECT
         DROP  R7,R8,R11
         EJECT
         LTORG
         EJECT
MSG_HELLO     DC C'IUCV: Demonstrating IUCV interface to TCP/IP.'
MSG_GOODBY    DC C'IUCV: Completed.'
MSG_FAILED    DC C'IUCV: Terminated. '
MSG_NOPCNUMS  DC C'IUCV: SNMPGPCN failed, no PC numbers set.'
MSG_NOGCSSET  DC C'IUCV: IUCVMINI SET failed, error routine taken.'
MSG_SETFAIL   DC C'IUCV: IUCVMINI SET failed, nonzero return code.'
MSG_NOGCSCON  DC C'IUCV: IUCVMINI CONNECT failed, error routine taken.'
MSG_CONFAIL   DC C'IUCV: IUCVMINI CONNECT failed, nonzero return code.'
MSG_SENDFAIL  DC C'IUCV: IUCVMCOM SEND failed, error routine taken.'
MSG_ICFAIL    DC C'IUCV: IUCVMCOM SEND failed, nonzero return code.'
MSG_WAITING   DC C'IUCV: Waiting for external interrupt routine.'
MSG_WAITED    DC C'IUCV: Returned from wait.'
MSG_IUCV_DCLB DC C'IUCV: Doing IUCV DCLBFR.'
MSG_MINI_SET  DC C'IUCV: Doing IUCVMINI SET.'
MSG_IUCV_CONN DC C'IUCV: Doing IUCV CONNECT.'
MSG_MCOM_CONN DC C'IUCV: Doing IUCVMCOM CONNECT.'
MSG_IUCV_SEND DC C'IUCV: Doing IUCV SEND.'
MSG_MCOM_SEND DC C'IUCV: Doing IUCVMCOM SEND.'
MSG_ASK_SEND_RECEIVE_OR_QUIT DC C'IUCV: S(end), R(eceive), or Q(uit)?'
MSG_ASK_DATA_TO_SEND         DC C'IUCV: Enter data to send:'
MSG_BAD_ANSWER               DC C'IUCV: Bad answer (not S, R, or Q).'
*
MSG_IR_CALLED   DC C'IUCVIR: Interrupt routine called.'
MSG_ECBPOSTED   DC C'IUCVIR: ECB posted.'
MSG_FROM_EXTBUF DC C'IUCVIR: Data from MYEXTBUF.'
*
MSG_TCPIP_SEND_INITIAL         DC C'IUCV: Doing TCP/IP SEND INITIAL.'
MSG_TCPIP_ACCEPT               DC C'IUCV: Doing TCP/IP ACCEPT.'
MSG_TCPIP_BIND                 DC C'IUCV: Doing TCP/IP BIND.'
MSG_TCPIP_CLOSE                DC C'IUCV: Doing TCP/IP CLOSE.'
MSG_TCPIP_CONNECT              DC C'IUCV: Doing TCP/IP CONNECT.'
MSG_TCPIP_FCNTL                DC C'IUCV: Doing TCP/IP FCNTL.'
MSG_TCPIP_GETHOSTID            DC C'IUCV: Doing TCP/IP GETHOSTID.'
MSG_TCPIP_GETHOSTNAME          DC C'IUCV: Doing TCP/IP GETHOSTNAME.'
MSG_TCPIP_GETPEERNAME          DC C'IUCV: Doing TCP/IP GETPEERNAME.'
MSG_TCPIP_GETSOCKNAME          DC C'IUCV: Doing TCP/IP GETSOCKNAME.'
MSG_TCPIP_GETSOCKOPT           DC C'IUCV: Doing TCP/IP GETSOCKOPT.'
MSG_TCPIP_IOCTL                DC C'IUCV: Doing TCP/IP IOCTL.'
MSG_TCPIP_LISTEN               DC C'IUCV: Doing TCP/IP LISTEN.'
MSG_TCPIP_READ                 DC C'IUCV: Doing TCP/IP READ.'
MSG_TCPIP_READV                DC C'IUCV: Doing TCP/IP READV.'
MSG_TCPIP_RECV                 DC C'IUCV: Doing TCP/IP RECV.'
MSG_TCPIP_RECVFROM             DC C'IUCV: Doing TCP/IP RECVFROM.'
MSG_TCPIP_RECVMSG              DC C'IUCV: Doing TCP/IP RECVMSG.'
MSG_TCPIP_SELECT               DC C'IUCV: Doing TCP/IP SELECT.'
MSG_TCPIP_SEND                 DC C'IUCV: Doing TCP/IP SEND.'
MSG_TCPIP_SENDTO               DC C'IUCV: Doing TCP/IP SENDTO.'
MSG_TCPIP_SETSOCKOPT           DC C'IUCV: Doing TCP/IP SETSOCKOPT.'
MSG_TCPIP_SHUTDOWN             DC C'IUCV: Doing TCP/IP SHUTDOWN.'
MSG_TCPIP_SOCKET               DC C'IUCV: Doing TCP/IP SOCKET.'
MSG_TCPIP_WRITE                DC C'IUCV: Doing TCP/IP WRITE.'
MSG_TCPIP_WRITEV               DC C'IUCV: Doing TCP/IP WRITEV.'
MSG_TCPIP_GETCLIENTID          DC C'IUCV: Doing TCP/IP GETCLIENTID.'
MSG_TCPIP_GIVESOCKET           DC C'IUCV: Doing TCP/IP GIVESOCKET.'
MSG_TCPIP_TAKESOCKET           DC C'IUCV: Doing TCP/IP TAKESOCKET.'
MSG_TCPIP_SEND_INITIAL_FAILED  DC C'IUCV: TCP/IP SEND INITIAL failed.'
MSG_TCPIP_ACCEPT_FAILED        DC C'IUCV: TCP/IP ACCEPT failed.'
MSG_TCPIP_BIND_FAILED          DC C'IUCV: TCP/IP BIND failed.'
MSG_TCPIP_CLOSE_FAILED         DC C'IUCV: TCP/IP CLOSE failed.'
MSG_TCPIP_CONNECT_FAILED       DC C'IUCV: TCP/IP CONNECT failed.'
MSG_TCPIP_FCNTL_FAILED         DC C'IUCV: TCP/IP FCNTL failed.'
MSG_TCPIP_GETHOSTID_FAILED     DC C'IUCV: TCP/IP GETHOSTID failed.'
MSG_TCPIP_GETHOSTNAME_FAILED   DC C'IUCV: TCP/IP GETHOSTNAME failed.'
MSG_TCPIP_GETPEERNAME_FAILED   DC C'IUCV: TCP/IP GETPEERNAME failed.'
MSG_TCPIP_GETSOCKNAME_FAILED   DC C'IUCV: TCP/IP GETSOCKNAME failed.'
MSG_TCPIP_GETSOCKOPT_FAILED    DC C'IUCV: TCP/IP GETSOCKOPT failed.'
MSG_TCPIP_IOCTL_FAILED         DC C'IUCV: TCP/IP IOCTL failed.'
MSG_TCPIP_LISTEN_FAILED        DC C'IUCV: TCP/IP LISTEN failed.'
MSG_TCPIP_READ_FAILED          DC C'IUCV: TCP/IP READ failed.'
MSG_TCPIP_READV_FAILED         DC C'IUCV: TCP/IP READV failed.'
MSG_TCPIP_RECV_FAILED          DC C'IUCV: TCP/IP RECV failed.'
MSG_TCPIP_RECVFROM_FAILED      DC C'IUCV: TCP/IP RECVFROM failed.'
MSG_TCPIP_RECVMSG_FAILED       DC C'IUCV: TCP/IP RECVMSG failed.'
MSG_TCPIP_SELECT_FAILED        DC C'IUCV: TCP/IP SELECT failed.'
MSG_TCPIP_SEND_FAILED          DC C'IUCV: TCP/IP SEND failed.'
MSG_TCPIP_SENDTO_FAILED        DC C'IUCV: TCP/IP SENDTO failed.'
MSG_TCPIP_SETSOCKOPT_FAILED    DC C'IUCV: TCP/IP SETSOCKOPT failed.'
MSG_TCPIP_SHUTDOWN_FAILED      DC C'IUCV: TCP/IP SHUTDOWN failed.'
MSG_TCPIP_SOCKET_FAILED        DC C'IUCV: TCP/IP SOCKET failed.'
MSG_TCPIP_WRITE_FAILED         DC C'IUCV: TCP/IP WRITE failed.'
MSG_TCPIP_WRITEV_FAILED        DC C'IUCV: TCP/IP WRITEV failed.'
MSG_TCPIP_GETCLIENTID_FAILED   DC C'IUCV: TCP/IP GETCLIENTID failed.'
MSG_TCPIP_GIVESOCKET_FAILED    DC C'IUCV: TCP/IP GIVESOCKET failed.'
MSG_TCPIP_TAKESOCKET_FAILED    DC C'IUCV: TCP/IP TAKESOCKET failed.'
*
MSG_SHOW_IPPATHID  DC  C'IUCV: PATHID             = '
MSG_SHOW_IPAUDIT1  DC  C'IUCV: IPAUDIT1           = '
MSG_SHOW_IPAUDIT2  DC  C'IUCV: IPAUDIT2           = '
MSG_SHOW_IPAUDIT3  DC  C'IUCV: IPAUDIT3           = '
MSG_SHOW_IPBFLN1F  DC  C'IUCV: IPNFLN1F           = '
MSG_SHOW_IPBFLN2F  DC  C'IUCV: IPNFLN2F           = '
MSG_SHOW_ARETURN   DC  C'IUCV: ANSBUF return code = '
MSG_SHOW_AREASON   DC  C'IUCV: ANSBUF reason code = '
MSG_SHOW_AHOSTNAM  DC  C'IUCV: ANSBUF host name   = '
MSG_SHOW_ARECFROM  DC  C'IUCV: RECEIVE addr/port (ASCII)  = '
MSG_SHOW_ARECDATA  DC  C'IUCV: RECEIVE data      (ASCII)  = '
MSG_SHOW_ERECFROM  DC  C'IUCV: RECEIVE addr/port (EBCDIC) = '
MSG_SHOW_ERECDATA  DC  C'IUCV: RECEIVE data      (EBCDIC) = '
MSG_SHOW_SOCKETNO  DC  C'IUCV: Socket number      = '
MSG_SHOW_SUBTSKID  DC  C'IUCV: Subtask ID         = '
MSG_SHOW_MYERROR   DC  C'IUCV: Error code         = '
MSG_SHOW_MAXSOCK#  DC  C'IUCV: Max socket number  = '
MSG_SHOW_TCPERROR  DC  C'IUCV: TCP error code     = '
*
MSG_SHOW_EXTBUFAD  DC  C'IUCV: EXTBUFAD contains '
MSG_SHOW_@IPARML   DC  C'IUCV: IPARML (EXTBUF) at '
MSG_SHOW_EXTSTUFF  DC  C'IUCVIR: Uh-oh, EXTSTUFF  = '
MSG_SHOW_IPTYPE    DC  C'IUCVIR: IPTYPE           = '
MSG_SHOW_MYIPADDR  DC  C'IUCV: MYIPADDR           = '
MSG_SHOW_SENDBUF   DC  C'IUCV: SENDBUF            = '
*
MSG_IPADRPLE DC C'IPADRRPLE: REPLY TOO LONG FOR BUFFER'
MSG_IPADSNPX DC C'IPADSNPX : PROTECTION EXCEPTION ON SEND BUFFER'
MSG_IPADSNAX DC C'IPADSNAX : ADDRESSING EXCEPTION ON SEND BUFFER'
MSG_IPADANPX DC C'IPADANPX : PROTECTION EXCEPTION ANSWER BUFFER'
MSG_IPADANAX DC C'IPADANAX : ADDRESSING EXCEPTION ANSWER BUFFER'
MSG_IPADRJCT DC C'IPADRJCT : MESSAGE WAS REJECTED'
MSG_IPADPRMD DC C'IPADPRMD : REPLY SENT IN PARAMETER LIST'
*
MSG_IPADRCPX DC C'IPADRCPX : PROTECTION EXCEPTION RECEIVE BUFFER'
MSG_IPADRCAX DC C'IPADRCAX : ADDRESSING EXCEPTION RECEIVE BUFFER'
MSG_IPADRPPX DC C'IPADRPPX : PROTECTION EXCEPTION REPLY BUFFER'
MSG_IPADRPAX DC C'IPADRPAX : ADDRESSING EXCEPTION REPLY BUFFER'
MSG_IPADSVRD DC C'IPADSVRD : PATH WAS SEVERED'
MSG_IPADRLST DC C'IPADRLST : INVALID RECEIVE/REPLY LIST'
*
MSG_IPADBLEN DC C'IPADBLEN : BAD LENGTH IN SEND BUFFER LIST'
MSG_IPADALEN DC C'IPADALEN : BAD LENGTH IN SEND ANSWER LIST'
MSG_IPADBTOT DC C'IPADBTOT : INVALID TOTAL SEND BUFFER LENGTH'
MSG_IPADATOT DC C'IPADATOT : INVALID TOTAL SEND ANSWER LENGTH'
*
         DS    0C
*
TCPERRAD EQU   *-16
  DC CL16'EPERM'        1               /* Not owner */
  DC CL16'ENOENT'       2               /* No such file or directory */
  DC CL16'ESRCH'        3               /* No such process */
  DC CL16'EINTR'        4               /* Interrupted system call */
  DC CL16'EIO'          5               /* I/O error */
  DC CL16'ENXIO'        6               /* No such device or address */
  DC CL16'E2BIG'        7               /* Arg list too long */
  DC CL16'ENOEXEC'      8               /* Exec format error */
  DC CL16'EBADF'        9               /* Bad file number */
  DC CL16'ECHILD'       10              /* No children */
  DC CL16'EAGAIN'       11              /* No more processes */
  DC CL16'ENOMEM'       12              /* Not enough core */
  DC CL16'EACCES'       13              /* Permission denied */
  DC CL16'EFAULT'       14              /* Bad address */
  DC CL16'ENOTBLK'      15              /* Block device required */
  DC CL16'EBUSY'        16              /* Mount device busy */
  DC CL16'EEXIST'       17              /* File exists */
  DC CL16'EXDEV'        18              /* Cross-device link */
  DC CL16'ENODEV'       19              /* No such device */
  DC CL16'ENOTDIR'      20              /* Not a directory*/
  DC CL16'EISDIR'       21              /* Is a directory */
  DC CL16'EINVAL'       22              /* Invalid argument */
  DC CL16'ENFILE'       23              /* File table overflow */
  DC CL16'EMFILE'       24              /* Too many open files */
  DC CL16'ENOTTY'       25              /* Not a typewriter */
  DC CL16'ETXTBSY'      26              /* Text file busy */
  DC CL16'EFBIG'        27              /* File too large */
  DC CL16'ENOSPC'       28              /* No space left on device */
  DC CL16'ESPIPE'       29              /* Illegal seek */
  DC CL16'EROFS'        30              /* Read-only file system */
  DC CL16'EMLINK'       31              /* Too many links */
  DC CL16'EPIPE'        32              /* Broken pipe */
  DC CL16' '   33
  DC CL16' '   34
  DC CL16'EWOULDBLOCK'  35              /* Operation would block */
  DC CL16'EINPROGRESS'  36              /* Operation now in progress */
  DC CL16'EALREADY'     37              /* Operation already in\
  DC CL16'ENOTSOCK'     38              /* Socket operation on\
  DC CL16'EDESTADDRREQ' 39              /* Destination address required
  DC CL16'EMSGSIZE'     40              /* Message too long */
  DC CL16'EPROTOTYPE'   41              /* Protocol wrong type for\
  DC CL16'ENOPROTOOPT'  42              /* Protocol not available */
  DC CL16'EPROTONOSUPPORT' 43           /* Protocol not supported */
  DC CL16'ESOCKTNOSUPPORT' 44           /* Socket type not supported */
  DC CL16'EOPNOTSUPP'   45              /* Operation not supported on\
  DC CL16'EPFNOSUPPORT' 46              /* Protocol family not\
  DC CL16'EAFNOSUPPORT' 47              /* Address family not supported
  DC CL16'EADDRINUSE'   48              /* Address already in use */
  DC CL16'EADDRNOTAVAIL' 49             /* Can't assign requested\
  DC CL16'ENETDOWN'     50              /* Network is down */
  DC CL16'ENETUNREACH'  51              /* Network is unreachable */
  DC CL16'ENETRESET'    52             /* Network dropped connection on
  DC CL16'ECONNABORTED' 53              /* Software caused connection\
  DC CL16'ECONNRESET'   54              /* Connection reset by peer */
  DC CL16'ENOBUFS'      55              /* No buffer space available */
  DC CL16'EISCONN'      56              /* Socket is already connected\
  DC CL16'ENOTCONN'     57              /* Socket is not connected */
  DC CL16'ESHUTDOWN'    58              /* Can't send after socket\
  DC CL16'ETOOMANYREFS' 59              /* Too many references: can't\
  DC CL16'ETIMEDOUT'    60              /* Connection timed out */
  DC CL16'ECONNREFUSED' 61              /* Connection refused */
  DC CL16'ELOOP'        62              /* Too many levels of symbolic\
  DC CL16'ENAMETOOLONG' 63              /* File name too long */
  DC CL16'EHOSTDOWN'    64              /* Host is down */
  DC CL16'EHOSTUNREACH' 65              /* No route to host */
  DC CL16'ENOTEMPTY'    66              /* Directory not empty */
  DC CL16'EPROCLIM'     67              /* Too many processes */
  DC CL16'EUSERS'       68              /* Too many users */
  DC CL16'EDQUOT'       69              /* Disc quota exceeded */
  DC CL16'ESTALE'       70              /* Stale NFS file handle */
  DC CL16'EREMOTE'      71              /* Too many levels of remote in
  DC CL16'ENOSTR'       72              /* Device is not a stream */
  DC CL16'ETIME'        73              /* Timer expired */
  DC CL16'ENOSR'        74              /* Out of streams resources */
  DC CL16'ENOMSG'       75              /* No message of desired type *
  DC CL16'EBADMSG'      76              /* Trying to read unreadable\
  DC CL16'EIDRM'        77              /* Identifier removed */
  DC CL16'EDEADLK'      78              /* Deadlock condition. */
  DC CL16'ENOLCK'       79              /* No record locks available.*/
  DC CL16'ENONET'       80              /* Machine is not on the\
  DC CL16'ERREMOTE'     81              /* Object is remote */
  DC CL16'ENOLINK'      82              /* the link has been severed */
  DC CL16'EADV'         83              /* advertise error */
  DC CL16'ESRMNT'       84              /* srmount error */
  DC CL16'ECOMM'        85              /* Communication error on send\
  DC CL16'EPROTO'       86              /* Protocol error */
  DC CL16'EMULTIHOP'    87              /* multihop attempted */
  DC CL16'EDOTDOT'      88              /* Cross mount point (not an\
  DC CL16'EREMCHG'      89              /* Remote address changed */
         SPACE 1
ASCII_TO_EBCDIC DS 0C              from 'TCPIP.STANDARD.TCPXLBIN'
         SPACE 1
         DC    X'00010203372D2E2F1605250B0C0D0E0F'
         DC    X'101112133C3D322618193F271C1D1E1F'
         DC    X'405A7F7B5B6C507D4D5D5C4E6B604B61'
         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'
         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'
         DC    X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'
         DC    X'79818283848586878889919293949596'
         DC    X'979899A2A3A4A5A6A7A8A9C04FD0A107'
         DC    X'00010203372D2E2F1605250B0C0D0E0F'
         DC    X'101112133C3D322618193F271C1D1E1F'
         DC    X'405A7F7B5B6C507D4D5D5C4E6B604B61'
         DC    X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'
         DC    X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'
         DC    X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'
         DC    X'79818283848586878889919293949596'
         DC    X'979899A2A3A4A5A6A7A8A9C04FD0A107'
         SPACE 1
EBCDIC_TO_ASCII DS 0C              from 'TCPIP.STANDARD.TCPXLBIN'
         SPACE 1
         DC    X'00010203FF09FF7FFFFFFF0B0C0D0E0F'
         DC    X'10111213FFFF08FF1819FFFF1C1D1E1F'
         DC    X'FFFFFFFFFF0A171BFFFFFFFFFF050607'
         DC    X'FFFF16FFFFFFFF04FFFFFFFF1415FF1A'
         DC    X'20FFFFFFFFFFFFFFFFFFFF2E3C282B7C'
         DC    X'26FFFFFFFFFFFFFFFFFF21242A293B5E'
         DC    X'2D2FFFFFFFFFFFFFFFFFFF2C255F3E3F'
         DC    X'FF5EFFFFFFFFFFFFFF603A2340273D22'
         DC    X'FF616263646566676869FF7BFFFFFFFF'
         DC    X'FF6A6B6C6D6E6F707172FFFFFFFFFFFF'
         DC    X'FF7E737475767778797AFFFFFF5BFFFF'
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFF5DFFFF'
         DC    X'7B414243444546474849FFFFFFFFFFFF'
         DC    X'7D4A4B4C4D4E4F505152FFFFFFFFFF82'
         DC    X'5CFF535455565758595AFFFFFFFFFFFF'
         DC    X'30313233343536373839FFFFFFFF82FF'
         SPACE 1
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
*
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
ZEROES   DC    XL256'00'
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
*
SAVEAREA DS    18F
*
SAVER12  DS    F
SAVER10  DS    F
SAVER9   DS    F
*
AREA_TO_CLEAR EQU *
*
DOUBLE   DS    D                   For conversions
MYIPADDR DS    F                   My IP address
YRIPADDR DS    F                   Your IP address
@IPARML  DS    A                   Address of IPARML
SENDIUCV_R14 DS A                  Save area for SENDIUCV subroutine
WAIT_R14     DS A                  Save area for WAIT     subroutine
*
IUCVSAVE DS    0F
IUCVSR14 DS    F
IUCVSR15 DS    F
IUCVSR0  DS    F
IUCVSR1  DS    F
IUCVSR2  DS    F
IUCVSR3  DS    F
IUCVSR4  DS    F
IUCVSR5  DS    F
IUCVSR6  DS    F
IUCVSR7  DS    F
IUCVSR8  DS    F
IUCVSR9  DS    F
IUCVSR10 DS    F
IUCVSR11 DS    F
IUCVSR12 DS    F
*
MYBUFLEN DS    H
MYANSLEN DS    H
PORT     DS    H
*
IRSTUFF  DS    F                   R1 points here at entry to I.R.
MYERROR  DS    F
MYUWORD  DS    F                   User word for interrupt
MYMSGLIM DS    F                   Message limit for IUCV CONNECT
EXTBUFAD DS    F                   Address of external interrupt buffer
TARGCLAS DS    F                   Target class
MAXSOCK# DS    F                   Maximum socket number
*
SOCKETNO EQU   TARGCLAS+2,2,C'H'
*
* Fields to send to TCP/IP
*
MESSAGE1 DS    0XL20
APICONST DS    CL8
MAXSOCK  DS    H
FLAG     DS    H
SUBTSKID DS    CL8
MESSAGE1_LENGTH EQU *-MESSAGE1
*
TCPERROR DS    CL16
*
MYNAME   DS    CL8                 Name IUCV knows me by
MYUSERID DS    CL8                 Name to ask for TCP/IP by
MYUSRDTA DS    XL16                User data for IUCV CONNECT
         DS    0D
MYANSBUF DS    XL256
MYBUFFER DS    XL256
*
ARETURN  EQU   MYANSBUF+0,4,C'F'   TCP/IP return code
AREASON  EQU   MYANSBUF+4,4,C'F'   TCP/IP reason code
AHOSTNAM EQU   MYANSBUF+8,0,C'C'
ARECFROM EQU   MYANSBUF+8,16,C'C'
ARECDATA EQU   MYANSBUF+24,0,C'C'
*
ERECFROM DS    CL16
ERECDATA DS    CL256
*
NUMAREA  DS    CL12                Area for number conversion
TXTAREA  DS    CL64                Area for text
MSGAREA  DS    CL218               Area for message text
ANSWER   DS    CL200
SENDPRE  DS    CL20
SENDBUF  DS    CL236
*
         SNMPPCN SECT=CSECT
*
LENGTH_OF_AREA_TO_CLEAR EQU *-AREA_TO_CLEAR
*
SIZDATD  EQU   *-DATD              Length of dynamic work area
         EJECT
EXTBUFD  DSECT ,                   Map the external interrupt buffer
*
EXTSTUFF DS    XL16
MYEXTBUF DS    XL40
ECB      DS    F
EXTDATD  DS    F
*
EXTBUFDL EQU   *-EXTBUFD
*
         EJECT
*
***********************************************************************
* Miscellaneous equates                                               *
***********************************************************************
*
*
* equates for TCP/IP requests
*
TCPIP_SEND_INITIAL  EQU 0
TCPIP_ACCEPT        EQU 1
TCPIP_BIND          EQU 2
TCPIP_CLOSE         EQU 3
TCPIP_CONNECT       EQU 4
TCPIP_FCNTL         EQU 5
TCPIP_GETHOSTID     EQU 7
TCPIP_GETHOSTNAME   EQU 8
TCPIP_GETPEERNAME   EQU 9
TCPIP_GETSOCKNAME   EQU 10
TCPIP_GETSOCKOPT    EQU 11
TCPIP_IOCTL         EQU 12
TCPIP_LISTEN        EQU 13
TCPIP_READ          EQU 14
TCPIP_READV         EQU 14
TCPIP_RECV          EQU 16
TCPIP_RECVFROM      EQU 16
TCPIP_RECVMSG       EQU 16
TCPIP_SELECT        EQU 19
TCPIP_SEND          EQU 20
TCPIP_SENDTO        EQU 22
TCPIP_SETSOCKOPT    EQU 23
TCPIP_SHUTDOWN      EQU 24
TCPIP_SOCKET        EQU 25
TCPIP_WRITE         EQU 26
TCPIP_WRITEV        EQU 26
TCPIP_GETCLIENTID   EQU 30
TCPIP_GIVESOCKET    EQU 31
TCPIP_TAKESOCKET    EQU 32
*
PF_INET             EQU  2
*
SOCK_STREAM         EQU  1       stream socket
SOCK_DGRAM          EQU  2       datagram socket
SOCK_RAW            EQU  3       raw-protocol interface
SOCK_RDM            EQU  4       reliably-delivered message
SOCK_SEQPACKET      EQU  5       sequenced packet stream
*
         EJECT
*
***********************************************************************
* Macro expansions                                                    *
***********************************************************************
*
******** MVPXVMCV ,                VMCF stuff
*
         COPY  IPARML              Map the IPARML dsect
*
         PRINT NOGEN
*
         IEFJESCT
         IEFJSCVT
         CVT   DSECT=YES
         IHAPSA
*
         END
./ ADD NAME=PBRHLPA  0100-07332-07332-0900-00014-00014-00000-SEB
PBRHLPA  CSECT
         USING PBRHLPA,15
         ST    14,SALVE
         L     15,=V(PBRHLPR)
         DROP  15
         BALR  14,15
         USING *,14
         L     14,SALVE
         DROP  14
         LR    15,0
         BR    14
         SPACE 1
SALVE    DS    F
         END
./ ADD NAME=PROMPT   0100-07332-07332-0900-00143-00143-00000-SEB
         TITLE 'PROMPT - PROGRAM TO TEST PUTGET ROUTINES'
***********************************************************************
*                                                                     *
* PROMPT - A TSO COMMAND PROCESSOR TO TEST THE PUTGET ROUTINE.        *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
PROMPT   CSECT
         SAVE  (14,12),,PROMPT_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING PROMPT,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS
         EJECT
         MVC   CPPL(16),0(R1)      SAVE CPPL
         MVC   IOPLUPT,CPPLUPT
         MVC   IOPLECT,CPPLECT
         LA    R0,ECB
         ST    R0,IOPLECB
         MVC   PGLIST(PGLEN),SPGLIST
         LOAD  EP=IKJPTGT          LOAD PUTGET FROM OUR LIBRARY
         ST    R0,@PUTGET          SAVE ITS ADDRESS
         SPACE 3
REPEAT   DS    0H                  MAIN PROGRAM LOOP
         XC    ECB,ECB             CLEAR ECB
         L     R15,@PUTGET
         PUTGET PARM=PGLIST,MF=(E,IOPL),ENTRY=(15),                    X
               OUTPUT=(PROMOLD1,MULTLVL,PROMPT)
         MVC   RMSG(L'SRMSG),SRMSG
         LR    R4,R15              SAVE RETURN CODE
         CVD   R4,DOUBLE
         UNPK  RCODE(2),DOUBLE
         OI    RCODE+1,X'F0'
         LA    R1,RMSG
         LA    R0,L'RMSG+2
         TPUT  (1),(0),R
         L     R3,PGLIST+12        GET ADDRESS OF INPUT BUFFER
         LTR   R3,R3               IF NONE,
         BZ    RETURNP              DON'T DISPLAY IT
         LA    R1,4(,R3)           POINT TO INPUT TEXT
         LH    R0,0(,R3)           GET LENGTH OF INPUT BUFFER
         SH    R0,=H'4'            SUBTRACT HEADER LENGTH
         BZ    RETURNP             IF NULL LINE, PROGRAM TERMINATED
         TPUT  (1),(0),R           ECHO INPUT BUFFER TO TERMINAL
         EJECT
RETURNP  DS    0H                  RETURN WITH CODE 0
         SPACE
         DELETE EP=IKJPTGT
         SPACE
         LR    R15,R4              SET RETURN CODE TO = PUTGET RC
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
PROMOLD1 DC    A(PROMOLD2,1,PROMMSG1)
PROMOLD2 DC    A(0,1,PROMMSG2)
         SPACE 1
SPGLIST  PUTGET MF=L,OUTPUT=(*-*,MULTLVL,PROMPT)
PGLEN    EQU   *-SPGLIST
         SPACE 1
PROMMSG1 WTO   MF=L,' PLEASE REPLY TO PROMPT+'
PROMMSG2 WTO   MF=L,' PLEASE ENTER SOMETHING IN REPLY TO THE PROMPT MESX
               SAGE DISPLAYED ABOVE'
         SPACE 1
SRMSG    DC    C'PROMPT: PUTGET RETURN CODE WAS '
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
@PUTGET  DS    A                   ADDRESS OF PUTGET ROUTINE
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
CPPL     DS    0A
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
IOPL     DS    0A
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
PGLIST   PUTGET MF=L
         SPACE 1
RMSG     DS    CL(L'SRMSG)
RCODE    DS    CL2
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         END
./ ADD NAME=RECSIZE  0100-07332-07332-0900-00037-00037-00000-SEB
***********************************************************************
*                                                                     *
* PROCEDURE NAME:  RECSIZE                                            *
*                                                                     *
* FUNCTION:  TO RETURN THE RECORD SIZE OF A FILE TO A PL/1 PROGRAM.   *
*                                                                     *
* DECLARATION:                                                        *
*                                                                     *
*     DCL RECSIZE EXTERNAL ENTRY(FILE) RETURNS(FIXED(31) BIN);        *
*                                                                     *
* SAMPLE INVOCATION:                                                  *
*                                                                     *
*     I = RECSIZE(SYSPRINT);                                          *
*                                                                     *
***********************************************************************
         SPACE
RECSIZE  CSECT
         USING RECSIZE,15
         STM   14,4,12(13)
         LM    2,3,0(1)            R2 -> ADDR(DCLCB), R3 -> RETURN AREA
         L     2,0(,2)             R2 -> DCLCB
         L     1,4(,12)            R1 -> PRV
         AH    1,2(,2)              ADD OFFSET OF FCB PTR IN PRV
         ICM   4,15,0(1)           R4 -> FCB
         BZ    NODCB               IF NO FCB, TRY USING RECSZ IN DCLCB
         ICM   4,15,20(4)          R4 -> DCB
         BZ    NODCB               IF NO DCB, TRY USING RECSZ IN DCLCB
         LH    0,82(,4)            R0 = DCBLRECL
         B     RETURN
NODCB    DS    0H                  NO DCB, USE RECSIZE FIELD IN DCLCB
         L     4,12(,2)            R4 -> DENV
         L     4,16(,4)            R4 -> NREC
         L     0,0(,4)             USE RECSIZE FIELD IN DENV
RETURN   ST    0,0(,3)             STORE RESULT IN RETURN AREA
         LM    14,4,12(13)
         BR    14
         END
./ ADD NAME=TCBMAP   0100-07332-07332-0900-00267-00267-00000-SEB
         TITLE 'TCBMAP - MAPS TCB TREE SYSTEM CONTROL BLOCKS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    TCB POINTER
R4       EQU   4    JPQ POINTER
R5       EQU   5    LLS POINTER
R6       EQU   6    RB POINTER
R7       EQU   7    CDE POINTER
R8       EQU   8    DEB POINTER
R9       EQU   9    BRANCH AND LINK REGISTER
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
TCBMAP   CSECT
         SAVE  (14,12),,TCBMAP_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING TCBMAP,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE CLEAR LINE TO BLANKS
         EJECT
         L     R3,X'21C'           TCB
         L     R3,X'7C'(,R3)       JSTCB
DOIT     DS    0H
         BAL   R14,PROCESS
         ICM   R15,7,X'89'(R3)     DAUGHTER TCB
         BZ    NODTR
         LR    R3,R15              IF EXISTS, USE IT
         B     DOIT
NODTR    DS    0H                  ELSE
         ICM   R15,7,X'81'(R3)     SISTER TCB
         BZ    NOSISTER
         LR    R3,R15              IF EXISTS, USE IT
         B     DOIT
NOSISTER DS    0H                  ELSE
         ICM   R15,7,X'85'(R3)     MOTHER TCB
         BZ    NOMORE
         LR    R3,R15              IF EXISTS, THEN
         B     NODTR               PROCESS ITS SISTER, ETC.
NOMORE   DS    0H
         B     RETURN
         EJECT
PROCESS  DS    0H
         ST    R14,PRCSSAVE        SAVE RETURN REGISTER
TCBLOOP  DS    0H
         BAL   R9,OUTPUT           TPUT " "
         MVC   LINE(L'TCBMSG),TCBMSG
         STCM  R3,7,DOUBLE         TCB ADDRESS
         UNPK  LINE+L'TCBMSG(7),DOUBLE(4)
         TR    LINE+L'TCBMSG(6),HEXTBL
         MVI   LINE+L'TCBMSG+6,C' '
         BAL   R9,OUTPUT           TPUT "PROCESSING TCB"
         L     R6,0(,R3)           RB
         MVC   LINE(L'RBMSG),RBMSG
         STCM  R6,7,DOUBLE         RB ADDRESS
         UNPK  LINE+L'RBMSG(7),DOUBLE(4)
         TR    LINE+L'RBMSG(6),HEXTBL
         MVI   LINE+L'RBMSG+6,C' '
         BAL   R9,OUTPUT           TPUT "PROCESSING RB"
RBLOOP   DS    0H
         TM    X'A'(R6),X'C0'      CHECK RB TYPE
         BZ    PRB
         BO    SVRB
         LA    R1,=C'IRB '
         B     RBTYPE
SVRB     LA    R1,=C'SVRB'
RBTYPE   DS    0H
         STCM  R6,7,DOUBLE         RB ADDRESS
         UNPK  LINE+0(7),DOUBLE(4)
         TR    LINE+0(6),HEXTBL
         MVI   LINE+6,C' '
         MVC   LINE+8(4),0(R1)
         BAL   R9,OUTPUT           TPUT RB TYPE
         B     RBNEXT
PRB      DS    0H
         L     R7,X'C'(R6)         RBCDE
         STCM  R6,7,DOUBLE         RB ADDRESS
         UNPK  LINE+0(7),DOUBLE(4)
         TR    LINE+0(6),HEXTBL
         MVI   LINE+6,C' '
         MVC   LINE+8(8),8(R7)
         BAL   R9,OUTPUT           TPUT CDE NAME TO IDENTIFY RB
RBNEXT   DS    0H
         TM    X'B'(R6),X'80'      IF NEXTRB POINTS TO TCB
         BO    ENDRB               THEN NO MORE RB'S. ELSE
         ICM   R6,7,X'1D'(R6)      NEXT RB
         B     RBLOOP
ENDRB    DS    0H
         MVC   LINE(L'JPQMSG),JPQMSG
         BAL   R9,OUTPUT           TPUT "MAPPING JOB PACK QUEUE"
         ICM   R4,15,X'2C'(R3)     JPQ
CDELOOP  BZ    ENDCDE
         STCM  R4,7,DOUBLE         CDE ADDRESS
         UNPK  LINE+0(7),DOUBLE(4)
         TR    LINE+0(6),HEXTBL
         MVI   LINE+6,C' '
         MVC   LINE+8(8),8(R4)
         BAL   R9,OUTPUT           TPUT CDE MODULE NAME
         ICM   R4,15,0(R4)
         B     CDELOOP
ENDCDE   DS    0H
TCB2LOOP DS    0H
         MVC   LINE(L'LLSMSG),LLSMSG
         BAL   R9,OUTPUT           TPUT "MAPPING LOAD LIST"
         ICM   R5,15,X'24'(R3)     LLS
LLSLOOP  BZ    ENDLLS
         L     R4,4(,R5)           CDE FOR LOAD LIST ENTRY
         STCM  R4,7,DOUBLE         CDE ADDRESS
         UNPK  LINE+0(7),DOUBLE(4)
         TR    LINE+0(6),HEXTBL
         MVI   LINE+6,C' '
         MVC   LINE+8(8),8(R4)
         BAL   R9,OUTPUT           TPUT CDE MODULE NAME
         ICM   R5,15,0(R5)
         B     LLSLOOP
ENDLLS   DS    0H
         ICM   R8,7,9(R3)          DEB
         BNZ   GOTDEBS
         MVC   LINE(L'NODEBS),NODEBS
         BAL   R9,OUTPUT           TPUT "NO OPEN DATA SETS"
         B     ENDDEB
GOTDEBS  DS    0H
         MVC   LINE(L'DEBMSG),DEBMSG
         STCM  R8,7,DOUBLE         DEB ADDRESS
         UNPK  LINE+L'DEBMSG(7),DOUBLE(4)
         TR    LINE+L'DEBMSG(6),HEXTBL
         MVI   LINE+L'DEBMSG+6,C' '
         BAL   R9,OUTPUT           TPUT "MAPPING DEB CHAIN"
DEBLOOP  DS    0H
         L     R10,X'18'(,R8)      DCB
         L     R11,X'C'(,R3)       TIOT
         AH    R11,X'28'(,R10)     ADD TIOT OFFSET FROM DCB
         STCM  R8,7,DOUBLE         DEB ADDRESS
         MVC   LINE(4),=C'DEB='
         UNPK  LINE+4(7),DOUBLE(4)
         TR    LINE+4(6),HEXTBL
         MVI   LINE+4+6,C' '
         MVC   LINE+12(4),=C'DCB='
         STCM  R10,7,DOUBLE        DCB ADDRESS
         UNPK  LINE+16(7),DOUBLE(4)
         TR    LINE+16(6),HEXTBL
         MVI   LINE+16+6,C' '
         MVC   LINE+24(8),4(R11)   DDNAME
         MVI   LINE+32,C' '
         ICM   R10,7,X'C'(R11)     JFCB ADDRESS
         MVC   LINE+33(44),X'10'(R10)   DSNAME
         LA    R1,LINE+33+44-1
DSNLOOP  CLI   0(R1),C' '
         BNE   DSNEND
         BCTR  R1,0
         B     DSNLOOP
DSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME
         CLI   X'10'+44(R10),C' '  IF THERE IS A MEMBER NAME IN JFCB
         BE    NOMEMBER            THEN
         MVI   1(R1),C'('
         MVC   2(8,R1),X'10'+44(R10)
         LA    R1,9(,R1)
MEMLOOP  CLI   0(R1),C' '
         BNE   MEMEND
         BCTR  R1,0
         B     MEMLOOP
MEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME
         MVI   1(R1),C')'
NOMEMBER DS    0H
         BAL   R9,OUTPUT           TPUT DEB=ADDR DCB=ADDR DDNAME
         ICM   R8,7,5(R8)
         BNZ   DEBLOOP
ENDDEB   DS    0H
         L     R14,PRCSSAVE        RETURN
         BR    R14
         EJECT
OUTPUT   DS    0H
         TR    LINE(L'LINE),TRTBL
         LA    R1,LINE
         LA    R0,L'LINE
         SVC   93                  TPUT LINE,LENGTH(LINE)
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE CLEAR LINE TO BLANKS
         BR    R9                  RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
TCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '
RBMSG    DC    C'---MAPPING RBS (REQUEST BLOCKS) - '
JPQMSG   DC    C'---MAPPING CDES FOR TCB FROM JOB PACK QUEUE'
LLSMSG   DC    C'---MAPPING CDES FOR TCB FROM LOAD LIST'
NODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'
DEBMSG   DC    C'---MAPPING DEBS - '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
PRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE
LINE     DS    CL128               WORD AREA FOR OUTPUT LINES
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         END
./ ADD NAME=TMPOFF   0100-07332-07332-0900-00010-00010-00000-SEB
TMPOFF   CSECT
         SPACE
         STM   14,12,12(13)
         LR    12,15
         USING TMPOFF,12
         STTMPMD OFF
         L     14,12(,13)
         LM    0,12,20(13)
         BR    14
         END
./ ADD NAME=TMPON    0100-07332-07332-0900-00014-00014-00000-SEB
TMPON    CSECT
         SPACE
         STM   14,12,12(13)
         LR    12,15
         USING TMPON,12
         STTMPMD ON
         TPUT  MSGF,MSGFL,FULLSCR
         L     14,12(,13)
         LM    0,12,20(13)
         BR    14
         SPACE
MSGF     DC    X'27F140'
MSGFL    EQU   *-MSGF
         END
./ ADD NAME=VITWHR   0100-07332-07332-0900-00295-00295-00000-SEB
         TITLE 'VITWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'VITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *
* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *
* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *
* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *
* VALUES AS ISPF SHARED VARIABLES.                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
VITWHR   CSECT
         SAVE  (14,12),,VITWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING VITWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         XR    R0,R0
         ST    R0,ADPLCOM1         CLEAR XIPSWHR COMMUNICATION FIELD
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         MVI   VITPLACE,C' '
         MVC   VITPLACE+1(L'VITPLACE-1),VITPLACE
         MVI   VITNAME,C' '
         MVC   VITNAME+1(L'VITNAME-1),VITNAME
         MVI   VITLOC,C' '
         MVC   VITLOC+1(L'VITLOC-1),VITLOC
         MVI   VITOFF,C' '
         MVC   VITOFF+1(L'VITOFF-1),VITOFF
*
* SET VITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR
*
         MVC   VITPLACE(4),ADPLFMT1
         CLI   VITPLACE,C' '
         BE    VITERROR
         CLI   VITPLACE,C'E'
         BE    VITERRNP
         B     VITOK
VITERROR DS    0H                  ERROR - MODULE NOT FOUND
         MVC   VITPLACE(11),=C'UNAVAILABLE'
VITERRNP DS    0H                  STORAGE ERROR - RETAIN VITPLACE
         MVC   VITNAME(11),=C'UNAVAILABLE'
         MVC   VITLOC(11),=C'UNAVAILABLE'
         B     VITSET
VITOK    DS    0H
*
* SET VITNAME = THE NAME OF THE LOAD MODULE
*
         MVC   VITNAME(8),ADPLCOM1
*
* SET VITLOC = THE DECIMAL OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE
*
         L     R0,ADPLFMT2
         CVD   R0,DOUBLE
         UNPK  VITLOC(10),DOUBLE
         OI    VITLOC+9,X'F0'
*
* SET VITOFF = THE HEX OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE
*
         L     R0,ADPLFMT2
         ST    R0,DOUBLE
         UNPK  VITOFF(9),DOUBLE(5)
         TR    VITOFF(8),HEXTBL
         MVC   VITOFF+8(8),=CL8'         '
         LA    R1,VITOFF
         LA    R15,7
VOLOOP   DS    0H
         CLI   0(R1),C'0'
         BNE   VOLEND
         LA    R1,1(,R1)
         BCT   R15,VOLOOP
VOLEND   DS    0H
         MVC   VITOFF(8),0(R1)
         SPACE 1
VITSET   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* OK, NOW INVOKE ISPF DIALOG SERVICES TO SET THE THREE VALUES AS      *
* ISPF DIALOG VARIABLES.                                              *
*                                                                     *
***********************************************************************
         SPACE 1
         LOAD  EPLOC==CL8'ISPLINK'
         ST    R0,@ISPLINK
*
* ISPEXEC VDEFINE (VITNAME VITPLACE VITLOC VITOFF)
*
         LA    R1,=C'VDEFINE '
         ST    R1,ISPPARMS+0
         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'
         ST    R1,ISPPARMS+4
         LA    R1,VITPLACE
         ST    R1,ISPPARMS+8
         LA    R1,=C'CHAR '
         ST    R1,ISPPARMS+12
         LA    R1,=F'11'
         ST    R1,ISPPARMS+16
         OI    ISPPARMS+16,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VPUT (VITNAME VITPLACE VITLOC VITOFF) SHARED
*
         LA    R1,=C'VPUT    '
         ST    R1,ISPPARMS+0
         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'
         ST    R1,ISPPARMS+4
         LA    R1,=C'SHARED '
         ST    R1,ISPPARMS+8
         OI    ISPPARMS+8,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDELETE (VITNAME VITPLACE VITLOC VITOFF)
*
         LA    R1,=C'VDELETE '
         ST    R1,ISPPARMS+0
         LA    R1,=C'(VITPLACE VITNAME VITLOC VITOFF)'
         ST    R1,ISPPARMS+4
         OI    ISPPARMS+4,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* GOODBYE
*
         DELETE EPLOC==CL8'ISPLINK '
*
* RETURN TO CALLER
*
         B     RETURN0
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION
OUTSAVE  DS    A
         SPACE 1
@ISPLINK DS    A                   ADDRESS OF ISPLINK
ISPPARMS DS    6A                  PARMS FOR ISPLINK
         SPACE 1
VITPLACE DS    CL11                VALUE OF ISPF VARIABLE
VITNAME  DS    CL11                VALUE OF ISPF VARIABLE
VITLOC   DS    CL11                VALUE OF ISPF VARIABLE
VITOFF   DS    CL11                VALUE OF ISPF VARIABLE
         DS    CL8                 PADDING
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORK AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         IKJTSVT
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=VMCFTCP  0100-07332-07332-0900-01370-01370-00000-SEB
         TITLE 'VMCF     - Macros'
         MACRO
&SYM     TELL  &MSG,&MSGLEN
         LCLC  &L
&L       SETC  '&MSGLEN'
         AIF   ('&L' NE '').GOTLEN
&L       SETC  'L''&MSG'
.GOTLEN  ANOP
&SYM     LA    R1,&MSG
         LA    R0,&L
         TPUT  (1),(0),R
         MEND
         EJECT
         MACRO
&SYM     SHOWX &WHAT
&SYM     XR    R0,R0
         IC    R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(3),DOUBLE
         OI    NUMAREA+3-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(3),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+3
         MEND
         EJECT
         MACRO
&SYM     SHOWH &WHAT
&SYM     LH    R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(5),DOUBLE
         OI    NUMAREA+5-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(5),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+5
         MEND
         EJECT
         MACRO
&SYM     SHOWF &WHAT
&SYM     L     R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(11),DOUBLE
         OI    NUMAREA+11-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(11),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+11
         MEND
         EJECT
         MACRO
&SYM     SHOWC &WHAT,&HOWLONG
&SYM     MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),&WHAT
         TR    MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),TRTBL
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+&HOWLONG
         MEND
         EJECT
         TITLE 'VMCF     - Program to demonstrate TCP/IP via VMCF'
***********************************************************************
*                                                                     *
* VMCF     - Program to demonstrate TCP/IP via VMCF                   *
*                                                                     *
* Reference:                                                          *
*                                                                     *
*       TCP/IP Version 2 for MVS Programmer's Reference (SC31-6087-0) *
*       Chapter 5: Virtual Machine Communication Facility Interface   *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    VMCF CVT
R4       EQU   4    SSCT
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    Base register for Connection Information Record
R10      EQU   10   Static base register for interrupt routine
R11      EQU   11   Dynamic base register
R12      EQU   12   Static base register
R13      EQU   13   Save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
VMCF     CSECT
         SAVE  (14,12),,VMCF_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING VMCF,R12
         LR    R2,R1               Save input parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         LR    R11,R13
         USING DATD,R11
         LR    R1,R2               Restore input parameter address
         EJECT
         TELL  MSG_HELLO
         EJECT
*
***********************************************************************
*                                                                     *
* Locate the VMCF CVT by searching through subsystem control blocks   *
*                                                                     *
***********************************************************************
*
         L     R4,FLCCVT-PSA(0)          Get address of CVT
         L     R4,CVTJESCT-CVT(,R4)      Get address of JESCT
         ICM   R4,15,JESSSCT-JESCT(R4)   Get address of SSCT
         BZ    NOVMCF                    If none, error
         USING SSCT,R4
FINDVMCF DS    0H
         CLC   SSCTSNAM,=C'VMCF'
         BE    FOUNVMCF
         ICM   R4,15,SSCTSCTA
         BNZ   FINDVMCF
         B     NOVMCF
         SPACE 1
FOUNVMCF DS    0H
         TELL  MSG_VMCF_FOUND
         SPACE 1
         L     R3,SSCTSUSE         Get address of VMCF CVT
         USING MVPXVMCV,R3
         EJECT
*
***********************************************************************
*                                                                     *
* Initialize VMCF parameters.                                         *
*                                                                     *
***********************************************************************
*
         LA    R0,AREA_TO_CLEAR
         LA    R1,LENGTH_OF_AREA_TO_CLEAR
         XR    R14,R14
         XR    R15,R15
         MVCL  R0,R14              Clear entire dynamic area to zero
*
         ST    R11,TOKEN           Token = address of our work area
*
         LA    R14,VMCBLOK         Address of VMCBLOK
         LA    R15,IREP            Address of EP of routine to handle
*                                  simulated external interrupts
         LA    R0,TOKEN            Address of token
         STM   R14,R0,VMCFPARM     Build parameter list
         EJECT
*
***********************************************************************
*                                                                     *
* Start by issuing a VMCF AUTHORIZE call.                             *
*                                                                     *
***********************************************************************
*
         TELL  MSG_ISSUING_VMCF_AUTHORIZE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
*        MVI   V1,VMCPAUTS         Set AUTHORIZE flag in VMCBLOK
         MVI   V1,VMCFAUTHORIZESPECIFICFLAG
         LA    R0,VMCFAUTHORIZEFUNCTION
         STH   R0,FUNC             Set FUNC = AUTHORIZE
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* "Set Control Register Zero."                                        *
*                                                                     *
***********************************************************************
*
         TELL  MSG_SETTING_CONTROL_REGISTER_ZERO
         LA    R0,1                Desired control register 0 value
         BAL   R14,SETCR0          Issue the VMCF request
*
***********************************************************************
*                                                                     *
* "Set System Mask."                                                  *
*                                                                     *
***********************************************************************
*
         TELL  MSG_SETTING_SYSTEM_MASK
         LA    R0,1                Desired system mask value
         BAL   R14,SSM             Issue the VMCF request
*
***********************************************************************
*                                                                     *
* Begin TCP/IP Service.                                               *
*                                                                     *
***********************************************************************
*
         TELL  MSG_BEGIN_TCPIP_SERVICE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,BEGINTCPIPSERVICE
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* Specify the Notifications to Receive.                               *
*                                                                     *
***********************************************************************
*
         TELL  MSG_HANDLE_NOTICE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,HANDLENOTICE
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
*
* What the hell, ask for every damn notification.
*
* Slow code, but easier to read for brain-damaged IBM 370 assembler.
*
         XR    R0,R0
         A     R0,=A(MASKCONNECTIONSTATECHANGED)
         A     R0,=A(MASKDATADELIVERED)
         A     R0,=A(MASKBUFFERSPACEAVAILABLE)
         A     R0,=A(MASKCONNECTIONSTATECHANGED)
         A     R0,=A(MASKDATADELIVERED)
         A     R0,=A(MASKURGENTPENDING)
         A     R0,=A(MASKUDPDATAGRAMDELIVERED)
         A     R0,=A(MASKUDPDATAGRAMSPACEAVAILABLE)
         A     R0,=A(MASKRAWIPPACKETSDELIVERED)
         A     R0,=A(MASKRAWIPSPACEAVAILABLE)
         A     R0,=A(MASKRESOURCESAVAILABLE)
         A     R0,=A(MASKUDPRESOURCESAVAILABLE)
         A     R0,=A(MASKPINGRESPONSE)
         ST    R0,VADB             Set note mask
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* Fill in Connection Information Record with data about the           *
* connection we wish to establish.                                    *
*                                                                     *
* Get IP address and port number with which to communicate.           *
*                                                                     *
***********************************************************************
*
         LA    R9,CIRA
         USING CIR,R9
         MVC   CONNECTION,=Y(UNSPECIFIEDCONNECTION)
         MVC   OPENATTEMPTTIMEOUT,=A(DEFAULTOPENTIMEOUT)
         MVC   SECURITY,=Y(DEFAULTSECURITY)
         MVC   COMPARTMENT,=Y(DEFAULTCOMPARTMENT)
         MVI   PRECEDENCE,DEFAULTPRECEDENCE
         MVC   BYTESTOREAD,=F'0'
         MVC   UNACKEDBYTES,=F'0'
         MVI   CONNECTIONSTATE,TRYINGTOOPEN  "active open"
         MVC   LOCALSOCKET_ADDRESS,=A(UNSPECIFIEDADDRESS)
         MVC   LOCALSOCKET_PORT,=A(UNSPECIFIEDPORT)
         MVC   FOREIGNSOCKET_ADDRESS,YOUR_IP_ADDRESS
         MVC   FOREIGNSOCKET_PORT,YOUR_PORT
         DROP  R9
         B     AROUND_MY_AND_YOUR_CONSTANTS
         SPACE 1
MY_IP_ADDRESS    DC Y(140,102,4,1)     ip address for MVS
MY_PORT          DC H'25'              smtp
YOUR_IP_ADDRESS  DC Y(140,102,30,3)    ip address for support2
YOUR_PORT        DC H'25'              smtp
         SPACE 1
AROUND_MY_AND_YOUR_CONSTANTS DS 0H
*
***********************************************************************
*                                                                     *
* Open TCP Connection.                                                *
*                                                                     *
***********************************************************************
*
         TELL  MSG_OPEN_TCP
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,OPENTCP
         LA    R0,VMCFSENDRECEIVEFUNCTION
         STH   R0,FUNC             Set function code = SEND/RECV
         LH    R0,=Y(UNSPECIFIEDCONNECTION)
         STH   R0,CONN             Set connection type
         LA    R0,CIRA             Address of Connection Information
         ST    R0,VADA              Record initialized by me
         LA    R0,CIRB             Address of Connection Information
         ST    R0,VADB              Record for TCP/IP to fill in
         LA    R0,CIRLEN
         ST    R0,LENA             Length of Connection Information Rec
         LA    R0,CIRLEN
         ST    R0,LENB             Length of Connection Information Rec
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* Wait until the connection state is changed.                         *
*                                                                     *
***********************************************************************
*
         CLC   ECB(4),=F'0'
         BNE   NOWAIT
         TELL  MSG_WAITING_FOR_OPEN_TO_COMPLETE
         WAIT  ECB=ECB             Wait for response to external 'rupt
NOWAIT   DS    0H
*
***********************************************************************
*                                                                     *
* Show connection.                                                    *
*                                                                     *
***********************************************************************
*
         TELL  MSG_SHOWING_CIRA
         LA    R9,CIRA
         BAL   R14,SHOWCONN
         TELL  MSG_SHOWING_CIRB
         LA    R9,CIRB
         BAL   R14,SHOWCONN
*
***********************************************************************
*                                                                     *
* Close TCP Connection.                                               *
*                                                                     *
***********************************************************************
*
         TELL  MSG_CLOSE_TCP
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,CLOSETCP
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,CIRA             Address of Connection Information
         ST    R0,VADA              Record initialized by me
         LA    R0,CIRB             Address of Connection Information
         ST    R0,VADB              Record for TCP/IP to fill in
         LA    R0,CIRLEN
         ST    R0,LENA             Length of Connection Information Rec
         LA    R0,CIRLEN
         ST    R0,LENB             Length of Connection Information Rec
         LA    R9,CIRB             TCP-sent Connection Information Rec.
         USING CIR,R9
         LH    R0,CONNECTION       Get connection number
         DROP  R9
         STH   R0,CONN             Set connection number
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* End TCP/IP Service.                                                 *
*                                                                     *
***********************************************************************
*
         TELL  MSG_END_TCPIP_SERVICE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,ENDTCPIPSERVICE
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
* ... Expected response from TCP/IP:  VMCF REJECT function...
*
*
***********************************************************************
*                                                                     *
* End by issuing a VMCF UNAUTHORIZE call.                             *
*                                                                     *
***********************************************************************
*
         TELL  MSG_ISSUING_VMCF_UNAUTHORIZE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   V1,0
         LA    R0,VMCFUNAUTHORIZEFUNCTION
         STH   R0,FUNC             Set FUNC = UNAUTHORIZE
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
         EJECT
         B     RETURN0             Return with code 0
         EJECT
NOVMCF   DS    0H                  Cannot find VMCF subssytem
         SPACE 1
         TELL  MSG_NOVMCF
         B     RETURN12
         EJECT
RETURN12 DS    0H
         TELL  MSG_FAILED
         LA    R15,12              Set return code to 12
         B     RETURN
         SPACE 1
RETURN0  DS    0H
         TELL  MSG_GOODBY
         XR    R15,R15             Set return code to zero
         B     RETURN
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
IREP     DC    A(VMCFIR)           Address of routine to handle
*                                  simulated external interrupts
         EJECT
CALLVMCF DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine calls VMCF.  On entry it is assumed that VMCBLOK    *
* and TOKEN have been filled in appropriately.                        *
*                                                                     *
* The VMCF PC number is in the VMCF CVT field named PCVMCF.           *
*                                                                     *
***********************************************************************
*
*        MVI   RETCODE,X'FF'       See if RETCODE is really set
*
         MVC   JOBNAME,=CL8'TCPIP' Set jobname in VMCBLOK
         LA    R1,2                Increment global MSGID by 2
         A     R1,GMSGID           to keep it a unique even number
         ST    R1,GMSGID
         ST    R1,MSGID            Set MSGID in VMCBLOK
*
         XC    ECB,ECB             Clear ECB
*
         LA    R1,VMCFPARM         Point to parameter list
         ST    R14,CALLVMCF_R14    Save return address
         ESAR  R14                 Save secondary ASID
         STM   R14,R12,12(R13)     Save all registers
         L     R2,PCVMCF           Get PC number of VMCF interface
         PC    0(R2)               Call VMCF
         L     R14,12(,R13)        Get saved secondary ASID
         SSAR  R14                 Restore secondary ASID
         LM    R2,12,28(R13)       Restore rest of registers
         L     R14,CALLVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SETCR0   DS    0H
*
***********************************************************************
*                                                                     *
* This routine performs the fake "set control register 0" function.   *
* On entry, general register 0 contains the desired contents of       *
* the fake control register 0.                                        *
*                                                                     *
***********************************************************************
*
         ST    R0,CR0              Store desired control register data
         LA    R1,CR0              Get address thereof
         ST    R1,SETPARM1         Store into parameter list
         LA    R1,SETPARM          Point to parameter list
         ST    R14,CALLVMCF_R14    Save return address
         ESAR  R14                 Save secondary ASID
         STM   R14,R12,12(R13)     Save all registers
         L     R2,PCSETCR0         Get PC number of SETCR0 interface
         PC    0(R2)               Call VMCF
         L     R14,12(,R13)        Get saved secondary ASID
         SSAR  R14                 Restore secondary ASID
         LM    R2,12,28(R13)       Restore rest of registers
         L     R14,CALLVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SSM      DS    0H
*
***********************************************************************
*                                                                     *
* This routine performs the fake "set system mask" function.          *
* On entry, general register 0 contains the desired contents of       *
* the fake system mask.                                               *
*                                                                     *
***********************************************************************
*
         STC   R0,SYSMASK          Store desired system mask data
         LA    R1,SYSMASK          Get address thereof
         ST    R1,SETPARM1         Store into parameter list
         LA    R1,SETPARM          Point to parameter list
         ST    R14,CALLVMCF_R14    Save return address
         ESAR  R14                 Save secondary ASID
         STM   R14,R12,12(R13)     Save all registers
         L     R2,PCSSM            Get PC number of SSM interface
         PC    0(R2)               Call VMCF
         L     R14,12(,R13)        Get saved secondary ASID
         SSAR  R14                 Restore secondary ASID
         LM    R2,12,28(R13)       Restore rest of registers
         L     R14,CALLVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SHOWVMCF DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine displays the response from VMCF after a call.  It   *
* shows the contents of the control blocks after the call, not what   *
* happens when the simulated external interrupt routine gets control. *
*                                                                     *
***********************************************************************
*
         ST    R14,SHOWVMCF_R14    Save return address
         TELL  MSG_AFTER_CALL
         SHOWX RETCODE
         SHOWX V1
         SHOWX CALLCODE
         SHOWH CONN
         L     R14,SHOWVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SHOWCONN DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine displays fields from the Connection Information     *
* Record after a call, not what happens when the simulated external   *
* interrupt routine gets control.  On entry R9 must be set to the     *
* address of the Connection Information Record being displayed.       *
*                                                                     *
***********************************************************************
*
         ST    R14,SHOWCONN_R14    Save return address
         USING CIR,R9
         SHOWH CONNECTION
         SHOWX CONNECTIONSTATE
*
* Interpret connection state.
*
         MVI   TXTAREA,C' '
         MVC   TXTAREA+1(L'TXTAREA-1),TXTAREA
         CLI   CONNECTIONSTATE,CONNECTIONCLOSING
         BNE   NOT_CONNECTIONCLOSING
         MVC   TXTAREA(17),=C'CONNECTIONCLOSING'
         B     TELL_CONNECTIONSTATE
NOT_CONNECTIONCLOSING DS 0H
         CLI   CONNECTIONSTATE,LISTENING
         BNE   NOT_LISTENING
         MVC   TXTAREA(9),=C'LISTENING'
         B     TELL_CONNECTIONSTATE
NOT_LISTENING         DS 0H
         CLI   CONNECTIONSTATE,NONEXISTENT
         BNE   NOT_NONEXISTENT
         MVC   TXTAREA(11),=C'NONEXISTENT'
         B     TELL_CONNECTIONSTATE
NOT_NONEXISTENT       DS 0H
         CLI   CONNECTIONSTATE,OPEN
         BNE   NOT_OPEN
         MVC   TXTAREA(4),=C'OPEN'
         B     TELL_CONNECTIONSTATE
NOT_OPEN              DS 0H
         CLI   CONNECTIONSTATE,RECEIVINGONLY
         BNE   NOT_RECEIVINGONLY
         MVC   TXTAREA(13),=C'RECEIVINGONLY'
         B     TELL_CONNECTIONSTATE
NOT_RECEIVINGONLY     DS 0H
         CLI   CONNECTIONSTATE,SENDINGONLY
         BNE   NOT_SENDINGONLY
         MVC   TXTAREA(11),=C'SENDINGONLY'
         B     TELL_CONNECTIONSTATE
NOT_SENDINGONLY       DS 0H
         CLI   CONNECTIONSTATE,TRYINGTOOPEN
         BNE   NOT_TRYINGTOOPEN
         MVC   TXTAREA(12),=C'TRYINGTOOPEN'
         B     TELL_CONNECTIONSTATE
NOT_TRYINGTOOPEN      DS 0H
         MVC   TXTAREA(3),=C'???'
TELL_CONNECTIONSTATE  DS 0H
         TELL  TXTAREA
         DROP  R9
         L     R14,SHOWCONN_R14    Load return address
         BR    R14                 Return to caller
         EJECT
         DROP  R11,R12
         EJECT
VMCFIR   DS    0H
*
***********************************************************************
*                                                                     *
* This is the routine that handles simulated external interrupts,     *
* which is how TCP/IP passes information back to this program.        *
*                                                                     *
***********************************************************************
*
         STM   R14,R12,12(R13)
         LR    R10,R15
         USING VMCFIR,R10
         LM    R3,R4,0(R1)         R3 -> interrupt code, R4 ->  token
         L     R11,0(,R4)          Get token = work area address
         USING DATD,R11
         TELL  MSG_IR_CALLED
         LH    R5,0(,R3)           Interrupt code
         STH   R5,INTERRUPT_CODE
         SHOWH INTERRUPT_CODE
*
* Interpret interrupt code.
*
         MVI   TXTAREA,C' '
         MVC   TXTAREA+1(L'TXTAREA-1),TXTAREA
         CH    R5,=Y(TIMERINTERRUPTCODE)
         BNE   IRNOTTIMERINTERRUPTCODE
         MVC   TXTAREA(18),=C'TIMERINTERRUPTCODE'
         B     TELL_INTERRUPTCODE
IRNOTTIMERINTERRUPTCODE           DS 0H
         CH    R5,=Y(VMCFINTERRUPTCODE)
         BNE   IRNOTVMCFINTERRUPTCODE
         MVC   TXTAREA(17),=C'VMCFINTERRUPTCODE'
         B     TELL_INTERRUPTCODE
IRNOTVMCFINTERRUPTCODE            DS 0H
         CH    R5,=Y(IUCVINTERRUPTCODE)
         BNE   IRNOTIUCVINTERRUPTCODE
         MVC   TXTAREA(17),=C'IUCVINTERRUPTCODE'
         B     TELL_INTERRUPTCODE
IRNOTIUCVINTERRUPTCODE            DS 0H
         CH    R5,=Y(LDSFINTERRUPTCODE)
         BNE   IRNOTLDSFINTERRUPTCODE
         MVC   TXTAREA(17),=C'LDSFINTERRUPTCODE'
         B     TELL_INTERRUPTCODE
IRNOTLDSFINTERRUPTCODE            DS 0H
         CH    R5,=Y(INTERVALTIMERINTERRUPTCODE)
         BNE   IRNOTINTERVALTIMERINTERRUPTCODE
         MVC   TXTAREA(26),=C'INTERVALTIMERINTERRUPTCODE'
         B     TELL_INTERRUPTCODE
IRNOTINTERVALTIMERINTERRUPTCODE   DS 0H
         MVC   TXTAREA(1),=C'?'
TELL_INTERRUPTCODE DS 0H
*
* Show contents of VMCF interrupt header.
*
         TELL  MSG_SHOWING_INTERRUPT_HEADER
         SHOWX V1
         SHOWX V2
         SHOWH FUNC
         SHOWF MSGID
         SHOWC JOBNAME,8
         SHOWF ANINTEGR
         SHOWH CONN
         SHOWX CALLCODE
         SHOWX RETCODE
*
         POST  ECB                 Post ECB
*
         LM    R14,R12,12(R13)
         BR    R14                 Return to caller
         SPACE 1
         DROP  R10,R11
         EJECT
         LTORG
         EJECT
***********************************************************************
* Messages                                                            *
***********************************************************************
         SPACE 1
MSG_HELLO  DC  C'VMCF: Program demonstrating TCP/IP via VMCF interface'
MSG_GOODBY DC  C'VMCF: Completed.'
MSG_FAILED DC  C'VMCF: Terminated. '
MSG_NOVMCF DC  C'VMCF: Subsystem VMCF is not active or not found.'
MSG_VMCF_FOUND                    DC C'VMCF: Found VMCF subsystem.'
MSG_SETTING_CONTROL_REGISTER_ZERO DC C'VMCF: Setting control register zX
               ero to 1.'
MSG_SETTING_SYSTEM_MASK           DC C'VMCF: Setting system mask to 1.'
MSG_WAITING_FOR_OPEN_TO_COMPLETE  DC C'VMCF: Waiting for OPEN to compleX
               te.'
MSG_SHOWING_CIRA  DC C'VMCF: Showing Connection Information Record A.'
MSG_SHOWING_CIRB  DC C'VMCF: Showing Connection Information Record B.'
MSG_SHOWING_INTERRUPT_HEADER DC C'VMCF: Showing Interrupt Header.'
MSG_AFTER_CALL               DC C'VMCF: After call...'
MSG_SHOW_V1                  DC C'VMCF:             V1       = '
MSG_SHOW_V2                  DC C'VMCF:             V2       = '
MSG_SHOW_FUNC                DC C'VMCF:             FUNC     = '
MSG_SHOW_MSGID               DC C'VMCF:             MSGID    = '
MSG_SHOW_JOBNAME             DC C'VMCF:             JOBNAME  = '
MSG_SHOW_ANINTEGR            DC C'VMCF:             ANINTEGR = '
MSG_SHOW_CALLCODE            DC C'VMCF:             CALLCODE = '
MSG_SHOW_RETCODE             DC C'VMCF:             RETCODE  = '
MSG_SHOW_CONN                DC C'VMCF:             CONN     = '
MSG_SHOW_CONNECTION          DC C'VMCF: CIR Connection number = '
MSG_SHOW_CONNECTIONSTATE     DC C'VMCF: CIR Connection state  = '
MSG_ISSUING_VMCF_AUTHORIZE   DC C'VMCF: Issuing AUTHORIZE call.'
MSG_ISSUING_VMCF_UNAUTHORIZE DC C'VMCF: Issuing UNAUTHORIZE call.'
MSG_BEGIN_TCPIP_SERVICE      DC C'VMCF: Issuing BEGINtcpIPservice.'
MSG_END_TCPIP_SERVICE        DC C'VMCF: Issuing ENDtcpIPservice.'
MSG_HANDLE_NOTICE            DC C'VMCF: Issuing HANDLEnotice.'
MSG_OPEN_TCP                 DC C'VMCF: Issuing OPENtcp.'
MSG_CLOSE_TCP                DC C'VMCF: Issuing CLOSEtcp.'
MSG_IR_CALLED                DC C'VMCFIR: Interrupt routine called.'
MSG_SHOW_INTERRUPT_CODE      DC C'VMCFIR: Interrupt code:'
         EJECT
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
         SPACE 1
SAVEAREA DS    18F
         SPACE 1
AREA_TO_CLEAR EQU *
         SPACE 1
DOUBLE   DS    D                   For conversions
ECB      DS    F                   Event control block
GMSGID   DS    F                   Message ID for transaction tracking
CR0      DS    F                   Fake control register 0
SYSMASK  DS    X                   Fake system mask
CALLVMCF_R14 DS A                  Save area for CALLVMCF subroutine
SHOWVMCF_R14 DS A                  Save area for SHOWVMCF subroutine
SHOWCONN_R14 DS A                  Save area for SHOWCONN subroutine
         SPACE 1
VMCFPARM DS    3A                  VMCF parameter list
         ORG   VMCFPARM
PARM1    DS    A                   VMCF parm 1: address of VMCBLOK
PARM2    DS    A                   VMCF parm 2: address of EP of I.R.
PARM3    DS    A                   VMCF parm 3: address of token
         SPACE 1
SETPARM  DS    A                   Other parameter list
         ORG   SETPARM
SETPARM1 DS    A                   used by SETCR0 and SSM services
         SPACE 1
TOKEN    DS    D                   Token used by AUTHORIZE call
INTERRUPT_CODE DS H
NUMAREA  DS    CL12                Area for number conversion
TXTAREA  DS    CL64                Area for text
MSGAREA  DS    CL218               Area for message text
*
*----------------------------------------------------------------------
*
VMCBLOK  DS    0D                  VMCF parameter block
         ORG   VMCBLOK
V1       DS    X                   Out: Set to VMCPAUTS for AUTHORIZE
*                                  In:  May be VMCMRESP or VMCMRJCT
V2       DS    X                   Out: Must be zero
FUNC     DS    H
MSGID    DS    F                   Out: Unique even number for each
*                                       outstanding transaction
JOBNAME  DS    CL8                 Out: 'TCPIP' to talk to TCPIP
VADA     DS    A
LENA     DS    F
VADB     DS    A
LENB     DS    F
*
* User-doubleword field is divided into the following fields:
*
ANINTEGR DS    F
CONN     DS    H
CALLCODE DS    X                   In:  What I set if V1 = VMCMRESP
RETCODE  DS    X                   In:  Pascal return code
         SPACE 1
VMCBLOK_LEN EQU *-VMCBLOK
*
*----------------------------------------------------------------------
*
CIRA     DS    CL(CIRLEN)          Connection Information Record A
CIRB     DS    CL(CIRLEN)          Connection Information Record B
*
*----------------------------------------------------------------------
*
LENGTH_OF_AREA_TO_CLEAR EQU *-AREA_TO_CLEAR
         SPACE 1
SIZDATD  EQU   *-DATD              Length of dynamic work area
         EJECT
CIR      DSECT ,                   Map Connection Information Record
         SPACE 1
CONNECTION            DS  H
OPENATTEMPTTIMEOUT    DS  F
SECURITY              DS  H
COMPARTMENT           DS  H
PRECEDENCE            DS  X
BYTESTOREAD           DS  F
UNACKEDBYTES          DS  F
CONNECTIONSTATE       DS  X
LOCALSOCKET           DS  0F,3H
         ORG   LOCALSOCKET
LOCALSOCKET_ADDRESS   DS  F
LOCALSOCKET_PORT      DS  H
FOREIGNSOCKET         DS  0F,3H
         ORG   FOREIGNSOCKET
FOREIGNSOCKET_ADDRESS DS F
FOREIGNSOCKET_PORT    DS  H
         SPACE 1
CIRLEN   EQU   *-CIR
         EJECT
*
***********************************************************************
*                                                                     *
* Miscellaneous constants.                                            *
*                                                                     *
***********************************************************************
*
*
         EJECT
*
***********************************************************************
*                                                                     *
* Equates for the CALLCODE field.  These are listed in the manual,    *
* but I found it easier to extract them from 'TCPIP.COMMMAC(CMCOMM)'  *
* and convert the PASCAL declaration, adjusting the numbers to match  *
* the assembler EQU listing in the manual.                            *
*                                                                     *
***********************************************************************
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used by the program to initiate a function.       *
*                                                                     *
***********************************************************************
*
ABORTTCP          EQU  100
BEGINTCPIPSERVICE EQU  101
CLOSETCP          EQU  102
CLOSEUDP          EQU  103
ENDTCPIPSERVICE   EQU  104
HANDLENOTICE      EQU  105
ISHOSTLOCAL       EQU  106
MONITORCOMMAND    EQU  107
MONITORQUERY      EQU  108
NOCALL            EQU  109
OPENTCP           EQU  110
OPENUDP           EQU  111
RESERVEDCALL2     EQU  112
RECEIVETCP        EQU  113
RECEIVEUDP        EQU  114
NRECEIVEUDP       EQU  115
STATUSUDP         EQU  116
RESERVEDCALL3     EQU  117
SENDTCP           EQU  118
SENDUDP           EQU  119
STATUSTCP         EQU  120
FRECEIVETCP       EQU  121
FSENDTCP          EQU  122
CLOSERAWIP        EQU  123
OPENRAWIP         EQU  124
RECEIVERAWIP      EQU  125
SENDRAWIP         EQU  126
PINGREQ           EQU  127
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used by TCPIP to send a notification.             *
*                                                                     *
***********************************************************************
*                                                                     *
BUFFERSPACEAVAILABLE EQU 10
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a connection on which a TCP send        *
*               request was previously rejected due to insufficient   *
*               resources.                                            *
*                                                                     *
CONNECTIONSTATECHANGED EQU 11
*                                                                     *
*              This notification is given when a TCP connection       *
*              receives information from the network that causes      *
*              the state of the connection to change. Such changes    *
*              may arise when the remote client opens, closes, or     *
*              aborts the connection.                                 *
*                                                                     *
DATADELIVERED  EQU 12
*                                                                     *
*              This notification is given when the client buffer      *
*              indicated in an earlier TcpReceive request now         *
*              contains data.                                         *
*                                                                     *
USERDEFINEDNOTIFICATION EQU 13
*                                                                     *
*              For use by user-written programs.                      *
*                                                                     *
DATAGRAMSPACEAVAILABLE EQU 14
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a datagram on which an IP send request  *
*               was previously rejected due to insufficient resources *
*                                                                     *
URGENTPENDING  EQU 15
*                                                                     *
*              This notification is given when the TCP-IP service     *
*               is informed by the foreign site that there is         *
*               urgent data not yet delivered to the client.          *
*                                                                     *
UDPDATAGRAMDELIVERED EQU 16
*                                                                     *
*              This notification is given when the client buffer      *
*              indicated in an earlier UdpReceive request now         *
*              contains a  datagram.                                  *
*                                                                     *
UDPDATAGRAMSPACEAVAILABLE EQU 17
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a datagram on which an UDP send request *
*               was previously rejected due to insufficient resources *
*                                                                     *
EXTERNALINTERRUPT EQU 18
*                                                                     *
*              This special notification is returned when             *
*               a non-VMCF external interrupt arrives for             *
*               the client.  Typically, this external interrupt       *
*               will be CPexternalCOMMAND, and will be interpreted    *
*               by the client as a directive to commit suicide        *
*                                                                     *
USERDELIVERSLINE EQU 19
*                                                                     *
*              The user has entered a line of data at the terminal.   *
*                                                                     *
USERWANTSATTENTION EQU 20
*                                                                     *
*              The user has hit an attention key, such as a PF key.   *
*                                                                     *
TIMEREXPIRED EQU 21
*                                                                     *
*              A timer has expired                                    *
*                                                                     *
FSENDRESPONSE  EQU 22
*                                                                     *
*              Response has been received for TcpFSend call           *
*                                                                     *
FRECEIVEERROR  EQU 23
*                                                                     *
*              This notification is given when a TcpFReceive call     *
*              resulted in an error, instead of a DATAdelivered       *
*              notification.  Every TcpFReceive call will eventually  *
*              generate either DATAdelivered or RECEIVEerror.         *
*                                                                     *
RAWIPPACKETSDELIVERED EQU 24
*                                                                     *
*              This notification is given when the client buffer      *
*              indicated in an earlier RawIpReceive request now       *
*              contains data.                                         *
*                                                                     *
RAWIPSPACEAVAILABLE EQU 25
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a datagram on which a RawIpSend request *
*               was previously rejected due to insufficient resources *
*                                                                     *
IUCVINTERRUPT  EQU 26
*                                                                     *
*              This special notification is returned when a           *
*              IUCV external interrupt arrives for the client.        *
*                                                                     *
IOINTERRUPT EQU 27
*                                                                     *
*              This notification is given when an I/O interrupt       *
*              occurs on a device which the client program has        *
*              specified in a NotifyIo() call.                        *
*                                                                     *
RESOURCESAVAILABLE EQU 28
*                                                                     *
*              This notification is given to a client who previously  *
*              tried to do TcpOpen but got ZEROresources.  When       *
*              all resources necessary for open are available (TCB    *
*              and SCB plus incoming and outgoing data buffer),       *
*              this notice is given.                                  *
*                                                                     *
UDPRESOURCESAVAILABLE EQU 29
*                                                                     *
*              Similar to RESOURCESavailable, for UdpOpen.            *
*                                                                     *
PINGRESPONSE EQU 30
*                                                                     *
*              Sent when a ping response is received, or when the     *
*              request times out                                      *
*                                                                     *
SMSGRECEIVED EQU 31
*                                                                     *
*              Sent when a CP Special Message (SMSG) is received      *
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used for the connection states.                   *
*                                                                     *
***********************************************************************
*                                                                     *
CONNECTIONCLOSING EQU 0
*                                                                     *
*    Data may no longer be transmitted on this connection             *
*     since the TCP-IP service is in the process of closing           *
*     down the connection.                                            *
*                                                                     *
LISTENING         EQU 1
*                                                                     *
*    Waiting for a foreign site to open a connection.                 *
*                                                                     *
NONEXISTENT       EQU 2
*                                                                     *
*    The connection no longer exists.                                 *
*                                                                     *
OPEN              EQU 3
*                                                                     *
*    Data can go either way on the connection.                        *
*                                                                     *
RECEIVINGONLY     EQU 4
*                                                                     *
*    Data can be received but not sent on this connection,            *
*     because the client has done a one-way close.                    *
*                                                                     *
SENDINGONLY       EQU 5
*                                                                     *
*    Data can be sent out but not received on this                    *
*     connection.  This means that the foreign site has               *
*     done a one-way close.                                           *
*                                                                     *
TRYINGTOOPEN      EQU 6
*                                                                     *
*    Trying to contact a foreign site to establish                    *
*     a connection.                                                   *
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used for the notification mask in the             *
* HANDLEnotice call.                                                  *
*                                                                     *
***********************************************************************
*                                                                     *
MASKBUFFERSPACEAVAILABLE         EQU X'00000001'
MASKCONNECTIONSTATECHANGED       EQU X'00000002'
MASKDATADELIVERED                EQU X'00000004'
MASKURGENTPENDING                EQU X'00000020'
MASKUDPDATAGRAMDELIVERED         EQU X'00000040'
MASKUDPDATAGRAMSPACEAVAILABLE    EQU X'00000080'
MASKRAWIPPACKETSDELIVERED        EQU X'00004000'
MASKRAWIPSPACEAVAILABLE          EQU X'00008000'
MASKRESOURCESAVAILABLE           EQU X'00040000'
MASKUDPRESOURCESAVAILABLE        EQU X'00080000'
MASKPINGRESPONSE                 EQU X'00100000'
*
*
***********************************************************************
*                                                                     *
* We need to copy more equates from 'TCPIP.COMMMAC(CMCOMM)' because   *
* IBM did not provide documentation for everything.  So here goes...  *
* Some of these are in the manual, but I include everything.          *
*                                                                     *
***********************************************************************
*
DEFAULTSECURITY         EQU  0
DEFAULTCOMPARTMENT      EQU  0
DEFAULTPRECEDENCE       EQU  0
UNSPECIFIEDADDRESS      EQU  0
UNSPECIFIEDPORT         EQU  X'FFFF'
BROADCASTADDRESS        EQU  X'FFFFFFFF'
WAITFOREVER             EQU  2147483647   (MAXint)
*
DEFAULTOPENTIMEOUT      EQU  30
*
*    These are the return codes that the client might see as a result
*     of issuing an IP or TCP request.  They must be in the range
*     LOWerrorCODE .. HIGHerrorCODE.  HIGHerrorCODE = 0.
*
HIGHERRORCODE              EQU 0
LOWERRORCODE               EQU -128
OK                         EQU 0
ABNORMALCONDITION          EQU -1  { nonfatal VMCF error }
ALREADYCLOSING             EQU -2  { connection already closing }
BADLENGTHARGUMENT          EQU -3  { length parameter is invalid }
CANNOTSENDDATA             EQU -4
CLIENTRESTART              EQU -5
CONNECTIONALREADYEXISTS    EQU -6
DESTINATIONUNREACHABLE     EQU -7  { from remote site or gateway }
ERRORINPROFILE             EQU -8
FATALERROR                 EQU -9  { fatal VMCF error }
HASNOPASSWORD              EQU -10  { errors         }
INCORRECTPASSWORD          EQU -11  { ... in opening }
INVALIDREQUEST             EQU -12
INVALIDUSERID              EQU -13  { ... file       }
INVALIDVIRTUALADDRESS      EQU -14  { ... used       }
KILLEDBYCLIENT             EQU -15
LOCALPORTNOTAVAILABLE      EQU -16
MINIDISKINUSE              EQU -17  { ... by         }
MINIDISKNOTAVAILABLE       EQU -18  { ... MonCommand }
NOBUFFERSPACE              EQU -19
NOMOREINCOMINGDATA         EQU -20
NONLOCALADDRESS            EQU -21
NOOUTSTANDINGNOTIFICATIONS EQU -22
NOSUCHCONNECTION           EQU -23
NOTCPIPSERVICE             EQU -24
NOTYETBEGUN                EQU -25  { Client hasn't called BeginTcpIp}
NOTYETOPEN                 EQU -26  { Client hasn't called TcpOpen }
OPENREJECTED               EQU -27
PARAMLOCALADDRESS          EQU -28  { Invalid .....      }
PARAMSTATE                 EQU -29  { ... values...      }
PARAMTIMEOUT               EQU -30  { ... specified ...  }
PARAMUNSPECADDRESS         EQU -31  { ... in Connection  }
PARAMUNSPECPORT            EQU -32  { ..Information Record }
PROFILENOTFOUND            EQU -33
RECEIVESTILLPENDING        EQU -34
REMOTECLOSE                EQU -35  { Foreign client closing }
REMOTERESET                EQU -36
SOFTWAREERROR              EQU -37  { WISCNET software error }
TCPIPSHUTDOWN              EQU -38
TIMEOUTCONNECTION          EQU -39
TIMEOUTOPEN                EQU -40
TOOMANYOPENS               EQU -41
UNAUTHORIZEDUSER           EQU -43
UNEXPECTEDSYN              EQU -44
UNIMPLEMENTEDREQUEST       EQU -45
UNKNOWNHOST                EQU -46  { we lack info in our tables }
UNREACHABLENETWORK         EQU -47
UNSPECIFIEDCONNECTION      EQU -48
VIRTUALMEMORYTOOSMALL      EQU -49
WRONGSECORPRC              EQU -50  { wrong security or priority }
X25TOOCONGESTED            EQU -51  { no virtual circuits available }
YOUREND                    EQU -55
ZERORESOURCES              EQU -56
*
* UDP specific errors
*
UDPLOCALADDRESS            EQU -57  {Invalid local address}
UDPUNSPECADDRESS           EQU -59  {Unspecified local address}
UDPUNSPECPORT              EQU -60  {Unspecified local port}
UDPZERORESOURCES           EQU -61  {No space available to continue}
*
* New errors, not yet sorted alphabetically
*
FSENDSTILLPENDING          EQU -62  {TcpFSend is still outstanding }
*
* Error codes from FSD
*
HOSTMSGTOOBIG              EQU -63
CHANNELWRITEIOERR          EQU -64
UNKNOWNSENSEBYTE           EQU -65
SERIES1DOWN                EQU -71
IMPISDOWN                  EQU -72
HOSTDEAD                   EQU -73
BADIMPMSG                  EQU -74
HOSTNOTREADY               EQU -75
S1APPLNOTREADY             EQU -76
WRITEBUFFERREADY           EQU -77
LOOPX25ADDRESS             EQU -78
DROPPEDBYOPERATOR          EQU -79
ERROROPENINGORREADINGFILE  EQU -80
FILEFORMATINVALID          EQU -81
*
**********************************************************************
*                                                                    *
*                        Ip Datagram Section                         *
*                                                                    *
**********************************************************************
*
ANYCONNECTION     EQU UNSPECIFIEDCONNECTION
*
*     { This indicates that the request is to be done on any
*        connection. }
*
NOTIPNOTIFICATION EQU 0
*
*     { This is given in the Protocol field during an
*        asynchronous notification if the notification is not
*        relevant to a particular protocol other than TCP. }
*
ANYPROTOCOL       EQU 0 { Used as a Wild Card }
*
* The following definitions are used to describe an IP datagram.
* For more information, see RFC 791, pages 11 - 23. Due to the
* variable length of the options list, it is not declared as a
* separate field; the client is responsible for determining
* which characters in the data portion of the datagram are options.
*
MINIMUMIPHEADERSIZE EQU 20
*
*  { Implementation limits on the size of raw IP datagrams }
*
MAX512DATAGRAMSIZE   EQU 512
MAX512IPDATA         EQU MAX512DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX1024DATAGRAMSIZE  EQU 1024
MAX1024IPDATA        EQU MAX1024DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX2048DATAGRAMSIZE  EQU 2048
MAX2048IPDATA        EQU MAX2048DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX4096DATAGRAMSIZE  EQU 4096
MAX4096IPDATA        EQU MAX4096DATAGRAMSIZE-MINIMUMIPHEADERSIZE
*
*  { 8192 datagram is actually a little larger, to accommodate NFS.
*    NFS wants to send UDP data of 8K plus 200.  Add the UDP header
*    size, the IP header size, and 100 bytes for good measure. }
*
MAX8192DATAGRAMSIZE  EQU 8192+8+MINIMUMIPHEADERSIZE+200+100
MAX8192IPDATA        EQU MAX8192DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX16384DATAGRAMSIZE EQU 16384
MAX16384IPDATA       EQU MAX16384DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX32768DATAGRAMSIZE EQU 32768
MAX32768IPDATA       EQU MAX32768DATAGRAMSIZE-MINIMUMIPHEADERSIZE
*
* The possible flag bits:  (see RFC 791, page 13) }
*
IPMAYFRAGMENT        EQU 0
IPDONTFRAGMENT       EQU 16384 { Bit 1 of the halfword }
IPLASTFRAGMENT       EQU 0
IPMOREFRAGMENTS      EQU 8192 { Bit 2 of the halfword }
*
* The bit flags for the IP type-of-service field: RFC 791, p. 12 }
*
LOWDELAY             EQU 16
NORMALDELAY          EQU 0
HIGHTHROUGHPUT       EQU 8
NORMALTHROUGHPUT     EQU 0
HIGHRELIABILITY      EQU 4
NORMALRELIABILITY    EQU 0
*
* UDP header size }
*
UDPHEADERSIZE        EQU 8
*
* Max data returned on an old-style UdpReceive.  This number
* will never change. }
*
OLDSTYLEMAXUDPDATA   EQU 2040-MINIMUMIPHEADERSIZE-UDPHEADERSIZE
*
* Well known protocol numbers }
*
ICMPPROTOCOLNUMBER   EQU 1
TCPPROTOCOLNUMBER    EQU 6
UDPPROTOCOLNUMBER    EQU 17
*
* Maximum number of IP protocols }
*
IPPROTO_MAX       EQU 256  { Don't even think of changing this number }
*
DISABLEALLINTERRUPTS   EQU  X'00'
ENABLEALLINTERRUPTS    EQU  255  { a byte with every bit set to one }
FIXEDOVERFLOWMASK      EQU  X'08'
DECIMALOVERFLOWMASK    EQU  X'04'
EXPONENTUNDERFLOWMASK  EQU  X'02'
SIGNIFICANCEMASK       EQU  X'01'
LENGTHOFVIRTUALADDRESS EQU  4
LENGTHOFDISKLABEL      EQU  6
CPEXTERNALCOMMAND      EQU  X'40'
MESSAGENUMBERLIMIT     EQU  1000000000
*
*  { This limit is made smaller than necessary so
*     wrap-around arithmetic is easier. }
*
TIMERINTERRUPTCODE     EQU X'1004'
VMCFINTERRUPTCODE      EQU X'4001'
IUCVINTERRUPTCODE      EQU X'4000'
LDSFINTERRUPTCODE      EQU X'2402'
INTERVALTIMERINTERRUPTCODE EQU X'0080'
ANYOLDADDRESS          EQU 0
*
*  { These are all the possible VMCF function calls. }
*
VMCFAUTHORIZEFUNCTION   EQU X'0000'
VMCFUNAUTHORIZEFUNCTION EQU X'0001'
VMCFSENDFUNCTION        EQU X'0002'
VMCFSENDRECEIVEFUNCTION EQU X'0003'
VMCFSENDXFUNCTION       EQU X'0004'
VMCFRECEIVEFUNCTION     EQU X'0005'
VMCFCANCELFUNCTION      EQU X'0006'
VMCFREPLYFUNCTION       EQU X'0007'
VMCFQUIESCEFUNCTION     EQU X'0008'
VMCFRESUMEFUNCTION      EQU X'0009'
VMCFIDENTIFYFUNCTION    EQU X'000A'
VMCFREJECTFUNCTION      EQU X'000B'
*
*  { The IUCV function codes.  The ord of this enum type gives the
*    actual function code. }
*
IUCVQUERYFUNCTION       EQU   0
IUCVTESTMSGFUNCTION     EQU   1
IUCVRTRVBFRFUNCTION     EQU   2
IUCVDESCRIBEFUNCTION    EQU   3
IUCVSENDFUNCTION        EQU   4
IUCVRECEIVEFUNCTION     EQU   5
IUCVREPLYFUNCTION       EQU   6
IUCVTESTCMPLFUNCTION    EQU   7
IUCVREJECTFUNCTION      EQU   8
IUCVPURGEFUNCTION       EQU   9
IUCVACCEPTFUNCTION      EQU   10
IUCVCONNECTFUNCTION     EQU   11
IUCVDCLBFRFUNCTION      EQU   12
IUCVQUIESCEFUNCTION     EQU   13
IUCVRESUMEFUNCTION      EQU   14
IUCVSEVERFUNCTION       EQU   15
IUCVSETMASKFUNCTION     EQU   16
IUCVSETCMASKFUNCTION    EQU   17
*
* These are the IUCV external interrupt types
*
IUCVPENDINGCONNECTION     EQU X'01'
IUCVCONNECTIONCOMPLETE    EQU X'02'
IUCVSEVEREDCONNECTION     EQU X'03'
IUCVQUIESCEDCONNECTION    EQU X'04'
IUCVRESUMEDCONNECTION     EQU X'05'
IUCVINCOMINGPREPLY        EQU X'06'
IUCVINCOMINGREPLY         EQU X'07'
IUCVINCOMINGPMESSAGE      EQU X'08'
IUCVINCOMINGMESSAGE       EQU X'09'
*
*  { These are V1 flags for the authorize command. }
*
VMCFAUTHORIZESPECIFICFLAG EQU X'80'
VMCFPRIORITYFLAG          EQU X'40'
VMCFSMSGFLAG              EQU X'20'
*
*  { These are V1 flags for a Final Response Interrupt. }
*
VMCFFINALRESPONSECODE     EQU X'80'
VMCFREJECTRESPONSECODE    EQU X'40'
VMCFPRIORITYRESPONSECODE  EQU X'20'
MAXSMSGLENGTH             EQU 240  { Maximum SMSG data }
ANINTEGERFLAGREQUESTERR   EQU X'80000000'
*     { Used only when REJECTing FSENDtcp and FRECEIVEtcp calls }
IUCVADDRESSLISTSIZE       EQU 20
NOHOST EQU 0    { an always-invalid InternetAddress }
*
*    Because we use 0.0.0.0 as a flag meaning
*    'NO host', we assume that zero is never allowed as a
*    valid internet address. RFC 820 lists it as "reserved".
*
MAXWORDTYPELENGTH        EQU 100
MAXDESCRIPTORSETLENGTH   EQU 64
*
*
         EJECT
***********************************************************************
* Macro expansions                                                    *
***********************************************************************
*
* The following macro needs 'TCPIP.COMMMAC'.                    \
*
         MVPXVMCV ,                VMCF stuff
*
         PRINT NOGEN
*
         IEFJESCT
         IEFJSCVT
         CVT   DSECT=YES
         IHAPSA
*
         END
./ ADD NAME=VMCFUDP  0100-07332-07332-0900-01474-01474-00000-SEB
         TITLE 'VMCFUDP  - Macros'
         MACRO
&SYM     INTERP &TYPE,&FIELD
.*
.* example: INTERP H,FUNC,FOO,BAR,BAZ,FROB
.*
         LCLA  &I,&L,&LEN,&UNKL
         LCLC  &NUMVAL,&VAL,&UNK,&LABEL,&LABEND
         AIF   ('&TYPE' EQ 'F').F
         AIF   ('&TYPE' EQ 'H').H
         AIF   ('&TYPE' EQ 'C').C
         MNOTE 8,'Unknown type.  Use F, H, or C.'
         MEXIT
.F       ANOP
&SYM     L     R0,&FIELD
         AGO   .DOIT
.H       ANOP
&SYM     LH    R0,&FIELD
         AGO   .DOIT
.C       ANOP
&SYM     XR    R0,R0
         IC    R0,&FIELD
         AGO   .DOIT
.DOIT    ANOP
         MVI   TXTAREA,C' '
         MVC   TXTAREA+1(L'TXTAREA-1),TXTAREA
&I       SETA  3
&L       SETA  0
&LABEND  SETC  '$&SYSNDX'
&UNK     SETC  '&FIELD value is unrecognizable'
&UNKL    SETA  K'&UNK
.LOOP    ANOP
&L       SETA  &L+1
&LABEL   SETC  '@&SYSNDX&L'
         AIF   (&I GT N'&SYSLIST).ENDLOOP
&VAL     SETC  '&FIELD: &SYSLIST(&I)'
&NUMVAL  SETC  '&SYSLIST(&I)'
&LEN     SETA  K'&VAL
         C     R0,=A(&NUMVAL)
         BNE   &LABEL
         MVC   TXTAREA(&LEN),=C'&VAL'
         B     &LABEND
&LABEL   DS    0H
&I       SETA  &I+1
         AGO   .LOOP
.ENDLOOP ANOP
         MVC   TXTAREA(&UNKL),=C'&UNK'
&LABEND  DS    0H
         TELL  TXTAREA
         MEND
         MACRO
&SYM     TELL  &MSG,&MSGLEN
         LCLC  &L
&L       SETC  '&MSGLEN'
         AIF   ('&L' NE '').GOTLEN
&L       SETC  'L''&MSG'
.GOTLEN  ANOP
&SYM     LA    R1,&MSG
         LA    R0,&L
         TPUT  (1),(0),R
         MEND
         EJECT
         MACRO
&SYM     SHOWX &WHAT
&SYM     XR    R0,R0
         IC    R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(3),DOUBLE
         OI    NUMAREA+3-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(3),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+3
         MEND
         EJECT
         MACRO
&SYM     SHOWH &WHAT
&SYM     LH    R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(5),DOUBLE
         OI    NUMAREA+5-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(5),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+5
         MEND
         EJECT
         MACRO
&SYM     SHOWF &WHAT
&SYM     L     R0,&WHAT
         CVD   R0,DOUBLE
         UNPK  NUMAREA(11),DOUBLE
         OI    NUMAREA+11-1,X'F0'
         MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         LTR   R0,R0
         BNM   *+8
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C'-'
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(11),NUMAREA
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+11
         MEND
         EJECT
         MACRO
&SYM     SHOWC &WHAT,&HOWLONG
&SYM     MVC   MSGAREA(L'MSG_SHOW_&WHAT),MSG_SHOW_&WHAT
         MVI   MSGAREA+L'MSG_SHOW_&WHAT,C' '
         MVC   MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),&WHAT
         TR    MSGAREA+L'MSG_SHOW_&WHAT+1(&HOWLONG),TRTBL
         TELL  MSGAREA,L'MSG_SHOW_&WHAT+1+&HOWLONG
         MEND
         EJECT
         TITLE 'VMCFUDP  - Program to demonstrate TCP/IP UDP via VMCF'
***********************************************************************
*                                                                     *
* VMCFUDP  - Program to demonstrate TCP/IP UDP via VMCF               *
*                                                                     *
* Reference:                                                          *
*                                                                     *
*       TCP/IP Version 2 for MVS Programmer's Reference (SC31-6087-0) *
*       Chapter 5: Virtual Machine Communication Facility Interface   *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    VMCF CVT
R4       EQU   4    SSCT
R5       EQU   5    Miscellaneous data items
R6       EQU   6    Base register for Connection Information Record
R7       EQU   7    .
R8       EQU   8    Internal return address
R9       EQU   9    Yet another static base register
R10      EQU   10   Another static base register
R11      EQU   11   Dynamic base register
R12      EQU   12   Static base register
R13      EQU   13   Save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
VMCFUDP  CSECT
         SAVE  (14,12),,VMCFUDP_&SYSDATE._&SYSTIME
         LR    R12,R15
         LA    R10,4095(,R12)
         LA    R10,1(,R10)
         LA    R9,4095(,R10)
         LA    R9,1(,R9)
         USING VMCFUDP,R12,R10,R9
         LR    R2,R1               Save input parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         LR    R11,R13
         USING DATD,R11
         LR    R1,R2               Restore input parameter address
         ST    R12,SAVER12
         ST    R10,SAVER10
         ST    R9,SAVER9
         EJECT
         TELL  MSG_HELLO
         EJECT
*
***********************************************************************
*                                                                     *
* Locate the VMCF CVT by searching through subsystem control blocks   *
*                                                                     *
***********************************************************************
*
         L     R4,FLCCVT-PSA(0)          Get address of CVT
         L     R4,CVTJESCT-CVT(,R4)      Get address of JESCT
         ICM   R4,15,JESSSCT-JESCT(R4)   Get address of SSCT
         BZ    NOVMCF                    If none, error
         USING SSCT,R4
FINDVMCF DS    0H
         CLC   SSCTSNAM,=C'VMCF'
         BE    FOUNVMCF
         ICM   R4,15,SSCTSCTA
         BNZ   FINDVMCF
         B     NOVMCF
         SPACE 1
FOUNVMCF DS    0H
         TELL  MSG_VMCF_FOUND
         SPACE 1
         L     R3,SSCTSUSE         Get address of VMCF CVT
         USING MVPXVMCV,R3
         EJECT
*
***********************************************************************
*                                                                     *
* Initialize VMCF parameters.                                         *
*                                                                     *
***********************************************************************
*
         LA    R0,AREA_TO_CLEAR
         LA    R1,LENGTH_OF_AREA_TO_CLEAR
         XR    R14,R14
         XR    R15,R15
         MVCL  R0,R14              Clear entire dynamic area to zero
*
         ST    R11,TOKEN           Token = address of our work area
*
         LA    R14,VMCBLOK         Address of VMCBLOK
         LA    R15,IREP            Address of EP of routine to handle
*                                  simulated external interrupts
         LA    R0,TOKEN            Address of token
         STM   R14,R0,VMCFPARM     Build parameter list
         EJECT
*
***********************************************************************
*                                                                     *
* Start by issuing a VMCF AUTHORIZE call.                             *
*                                                                     *
***********************************************************************
*
         TELL  MSG_ISSUING_VMCF_AUTHORIZE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
*        MVI   V1,VMCPAUTS         Set AUTHORIZE flag in VMCBLOK
         MVI   V1,VMCFAUTHORIZESPECIFICFLAG
         LA    R0,VMCFAUTHORIZEFUNCTION
         STH   R0,FUNC             Set FUNC = AUTHORIZE
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* "Set Control Register Zero."                                        *
*                                                                     *
***********************************************************************
*
         TELL  MSG_SETTING_CONTROL_REGISTER_ZERO
         LA    R0,1                Desired control register 0 value
         BAL   R14,SETCR0          Issue the VMCF request
*
***********************************************************************
*                                                                     *
* "Set System Mask."                                                  *
*                                                                     *
***********************************************************************
*
         TELL  MSG_SETTING_SYSTEM_MASK
         LA    R0,1                Desired system mask value
         BAL   R14,SSM             Issue the VMCF request
*
***********************************************************************
*                                                                     *
* Begin TCP/IP Service.                                               *
*                                                                     *
***********************************************************************
*
         TELL  MSG_BEGIN_TCPIP_SERVICE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,BEGINTCPIPSERVICE
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* Specify the Notifications to Receive.                               *
*                                                                     *
***********************************************************************
*
         TELL  MSG_HANDLE_NOTICE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,HANDLENOTICE
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
*
* What the hell, ask for every damn notification.
*
* Slow code, but easier to read for brain-damaged IBM 370 assembler.
*
         XR    R0,R0
         A     R0,=A(MASKCONNECTIONSTATECHANGED)
         A     R0,=A(MASKDATADELIVERED)
         A     R0,=A(MASKBUFFERSPACEAVAILABLE)
         A     R0,=A(MASKCONNECTIONSTATECHANGED)
         A     R0,=A(MASKDATADELIVERED)
         A     R0,=A(MASKURGENTPENDING)
         A     R0,=A(MASKUDPDATAGRAMDELIVERED)
         A     R0,=A(MASKUDPDATAGRAMSPACEAVAILABLE)
         A     R0,=A(MASKRAWIPPACKETSDELIVERED)
         A     R0,=A(MASKRAWIPSPACEAVAILABLE)
         A     R0,=A(MASKRESOURCESAVAILABLE)
         A     R0,=A(MASKUDPRESOURCESAVAILABLE)
         A     R0,=A(MASKPINGRESPONSE)
         ST    R0,VADB             Set note mask
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* Open UDP Connection.                                                *
*                                                                     *
***********************************************************************
*
         B     AROUND_MY_AND_YOUR_CONSTANTS
         SPACE 1
         DS    0F
MY_IP_ADDRESS    DC Y(140,102,4,1)     ip address for MVS
MY_PORT          DC H'25'              smtp
YOUR_IP_ADDRESS  DC Y(140,102,30,3)    ip address for support2
YOUR_PORT        DC H'25'              smtp
         SPACE 1
AROUND_MY_AND_YOUR_CONSTANTS DS 0H
         SPACE 1
         TELL  MSG_OPEN_UDP
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,OPENUDP
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,ARBNUM
         STH   R0,CONN             Connection number:  An arbitrary
*                                  number, which your program will use
*                                  in subsequent actions involving
*                                  this port.
         LA    R0,0                Zero
         ST    R0,VADA
         LH    R0,MY_PORT          Local port number or UNSPECIFIEDport
         ST    R0,VADB              Record for TCP/IP to fill in
         LA    R0,1
         ST    R0,LENA             Length of zero
         L     R0,MY_IP_ADDRESS
         ST    R0,LENB             Local address
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* Show connection.                                                    *
*                                                                     *
***********************************************************************
*
         TELL  MSG_SHOWING_CIRA
         LA    R6,CIRA
         BAL   R14,SHOWCONN
         TELL  MSG_SHOWING_CIRB
         LA    R6,CIRB
         BAL   R14,SHOWCONN
*
***********************************************************************
*                                                                     *
* Close UDP Connection.                                               *
*                                                                     *
***********************************************************************
*
         TELL  MSG_CLOSE_UDP
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,CLOSEUDP
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,0
         ST    R0,VADA             Zero
         LA    R0,0
         ST    R0,VADB             Zero
         LA    R0,1
         ST    R0,LENA             One
         LA    R0,0
         ST    R0,LENB             Zero
         LA    R0,ARBNUM
         STH   R0,CONN             Connection number we opened with?
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
***********************************************************************
*                                                                     *
* End TCP/IP Service.                                                 *
*                                                                     *
***********************************************************************
*
         TELL  MSG_END_TCPIP_SERVICE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   CALLCODE,ENDTCPIPSERVICE
         LA    R0,VMCFSENDFUNCTION
         STH   R0,FUNC             Set function code = SEND
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
*
* ... Expected response from TCP/IP:  VMCF REJECT function...
*
*
***********************************************************************
*                                                                     *
* End by issuing a VMCF UNAUTHORIZE call.                             *
*                                                                     *
***********************************************************************
*
         TELL  MSG_ISSUING_VMCF_UNAUTHORIZE
         XC    VMCBLOK(VMCBLOK_LEN),VMCBLOK  Clear parameter block
         MVI   V1,0
         LA    R0,VMCFUNAUTHORIZEFUNCTION
         STH   R0,FUNC             Set FUNC = UNAUTHORIZE
         LA    R0,CIRA             Set address of
         ST    R0,VADA             Connection Information Record
         LA    R0,1
         ST    R0,LENA             Set LENA = 1
         BAL   R14,CALLVMCF        Issue the VMCF request
         BAL   R14,SHOWVMCF        Show VMCF response if any
         EJECT
         B     RETURN0             Return with code 0
         EJECT
NOVMCF   DS    0H                  Cannot find VMCF subssytem
         SPACE 1
         TELL  MSG_NOVMCF
         B     RETURN12
         EJECT
RETURN12 DS    0H
         TELL  MSG_FAILED
         LA    R15,12              Set return code to 12
         B     RETURN
         SPACE 1
RETURN0  DS    0H
         TELL  MSG_GOODBY
         XR    R15,R15             Set return code to zero
         B     RETURN
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
IREP     DC    A(VMCFIR)           Address of routine to handle
*                                  simulated external interrupts
         EJECT
CALLVMCF DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine calls VMCF.  On entry it is assumed that VMCBLOK    *
* and TOKEN have been filled in appropriately.                        *
*                                                                     *
* The VMCF PC number is in the VMCF CVT field named PCVMCF.           *
*                                                                     *
***********************************************************************
*
*        MVI   RETCODE,X'FF'       See if RETCODE is really set
*
         MVC   JOBNAME,=CL8'TCPIP' Set jobname in VMCBLOK
         LA    R1,2                Increment global MSGID by 2
         A     R1,GMSGID           to keep it a unique even number
         ST    R1,GMSGID
         ST    R1,MSGID            Set MSGID in VMCBLOK
*
         XC    ECB,ECB             Clear ECB
*
         LA    R1,VMCFPARM         Point to parameter list
         ST    R14,CALLVMCF_R14    Save return address
         ESAR  R14                 Save secondary ASID
         STM   R14,R12,12(R13)     Save all registers
         L     R2,PCVMCF           Get PC number of VMCF interface
         PC    0(R2)               Call VMCF
         L     R14,12(,R13)        Get saved secondary ASID
         SSAR  R14                 Restore secondary ASID
         LM    R2,12,28(R13)       Restore rest of registers
         L     R14,CALLVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SETCR0   DS    0H
*
***********************************************************************
*                                                                     *
* This routine performs the fake "set control register 0" function.   *
* On entry, general register 0 contains the desired contents of       *
* the fake control register 0.                                        *
*                                                                     *
***********************************************************************
*
         ST    R0,CR0              Store desired control register data
         LA    R1,CR0              Get address thereof
         ST    R1,SETPARM1         Store into parameter list
         LA    R1,SETPARM          Point to parameter list
         ST    R14,CALLVMCF_R14    Save return address
         ESAR  R14                 Save secondary ASID
         STM   R14,R12,12(R13)     Save all registers
         L     R2,PCSETCR0         Get PC number of SETCR0 interface
         PC    0(R2)               Call VMCF
         L     R14,12(,R13)        Get saved secondary ASID
         SSAR  R14                 Restore secondary ASID
         LM    R2,12,28(R13)       Restore rest of registers
         L     R14,CALLVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SSM      DS    0H
*
***********************************************************************
*                                                                     *
* This routine performs the fake "set system mask" function.          *
* On entry, general register 0 contains the desired contents of       *
* the fake system mask.                                               *
*                                                                     *
***********************************************************************
*
         STC   R0,SYSMASK          Store desired system mask data
         LA    R1,SYSMASK          Get address thereof
         ST    R1,SETPARM1         Store into parameter list
         LA    R1,SETPARM          Point to parameter list
         ST    R14,CALLVMCF_R14    Save return address
         ESAR  R14                 Save secondary ASID
         STM   R14,R12,12(R13)     Save all registers
         L     R2,PCSSM            Get PC number of SSM interface
         PC    0(R2)               Call VMCF
         L     R14,12(,R13)        Get saved secondary ASID
         SSAR  R14                 Restore secondary ASID
         LM    R2,12,28(R13)       Restore rest of registers
         L     R14,CALLVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SHOWVMCF DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine displays the response from VMCF after a call.  It   *
* shows the contents of the control blocks after the call, not what   *
* happens when the simulated external interrupt routine gets control. *
*                                                                     *
***********************************************************************
*
         ST    R14,SHOWVMCF_R14    Save return address
         TELL  MSG_AFTER_CALL
         SHOWX RETCODE
         BAL   R8,INTERPRET_RETCODE
         SHOWX V1
         SHOWX CALLCODE
         BAL   R8,INTERPRET_CALLCODE
         SHOWH CONN
         L     R14,SHOWVMCF_R14    Load return address
         BR    R14                 Return to caller
         EJECT
SHOWCONN DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine displays fields from the Connection Information     *
* Record after a call, not what happens when the simulated external   *
* interrupt routine gets control.  On entry R6 must be set to the     *
* address of the Connection Information Record being displayed.       *
*                                                                     *
***********************************************************************
*
         ST    R14,SHOWCONN_R14    Save return address
         USING CIR,R6
         SHOWH CONNECTION
         SHOWX CONNECTIONSTATE
         BAL   R8,INTERPRET_CONNECTIONSTATE
         DROP  R6
         L     R14,SHOWCONN_R14    Load return address
         BR    R14                 Return to caller
         EJECT
         DROP  R9,R10,R11,R12
         EJECT
VMCFIR   DS    0H
*
***********************************************************************
*                                                                     *
* This is the routine that handles simulated external interrupts,     *
* which is how TCP/IP passes information back to this program.        *
*                                                                     *
***********************************************************************
*
         STM   R14,R12,12(R13)
         LM    R3,R4,0(R1)         R3 -> interrupt code, R4 ->  token
         L     R11,0(,R4)          Get token = work area address
         USING DATD,R11
         L     R12,SAVER12
         L     R10,SAVER10
         L     R9,SAVER9
         USING VMCFUDP,R12,R10,R9
         TELL  MSG_IR_CALLED
         LH    R5,0(,R3)           Interrupt code
         STH   R5,INTERRUPT_CODE
         SHOWH INTERRUPT_CODE
         BAL   R8,INTERPRET_INTERRUPT_CODE
         TELL  MSG_SHOWING_INTERRUPT_HEADER
         SHOWX V1
         SHOWX V2
         SHOWH FUNC
         BAL   R8,INTERPRET_FUNC
         SHOWF MSGID
         SHOWC JOBNAME,8
         SHOWF ANINTEGR
         SHOWH CONN
         SHOWX CALLCODE
         BAL   R8,INTERPRET_CALLCODE
         SHOWX RETCODE
         BAL   R8,INTERPRET_RETCODE
*
         POST  ECB                 Post ECB
*
         LM    R14,R12,12(R13)
         BR    R14                 Return to caller
         EJECT
INTERPRET_CONNECTIONSTATE DS 0H
         USING CIR,R6
         INTERP C,CONNECTIONSTATE,                                     X
               CONNECTIONCLOSING,                                      X
               LISTENING,                                              X
               NONEXISTENT,                                            X
               OPEN,                                                   X
               RECEIVINGONLY,                                          X
               SENDINGONLY,                                            X
               TRYINGTOOPEN
         BR    R8
         DROP  R6
*
INTERPRET_INTERRUPT_CODE DS 0H
         INTERP H,INTERRUPT_CODE,                                      X
               TIMERINTERRUPTCODE,                                     X
               VMCFINTERRUPTCODE,                                      X
               IUCVINTERRUPTCODE,                                      X
               LDSFINTERRUPTCODE,                                      X
               INTERVALTIMERINTERRUPTCODE
         BR    R8
*
INTERPRET_FUNC DS 0H
         INTERP H,FUNC,                                                X
               VMCFAUTHORIZEFUNCTION,                                  X
               VMCFUNAUTHORIZEFUNCTION,                                X
               VMCFSENDFUNCTION,                                       X
               VMCFSENDRECEIVEFUNCTION,                                X
               VMCFSENDXFUNCTION,                                      X
               VMCFRECEIVEFUNCTION,                                    X
               VMCFCANCELFUNCTION,                                     X
               VMCFREPLYFUNCTION,                                      X
               VMCFQUIESCEFUNCTION,                                    X
               VMCFRESUMEFUNCTION,                                     X
               VMCFIDENTIFYFUNCTION,                                   X
               VMCFREJECTFUNCTION
         BR    R8
*
INTERPRET_RETCODE DS 0H
         INTERP C,RETCODE,                                             X
               OK,                                                     X
               ABNORMALCONDITION,                                      X
               ALREADYCLOSING,                                         X
               BADLENGTHARGUMENT,                                      X
               CANNOTSENDDATA,                                         X
               CLIENTRESTART,                                          X
               CONNECTIONALREADYEXISTS,                                X
               DESTINATIONUNREACHABLE,                                 X
               ERRORINPROFILE,                                         X
               FATALERROR,                                             X
               HASNOPASSWORD,                                          X
               INCORRECTPASSWORD,                                      X
               INVALIDREQUEST,                                         X
               INVALIDUSERID,                                          X
               INVALIDVIRTUALADDRESS,                                  X
               KILLEDBYCLIENT,                                         X
               LOCALPORTNOTAVAILABLE,                                  X
               MINIDISKINUSE,                                          X
               MINIDISKNOTAVAILABLE,                                   X
               NOBUFFERSPACE,                                          X
               NOMOREINCOMINGDATA,                                     X
               NONLOCALADDRESS,                                        X
               NOOUTSTANDINGNOTIFICATIONS,                             X
               NOSUCHCONNECTION,                                       X
               NOTCPIPSERVICE,                                         X
               NOTYETBEGUN,                                            X
               NOTYETOPEN,                                             X
               OPENREJECTED,                                           X
               PARAMLOCALADDRESS,                                      X
               PARAMSTATE,                                             X
               PARAMTIMEOUT,                                           X
               PARAMUNSPECADDRESS,                                     X
               PARAMUNSPECPORT,                                        X
               PROFILENOTFOUND,                                        X
               RECEIVESTILLPENDING,                                    X
               REMOTECLOSE,                                            X
               REMOTERESET,                                            X
               SOFTWAREERROR,                                          X
               TCPIPSHUTDOWN,                                          X
               TIMEOUTCONNECTION,                                      X
               TIMEOUTOPEN,                                            X
               TOOMANYOPENS,                                           X
               UNAUTHORIZEDUSER,                                       X
               UNEXPECTEDSYN,                                          X
               UNIMPLEMENTEDREQUEST,                                   X
               UNKNOWNHOST,                                            X
               UNREACHABLENETWORK,                                     X
               UNSPECIFIEDCONNECTION,                                  X
               VIRTUALMEMORYTOOSMALL,                                  X
               WRONGSECORPRC,                                          X
               X25TOOCONGESTED,                                        X
               YOUREND,                                                X
               ZERORESOURCES,                                          X
               UDPLOCALADDRESS,                                        X
               UDPUNSPECADDRESS,                                       X
               UDPUNSPECPORT,                                          X
               UDPZERORESOURCES,                                       X
               FSENDSTILLPENDING,                                      X
               HOSTMSGTOOBIG,                                          X
               CHANNELWRITEIOERR,                                      X
               UNKNOWNSENSEBYTE,                                       X
               SERIES1DOWN,                                            X
               IMPISDOWN,                                              X
               HOSTDEAD,                                               X
               BADIMPMSG,                                              X
               HOSTNOTREADY,                                           X
               S1APPLNOTREADY,                                         X
               WRITEBUFFERREADY,                                       X
               LOOPX25ADDRESS,                                         X
               DROPPEDBYOPERATOR,                                      X
               ERROROPENINGORREADINGFILE,                              X
               FILEFORMATINVALID
         BR    R8
*
INTERPRET_CALLCODE DS 0H
         INTERP C,CALLCODE,                                            X
               ABORTTCP,                                               X
               BEGINTCPIPSERVICE,                                      X
               CLOSETCP,                                               X
               CLOSEUDP,                                               X
               ENDTCPIPSERVICE,                                        X
               HANDLENOTICE,                                           X
               ISHOSTLOCAL,                                            X
               MONITORCOMMAND,                                         X
               MONITORQUERY,                                           X
               NOCALL,                                                 X
               OPENTCP,                                                X
               OPENUDP,                                                X
               RESERVEDCALL2,                                          X
               RECEIVETCP,                                             X
               RECEIVEUDP,                                             X
               NRECEIVEUDP,                                            X
               STATUSUDP,                                              X
               RESERVEDCALL3,                                          X
               SENDTCP,                                                X
               SENDUDP,                                                X
               STATUSTCP,                                              X
               FRECEIVETCP,                                            X
               FSENDTCP,                                               X
               CLOSERAWIP,                                             X
               OPENRAWIP,                                              X
               RECEIVERAWIP,                                           X
               SENDRAWIP,                                              X
               PINGREQ
         BR    R8
         EJECT
         DROP  R11
         EJECT
         LTORG
         EJECT
***********************************************************************
* Messages                                                            *
***********************************************************************
         SPACE 1
MSG_HELLO  DC  C'VMCF: Program demonstrating TCP/IP via VMCF interface'
MSG_GOODBY DC  C'VMCF: Completed.'
MSG_FAILED DC  C'VMCF: Terminated. '
MSG_NOVMCF DC  C'VMCF: Subsystem VMCF is not active or not found.'
MSG_VMCF_FOUND                    DC C'VMCF: Found VMCF subsystem.'
MSG_SETTING_CONTROL_REGISTER_ZERO DC C'VMCF: Setting control register zX
               ero to 1.'
MSG_SETTING_SYSTEM_MASK           DC C'VMCF: Setting system mask to 1.'
MSG_WAITING_FOR_OPEN_TO_COMPLETE  DC C'VMCF: Waiting for OPEN to compleX
               te.'
MSG_SHOWING_CIRA  DC C'VMCF: Showing Connection Information Record A.'
MSG_SHOWING_CIRB  DC C'VMCF: Showing Connection Information Record B.'
MSG_SHOWING_INTERRUPT_HEADER DC C'VMCF: Showing Interrupt Header.'
MSG_AFTER_CALL               DC C'VMCF: After call...'
MSG_SHOW_V1                  DC C'VMCF:             V1       = '
MSG_SHOW_V2                  DC C'VMCF:             V2       = '
MSG_SHOW_FUNC                DC C'VMCF:             FUNC     = '
MSG_SHOW_MSGID               DC C'VMCF:             MSGID    = '
MSG_SHOW_JOBNAME             DC C'VMCF:             JOBNAME  = '
MSG_SHOW_ANINTEGR            DC C'VMCF:             ANINTEGR = '
MSG_SHOW_CALLCODE            DC C'VMCF:             CALLCODE = '
MSG_SHOW_RETCODE             DC C'VMCF:             RETCODE  = '
MSG_SHOW_CONN                DC C'VMCF:             CONN     = '
MSG_SHOW_CONNECTION          DC C'VMCF: CIR Connection number = '
MSG_SHOW_CONNECTIONSTATE     DC C'VMCF: CIR Connection state  = '
MSG_ISSUING_VMCF_AUTHORIZE   DC C'VMCF: Issuing AUTHORIZE call.'
MSG_ISSUING_VMCF_UNAUTHORIZE DC C'VMCF: Issuing UNAUTHORIZE call.'
MSG_BEGIN_TCPIP_SERVICE      DC C'VMCF: Issuing BEGINtcpIPservice.'
MSG_END_TCPIP_SERVICE        DC C'VMCF: Issuing ENDtcpIPservice.'
MSG_HANDLE_NOTICE            DC C'VMCF: Issuing HANDLEnotice.'
MSG_OPEN_UDP                 DC C'VMCF: Issuing OPENudp.'
MSG_CLOSE_UDP                DC C'VMCF: Issuing CLOSEudp.'
MSG_IR_CALLED                DC C'VMCFIR: Interrupt routine called.'
MSG_SHOW_INTERRUPT_CODE      DC C'VMCFIR: Interrupt code:'
         EJECT
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ...........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
         SPACE 1
SAVEAREA DS    18F
         SPACE 1
SAVER12  DS    F
SAVER10  DS    F
SAVER9   DS    F
         SPACE 1
AREA_TO_CLEAR EQU *
         SPACE 1
DOUBLE   DS    D                   For conversions
ECB      DS    F                   Event control block
GMSGID   DS    F                   Message ID for transaction tracking
CR0      DS    F                   Fake control register 0
SYSMASK  DS    X                   Fake system mask
CALLVMCF_R14 DS A                  Save area for CALLVMCF subroutine
SHOWVMCF_R14 DS A                  Save area for SHOWVMCF subroutine
SHOWCONN_R14 DS A                  Save area for SHOWCONN subroutine
         SPACE 1
VMCFPARM DS    3A                  VMCF parameter list
         ORG   VMCFPARM
PARM1    DS    A                   VMCF parm 1: address of VMCBLOK
PARM2    DS    A                   VMCF parm 2: address of EP of I.R.
PARM3    DS    A                   VMCF parm 3: address of token
         SPACE 1
SETPARM  DS    A                   Other parameter list
         ORG   SETPARM
SETPARM1 DS    A                   used by SETCR0 and SSM services
         SPACE 1
TOKEN    DS    D                   Token used by AUTHORIZE call
INTERRUPT_CODE DS H
NUMAREA  DS    CL12                Area for number conversion
TXTAREA  DS    CL64                Area for text
MSGAREA  DS    CL218               Area for message text
*
*----------------------------------------------------------------------
*
VMCBLOK  DS    0D                  VMCF parameter block
         ORG   VMCBLOK
V1       DS    X                   Out: Set to VMCPAUTS for AUTHORIZE
*                                  In:  May be VMCMRESP or VMCMRJCT
V2       DS    X                   Out: Must be zero
FUNC     DS    H
MSGID    DS    F                   Out: Unique even number for each
*                                       outstanding transaction
JOBNAME  DS    CL8                 Out: 'TCPIP' to talk to TCPIP
VADA     DS    A
LENA     DS    F
VADB     DS    A
LENB     DS    F
*
* User-doubleword field is divided into the following fields:
*
ANINTEGR DS    F
CONN     DS    H
CALLCODE DS    X                   In:  What I set if V1 = VMCMRESP
RETCODE  DS    X                   In:  Pascal return code
         SPACE 1
VMCBLOK_LEN EQU *-VMCBLOK
*
*----------------------------------------------------------------------
*
CIRA     DS    CL(CIRLEN)          Connection Information Record A
CIRB     DS    CL(CIRLEN)          Connection Information Record B
*
*----------------------------------------------------------------------
*
LENGTH_OF_AREA_TO_CLEAR EQU *-AREA_TO_CLEAR
         SPACE 1
SIZDATD  EQU   *-DATD              Length of dynamic work area
         EJECT
ARBNUM   EQU   1                   Arbitrary connection number
         EJECT
CIR      DSECT ,                   Map Connection Information Record
         SPACE 1
CONNECTION            DS  H
OPENATTEMPTTIMEOUT    DS  F
SECURITY              DS  H
COMPARTMENT           DS  H
PRECEDENCE            DS  X
BYTESTOREAD           DS  F
UNACKEDBYTES          DS  F
CONNECTIONSTATE       DS  X
LOCALSOCKET           DS  0F,3H
         ORG   LOCALSOCKET
LOCALSOCKET_ADDRESS   DS  F
LOCALSOCKET_PORT      DS  H
FOREIGNSOCKET         DS  0F,3H
         ORG   FOREIGNSOCKET
FOREIGNSOCKET_ADDRESS DS F
FOREIGNSOCKET_PORT    DS  H
         SPACE 1
CIRLEN   EQU   *-CIR
         EJECT
*
***********************************************************************
*                                                                     *
* Miscellaneous constants.                                            *
*                                                                     *
***********************************************************************
*
*
         EJECT
*
***********************************************************************
*                                                                     *
* Equates for the CALLCODE field.  These are listed in the manual,    *
* but I found it easier to extract them from 'TCPIP.COMMMAC(CMCOMM)'  *
* and convert the PASCAL declaration, adjusting the numbers to match  *
* the assembler EQU listing in the manual.                            *
*                                                                     *
***********************************************************************
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used by the program to initiate a function.       *
*                                                                     *
***********************************************************************
*
ABORTTCP          EQU  100
BEGINTCPIPSERVICE EQU  101
CLOSETCP          EQU  102
CLOSEUDP          EQU  103
ENDTCPIPSERVICE   EQU  104
HANDLENOTICE      EQU  105
ISHOSTLOCAL       EQU  106
MONITORCOMMAND    EQU  107
MONITORQUERY      EQU  108
NOCALL            EQU  109
OPENTCP           EQU  110
OPENUDP           EQU  111
RESERVEDCALL2     EQU  112
RECEIVETCP        EQU  113
RECEIVEUDP        EQU  114
NRECEIVEUDP       EQU  115
STATUSUDP         EQU  116
RESERVEDCALL3     EQU  117
SENDTCP           EQU  118
SENDUDP           EQU  119
STATUSTCP         EQU  120
FRECEIVETCP       EQU  121
FSENDTCP          EQU  122
CLOSERAWIP        EQU  123
OPENRAWIP         EQU  124
RECEIVERAWIP      EQU  125
SENDRAWIP         EQU  126
PINGREQ           EQU  127
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used by TCPIP to send a notification.             *
*                                                                     *
***********************************************************************
*                                                                     *
BUFFERSPACEAVAILABLE EQU 10
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a connection on which a TCP send        *
*               request was previously rejected due to insufficient   *
*               resources.                                            *
*                                                                     *
CONNECTIONSTATECHANGED EQU 11
*                                                                     *
*              This notification is given when a TCP connection       *
*              receives information from the network that causes      *
*              the state of the connection to change. Such changes    *
*              may arise when the remote client opens, closes, or     *
*              aborts the connection.                                 *
*                                                                     *
DATADELIVERED  EQU 12
*                                                                     *
*              This notification is given when the client buffer      *
*              indicated in an earlier TcpReceive request now         *
*              contains data.                                         *
*                                                                     *
USERDEFINEDNOTIFICATION EQU 13
*                                                                     *
*              For use by user-written programs.                      *
*                                                                     *
DATAGRAMSPACEAVAILABLE EQU 14
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a datagram on which an IP send request  *
*               was previously rejected due to insufficient resources *
*                                                                     *
URGENTPENDING  EQU 15
*                                                                     *
*              This notification is given when the TCP-IP service     *
*               is informed by the foreign site that there is         *
*               urgent data not yet delivered to the client.          *
*                                                                     *
UDPDATAGRAMDELIVERED EQU 16
*                                                                     *
*              This notification is given when the client buffer      *
*              indicated in an earlier UdpReceive request now         *
*              contains a  datagram.                                  *
*                                                                     *
UDPDATAGRAMSPACEAVAILABLE EQU 17
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a datagram on which an UDP send request *
*               was previously rejected due to insufficient resources *
*                                                                     *
EXTERNALINTERRUPT EQU 18
*                                                                     *
*              This special notification is returned when             *
*               a non-VMCF external interrupt arrives for             *
*               the client.  Typically, this external interrupt       *
*               will be CPexternalCOMMAND, and will be interpreted    *
*               by the client as a directive to commit suicide        *
*                                                                     *
USERDELIVERSLINE EQU 19
*                                                                     *
*              The user has entered a line of data at the terminal.   *
*                                                                     *
USERWANTSATTENTION EQU 20
*                                                                     *
*              The user has hit an attention key, such as a PF key.   *
*                                                                     *
TIMEREXPIRED EQU 21
*                                                                     *
*              A timer has expired                                    *
*                                                                     *
FSENDRESPONSE  EQU 22
*                                                                     *
*              Response has been received for TcpFSend call           *
*                                                                     *
FRECEIVEERROR  EQU 23
*                                                                     *
*              This notification is given when a TcpFReceive call     *
*              resulted in an error, instead of a DATAdelivered       *
*              notification.  Every TcpFReceive call will eventually  *
*              generate either DATAdelivered or RECEIVEerror.         *
*                                                                     *
RAWIPPACKETSDELIVERED EQU 24
*                                                                     *
*              This notification is given when the client buffer      *
*              indicated in an earlier RawIpReceive request now       *
*              contains data.                                         *
*                                                                     *
RAWIPSPACEAVAILABLE EQU 25
*                                                                     *
*              This notification is given when buffer space becomes   *
*               available for a datagram on which a RawIpSend request *
*               was previously rejected due to insufficient resources *
*                                                                     *
IUCVINTERRUPT  EQU 26
*                                                                     *
*              This special notification is returned when a           *
*              IUCV external interrupt arrives for the client.        *
*                                                                     *
IOINTERRUPT EQU 27
*                                                                     *
*              This notification is given when an I/O interrupt       *
*              occurs on a device which the client program has        *
*              specified in a NotifyIo() call.                        *
*                                                                     *
RESOURCESAVAILABLE EQU 28
*                                                                     *
*              This notification is given to a client who previously  *
*              tried to do TcpOpen but got ZEROresources.  When       *
*              all resources necessary for open are available (TCB    *
*              and SCB plus incoming and outgoing data buffer),       *
*              this notice is given.                                  *
*                                                                     *
UDPRESOURCESAVAILABLE EQU 29
*                                                                     *
*              Similar to RESOURCESavailable, for UdpOpen.            *
*                                                                     *
PINGRESPONSE EQU 30
*                                                                     *
*              Sent when a ping response is received, or when the     *
*              request times out                                      *
*                                                                     *
SMSGRECEIVED EQU 31
*                                                                     *
*              Sent when a CP Special Message (SMSG) is received      *
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used for the connection states.                   *
*                                                                     *
***********************************************************************
*                                                                     *
CONNECTIONCLOSING EQU 0
*                                                                     *
*    Data may no longer be transmitted on this connection             *
*     since the TCP-IP service is in the process of closing           *
*     down the connection.                                            *
*                                                                     *
LISTENING         EQU 1
*                                                                     *
*    Waiting for a foreign site to open a connection.                 *
*                                                                     *
NONEXISTENT       EQU 2
*                                                                     *
*    The connection no longer exists.                                 *
*                                                                     *
OPEN              EQU 3
*                                                                     *
*    Data can go either way on the connection.                        *
*                                                                     *
RECEIVINGONLY     EQU 4
*                                                                     *
*    Data can be received but not sent on this connection,            *
*     because the client has done a one-way close.                    *
*                                                                     *
SENDINGONLY       EQU 5
*                                                                     *
*    Data can be sent out but not received on this                    *
*     connection.  This means that the foreign site has               *
*     done a one-way close.                                           *
*                                                                     *
TRYINGTOOPEN      EQU 6
*                                                                     *
*    Trying to contact a foreign site to establish                    *
*     a connection.                                                   *
*                                                                     *
*                                                                     *
***********************************************************************
*                                                                     *
* These equates are used for the notification mask in the             *
* HANDLEnotice call.                                                  *
*                                                                     *
***********************************************************************
*                                                                     *
MASKBUFFERSPACEAVAILABLE         EQU X'00000001'
MASKCONNECTIONSTATECHANGED       EQU X'00000002'
MASKDATADELIVERED                EQU X'00000004'
MASKURGENTPENDING                EQU X'00000020'
MASKUDPDATAGRAMDELIVERED         EQU X'00000040'
MASKUDPDATAGRAMSPACEAVAILABLE    EQU X'00000080'
MASKRAWIPPACKETSDELIVERED        EQU X'00004000'
MASKRAWIPSPACEAVAILABLE          EQU X'00008000'
MASKRESOURCESAVAILABLE           EQU X'00040000'
MASKUDPRESOURCESAVAILABLE        EQU X'00080000'
MASKPINGRESPONSE                 EQU X'00100000'
*
*
***********************************************************************
*                                                                     *
* We need to copy more equates from 'TCPIP.COMMMAC(CMCOMM)' because   *
* IBM did not provide documentation for everything.  So here goes...  *
* Some of these are in the manual, but I include everything.          *
*                                                                     *
***********************************************************************
*
DEFAULTSECURITY         EQU  0
DEFAULTCOMPARTMENT      EQU  0
DEFAULTPRECEDENCE       EQU  0
UNSPECIFIEDADDRESS      EQU  0
UNSPECIFIEDPORT         EQU  X'FFFF'
BROADCASTADDRESS        EQU  X'FFFFFFFF'
WAITFOREVER             EQU  2147483647   (MAXint)
*
DEFAULTOPENTIMEOUT      EQU  30
*
*    These are the return codes that the client might see as a result
*     of issuing an IP or TCP request.  They must be in the range
*     LOWerrorCODE .. HIGHerrorCODE.  HIGHerrorCODE = 0.
*
HIGHERRORCODE              EQU 0
LOWERRORCODE               EQU -128
OK                         EQU 0
ABNORMALCONDITION          EQU -1  { nonfatal VMCF error }
ALREADYCLOSING             EQU -2  { connection already closing }
BADLENGTHARGUMENT          EQU -3  { length parameter is invalid }
CANNOTSENDDATA             EQU -4
CLIENTRESTART              EQU -5
CONNECTIONALREADYEXISTS    EQU -6
DESTINATIONUNREACHABLE     EQU -7  { from remote site or gateway }
ERRORINPROFILE             EQU -8
FATALERROR                 EQU -9  { fatal VMCF error }
HASNOPASSWORD              EQU -10  { errors         }
INCORRECTPASSWORD          EQU -11  { ... in opening }
INVALIDREQUEST             EQU -12
INVALIDUSERID              EQU -13  { ... file       }
INVALIDVIRTUALADDRESS      EQU -14  { ... used       }
KILLEDBYCLIENT             EQU -15
LOCALPORTNOTAVAILABLE      EQU -16
MINIDISKINUSE              EQU -17  { ... by         }
MINIDISKNOTAVAILABLE       EQU -18  { ... MonCommand }
NOBUFFERSPACE              EQU -19
NOMOREINCOMINGDATA         EQU -20
NONLOCALADDRESS            EQU -21
NOOUTSTANDINGNOTIFICATIONS EQU -22
NOSUCHCONNECTION           EQU -23
NOTCPIPSERVICE             EQU -24
NOTYETBEGUN                EQU -25  { Client hasn't called BeginTcpIp}
NOTYETOPEN                 EQU -26  { Client hasn't called TcpOpen }
OPENREJECTED               EQU -27
PARAMLOCALADDRESS          EQU -28  { Invalid .....      }
PARAMSTATE                 EQU -29  { ... values...      }
PARAMTIMEOUT               EQU -30  { ... specified ...  }
PARAMUNSPECADDRESS         EQU -31  { ... in Connection  }
PARAMUNSPECPORT            EQU -32  { ..Information Record }
PROFILENOTFOUND            EQU -33
RECEIVESTILLPENDING        EQU -34
REMOTECLOSE                EQU -35  { Foreign client closing }
REMOTERESET                EQU -36
SOFTWAREERROR              EQU -37  { WISCNET software error }
TCPIPSHUTDOWN              EQU -38
TIMEOUTCONNECTION          EQU -39
TIMEOUTOPEN                EQU -40
TOOMANYOPENS               EQU -41
UNAUTHORIZEDUSER           EQU -43
UNEXPECTEDSYN              EQU -44
UNIMPLEMENTEDREQUEST       EQU -45
UNKNOWNHOST                EQU -46  { we lack info in our tables }
UNREACHABLENETWORK         EQU -47
UNSPECIFIEDCONNECTION      EQU -48
VIRTUALMEMORYTOOSMALL      EQU -49
WRONGSECORPRC              EQU -50  { wrong security or priority }
X25TOOCONGESTED            EQU -51  { no virtual circuits available }
YOUREND                    EQU -55
ZERORESOURCES              EQU -56
*
* UDP specific errors
*
UDPLOCALADDRESS            EQU -57  {Invalid local address}
UDPUNSPECADDRESS           EQU -59  {Unspecified local address}
UDPUNSPECPORT              EQU -60  {Unspecified local port}
UDPZERORESOURCES           EQU -61  {No space available to continue}
*
* New errors, not yet sorted alphabetically
*
FSENDSTILLPENDING          EQU -62  {TcpFSend is still outstanding }
*
* Error codes from FSD
*
HOSTMSGTOOBIG              EQU -63
CHANNELWRITEIOERR          EQU -64
UNKNOWNSENSEBYTE           EQU -65
SERIES1DOWN                EQU -71
IMPISDOWN                  EQU -72
HOSTDEAD                   EQU -73
BADIMPMSG                  EQU -74
HOSTNOTREADY               EQU -75
S1APPLNOTREADY             EQU -76
WRITEBUFFERREADY           EQU -77
LOOPX25ADDRESS             EQU -78
DROPPEDBYOPERATOR          EQU -79
ERROROPENINGORREADINGFILE  EQU -80
FILEFORMATINVALID          EQU -81
*
**********************************************************************
*                                                                    *
*                        Ip Datagram Section                         *
*                                                                    *
**********************************************************************
*
ANYCONNECTION     EQU UNSPECIFIEDCONNECTION
*
*     { This indicates that the request is to be done on any
*        connection. }
*
NOTIPNOTIFICATION EQU 0
*
*     { This is given in the Protocol field during an
*        asynchronous notification if the notification is not
*        relevant to a particular protocol other than TCP. }
*
ANYPROTOCOL       EQU 0 { Used as a Wild Card }
*
* The following definitions are used to describe an IP datagram.
* For more information, see RFC 791, pages 11 - 23. Due to the
* variable length of the options list, it is not declared as a
* separate field; the client is responsible for determining
* which characters in the data portion of the datagram are options.
*
MINIMUMIPHEADERSIZE EQU 20
*
*  { Implementation limits on the size of raw IP datagrams }
*
MAX512DATAGRAMSIZE   EQU 512
MAX512IPDATA         EQU MAX512DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX1024DATAGRAMSIZE  EQU 1024
MAX1024IPDATA        EQU MAX1024DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX2048DATAGRAMSIZE  EQU 2048
MAX2048IPDATA        EQU MAX2048DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX4096DATAGRAMSIZE  EQU 4096
MAX4096IPDATA        EQU MAX4096DATAGRAMSIZE-MINIMUMIPHEADERSIZE
*
*  { 8192 datagram is actually a little larger, to accommodate NFS.
*    NFS wants to send UDP data of 8K plus 200.  Add the UDP header
*    size, the IP header size, and 100 bytes for good measure. }
*
MAX8192DATAGRAMSIZE  EQU 8192+8+MINIMUMIPHEADERSIZE+200+100
MAX8192IPDATA        EQU MAX8192DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX16384DATAGRAMSIZE EQU 16384
MAX16384IPDATA       EQU MAX16384DATAGRAMSIZE-MINIMUMIPHEADERSIZE
MAX32768DATAGRAMSIZE EQU 32768
MAX32768IPDATA       EQU MAX32768DATAGRAMSIZE-MINIMUMIPHEADERSIZE
*
* The possible flag bits:  (see RFC 791, page 13) }
*
IPMAYFRAGMENT        EQU 0
IPDONTFRAGMENT       EQU 16384 { Bit 1 of the halfword }
IPLASTFRAGMENT       EQU 0
IPMOREFRAGMENTS      EQU 8192 { Bit 2 of the halfword }
*
* The bit flags for the IP type-of-service field: RFC 791, p. 12 }
*
LOWDELAY             EQU 16
NORMALDELAY          EQU 0
HIGHTHROUGHPUT       EQU 8
NORMALTHROUGHPUT     EQU 0
HIGHRELIABILITY      EQU 4
NORMALRELIABILITY    EQU 0
*
* UDP header size }
*
UDPHEADERSIZE        EQU 8
*
* Max data returned on an old-style UdpReceive.  This number
* will never change. }
*
OLDSTYLEMAXUDPDATA   EQU 2040-MINIMUMIPHEADERSIZE-UDPHEADERSIZE
*
* Well known protocol numbers }
*
ICMPPROTOCOLNUMBER   EQU 1
TCPPROTOCOLNUMBER    EQU 6
UDPPROTOCOLNUMBER    EQU 17
*
* Maximum number of IP protocols }
*
IPPROTO_MAX       EQU 256  { Don't even think of changing this number }
*
DISABLEALLINTERRUPTS   EQU  X'00'
ENABLEALLINTERRUPTS    EQU  255  { a byte with every bit set to one }
FIXEDOVERFLOWMASK      EQU  X'08'
DECIMALOVERFLOWMASK    EQU  X'04'
EXPONENTUNDERFLOWMASK  EQU  X'02'
SIGNIFICANCEMASK       EQU  X'01'
LENGTHOFVIRTUALADDRESS EQU  4
LENGTHOFDISKLABEL      EQU  6
CPEXTERNALCOMMAND      EQU  X'40'
MESSAGENUMBERLIMIT     EQU  1000000000
*
*  { This limit is made smaller than necessary so
*     wrap-around arithmetic is easier. }
*
TIMERINTERRUPTCODE     EQU X'1004'
VMCFINTERRUPTCODE      EQU X'4001'
IUCVINTERRUPTCODE      EQU X'4000'
LDSFINTERRUPTCODE      EQU X'2402'
INTERVALTIMERINTERRUPTCODE EQU X'0080'
ANYOLDADDRESS          EQU 0
*
*  { These are all the possible VMCF function calls. }
*
VMCFAUTHORIZEFUNCTION   EQU X'0000'
VMCFUNAUTHORIZEFUNCTION EQU X'0001'
VMCFSENDFUNCTION        EQU X'0002'
VMCFSENDRECEIVEFUNCTION EQU X'0003'
VMCFSENDXFUNCTION       EQU X'0004'
VMCFRECEIVEFUNCTION     EQU X'0005'
VMCFCANCELFUNCTION      EQU X'0006'
VMCFREPLYFUNCTION       EQU X'0007'
VMCFQUIESCEFUNCTION     EQU X'0008'
VMCFRESUMEFUNCTION      EQU X'0009'
VMCFIDENTIFYFUNCTION    EQU X'000A'
VMCFREJECTFUNCTION      EQU X'000B'
*
*  { The IUCV function codes.  The ord of this enum type gives the
*    actual function code. }
*
IUCVQUERYFUNCTION       EQU   0
IUCVTESTMSGFUNCTION     EQU   1
IUCVRTRVBFRFUNCTION     EQU   2
IUCVDESCRIBEFUNCTION    EQU   3
IUCVSENDFUNCTION        EQU   4
IUCVRECEIVEFUNCTION     EQU   5
IUCVREPLYFUNCTION       EQU   6
IUCVTESTCMPLFUNCTION    EQU   7
IUCVREJECTFUNCTION      EQU   8
IUCVPURGEFUNCTION       EQU   9
IUCVACCEPTFUNCTION      EQU   10
IUCVCONNECTFUNCTION     EQU   11
IUCVDCLBFRFUNCTION      EQU   12
IUCVQUIESCEFUNCTION     EQU   13
IUCVRESUMEFUNCTION      EQU   14
IUCVSEVERFUNCTION       EQU   15
IUCVSETMASKFUNCTION     EQU   16
IUCVSETCMASKFUNCTION    EQU   17
*
* These are the IUCV external interrupt types
*
IUCVPENDINGCONNECTION     EQU X'01'
IUCVCONNECTIONCOMPLETE    EQU X'02'
IUCVSEVEREDCONNECTION     EQU X'03'
IUCVQUIESCEDCONNECTION    EQU X'04'
IUCVRESUMEDCONNECTION     EQU X'05'
IUCVINCOMINGPREPLY        EQU X'06'
IUCVINCOMINGREPLY         EQU X'07'
IUCVINCOMINGPMESSAGE      EQU X'08'
IUCVINCOMINGMESSAGE       EQU X'09'
*
*  { These are V1 flags for the authorize command. }
*
VMCFAUTHORIZESPECIFICFLAG EQU X'80'
VMCFPRIORITYFLAG          EQU X'40'
VMCFSMSGFLAG              EQU X'20'
*
*  { These are V1 flags for a Final Response Interrupt. }
*
VMCFFINALRESPONSECODE     EQU X'80'
VMCFREJECTRESPONSECODE    EQU X'40'
VMCFPRIORITYRESPONSECODE  EQU X'20'
MAXSMSGLENGTH             EQU 240  { Maximum SMSG data }
ANINTEGERFLAGREQUESTERR   EQU X'80000000'
*     { Used only when REJECTing FSENDtcp and FRECEIVEtcp calls }
IUCVADDRESSLISTSIZE       EQU 20
NOHOST EQU 0    { an always-invalid InternetAddress }
*
*    Because we use 0.0.0.0 as a flag meaning
*    'NO host', we assume that zero is never allowed as a
*    valid internet address. RFC 820 lists it as "reserved".
*
MAXWORDTYPELENGTH        EQU 100
MAXDESCRIPTORSETLENGTH   EQU 64
*
*
         EJECT
***********************************************************************
* Macro expansions                                                    *
***********************************************************************
*
* The following macro needs 'TCPIP.COMMMAC'.                    \
*
         MVPXVMCV ,                VMCF stuff
*
         PRINT NOGEN
*
         IEFJESCT
         IEFJSCVT
         CVT   DSECT=YES
         IHAPSA
*
         END
./ ADD NAME=XABDGET  0100-07332-07332-0900-00455-00455-00000-SEB
         TITLE 'XABDGET  - VERB EXIT INTERFACE MODULE'
***********************************************************************
*                                                                     *
* XABDGET  - VERB EXIT INTERFACE MODULE                               *
*                                                                     *
* THIS MODULE HAS SEVERAL ENTRY POINTS, ALL USED TO ENABLE A PROGRAM  *
* TO RUN AS A TSO COMMAND PROCESSOR OR AN IPCS VERB EXIT:             *
*                                                                     *
* XABDGET - DETERMINE IF THE PROGRAM WAS INVOKED AS A VERB EXIT AND   *
*           RETURN THE ADDRESS OF THE ABDPL IF SO, OTHERWISE BUILD    *
*           A FAKE ABDPL AND RETURN ITS ADDRESS.                      *
* XABDFRE - FREE THE FAKE ABDPL BUILT BY XABDGET.                     *
* XABDMEM - FAKE STORAGE ACCESS ROUTINE.                              *
* XABDPRT - FAKE OUTPUT WRITING ROUTINE.                              *
*                                                                     *
* (THERE MAY BE OTHERS, LIKE A FAKE FORMATTER, IN THE FUTURE.)        *
*                                                                     *
* NOTE: CURRENTLY THERE IS NO "XABDFRE" ENTRY POINT - THE XABDGET     *
*       EP WITH R1 = 0 IS A GET REQUEST, ELSE A FREE REQUEST.         *
*                                                                     *
* 09/26/1997 SEB1525 - replaced XPUTLINE with direct call to PUTLINE  *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    NUMBER OF ELEMNTS IN PARAMETER LIST
R4       EQU   4    ADDRESS OF ABDPL
R5       EQU   5    ADDRESS OF ABDPL EXTENSION
R6       EQU   6    ADDRESS OF OUTPUT BUFFER
R7       EQU   7    .
R8       EQU   8    SAVED PARM POINTER
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XABDGET  CSECT
         SPACE 1
         SAVE  (14,12),,XABDGET_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XABDGET,R12
         SPACE 1
***********************************************************************
*                                                                     *
* XABDGET IS CALLED WITH R1 CONTAINING:                               *
*    THE ADDRESS OF THE FAKE ABDPL, IF IT IS TO BE FREED.             *
*    ZEROES, IF AN ABDPL IS TO BE OBTAINED.                           *
*                                                                     *
***********************************************************************
         SPACE 1
         LTR   R1,R1
         BNZ   FREEPL
         EJECT
GETPL    DS    0H                  R1 = 0, GET AN ABDPL
         SPACE 1
         L     R1,4(,R13)          GET SA WHERE CALLER SAVED REGS
         L     R1,24(,R1)          GET R1 PASSED TO CALLER
         LR    R8,R1               SAVE FOR FUTURE USE
         LR    R2,R1               POINT TO FIRST PARM
* COUNT # OF PARMS PASSED.  IF GE 7, ASSUME CALLED AS VERB EXIT.
         LA    R0,6                INITIALIZE PARAMETER COUNT
         LA    R3,1                CLEAR PARAMETER COUNT
PARMLOOP TM    0(R2),X'80'         IF VL BIT (LAST PARM ADDR) FOUND,
         BO    LASTPARM            THEN WE GOT IT
         LA    R3,1(,R3)
         LA    R2,4(,R2)           ELSE BUMP POINTER
         BCT   R0,PARMLOOP         AND CONTINUE LOOPING
LASTPARM LTR   R0,R0               IF LESS THAN 7 PARMS (R0 ^= 0)
         BNZ   GETFAKE             THEN NOT INVOKED AS VERB EXIT
         L     R15,X'21C'          -> TCB
         L     R15,X'B4'(,R15)     -> JSCB
         L     R15,X'15C'(,R15)    -> ACTIVE JSCB
         L     R15,X'108'(,R15)    -> PSCB
         C     R15,8(,R1)          IF PARM 3 -> PSCB (INVOKED AS CMD)
******** BE    GETFAKE             THEN NOT INVOKED AS VERB EXIT
         BNE   RETURN0             ELSE RETURN, R1 -> ABDPL
         SPACE 1
* ELSE WE HAVE TO BUILD OUR OWN FAKE ABDPL
         SPACE 1
GETFAKE  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* WE ACQUIRE A WORK AREA WITH THE FOLLOWING CONTIGUOUS AREAS:         *
*                                                                     *
*   THE ABDPL                                                         *
*   THE ABDPL EXTENSION                                               *
*   OUR OWN AREA, INCLUDING OUTPUT BUFFER, CPPL, AND LOTS OF OTHERS.  *
*                                                                     *
***********************************************************************
         SPACE 1
         GETMAIN R,LV=TOTAREAL     GET STORAGE FOR ABDPL ET AL.
         LR    R4,R1               SAVE ITS ADDRESS
         USING ABDPL,R4
         LA    R5,ADPLLEN(,R4)     ADDRESS THE EXTENSION
         USING ADPLEXTN,R5
         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA
         USING OURAREA,R6
*
* INITIALIZE ABDPL
*
         XC    ABDPL(ADPLLEN),ABDPL
         L     R15,X'21C'          ->TCB
         ST    R15,ADPLTCB         SET TCB OF CURRENT TASK
         L     R15,X'224'          ->ASCB
         LH    R15,X'24'(,R15)     ASID
         STH   R15,ADPLASID        ADDRESS SPACE IDENTIFIER
         MVI   ADPLFLAG,ADPLSYTM   SET VS1 BIT (REALLY "FAKE" BIT)
         LA    R15,OURBUF
         ST    R15,ADPLBUF         ADDRESS OF OUTPUT BUFFER
         L     R15,=V(XABDPRT)
         ST    R15,ADPLPRNT        ADDRESS OF PRINT ROUTINE
         L     R15,X'10'
         ST    R15,ADPLCVT         ADDRESS OF CVT
         L     R15,=V(XABDMEM)
         ST    R15,ADPLMEMA        ADDRESS OF MEMORY ACCESS ROUTINE
*        L     R15,=V(XABDFMT)
*        ST    R15,ADPLFRMT        ADDRESS OF FORMAT ROUTINE
*
         ST    R5,ADPLEXT          ADDRESS OF EXTENSION
*        L     R15,=V(XABDSRV)
*        ST    R15,ADPLSERV        ADDRESS OF SERVICES ROUTER
*
* INITIALIZE ADPL EXTENSION
*
         XC    ADPLEXTN(ADPLEXTL),ADPLEXTN
* CHECK # OF PARMS PASSED.  IF 4, ASSUME CPPL PASSED
         L     R15,X'21C'          GET TCB ADDRESS
         L     R15,X'B4'(,R15)     GET JSCB ADDRESS
         L     R15,X'15C'(,R15)    GET ADDRESS OF ACTIVE JSCB
         L     R15,X'108'(,R15)    GET ADDRESS OF PSCB
         CH    R3,=H'4'            IF AT LEAST 4 PARMS
         BL    NOTTSOCP            AND
         C     R15,8(,R8)          PARM 3 -> PSCB (INVOKED AS CMD)
         BNE   NOTTSOCP            THEN
         ST    R8,ADPLCPPL          INPUT PARM -> CPPL
         L     R1,0(,R8)            POINT TO COMMAND BUFFER
         LH    R14,0(,R1)           GET LENGTH OF COMMAND BUFFER
         LH    R15,2(,R1)           GET OFFSET TO FIRST OPERAND
         LA    R15,4(R15,R1)        ABSOLUTE ADDRESS OF OPERAND
         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER
         ALR   R14,R1               POINT TO END OF COMMAND BUFFER
         SR    R14,R15              SUBTRACT OFFSET TO FIRST OPERAND
         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST
         B     AFTTSOCP            ELSE
NOTTSOCP DS    0H                   ...BUILD OUR OWN CPPL
         ST    R15,CPPLPSCB         SAVE PSCB ADDRESS
         MVC   CPPLUPT,X'34'(R15)   SAVE UPT ADDRESS
         L     R15,X'30'(,R15)      GET ADDRESS OF RELOGON BUFFER
         L     R15,X'100'(,R15)     GET ADDRESS OF ECT
         ST    R15,CPPLECT          SAVE ECT ADDRESS
         XC    CPPLCBUF,CPPLCBUF    NO COMMAND BUFFER
         LA    R1,OURCPPL
         ST    R1,ADPLCPPL          SET CPPL ADDRESS
         L     R1,0(,R8)            ASSUME FIRST PARM IS A CALL PARM
         LA    R15,2(,R1)           ADDRESS OF PARM TEXT
         ST    R15,ADPLOPTR         SET ADDRESS OF OPERANDS BUFFER
         LH    R14,0(,R1)           GET LENGTH OF PARM FIELD
         STH   R14,ADPLOPLN         SET LENGTH OF VERB OPERAND LIST
AFTTSOCP DS    0H
         L     R1,ADPLCPPL
         MVC   IOPLUPT,CPPLUPT-OURCPPL(R1) PTR TO UPT
         MVC   IOPLECT,CPPLECT-OURCPPL(R1) PTR TO ECT
         LA    R0,ECB
         ST    R0,IOPLECB              PTR TO USER'S ECB
         LA    R0,1                DEFINE 1 MESSAGE SEGMENT
         LA    R1,MSGHDR
         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR
*
* INITIALIZE OUTPUT BUFFER TO BLANKS
*
         MVI   OURBUFB,C' '        BLANK REQUIRED FOR PUTLINE
         MVI   OURBUF,C' '
         MVC   OURBUF+1(OURBUFL-1),OURBUF
         EJECT
         LR    R1,R4               SET ABDPL POINTER FOR RETURN
         B     RETURN0
         EJECT
FREEPL   DS    0H                  R1 -> ABDPL TO BE FREED
         SPACE 1
         TM    ADPLFLAG-ABDPL(R1),ADPLSYTM  IF VS1/FAKE FLAG SET,
         BZ    RETURN0             THEN
         FREEMAIN R,LV=TOTAREAL,A=(1) FREE IT
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 1
RETURN   DS    0H                  RETURN
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
*                                 R1 CONTAINS ABDPL POINTER           *
***********************************************************************
         SPACE 1
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         ST    R1,24(,R13)         STORE ABDPL PTR (R1) IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES, ETC.                                                  *
***********************************************************************
         SPACE 1
         LTORG
         SPACE 3
         DROP  R12
         TITLE 'XABDPRT  - VERB EXIT FAKE OUTPUT PRINT ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
XABDPRT  CSECT
         SPACE 1
         SAVE  (14,12),,XABDPRT
         LR    R12,R15
         USING XABDPRT,R12
         LR    R4,R1               SAVE ABDPL ADDRESS
         USING ABDPL,R4
         L     R5,ADPLEXT
         USING ADPLEXTN,R5
         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA
         USING OURAREA,R6
         SPACE 1
         ST    R13,OURSAVE+4       SET UP SAVE AREA
         LA    R1,OURSAVE
         ST    R1,8(,R13)
         LR    R13,R1
         SPACE 1
         TR    OURBUF(OURBUFL),PRTTRTBL  FIX ALL BAD CHARACTERS
         SPACE 1
         LA    R0,OURBUFL+1        LENGTH OF OUTPUT BUFFER
         LA    R1,OURBUFB          THE OUTPUT BUFFER
         BAL   R14,PUTLINE         Call PUTLINE to display line
         LTR   R15,R15             IF PUTLINE FAILED
         BZ    PRTPUTOK            THEN
         LA    R1,400(,R15)         ABEND WITH PUTLINE RC + 400
         ABEND (1),DUMP
         SPACE 1
PRTPUTOK DS    0H
         MVI   OURBUF,C' '         CLEAR OUTPUT BUFFER TO BLANKS
         MVC   OURBUF+1(OURBUFL-1),OURBUF
         B     PRTRET0
         EJECT
PRTRET4  DS    0H                  RETURN WITH CODE 4
         LA    R15,4               SET RETURN CODE TO FOUR
         B     PRTRET
PRTRET0  DS    0H                  RETURN WITH CODE 0
         XR    R15,R15             SET RETURN CODE TO ZERO
******** B     PRTRET
PRTRET   DS    0H                  RETURN
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
         L     R13,4(,R13)         RESTORE SAVE AREA POINTER
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
*
PRTTRTBL DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/........,%_>?'
         DC    C'.........`:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         TITLE 'PUTLINE SUBROUTINE'
         SPACE
PUTLINE  DS    0H
*
***********************************************************************
*                                                                     *
* This routine displays messages to the TSO user using the TSO        *
* PUTLINE service routine.  At entry R1 contains the address of the   *
* message to be displayed, and R0 contains the length of the message. *
* The message is assumed to begin with a message ID unless            *
* the first character is blank, in which case the initial blank is    *
* stripped off by PUTLINE anyhow.                                     *
*                                                                     *
***********************************************************************
*
         ST    R14,PUTLIN14        Save return register
         LTR   R15,R0              Load length value
         BNP   PUTLRET             If zero, don't do anything
         BCTR  R15,0               Else reduce length for execute
         LTR   R1,R1               If R1 is zero,
         BZ    PUTIT               then message already set up.
         EX    R15,MVCPUT          Else move message to work area
PUTIT    DS    0H
         LA    R15,5(,R15)         Restore length + 4 for header
         SLL   R15,16              Shift length into left half of hdr
         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr
         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM
PUTRETRY DS    0H
         XC    ECB,ECB             Clear ECB
         PUTLINE PARM=PTLIST,                                          X
               MF=(E,IOPL),                                            X
               OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15             If PUTLINE OK
         BZ    PUTLRET             then return
         CH    R15,=H'8'           Else if attention interrupt
         BE    PUTLRET             then OK
         CH    R15,=H'12'          Else if pending 2nd level message
         BE    PUTL12              then OK
PUTERROR DS    0H                  Else PUTLINE error
         CVD   R15,OURWORK
         UNPK  OURWORK(2),OURWORK(8)
         OI    OURWORK+1,X'F0'
         MVC   PUTWA+1(L'PUTFMSG1),PUTFMSG1
         MVC   PUTWA+1+L'PUTFMSG1(2),OURWORK
         MVC   PUTWA+1+L'PUTFMSG1+2(L'PUTFMSG2),PUTFMSG2
         TPUT  PUTWA+1,L'PUTFMSG1+2+L'PUTFMSG2
         LA    R1,MSGWA
         LH    R0,MSGHDR
         SH    R0,=H'4'
         TPUT  (1),(0),R           Try to display original message
PUTLRET  L     R14,PUTLIN14        Restore return register
         BR    R14                 Return
*
PUTL12   DS    0H                  Try putting out pending 2nd level ms
         XC    ECB,ECB             Clear ecb
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)
         B     PUTRETRY
*
MVCPUT   MVC   MSGWA(*-*),0(R1)    Executed
*
PUTFMSG1 DC    C'*** XABDGET: PUTLINE error code '
PUTFMSG2 DC    C' trying to issue the following message:'
         EJECT
         LTORG
         EJECT
         TITLE 'XABDMEM  - VERB EXIT FAKE MEMORY ACCESS ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
XABDMEM  CSECT
         SPACE 1
         SAVE  (14,12),,XABDMEM
         LR    R12,R15
         USING XABDMEM,R12
         LR    R4,R1               SAVE ABDPL ADDRESS
         USING ABDPL,R4
         L     R5,ADPLEXT
         USING ADPLEXTN,R5
         LA    R6,ADPLEXTL(,R5)    ADDRESS OUR ADDITIONAL AREA
         USING OURAREA,R6
         SPACE 1
***********************************************************************
*                                                                     *
* FOR NOW, JUST RETURN THE ADDRESS AS IS.                             *
*                                                                     *
***********************************************************************
         SPACE 1
         B     MEMRET0             RETURN OK, ADDRESS IN R0
         SPACE 1
         EJECT
MEMRET4  DS    0H                  RETURN WITH CODE 4
         LA    R15,4               SET RETURN CODE TO FOUR
         B     MEMRET
MEMRET0  DS    0H                  RETURN WITH CODE 0
         XR    R15,R15             SET RETURN CODE TO ZERO
******** B     MEMRET
MEMRET   DS    0H                  RETURN
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
*                                 R0 CONTAINS ADDRESS OF DATA         *
***********************************************************************
         SPACE 1
         STM   R15,R0,16(R13)      STORE VALUES IN SAVE AREA
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
         LTORG
***********************************************************************
* MAP OF THE ADDITIONAL AREA FOLLOWING ABDPL AND ADPLEXT              *
***********************************************************************
         SPACE 1
OURAREA  DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
OURSAVE  DS    9D                  SAVE AREA IF NEEDED
OURWORK  DS    D                   MISCELLANEOUS WORKAREA
PUTLIN14 DS    A                   PUTLINE SAVE AREA
OURPLIST DS    0A                  PARAMETER LIST
OURPARM1 DS    A                   PARAMETER 1
OURPARM2 DS    A                   PARAMETER 2
OURPARM3 DS    A                   PARAMETER 3
OURPARM4 DS    A                   PARAMETER 4
OURCPPL  DS    0F       TSO COMMAND PROCESSOR PARAMETER LIST
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
*
IOPL     DS    0A
*
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
*
ECB      DS    F                   ECB for TSO routines
*
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
*
OLD      DS    0F                  PUTLINE output line descriptor
OLDF1    DS    F'1'                Number of message segments
OLDMSG   DS    A(*-*)              Address of the first message segment
*
MSGHDR   DS    F                   PUTLINE message header
MSGWA    DS    CL256               PUTLINE message work area
PUTWA    DS    CL256               PUTLINE message work area
*
         SPACE 1
OURBUFB  DS    CL1                 LEADING BLANK REQUIRED FOR XPUTLINE
OURBUF   DS    CL133               OUTPUT BUFFER
OURBUFL  EQU   *-OURBUF
         SPACE 1
         DS    0D                  ALIGN TO DOUBLEWORD
         SPACE 2
OURAREAL EQU   *-OURAREA           LENGTH OF OUR AREA
         EJECT
         BLSABDPL
         EJECT
***********************************************************************
* ADDITIONAL EQUATES                                                  *
***********************************************************************
         SPACE 1
TOTAREAL EQU   ADPLLEN+ADPLEXTL+OURAREAL
         SPACE 1
         END
./ ADD NAME=XACF2    0100-07332-07332-0900-00309-00309-00000-SEB
         MACRO
&LABEL   WTT   &TEXT,&HOW
         LCLC  &LAPOST,&LBLA,&LBLB
&LAPOST  SETC  'L'''
&LBLA    SETC  'WTT&SYSNDX.A'
&LBLB    SETC  'WTT&SYSNDX.B'
         CNOP  0,4
&LABEL   BAL   1,&LBLB
&LBLA    DC    C&TEXT
&LBLB    DS    0H
         LA    1,0(,1)
         LA    0,&LAPOST.&LBLA
         TPUT  (1),(0),&HOW
         MEND
         MACRO
&LABEL   ASK4  &THING
         LCLA  &THINGLN
&THINGLN SETA  L'&THING
         WTT   'Enter &THING (&THINGLN):',ASIS
         TCLEARQ INPUT
         TGET  &THING,&THINGLN
         TR    &THING.(&THINGLN),UPTBL
         MEND
         TITLE 'XACF2    - subroutine to test acf2 access'
***********************************************************************
*                                                                     *
* XACF2    - subroutine to test acf2 access                           *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   Static base register
R13      EQU   13   Dynamic base register and save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
XACF2    CSECT
         SAVE  (14,12),,XACF2_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XACF2,R12
         LR    R2,R1               Save input parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         LR    R1,R2               Restore input parameter address
         EJECT
         ASK4  DSNAME
         ASK4  VOLUME
         ASK4  PROGRAM
         ASK4  DDNAME
         EJECT
*        ZAP   DATE,=P'0'
*        LA    R0,RULEREC
*        L     R1,=A(L'RULEREC)
*        XR    R14,R14
*        XR    R15,R15
*        MVCL  R0,R14
*        LA    R0,WORKAREA
*        L     R1,=A(L'WORKAREA)
*        XR    R14,R14
*        XR    R15,R15
*        MVCL  R0,R14
         EJECT
***********************************************************************
*                                                                     *
* Set the values we want to test access for.                          *
*                                                                     *
***********************************************************************
         SPACE 1
         XC    ACDSV(LACDSV),ACDSV
         SPACE 1
         MVI   ACFSPREQ,ACFSPRAC   Validate dsname, volume, ddname
         OI    ACFSPREQ,ACFSPRFF   Indicate extended parameter list
         MVI   ACFSPID1,ACFSPIOP   Open request
         MVI   ACFSPID1,ACFSPIUR   User callable request
         MVI   ACFSPAC1,ACFSPAIN   Access is input only
         LA    R1,MSGBUF
         ST    R1,ACFSPMSG         Our own message buffer.
*
* The above should be user-settable.
*
         SPACE 1
         LA    R1,DSNAME
         ST    R1,ACFSPDSN           ADDRESS OF 44 BYTE DSNAME
         LA    R1,VOLUME
         ST    R1,ACFSPVOL           ADDRESS OF 6 BYTE VOLSER
         LA    R1,PROGRAM
         ST    R1,ACFSPPGM           ADDRESS OF 8 BYTE PROGRAM NAME
         LA    R1,DDNAME
         ST    R1,ACFSPDDN           ADDRESS OF 8 BYTE DDNAME
         EJECT
***********************************************************************
*                                                                     *
* Call ACFSVC to do the validation testing.                           *
*                                                                     *
***********************************************************************
         SPACE 1
         ACFSVC PARMLIST,TYPE=S,CVT=FIND,NONE=RETURN
         EJECT
***********************************************************************
*                                                                     *
* Interpret the return code.                                          *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R2,R15              Return code
*        LR    R3,R1               Pointer to one-byte access flag
*        LR    R4,R0               Contains information about access
         B     ACFRET(R2)
ACFRET   B     RC0                 Return code = 0
         EX    0,*                 Return code = 4
         EX    0,*                 Return code = 8
         B     RC12                Return code = 12
         B     RC16                Return code = 16
         EJECT
RC0      DS    0H                  Request is valid
         SPACE 1
         WTT   'Access permitted.'
         B     RETURN
         SPACE 1
RC12     DS    0H                  Request is not valid; msg returned.
         SPACE 1
         WTT   'Access denied.'
         B     SEEWHY
         SPACE 1
RC16     DS    0H                  Invalid SVC input; msg returned.
         SPACE 1
         WTT   'Invalid SVC input parameter.'
         B     SEEWHY
         EJECT
SEEWHY   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Inspect message returned by ACFSVC, pointed to by ???.              *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R2,ACFSPMSG         Get address of message buffer
         LH    R0,0(,R2)
         SH    R0,=H'4'
         LA    R1,4(,R2)
         TPUT  (1),(0),R           Display the message
         B     RETURN
         SPACE 1
***********************************************************************
*                                                                     *
*                                                                     *
***********************************************************************
*        SPACE 1
*HKACC   DS    0H
*        SPACE 1
*        MVC   ANSWER(L'ANSWERT),ANSWERT
*        MVI   AREAD,C'P'
*        MVI   AWRITE,C'P'
*        MVI   AALLOC,C'P'
*        MVI   AEXEC,C'P'
*        TM    0(R3),X'80'
*        BNE   NOREADA
*        MVI   AREAD,C'A'
*        B     NOREAD
*OREADA  TM    0(R3),X'40'
*        BNE   NOREAD
*        MVI   AREAD,C'L'
*OREAD   DS    0H
*        TM    0(R3),X'20'
*        BNE   NOWRITEA
*        MVI   AWRITE,C'A'
*        B     NOWRITE
*OWRITEA TM    0(R3),X'10'
*        BNE   NOWRITE
*        MVI   AWRITE,C'L'
*OWRITE  DS    0H
*        TM    0(R3),X'08'
*        BNE   NOALLOCA
*        MVI   AALLOC,C'A'
*        B     NOALLOC
*OALLOCA TM    0(R3),X'04'
*        BNE   NOALLOC
*        MVI   AALLOC,C'L'
*OALLOC  DS    0H
*        TM    0(R3),X'02'
*        BNE   NOEXECA
*        MVI   AEXEC,C'A'
*        B     NOEXEC
*OEXECA  TM    0(R3),X'01'
*        BNE   NOEXEC
*        MVI   AEXEC,C'L'
*OEXEC   DS    0H
*        LA    R1,ANSWER
*        LA    R0,ANSWERL
*        TPUT  (1),(0),R
*        SPACE 1
***********************************************************************
* Return to calling environment - R2 contains return code             *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R2,16(,R13)         Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* Subroutines                                                         *
***********************************************************************
         EJECT
***********************************************************************
* Executed instructions                                               *
***********************************************************************
         SPACE 1
***********************************************************************
* Declaratives                                                        *
***********************************************************************
         SPACE 1
ANSWERT  DS    0C
         DC    C'READ('
         DC    C' '
         DC    C') WRITE('
         DC    C' '
         DC    C') ALLOC('
         DC    C' '
         DC    C') EXEC('
         DC    C' '
         DC    C')'
         ORG   ,
ANSWERTL EQU   *-ANSWERT
         SPACE 1
UPTBL    DC    256YL1(*-UPTBL)
         ORG   UPTBL+C'a'
         DC    C'ABCDEFGHI'
         ORG   UPTBL+C'j'
         DC    C'JKLMNOPQR'
         ORG   UPTBL+C's'
         DC    C'STUVWXYZ'
         ORG   ,
         SPACE 1
***********************************************************************
* Messages                                                            *
***********************************************************************
         SPACE 1
         LTORG
         SPACE 1
         DROP  R12
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
@ACFINT  DS    A                   Address of ACFINT
PARMLIST DS    0D                  Parameter list
         SPACE 1
         ACDSV DSECT=NO
LACDSV   EQU   *-ACDSV
         SPACE 1
ANSWER   DS    0C
         ORG   ANSWER
         DC    C'READ('
AREAD    DC    C' '
         DC    C') WRITE('
AWRITE   DC    C' '
         DC    C') ALLOC('
AALLOC   DC    C' '
         DC    C') EXEC('
AEXEC    DC    C' '
         DC    C')'
         ORG   ,
ANSWERL  EQU   *-ANSWER
DSNAME   DS    CL44
VOLUME   DS    CL6
PROGRAM  DS    CL8
DDNAME   DS    CL8
*ATE     DS    PL4
*ULEREC  DS    CL512
*ORKAREA DS    CL1024
MSGBUF   DS    CL128
         SPACE 2
SIZDATD  EQU   *-DATD              Length of dynamic work area
         EJECT
***********************************************************************
* Macro expansions                                                    *
***********************************************************************
         SPACE 1
         ACCVT
         SPACE 1
         END
./ ADD NAME=XALCMOD  0100-07332-07332-0900-02667-02667-00000-SEB
         TITLE 'XALCMOD  - modify TSO file allocation'
***********************************************************************
*                                                                     *
* XALCMOD  - modify TSO file allocation                               *
*                                                                     *
* This is the replacement for XALCAPP/XALCREM/XAPPEND/XREMOVE.        *
*                                                                     *
* The syntax is:  XALCMOD +                                           *
*                         option(file1(dsn11 dsn12 ...) +             *
*                                file2(dsn21 dsn22 ...) +             *
*                                ... +                                *
*                               )  +                                  *
*                         INFORM | ACTINFORM | FAILINFORM | NOINFORM  *
*                                                                     *
* where:                                                              *
*       "option" is required and one of:                              *
*       INSERT/FRONT/BACK/DELETE/SETUP                                *
*                                                                     *
* and zero or more filei(dsni) specifications are required.           *
*                                                                     *
* One or more dsni's may occur within the parentheses; if no dsni's   *
* are specified, the filei is ignored.                                *
*                                                                     *
* Return codes:                                                       *
*                                                                     *
*   0 - allocation request OK, changes occurred                       *
*   4 - allocation request processed, no changes occurred             *
*   8 - one or more requested datasets unavailable, partially done    *
*  12 - specification error or failure, allocation as before          *
*  16 - severe error, allocation may be munged                        *
*                                                                     *
*************************************************************** #TSO158
*                                                               #TSO158
* Change activity:                                              #TSO158
*                                                               #TSO158
* 11/14/91 - SEB1525 - added support for 'CCF.*' data sets.     #TSO158
* 10/15/96 - SEB1525 - changes required for new UCB access.     #TSO???
*                                                               #TSO158
***********************************************************************
*
         GBLA  &CATLIM             Max # of datasets we can concatenate
&CATLIM  SETA  50                  <== Change this value if desired
*
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    Address of FDB (user input file dataset block)
R4       EQU   4    Address of DSL (already allocated data set list)
R5       EQU   5    Pointer into variable part of DSL (each dsname)
R6       EQU   6    Pointer into variable part of FDB (each dsname)
R7       EQU   7    Used for building concatenation ddname list
R8       EQU   8    Miscellaneous uses
R9       EQU   9    Counter for looping through FDB or DSL dsnames
R10      EQU   10   Dynamic base register
R11      EQU   11   Second static base register
R12      EQU   12   First static base register
R13      EQU   13   Save area pointer
R14      EQU   14
R15      EQU   15
         EJECT
XALCMOD  CSECT
XALCMOD  AMODE 31
XALCMOD  RMODE ANY
         B     XALCMOD_START-XALCMOD(,R15)
         DC             YL1(XALCMOD_EYECATCHER_END-XALCMOD_EYECATCHER)
XALCMOD_EYECATCHER      DC C'XALCMOD &SYSDATE &SYSTIME'
XALCMOD_EYECATCHER_END  EQU *
SECOND_BASE_CON         DC A(XALCMOD+4096)
XALCMOD_START           DS 0H
         STM   R14,R12,12(R13)
         LR    R12,R15
         L     R11,SECOND_BASE_CON-XALCMOD(,R15)
         USING XALCMOD,R12,R11
         LR    R2,R1               Save CPPL address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         LR    R10,R13
         USING DATD,R10
         EJECT
         USING CPPL,R2             Addressability to CPPL
*
         ST    R2,CPPLADDR
         MVC   IOPLUPT,CPPLUPT         PTR TO UPT
         MVC   IOPLECT,CPPLECT         PTR TO ECT
         LA    R0,ECB
         ST    R0,IOPLECB              PTR TO USER'S ECB
*                                  Initialize PARSE fields
         XC    ANSWER,ANSWER
         MVC   PPLUPT,CPPLUPT
         MVC   PPLECT,CPPLECT
         LA    R14,ECB
         L     R15,=V(XALCMPCL)
         LA    R0,ANSWER
         L     R1,CPPLCBUF
         STM   R14,R1,PPLECB
         ST    R10,PPLUWA          User work area = "DATD"
         ST    R10,PPLVEWA         User work area = "DATD"
         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM
         LA    R0,1                DEFINE 1 MESSAGE SEGMENT
         LA    R1,MSGHDR
         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR
*                                  Initialize other data areas
         XC    FRSTFDB,FRSTFDB     Clear file-dataset block pointer
         XC    LASTFDB,LASTFDB     Clear file-dataset block pointer
         STM   R11,R12,MYBASES     Base registers used in PARSE exits
         MVI   FLAGS,X'00'         Clear flags
*
         DROP  R2                  Addressability to CPPL not needed
*
* Initialize dynamic allocation control blocks.
* S99VERB and S99TXTPP are set by the individual subroutines.
*
         LA    R14,S99RBP          Address of SVC 99 work area
         LA    R15,ENDS99          Compute length thereof
         SR    R15,R14
         XR    R0,R0
         XR    R1,R1
         MVCL  R14,R0              Move zeroes to all of SVC 99 w/a
         LA    R1,S99RB
         ST    R1,S99RBPTR
         OI    S99RBPTR,X'80'
         MVI   S99RBLN,20          Length of SVC 99 request block
         OI    S99FLG11,S99NOCNV   Don't use existing allocation
         LA    R14,TUADSNAM        Allocation text unit pointers
         LA    R15,TUASTATS        " (VL bit set depending on call)
         LA    R0,TUAPERMA         "
         LA    R1,TUADDNAM         "
         LA    R2,TUAUNIT          "
         STM   R14,R2,TUPLALLC     "
         LA    R14,TUUDDNAM        Unallocation text unit pointers
         LA    R15,TUUUNALC        "
         STM   R14,R15,TUPLUNAL+0  "
         OI    TUPLUNAL+4,X'80'    "
         LA    R14,TUCDDNAM        Concatenation text unit pointers
         LA    R15,TUCPERMC        "
         STM   R14,R15,TUPLCCAT+0  "
         OI    TUPLCCAT+4,X'80'    "
*
         MVC   TUADSNAM(4),=Y(DALDSNAM,1)
         MVC   TUADDNAM(4),=Y(DALDDNAM,1)
         MVC   TUASTATS(6),=Y(DALSTATS,1,1)
*        MVC   TUAVLSER(6),=Y(DALVLSER,1,6)
         MVC   TUAUNIT(6),=Y(DALUNIT,1,4)
         MVC   TUAPERMA(2),=Y(DALPERMA)
         MVC   TUARTDDN(6),=Y(DALRTDDN,1,8)
         MVC   TUUDDNAM(4),=Y(DUNDDNAM,1)
         MVC   TUUUNALC(2),=Y(DUNUNALC)
         MVC   TUCDDNAM(2),=Y(DCCDDNAM)
         MVC   TUCPERMC(2),=Y(DCCPERMC)
*
***********************************************************************
*                                                                     *
* Invoke the PARSE service routine to get the parameters              *
*                                                                     *
***********************************************************************
*
         XC    ECB,ECB             Clear ECB
         CALLTSSR EP=IKJPARS,MF=(E,PPL) Call PARSE service routine
         LTR   R15,R15             If return code nonzero
         BNZ   RETURN12            then failure, return code(12)
*
***********************************************************************
*                                                                     *
* Set FRONT/BACK/INSERT/DELETE/SETUP and INFORM/etc.                  *
*                                                                     *
***********************************************************************
*
         L     R1,ANSWER
         USING PDL,R1
         MVC   WHAT(1),PWHAT+1     FRONT, BACK, INSERT, DELETE, SETUP
         XR    R15,R15             Clear insert register
         IC    R15,PINFORM+1       INFORM/ACTINFORM/FAILINFOR/NOINFORM
         STC   R15,MSGLEVEL        Save message level
NO_MSGLEVEL DS 0H
         DROP  R1
*
***********************************************************************
*                                                                     *
* Process each file(dsn dsn ...) combination.                         *
*                                                                     *
***********************************************************************
*                                                                     *
         USING FDB,R3              Addressability to file-ds blocks
         USING FDBDATAD,R6
         USING DSLIST,R4
         USING DSLDATAD,R5
*                                                                     *
         ICM   R3,15,FRSTFDB       Get address of first FDB
         BZ    ENDFDB              Skip if no FDB's
LOOPFDB  DS    0H
         BAL   R14,PROCFDB         Process this file
         LR    R1,R3               Get address of this FDB
         L     R0,FDBLEN           Get length of this FDB
         L     R3,FDBNEXT          Get address of next FDB and then...
         FREEMAIN R,LV=(0),A=(1)   free this FDB
         LTR   R3,R3               If there is another FDB
         BNZ   LOOPFDB             then go to process it
ENDFDB   DS    0H
*
* Finished.  Now figure out what return code to return.
*
         TM    FLAGS,DISASTER      If recovery failed and allocation
         BO    RETURN16            is munged, then return code(16)
         TM    FLAGS,DDFAILED      Else if a dd couldn't be processed
         BO    RETURN12            then return code(12)
         TM    FLAGS,DSNSKIPD      Else if some dsn's were bypassed
         BO    RETURN8             then return code(8)
         TM    FLAGS,DIDSTUFF      Else if reallocation was done
         BO    RETURN0             then return code(0)
         B     RETURN4             else no changes, return code(4)
*
RETURN16 LA    R2,16               Return with code 16
         B     FLUSH_STACK_AND_RETURN
RETURN12 LA    R2,12               Return with code 12
         B     FLUSH_STACK_AND_RETURN
RETURN8  LA    R2,8                Return with code 8
         B     RETURN
RETURN4  LA    R2,4                Return with code 4
         B     RETURN
RETURN0  XR    R2,R2               Return with code 0
         B     RETURN
         EJECT
FLUSH_STACK_AND_RETURN DS 0H       Return in failure
         TCLEARQ INPUT
         MVC   FLUSH(LENFLUSH),MFLUSH Set up stack list form
         XC    ECB,ECB             Clear ECB and flush the input stack
         STACK PARM=FLUSH,MF=(E,IOPL)
         LTR   R15,R15
         BZ    RETURN
         LA    R1,MSG_STACK_ERROR
         LA    R0,L'MSG_STACK_ERROR
         BAL   R14,PUTLINE
*
RETURN   DS    0H                  R2 contains return code
*
         IKJRLSA ANSWER            Free IKJPARS storage if any
*
         LR    R1,R13
         L     R13,4(,R13)
         ST    R2,16(,R13)         Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
*
PROCFDB  DS    0H
*
*
***********************************************************************
*                                                                     *
* This routine processes each file(dsn1 dsn2 dsn3 ...) specification. *
*                                                                     *
***********************************************************************
*                                                                     *
* R3 -> the current FDB (file-dataset block.                          *
*                                                                     *
***********************************************************************
*
         ST    R14,PROCFDB_R14     Save return register
         NI    FLAGS,255-DDFREED-DELETING  Clear appropriate flags
*
***********************************************************************
*                                                                     *
*      Determine the current allocation environment associated with   *
*      DDNAME filei.  Do this by scanning the TIOT for filei,         *
*      including its concatenations (i.e. any following blank dd's).  *
*      Acquire an area of storage large enough to hold information    *
*      for all the currently allocated data sets.  Then, from all     *
*      TIOT entries for these, collect the following information:     *
*                                                                     *
*       Data set name (from the JFCB)                                 *
*       (If a member name is present, abort this with an error.)      *
*       Volume serial (from the JFCB)                                 *
*       (If more than one volume, abort this with an error.)          *
*       Unit name (from the UCB)                                      *
*       (If not a DASD volume, abort this with an error.)             *
*                                                                     *
*      If the disposition is not SHR, abort this with an error.       *
*                                                                     *
*      In addition, the following text units must be present:         *
*                                                                     *
*       DDNAME (to be filled in later, NOT copied from TIOT)          *
*       Permanently allocated attribute                               *
*                                                                     *
***********************************************************************
*
* Scan the TIOT to see how many concatenated allocations to this file
*
         L     R15,X'21C'          TCB
         L     R15,12(,R15)        TIOT
         USING TIOT1,R15
         LA    R15,TIOENTRY        POINT TO FIRST TIOT ENTRY
         XR    R14,R14             CLEAR REG USED TO INSERT LENGTH
         XR    R2,R2               Set data set count to zero
LOOPTIOT DS    0H
         USING TIOENTRY,R15
         TM    TIOESTTA,TIOSLTYP   If TIOT entry not in use
         BO    SKIPTIOT            then skip this entry
         CLC   TIOEDDNM,FDBDDN     If TIOT ddname matches ours
         BE    GOTTIOT             then skip this entry
SKIPTIOT DS    0H
         IC    R14,TIOELNGH        Get length of current TIOT entry
         ALR   R15,R14             Add length to get to next entry
         CLI   TIOELNGH,X'00'      If not yet end of TIOT
         BNE   LOOPTIOT            then continue
         B     EXITTIOT            else we're through.
*
GOTTIOT  DS    0H                  Found our ddname
         LR    R8,R15              Save address of this entry
GOT_ANOTHER_TIOT DS 0H
         LA    R2,1(,R2)           Show at least 1 dataset allocated
SKIPTIOT2 DS   0H                  Scan for all following blank dd's
         IC    R14,TIOELNGH        Get length of current TIOT entry
         ALR   R15,R14             Add length to get to next entry
         CLI   TIOELNGH,X'00'      If end of TIOT
         BE    EXITTIOT            then we're through
LOOPTIOT2 DS   0H
         TM    TIOESTTA,TIOSLTYP   If TIOT entry not in use
         BO    SKIPTIOT2           then skip this entry
         CLC   TIOEDDNM,BLANKS     If TIOT ddname is not blank
         BE    GOT_ANOTHER_TIOT    then we're through.
******** B     EXITTIOT            then we're through.
*
EXITTIOT DS    0H                  Else we got nothing...
         DROP  R15
*
* R4 will -> DSLIST buffer for this file
* Assume number of allocations is in R2
* R8 -> TIOT entry for file (the first one)
*
         USING TIOENTRY,R8
         LR    R14,R2              Number of data sets allocated
         MH    R14,=Y(DSLDATAL)    Length of variable portion of dslist
         AH    R14,=Y(DSLISTL)     Length of fixed portion of dslist
         GETMAIN R,LV=(R14)        Get a DSLIST buffer
         LR    R4,R1               Address it
         ST    R14,DSLLEN          Save length of this DSLIST buffer
         AR    R14,R4
         ST    R14,DSLEND          Save address of end of the buffer
         STH   R2,DSLCOUNT         Save number of data sets
         LTR   R9,R2               Get number of datasets allocarted
         BZ    AFTDSL              If zero, then skip the following.
         LA    R5,DSLDATA          Point to first dataset section
*                                  R8 -> first TIOT entry for file
STORE_DSL_DATA_LOOP DS 0H          Loop through allocated data sets
*
* R8 -> each TIOT entry as we loop through (R9) times.
*
*----------------------------------------------------------------------
*
* Watch out - need SWA below the line to do this!!!!!!!!
*
*----------------------------------------------------------------------
*
         XR    R7,R7
         ICM   R7,7,TIOEJFCB       Get JFCB address
         LA    R7,16(,R7)          Bump past SWA prefix
         USING INFMJFCB,R7
         CLI   JFCBDSNM,C' '       If data set name is blank
         BE    ERROR_BLANK_DSNAME  then error - not a data set
         MVC   DSLDSN(44),JFCBDSNM Move JFCB data set name to DSLIST
         LA    R1,DSLDSN           Beginning of dsname
         LA    R2,DSLDSN+43        Last byte of dsname
GET_DSLDSN_BLANK DS 0H
         CLI   0(R2),C' '          Search for last nonblank
         BNE   GOT_DSLDSN_LENGTH
         BCT   R2,GET_DSLDSN_BLANK
GOT_DSLDSN_LENGTH DS 0H
         SR    R2,R1               Last blank minus start
         LA    R2,1(,R2)           plus 1
         STH   R2,DSLDSNL          gives length of data set name
         CLC   JFCBELNM(8),BLANKS  If member name is not blank
         BNE   ERROR_ALLOC_MEMBER  then error - allocated with member
         XR    R14,R14
         ICM   R14,7,TIOEFSRT      Get address of UCB
         BZ    ERROR_BAD_UCB_ADDR  If none, wrong kind of allocation
         USING UCBCMSEG,R14
         CLC   =CL3'UCB',UCBNAME   Get device name from UCB
         BE    USE_UCBCHAN_INSTEAD
         MVC   DSLUNAME(3),UCBNAME
         MVI   DSLUNAME+3,C' '
         B     UCBNAME_MOVED
USE_UCBCHAN_INSTEAD DS 0H
*        UNPK  DSLUNAME(5),UCBCHAN(3)
*        TR    DSLUNAME(4),HEXTBL
         MVC   DSLUNAME,BLANKS     4-digit device NG, don't use unit #
UCBNAME_MOVED       DS 0H
         CLI   JFCBNVOL,1          If more than 1 volume serial
         BH    ERROR_MULTIPLE_VOL  then error - multivolume data set
         MVC   DSLVOL(6),JFCBVOLS  Move JFCB volume serial to DSLIST
         TM    JFCBIND2,JFCSHARE   If disposition is not SHR
         BNO   ERROR_DISP_NOT_SHR  then error - invalid disposition
         MVI   DSLFLAGS,X'00'      Clear flags
         LA    R5,DSLDATAL(,R5)    Bump to next dataset section
         XR    R14,R14             Clear insert register
BUMP_TO_NEXT_TIOT_ENTRY DS 0H
         IC    R14,TIOELNGH            Get length of current TIOT entry
         ALR   R8,R14                  Add length to get to next entry
         TM    TIOESTTA,TIOSLTYP       If TIOT entry not in use
         BO    BUMP_TO_NEXT_TIOT_ENTRY then skip this entry
         BCT   R9,STORE_DSL_DATA_LOOP Continue until no more datasets
*
AFTDSL   DS    0H
         XR    R7,R7               Initialize concatenation stuff
         STH   R7,C9NUMBER
*
***********************************************************************
*                                                                     *
* Proceed depending on the value of the "what processing" keyword.    *
*                                                                     *
***********************************************************************
*
         CLI   WHAT,FRONT
         BE    DOFRONT
         CLI   WHAT,BACK
         BE    DOBACK
         CLI   WHAT,INSERT
         BE    DOINSERT
         CLI   WHAT,DELETE
         BE    DODELETE
         CLI   WHAT,SETUP
         BE    DOSETUP
         EJECT
DOFRONT  DS    0H
*
***********************************************************************
*                                                                     *
* This routine does processing when the keyword request is FRONT.     *
*                                                                     *
***********************************************************************
*
* If a ddname without dsnames was specified, take no action.
*
         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested
         BL    DONE                If none, take no action
         BH    DOFRONT_MULTIPLE_INPUT_DSNS If more than one, go...
*
* Only one input dsn specified for this ddname:
*
         LA    R6,FDBDATA          Point to first and only input dsn
*
* If filei is not allocated, then allocate filei to dsni and exit.
*
         CLC   DSLCOUNT,=H'0'      If there are no datasets
         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.
*
* If dsni is the first name in dslist, exit doing nothing.
*
         LA    R5,DSLDATA          Point to first dslist data set
         CLC   FDBDSN,DSLDSN       If requested dataset in front now,
         BE    DO_NOTHING          then exit - already allocated as is
*
* Set up the file name and the data set name to be allocated.
*
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   DDNAME,FDBDDN
         MVC   DDNAMEL,FDBDDNL
*
* Remove all occurrences of input dsn from dslist so that they will
* be "moved" from their currently-allocated position to the front.
*
         BAL   R14,REMOVEI         Remove DSNAME from DSLIST
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* Allocate filei to dsni.
*
         MVC   UNIT,BLANKS
         BAL   R14,ALLOC1          Allocate the file to the dataset.
         LTR   R15,R15             If failure
         BZ    DOFRONT_OK_SO_FAR   then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
DOFRONT_OK_SO_FAR DS 0H
*
* For each non-removed dataset in dslist, generate a file name and
* allocate that file name to the dataset.
*
         LA    R5,DSLDATA
         LH    R9,DSLCOUNT
         LTR   R9,R9
         BZ    DOFRONT_END_LOOP
DOFRONT_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOFRONT_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOFRONT_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOFRONT_LOOP
*
DOFRONT_END_LOOP DS 0H
         B     DO_CONCATENATION    Go concatenate allocated files.
*
DOFRONT_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested
*
* If filei is not allocated, then just allocate the dsns to filei.
*
         MVC   DDNAME,FDBDDN       Set up ddname
         MVC   DDNAMEL,FDBDDNL
         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname
         BE    DOFRONT_ALLOCATE_MI then just allocate input dsns.
*
* If the first n data set names in the dslist match the dsni's, exit.
*
         LA    R5,DSLDATA          Point to allocated dsnames list
         LA    R6,FDBDATA          Point to requested dsnames list
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
         CH    R9,DSLCOUNT         If more dsns wanted than allocated
         BH    DOFRONT_MATCH_LOST  then input dsn's don't all match up
DOFRONT_MATCH_LOOP DS 0H
         C     R5,DSLEND           If we reached end of dslist
         BNL   DOFRONT_MATCH_LOST  then input dsns don't all match up
         CLC   FDBDSN,DSLDSN       If data set names don't match
         BNE   DOFRONT_MATCH_LOST  then input dsns don't all match up
         LA    R5,DSLDATAL(,R5)    Bump
         LA    R6,FDBDATAL(,R6)    Bump
         BCT   R9,DOFRONT_MATCH_LOOP Loop
         B     DO_NOTHING          If we made it, all match, do nothing
DOFRONT_MATCH_LOST DS 0H           Otherwise they don't all match...
*
* For each dsnij found somewhere in the dslist, remove it from dslist.
*
         LA    R6,FDBDATA          Point to requested dsnames list
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
DOFRONT_REMOVEI_LOOP DS 0H         For each requested dsname...
         MVC   DSNAME,FDBDSN
         BAL   R14,REMOVEI          Remove DSNAME from DSLIST
         LA    R6,FDBDATAL(,R6)
         BCT   R9,DOFRONT_REMOVEI_LOOP
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For j = 1 thru n, allocate files to dsnij's.  The first allocation
* will be to filei, and the others will be to generated file names.
* (Note that we come here when filei isn't already allocated.)
*
DOFRONT_ALLOCATE_MI DS 0H
         LA    R6,FDBDATA          Point to first requested dataset.
         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)
DOFRONT_MI_LOOP DS 0H
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   UNIT,BLANKS
         BAL   R14,ALLOC1          Allocate the dsname
         LTR   R15,R15             If failure
         BZ    DOFRONT_MI_CONTINUE  then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
DOFRONT_MI_CONTINUE DS 0H
         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.
         BCT   R9,DOFRONT_MI_LOOP
*
* For each non-removed dataset in dslist, generate a file name
* and allocate that file name to the dataset.
* (There may be none in dslist, so take that into account.)
*
         LA    R5,DSLDATA
         LH    R9,DSLCOUNT
         LTR   R9,R9
         BZ    DOFRONT_MO_END_LOOP
DOFRONT_MO_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOFRONT_MO_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOFRONT_MO_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOFRONT_MO_LOOP
*
DOFRONT_MO_END_LOOP DS 0H
         B     DO_CONCATENATION    Go concatenate allocated files.
         EJECT
DOBACK   DS    0H
*
***********************************************************************
*                                                                     *
* This routine does processing when the keyword request is BACK.      *
*                                                                     *
***********************************************************************
*
* If a ddname without dsnames was specified, take no action.
*
         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested
         BL    DONE                If none, take no action
         BH    DOBACK_MULTIPLE_INPUT_DSNS If more than one, go...
*
* Only one input dsn specified for this ddname:
*
         LA    R6,FDBDATA          Point to first and only input dsn
*
* If filei is not allocated, then allocate filei to dsni and exit.
*
         CLC   DSLCOUNT,=H'0'      If there are no datasets
         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.
*
* If dsni is the last name in dslist, exit doing nothing.
*
         L     R5,DSLEND
         SH    R5,=Y(DSLDATAL)     Point to last dslist data set
         CLC   FDBDSN,DSLDSN       If requested dataset in back now,
         BE    DO_NOTHING          then exit - already allocated as is
*
* Remove all occurrences of input dsn from dslist so that they will
* be "moved" from their currently-allocated position to the back.
*
         MVC   DSNAME,FDBDSN
         BAL   R14,REMOVEI         Remove DSNAME from DSLIST
*
* Unallocate filei.
*
         MVC   DDNAME,FDBDDN
         MVC   DDNAMEL,FDBDDNL
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For each non-removed dataset in dslist, allocate that dataset.
*
         LA    R5,DSLDATA
         LH    R9,DSLCOUNT
         LTR   R9,R9
         BZ    DOBACK_END_LOOP
DOBACK_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOBACK_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOBACK_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOBACK_LOOP
DOBACK_END_LOOP DS 0H
*
* Allocate dsni.
*
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   UNIT,BLANKS
         BAL   R14,ALLOC1          Allocate the file to the dataset.
         LTR   R15,R15             If failure
         BZ    DOBACK_OK_SO_FAR    then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
DOBACK_OK_SO_FAR DS 0H
         B     DO_CONCATENATION    Go concatenate allocated files.
*
DOBACK_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested
*
* If filei is not allocated, then just allocate the dsns to filei.
*
         MVC   DDNAME,FDBDDN       Set up ddname
         MVC   DDNAMEL,FDBDDNL
         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname
         BE    DOBACK_ALLOCATE_MI then just allocate input dsns.
*
* If the last n data set names in the dslist match the dsni's, exit.
*
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
         CH    R9,DSLCOUNT         If more dsns wanted than allocated
         BH    DOBACK_MATCH_LOST   then input dsn's don't all match up
         L     R5,DSLEND
         LA    R1,DSLDATAL
         MH    R1,FDBCOUNT
         SR    R5,R1               Point to nth-from-last data set
         LA    R6,FDBDATA          Point to requested dsnames list
DOBACK_MATCH_LOOP DS 0H
         C     R5,DSLEND           If we reached end of dslist
         BNL   DOBACK_MATCH_LOST   then input dsns don't all match up
         CLC   FDBDSN,DSLDSN       If data set names don't match
         BNE   DOBACK_MATCH_LOST   then input dsns don't all match up
         LA    R5,DSLDATAL(,R5)    Bump
         LA    R6,FDBDATAL(,R6)    Bump
         BCT   R9,DOBACK_MATCH_LOOP Loop
         B     DO_NOTHING          If we made it, all match, do nothing
DOBACK_MATCH_LOST DS 0H            Otherwise they don't all match...
*
* For each dsnij found somewhere in the dslist, remove it from dslist.
*
         LA    R6,FDBDATA          Point to requested dsnames list
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
DOBACK_REMOVEI_LOOP DS 0H          For each requested dsname...
         MVC   DSNAME,FDBDSN
         BAL   R14,REMOVEI          Remove DSNAME from DSLIST
         LA    R6,FDBDATAL(,R6)
         BCT   R9,DOBACK_REMOVEI_LOOP
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For each non-removed dataset in dslist, allocate that dataset.
* The first allocation will be to filei, and the others will be to
* generated file names.
* (There may be none in dslist, so take that into account.)
*
         LA    R5,DSLDATA
         LH    R9,DSLCOUNT
         LTR   R9,R9
         BZ    DOBACK_MO_END_LOOP
DOBACK_MO_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOBACK_MO_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOBACK_MO_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOBACK_MO_LOOP
DOBACK_MO_END_LOOP DS 0H
*
* For j = 1 thru n, allocate files to dsnij's.  The first allocation
* was to filei, and the others will be to generated file names.
* (Note that we come here when filei isn't already allocated.)
*
DOBACK_ALLOCATE_MI DS 0H
         LA    R6,FDBDATA          Point to first requested dataset.
         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)
DOBACK_MI_LOOP DS 0H
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   UNIT,BLANKS
         BAL   R14,ALLOC1          Allocate the dsname
         LTR   R15,R15             If failure
         BZ    DOBACK_MI_CONTINUE   then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
DOBACK_MI_CONTINUE DS 0H
         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.
         BCT   R9,DOBACK_MI_LOOP
         B     DO_CONCATENATION    Go concatenate allocated files.
         EJECT
DOINSERT DS    0H
*
***********************************************************************
*                                                                     *
* This routine does processing when the keyword request is INSERT.    *
*                                                                     *
***********************************************************************
*
* If a ddname without dsnames was specified, take no action.
*
         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested
         BL    DONE                If none, take no action
         BH    DOINSERT_MULTIPLE_INPUT_DSNS If more than one, go...
*
* Only one input dsn specified for this ddname:
*
         LA    R6,FDBDATA          Point to first and only input dsn
*
* If filei is not allocated, then allocate filei to dsni and exit.
*
         CLC   DSLCOUNT,=H'0'      If there are no datasets
         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.
*
* Find the first "system" data set in the dslist.
* If there is none, then go to process as for BACK.
*
* Note: A "system" data set is currently considered to be a data set
*       whose high-level qualifier is one of the following:
*
*       SYS1, CSD, ISP, SYSALL, CCF                             #TSO158
*
         LA    R5,DSLDATA          Point to first data set in dslist
         XR    R1,R1               Clear before-system-ds counter
DOINSERT_FIND_SYSTEM_DS_LOOP DS 0H
         C     R5,DSLEND           Loop until end of dslist
         BNL   DOBACK              If none, go process like BACK
         CLC   =C'SYS1.',DSLDSN    Test for system-data-set-ness
         BE    DOINSERT_FOUND_SYSTEM_DS
         CLC   =C'CSD.',DSLDSN
         BE    DOINSERT_FOUND_SYSTEM_DS
         CLC   =C'ISP.',DSLDSN
         BE    DOINSERT_FOUND_SYSTEM_DS
         CLC   =C'SYSALL.',DSLDSN
         BE    DOINSERT_FOUND_SYSTEM_DS
         CLC   =C'CCF.',DSLDSN                                  #TSO158
         BE    DOINSERT_FOUND_SYSTEM_DS                         #TSO158
         LA    R1,1(,R1)           Increment before-system-ds counter
         LA    R5,DSLDATAL(,R5)
         B     DOINSERT_FIND_SYSTEM_DS_LOOP
DOINSERT_FOUND_SYSTEM_DS DS 0H
         ST    R5,PSYSDS           Save address of system data set
*
* If the first "system" data set is the same as dsni, then do nothing.
*
         CLC   DSLDSN,FDBDSN
         BE    DO_NOTHING
*
* If the first data set in dslist is a "system" data set,
* then go to process as for FRONT.
*
         LTR   R1,R1               If no before-system-ds data sets
         BZ    DOFRONT             then go process like FRONT
*
         SH    R5,=Y(DSLDATAL)     Get address of dataset before sys ds
         ST    R5,BSYSDS           Save it
         STH   R1,BSDCOUNT         # of datasets before system one
         LH    R15,DSLCOUNT        Get total dslist count
         SR    R15,R1              Subtract before-system count
         STH   R15,PSDCOUNT        # of datasets from system one onward
*
* If dsni immediately precedes the first "system" data set, do nothing.
*
         L     R5,BSYSDS           Point to first "system" data set
         CLC   DSLDSN,FDBDSN
         BE    DO_NOTHING
*
* Remove all occurrences of input dsn from dslist so that they will
* be "moved" from their currently-allocated position to the INSERT.
*
         MVC   DSNAME,FDBDSN
         BAL   R14,REMOVEI         Remove DSNAME from DSLIST
*
* Unallocate filei.
*
         MVC   DDNAME,FDBDDN
         MVC   DDNAMEL,FDBDDNL
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For each non-removed dataset in dslist, up to but not including the
* first "system" data set, allocate that dataset.
*
         LA    R5,DSLDATA
         LH    R9,BSDCOUNT
         LTR   R9,R9
         BZ    DOINSERT_BEFORE_END_LOOP
DOINSERT_BEFORE_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOINSERT_BEFORE_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOINSERT_BEFORE_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOINSERT_BEFORE_LOOP
DOINSERT_BEFORE_END_LOOP DS 0H
*
* Allocate dsni.
*
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   UNIT,BLANKS
         BAL   R14,ALLOC1          Allocate the file to the dataset.
         LTR   R15,R15             If failure
         BZ    DOINSERT_OK_SO_FAR  then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
DOINSERT_OK_SO_FAR DS 0H
*
* For each non-removed dataset in dslist starting from the first
* "system" data set, allocate that data set.
*
         L     R5,PSYSDS
         LH    R9,PSDCOUNT
         LTR   R9,R9
         BZ    DOINSERT_AFTER_END_LOOP
DOINSERT_AFTER_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOINSERT_AFTER_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOINSERT_AFTER_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOINSERT_AFTER_LOOP
DOINSERT_AFTER_END_LOOP DS 0H
         B     DO_CONCATENATION    Go concatenate allocated files.
*
DOINSERT_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested
*
* If filei is not allocated, then just allocate the dsns to filei.
*
         MVC   DDNAME,FDBDDN       Set up ddname
         MVC   DDNAMEL,FDBDDNL
         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname
         BE    DOINSERT_ALLOCATE_MI then just allocate input dsns.
*
* Find the first "system" data set in the dslist.
* If there is none, then go to process as for BACK.
*
* Note: A "system" data set is currently considered to be a data set
*       whose high-level qualifier is one of the following:
*
*       SYS1, CSD, ISP, SYSALL, CCF                             #TSO158
*
         LA    R5,DSLDATA          Point to first data set in dslist
         XR    R1,R1               Clear before-system-ds counter
DOINSERT_MIND_SYSTEM_DS_LOOP DS 0H
         C     R5,DSLEND           Loop until end of dslist
         BNL   DOBACK              If none, then go process like BACK
         CLC   =C'SYS1.',DSLDSN    Test for system-data-set-ness
         BE    DOINSERT_MOUND_SYSTEM_DS
         CLC   =C'CSD.',DSLDSN
         BE    DOINSERT_MOUND_SYSTEM_DS
         CLC   =C'ISP.',DSLDSN
         BE    DOINSERT_MOUND_SYSTEM_DS
         CLC   =C'SYSALL.',DSLDSN
         BE    DOINSERT_MOUND_SYSTEM_DS
         CLC   =C'CCF.',DSLDSN                                  #TSO158
         BE    DOINSERT_MOUND_SYSTEM_DS                         #TSO158
         LA    R1,1(,R1)           Increment before-system-ds counter
         LA    R5,DSLDATAL(,R5)
         B     DOINSERT_MIND_SYSTEM_DS_LOOP
DOINSERT_MOUND_SYSTEM_DS DS 0H
*
* If the first data set in dslist is a "system" data set,
* then go to process as for FRONT.
*
         LTR   R1,R1               If no before-system-ds data sets
         BZ    DOFRONT             then go process like FRONT
*
* Else save info about where the first "system" data set is.
*
         ST    R5,PSYSDS           Save address of system data set
         SH    R5,=Y(DSLDATAL)     Get address of dataset before sys ds
         ST    R5,BSYSDS           Save it
         STH   R1,BSDCOUNT         # of datasets before system one
         LH    R15,DSLCOUNT        Get total dslist count
         SR    R15,R1              Subtract before-system count
         STH   R15,PSDCOUNT        # of datasets from system ds onward
*
* If the first n data sets in the portion of dslist starting with the
* first "system" data set matches the dsni's, then exit doing nothing.
*
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
         CH    R9,PSDCOUNT         If more dsns wanted than allocated
         BH    DOINSERT_SYS_LOST   then input dsn's don't all match up
         L     R5,PSYSDS           Point to first "system" data set
         LA    R6,FDBDATA          Point to requested dsnames list
DOINSERT_SYS_LOOP DS 0H
         C     R5,DSLEND           If we reached end of dslist
         BNL   DOINSERT_SYS_LOST   then input dsns don't all match up
         CLC   FDBDSN,DSLDSN       If data set names don't match
         BNE   DOINSERT_SYS_LOST   then input dsns don't all match up
         LA    R5,DSLDATAL(,R5)    Bump
         LA    R6,FDBDATAL(,R6)    Bump
         BCT   R9,DOINSERT_SYS_LOOP Loop
         B     DO_NOTHING          If we made it, all match, do nothing
DOINSERT_SYS_LOST DS 0H            Otherwise they don't all match...
*
* If the last n data set names in the dslist preceding the first
* "system" data set match the dsni's, then exit doing nothing.
*
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
         CH    R9,BSDCOUNT         If more dsns wanted than alloc'd
         BH    DOINSERT_BEF_LOST   then input dsn's don't all match up
         L     R5,PSYSDS
         LA    R1,DSLDATAL
         MH    R1,FDBCOUNT
         SR    R5,R1               Point to nth-from-system data set
         LA    R6,FDBDATA          Point to requested dsnames list
DOINSERT_BEF_LOOP DS 0H
         C     R5,DSLEND           If we reached end of dslist
         BNL   DOINSERT_BEF_LOST   then input dsns don't all match up
         CLC   FDBDSN,DSLDSN       If data set names don't match
         BNE   DOINSERT_BEF_LOST   then input dsns don't all match up
         LA    R5,DSLDATAL(,R5)    Bump
         LA    R6,FDBDATAL(,R6)    Bump
         BCT   R9,DOINSERT_BEF_LOOP Loop
         B     DO_NOTHING          If we made it, all match, do nothing
DOINSERT_BEF_LOST DS 0H            Otherwise they don't all match...
*
* For each dsnij found somewhere in the dslist, remove it from dslist.
*
         LA    R6,FDBDATA          Point to requested dsnames list
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
DOINSERT_REMOVEI_LOOP DS 0H        For each requested dsname...
         MVC   DSNAME,FDBDSN
         BAL   R14,REMOVEI          Remove DSNAME from DSLIST
         LA    R6,FDBDATAL(,R6)
         BCT   R9,DOINSERT_REMOVEI_LOOP
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For each non-removed dataset in dslist, up to but not including the
* first "system" data set, allocate that dataset.
*
         LA    R5,DSLDATA
         LH    R9,BSDCOUNT
         LTR   R9,R9
         BZ    DOINSERT_MO_BEFORE_END_LOOP
DOINSERT_MO_BEFORE_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOINSERT_MO_BEFORE_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOINSERT_MO_BEFORE_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOINSERT_MO_BEFORE_LOOP
DOINSERT_MO_BEFORE_END_LOOP DS 0H
*
* For j = 1 thru n, allocate files to dsnij's.  The first allocation
* was to filei, and the others will be to generated file names.
* (Note that we come here when filei isn't already allocated.)
*
DOINSERT_ALLOCATE_MI DS 0H
         LA    R6,FDBDATA          Point to first requested dataset.
         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)
DOINSERT_MI_LOOP DS 0H
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   UNIT,BLANKS
         BAL   R14,ALLOC1          Allocate the dsname
         LTR   R15,R15             If failure
         BZ    DOINSERT_MI_CONTINUE then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
DOINSERT_MI_CONTINUE DS 0H
         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.
         BCT   R9,DOINSERT_MI_LOOP
*
* For each non-removed dataset in dslist starting from the first
* "system" data set, allocate that data set.
*
         L     R5,PSYSDS
         LH    R9,PSDCOUNT
         LTR   R9,R9
         BZ    DOINSERT_MO_AFTER_END_LOOP
DOINSERT_MO_AFTER_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DOINSERT_MO_AFTER_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DOINSERT_MO_AFTER_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DOINSERT_AFTER_LOOP
DOINSERT_MO_AFTER_END_LOOP DS 0H
         B     DO_CONCATENATION    Go concatenate allocated files.
         EJECT
DODELETE DS    0H
*
***********************************************************************
*                                                                     *
* This routine does processing when the keyword request is DELETE.    *
*                                                                     *
***********************************************************************
*
         OI    FLAGS,DELETING      Show we are deleting
*
* If a ddname without dsnames was specified, take no action.
*
         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested
         BL    DONE                If none, take no action
         BH    DODELETE_MULTIPLE_INPUT_DSNS If more than one, go...
*
* Only one input dsn specified for this ddname:
*
         LA    R6,FDBDATA          Point to first and only input dsn
*
* If filei is not allocated, then do nothing and exit.
*
         CLC   DSLCOUNT,=H'0'      If there are no datasets
         BE    DO_NOTHING          then go allocate filei to dsni.
*
* Set up the file name and the data set name to be removed therefrom.
*
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   DDNAME,FDBDDN
         MVC   DDNAMEL,FDBDDNL
*
* Remove all occurrences of input dsn from dslist.
* If no names were removed, there is no need to reallocate the file.
*
         BAL   R14,REMOVEI         Remove DSNAME from DSLIST
         LTR   R1,R1               If no dsnames were removed
         BZ    DO_NOTHING          then exit, nothing to be done
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For each non-removed dataset in dslist, allocate that dataset.
* The first allocation will use the specified file name, and others
* will use a system-generated file name.
*
         LA    R5,DSLDATA
         LH    R9,DSLCOUNT
         LTR   R9,R9
         BZ    DODELETE_END_LOOP
DODELETE_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DODELETE_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DODELETE_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DODELETE_LOOP
*
DODELETE_END_LOOP DS 0H
         B     DO_CONCATENATION    Go concatenate allocated files.
*
DODELETE_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested
*
* If filei is not allocated, then do nothing and exit.
*
         MVC   DDNAME,FDBDDN       Set up ddname
         MVC   DDNAMEL,FDBDDNL
         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname
         BE    DO_NOTHING          then nothing to be done
*
* For each dsnij found somewhere in the dslist, remove it from dslist.
*
         XR    R2,R2               Clear count of removed dsns
         LA    R6,FDBDATA          Point to requested dsnames list
         LH    R9,FDBCOUNT         Get requested-dsnames count (> 1)
DODELETE_REMOVEI_LOOP DS 0H        For each requested dsname...
         MVC   DSNAME,FDBDSN
         BAL   R14,REMOVEI         Remove DSNAME from DSLIST
         NI    FDBFLAGS,255-FDBDELNF Preset dataset-found flag
         LTR   R1,R1               If requested dataset was not found,
         BNZ   DODELETE_REMOVEI_NF then...
         OI    FDBFLAGS,FDBDELNF    indicate so in file-dataset block
DODELETE_REMOVEI_NF DS 0H
         AR    R2,R1               Accumulate removed-dsn count
         LA    R6,FDBDATAL(,R6)
         BCT   R9,DODELETE_REMOVEI_LOOP
         LTR   R2,R2               If nothing was removed
         BZ    DO_NOTHING          then leave allocation as is
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For each non-removed dataset in dslist, generate a file name
* and allocate that file name to the dataset.
* (There may be none in dslist, so take that into account.)
*
         LA    R5,DSLDATA
         LH    R9,DSLCOUNT
         LTR   R9,R9
         BZ    DODELETE_MO_END_LOOP
DODELETE_MO_LOOP DS 0H
         TM    DSLFLAGS,DSLREMOV   Skip names that were "removed"
         BO    DODELETE_MO_CONTINUE
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
DODELETE_MO_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,DODELETE_MO_LOOP
*
DODELETE_MO_END_LOOP DS 0H
         B     DO_CONCATENATION    Go concatenate allocated files.
         EJECT
DOSETUP  DS    0H
*
***********************************************************************
*                                                                     *
* This routine does processing when the keyword request is SETUP.     *
*                                                                     *
***********************************************************************
*
* If a ddname without dsnames was specified, take no action except for
* freeing the file.
*
         CLC   FDBCOUNT,=H'1'      Check number of dsnames requested
         BL    UNSETUP             If none, just free the file.
         BH    DOSETUP_MULTIPLE_INPUT_DSNS If more than one, go...
*
* Only one input dsn specified for this ddname:
*
         LA    R6,FDBDATA          Point to first and only input dsn
*
* If filei is not allocated, then allocate filei to dsni and exit.
*
         CLC   DSLCOUNT,=H'0'      If there are no datasets
         BE    SINGLE_ALLOCATE     then go allocate filei to dsni.
*
* Set up the file name and the data set name to be allocated.
*
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   DDNAME,FDBDDN
         MVC   DDNAMEL,FDBDDNL
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* Allocate filei to dsni.
*
         B     SINGLE_ALLOCATE     Go allocate filei to dsni.
*
DOSETUP_MULTIPLE_INPUT_DSNS DS 0H More than one input DSN requested
*
* If filei is not allocated, then just allocate the dsns to filei.
*
         MVC   DDNAME,FDBDDN       Set up ddname
         MVC   DDNAMEL,FDBDDNL
         CLC   DSLCOUNT,=H'0'      If no datasets allocated to ddname
         BE    DOSETUP_ALLOCATE_MI then just allocate input dsns.
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
*
* For j = 1 thru n, allocate files to dsnij's.  The first allocation
* will be to filei, and the others will be to generated file names.
* (Note that we come here when filei isn't already allocated.)
*
DOSETUP_ALLOCATE_MI DS 0H
         LA    R6,FDBDATA          Point to first requested dataset.
         LH    R9,FDBCOUNT         Get # of requested dsnames (> 1)
DOSETUP_MI_LOOP DS 0H
         MVC   DSNAME,FDBDSN
         MVC   DSNAMEL,FDBDSNL
         MVC   UNIT,BLANKS
         BAL   R14,ALLOC1          Allocate the dsname
         LTR   R15,R15             If failure
         BZ    DOSETUP_MI_CONTINUE  then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
DOSETUP_MI_CONTINUE DS 0H
         LA    R6,FDBDATAL(,R6)    Bump to next dsn in dslist.
         BCT   R9,DOSETUP_MI_LOOP
         B     DO_CONCATENATION    Go concatenate allocated files.
UNSETUP  DS    0H
*
* If filei with no dsni's specified, just free indicated file.
*
         MVC   DDNAME,FDBDDN
         MVC   DDNAMEL,FDBDDNL
*
* Unallocate filei.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         OI    FLAGS,DDFREED       Else indicate file's been freed.
         B     NOTIFY
         EJECT
DO_CONCATENATION DS 0H
*
* Concatenate filei with the list of generated file names.
*
         BAL   R14,CONCAT1         Do concatenation
         LTR   R15,R15             If failure
         BNZ   FAILED               then abort.
         B     NOTIFY              Return.
         EJECT
SINGLE_ALLOCATE DS 0H              Allocate one file to one dsn.
*
* It is assumed that R6 already points to the correct FDBDATA entry.
*
         BCTR  R7,0                Indicate no concatenation wanted
         MVC   DDNAME,FDBDDN       Set up file name
         MVC   DDNAMEL,FDBDDNL
         MVC   DSNAME,FDBDSN       Set up data set name
         MVC   DSNAMEL,FDBDSNL
         MVC   UNIT,BLANKS         Volume/unit not known
         BAL   R14,ALLOC1          Allocate the file to the dataset
         LTR   R15,R15             If allocation failed
         BZ    NOTIFY              then
         OI    FDBFLAGS,FDBERROR    indicate so
         OI    FLAGS,DSNSKIPD       indicate we're skipping a dataset
         B     NOTIFY              Return with allocation.
         EJECT
DO_NOTHING DS 0H                   Exit doing nothing
         CLI   MSGLEVEL,INFORM     Display messages only for INFORM
         BH    DO_NOTHING_END
         LA    R6,FDBDATA
         LH    R9,FDBCOUNT
         LTR   R9,R9
         BZ    DO_NOTHING_END
DO_NOTHING_LOOP DS 0H
         BAL   R14,NOTIFY_NOTHING
         LA    R6,FDBDATAL(,R6)
         BCT   R9,DO_NOTHING_LOOP
DO_NOTHING_END DS 0H
         B     DONE
         EJECT
NOTIFY   DS    0H
         OI    FLAGS,DIDSTUFF      Show something has been changed
         LA    R6,FDBDATA
         LH    R9,FDBCOUNT
         LTR   R9,R9
         BZ    NOTIFY_END
NOTIFY_LOOP DS 0H
         TM    FDBFLAGS,FDBDELNF
         BO    ALLOCATED_NOTHING
         TM    FDBFLAGS,FDBERROR
         BO    ALLOCATED_BAD
         BAL   R14,NOTIFY_GOOD
         B     ALLOCATED_GOOD_OR_BAD
ALLOCATED_NOTHING DS 0H
         BAL   R14,NOTIFY_NOTHING
         B     ALLOCATED_GOOD_OR_BAD
ALLOCATED_BAD DS 0H
         BAL   R14,NOTIFY_BAD
******** B     ALLOCATED_GOOD_OR_BAD
ALLOCATED_GOOD_OR_BAD DS 0H
         LA    R6,FDBDATAL(,R6)
         BCT   R9,NOTIFY_LOOP
NOTIFY_END DS  0H
******** B     DONE
         EJECT
DONE     DS    0H
*
***********************************************************************
*                                                                     *
* Allocations finished for this file.  Free DSLIST buffer and return. *
*                                                                     *
***********************************************************************
*
         L     R0,DSLLEN           Get length of DSLIST buffer
         FREEMAIN R,LV=(0),A=(R4)  Free the DSLIST buffer
         L     R14,PROCFDB_R14     Load return register
         BR    R14                 Return to caller
         EJECT
FAILED   DS    0H                  Here if reallocation failed
*
         OI    FLAGS,DDFAILED      Indicate failure and recovery coming
         LA    R6,FDBDATA
         LH    R9,FDBCOUNT
         LTR   R9,R9
         BZ    FAILED_END
FAILED_LOOP DS 0H
         BAL   R14,NOTIFY_BAD
         LA    R6,FDBDATAL(,R6)
         BCT   R9,FAILED_LOOP
FAILED_END DS  0H
******** B     RECOVER
         EJECT
RECOVER  DS    0H
*
***********************************************************************
*                                                                     *
*     Recovery step, executed only if an allocation or concatenation  *
*     fails.  This attempts to reallocate the original datasets to    *
*     the specified file name.                                        *
*                                                                     *
* Any failure here is a major disaster and should be reported as such *
*                                                                     *
***********************************************************************
*
* If file has not been unallocated, no recovery is necessary.
*
         TM    FLAGS,DDFREED
         BZ    DONE
*
* Restore original dslist (i.e. "unremove" any removed dsns).
*
         LA    R5,DSLDATA          Point to first data entry
         LH    R9,DSLCOUNT          Number of times to loop
         LTR   R9,R9
         BZ    RECOVER_UNREMOVE_END If none, finished
RECOVER_UNREMOVE_LOOP DS 0H
         NI    DSLFLAGS,255-DSLREMOV Unmark dataset as not removed
         LA    R5,DSLDATAL(,R5)    Bump to next entry
         BCT   R9,RECOVER_UNREMOVE_LOOP and continue search.
RECOVER_UNREMOVE_END DS 0H
         XR    R7,R7               Clear concatenation register
         MVC   DDNAME,FDBDDN       Set file name to be processed
         MVC   DDNAMEL,FDBDDNL
*
* Unallocate filei if necessary.
*
         BAL   R14,FREE1           Unallocate the file.
         LTR   R15,R15             If failure
         BNZ   RECOVER_FAILED       then we're really in trouble.
*
* If dslist is empty, exit.
*
         CLC   DSLCOUNT,=H'0'
         BE    RECOVER_DONE
*
* For each of the datasets in dslist, allocate it.  The first one will
* be allocated to the file name and the others will get generated ones.
*
         LA    R5,DSLDATA          Point to first dslist entry
         LH    R9,DSLCOUNT         Get count of data set names
         LTR   R9,R9
         BZ    RECOVER_END_LOOP
RECOVER_LOOP DS 0H
         MVC   DSNAME,DSLDSN
         MVC   DSNAMEL,DSLDSNL
         MVC   UNIT,DSLUNAME
         BAL   R14,ALLOC1          Allocate the dsn to a temp ddname
         LTR   R15,R15             If failure
         BNZ   RECOVER_FAILED       then abort.
RECOVER_CONTINUE DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next dsn in dslist.
         BCT   R9,RECOVER_LOOP
RECOVER_END_LOOP DS 0H
*
* Concatenate filei with the list of generated file names.
*
         BAL   R14,CONCAT1         Do concatenation
         LTR   R15,R15             If failure
         BNZ   RECOVER_FAILED       then abort.
*
RECOVER_DONE DS 0H                 Recovery successful.
         NI    FLAGS,255-DDFREED   Reset damage-done flag.
         B     DONE
*
RECOVER_FAILED DS 0H
         OI    FLAGS,DISASTER      Indicate we really are in trouble
         MVC   MSGWA(L'MSG_RECOVER_NG_1),MSG_RECOVER_NG_1
         LH    R15,FDBDDNL
         BCTR  R15,0
         EX    R15,MVC_RECOVER_NG_DDNAME
         LA    R1,MSGWA+L'MSG_RECOVER_NG_1+1(R15)
         MVC   0(L'MSG_RECOVER_NG_2,R1),MSG_RECOVER_NG_2
         LA    R0,L'MSG_RECOVER_NG_2(,R1)
         LA    R1,MSGWA
         SR    R0,R1
         XR    R1,R1
         BAL   R14,PUTLINE
         B     DONE
*
MVC_RECOVER_NG_DDNAME MVC MSGWA+L'MSG_RECOVER_NG_1(*-*),FDBDDN
*
         EJECT
NOTIFY_GOOD DS 0H
         CLI   MSGLEVEL,ACTINFORM  Display messages only for
         BHR   R14                  INFORM and ACTINFORM
         ST    R14,NOTIFY_R14
         MVC   MSGWA(L'MSG_ALLOCED_1),MSG_ALLOCED_1
         LH    R15,FDBDSNL
         BCTR  R15,0
         EX    R15,MVC_ALLOCED_DSNAME
         LA    R1,MSGWA+L'MSG_ALLOCED_1+1(R15)
         TM    FLAGS,DELETING
         BO    NOTIFY_GOOD_DELETING
         MVC   0(L'MSG_ALLOCED_2,R1),MSG_ALLOCED_2
         LH    R15,FDBDDNL
         BCTR  R15,0
         EX    R15,MVC_ALLOCED_2_DDNAME
         LA    R1,L'MSG_ALLOCED_2+1(R15,R1)
         B     NOTIFY_GOOD_AFT_DELETING
NOTIFY_GOOD_DELETING DS 0H
         MVC   0(L'MSG_ALLOCED_4,R1),MSG_ALLOCED_4
         LH    R15,FDBDDNL
         BCTR  R15,0
         EX    R15,MVC_ALLOCED_4_DDNAME
         LA    R1,L'MSG_ALLOCED_4+1(R15,R1)
NOTIFY_GOOD_AFT_DELETING DS 0H
         MVC   0(L'MSG_ALLOCED_3,R1),MSG_ALLOCED_3
         LA    R0,L'MSG_ALLOCED_3(,R1)
         LA    R1,MSGWA
         SR    R0,R1
         XR    R1,R1
         BAL   R14,PUTLINE
         L     R14,NOTIFY_R14
         BR    R14
*
MVC_ALLOCED_DSNAME MVC MSGWA+L'MSG_ALLOCED_1(*-*),FDBDSN
MVC_ALLOCED_2_DDNAME MVC L'MSG_ALLOCED_2(*-*,R1),FDBDDN
MVC_ALLOCED_4_DDNAME MVC L'MSG_ALLOCED_4(*-*,R1),FDBDDN
*
         EJECT
NOTIFY_BAD  DS 0H
         CLI   MSGLEVEL,FAILINFORM Display messages only for
         BHR   R14                  INFORM, ACTINFORM, FAILINFORM
         ST    R14,NOTIFY_R14
         TM    FLAGS,DELETING
         BO    NOTIFY_BAD_DELETING
         MVC   MSGWA(L'MSG_ALLOCNG_1),MSG_ALLOCNG_1
         LH    R15,FDBDSNL
         BCTR  R15,0
         EX    R15,MVC_ALLOCNG_1_DSNAME
         LA    R1,MSGWA+L'MSG_ALLOCNG_1+1(R15)
         B     NOTIFY_BAD_AFT_DELETING
NOTIFY_BAD_DELETING DS 0H
         MVC   MSGWA(L'MSG_ALLOCNG_4),MSG_ALLOCNG_4
         LH    R15,FDBDSNL
         BCTR  R15,0
         EX    R15,MVC_ALLOCNG_4_DSNAME
         LA    R1,MSGWA+L'MSG_ALLOCNG_4+1(R15)
NOTIFY_BAD_AFT_DELETING DS 0H
         TM    FLAGS,DELETING
         BO    NOTIFY_BAD_DELETING_AGAIN
         MVC   0(L'MSG_ALLOCNG_2,R1),MSG_ALLOCNG_2
         LH    R15,FDBDDNL
         BCTR  R15,0
         EX    R15,MVC_ALLOCNG_2_DDNAME
         LA    R1,L'MSG_ALLOCNG_2+1(R15,R1)
         B     NOTIFY_BAD_AFT_DELETING_AGAIN
NOTIFY_BAD_DELETING_AGAIN DS 0H
         MVC   0(L'MSG_ALLOCNG_5,R1),MSG_ALLOCNG_5
         LH    R15,FDBDDNL
         BCTR  R15,0
         EX    R15,MVC_ALLOCNG_5_DDNAME
         LA    R1,L'MSG_ALLOCNG_5+1(R15,R1)
NOTIFY_BAD_AFT_DELETING_AGAIN DS 0H
         MVC   0(L'MSG_ALLOCNG_3,R1),MSG_ALLOCNG_3
         LA    R0,L'MSG_ALLOCNG_3(,R1)
         LA    R1,MSGWA
         SR    R0,R1
         XR    R1,R1
         BAL   R14,PUTLINE
         L     R14,NOTIFY_R14
         BR    R14
*
MVC_ALLOCNG_1_DSNAME MVC MSGWA+L'MSG_ALLOCNG_1(*-*),FDBDSN
MVC_ALLOCNG_4_DSNAME MVC MSGWA+L'MSG_ALLOCNG_4(*-*),FDBDSN
MVC_ALLOCNG_2_DDNAME MVC L'MSG_ALLOCNG_2(*-*,R1),FDBDDN
MVC_ALLOCNG_5_DDNAME MVC L'MSG_ALLOCNG_5(*-*,R1),FDBDDN
*
         EJECT
NOTIFY_NOTHING DS 0H
         CLI   MSGLEVEL,INFORM     Display messages only for INFORM
         BHR   R14
         ST    R14,NOTIFY_R14
         MVC   MSGWA(L'MSG_NOTHING_1),MSG_NOTHING_1
         LH    R15,FDBDSNL
         BCTR  R15,0
         EX    R15,MVC_NOTHING_DSNAME
         LA    R1,MSGWA+L'MSG_NOTHING_1+1(R15)
         TM    FLAGS,DELETING
         BO    NOTHING_DELETING
         MVC   0(L'MSG_NOTHING_2,R1),MSG_NOTHING_2
         LH    R15,FDBDDNL
         BCTR  R15,0
         EX    R15,MVC_NOTHING_2_DDNAME
         LA    R1,L'MSG_NOTHING_2+1(R15,R1)
         B     NOTHING_AFT_DELETING
NOTHING_DELETING DS 0H
         MVC   0(L'MSG_NOTHING_4,R1),MSG_NOTHING_4
         LH    R15,FDBDDNL
         BCTR  R15,0
         EX    R15,MVC_NOTHING_4_DDNAME
         LA    R1,L'MSG_NOTHING_4+1(R15,R1)
NOTHING_AFT_DELETING DS 0H
         MVC   0(L'MSG_NOTHING_3,R1),MSG_NOTHING_3
         LA    R0,L'MSG_NOTHING_3(,R1)
         LA    R1,MSGWA
         SR    R0,R1
         XR    R1,R1
         BAL   R14,PUTLINE
         L     R14,NOTIFY_R14
         BR    R14
*
MVC_NOTHING_DSNAME MVC MSGWA+L'MSG_NOTHING_1(*-*),FDBDSN
MVC_NOTHING_2_DDNAME MVC L'MSG_NOTHING_2(*-*,R1),FDBDDN
MVC_NOTHING_4_DDNAME MVC L'MSG_NOTHING_4(*-*,R1),FDBDDN
*
         EJECT
REMOVEI  DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine searches the dslist for entries whose data set name *
* matches the name in the FDB, and removes them from the dslist.      *
* It does this by turning on the flag bit that marks an entry removed.*
* On return R1 contains the number of entries deleted.                *
* Do not use R2 or R9 in this routine!                                *
*                                                                     *
***********************************************************************
*
         LA    R5,DSLDATA          Point to first data entry
         LH    R15,DSLCOUNT        Number of times to loop
         XR    R1,R1               Clear removed-dsn count
         LTR   R15,R15
         BZR   R14                 If none, finished
REMOVEI_LOOP DS 0H
         CLC   DSNAME,DSLDSN       If data set name matches
         BNE   REMOVEI_SKIP        then
         OI    DSLFLAGS,DSLREMOV    mark dataset as removed
         LA    R1,1(,R1)            increment removed-dsn count
REMOVEI_SKIP DS 0H
         LA    R5,DSLDATAL(,R5)    Bump to next entry
         BCT   R15,REMOVEI_LOOP    and continue search.
         BR    R14                 Return to caller
         EJECT
ALLOC1   DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine allocates the file specified in DDNAME              *
* to the dataset specified in DSNAME.                                 *
*                                                                     *
* Initially the DDNAME is set to the "major" DDNAME.  This routine,   *
* once it successfully allocates a file to that DDNAME, sets the      *
* DDNAME to blank.  When the DDNAME is blank upon entry, this routine *
* uses a system-generated file name.                                  *
*                                                                     *
***********************************************************************
*
         ST    R14,ALLOC1_R14      Save return register
         MVI   S99VERB,S99VRBAL    Set verb code = allocation
         LA    R1,TUPLALLC         Point to relevant text units
         ST    R1,S99TXTPP         Set text unit pointers
         MVI   A9STATUS,X'08'      Set disposition = SHR
         LTR   R7,R7               If concatenations already started
         BNP   ALLOC1_USE_PASSED_DDNAME then
         LA    R1,TUARTDDN          Set text unit to return ddname
         ST    R1,TUPLALLC+12       Store into text unit parameter list
         B     ALLOC1_AFTER_PASSED_DDNAME
ALLOC1_USE_PASSED_DDNAME  DS 0H    Else...
         MVC   A9DDNLEN,DDNAMEL     Move ddname length to text unit
         MVC   A9DDNAME,DDNAME      Move ddname to text unit
         LA    R1,TUADDNAM          Set text unit to use given ddname
         ST    R1,TUPLALLC+12       Store into text unit parameter list
ALLOC1_AFTER_PASSED_DDNAME DS 0H
         MVC   A9DSNLEN,DSNAMEL    Move ddname length to text unit
         MVC   A9DSNAME,DSNAME     Move ddname to text unit
         CLC   UNIT,BLANKS         If unit name given,
         BE    ALLOC1_UNIT_BLANK   then...
         MVC   A9UNIT,UNIT          Move unit name to text unit
         NI    TUPLALLC_VL_NO_UNIT,X'7F'  Include unit name
         OI    TUPLALLC_VL,X'80'     by setting the VL bit accordingly
         B     ALLOC1_UNIT_DONE    else...
ALLOC1_UNIT_BLANK DS 0H             Unit name is blank...
         OI    TUPLALLC_VL_NO_UNIT,X'80'  Omit unit name
         NI    TUPLALLC_VL,X'7F'     by setting the VL bit accordingly
ALLOC1_UNIT_DONE        DS 0H
*
         LA    R1,S99RBP           Point to request block pointer
A1SVC99  DYNALLOC                  Call SVC 99
         LTR   R15,R15             If allocation failed,
         BNZ   ALLOC1_FAILED       then indicate so.
         LTR   R7,R7               Concatenations?
         BM    ALLOC1_RETURN       If we don't want 'em, skip it.
         BP    ALLOC1_CONT_CONCAT  If we started, add more.
******** BZ    ALLOC1_START_CONCAT Else start 'em.
ALLOC1_START_CONCAT DS 0H          Set up first file to be concat'd
         MVC   C9STUFF+0(2),DDNAMEL Set concat file #1 length
         MVC   C9STUFF+2(8),DDNAME  Set concat file #1 name
         LA    R15,1
         STH   R15,C9NUMBER        Initialize concat file counter
         LA    R7,C9STUFF+2        Initialize concat file pointer
         AH    R7,DDNAMEL          Bump to next concat file place
         B     ALLOC1_RETURN
ALLOC1_CONT_CONCAT DS 0H
         LA    R15,1               Increment number of files to concat
         AH    R15,C9NUMBER
         CH    R15,=H'&CATLIM'     We can't handle more than this many
         BH    ALLOC1_TOO_MANY     because we didn't allow that much rm
         STH   R15,C9NUMBER
         LH    R15,A9RETDDL        Get length of returned ddname
         STH   R15,0(,R7)          Store into concatenation parm
         BCTR  R15,0               Reduce for execute
         EX    R15,ALLOC1_MVC_RETURNED_DDNAME Move ret'd DD to cc parm
         LA    R7,2+1(R15,R7)      Bump to next concat file place
ALLOC1_RETURN DS 0H
         XR    R15,R15             Set success return code
         L     R14,ALLOC1_R14      Restore return register
         BR    R14                 Return to caller
ALLOC1_FAILED DS 0H                Allocation failed
         BAL   R14,DAIRFAIL        Report allocation error
         LA    R15,12              Set error return code
         L     R14,ALLOC1_R14      Restore return register
         BR    R14
ALLOC1_TOO_MANY DS 0H              Too many files to concatenate
         MVC   MSGWA(L'MSG_TOO_MANY_1),MSG_TOO_MANY_1
         LH    R15,DDNAMEL
         BCTR  R15,0
         EX    R15,MVC_TOO_MANY_DDNAME
         LA    R1,MSGWA+L'MSG_TOO_MANY_1+1(R15)
         MVC   0(L'MSG_TOO_MANY_2,R1),MSG_TOO_MANY_2
         LA    R0,L'MSG_TOO_MANY_2(,R1)
         LA    R1,MSGWA
         SR    R0,R1
         XR    R1,R1
         BAL   R14,PUTLINE         Report allocation error
         LA    R15,16              Set error return code
         L     R14,ALLOC1_R14      Restore return register
         BR    R14
*
ALLOC1_MVC_RETURNED_DDNAME MVC 2(*-*,R7),A9RETDDN  Executed
MVC_TOO_MANY_DDNAME MVC MSGWA+L'MSG_TOO_MANY_1(*-*),DDNAME
*
         EJECT
FREE1    DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine unallocates the file specified in DDNAME.           *
*                                                                     *
***********************************************************************
*
         ST    R14,FREE1_R14       Save return register
         MVI   S99VERB,S99VRBUN    Set verb code = unallocation
         LA    R1,TUPLUNAL         Point to relevant text units
         ST    R1,S99TXTPP         Set text unit pointers
         MVC   U9DDNLEN,DDNAMEL    Move ddname length to text unit
         MVC   U9DDNAME,DDNAME     Move ddname to text unit
         LA    R1,S99RBP           Point to request block pointer
U1SVC99  DYNALLOC                  Call SVC 99
         LTR   R15,R15             If unallocation went OK,
         BZ    FREE1_RETURN        then just return.
*
* If the unallocation error is "file not freed, is not allocated",
* then ignore the error.
*
         CH    R15,=H'4'           If return code is 4
         BNE   FREE1_NOT_NOT_ALLOCATED and
         CLC   S99ERROR(2),=X'0438'     error code is "file not allocd"
         BE    FREE1_RETURN              then return as if free was OK
FREE1_NOT_NOT_ALLOCATED DS 0H
         BAL   R14,DAIRFAIL        Else report unallocation error
         LA    R15,12              Set error return code
         L     R14,FREE1_R14       Restore return register
         BR    R14
FREE1_RETURN DS 0H
         XR    R15,R15             Set success return code
         L     R14,FREE1_R14       Restore return register
         BR    R14                 Return to caller
         EJECT
CONCAT1  DS    0H
*
***********************************************************************
*                                                                     *
* This subroutine concatenates files.                                 *
* If there is only one file to be "concatenated", this routine does   *
* not do anything, since the file is already allocated as desired.    *
*                                                                     *
***********************************************************************
*
         XR    R15,R15             Preset return code
         CLC   C9NUMBER,=H'1'      If zero or one file to concatenate
         BNHR  R14                 then return doing nothing.  Else...
         ST    R14,CONCAT1_R14     Save return register
         MVI   S99VERB,S99VRBCC    Set verb code = concatenation
         LA    R1,TUPLCCAT         Point to relevant text units
         ST    R1,S99TXTPP         Set text unit pointers
         LA    R1,S99RBP           Point to request block pointer
C1SVC99  DYNALLOC ,                Call SVC 99
         LTR   R15,R15             If concatenation went OK,
         BZ    CONCAT1_RETURN      then just return.
         BAL   R14,DAIRFAIL        Else report concatenation error
         LA    R15,12              Set error return code
         L     R14,CONCAT1_R14     Restore return register
         BR    R14
CONCAT1_RETURN DS 0H
         XR    R15,R15             Set success return code
         L     R14,CONCAT1_R14     Restore return register
         BR    R14                 Return to caller
         EJECT
ERROR_BLANK_DSNAME DS 0H
*
         MVC   MSGWA(L'MSG_BLANK_DSNAME),MSG_BLANK_DSNAME
         MVC   MSGWA+L'MSG_BLANK_DSNAME(8),FDBDDN
         LA    R0,L'MSG_BLANK_DSNAME+8
         XR    R1,R1
         BAL   R14,PUTLINE
         B     ERROR_RETURN
*
ERROR_ALLOC_MEMBER DS 0H
*
         MVC   MSGWA(L'MSG_ALLOC_MEMBER),MSG_ALLOC_MEMBER
         MVC   MSGWA+L'MSG_ALLOC_MEMBER(8),FDBDDN
         LH    R1,FDBDDNL
         LA    R1,MSGWA+L'MSG_ALLOC_MEMBER(R1)
         B     FILL_IN_ERROR_DSNAME
*
ERROR_MULTIPLE_VOL DS 0H
*
         MVC   MSGWA(L'MSG_MULTIPLE_VOL),MSG_MULTIPLE_VOL
         MVC   MSGWA+L'MSG_MULTIPLE_VOL(8),FDBDDN
         LH    R1,FDBDDNL
         LA    R1,MSGWA+L'MSG_MULTIPLE_VOL(R1)
         B     FILL_IN_ERROR_DSNAME
*
ERROR_DISP_NOT_SHR DS 0H
*
         MVC   MSGWA(L'MSG_DISP_NOT_SHR),MSG_DISP_NOT_SHR
         MVC   MSGWA+L'MSG_DISP_NOT_SHR(8),FDBDDN
         LH    R1,FDBDDNL
         LA    R1,MSGWA+L'MSG_DISP_NOT_SHR(R1)
         B     FILL_IN_ERROR_DSNAME
*
ERROR_BAD_UCB_ADDR DS 0H
*
         MVC   MSGWA(L'MSG_BAD_UCB_ADDR),MSG_BAD_UCB_ADDR
         MVC   MSGWA+L'MSG_BAD_UCB_ADDR(8),FDBDDN
         LH    R1,FDBDDNL
         LA    R1,MSGWA+L'MSG_BAD_UCB_ADDR(R1)
         B     FILL_IN_ERROR_DSNAME
*
FILL_IN_ERROR_DSNAME DS 0H
         MVC   0(2,R1),=C': '
         MVC   2(44,R1),DSLDSN
         LA    R1,2(,R1)
         AH    R1,DSLDSNL
         USING INFMJFCB,R7
         CLC   JFCBELNM,BLANKS
         BE    FIEDNM
         MVI   0(R1),C'('
         MVC   1(8,R1),JFCBELNM
         DROP  R7
         LA    R1,8(,R1)
         LA    R0,8
FIEDLOOP DS 0H
         CLI   0(R1),C' '
         BNE   FIEDEND
         BCTR  R1,0
         BCT   R0,FIEDLOOP
FIEDEND  DS 0H
         MVI   1(R1),C')'
         LA    R1,2(,R1)
FIEDNM   DS    0H
         LR    R0,R1
         LA    R1,MSGWA
         SR    R0,R1
         XR    R1,R1
         BAL   R14,PUTLINE
******** B     ERROR_RETURN
*
ERROR_RETURN DS 0H
*
         OI    FLAGS,DDFAILED      Indicate file processing aborted
         MVC   MSGWA(L'MSG_FILE_LOSSAGE),MSG_FILE_LOSSAGE
         MVC   MSGWA+L'MSG_FILE_LOSSAGE(8),FDBDDN
         LA    R0,L'MSG_FILE_LOSSAGE+8
         XR    R1,R1
         BAL   R14,PUTLINE
         L     R14,PROCFDB_R14     Load return register
         BR    R14                 Return to caller
         EJECT
PUTLINE  DS    0H
*
***********************************************************************
*                                                                     *
* This routine displays messages to the tso user using the tso        *
* PUTLINE service routine.  At entry R1 contains the address of the   *
* message to be displayed, and R0 contains the length of the message. *
* If R1 is zero, the message has already been built in the workarea   *
* MSGWA.  The message is assumed to begin with a message ID unless    *
* the first character is blank, in which case the initial blank is    *
* stripped off by PUTLINE anyhow.                                     *
*                                                                     *
***********************************************************************
*
         ST    R14,PUTLINE_R14     Save return register
         LTR   R15,R0              Load length value
         BNP   PUTLRET             If zero, don't do anything
         BCTR  R15,0               Else reduce length for execute
         LTR   R1,R1               If R1 is zero,
         BZ    PUTIT               then message already set up.
         EX    R15,MVC_PUT         Else move message to work area
PUTIT    DS    0H
         LA    R15,5(,R15)         Restore length + 4 for header
         SLL   R15,16              Shift length into left half of hdr
         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr
PUTLINE_RETRY DS 0H
         XC    ECB,ECB             Clear ECB
         PUTLINE PARM=PTLIST,                                          X
               MF=(E,IOPL),                                            X
               OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15             If PUTLINE OK
         BZ    PUTLRET             then return
         CH    R15,=H'8'           Else if attention interrupt
         BE    PUTLRET             then OK
         CH    R15,=H'12'          Else if pending 2nd level message
         BE    PUTL12              then OK
PUTERROR DS    0H                  Else PUTLINE error
         CVD   R15,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         MVC   PUTWA+1(L'MSG_PUTLINE_FAILURE1),MSG_PUTLINE_FAILURE1
         MVC   PUTWA+1+L'MSG_PUTLINE_FAILURE1(2),DOUBLE
         MVC   PUTWA+1+L'MSG_PUTLINE_FAILURE1+2(L'MSG_PUTLINE_FAILURE2)X
               ,MSG_PUTLINE_FAILURE2
         TPUT  PUTWA+1,L'MSG_PUTLINE_FAILURE1+2+L'MSG_PUTLINE_FAILURE2
         LA    R1,MSGWA
         LH    R0,MSGHDR
         SH    R0,=H'4'
         TPUT  (1),(0),R           Try to display original message
PUTLRET  L     R14,PUTLINE_R14     Restore return register
         BR    R14                 Return
*
PUTL12   DS    0H                  Try putting out pending 2nd level ms
         XC    ECB,ECB             Clear ecb
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)
         B     PUTLINE_RETRY
*
MVC_PUT  MVC   MSGWA(*-*),0(R1)    Executed
         EJECT
*
***********************************************************************
*                                                                     *
* IKJPARS verify exit for file(dsn dsn ...) keyword/value pairs       *
*                                                                     *
* See TSO Extensions Programming Services, p. 5-69, for how to code   *
* verify exit routines associated with the IKJUNFLD macro.  This is   *
* used to process keywords whose names aren't known until run time.   *
* The file names used by XALCMOD, file1(dsn1 dsn2) file3(dsn4), are   *
* a good example of this.                                             *
*                                                                     *
***********************************************************************
*                                                                     *
* On entry R1 -> the verify exit parameter list, mapped by the        *
* IKJVEPL macro.  This contains in turn a pointer to the PPE          *
* (parse parameter element) that describes the unidentified keyword   *
* the file name, in our case), mapped by the IKJPPE macro.            *
*                                                                     *
***********************************************************************
*                                                                     *
*       VEPL     DSECT                                                *
*       VEPLID   DS  CL4                IDENTIFIER                    *
*       VEPLVERS DS  FL2                VERSION NUMBER                *
*       VEPLLEN  DS  FL2                LENGTH OF THE VEPL            *
*       VEPLPPE  DS  F                  PTR TO PPE                    *
*       VEPLWRKA DS  F                  PTR TO USER SUPPLIED WORKAREA *
*       VEPLMSG1 DS  F                  PTR TO 1ST LEVEL MSG INSERT   *
*       VEPLM1LN DS  H                  LENGTH OF 1ST LEVEL INSERT    *
*       VEPLRSV1 DS  CL2                RESERVED                      *
*       VEPLMSG2 DS  F                  PTR TO SECOND LEVEL MSG       *
*       VEPLM2LN DS  H                  LENGTH OF SECOND LEVEL MSG    *
*       VEPLRSV2 DS  CL2                RESERVED                      *
*       VEPLCVER EQU  1                 CURRENT VERSION NUMBER        *
*                                                                     *
********************************************************************* *
*                                                                     *
*       PPE      DSECT                                                *
*       PPEID    DS  CL4            IDENTIFIER                        *
*       PPEVERS  DS  FL2            VERSION NUMBER                    *
*       PPELEN   DS  FL2            LENGTH OF THE PPE                 *
*       PPEOPER  DS  F              PTR TO THE OPERAND                *
*       PPEVEXIT DS  A              ADDRESS OF THE VERIFY EXIT        *
*       PPEOPLEN DS  H              LENGTH OF THE OPERAND             *
*       PPEFLAGS DS  CL1            FLAG BYTE                         *
*       PPELST   EQU X'80'          CURRENT OPERAND IS IN A LIST      *
*       PPENDLST EQU X'40'          LAST OPERAND WAS LAST IN LIST     *
*       PPENDOP  EQU X'20'          LAST OPERAND WAS THE LAST ONE     *
*       PPENWLST EQU X'10'          BEGIN A NEW SUBLIST               *
*       PPERSVD2 DS  CL1            RESERVED                          *
*       PPECVER  EQU 1              CURRENT VERSION NUMBER            *
*                                                                     *
***********************************************************************
*
VFYEXIT  DS    0H
*
         STM   R14,R12,12(R13)     Save registers
         LR    R9,R1               Get address of VEPL
         USING VEPL,R9
         L     R7,VEPLPPE          Get address of PPE describing file
         USING PPE,R7
         L     R10,VEPLWRKA        Get address of our workarea (DATD)
         LM    R11,R12,MYBASES     Get addressability
         LA    R14,SAVE2           Chain to new save area
         ST    R13,4(,R14)
         ST    R14,8(,R13)
         LR    R13,R14
*
* If we've already gone through a list, then something is wrong.
*
         TM    FLAGS,DONEWVFY      If a list of subfields was done once
         BO    DUPLICATE_KEYWORDS  then error - duplicate keywords
*
* If a list of suboperands was specified, reject the list.
*
         TM    PPEFLAGS,PPELST     If in a list of operands
         BO    VFYLSTNG            then error
*
* If this is the "no-more-keywords" call, process accordingly.
*
         XR    R15,R15             Set return code to zero
         TM    PPEFLAGS,PPENDOP    If previous operand was the last
         BNO   VFYNL               then
         OI    FLAGS,DONEWVFY       indicate done with verify
         B     VFYRET               and return.
*
VFYNL    DS    0H                  Else there's a keyword to process...
*
         LH    R2,PPEOPLEN         Get length of file keyword
         LTR   R2,R2
         BZ    VFYLSTNG            If ddname missing, assume syntax bug
         CH    R2,=H'8'            Cannot be longer than 8 character
         BH    DDNAME_INVALID
         L     R1,PPEOPER          Get address of ddname
         CLI   0(R1),X'F0'         First character cannot be numeric
         BNL   DDNAME_INVALID      (PARSE flags other bad characters)
*
         LA    R2,FDBL             Get size of a file-dataset block
         GETMAIN R,LV=(R2)
         ICM   R3,R15,LASTFDB      Get address of current FDB
         BNZ   GOTFDBL             If zero (no FDB's yet), then ...
         ST    R1,FRSTFDB          Store pointer
         B     AFTFDBL
GOTFDBL  DS    0H
         ST    R1,FDBNEXT
AFTFDBL  DS    0H
         ST    R1,LASTFDB
         LR    R3,R1
         XC    FDBNEXT,FDBNEXT     Clear chain pointer
         ST    R2,FDBLEN           Save length of this FDB
         XC    FDBCOUNT,FDBCOUNT   Set number of dsnames to zero
         MVI   FDBDDN,C' '         Clear ddname to blanks
         MVC   FDBDDN+1(7),FDBDDN
         LA    R15,FDBDATA         Initialize offset of dsnames
         ST    R15,FDBOFF
         L     R1,PPEOPER          Get address of file keyword
         LH    R2,PPEOPLEN         Get length of file keyword
         STH   R2,FDBDDNL          Store length of file
         BCTR  R2,0                Reduce length for execute
         EX    R2,MVC_FDBDDN       Move file keyword to FDB
         XR    R15,R15             Set return code to zero
*
VFYRET   DS    0H
         L     R13,4(,R13)         Reload save area pointer
         L     R14,12(,R13)        Restore registers
         LM    R0,R12,20(R13)      Restore registers
         BR    R14                 Return to caller
*
DDNAME_INVALID DS 0H
*        LA    R1,MSG_DDNAME_NG
*        LA    R0,L'MSG_DDNAME_NG
*        BAL   R14,PUTLINE
*        LA    R15,8
         LA    R15,12              Let PARSE say "invalid keyword"
         B     VFYRET
*
VFYLSTNG DS    0H                  List is no good
         LA    R1,MSG_LIST_NG
         LA    R0,L'MSG_LIST_NG
         BAL   R14,PUTLINE
         LA    R15,16              Abort the parse - no way to reenter
         B     VFYRET
*
DUPLICATE_KEYWORDS DS 0H           More than one of FRONT/BACK/etc.
         LA    R1,MSG_DUP_KEYS
         LA    R0,L'MSG_DUP_KEYS
         BAL   R14,PUTLINE
         LA    R15,16              Abort the parse - no way to reenter
         B     VFYRET
*
MVC_FDBDDN MVC FDBDDN(*-*),0(R1)   Executed
*
         DROP  R9,R7
         EJECT
*
DSNEXIT  DS    0H                  IKJPARSE validity check exit
*
***********************************************************************
*                                                                     *
* This exit gets control to process each data set name encountered    *
* within an unidentified keyword's subfield.  It must be sensitive to *
* which file-dataset block is current.                                *
*                                                                     *
***********************************************************************
*                                                                     *
* See TSO Extensions Programming Services, p. 5-67, for how to code   *
* validity check exit routines.                                       *
*                                                                     *
***********************************************************************
*                                                                     *
* On entry R1 -> the following parameter list:                        *
*                                                                     *
***********************************************************************
*                                                                     *
* +0    PDEADR   DS  F           Address of PDE for this operand      *
* +4    USERWORD DS  F           Address of user work area            *
* +8    VALMSG   DS  F           Address of 2nd lvl msg, initially 0  *
*                                                                     *
***********************************************************************
*
         STM   R14,R12,12(R13)     Save registers
         L     R9,0(,R1)           R9->PDE
         L     R10,4(,R1)          Get address of our work area
         LM    R11,R12,MYBASES     Get addressability
         LA    R14,SAVE2           Chain to new save area
         ST    R13,4(,R14)
         ST    R14,8(,R13)
         LR    R13,R14
*
         TM    14(R9),X'80'        If a member name was specified
         BO    MEMBER_NAME_NOT_ALLOWED then error
         L     R3,LASTFDB
         LH    R2,FDBCOUNT         Get count of data set names so far
         LA    R2,1(,R2)           Increment count
         CH    R2,=H'&CATLIM'
         BH    TOO_MANY_DSNS_PER_FILE
         STH   R2,FDBCOUNT
         L     R6,FDBOFF           Get offset of where to put dsn
         MVC   FDBDSN,BLANKS
         L     R7,0(,R9)           Get address of the dsname
         LH    R2,4(,R9)           Get length of the dsname
         STH   R2,FDBDSNL          Store dataset name length
         BCTR  R2,0
         EX    R2,MVC_VAL_DSN      Move PDE dsname to FDB dsname
         MVI   FDBFLAGS,X'00'      Clear flags
         LA    R6,FDBDATAL(,R6)
         ST    R6,FDBOFF           Increment offset
******** B     VALRET0             Return OK
*
VALRET0  DS    0H
         XR    R15,R15
VALRET   DS    0H
         L     R13,4(,R13)         Reload save area pointer
         L     R14,12(,R13)        Restore registers
         LM    R0,R12,20(R13)      Restore registers
         BR    R14                 Return to caller
*
MEMBER_NAME_NOT_ALLOWED DS 0H
         LA    R1,MSG_MEMBER_NG
         LA    R0,L'MSG_MEMBER_NG
         MVC   MSGWA(L'MSG_MEMBER_NG),MSG_MEMBER_NG
         LH    R2,4(,R9)
         LTR   R2,R2
         BZ    MNANODS
         L     R15,0(,R9)
         BCTR  R2,0
         EX    R2,MNAMVCD
         LA    R2,1(,R2)
MNANODS  DS    0H
         LA    R1,MSGWA+L'MSG_MEMBER_NG(R2)
         MVI   0(R1),C'('
         L     R15,8(,R9)
         LH    R2,12(,R9)
         BCTR  R2,0
         EX    R2,MNAMVCM
         LA    R1,1(R2,R1)
         MVI   1(R1),C')'
         LA    R0,2(,R1)
         LA    R1,MSGWA
         SR    R0,R1
         XR    R1,R1
         BAL   R14,PUTLINE
         LA    R15,8
         B     VALRET
*
MNAMVCD  MVC   MSGWA+L'MSG_MEMBER_NG(*-*),0(R15)
MNAMVCM  MVC   1(*-*,R1),0(R15)
*
TOO_MANY_DSNS_PER_FILE DS 0H
         MVC   VFYWORK+00(L'MSG_TMDPF1),MSG_TMDPF1
         MVC   VFYWORK+L'MSG_TMDPF1(8),FDBDDN
         LA    R1,VFYWORK
         LA    R0,L'MSG_TMDPF1+8
         BAL   R14,PUTLINE
         LA    R15,12
         B     VALRET
*
MVC_VAL_DSN MVC FDBDSN(*-*),0(R7)  Executed
*
         EJECT
DAIRFAIL DS    0H                  Display DYNALLOC failure message
*
***********************************************************************
*                                                                     *
* If DYNALLOC request failed, call DAIRFAIL to display message.       *
*                                                                     *
***********************************************************************
*
         ST    R14,DAIRFAIL_R14    Save return register
         ST    R15,DYNARC          Store return code from SVC99
         LA    R14,S99RB           +00->address of SVC99RB
         LA    R15,DYNARC          +04->address of return code
         LA    R0,=F'0'            +08->address of IKJEFF02 not present
         LA    R1,=X'0032'         +0C->request for msg using PUTLINE
         L     R2,CPPLADDR         +10->address of CPPL for PUTLINE
         STM   R14,R2,DFPARMS      Set up parameter list for DAIRFAIL
         XR    R0,R0               +14=zeroes
         ST    R0,DFPARMS+20       Set up parameter list for DAIRFAIL
         LA    R1,DFPARMS          Address DAIRFAIL parameter list
         LINK  EP=IKJEFF18         Call DAIRFAIL service routine
         LTR   R15,R15             If DAIRFAIL failed,
         BZ    DAIRFAIL_OK         then...
         LA    R1,MSG_DAIRFAIL_MSG
         LA    R0,L'MSG_DAIRFAIL_MSG
         BAL   R14,PUTLINE         Display failure message
DAIRFAIL_OK DS 0H
         L     R14,DAIRFAIL_R14    Restore return register
         BR    R14
         EJECT
MFLUSH   STACK MF=L,DELETE=ALL
LENFLUSH EQU   *-MFLUSH
*
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
*
BLANKS   DC    CL44' '
*
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
*
MSG_TMDPF1       DC C'XALCMOD001 More than &CATLIM data sets specified X
               for file '
MSG_MEMBER_NG    DC C'XALCMOD002 Member name not allowed, '
MSG_LIST_NG      DC C'XALCMOD003 Invalid syntax: nested list or extra pX
               arentheses found'
MSG_DUP_KEYS     DC C'XALCMOD003 Invalid syntax: duplicate or conflictiX
               ng keyword options'
*SG_DDNAME_NG    DC C'XALCMOD003 Invalid file name syntax'
MSG_FILE_LOSSAGE DC C'XALCMOD004 No processing done for file '
MSG_BLANK_DSNAME DC C'XALCMOD005 Unnamed data set allocated to file '
MSG_ALLOC_MEMBER DC C'XALCMOD006 Data set with member allocated to '
MSG_MULTIPLE_VOL DC C'XALCMOD007 Multivolume data set allocated to '
MSG_DISP_NOT_SHR DC C'XALCMOD008 Data set with DISP OLD allocated to '
MSG_BAD_UCB_ADDR DC C'XALCMOD009 Data set not on DASD allocated to '
*
MSG_NOTHING_1 DC C'XALCMOD010 '
MSG_NOTHING_2 DC C' already allocated to file '
MSG_NOTHING_4 DC C' already absent from file '
MSG_NOTHING_3 DC C'.'
*
MSG_ALLOCED_1 DC C'XALCMOD011 '
MSG_ALLOCED_2 DC C' allocation added to file '
MSG_ALLOCED_4 DC C' allocation removed from file '
MSG_ALLOCED_3 DC C'.'
*
MSG_ALLOCNG_1 DC C'XALCMOD012 Unable to allocate '
MSG_ALLOCNG_4 DC C'XALCMOD012 Unable to remove '
MSG_ALLOCNG_2 DC C' to file '
MSG_ALLOCNG_5 DC C' from file '
MSG_ALLOCNG_3 DC C'.'
*
MSG_RECOVER_NG_1 DC C'XALCMOD013 Unable to recover allocation of file '
MSG_RECOVER_NG_2 DC C'.'
*
MSG_TOO_MANY_1 DC C'XALCMOD014 Attempt to allocate more than &CATLIM daX
               ta sets to file '
MSG_TOO_MANY_2 DC C'.'
*
MSG_STACK_ERROR  DC C'XALCMOD015 STACK service routine failure'
MSG_DAIRFAIL_MSG DC C'XALCMOD016 DAIRFAIL error, unable to show why dynX
               amic allocation request failed.'
*
MSG_PUTLINE_FAILURE1 DC C'*** XALCMOD: PUTLINE error code '
MSG_PUTLINE_FAILURE2 DC C' trying to issue the following message:'
*
         EJECT
         LTORG
*
         DROP  R12
         EJECT
***********************************************************************
* PARSE CONTROL BLOCKS CSECT                                          *
***********************************************************************
*
XALCMPCL IKJPARM DSECT=PDL
XALCMPCL AMODE 31
XALCMPCL RMODE ANY
*
* Damn fool aliases don't work.  Maybe the presence of IKJUNFLD
* introduces new IKJPARS bugs.  Anyhow, I'm not using them unless
* they work - trying to keep parse complexity down a bit.
*
PWHAT    IKJKEYWD
         IKJNAME 'FRONT',SUBFLD=ALSUBF     ALIAS=('F')
         IKJNAME 'BACK',SUBFLD=ALSUBF
         IKJNAME 'INSERT',SUBFLD=ALSUBF    ALIAS=('I','IN')
         IKJNAME 'DELETE',SUBFLD=ALSUBF
         IKJNAME 'SETUP',SUBFLD=ALSUBF
*
PINFORM  IKJKEYWD
         IKJNAME 'INFORM'
         IKJNAME 'ACTINFORM'
         IKJNAME 'FAILINFORM'
         IKJNAME 'NOINFORM'
INFORM     EQU 1
ACTINFORM  EQU 2
FAILINFORM EQU 3
NOINFORM   EQU 4
*
ALSUBF   IKJSUBF
*
* The following handles all operands of the form file(dsn dsn dsn).
*
         IKJUNFLD VERIFCK=VFYEXIT,SUBFLD=PSUBF
*
PSUBF    IKJSUBF
PDSN     IKJPOSIT DSNAME,LIST,USID,VALIDCK=DSNEXIT
*
         IKJENDP
*
*
XALCMOD  CSECT
*
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
*
DATD     DSECT ,                   Dynamically acquired work area
*
SAVEAREA DS    18F                 OS save area
SAVE2    DS    18F                 Save area for PARSE exit routines
DOUBLE   DS    D                   Conversion work area
PROCFDB_R14  DS F                  Return register save
PUTLINE_R14  DS F                  Return register save
REMOVEI_R14  DS F                  Return register save
NOTIFY_R14   DS F                  Return register save
ALLOC1_R14   DS F                  Return register save
FREE1_R14    DS F                  Return register save
CONCAT1_R14  DS F                  Return register save
DAIRFAIL_R14 DS F                  Return register save
FRONT14  DS    F                   Return register save
BACK14   DS    F                   Return register save
INSERT14 DS    F                   Return register save
DELETE14 DS    F                   Return register save
FRSTFDB  DS    A                   Pointer to chain of file-dsn blocks
LASTFDB  DS    A                   Pointer to last file-dsn block
MYBASES  DS    2A                  Base regs for IKJPARS exit routines
CPPLADDR DS    A                   Address of CPPL
PSYSDS   DS    A                   Ptr to first system DS    for INSERT
BSYSDS   DS    A                   Ptr to last pre-system DS for INSERT
BSDCOUNT DS    H                   # of DS before system DS  for INSERT
PSDCOUNT DS    H                   # of DS from system DS on for INSERT
DYNARC   DS    F                   SVC 99 return code
DFPARMS  DS    6A                  DAIRFAIL parameter list
*
DDNAMEL  DS    H                   Length of file name being processed
DDNAME   DS    CL8                 File name being processed
DSNAMEL  DS    H                   Length of dsname being processed
DSNAME   DS    CL44                Data set name being processed
VOLSER   DS    CL6                 Volume serial
UNIT     DS    CL4                 Unit name
FLAGS    DS    X                   Flags
DDFREED  EQU   B'10000000'          1 = file has been unallocated
DELETING EQU   B'01000000'          1 = deleting, 0 = allocating
DIDSTUFF EQU   B'00100000'          1 = a reallocation has been done
DSNSKIPD EQU   B'00010000'          1 = skipped one but realloc done
DDFAILED EQU   B'00001000'          1 = free/alc failed, recover alloc
DISASTER EQU   B'00000100'          1 = recovery failed, alloc now bad
DONEWVFY EQU   B'00000010'          1 = verify exit processed all names
*        EQU   B'00000001'          Reserved
*
WHAT     DS    X                   FRONT, BACK, INSERT, DELETE, SETUP
FRONT    EQU   1
BACK     EQU   2
INSERT   EQU   3
DELETE   EQU   4
SETUP    EQU   5
*
MSGLEVEL DS    X                   Value of INFORM/etc.
*
ECB      DS    F                   ECB for TSO routines
*
OLD      DS    0F                  PUTLINE output line descriptor
OLDF1    DS    F'1'                Number of message segments
OLDMSG   DS    A(*-*)              Address of the first message segment
*
MSGHDR   DS    F                   PUTLINE message header
MSGWA    DS    CL256               PUTLINE message work area
PUTWA    DS    CL256               PUTLINE message work area
*
VFYWORK  DS    CL80                Verify exit work area
*
FLUSH    STACK MF=L,DELETE=ALL
*
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
*
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
*
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
*
PPL      DS    0A
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
PPLVEWA  DS    A        PTR TO USER WORK AREA FOR VERIFY EXITS
*
ANSWER   DS    F                   ANSWER AREA FOR PARSE
*
***********************************************************************
*                                                                     *
* DYNAMIC ALLOCATION PARAMETER LISTS                                  *
*                                                                     *
* (with apologies to 'SYS1.MACLIB(IEFZB4D0)' and friends)             *
*                                                                     *
* Tough on IBM.  If they want me to use their macro, let them         *
* provide a DSECT=NO version.                                         *
*                                                                     *
***********************************************************************
*
S99RBP   DS    0D                  SVC 99 input request block
*
S99RBPTR DS    A                   Request block pointer
S99RB    DS    0D                  Request block
S99RBLN  DC    YL1(20)             Length of request block
S99VERB  DS    YL1                 Verb code
S99VRBAL EQU   X'01'                Allocation
S99VRBUN EQU   X'02'                Unallocation
S99VRBCC EQU   X'03'                Concatenation
S99VRBDC EQU   X'04'                Deconcatenation
S99VRBRI EQU   X'05'                Remove in-use
S99VRBDN EQU   X'06'                DDNAME allocation
S99VRBIN EQU   X'07'                Information retrieval
S99FLG11 DS    XL1                 First flags byte
S99ONCNV EQU   X'80'               Don't use non-convertible allocation
S99NOCNV EQU   X'40'               Don't use existing allocation
S99FLG12 DS    XL1                 Second flags byte
S99ERROR DS    XL2                 Error reason code
S99INFO  DS    XL2                 Information reason code
S99TXTPP DS    A                   Pointer to list of text units
         DS    F                   Reserved
         DS    4XL1                Flags for authorized functions
S99RBEND EQU   *                   End marker
*
*
* SVC 99 text unit pointer list for allocation functions
*
TUPLALLC DS    0F                  Allocate dsname
         DC    A(TUADSNAM)
         DC    A(TUASTATS)
         DC    A(TUAPERMA)
         DS    A TUADDNAM or TUARTDDN, depending on call
TUPLALLC_VL_NO_UNIT EQU *-4
         DC    A(TUAUNIT)
TUPLALLC_VL EQU *-4
*
* SVC 99 text unit for allocation of a dsname
*
TUADSNAM DS    0H
         DC    Y(DALDSNAM)         Key
         DC    H'1'                Number
A9DSNLEN DS    H                   Length of dsname
A9DSNAME DS    CL44                Dsname
*
* SVC 99 text unit for specification of a ddname
*
TUADDNAM DS    0H
         DC    Y(DALDDNAM)         Key
         DC    H'1'                Number
A9DDNLEN DS    H                   Length of ddname
A9DDNAME DS    CL8                 Ddname
*
* SVC 99 text unit for data set status
*
TUASTATS DS    0H
         DC    Y(DALSTATS)         Key
         DC    H'1'                Number
         DC    H'1'                Length
A9STATUS DS    XL1                 Data set status
*
* SVC 99 text unit for volume serial
*
*UAVLSER DS    0H
*        DC    Y(DALVLSER)         Key
*        DC    H'1'                Number
*        DC    H'6'                Length
*9VOLSER DS    CL6                 Volume serial
*
* SVC 99 text unit for unit specification
*
TUAUNIT  DS    0H
         DC    Y(DALUNIT)          Key
         DC    H'1'                Number
         DC    H'3'                Length
A9UNIT   DS    CL6                 Unit name
*
* SVC 99 text unit for permanently allocated attribute
*
TUAPERMA DS    0H
         DC    Y(DALPERMA)         Key
         DC    H'0'                Number
*
* SVC 99 text unit to return ddname
*
TUARTDDN DS    0H
         DC    Y(DALRTDDN)         Key
         DC    H'1'                Number
A9RETDDL DC    H'8'                Length
A9RETDDN DS    CL8                 DDname
*
* SVC 99 text unit pointer list for unallocation functions
*
TUPLUNAL DS    0F
         DC    A(TUUDDNAM)
         DC    A(TUUUNALC)
*
* SVC 99 text unit for unallocation of a ddname
*
TUUDDNAM DS    0H
         DC    Y(DUNDDNAM)         Key
         DC    H'1'                Number
U9DDNLEN DS    H                   Length of ddname
U9DDNAME DS    CL8                 Ddname
*
* SVC 99 text unit for unallocation even if permanently allocated
*
TUUUNALC DS    0H
         DC    Y(DUNUNALC)         Key
         DC    H'0'                Number
*
*
* SVC 99 text unit pointer list for concatenation functions
*
TUPLCCAT DS    0F
         DC    A(TUCDDNAM)
         DC    A(TUCPERMC)
*
* SVC 99 text unit for concatenation of a ddname
*
TUCDDNAM DS    0H
         DC    Y(DCCDDNAM)         Key
C9NUMBER DS    H                   Number (2 to &CATLIM)
*                                  Area to hold up to &CATLIM
C9STUFF  DS    XL(&CATLIM*(2+8))    contiguous HL2-CL8 fields...
*
* SVC 99 text unit for permanently concatenated
*
TUCPERMC DS    0H
         DC    Y(DCCPERMC)         Key
         DC    H'0'                Number
         SPACE 2
ENDS99   DS    0D                  End of dynamic allocation area
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
FDB      DSECT ,                   Map file-dataset blocks
*
FDBNEXT  DS    A                   Pointer to next FDB
FDBLEN   DS    A                   Length of this FDB
FDBOFF   DS    A                   Offset of next dsn slot
FDBCOUNT DS    H                   Number of data set names
FDBDDNL  DS    H                   Length of ddname
FDBDDN   DS    CL8                 File name (ddname)
FDBDATA  DS    &CATLIM.CL(FDBDATAL) Data set name data (max of &CATLIM)
*
FDBL     EQU   *-FDB               Length of file-dataset block
*
FDBDATAD DSECT ,                   Map FDBDATA entries
*
FDBDSNL  DS    H                   Length of this dsn
FDBDSN   DS    CL44                The dsn
FDBFLAGS DS    X                   Flags
FDBERROR EQU   B'10000000'          1 = allocation failed
FDBDELNF EQU   B'01000000'          1 = dataset to be removed not found
*        EQU   B'00100000'          Reserved
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
*
FDBDATAL EQU   *-FDBDATAD          Length of each FDBDATA entry
         EJECT
DSLIST   DSECT                     DSLIST buffer mapping
*
DSLLEN   DS    F                   Length of this dslist buffer
DSLEND   DS    A                   Address of the end of dslist buffer
DSLCOUNT DS    H                   Number of data sets in list
DSLDATA  EQU   *                   Data repeated for each data set
*
DSLISTL  EQU   *-DSLIST            Length of fixed portion of DSLIST
*
*
DSLDATAD DSECT ,                   Map DSLDATA entries
*
DSLDSNL  DS    H                   Length of data set name
DSLDSN   DS    CL44                Data set name
DSLVOL   DS    CL6                 Volume serial
DSLUNAME DS    CL4                 Unit name
         DS    C                   Filler for unpacking hex data
DSLFLAGS DS    X                   Flags
DSLREMOV EQU   B'10000000'          1 = remove from new allocation
*        EQU   B'01000000'          Reserved
*        EQU   B'00100000'          Reserved
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
*
DSLDATAL EQU   *-DSLDATAD          Length of each DSLDATA entry
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
*
         IKJVEPL                   Parse verify exit parameter list
         EJECT
         IKJPPE                    Parse parameter element
         EJECT
         IKJCPPL
         EJECT
         PRINT NOGEN
*
         IEFTIOT1                  Map the TIOT
*
JFCB_DSECT DSECT ,                 needed to avoid USING warnings 10/96
*
         IEFJFCBN                  Map the JFCB
*
UCB_DSECT DSECT ,                  needed to avoid USING warnings 10/96
*
         IEFUCBOB                  Map the UCB
         IEFZB4D2                  Map dynamic allocation text units
         CVT   DSECT=YES
         END
./ ADD NAME=XALCUNIT 0100-07332-07332-0900-00210-00210-00000-SEB
         TITLE 'XALCUNIT - TSO command processor'
***********************************************************************
*                                                                     *
* XALCUNIT - TSO command processor to return allocation information   *
*            (in particular, ddname) about a particular unit address  *
*                                                                     *
***********************************************************************
*                                                                     *
* Syntax:   XALCUNIT unitnumber                                       *
*                                                                     *
* (example: XALCUNIT C65)                                             *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    ADDRESS OF UNIT NUMBER
R7       EQU   7    ADDRESS THE PDL (PARSE OUTPUT)
R8       EQU   8    ADDRESS THE UCB
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XALCUNIT CSECT
         SAVE  (14,12),,XALCUNIT_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XALCUNIT,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
         USING CPPL,R2             ADDRESS INPUT CPPL
         XC    ANSWER,ANSWER
         MVC   PPLUPT,CPPLUPT
         MVC   PPLECT,CPPLECT
         LA    R14,ECB
         L     R15,=V(XALCUPCL)
         LA    R0,ANSWER
         L     R1,CPPLCBUF
         STM   R14,R1,PPLECB
         ST    R13,PPLUWA          USER WORK AREA = "DATD"
         XC    ECB,ECB
         CALLTSSR EP=IKJPARS,MF=(E,PPL)
         LTR   R15,R15
         BNZ   RETURN12
         L     R7,ANSWER
         USING PDL,R7
         L     R6,PDLUNIT+0        Get address of unit number
         SPACE 1
         L     R3,540              Get address of TCB
         L     R3,12(,R3)          Get address of TIOT
         USING TIOT1,R3
         LA    R3,TIOENTRY         Point to first TIOT entry
         XR    R4,R4               Clear reg used to insert length
         XR    R5,R5               Clear register for 24-bit address
LOOP     DS    0H
         USING TIOENTRY,R3
         TM    TIOESTTA,TIOSLTYP   If TIOT entry is not in use
         BO    SKIP                then skip it
         ICM   R5,B'0111',TIOEFSRT Get address of UCB from TIOT
         BZ    SKIP                If none, this is not a winner
         USING UCBCMSEG,R5
         CLC   0(3,R6),UCBNAME     See if device names match
         BNE   SKIP                If so, we found an allocation
WIN      DS    0H                  We found an allocation
         SPACE 1
*                                  Temporary...
* What we have to do is save nonblank ddnames so that we can print
* out concatenation numbers.  We should also print out the unit #.
*
*
*
         TPUT  TIOEDDNM,8
         SPACE 1
SKIP     DS    0H
         IC    R4,TIOELNGH         Get length of TIOT entry
         ALR   R3,R4               Add length to get to next entry
         CLI   TIOELNGH,X'00'      If next entry says "end of TIOT"
         BNE   LOOP                then end, else continue
         SPACE 1
RETURN12 DS    0H                  RETURN WITH CODE 12
         LA    R2,12               SET RETURN CODE TO TWELVE
         B     RETURN
         SPACE 1
RETURN0  DS    0H                  RETURN WITH CODE 0
         XR    R2,R2               SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *
***********************************************************************
RETURNP  DS    0H
         SPACE
         LA    R1,ANSWER
         IKJRLSA (1)               RELEASE PARSE STORAGE
         SPACE
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *
***********************************************************************
RETURN   DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
*******************************************************************
*
*  Parse validity check exit for unitname.
*
*******************************************************************
         SPACE 1
UNITCHK  DS   0H
         SPACE 1
         STM   R14,R12,12(R13)
         LR    R12,R15
         USING UNITCHK,R12
         SPACE 1
         L     R8,0(,R1)           Get address of unit number PDE
         L     R5,0(,R8)           Get address of unit number
         LH    R6,4(,R8)           Get length of unit number
         LA    R0,3
         CR    R6,R0               Length must be equal to 3
         BNE   UNITNG
         TRT   0(3,R5),UNITTBL     Check for valid characters
         BZ    UNITOK
UNITNG   LA    R15,4               Invalid unit number
         B     UNITRET
UNITOK   XR    R15,R15             Valid unit number
UNITRET  L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14                 Return to PARSE
         SPACE 1
UNITTBL  DC    256YL1(1)           All characters invalid except...
         ORG   UNITTBL+C'0'        0-9
         DC    10YL1(0)             and
         ORG   UNITTBL+C'A'        A-F
         DC    6YL1(0)
         ORG   ,
         SPACE 1
         DROP  R12
         EJECT
***********************************************************************
* PARSE CONTROL BLOCKS CSECT                                          *
***********************************************************************
         SPACE 1
XALCUPCL IKJPARM DSECT=PDL
         SPACE
PDLUNIT  IKJIDENT 'UNIT NUMBER',UPPERCASE,                             X
               PROMPT='UNIT NUMBER',VALIDCK=UNITCHK,                   X
               MAXLNTH=3,FIRST=ALPHANUM,OTHER=ALPHANUM
         SPACE
         IKJENDP
         SPACE
XALCUNIT CSECT
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
         SPACE
PPL      DS    0A
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
         SPACE 1
ANSWER   DS    F                   ANSWER AREA FOR PARSE
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJCPPL
         IEFTIOT1
         IEFUCBOB PREFIX=YES       UCB MAPPING MACRO
         CVT   DSECT=YES
         END
./ ADD NAME=XALLOCSV 0100-07332-07332-0900-00243-00243-00000-SEB
         TITLE 'XALLOCSV - SAVE CURRENT ALLOCATION INFO IN A DATA SET'
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
XALLOCSV CSECT
         SAVE  (14,12),,XALLOCSV_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XALLOCSV,R12
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R1,8(,R13)
         ST    R13,4(,R1)
         LR    R13,R1
         L     R1,4(,R13)
         LM    R0,R1,20(R1)
         USING DATD,R13
         EJECT
         LA    R7,4                INITIALIZE RETURN CODE
         MVI   FLAGS,X'00'         INITIALIZE FLAGS
         LR    R2,R1               POINT TO CPPL
         USING CPPL,R2
         MVC   OUTDCB(OUTDCBL),OUTDCBS
         LA    R1,OUTDCB           SET UP DCB AND OPEN FOR OUTPUT
         ST    R1,OUTDCBO
         MVI   OUTDCBO,X'8F'
         OPEN  MF=(E,OUTDCBO)      OPEN OUTPUT FILE
         L     R3,CPPLECT          ADDRESS THE ECT
         USING ECT,R3
         TM    ECTSWS,ECTNOPD      IF AN OPERAND ON COMMAND
         BO    NOARGDD             THEN
         L     R4,CPPLCBUF          POINT TO COMMAND BUFFER
         LA    R14,4(,R4)           GET ADDRESS OF START OF COMMAND
         AH    R14,2(,R4)           ADD OFFSET OF OPERAND
* R14 POINTS TO BEGINNING OF OPERAND
         LA    R0,0(,R4)            GET ADDRESS OF COMMAND BUFFER
         AH    R0,0(,R4)            ADD LENGTH OF COMMAND BUFFER
* R0 POINTS TO END OF COMMAND BUFFER
         LR    R1,R14
OPLOOP   CR    R1,R0
         BNL   ENDOP
         CLI   0(R1),C' '
         BE    ENDOP
         CLI   0(R1),C','
         BE    ENDOP
         CLI   0(R1),X'05'
         BE    ENDOP
         CLI   0(R1),C'/'          CHECK FOR POSSIBLE /*
         BE    ENDOP
         LA    R1,1(,R1)
         B     OPLOOP
ENDOP    DS    0H                  R1 POINTS TO END OF OPERAND
         SR    R1,R14              R1 = LENGTH OF OPERAND
         BNP   NOARGDD              IF ZERO, NO OPERAND
         CH    R1,=H'8'             IF GREATER THAN 8,
         BNH   LE8                  THEN
         LA    R7,12                SET RETURN CODE TO 12
         PUT   OUTDCB,INVALID       PUT OUT AN ERROR MESSAGE
         B     RETURN               AND RETURN.
LE8      DS    0H
         OI    FLAGS,DDFLAG        INDICATE DD SPECIFIED
         MVC   ARGDD,BLANKS
         MVC   TESTDD,BLANKS       BLANK OUT BOTH DD FIELDS
         BCTR  R1,0
         EX    R1,MOVEDD           MOVE OPERAND TO ARGUMENT DDNAME
         MVC   MASKDD,ARGDD        MOVE ARGUMENT DD TO MASK
         TR    ARGDD,ARGTABLE      TRANSLATE ARGUMENT ASTERISKS
         TR    MASKDD,MSKTABLE     CREATE MASK FOR COMPARES
         DROP  R2,R3
NOARGDD DS     0H
         SPACE
         L     R3,540              TCB
         L     R3,12(,R3)          TIOT
         USING TIOT1,R3
         LA    R3,TIOENTRY         POINT TO FIRST TIOT ENTRY
         XR    R4,R4               CLEAR REG USED TO INSERT LENGTH
LOOP     DS    0H
         USING TIOENTRY,R3
         TM    TIOESTTA,TIOSLTYP   IF ENTRY NOT IN USE
         BO    SKIP                THEN SKIP
         TM    FLAGS,DDFLAG        IF TESTING FOR SPECIFIC DDNAME
         BZ    GOAHEAD             THEN
         CLC   TIOEDDNM,BLANKS      IF TIOT DDNAME IS NOT BLANK
         BE    NOMOVETT             THEN
         MVC   TESTDD,TIOEDDNM       USE IT FOR COMPARISONS
         OC    TESTDD,MASKDD         OR IT W/MASK TO MASK GENERIC POS.
NOMOVETT DS    0H                   (ELSE USE PREV. NONBLANK TIOT DD)
         CLC   TESTDD,ARGDD         IF ARGUMENT DD DOES NOT MATCH
         BNE   SKIP                 THEN SKIP THIS ENTRY
GOAHEAD  DS    0H                  ELSE PROCESS THIS ENTRY
         MVI   DATALINE,C' '       ELSE CLEAR OUTPUT LINE
         MVC   DATALINE+1(L'DATALINE-1),DATALINE
         MVC   DDNAME,TIOEDDNM     MOVE DDNAME TO OUTPUT LINE
         CLC   DDNAME,BLANKS       IF DDNAME IS BLANK
         BNE   NOTBLANK            THEN
         MVC   DDNAME(2),=X'7D7D'   MOVE DOUBLE APOSTROPHES TO OUTPUT
NOTBLANK ICM   R5,7,TIOEFSRT       GET ADDRESS OF UCB
         BZ    NOUCB               IF NONE, OTHER KIND OF ALLOCATION
         USING UCBCMSEG,R5
         MVC   VOLSER,UCBVOLI      MOVE VOLUME SERIAL TO OUTPUT LINE
         B     AFTUCB
         SPACE
NOUCB    DS    0H
         TM    TIOELINK,TIOTTERM   IF DEVICE IS A TERMINAL
         BZ    NOTTERM             THEN
         MVI   DSNAME,C'*'                SAY SO
         B     NOJFCB              ELSE
NOTTERM  DS    0H
         TM    TIOELINK,TIOESSDS   IF A SUBSYSTEM DATA SET
         BZ    AFTUCB              THEN
         MVC   VOLSER(6),=C'SYSOUT'      SAY SO
         B     NOJFCB              ELSE
         SPACE
AFTUCB   DS    0H
         SPACE
         ICM   R6,7,TIOEJFCB       GET ADDRESS OF JFCB
         BZ    NOJFCB
         MVC   DSNAME(44),0+16(R6) MOVE DSNAME TO OUTPUT LINE
         CLC   DSNAME(9),=C'NULLFILE '
         BNE   NOTDUMMY
         CLC   VOLSER(6),BLANKS
         BNE   NOTDUMMY
         MVC   VOLSER(5),=C'DUMMY'
NOTDUMMY DS    0H
         CLI   44+16(R6),C' '      IF A MEMBER NAME PRESENT
         BE    NOMEM               THEN
         LA    R1,DSNAME+44        SCAN FOR LAST NONBLANK IN DSNAME
         LA    R0,44
DSNLOOP  CLI   0(R1),C' '
         BNE   ENDDSN
         BCTR  R1,0
         BCT   R0,DSNLOOP
ENDDSN   DS    0H
         MVI   1(R1),C'('           MOVE LEFT PAREN
         MVC   2(8,R1),44+16(R6)  MOVE MEMBER NAME IN
         LA    R1,2+8(,R1)         SCAN FOR LAST NONBLANK IN MEMBER
         LA    R0,8
MEMLOOP  CLI   0(R1),C' '
         BNE   ENDMEM
         BCTR  R1,0
         BCT   R0,MEMLOOP
ENDMEM   MVI   1(R1),C')'
NOMEM    DS    0H
NOJFCB   DS    0H
         SPACE
         CLC   VOLSER(6),BLANKS
         BNE   NOTVBLK
         MVC   VOLSER(2),=X'7D7D'
NOTVBLK  DS    0H
         PUT   OUTDCB,DATALINE     WRITE LINE OUT TO DATA SET
         XR    R7,R7               INDICATE DATA DISPLAYED
         SPACE
SKIP     DS    0H
         IC    R4,TIOELNGH         ELSE GET LENGTH OF THIS ENTRY
         ALR   R3,R4               ADD LENGTH TO GET TO NEXT ENTRY
         CLI   TIOELNGH,X'00'      IF END OF TIOT
         BNE   LOOP                THEN END, ELSE CONTINUE
         SPACE
         LTR   R7,R7               IF DATA WAS NOT DISPLAYED
         BZ    RETURN              THEN
         PUT   OUTDCB,NOTHING       SAY NOTHING FOUND
         SPACE
RETURN   DS    0H
         CLOSE MF=(E,OUTDCBO)
         LR    R1,R13
         LA    R0,SIZDATD
         L     R13,4(,R13)
         ST    R7,16(,R13)         STORE RETURN CODE
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         TITLE 'XALLOCSV - DATA AREAS'
MOVEDD   MVC   ARGDD(0),0(R14)     MOVE OPERAND TO TEST DDNAME
         SPACE
BLANKS   DC    CL8' '              ALL-PURPOSE BLANKS
         SPACE
NOTHING  DC    CL80''''' '''' ''''  ''NO ALLOCATIONS FOR FILE NAME'''
         SPACE
INVALID  DC    CL80''''' '''' ''''  ''INVALID FILE NAME SPECIFIED'''
         SPACE
ARGTABLE DC    256YL1(*-ARGTABLE)  TRANSLATE TABLE FOR DD ARGUMENT
         ORG   ARGTABLE+C'*'        WHICH CHANGES ASTERISKS
         DC    X'FF'                TO ALL 1-BITS
         ORG   ARGTABLE+X'81'       AND SHIFTS TO UPPER CASE
         DC    C'ABCDEFGHI'
         ORG   ARGTABLE+X'91'
         DC    C'JKLMNOPQR'
         ORG   ARGTABLE+X'A2'
         DC    C'STUVWXYZ'
         ORG
         SPACE
MSKTABLE DC    256YL1(0)           TRANSLATE TABLE FOR DD MASK
         ORG   MSKTABLE+C'*'        WHICH CHANGES ALL CHARS TO 0-BITS
         DC    X'FF'                EXCEPT ASTERISKS, WHICH ARE 1-BITS
         ORG
         PRINT NOGEN
OUTDCBS  DCB   DDNAME=CSDALLOC,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,    X
               BLKSIZE=1680
OUTDCBL  EQU   *-OUTDCBS
         EJECT
DATD     DSECT
SAVEAREA DS    18F
ARGDD    DS    CL8
MASKDD   DS    CL8
TESTDD   DS    CL8
FLAGS    DS    X
DDFLAG   EQU   X'80'               1 = A DDNAME WAS SPECIFIED
DISPLAYD EQU   X'40'               1 = RESPONSE WAS DISPLAYED
OUTDCB   DS    CL(OUTDCBL)
OUTDCBO  OPEN  (*-*),MF=L
DATALINE DS    CL80
         ORG   DATALINE
DDNAME   DS    CL8
         DS    C
VOLSER   DS    CL6
         DS    C
DSNAME   DS    CL44
         ORG
         SPACE
SIZDATD  EQU   *-DATD
         EJECT
         IKJCPPL
         EJECT
         IKJECT
         EJECT
TIOT     DSECT
         IEFTIOT1 ,                MAP TIOT - NEED DST1.AMODGEN
         IEFUCBOB ,                MAP UCB  - NEED DST1.AMODGEN
XALLOCSV CSECT
         LTORG
         END
./ ADD NAME=XAMODE   0100-07332-07332-0900-00058-00058-00000-SEB
         TITLE 'XAMODE   - Function that returns current AMODE'
***********************************************************************
*                                                                     *
* XAMODE   - Function that returns current AMODE                      *
*                                                                     *
* This function returns either 24 or 31 as the return code / integer  *
* value to its caller.                                                *
*                                                                     *
* PL/1 invocation:                                                    *
*                                                                     *
*  DCL XAMODE ENTRY OPTIONS(ASSEMBLER INTER RETCODE);                 *
*                                                                     *
*  CALL XAMODE;                                                       *
*  SELECT PLIRETV();                                                  *
*   WHEN (24) ...                                                     *
*   WHEN (31) ...                                                     *
*  END;                                                               *
*                                                                     *
* FORTRAN invocation:                                                 *
*                                                                     *
*  INTEGER*4 XAMODE,IRC                                               *
*                                                                     *
*  IRC = XAMODE()                                                     *
*  IF (IRC.EQ.24) ...                                                 *
*  IF (IRC.EQ.31) ...                                                 *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 1
XAMODE   CSECT
XAMODE   AMODE ANY
XAMODE   RMODE ANY
         BSM   R15,0               Get AMODE into hi-ord bit of reg 15
         LTR   R15,R15             Test high-order bit (sign)
         LA    R0,24               Return AMODE 24
         LR    R15,R0              (for PL/1 and FORTRAN)
         BNMR  R14                 if high-order bit is zero.
         LA    R0,31               Return AMODE 31
         LR    R15,R0              (for PL/1 and FORTRAN)
         BR    R14                 if high-order bit is one.
         SPACE 1
         END
./ ADD NAME=XCLIST   0100-07332-07332-0900-00101-00101-00000-SEB
         TITLE 'XCLIST - SUBROUTINE TO RUN A CLIST FROM A PL/1 PROGRAM'
***********************************************************************
*                                                                     *
* XCLIST - PL/1 SUBROUTINE TO EXECUTE A CLIST (OR NORMAL TSO COMMAND) *
*          FROM WITHIN A PROGRAM.  THIS PROGRAM WAS WRITTEN IN ORDER  *
*          TO ENABLE THE M6A PROJECT TO PROCEED, AS A SEMITEMPORARY   *
*          MEASURE PRIOR TO ONE OF THE FOLLOWING BECOMING TRUE:       *
*                                                                     *
* (1) TONE SOFTWARE FIXES THE INTEXEC FEATURE OF PROCMAN.             *
* (2) TSO/EXTENSIONS RELEASE 2 (INCLUDING TSO SERVICE FACILITY)       *
*     IS INSTALLED.                                                   *
* (3) THE PROJECT CONVERTS TO ISPF.                                   *
*                                                                     *
*          THE PROGRAM WORKS LIKE XCMD IN THAT IT SCANS THE COMMAND   *
*          BUFFER AND PASSES CONTROL TO THE REQUESTED COMMAND         *
*          PROCESSOR.  HOWEVER, IT IS DIFFERENT IN THAT IT ALSO       *
*          PROCESSES ALL COMMANDS PLACED ON THE INPUT STACK BY THE    *
*          INITIAL COMMAND.                                           *
*          AT THE PRESENT TIME NO TASK LIBRARY SPECIFICATIONS ARE     *
*          USED BY THIS COMMAND.  HOWEVER, THIS CAN EASILY BE         *
*          GOTTEN AROUND BY INVOKING XCMD VIA THIS FACILITY, SINCE    *
*          THE INITIAL COMMAND DOES NOT HAVE TO BE A CLIST AS LONG    *
*          AS SOMETHING IS PLACED ON THE INPUT STACK WHILE THE        *
*          INITIAL COMMAND IS PROCESSED.                              *
*                                                                     *
* THE SUBROUTINE IS INVOKED AS FOLLOWS:                               *
*                                                                     *
*    CALL XCLIST ('CLISTNAME CLISTOPERANDS ETC.');                    *
*                                                                     *
* A DECLARATION SHOULD BE INCLUDED IN THE PL/1 PROGRAM AS FOLLOWS:    *
*                                                                     *
*    DCL XCLIST EXT ENTRY(CHAR(*) VAR) OPTIONS(ASSEMBLER RETCODE);    *
*                                                                     *
* INPUT IS A PL/1 VARYING-LENGTH CHARACTER STRING (YOU KNOW, A        *
* HALFWORD CONTAINING THE COMMAND LENGTH FOLLOWED BY THE COMMAND).    *
*                                                                     *
* THE RETURN CODE FROM THE LAST COMMAND EXECUTED IS RETURNED TO       *
* THE CALLING PROGRAM.                                                *
*                                                                     *
***********************************************************************
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
* 09/84 - FIX BUG IN NOT RETURNING RC 12 FROM ISPEXEC COMMAND         *
*                                                                     *
* 01/25/85 - RETURN THE RETURN CODE IN REGISTER 0 TO MAKE IT          *
*            AVAILABLE TO FORTRAN CALLERS.  THE FORTRAN INTERFACE     *
*            IS SOMETHING LIKE THIS:                                  *
*                                                                     *
*      INTEGER*2    ILEN                                              *
*      INTEGER*4    IRC                                               *
*      INTEGER*4    XCLIST                                            *
*      CHARACTER*2  CMDLEN                                            *
*      CHARACTER*80 CMD                                               *
*      DATA ILEN/80/                                                  *
*      EQUIVALENCE (ILEN,CMDLEN)                                      *
*      CMD = 'WHATEVER YOUR COMMAND IS'                               *
*      IRC = XCLIST(CMDLEN // CMD)                                    *
*C     ... IRC IS THE RETURN CODE FROM THE COMMAND.                   *
*                                                                     *
* 01/30/85 - XCLIST WILL NOW ISSUE A WRITE-TO-PROGRAMMER MESSAGE      *
*            IF IT IS INVOKED IN A NON-TSO ENVIRONMENT.  ALSO,        *
*            USER ABEND 1500 WILL BE ISSUED IN THIS CASE.             *
*                                                                     *
* 05/01/87 - (1) AMODE/RMODE SUPPORT ADDED.                           *
*            (2) BUG FIXED CALLING XCLIST WITH SYNTACTICALLY INVALID  *
*                COMMANDS MORE THAN ONCE FROM THE SAME PROGRAM.       *
*                                                                     *
*                THIS APPEARS TO BE A BUG IN IKJSCAN RATHER THAN IN   *
*                XCLIST.  BUT WE WILL TRY TO PROGRAM AROUND IT ANYHOW *
*                                                                     *
* 12/15/87 - (1) In preparation for TSO/E Release 4, which causes     *
*                some more TSO commands to be APF authorized, XCLIST  *
*                will now use the TSO service facility to invoke      *
*                TSO commands which it finds in the TSO authorized    *
*                command names table (IKJEFTE2).                      *
*                                                                     *
* 05/17/88 - (1) ISPF 2.3.0 no longer has an ISPCALL command.         *
*                Therefore, XCLIST will now use the name IKJEFG00     *
*                rather than ISPCALL when it invokes the CALL command.*
*                                                                     *
* 03/28/89 - The body of the code for XCLIST has been moved into the  *
*            linklist-resident routine XTSEXEC.  XCLIST is now a stub *
*            that LINKs to XTSEXEC.  In this way the code may be      *
*            enhanced, upgraded and tested, with new features of      *
*            TSO/Extensions in mind.                                  *
*                                                                     *
***********************************************************************
         EJECT
XCLIST   CSECT
XCLIST   AMODE ANY
XCLIST   RMODE ANY
         STM   14,12,12(13)
         USING XCLIST,15
         LINK  EPLOC=$XTSEXEC
         L     14,12(,13)          preserve regs 15 and 0
         LM    1,12,24(13)
         BR    14
         SPACE
$XTSEXEC DC    CL8'XTSEXEC '
         END
./ ADD NAME=XCONCAT  0100-07332-07332-0900-00298-00298-00000-SEB
         TITLE 'XCONCAT - TSO COMMAND TO CONCATENATE FILES          '
***********************************************************************
*                                                                     *
* XCONCAT - TSO COMMAND TO CONCATENATE 2 OR MORE PREALLOCATED FILES   *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    MISCELLANEOUS USES
R4       EQU   4    ADDRESS OF COMMAND PROCESSOR PARAMETER LIST
R5       EQU   5    USED FOR DAIRFAIL STORAGE
R6       EQU   6    ADDRESS OF THE COMMAND BUFFER
R7       EQU   7    DDNAME COUNTER
R8       EQU   8    DDNAME POINTER
R9       EQU   9    CONSTANT 8 FOR DDNAME MOVES
R10      EQU   10   ADDRESS OF THE DAPB0C PARAMETER BLOCK
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XCONCAT CSECT
         SAVE  (14,12),,XCONCAT_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XCONCAT,R12
         LR    R4,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         USING CPPL,R4             MAP INPUT PARAMETER LIST
         EJECT
         MVC   DAPLUPT,CPPLUPT         PTR TO UPT
         MVC   DAPLECT,CPPLECT         PTR TO ECT
         MVC   DAPLPSCB,CPPLPSCB       PTR TO PSCB
         MVC   CSPLUPT,CPPLUPT         PTR TO  UPT
         MVC   CSPLECT,CPPLECT         PTR TO  ECT
         MVC   IOPLUPT,CPPLUPT         PTR TO UPT
         MVC   IOPLECT,CPPLECT         PTR TO ECT
         LA    R0,ECB
         ST    R0,DAPLECB              PTR TO CP'S ECB
         ST    R0,CSPLECB              PTR TO  CP'S ECB
         ST    R0,IOPLECB              PTR TO USER'S ECB
         MVI   FLAG,X'00'              REQUEST SYNTAX CHECKS
         LA    R0,FLAG
         ST    R0,CSPLFLG              PTR TO  FLAG WORD
         LA    R0,CSOA
         ST    R0,CSPLOA               PTR TO OUTPUT AREA (CSOA DSECT)
         MVC   CSPLCBUF,CPPLCBUF       PTR TO COMMAND BUFFER
         SPACE 2
         L     R6,CPPLCBUF         GET ADDRESS OF COMMAND BUFFER
         LH    R0,0(,R6)           GET LENGTH OF COMMAND BUFFER
         SLL   R0,2                MULTIPLY BY 4 TO BE REALLY SAFE
         AH    R0,=H'12'           AND ADD 12 FOR THE PREFIX
         ST    R0,DALEN            SAVE THIS LENGTH
         GETMAIN R,LV=(0)          ASSUME THIS WILL HOLD ALL DDNAMES
         LR    R10,R1
         USING DAPB0C,R10
         ST    R10,DAPLDAPB            PTR TO DAIR PARAMETER BLOCK
         XC    DAPB0C(12),DAPB0C       CLEAR THE PARAMETER BLOCK
         MVI   DA0CCD+1,X'0C'          SET DAIR ENTRY CODE
         XR    R7,R7               INITIALIZE DDNAME COUNTER
         LA    R8,DA0CDDN          INITIALIZE DDNAME POINTER
         SPACE 2
GETDDN   XC    ECB,ECB
         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  SCAN FOR A DDNAME
         TM    CSOAFLG,CSOABAD+CSOAQM+CSOAEXEC
         BNZ   ERROR1
         TM    CSOAFLG,CSOANOC
         BO    NOMORE
         LA    R7,1(,R7)           INCREMENT DDNAME COUNTER
         LA    R9,8                SET DDNAME LENGTH REGISTER
         L     R14,CSOACNM
         LH    R15,CSOALNM
         ICM   R15,8,=X'40'
         MVCL  R8,R14              MOVE DDNAME TO DAPB0C PARM LIST
         B     GETDDN
         SPACE 1
NOMORE   DS    0H                  NO MORE DDNAMES, FINISHED
         STH   R7,DA0CNUMB
         CH    R7,=H'2'
         BL    ERROR2
         SPACE 2
         XC    ECB,ECB
         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)
******   LA    R1,DAPL             THIS WAS ONCE PUT IN TO PERMIT DAIR
******   LINK  EP=IKJDAIR          TESTING UNDER TSO TEST WITH BREAKPTS
AFTLINK  DS    0H                  BREAKPOINT AFTER DAIR WAS CALLED
         ORG   *-2
LINKDAIR DS    0H                  BREAKPOINT WHEN DAIR ABOUT TO BE
         ORG
         LTR   R15,R15
         BZ    RETURN0
         SPACE 1
***********************************************************************
* IF CONCATENATION REQUEST FAILED, CALL DAIRFAIL TO DISPLAY MESSAGE.  *
***********************************************************************
         SPACE 1
         ST    R15,DAIRRC          STORE RETURN CODE FROM DAIR
         L     R0,DFGETWD          GET SUBPOOL & LENGTH FOR STORAGE
         GETMAIN R,LV=(0)          GET STORAGE FOR DAIRFAIL
         LR    R5,R1               ADDRESS DAIRFAIL PARAMETER LIST
         LA    R14,DAPL            +00->ADDRESS OF DAPL
         LA    R15,DAIRRC          +04->ADDRESS OF RETURN CODE
         LA    R0,=F'0'            +08->ADDRESS OF IKJEFF02 NOT PRESENT
         LA    R1,=H'1'            +0C->REQUEST FOR MSG USING PUTLINE
         LA    R2,CPPL             +10->ADDRESS OF CPPL FOR PUTLINE
         XR    R3,R3               +14=ZEROES
         STM   R14,R3,0(R5)        SET UP PARAMETER LIST FOR DAIRFAIL
         LR    R1,R5               USING PARAMETER LIST,
         LINK  EP=IKJEFF18         CALL DAIRFAIL SERVICE ROUTINE
         LTR   R1,R15              IF DAIRFAIL FAILED,
         BNZ   ABEND               THEN BLOW UP
         LR    R1,R5               ELSE...
         L     R0,DFGETWD
         FREEMAIN R,LV=(0),A=(1)   FREE THE STORAGE
         B     RETURN12            RETURN WITH CODE 12
         EJECT
ERROR1   DS    0H
         SPACE 1
         LA    R1,BADPARMS         ADDRESS OF ERROR MESSAGE
         B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT
         SPACE 2
ERROR2   DS    0H
         SPACE 1
         LA    R1,BADDDS           ADDRESS OF ERROR MESSAGE
******** B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT
         SPACE 2
TERMPUT  DS    0H                  DISPLAY MSG: R1 -> MSG HEADER
         SPACE 1
         MVC   PTLIST(LENPUTL),MPTLIST SET UP STACK LIST FORM
         LA    R0,1                DEFINE 1 MESSAGE SEGMENT
         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R1,R15
         BNZ   ABEND
******** B     RETURN12            RETURN WITH CODE 12
         SPACE 2
RETURN12 DS    0H                  RETURN WITH CODE 12
         SPACE 1
         MVC   FLUSH(LENFLUSH),MFLUSH SET UP STACK LIST FORM
         XC    ECB,ECB             CLEAR ECB AND FLUSH THE INPUT STACK
         STACK PARM=FLUSH,MF=(E,IOPL)
         LTR   R1,R15
         BNZ   ABEND
         SPACE 2
STACKOK  LA    R15,12              SET RETURN CODE TO 12
         B     RETURN
         SPACE 3
ABEND    ABEND (1),DUMP            BAD RC FROM SOMETHING, BLOW UP
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R14,R15
         LR    R1,R10              FREE THE DAPB0C BUFFER
         L     R0,DALEN
         FREEMAIN R,LV=(0),A=(1)
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R14,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* NO EXECUTED INSTRUCTIONS                                            *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
DFGETWD  DC    0F'0',YL1(78),AL3(24) GETMAIN/FREEMAIN: SP=78,LV=24
         SPACE 1
MFLUSH   STACK MF=L,DELETE=ALL
LENFLUSH EQU   *-MFLUSH
         SPACE 1
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
         SPACE 2
BADPARMS WTO   MF=L,'XCONCAT: INVALID DDNAME(S) ENTERED.'
         SPACE 1
BADDDS   WTO   MF=L,'XCONCAT: AT LEAST TWO DDNAMES REQUIRED.'
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F                 OS SAVE AREA
         SPACE 1
ECB      DS    F                   ECB FOR TSO ROUTINES
FLAG     DS    F                   FLAG WORD FOR IKJSCAN
DALEN    DS    F                   LENGTH OF DA0C BUFFER
DAIRRC   DS    F                   RETURN CODE FROM DAIR
         SPACE 1
OLD      DS    0F                  PUTLINE OUTPUT LINE DESCRIPTOR
OLDF1    DS    F'1'                NUMBER OF MESSAGE SEGMENTS
OLDMSG   DS    A(*-*)              ADDRESS OF THE FIRST MESSAGE SEGMENT
         SPACE 1
FLUSH    STACK MF=L,DELETE=ALL
         SPACE 1
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE 1
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
DAPL     DS    0A
         SPACE 1
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
         SPACE 2
CSPL     DS    0A
***********************************************************************
*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *
*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *
***********************************************************************
         SPACE 1
CSPLUPT  DS    A        PTR TO  UPT
CSPLECT  DS    A        PTR TO  ECT
CSPLECB  DS    A        PTR TO  CP'S ECB
CSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED
*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF
*                       COMMAND NAME.
CSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)
CSPLCBUF DS    A        PTR TO COMMAND BUFFER
         SPACE 1
CSOA     DS    0A
***********************************************************************
*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *
*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *
*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *
***********************************************************************
         SPACE 1
CSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME
CSOALNM  DS    H        LENGTH OF CMD NAME
CSOAFLG  DS    X        FLAGS
CSOAVWP  EQU   X'80'    VALID WITH PARAMETERS
CSOAVNP  EQU   X'40'    VALID NO   PARAMS
CSOAQM   EQU   X'20'    QUESTION MARK
CSOANOC  EQU   X'10'    NO COMMAND
CSOABAD  EQU   X'08'    BAD CMD NAME
CSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME              Y30PQJN
         DS    CL1      RESERVED
         SPACE 2
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE 1
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
***********************************************************************
* DYNAMIC ALLOCATION PARAMETER BLOCK TO CONCATENATE DDNAMES           *
***********************************************************************
         IKJDAP0C
         SPACE
DA0CDDN  DS    0CL8                DDNAMES
         EJECT
         IKJCPPL
         EJECT
         CVT   DSECT=YES
         END
./ ADD NAME=XDECONC  0100-07332-07332-0900-00290-00290-00000-SEB
         TITLE 'XDECONC - TSO COMMAND TO DECONCATENATE FILES'
***********************************************************************
*                                                                     *
* XDECONC - TSO COMMAND TO DECONCATENATE A CONCATENATED FILE NAME     *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    MISCELLANEOUS USES
R4       EQU   4    ADDRESS OF COMMAND PROCESSOR PARAMETER LIST
R5       EQU   5    USED FOR DAIRFAIL STORAGE
R6       EQU   6    ADDRESS OF THE COMMAND BUFFER
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XDECONC CSECT
         SAVE  (14,12),,XDECONC_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XDECONC,R12
         LR    R4,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         USING CPPL,R4             MAP INPUT PARAMETER LIST
         EJECT
         MVC   DAPLUPT,CPPLUPT         PTR TO UPT
         MVC   DAPLECT,CPPLECT         PTR TO ECT
         MVC   DAPLPSCB,CPPLPSCB       PTR TO PSCB
         MVC   CSPLUPT,CPPLUPT         PTR TO  UPT
         MVC   CSPLECT,CPPLECT         PTR TO  ECT
         MVC   IOPLUPT,CPPLUPT         PTR TO UPT
         MVC   IOPLECT,CPPLECT         PTR TO ECT
         LA    R0,ECB
         ST    R0,DAPLECB              PTR TO CP'S ECB
         ST    R0,CSPLECB              PTR TO  CP'S ECB
         ST    R0,IOPLECB              PTR TO USER'S ECB
         MVI   FLAG,X'00'              REQUEST SYNTAX CHECKS
         LA    R0,FLAG
         ST    R0,CSPLFLG              PTR TO  FLAG WORD
         LA    R0,CSOA
         ST    R0,CSPLOA               PTR TO OUTPUT AREA (CSOA DSECT)
         MVC   CSPLCBUF,CPPLCBUF       PTR TO COMMAND BUFFER
         LA    R1,DAPB10
         ST    R1,DAPLDAPB             PTR TO DAIR PARAMETER BLOCK
         XC    DAPB10(16),DAPB10       CLEAR THE PARAMETER BLOCK
         MVI   DA10CD+1,X'10'          SET DAIR ENTRY CODE
         MVI   DA10DDN,C' '            CLEAR DDNAME TO BLANKS
         MVC   DA10DDN+1(7),DA10DDN
         SPACE 2
GETDDN   XC    ECB,ECB
         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  SCAN FOR A DDNAME
         TM    CSOAFLG,CSOABAD+CSOAQM+CSOAEXEC  BAD DD SYNTAX?
         BNZ   ERROR1
         TM    CSOAFLG,CSOANOC     NO DDNAME?
         BO    ERROR2
         TM    CSOAFLG,CSOAVWP     TOO MANY DDNAMES?
         BO    ERROR3
         L     R14,CSOACNM         GET ADDRESS OF DDNAME
         LH    R15,CSOALNM         GET LENGTH OF DDNAME
         BCTR  R15,0
         EX    R15,MOVEDDN         MOVE DDNAME TO DAPB10 PARM LIST
         SPACE 2
         XC    ECB,ECB
         CALLTSSR EP=IKJDAIR,MF=(E,DAPL) DO IT TO IT
         LTR   R15,R15
         BZ    RETURN0
         SPACE 1
***********************************************************************
* IF DECONCATENATION REQUEST FAILED, CALL DAIRFAIL TO DISPLAY MESSAGE *
***********************************************************************
         SPACE 1
         ST    R15,DAIRRC          STORE RETURN CODE FROM DAIR
         L     R0,DFGETWD          GET SUBPOOL & LENGTH FOR STORAGE
         GETMAIN R,LV=(0)          GET STORAGE FOR DAIRFAIL
         LR    R5,R1               ADDRESS DAIRFAIL PARAMETER LIST
         LA    R14,DAPL            +00->ADDRESS OF DAPL
         LA    R15,DAIRRC          +04->ADDRESS OF RETURN CODE
         LA    R0,=F'0'            +08->ADDRESS OF IKJEFF02 NOT PRESENT
         LA    R1,=H'1'            +0C->REQUEST FOR MSG USING PUTLINE
         LA    R2,CPPL             +10->ADDRESS OF CPPL FOR PUTLINE
         XR    R3,R3               +14=ZEROES
         STM   R14,R3,0(R5)        SET UP PARAMETER LIST FOR DAIRFAIL
         LR    R1,R5               USING PARAMETER LIST,
         LINK  EP=IKJEFF18         CALL DAIRFAIL SERVICE ROUTINE
         LTR   R1,R15              IF DAIRFAIL FAILED,
         BNZ   ABEND               THEN BLOW UP
         LR    R1,R5               ELSE...
         L     R0,DFGETWD
         FREEMAIN R,LV=(0),A=(1)   FREE THE STORAGE
         B     RETURN12            RETURN WITH CODE 12
         EJECT
ERROR1   DS    0H
         SPACE 1
         LA    R1,INVALID          ADDRESS OF ERROR MESSAGE
         B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT
         SPACE 2
ERROR2   DS    0H
         SPACE 1
         LA    R1,MISSING          ADDRESS OF ERROR MESSAGE
         B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT
         SPACE 2
ERROR3   DS    0H
         SPACE 1
         LA    R1,TOOMANY          ADDRESS OF ERROR MESSAGE
******** B     TERMPUT             GO TO DISPLAY ERROR MSG AND EXIT
         SPACE 2
TERMPUT  DS    0H                  DISPLAY MSG: R1 -> MSG HEADER
         SPACE 1
         MVC   PTLIST(LENPUTL),MPTLIST SET UP STACK LIST FORM
         LA    R0,1                DEFINE 1 MESSAGE SEGMENT
         STM   R0,R1,OLD           SET UP OUTPUT LINE DESCRIPTOR
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R1,R15
         BNZ   ABEND
******** B     RETURN12            RETURN WITH CODE 12
         SPACE 2
RETURN12 DS    0H                  RETURN WITH CODE 12
         SPACE 1
         MVC   FLUSH(LENFLUSH),MFLUSH SET UP STACK LIST FORM
         XC    ECB,ECB             CLEAR ECB AND FLUSH THE INPUT STACK
         STACK PARM=FLUSH,MF=(E,IOPL)
         LTR   R1,R15
         BNZ   ABEND
         SPACE 2
STACKOK  LA    R15,12              SET RETURN CODE TO 12
         B     RETURN
         SPACE 3
ABEND    ABEND (1),DUMP            BAD RC FROM SOMETHING, BLOW UP
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE
MOVEDDN  MVC   DA10DDN(0),0(R14)   EXECUTED: MOVE DDNAME TO DAIR BLOCK
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
DFGETWD  DC    0F'0',YL1(78),AL3(24) GETMAIN/FREEMAIN: SP=78,LV=24
         SPACE 1
MFLUSH   STACK MF=L,DELETE=ALL
LENFLUSH EQU   *-MFLUSH
         SPACE 1
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
         SPACE 2
INVALID WTO    MF=L,'XDECONC: INVALID DDNAME ENTERED.'
         SPACE 1
MISSING  WTO   MF=L,'XDECONC: A DDNAME IS REQUIRED.'
         SPACE 1
TOOMANY  WTO   MF=L,'XDECONC: ONLY ONE DDNAME PERMITTED.'
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F                 OS SAVE AREA
         SPACE 1
ECB      DS    F                   ECB FOR TSO ROUTINES
FLAG     DS    F                   FLAG WORD FOR IKJSCAN
DALEN    DS    F                   LENGTH OF DA10 BUFFER
DAIRRC   DS    F                   RETURN CODE FROM DAIR
         SPACE 1
OLD      DS    0F                  PUTLINE OUTPUT LINE DESCRIPTOR
OLDF1    DS    F'1'                NUMBER OF MESSAGE SEGMENTS
OLDMSG   DS    A(*-*)              ADDRESS OF THE FIRST MESSAGE SEGMENT
         SPACE 1
FLUSH    STACK MF=L,DELETE=ALL
         SPACE 1
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE 1
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
DAPL     DS    0A
         SPACE 1
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
         SPACE 2
CSPL     DS    0A
***********************************************************************
*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *
*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *
***********************************************************************
         SPACE 1
CSPLUPT  DS    A        PTR TO  UPT
CSPLECT  DS    A        PTR TO  ECT
CSPLECB  DS    A        PTR TO  CP'S ECB
CSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED
*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF
*                       COMMAND NAME.
CSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)
CSPLCBUF DS    A        PTR TO COMMAND BUFFER
         SPACE 1
CSOA     DS    0A
***********************************************************************
*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *
*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *
*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *
***********************************************************************
         SPACE 1
CSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME
CSOALNM  DS    H        LENGTH OF CMD NAME
CSOAFLG  DS    X        FLAGS
CSOAVWP  EQU   X'80'    VALID WITH PARAMETERS
CSOAVNP  EQU   X'40'    VALID NO   PARAMS
CSOAQM   EQU   X'20'    QUESTION MARK
CSOANOC  EQU   X'10'    NO COMMAND
CSOABAD  EQU   X'08'    BAD CMD NAME
CSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME              Y30PQJN
         DS    CL1      RESERVED
         SPACE 2
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE 1
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE 2
***********************************************************************
* DYNAMIC ALLOCATION PARAMETER BLOCK TO DECONCATENATE DDNAMES         *
***********************************************************************
DAPB10   DS    0A
***********************************************************************
* THIS OPERATION CODE CAUSES THE PREVIOUSLY CONCATENATED DDNAME  TO   *
* BE DECONCATENATED                                                   *
***********************************************************************
DA10CD   DS    CL2      DAIR ENTRY CODE
DA10FLG  DS    X        FUNCTIONS TO BE PERFORMED WHEN RET CODE IS 0
         DS    X
DA10DARC DS    H        DYN ALLOC RETURN CODE
         DS    CL2      RESERVED
DA10DDN  DS    CL8      DDNAME TO BE SEARCHED IN DSE
         SPACE 3
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJCPPL
         EJECT
         CVT   DSECT=YES
         END
./ ADD NAME=XFINDM   0100-07332-07332-0900-00154-00154-00000-SEB
         TITLE 'XFINDM - INSTREAM MACRO'
         MACRO
&NAME    TEPUT &A,&L
.* NEW IMPROVED TPUT MACRO
&NAME    LA    R1,&A                    LOAD PARAMETER REG 1
         LA    R0,&L                    LOAD PARAMETER REG 0
         SVC   93                       ISSUE TPUT SVC
         MEND
         TITLE 'XFINDM - TELLS WHERE MEMBER IS IN PDS CONCATENATION'
XFINDM   CSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SAVE  (14,12),,XFINDM_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XFINDM,R12
         L     R4,0(,R1)               ADDRESS OF PARAMETER STRING
         LH    R2,0(,R4)               LENGTH OF PARAMETER STRING
         LTR   R2,R2                   IF PARM LENGTH NOT ZERO,
         BZ    NODDNAME                THEN...
         CH    R2,=H'8'                 IF PARM LENGTH EXCEEDS 8,
         BNH   DDNAMEOK                 THEN...
         TEPUT BADDD,L'BADDD             'INVALID DDNAME'
         B     RETURN                   ELSE...
DDNAMEOK MVC   SYSLIB+40(8),BLANKS       MOVE BLANKS TO DCB DDNAME
         BCTR  R2,0                      USING PARM LENGTH,
         EX    R2,MOVEDD                 MOVE DDNAME TO DCB
         B     OPEN                    ELSE (ZERO PARM LENGTH)...
NODDNAME TEPUT DEFAULT,L'DEFAULT        'NO DDNAME, USING SYSLIB'
OPEN     MVC   DD1,SYSLIB+40           MOVE DDNAME TO MESSAGE
         OPEN  SYSLIB                  OPEN THE PDS
         TM    SYSLIB+48,X'10'         IF PDS WAS NOT OPENED,
         BNO   NOSYSLIB                THEN FAIL. ELSE...
         MVC   BLDLNAME,BLANKS         MOVE BLANKS TO BLDL LIST NAME
         BLDL  SYSLIB,BLDLLIST         DO DUMMY BLDL ON BLANK MEMBER
         B     DUMBLDL(R15)            CHECK BLDL RETURN CODE
DUMBLDL  B     DSORGOK                 RC=0 - DSORG OK
         B     DSORGOK                 RC=4 - DSORG OK
         MVC   DD2,DD1                 RC=8 - BLDL I/O ERROR
         TEPUT BADDSORG,L'BADDSORG     'BAD DSORG (NOT PO)'
         B     END                      AND FAIL.
         SPACE
DSORGOK  DS    0H                      DSORG IS PO - CONTINUE
         L     R15,X'21C'              TCB
         L     R5,12(,R15)             TIOT
         AH    R5,SYSLIB+40            ADD TIOT OFFSET FROM DCB
* R5 NOW POINTS TO THE FIRST TIOT ENTRY FOR THE DDNAME.
         SPACE
ASK      TEPUT PROMPT,L'PROMPT         ASK FOR A MEMBER NAME
         TGET  MEMNAME,8               READ IN A MEMBER NAME
         CH    R15,=H'12'              IF INPUT LONGER THAN 8 CHARS
         BE    TOOLONG                 THEN MEMBER NAME TOO LONG
         CH    R15,=H'8'               ELSE IF ATTENTION INTERRUPT
         BE    ATTN                    THEN REPROMPT
         LTR   R15,R15                 ELSE IF OTHER BAD RETURN CODE
         BNZ   TGETERR                 THEN DISASTROUS ERROR. ELSE...
         OC    MEMNAME,BLANKS          SHIFT NAME TO UPPER CASE
         CLC   MEMNAME,BLANKS          IF NO NAME ENTERED (NULL LINE),
         BE    END                     THEN GO CLOSE PDS & END. ELSE...
         MVC   BLDLNAME,MEMNAME        MOVE NAME TO BLDL LIST
         BLDL  SYSLIB,BLDLLIST         DO BLDL FOR THE MEMBER
         B     GO(R15)                 BRANCH DEPENDING ON RETURN CODE
GO       B     BLDL0                   RC=0 - MEMBER FOUND
         B     BLDL4                   RC=4 - MEMBER NOT FOUND
         B     BLDL8                   RC=8 - UNEXPECTED ERROR
         SPACE
BLDL0    DS    0H                      BLDL RC=0: SUCCESSFUL
         XR    R3,R3                   CLEAR INSERT REG
         ICM   R3,1,K                  PICK UP CONCATENATION INDEX
         MH    R3,=H'20'               CONVERT TO OFFSET INTO TIOT
* (ASSUME THAT, SINCE ALL DD ENTRIES ARE FOR PDS'S AND PDS'S CANNOT
*  RESIDE ON MORE THAN ONE VOLUME, ALL TIOT ENTRIES FOR THIS DDNAME
*  ARE 20 BYTES IN LENGTH SINCE THEY CONTAIN 1 UCB ADDRESS EACH.)
         ALR   R3,R5                   CONVERT TO TIOT-ENTRY ADDRESS
         ICM   R4,7,12(R3)             GET JFCB ADDRESS
         MVC   DSNAME,16(R4)           MOVE DSNAME FROM JFCB TO MESSAGE
         MVC   DSNMSG(8),BLDLNAME      MOVE MEMBER NAME TO MESSAGE
         TEPUT DSNMSG,DSNMSGL          TELL USER WHERE MEMBER CAME FROM
         B     ASK                     AND GO GET ANOTHER MEMBER NAME.
         SPACE
BLDL4    DS    0H                      BLDL RC=4: MEMBER NOT FOUND
         MVC   NOTFOUND(8),BLDLNAME    MOVE MEMBER NAME TO MESSAGE
         TEPUT NOTFOUND,L'NOTFOUND     DISPLAY NOT-FOUND MESSAGE
         B     ASK                     AND GO GET ANOTHER MEMBER NAME.
         SPACE
BLDL8    DS    0H                      BLDL RC=8: DIRECTORY I/O ERROR
         TEPUT ERROR8,L'ERROR8         TELL USER THE SAD NEWS
         B     ASK                     AND GO GET ANOTHER MEMBER NAME.
         SPACE
TOOLONG  DS    0H                      USER ENTERED TOO MUCH DATA
         TEPUT MSGTL,L'MSGTL           'INPUT TOO LONG'
         TCLEARQ INPUT                 PURGE EXTRA TERMINAL INPUT
         B     ASK                     AND GO GET ANOTHER MEMBER NAME.
         SPACE
ATTN     DS    0H                      USER HIT THE PA1/ATTN KEY
         TEPUT ATTNMSG,L'ATTNMSG       'ATTENTION INTERRUPT'
         TCLEARQ INPUT                 PURGE EXTRA TERMINAL INPUT
         B     ASK                     AND GO GET ANOTHER MEMBER NAME.
         SPACE
NOSYSLIB DS    0H                      PDS NOT ALLOCATED/OPENED
         TEPUT NOLIBS,NOLIBSL          'REQUESTED DDNAME NOT OPENED'
         B     RETURN                  END
         SPACE
TGETERR  TEPUT ERRORT,L'ERRORT         'TGET ERROR'
         SPACE
END      CLOSE SYSLIB                  FINISH UP
RETURN   LM    R14,R12,12(R13)
         XR    R15,R15                 RETURN CODE(0) - ALWAYS
         BR    R14
         TITLE 'XFINDM - DATA AREAS'
MOVEDD   MVC   SYSLIB+40(0),2(R4)      EXECUTED - MOVE DDNAME TO DCB
BLANKS   DC    CL8' '                  GENERAL PURPOSE BLANKS
MEMNAME  DS    CL8                     THE MEMBER NAME IS READ IN HERE
BLDLLIST DC    Y(1,LISTLEN)            BLDL LIST TO LOOK FOR 1 MEMBER
BLDLNAME DS    CL8                     BLDL MEMBER NAME
TTR      DS    XL3                     TTR OF MEMBER
K        DS    X                       CONCATENATION # (0=1ST LIBRARY)
*** REFERENCE FOR ABOVE FIELDS: DATA MANAGEMENT SERVICES GUIDE ***
LISTLEN  EQU   *-BLDLNAME              LENGTH OF BLDL LIST
         PRINT NOGEN
SYSLIB   DCB   DDNAME=SYSLIB,DSORG=PO,MACRF=R PDS DCB DEFAULT IS SYSLIB
         PRINT GEN
         SPACE
PROMPT   DC    C'ENTER MEMBER NAME OR A NULL LINE TO END'
DSNMSG   DC    C'         IS LOCATED IN '
DSNAME   DS    CL44
DSNMSGL  EQU   *-DSNMSG
NOTFOUND DC    C'         NOT FOUND'
ERROR8   DC    C'BLDL FAILED, PROBABLE I/O ERROR ON DIRECTORY'
MSGTL    DC    C'INPUT LONGER THAN 8 CHARACTERS'
ATTNMSG  DC    C'ATTENTION INTERRUPT, INPUT IGNORED'
ERRORT   DC    C'TGET ERROR, PROCESSING TERMINATED'
NOLIBS   DC    C'UNABLE TO OPEN '
DD1      DC    CL8' '
         DC    C' - PROCESSING TERMINATED'
NOLIBSL  EQU   *-NOLIBS
DEFAULT  DC    C'NO DDNAME PARM SPECIFIED, USING DEFAULT OF SYSLIB'
BADDD    DC    C'INVALID DDNAME PARM SPECIFIED, PROCESSING TERMINATED'
BADDSORG DC    C'INVALID DSORG (NOT PARTITIONED) ON DD         '
DD2      EQU   *-8,8,C'C'
         END
./ ADD NAME=XGET     0100-07332-07332-0900-00014-00014-00000-SEB
XGET     CSECT
*
* DCL XGET ENTRY(CHAR(*), FIXED(15) BIN) EXTERNAL OPTIONS(ASM INTER);
*
         SAVE  (14,12),,XGET_&SYSDATE._&SYSTIME
         LR    12,15
         USING XGET,12
         LM    1,2,0(1)            GET ADDRESS OF VAR & ADDR OF LENGTH
         LH    0,0(,2)             GET LENGTH OF VARIABLE
         TGET  (1),(0)
         L     14,12(,13)          RETURN WITH RC FROM TGET
         LM    0,12,20(13)
         BR    14
         END
./ ADD NAME=XIPMAP   0100-07332-07332-0900-00667-00667-00000-SEB
         TITLE 'XIPMAP - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         EJECT
         MACRO
&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE
         AIF   ('&REG' EQ '*').NOSTORE
&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED
         AGO   .AFT
.NOSTORE ANOP
&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED
.AFT     ANOP
         UNPK  &PLACE.(9),&STG.(5)
         TR    &PLACE.(8),HEXTBL
         MVI   &PLACE.+8,C&FILL
         MEND
         TITLE 'XIPMAP - IPCS VERB EXIT TO MAP TCB TREE CONTROL BLOCKS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    TCB POINTER
R4       EQU   4    ABDPL ADDRESS
R5       EQU   5    LLS POINTER
R6       EQU   6    RB POINTER
R7       EQU   7    CDE POINTER
R8       EQU   8    DEB POINTER
R9       EQU   9    DCB POINTER
R10      EQU   10   JPQ POINTER
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XIPMAP   CSECT
         SAVE  (14,12),,XIPMAP-&SYSDATE-&SYSTIME
         LR    R12,R15
         USING XIPMAP,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO
         USING LINEDSCT,R11            OUTPUT BUFFER
         XC    WHRADDR,WHRADDR
         XC    FIRSTTCB,FIRSTTCB
         EJECT
*
* Instead of using the low-core pointer to get to the TCB,
* use the ASID to locate the ASCB (via the ASVT) and get the
* first TCB from there.  In that way, setting the ASID via
* SETDEF will affect which address space gets mapped.
*
*        LA    R3,X'21C'           ADDRESS OF CVTTCBP
*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY218),TRY218
*        BAL   R14,OUTPUT
*        LA    R3,X'218'
*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY224),TRY224
*        BAL   R14,OUTPUT
*
* Try to get ASCB.  Instead of relying on the low-core pointer,
* use the ASID to locate it via the ASVT.  In that way, setting
* the ASID with SETDEF will cause this exit to pick up the right one.
*
*----------------------------------------------------------------------
*        LA    R3,X'224'            TRY VIA ASCB
*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB
*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP
*----------------------------------------------------------------------
         L     R3,ADPLCVT          Get CVT pointer
         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT
         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump
         L     R3,0(,R3)           Load address of CVT's ASVT pointer
         LH    R2,ADPLASID         Get the current ASID
         SLA   R2,2                Multiply by 4 making index into ASVT
         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID
         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump
         L     R3,0(,R3)           Load the ASCB address
         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump
         L     R3,X'6C'(,R3)       GET POINTER TO ASXB
         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP
         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB
         ST    R3,FIRSTTCB         Save it for module findings
FINDTOP  DS    0H                  SCAN FOR TOP TCB
         LR    R2,R3               SAVE ACTUAL TCB ADDRESS
         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP
         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB
         BZ    USETCB              IF NONE, THIS IS THE TOP TCB
         LR    R3,R15              IF THERE IS A MOTHER,
         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT
USETCB   DS    0H                  START WITH THIS TCB
         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN
         SPACE 1
*******                            (WE DON'T DO THIS ANY MORE)
*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB
*******
*
         BAL   R14,OUTPUT          Print a blank line
         MVC   LINE(L'HIMSG),HIMSG
         LH    R2,ADPLASID
         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID
         BAL   R14,OUTPUT          PRINT "HI THERE" MESSAGE
         BAL   R14,OUTPUT          Print a blank line
*
DOIT     DS    0H
         BAL   R14,PROCESS
         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB
         BNZ   DOIT
NODTR    DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'80' SISTER TCB
         BNZ   DOIT
NOSISTER DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'84' MOTHER TCB
         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE
         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP
         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE
         B     NODTR               PROCESS ITS SISTER, ETC.
NOMORE   DS    0H
         B     RETURN0
         EJECT
PROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED
         SPACE
         ST    R14,PRCSSAVE        SAVE RETURN REGISTER
         BAL   R14,OUTPUT          PRINT A BLANK LINE
         MVC   LINE(L'TCBMSG),TCBMSG
         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING TCB"
         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP
         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE
         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE
         BZ    NOTCBCMP            IF THERE IS ONE, THEN...
         MVC   LINE(L'CMPMSG),CMPMSG
         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT
         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG
         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA
         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT
         BAL   R14,OUTPUT          PRINT COMPLETION CODE
NOTCBCMP DS    0H
         L     R6,COPYTCB+0        ADDRESS OF RB
         MVC   LINE(L'RBMSG),RBMSG
         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING RB"
RBLOOP   DS    0H
         LR    R2,R6               SAVE TRUE RB ADDRESS
         SH    R6,=H'32'           POINT TO RB PREFIX
         BM    BADRB               IF MAKES IT GO NEGATIVE, BAD ADDR
         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP
         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT
         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS
         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE
         BZ    PRB
         BO    SVRB
         LA    R1,=CL8'(IRB)'
         B     RBTYPE
SVRB     LA    R1,=CL8'(SVRB)'
RBTYPE   DS    0H
         MVC   LINE+10(8),0(R1)    MOVE RB TYPE
         B     RBOUT
PRB      DS    0H
         XR    R7,R7
         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE
         BNZ   GOTACDE             IF ZERO, THEN...
         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO
         BZ    NOCDE                 THEN
         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO
         B     RBOUT                 ELSE
NOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE
         B     RBOUT
GOTACDE  DS    0H
         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE
         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP
         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME
RBOUT    DS    0H
         MVC   LINE+21(4),=C'INT='
         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE
         TR    LINE+25(2),HEXTBL
         MVI   LINE+27,C' '
         MVC   LINE+29(4),=C'PSW='
         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW
         TR    LINE+33(8),HEXTBL
         MVI   LINE+41,C' '
         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW
         TR    LINE+42(8),HEXTBL
         MVI   LINE+50,C' '
         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW
         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS
         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB
RBNEXT   DS    0H
         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB
         BO    ENDRB               THEN NO MORE RB'S. ELSE
         XR    R6,R6
         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB
         B     RBLOOP
BADRB    DS    0H                  RB STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'RBERRMSG),RBERRMSG
         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB
         BAL   R14,OUTPUT
ENDRB    DS    0H
         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE
         BZ    ENDCDE
         MVC   LINE(L'JPQMSG),JPQMSG
         BAL   R14,OUTPUT          PRINT "MAPPING JOB PACK QUEUE"
CDELOOP  DS    0H
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
         ICM   R10,15,0(R10)
         BNZ   CDELOOP
ENDCDE   DS    0H
TCB2LOOP DS    0H
         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS
         BZ    ENDLLS
         MVC   LINE(L'LLSMSG),LLSMSG
         BAL   R14,OUTPUT          PRINT "MAPPING LOAD LIST"
LLSLOOP  DS    0H
         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP
         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS
         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
NEXTLLS  DS    0H
         LTR   R5,R2               GET ADDRESS OF NEXT LLS
         BZ    ENDLLS
         B     LLSLOOP
BADLLS   DS    0H                  ERROR ACCESSING LLS
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'LLSERMSG),LLSERMSG
         GDUMP R5,LINE+L'LLSERMSG
         BAL   R14,OUTPUT
         SPACE 1
ENDLLS   DS    0H
         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB
         BNZ   GOTDEBS
         MVC   LINE(L'NODEBS),NODEBS
         BAL   R14,OUTPUT          PRINT "NO OPEN DATA SETS"
         B     ENDDEB
GOTDEBS  DS    0H
         MVC   LINE(L'DEBMSG),DEBMSG
         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB
         BAL   R14,OUTPUT          PRINT "MAPPING DEB CHAIN"
DEBLOOP  DS    0H
         MVC   LINE(4),=C'DEB='
         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB
         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP
         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT
         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB
         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE
         MVC   LINE+14(4),=C'DCB='
         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB
         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP
         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT
         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB
         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP
         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT
         MVI   LINE+36,C' '
         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT
         LA    R9,X'10'(,R9)       ADDRESS OF JFCB
         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP
         MVC   LINE+37(44),0(R9)   DSNAME
         LA    R1,LINE+37+44-1
DSNLOOP  CLI   0(R1),C' '
         BNE   DSNEND
         BCTR  R1,0
         B     DSNLOOP
DSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME
         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB
         BE    NOMEMBER            THEN
         MVI   1(R1),C'('
         MVC   2(8,R1),44(R9)
         LA    R1,9(,R1)
MEMLOOP  CLI   0(R1),C' '
         BNE   MEMEND
         BCTR  R1,0
         B     MEMLOOP
MEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER
         LA    R1,1(,R1)
         MVI   0(R1),C')'
NOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK
         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,
         BZ    PRINTDEB            THEN...
         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW
         B     PRINTDEB
BADDCB   DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+14(L'DCBERMSG),DCBERMSG
         GDUMP R9,LINE+14+L'DCBERMSG
         B     PRINTDEB
BADTIOT  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+28(L'TIOERMSG),TIOERMSG
         GDUMP R2,LINE+28+L'TIOERMSG
         B     PRINTDEB
BADJFCB  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+37(L'JFERRMSG),JFERRMSG
         GDUMP R9,LINE+37+L'JFERRMSG
         B     PRINTDEB
PRINTDEB DS    0H
         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME
         B     NEXTDEB             GO TO NEXT DEB
BADOTHER DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
******** B     NEXTDEB
NEXTDEB  DS    0H
         XR    R8,R8
         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB
         BZ    ENDDEB
         B     DEBLOOP
BADDEB   DS    0H                  ERROR ACCESSING DEB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'DEBERMSG),DEBERMSG
         GDUMP R8,LINE+L'DEBERMSG
         BAL   R14,OUTPUT
ENDDEB   DS    0H
ENDPROC  DS    0H
         L     R14,PRCSSAVE        RETURN
         BR    R14
         EJECT
DUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE
*
* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,
* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.
*
         SPACE 1
         ST    R14,DCDESAVE        SAVE RETURN REGISTER
         ST    R10,DOUBLE          CDE ADDRESS
         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP
         USING CDENTRY,R10
         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE
         MVC   LNCDNAME(8),CDNAME   CDE NAME
         MVC   LNCDEPEQ(3),=C'EP='
         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE
         TM    CDATTR,CDREN
         BZ    NOTRENT
         MVC   LNCDRENT,=C'RENT'
NOTRENT  TM    CDATTR,CDSER
         BZ    NOTREUS
         MVC   LNCDREUS,=C'REUS'
NOTREUS  TM    CDATTR2,CDEANYM
         BZ    NOTANY
         MVC   LNCDANY,=C'ANY'
NOTANY   TM    CDATTR2,CDOLY
         BZ    NOTOVLY
         MVC   LNCDOVLY,=C'OVLY'
NOTOVLY  TM    CDATTR2,CDSYSLIB
         BZ    NOTSYSL
         MVC   LNCDSYSL,=C'SYSLIB'
NOTSYSL  TM    CDATTR2,CDAUTH
         BZ    NOTAUTH
         MVC   LNCDAUTH,=C'AUTH'
NOTAUTH  DS    0H
         B     OUTCDE
BADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CDERRMSG),CDERRMSG
         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS
OUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME
         L     R14,DCDESAVE        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         EJECT
BAD21C   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER21CMSG),ER21CMSG
         GDUMP R3,LINE+L'ER21CMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BAD218   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER218MSG),ER218MSG
         GDUMP R3,LINE+L'ER218MSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BAD224   DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER224MSG),ER224MSG
         GDUMP R3,LINE+L'ER224MSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADTCB   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'TCBERMSG),TCBERMSG
         GDUMP R3,LINE+L'TCBERMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADASCB  DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASCBEMSG),ASCBEMSG
         GDUMP R3,LINE+L'ASCBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADASXB  DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASXBEMSG),ASXBEMSG
         GDUMP R3,LINE+L'ASXBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADCVT   DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CVTEMSG),CVTEMSG
         GDUMP R3,LINE+L'CVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADCASVT DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CASVEMSG),CASVEMSG
         GDUMP R3,LINE+L'CASVEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
BADASVT  DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASVTEMSG),ASVTEMSG
         GDUMP R3,LINE+L'ASVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R14,FMSAVE
         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON
         BM    FMASIS              THEN
         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD
FMASIS   DS    0H
         ICM   R15,15,WHRADDR
         BNZ   FMGOTWHR
         ST    R0,FMWORK
         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF
         ST    R0,WHRADDR
         LR    R15,R0
         L     R0,FMWORK
FMGOTWHR DS    0H
         L     R14,FIRSTTCB        Get address of first TCB
         ST    R14,ADPLCOM1        Set first-TCB pointer for XIPSWHR
         LR    R1,R4               POINT TO ABDPL
         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME
         CLI   ADPLFMT1,C' '       IF NOT FOUND...
         BE    FMNF
         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...
         BE    FMERR
         MVC   LINE+52(16),ADPLCOM1
         B     FMRET
FMERR    DS    0H
         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '
         B     FMRET
FMNF     DS    0H
         MVC   LINE+52(16),=CL16'(UNKNOWN)       '
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15                 CALL IT
         LTR   R15,R15
         BNZ   RETURN0
         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         ICM   R15,R15,WHRADDR
         BZ    NODELETE
         DELETE EPLOC==CL8'XIPSWHR'
NODELETE DS    0H
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
HIMSG    DC    C'                 MAP FOR ASID '
TCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '
CMPMSG   DC    C'*** COMPCODE='
RTM2MSG  DC    C' RTWA AT '
RBMSG    DC    C'---MAPPING RBS - '
JPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'
LLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'
NODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'
DEBMSG   DC    C'---MAPPING DEBS - '
TRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'
TRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
ER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'
ER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'
ER224MSG DC    C'ERROR - ASCB UNAVAILABLE'
TCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '
ASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '
ASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '
RBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '
CDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '
LLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '
DEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '
DCBERMSG DC    C'DCB UNAVAILABLE AT '
TIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '
JFERRMSG DC    C'JFCB UNAVAILABLE AT '
CVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '
CASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '
ASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
PRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE
DCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE
FIRSTTCB DS    A                   Address of first TCB to search
         SPACE 1
COPYTCB  DS    CL256               COPY OF MOST OF TCB
COPYDEB  DS    CL32                COPY OF MOST OF DEB
RBPREFIX DS    CL32                COPY OF RB PREFIX
COPYRB   DS    CL64                COPY OF MOST OF RB
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER
LINE     DS    CL132               WORD AREA FOR OUTPUT LINES
         ORG   LINE
LNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK
         DS    CL2
LNCDNAME DS    CL8                 NAME
         DS    CL3
LNCDEPEQ DS    C'EP='              "EP="
LNCDEPA  DS    CL8                 ENTRY POINT
         DS    CL3                 FOLLOWED BY ATTRIBUTES
LNCDRENT DS    C'RENT'
         DS    CL1
LNCDREUS DS    C'REUS'
         DS    CL1
LNCDANY  DS    C'ANY'
         DS    CL1
LNCDOVLY DS    C'OVLY'
         DS    CL1
LNCDSYSL DS    C'SYSLIB'
         DS    CL1
LNCDAUTH DS    C'AUTH'
         DS    CL1
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         BLSABDPL
         SPACE 1
         IHACDE
         SPACE 1
         END
./ ADD NAME=XIPSWHR  0100-07332-07332-0900-00495-00495-00000-SEB
         TITLE 'XIPSWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XIPSWHR - VERB EXIT SUBROUTINE TO LOCATE AN ADDRESS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS SUBROUTINE IS INVOKED FROM IPCS VERB EXITS TO RETURN           *
* INFORMATION ABOUT AN ADDRESS.                                       *
*                                                                     *
* ON ENTRY REGISTER 1 POINTS TO THE ABDPL (EXIT PARAMETER LIST),      *
*      AND REGISTER 0 CONTAINS THE ADDRESS TO BE SEARCHED FOR.        *
*                                                                     *
* In addition, the following field must be filled in by the caller:   *
*                                                                     *
*    ADPLCOM1 - 4 bytes - the address of the first TCB to search,     *
*                         or zeroes if not known.                     *
*                                                                     *
* ON RETURN THE FOLLOWING FIELDS OF THE PARAMETER LIST ARE FILLED:    *
*                                                                     *
*    ADPLCOM1 - 8 BYTES - THE NAME OF THE MODULE IT WAS FOUND IN.     *
*                                                                     *
*    ADPLCOM3 - 8 BYTES - EBCDIC REPRESENTATION OF THE OFFSET,        *
*                         INCLUDING LEADING PLUS SIGN.                *
*                                                                     *
*    ADPLFMT1 - ONE OF THE FOLLOWING 4-CHARACTER VALUES:              *
*                                                                     *
*    "JPA "  -  THE ADDRESS IS IN A MODULE IN THE JOB PACK AREA.      *
*    "PLPA"  -  THE ADDRESS IS IN A PAGEABLE LINK PACK AREA MODULE.   *
*    "MLPA"  -  THE ADDRESS IS IN A MODULE IN THE MLPA.               *
*    "NUC "  -  THE ADDRESS IS IN THE NUCLEUS.                        *
*    "ERR "  -  A STORAGE ERROR OCCURRED TRYING TO LOCATE IT.         *
*    "    "  -  BLANK IF THE ADDRESS WAS NOT FOUND.                   *
*                                                                     *
*    ADPLFMT2 - THE BINARY VALUE OF THE OFFSET.                       *
*                                                                     *
* NOTE: THIS ROUTINE MUST BE INVOKED VIA LINK OR LOAD/BASSM,          *
*       SINCE IT RUNS IN AMODE 31.                                    *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    INPUT ADDRESS TO BE SEARCHED FOR
R6       EQU   6    POINTER TO TCB
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   .
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XIPSWHR  CSECT
XIPSWHR  AMODE 31
XIPSWHR  RMODE 24
         SAVE  (14,12),,XIPSWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XIPSWHR,R12
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LR    R5,R0               SAVE INPUT ADDRESS PARAMETER
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         EJECT
         N     R5,=X'7FFFFFFF'     CLEAR HIGH ORDER BIT OF ADDRESS
         MVC   ADPLFMT1(4),=C'    '
         EJECT
*
* If a TCB address has been provided by the caller, it will be in
* the ADPLCOM1 field and nonzero.  In this case, use that as the
* first TCB to search, since that should have been chosen to work
* with the current ASID.
*
         ICM   R6,15,ADPLCOM1      Get communication word TCB address
         BNZ   GOT1TCB             If provided, skip TCB search
         EJECT
*
* We don't do this anymore.  Must go by current ASID.
*
* FIRST SEARCH THE JOB PACK AREA.
*        SPACE 1
*        LA    R6,X'21C'           ADDRESS OF CVTTCBP
*        GSTOR R6,4                GET PSATOLD FROM DUMP
*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB
*        LTR   R6,R6               IF POINTER AT 21C IS ZEROES,
*        BNZ   GOT1TCB             THEN...
*        LA    R6,X'218'
*        GSTOR R6,4                GET PSATNEW FROM DUMP
*        L     R6,0(,R6)           ADDRESS OF CURRENT TCB
*        LTR   R6,R6               IF POINTER AT 218 IS ZEROES,
*        BNZ   GOT1TCB             THEN...
*        LA    R6,X'224'            TRY VIA ASCB
*        GSTOR R6,4                GET PSA'S ASCB PTR FROM DUMP
*        L     R6,0(,R6)           ADDRESS OF CURRENT ASCB
*        GSTOR R6,X'70'            GET CURRENT ASCB FROM DUMP
*        L     R6,X'6C'(,R6)       GET POINTER TO ASXB
*        GSTOR R6,8                GET ASXB FROM DUMP
*        L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB
*
         L     R6,ADPLCVT          Get CVT pointer
         LA    R6,X'22C'(,R6)      CVT+22C -> ASVT
         GSTOR R6,4                Get loc of CVT's ASVT ptr from dump
         L     R6,0(,R6)           Load address of CVT's ASVT pointer
         LH    R2,ADPLASID         Get the current ASID
         SLA   R2,2                Multiply by 4 making index into ASVT
         LA    R6,X'20C'(R2,R6)    Point to ASCB address for this ASID
         GSTOR R6,4                Get ASCB address from dump
         L     R6,0(,R6)           Load the ASCB address
         GSTOR R6,X'70'            Get the ASCB from dump
         L     R6,X'6C'(,R6)       GET POINTER TO ASXB
         GSTOR R6,8                GET ASXB FROM DUMP
         L     R6,4(,R6)           GET 1ST TCB ADDRESS FROM ASXB
*
GOT1TCB  DS    0H                  SCAN FOR TOP TCB
         SPACE 1
         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP
         USING TCB,R6
*
* WE DON'T GO DIRECTLY TO THE JOB STEP TCB ANY MORE, SINCE UNDER
* PIE/SESSIONS THERE MAY BE MORE THAN ONE.  INSTEAD, WE GO TO THE
* TOP OF THE TCB TREE EVERY TIME, AND THEN DESCEND LEVELS UNTIL
* WE FIND THE LEVEL WITH THE JOB STEP TCB'S.  ALL THE SISTERS IN
* THAT LEVEL ARE THEN PROCESSED.
*
****     LA    R6,TCBJSTCB         POINTER TO JOB STEP TCB
****     GSTOR R6,4                GET TCBJSTCB FROM DUMP
****     L     R6,0(,R6)           ADDRESS OF JOB STEP TCB
****     GSTOR R6,X'A0'            GET MOST OF JSTCB FROM DUMP
****     L     R7,TCBJPQ           ADDRESS OF FIRST CDE IN JOB PACK Q
****     LTR   R7,R7               IF NO CDE'S IN JOB PACK QUEUE
****     BNZ   LOOPCDE             THEN...
*
* IF JSTCB HAS NO JOB PACK QUEUE, THIS MAY BE A DUMP OF JES2 OR
* SOMETHING WHERE THE JSTCB IS NOT THE TCB WITH THE JPQ.  WE MUST
* THEN SEARCH FOR THE TCB WITH THE GOODS.
*
FINDTOP  DS    0H
         L     R7,TCBOTC           GET ADDRESS OF MOTHER TCB
         LTR   R7,R7               IF ZERO, THEN...
         BZ    TRYJPQ               THIS IS THE TOP TCB
         LR    R6,R7               ELSE GET ADDRESS OF THIS TCB
         GSTOR R6,X'A0'            GET MOST OF THIS TCB FROM DUMP
         B     FINDTOP             CONTINUE SEARCHING FOR TOP TCB
TRYJPQ   DS    0H                  R6 --> TOP TCB FROM DUMP
         MVC   COPYTCB(X'A0'),0(R6)
         LA    R6,COPYTCB
         L     R7,TCBJPQ           OK, TRY THE JOB PACK QUEUE HERE
         LTR   R7,R7               IF WE GOT ONE,
         BNZ   LOOPCDE             THEN GO TO SCAN IT.
         L     R7,TCBLTC           ELSE GET NEXT DAUGHTER TASK
         LTR   R7,R7               IF NONE,
         BZ    ENDCDE              THEN GIVE UP, NO JOB PACK FOUND
         LR    R6,R7               ELSE...
         GSTOR R6,X'A0'            GET IT FROM THE DUMP
         B     TRYJPQ              AND TRY IT AGAIN.
LOOPCDE  DS    0H                  LOOP THROUGH CDE'S
         LTR   R7,R7               UNTIL NO MORE
         BZ    ENDCDE
         GSTOR R7,32               GET CDE FROM DUMP
         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA
         LA    R7,COPYCDE
         USING CDENTRY,R7
         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,
         BO    CONTCDE             THEN SKIP IT
         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST
         LTR   R3,R3               IF NONE
         BZ    CONTCDE             THEN SKIP THIS CDE, GO TO NEXT ONE
         GSTOR R3,16               GET XTLST FROM DUMP
         USING XTLST,R3
         L     R0,XTLMSBAA         GET LOAD POINT
         N     R0,=X'7FFFFFFF'
         XR    R1,R1
         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH
         ALR   R1,R0               CONVERT IT TO LOAD END POINT
         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT
         BH    CONTCDE             THEN THIS IS NOT THE ONE
         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END
         BNH   CONTCDE             THEN THIS IS NOT THE ONE
         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT
         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE
         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'JPA ' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD
         B     FORMAT              GO TO FORMAT OFFSET AND RETURN
CONTCDE  DS    0H
         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN
         B     LOOPCDE             CONTINUE LOOPING
ENDCDE   DS    0H                  SCANNED ALL OF JPQ - NOT FOUND YET
         SPACE 1
JSSISTER DS    0H
         L     R7,TCBNTC           GET SISTER TASK
         LTR   R7,R7               IF NONE,
         BZ    NOSISTER            THEN THROUGH WITH SISTER TASKS
         LR    R6,R7               ELSE...
         GSTOR R6,X'A0'            GET IT FROM THE DUMP
         MVC   COPYTCB(X'A0'),0(R6)
         LA    R6,COPYTCB
         L     R7,TCBJPQ           TRY THE JOB PACK QUEUE HERE
         LTR   R7,R7               IF WE GOT ONE,
         BNZ   LOOPCDE             THEN GO TO SCAN IT
         B     JSSISTER            ELSE TRY NEXT SISTER
NOSISTER DS    0H
         L     R7,TCBLTC           GET NEXT DAUGHTER TASK
         LTR   R7,R7               IF NONE,
         BZ    ENDJSTS             THEN GIVE UP, NO JOB PACK FOUND
         LR    R6,R7               ELSE...
         GSTOR R6,X'A0'            GET IT FROM THE DUMP
         B     TRYJPQ              AND TRY IT AGAIN.
ENDJSTS  DS    0H                  NO MORE JOB STEP TCB'S
         EJECT
* THEN SEARCH THE LINK PACK AREA.
         SPACE 1
         L     R3,ADPLCVT          ADDRESS OF CVT
         USING CVT,R3
         LA    R3,CVTLPDIR         POINTER TO LPA DIRECTORY
         GSTOR R3,3                GET CVTLPDIR FROM DUMP
         XR    R7,R7
         ICM   R7,7,0(R3)          ADDRESS OF LPA DIRECTORY
         USING LPDE,R7
LOOPLPDE DS    0H                  LOOP THROUGH LPDE'S
         LA    R2,LPDEXTAD+4       GET TRUE ADDR OF NEXT LPDE IN CHAIN
         GSTOR R7,40               GET LPA DIRECTORY FROM DMP
         ICM   R0,15,LPDENTP       UNTIL NO MORE
         BZ    ENDLPDE
         TM    LPDEATTR,LPDEMIN    IF THIS IS A MINOR LPDE,
         BO    CONTLPDE            THEN SKIP IT
         L     R0,LPDEXTAD         GET LOAD POINT
         N     R0,=X'7FFFFFFF'
         ICM   R1,15,LPDEXTLN      GET MODULE LENGTH
         ALR   R1,R0               CONVERT IT TO LOAD END POINT
         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT
         BH    CONTLPDE            THEN THIS IS NOT THE ONE
         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END
         BNH   CONTLPDE            THEN THIS IS NOT THE ONE
         LR    R1,R5               ELSE ADDRESS MINUS LOAD POINT
         SR    R1,R0                GIVES OFFSET WITHIN PLPA MODULE
         ST    R1,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'PLPA' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),LPDENAME PUT MODULE NAME IN RETURN FIELD
         B     FORMAT
CONTLPDE DS    0H
         LR    R7,R2               GET (SAVED) ADDRESS OF NEXT LPDE
         B     LOOPLPDE            CONTINUE LOOPING
ENDLPDE  DS    0H                  SCANNED ALL PLPA - NOT FOUND YET
         EJECT
* THEN SEARCH THE MLPA.
         SPACE 1
         L     R3,ADPLCVT          ADDRESS OF CVT
         USING CVT,R3
         LA    R3,CVTQLPAQ         POINTER TO MLPA CDE'S
         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP
         L     R3,0(,R3)           ADDRESS OF POINTER TO 1ST LPA Q CDE
         GSTOR R3,4                GET ADDR OF 1ST LPAQ CDE FROM DUMP
         L     R7,0(,R3)           ADDRESS OF FIRST CDE IN LPA Q
LOOPMLPA DS    0H                  LOOP THROUGH CDE'S
         LTR   R7,R7               UNTIL NO MORE
         BZ    ENDMLPA
         GSTOR R7,32               GET CDE FROM DUMP
         MVC   COPYCDE(32),0(R7)   COPY INTO OUR WORK AREA
         LA    R7,COPYCDE
         USING CDENTRY,R7
         TM    CDATTR,CDMIN        IF THIS IS A MINOR CDE,
         BO    CONTMLPA            THEN SKIP IT
         L     R3,CDXLMJP          ELSE GET ADDRESS OF EXTENT LIST
         GSTOR R3,16               GET XTLST FROM DUMP
         USING XTLST,R3
         L     R0,XTLMSBAA         GET LOAD POINT
         N     R0,=X'7FFFFFFF'
         XR    R1,R1
         ICM   R1,7,XTLMSBLN       GET MODULE LENGTH
         ALR   R1,R0               CONVERT IT TO LOAD END POINT
         CR    R0,R5               IF ADDRESS LESS THAN LOAD POINT
         BH    CONTMLPA            THEN THIS IS NOT THE ONE
         CR    R1,R5               IF ADDRESS NOT LESS THAN LOAD END
         BNH   CONTMLPA            THEN THIS IS NOT THE ONE
         LR    R2,R5               ELSE ADDRESS MINUS LOAD POINT
         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE
         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'MLPA' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),CDNAME   PUT MODULE NAME IN RETURN FIELD
         B     FORMAT
CONTMLPA DS    0H
         L     R7,CDCHAIN          GET ADDRESS OF NEXT CDE IN CHAIN
         B     LOOPMLPA            CONTINUE LOOPING
ENDMLPA  DS    0H                  SCANNED ALL MLPA - NOT FOUND YET
         EJECT
* THEN SEARCH THE NUCLEUS MAP.
         SPACE 1
         L     R3,ADPLCVT          ADDRESS OF CVT
         USING CVT,R3
         LA    R3,CVTNUCMP         POINTER TO NUCLEUS MAP
         GSTOR R3,4                GET ADDR OF NUCMAP FROM DUMP
         L     R3,0(,R3)           ADDRESS OF NUCMAP
         LR    R2,R5               SET ADDRESS FOR COMPARISONS
         LR    R7,R3               SAVE DUMP ADDRESS
         GSTOR R3,16               GET NUCMAP HEADER FROM DUMP
         L     R9,X'08'(,R3)       GET ADDRESS OF LAST NUCMAP ENTRY
         LA    R8,16               SET NUCMAP ENTRY INCREMENT
LOOPNUC  DS    0H                  LOOP THROUGH CDE'S
         BXH   R7,R8,ENDNUC        BUMP TO NEXT NUCMAP ENTRY UNTIL LAST
         LR    R3,R7               GET ADDRESS OF NUCMAP ENTRY
         GSTOR R3,16               GET NUCMAP ENTRY FROM DUMP
         TM    X'0C'(R3),X'10'     IF THIS IS NOT A CSECT ENTRY
         BNO   LOOPNUC             THEN CONTINUE
         L     R0,X'08'(,R3)       GET LOCATION OF NUCLEUS CSECT
         CR    R2,R0               IF ADDRESS LESS THAN NUC CSECT LOC
         BL    LOOPNUC             THEN THIS IS NOT THE ONE
         XR    R1,R1
         ICM   R1,7,X'0D'(R3)      GET LENGTH
         ALR   R1,R0               ADD LOC GIVING END POINT
         CR    R2,R1               IF ADDRESS NOT LESS THAN END POINT
         BNL   LOOPNUC             THEN THIS IS NOT THE ONE
*                                  ELSE ADDRESS MINUS LOAD POINT
         SR    R2,R0                GIVES OFFSET WITHIN JPA MODULE
         ST    R2,ADPLFMT2         PUT OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'NUC ' TELL WHERE IT WAS FOUND
         MVC   ADPLCOM1(8),0(R3)    PUT MODULE NAME IN RETURN FIELD
         B     FORMAT
ENDNUC   DS    0H
         SPACE 1
* IF ALL FAILS, NOT FOUND.
         SPACE 1
         B     NOTFOUND
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         SPACE 1
         MVC   ERRBUG(L'BUGMSG),BUGMSG
         STCM  R0,15,OFFWORK
         UNPK  ERRWORK(9),OFFWORK(5)
         TR    ERRWORK(8),HEXTBL
         MVI   ERRWORK+8,C' '
         LA    R1,ERRBUG
         LA    R0,L'ERRBUG
         TPUT  (1),(0),R
         SPACE 1
         XR    R2,R2
         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'ERR ' TELL WHY IT WAS NOT FOUND
         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD
         MVC   ADPLCOM1+1(7),ADPLCOM1
         B     FORMAT
         EJECT
NOTFOUND DS    0H
         SPACE 1
         XR    R2,R2
         ST    R2,ADPLFMT2         PUT NO OFFSET IN RETURN FIELD
         MVC   ADPLFMT1(4),=C'    ' TELL WHERE IT WAS NOT FOUND
         MVI   ADPLCOM1,C' '        PUT BLANKS IN RETURN FIELD
         MVC   ADPLCOM1+1(7),ADPLCOM1
         B     FORMAT
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BASSM R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
FORMAT   DS    0H                  FORMAT OFFSET AND RETURN
         MVI   ADPLCOM3,C'+'       BEGIN FORMATTING OFFSET FIELD
         MVI   ADPLCOM3+1,C' '     CLEAR OFFSET RETURN FIELD TO BLANKS
         MVC   ADPLCOM3+2(6),ADPLCOM3+1
         UNPK  OFFWORK(7),ADPLFMT2+1(4) FORMAT OFFSET FIELD IN WORKAREA
         TR    OFFWORK(6),HEXTBL
         LA    R0,5                SKIP OVER LEADING ZEROES
         LA    R1,OFFWORK
OFFLOOP  DS    0H
         CLI   0(R1),C'0'
         BNE   OFFEND
         LA    R1,1(,R1)
         BCT   R0,OFFLOOP
OFFEND   DS    0H
         LA    R15,OFFWORK+5
         SR    R15,R1
         EX    R15,OFFMOVE
         B     RETURN
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BSM   0,R14               RETURN IN CALLER'S ADDRESSING MODE
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
OFFMOVE  MVC   ADPLCOM3+1(*-*),0(R1) MOVE FORMATTED OFFSET TO FIELD
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
BUGMSG   DC    C'XIPSWHR: STORAGE NOT AVAILABLE AT ADDRESS '
ERRMSG   DC    C'XIPSWHR: ERROR ACCESSING STORAGE IN MODULE SEARCH.'
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
COPYCDE  DS    CL32                WORK AREA FOR CDE'S
COPYTCB  DS    CL(X'A0')           WORK AREA FOR TCB'S
OFFWORK  DS    CL8                 WORK AREA TO BUILD OFFSET
ERRBUG   DS    CL(L'BUGMSG+9)
ERRWORK  EQU   *-9,9,C'C'
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL132               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XIPWHR   0100-07332-07332-0900-00322-00322-00000-SEB
         TITLE 'XIPWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XIPWHR - IPCS VERB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XIPWHR   CSECT
         SAVE  (14,12),,XIPWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XIPWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* EXTRACT THE PARAMETER (MUST BE AN ADDRESS).
         SPACE 1
         L     R5,ADPLOPTR         GET ADDRESS OF OPERAND FIELD
         LTR   R5,R5               IF ZERO,
         BZ    MISSING              THEN MISSING
         LH    R6,ADPLOPLN         GET LENGTH OF OPERAND FIELD
         LTR   R6,R6               IF ZERO,
         BNP   MISSING              THEN MISSING
         LA    R1,0(R5,R6)         POINT TO END OF OPERAND FIELD
         BCTR  R1,0                POINT TO LAST CHARACTER OF OPERAND
         CLI   0(R1),C'.'          IF A PERIOD
         BNE   NOTPD               THEN
         BCTR  R6,0                 REDUCE LENGTH BY 1
NOTPD    LTR   R6,R6               IF REMAINING LENGTH IS ZERO
         BNP   INVALID             THEN BAD ADDRESS
         CH    R6,=H'8'            IF MORE THAN 8 CHARACTERS,
         BH    TOOLONG              THEN TOO LONG
         BCTR  R6,0                ELSE REDUCE FOR EXECUTES
         EX    R6,TRTOP            SCAN FOR VALID HEX CHARACTERS
         BNZ   INVALID             IF BAD CHARACTERS, INVALID
         EX    R6,MVCOP            ELSE MOVE OPERAND TO SAFE AREA
         EX    R6,TROP             TRANSLATE ABCDEF TO FAFBFCFDFEFF
         LA    R6,1(,R6)           ADD 1 FOR PACKING EXTRA BYTE
         EX    R6,PACKOP           CREATE FULLWORD HEX ADDRESS FIELD
*                                  THIS SETS FIELD "ADDRESS"
         EJECT
         XR    R0,R0
         ST    R0,ADPLCOM1         Clear XIPSWHR communication word
         L     R0,ADDRESS          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         UNPK  LINE+00(9),ADDRESS(5)
         TR    LINE+00(8),HEXTBL
         MVI   LINE+08,C'.'
         CLC   ADPLFMT1(4),=C'    '
         BE    NOTFOUND
         CLC   ADPLFMT1(4),=C'JPA '
         BE    INJPA
         CLC   ADPLFMT1(4),=C'PLPA'
         BE    INPLPA
         CLC   ADPLFMT1(4),=C'MLPA'
         BE    INMLPA
         CLC   ADPLFMT1(4),=C'NUC '
         BE    INNUC
         CLC   ADPLFMT1(4),=C'ERR '
         BE    INERROR
         B     INLIMBO
         EJECT
NOTFOUND DS    0H
         SPACE 1
         MVC   LINE+09(L'NFMSG),NFMSG
         B     ERROUT
         EJECT
INERROR  DS    0H
         SPACE 1
         MVC   LINE+09(L'ERMSG),ERMSG
         B     ERROUT
         SPACE 1
INVALID  MVC   LINE(L'INVMSG),INVMSG
         B     ERROUT
         SPACE 1
TOOLONG  MVC   LINE(L'TLMSG),TLMSG
         B     ERROUT
         SPACE 1
MISSING  MVC   LINE(L'MISSMSG),MISSMSG
         B     ERROUT
         SPACE 1
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERMSG),ERMSG
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
INJPA    DS    0H
         SPACE 1
         MVC   LINE+09(L'JPAMSG),JPAMSG
         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'JPAMSG+08,C' '
         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'JPAMSG+10,C' '
         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INPLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'PLPAMSG),PLPAMSG
         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'PLPAMSG+08,C' '
         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'PLPAMSG+10,C' '
         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INMLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'MLPAMSG),MLPAMSG
         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'MLPAMSG+08,C' '
         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'MLPAMSG+10,C' '
         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INNUC    DS    0H
         SPACE 1
         MVC   LINE+09(L'NUCMSG),NUCMSG
         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'NUCMSG+08,C' '
         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'NUCMSG+10,C' '
         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INLIMBO  DS    0H
         SPACE 1
         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG
         MVC   LINE+09+LIMBOFF(4),ADPLFMT1
         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'LIMBOMSG+08,C' '
         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'LIMBOMSG+10,C' '
         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
TRTOP    TRT   0(*-*,R5),VALTBL    SCAN FOR VALID HEX CHARACTERS
MVCOP    MVC   OPWORK(*-*),0(R5)   MOVE OPERAND TO SAFE AREA
TROP     TR    OPWORK(0),FTBL      TRANSLATE ABCDEF TO FAFBFCFDFEFF
PACKOP   PACK  ADDRESS(5),OPWORK(0) CREATE BINARY VALUE FROM OPERAND
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
MISSMSG  DC    C'ADDRESS OPERAND MISSING'
TLMSG    DC    C'ADDRESS OPERAND TOO LONG'
INVMSG   DC    C'ADDRESS OPERAND SYNTAX ERROR'
JPAMSG   DC    C'  FOUND IN JPA MODULE '
PLPAMSG  DC    C'  FOUND IN PLPA MODULE '
MLPAMSG  DC    C'  FOUND IN MLPA MODULE '
NUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '
NFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'
ERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'
LIMBOMS1 DC    C'  FOUND IN '
LIMBOMS2 DC    CL4'    '
LIMBOMS3 DC    C' MODULE '
LIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'
LIMBOFF  EQU   LIMBOMS2-LIMBOMS1
         SPACE
VALTBL   DC    256YL1(1)
         ORG   VALTBL+X'81'
         DC    6YL1(0)             LOWER CASE ABCDEF
         ORG   VALTBL+C'A'
         DC    6YL1(0)             UPPER CASE ABCDEF
         ORG   VALTBL+C'0'
         DC    10YL1(0)            0123456789
         ORG
         SPACE
FTBL     DC    256YL1(*-FTBL)
         ORG   FTBL+X'81'
         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF
         ORG   FTBL+C'A'
         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF
         ORG
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
ADDRESS  DS    A                   THE ADDRESS TO BE SEARCHED ON
         DS    XL1                 PADDING FOR CONVERSION
OPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XITMAP   0100-07332-07332-0900-00676-00676-00000-SEB
         TITLE 'XITMAP - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN-ABDPL(,R1)  STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA-ABDPL(,R1) GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         EJECT
         MACRO
&SYM     GDUMP &REG,&PLACE,&FILL=' ',&STG=DOUBLE
         AIF   ('&REG' EQ '*').NOSTORE
&SYM     ST    &REG,&STG               REGISTER CONTENTS TO BE DUMPED
         AGO   .AFT
.NOSTORE ANOP
&SYM     DS    0H                      CONTENTS OF STORAGE TO BE DUMPED
.AFT     ANOP
         UNPK  &PLACE.(9),&STG.(5)
         TR    &PLACE.(8),HEXTBL
         MVI   &PLACE.+8,C&FILL
         MEND
         TITLE 'XITMAP - IPCS TCB EXIT TO MAP RB CONTROL BLOCKS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    TCB POINTER
R4       EQU   4    ABDPL ADDRESS
R5       EQU   5    LLS POINTER
R6       EQU   6    RB POINTER
R7       EQU   7    CDE POINTER
R8       EQU   8    DEB POINTER
R9       EQU   9    DCB POINTER
R10      EQU   10   JPQ POINTER
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XITMAP   CSECT
         SAVE  (14,12),,XITMAP-&SYSDATE-&SYSTIME
         LR    R12,R15
         USING XITMAP,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF         ESTABLISH ADDRESSABILITY TO
         USING LINEDSCT,R11            OUTPUT BUFFER
         XC    WHRADDR,WHRADDR
         XC    FIRSTTCB,FIRSTTCB
         EJECT
         L     R3,ADPLTCB          GET TCB PASSED FOR TCB EXIT
         LTR   R3,R3               IF TCB ADDRESS IS ZERO
         BZ    SCANTREE            THEN SCAN TCB TREE FOR ALL TASKS,
         BAL   R14,PROCESS         ELSE JUST PROCESS THIS ONE
         B     RETURN0             AND RETURN.
         SPACE 1
SCANTREE DS    0H                  PROCESS ALL TCB'S...
*
*
* Instead of using the low-core pointer to get to the TCB,
* use the ASID to locate the ASCB (via the ASVT) and get the
* first TCB from there.  In that way, setting the ASID via
* SETDEF will affect which address space gets mapped.
*
*        LA    R3,X'21C'           ADDRESS OF CVTTCBP
*        GSTOR R3,4,ERRET=BAD21C   GET PSATOLD FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 21C IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY218),TRY218
*        BAL   R14,OUTPUT
*        LA    R3,X'218'
*        GSTOR R3,4,ERRET=BAD218   GET PSATNEW FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT TCB
*        LTR   R3,R3               IF POINTER AT 218 IS ZEROES,
*        BNZ   FINDTOP             THEN...
*        MVI   LINE,C' '
*        MVC   LINE+1(L'LINE-1),LINE
*        MVC   LINE(L'TRY224),TRY224
*        BAL   R14,OUTPUT
*
* Try to get ASCB.  Instead of relying on the low-core pointer,
* use the ASID to locate it via the ASVT.  In that way, setting
* the ASID with SETDEF will cause this exit to pick up the right one.
*
*----------------------------------------------------------------------
*        LA    R3,X'224'            TRY VIA ASCB
*        GSTOR R3,4,ERRET=BAD224   GET PSA'S ASCB PTR FROM DUMP
*        L     R3,0(,R3)           ADDRESS OF CURRENT ASCB
*        GSTOR R3,X'70',ERRET=BADASCB   GET CURRENT ASCB FROM DUMP
*----------------------------------------------------------------------
         L     R3,ADPLCVT          Get CVT pointer
         LA    R3,X'22C'(,R3)      CVT+22C -> ASVT
         GSTOR R3,4,ERRET=BADCVT   Get loc of CVT's ASVT ptr from dump
         L     R3,0(,R3)           Load address of CVT's ASVT pointer
         LH    R2,ADPLASID         Get the current ASID
         SLA   R2,2                Multiply by 4 making index into ASVT
         LA    R3,X'20C'(R2,R3)    Point to ASCB address for this ASID
         GSTOR R3,4,ERRET=BADASVT  Get ASCB address from dump
         L     R3,0(,R3)           Load the ASCB address
         GSTOR R3,X'70',ERRET=BADASCB   Get the ASCB from dump
         L     R3,X'6C'(,R3)       GET POINTER TO ASXB
         GSTOR R3,8,ERRET=BADASXB  GET ASXB FROM DUMP
         L     R3,4(,R3)           GET 1ST TCB ADDRESS FROM ASXB
         ST    R3,FIRSTTCB         Save for future module findings
FINDTOP  DS    0H                  SCAN FOR TOP TCB
         LR    R2,R3               SAVE ACTUAL TCB ADDRESS
         GSTOR R3,X'8C',ERRET=BADTCB GET CURRENT TCB FROM DUMP
         ICM   R15,15,X'84'(R3)    ADDRESS OF MOTHER TCB
         BZ    USETCB              IF NONE, THIS IS THE TOP TCB
         LR    R3,R15              IF THERE IS A MOTHER,
         B     FINDTOP             THEN GO FIND ITS MOTHER OR USE IT
USETCB   DS    0H                  START WITH THIS TCB
         LR    R3,R2               GET ACTUAL TCB ADDRESS AGAIN
         SPACE 1
*******                            (WE DON'T DO THIS ANY MORE)
*******  L     R3,X'7C'(,R3)       GET POINTER TO TCBJSTCB
*******
*
         BAL   R14,OUTPUT          Print a blank line
         MVC   LINE(L'HIMSG),HIMSG
         LH    R2,ADPLASID
         GDUMP R2,LINE+L'HIMSG     FORMAT AND PRINT ASID
         BAL   R14,OUTPUT          PRINT "HI THERE" MESSAGE
         BAL   R14,OUTPUT          Print a blank line
*
DOIT     DS    0H
         BAL   R14,PROCESS
         ICM   R3,15,COPYTCB+X'88' DAUGHTER TCB
         BNZ   DOIT
NODTR    DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'80' SISTER TCB
         BNZ   DOIT
NOSISTER DS    0H                  ELSE
         ICM   R3,15,COPYTCB+X'84' MOTHER TCB
         BZ    NOMORE              IF NONE, FINISHED WITH TCB TREE
         GSTOR R3,X'8C',ERRET=BADTCB ELSE GET MOTHER TCB FROM DUMP
         MVC   COPYTCB(X'8C'),0(R3) SAVE TCB STORAGE
         B     NODTR               PROCESS ITS SISTER, ETC.
NOMORE   DS    0H
         B     RETURN0
         EJECT
PROCESS  DS    0H                  R3 = ADDRESS OF TCB BEING PROCESSED
         SPACE
         ST    R14,PRCSSAVE        SAVE RETURN REGISTER
         BAL   R14,OUTPUT          PRINT A BLANK LINE
         MVC   LINE(L'TCBMSG),TCBMSG
         GDUMP R3,LINE+L'TCBMSG    FORMAT AND PRINT TCB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING TCB"
         GSTOR R3,256,ERRET=BADTCB GET TCB ITSELF FROM DUMP
         MVC   COPYTCB(256),0(R3)  SAVE TCB STORAGE FOR FUTURE USE
         ICM   R6,15,COPYTCB+X'10' PICK UP COMPLETION CODE
         BZ    NOTCBCMP            IF THERE IS ONE, THEN...
         MVC   LINE(L'CMPMSG),CMPMSG
         GDUMP R6,LINE+L'CMPMSG               FORMAT IT AND PRINT IT
         MVC   LINE+L'CMPMSG+9(L'RTM2MSG),RTM2MSG
         ICM   R6,15,COPYTCB+X'E0'            PICK UP ADDRESS OF RTM2WA
         GDUMP R6,LINE+L'CMPMSG+9+L'RTM2MSG   FORMAT IT AND PRINT IT
         BAL   R14,OUTPUT          PRINT COMPLETION CODE
NOTCBCMP DS    0H
         L     R6,COPYTCB+0        ADDRESS OF RB
         MVC   LINE(L'RBMSG),RBMSG
         GDUMP R6,LINE+L'RBMSG     FORMAT AND PRINT RB ADDRESS
         BAL   R14,OUTPUT          PRINT "PROCESSING RB"
RBLOOP   DS    0H
         LR    R2,R6               SAVE TRUE RB ADDRESS
         SH    R6,=H'32'           POINT TO RB PREFIX
         BM    BADRB               IF IT MAKES IT GO NEGATIVE, BAD ADDR
         GSTOR R6,96,ERRET=BADRB   GET RB FROM DUMP
         MVC   RBPREFIX(96),0(R6)  MAKE A COPY OF IT
         GDUMP R2,LINE+0           FORMAT AND PRINT RB ADDRESS
         TM    COPYRB+X'0A',X'C0'  CHECK RB TYPE
         BZ    PRB
         BO    SVRB
         LA    R1,=CL8'(IRB)'
         B     RBTYPE
SVRB     LA    R1,=CL8'(SVRB)'
RBTYPE   DS    0H
         MVC   LINE+10(8),0(R1)    MOVE RB TYPE
         B     RBOUT
PRB      DS    0H
         XR    R7,R7
         ICM   R7,7,COPYRB+X'0D'   ADDRESS OF RBCDE
         BNZ   GOTACDE             IF ZERO, THEN...
         TM    COPYRB+X'0C',X'04'   IF REQUESTED BY SYNCH MACRO
         BZ    NOCDE                 THEN
         MVC   LINE+10(8),=CL8'(SYNCH)'   SAY SO
         B     RBOUT                 ELSE
NOCDE    MVC   LINE+10(8),=CL8'(NO CDE)'  JUST SAY NO CDE
         B     RBOUT
GOTACDE  DS    0H
         MVC   LINE+10(8),=CL8'(*N/A*)' IN CASE CDE NOT AVAILABLE
         GSTOR R7,32,ERRET=RBOUT   GET CDE FROM DUMP
         MVC   LINE+10(8),CDNAME-CDENTRY(R7) CDE NAME
RBOUT    DS    0H
         MVC   LINE+21(4),=C'INT='
         UNPK  LINE+25(3),COPYRB-1(2) INTERRUPT CODE
         TR    LINE+25(2),HEXTBL
         MVI   LINE+27,C' '
         MVC   LINE+29(4),=C'PSW='
         UNPK  LINE+33(9),COPYRB+X'10'(5) LEFT HALF OF RBOPSW
         TR    LINE+33(8),HEXTBL
         MVI   LINE+41,C' '
         UNPK  LINE+42(9),COPYRB+X'14'(5) RIGHT HALF OF RBOPSW
         TR    LINE+42(8),HEXTBL
         MVI   LINE+50,C' '
         L     R0,COPYRB+X'14'     GET RIGHT HALF OF PSW
         BAL   R14,FINDMOD         LOCATE MODULE WHERE IT IS
         BAL   R14,OUTPUT          PRINT CDE NAME TO IDENTIFY RB
RBNEXT   DS    0H
         TM    COPYRB+X'0B',X'80'  IF NEXTRB POINTS TO TCB
         BO    ENDRB               THEN NO MORE RB'S. ELSE
         XR    R6,R6
         ICM   R6,7,COPYRB+X'1D'   ADDRESS OF NEXT RB
         B     RBLOOP
BADRB    DS    0H                  RB STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'RBERRMSG),RBERRMSG
         GDUMP R6,LINE+L'RBERRMSG  FORMAT AND PRINT ADDRESS OF RB
         BAL   R14,OUTPUT
ENDRB    DS    0H
         ICM   R10,15,COPYTCB+X'2C' ADDRESS OF JOB PACK QUEUE
         BZ    ENDCDE
         MVC   LINE(L'JPQMSG),JPQMSG
         BAL   R14,OUTPUT          PRINT "MAPPING JOB PACK QUEUE"
CDELOOP  DS    0H
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
         ICM   R10,15,0(R10)
         BNZ   CDELOOP
ENDCDE   DS    0H
TCB2LOOP DS    0H
         ICM   R5,15,COPYTCB+X'24' ADDRESS OF LOAD LIST ELEMENTS
         BZ    ENDLLS
         MVC   LINE(L'LLSMSG),LLSMSG
         BAL   R14,OUTPUT          PRINT "MAPPING LOAD LIST"
LLSLOOP  DS    0H
         GSTOR R5,16,ERRET=BADLLS  GET LLS FROM DUMP
         L     R2,0(,R5)           SAVE ADDRESS OF NEXT LLS
         L     R10,4(,R5)          CDE FOR LOAD LIST ENTRY
         BAL   R14,DUMPCDE         WRITE OUT CDE INFO
NEXTLLS  DS    0H
         LTR   R5,R2               GET ADDRESS OF NEXT LLS
         BZ    ENDLLS
         B     LLSLOOP
BADLLS   DS    0H                  ERROR ACCESSING LLS
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'LLSERMSG),LLSERMSG
         GDUMP R5,LINE+L'LLSERMSG
         BAL   R14,OUTPUT
         SPACE 1
ENDLLS   DS    0H
         ICM   R8,15,COPYTCB+X'08' ADDRESS OF DEB
         BNZ   GOTDEBS
         MVC   LINE(L'NODEBS),NODEBS
         BAL   R14,OUTPUT          PRINT "NO OPEN DATA SETS"
         B     ENDDEB
GOTDEBS  DS    0H
         MVC   LINE(L'DEBMSG),DEBMSG
         GDUMP R8,LINE+L'DEBMSG    FORMAT AND PRINT ADDRESS OF DEB
         BAL   R14,OUTPUT          PRINT "MAPPING DEB CHAIN"
DEBLOOP  DS    0H
         MVC   LINE(4),=C'DEB='
         GDUMP R8,LINE+4           FORMAT AND PRINT ADDRESS OF DEB
         GSTOR R8,32,ERRET=BADDEB  GET DEB FROM DUMP
         MVC   COPYDEB(32),0(R8)   MAKE A COPY OF IT
         L     R9,COPYDEB+X'18'    ADDRESS OF DCB FOR THIS DEB
         N     R9,=X'00FFFFFF'     CLEAR HIGH ORDER BYTE
         MVC   LINE+14(4),=C'DCB='
         GDUMP R9,LINE+18          FORMAT AND PRINT ADDRESS OF DCB
         GSTOR R9,X'30',ERRET=BADDCB GET DCB FROM DUMP
         L     R2,COPYTCB+X'0C'    ADDRESS OF TIOT
         AH    R2,X'28'(,R9)       ADD TIOT OFFSET FROM DCB
         GSTOR R2,20,ERRET=BADTIOT GET TIOT ENTRY FROM DUMP
         MVC   LINE+28(8),4(R2)    DDNAME FROM TIOT
         MVI   LINE+36,C' '
         ICM   R9,7,X'C'(R2)       POINTER TO JFCB FROM TIOT
         LA    R9,X'10'(,R9)       ADDRESS OF JFCB
         GSTOR R9,176,ERRET=BADJFCB GET JFCB FROM DUMP
         MVC   LINE+37(44),0(R9)   DSNAME
         LA    R1,LINE+37+44-1
DSNLOOP  CLI   0(R1),C' '
         BNE   DSNEND
         BCTR  R1,0
         B     DSNLOOP
DSNEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN DSNAME
         CLI   44(R9),C' '         IF THERE IS A MEMBER NAME IN JFCB
         BE    NOMEMBER            THEN
         MVI   1(R1),C'('
         MVC   2(8,R1),44(R9)
         LA    R1,9(,R1)
MEMLOOP  CLI   0(R1),C' '
         BNE   MEMEND
         BCTR  R1,0
         B     MEMLOOP
MEMEND   DS    0H                  R1 POINTS TO LAST NONBLANK IN MEMBER
         LA    R1,1(,R1)
         MVI   0(R1),C')'
NOMEMBER DS    0H                  R1 POINTS TO LAST NONBLANK
         TM    COPYDEB+X'08',X'01' IF CONCATENATED DATA SETS,
         BZ    PRINTDEB            THEN...
         MVC   2(7,R1),=C' ET AL.'  LET ME KNOW
         B     PRINTDEB
BADDCB   DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+14(L'DCBERMSG),DCBERMSG
         GDUMP R9,LINE+14+L'DCBERMSG
         B     PRINTDEB
BADTIOT  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+28(L'TIOERMSG),TIOERMSG
         GDUMP R2,LINE+28+L'TIOERMSG
         B     PRINTDEB
BADJFCB  DS    0H                  ERROR ACCESSING DCB
         MVC   LINE+37(L'JFERRMSG),JFERRMSG
         GDUMP R9,LINE+37+L'JFERRMSG
         B     PRINTDEB
PRINTDEB DS    0H
         BAL   R14,OUTPUT          PRINT DEB=ADDR DCB=ADDR DDNAME
         B     NEXTDEB             GO TO NEXT DEB
BADOTHER DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
******** B     NEXTDEB
NEXTDEB  DS    0H
         XR    R8,R8
         ICM   R8,7,COPYDEB+5      ADDRESS OF NEXT DEB
         BZ    ENDDEB
         B     DEBLOOP
BADDEB   DS    0H                  ERROR ACCESSING DEB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'DEBERMSG),DEBERMSG
         GDUMP R8,LINE+L'DEBERMSG
         BAL   R14,OUTPUT
ENDDEB   DS    0H
ENDPROC  DS    0H
         L     R14,PRCSSAVE        RETURN
         BR    R14
         EJECT
DUMPCDE  DS    0H                  THIS ROUTINE DUMPS A CDE
*
* THIS SUBROUTINE FORMATS AND WRITES OUT CDE INFORMATION,
* ON ENTRY R10 CONTAINS THE ADDRESS OF THE CDE.
*
         SPACE 1
         ST    R14,DCDESAVE        SAVE RETURN REGISTER
         ST    R10,DOUBLE          CDE ADDRESS
         GSTOR R10,32,ERRET=BADCDE GET CDE FROM DUMP
         USING CDENTRY,R10
         GDUMP *,LNCDADDR          FORMAT AND PRINT ADDRESS OF CDE
         MVC   LNCDNAME(8),CDNAME   CDE NAME
         MVC   LNCDEPEQ(3),=C'EP='
         GDUMP *,LNCDEPA,STG=CDENTPT ENTRY POINT FROM CDE
         TM    CDATTR,CDREN
         BZ    NOTRENT
         MVC   LNCDRENT,=C'RENT'
NOTRENT  TM    CDATTR,CDSER
         BZ    NOTREUS
         MVC   LNCDREUS,=C'REUS'
NOTREUS  TM    CDATTR2,CDEANYM
         BZ    NOTANY
         MVC   LNCDANY,=C'ANY'
NOTANY   TM    CDATTR2,CDOLY
         BZ    NOTOVLY
         MVC   LNCDOVLY,=C'OVLY'
NOTOVLY  TM    CDATTR2,CDSYSLIB
         BZ    NOTSYSL
         MVC   LNCDSYSL,=C'SYSLIB'
NOTSYSL  TM    CDATTR2,CDAUTH
         BZ    NOTAUTH
         MVC   LNCDAUTH,=C'AUTH'
NOTAUTH  DS    0H
         B     OUTCDE
BADCDE   DS    0H                  CDE STORAGE NOT AVAILABLE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CDERRMSG),CDERRMSG
         GDUMP R10,LINE+L'CDERRMSG FORMAT AND PRINT CDE ADDRESS
OUTCDE   BAL   R14,OUTPUT          PRINT CDE MODULE NAME
         L     R14,DCDESAVE        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         EJECT
BAD21C   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER21CMSG),ER21CMSG
         GDUMP R3,LINE+L'ER21CMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BAD218   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER218MSG),ER218MSG
         GDUMP R3,LINE+L'ER218MSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BAD224   DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ER224MSG),ER224MSG
         GDUMP R3,LINE+L'ER224MSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADTCB   DS    0H                  ERROR ACCESSING TCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'TCBERMSG),TCBERMSG
         GDUMP R3,LINE+L'TCBERMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADASCB  DS    0H                  ERROR ACCESSING ASCB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASCBEMSG),ASCBEMSG
         GDUMP R3,LINE+L'ASCBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADASXB  DS    0H                  ERROR ACCESSING ASXB
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASXBEMSG),ASXBEMSG
         GDUMP R3,LINE+L'ASXBEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADCVT   DS    0H
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CVTEMSG),CVTEMSG
         GDUMP R3,LINE+L'CVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADCASVT DS    0H
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'CASVEMSG),CASVEMSG
         GDUMP R3,LINE+L'CASVEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
BADASVT  DS    0H
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ASVTEMSG),ASVTEMSG
         GDUMP R3,LINE+L'ASVTEMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         MVC   LINE(L'ERRMSG),ERRMSG
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R14,FMSAVE
         LTR   R0,R0               IF AMODE 31 BIT IS NOT ON
         BM    FMASIS              THEN
         N     R0,=X'00FFFFFF'      CLEAR HIGH-ORDER BYTE FOR 24-BIT AD
FMASIS   DS    0H
         ICM   R15,15,WHRADDR
         BNZ   FMGOTWHR
         ST    R0,FMWORK
         LOAD  EPLOC==CL8'XIPSWHR',ERRET=FMNF
         ST    R0,WHRADDR
         LR    R15,R0
         L     R0,FMWORK
FMGOTWHR DS    0H
         L     R14,FIRSTTCB
         ST    R14,ADPLCOM1        Get first TCB address for XIPSWHR
         LR    R1,R4               POINT TO ABDPL
         BASSM R14,R15             CALL XIPSWHR TO GET MODULE NAME
         CLI   ADPLFMT1,C' '       IF NOT FOUND...
         BE    FMNF
         CLI   ADPLFMT1,C'E'       IF STORAGE ERROR...
         BE    FMERR
         MVC   LINE+52(16),ADPLCOM1
         B     FMRET
FMERR    DS    0H
         MVC   LINE+52(16),=CL16'(STORAGE ERROR) '
         B     FMRET
FMNF     DS    0H
         MVC   LINE+52(16),=CL16'(UNKNOWN)       '
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT-ABDPL(,R1) GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15                 CALL IT
         LTR   R15,R15
         BNZ   RETURN0
         L     R11,ADPLBUF-ABDPL(,R1)  POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         ICM   R15,R15,WHRADDR
         BZ    NODELETE
         DELETE EPLOC==CL8'XIPSWHR'
NODELETE DS    0H
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
HIMSG    DC    C'                 MAP FOR ASID '
TCBMSG   DC    C'*** P R O C E S S I N G   T C B *** - '
CMPMSG   DC    C'*** COMPCODE='
RTM2MSG  DC    C' RTM2 AT '
RBMSG    DC    C'---MAPPING RBS - '
JPQMSG   DC    C'---MAPPING CDES FROM JOB PACK QUEUE'
LLSMSG   DC    C'---MAPPING CDES FROM LOAD LIST'
NODEBS   DC    C'---TASK HAS NO OPEN DATA SETS'
DEBMSG   DC    C'---MAPPING DEBS - '
TRY218   DC    C'PSATOLD TCB POINTER IS ZEROES, USING PSATNEW POINTER'
TRY224   DC    C'PSATNEW TCB POINTER IS ZEROES, USING ASXB POINTER'
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
ER21CMSG DC    C'ERROR - PSATOLD UNAVAILABLE'
ER218MSG DC    C'ERROR - PSATNEW UNAVAILABLE'
ER224MSG DC    C'ERROR - ASCB UNAVAILABLE'
TCBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR TCB AT '
ASCBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASCB AT '
ASXBEMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR ASXB AT '
RBERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR RB AT '
CDERRMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR CDE AT '
LLSERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR LLS AT '
DEBERMSG DC    C'ERROR - STORAGE UNAVAILABLE FOR DEB AT '
DCBERMSG DC    C'DCB UNAVAILABLE AT '
TIOERMSG DC    C'TIOT ENTRY UNAVAILABLE AT '
JFERRMSG DC    C'JFCB UNAVAILABLE AT '
CVTEMSG  DC    C'CVT ASVT POINTER UNAVAILABLE AT '
CASVEMSG DC    C'ASVT ADDRESS UNAVAILABLE AT '
ASVTEMSG DC    C'ASVT ASCB POINTER UNAVAILABLE AT '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
PRCSSAVE DS    A                   SAVE AREA FOR PROCESS SUBROUTINE
DCDESAVE DS    A                   SAVE AREA FOR DUMPCDE SUBROUTINE
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWORK   DS    A                   WORK AREA FOR FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR LOAD MODULE
FIRSTTCB DS    A                   First TCB address
         SPACE 1
COPYTCB  DS    CL256               COPY OF MOST OF TCB
COPYDEB  DS    CL32                COPY OF MOST OF DEB
RBPREFIX DS    CL32                COPY OF RB PREFIX
COPYRB   DS    CL64                COPY OF MOST OF RB
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINEDSCT DSECT ,                   MAP THE OUTPUT BUFFER
LINE     DS    CL132               WORD AREA FOR OUTPUT LINES
         ORG   LINE
LNCDADDR DS    CL8                 ADDRESS OF CONTROL BLOCK
         DS    CL2
LNCDNAME DS    CL8                 NAME
         DS    CL3
LNCDEPEQ DS    C'EP='              "EP="
LNCDEPA  DS    CL8                 ENTRY POINT
         DS    CL3                 FOLLOWED BY ATTRIBUTES
LNCDRENT DS    C'RENT'
         DS    CL1
LNCDREUS DS    C'REUS'
         DS    CL1
LNCDANY  DS    C'ANY'
         DS    CL1
LNCDOVLY DS    C'OVLY'
         DS    CL1
LNCDSYSL DS    C'SYSLIB'
         DS    CL1
LNCDAUTH DS    C'AUTH'
         DS    CL1
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         BLSABDPL
         SPACE 1
         IHACDE
         SPACE 1
         END
./ ADD NAME=XITSAV   0100-07332-07332-0900-00437-00437-00000-SEB
         TITLE 'XITSAV - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   ('&LENGTH' EQ '(0)').GOTLEN
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)
R8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA
R9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XITSAV   CSECT
         SAVE  (14,12),,XITSAV_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XITSAV,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
PROCESS  DS    0H
         SPACE 1
         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE
         ST    R0,WHRADDR
         SPACE 1
         L     R3,ADPLTCB          R3 = ADDRESS OF TCB
         USING TCB,R3
         XR    R7,R7               INITIALIZE HSA POINTER
         LA    R3,TCBFSA           POINTER TO ADDRESS OF FIRST SAVEAREA
         GSTOR R3,4                GET TCBFSA FROM DUMP
         ICM   R3,15,0(R3)         ADDRESS OF FIRST SAVE AREA
         BNZ   LOOP                IF NONE, THEN...
         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
LOOP     DS    0H
         LTR   R3,R3               UNTIL NO MORE
         BZ    ENDLOOP
         MVC   LINE(L'SAMSG),SAMSG "SAVE AREA AT "
         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA
         ST    R8,OPWORK           DISPLAY IT
         UNPK  LINESAA+0(9),OPWORK(5)
         TR    LINESAA+0(8),HEXTBL
         MVI   LINESAA+8,C'.'
         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP
         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA
CONTLOOP DS    0H
         SPACE
         MVC   LINEL1(4),=C'WD1='
         UNPK  LINEN1(9),SAWD1(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'HSA='
         UNPK  LINEN2(9),SAHSA(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'LSA='
         UNPK  LINEN3(9),SALSA(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         BAL   R14,OUTPUT
         C     R7,SAHSA            CHECK HSA POINTER
         BE    HSAOK               IF IT DOESN'T MATCH, THEN...
         MVC   LINEL1(L'IBCMSG),IBCMSG
         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN
HSAOK    DS    0H
         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS
         MVC   LINEL1(4),=C'R14='
         UNPK  LINEN1(9),SAR14(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR14
         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R15='
         UNPK  LINEN1(9),SAR15(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR15
         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS
         SPACE 1
         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED
         LTR   R9,R9               IF ZERO, IGNORE IT
         BZ    NOEP
         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA
         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION
         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT
         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND
         BNE   NOEP                THEN NO EP DATA
         XR    R2,R2               CLEAR INSERT REG
         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER
         LTR   R2,R2               IF ZERO
         BZ    NOEP                THEN NO EP DATA
         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW
         BNH   SETMAX
         LA    R2,EPLENGTH
SETMAX   DS    0H
         LA    R9,4
         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF
         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...
         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY
         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED
         MVC   LINEEP1(6),=CL6'AT EP '
         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE
         EX    R2,EPMVC            TRANSLATE EP DATA
NOEP     DS    0H
         SPACE 1
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R0 ='
         UNPK  LINEN1(9),SAR00(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R1 ='
         UNPK  LINEN1(9),SAR01(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R2 ='
         UNPK  LINEN2(9),SAR02(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R3 ='
         UNPK  LINEN3(9),SAR03(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R4 ='
         UNPK  LINEN4(9),SAR04(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R5 ='
         UNPK  LINEN1(9),SAR05(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R6 ='
         UNPK  LINEN2(9),SAR06(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R7 ='
         UNPK  LINEN3(9),SAR07(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R8 ='
         UNPK  LINEN4(9),SAR08(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R9 ='
         UNPK  LINEN1(9),SAR09(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R10='
         UNPK  LINEN2(9),SAR10(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R11='
         UNPK  LINEN3(9),SAR11(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R12='
         UNPK  LINEN4(9),SAR12(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         BAL   R14,OUTPUT          JUST A BLANK LINE
         SPACE
         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA
         B     LOOP                CONTINUE LOOPING
         SPACE 1
SANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP
         SPACE 1
         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG
         BAL   R14,OUTPUT
         B     ERROUT
         SPACE 1
ENDLOOP  DS    0H
         B     RETURN0
         SPACE 2
EPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERRMSG),ERRMSG
******** B     ERROUT
         SPACE 1
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED
         LTR   R0,R0               IF ADDRESS IS ZEROES,
         BZR   R14                 THEN PRINT NOTHING, NOT AN EP
         ST    R14,FMSAVE
         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS
FMDOIT   DS    0H
         XR    R0,R0
         ST    R0,ADPLCOM1
         L     R0,FMWHERE
         LR    R1,R4
         L     R15,WHRADDR
         BALR  R14,R15
         CLI   ADPLFMT1,C' '
         BE    FMNF
         MVC   LINEMOD(16),ADPLCOM1
         B     FMRET
FMNF     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *
* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS
         BE    FMFAIL              THEN DON'T TRY AGAIN
         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS
         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE
FMFAIL   DS    0H                  ELSE GIVE UP
         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '
         XC    FMWHERE,FMWHERE
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         LTR   R15,R15             IF LINE NOT PRINTED
         BNZ   RETURN0             THEN...
NORETYET DS    0H
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         DELETE EP=XIPSWHR
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
NOSAMSG  DC    C'NO SAVE AREA CHAIN FOR THIS TCB'
IBCMSG   DC    C'*** INVALID BACK CHAIN ***'
SANAMSG  DC    C'STORAGE UNAVAILABLE'
SAMSG    DC    C'SAVE AREA AT '
         SPACE
VALTBL   DC    256YL1(1)
         ORG   VALTBL+X'81'
         DC    6YL1(0)             LOWER CASE ABCDEF
         ORG   VALTBL+C'A'
         DC    6YL1(0)             UPPER CASE ABCDEF
         ORG   VALTBL+C'0'
         DC    10YL1(0)            0123456789
         ORG
         SPACE
FTBL     DC    256YL1(*-FTBL)
         ORG   FTBL+X'81'
         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF
         ORG   FTBL+C'A'
         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF
         ORG
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE
         DS    XL1                 PADDING FOR CONVERSION
OPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION
COPYSA   DS    18F                 WORK AREA FOR SAVE AREA
         ORG   COPYSA
SAWD1    DS    F                   00 = FIRST WORD
SAHSA    DS    F                   04 = HSA
SALSA    DS    F                   08 = LSA
SAR14    DS    F                   0C = REG14
SAR15    DS    F                   10 = REG15
SAR00    DS    F                   14 = REG0
SAR01    DS    F                   18 = REG1
SAR02    DS    F                   1C = REG2
SAR03    DS    F                   20 = REG3
SAR04    DS    F                   24 = REG4
SAR05    DS    F                   28 = REG5
SAR06    DS    F                   2C = REG6
SAR07    DS    F                   30 = REG7
SAR08    DS    F                   34 = REG8
SAR09    DS    F                   38 = REG9
SAR10    DS    F                   3C = REG10
SAR11    DS    F                   40 = REG11
SAR12    DS    F                   44 = REG12
         ORG
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         ORG   LINE
         DS    CL(L'SAMSG)         "SAVE AREA AT "
LINESAA  DS    CL8                 ADDRESS OF SAVE AREA
         DS    CL2                 "  "
LINEL1   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN1   DS    CL8                 "NNNNNNNN"
LINEB1   DS    CL1                 " "
LINEL2   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN2   DS    CL8                 "NNNNNNNN"
LINEB2   DS    CL1                 " "
LINEL3   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN3   DS    CL8                 "NNNNNNNN"
LINEB3   DS    CL1                 " "
LINEL4   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN4   DS    CL8                 "NNNNNNNN"
LINEB4   DS    CL1                 " "
LINEL5   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN5   DS    CL8                 "NNNNNNNN"
LINEB5   DS    CL1                 " "
         ORG   LINEL2
         DS    CL1
LINEMOD  DS    CL16                "WHERE" DATA
         DS    CL1
LINEEP1  DS    CL6                 "AT EP "
LINEEP2  DS    CL(EPLENGTH)
         SPACE 1
EPLENGTH EQU   78-(LINEEP2-LINE)
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IKJTCB
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XITWHR   0100-07332-07332-0900-00260-00260-00000-SEB
         TITLE 'XITWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         NI    ADPLPRDP,255-ADPLSAMK   Insure 31-bit address
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'XITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XITWHR   CSECT
         SAVE  (14,12),,XITWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XITWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         XR    R0,R0
         ST    R0,ADPLCOM1         Clear communication word
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         UNPK  LINE+00(9),ADPLTCB(5)
         TR    LINE+00(8),HEXTBL
         MVI   LINE+08,C'.'
         CLC   ADPLFMT1(4),=C'    '
         BE    NOTFOUND
         CLC   ADPLFMT1(4),=C'JPA '
         BE    INJPA
         CLC   ADPLFMT1(4),=C'PLPA'
         BE    INPLPA
         CLC   ADPLFMT1(4),=C'MLPA'
         BE    INMLPA
         CLC   ADPLFMT1(4),=C'NUC '
         BE    INNUC
         CLC   ADPLFMT1(4),=C'ERR '
         BE    INERROR
         B     INLIMBO
         EJECT
NOTFOUND DS    0H
         SPACE 1
         MVC   LINE+09(L'NFMSG),NFMSG
         B     ERROUT
         EJECT
INERROR  DS    0H
         SPACE 1
         MVC   LINE+09(L'ERMSG),ERMSG
         B     ERROUT
         SPACE 1
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERMSG),ERMSG
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
INJPA    DS    0H
         SPACE 1
         MVC   LINE+09(L'JPAMSG),JPAMSG
         MVC   LINE+09+L'JPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'JPAMSG+08,C' '
         MVC   LINE+09+L'JPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'JPAMSG+10,C' '
         MVC   LINE+09+L'JPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INPLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'PLPAMSG),PLPAMSG
         MVC   LINE+09+L'PLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'PLPAMSG+08,C' '
         MVC   LINE+09+L'PLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'PLPAMSG+10,C' '
         MVC   LINE+09+L'PLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INMLPA   DS    0H
         SPACE 1
         MVC   LINE+09(L'MLPAMSG),MLPAMSG
         MVC   LINE+09+L'MLPAMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'MLPAMSG+08,C' '
         MVC   LINE+09+L'MLPAMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'MLPAMSG+10,C' '
         MVC   LINE+09+L'MLPAMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INNUC    DS    0H
         SPACE 1
         MVC   LINE+09(L'NUCMSG),NUCMSG
         MVC   LINE+09+L'NUCMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'NUCMSG+08,C' '
         MVC   LINE+09+L'NUCMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'NUCMSG+10,C' '
         MVC   LINE+09+L'NUCMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
INLIMBO  DS    0H
         SPACE 1
         MVC   LINE+09(L'LIMBOMSG),LIMBOMSG
         MVC   LINE+09+LIMBOFF(4),ADPLFMT1
         MVC   LINE+09+L'LIMBOMSG+00(8),ADPLCOM1
         MVI   LINE+09+L'LIMBOMSG+08,C' '
         MVC   LINE+09+L'LIMBOMSG+09(1),ADPLCOM3+0
         MVI   LINE+09+L'LIMBOMSG+10,C' '
         MVC   LINE+09+L'LIMBOMSG+11(7),ADPLCOM3+1
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
JPAMSG   DC    C'  FOUND IN JPA MODULE '
PLPAMSG  DC    C'  FOUND IN PLPA MODULE '
MLPAMSG  DC    C'  FOUND IN MLPA MODULE '
NUCMSG   DC    C'  FOUND IN NUCLEUS CSECT '
NFMSG    DC    C'  NOT FOUND IN JPA, LPA OR NUCLEUS'
ERMSG    DC    C'  STORAGE ERROR - UNABLE TO FIND MODULE'
LIMBOMS1 DC    C'  FOUND IN '
LIMBOMS2 DC    CL4'    '
LIMBOMS3 DC    C' MODULE '
LIMBOMSG EQU   LIMBOMS1,*-LIMBOMS1,C'C'
LIMBOFF  EQU   LIMBOMS2-LIMBOMS1
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=XLBRKS   0100-07332-07332-0900-00348-00348-00000-SEB
         TITLE 'XLBRKS - INSTREAM MACRO DEFINITIONS'
         MACRO
&LABEL   CLRLINE
&LABEL   MVI   DATALINE,C' '
         MVC   DATALINE+1(255),DATALINE
         MVC   DATALINE+256(L'DATALINE-256),DATALINE
         MEND
         SPACE 5
         MACRO
&LABEL   TUPT  &ADDR,&LEN
&LABEL   LA    R1,&ADDR                    LOAD PARAMETER REG 1
         LA    R0,&LEN                     LOAD PARAMETER REG 0
         SVC   93                          ISSUE TPUT SVC
         MEND
         TITLE 'XLBRKS - COMMAND TO DISPLAY BREAKPOINTS UNDER TEST'
***********************************************************************
* SYNTAX: ... XLB | XLBRKS                                            *
*        (WHERE ... IS HELP OR SOME OTHER MEANS OF GETTING THIS TSO   *
* COMMAND INTO THE TEST ENVIRONMENT)                                  *
*    OPERANDS:   "S", IF SPECIFIED, CAUSES SUBCOMMAND CHAINS TO BE    *
* DISPLAYED FOR ACTIVE AND DEFERRED BREAKPOINTS.                      *
* CHANGE ACTIVITY:                                                    *
*     11/84 - SOME TEST CONTROL BLOCKS ARE NOW ABOVE THE 16MB LINE.   *
*             THEREFORE, THIS PROGRAM MUST RUN IN 31-BIT MODE.        *
*     05/85 - ADDRESSES MAY BE 31-BIT, SO MUST DISPLAY 4 BYTES.       *
***********************************************************************
R0       EQU   0
R1       EQU   1
R2       EQU   2                   ADDRESS OF CPPL
R3       EQU   3                   ADDRESS OF BREAK ELEMENT
R4       EQU   4                   ADDRESS OF DEFERRED ELEMENT QUEUE
R5       EQU   5                   ADDRESS OF DBE (DEFER BREAK ELEMENT)
R6       EQU   6                   ADDRESS OF PDL (PARSE) FOR DBE
R7       EQU   7                   ADDRESS OF EBCDIC BREAK DESCRIPTOR
R8       EQU   8                   ADDRESS OF PDE OF OPERAND FOR DBE
R9       EQU   9                   ADDRESS OF TCOMTAB
R10      EQU   10
R11      EQU   11
R12      EQU   12                  STATIC BASE REGISTER
R13      EQU   13                  DYNAMIC BASE REGISTER
R14      EQU   14
R15      EQU   15
XLBRKS   CSECT
XLBRKS   AMODE 31
XLBRKS   RMODE 24
         SAVE  (14,12),,XLBRKS_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XLBRKS,R12
         LR    R2,R1
         USING CPPL,R2
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R1,8(,R13)
         ST    R13,4(,R1)
         LR    R13,R1
         USING DATD,R13
         EJECT
         L     R9,540                  TCB FOR THIS PROGRAM
TESTLOOP CLC   21(3,R9),=X'000000'     CHECK TESTRAN FIELD IN TCB
         BNE   TESTOK                  IF NONE, THEN
         ICM   R9,7,133(R9)             TRY NEXT (MOTHER) TCB
         BNZ   TESTLOOP                 UNTIL NO MORE, AT WHICH POINT
         TUPT  NOTEST,L'NOTEST          SAY 'TEST NOT ACTIVE'
         LA    R15,12                   AND QUIT.
         B     RETURN
         SPACE 1
TESTOK   DS    0H                      R9 POINTS TO TEST'S TCB
         L     R9,20(,R9)              POINT R9 TO TCOMTAB (TCBTRN)
         N     R9,=X'00FFFFFF'         CLEAR HIGH-ORDER BYTE
         USING TCOMTAB,R9
         SPACE 1
         NI    FLAGS,255-DISPSUBS    INIT SUBCOMMANDS NOT DISPLAYED
         L     R15,CPPLECT
         USING ECT,R15
         TM    ECTSWS,ECTNOPD      IF THERE IS AN OPERAND ON THE CMD
         DROP  R15
         BO    NOOPERS             THEN
         L     R14,CPPLCBUF         POINT TO COMMAND BUFFER
         LA    R15,4(,R14)          POINT TO TEXT PART OF COMMAND
         AH    R15,2(,R14)          POINT TO COMMAND OPERAND
         OI    0(R15),X'40'         TRANSLATE IT TO UPPER CASE
         CLI   0(R15),C'S'          IF OPERAND IS AN "S"
         BNE   NOOPERS              THEN
         OI    FLAGS,DISPSUBS        INDICATE SUBCOMMANDS TO BE DSPLYD
NOOPERS  DS    0H
         SPACE 1
         ICM   R3,15,BREAKTAB          ADDR OF ACTIVE BREAK ELEMENT Q
         BNZ   ACTIVEOK                IF NONE, THEN
         TUPT  NOACTIVE,L'NOACTIVE      SAY NO ACTIVE BREAKPOINTS
         B     TRYDEFER                 AND GO LOOK AT DEFERRED ONES
         SPACE 2
ACTIVEOK DS    0H                      ELSE PROCESS ACTIVE BREAKPOINTS
         USING BRKELEM,R3
         CLRLINE ,                     INIT OUTPUT LINE TO BLANKS
         MVC   AT(4),=C' AT '          MOVE IN AN "AT"
         UNPK  WHERE(9),BRKADDR(5)     CONVERT BREAKPOINT ADDRESS
         TR    WHERE(8),HEXTBL          TO DISPLAY
         MVI   WHERE+8,C'.'            ADD A PERIOD
         UNPK  INSTR(13),BRKINST(7)    CONVERT SAVED INSTRUCTION
         TR    INSTR(12),HEXTBL         TO DISPLAY
         MVI   INSTR+12,C' '           OVERLAY LEFTOVER CRUD
***********************************************************************
* CHECK LENGTH OF INSTRUCTION (2, 4, OR 6 DEPENDING ON OPCODE) AND    *
* BLANK OUT REST OF IT                                                *
***********************************************************************
         CLI   BRKINST,X'40'           IF OPCODE LESS THAN 40
         BNL   COMPC0                  THEN
         MVC   INSTR+4(4),=C'    '      BLANK OUT BYTES 3 AND 4
COMPC0   CLI   BRKINST,X'C0'           IF OPCODE LESS THAN C0
         BNL   AFTINSTR                THEN
         MVC   INSTR+8(4),=C'    '      BLANK OUT BYTES 5 AND 6
AFTINSTR DS    0H
         LA    R1,DESC                 POINT TO DESCRIPTION LOC, BUT...
         TM    BRKFLGS,BRKRANGE        IF A RANGE OF BREAKPOINTS
         BZ    NORANGE                 THEN
         MVC   DESC(L'RANGELBL),RANGELBL   SAY "+... FROM"
         LH    R0,BRKDISP                  GET OFFSET OF BREAKPOINT
         UNPK  DESC+1(5),BRKDISP(3)        CONVERT OFFSET TO
         TR    DESC+1(4),HEXTBL             PRINTABLE HEX DISPLAY
         MVI   DESC+5,C' '
         LA    R1,DESC+L'RANGELBL       & POINT PAST RANGE DESCRIPTION.
NORANGE  DS    0H
         ICM   R7,15,BRKNAME           ADDRESS OF BREAKPOINT DESCRIPTN
         BZ    BRKERR1                 IF NONE, ERROR IN BREAK CHAIN
         LH    R15,0(,R7)              LENGTH OF DESCRIPTION
         LTR   R15,R15                 IF ZERO,
         BZ    BRKERR1                   ERROR IN BREAKPOINT CHAIN
         BCTR  R15,0                   USING THIS LENGTH,
         EX    R15,MOVEDESC            MOVE IN BREAKPOINT ADDRESS
         B     DISPLAY1
BRKERR1  DS    0H
         MVC   AT(L'ERR1MSG),ERR1MSG   IF ERROR, SAY SO
DISPLAY1 DS    0H
         TR    DATALINE(256),TRTBL
         TR    DATALINE+256(L'DATALINE-256),TRTBL
         TUPT  DATALINE,L'DATALINE     DISPLAY BREAKPOINT INFO
         SPACE 2
         TM    FLAGS,DISPSUBS          IF DISPLAYING SUBCOMMANDS
         BZ    NOCHAIN                 AND
         ICM   R15,15,BRKCHAIN         IF A SUBCOMMAND CHAIN EXISTS
         BZ    NOCHAIN                 THEN
         LH    R1,0(,R15)               GET LENGTH OF SUBCOMMAND CHAIN
         LA    R15,2(,R15)              GET ADDRESS OF SUBCOMMAND CHAIN
         BAL   R14,DISPSUB              DISPLAY SUBCOMMAND CHAIN
         SPACE 2
NOCHAIN  DS    0H                      NO SUBCOMMANDS TO BE DISPLAYED
         ICM   R3,15,BRKLINK           REPEAT UNTIL NO MORE ACTIVE
         BNZ   ACTIVEOK                 BREAKPOINTS, THEN...
         SPACE 3
TRYDEFER DS    0H                      PROCESS DEFERRED BREAKPOINTS
         ICM   R4,15,DEFERTAB          GET ADDR OF DEFERRED ELEMENT Q
         BNZ   DEFEROK                 IF NONE, THEN
         TUPT  NODEFER,L'NODEFER        SAY NO DEFERRED BREAKPOINTS
         B     RETURN0                  AND RETURN TO TEST.
         SPACE 1
DEFEROK  DS    0H                      ADDRESS THE DEFER MODULE ELEMENT
         USING DME,R4
PROCDME  ICM   R5,15,DMEDBE            GET ADDR OF DEFER BREAK ELEMENT
         BZ    NEXTDME                 IF NONE, ERROR, TRY NEXT DME
         USING DBE,R5
PROCDBE  ICM   R6,15,DBEPDL            GET ADDRESS OF PARSE-CREATED PDL
         BZ    NEXTDBE                 IF NONE, ERROR, TRY NEXT DBE
         LA    R8,8(,R6)               POINT TO PDE FOR BRKPT ADDRESS
         SPACE 1
PROCPDE  DS    0H                      PROCESS THIS PDE TO GET INFO
         CLRLINE ,                     REINIT OUTPUT LINE TO BLANKS
         MVC   DATALINE(L'DEFERLBL),DEFERLBL   MOVE IN DEFER LABEL
         TM    32(R8),X'10'            IF BREAKPOINT IS MARKED OFF,
         BO    NXTINLST                THEN BYPASS THIS PDE. ELSE...
         LR    R0,R8                   POINT TO FIRST PDE OF RANGE
         LA    R1,DATALINE+L'DEFERLBL  POINT TO WHERE TO BUILD STRING
         L     R15,TSTADDR             GET ADDRESS OF IKJEGBLD ROUTINE
         BALR  R14,R15                 CALL IKJEGBLD TO GET "AT" STRING
***********************************************************************
* NOTE THAT IKJEGBLD SETS R1 TO POINT TO THE END OF THE STRING, I.E.  *
* THE LOCATION WHERE WE CAN MOVE IN ADDITIONAL DATA IN CASE THIS WAS  *
* A RANGE SPECIFICATION AND WE HAVE TO PROCESS THE SECOND ADDRESS OF  *
* THE RANGE.                                                          *
***********************************************************************
PROCPDE2 OC    36(4,R8),36(R8)         IF A SECOND ADDRESS IN RANGE,
         BZ    DSPDEFER                THEN
         LA    R0,36(,R8)               POINT TO SECOND PDE OF RANGE
         MVI   0(R1),C':'               MOVE COLON AFTER END OF STRING
         LA    R1,1(,R1)                BUMP PAST COLON TO PUT NEW DATA
         L     R15,TSTADDR              GET ADDR OF IKJEGBLD AGAIN
         BALR  R14,R15                  CALL IKJEGBLD FOR "AT" STRING
         SPACE 1
DSPDEFER DS    0H
         TR    DATALINE(256),TRTBL
         TR    DATALINE+256(L'DATALINE-256),TRTBL
         TUPT  DATALINE,L'DATALINE     DISPLAY THE DEFERRED BREAKPOINT
         SPACE 2
         TM    FLAGS,DISPSUBS          IF DISPLAYING SUBCOMMANDS
         BZ    NXTINLST                AND
         TM    90(R6),X'80'            A SUBCOMMAND CHAIN EXISTS
         BZ    NXTINLST                THEN
         L     R15,84(,R6)              GET ADDRESS OF SUBCOMMAND CHAIN
         LTR   R1,R15                   IF BAD ADDRESS
         BZ    *+8                      THEN CAUSE ERROR DISPLAY. ELSE
         LH    R1,88(,R6)               GET LENGTH OF SUBCOMMAND CHAIN
         BAL   R14,DISPSUB              DISPLAY ORIGINAL SUBCOMMAND
         SPACE 1
NXTINLST DS    0H
         CLC   72(4,R8),=X'FF000000'   IF THERE'S ANOTHER ADDR IN LIST
         BE    NEXTDBE                 THEN
         L     R8,72(,R8)               GET PDE FOR NEXT ADDR IN LIST
         B     PROCPDE                  AND GO PROCESS IT.
NEXTDBE  ICM   R5,15,DBEDBE            ELSE GO TO NEXT DBE
         BNZ   PROCDBE                 WHEN NO MORE DBE'S
NEXTDME  ICM   R4,15,DMEDME            GET NEXT DME
         BNZ   PROCDME                 UNTIL NO MORE DME'S.
         SPACE 4
RETURN0  XR    R15,R15                 SET RETURN CODE TO ZERO
RETURN   DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)            STORE RETURN CODE
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
DISPSUB  DS    0H                  SUBROUTINE TO DISPLAY SUBCOMMAND
         SPACE
***********************************************************************
* THIS SUBROUTINE DISPLAYS THE CONTENTS OF A SUBCOMMAND CHAIN.        *
* ON ENTRY R15 CONTAINS THE ADDRESS OF THE SUBCOMMAND CHAIN BUFFER TO *
* BE DISPLAYED. R1 CONTAINS THE LENGTH OF THE SUBCOMMAND CHAIN.       *
* R14 CONTAINS THE RETURN ADDRESS. THIS SUBROUTINE ALTERS R0 AND R1.  *
***********************************************************************
         SPACE
         CLRLINE ,                      REINIT OUTPUT LINE TO BLANKS
         LTR   R1,R1                    IF ZERO,
         BZ    BRKERR2                   ERROR IN SUBCOMMAND CHAIN
         CH    R1,=H'256'               IF GREATER THAN 256,
         BH    BRKERR3                   ERROR IN SUBCOMMAND CHAIN
         MVC   DATALINE(L'SUBLBL),SUBLBL  MOVE IN SUBCOMMAND IDENT
         BCTR  R1,0                     USING THIS LENGTH,
         EX    R1,SUBMOVE               MOVE IN SUBCOMMAND STRING
         B     DISPLAY2
BRKERR2  DS    0H
         MVC   DATALINE(L'ERR2MSG),ERR2MSG   IF ERROR, SAY SO
         B     DISPLAY2
BRKERR3  DS    0H
         MVC   DATALINE(L'ERR3MSG),ERR3MSG   IF ERROR, SAY SO
DISPLAY2 DS    0H
         TR    DATALINE(256),TRTBL
         TR    DATALINE+256(L'DATALINE-256),TRTBL
         TUPT  DATALINE,L'DATALINE     DISPLAY (SUB)COMMAND STRING
         BR    R14                 RETURN TO CALLER
         EJECT
***********************************************************************
*  DATA AREAS                                                         *
***********************************************************************
         SPACE
*  EXECUTED INSTRUCTIONS
         SPACE
MOVEDESC MVC   0(0,R1),2(R7)           MOVE DESCRIPTION TO DATA LINE
SUBMOVE  MVC   DATALINE+L'SUBLBL(0),0(R15) MOVE SUBCOMMAND TO DATA LINE
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256                   TABLE FOR HEX CONVERSION
RANGELBL DC    C'+0000 FROM '
SUBLBL   DC    C' SUBCOMMAND: '
DEFERLBL DC    C' DEFERRED BREAKPOINT AT '
NOTEST   DC    C'TEST NOT ACTIVE'
NOACTIVE DC    C'NO ACTIVE BREAKPOINTS'
NODEFER  DC    C'NO DEFERRED BREAKPOINTS'
ERR1MSG  DC    C'*** ERROR IN BREAKPOINT CHAIN ***'
ERR2MSG  DC    C' *** ERROR IN SUBCOMMAND CHAIN ***'
ERR3MSG  DC    C' *** INVALID SUBCOMMAND CHAIN ***'
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE 3
         LTORG
         EJECT
DATD     DSECT ,                       REENTRANT WORK AREA
         SPACE 1
SAVEAREA DS    9D                      OS SAVE AREA
         SPACE 1
FLAGS    DS    X
DISPSUBS EQU   X'80'                   1 = DISPLAY SUBCOMMANDS
         SPACE 1
DATALINE DS    0CL320                  PLACE TO BUILD OUTPUT
WHERE    DS    CL9                     BREAKPOINT INSTRUCTION ADDRESS
         DS    C' '                    FILLER
INSTR    DS    CL12                    INSTRUCTION IMAGE
AT       DS    C' AT '                 FILLER
DESC     DS    CL(L'DATALINE-(*-DATALINE))   THE REST OF IT
         SPACE 1
SIZDATD  EQU   *-DATD                  LENGTH OF WORK AREA
         TITLE 'XLBRKS - TSO TEST CONTROL BLOCKS'
***********************************************************************
* THE INFORMATION IN THE FOLLOWING DSECT MAPPINGS IS TAKEN FROM:      *
* OS/VS2 MVS TSO COMMAND PROCESSOR LOGIC VOLUME III: TEST             *
* AND IS COPYRIGHT BY IBM.                                            *
***********************************************************************
         SPACE 1
BRKELEM  DSECT ,                       MAPPING OF BREAK ELEMENT
         SPACE 1
BRKLINK  DS    A                       LINK PTR TO NEXT BREAK ELEMENT
BRKADDR  DS    A                       ABS ADDR IN PP WHERE SVC97 SET
BRKINST  DS    XL8                     SAVED INSTRUCTION
BRKFLGS  DS    X                       FLAGS
BALSW    EQU   X'80'                   SAVED INSTRUCTION IS BAL(R)
BRKRANGE EQU   X'40'                   ELEMENT IS PART OF RANGE OF ADDR
BRKLIST  EQU   X'20'                   ELEMENT IS PART OF LIST OF ADDRS
BRKNONOT EQU   X'10'                   NONOTIFY ACTIVE
BRKDISP  DS    H                       DISPLACEMENT FROM START OF RANGE
BRKNAME  DS    A                       PTR TO 1ST EBCDIC ADDR ENTERED
BRKCHAIN DS    A                       PTR TO EBCDIC SUBCOMMAND CHAIN
BRKCOUNT DS    A                       COUNT-1 IN LOW-ORDER 2 BYTES
*                                      (HI-ORDER USED BY SVC97)
BRKRB    DS    A                       ADDR OF RB FOR MODULE
         SPACE 2
DME      DSECT ,                       DEFER MODULE ELEMENT
         SPACE 1
DMEDME   DS    A                       PTR TO NEXT DME OR ZEROES
DMEDBE   DS    A                       PTR TO 1ST DEFER BREAK ELEMENT
DMELOAD  DS    CL8                     NAME OF LOAD MODULE
         SPACE 2
DBE      DSECT ,                       DEFER BREAK ELEMENT
         SPACE 1
DBEDBE   DS    A                       PTR TO NEXT DBE OR ZEROES
DBEPDL   DS    A                       PTR TO PDL FOR AT DEFER SUBCMD
DBEINBUF DS    A                       PTR TO INPUT BUF W/ SUBCOMMAND
         EJECT
         TCOMTAB
         EJECT
         IKJCPPL
         EJECT
         IKJECT
         END
./ ADD NAME=XLL      0100-07332-07332-0900-02926-02926-00000-SEB
         TITLE 'XLL - INTRODUCTION'
***********************************************************************
* THIS PROGRAM SCANS A LOAD MODULE FOR OCCURRENCES OF A SPECIFIED     *
* CHARACTER STRING. IT ALSO DISPLAYS CSECT NAMES.                     *
***********************************************************************
* NON-REENTRANT, NON-REUSABLE                                         *
* REQUIRED MACRO LIBRARY: DST1.AMODGEN                                *
* REQUIRED FILES:                                                     *
*   SYSIN       -   INPUT CONTROL STATEMENTS                          *
*   SYSPRINT    -   MESSAGES AND OUTPUT                               *
*   SYSLIB      -   LOAD MODULE LIBRARY                               *
* (NOTE: THESE FILE NAMES MAY BE OVERRIDDEN IN STANDARD IBM UTILITY   *
* "PARM 2" FORMAT, E.G. BY THE DRAPER "XINVOKE" COMMAND OPERANDS      *
* SYSIN(XXX), SYSPRINT(XXX), SYSLIB(XXX).)                            *
***********************************************************************
* OPTIONAL PARAMETERS:                                                *
* (1) A STANDARD OS EXEC PARAMETER STRING.  IF NON-NULL, DEFINES THE  *
*     NAME OF AN ISPF PANEL AND THIS UTILITY WILL FUNCTION AS AN ISPF *
*     DIALOG, IN WHICH CASE DDNAMES SYSPRINT AND SYSIN ARE NOT USED.  *
*     (AN ISPF TEMP TABLE IS CREATED WHOSE NAME IS THE PANEL NAME.)   *
*     THE PARM FIELD CONTAINS THE PANEL NAME FOLLOWED BY AN OPTIONAL  *
*     ALTERNATE DDNAME FOR SYSLIB, SEPARATED BY BLANKS.               *
* (2) AN ALTERNATE-DDNAME LIST (SEE ABOVE).                           *
***********************************************************************
         TITLE 'XLL - INTERNAL MACRO DEFINITIONS'
         MACRO
&NAME    MSG
.********************************************************************
.* THIS MACRO IS USED TO GENERATE A MESSAGE TO BE WRITTEN ON THE
.* OUTPUT FILE.  IT IS REFERENCED BY THE "WRTMSG" MACRO (Q.V.)
.* INPUT IS POSITIONAL PARAMETERS WITH 1 TO 3 SUBPARAMETERS EACH,
.* DEFINING THE ADDRESS, LENGTH, AND TYPE OF EACH ITEM TO BE
.* DISPLAYED.  VALID TYPES ARE:
.*      W  -  CHARACTER FORMAT WITH TRAILING BLANKS TRIMMED
.*      C  -  CHARACTER FORMAT WITH ALL BLANKS INCLUDED
.*      X  -  HEXADECIMAL FORMAT TO BE CONVERTED TO HEX DISPLAY
.*      F  -  FULLWORD FORMAT TO BE CONVERTED TO NUMERIC DISPLAY
.*      H  -  HALFWORD FORMAT TO BE CONVERTED TO NUMERIC DISPLAY
.* IF LENGTH OR TYPE IS OMITTED, IT WILL BE TAKEN FROM THE DEFAULT
.* FOR THE SPECIFIED SYMBOL.
.* NOTE 1: LENGTH AND TYPE ARE IGNORED WHEN A QUOTED STRING IS
.*   SPECIFIED INSTEAD OF A SYMBOLIC ADDRESS, AND SHOULD BE OMITTED.
.* NOTE 2: THE LENGTH MAY BE SPECIFIED IN A REGISTER AS (#), BUT
.*   THE ADDRESS MUST BE WRITTEN AS AN S-TYPE EXPRESSION, E.G. 0(#),
.*   IN ORDER FOR A REGISTER DESIGNATION TO BE USED FOR IT.
.* NOTE 3: SYMBOLS WITH TYPE OF C DEFAULT TO TYPE W UNLESS OVERRIDDEN.
.* NOTE 4: ALL SYMBOLS MUST BE ADDRESSABLE, BUT THEY NEED NOT BE IN
.*   THE PROGRAM AREA, BECAUSE S-TYPE ADDRESS CONSTANTS ARE GENERATED
.*   FOR ALL SYMBOLS.
.*********************************************************************
         LCLA  &I
         LCLC  &LENGTH,&TYPE,&LREG
&I       SETA  0                   INITIALIZE PARAMETER COUNTER
&NAME    DS    0C
.LOOP    ANOP  ,                   LOOP FOR EACH POSITIONAL PARAMETER
&I       SETA  &I+1                INCREMENT PARAMETER COUNTER
         AIF   (&I GT N'&SYSLIST).ENDLOOP UNTIL END OF ALL PARAMETERS
         AIF   ('&SYSLIST(&I)'(1,1) NE '''').NOTCHAR
.* QUOTED CHARACTER STRING - GENERATE INLINE DATA
         DC    C&SYSLIST(&I)
         AGO   .LOOP
.NOTCHAR ANOP  ,                   ELSE NOT A QUOTED STRING...
         AIF   ('&SYSLIST(&I,2)' EQ '').IMPLEN   CHECK LENGTH SUBPARM
         AIF   ('&SYSLIST(&I,2)'(1,1) EQ '(').REGLEN   IF NOT REG SPEC
&LENGTH  SETC  '&SYSLIST(&I,2)'    THEN LENGTH IS NUMERIC VALUE
         AGO   .AFTLEN             ELSE
.REGLEN  ANOP                       LENGTH-IN-REGISTER SPECIFIED...
&LREG    SETC  '&SYSLIST(&I,2)'(2,K'&SYSLIST(&I,2)-2) EXTRACT REGISTER#
&LENGTH  SETC  '128+&LREG'          SPECIFY LENGTH IS A REGISTER SPEC.
         AGO   .AFTLEN
.IMPLEN  ANOP  ,                   OTHERWISE IMPLICIT LENGTH USED
&LENGTH  SETC  'L''&SYSLIST(&I,1)' USE LENGTH OF DEFINED SYMBOL
.AFTLEN  ANOP  ,                   END OF LENGTH PROCESSING
         AIF   ('&SYSLIST(&I,3)' EQ '').IMPTYPE  CHECK TYPE SUBPARM
&TYPE    SETC  '&SYSLIST(&I,3)'    IF ENTERED, USE AS TYPE VALUE
         AGO   .AFTTYPE            ELSE...
.IMPTYPE ANOP  ,                    TYPE NOT SPECIFIED...
&TYPE    SETC  T'&SYSLIST(&I,1)     USE TYPE OF DEFINED SYMBOL
.AFTTYPE ANOP  ,                   END OF TYPE PROCESSING
         AIF   ('&TYPE' EQ 'X').TYPEX
         AIF   ('&TYPE' EQ 'F').TYPEF
         AIF   ('&TYPE' EQ 'H').TYPEH
         AIF   ('&TYPE' EQ 'W').TYPEW
.* SEE NOTE 3 ABOVE PER THE FOLLOWING
         AIF (T'&SYSLIST(&I,1) EQ 'C' AND '&SYSLIST(&I,3)' EQ '').TYPEW
         AIF   ('&TYPE' EQ 'C').TYPEC
         MNOTE 12,'UNSUPPORTED TYPE &TYPE FOR OPERAND &SYSLIST(&I,1)'
         AGO   .LOOP
.TYPEC   ANOP  ,                   TYPE = C
&TYPE    SETC  '04'
         AGO   .GEN
.TYPEX   ANOP  ,                   TYPE = X
&TYPE    SETC  '08'
         AGO   .GEN
.TYPEF   ANOP  ,                   TYPE = F
.TYPEH   ANOP  ,                   TYPE = H
&TYPE    SETC  '0C'                NOTE - LENGTH DETERMINED BY SYMBOL
         AGO   .GEN
.TYPEW   ANOP  ,                   TYPE = W
&TYPE    SETC  '00'
.GEN     ANOP  ,                   GENERATE CODE FOR THIS PARAMETER
         DC    X'&TYPE',YL1(&LENGTH),SL2(&SYSLIST(&I,1))
         AGO   .LOOP               AND CONTINUE WITH NEXT PARAMETER
.ENDLOOP ANOP  ,
         DC    X'3F'                           END OF MESSAGE INDICATOR
         SPACE
         MEND
         EJECT
         MACRO
&LABEL   WRTMSG &MSG,&USE15=NO
.********************************************************************
.* THIS MACRO IS USED TO DISPLAY A MESSAGE OR A DATA LINE ON THE
.* "SYSPRINT" OUTPUT FILE.  THE REQUIRED POSITIONAL OPERAND IS THE
.* LABEL OF A "MSG" MACRO DEFINING THE MESSAGE TO BE DISPLAYED.
.* THE "CC" FIELD CONTAINS THE ASA CONTROL CHARACTER TO BE USED WITH
.* THE MESSAGE; THE PROGRAMMER SHOULD BE SURE THAT IT CONTAINS THE
.* CORRECT VALUE AT THE TIME THE MACRO IS EXECUTED.
.* SPECIFY "USE15=YES" IF THE MESSAGE TO BE DISPLAYED USES REGISTER 15
.* AS A BASE REGISTER; EXTRA CODE IS GENERATED IN THIS CASE TO SAVE
.* THE CURRENT CONTENTS OF REGISTER 15 IN THE FIRST WORD OF THE OS
.* SAVE AREA (NOTE NONSTANDARD LINKAGE DESCRIBED IN THE "WRITE"
.* SUBROUTINE OF THE PROGRAM, WHICH THIS MACRO INVOKES).
.* NOTE: A REGISTER SPECIFICATION FOR THE MESSAGE, I.E. (#), CAN BE
.*       USED IN THIS MACRO, IF THE REGISTER HAS BEEN PREVIOUSLY
.*       LOADED WITH THE ADDRESS OF A "MSG" MACRO INSTRUCTION.
.* NOTE: AS WITH THE MSG MACRO, S-TYPE CONSTANTS ARE GENERATED FOR
.*       ALL OPERANDS.
.*********************************************************************
&LABEL   DS    0H
         AIF   ('&USE15' NE 'YES').N15
         ST    15,0(,13)             SAVE REG 15 IN CASE IT IS USED
.N15     L     15,WRTADDR            GET ADDR OF MSG WRITER SUBROUTINE
         BALR  0,15                  CALL MSG WRITER, PLIST IN REG 0
         AIF   ('&MSG'(1,1) EQ '(').ZEROOFF
         DC    S(&MSG)               ADDRESS OF MESSAGE STRING
         AGO   .AFTDC
.ZEROOFF DC    S(0&MSG)              ADDRESS OF MESSAGE STRING
.AFTDC   ANOP
         MEND
         EJECT
         MACRO
&NAME    SCAN  &KEYNUM,&MAXLEN=128
.*********************************************************************
.* THIS MACRO INVOKES THE "SCAN" SUBROUTINE.  THE POSITIONAL OPERAND
.* SPECIFIES THE RELATIVE NUMBER OF THE OPERAND TO BE SCANNED FOR
.* (FOR INFORMATIONAL MESSAGE PURPOSES ONLY).  THE "MAXLEN" OPERAND
.* SPECIFIES THE MAXIMUM LENGTH THAT THE OPERAND MAY POSSESS.  IF THIS
.* OPERAND IS OMITTED, NO MAXIMUM LENGTH IS REQUIRED AND THE STRING
.* MAY CONTAIN QUOTATION-MARK SYNTAX.
.*********************************************************************
&NAME    L     R15,SCANADDR              GET ADDR OF SCAN SUBROUTINE
         BALR  R14,R15                   CALL THE SCAN SUBROUTINE
         DC    YL1(&KEYNUM,&MAXLEN)      OPERAND # AND MAX VALUE LENGTH
         MEND
         EJECT
         MACRO
&NAME    LOADSA &LOC,&ERRET=WRTERROR
.*********************************************************************
.* *** USED BY THE "WRITE" SUBROUTINE ONLY. ***
.* THIS MACRO LOADS REGISTER 15 WITH THE ADDRESS VALUE TAKEN FROM THE
.* S-TYPE (BASE-DISPLACEMENT) CONSTANT LOCATED AT THE ARGUMENT ADDRESS.
.* REGISTER 14 IS USED IN CONJUNCTION WITH 15 TO EFFECT THE CONVERSION.
.* "REGSAVE" IS USED AS A TABLE OF REGISTER VALUES FROM THE CALLER.
.*********************************************************************
&NAME    XR    R14,R14                 CLEAR REG 14
         ICM   R15,B'1100',&LOC        PICK UP S-FORMAT B2D2
         SLDL  R14,4                   SHIFT BASEREG INTO REG 14
         LTR   R14,R14                 BASE REG CANNOT BE 0
         BNP   &ERRET                  IF IT IS, GO TO ERROR ROUTINE
         SRL   R15,20                  REG 15 = DISPLACEMENT VALUE
         SLA   R14,2                   MUL REG 14 BY 4 FOR INDEX
         AL    R15,REGSAVE(R14)        BASE+DISPL=ADDR OF DATA IN R15
         MEND
         EJECT
         MACRO
&NAME    CGETMAIN
.*********************************************************************
.* THIS MACRO IS THE EQUIVALENT OF THE SYSTEM MACRO INVOCATION
.* "GETMAIN RC,LV=(0)".  HOWEVER, IT GENERATES BETTER CODE.
.* NOTE THAT REGISTER 0 MUST CONTAIN THE LENGTH TO BE GETMAINED.
.*********************************************************************
&NAME    XR    R15,R15                 CLEAR PARAMETER REGISTER
         XR    R1,R1                   CLEAR PARAMETER REGISTER
         SVC   120                     ISSUE GETMAIN SVC
         MEND
         TITLE 'XLL - PROGRAM TO SCAN FOR STRINGS IN A LOAD MODULE'
XLL      CSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SAVE  (14,12),,XLL_&SYSDATE_&SYSTIME
         LR    R12,R15             SET LOCAL BASE REGISTER
         USING XLL,R12
         L     R14,ADCOMMON
         ST    R13,4(,R14)         STORE HSA ADDRESS
         ST    R14,8(,R13)
         LR    R13,R14             ADDRESS SAVEAREA IN COMMON AREA
         USING COMMON,R13
         B     BEGIN               BRANCH AROUND RETURNING CODE
         SPACE
ADCOMMON DC    A(COMMON)           ADDRESS OF COMMON AREA
         EJECT
BEGIN    DS    0H
         TM    0(R1),X'80'         IF ONLY 1 PARM PASSED
         BO    NOALTDD             THEN NO ALTERNATE DDNAMES
         TM    4(R1),X'80'         IF MORE THAN 2 PARMS PASSED
         BZ    NOALTDD             THEN NO ALTERNATE DDNAMES
         L     R2,4(,R1)           ELSE GET ADDRESS OF ALT DD LIST
         USING ALTDDS,R2
         LH    R0,ALTDDLEN         GET LENGTH OF ALTERNATE DD LIST
         CH    R0,=Y(ALTIN-ALTDDS+8-2)
         BL    NOSYSIN
         CLI   ALTIN,C' '          IF ALTERNATE SYSIN DD SPECIFIED
         BNH   NOSYSIN             THEN
         MVC   SYSIN+40(8),ALTIN        USE IT
NOSYSIN  DS    0H
         CH    R0,=Y(ALTPRINT-ALTDDS+8-2)
         BL    NOPRINT
         CLI   ALTPRINT,C' '       IF ALTERNATE SYSPRINT DD SPECIFIED
         BNH   NOPRINT             THEN
         MVC   SYSPRINT+40(8),ALTPRINT  USE IT
NOPRINT  DS    0H
         CH    R0,=Y(ALTLIB-ALTDDS+8-2)
         BL    NOSYSLIB
         CLI   ALTLIB,C' '         IF ALTERNATE SYSLIB DD SPECIFIED
         BNH   NOSYSLIB            THEN
         MVC   SYSLIB+40(8),ALTLIB      USE IT
NOSYSLIB DS    0H
         DROP  R2
NOALTDD  DS    0H
         SPACE
         OI    DIALOGSW,PARMSCAN   INDICATE SCANNING PARM STRING
         L     R1,0(,R1)           GET ADDRESS OF EXEC PARM STRING
         LH    R2,0(,R1)           GET LENGTH OF EXEC PARM STRING
         LTR   R2,R2               IF PARM STRING IS NONZERO,
         BZ    NOTISPF             THEN...
         LA    R15,2(,R1)           SET START FOR SCAN OF PARM FIELD
         ST    R15,SCANPTR          SET START FOR SCAN OF PARM FIELD
         ALR   R15,R2               SET END OF PARM FIELD ADDRESS
         ST    R15,SCANEPTR         SET END FOR SCAN OF PARM FIELD
         SCAN  1,MAXLEN=8           SCAN FOR FIRST OPERAND OF PARM FLD
         LTR   R8,R8                CHECK FIRST PARM OPERAND
         BZ    NOTISPF              IF NONE, NOT ISPF MODE
         BM    BADRET               IF INVALID, TERMINATE
         OI    DIALOGSW,ISPFMODE+TBCREATE SET ISPF DIALOG MODE
         BCTR  R15,0                ELSE USING LENGTH OF OPERAND 1
         EX    R15,MVCPANEL         MOVE IT TO PANEL NAME
         SCAN  2,MAXLEN=8           NOW SCAN FOR 2ND OPERAND
         LTR   R8,R8                CHECK IF ALTERNATE DD FOR SYSLIB
         BZ    NOPARM2              IF NONE, USE SYSLIB
         BM    BADRET               IF INVALID, TERMINATE
         MVC   SYSLIB+40(8),BLANKS  ELSE CLEAR SYSLIB DD PREP TO MOVE
         BCTR  R15,0                USING LENGTH OF OPERAND 2
         EX    R15,MVCSYSDD         MOVE IT TO SYSLIB DD NAME
NOPARM2  DS    0H
         MVC   TABLE,PANEL         SET TABLE NAME = PANEL NAME
         LOAD  EPLOC==CL8'ISPLINK' LOAD THE ISPLINK MODULE
         ST    R0,@ISPLINK         SAVE THE ENTRY ADDRESS
* ISPEXEC VDEFINE XLLCMD CHAR(LENGTH(XLLCMD))
         LA    R14,=C'VDEFINE'     SERVICE NAME
         LA    R15,=C'(XLLCMD)'    VARIABLE NAME
         LA    R0,XLLCMD           DATA ADDRESS
         LA    R1,=C'CHAR'         DATA TYPE
         LA    R2,=A(L'XLLCMD)     DATA LENGTH
         STM   R14,R2,ISPPARMS     STORE INTO PARAMETER LIST
         OI    ISPPARM5,X'80'      INDICATE END OF LIST
         LA    R1,ISPPARMS         POINT TO PARAMETER LIST
         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK
         BALR  R14,R15             CALL ISPLINK TO DEFINE XLLCMD
* ISPEXEC VDEFINE XLLROW CHAR(LENGTH(XLLROW)) NOBSCAN
         LA    R14,=C'(XLLROW)'    VARIABLE NAME
         LA    R15,XLLROW          DATA ADDRESS
         STM   R14,R15,ISPPARM2    STORE INTO PARAMETER LIST
         LA    R14,=A(L'XLLROW)    DATA LENGTH
         LA    R15,=C'(NOBSCAN)'   INDICATE NO SCAN FOR TRAILING BLANKS
         STM   R14,R15,ISPPARM5    STORE INTO PARAMETER LIST
         OI    ISPPARM6,X'80'      INDICATE END OF LIST
         LA    R1,ISPPARMS         POINT TO PARAMETER LIST
         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK
         BALR  R14,R15             CALL ISPLINK TO DEFINE XLLROW
         B     AFTISPF
         SPACE
NOTISPF  DS    0H                  IF NOT ISPF MODE, USE SYSIN/SYSPRINT
         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))
         TM    SYSPRINT+48,X'10'   IF SYSPRINT NOT OPEN
         BNO   BADRET              THEN BOMB
         TM    SYSIN+48,X'10'      IF SYSIN NOT OPEN
         BNO   BADRET              THEN BOMB
AFTISPF  DS    0H
         SPACE
         MVC   SYSLIBD+40(8),SYSLIB+40   MOVE SYSLIB DDNAME TO DIR DCB
         NI    DIALOGSW,255-PARMSCAN     NO LONGER SCANNING PARM FIELD
         SPACE
         OPEN  (SYSLIB,(INPUT))
         TM    SYSLIB+48,X'10'     IF SYSLIB NOT OPEN
         BNO   BADRET              THEN BOMB
         L     R15,540             GET TCB ADDRESS
         L     R15,12(,R15)        GET TIOT ADDRESS
         AH    R15,SYSLIB+40       ADD TIOT OFFSET ==> TIOT ENTRY ADDR
         ICM   R15,7,12(R15)       GET JFCB ADDRESS (-16) FOR SYSLIB
         L     R14,SYSLIB+44       GET DEB ADDRESS
         TM    8(R14),X'01'        IF CONCATENATED DATA SETS,
         BZ    NOTCCAT             THEN
         LA    R1,BEGINCON          SET UP MESSAGE FOR CONCATENATION
         B     SAYHELLO            ELSE
NOTCCAT  LA    R1,BEGINMSG          SET UP MESSAGE FOR SPECIFIC DATASET
SAYHELLO WRTMSG (1),USE15=YES      SAY HI
         XR    R10,R10             CLEAR OVERLAY TABLE ADDRESS
         SPACE
***********************************************************************
* SET UP ATTENTION EXIT ROUTINE.                                      *
***********************************************************************
         SPACE
         TM    DIALOGSW,ISPFMODE   IF NOT IN ISPF DIALOG MODE
         BO    GETSYSIN            THEN
         L     R15,540              GET TCB ADDRESS
         L     R15,12(,R15)         GET TIOT ADDRESS
         AH    R15,SYSIN+40         ADD TIOT OFFSET ==> TIOT ENTRY ADDR
         TM    3(R15),X'20'         IF SYSIN ALLOCATED TO TERMINAL
         BZ    GETSYSIN             THEN
         OI    SWITCH,SYSINTRM       INDICATE SO AND SET UP ATTN EXIT
         STAX  ATTNEXIT,USADDR=COMMON,REPLACE=NO
         SPACE 3
GETSYSIN DS    0H
         NI    SWITCH,255-ATTN     INITIALIZE ATTENTION INDICATOR
         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE
         BZ    SYSINGET            THEN
* ISPEXEC TBTOP TABLE-NAME
         LA    R14,=C'TBTOP'       SERVICE NAME
         LA    R15,TABLE           TABLE NAME
         STM   R14,R15,ISPPARMS    STORE INTO PARAMETER LIST
         OI    ISPPARM2,X'80'      INDICATE END OF LIST
         LA    R1,ISPPARMS         POINT TO PARAMETER LIST
         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK
         BALR  R14,R15             CALL ISPLINK TO DISPLAY TABLE
* ISPEXEC TBDISPL TABLE-NAME PANEL-NAME
         LA    R14,=C'TBDISPL'     SERVICE NAME
         LA    R15,TABLE           TABLE NAME
         LA    R0,PANEL            PANEL NAME
         LA    R1,MSGID            MESSAGE ID
         STM   R14,R1,ISPPARMS     STORE INTO PARAMETER LIST
         OI    ISPPARM4,X'80'      INDICATE END OF LIST
         LA    R1,ISPPARMS         POINT TO PARAMETER LIST
         L     R15,@ISPLINK        GET ADDRESS OF ISPLINK
         BALR  R14,R15             CALL ISPLINK TO DISPLAY TABLE
         LTR   R15,R15             IF END KEY HIT (OR OTHER ERROR)
         BNZ   EOF                 THEN GO TO TERMINATION
         LA    R1,XLLCMD           ELSE POINT TO COMMAND FIELD AS INPUT
         B     INPUTOK             AND PROCESS INPUT.
SYSINGET DS    0H                  ELSE...
         GET   SYSIN               READ A CONTROL STATEMENT
         TM    SWITCH,ATTN         IF ATTENTION INTERRUPT OCCURRED
         BZ    INPUTOK             THEN
         NI    SWITCH,255-ATTN      RESET FLAG
         WRTMSG INPUTMSG            TELL USER INPUT NO GOOD
         B     GETSYSIN             AND TRY AGAIN.
INPUTOK  DS    0H
         ST    R1,SCANPTR          INITIALIZE SCANNING PARAMETER
         LA    R15,80(,R1)         POINT TO END OF CONTROL STATEMENT
         ST    R15,SCANEPTR        INITIALIZE SCANNING PARAMETER
         MVI   CC,C'-'             SET ASA CONTROL = TRIPLE SPACE
         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE
         BZ    ECHOMSG             THEN
         OI    DIALOGSW,TBCREATE    INDICATE REUSE OF TABLE REQUIRED
         B     AFTECHO             ELSE...
ECHOMSG  WRTMSG SYSINMSG           ECHO SYSIN - R1 ALREADY POINTS TO IT
         MVI   CC,C'0'             SET ASA DOUBLE SPACE FOR NEXT MSGS
AFTECHO  DS    0H
         SPACE
***********************************************************************
* THE "SCAN" SUBROUTINE IS INVOKED TO EXTRACT EACH KEYWORD FROM THE   *
* CONTROL STATEMENT.  ON RETURN R8 HAS THE ADDRESS OF THE KEYWORD,    *
* AND R15 HAS ITS LENGTH. IF R15 IS ZERO NO KEYWORD IS PRESENT.       *
***********************************************************************
         SCAN  0,MAXLEN=8          SCAN 1ST KEYWORD (COMMAND)
         LTR   R15,R15             IF NO COMMAND FOUND,
         BNP   GETSYSIN            THEN IGNORE THIS CARD, GET ANOTHER
         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTES
         LA    R14,COMMAND         GET READY TO SET UP COMMAND NAME
         MVC   0(8,R14),BLANKS     BLANK OUT COMMAND NAME AREA
         EX    R15,MVCCMD          MOVE COMMAND FROM STMT TO STORAGE
         LA    R6,CMDTABLE         BEGIN COMMAND TABLE SEARCH
         LA    R0,12               SET BXLE REGISTER
         LA    R1,CMDTBEND-12      SET BXLE REGISTER
CMDLOOP  EX    R15,COMPCMD         COMPARE COMMAND TO TABLE ENTRY
         BE    CMDFOUND            IF EQUAL, EXIT LOOP
         BXLE  R6,R0,CMDLOOP       ELSE CONTINUE SEARCH
CMDNF    WRTMSG CNFMSG             AT END SAY COMMAND INVALID
         B     GETSYSIN            AND GET ANOTHER CONTROL STATEMENT.
         SPACE
CMDFOUND DS    0H                  COMMAND FOUND IN TABLE - PROCESS IT
         TM    8(R6),REQLOAD       IF A MODULE MUST BE LOADED
         BZ    CMDDOIT              AND
         TM    SWITCH,LOADED        THERE ISN'T ONE
         BO    CMDDOIT              THEN
         WRTMSG NUTS                 SAY SO AND REJECT COMMAND
         B     GETSYSIN            ELSE...
CMDDOIT  DS    0H                  COMMAND OK TO PROCESS
         L     R15,8(,R6)          LOAD ADDRESS OF COMMAND PROCESSOR
         ST    R12,SAVEBASE        SAVE OUR BASE REGISTER
         BALR  R14,R15             CALL IT
         L     R12,SAVEBASE        RESTORE OUR BASE REGISTER
         B     GETSYSIN             THEN GET NEXT CONTROL STATEMENT
         SPACE 2
EOF      DS    0H                  END OF FILE ON SYSIN CONTROL STMTS
ENDRTE   EQU   EOF                 (ALSO "END" COMMAND PROCESSOR)
         SPACE
         OI    SWITCH,CLEANUP      INDICATE FINAL CLEANUP REQUIRED
         ICM   R15,15,@NAMERTE     LOAD ADDRESS OF NAME PROCESSOR
         ST    R12,SAVEBASE        SAVE OUR BASE REGISTER
         BALR  R14,R15             CALL NAME RTE TO CLEAN UP ONLY
         L     R12,SAVEBASE        RESTORE OUR BASE REGISTER
         SPACE
         TM    SWITCH,SYSINTRM     IF SYSIN ALLOCATED TO TERMINAL,
         BZ    NOUNSTAX            THEN
         STAX  ,                    CANCEL ATTENTION EXIT
NOUNSTAX DS    0H
         SPACE
         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE
         BZ    ENDNISPF            THEN
* ISPEXEC TBEND TABLE-NAME
         LA    R14,=C'TBEND'
         LA    R15,TABLE
         STM   R14,R15,ISPPARMS
         OI    ISPPARM2,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15              CLEAN UP
*
* ISPEXEC VDELETE (XLLCMD XLLROW)
*
         LA    R14,=C'VDELETE'
         LA    R15,=C'(XLLCMD XLLROW)'
         STM   R14,R15,ISPPARMS
         OI    ISPPARM2,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
         SPACE
         DELETE EPLOC==CL8'ISPLINK' RELEASE ISPLINK
         B     AFTNISPF            ELSE
         SPACE
ENDNISPF DS    0H                   NOT IN ISPF MODE
         CLOSE (SYSIN,,SYSPRINT)    SO CLOSE SYSIN AND SYSPRINT
AFTNISPF DS    0H
         CLOSE (SYSLIB)            WRAP IT UP
         XR    R15,R15             RETURN CODE(ZERO)
         B     RETURN              RETURN TO SYSTEM
         SPACE 2
BADRET   DS    0H                  COME HERE ON BAD RETURN
         SPACE
         LA    R15,12              RETURN CODE(12)
         SPACE
RETURN   L     R13,4(,R13)         MAINLINE RETURN POINT
         L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14
         SPACE 4
MVCCMD   MVC   0(0,R14),0(R8)      EXECUTED: MOVE COMMAND FROM INPUT
COMPCMD  CLC   COMMAND(0),0(R6)    EXECUTED: COMPARE CMD TO TABLE ENTRY
MVCPANEL OC    PANEL(0),0(R8)      EXECUTED: MOVE PANEL NAME FROM PARM
MVCSYSDD OC    SYSLIB+40(0),0(R8)  EXECUTED: MOVE PARM DD TO SYSLIB DCB
         SPACE
CMDTABLE DS    0X                  TABLE OF VALID XLL COMMANDS
         DC    CL8'NAME    ',YL1(NOTHING),AL3(NAMERTE)
         DC    CL8'FIND    ',YL1(REQLOAD),AL3(FINDRTE)
         DC    CL8'LIST    ',YL1(REQLOAD),AL3(LISTRTE)
         DC    CL8'MAP     ',YL1(REQLOAD),AL3(MAPRTE)
         DC    CL8'AMAP    ',YL1(REQLOAD),AL3(AMAPRTE)
         DC    CL8'WHERE   ',YL1(REQLOAD),AL3(WHERERTE)
         DC    CL8'DIR     ',YL1(NOTHING),AL3(DIRRTE)
         DC    CL8'END     ',YL1(NOTHING),AL3(ENDRTE)
CMDTBEND EQU   *                   END OF COMMAND TABLE
NOTHING  EQU   X'00'               ... NO SPECIAL REQUIREMENTS
REQLOAD  EQU   X'80'               1 = MODULE MUST BE LOADED TO EXECUTE
         SPACE
@NAMERTE EQU   CMDTABLE+8          ADDRESS OF "NAME" COMMAND PROCESSOR
         SPACE
         USING INFMJFCB-16,R15
BEGINMSG MSG   'XLL FOR ',(JFCBDSNM,44,W),' ON VOLUME ',(JFCBVOLS,6,C)
BEGINCON MSG   'XLL FOR ',(JFCBDSNM,44,W),' ET AL. (CONCATENATION)'
         DROP  R15
SYSINMSG MSG   (0(R1),80,C)        USED TO PRINT CONTROL STATEMENT
CNFMSG   MSG   '*INVALID COMMAND'
NUTS     MSG   '*NO MODULE IS CURRENTLY LOADED, COMMAND REJECTED'
INPUTMSG MSG   '*ATTENTION INTERRUPT - REENTER'
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XLL - NAME COMMAND PROCESSOR'
***********************************************************************
* "NAME" COMMAND PROCESSOR                                            *
* THIS COMMAND CAUSES A MODULE TO BE LOADED INTO MAIN STORAGE AND ITS *
* CESD ENTRIES COLLECTED IN BOTH ADDRESS AND NAME ORDER.  SYNTAX:     *
*              N(AME)  LOADNAME  CSECTNAME                            *
* WHERE: LOADNAME IS REQUIRED AND IS THE NAME OF THE LOAD MODULE ON   *
*        THE SYSLIB LIBRARY                                           *
*        CSECTNAME IS OPTIONAL AND SPECIFIES THE NAME OF THE CONTROL  *
*        SECTION TO BE PROCESSED BY SUBSEQUENT FIND COMMANDS.  IF     *
*        THIS IS OMITTED THEN ALL CSECTS ARE PROCESSED.               *
***********************************************************************
         SPACE
NAMERTE  DS    0H
         SPACE
***********************************************************************
* ESTABLISH ADDRESSABILITY HERE FOR ALL TABLES CREATED IN THIS RTE.   *
***********************************************************************
         USING ESDTABLE,R5           ADDRESS THE ESD TABLE
         USING ESDENTRY,R6           ADDRESS EACH ENTRY WITHIN IT
         USING OVLYTBL,R10           ADDRESS THE OVERLAY TBL ENTRIES
         SPACE
         ST    R14,SAVE14          SAVE RETURN REGISTER
         LR    R12,R15
         USING NAMERTE,R12
         XR    R7,R7               CLEAR READ BUFFER ADDRESS
         TM    SWITCH,CLEANUP      IF CALLED ONLY TO CLEAN UP (END),
         BO    NAMPURGE            THEN FREE UP EVERYTHING AND RETURN
         SCAN  1,MAXLEN=8          ELSE SCAN 1ST KEYWORD (LOAD MODULE)
         LTR   R8,R8               CHECK RETURN FROM SCAN
         BM    NAMPURGE            IF LOAD MODULE NAME INVALID, FAIL
         BP    NK1OK               IF NO LOAD MODULE NAME ENTERED,
         LA    R1,NOOPMSG           THEN SAY SO
         B     NAMEERR              AND FINISH
NK1OK    LA    R14,KEYWORD         ELSE READY TO SET UP LOAD MOD NAME
         MVC   0(8,R14),BLANKS     BLANK OUT NAME AREA
         BCTR  R15,0               REDUCE LOAD NAME LENGTH FOR EXECUTES
         EX    R15,MVCNAME         MOVE NAME FROM STMT TO STORAGE
         MVC   CSECT,BLANKS        INIT CSECT NAME = BLANK
         SCAN  2,MAXLEN=8          SCAN 2ND KEYWORD (CSECT NAME)
         LTR   R8,R8               CHECK RETURN FROM SCAN
         BM    NAMPURGE            IF CSECT NAME INVALID, FAIL
         BZ    NOCSECT             IF CSECT OMITTED, PROCESS WITHOUT IT
         LA    R14,CSECT           ELSE READY TO SET UP CSECT NAME
         BCTR  R15,0               REDUCE CSECTNAME LENGTH FOR EXECUTES
         EX    R15,MVCNAME         MOVE CSECT NAME FROM STMT TO STORAGE
NOCSECT  DS    0H
         CLI   LOADMOD,C' '        IF NO CURRENT LOAD MODULE
         BE    NAFREE              THEN DON'T FREE OR DELETE ANYTHING
         CLC   LOADMOD,KEYWORD     ELSE IF NEW LOAD MOD = OLD LOAD MOD
         BE    ENDLNKS             THEN KEEP IT, DON'T DO ANOTHER LOAD
         BAL   R14,FREELOAD        ELSE FREE CURRENT MODULE STORAGE
NAFREE   DS    0H                  NOW WE HAVE NO LOAD MODULE AROUND
         MVC   LOADMOD,KEYWORD     SET UP LOAD MODULE NAME
         BLDL  SYSLIB,BLDLLIST     SEE IF LOAD MODULE EXISTS IN LIBRARY
         LTR   R15,R15             IF BLDL SUCCESSFUL
         BZ    BLDL0               THEN GO AHEAD
         L     R1,BLDLXMSG-4(R15)  ELSE GET MESSAGE FOR BLDL ERROR
         B     NAMEERR             AND GO TO DISPLAY ERROR MESSAGE
         SPACE
BLDL0    DS    0H                  BLDL SUCCESSFUL - CONTINUE
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         AGO   .NOLMTST            TEST FOR LOAD MOD VALIDITY IS N.G.
         MVC   TESTBYTE,PDS2INDC   GET INDICATOR BYTE
         NI    TESTBYTE,B'00011111' CLEAR EXTRANEOUS BITS
         CLI   TESTBYTE,22         TO GET # OF USER DATA HALFWORDS
         BE    ISAMOD              THIS MUST BE EXACTLY 22 OR ELSE...
         LA    R1,BLDL0MSG          SAY SO
         B     NAMEERR              AND FINISH
ISAMOD   DS    0H
.NOLMTST ANOP
         TM    PDS2ATR1,PDS2OVLY   IF MODULE HAS THE OVERLAY ATTRIBUTE
         BNO   NOTOVLY             THEN
         XR    R2,R2                CLEAR INSERT REG
         IC    R2,PDS2NL            GET NUMBER OF OVERLAY SEGMENTS
         LA    R2,1(,R2)            ADD 1 TO INCLUDE ENTRY ZERO
         SLA   R2,OVSHIFT           CONVERT TO LENGTH OF ALL ENTRIES
         LR    R0,R2                THIS IS THE REQUIRED LENGTH
         CGETMAIN ,                 GET STORAGE FOR OVERLAY TABLE
         LTR   R15,R15              IF STORAGE NOT AVAILABLE,
         BNZ   NOTENUF              THEN BLOW UP. ELSE...
*** ASSUME R15 = 0
         ST    R15,LOADADDR         CLEAR LOAD MODULE ADDRESS
         LR    R10,R1               SET ADDRESS OF OVERLAY TABLE
         LR    R0,R10               ADDRESS OF OVERLAY TABLE
         LR    R1,R2                LENGTH OF OVERLAY TABLE
         XR    R14,R14              CLEAR FROM-ADDRESS REG
*** ASSUME R15 = 0 (RETURN CODE FROM SUCCESSFUL GETMAIN)
******** XR    R15,R15              CLEAR FROM-LENGTH REG
         MVCL  R0,R14               CLEAR ALL OF THE TABLE TO ZEROES
         ST    R2,OVTBLEN           STORE LENGTH OF REQUIRED STORAGE
         MVI   CURSEG#+1,0          SET CURRENT SEGMENT NUMBER = 0
         MVC   MAXSEG#+1(1),PDS2NL  SET MAXIMUM SEGMENT NUMBER
         OI    SWITCH,NEWSEG        INDICATE A NEW SEGMENT WILL COME
         B     AFTOVLY              DON'T SET TOTAL MODULE LENGTH
NOTOVLY  DS    0H
         SPACE
***********************************************************************
* FOR A NON-OVERLAY MODULE,                                           *
* ALLOCATE STORAGE FOR THE LOAD MODULE ITSELF USING THE TOTAL LENGTH  *
* FROM THE PDS DIRECTORY ENTRY.                                       *
***********************************************************************
         SPACE
         XR    R0,R0               CLEAR INSERT REG
         ICM   R0,7,PDS2STOR       LENGTH OF MAIN STORAGE FOR MODULE
         ST    R0,LOADLEN          STORE LENGTH OF LOAD MODULE
         CGETMAIN ,                GET A BUFFER FOR THE LOAD MODULE
         LTR   R15,R15             IF STORAGE NOT AVAILABLE
         BNZ   NOTENUF             THEN GO TO SAY SO
         ST    R1,LOADADDR         ELSE SAVE ADDRESS OF LOAD MOD BUFFER
         AL    R1,LOADLEN          ADD LENGTH OF LOAD MODULE
         SPACE
AFTOVLY  DS    0H
         SPACE
***********************************************************************
* SET UP TO READ LOAD MODULE RECORDS BY ISSUING FIND MACRO USING THE  *
* TTR FROM THE BLDL DIRECTORY DATA.                                   *
* REFERENCE FOR LOAD MODULE RECORD FORMATS: LINKAGE EDITOR LOGIC      *
***********************************************************************
         SPACE 2
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         FIND  SYSLIB,LOADMOD+8,C  FIND START OF MEMBER USING TTR
         LTR   R15,R15             IF FIND FAILED,
         BZ    FINDOK              THEN
         LA    R1,FINDMSG           SAY SO
         B     NAMEERR              AND FINISH
FINDOK   DS    0H                  ELSE READY TO READ DATA
         LH    R0,SYSLIB+62        GET LOAD LIBRARY BLOCKSIZE
         CGETMAIN ,                USE IT TO GET A READ BUFFER
         LTR   R15,R15             IF NOT ENOUGH STORAGE
         BNZ   NOTENUF             THEN GO TO SAY SO
         LR    R7,R1               ELSE SET READ BUFFER ADDRESS
         NI    SWITCH,255-CESDRECS-INTEXT-SEGTAB INITIALIZE SWITCH
* BYPASS END-OF-FILE / CONTROL-RECORD CHECK, GO READ FIRST MODULE REC
         B     READ1ST              GO READ FIRST MODULE RECORD
         SPACE
READLOOP DS    0H                  READ NON-TEXT LOAD MODULE RECORDS
         TM    0(R7),X'08'         IF END-OF-MODULE ON IN LAST REC READ
         BO    ENDRECS             THEN GO TO END-OF-DATA ROUTINE
         LTR   R10,R10             ELSE IF PROCESSING AN OVERLAY MODULE
         BZ    READ1ST              AND
         TM    0(R7),X'04'           END-OF-SEGMENT ON IN LAST REC READ
         BZ    READ1ST                THEN
         OI    SWITCH,NEWSEG           INDICATE A NEW SEGMENT IS COMING
READ1ST  DS    0H                  ELSE
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         READ  DECB,SF,,(R7),'S',MF=E  READ RECORD (R7 -> READ BUFFER)
         CHECK DECB                WAIT FOR I/O TO COMPLETE
         TM    0(R7),X'01'         IF THIS IS A CONTROL RECORD,
         BO    CONTROL             THEN PROCESS CONTROL & TEXT RECORD
         TM    0(R7),X'20'         ELSE IF THIS IS A CESD RECORD,
         BNO   READLOOP            THEN PROCESS, ELSE GO GET ANOTHER.
         SPACE
THISCESD DS    0H                  THIS IS A CESD RECORD
         OI    SWITCH,CESDRECS     IF WE GOT A CESD, INDICATE SO
         LA    R3,8(,R7)           INIT R3 -> 1ST ESD ENTRY IN RECORD
         LH    R4,6(,R7)           GET COUNT OF ESD DATA IN RECORD
         ALR   R4,R3               R4 -> END OF ESD ENTRIES IN RECORD
CESDLOOP DS    0H                  LOOP TO PROCESS EACH ENTRY IN RECORD
         CR    R3,R4               WHEN NO MORE ESD'S IN THIS RECORD,
         BNL   READLOOP             GO READ ANOTHER LOAD MODULE RECORD
         MVC   TESTTYPE,8(R3)      PICK UP ESD TYPE INDICATION
         NI    TESTTYPE,X'0F'      ZERO OUT THE SUBCLASSIFICATION BITS
         CLI   TESTTYPE,ESDPC      IF THIS ENTRY IS PC (PRIVATE CODE)
         BE    ESDTYPOK             THEN GO PROCESS IT
         CLI   TESTTYPE,ESDSD      IF THIS ENTRY IS SD (SECTION DEF.)
         BE    ESDTYPOK             THEN GO PROCESS IT
         CLI   TESTTYPE,ESDCM      IF THIS ENTRY IS CM (COMMON)
         BE    ESDTYPOK             THEN GO PROCESS IT
         LA    R3,16(,R3)          ELSE BUMP TO NEXT CESD ENTRY
         B     CESDLOOP            CONTINUE WITH NEXT ENTRY
ESDTYPOK DS    0H
         SPACE 2
***********************************************************************
* WE STORE THE ESD ENTRIES IN THE TABLE IN ASCENDING ORDER OF         *
* ALPHABETIC NAMES, BUT LINKED IN ASCENDING ORDER OF RELATIVE         *
* ADDRESSES.  A SCAN FOR NAME MAY BE DONE BY MEANS OF A BINARY SEARCH *
* (ALTHOUGH THIS HAS YET TO BE IMPLEMENTED), WHEREAS A SEARCH BY      *
* RELATIVE ADDRESS MUST BE DONE BY MEANS OF CHAINING THROUGH THE LINK *
* FIELDS.  NOTE THAT FOR A PRIVATE CODE ENTRY THE NAME $PRIVATE IS    *
* USED IN THE TABLE.                                                  *
***********************************************************************
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         ICM   R15,15,ESDBUFAD     GET ADDRESS OF OUR ESD TABLE BUFFER
         BNZ   GOTESDBF            IF WE DON'T HAVE ONE YET, THEN...
         LA    R14,INITLNTH+ESDHDRLN GET LENGTH FOR INITIAL BUFFER
         LR    R0,R14
         CGETMAIN ,                  GET STORAGE FOR ESD TABLE
         LTR   R15,R15               IF WE DIDN'T GET IT
         BNZ   NOTENUF               THEN GO TO SAY SO
         ST    R1,ESDBUFAD           ELSE SET ESD TABLE ADDRESS
         LR    R5,R1                 R5 -> ESD TABLE
         ST    R14,ESDBUFLN          LENGTH OF ESD BUFFER TO FREE
         ST    R14,ESDTBLEN          LENGTH OF ESD BUFFER FOR OUR USE
         LA    R0,ESDHDRLN           INITIALIZE OFFSET OF
         ST    R0,ESDAVAIL            FIRST UNUSED ENTRY SLOT
***  ASSUME  R15 = ZERO  (RETURN CODE FROM SUCCESSFUL GETMAIN)
         ST    R15,ESD#ENTS          INITIAL NUMBER OF ENTRIES = 0
         ST    R15,ESDLKHDR          CLEAR LINK POINTER
GOTESDBF DS    0H                  WE NOW HAVE AN ESD BUFFER
         LA    R15,ESDENTLN        GET OFFSET OF END OF NEXT SLOT
         A     R15,ESDAVAIL        IF NEXT AVAILABLE SLOT
         C     R15,ESDTBLEN         IS NOT WITHIN END OF BUFFER,
         BNH   ESDROOM             THEN...
* ADD LENGTH FOR NEW ENTRIES TO THE BUFFER LENGTH
         LA    R0,INITLNTH           COMPUTE LENGTH OF NEW BUFFER
         AL    R0,ESDTBLEN           AND PUT IT IN
         ST    R0,ESDTBLEN            LENGTH FIELD OF OLD BUFFER
         CGETMAIN ,                  GET A NEW BUFFER
         LTR   R15,R15               IF WE DIDN'T GET IT
         BNZ   NOTENUF               THEN GO TO SAY SO
         LR    R0,R1                    ADDRESS OF NEW BUFFER
         L     R1,ESDTBLEN-ESDTABLE(,R5) LENGTH OF NEW BUFFER
         L     R14,ESDBUFAD             ADDRESS OF OLD BUFFER
         L     R15,ESDBUFLN              LENGTH OF OLD BUFFER
         LR    R5,R0                 POINT TO THE NEW BUFFER NOW
         MVCL  R0,R14                MOVE OLD BUFFER DATA TO NEW BUFFER
         L     R1,ESDBUFAD           GET ADDRESS OF OLD BUFFER
         L     R0,ESDBUFLN           GET LENGTH OF OLD BUFFER
         FREEMAIN R,A=(1),LV=(0)     FREE THE OLD BUFFER
         ST    R5,ESDBUFAD           STORE THE NEW ESD BUFFER ADDRESS
         MVC   ESDBUFLN,ESDTBLEN     STORE THE NEW ESD BUFFER LENGTH
ESDROOM  DS    0H                  WE NOW HAVE ROOM TO ADD NEW ENTRIES
         L     R6,ESDAVAIL         GET OFFSET OF UNUSED ESD SLOT
         ALR   R6,R5               CONVERT TO ADDR OF END OF LAST ENTRY
         LA    R0,ESDHDRLN(,R5)    SET ADDR OF 1ST ENTRY FOR INSERTION
         SPACE
ESDADDLP DS    0H                  WE NOW HAVE ROOM TO ADD NEW ENTRIES
***********************************************************************
* CHECK EACH CURRENT ESD TABLE ENTRY.  IF THE SORTING FIELD IN THIS   *
* ENTRY IS LESS THAN OR EQUAL TO THE SORTING FIELD IN THE ENTRY BEING *
* ADDED, THEN INSERT THE NEW ENTRY HERE.  OTHERWISE KEEP MOVING       *
* BACKWARDS UNTIL SUCH AN ENTRY IS FOUND OR WE REACH THE BEGINNING OF *
* THE ENTRIES.                                                        *
***********************************************************************
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         SH    R6,=Y(ESDENTLN)     BUMP TO PREVIOUS ESD TABLE ENTRY
         CR    R6,R0               IF IT PUTS US IN FRONT OF 1ST ENTRY,
         BL    ESDADDHR            THEN GO TO INSERT NEW ENTRY HERE
         CLC   ESDNAME,ESDNAME-ESDENTRY(R3) ELSE COMPARE THIS ENTRY
         BNH   ESDADDHR            IF THIS IS THE PLACE, GO TO INSERT
         MVC   ESDENTRY+ESDENTLN(ESDENTLN),ESDENTRY    ELSE MOVE ENTRY
         B     ESDADDLP             UP TO NEXT SLOT AND TRY NEXT LOC.
ESDADDHR DS    0H                  TIME TO INSERT THE NEW ENTRY HERE
         LA    R6,ESDENTLN(,R6)    BUMP TO POINT TO NEW ENTRY SLOT
         MVC   ESDENTRY(16),0(R3)  MOVE FIXED CESD ENTRY DATA TO SLOT
         XR    R0,R0               CLEAR INSERT REG
         ICM   R0,7,ESDADDR        GET RELADDR OF ESD CONTROL SECTION
         XR    R14,R14
         ICM   R14,7,ESDLEN        GET LENGTH OF ESD CONTROL SECTION
         ALR   R0,R14              RELADDR + LENGTH ...
         ST    R0,ESDNADDR          GIVES ADDRESS OF DATA FF. CSECT
         CLC   ESDNAME(8),BLANKS   IF NAME IS BLANK,
         BNE   NOTBLANK            THEN...
         CLI   ESDTYPE,ESDPC         IF PRIVATE CODE
         BNE   NOTPRIV                  THEN
         MVC   ESDNAME(8),$PRIVATE        CALL IT PRIVATE CODE
NOTPRIV  DS    0H                  ELSE
         CLI   ESDTYPE,ESDPCOV       IF PRIVATE CODE MARKED DELETE
         BNE   NOTBLANK              THEN
         TM    SWITCH,SEGTAB           IF A SEGMENT TABLE NOT FOUND YET
         BO    SETENTAB                  THEN
         MVC   ESDNAME(8),$SEGTAB          CALL IT A SEGMENT TABLE
         OI    SWITCH,SEGTAB               AND INDICATE THAT ONE EXISTS
         B     NOTBLANK                  ELSE
SETENTAB MVC   ESDNAME(8),$ENTAB           CALL IT AN ENTRY TABLE
NOTBLANK DS    0H
         SPACE 2
***********************************************************************
* IF WE ARE PROCESSING AN OVERLAY MODULE, WE MUST COMPUTE THE TOTAL   *
* CUMULATIVE STORAGE REQUIRED FOR EACH SEGMENT OF THE MODULE.  THIS   *
* IS DONE BY ADDING THE LENGTH OF THE CONTROL SECTION TO THE          *
* ADDRESS OF THE CONTROL SECTION, GIVING THE LARGEST POSSIBLE UPPER   *
* BOUND, AND PLACING THE MAXIMUM SUCH VALUE IN THE                    *
* APPROPRIATE ENTRY IN THE OVERLAY TABLE.                             *
***********************************************************************
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         LTR   R10,R10             IF OVERLAY MODULE
         BZ    ESDNOTOV            THEN...
         XR    R1,R1               CLEAR INSERT REG
         IC    R1,ESDSEGNO          GET SEGMENT NUMBER FOR THIS CSECT
         SLA   R1,OVSHIFT           CONVERT TO INDEX
         XR    R15,R15
         ICM   R15,7,ESDADDR        GET CURRENT RELATIVE ADDRESS
         L     R0,OVSEGHI(R1)       GET HIGH BOUND OF SEGMENT SO FAR
         LTR   R0,R0                IF NO SEGMENT DATA YET
         BZ    ESDSETOF             OR
         CL    R15,OVSEGLO(R1)       ESD LESS THAN CURRENT LOW BOUND
         BNL   ESDAFTST               THEN
ESDSETOF ST    R15,OVSEGLO(R1)         SET NEW LOW BOUND OF SEGMENT
ESDAFTST DS    0H
         L     R15,ESDNADDR         GET ENDING ADDRESS OF THIS CSECT
         CLR   R15,R0               IF THIS EXCEEDS PREV HIGH BOUND
         BNH   ESDNOTOV             THEN
         LA    R15,7(,R15)           ROUND UP TO DOUBLEWORD BOUNDARY
         N     R15,=X'FFFFFFF8'      AND
         ST    R15,OVSEGHI(R1)       STORE AS NEW SEGMENT HIGH BOUND
ESDNOTOV DS    0H
         SPACE 2
         LA    R15,ESDENTLN        LENGTH OF AN ESD ENTRY
         A     R15,ESDAVAIL        PLUS LOCATION OF SLOT JUST FILLED
         ST    R15,ESDAVAIL        GIVES UPDATED OFFSET OF UNUSED SLOT
         LA    R15,1
         A     R15,ESD#ENTS
         ST    R15,ESD#ENTS        UPDATE NUMBER OF ESD ENTRIES BY 1
         LA    R3,16(,R3)          BUMP UP INPUT CESD ENTRY POINTER
         B     CESDLOOP            GO PROCESS NEXT CESD ENTRY.
         SPACE 4
CONTROL  DS    0H                  THIS IS A CONTROL RECORD
         SPACE
***********************************************************************
* LOAD MODULE CONTROL RECORD PROCESSING:  THE CONTROL RECORD CONTAINS *
* A CHANNEL COMMAND WORD (CCW) AT LOCATION 8 THAT CAN BE USED TO READ *
* THE TEXT RECORD WHICH FOLLOWS.  WE USE THE DATA ADDRESS PORTION OF  *
* THIS CCW TO DETERMINE THE OFFSET IN THE LOAD MODULE BUFFER WHERE    *
* THE TEXT IS TO BE LOADED, AND THE BYTE COUNT TO GET THE LENGTH OF   *
* THE BLOCK OF TEXT, WHICH IS THEN READ DIRECTLY INTO THE LOAD MODULE *
* BUFFER AT THE SPECIFIED RELATIVE LOCATION.                          *
***********************************************************************
         SPACE
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         XR    R2,R2               CLEAR INSERT REG
         ICM   R2,7,9(R7)          GET DATA ADDRESS FROM CCW IN RECORD
         LH    R4,14(,R7)          GET BYTE COUNT (LENGTH) FROM CCW
         LTR   R10,R10             IF MODULE IS IN OVERLAY STRUCTURE
         BZ    CTLNOTOV            THEN...
         TM    SWITCH,NEWSEG        IF THIS WILL BE 1ST OF NEW SEGMENT
         BZ    SAMESEG              THEN
         NI    SWITCH,255-NEWSEG     RESET FLAG
ADDAGAIN DS    0H                    TO PREVENT INFINITE LOOPING,
         TM    SWITCH,ATTN           CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE              WHILE WE...
         LA    R14,1                 ADD 1 TO CURRENT-SEGMENT NUMBER
         AH    R14,CURSEG#           UNTIL NON-NULL SEGMENT FOUND
         STH   R14,CURSEG#           GET CURRENT SEGMENT NUMBER
         SLA   R14,OVSHIFT           CONVERT TO INDEX INTO SEGMENT TBL
         L     R0,OVSEGHI(R14)       GET HIGH BOUND OF SEGMENT
         S     R0,OVSEGLO(R14)       SUBTRACT LOW BOUND OF SEGMENT
         ST    R0,OVSEGLEN(R14)      GIVES LENGTH OF THIS SEGMENT
         BZ    ADDAGAIN              IF ZERO, SKIP SEGMENT, USE NEXT 1
SAMESEG  LH    R14,CURSEG#          NOW GET CURRENT SEGMENT NUMBER
         SLA   R14,OVSHIFT          CONVERT TO INDEX INTO SEGMENT TABLE
         L     R1,OVSEGADR(R14)     GET ADDR OF BUFFER FOR THIS SEG.
         LTR   R1,R1                IF NO STORAGE ALLOCATED FOR IT YET
         BNZ   CTLGOTIT             THEN
         L     R0,OVSEGLEN(R14)      GET LENGTH OF THIS SEGMENT
         CGETMAIN ,                  ACQUIRE THE STORAGE
         LTR   R15,R15               IF STORAGE NOT AVAILABLE
         BNZ   NOTENUF               THEN BLOW UP, ELSE....
         ST    R1,OVSEGADR(R14)      SAVE ADDRESS OF STORAGE BUFFER
CTLGOTIT DS    0H                   R1 NOW POINTS TO SEGMENT BUFFER
         SL    R2,OVSEGLO(R14)      SUBTRACT LOW BOUND FROM DATA ADDR
         ALR   R2,R1                ADD BUF ADDR GIVING OFFSET IN BUF
         B     CTLAFTOV             AND CONTINUE
CTLNOTOV DS    0H                  ELSE NON-OVERLAY MODULE...
         AL    R2,LOADADDR          JUST ADD BUFFER ADDR TO GET OFFSET
CTLAFTOV DS    0H                  NON-OVERLAY MODULE...
         OI    SWITCH,INTEXT       INDICATE READING TEXT IN CASE OF EOF
         READ  DECB,SF,,(R2),(R4),MF=E  READ TEXT RECORD INTO BUFFER
         CHECK DECB                 USING OFFSET & LENGTH FROM CTL CCW
         NI    SWITCH,255-INTEXT   TURN OFF TEXT READING INDICATOR
         B     READLOOP            GO TO GET ANOTHER LOAD MODULE RECORD
         SPACE 3
ENDRECS  DS    0H                  END OF FILE ON LOAD MODULE RECORDS
         SPACE
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    NAMPURGE
         TM    SWITCH,INTEXT       IF EOF ENCOUNTERED WHEN TEXT EXPCTD
         BO    IOERROR             THEN ERROR - SAY SO. ELSE...
         TM    SWITCH,CESDRECS     IF NO CESD RECORDS IN LOAD MODULE
         BZ    IOERROR             THEN ERROR - SAY SO. ELSE...
***********************************************************************
* FINISH PROCESSING THE EXTERNAL SYMBOL DICTIONARY TABLE ENTRIES.     *
***********************************************************************
         L     R15,ESDAVAIL        GET OFFSET OF AVAILABLE SLOT
         ALR   R15,R5              CONVERT OFFSET TO VIRTUAL ADDRESS
         BCTR  R15,0               CONVERT TO BXLE-COMPATIBLE FORMAT
         ST    R15,ESDENDAD        STORE END-OF-ESD-ENTRIES ADDRESS
         SPACE 4
***********************************************************************
* AFTER THE ESD TABLE HAS BEEN BUILT AND ALL ENTRIES INSERTED, DO FOR *
* EACH ENTRY THE FOLLOWING:                                           *
* SET THE LINK POINTER BY ORDER OF CONTROL SECTION OFFSET             *
* CONCATENATED WITH SEGMENT NUMBER.  IN THIS WAY THE CESD ENTRIES     *
* WILL BE ORDERED IN A SINGLY LINKED LIST BY (1) RELATIVE ADDRESS AND *
* (2) OVERLAY SEGMENT.                                                *
***********************************************************************
         SPACE 2
         LA    R6,ESDHDRLN(,R5)    POINT TO WHERE 1ST ENTRY IS
         LA    R0,ESDENTLN         SET BXLE REGISTER
         L     R1,ESDENDAD         SET BXLE REGISTER
LNKLOOP1 DS    0H                  LOOP UNTIL OUT OF INPUT ENTRIES
         LA    R14,ESDLKHDR-ESDTABLE(,R5) POINT TO 1ST ENTRY IN CHAIN
LNKLOOP2 ICM   R15,15,0(R14)       POINT TO ESD ENTRY TO COMPARE
         BZ    LNKINSRT            IF NO MORE, GO INSERT @ END OF CHAIN
         CLC   ESDARG-ESDENTRY(L'ESDARG,R15),ESDARG   COMPARE ARGUMENTS
         BH    LNKINSRT            IF NOT THE PLACE, THEN GET THE NEXT
         LA    R14,ESDLINKP-ESDENTRY(,R15)  CANDIDATE FOR INSERTION AND
         B     LNKLOOP2                     TRY IT.
LNKINSRT DS    0H                  WHEN PLACE FOUND TO INSERT...
         MVC   ESDLINKP,0(R14)     LINK NEXT ENTRY TO OUR ENTRY
         ST    R6,0(,R14)          LINK US TO PREVIOUS ENTRY
         BXLE  R6,R0,LNKLOOP1      CONTINUE WITH NEXT INPUT ENTRY
         SPACE 2
ENDLNKS  DS    0H                  ESD TABLE ALL SET UP, NO MORE WORK
         SPACE
         TM    SWITCH,LOADED       IF LOAD MODULE PREVIOUSLY LOADED
         BZ    LOADIT              THEN...
         LA    R1,LOADMSGA          GO TO SAY IT IS BEING RETAINED
         B     AFTLDED             ELSE...
LOADIT   BAL   R14,FREEREAD         FREE THE READ BUFFER
         OI    SWITCH,LOADED        INDICATE THAT THE MODULE IS LOADED
         XR    R0,R0                CLEAR INSERT REG
         IC    R0,PDS2CNCT          GET BLDL CONCATENATION NUMBER
         MH    R0,=H'20'            CONVERT TO INDEX INTO TIOT ENTRY
         AH    R0,SYSLIB+40         ADD TIOT OFFSET TO GET IXD OFFSET
         L     R15,540              GET TCB ADDRESS
         L     R15,12(,R15)         GET TIOT ADDRESS
         ALR   R15,R0               ADD TO TIOT ADDR TO GET ENTRY ADDR
         ICM   R15,7,12(R15)        GET JFCB ADDRESS (-16) FOR SYSLIB
         LA    R1,LOADMSGG          GO SAY IT IS LOADED OK
AFTLDED  WRTMSG (R1),USE15=YES     TELL USER IT'S LOADED 1 WAY OR OTHER
***********************************************************************
* NOW SET STARTING ABSOLUTE ADDRESS OF THE CSECT BEING PROCESSED.     *
* IF NO CSECT SPECIFIED, THEN USE ADDRESS OF ENTIRE LOAD MODULE.      *
***********************************************************************
         SPACE
         CLI   CSECT,C' '          IF NO SPECIFIC CSECT REQUESTED
         BE    WHOLEMOD            THEN USE ENTIRE MODULE. ELSE...
         L     R5,ESDBUFAD         ADDRESS THE ESD TABLE
         LA    R6,ESDHDRLN(,R5)    POINT TO BEGINNING OF ESD TABLE
         LA    R0,ESDENTLN         SET BXLE REGISTER
         L     R1,ESDENDAD         SET BXLE REGISTER
CFNLOOP  DS    0H                  UNTIL END OF ESD ENTRIES (ALPH ORD)
         CLC   CSECT,ESDNAME       COMPARE CSECT NAME WITH ENTRY NAME
         BE    CSECTF              IF MATCH, EXIT LOOP
         BXLE  R6,R0,CFNLOOP       ELSE CONTINUE WITH NEXT ESD ENTRY
CSECTNF  DS    0H                  IF CSECT NAME NOT FOUND...
         WRTMSG CSNFMSG             SAY SO
         MVC   CSECT,BLANKS         AND USE ENTIRE LOAD MODULE INSTEAD
         B     WHOLEMOD            ELSE...
CSECTF   DS    0H                   STORE ADDRESS OF ACTIVE ESD ENTRY
         XR    R15,R15              CLEAR INSERT REG
         ICM   R15,7,ESDADDR        GET OFFSET OF CONTROL SECTION
         LTR   R10,R10              IF OVERLAY MODULE
         BZ    CSNOTOV              THEN...
         XR    R1,R1                 CLEAR INSERT REG
         IC    R1,ESDSEGNO           GET SEGMENT NUMBER
         SLA   R1,OVSHIFT            CONVERT TO INDEX
         SL    R15,OVSEGLO(R1)       CVT MOD OFFSET TO OFF WITHIN SEG
         AL    R15,OVSEGADR(R1)      ADD VIRTUAL ADDR OF SEGMENT BUFFER
         B     CSAFTOV              ELSE...
CSNOTOV  DS    0H                    (NOT OVERLAY)...
         AL    R15,LOADADDR          ADD VIRTUAL ADDRESS OF LOAD MODULE
CSAFTOV  DS    0H
         ST    R15,ADRSTART         R15 GIVES STARTING ADDRESS OF CSECT
         ST    R6,CURRESD           SAVE ESD ENTRY ADDR FOR THIS CSECT
         B     GOODRET              RETURN TO MAINLINE
         SPACE
WHOLEMOD DS    0H                  NO VALID CSECT ENTERED, USE ALL.
         LTR   R10,R10             IF OVERLAY MODULE
         BZ    WHOLESET            THEN
         XR    R0,R0                MAKE A ZERO
         ST    R0,CURRESD           CLEAR ESD ENTRY ADDRESS
         ST    R0,ADRSTART          CLEAR STARTING ADDRESS
         B     GOODRET             ELSE
WHOLESET DS    0H                  (NOT OVERLAY - USE ENTIRE MODULE)
         MVC   ADRSTART,LOADADDR    STARTING ADDRESS = LOAD MOD ADDR
         B     GOODRET
         EJECT
NOTENUF  DS    0H                  INSUFFICIENT STORAGE
         SPACE
         LA    R1,NOSTRG           GO SAY THERE'S NOT ENOUGH STORAGE
         B     NAMEERR             AND GO FINISH UP.
         SPACE
IOERROR  DS    0H                  HERE WHEN LOGICAL I/O ERROR IN MOD
         SPACE
         LA    R1,IOERMSG          GO TO SAY SOMETHING'S WRONG WITH
******** B     NAMEERR              THE LOAD MODULE
         EJECT
NAMEERR  DS    0H
         SPACE
***********************************************************************
* FAILURE IN "NAME" COMMAND PROCESSING - CLEAR OUT ALL PREVIOUSLY SET *
* FIELDS ASSOCIATED WITH LOAD MODULE OR CSECT NAMES                   *
***********************************************************************
         SPACE
         WRTMSG (R1)               DISPLAY ERROR MESSAGE
         SPACE
NAMPURGE DS    0H                  GO HERE IF NO MSG TO BE DISPLAYED
         SPACE
         NI    SWITCH,255-ATTN
         MVC   LOADMOD,BLANKS      CLEAR MODULE NAME
         MVC   CSECT,BLANKS        CLEAR CSECT NAME
         BAL   R14,FREELOAD        FREE CURRENT MODULE STORAGE IF ANY
         B     COMMONRT            RETURN TO MAINLINE
         EJECT
FREELOAD DS    0H                  SUBROUTINE TO FREE MODULE STORAGE
         SPACE
         TM    SWITCH,LOADED       IF A MODULE IS STILL LOADED
         BZ    FREEOVLY            THEN
         ICM   R1,15,LOADADDR        GET ADDRESS OF LOAD MODULE
         BZ    FREEOVLY              IF NONE (OVERLAY), SKIP FREE
         L     R0,LOADLEN            GET LENGTH OF LOAD MODULE
         FREEMAIN R,LV=(0),A=(1)     DELETE IT
         SPACE
FREEOVLY DS    0H
         LTR   R10,R10             IF THERE IS AN OVERLAY TABLE
         BZ    FREEESD             THEN
* FIRST, FREE ALL THE SEGMENT BUFFERS
         LH    R4,MAXSEG#          GET NUMBER OF OVERLAY SEGMENTS
         XR    R2,R2               INITIALIZE INDEX REGISTER
FREEOVLP LA    R2,OVENTLB(,R2)     INCREMENT INDEX REGISTER
         L     R1,OVSEGADR(R2)     GET ADDRESS OF SEGMENT BUFFER
         LTR   R1,R1               IF THERE IS ONE,
         BZ    NOFROVSG            THEN
         L     R0,OVSEGLEN(R2)      GET LENGTH OF SEGMENT BUFFER
         FREEMAIN R,LV=(0),A=(1)    AND FREE IT
NOFROVSG BCT   R4,FREEOVLP         CONTINUE FOR EVERY SEGMENT DEFINED
* NOW, FREE THE OVERLAY TABLE
         L     R0,OVTBLEN          GET LENGTH OF OVERLAY TABLE
         LR    R1,R10              GET ADDRESS OF OVERLAY TABLE
         FREEMAIN R,LV=(0),A=(1)   FREE IT
         SPACE
FREEESD  DS    0H
         NI    SWITCH,255-LOADED   SET FLAG OFF
         XR    R10,R10             CLEAR OVERLAY TABLE ADDRESS
         ST    R10,LOADADDR        CLEAR LOAD MODULE ADDRESS
         ST    R10,LOADLEN         CLEAR LOAD MODULE LENGTH
         ST    R10,CURRESD         CLEAR ESD ENTRY ADDRESS
         ST    R10,ADRSTART        CLEAR CSECT FIELDS
         ICM   R1,15,ESDBUFAD      IF THERE WAS AN ESD TABLE ALLOCATED
         BZ    FREEREAD            THEN
         L     R0,ESDBUFLN           GET LENGTH OF IT
         FREEMAIN R,LV=(0),A=(1)     FREE IT
         ST    R10,ESDBUFAD          CLEAR ITS ADDRESS
         ST    R10,ESDBUFLN          AND CLEAR ITS LENGTH
         SPACE
FREEREAD DS    0H                  SUBROUTINE TO FREE THE READ BUFFER
         LTR   R1,R7               GET ADDRESS OF THE READ BUFFER
         BZR   R14                 IF THERE IS ONE, THEN
         LH    R0,SYSLIB+62          PICK UP BLOCKSIZE=LENGTH OF BUFFER
         FREEMAIN R,LV=(0),A=(1)     FREE THE READ BUFFER
         XR    R7,R7                 AND CLEAR ITS POINTER
         BR    R14                 RETURN TO CALLER
         EJECT
MVCNAME  MVC   0(0,R14),0(R8)      EXECUTED: MOVE NAME FROM INPUT
         SPACE
BLDLXMSG DC    A(BLDL4MSG,BLDL8MSG) BLDL ERROR MESSAGE VECTOR
         SPACE
NOOPMSG  MSG   '*NO OPERANDS, COMMAND REJECTED'
         AGO   .NOLMTS2
BLDL0MSG MSG   '*MEMBER ',LOADMOD,' IS NOT A LOAD MODULE'
.NOLMTS2 ANOP
BLDL4MSG MSG   '*LOAD MODULE ',LOADMOD,' NOT FOUND'
BLDL8MSG MSG   '*DIRECTORY ERROR - LIBRARY MAY NOT BE A PDS'
FINDMSG  MSG   '*FIND ERROR FOR ',LOADMOD,' - RETURN CODE = ',ERRCODE
NOSTRG   MSG   '*NOT ENOUGH STORAGE TO PROCESS MODULE ',LOADMOD
LOADMSGA MSG   'MODULE ',LOADMOD,' IS ALREADY LOADED'
         USING INFMJFCB-16,R15
LOADMSGG MSG   'MODULE ',LOADMOD,' LOADED FROM ',                      X
               (JFCBDSNM,44,W),' ON ',(JFCBVOLS,6,C)
         DROP  R15
CSNFMSG  MSG   '*CSECT ',CSECT,' NOT FOUND IN MODULE ',LOADMOD
IOERMSG  MSG   '*LOGICAL I/O ERROR IN LOAD MODULE ',LOADMOD
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XLL - FIND COMMAND PROCESSOR'
***********************************************************************
* "FIND" COMMAND PROCESSOR                                            *
* THIS COMMAND SEARCHES THE CURRENT LOAD MODULE (OR CSECT, IF ONE WAS *
* SPECIFIED ON THE MOST RECENT NAME COMMAND) FOR A SPECIFIED STRING   *
* (WHICH MAY BE SPECIFIED GENERICALLY OR EXPLICITLY, IN ONE OF        *
* SEVERAL FORMATS).  SYNTAX:                                          *
*              F(IND)  STRING  ALIGNMENT                              *
* WHERE: STRING IS REQUIRED UNLESS ONE HAS BEEN SPECIFIED ON A        *
*        PREVIOUS FIND COMMAND (FORMATS BELOW)                        *
*        ALIGNMENT IS OPTIONAL AND SPECIFIES DOUBLEWORD, FULLWORD,    *
*        HALFWORD, OR NO ALIGNMENT (THESE MAY BE ABBREVIATED)         *
* THE FIRST OPERAND OF THE FIND COMMAND MUST BE IN ONE OF THE         *
* FOLLOWING FORMATS:                                                  *
* NNN...N    WHERE EACH N IS A MEMBER OF THE SET 0123456789ABCDEF,*   *
* X'NNN...N' WHERE EACH N IS A MEMBER OF THE SET 0123456789ABCDEF,*   *
* C'NNN...N' WHERE EACH N IS ANY CHARACTER, 2 QUOTES REPRESENTING 1   *
* G'NNN...N' WHERE EACH N IS ANY CHARACTER, 2 QUOTES REPRESENTING 1   *
* F'...N'    WHERE ...N IS A # BETWEEN -2147483648 AND 2147483647     *
* H'...N'    WHERE ...N IS A # BETWEEN -32768 AND 32767               *
* *          AN ASTERISK, MEANING USE THE PREVIOUSLY SPECIFIED STRING *
* THE SECOND OPERAND OF THE FIND COMMAND MUST BE ANY ABBREVIATION OF  *
* ONE OF THE FOLLOWING:                                               *
* NOALIGN, HALFWORD, FULLWORD, DOUBLEWORD                             *
* IF THIS OPERAND IS OMITTED, THE DEFAULT ALIGNMENT FOR THE TYPE OF   *
* THE SPECIFIED STRING IS USED.  IF BOTH OPERANDS ARE OMITTED, THE    *
* STRING AND ALIGNMENT MOST RECENTLY SPECIFIED ARE USED.              *
***********************************************************************
         SPACE
FINDRTE  DS    0H
         SPACE
         ST    R14,SAVE14          SAVE RETURN REGISTER
         LR    R12,R15
         USING FINDRTE,R12
         MVI   FINDSW,X'00'        INITIALIZE SWITCH
         XR    R4,R4               SET FIND COUNT TO ZERO
         LH    R5,DATALEN          GET CURRENT DATA LENGTH (IF ANY)
         SPACE
         SCAN  1                   SCAN FIND STRING
         LTR   R8,R8               IF R8 LESS THAN 0, ERR MSG ALREADY
         BP    FK1OK               WRITTEN BY SCAN FOR BAD QUOTES. ELSE
         BM    COMMONRT            IF R8 = 0 THEN (NO OPERANDS ENT'D)
*** ASSUME R8 = 0
         LTR   R5,R5               IF A CURRENT FIND STRING EXISTS
         BNZ   FINDPROC            THEN USE IT, SCAN NO MORE
         LA    R1,FNOOPMSG         ELSE SAY "MISSING OPERAND"
         B     FINDWRT             AND TERMINATE FIND PROCESSING
         SPACE
FK1OK    DS    0H                  ELSE PARSE THE FIND STRING
         SPACE
***********************************************************************
* DETERMINE WHAT KIND OF STRING OPERAND THIS IS.                      *
* FIRST OF ALL, IT MAY BE A SINGLE ASTERISK, WHICH IS VALID ONLY IF   *
* THERE WAS A PREVIOUS FIND STRING SPECIFIED ONCE.                    *
***********************************************************************
         SPACE
         CH    R15,H1              IF THE LENGTH OF THIS OPERAND IS 1
         BNE   NOT1AST              AND
         CLI   0(R8),C'*'           IT IS A SINGLE ASTERISK,
         BNE   NOT1AST              THEN
         LTR   R5,R5               IF THERE WAS A PREVIOUS FIND STRING
         BNZ   GETALIGN            THEN USE PREV.STRING W.NEW ALIGNMENT
         LA    R1,FNOOPMSG         ELSE SAY "MISSING OPERAND"
         B     FINDWRT             AND TERMINATE FIND PROCESSING
         SPACE
NOT1AST  DS    0H                  ELSE NOT ONE ASTERISK, IT'S FOR REAL
         LR    R9,R15              SAVE LENGTH OF OPERAND
         STH   R15,STRINGL         SET LENGTH OF TEXT OF STRING
         BCTR  R15,0               ADJUST FOR EXECUTES
         EX    R15,SAVFNSTR        SAVE TEXT OF FIND STRING FOR DISPLAY
         CH    R9,H1               OPERAND LENGTH MUST BE AT LEAST 2
         BNH   FNULL               OTHERWISE CAN'T BE A VALID OPERAND
         CLI   1(R8),C''''         CHECK IF 2ND CHAR IS A QUOTE
         BNE   FIMPLHEX            IF NOT, MUST BE IMPLICIT HEX. ELSE..
         MVC   STRTYPE,0(R8)       SET STRING TYPE FROM 1ST CHAR
         LA    R1,0(R8,R15)        POINT TO LAST CHAR IN OPERAND
         CLI   0(R1),C''''         IF LAST CHAR IS NOT A QUOTE
         BNE   FINVALID            THEN GO REJECT THE INVALID STRING
         LA    R0,2(,R8)           ELSE POINT TO 1ST CHAR WITHIN QUOTES
         ST    R0,STRADDR          STORE ITS ADDRESS
         SR    R1,R0               GET LENGTH OF DATA INSIDE QUOTES
         BNP   FNULL               IF ZERO-LENGTH DATA, INVALID STRING
         STH   R1,STRLEN           ELSE SAVE DATA LENGTH WITHIN QUOTES
         ALR   R0,R1               R0 -> END OF STRING DATA (ADDR+LEN)
*
* STRING OPERAND IS IN FORMAT _'...' - NOW CHECK THE STRING TYPE
*
         CLI   STRTYPE,C'X'        IF X'...'
         BE    FINDQX              THEN PROCESS HEX STRING
         CLI   STRTYPE,C'C'        IF C'...'
         BE    FINDQC              THEN PROCESS CHARACTER STRING
         CLI   STRTYPE,C'G'        IF G'...'
         BE    FINDQG              THEN PROCESS GENERIC CHAR STRING
         CLI   STRTYPE,C'F'        IF F'...'
         BE    FINDQF              THEN PROCESS FULLWORD STRING
         CLI   STRTYPE,C'H'        IF H'...'
         BE    FINDQH              THEN PROCESS HALFWORD STRING
         B     FBADTYPE            OF NONE OF THE ABOVE, BAD OPERAND
         EJECT
FIMPLHEX DS    0H                  NO QUOTES - IMPLICIT HEX FORMAT
         ST    R8,STRADDR          OPERAND ADDRESS = STRING ADDRESS
         STH   R9,STRLEN           OPERAND LENGTH = STRING LENGTH
         LA    R0,0(R8,R9)         R0 -> END OF OPERAND/STRING
         MVI   STRTYPE,C'X'        SET STRING TYPE = HEX
******** B     FINDQX              FALL THROUGH TO HEX-DATA PROCESSING
         EJECT
FINDQX   DS    0H                  HEX STRING, SET UP FOR HEX FMT DATA
         L     R15,STRADDR         R15 -> EACH INPUT CHARACTER
         XR    R14,R14             R14 = OFFSET OF OUTPUT CHARACTER
FXLOOP1  DS    0H                  2 LOOPS HANDLE PAIRS OF INPUT CHARS
         CR    R15,R0              DO UNTIL END OF INPUT STRING
         BNL   FXEND               (FOR ALL CHARACTERS IN STRING)
         CLI   0(R15),C','         BYPASSING ALL COMMAS
         BNE   FXNOTCMA
         LA    R15,1(,R15)
         B     FXLOOP1
FXNOTCMA MVC   XCVAREA+0(1),0(R15) MOVE 1ST CHAR TO CONVERSION AREA
FXLOOP2  LA    R15,1(,R15)         PROCESS 2ND CHARACTER OF PAIR
         CR    R15,R0              IF NO CHARACTER (I.E.ODD # OF CHARS)
         BL    FXNASTK             THEN
         MVI   XCVAREA+1,C'*'       PRETEND THERE'S AN ASTERISK THERE
         B     FXAFTNC2             AND GENERATE A MASK CHAR FOR IT.
FXNASTK  CLI   0(R15),C','         ELSE IF THIS CHAR IS A COMMA
         BE    FXLOOP2             THEN IGNORE IT
         MVC   XCVAREA+1(1),0(R15) ELSE MOVE 2ND CHAR TO CONVERSN AREA
FXAFTNC2 DS    0H                  OK, NOW PROCESS THE MOVED CHAR PAIR
         TRT   XCVAREA(2),VALIDXTB CHECK BOTH CHARS ARE VALID HEX-FMT
         BNZ   FINVALID            IF NOT, GO REJECT THE STRING. ELSE
         MVC   XCVAREA2(2),XCVAREA SET UP CONVERSION FOR COMPARE MASK
         TR    XCVAREA(2),XTCTBL   PREPARE FOR STRING CREATION
         TR    XCVAREA2(2),XTMTBL  PREPARE FOR MASK CREATION
         CH    R14,=H'128'         LENGTH MUST NEVER EXCEED 128
         BH    FINVALID            BUT AS LONG AS IT DOESN'T...
         LA    R1,DATAAREA(R14)    POINT TO OFFSET IN DATA AREA
         PACK  0(2,R1),XCVAREA(3)  CREATE 1 HEX BYTE OF DATA
         LA    R1,MASKAREA(R14)    POINT TO OFFSET IN MASK AREA
         PACK  0(2,R1),XCVAREA2(3) CREATE 1 HEX BYTE OF MASK
         CLI   0(R1),X'FF'         IF 0123456789ABCDEF ... NOT * ...
         BE    MASKONLY            THEN (REAL DATA PRESENT) ...
         OI    FINDSW,REALDATA      INDICATE IT'S NOT ONLY MASK CHARS
MASKONLY DS    0H
         LA    R14,1(,R14)         BUMP UP WORK AREA OFFSET
         LA    R15,1(,R15)         BUMP UP INPUT POINTER
         B     FXLOOP1             CONTINUE UNTIL NO MORE CHARACTERS
         SPACE
FXEND    DS    0H
         SPACE
***********************************************************************
* AT THIS POINT THE HEX STRING HAS BEEN BUILT.  NOW MAKE SURE THAT IT *
* IS ACCEPTABLE.  R14 CONTAINS THE LENGTH OF THE DATA.                *
***********************************************************************
         SPACE
         LTR   R5,R14              R5 = LENGTH OF DATA
         BZ    FNULL               NULL DATA STRING IS INVALID
         TM    FINDSW,REALDATA     IF REAL-DATA SWITCH IS OFF,
         BNO   FALLASTS            THEN STRING IS ALL *'S AND NO GOOD
         B     GETALIGN            ELSE GO PROCESS THE NEXT OPERAND.
         EJECT
FINDQC   DS    0H                  CHARACTER STRING (NON-GENERIC)
         SPACE
         OI    FINDSW,REALDATA     FOR C-TYPE INDICATE ALL DATA IS REAL
         SPACE
FINDQG   DS    0H                  CHARACTER STRING (GENERIC)
         SPACE
         L     R15,STRADDR         POINT TO EACH CHAR IN STRING
         LA    R14,DATAAREA        POINT TO OUTPUT AREA TO MOVE CHARS
         LA    R1,MASKAREA         POINT TO OUTPUT AREA TO BUILD MASK
FCLOOP   CR    R15,R0              DO UNTIL END OF STRING
         BNL   FCEND               (FOR ALL CHARS IN INPUT STRING)
         CLI   0(R15),C''''        IF INPUT IS A QUOTE
         BNE   FCNQUOTE            THEN
         CLI   1(R15),C''''         IF FOLLOWING CHAR IS NOT A QUOTE
         BNE   FINVALID             THEN STRING IS INVALID
         LA    R15,1(,R15)          ELSE BUMP INPUT PTR PAST ONE QUOTE
         B     GMSKONLY             AND TREAT AS NON-MASK CHARACTER
FCNQUOTE DS    0H                  ELSE (NON-QUOTE CHARACTER) ...
         CLI   STRTYPE,C'G'        IF THIS IS A GENERIC STRING REQUEST
         BNE   GMSKONLY             AND
         CLI   0(R15),C'*'          IF THIS IS THE MASK CHARACTER
         BNE   GMSKONLY              THEN...
         MVI   0(R1),X'FF'            PUT 1-BITS IN THE MASK
         MVI   0(R14),X'FF'           MOVE 1-BITS TO DATA AREA
         B     AFTGMASK            ELSE DO LIKE THE REST...
GMSKONLY MVI   0(R1),X'00'          PUT 0-BITS IN THE MASK
         MVC   0(1,R14),0(R15)      MOVE THE INPUT CHAR TO DATA AREA
         OI    FINDSW,REALDATA      INDICATE THAT REAL DATA IS PRESENT
AFTGMASK DS    0H
         LA    R14,1(,R14)         BUMP UP WORK AREA POINTER
         LA    R1,1(,R1)           BUMP UP MASK AREA POINTER
         LA    R15,1(,R15)         BUMP UP INPUT AREA POINTER
         B     FCLOOP              AND CONTINUE.
         SPACE
FCEND    DS    0H
         TM    FINDSW,REALDATA     IF REAL-DATA SWITCH IS OFF,
         BNO   FALLASTS            THEN STRING IS ALL *'S AND NO GOOD
         LA    R0,DATAAREA         ELSE
         SLR   R14,R0               COMPUTE LENGTH OF CHARACTER DATA
         LR    R5,R14               SAVE IT AS THE DATA LENGTH
         B     GETALIGN             AND GO PROCESS THE NEXT OPERAND.
         EJECT
FINDQF   DS    0H                  FULLWORD STRING
FINDQH   DS    0H                  HALFWORD STRING
         SPACE
* VALIDATE F/H INPUT.  IT MAY HAVE A + OR - SIGN IN FRONT, BUT THE REST
* OF IT MUST BE NUMERIC.
         SPACE
         STCM  R4,15,MASKAREA      NO MASK USED WITH THIS TYPE OF DATA
         L     R14,STRADDR         POINT TO EACH CHAR OF INPUT STRING
         LH    R15,STRLEN          GET LENGTH OF THE INPUT STRING
         CLI   0(R14),C'+'         IF FIRST CHAR IS A PLUS SIGN
         BE    F#PLUS              THEN PROCESS POSITIVE INTEGER
         CLI   0(R14),C'-'         IF FIRST CHAR IS A MINUS SIGN
******** BE    F#MINUS             THEN PROCESS NEGATIVE INTEGER
         BNE   FNOSIGN             ELSE NO SIGN, PROCESS AS POSITIVE
F#MINUS  OI    FINDSW,NEGATIVE     IF MINUS SIGN, INDICATE NEGATIVE
F#PLUS   DS    0H                  IF PLUS SIGN, INDICATE NOTHING
         LA    R14,1(,R14)         BUMP INPUT POINTER PAST SIGN
         BCTR  R15,0               DECREMENT LENGTH ACCORDINGLY
FNOSIGN  DS    0H                  NOW WE HAVE ADDR & LEN OF UNSIGNED
         LTR   R15,R15             IF DATA LENGTH ZERO,
         BNP   FINVALID            THEN GO TO REJECT INVALID STRING
         CLI   STRTYPE,C'F'        IF STRING TYPE IS FULLWORD
         BE    CHK2TO31            THEN CHECK RANGE FOR FULLWORD. ELSE
         CH    R15,=H'5'           MAX LENGTH FOR HALFWORD TYPE IS 5
         BH    FINVALID            IF TOO LONG, REJECT
         BL    FLENOK              IF LESS, OK
         CLC   0(5,R14),=C'32768'  CHECK AGAINST MINIMUM/MAXIMUM VALUE
         B     RANGECHK            GO INSPECT CONDITION CODE
CHK2TO31 DS    0H                  CHECK RANGE FOR FULLWORD
         CH    R15,=H'10'          MAX LENGTH FOR FULLWORD TYPE IS 10
         BH    FINVALID            IF TOO LONG, REJECT
         BL    FLENOK              IF LESS, OK
         CLC   0(10,R14),=C'2147483648'  CHECK MINIMUM/MAXIMUM VALUE
RANGECHK DS    0H                  CHECK RESULTS FOR BOTH TYPES
         BH    FINVALID            IF OUTSIDE BOUNDS, REJECT
         BL    FLENOK              IF WITHIN BOUNDS, OK
         TM    FINDSW,NEGATIVE     IF EQUAL, CAN ONLY BE NEGATIVE
         BZ    FINVALID            OTHERWISE REJECT
         CLI   STRTYPE,C'F'        IF F'-2147483648'
         BNE   FLENOK              THEN (TO AVOID S0C9)...
         LA    R0,X'80'
         SLL   R0,24                SET R0 = X'80000000' EXPLICITLY
         B     STORFULL             AND GO TO STORE THE VALUE.
FLENOK   DS    0H                  ELSE OK, GO ON
         BCTR  R15,0               ADJUST LENGTH FOR EXECUTE
         EX    R15,TRTNUM          VALUE MUST BE NUMERIC
         BNZ   FINVALID            OTHERWISE INVALID STRING, REJECT
         EX    R15,PACKIT          CONVERT TO DECIMAL
         CVB   R0,DOUBLE           AND THEN TO BINARY
         TM    FINDSW,NEGATIVE     IF IT HAD A MINUS SIGN
         BNO   NOLCR               THEN
         LCR   R0,R0                MAKE IT NEGATIVE
NOLCR    CLI   STRTYPE,C'H'        IF TYPE = HALFWORD
         BNE   STORFULL            THEN
         STCM  R0,B'0011',DATAAREA  STORE 2 BYTES OF BINARY DATA
         LA    R5,2                 SET DATA LENGTH = 2
         B     GETALIGN            ELSE (TYPE = FULLWORD) ...
STORFULL STCM  R0,B'1111',DATAAREA  STORE 4 BYTES OF BINARY DATA
         LA    R5,4                 SET DATA LENGTH = 5
******** B     GETALIGN            GO PROCESS NEXT OPERAND
         EJECT
GETALIGN DS    0H
         SPACE
***********************************************************************
* GET THE NEXT OPERAND, WHICH WILL BE THE REQUESTED ALIGNMENT OF THE  *
* STRING.  THE DEFAULT IS DETERMINED BY THE STRING TYPE.  VALID       *
* VALUES ARE FULLWORD, HALFWORD, DOUBLEWORD, AND NO ALIGNMENT.        *
***********************************************************************
         SPACE
         SCAN  2,MAXLEN=11         SCAN ALIGNMENT OPERAND
         STH   R5,DATALEN          SAVE DATA LENGTH FOR FUTURE USE
         LTR   R8,R8               IF INVALID VALUE
         BM    BADALIGN             THEN REJECT, CANCEL FIND
         BZ    ALIGNDEF            IF NO VALUE, USE DEFAULT ALIGNMENT
         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTES
         LA    R14,ALIGNTBL        POINT TO ALIGNMENT VALUE TABLE
         LA    R0,12               SET BXLE REGISTER
         LA    R1,ALIGNEND-12      SET BXLE REGISTER
ALGNLOOP DS    0H                  SEARCH 4 VALUE USING ENTERED LENGTH
         EX    R15,COMPALGN        COMPARE OPERAND TO ALIGNMENT VALUE
         BE    ALIGNSET            IF EQUAL, A GOOD ALIGNMENT FOUND
         BXLE  R14,R0,ALGNLOOP     ELSE CONTINUE SEARCH ON TABLE
         MVC   ALGNTEST,BLANKS     NOT FOUND: BLANK ALIGNMENT WORK AREA
         EX    R15,MVALTEST        MOVE BAD VALUE TO MESSAGE AREA
         WRTMSG ALIGNMSG           SAY ALIGNMENT INVALID
BADALIGN ST    R4,ALGNADDR         CANCEL CURRENT ALIGNMENT
         B     COMMONRT            RETURN WITHOUT PROCESSING
         SPACE
ALIGNDEF DS    0H                  ALIGNMENT DEFAULT GETS SET HERE
         CLI   STRTYPE,C'F'        IF DATA TYPE = FULLWORD
         BNE   ALIGNNTF            THEN
         LA    R14,FULLWORD         USE FULLWORD ALIGNMENT
         B     ALIGNSET            ELSE
ALIGNNTF CLI   STRTYPE,C'H'        IF DATA TYPE = HALFWORD
         BNE   ALIGNNTH            THEN
         LA    R14,HALFWORD         USE HALFWORD ALIGNMENT
         B     ALIGNSET            ELSE (HEX OR CHAR) ...
ALIGNNTH LA    R14,NOALIGN          USE NO ALIGNMENT
         SPACE
ALIGNSET DS    0H                  R1 NOW POINTS TO ALIGNMENT ENTRY
         ST    R14,ALGNADDR        SAVE POINTER TO ALIGNMENT VALUE
         MVC   ALGNMASK,11(R14)    USE CORRESPONDING ALIGNMENT BIT MASK
******** B     FINDPROC            GO TO ACTUALLY DO THE FIND
         EJECT
FINDPROC DS    0H                  OPERANDS FULLY SCANNED. NOW GO.
         SPACE
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         CLI   CSECT,C' '          IF A CSECT NAME SPECIFIED
         BE    FDOALL              THEN
         L     R6,CURRESD           GET ITS ESD ENTRY ADDRESS
         L     R3,ADRSTART          GET STARTING ADDRESS
         B     FINDGO               ELSE...
FDOALL   DS    0H                  NO CSECT SPECIFIED, LOOP FOR ALL
* NOTE R6 USED INSTEAD OF R5 BECAUSE R5 IS HOLDING STRING LENGTH
         L     R6,ESDBUFAD          GET ADDRESS OF ESD TABLE
         ICM   R6,15,ESDLKHDR-ESDTABLE(R6) GET FIRST ESD ENTRY ADDRESS
FREPEAT  BZ    NOTFOUND             AT END, NO MORE OCCURRENCES
         XR    R3,R3                CLEAR FOR INSERT
         ICM   R3,7,ESDADDR         GET RELATIVE ADDRESS OF CSECT
         LTR   R10,R10              IF OVERLAY MODULE,
         BZ    FINITNOV             THEN...
         XR    R1,R1                 CLEAR INSERT REG
         IC    R1,ESDSEGNO           GET SEGMENT NUMBER OF THIS CSECT
         SLA   R1,OVSHIFT            CONVERT TO INDEX
         SL    R3,OVSEGLO(R1)        SUBTRACT LOWER BOUND
         AL    R3,OVSEGADR(R1)       ADD ADDR OF SEGMENT BUFFER
         B     FINDGO               ELSE...
FINITNOV AL    R3,LOADADDR           JUST ADD ADDRESS OF MODULE BUFFER
         SPACE
FINDGO   LA    R9,256              SET UP A CONSTANT '256'
         XR    R7,R7               CLEAR INSERT REG
         ICM   R7,7,ESDLEN         GET LENGTH OF THIS CONTROL SECTION
         SR    R7,R5               SUBTRACT STRING LENGTH FROM ENDADDR
         BM    FNEXTCS             IF DATA LONGER THAN CSECT, NOT FOUND
         LA    R7,1(,R7)           ELSE ADD 1: HOW MANY CHARS TO SCAN
***********************************************************************
* R7 = TOTAL LENGTH FOR SCAN OF A CONTROL SECTION.
***********************************************************************
* IF FIRST CHARACTER OF STRING IS NOT MASKED, SET UP TRANSLATION TABLE
* FOR QUICK SCAN.
***********************************************************************
         CLI   MASKAREA,X'00'      IF FIRST CHAR IS A MASK CHAR,
         BNE   COMPWMSK            THEN CAN'T USE TRT. ELSE 1ST IS REAL
USETRT   DS    0H                   SO SET UP TRANSLATION TABLE
         XC    SCANTBL,SCANTBL      BY FIRST CLEARING IT TO ZEROES
         XR    R15,R15              AND THEN
         IC    R15,DATAAREA         TAKING THE FIRST ARGUMENT BYTE
         LA    R0,1                 AND SETTING THE CORRESPONDING
         STC   R0,SCANTBL(R15)      TABLE BYTE TO X'01'.
FINDLOOP DS    0H                  MAIN LOOP FOR CHARACTER SCAN
         CLI   MASKAREA,X'00'      IF FIRST CHAR IS MASKED,
         BNE   COMPWMSK            THEN DO STRAIGHT COMPARE,
FTRTLOOP DS    0H                  ELSE DO TRT-SCAN FOR FIRST CHAR:
         CR    R7,R9               IF LENGTH EXCEEDS 256,
         BNH   LE256LFT            THEN BREAK UP THE SCAN BY
         TRT   0(256,R3),SCANTBL    SCANNING 256 BYTES UNTIL
         BNZ   CHAR1FND             CHARACTER IS FOUND OR
         ALR   R3,R9                UNTIL LESS THAN 256 BYTES
         SLR   R7,R9                ARE LEFT TO SCAN.
         B     FTRTLOOP
LE256LFT DS    0H                  WHEN LESS THAN 256 BYTES LEFT
         LTR   R15,R7              GET LENGTH OF REMAINING DATA
         BNP   FNEXTCS             IF ZERO, END OF SCAN, NOTHING LEFT
         BCTR  R15,0               ADJUST FOR EXECUTE
         EX    R15,TRTSCAN         EXECUTE SCAN FOR FIRST CHARACTER
         BZ    FNEXTCS             IF FAILS, END OF SCAN, NOTHING LEFT
CHAR1FND DS    0H                  SCAN ENCOUNTERED THE 1ST CHARACTER
* TRT HAS SET R1 -> FIRST CHAR THAT MATCHES.  NOW CHECK ENTIRE STRING
         LR    R15,R1              THIS LOC MINUS PREVIOUS LOC
         SR    R15,R3              GIVES R15 = LENGTH JUST SCANNED
         SR    R7,R15              REDUCE TOTAL LENGTH REMAINING
         LR    R3,R1               SET NEW SCAN ADDRESS FOR NEXT TIME
         B     COMPARE             GO SEE IF THE WHOLE STRING MATCHES
         SPACE
COMPWMSK DS    0H                  FOR DATA WHOSE 1ST CHAR IS MASKED...
         LTR   R7,R7               WHILE REMAINING LENGTH GT 0, COMPARE
         BNP   FNEXTCS             OTHERWISE SEARCH IS TERMINATED.
         SPACE
COMPARE  DS    0H                  R3 -> POSSIBLE MATCH. NOW CHK ALGNMT
         ICM   R15,1,ALGNMASK      PICK UP ALIGNMENT BIT MASK
         BZ    FALIGNOK            IF ZERO, NOALIGN SPECIFIED, NO CHECK
         STC   R3,TESTBYTE         TEST LOW-ORDER ADDRESS BYTE
         EX    R15,TESTMASK        TEST BITS OF IT FOR ALIGNMENT
         BNZ   FCONTINU            IF IT FAILS TEST, SKIP THIS, GO ON
FALIGNOK DS    0H                  ALIGNMENT IS ACCEPTED...
         LR    R15,R5              GET LENGTH OF THE DATA
         BCTR  R15,0               REDUCE FOR EXECUTES
         LTR   R15,R15             IF DATA LENGTH IS 1
         BNZ   MAYNOTBE             AND
         CLI   MASKAREA,X'00'        FIRST CHAR IS REAL (NOT MASKED),
         BE    THISISIT               THEN WE HAVE FOUND A TRUE MATCH.
MAYNOTBE DS    0H                  ELSE COMPARE THE REST OF THE DATA
         EX    R15,MVCTEST         MOVE LOAD MODULE DATA TO TEST AREA
         EX    R15,OCTEST          "OR" IT WITH THE COMPARE MASK
         EX    R15,CLCTEST         COMPARE ARGUMENT WITH MASKED DATA
******** BE    THISISIT            IF IT MATCHES, GREAT, DISPLAY IT
         BNE   FCONTINU            IF NOT, GO TO CONTINUE SCANNING
         SPACE
THISISIT DS    0H                  WE HAVE FOUND AN OCCURRENCE...
         SPACE
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         LR    R1,R3               GET DATA ADDRESS IN MODULE
         LTR   R10,R10             IF OVERLAY MODULE
         BZ    THISNOV             THEN
         XR    R15,R15              CLEAR INSERT REG
         IC    R15,ESDSEGNO         GET CURRENT SEGMENT NUMBER
         SLA   R15,OVSHIFT          CONVERT TO INDEX
         S     R1,OVSEGADR(R15)     SEGMENT BUF ADDR MINUS DATA ADDRESS
         A     R1,OVSEGLO(R15)      PLUS OFFSET OF SEGMENT IN MODULE
         B     THISSET              GIVES OFFSET OF FOUND DATA
THISNOV  DS    0H                  ELSE...
         S     R1,LOADADDR          DATA ADDRESS MINUS LOAD MODULE ADDR
THISSET  STCM  R1,7,FINDADR1       GIVES OFFSET OF FOUND DATA
         SPACE
***********************************************************************
* R1 = OFFSET OF THE FOUND DATA WITHIN THE LOAD MODULE.               *
* THE DATA IS WITHIN THE CSECT REFERENCED BY R6.                      *
***********************************************************************
         SPACE
         LA    R4,1(,R4)           INCREMENT FIND COUNT BY 1
         XR    R0,R0               CLEAR INSERT REG
         ICM   R0,7,ESDADDR        GET CONTROL SECTION OFFSET
         SLR   R1,R0               DATA LOCATION MINUS CSECT LOCATION
         STCM  R1,7,FINDADR2        GIVES OFFSET OF DATA IN CTL SECTION
***********************************************************************
* NOW TELL USER THAT THE STRING HAS BEEN FOUND.  DISPLAY INFORMATION  *
***********************************************************************
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         TM    FINDSW,FINDHEAD     IF HEADING HAS NOT BEEN WRITTEN YET,
         BO    NOHEAD              THEN...
         MVI   CC,C'0'              SET UP DOUBLE SPACE ASA CONTROL
         WRTMSG HEADMSG             WRITE THE HEADING, AND
         OI    FINDSW,FINDHEAD      TURN THE HEADING INDICATOR ON.
NOHEAD   DS    0H                  NOW HANDLE THE INFO TO BE DISPLAYED
         CLI   STRTYPE,C'G'        IF A "G-STRING"
         BNE   DISPLAYX            THEN
         LA    R1,GDATAMSG          DISPLAY THE INFO IN CHAR FORMAT
         B     DISPLAY             ELSE
DISPLAYX LA    R1,DATAMSG           DISPLAY THE INFO IN HEX FORMAT
DISPLAY  WRTMSG (R1)               DO IT
         MVI   CC,C' '             SET SINGLE SPACE ASA FOR NEXT MSG
         SPACE
FCONTINU DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         LA    R3,1(,R3)           BUMP UP TO NEXT DATA IN LOAD MODULE
         BCT   R7,FINDLOOP         DECR REM CHAR COUNT & KEEP SCANNING
FNEXTCS  DS    0H                  UNTIL SCANNING LENGTH EXHAUSTED
         CLI   CSECT,C' '          AT WHICH POINT, IF USING ALL CSECTS
         BNE   NOTFOUND            THEN
         ICM   R6,15,ESDLINKP       GET ADDR OF NEXT ESD ENTRY
         B     FREPEAT              AND CONTINUE UNTIL CSECTS EXHAUSTED
*                                  ELSE ONLY 1 CSECT - NO DATA LEFT
         SPACE 2
NOTFOUND DS    0H                  NO MORE DATA TO SEARCH; FIND IS OVER
         SPACE
         ST    R4,FNDCOUNT         STORE OCCURRENCE COUNT FOR MESSAGE
         LA    R1,FOUNDMSG         TELL HOW MANY WERE FOUND
         B     FINDWRT             GO TO DISPLAY MESSAGE
         SPACE
FNULL    LA    R1,NULLMSG          NULL STRING IS INVALID
         B     FBADWRT             GO TO DISPLAY MESSAGE
         SPACE
FBADTYPE LA    R1,BADTMSG          BAD TYPE CODE
         B     FBADWRT             GO TO DISPLAY MESSAGE
         SPACE
FALLASTS LA    R1,ASTSMSG          STRING CANNOT BE ALL ASTERISKS
         B     FBADWRT             GO TO DISPLAY MESSAGE
         SPACE
FINVALID LA    R1,INVCSMSG         STRING IS NOT VALID
******** B     FBADWRT             GO TO DISPLAY MESSAGE
         SPACE
FBADWRT  XR    R0,R0               FIND COMMAND ERROR
         STH   R0,STRINGL          ERROR OCCURRED, CANCEL FIND STRING
         STH   R0,DATALEN          ERROR OCCURRED, CANCEL FIND STRING
         MVI   CC,C'0'             SET DOUBLE SPACE ASA CONTROL
         WRTMSG (R1)               GIVE USER THE WORD
         B     COMMONRT            RETURN TO MAINLINE
FINDWRT  MVI   CC,C'0'             SET DOUBLE SPACE ASA CONTROL
         WRTMSG (R1)               GIVE USER THE WORD
         B     GOODRET             RETURN TO MAINLINE
         SPACE
SAVFNSTR MVC   STRING(0),0(R8)     EXECUTED: SAVE FIND STRING FOR DISPL
TRTNUM   TRT   0(0,R14),NUMTBL     EXECUTED: VERIFY NUMERIC OPERAND
PACKIT   PACK  DOUBLE,0(0,R14)     EXECUTED: CONVERT CHAR TO DECIMAL
COMPALGN CLC   0(0,R8),0(R14)      EXECUTED: COMPARE ALIGNMENT VALUE
MVALTEST MVC   ALGNTEST(0),0(R8)   EXECUTED: STORE ALIGNMENT MASK
TRTSCAN  TRT   0(0,R3),SCANTBL     EXECUTED: SCAN FOR FIND STRING DATA
MVCTEST  MVC   TESTAREA(0),0(R3)   EXECUTED: MOVE DATA TO COMPARE SPOT
OCTEST   OC    TESTAREA(0),MASKAREA EXECUTED: MASK THE COMPARE DATA
CLCTEST  CLC   DATAAREA(0),TESTAREA EXECUTED: COMPARE DATA W/ARGUMENT
TESTMASK TM    TESTBYTE,X'00'      EXECUTED: CHECK ALIGNMENT ADDR BITS
         SPACE
FNDCOUNT DS    F                   NUMBER OF TIMES STRING FOUND
STRADDR  DS    F                   ADDRESS OF CHAR STRING ON CTL STMT
STRLEN   DS    H                   LENGTH OF CHAR STRING ON CTL STMT
DATALEN  DS    H                   LENGTH OF ACTUAL FIND STRING
FINDADR1 DS    XL3                 OFFSET OF DATA IN THE LOAD MODULE
FINDADR2 DS    XL3                 OFFSET OF DATA IN CONTROL SECTION
STRTYPE  DS    C                   TYPE OF CHARACTER STRING ON CARD
ALGNMASK DS    C                   TM MASK FOR ALIGNMENT CHECK
XCVAREA  DS    CL3                 HEX CONVERSION AREA FOR STRING
XCVAREA2 DS    CL3                 HEX CONVERSION AREA FOR MASK
         SPACE
FINDSW   DS    X                   SWITCHES AND FLAGS
         SPACE
REALDATA EQU   B'10000000'         IF OFF, X/G STRING IS ONLY ASTERISKS
NEGATIVE EQU   B'01000000'         IF ON, F/H STRING HAS A MINUS SIGN
FINDHEAD EQU   B'00100000'         IF ON, HEADING HAS BEEN DISPLAYED
*        EQU   B'00010000'         RESERVED
*        EQU   B'00001000'         RESERVED
*        EQU   B'00000100'         RESERVED
*        EQU   B'00000010'         RESERVED
*        EQU   B'00000001'         RESERVED
         SPACE
$FINDSTR DC    C' FIND STRING '    CONSTANT FOR MESSAGES
         SPACE
FNOOPMSG MSG   '*NO',($FINDSTR,,C),'HAS BEEN SPECIFIED'
INVCSMSG MSG   '*INVALID CHARACTERS IN',($FINDSTR,,C)
NULLMSG  MSG   '*INVALID',($FINDSTR,,C),'LENGTH'
BADTMSG  MSG   '*INVALID TYPE PREFIX ON',($FINDSTR,,C)
ASTSMSG  MSG   '*A',($FINDSTR,,C),'OF ALL MASK SYMBOLS IS NOT ALLOWED'
ALIGNMSG MSG   '*INVALID ALIGNMENT SPECIFICATION - ',ALGNTEST
HEADMSG  MSG   ' LOAD MODULE OFFSET    CSECT     OFFSET    DATA'
DATAMSG  MSG   '  ',(LOADMOD,8,C),'   ',FINDADR1,'   ',(ESDNAME,8,C),  X
               '   ',FINDADR2,'    ',(0(R3),(R5),X)
GDATAMSG MSG   '  ',(LOADMOD,8,C),'   ',FINDADR1,'   ',(ESDNAME,8,C),  X
               '   ',FINDADR2,'    ',(0(R3),(R5),C)
FOUNDMSG MSG   'TOTAL OF ',FNDCOUNT,' OCCURRENCES FOUND IN ',          X
               LOADMOD,' ',(CSECT,,C)
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XLL - LIST COMMAND PROCESSOR'
***********************************************************************
* "LIST" COMMAND PROCESSOR                                            *
* THIS COMMAND PRODUCES A HEXADECIMAL AND EBCDIC LIST OF ONE OR ALL   *
* CONTROL SECTIONS OF THE CURRENT LOAD MODULE, 16 BYTES/LINE. SYNTAX: *
*              L(IST)  CSECTNAME                                      *
* WHERE: CSECTNAME IS OPTIONAL AND SPECIFIES THE NAME OF THE ONLY     *
*        CONTROL SECTION TO BE LISTED.  IF THIS IS OMITTED THEN IF    *
*        A CSECT WAS SPECIFIED ON THE PREVIOUS NAME COMMAND, THAT     *
*        CSECT IS LISTED, OTHERWISE ALL CSECTS ARE LISTED.            *
***********************************************************************
         SPACE
LISTRTE  DS    0H
         SPACE
         ST    R14,SAVE14
         LR    R12,R15
         USING LISTRTE,R12
         MVI   LISTSW,X'00'        CLEAR FLAGS
         MVC   LISTNAME,CSECT      INIT NAME OF CSECT TO BE LISTED
         SCAN  1,MAXLEN=8          SCAN FOR NAME OF CSECT TO LIST
         LTR   R8,R8               CHECK IF VALID NAME WAS ENTERED
         BM    COMMONRT            IF INVALID, THEN RETURN TO CALLER
         BZ    LNOCSECT            IF A CSECT NAME WAS ENTERED, THEN
         MVC   LISTNAME,BLANKS      CLEAR NAME OUT AND
         BCTR  R15,0                USING LENGTH OF OPERAND
         EX    R15,LISTMOVE         MOVE NAME OF CSECT TO BE LISTED
LNOCSECT DS    0H
         L     R5,ESDBUFAD         GET ADDRESS OF ESD TABLE
         ICM   R6,15,ESDLKHDR      GET FIRST ESD ENTRY IN PHYS ORDER
LISTLOOP BZ    LISTDONE            LOOP WHILE NOT ZERO
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         CLI   LISTNAME,C' '       IF A SPECIFIC CSECT REQUESTED
         BE    LISTTHIS            THEN
         CLC   LISTNAME,ESDNAME     IF REQUESTED CSECT DOES NOT MATCH
         BNE   DONTLIST             THEN SKIP THIS CONTROL SECTION
         OI    LISTSW,LCSECTD       ELSE SAY REQUESTED CSECT LOCATED
LISTTHIS DS    0H                  LIST THIS CONTROL SECTION
         MVI   CC,C'1'             DO A PAGE EJECT
         WRTMSG LISTHDR            WRITE THE HEADING
         MVI   CC,C'0'             DO A DOUBLE SPACE NEXT TIME
         XR    R0,R0               CLEAR REGISTER FOR INSERTS
         ICM   R0,7,ESDLEN         CHECK CSECT LENGTH
         BZ    DONTLIST            IF ZERO, SKIP LISTING OF IT
         LTR   R10,R10             IF OVERLAY MODULE
         BZ    LSTNOTOV            THEN...
         XR    R1,R1                CLEAR INSERT REG
         IC    R1,ESDSEGNO          GET SEGMENT NUMBER
         SLA   R1,OVSHIFT           CONVERT TO INDEX
         L     R9,OVSEGADR(R1)      GET ADDRESS OF SEGMENT BUFFER
         SL    R9,OVSEGLO(R1)       SUBTRACT OFFSET RELATIVE TO MODULE
         B     LSTAFTOV            ELSE...
LSTNOTOV DS    0H                  NOT OVERLAY...
         L     R9,LOADADDR          GET ADDRESS OF LOAD MODULE
LSTAFTOV DS    0H                  ANYHOW...
         XR    R3,R3               CLEAR REGISTER FOR INSERTS
         ICM   R3,7,ESDADDR        GET ADDRESS OF START OF CSECT
         ALR   R3,R9               CONVERT TO ABSOLUTE ADDRESS
         ICM   R4,15,ESDNADDR      GET ADDRESS OF END OF CSECT
         ALR   R4,R9               CONVERT TO ABSOLUTE ADDRESS
         ST    R4,LISTEND          SAVE ADDRESS OF END OF CSECT
         LR    R1,R3               POINT TO FIRST WORD TO CONVERT
FMTLOOP  DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         LR    R14,R3              GET OFFSET OF NEXT DATA TO LIST
         SLR   R14,R9              CONVERT TO RELATIVE ADDRESS IN LOAD
         STCM  R14,7,LISTLOC1      STORE RELATIVE ADDR OF CURRENT LINE
         ICM   R0,7,ESDADDR
         SLR   R14,R0              CONVERT TO RELATIVE ADDRESS IN CSECT
         STCM  R14,7,LISTLOC2      STORE ADDRESS OF CURRENT LINE
         MVI   LISTLINE,C' '       CLEAR LINE TO BLANKS
         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE
         LA    R14,LISTLINE+0      INITIALIZE OUTPUT POINTER FOR LINE
         LA    R0,4                SET COUNTER OF # OF WORDS / LINE
FMTLOOP2 DS    0H
         L     R15,LISTEND
         SLR   R15,R1              GET LENGTH OF REMAINING DATA
         STH   R15,LISTLEN
         CH    R15,=H'4'           IF LESS THAN 4
         BNL   FMTMOVE4            THEN...
         BCTR  R15,0                REDUCE LENGTH FOR EXECUTES
         EX    R15,FMTMOVE0         MOVE DATA FROM MODULE TO WORK AREA
         LH    R15,LISTLEN          GET LENGTH +1 FOR UNPACK SOURCE
         SLL   R15,4+1              GET (LENGTH+1)*2 FOR UNPACK DEST
         AH    R15,LISTLEN          PUT LENGTHS TOGETHER FOR EXECUTE
         EX    R15,FMTUNPK0         MOVE TO HEX AREA
         LH    R15,LISTLEN          GET LENGTH AGAIN
         SLL   R15,1                MULTIPLY BY 2
         BCTR  R15,0                ADJUST FOR EXECUTE
         EX    R15,FMTTRAN0         TRANSLATE
         ALR   R14,R15              POINT TO END OF TRANSLATED DATA
         MVI   1(R14),C' '          BLANK OUT FOLLOWING POSITION
         AH    R1,LISTLEN           BUMP INPUT POINTER
         B     FMTCHAR              AND EXIT FORMATTING
FMTMOVE4 DS    0H                  ELSE...
         MVC   LISTWORK(4),0(R1)   MOVE DATA FROM MODULE TO WORK AREA
         UNPK  0(9,R14),LISTWORK(5)  AND THEN TO HEX AREA TO AVOID 0C4
         TR    0(8,R14),LISTXTBL   TRANSLATE
         MVI   8(R14),C' '         BLANK OUT THE FOLLOWING POSITION
         LA    R1,4(,R1)           BUMP INPUT POINTER
         LA    R14,9(,R14)         BUMP OUTPUT POINTER
         C     R1,LISTEND          IF END OF CSECT TO BE LISTED
         BNL   FMTCHAR             THEN EXIT
         BCT   R0,FMTLOOP2         CONTINUE FOR ALL WORDS ON LINE
FMTCHAR  LR    R2,R1
         SLR   R2,R3               SET R2 = LENGTH OF CHAR DATA
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         WRTMSG LISTMSG            DISPLAY THE LINE
         MVI   CC,C' '             SET ASA CONTROL = SINGLE SPACE
         C     R1,LISTEND          IF END OF CSECT TO BE LISTED
         BNL   DONTLIST            THEN EXIT
         LR    R3,R1               ELSE PREPARE FOR NEXT LINE OF DATA
         B     FMTLOOP             CONTINUE WITH NEXT LINE
         SPACE
DONTLIST DS    0H
         TM    LISTSW,LCSECTD      IF REQUESTED CSECT WAS LISTED
         BO    LISTDONG            THEN GO TO SUCCESSFUL TERMINATION
         ICM   R6,15,ESDLINKP      ELSE GET NEXT ESD ENTRY (PHYS ORDER)
         B     LISTLOOP            AND CONTINUE LOOP
         SPACE
LISTDONE DS    0H                  END OF ALL LISTING & LCSECTD = OFF
         CLI   LISTNAME,C' '       IF A SPECIFIC CSECT WAS REQUESTED
         BE    LISTDONG            THEN
         WRTMSG LISTFAIL           PUT OUT ERROR MESSAGE
         B     COMMONRT            ELSE
LISTDONG MVI   CC,C'1'             EJECT THE PAGE
         WRTMSG LISTEMSG           SAY WE ARE DONE
         B     GOODRET
         SPACE
LISTMOVE MVC   LISTNAME(0),0(R8)   EXECUTED: MOVE CSECT NAME
FMTMOVE0 MVC   LISTWORK(0),0(R1)   EXECUTED: MOVE DATA FROM MODULE
FMTUNPK0 UNPK  0(0,R14),LISTWORK(0) EXECUTED: MOVE DATA TO HEX AREA
FMTTRAN0 TR    0(0,R14),LISTXTBL   EXECUTED: TRANSLATE HEX DATA
         SPACE
LISTEND  DS    A                   ADDRESS OF END OF CSECT
LISTLEN  DS    H                   LENGTH REMAINING TO LIST
LISTWORK DS    XL5                 WORK AREA
LISTLOC1 DS    XL3                 LOCATION OF CURRENT LINE
LISTLOC2 DS    XL3                 LOCATION OF CURRENT LINE
LISTNAME DS    CL8                 NAME OF CSECT FOR LISTING
         SPACE
LISTSW   DS    X
LCSECTD  EQU   B'10000000'         1 = REQUESTED CSECT HAS BEEN LISTED
         SPACE
LISTLINE DS    CL36                OUTPUT LINE AREA
         SPACE
LISTHDR  MSG   'LOAD MODULE ',(LOADMOD,,C),'   CSECT ',(ESDNAME,8,C),  X
               '   LENGTH ',ESDLEN,                                    X
               '   SEGMENT ',(ESDSEGNO,1,H)
LISTMSG  MSG   LISTLOC1,' ',LISTLOC2,'  ',                             X
               (LISTLINE,35,C),'  *',(0(R3),(R2),C),'*'
LISTEMSG MSG   (BLANKS,15,C),'END OF LIST'
LISTFAIL MSG   '*CSECT ',LISTNAME,' NOT FOUND'
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XLL - MAP/AMAP COMMAND PROCESSOR'
***********************************************************************
* "MAP" COMMAND PROCESSOR                                             *
*        -- AND --                                                    *
* "AMAP" COMMAND PROCESSOR                                            *
* THIS COMMAND DISPLAYS PERTINENT INFORMATION ABOUT THE CURRENT       *
* ENVIRONMENT, INCLUDING CONTROL SECTION NAMES AND RELATIVE ADDRESSES *
* IN PHYSICAL ORDER (FOR "MAP") OR ALPHABETICAL ORDER (FOR "AMAP").   *
*              M(AP)  CSECTNAME                                       *
*                  -- OR --                                           *
*              A(MAP) CSECTNAME                                       *
* WHERE: CSECTNAME IS OPTIONAL AND SPECIFIES THE NAME OF THE ONLY     *
*        CONTROL SECTION TO BE LISTED.  IF THIS IS OMITTED THEN ALL   *
*        CSECTS ARE LISTED.  IF AN INVALID NAME IS ENTERED THEN NO    *
*        CSECTS ARE LISTED.                                           *
***********************************************************************
         SPACE
MAPRTE   DS    0H                  MAP COMMAND PROCESSOR SAME AS...
AMAPRTE  DS    0H                  AMAP COMMAND PROCESSOR
         SPACE
         ST    R14,SAVE14          SAVE RETURN REGISTER
         LR    R12,R15
         USING MAPRTE,R12
         NI    MAPSW,255-MCFOUND   INITIALIZE FLAGS
         MVI   CC,C'0'             SET UP ASA DOUBLE SPACING
         WRTMSG MHDMSG             WRITE MAP HEADING
         CLI   CSECT,C' '          IF A CSECT IS CURRENTLY ACTIVE
         BE    MNOCSECT            THEN
         MVI   CC,C' '              SET UP ASA SINGLE SPACING
         WRTMSG CSECTMSG            WRITE CSECT HEADER
         MVI   CC,C'0'              RESTORE ASA DOUBLE SPACING
MNOCSECT DS    0H
         LH    R14,STRINGL         IF THERE IS A CURRENT FIND STRING
         LTR   R14,R14
         BZ    MNOFS               THEN
         WRTMSG FSMSG               DISPLAY IT
         ICM   R1,15,ALGNADDR       AND IF THERE IS A CURRENT ALIGNMENT
         BZ    MNOFS                THEN
         WRTMSG ALMSG                DISPLAY IT
MNOFS    DS    0H
         MVC   MAPCSECT,BLANKS     CLEAR CSECT NAME FOR DISPLAY
         SCAN  1,MAXLEN=8          SCAN FOR NAME OF CSECT TO MAP
         LTR   R8,R8               CHECK IF A VALID NAME ENTERED
         BM    COMMONRT            IF INVALID, RETURN TO CALLER
         BZ    MAPITALL            IF A CSECT NAME WAS ENTERED, THEN
         BCTR  R15,0                USING ITS LENGTH,
         EX    R15,MOVEMAPC         MOVE NAME TO CSECT NAME FOR COMPARE
MAPITALL DS    0H                  ELSE MAP ALL CSECTS IN LOAD MODULE
         L     R5,ESDBUFAD         GET ADDRESS OF ESD TABLE
         CLI   COMMAND,C'A'        IF THIS IS THE "AMAP" COMMAND,
         BNE   MAPCHAIN            THEN
         LA    R6,ESDHDRLN(,R5)     GET FIRST ESD ENTRY IN ALPHA ORDER
ACHKZERO C     R6,ESDENDAD          LOOP UNTIL END OF ALPHA LIST
         BH    COMMAPRT             WHEN FINISHED, GO TO COMMON RETURN
         B     MAPLOOP             ELSE
MAPCHAIN ICM   R6,15,ESDLKHDR       GET FIRST ESD ENTRY IN PHYS ORDER
MCHKZERO BZ    COMMAPRT             LOOP WHILE NOT ZERO
MAPLOOP  DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         CLI   MAPCSECT,C' '        IF A SPECIFIC CSECT REQUESTED
         BE    MAPTHIS              THEN
         CLC   MAPCSECT,ESDNAME      IF REQUESTED CSECT DOES NOT MATCH
         BNE   DONTMAP               THEN SKIP THIS CONTROL SECTION
         OI    MAPSW,MCFOUND         ELSE INDICATE CSECT FOUND
MAPTHIS  DS    0H                   DISPLAY INFO ON ESD ENTRY <- R6
         MVC   MAPID,BLANKS         CLEAR MAP ID OUTPUT
         MVC   TESTTYPE,ESDTYPE     MOVE ESD TYPE FOR TESTING
         NI    TESTTYPE,X'0F'       ZERO OUT IRRELEVANT BITS
         CLI   TESTTYPE,ESDSD       IF SECTION DEFINITION
         BNE   MAPNOTSD             THEN
         MVC   MAPID(5),=C'CSECT'    MOVE IN CSECT IDENTIFIER
         MVC   MAPID+7(8),ESDNAME    MOVE IN CSECT NAME
         B     MAPTHIS2             ELSE
MAPNOTSD CLI   TESTTYPE,ESDPC       IF PRIVATE CODE
         BNE   MAPNOTPC
         CLC   ESDNAME,$PRIVATE
         BNE   MAPNPRIV
         MVC   MAPID(12),=C'PRIVATE CODE'
         B     MAPTHIS2             ELSE
MAPNPRIV CLC   ESDNAME,$SEGTAB
         BNE   MAPNSEGT
         MVC   MAPID(13),=C'SEGMENT TABLE'
         B     MAPTHIS2             ELSE
MAPNSEGT CLC   ESDNAME,$ENTAB
         BNE   MAPNENTT
         MVC   MAPID(11),=C'ENTRY TABLE'
         B     MAPTHIS2             ELSE
MAPNENTT MVC   MAPID(9),=C'(UNKNOWN)'
         B     MAPTHIS2             ELSE
MAPNOTPC CLI   TESTTYPE,ESDCM        IF COMMON
         BNE   MAPNOTCM
         MVC   MAPID(6),=C'COMMON'
         MVC   MAPID+7(8),ESDNAME
         B     MAPTHIS2
MAPNOTCM MVC   MAPID(5),=C'(UNKN)'
         MVC   MAPID+6(8),ESDNAME
MAPTHIS2 WRTMSG MAPMSG              DISPLAY INFO ON ESD ENTRY <- R6
DONTMAP  DS    0H
         TM    MAPSW,MCFOUND       IF REQUESTED CSECT HAS BEEN MAPPED
         BO    COMMAPRT            THEN TERMINATE MAPPING
         MVI   CC,C' '             ELSE ASA SINGLE SPACE NEXT MESSAGE
         CLI   COMMAND,C'A'        IF THIS IS THE "AMAP" COMMAND
         BNE   MAPNEXT             THEN
         LA    R6,ESDENTLN(,R6)     GET NEXT ESD ENTRY (ALPHA ORDER)
         B     ACHKZERO             AND CONTINUE LOOP
MAPNEXT  DS    0H                  ELSE
         ICM   R6,15,ESDLINKP       GET NEXT ESD ENTRY (PHYSICAL ORDER)
         B     MCHKZERO             AND CONTINUE LOOP
         SPACE
COMMAPRT DS    0H                  COMMON MAP/AMAP TERMINATION
         MVI   CC,C'0'             SET ASA DOUBLE SPACING
         WRTMSG MAPENMSG           SAY END OF MAP
         B     GOODRET             RETURN TO MAINLINE
         SPACE 2
MOVEMAPC MVC   MAPCSECT(0),0(R8)   EXECUTED: MOVE CSECT NAME FOR (A)MAP
         SPACE
MAPSW    DS    X                   FLAGS
MCFOUND  EQU   B'10000000'         1 = REQUESTED CSECT HAS BEEN MAPPED
         SPACE
MAPID    DS    CL15
         SPACE
MHDMSG   MSG   (BLANKS,16,C),'  LOAD MODULE: ',(LOADMOD,8,C),          X
               '   LENGTH: ',(PDS2STOR,3,X),                           X
               '   ENTRY POINT: ',(PDS2EPA,3,X)
CSECTMSG MSG   (BLANKS,6,C),'CURRENT CONTROL SECTION: ',CSECT
FSMSG    MSG   'CURRENT FIND STRING: ',(STRING,(R14),C)
ALMSG    MSG   'CURRENT ALIGNMENT IS ',(0(R1),11,W)
MAPMSG   MSG   (MAPID,,C),                                             X
               ' EXTENDS FROM ',ESDADDR,' TO ',(ESDNADDR+1,3,X),       X
               ' - LENGTH IS ',ESDLEN,' - SEGMENT ',(ESDSEGNO,1,H)
MAPENMSG MSG   (BLANKS,16,C),'END OF MAP'
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XLL - WHERE COMMAND PROCESSOR'
***********************************************************************
* "WHERE" COMMAND PROCESSOR                                           *
* THIS COMMAND DISPLAYS THE CONTROL SECTION AND RELATIVE LOCATION     *
* WITHIN THE CONTROL SECTION FOR A GIVEN HEXADECIMAL OFFSET.          *
* SYNTAX:                                                             *
*              W(HERE) HEXOFFSET                                      *
* WHERE: HEXOFFSET IS REQUIRED AND SPECIFIES A HEXADECIMAL VALUE      *
*        REPRESENTING AN OFFSET FROM THE LOAD POINT OF THE MODULE.    *
*        IF THE MODULE IS AN OVERLAY MODULE THEN ALL LOCATIONS IN     *
*        ALL OVERLAY SEGMENTS ARE DISPLAYED.                          *
***********************************************************************
         SPACE
WHERERTE DS    0H
         SPACE
         ST    R14,SAVE14          SAVE RETURN REGISTER
         LR    R12,R15
         USING WHERERTE,R12
         NI    WHERESW,255-WFOUND  INITIALIZE FLAGS
         MVI   CC,C'0'             SET UP ASA DOUBLE SPACING
         MVC   MAPCSECT,BLANKS     CLEAR CSECT NAME FOR DISPLAY
         SCAN  1,MAXLEN=10         SCAN FOR OFFSET TO LOCATE
         LTR   R8,R8               CHECK IF A VALID VALUE ENTERED
         BM    COMMONRT            IF INVALID, RETURN TO CALLER
         BNZ   WDOIT               IF NO OPERAND WAS ENTERED, THEN
         LA    R1,WNOOPMSG          SAY 'MISSING OPERAND"
         B     WHEREWRT             AND RETURN.
WDOIT    DS    0H                  ELSE PROCESS OPERAND
         LA    R1,0(R8,R15)        GET ADDRESS OF LAST CHARACTER
         BCTR  R1,0                IN OPERAND
         CLI   0(R1),C'.'          IF IT IS A PERIOD
         BNE   WNOTPD              THEN
         BCTR  R15,0                REDUCE OPERAND LENGTH BY 1
WNOTPD   DS    0H
         CLI   0(R8),C'+'          IF STARTS WITH A PLUS SIGN
         BNE   WNOTPLUS            THEN
         BCTR  R15,0                REDUCE OPERAND LENGTH BY 1
         LA    R8,1(,R8)            BUMP UP OPERAND POINTER
WNOTPLUS DS    0H
         LTR   R14,R15             IF LENGTH ZERO OR NEGATIVE
         BNP   WINVOP              THEN INVALID OPERAND
         CH    R14,=H'8'           IF LENGTH GREATER THAN 8
         BH    WINVOP              THEN INVALID OPERAND
         BCTR  R14,0               REDUCE LENGTH FOR EXECUTE
         EX    R14,WVERIFY         CHECK ALL VALID HEX CHARACTERS
         BNZ   WINVOP              IF BAD, INVALID OPERAND
         EX    R14,WMOVE           ELSE MOVE OPERAND TO WORK AREA
         EX    R14,WTRANS          TRANSLATE ABCDEF TO X'FA' ETC.
         EX    R15,WPACK           PACK INTO LOCATION (USING LENGTH+1)
         L     R2,WLOC             GET LOCATION INTO REGISTER
         L     R5,ESDBUFAD         GET ADDRESS OF ESD TABLE
         ICM   R6,15,ESDLKHDR      GET FIRST ESD ENTRY IN PHYS ORDER
WCHKZERO BZ    WEND                LOOP WHILE NOT ZERO
WLOOP    DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         XR    R14,R14             CLEAR INSERT REG
         ICM   R14,7,ESDADDR       GET ESD BEGINNING ADDRESS
         CR    R2,R14              IF LOCATION EQ OR GT THIS CSECT LOC
         BL    WNEXT               AND
         C     R2,ESDNADDR         LOCATION LESS THAN CSECT END
         BNL   WNEXT               THEN THIS IS THE ONE
         OI    WHERESW,WFOUND       INDICATE LOCATION FOUND
         LR    R0,R2                LOCATION MINUS ADDRESS
         SLR   R0,R14               GIVES OFFSET WITHIN CSECT
         ST    R0,WOFFSET           STORE OFFSET FOR DISPLAY
         WRTMSG WHEREMSG            DISPLAY INFO ON ESD ENTRY
         MVI   CC,C' '              ASA SINGLE SPACE NEXT MESSAGE
WNEXT    DS    0H
         ICM   R6,15,ESDLINKP       GET NEXT ESD ENTRY (PHYSICAL ORDER)
         B     WCHKZERO             AND CONTINUE LOOP
         SPACE
WINVOP   DS    0H                  INVALID OPERAND...
         LA    R1,WINVMSG          SAY SO
         B     WHEREWRT            AND RETURN
         SPACE
WEND     DS    0H                  END OF WHERE PROCESSING
         TM    WHERESW,WFOUND      IF LOCATION NOT FOUND,
         BO    GOODRET             THEN
         LA    R1,WNFMSG            SAY NOT FOUND
******** B     WHEREWRT             GO TO DISPLAY MESSAGE
         SPACE
WHEREWRT WRTMSG (R1)
         B     COMMONRT
         SPACE 2
WVERIFY  TRT   0(0,R8),WTRTBL      EXECUTED: VERIFY HEX CHARACTERS
WMOVE    MVC   WWORK(0),0(R8)      EXECUTED: MOVE OPERAND TO WORK AREA
WTRANS   TR    WWORK(0),XTCTBL     EXECUTED: TRANSLATE ABCDEF ETC.
WPACK    PACK  WLOC(5),WWORK(0)    EXECUTED: PACK DATA INTO LOCATION
         SPACE
WOFFSET  DS    F                   OFFSET FOR DISPLAY
WLOC     DS    F                   FULLWORD LOCATION OFFSET
         DS    C                   SLACK BYTE FOR CONVERSION
WWORK    DS    CL9                 WORK AREA FOR CONVERSION
         SPACE
WHERESW  DS    X                   FLAGS
WFOUND   EQU   B'10000000'         1 = OFFSET HAS BEEN LOCATED
         SPACE
WTRTBL   DC    256X'01'            TABLE TO VERIFY HEX CHARACTERS
         ORG   WTRTBL+C'A'
         DC    6X'00'              ABCDEF ARE OK
         ORG   WTRTBL+C'0'
         DC    10X'00'             0123456789 ARE OK
         ORG
         SPACE
WNOOPMSG MSG   '*MISSING OPERAND'
WINVMSG  MSG   '*INVALID OPERAND'
WHEREMSG MSG   (WLOC+1,3,X),'.  LOCATED AT +',(WOFFSET+1,3,X),         X
               ' IN CSECT ',(ESDNAME,8,C),' - SEGMENT ',(ESDSEGNO,1,H)
WNFMSG   MSG   (WLOC+1,3,X),'.  NOT WITHIN LOAD MODULE ',LOADMOD
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XLL - DIR COMMAND PROCESSOR'
***********************************************************************
* "DIR" COMMAND PROCESSOR                                             *
* THIS COMMAND DISPLAYS ALL MEMBER NAMES FOR THE CURRENTLY ALLOCATED  *
* LIBRARIES.  ALIASES ARE INCLUDED IN THE SEQUENCE.                   *
* SYNTAX:                                                             *
*              D(IR)  ARGUMENT                                        *
* WHERE: ARGUMENT IS OPTIONAL AND SPECIFIES A MEMBER NAME MASK        *
* CONSISTING OF VALID CHARACTERS AND/OR ASTERISKS.  THE NAME MAY BE   *
* SHORT, IN WHICH CASE IT IS PADDED WITH ASTERISKS.  THIS PROVIDES    *
* FOR ONLY THOSE MEMBER NAMES WHICH MATCH THE MASK SPECIFICATION TO   *
* BE DISPLAYED.  IF IT IS OMITTED, ALL MEMBER NAMES ARE DISPLAYED.    *
***********************************************************************
         SPACE
DIRRTE   DS    0H
         SPACE
         ST    R14,SAVE14          SAVE RETURN REGISTER
         LR    R12,R15
         USING DIRRTE,R12
         SCAN  1,MAXLEN=8          SCAN FOR AN OPERAND
         LTR   R8,R8
         BM    COMMONRT            IF SCAN ERROR, RETURN
         BP    DIROPER             IF NO OPERAND, THEN
         OI    DIRSW,DIRALLM        INDICATE TO PROCESS ALL MEMBERS
         B     DIROPEN             ELSE
DIROPER  DS    0H
         NI    DIRSW,255-DIRALLM   INDICATE NOT PROCESSING ALL MEMBERS
         LA    R0,DIRARG           POINT TO MOVE DESTINATION
         LA    R1,8                GET LENGTH OF MOVE
         LR    R14,R8              POINT TO MOVE SOURCE (OPERAND)
         ICM   R15,8,=C'*'         LENGTH PLUS FILL CHARACTER
         MVCL  R0,R14              MOVE OPERAND TO ARGUMENT, PAD='*'
         MVC   DIRMASK,DIRARG      ALSO MOVE TO MASK AREA
         TR    DIRARG,XTATBL       TRANSLATE ARGUMENT FROM '*' TO X'FF'
         TR    DIRMASK,XTMTBL      TRANSLATE MASK TO X'00'S AND X'FF'S
DIROPEN  DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    COMMONRT
         OPEN  SYSLIBD             OPEN TO READ DIRECTORY BLOCKS
DIRINIT  DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    DIRCLOSE
         NI    DIRSW,255-DIRDSHD   INITIALIZE SWITCH
         LA    R4,DIROUT           POINT TO OUTPUT AREA
         LA    R5,DIROUT+L'DIROUT-11 POINT TO LAST VALID OUTPUT AREA
         XR    R7,R7               CLEAR COUNT OF OUTPUT MEMBER NAMES
         XR    R3,R3               CLEAR COUNT OF TOTAL MEMBER NAMES
RDBLOCK  DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    DIRCLOSE
         GET   SYSLIBD             READ A DIRECTORY BLOCK
         LH    R2,0(,R1)           GET BYTE COUNT OF CURRENT BLOCK
         LA    R6,2(,R1)           POINT TO DATA IN BLOCK
         BCTR  R2,0                SUBTRACT 2 FROM BYTE COUNT
         BCTR  R2,0
CHECKFF  CLC   0(8,R6),=8X'FF'     IF FFFFFFFF (END OF DIRECTORY)
         BE    ENDDIR              THEN END OF MEMBERS. ELSE...
         TM    DIRSW,DIRALLM       IF PROCESSING ONLY SOME MEMBERS
         BO    DIRNOCHK             AND
         CLC   0(8,R6),DIRARG        ENTRY HIGHER THAN LAST POSSIBLE
         BH    ENDDIR                 THEN DON'T READ ANY UNNEC. BLOCKS
DIRNOCHK TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    DIRCLOSE
         CR    R4,R5               IF AT END OF CURRENT OUTPUT
         BL    DIROUTOK            THEN
         BAL   R14,DIROUTP          WRITE OUT A MEMBER LINE
DIROUTOK DS    0H
         TM    DIRSW,DIRALLM       IF PROCESSING ALL MEMBER NAMES
         BO    DIRACC              THEN ACCEPT THIS NAME
         MVC   DIRWORK,0(R6)       ELSE MOVE MEMBER NAME TO WORK AREA
         OC    DIRWORK,DIRMASK     "OR" IT WITH THE MASK
         CLC   DIRWORK,DIRARG      COMPARE WITH OPERAND ARGUMENT
         BNE   DIRSKIP             IF NOT EQUAL, SKIP THIS NAME
DIRACC   DS    0H
         TM    11(R6),X'80'        IF THIS IS AN ALIAS NAME
         BNO   DNTALIAS            THEN
         MVC   0(2,R4),=C'A:'       INDICATE ALIAS IN OUTPUT
DNTALIAS MVC   2(8,R4),0(R6)       MOVE MEMBER NAME TO OUTPUT
         LA    R7,1(,R7)           INCREMENT OUTPUT MEMBER NAME COUNT
         LA    R3,1(,R3)           INCREMENT TOTAL MEMBER NAME COUNT
         LA    R4,11(,R4)          BUMP OUTPUT POINTER
DIRSKIP  DS    0H
         IC    R1,11(,R6)          PICK UP COUNT OF USER DATA HALFWORDS
         SLL   R1,27               ERASE HIGH-ORDER 3 BITS
         SRL   R1,26               AND MULTIPLY VALUE BY 2
         LA    R1,12(,R1)          ADD 12 FOR MEMBER NAME AND TTR INFO
         ALR   R6,R1               BUMP UP DATA POINTER
         SR    R2,R1               BUMP DOWN REMAINING BYTE COUNT
         BZ    RDBLOCK             IF NO MORE DATA IN BLOCK, NEXT BLOCK
         B     CHECKFF             ELSE CONTINUE SCANNING THIS BLOCK
ENDDIR   DS    0H                  FF'S FOUND - LOGICAL END OF DIRBLKS
         LTR   R3,R3               IF NO MEMBER NAMES AT ALL
         BZ    DIRDOIT             OR
         LTR   R7,R7                ANY MEMBER NAMES LEFT OVER
         BZ    DIRFEOV             THEN
DIRDOIT  BAL   R14,DIROUTP          WRITE CURRENT OUTPUT
DIRFEOV  DS    0H
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BO    DIRCLOSE
         FEOV  SYSLIBD             FORCE END OF VOLUME TO GO TO NEXT
         B     DIRINIT             LIBRARY IN CONCATENATION & CONTINUE
         SPACE
DIREND   DS    0H                  REAL EOF ON DIRECTORY BLOCKS
         MVI   CC,C'-'             TRIPLE SPACE FOR END MESSAGE
         WRTMSG DIREMSG
DIRCLOSE DS    0H
         CLOSE SYSLIBD
         MVI   CC,C'0'
         B     GOODRET             RETURN TO MAINLINE
         SPACE
DIROUTP  DS    0H                  SUBROUTINE TO WRITE OUT MEMBER DATA
         SPACE
         TM    SWITCH,ATTN         CHECK FOR ATTENTION INTERRUPT
         BOR   R14
         TM    DIRSW,DIRDSHD       IF NO DATA SET HEADING DISPLAYED
         BO    DIRWRT1             THEN
         OI    DIRSW,DIRDSHD        INDICATE HEADING DISPLAYED
         L     R15,540              GET TCB ADDRESS
         L     R15,12(,R15)         GET TIOT ADDRESS
         AH    R15,SYSLIBD+40       ADD TIOT OFFSET
         ICM   R15,7,12(R15)        GET JFCB ADDRESS MINUS 16
         MVI   CC,C'0'
         WRTMSG DIRHEAD,USE15=YES   WRITE HEADING FOR LIBRARY
         MVI   CC,C'0'
DIRWRT1  DS    0H
         LTR   R3,R3               IF MEMBER COUNT = 0
         BNZ   DIRWRT2             THEN
         LA    R1,DIRNOMEM          SAY NO MEMBERS IN DATA SET
         B     DIRWRT
DIRWRT2  LA    R1,DIRMSG            WRITE CURRENT OUTPUT
DIRWRT   WRTMSG (1)
         MVI   CC,C' '
         MVI   DIROUT,C' '          CLEAR OUTPUT LINE TO BLANKS
         MVC   DIROUT+1(L'DIROUT-1),DIROUT
         LA    R4,DIROUT           POINT TO OUTPUT AREA
         XR    R7,R7               CLEAR COUNT OF OUTPUT MEMBER NAMES
         BR    R14                 RETURN
         SPACE 2
DIRSW    DC    X'00'
DIRDSHD  EQU   X'80'               1 = DATA SET HEADING DISPLAYED
DIRALLM  EQU   X'40'               1 = PROCESS ALL MEMBER NAMES
         SPACE
DIRARG   DS    CL8                 ARGUMENT FOR SELECTIVE MEMBER LIST
DIRMASK  DS    CL8                 MASK FOR SELECTIVE MEMBER LIST
DIRWORK  DS    CL8                 WORK AREA TO CHECK MEMBER NAME
         SPACE
DIROUT   DC    CL80' '             OUTPUT AREA TO BUILD MEMBER NAMES
         SPACE
DIRMSG   MSG   (DIROUT,,C)         FORMAT FOR OUTPUT DATA
         USING INFMJFCB-16,R15
DIRHEAD  MSG   'MEMBERS OF ',(JFCBDSNM,44,W),' ON ',(JFCBVOLS,6,C),':'
         DROP  R15
DIREMSG  MSG   'END OF DIRECTORY DISPLAY'
DIRNOMEM MSG   'NO MEMBERS FOUND'
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XLL - SCAN SUBROUTINE'
***********************************************************************
* "SCAN" SUBROUTINE                                                   *
* THIS ROUTINE IS INVOKED BY THE "SCAN" MACRO.                        *
* THIS ROUTINE EXTRACTS THE NEXT KEYWORD VALUE FROM THE CURRENT       *
* CONTROL STATEMENT.  ON RETURN THE FOLLOWING REGISTERS ARE SET:      *
* R8 - POINTS TO THE KEYWORD.                                         *
* R15 - CONTAINS THE LENGTH OF THE KEYWORD.                           *
* IF R15 IS ZERO, NO KEYWORD WAS FOUND.                               *
* IF R8 IS ZERO, NO KEYWORD WAS FOUND.                                *
* IF R8 IS NEGATIVE, AN ERROR WAS FOUND DURING SCANNING WHICH CAUSED  *
* A MESSAGE TO BE WRITTEN OUT TO THE SYSPRINT FILE.                   *
* THE FIELDS "SCANPTR" AND "SCANEPTR" ARE USED BY THIS SUBROUTINE AND *
* MUST BE SET BY THE CALLER ON THE FIRST CALL AFTER AN INPUT CONTROL  *
* STATEMENT IS READ.                                                  *
* THIS ROUTINE MODIFIES REGISTERS R1, R2, R15.                        *
* R2 IS THE BASE REGISTER.                                            *
* R15 IS THE ENTRY REGISTER.                                          *
* R14 IS THE LINK REGISTER - POINTS AS FOLLOWS:                       *
*     +0 IS THE RELATIVE NUMBER OF THE OPERAND BEING SCANNED FOR.     *
*     +1 IS THE MAXIMUM LENGTH (X'80' MEANS THERE IS NO MAXIMUM AND   *
*        QUOTED-STRING SYNTAX IS PERMITTED).                          *
*     +2 IS THE RETURN LOCATION TO BRANCH TO.                         *
***********************************************************************
         SPACE
SCAN     DS    0H
         SPACE
         LR    R2,R15
         USING SCAN,R2
         XR    R15,R15             CLEAR LENGTH REGISTER
         L     R1,SCANPTR          GET ADDRESS OF WHERE TO BEGIN SCAN
SNLOOP1  CLM   R1,7,SCANEPTR+1     LOOP UNTIL END OF STATEMENT
         BNL   NOMOREK             AT WHICH POINT NOTHING WAS FOUND
         CLI   0(R1),C' '          SCAN UNTIL A NON-BLANK IS FOUND
         BNE   GOTKWD
         LA    R1,1(,R1)
         B     SNLOOP1
GOTKWD   DS    0H                  NON-BLANK FOUND: START OF KEYWORD
         LR    R8,R1               SAVE ADDRESS: R8 -> THE KEYWORD
         CLI   0(R14),0            IF A COMMAND BEING SCANNED
         BNE   SNLOOP2             THEN
         CLI   0(R8),C'*'           IF A COMMENT
         BE    NOMOREK              THEN PRETEND NOTHING WAS ENTERED
SNLOOP2  CLM   R1,7,SCANEPTR+1     LOOP AGAIN UNTIL END OF STATEMENT
         BNL   GOTKEND             AT WHICH POINT END OF KEYWORD
         CLI   0(R1),C' '          IF A BLANK
         BE    GOTKEND             THEN TERMINATE KEYWORD
         TM    1(R14),X'80'        ELSE IF A MAXIMUM LENGTH REQUIRED
         BZ    SNINCR1             THEN DON'T LOOK FOR QUOTES
         CLI   0(R1),C''''         ELSE IF A SINGLE QUOTE
         BE    GOTQUOTE            THEN GO PROCESS QUOTED SUBSTRING
SNINCR1  LA    R1,1(,R1)           ELSE KEEP SCANNING
         B     SNLOOP2
GOTQUOTE DS    0H                  IF WE FOUND A QUOTE...
         LA    R1,1(,R1)           BUMP TO FOLLOWING CHARACTER
         CLM   R1,7,SCANEPTR+1     IF END OF CONTROL STATEMENT HERE
         BNL   SCANERR             THEN ERROR - MISSING END QUOTE
         CLI   0(R1),C''''         IF ANYTHING BUT ANOTHER QUOTE
         BNE   GOTQUOTE            THEN KEEP LOOPING HERE
         LA    R1,1(,R1)           IF ANOTHER QUOTE, BUMP PAST IT
         CLM   R1,7,SCANEPTR+1     IF END OF STATEMENT FOLLOWS
         BNL   GOTKEND             THEN END OF ENTIRE KEYWORD STRING
         CLI   0(R1),C''''         IF YET ANOTHER QUOTE,
         BE    GOTQUOTE            THEN 2 QUOTES IS OK IN QUOTES STRING
         CLI   0(R1),C' '          IF NONBLANK/NONQUOTE FOLLOWS,
         BNE   SNLOOP2             THEN RESUME UNQUOTED SCANNING. ELSE
GOTKEND  DS    0H                  END OF KEYWORD FOUND HERE...
         LR    R15,R1              ADDRESS OF TERMINATING LOCATION
         SR    R15,R8              MINUS START ==> LENGTH OF KEYWORD
         TM    1(R14),X'80'        IF NO LENGTH CHECK REQUESTED
         BO    RETSCAN             THEN RETURN WITH R15 = KEYWORD LEN
         CLM   R15,1,1(R14)        ELSE IF LENGTH EXCEEDS MAXIMUM
         BNH   RETSCAN             THEN
         TM    DIALOGSW,PARMSCAN    IF SCANNING PARM FIELD
         BZ    SCANWRT              THEN
         WTO   MF=(E,WTOIVPRM)       SAY INVALID PARM FIELD SPECIFIED
         B     SCANFAIL              WRITE TO PROGRAMMER AN ERROR MSG
SCANWRT  DS    0H                   ELSE
         CLI   0(R14),0             IF A COMMAND BEING SCANNED
         BNE   SCNKWDM              THEN
         LA    R8,TOOLONGC           SAY THAT
         B     SCANMSG               AND RETURN W/R15 = KEYWORD LENGTH
SCNKWDM  DS    0H                   ELSE
         LA    R8,TOOLONGO           SAY SO
         B     SCANMSG               AND RETURN W/R15 = KEYWORD LENGTH
SCANERR  DS    0H                  IF AN ERROR IN QUOTED STRING...
         LA    R8,NOENDQ            SAY ENDING QUOTE IS MISSING
******** B     SCANMSG               AND RETURN W/R15 = KEYWORD LENGTH
SCANMSG  WRTMSG (R8)
SCANFAIL XR    R15,R15             SET R15 = 0 (INDICATE NO KEYWORD)
         XR    R8,R8               SET R8 = -1 (NEGATIVE)
         BCT   R8,RETSCAN           AND RETURN TO CALLER.
NOMOREK  DS    0H                  NO KEYWORD FOUND...
         XR    R8,R8               CLEAR KEYWORD PTR (LENGTH STILL 0)
RETSCAN  ST    R1,SCANPTR          UPDATE SCAN POINTER
         B     2(,R14)             RETURN TO CALLER
         SPACE
NOENDQ   MSG   '*MISSING END QUOTE ON OPERAND'
TOOLONGC MSG   '*COMMAND NAME TOO LONG'
TOOLONGO MSG   '*OPERAND ',(0(R14),1,H),                               X
               ' CANNOT EXCEED ',(1(R14),1,H),' CHARACTERS'
         SPACE
WTOIVPRM WTO   MF=L,ROUTCDE=11,'XLL: INVALID PARM FIELD SPECIFIED'
         SPACE
         LTORG
         SPACE
         DROP  R2
         TITLE 'XLL - ATTENTION EXIT ROUTINE'
         SPACE
***********************************************************************
* THIS ROUTINE RECEIVES CONTROL WHEN AN ATTENTION INTERRUPTION IS
* RECEIVED.
***********************************************************************
         SPACE
ATTNEXIT DS    0H
         SPACE
         L     R2,8(,R1)           GET ADDRESS OF USER PARM LIST
         OI    SWITCH-COMMON(R2),ATTN  INDICATE ATTENTION OCCURRED
         BR    R14                 RETURN TO SYSTEM
         TITLE 'XLL - COMMON AREA'
COMMON   DS    0D
         SPACE
***********************************************************************
* SAVE AREAS
***********************************************************************
SAVEAREA DS    18F                 OS SAVE AREA
SAVED14  EQU   SAVEAREA+12,4,C'F'
SAVED15  EQU   SAVEAREA+16,4,C'F'
SAVED0   EQU   SAVEAREA+20,4,C'F'
SAVED1   EQU   SAVEAREA+24,4,C'F'
SAVEBASE DS    F                   BASE REGISTER SAVE FOR MAINLINE
SAVE14   DS    F                   SAVE AREA FOR COMMAND PROCESSORS
         SPACE
***********************************************************************
* SUBROUTINE ADDRESSES
***********************************************************************
SCANADDR DC    A(SCAN)             ADDRESS OF THE SCAN SUBROUTINE
WRTADDR  DC    V(WRITE)            ADDRESS OF THE WRITE SUBROUTINE
         SPACE
***********************************************************************
* COMMON RETURN POINTS USED BY ALL COMMAND PROCESSING SUBROUTINES     *
***********************************************************************
GOODRET  DS    0H                  COMMON RETURN POINT FOR SUCCESSES
         MVI   XLLCMD,C' '         CLEAR COMMAND VARIABLE TO BLANKS
         MVC   XLLCMD+1(L'XLLCMD-1),XLLCMD
COMMONRT DS    0H                  COMMON RETURN POINT FOR ALL COMMANDS
         L     R14,SAVE14          RELOAD RETURN REGISTER
         TM    SWITCH,ATTN         IF NO ATTENTION INTERRUPT OCCURRED,
         BZR   R14                 THEN RETURN TO MAINLINE
         NI    SWITCH,255-ATTN     ELSE RESET ATTENTION FLAG
         WRTMSG ATTNMSG            SEND USER A MESSAGE
         BR    R14                 RETURN TO MAINLINE
         SPACE
ATTNMSG  MSG   'ATTENTION INTERRUPT, ENTER NEW XLL COMMAND'
         SPACE
***********************************************************************
* WORK AREAS AND OTHER DECLARATIVES
***********************************************************************
DOUBLE   DS    D                   CONVERSION WORK AREA
TESTBYTE EQU   DOUBLE+7,1,C'C'     OVERLAY FOR ALIGNMENT TESTING
         SPACE
SCANPTR  DS    F                   USED BY THE SCAN SUBROUTINE
SCANEPTR DS    F                   USED BY THE SCAN SUBROUTINE
ERRCODE  DS    F                   USED WHEN OS MACRO FAILURE
ESDBUFAD DC    F'0'                POINTER TO ESD BUFFER
ESDBUFLN DC    F'0'                LENGTH OF ESD BUFFER
ESDENDAD DC    F'0'                ADDRESS OF END OF ESD ENTRIES
LOADLEN  DS    F                   LENGTH OF LOAD MODULE
LOADADDR DS    F                   ADDRESS OF LOAD MODULE
ADRSTART DS    F                   ADDRESS OF BEGINNING OF CSECT
CURRESD  DC    F'0'                ADDR OF ESD ENTRY FOR ACTIVE CSECT
ALGNADDR DC    F'0'                ADDRESS OF ALIGNMENT TABLE ENTRY
STRINGL  DC    H'0'                LENGTH OF SAVED STRING (0 = NONE)
TESTTYPE DS    C                   ESD TYPE FOR TESTING
ALGNTEST DS    CL11                USED TO DETERMINE ALIGNMENT SPEC.
         SPACE
SWITCH   DC    X'00'               VARIOUS SWITCHES AND FLAGS
         SPACE
CESDRECS EQU   B'10000000'         ON WHEN CESD RECORD(S) ARE FOUND
LOADED   EQU   B'01000000'         ON WHEN A MODULE IS LOADED
INTEXT   EQU   B'00100000'         ON WHEN READING A TEXT RECORD
SEGTAB   EQU   B'00010000'         ON WHEN A SEGMENT TABLE FOUND
SYSINTRM EQU   B'00001000'         ON WHEN SYSIN ALLOCATED TO TERMINAL
ATTN     EQU   B'00000100'         ON WHEN ATTENTION EXIT TAKEN
NEWSEG   EQU   B'00000010'         ON WHEN NEXT SEGMENT IS COMING
CLEANUP  EQU   B'00000001'         ON WHEN NAME RTE CALLED TO END UP
         SPACE
DIALOGSW DC    X'00'               VARIOUS FLAGS RELATING TO ISPF USAGE
         SPACE
ISPFMODE EQU   B'10000000'         ON WHEN ISPF DIALOG MODE IN USE
TBCREATE EQU   B'01000000'         ON WHEN TABLE MUST BE (RE)CREATED
PARMSCAN EQU   B'00100000'         ON WHEN SCANNING PARM FIELD
*        EQU   B'00010000'         RESERVED
*        EQU   B'00001000'         RESERVED
*        EQU   B'00000100'         RESERVED
*        EQU   B'00000010'         RESERVED
*        EQU   B'00000001'         RESERVED
         SPACE
ALIGNTBL DS    0X                  TABLE OF VALID ALIGNMENT SPEC'S
NOALIGN  DC    CL11'NOALIGN    ',B'00000000'
NOALMASK EQU   *-1,1,C'B'
HALFWORD DC    CL11'HALFWORD   ',B'00000001'
HALFMASK EQU   *-1,1,C'B'
FULLWORD DC    CL11'FULLWORD   ',B'00000011'
FULLMASK EQU   *-1,1,C'B'
DOUBWORD DC    CL11'DOUBLEWORD ',B'00000111'
DOUBMASK EQU   *-1,1,C'B'
ALIGNEND EQU   *                   END OF ALIGNMENT TABLE
         SPACE
         READ  DECB,SF,SYSLIB,,'S',MF=L DECB TO READ LOAD MOD RECORDS
         SPACE
BLANKS   DC    CL16' '             GENERAL PURPOSE BLANKS
STRING   DS    CL80                SAVED TEXT OF FIND STRING
DATAAREA DS    CL128               DATA AREA FOR STRING CONVERSION
MASKAREA DS    CL128               DATA AREA FOR COMPARE MASK
TESTAREA DS    CL128               DATA AREA FOR COMPARE OPERATION
CC       DC    C'1'                ASA CONTROL CHARACTER FOR WRITES
         SPACE
***********************************************************************
* MISCELLANEOUS CONSTANTS
***********************************************************************
         SPACE
$PRIVATE DC    CL8'$PRIVATE'
$SEGTAB  DC    CL8'$SEGTAB '
$ENTAB   DC    CL8'$ENTAB  '
         SPACE
***********************************************************************
* TRANSLATION TABLES
***********************************************************************
         SPACE
LWRTXTBL DC    C'0123456789ABCDEF' TABLE
LISTXTBL EQU   *-256                    FOR CONVERTING HEX TO CHARACTER
         SPACE
VALIDXTB DC    256X'01'            TABLE OF VALID HEX-STRING CHARACTERS
         ORG   VALIDXTB+C'A'       ABCDEF
         DC    6X'00'
         ORG   VALIDXTB+C'0'       0123456789
         DC    10X'00'
         ORG   VALIDXTB+C'*'       *
         DC    X'00'
         ORG
XTCTBL$  DC    (256-C'*')YL1(*-XTCTBL) TABLE TO BUILD HEX COMPARESTRING
XTCTBL   EQU   XTCTBL$-C'*'        REAL LABEL FOR ABOVE TABLE
         ORG   XTCTBL+C'A'
         DC    X'FAFBFCFDFEFF'     STANDARD HEX TRANSLATIONS
         ORG   XTCTBL+C'*'
         DC    X'FF'               TREAT ASTERISK AS ALL 1-BITS
         ORG
XTMTBL   DC    256X'00'            TABLE TO BUILD HEX COMPARE MASK
         ORG   XTMTBL+C'*'         CHANGES EVERYTHING TO 0-BITS
         DC    X'FF'               EXCEPT ASTERISKS WHICH BECOME 1-BITS
         ORG
XTATBL   DC    256YL1(*-XTATBL)    TABLE TO BUILD ARGUMENT STRING
         ORG   XTATBL+C'*'         LEAVES EVERYTHING AS IS
         DC    X'FF'               EXCEPT ASTERISKS WHICH BECOME 1-BITS
         ORG
NUMTBL   DC    256X'01'            TABLE TO VERIFY NUMERICS
         ORG   NUMTBL+C'0'
         DC    10X'00'
         ORG
SCANTBL  DS    XL256               DYNAMICALLY SET TBL 4 QUICK SCANNING
         SPACE 2
COMMAND  DS    CL8                 THIS IS WHERE THE COMMAND NAME GOES
KEYWORD  DS    CL8                 THIS IS WHERE THE MODULE NAME GOES
CSECT    DC    CL8' '              THIS IS WHERE THE CSECT NAME GOES
MAPCSECT DC    CL8' '              NAME OF THE CSECT TO BE MAPPED
         SPACE 2
* DATA AREAS USED IN ISPF DIALOG MODE
         SPACE
TABLE    DC    CL8' '              ISPF TABLE NAME FOR DIALOG MODE
PANEL    DC    CL8' '              ISPF PANEL NAME FOR DIALOG MODE
MSGID    DC    CL8' '              ISPF MESSAGE ID FOR DIALOG MODE
XLLCMD   DC    CL80' '             ISPF INPUT FIELD
XLLROW   DC    CL79' '             ISPF OUTPUT FIELD
@ISPLINK DS    A                   ADDRESS OF ISPLINK MODULE
ISPPARMS DS    0A                  PARAMETERS FOR ISPLINK
ISPPARM1 DS    A
ISPPARM2 DS    A
ISPPARM3 DS    A
ISPPARM4 DS    A
ISPPARM5 DS    A
ISPPARM6 DS    A
ISPPARM7 DS    A
         EJECT
         DS    0F                  ALIGN THE FOLLOWING
BLDLLIST EQU   *                   BLDL LIST WITH 1 ENTRY
H1       DC    H'1'                THIS DOUBLES AS A LITERAL CONSTANT
         DC    H'58'
LOADMOD  DC    CL8' '              LOAD MODULE NAME FOR BLDL AND LOAD
TTR      DS    CL3
K        DS    CL1
Z        DS    CL1
C        DS    CL1
         DS    CL44
BLDLEND  EQU   *                   END OF THE BLDL LIST
         ORG   LOADMOD             THE FF. MACRO MAPS DIRECTORY ENTRY
         SPACE 4
         IHAPDS DSECT=NO,PDSBLDL=YES
         SPACE 4
         ORG   BLDLEND
         EJECT
***********************************************************************
* DATA CONTROL BLOCKS                                                 *
***********************************************************************
         SPACE
         PRINT NOGEN
         SPACE
SYSIN    DCB   DDNAME=SYSIN,MACRF=GL,DSORG=PS,EODAD=EOF,               X
               RECFM=FB,LRECL=80
         SPACE
SYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS,                      X
               RECFM=FBA,LRECL=121,BLKSIZE=6171
         SPACE
SYSLIB   DCB   DDNAME=SYSLIB,MACRF=R,DSORG=PO,RECFM=U,EODAD=ENDRECS
         SPACE
SYSLIBD  DCB   DDNAME=SYSLIB,MACRF=GL,DSORG=PS,RECFM=F,LRECL=256,      X
               BLKSIZE=256,EODAD=DIREND
         SPACE
         PRINT GEN
         SPACE
COMMNEND EQU   *                   DISPLAY LOCATION OF END OF COMMON
COMMNLNG EQU   *-COMMON            DISPLAY LENGTH OF COMMON AREA
         SPACE
         DROP  R5,R6,R13
         EJECT
***********************************************************************
* *** DSECTS ***                                                      *
***********************************************************************
         SPACE
ALTDDS   DSECT
*
*    ALTERNATE DDNAME LIST FOR STANDARD UTILITIES:
*
ALTDDLEN DS    H
         DS    CL8    1    SYSLIN
         DS    CL8    2    NAME (FOR LKED)
         DS    CL8    3    SYSLMOD
ALTLIB   DS    CL8    4    SYSLIB
ALTIN    DS    CL8    5    SYSIN
ALTPRINT DS    CL8    6    SYSPRINT
         DS    CL8    7    SYSPUNCH
         DS    CL8    8    SYSUT1
         DS    CL8    9    SYSUT2
         SPACE
ESDTABLE DSECT ,                   LAYOUT OF ESD TABLE
         SPACE
ESDTBLEN DS    F                   LENGTH OF THIS BUFFER INCLUDING HDR
*                  (WHICH ALSO EQUALS THE OFFSET OF END OF THIS BUFFER)
ESD#ENTS DS    F                   NUMBER OF ENTRIES IN BUFFER
ESDAVAIL DS    F                   OFFSET OF FIRST UNUSED BUFFER SLOT
ESDLKHDR DS    F                   PTR TO FIRST ENTRY IN PHYSICAL ORDER
         SPACE
ESDENTRY DS    0C                  CESD ENTRIES BEGIN HERE
*
* NOTE THAT THE FIRST 16 BYTES OF EACH ESD ENTRY CORRESPOND TO THE
* LOAD MODULE CESD ENTRY MAPPING.
*
ESDNAME  DS    CL8                 EXTERNAL SYMBOL NAME (CSECT NAME)
ESDTYPE  DS    X                   TYPE OF ENTRY (00=SD,04=PC,05=CM)
ESDSD    EQU   X'00'               SECTION DEFINITION
ESDLD    EQU   X'01'               LABEL REFERENCE
ESDER    EQU   X'02'               EXTERNAL REFERENCE
ESDPR    EQU   X'06'               PSEUDO REGISTER
ESDPC    EQU   X'04'               PRIVATE CODE
ESDCM    EQU   X'05'               COMMON
ESDWX    EQU   X'0A'               WEAK EXTERNAL REFERENCE
ESDPCOV  EQU   X'14'               PRIVATE CODE MARKED DELETE
*                                  (SEGMENT TABLE OR ENTRY TABLE)
ESDADDR  DS    XL3                 ASSIGNED ADDRESS OF SYMBOL (REL.)
ESDSEGNO DS    X                   SEGMENT NUMBER (OVERLAY ONLY)
ESDARG   EQU   ESDADDR,*-ESDADDR,C'X'  COMPARE ARGUMENT FOR LINKING
ESDLEN   DS    XL3                 LENGTH OF CONTROL SECTION
         SPACE
ESDNADDR DS    XL4                 OFFSET OF NEXT CSECT (ADDR + LENGTH)
ESDLINKP DS    AL4                 CHAIN POINTER FOR PHYSICAL ORDER
         SPACE
ESDENTLN EQU   *-ESDENTRY          LENGTH OF ONE OF OUR ESD ENTRIES
         SPACE
ESDHDRLN EQU   ESDENTRY-ESDTABLE   LENGTH OF THE ESD TABLE HEADER
         SPACE
*** EQUATES ***
         SPACE
INIT#ENT EQU   16                  INITIAL NUMBER OF ENTRIES PER BUFFER
         SPACE
INITLNTH EQU   INIT#ENT*ESDENTLN   LENGTH OF ALL ENTRIES WITHOUT HEADER
         EJECT
OVLYTBL  DSECT ,                   OVERLAY SEGMENT CONTROL TABLE
         SPACE
***********************************************************************
* THERE IS ONE 16-BYTE ENTRY IN THIS TABLE FOR EACH SEGMENT IN THE    *
* LOAD MODULE; EACH ENTRY CONTAINS THE ADDRESS OF THE IN-STORAGE      *
* BUFFER ALLOCATED TO HOLD ALL THE CSECTS FROM ONE SEGMENT.  THE      *
* SEGMENT NUMBER IS USED AS AN INDEX INTO THE TABLE. SINCE THERE IS   *
* NO ZERO-NUMBERED SEGMENT, THE FIRST 16 BYTES OF THE TABLE ARE USED  *
* TO HOLD CONTROL INFORMATION ABOUT THE OVERLAY SEGMENTS AND TABLE.   *
***********************************************************************
         SPACE
OVSEGADR DS    A                   ADDRESS OF MODULE SEGMENT BUFFER
OVSEGHI  DS    A                   HIGH BOUND OF MODULES IN SEGMENT
OVSEGLO  DS    A                   LOW BOUND OF MODULES IN SEGMENT
OVSEGLEN DS    A                   LENGTH OF SEGMENT (OVSEGHI-OVSEGLO)
         SPACE
         ORG   OVLYTBL             DEFINE CONTENTS OF ENTRY 0
         SPACE
OVTBLEN  DS    F                   LENGTH OF OVERLAY CONTROL TABLE
CURSEG#  DS    H                   CURRENT SEGMENT NUMBER
MAXSEG#  DS    H                   MAXIMUM SEGMENT NUMBER
         SPACE
         ORG
         SPACE
OVENTLB  EQU   *-OVLYTBL           LENGTH OF EACH ENTRY IN TABLE
OVSHIFT  EQU   4                   AMOUNT TO SHIFT REGISTER FOR INDEX
         EJECT
         IEFJFCBN ,                MAP THE JOB FILE CONTROL BLOCK
         EJECT
         TITLE 'XLL - WRITE MODULE FOR GENERAL PURPOSE MESSAGE OUTPUT'
WRITE    CSECT
         SAVE  (14,12),,WRITE
         BALR  R12,0
         USING *,12
         LA    R1,WRTSAVE
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R9,R13              SAVE HSA ADDRESS
         LR    R13,R1
         USING COMMON,R9
***********************************************************************
* THIS SUBROUTINE USES NONSTANDARD LINKAGE.                           *
* REGISTER 14 DOES NOT CONTAIN RETURN ADDRESS.                        *
* REGISTER 1 DOES NOT CONTAIN ADDRESS OF PARAMETER LIST.              *
* REGISTER 0 POINTS TO A PARAMETER LIST AS FOLLOWS:                   *
*    +0 ... S-TYPE ADDRESS OF MESSAGE STRING                          *
*    +2 IS THE RETURN ADDRESS (NOT IN REG14)                          *
***********************************************************************
* CALLING SEQUENCE IS AS FOLLOWS:                                     *
*        ST    15,0(,13)           TEMPORARY REG 15 SAVE IF NEEDED    *
*        L     15,=V(WRITE)        ADDRESS OF THIS ROUTINE            *
*        BALR  0,15                CALL ROUTINE PASSING PLIST IN REG0 *
*        DC    S(MSG)              ADDRESS OF MESSAGE STRING          *
*        ...   INSTRUCTIONS CONTINUE HERE                             *
***********************************************************************
         SPACE
***********************************************************************
* CHECK FOR ATTENTION INTERRUPT.  IF ANY, RETURN WITHOUT PROCESSING   *
***********************************************************************
         SPACE
         TM    SWITCH,ATTN
         BO    WRTRET
         SPACE
***********************************************************************
* SET UP OUR OWN SAVE AREA FOR QUICK REFERENCE TO S-CON REGISTERS     *
***********************************************************************
         MVC   REGSAVE(4*(12+1)),SAVED0      GET CALLER'S REGS 0-12
         MVC   REGSAVE+(4*13)(4),WRTSAVE+4   GET CALLER'S REG 13
         MVC   REGSAVE+(4*14)(4),SAVED14     GET CALLER'S REG 14
         MVC   REGSAVE+(4*15)(4),SAVEAREA    GET CALLER'S REG15
*
* THE ABOVE ASSUMES THAT THE CALLER OF THIS ROUTINE ISSUED THE
* INSTRUCTION "ST 15,0(,13)".
*
         L     R1,REGSAVE+(4*0)    PICK UP CALLER'S REG 0 IN OUR REG 1
         LOADSA 0(R1),ERRET=BADPARM GET ADDR OF MESSAGE STRING IN R15
         LA    R14,0(,R15)         SAVE IT TO POINT TO START OF MESSAGE
         MVC   CCC(1),CC           SAVE CONTROL CHARACTER
         LA    R15,SYSPRINT        GET ADDRESS OF PRINT DCB
         ST    R15,DCBADDR         SAVE IT
         LA    R3,WRAREA+L'WRAREA  POINT TO END OF WORK AREA
         MVI   WRAREA,C' '         INIT WORK AREA TO BLANKS
         MVC   WRAREA+1(L'WRAREA-1),WRAREA
         LA    R2,WRAREA           INITIALIZE OUTPUT POINTER
         LR    R1,R14              INITIALIZE SCANNING POINTER
WRTLOOP1 TM    0(R1),X'C0'         SCAN MESSAGE STRING UNTIL
         BZ    WRTGCNTL             A BYTE CONTAINING B'00......' IN
         LA    R1,1(,R1)            LEFT HALF IS ENCOUNTERED.
         B     WRTLOOP1            THAT WILL BE A CONTROL BYTE.
WRTGCNTL DS    0H                  R1 -> CONTROL BYTE
         LR    R15,R1              CURRENT LOCATION MINUS PREV START...
         SR    R15,R14             R15 = LENGTH OF CHARACTERS SO FAR
         BNP   WRTLZERO            IF ZERO, NO INTERVENING DATA, SKIP
         BCTR  R15,0               ADJUST FOR EXECUTE
         EX    R15,WRTMVC14        MOVE INTERVENING DATA TO OUTPUT
         LA    R2,1(R15,R2)        BUMP OUTPUT POINTER PAST MOVED DATA
WRTLZERO DS    0H
         CLI   0(R1),X'3F'         IF HEX 3F FOUND (END-OF-MESSAGE)
         BE    WRTFINIS            THEN END OF MESSAGE, FINISH. ELSE...
* WE HAVE A 4-BYTE CONTROL SEQUENCE AS FOLLOWS:
* +0 IS A 1-BYTE TYPE CODE
* +1 IS A 1-BYTE LENGTH CODE
* +2 IS THE S-CON OF THE DATA
* DETERMINE LENGTH OF DATA TO BE WRITTEN
         TM    1(R1),X'80'         IF THIS IS A REGISTER-LENGTH SPEC,
         BZ    WRTNOREG            THEN...
         IC    R14,1(,R1)          LENGTH CODE CONTAINS REGISTER NUMBER
         SLL   R14,25              ERASE HIGH-ORDER INDICATOR BIT
         SRL   R14,25              LEAVING THE REGISTER NUMBER ONLY
         LTR   R14,R14             IF REGISTER NUMBER IS ZERO
         BNP   WRTERROR            THEN ERROR, BASE CANNOT BE ZERO
         SLA   R14,2               ELSE MULTIPLY BY 4 FOR INDEX
         L     R4,REGSAVE(R14)     LENGTH=CONTENTS OF CALLER'S REGISTER
         LTR   R4,R4               IF ZERO LENGTH,
         BZ    WRTCOMMN            THEN BYPASS PROCESSING THIS FIELD
         CH    R4,=H'128'          IF LENGTH EXCEEDS THE MAXIMUM
         BNL   WRTERROR            THEN ERROR - LENGTH TOO BIG
         B     AFTREGLN            ELSE OK, PROCESS THE LENGTH
WRTNOREG DS    0H                  LENGTH IS NOT REGISTER BUT ACTUAL...
         XR    R4,R4               CLEAR INSERT REG
         ICM   R4,1,1(R1)          PICK UP LENGTH FROM STRING
         BZ    WRTERROR            IF ZERO, PARAMETER ERROR, REJECT
AFTREGLN DS    0H                  LENGTH IS OK, NOW USE IT
         LOADSA 2(R1)              SET R15 = ADDRESS OF THE DATA
* NOW R15 CONTAINS THE VIRTUAL STORAGE ADDRESS OF THE DATA TO BE
* MOVED TO THE PLACE THAT R2 POINTS TO.
         XR    R14,R14             CLEAR INSERT REG
         IC    R14,0(,R1)          PICK UP TYPE INDICATOR
         B     WRTTYPE(R14)        BRANCH DEPENDING ON TYPE
WRTTYPE  B     TYPEW               X'00' - TYPE = W
         B     TYPEC               X'04' - TYPE = C
         B     TYPEX               X'08' - TYPE = X
         B     TYPEFH              X'0C' - TYPE = F OR H
*                                  ANYTHING ELSE - ASSUME TYPE W
         EJECT
***********************************************************************
* TYPE W - CHARACTER TERMINATED BY FIRST BLANK
***********************************************************************
         SPACE
TYPEW    DS    0H
         SPACE
         LR    R0,R4               PICK UP DATA LENGTH
         LA    R15,0(,R15)         PURIFY INPUT REGISTER
         LR    R14,R15             SAVE ADDRESS OF START OF INPUT
WLOOP1   CLI   0(R14),C' '         SCAN FOR FIRST BLANK
         BE    WENDLOOP             WHILE
         LA    R14,1(,R14)          BUMPING INPUT POINTER
         BCT   R0,WLOOP1            UNTIL END OF DATA
WENDLOOP SR    R14,R15             GET LENGTH OF DATA TO BE MOVED
         BNP   WRTCOMMN            IF ZERO, NO MOVE, CONTINUE
         B     TWCMOVE             GO TO ACTUALLY MOVE THE DATA
         EJECT
***********************************************************************
* TYPE C - CHARACTER INCLUDING ALL BLANKS
***********************************************************************
         SPACE
TYPEC    DS    0H
         SPACE
         LR    R14,R4              PICK UP DATA LENGTH
TWCMOVE  DS    0H                  MOVE FOR TYPES W AND C
         BCTR  R14,0               REDUCE FOR EXECUTE
         EX    R14,WRTMVC15        MOVE DATA TO OUTPUT AREA
         EX    R14,TRCHAR          TRANSLATE DATA TO PRINTABLE
         LA    R2,1(R14,R2)        BUMP UP OUTPUT POINTER
         B     WRTCOMMN            GO FINISH UP
         EJECT
***********************************************************************
* TYPE X - HEX TO BE CONVERTED TO  READABLE DISPLAY
***********************************************************************
         SPACE
TYPEX    DS    0H
         SPACE
         LR    R14,R4              PICK UP DATA LENGTH
         XR    R0,R0               CLEAR INSERT REG
XLOOP    IC    R0,0(,R15)          PICK UP BYTE OF HEX INPUT DATA
         STC   R0,1(,R2)           STORE INTO OUTPUT AREA 2ND BYTE
         NI    1(R2),X'0F'         ZERO LEFT HALF, KEEP RIGHT HALF
         SRL   R0,4                ISOLATE LEFT HEX DIGIT
         STC   R0,0(,R2)           STORE INTO OUTPUT AREA 1ST BYTE
         TR    0(2,R2),LWRTXTBL              TRANSLATE TO PRINTABLE
         LA    R2,2(,R2)           BUMP UP OUTPUT POINTER
         LA    R15,1(,R15)         BUMP UP INPUT POINTER
         BCT   R14,XLOOP           CONTINUE UNTIL LENGTH EXHAUSTED
         B     WRTCOMMN            GO FINISH UP
         EJECT
***********************************************************************
* TYPE H OR F - HALFWORD OR FULLWORD, TO BE DISPLAYED AS NUMERIC
***********************************************************************
         SPACE
TYPEFH   DS    0H
         SPACE
         CH    R4,=H'4'            IF GREATER THAN MAXIMUM LENGTH OF 4,
         BH    WRTERROR            THEN PARAMETER ERROR, REJECT
         IC    R14,MASKS-1(R4)     PUT MASK FOR ICM INSTRUCTION IN R14
         XR    R0,R0               CLEAR INSERT REG
         EX    R14,WRTICM          LOAD R0 WITH FULLWORD/HALFWORD
         CVD   R0,WDOUBLE          CONVERT TO PACKED DECIMAL
         MVI   CONVWORK,C' '       CLEAR DATA AREA TO BLANKS
         MVC   CONVWORK+1(L'CONVWORK-1),CONVWORK
         MVC   CONVWORK(12),=X'F02020202020202020202020' EDIT-PATTERN
         LR    R15,R1              SAVE INPUT SCAN REGISTER
         LA    R1,CONVWORK+11      INITIALIZE MARK REGISTER
         EDMK  CONVWORK(12),WDOUBLE+2  FORMAT THE NUMERIC VALUE
         BNM   NOMINSGN            IF RESULT NEGATIVE,
         BCTR  R1,0                THEN ADJUST MARK REGISTER
         MVI   0(R1),C'-'           AND MOVE MINUS SIGN IN.
NOMINSGN DS    0H                  ANYHOW...
         MVC   0(12,R2),0(R1)      MOVE EDITED VALUE TO OUTPUT
         LR    R1,R15              RESTORE SCANNING REGISTER
         LA    R14,12              SET LENGTH OF MOVED OUTPUT FOR LOOP
FLOOP1   CLI   0(R2),C' '          SCAN FOR FIRST BLANK FOLLOWING VALUE
         BE    WRTCOMMN
         LA    R2,1(,R2)
         BCT   R14,FLOOP1          LOOP FOR BLANKS UNTIL MAX LENGTH
         B     WRTCOMMN            THEN GO FINISH
         EJECT
WRTERROR DS    0H
         SPACE
***********************************************************************
* UNABLE TO CONSTRUCT MESSAGE SEGMENT - JUST PUT IN SPECIAL CHAR AND GO
***********************************************************************
         SPACE
         MVI   0(R2),C'?'          STICK IN DUMMY CHARACTER
         LA    R2,1(,R2)           BUMP UP OUTPUT POINTER
         SPACE
WRTCOMMN DS    0H
         SPACE
***********************************************************************
* ALL COME TOGETHER HERE TO BUMP TO THE NEXT SEGMENT
***********************************************************************
         SPACE
         CR    R2,R3               IF AT END OF OUTPUT AREA
         BNH   WRTYETOK            THEN (OUT OF ROOM)...
         LA    R1,WTO1002           ADDRESS OF WTO MESSAGE
         LA    R2,1002              ABEND CODE
         B     WRTABEND             GO BLOW UP
WRTYETOK DS    0H                  ELSE STILL ENOUGH ROOM FOR MESSAGE
         LA    R1,4(,R1)           BUMP PAST CONTROL FIELD
         LR    R14,R1              SET POINTER TO START OF NEW DATA
         B     WRTLOOP1            CONTINUE PROCESSING FIELDS
         SPACE 2
BADPARM  DS    0H                  INVALID S-TYPE SPECS ON INPUT
         LA    R1,WTO1001          ADDRESS OF WTO MESSAGE
         LA    R2,1001             ABEND CODE
         B     WRTABEND            GO BOMB OUT
         SPACE 2
WRTFINIS DS    0H
         TM    DIALOGSW,ISPFMODE   IF IN ISPF DIALOG MODE,
         BZ    WRTPRINT            THEN...
         TM    DIALOGSW,TBCREATE    IF TABLE MUST BE CREATED
         BZ    WRTNOCRE             THEN
         NI    DIALOGSW,255-TBCREATE RESET SWITCH
* ISPEXEC TBCREATE TABLE-NAME () NAME-LIST NOWRITE REPLACE
         LA    R1,WRTTBA1          POINT TO TBCREATE PARAMETERS
         L     R15,@ISPLINK        CALL ISPLINK TO RESET TABLE
         BALR  R14,R15
WRTNOCRE DS    0H
         MVC   XLLROW,WRAREA       MOVE OUR DATA TO ISPF AREA
*
* THE FOLLOWING THREE INSTRUCTIONS ARE PRESENT BECAUSE ISPF FORCES
* LEFT JUSTIFICATION FOR ALL TABLE VARIABLES.  TO DEFEAT THIS, WE
* FORCE THE FIRST CHARACTER OF A TABLE ROW VARIABLE TO BE ALWAYS
* NONBLANK.  THIS CAN BE DONE BY CHANGING INITIAL BLANKS TO NULLS,
* WHICH WILL DISPLAY AS BLANKS ON THE SCREEN (AS LONG AS NO ONE
* SUBMITS AN APAR COMPLAINING THAT ISPF DOES NOT TRANSLATE INVALID
* CHARACTERS ON TABLE DISPLAYS).
*
         CLI   XLLROW,C' '         IF FIRST CHAR OF TABLE VAR IS BLANK
         BNE   *+8                 THEN
         MVI   XLLROW,X'00'         CHANGE IT TO A NULL CHARACTER
* ISPEXEC TBADD TABLE-NAME
         LA    R1,WRTADD1          POINT TO TBADD PARAMETERS
         L     R15,@ISPLINK        CALL ISPLINK TO ADD TO TABLE
         BALR  R14,R15
         B     WRTRET
WRTPRINT DS    0H                  ELSE WRITE TO SYSPRINT
         L     R1,DCBADDR          GET PRINT DCB ADDRESS
         PUT   (1),CCC              WRITE OUT THE RECORD
         SPACE 2
WRTRET   DS    0H
         L     R13,4(,R13)         GO BACK NOW
         LM    R14,12,12(R13)
         L     R15,20(,R13)        PICK UP SAVED REGISTER 0 IN R15
         B     2(,R15)             BRANCH TO RETURN ADDRESS IN CALLER
         SPACE 4
WRTABEND DS    0H                  CATASTROPHIC ERROR IN WRITE ROUTINE
         SPACE
         WTO   MF=(E,(1))          TELL THE OPERATOR
         LR    R1,R2               GET ABEND CODE IN CORRECT REG
         ABEND (1),DUMP            GOODBYE FOREVER
         EJECT
* EXECUTED INSTRUCTIONS
         SPACE
TRCHAR   TR    0(0,R2),CHARTBL     TRANSLATE CHAR DATA TO PRINTABLE
WRTMVC14 MVC   0(0,R2),0(R14)      MOVE DATA TO OUTPUT
WRTMVC15 MVC   0(0,R2),0(R15)      MOVE DATA TO OUTPUT
WRTICM   ICM   R0,0,0(R15)         LOAD R0 WITH FULLWORD OR HALFWORD
         SPACE
* CONSTANTS
         SPACE
WRTADD1  DC    A(WRTTBADD)         PARAMETER FOR ISPLINK
WRTADD2  DC    X'80',AL3(TABLE)    PARAMETER FOR ISPLINK
WRTTBA1  DC    A(WRTTBC1)          PARAMETER FOR ISPLINK
WRTTBA2  DC    A(TABLE)            PARAMETER FOR ISPLINK
WRTTBA3  DC    A(WRTTBC3)          PARAMETER FOR ISPLINK
WRTTBA4  DC    A(WRTTBC4)          PARAMETER FOR ISPLINK
WRTTBA5  DC    A(WRTTBC5)          PARAMETER FOR ISPLINK
WRTTBA6  DC    X'80',AL3(WRTTBC6)  PARAMETER FOR ISPLINK
WRTTBADD DC    C'TBADD'            PARAMETER FOR ISPLINK
WRTTBC1  DC    C'TBCREATE'         PARAMETER FOR ISPLINK
WRTTBC3  DC    C'()'               PARAMETER FOR ISPLINK
WRTTBC4  DC    C'(XLLROW)'         PARAMETER FOR ISPLINK
WRTTBC5  DC    C'NOWRITE'          PARAMETER FOR ISPLINK
WRTTBC6  DC    C'REPLACE'          PARAMETER FOR ISPLINK
         SPACE
MASKS    DS    0H                  USED IN EXECUTED ICM INSTRUCTION
         DC    B'00000001'         ICM MASK TO LOAD DATA LENGTH 1
         DC    B'00000011'         ICM MASK TO LOAD DATA LENGTH 2
         DC    B'00000111'         ICM MASK TO LOAD DATA LENGTH 3
         DC    B'00001111'         ICM MASK TO LOAD DATA LENGTH 4
         EJECT
         LTORG
         EJECT
WTO1001  WTO   MF=L,                                                   X
               'XLL/WRITE: INVALID PARAMETERS PASSED TO SUBROUTINE'
         SPACE
WTO1002  WTO   MF=L,                                                   X
               'XLL/WRITE: MESSAGE EXCEEDS MAXIMUM PERMISSIBLE LENGTH'
         SPACE
CHARTBL  DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'.ABCDEFGHI......'
         DC    C'.JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         EJECT
WRTSAVE  DS    18F                 OS SAVE AREA
REGSAVE  DS    16F                 SA FOR CALLER'S S-CON REGS
WDOUBLE  DS    D                   FOR CONVERSION OF NUMERIC DATA
DCBADDR  DS    A                   ADDRESS OF DCB FOR PUTS
CONVWORK DS    CL24                CONVERSION DATA AREA
WRAWTO   DS    AL4                 WTO HEADER IF HAVE TO USE WTP
         ORG   *-1                 REDEFINE AS...
CCC      DS    C                   ASA CONTROL CHARACTER AREA
WRAREA   DS    CL256               DATA AREA TO CONSTRUCT MESSAGE
         SPACE
         END
./ ADD NAME=XLNKLST  0100-07332-07332-0900-00812-00812-00000-SEB
         TITLE 'XLNKLST - TSO COMMAND TO ALLOCATE THE LINK LIST'
***********************************************************************
*                                                                     *
* XLNKLST - TSO COMMAND TO ALLOCATE THE LINK LIST                     *
*                                                                     *
* SYNTAX:   XLNKLST 'FILENAME' LPA/NOLPA LINKLIST/NOLINKLIST REUSE    *
*                                                                     *
* PROCESSING:  SCAN THE LPA LIST AND THE LINK LIST TABLE AND          *
*              ALLOCATE THE DATASETS THEREIN TO THE REQUESTED DDNAME. *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    CVT ADDRESS
R4       EQU   4    LPA LIST ADDRESS
R5       EQU   5    LINK LIST TABLE ADDRESS
R6       EQU   6    COUNT OF LIBRARIES TO ALLOCATE
R7       EQU   7    PDL ADDRESS
R8       EQU   8    USED TO LOOP THROUGH LIBRARY ENTRIES
R9       EQU   9    USED TO LOOP THROUGH LIBRARY ENTRIES
R10      EQU   10   POINTER TO DDNAMES FOR CONCATENATION
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XLNKLST  CSECT
XLNKLST  AMODE 31
XLNKLST  RMODE 24
         SPACE 1
         SAVE  (14,12),,XLNKLST_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XLNKLST,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
***********************************************************************
* INITIALIZATION                                                      *
***********************************************************************
         USING CPPL,R2             ADDRESS INPUT CPPL
         ST    R2,DFCPPLP          SAVE IT FOR DAIRFAIL
         XC    ANSWER,ANSWER
         MVC   IOPLUPT,CPPLUPT
         MVC   IOPLECT,CPPLECT
         MVC   PPLUPT,CPPLUPT
         MVC   PPLECT,CPPLECT
         LA    R14,ECB
         ST    R14,IOPLECB
         L     R15,=V(XFLNKPCL)
         LA    R0,ANSWER
         L     R1,CPPLCBUF
         STM   R14,R1,PPLECB
         ST    R13,PPLUWA          USER WORK AREA = "DATD"
         MVC   PTLIST(PTLISTL),SPTLIST
         LA    R14,1
         LA    R15,OUTHDR
         LA    R0,L'OUTLINE+4
         SLL   R0,16
         STM   R14,R0,OLD
         XC    DDBUFFER,DDBUFFER
         EJECT
***********************************************************************
*                                                                     *
* PARSE THE INPUT COMMAND                                             *
*                                                                     *
***********************************************************************
         SPACE 1
         XC    ECB,ECB
         CALLTSSR EP=IKJPARS,MF=(E,PPL)
         LTR   R15,R15
         BNZ   BLOWUP
         L     R7,ANSWER
         USING PDL,R7
         EJECT
***********************************************************************
*                                                                     *
* SET UP POINTERS TO LPA LIST AND LINK LIST.                          *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R3,X'10'
         USING CVT,R3
         L     R2,CVTSMEXT         POINT TO CVT VIRTUAL STORAGE EXT
         USING CVTVSTGX,R2
         L     R4,CVTEPLPS
         USING LPAT,R4
         L     R5,CVTLLTA
         USING LLT,R5
         EJECT
***********************************************************************
*                                                                     *
* FIRST, DETERMINE HOW MUCH SPACE WE NEED TO STORE DDNAMES.           *
* THIS IS CALCULATED FROM THE NUMBER OF LIBRARIES IN THE LPA LIST     *
* PLUS THE NUMBER OF LIBRARIES IN THE LINK LIST.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R6,R6
         CLI   XFLPA+1,2           IF "NOLPA" WAS SPECIFIED
         BE    EXLPA               THEN EXCLUDE LPA LIBRARIES
         A     R6,LPATCNT          ELSE ADD IN # OF LPA LIBRARIES
EXLPA    DS    0H
         CLI   XFLNK+1,2           IF "NOLINKLIST" WAS SPECIFIED
         BE    EXLINK              THEN EXCLUDE LINK LIST LIBRARIES
         A     R6,LLTCOUNT         ELSE ADD IN # OF LNKLIST LIBRARIES
EXLINK   DS    0H
         LTR   R6,R6               IF LIBRARY COUNT IS ZERO,
         BP    OKSOFAR             THEN...
         MVI   OUTLINE,C' '
         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE
         MVC   OUTLINE(L'NOLIBMSG),NOLIBMSG
         BAL   R14,PUTLINE          PUT OUT ERROR MESSAGE AND TERMINATE
         B     BLOWUP
OKSOFAR  DS    0H
         ST    R6,LIBCOUNT
         LR    R1,R6               COPY NUMBER OF DDNAMES
         MH    R1,=H'10'           MULTIPLY BY LENGTH OF A DDNM ENTRY
         LA    R1,4(,R1)           ADD LENGTH FOR TEXT UNIT PREFIX
         STH   R1,DDBUFLEN         SAVE LENGTH
         LR    R0,R1
         GETMAIN R,LV=(0)          GET STORAGE FOR A DDNAME BUFFER
         ST    R1,DDBUFFER         SAVE ITS ADDRESS
         MVC   0(2,R1),=X'0001'    SET KEY FOR CONCATENATING DDNAMES
         STH   R6,2(,R1)           SET NUMBER OF DDNAMES
         EJECT
***********************************************************************
*                                                                     *
* NOW, ALLOCATE LIBRARIES.  THE FIRST ONE WILL BE ALLOCATED TO THE    *
* FILE NAME SPECIFIED ON THE COMMAND, AND THE OTHERS WILL ALL GET     *
* SYSTEM-GENERATED DDNAMES.                                           *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R10,DDBUFFER        GET ADDRESS OF DDNAME BUFFER
         LA    R10,4(,R10)         POINT TO FIRST DDNAME TO PUT IN
         ST    R10,FIRSTDDN        SAVE ADDRESS OF IT
         SPACE 1
***********************************************************************
*                                                                     *
* INITIALIZE DYNAMIC ALLOCATION PARAMETER LIST                        *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,S99RB
         ST    R1,S99RBPTR
         OI    S99RBPTR,X'80'
         XC    S99RB(S99RBEND-S99RB),S99RB
         MVI   S99RBLN,S99RBEND-S99RB
         EJECT
***********************************************************************
*                                                                     *
* IF "REUSE" WAS SPECIFIED, FREE THE FILE FIRST.                      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   XFREUSE+1,X'01'     IF REUSE WAS SPECIFIED
         BNE   NOUNALC             THEN
         SPACE 1
***********************************************************************
*                                                                     *
* SET UP FOR UNALLOCATION                                             *
*                                                                     *
***********************************************************************
         SPACE 1
         MVI   S99VERB,S99VRBUN    DO UNALLOCATION
         LA    R1,TUPLUNAL         LIST OF TEXT UNIT POINTERS
         ST    R1,S99TXTPP         SET TEXT UNITS FOR UNALLOCAT ION
         SPACE 1
         LA    R1,DUNDDNAM         FREE DDNAME
         ST    R1,TUPLUNAL+X'00'
         LA    R1,DUNUNALC         EVEN IF PERMANENTLY ALLOCATED
         ST    R1,TUPLUNAL+X'04'
         OI    TUPLUNAL+X'04',X'80' MARK END OF TEXT UNITS
         SPACE 1
         MVC   DUNUNALC(4),=X'00070000'     KEY, NUMBER
         MVC   DUNDDNAM(4),=X'00010001'     KEY, NUMBER
         L     R15,XFFILE+0         GET ADDRESS OF SPECIFIED DDNAME
         LH    R1,XFFILE+4          GET LENGTH OF SPECIFIED DDNAME
         STH   R1,DDLEN99           SET DDNAME LENGTH
         BCTR  R1,0                 REDUCE LENGTH FOR EXECUTE
         EX    R1,MOVEDD99          MOVE DDNAME TO TEXT UNIT
         SPACE 1
***********************************************************************
*                                                                     *
* DO DYNAMIC UNALLOCATION                                             *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,S99RBP           POINT TO SVC 99 PARAMETER LIST
         DYNALLOC ,                UNALLOCATE THE FILE NAME
         ST    R15,DRETCODE        SAVE RETURN CODE
         LTR   R15,R15             IF RETURN CODE NONZERO,
         BZ    NOUNALC             THEN...
         CLC   S99ERROR(2),=X'0438' IF ERROR = DDNAME NOT FOUND
         BE    NOUNALC              THEN STILL OK
         BAL   R14,DYNALERR         ELSE REPORT FREE ERROR
         B     BLOWUP               AND TERMINATE.
NOUNALC  DS    0H                  FILE IS NOW UNALLOCATED
         EJECT
***********************************************************************
*                                                                     *
* SET UP FOR ALLOCATION                                               *
*                                                                     *
* NOTE: WE SPECIFY THAT AN EXISTING ALLOCATION IS NOT TO BE USED,     *
*       EVEN IF IT IS CONVERTIBLE.  THIS PREVENTS A CURRENT           *
*       ALLOCATION WITH THE WRONG VOLUME SERIAL FROM BEING USED.      *
*                                                                     *
***********************************************************************
         SPACE 1
         MVI   S99FLG11,S99ONCNV+S99NOCNV DON'T USE AN EXISTING ALLOC'N
         SPACE 1
         MVI   S99VERB,S99VRBAL    DO ALLOCATION
         LA    R1,TUPLALLC         LIST OF TEXT UNIT POINTERS
         ST    R1,S99TXTPP         SET TEXT UNITS FOR ALLOCATION
         SPACE 1
         LA    R1,DALDSNAM         DSNAME
         ST    R1,TUPLALLC+X'04'
         LA    R1,DALSTATS         DISP=(SHR,
         ST    R1,TUPLALLC+X'08'
         LA    R1,DALNDISP                   KEEP)
         ST    R1,TUPLALLC+X'0C'
         LA    R1,DALPERMA         PERMANENT ALLOCATION REQUEST ED
         ST    R1,TUPLALLC+X'10'
         OI    TUPLALLC+X'10',X'80' MARK END OF TEXT UNITS
         SPACE 1
         MVC   DALDSNAM(6),=X'00020001002C' KEY, NUMBER, LENGTH
         MVC   DALSTATS(7),=X'00040001000108' DISP=(SHR,
         MVC   DALNDISP(7),=X'00050001000108'           KEEP)
         MVC   DALPERMA(4),=X'00520000'     KEY, NUMBER, LENGTH
         SPACE 1
***********************************************************************
*                                                                     *
* UNLESS "NOLPA" WAS SPECIFIED,                                       *
* GO THROUGH THE LPA TABLE AND ALLOCATE THE LIBRARIES SPECIFIED.      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   XFLPA+1,2           IF "NOLPA" WAS SPECIFIED
         BE    SKIPLPA             THEN SKIP LPA LIBRARIES
         ICM   R8,15,LPATCNT       GET NUMBER OF LPA LIBRARIES
         BZ    SKIPLPA             SKIP IF NONE
         LA    R9,LPATNTRY         POINT TO FIRST LPA LIBRARY ENTRY
LPALOOP  DS    0H                  LOOP FOR ALL LPA LIBRARIES...
         BAL   R14,ALLOCDSN        ALLOCATE THE DATA SET
         LTR   R15,R15             IF ALLOCATION FAILED,
         BNZ   BLOWUP              THEN REPORT ERROR
         LA    R9,45(,R9)          BUMP TO NEXT LPA LIBRARY ENTRY
         BCT   R8,LPALOOP          CONTINUE
         SPACE 1
SKIPLPA  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* UNLESS "NOLINK" WAS SPECIFIED,                                      *
* GO THROUGH LINK LIST TABLE AND ALLOCATE THE LIBRARIES SPECIFIED.    *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   XFLNK+1,2           IF "NOLINK" WAS SPECIFIED
         BE    SKIPLNK             THEN SKIP LINK LIBRARIES
         ICM   R8,15,LLTCOUNT      GET NUMBER OF LLT LIBRARIES
         BZ    SKIPLNK             SKIP IF NONE
         LA    R9,LLTENTRY         POINT TO FIRST LLT LIBRARY ENTRY
LNKLOOP  DS    0H                  LOOP FOR ALL LLT LIBRARIES...
         BAL   R14,ALLOCDSN        ALLOCATE THE DATA SET
         LTR   R15,R15             IF ALLOCATION FAILED,
         BNZ   BLOWUP              THEN REPORT ERROR
         LA    R9,45(,R9)          BUMP TO NEXT LLT LIBRARY ENTRY
         BCT   R8,LNKLOOP          CONTINUE
         SPACE 1
SKIPLNK  DS    0H
         EJECT
***********************************************************************
*                                                                     *
* NOW CONCATENATE THE LIBRARIES TO THE REQUESTED FILE NAME.           *
*                                                                     *
***********************************************************************
         SPACE 1
         CH    R6,=H'1'            IF ONLY ONE LIBRARY
         BE    CONCATOK            THEN SKIP CONCATENATION
         SPACE 1
         MVI   S99VERB,S99VRBCC    NOW, DO CONCATENATION
         LA    R1,TUPLCONC         TEXT UNIT POINTERS FOR CONCATENATION
         ST    R1,S99TXTPP         SET TEXT UNITS FOR CONCATENATION
         L     R1,DDBUFFER         GET ADDRESS OF DDNAMES
         ST    R1,TUPLCONC+0
         LA    R1,DCCPERMC         SPECIFY PERMANENT CONCATENATION
         ST    R1,TUPLCONC+4       (THE SIOT'S WILL SHOW SAME DDNAME)
         OI    TUPLCONC+4,X'80'
         MVC   DCCPERMC(8),=X'00040000' PERMANENTLY CONCATENATED
         SPACE 1
***********************************************************************
*                                                                     *
* DO DYNAMIC CONCATENATION                                            *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,S99RBP           POINT TO SVC 99 PARAMETER LIST
         DYNALLOC ,                CONCATENATE THE FILES
         ST    R15,DRETCODE        SAVE RETURN CODE
         LTR   R15,R15             IF RETURN CODE NONZERO,
         BZ    CONCATOK            THEN...
         BAL   R14,DYNALERR         DISPLAY ERROR MESSAGE
         B     BLOWUP               AND QUIT
CONCATOK DS    0H                  ELSE...
         B     RETURN0              EVERYTHING OK
         EJECT
ALLOCDSN DS    0H                  SUBROUTINE TO ALLOCATE LIBRARY
         SPACE 1
***********************************************************************
*                                                                     *
* SUBROUTINE TO ALLOCATE A LIBRARY                                    *
*                                                                     *
* THE FIRST LIBRARY FOUND IS ALLOCATED TO THE DDNAME REQUESTED ON THE *
* COMMAND; ALL OTHERS USE SYSTEM GENERATED DDNAMES.                   *
*                                                                     *
* LATER THE CONCATENATE OPERATION WILL GIVE ALL OF THE LIBRARIES      *
* THE DDNAME OF THE FIRST ONE.                                        *
*                                                                     *
* ON ENTRY R9 POINTS TO THE LPAT OR LLT ENTRY (YL1(LENGTH),CL44(DSN)) *
* R10 POINTS TO THE PLACE TO PUT THE DDNAME FOR FUTURE CONCATENATION  *
*                                                                     *
***********************************************************************
         SPACE 1
         ST    R14,AD14            SAVE RETURN REGISTER
         MVC   DSNAME99(44),1(R9)  MOVE LPATDSN TO DSNAME TEXT UNIT
         C     R10,FIRSTDDN        IF THIS IS THE FIRST DDNAME
         BNE   NOT1STDD            THEN...
         MVI   DDNAME99,C' '        CLEAR TEXT UNIT DDNAME TO BLANKS
         MVC   DDNAME99+1(7),DDNAME99
         L     R15,XFFILE+0         GET ADDRESS OF SPECIFIED DDNAME
         LH    R1,XFFILE+4          GET LENGTH OF SPECIFIED DDNAME
         STH   R1,DDLEN99           SET DDNAME LENGTH
         BCTR  R1,0                 REDUCE LENGTH FOR EXECUTE
         EX    R1,MOVEDD99          MOVE DDNAME TO TEXT UNIT
         MVC   0(2,R10),=X'0008'    SET DD LENGTH TO 8
         MVC   2(8,R10),DDNAME99    MOVE DDNAME TO CONCAT AREA
         MVC   DALDDNAM(4),=X'00010001' BUILD TEXT UNIT TO PASS DDNAME
         LA    R1,DALDDNAM          SPECIFY DDNAME TO BE ALLOCATED
         ST    R1,TUPLALLC+X'00'    AS A TEXT UNIT
         B     AFT1STDD            ELSE...
NOT1STDD DS    0H
         MVI   DDNAME99,C' '        CLEAR TEXT UNIT DDNAME TO BLANKS
         MVC   DDNAME99+1(7),DDNAME99
         LA    R0,8                 SET DDNAME LENGTH FOR RETURN
         STH   R0,DDLEN99
         MVC   DALRTDDN(2),=X'00550001' BUILD TEXT UNIT TO RETURN DD
         LA    R1,DALRTDDN         RETURN DDNAME
         ST    R1,TUPLALLC+X'00'
AFT1STDD DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* DO DYNAMIC ALLOCATION                                               *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,S99RBP           POINT TO SVC 99 PARAMETER LIST
         DYNALLOC ,                ALLOCATE THE DATASET
         ST    R15,DRETCODE        SAVE RETURN CODE
         LTR   R15,R15             IF RETURN CODE NONZERO,
         BZ    ALLOCOK             THEN...
         BAL   R14,DYNALERR         DISPLAY ERROR MESSAGE
         B     BLOWUP               AND QUIT.
ALLOCOK  DS    0H                  ELSE DATASET SUCCESSFULLY ALLOCATED
         C     R10,FIRSTDDN        IF THIS IS NOT THE FIRST DDNAME
         BE    NOCPYLPA            THEN
         MVC   0(2,R10),=X'0008'    SET LENGTH OF DDNAME
         MVC   2(8,R10),DDNAME99    MOVE RETURNED DDNAME
NOCPYLPA DS    0H
         LA    R10,10(,R10)        BUMP DDNAME POINTER FOR CONCATS
         L     R15,DRETCODE        LOAD DYNALLOC RETURN CODE
         L     R14,AD14            LOAD RETURN REGISTER
         BR    R14                 RETURN TO CALLER
         EJECT
DYNALERR DS    0H                  SVC99 ERROR
         SPACE 1
***********************************************************************
*                                                                     *
* SUBROUTINE TO DISPLAY DYNALLOC ERROR MESSAGE USING DAIRFAIL         *
*                                                                     *
***********************************************************************
         SPACE 1
         ST    R14,DYNER14         SAVE RETURN REGISTER
         LA    R14,S99RB           PARM 1 = SVC 99 REQUEST BLOCK
         LA    R15,DRETCODE        PARM 2 = SVC 99 RETURN CODE
         LA    R0,=F'0'            PARM 3 = ADDRESS OF IKJEFF02
         LA    R1,=X'0032'         PARM 4 = USE PUTLINE FOR SVC99 ERROR
         STM   R14,R1,DFPARMS      PARM 5 (CPPL ADDR) WAS SET IN INIT.
         XC    DFBUFP,DFBUFP       PARM 6 = WTP BUFFER (NOT USED)
         LA    R1,DFPARMS          POINT TO DAIRFAIL PARAMETER LIST
         LINK  EP=IKJEFF18         CALL DAIRFAIL
         LTR   R15,R15             CHECK RETURN CODE
         BZ    DYNALRET            IF DAIRFAIL FAILED,
         MVI   OUTLINE,C' '        THEN...
         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE
         MVC   OUTLINE(L'DFERR),DFERR
         BAL   R14,PUTLINE          PUT OUT ERROR MESSAGE AND TERMINATE
DYNALRET L     R14,DYNER14         RESTORE RETURN REGISTER
         BR    R14                 RETURN
         EJECT
BLOWUP   DS    0H                  A FAILURE HAS OCCURRED...
         SPACE 1
***********************************************************************
*                                                                     *
* CLEAR TYPED-AHEAD INPUT AND FLUSH THE STACK ON ERROR                *
*                                                                     *
***********************************************************************
         SPACE 1
         TCLEARQ INPUT             CLEAR TERMINAL INPUT
         SPACE 1
         STACK MF=(E,IOPL),PARM=FLUSH  FLUSH INPUT STACK (CLIST)
         SPACE 1
******** B     RETURN12            RETURN CODE(12)
         EJECT
RETURN12 DS    0H                  RETURN WITH CODE 12
         SPACE 1
         LA    R2,12               SET RETURN CODE TO TWELVE
         B     RETURN              RETURN WITHOUT FREEING PARSE STORAGE
         SPACE 2
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         XR    R2,R2               SET RETURN CODE TO ZERO
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *
***********************************************************************
         SPACE 1
RETURNP  DS    0H
         SPACE
         ICM   R1,15,DDBUFFER      GET ADDRESS OFF DDNAME BUFFER
         BZ    NOFREE              IF THERE IS ONE, THEN...
         LH    R0,DDBUFLEN          GET ITS LENGTH
         FREEMAIN R,LV=(0),A=(1)    FREE STORAGE FOR DDNAME BUFFER
NOFREE   DS    0H
         L     R1,ANSWER
         IKJRLSA (1)               RELEASE PARSE STORAGE
         SPACE 1
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
PUTLINE  DS    0H
         SPACE 1
***********************************************************************
* PUTLINE SUBROUTINE  - LINK REGISTER IS R14                          *
* MESSAGE MUST BE MOVED TO "OUTLINE" BEFORE CALLING.                  *
***********************************************************************
         SPACE 1
         ST    R14,PUTL14
         TR    OUTLINE(L'OUTLINE),TRANSTBL
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15
         BZ    PUTLOK              BRANCH TO LOW CORE IF PUTLINE FAILS
         LA    R1,PUTLERR
         LA    R0,L'PUTLERR
         TPUT  (1),(0),R
PUTLOK   L     R14,PUTL14
         BR    R14
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
MOVEDD99 MVC   DDNAME99(0),0(R15)  MOVE DDNAME TO TEXT UNIT
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
SPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
PTLISTL  EQU   *-SPTLIST
         SPACE 2
FLUSH    STACK MF=L,DELETE=ALL
         SPACE 2
BLANKS   DC    CL8' '              GENERAL PURPOSE BLANKS
         SPACE 2
TRANSTBL DS    0C
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/........,%_>?'
         DC    C'.........`:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    C'................'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE 1
         DC    C'0123456789ABCDEF'
TRTBL    EQU   *-256
         EJECT
***********************************************************************
* MESSAGES                                                            *
***********************************************************************
         SPACE 2
NOLIBMSG DC    C'XLNKLST: NO LIBRARIES FOUND IN REQUEST.'
DFERR    DC    C'XLNKLST: ERROR IN DAIRFAIL ROUTINE.'
PUTLERR  DC    C'*** XLNKLST PUTLINE FAILURE ***'
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* PARSE CONTROL BLOCKS CSECT                                          *
***********************************************************************
         SPACE 1
XFLNKPCL IKJPARM DSECT=PDL
         SPACE 1
XFFILE   IKJIDENT 'FILE NAME',                                         X
               PROMPT='DDNAME TO BE ALLOCATED TO SYSTEM LINK LIST',    X
               MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM
         SPACE 1
XFLPA    IKJKEYWD
         IKJNAME 'LPA'
         IKJNAME 'NOLPA'
         SPACE 1
XFLNK    IKJKEYWD
         IKJNAME 'LINKLIST'
         IKJNAME 'NOLINKLIST'
         SPACE 1
XFREUSE  IKJKEYWD
         IKJNAME 'REUSE'
         SPACE 1
         IKJENDP
         SPACE
XLNKLST  CSECT
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
PUTL14   DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE
AD14     DS    A                   SAVE AREA FOR ALLOCDSN SUBROUTINE
DYNER14  DS    A                   SAVE AREA FOR DYNALERR SUBROUTINE
LIBCOUNT DS    F                   NUMBER OF LIBRARIES TO BE ALLOCATED
DRETCODE DS    A                   RETURN CODE FROM SVC 99
DDBUFFER DS    A                   ADDRESS OF DD NAME BUFFER
DDBUFLEN DS    H                   LENGTH OF DD NAME BUFFER
FIRSTDDN DS    A                   ADDRESS OF FIRST DD NAME
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
         SPACE 1
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE 1
PPL      DS    0A
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE 1
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
         SPACE 1
ANSWER   DS    F                   ANSWER AREA FOR PARSE
         SPACE 1
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE 1
OLD      DS    0A
OLD1     DC    F'1'
OLD2     DC    A(OUTHDR)
OUTHDR   DC    Y(L'OUTLINE+4,0)
OUTLINE  DS    CL79
         SPACE 2
***********************************************************************
* DYNAMIC ALLOCATION CONTROL BLOCKS                                   *
***********************************************************************
         SPACE 1
***********************************************************************
* COPIED FROM: 'SYS1.MACLIB(IEFZB4D0)'
***********************************************************************
         SPACE 1
***********************************************************************
*                SVC 99 INPUT REQUEST BLOCK
***********************************************************************
S99RBP   DS     0D
S99RBPTR DS     F                      REQUEST BLOCK POINTER
S99RBPND EQU    X'80'                  LAST POINTER INDICATOR
S99RB    DS     0D                     REQUEST BLOCK
         DS     0F
S99RBLN  DS     CL1                    LENGTH OF REQUEST BLOCK
S99VERB  DS     CL1                    VERB CODE
S99VRBAL EQU    X'01'                  ALLOCATION
S99VRBUN EQU    X'02'                  UNALLOCATION
S99VRBCC EQU    X'03'                  CONCATENATION
S99VRBDC EQU    X'04'                  DECONCATENATION
S99VRBRI EQU    X'05'                  REMOVE IN-USE
S99VRBDN EQU    X'06'                  DDNAME ALLOCATION
S99VRBIN EQU    X'07'                  INFORMATION RETRIEVAL
S99FLAG1 DS     0CL2                   FLAGS
S99FLG11 DS     CL1                    FIRST FLAGS BYTE
S99ONCNV EQU    X'80'                  ALLOC FUNCTION-DO NOT USE AN
*                                      EXISTING ALLOCATION THAT DOES
*                                      NOT HAVE THE CONVERTIBLE
*                                      ATTRIBUTE TO SATISFY A REQUEST
S99NOCNV EQU    X'40'                  ALLOC FUNCTION-DO NOT USE AN
*                                      EXISTING ALLOCATION TO SATISFY
*                                      THE REQUEST
S99NOMNT EQU    X'20'                  ALLOC FUNCTION-DO NOT MOUNT
*                                      VOLUMES OR CONSIDER OFFLINE
*                                      UNITS (THIS FLAG OVERRIDES
*                                      S99MOUNT AND S99OFFLN BELOW)
S99JBSYS EQU    X'10'                  ALLOC FUNC-JOB RELATED SYSOUT
S99CNENQ EQU    X'08'                  ALL FUNCTIONS-ISSUE A   @ZA32641
*                                      CONDITIONAL ENQ ON TIOT @ZA32641
*                                      RESOURCE. IF NOT        @ZA32641
*                                      AVAILABLE, RETURN AN    @ZA32641
*                                      ERROR CODE TO USER.     @ZA32641
S99FLG12 DS     CL1                    SECOND BYTE OF FLAGS
S99RSC   DS     0CL4                   REASON CODE FIELDS
S99ERROR DS     XL2                    ERROR REASON CODE
S99INFO  DS     XL2                    INFORMATION REASON CODE
S99TXTPP DS     F                      ADDR OF LIST OF TEXT UNIT PTRS
S99RSV01 DS     F                      RESERVED
S99FLAG2 DS     0CL4                   FLAGS FOR AUTHORIZED FUNCTIONS
S99FLG21 DS     CL1                    FIRST BYTE OF FLAGS
S99WTVOL EQU    X'80'                  ALLOC FUNCTION-WAIT FOR
*                                      VOLUMES
S99WTDSN EQU    X'40'                  ALLOC FUNCTION-WAIT FOR DSNAME
S99NORES EQU    X'20'                  ALLOC FUNCTION-DO NOT DO
*                                      DATA SET RESERVATION
S99WTUNT EQU    X'10'                  ALLOC FUNCTION-WAIT FOR UNITS
S99OFFLN EQU    X'08'                  ALLOC FUNCTION-CONSIDER OFFLINE
*                                      UNITS
S99TIONQ EQU    X'04'                  ALL FUNCTIONS-TIOT ENQ ALREADY
*                                      DONE
S99CATLG EQU    X'02'                  ALLOC FUNCTION-SET SPECIAL
*                                      CATALOG DATA SET INDICATORS
S99MOUNT EQU    X'01'                  ALLOC FUNCTION-MAY MOUNT VOLUME
S99FLG22 DS     CL1                    SECOND BYTE OF FLAGS
S99UDEVT EQU    X'80'                  ALLOCATION FUNCTION-UNIT NAME
*                                      PARM IS A DEVICE TYPE
S99PCINT EQU    X'40'                  ALLOC FUNCTION-ALLOC    @Y30QPPB
*                                      PRIVATE CATALOG TO      @Y30QPPB
*                                      INITIATOR               @Y30QPPB
S99DYNDI EQU    X'20'                  ALLOC FUNCTION-NO JES3  @ZA63125
*                                      DSN INTEGRITY PROCESS   @ZA63125
S99FLG23 DS     CL1                    THIRD BYTE OF FLAGS
S99FLG24 DS     CL1                    FOURTH BYTE OF FLAGS
S99RBEND EQU    *                      END MARKER
         SPACE 1
***********************************************************************
* SVC 99 TEXT UNIT POINTER LIST FOR ALLOCATION FUNCTIONS
***********************************************************************
TUPLALLC DS    8F                      TEXT UNIT POINTER LIST
***********************************************************************
* SVC 99 TEXT UNIT POINTER LIST FOR UNALLOCATION FUNCTIONS
***********************************************************************
TUPLUNAL EQU   TUPLALLC                TEXT UNIT POINTER LIST
***********************************************************************
* SVC 99 TEXT UNIT POINTER LIST FOR CONCATENATION FUNCTIONS
***********************************************************************
TUPLCONC EQU   TUPLALLC                TEXT UNIT POINTER LIST
***********************************************************************
* SVC 99 TEXT UNIT FOR ALLOCATION OF A DDNAME FOR DSNAME
***********************************************************************
DALDDNAM DS    0H                      TEXT UNIT
         DC    XL2'0001'               KEY
         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES
DDLEN99  DC    XL2'0008'               LENGTH OF DDNAME
DDNAME99 DC    CL8' '                  DDNAME
***********************************************************************
* SVC 99 TEXT UNIT FOR RETURN OF A DDNAME FOR DSNAME
***********************************************************************
DALRTDDN EQU   DALDDNAM                TEXT UNIT
***********************************************************************
* SVC 99 TEXT UNIT FOR UNALLOCATION OF A DDNAME
***********************************************************************
DUNDDNAM EQU   DALDDNAM                TEXT UNIT
***********************************************************************
* SVC 99 TEXT UNIT FOR ALLOCATION BY DSNAME
***********************************************************************
DALDSNAM DS    0H                      TEXT UNIT
         DC    XL2'0002'               KEY
         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES
DSLEN99  DC    XL2'0000'               LENGTH OF DSNAME
DSNAME99 DC    CL44' '                 DSNAME
***********************************************************************
* SVC 99 TEXT UNIT FOR DATA SET STATUS
***********************************************************************
DALSTATS DS    0H                      TEXT UNIT
         DC    XL2'0004'               KEY
         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES
         DC    XL2'0001'               LENGTH OF STATUS
         DC    X'08'                   STATUS = SHR
*              X'01'                   STATUS = OLD
***********************************************************************
* SVC 99 TEXT UNIT FOR NORMAL DISPOSITION
***********************************************************************
DALNDISP DS    0H                      TEXT UNIT
         DC    XL2'0005'               KEY
         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES
         DC    XL2'0001'               LENGTH OF NORMAL DISPOSITION
         DC    X'08'                   DISP = KEEP
***********************************************************************
* SVC 99 TEXT UNIT FOR PERMANENTLY ALLOCATED ATTRIBUTE
***********************************************************************
DALPERMA DS    0H                      TEXT UNIT
         DC    XL2'0052'               KEY
         DC    XL2'0000'               NO LENGTH+PARAMETER ENTRIES
***********************************************************************
* SVC 99 TEXT UNIT FOR PERMANENTLY CONCATENATED ATTRIBUTE
***********************************************************************
DCCPERMC DS    0H                      TEXT UNIT
         DC    XL2'0004'               KEY
         DC    XL2'0000'               NO LENGTH+PARAMETER ENTRIES
***********************************************************************
* SVC 99 TEXT UNIT FOR FREE EVEN IF PERMANENTLY ALLOCATED ATTRIBUTE
***********************************************************************
DUNUNALC DS    0H                      TEXT UNIT
         DC    XL2'0007'               KEY
         DC    XL2'0000'               NO LENGTH+PARAMETER ENTRIES
         EJECT
***********************************************************************
* DAIRFAIL (IKJEFF18) PARAMETER LIST                                  *
***********************************************************************
         SPACE 1
DFPARMS  DS    0A
         SPACE 1
DFS99RBP DC    A(S99RB)            ADDRESS OF SVC 99 REQUEST BLOCK
DFRCP    DC    A(DRETCODE)         ADDRESS OF SVC 99 RETURN CODE
DFJEFF02 DS    A                   ADDRESS OF EP OF IKJEFF02 OR ZEROES
DFIDP    DS    A                   ADDRESS OF 2-BYTE ID AREA
DFCPPLP  DS    A                   ADDRESS OF CPPL
DFBUFP   DS    A                   ADDRESS OF BUFFER NOT NEEDED
         EJECT
***********************************************************************
* END OF DATD DSECT                                                   *
***********************************************************************
         SPACE 1
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* DSECT'S FOR WHICH NO MACRO WAS FOUND                                *
***********************************************************************
         SPACE 1
LPAT     DSECT ,                   LPA LIST TABLE
         SPACE 1
LPATHDR  DS    0CL8                TABLE HEADER
LPATID   DS    CL4'LPAT'           TABLE ID 'LPAT'
LPATCNT  DS    F                   NUMBER OF ENTRIES IN TABLE
LPATNTRY DS    0CL8                TABLE ENTRY
         SPACE 1
LPATDSLN DS    XL1                 LENGTH OF DATA SET NAME
LPATDSN  DS    CL44                DATA SET NAME
         SPACE 3
LLT      DSECT ,                   LINK LIST TABLE
         SPACE 1
LLTHEAD  DS    0CL8                TABLE HEADER
LLTID    DS    CL4'LLT '           TABLE ID 'LLT '
LLTCOUNT DS    F                   NUMBER OF ENTRIES IN TABLE
LLTENTRY DS    0CL8                ENTRIES IN TABLE
         SPACE 1
LLTDSLTH DS    XL1                 LENGTH OF DATASET NAME
LLTDSN   DS    CL44                DATASET NAME
         SPACE 2
LLTAPFTB DSECT ,                   LNKLST APF LIBRARIES TABLE
LLTANTRY EQU   *                   LNKLST DATA SET ENTRIES
LLTAFLGS DS    CL1                 FLAG BYTE
LLTAPFIN EQU   B'10000000'          LIBRARY IS IN APF TABLE
LLTARSV1 EQU   B'01111111'          RESERVED
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJCPPL
         SPACE 1
         CVT   DSECT=YES
         END
./ ADD NAME=XLSYMS   0100-07332-07332-0900-00211-00211-00000-SEB
         TITLE 'XLSYMS - INSTREAM MACRO DEFINITIONS'
         MACRO
&LABEL   CLRLINE
&LABEL   MVI   DATALINE,C' '
         MVC   DATALINE+1(L'DATALINE-1),DATALINE
         MEND
         SPACE 5
         MACRO
&LABEL   TUPT  &ADDR
&LABEL   LA    R1,&ADDR                    LOAD PARAMETER REG 1
         LA    R0,L'&ADDR                  LOAD PARAMETER REG 0
         SVC   93                          ISSUE TPUT SVC
         MEND
         TITLE 'XLSYMS - COMMAND TO DISPLAY EQUATED SYMBOLS UNDER TEST'
***********************************************************************
* SYNTAX: ... XLSYMS                                                  *
*        (WHERE ... IS HELP OR SOME OTHER MEANS OF GETTING THIS TSO   *
* COMMAND INTO THE TEST ENVIRONMENT)                                  *
*    THERE ARE NO OPERANDS.                                           *
* NOTE: THIS COMMAND DISPLAYS ONLY SYMBOLS DEFINED BY THE EQUATE      *
*       SUBCOMMAND OF TEST OR THE EQUATE OPERAND OF THE GETMAIN       *
*       SUBCOMMAND OF TEST.                                           *
* CHANGE ACTIVITY:                                                    *
*     11/84 - SOME TEST CONTROL BLOCKS ARE NOW ABOVE THE 16MB LINE.   *
*             THEREFORE, THIS PROGRAM MUST RUN IN 31-BIT MODE.        *
***********************************************************************
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9                   ADDRESS OF TCOMTAB
R10      EQU   10
R11      EQU   11
R12      EQU   12                  STATIC BASE REGISTER
R13      EQU   13                  DYNAMIC BASE REGISTER
R14      EQU   14
R15      EQU   15
XLSYMS   CSECT
XLSYMS   AMODE 31
XLSYMS   RMODE 24
         SAVE  (14,12),,XLSYMS_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XLSYMS,R12
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R1,8(,R13)
         ST    R13,4(,R1)
         LR    R13,R1
         USING DATD,R13
         EJECT
         L     R9,540                  TCB FOR THIS PROGRAM
TESTLOOP CLC   21(3,R9),=X'000000'     CHECK TESTRAN FIELD IN TCB
         BNE   TESTOK                  IF NONE, THEN
         ICM   R9,7,133(R9)             TRY NEXT (MOTHER) TCB
         BNZ   TESTLOOP                 UNTIL NO MORE, AT WHICH POINT
         TUPT  NOTEST                   SAY 'TEST NOT ACTIVE'
         LA    R15,12                   AND QUIT.
         B     RETURN
         SPACE 1
TESTOK   DS    0H                      R9 POINTS TO TEST'S TCB
         L     R9,20(,R9)              POINT R9 TO TCOMTAB (TCBTRN)
         N     R9,=X'00FFFFFF'         CLEAR HIGH-ORDER BYTE
         USING TCOMTAB,R9
         SPACE 1
         NI    FLAGS,255-HEADSW    INITIALIZE HEADING SWITCH
         ICM   R3,15,SYMTABLE      GET ADDRESS OF ACTIVE SYMBOL ENTRIES
         BNZ   EQSOK               IF NONE, THEN...
         TUPT  NOEQS                SAY SO
         B     RETURN0              AND RETURN.
EQSOK    DS    0H                  ELSE...
         USING SYMELEM,R3           ESTABLISH ADDRESSABILITY
         TM    FLAGS,HEADSW        IF NO HEADING PRINTED YET
         BO    NOHEAD              THEN
         TUPT  HEADING              DISPLAY HEADING
         MVI   DASHES,C'-'
         MVC   DASHES+1(L'DASHES-1),DASHES
         TUPT  DASHES
         OI    FLAGS,HEADSW         AND INDICATE HEADING DISPLAYED
NOHEAD   DS    0H
         CLRLINE ,                 CLEAR OUTPUT LINE TO BLANKS
         UNPK  WHERE(9),ADDRSYM(5) CONVERT SYMBOL ADDRESS
         TR    WHERE(8),HEXTBL     TO DISPLAY
         MVI   WHERE+8,C'.'        ADD A PERIOD
         XR    R4,R4               CLEAR INSERT REGISTER
         IC    R4,ATTRTYPE         GET TYPE CODE
         SRA   R4,2                DIVIDE BY 4
         LA    R4,TYPE(R4)         POINT TO CORRESPONDING TYPE
         MVC   DATATYPE,0(R4)      MOVE TYPE TO OUTPUT LINE
         LH    R4,ATTRLNTH         GET LENGTH ATTRIBUTE OF SYMBOL
         CVD   R4,DOUBLE           CONVERT TO DISPLAY
         MVC   DATALEN-1(4),=X'40202120'
         ED    DATALEN-1(4),DOUBLE+6
         ICM   R4,7,ATTRMULT       GET MULTIPLICITY ATTRIBUTE OF SYMBOL
         CVD   R4,DOUBLE           CONVERT TO DISPLAY
         MVC   DATAMULT-1(10),=X'40202020202020202120'
         ED    DATAMULT-1(10),DOUBLE+3
         LH    R15,SYMLNGTH        GET LENGTH OF SYMBOL NAME
         BCTR  R15,0               REDUCE FOR EXECUTE
         EX    R15,MOVENAME        MOVE SYMBOL NAME TO OUTPUT LINE
         TR    DATALINE(L'DATALINE),TRTBL
         TUPT  DATALINE            DISPLAY SYMBOL INFORMATION
         ICM   R3,15,CHAIN         GET ADDRESS OF NEXT SYMBOL
         BNZ   EQSOK               REPEAT UNTIL NO MORE SYMBOL ENTRIES
         SPACE
RETURN0  XR    R15,R15                 SET RETURN CODE TO ZERO
RETURN   DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)            STORE RETURN CODE
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
*  DATA AREAS                                                         *
***********************************************************************
         SPACE
*  EXECUTED INSTRUCTIONS
         SPACE
MOVENAME MVC   DATASYMB(0),SYMBOL  EXECUTED: MOVE SYMBOL NAME TO OUTPUT
HEADING  DC    C' SYMBOL   ADDRESS    TYPE   LENGTH  MULTIPLICITY'
NOTEST   DC    C'TEST NOT ACTIVE'
NOEQS    DC    C'NO EQUATED SYMBOLS'
TYPE     DC    C'CXBIFHEDAYSVPZ'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256                   TABLE FOR HEX CONVERSION
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'.ABCDEFGHI......'
         DC    C'.JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE 3
         LTORG
         EJECT
DATD     DSECT ,                       REENTRANT WORK AREA
         SPACE 1
SAVEAREA DS    9D                      OS SAVE AREA
         SPACE 1
DOUBLE   DS    D                       FOR NUMERIC CONVERSIONS
FLAGS    DS    X
HEADSW   EQU   X'80'                   1 = HEADING DISPLAYED
         SPACE 1
DATABEG  DS    0C                      PLACE TO BUILD OUTPUT
DATASYMB DS    CL8' '
         DS    C'  '                   FILLER
WHERE    DS    CL9' ',C' '
         DS    C'  '                   FILLER
DATATYPE DS    C' ',CL3' '
         DS    C'  '                   FILLER
DATALEN  DS    CL3' ',CL3' '
         DS    C'  '                   FILLER
DATAMULT DS    CL8' ',C' '
         SPACE 1
DATAEND  EQU   *
         SPACE 1
DATALINE EQU   DATABEG,DATAEND-DATABEG,C'C'
DASHES   EQU   DATABEG,L'HEADING,C'C'
         SPACE 1
SIZDATD  EQU   *-DATD                  LENGTH OF WORK AREA
         TITLE 'XLSYMS - TSO TEST CONTROL BLOCKS'
***********************************************************************
* THE FOLLOWING INFORMATION IS TAKEN FROM:                            *
* OS/VS2 MVS TSO COMMAND PROCESSOR LOGIC VOLUME III: TEST             *
* AND IS COPYRIGHT BY IBM.                                            *
***********************************************************************
SYMELEM  DSECT ,                   MAPPING OF SYMBOL TABLE ENTRY
         SPACE 1
CHAIN    DS    A                   ADDR OF NEXT SYMBOL TABLE IN STORAGE
ADDRSYM  DS    A                   POINTER TO SYMBOL LOCATION
ATTRTYPE DS    XL1                 INTERNAL CODE FOR TYPE
*                                  00 - CHARACTER FORMAT
*                                  04 - HEXADECIMAL FORMAT
*                                  08 - BINARY FORMAT
*                                  0C - INSTRUCTION FORMAT
*                                  10 - FIXED POINT, FULLWORD FORMAT
*                                  14 - FIXED POINT, HALFWORD FORMAT
*                                  18 - FLOATING POINT, FULLWORD FORMAT
*                                  1C - FLOATING POINT, DOUBLEWORD FMT
*                                  20 - ADDRESS CONSTANT, A OR Q FMT
*                                  24 - ADDRESS CONSTANT, Y FORMAT
*                                  28 - ADDRESS = BASE-DISPLACEMENT FMT
*                                  2C - EXTERNAL (V-TYPE) FORMAT (N/A)
*                                  30 - PACKED DECIMAL FORMAT
*                                  34 - ZONED DECIMAL FORMAT
ATTRMULT DS    XL3                 MULTIPLICITY FACTOR
ATTRLNTH DS    H                   LENGTH ATTRIBUTE
SYMLNGTH DS    H                   SYMBOL LENGTH
SYMBOL   DS    CL8                 SYMBOL IN EBCDIC AS ENTERED IN
*                                  EQUATE SUBCOMMAND
         EJECT
         TCOMTAB
         END
./ ADD NAME=XPROC    0100-07332-07332-0900-02585-02585-00000-SEB
         TITLE 'XPROC copyright notice'
***********************************************************************
*                                                                     *
*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *
*                                                                     *
*   This program is provided on an "as is" basis.  It may be freely   *
*   distributed as long as it is not offered for commercial sale,     *
*   and as long as this copyright notice is included.                 *
*                                                                     *
***********************************************************************
         TITLE 'XPROC macros'
         MACRO
&SYM     ERROR &MSG,&FLUSH=YES
&SYM     L     R1,=A(&MSG)         Get address of error message
         LA    R0,L'&MSG           Get length of error message
         BAL   R14,PUTLINE         Display error message
         AIF   ('&FLUSH' EQ 'NO').MEND
         B     FLUSHIT             Fail
.MEND    MEND
         TITLE 'XPROC - CLIST-style command line parser for REXX'
***********************************************************************
*                                                                     *
* XPROC    - CLIST-style command line parser for REXX                 *
*                                                                     *
* Author:  S. Bacher 06/89                                            *
*                                                                     *
* Syntax:  XPROC {inputvar} number {positional-parameter-variables}*  *
*                                  {keyword-and-maybe-value-specs}*   *
*                                                                     *
*        where: "inputvar" is a valid CLIST/REXX variable name        *
*               and the part of the command that follows "inputvar"   *
*               looks exactly like the syntax of the CLIST "PROC"     *
*               statement.                                            *
*                                                                     *
* Example: /* REXX */                                                 *
*          PARSE ARG OPERANDS                                         *
*          "XPROC OPERANDS 2 FILE DSN VOL() SHR COUNT(1) KEY('A B')"  *
*                                                                     *
*          Note that everything, including "inputvar", must be quoted *
*          under REXX to prevent substitution.                        *
*                                                                     *
* Function:  To parse the value of a string (accessed as "inputvar")  *
*            according to the PROC-style specifications and place     *
*            the results in REXX variables.  If "inputvar" is         *
*            omitted, the argument to the REXX exec is parsed.        *
*                                                                     *
* Return codes:                                                       *
*                                                                     *
* 0 - normal operation                                                *
* 12 - error(s) occurred, prompting not possible                      *
*                                                                     *
* Note:  This can be used in CLISTs as well.  One use might be to     *
*        parse a non-command-buffer line, e.g. edit macro text.       *
*                                                               #TSO147
* Change activity:                                              #TSO147
*                                                               #TSO147
* 10/24/89 - SEB1525 - Bug fix when bigger keyword area needed. #TSO147
* 01/30/91 - SEB1525 - Extended to permit the specification of        *
*                      options via the syntax keyword/option.         *
*                      First option so supported is lowercase.        *
* 04/13/92 - SEB1525 - Bug fix when prototype has quoted data.  #TSO159
* 12/15/92 - SEB1525 - Pass REXX env block from ECT to IRXEXCOM #TSO162
*                      to solve problem with IPCS/ISPF          #TSO162
* 01/14/02 - SEB1525 - Pass ECT to IKJCT441 for IPCS/ISPF.      #TSO172
*                      Fix developed by:                        #TSO172
*                      Steven D. McGinty                        #TSO172
*                      <sm122284@exchange.SanDiegoCA.ncr.com>   #TSO172
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    Used by SCAN and PUTLINE; other temporary uses
R4       EQU   4    Positional parameter info
R5       EQU   5    Positional parameter info
R6       EQU   6    Keyword count
R7       EQU   7    Address of IKJPARS PDL answer area
R8       EQU   8    Used to loop through parameters
R9       EQU   9    Dynamic base register
R10      EQU   10   Static base register
R11      EQU   11   Static base register
R12      EQU   12   Static base register
R13      EQU   13   Save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
XPROC    CSECT
XPROC    AMODE 31
XPROC    RMODE ANY
         SAVE  (14,12),,XPROC_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XPROC,R12
         LA    R11,4095(,R12)
         USING XPROC+4095,R11
         LA    R10,4095(,R11)
         USING XPROC+4095+4095,R10
*
* Allocate storage to hold work area plus copies of positional and
* keyword parameters.  Since the maximum length required to hold
* all the parameters is obviously the length of the command buffer,
* use that as the amount to add.
*
         LR    R2,R1               Save input parameter address
         LA    R4,SIZDATD            Get length of basic workarea
         L     R3,CPPLCBUF-CPPL(,R2) Point to command buffer
         AH    R4,0(,R3)             Add length of command buffer
         LR    R0,R4
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         LR    R9,R13
         USING DATD,R9
         ST    R4,DATDLEN          Save length of getmained area
         LA    R0,WORDCOPY         Point to variable area
         ST    R0,WORDPTR          Save address of it
         MVC   CPPL(16),0(R2)      Set up our copy of CPPL
         MVC   IOPLUPT,CPPLUPT     Pointer TO UPT
         MVC   IOPLECT,CPPLECT     Pointer TO ECT
         LA    R0,ECB
         ST    R0,IOPLECB          Pointer to user's ECB
         MVC   PTLIST(LENPUTL),MPTLIST Set up PUTLINE list form
         LA    R0,1                Define 1 message segment
         LA    R1,MSGHDR
         STM   R0,R1,OLD           Make PUTLINE output line descriptor
*                                  Initialize other data areas
         STM   R11,R12,MYBASES     Base registers used in PARSE exits
         MVI   FLAGS,X'00'         Clear flags
         XR    R0,R0               Make a zero
         ST    R0,APOSD
         ST    R0,LPOSD
         ST    R0,AKEYD
         ST    R0,LKEYD
         ST    R0,AKEYE
         ST    R0,POSCOUNT
         ST    R0,KEYCOUNT
         ST    R0,PWADDR
         ST    R0,PWLEN
         ST    R0,VBUFADDR
         ST    R0,VBUFLEN
         ST    R0,ARGADDR
         ST    R0,ARGLEN
*
         EJECT
*
***********************************************************************
*
* First, set things up so that SCAN can start scanning.  On entry to
* the command, CPPLCBUF points to the command buffer.  Halfword 1 is
* the length of the buffer plus 4, and halfword 2 is the offset of the
* first operand (if any) past the command name in the buffer (set by
* TSO's call to IKJSCAN).
*
***********************************************************************
*
         L     R2,CPPLCBUF
         LR    R1,R2
         AH    R1,0(,R2)
         ST    R1,SCANEPTR         Save end of command buffer
         LA    R1,4(,R2)
         AH    R1,2(,R2)
         ST    R1,SCANPTR          Initialize scan pointer
         XR    R0,R0
         ST    R0,PARCOUNT         Initialize parenthesis count
*
***********************************************************************
*                                                                     *
* Scan command buffer for first operand - must be input variable name *
*                                                                     *
***********************************************************************
*
         BAL   R14,SCAN            Return R15 -> arg
         B     NOOPERANDS          No value
         B     ARG1OK              Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     ERROR_NO_WANT_LP    "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     ERROR_NO_WANT_SL    "/" found
         SPACE 1
ARG1OK   DS    0H
         SPACE 1
*
***********************************************************************
*                                                                     *
* Validate first argument as a variable name so that it can be used   *
* to retrieve CLIST/REXX variable value.                              *
*                                                                     *
* We may not really have to do that here - just verify that it's not  *
* a positional count.  If it is a positional count, set the address   *
* and length of the input variable to zero (extension to XPROC will   *
* get value to parse from REXX argument string in that case).         *
*                                                                     *
***********************************************************************
*
         LR    R3,R1               Save address
         LR    R4,R2               Save length
         CH    R2,=H'256'          If it's too long for EX instruction
         BH    ERROR_FIRST_ARG     then first arg is invalid
         BCTR  R2,0                Reduce for execute
         EX    R2,TRTPOSCT         Scan for numerics
         BNZ   NOTPOSCOUNT         If any non-numerics, not a count
         XR    R0,R0               Else make a zero
         ST    R0,PVARADDR         Clear address of the variable
         ST    R0,PVARLEN          Clear length of the variable
         B     ISACOUNT            Process this as the pos parm count
         SPACE 1
NOTPOSCOUNT DS 0H                  Not a count - assume a variable name
         LR    R14,R3              Get address of variable name
         LA    R1,PVAR             Point to place to build var name
         ST    R1,PVARADDR         Save address of the variable
         ST    R4,PVARLEN          Save length of the variable
         BCTR  R4,0                Reduce for execute
         EX    R4,MVCWORD          Move word to PVAR
         EX    R4,UPWORD           Translate to uppercase
         SPACE 1
*
***********************************************************************
*                                                                     *
* Scan command buffer for next operand - must be count of positionals *
*                                                                     *
***********************************************************************
*
         BAL   R14,SCAN
         B     NOPOSCOUNT          No value
         B     ARG2OK              Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     ERROR_NO_WANT_LP    "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     ERROR_NO_WANT_SL    "/" found
         SPACE 1
ARG2OK   DS    0H                  We have what should be a count...
         LR    R3,R1               Get address of argument
         LR    R4,R2               Get length of argument
ISACOUNT DS    0H                  Here for first non-alpha arg...
*
***********************************************************************
*                                                                     *
* Validate this argument as a number so that it can be used to count  *
* the number of positional parameters.                                *
*                                                                     *
***********************************************************************
*
         BCTR  R4,0                Reduce for execute
         CH    R4,=H'7'            If positional count more than 8 digs
         BH    BADPOSCOUNT         then invalid value
         EX    R4,TRTPOSCT         Scan for numerics
         BNZ   BADPOSCOUNT         If any non-numerics, invalid value
         EX    R4,PACKIT           Convert to numeric
         CVB   R0,DOUBLE           Get binary value
         ST    R0,POSCOUNT         Store positional parameter count
         SPACE 1
*
***********************************************************************
*                                                                     *
* We are about to start collecting all parameter names, both          *
* positional and keyword.  While we do this, we determine how much    *
* space will be needed for IKJPARS control blocks.                    *
*                                                                     *
* Compute storage needed for the PCL (built by us):                   *
*                                                                     *
*   For initial overhead:            7                                *
*   For each positional parameter:   56 + (2 * length(min(name,234))) *
*   For each keyword with a value:   66 + (2 * length(min(name,237))) *
*                                       + length(name)                *
*   For each keyword without value:  11 + length(name)                *
*                                                                     *
* Compute storage reserved for the PDL (built by IKJPARS):            *
*                                                                     *
*   For initial overhead:            8                                *
*   For each positional parameter:   8                                *
*   For each keyword:                2                                *
*   For each value subfield:         8                                *
*                                                                     *
***********************************************************************
*
         LA    R0,7                Set PCL amount to initial value
         ST    R0,PCLLEN
         XR    R0,R0               Set quoted-value-strings length
         ST    R0,QVALLEN
         LA    R0,8                Set PDL initial total length
         ST    R0,PDLLEN
*
***********************************************************************
*                                                                     *
* Get storage to hold information for as many positional parameters   *
* as we have defined.                                                 *
*                                                                     *
***********************************************************************
*
         ICM   R5,15,POSCOUNT      Get count of positional parameters
         BZ    NOPOZZES            If zero, no positional parameters
         MH    R5,=Y(POSDDATL)     Get total length to acquire
         GETMAIN RC,LV=(R5),LOC=ANY Get storage
         LTR   R15,R15             If GETMAIN failed,
         BNZ   BADPOSCOUNT         then positional count too big
         ST    R1,APOSD            Save address of this area
         ST    R5,LPOSD            Save length of this area
         LR    R4,R1               Address first entry in area
         USING POSDDATA,R4
*
***********************************************************************
*                                                                     *
* Loop (positional-parameter-count) times, collecting variable names. *
*                                                                     *
***********************************************************************
*
         NI    FLAGS,255-FLAGPOSD  Not currently processing anything
         NI    FLAGS,255-FLAGKEYD
         XR    R0,R0               Zero out error fields
         ST    R0,LASTADDR
         ST    R0,LASTLEN
         ST    R0,LASTAREA
         L     R8,POSCOUNT         Get count of positional parameters
PPLOOP   DS    0H                  R5 contains count of parms to get
         BAL   R14,SCAN            Get a positional parame
         B     PPMISSING           No value
         B     PPADD               Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     PPLP                "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     PPSLASH             "/" found
         SPACE 1
PPLP     DS    0H                  "(" found when a positional expected
         C     R8,POSCOUNT         If no pos. parms found yet
         BE    ERROR_NO_WANT_LP    then this is truly an error; else
*                                  (future extension, but error now)
         L     R3,LASTADDR         Get address of last processed P.P.
         L     R2,LASTLEN          Get length of last processed P.P.
         B     ERROR_PP_WITH_LP    say value spec not allowed
         SPACE 1
PPSLASH  DS    0H                  "/" found when a positional expected
         BAL   R14,DOOPTS          Process options
         B     PPLOOP
         SPACE 1
PPADD    DS    0H                  Add a positional parameter
*
* Check parameter for validity, and (if it's OK) make uppercase copy
* of it in our area.
*
         CH    R2,=H'255'          If too long
         BH    ERROR_PARM_TOO_LONG then error
         LR    R14,R1              Address
         LR    R15,R2              Length
         BCTR  R15,0               Reduce length for execute
         EX    R15,VERIFYP         Check syntax of parameter
         BNZ   ERROR_PARM_INVALID  If bad, error
         CLI   0(R14),C'0'         Must not begin with numeric
         BNL   ERROR_PARM_INVALID  If bad, error
         L     R1,WORDPTR          Get next available word slot
         EX    R15,MVCWORD         Move word to slot
         EX    R15,UPWORD          Translate to uppercase
         LA    R0,1(R15,R1)        Update slot pointer
         ST    R0,WORDPTR          for next time
*
* Check for duplicates. R1 -> new word, R15 = length-1
*
         L     R2,APOSD            Get address of first positional
         LA    R0,1(,R15)          Get true length
CDPPLOOP DS    0H                  Loop to check for duplicates
         CR    R2,R4               until we hit current PP slot
         BNL   CDPPLEND
         C     R0,POSDLEN-POSDDATA(,R2)
         BNE   CDPPNEXT            If lengths don't match, continue
         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter
         EX    R15,COMPWORD        If values are equal,
         BE    ERROR_PARM_DUPLICATE then error
CDPPNEXT LA    R2,POSDDATL(,R2)    Else continue
         B     CDPPLOOP
CDPPLEND DS    0H                  End loop to check for duplicates
         LA    R2,1(,R15)          Get length
         ST    R1,POSDADDR         Save address of this pos. parm.
         ST    R2,POSDLEN          Save length of this pos. parm.
         XR    R0,R0               Clear other fields
         ST    R0,POSDPCEA
         MVI   POSDFLGS,0
         ST    R4,LASTAREA         Save for option/error processing
         ST    R1,LASTADDR         Save for option/error processing
         ST    R2,LASTLEN          Save for option/error processing
         OI    FLAGS,FLAGPOSD      Say currently processing positional
         NI    FLAGS,255-FLAGKEYD
*
* PCE length for positional param: 56 + (2 * length(min(name,234)))
* PDE length for positional param: 8
*
         LR    R15,R2              Get length of positional parm name
         CH    R15,=H'234'         If longer than 255-21
         BNH   *+8                 then
         LA    R15,255-21           set length to 255-21
         ST    R15,POSDMAXL        Store this length
         SLA   R15,1               2 * length(min(name,234))
         LA    R15,56(,R15)        56 + (2 * length(min(name,234)))
         ST    R15,POSDPCEL        Set length of PCE for this parameter
         A     R15,PCLLEN          Accumulate PCL length
         ST    R15,PCLLEN
         LA    R1,8                Length of PDE for positional = 8
         A     R1,PDLLEN           Accumulate PDL length
         ST    R1,PDLLEN
         LA    R4,POSDDATL(,R4)    Bump pointer
         BCT   R8,PPLOOP           Loop until count exhausted
         SPACE 1
NOPOZZES DS    0H                  Here if no positional parameters
         SPACE 1
*
***********************************************************************
*                                                                     *
* Get storage to hold information for keyword and value parameters.   *
* We don't know how much we'll need yet, so we'll get a chunk of it   *
* and hope for the best.                                              *
*                                                                     *
***********************************************************************
*
         L     R5,KEYDINCR         Get estimated initial length
         GETMAIN RC,LV=(R5),LOC=ANY Get storage
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         ST    R1,AKEYD            Save address of this area
         ST    R5,LKEYD            Save length of this area
         XR    R4,R4               Start things off
         USING KEYDDATA,R4
         LA    R0,0(R1,R5)         Point to end of area
         ST    R0,AKEYE            Save address of end
*
***********************************************************************
*                                                                     *
* Loop collecting keywords and keyword/value pairs.                   *
*                                                                     *
***********************************************************************
*
         XR    R6,R6               Clear keyword count
KVLOOP   DS    0H
         BAL   R14,SCAN            Get a keyword parameter
         B     KVEND               No more
         B     KVADD               Unquoted name
         B     ERROR_NO_WANT_QS    Quoted string found
         B     KVLP                "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     KVSLASH             "/" found
         SPACE 1
KVLP     DS    0H                  "(" found when a keyword expected
         LTR   R6,R6               If we've seen keyword parms already
         BNZ   ERROR_NO_WANT_LP    then this is truly an error
         ICM   R0,15,POSCOUNT      Else if no positional parameters
         BZ    ERROR_NO_WANT_LP    then this is truly an error.  Else,
*                                  (future extension, but error now)
         L     R3,LASTADDR         Get address of last processed P.P.
         L     R2,LASTLEN          Get length of last processed P.P.
         B     ERROR_PP_WITH_LP    say value spec w/p.p. not allowed
         SPACE 1
KVSLASH  DS    0H                  "/" found when a keyword expected
         BAL   R14,DOOPTS          Process options
         B     KVLOOP
         SPACE 1
KVADD    DS    0H                  Add a keyword parameter
         OI    FLAGS,FLAGKEYD      Say we're currently processing
         NI    FLAGS,255-FLAGPOSD  keyword/value parameters
         LTR   R4,R4               If we haven't got any keywords yet
         BNZ   KVNZ                then
         L     R4,AKEYD             point to first entry in area
         B     KVA                  and do our stuff.
KVNZ     DS    0H                  Else...
         LA    R4,KEYDDATL(,R4)    Bump pointer
         C     R4,AKEYE            If this takes us past end of buffer
         BL    KVA                 then...                      #TSO147
         STM   R1,R2,SCANRES       Store result of scan
         L     R5,LKEYD             get length of current area
         A     R5,KEYDINCR          increment it
         GETMAIN RC,LV=(R5),LOC=ANY get storage
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         LR    R2,R1               Address of new key area
         LR    R0,R2               Address of new key area
         L     R14,AKEYD           Address of old key area
         L     R1,LKEYD            Length of old key area
         LR    R15,R1              Length of old key area
         MVCL  R0,R14              Move old key data to new key data
         LR    R4,R0               Point to slot in new key area
         L     R1,AKEYD            Address of old key area
         L     R0,LKEYD            Length of old key area
         FREEMAIN RC,LV=(0),A=(1)  Free the old key area
         ST    R2,AKEYD            Save address of new area
         ST    R5,LKEYD            Save length of new area
         LA    R0,0(R2,R5)         Point to end of area
         ST    R0,AKEYE            Save address of end
         LM    R1,R2,SCANRES       Load results of scan
KVA      DS    0H
*
* Check parameter for validity, and (if it's OK) make uppercase copy
* of it in our area.
*
         CH    R2,=H'255'          If too long
         BH    ERROR_PARM_TOO_LONG then error
         LR    R14,R1              Address
         LR    R15,R2              Length
         BCTR  R15,0               Reduce length for execute
         EX    R15,VERIFYP         Check syntax of parameter
         BNZ   ERROR_PARM_INVALID  If bad, error
         CLI   0(R14),C'0'         Must not begin with numeric
         BNL   ERROR_PARM_INVALID  If bad, error
         L     R1,WORDPTR          Get next available word slot
         EX    R15,MVCWORD         Move word to slot
         EX    R15,UPWORD          Translate to uppercase
         LA    R0,1(R15,R1)        Update slot pointer
         ST    R0,WORDPTR          for next time
*
* Check for duplicates. R1 -> new word, R15 = length-1
*
         ICM   R8,15,POSCOUNT      Get count of positionals
         BZ    KVPPLEND            If none, don't check 'em, obviously
         L     R2,APOSD            Get address of first positional
         LA    R0,1(,R15)          Get true length
KVPPLOOP DS    0H                  Loop to check for duplicates
         C     R0,POSDLEN-POSDDATA(,R2)
         BNE   KVPPNEXT            If lengths don't match, continue
         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter
         EX    R15,COMPWORD        If values are equal,
         BE    ERROR_PARM_DUPLICATE then error
KVPPNEXT LA    R2,POSDDATL(,R2)    Else continue
         BCT   R8,KVPPLOOP         until no more positionals
KVPPLEND DS    0H                  End loop to check for duplicates
*                                  Now check against keywords so far
         LTR   R8,R6               Get count of keywords
         BZ    KVKWLEND            If none so far, don't check 'em
         L     R2,AKEYD            Get address of first keyword
         LA    R0,1(,R15)          Get true length
KVKWLOOP DS    0H                  Loop to check for duplicates
         C     R0,KEYWORDL-KEYDDATA(,R2)
         BNE   KVKWNEXT            If lengths don't match, continue
         L     R14,KEYWORDA-KEYDDATA(,R2) Point to old parameter
         EX    R15,COMPWORD        If values are equal,
         BE    ERROR_PARM_DUPLICATE then error
KVKWNEXT LA    R2,KEYDDATL(,R2)    Else continue
         BCT   R8,KVKWLOOP         until no more keywords
KVKWLEND DS    0H                  End loop to check for duplicates
         LA    R6,1(,R6)           Increment keyword count
         LA    R2,1(,R15)          Get length
         ST    R1,KEYWORDA         Save address of this pos. parm.
         ST    R2,KEYWORDL         Save length of this pos. parm.
         ST    R4,LASTAREA         Save for option/error processing
         ST    R1,LASTADDR         Save for option/error processing
         ST    R2,LASTLEN          Save for option/error processing
         XR    R0,R0               Clear other keyword/value fields
         ST    R0,KEYDVALA
         ST    R0,KEYDVALL
         ST    R0,KEYDPCEA
         ST    R0,KEYDPCEL
         ST    R0,KEYDMAXL
         ST    R0,KEYSUBOF
         MVI   KEYFLAGS,0
KVOLOOP  DS    0H
*
* Now get the next thing, which might be a parenthesized default value
* or a slashed keyword processing option
*
         BAL   R14,SCAN            Get a keyword parameter
         B     KVFINEND            No more
         B     KVFINADD            Unquoted name, it's another keyword
         B     ERROR_NO_WANT_QS    Quoted string found
         B     KVVALUE             "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     KVOPTION            "/" found
         SPACE 1
KVOPTION DS    0H                  We (probably) have a /option...
         BAL   R14,DOOPTS          Process options
         B     KVOLOOP
         SPACE 1
KVVALUE  DS    0H                  We (probably) have a value...
         SPACE 1
*
* Scan for the value (can be any kind of string).
*
         BAL   R14,SCAN            Get a value string
         B     KVNULL              End of buffer, value is null
         B     KVWORD              Unquoted name, it's a value
         B     KVSTRING            Quoted string found, it's a value
         B     KVERROR             "(" found, should never happen
         B     KVNULL              ")" found, value is null
         B     KVERROR             "/" found, should never happen
         SPACE 1
KVWORD   DS    0H                  Unquoted word is the value
         ST    R1,KEYDVALA         Store address of default value
         ST    R2,KEYDVALL         Store length of default value
         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present
         B     KVGETRP             Go get right paren
         SPACE 1
KVSTRING DS    0H                  Quoted string is the value
         ST    R1,KEYDVALA         Store address of default value
         ST    R2,KEYDVALL         Store length of default value
         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present
         OI    KEYFLAGS,KEYFQUOT   Indicate it's a quoted string
         B     KVGETRP             Go get right paren
         SPACE 1
KVGETRP  DS    0H                  Time to terminate the value...
*
* Scan for the right parenthesis that ends the value spec
*
         BAL   R14,SCAN            Get a value string
         B     KVFINEND            End of buffer
         B     KVEXTRA             Unquoted name, shouldn't be there
         B     KVEXTRA             Quoted string, shouldn't be there
         B     KVERROR             "(" found, should never happen
         B     KVFINLOP            ")" found, OK, continue looping
         B     KVERROR             "/" found, should never happen
         SPACE 1
KVEXTRA  DS    0H
*                                  (future extension, but for now)
         LR    R3,R1               Get address of extraneous data
******** LR    R2,R2               Get length of extraneous data
         LA    R1,MSG_EXTRANEOUS   Ignore extraneous info
         LA    R0,L'MSG_EXTRANEOUS
         BAL   R14,PUTLINE
         B     KVGETRP             Keep looking for that right paren
         SPACE 1
KVNULL   DS    0H
         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present
         LA    R14,KVLOOP          (but it's null)
         B     KVACCUM             Accumulate length, then get next KW
         SPACE 1
KVFINLOP DS    0H                  End keyword(value), another follows
         LA    R14,KVLOOP          Proceed to KVLOOP after doing...
         B     KVACCUM             accumulation for this keyword
         SPACE 1
KVFINADD DS    0H                  End this keyword, another follows
         LA    R14,KVADD           Proceed to KVADD after doing...
         B     KVACCUM             accumulation for this keyword
         SPACE 1
KVFINEND DS    0H                  End this keyword, no more follow
         LA    R14,KVEND           Proceed to KVEND after doing...
******** B     KVACCUM             accumulation for this keyword
         SPACE 1
KVACCUM  DS    0H
*
*   Calculate PCE and PDE lengths for keyword parameter
*   For each keyword with a value:
*     66 + (2 * length(min(name,237))) + length(name)
*   For each keyword without value:
*     11 + length(name)
*
* We're going to use the same storage to build unquoted values of
* keywords, so add that length in too.
*
         STM   R1,R2,SCANRES       Save results of scan
         L     R15,KEYWORDL        Get length of keyword name
         TM    KEYFLAGS,KEYFDVAL   If a value specified
         BNO   PCKWNVAL            then...
         CH    R15,=H'237'         min(name,237)
         BNH   *+8
         LA    R15,237
         ST    R15,KEYDMAXL        Save this length
         SLA   R15,1               2 * length(min(name,237))
         LA    R15,66(,R15)        66 + (2 * length(min(name,237)))
         A     R15,KEYWORDL        66 + ... + length(name)
         LA    R1,8                Accumulate PDL length for subfield
         A     R1,PDLLEN
         ST    R1,PDLLEN
         TM    KEYFLAGS,KEYFQUOT   If value is quoted string
         BNO   PCKWNEXT            then...
         L     R1,KEYDVALL          accumulate value length
         A     R1,QVALLEN
         ST    R1,QVALLEN          (actual'll be less, but never more)
         B     PCKWNEXT
PCKWNVAL DS    0H                  No value specified...
         LA    R15,11(,R15)        just 11 + length(name)
PCKWNEXT DS    0H
         ST    R15,KEYDPCEL        Save PCE length
         A     R15,PCLLEN          Accumulate PCL length for keyword
         ST    R15,PCLLEN
         LA    R1,2                Accumulate PDL length for keyword
         A     R1,PDLLEN
         ST    R1,PDLLEN
         LM    R1,R2,SCANRES       Load results of scan
         BR    R14                 Go to KVADD or KVEND or KVLOOP
         SPACE 1
KVEND    DS    0H                  No more parameters of any kind
         SPACE 1
         ST    R6,KEYCOUNT         Save number of keywords
         SPACE 1
         EJECT
***********************************************************************
*                                                                     *
* Prepare to build control blocks for IKJPARS for the parameters,     *
* like so:                                                            *
*                                                                     *
*          IKJPARM                                                    *
*                                                                     *
*   For each positional parameter "pp":                               *
*                                                                     *
*          IKJIDENT 'POSITIONAL PARAMETER pp',                        *
*                ASIS,   /* only if the /ASIS option is specified */  *
*                CHAR,   /* only if /QUOTABLE option is specified */  *
*                FIRST=ANY,OTHER=ANY,                                 *
*                PROMPT='POSITIONAL PARAMETER pp'                     *
*                                                                     *
*   For each keyword parameter "kv" with a value "val";               *
*                                                                     *
*          IKJKEYWD                                                   *
*          IKJNAME 'kv',SUBFLD=kvsubfld                               *
*                                                                     *
*   For each keyword parameter "kw" without a value:                  *
*                                                                     *
*          IKJKEYWD                                                   *
*          IKJNAME 'kv'                                               *
*                                                                     *
*   For each keyword parameter "kv" with a value "val", as above:     *
*                                                                     *
* kvsubfld IKJSUBF                                                    *
*          IKJIDENT 'VALUE FOR KEYWORD kv',                           *
*                ASIS,   /* only if the /ASIS option is specified */  *
*                CHAR,                                                *
*                PROMPT='VALUE FOR KEYWORD kv'                        *
*                                                                     *
*          IKJENDP                                                    *
*                                                                     *
* Note that the default value from the specifications is not part of  *
* the IKJPARS parameters.  Rather, the absence of the keyword is      *
* detected after the call to PARSE and, at that point, the default    *
* value is used if the terminal user did not provide one.             *
*                                                                     *
* Compute storage needed for the PCL (built by us):                   *
*                                                                     *
*   For initial overhead:            7                                *
*   For each positional parameter:   56 + (2 * length(name))          *
*   For each keyword with a value:   66 + (3 * length(name))          *
*   For each keyword without value:  11 + length(name)                *
*                                                                     *
* Compute storage reserved for the PDL (built by IKJPARS):            *
*                                                                     *
*   For initial overhead:            8                                *
*   For each positional parameter:   8                                *
*   For each keyword:                2                                *
*   For each value subfield:         8                                *
*                                                                     *
* We're going to use the same storage to build unquoted values of     *
* keywords, so add that length in too.  Also, we want to include      *
* storage for the final call to IKJCT441 to update all parameters.    *
* How much storage is needed to build the parameter list:  9 words    *
* for each parameter, plus 4 extra words = 13*4.                      *
*                                                                     *
***********************************************************************
         EJECT
*
* Get storage for the PCL plus dequoted value strings plus IKJCT441 PL
*
         L     R1,PDLLEN
         LA    R1,7(,R1)           Round PDL length
         N     R1,=X'FFFFFFF8'      up to doubleword boundary
         ST    R1,PDLLEN           Store length of PDL
         LA    R1,8
         A     R1,QVALLEN          Quoted-string-length + fudge factor
         ST    R1,QVALLEN          Store length of quoted-value area
         A     R1,PCLLEN           Get length of PCL plus quoted area
         L     R0,POSCOUNT         Get count of positional parameters
         A     R0,KEYCOUNT         Add count of positional parameters
         MH    R0,=Y(13*4)         Compute # of plists required
         ST    R0,VUPLEN           Store length of IKJCTT41 parm list
         AR    R0,R1               Add to total length
         ST    R0,PWLEN            Store length of this area
         GETMAIN RC,LV=(0),LOC=ANY Get it
         LTR   R15,R15             If didn't get it, error
         BNZ   GETMAIN_FAILURE
         ST    R1,PWADDR           Save address thereof
         LR    R4,R1               Initialize PCL entry pointer
         LA    R5,8                Initialize PDL offset value
         XR    R0,R0               Clear other PCE-related junk
         ST    R0,FIRSTKEY
         ST    R0,SUBTOSET
*
* Build the IKJPARM part of the PCL.
*
* PCE contents:  +0 (2)  Length of entire PCL
*                +2 (2)  Length of PDL returned by PARSE
*                +4 (2)  Offset in PDL to first IKJKEYWD PCE
*                        (or to end-of-field indicator, i.e.
*                        the x'0000' in an IKJSUBF or IKJENDP)
*
*        ...   ..,0(,R4)           Leave this unset for now...
         L     R0,PDLLEN
         STH   R0,2(,R4)           IKJPARM +2 (2) Length of PDL
*        ...   ..,4(,R4)           Leave this unset for now...
         LA    R4,6(,R4)           Bump past this PCE
*
* For each positional parameter, build an IKJIDENT PCE.
*
* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)
*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)
*                +2 (2)  Length of this PCE: 56 + 2*length(name)
*                +4 (2)  Offset in PDL to PDE for this parameter
*                +6 (1)  Flags:  B'0000 x000' (x = 1 if CHAR, else 0)
*                +7 (1)  X'00' (FIRST=ANY)
*                +8 (1)  X'00' (OTHER=ANY)
*                +9 (2)  Length of 'POSITIONAL PARAMETER pp' + 4
*                                  (25 + length(name))
*                +B (2)  X'0012'
*                +D (*)  'POSITIONAL PARAMETER pp' (21 + length(name))
*                +* (1)  Length of 'POSITIONAL PARAMETER pp' - 1
*                                  (20 + length(name))
*                +* (*)  'POSITIONAL PARAMETER pp' (21 + length(name))
*
         ICM   R8,15,POSCOUNT      Get count of positionals
         BZ    PBPPLEND            If none, skip
         L     R2,APOSD            Get address of first positional
PBPPLOOP DS    0H                  Loop to build PCE's
         ST    R4,POSDPCEA-POSDDATA(,R2) Set address of PCE for this
         MVI   0(R4),B'10010100'   +0 (1) Flags
         TM    POSDFLGS-POSDDATA(R2),POSDASIS If /ASIS option given
         BZ    PBPPNASI                       then
         MVI   1(R4),B'01000000'   +1 (1) Flags
         B     PBPPAEND                       else
PBPPNASI MVI   1(R4),B'00000000'   +1 (1) Flags
PBPPAEND DS    0H
         L     R14,POSDPCEL-POSDDATA(,R2) Get length of PCE
         STH   R14,2(,R4)          +2 (2) Length of this PCE
         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this
         TM    POSDFLGS-POSDDATA(R2),POSDCHAR If /QUOTABLE option given
         BZ    PBPPNCHA                       then
         MVI   6(R4),B'00001000'   +6 (1) Flags
         B     PBPPCEND                       else
PBPPNCHA MVI   6(R4),B'00000000'   +6 (1) Flags
PBPPCEND DS    0H
         MVI   7(R4),X'00'         +7 (1) X'00' (FIRST=ANY)
         MVI   8(R4),X'00'         +8 (1) X'00' (OTHER=ANY)
         L     R15,POSDMAXL-POSDDATA(,R2) Get length of name for prompt
         LA    R0,25(,R15)         21 + length(name) + 4
         STH   R0,9(,R4)           +9 (2) Length of '...' + 4
         MVC   11(2,R4),=X'0012'   +B (2) X'0012'
         MVC   13(21,R4),=C'POSITIONAL PARAMETER '
         LA    R4,13+21(,R4)       Point to where to move param name
         BCTR  R15,0               Reduce length for execute
         L     R1,POSDADDR-POSDDATA(,R2) Get address of parameter name
         EX    R15,MVCTOPCE        Move parameter name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R0,21(,R15)         21 + length(name) - 1
         STC   R0,0(,R4)           Length of prompt data
         MVC   1(21,R4),=C'POSITIONAL PARAMETER '
         LA    R4,1+21(,R4)        Point to where to move param name
         EX    R15,MVCTOPCE        Move parameter name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R5,8(,R5)           Increment PDE offset
         LA    R2,POSDDATL(,R2)    Continue
         BCT   R8,PBPPLOOP          until no more positionals
PBPPLEND DS    0H                  End loop
*
* For each keyword parameter, build an IKJKEYWD PCE.
*
* PCE contents:  +0 (1)  Flags:  B'0100 0000' (IKJKEYWD)
*                +1 (1)  Flags:  B'0000 0000'
*                +2 (2)  Length of this PCE: 6
*                +4 (2)  Offset in PDL to PDE for this parameter
*
* If the keyword has a value, build an IKJNAME PCE as follows:
*
* PCE contents:  +0 (1)  Flags:  B'0110 0100' (IKJNAME, has subfield)
*                +1 (1)  Flags:  B'0000 0000'
*                +2 (2)  Length of this PCE: 7 + length(name)
*                +4 (1)  Length of keyword name minus 1
*                +5 (*)  the keyword name
*                +* (2)  offset (plus 1) in PCL to subfield PCE
*
* A subfield will be built as well.  But not now.
*
* If the keyword doesn't have a value, build an IKJNAME PCE as follows:
*
* PCE contents:  +0 (1)  Flags:  B'0110 0000' (IKJNAME, no subfield)
*                +1 (1)  Flags:  B'0000 0000'
*                +2 (2)  Length of this PCE: 5 + length(name)
*                +4 (1)  Length of keyword name minus 1
*                +5 (*)  the keyword name
*
         ICM   R8,15,KEYCOUNT      Get count of keywords
         BZ    PBKWLEND            If none, skip
         L     R2,AKEYD            Get address of first keyword
PBKWLOOP DS    0H                  Loop to build PCE's
*
* Build IKJKEYWD PCE
*
         ICM   R0,15,FIRSTKEY      If this is first keyword
         BNZ   *+8                 then
         ST    R4,FIRSTKEY         set address of first keyword PCE
         ST    R4,KEYDPCEA-KEYDDATA(,R2) Set address of PCE for this
         MVI   0(R4),B'01000000'   +0 (1) Flags (IKJKEYWD)
         MVI   1(R4),B'00000000'   +1 (1) Flags
         LA    R0,6
         STH   R0,2(,R4)           +2 (2) Length of this PCE
         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this
         LA    R4,6(,R4)           Bump PCE pointer
*
* Build IKJNAME PCE, format of which depends if with value or not.
*
         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If a value specified
         BNO   PBKWNVAL            then...
         MVI   0(R4),B'01100100'   +0 (1) Flags (IKJNAME, has subfield)
         MVI   1(R4),B'00000000'   +1 (1) Flags
         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name
         LA    R0,7(,R15)                7 + length(name)
         STH   R0,2(,R4)           +2 (2) Length of this PCE
         BCTR  R15,0               Length minus 1 for store & execute
         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1
         LA    R4,5(,R4)           Point to where to move keyword name
         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCE
         LA    R4,1(R15,R4)        Bump past name
         ST    R4,KEYSUBOF-KEYDDATA(,R2) Save where to set subfield off
*        ...   ...0(,R4)           Leave subfield offset out for now
         LA    R4,2(,R4)           Bump to end of PCE
         B     PBKWNEXT
PBKWNVAL DS    0H                  No value specified...
         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS was specified
         BO    ERROR_ASIS_NEEDS_VAL           then error
         MVI   0(R4),B'01100000'   +0 (1) Flags (IKJNAME, no subfield)
         MVI   1(R4),B'00000000'   +1 (1) Flags
         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name
         LA    R0,5(,R15)                5 + length(name)
         STH   R0,2(,R4)           +2 (2) Length of this PCE
         BCTR  R15,0               Length minus 1 for store & execute
         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1
         LA    R4,5(,R4)           Point to where to move keyword name
         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCE
         LA    R4,1(R15,R4)        Bump past name
******** LA    R4,0(,R4)           Bump to end of PCE
PBKWNEXT DS    0H
         LA    R5,2(,R5)           Increment PDE offset
         LA    R2,KEYDDATL(,R2)    Continue
         BCT   R8,PBKWLOOP          until no more keywords
PBKWLEND DS    0H                  End loop
*
* For each keyword parameter with a value, build subfield PCE's.
*
* Build an IKJSUBF PCE.
*
* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)
*                +1 (2)  Offset in PCL to next end-of-field indicator
*                        (either the next IKJSUBF or the IKJENDP).
*                        If the subfield had keywords, this would have
*                        to point to the next IKJKEYWD PCE therein.
*
* Build an IKJIDENT PCE for the keyword value.
*
* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)
*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)
*                +2 (2)  Length of this PCE: 50 + 2*length(name)
*                +4 (2)  Offset in PDL to PDE for this parameter
*                +6 (1)  Flags:  B'0000 1000' (CHAR)
*                +7 (1)  X'01' (FIRST= is not applicable)
*                +8 (1)  X'01' (OTHER= is not applicable)
*                +9 (2)  Length of 'VALUE FOR KEYWORD pp' + 4
*                                  (22 + length(name))
*                +B (2)  X'0012'
*                +D (*)  'VALUE FOR KEYWORD pp' (18 + length(name))
*                +* (1)  Length of 'VALUE FOR KEYWORD pp' - 1
*                                  (17 + length(name))
*                +* (*)  'VALUE FOR KEYWORD pp' (18 + length(name))
*
         ICM   R8,15,KEYCOUNT      Get count of keywords
         BZ    PSKWLEND            If none, skip
         L     R2,AKEYD            Get address of first keyword
PSKWLOOP DS    0H                  Loop to build subfield PCE's
         ICM   R14,15,KEYSUBOF-KEYDDATA(R2) Get where to put sub offset
         BZ    PSNOSUB             If none, skip
         LA    R0,1(,R4)           Get address of PCE we're building
         S     R0,PWADDR           Convert to offset plus 1
         STH   R0,0(,R14)          Set keyword PCE's subfield offset
*
* Build IKJSUBF PCE
*
         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE
         BZ    PSNSUBST            to set, then
         LR    R0,R4                get address of this IKJSUBF PCE
         S     R0,PWADDR            convert to offset
         STH   R0,1(,R1)            set offset to next subfield
PSNSUBST DS    0H
         ST    R4,SUBTOSET         Set address of subfield to set
         MVI   0(R4),B'00000000'   +0 (1) Flags (end-of-field indicator
*        ...   ...,1(,R4)          +1 (1) Offset of next SUBF or ENDP
         LA    R4,3(,R4)           Bump PCE pointer
         MVI   0(R4),B'10010100'   +0 (1) Flags (IKJIDENT, PROMPT)
         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS option given
         BZ    PSNASIS                        then
         MVI   1(R4),B'01000000'   +1 (1) Flags
         B     PSNAEND                        else
PSNASIS  MVI   1(R4),B'00000000'   +1 (1) Flags
PSNAEND  DS    0H
         L     R15,KEYDMAXL-KEYDDATA(,R2) Get length of name for prompt
         LR    R14,R15
         SLA   R14,1               2 * length(name)
         LA    R14,50(,R14)        50 + (2 * length(name))
         STH   R14,2(,R4)          +2 (2) Length of this PCE
         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this
         MVI   6(R4),B'00001000'   +6 (1) Flags (CHAR)
         MVI   7(R4),X'01'         +7 (1) X'01' (FIRST=n/a)
         MVI   8(R4),X'01'         +8 (1) X'01' (OTHER=n/a)
         LA    R0,22(,R15)         18 + length(name) + 4
         STH   R0,9(,R4)           +9 (2) Length of '...' + 4
         MVC   11(2,R4),=X'0012'   +B (2) X'0012'
         MVC   13(18,R4),=C'VALUE FOR KEYWORD '
         LA    R4,13+18(,R4)       Point to where to move keyword name
         BCTR  R15,0               Length minus 1 for store & execute
         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R0,18(,R15)         18 + length(name) - 1
         STC   R0,0(,R4)           Length of prompt data
         MVC   1(18,R4),=C'VALUE FOR KEYWORD '
         LA    R4,1+18(,R4)        Point to where to move keyword name
         EX    R15,MVCTOPCE        Move keyword name to PCL
         LA    R4,1(R15,R4)        Bump PCE pointer
         LA    R5,8(,R5)           Increment PDE offset
PSNOSUB  DS    0H
         LA    R2,KEYDDATL(,R2)    Continue
         BCT   R8,PSKWLOOP          until no more keywords
PSKWLEND DS    0H                  End loop
         SPACE 1
*
* Build the IKJENDP part of the PCL.
*
* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)
*
         MVI   0(R4),B'00000000'   +0 (1) Flags
         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE
         BZ    PENSUBST            to set, then
         LR    R0,R4                get address of this IKJENDP PCE
         S     R0,PWADDR            convert to offset
         STH   R0,1(,R1)            set offset to next subfield
PENSUBST DS    0H
         ICM   R1,15,FIRSTKEY      If no keyword PCE built
         BNZ   PEGOTKEY            then
         ST    R4,FIRSTKEY          make this the one
PEGOTKEY DS    0H
         L     R15,PWADDR          Get address of start of PCE
         L     R0,FIRSTKEY         Load offset of first key/or/etc.PCE
         SR    R0,R15              Convert to offset
         STH   R0,4(,R15)          Set offset in IKJPARM PCE
         LA    R4,1(,R4)           Bump past this PCE
         LR    R0,R4
         S     R0,PWADDR           Convert to offset
         ST    R0,PCLLEN           Set actual PCL length
         L     R1,PWADDR           Get address of IKJPARM PCE
         STH   R0,0(,R1)           IKJPARM +0 (2) Length of PCL
         ST    R4,QOFF             Save address of where to build
*                                   unquoted strings
*
* Note that unquoted strings won't be built until/unless we assign
* default values from them after a successful parse of the arguments.
*
         EJECT
*
* Next steps:  If initial variable specified, use IKJCT441 to get its
*              value.  Otherwise use REXX call to get at arguments.
*              Make a command buffer out of this and call IKJPARS.
*              If parsing successful, go thru each positional and
*              keyword parameter, getting its value, and assign all
*              the values using IKJCT441.
*
         ICM   R0,15,PVARADDR      Get address of first-arg variable
         BZ    NOVAR               If none, try REXX arg call
         ST    R0,CVNAMEA          Set address of variable name
         L     R0,PVARLEN          Get length of first-arg variable
         ST    R0,CVNAMEL          Set length of variable name
         LA    R0,TSVERETR         Return variable value
*                                  (create variable if doesn't exist)
         ST    R0,CVENTRY          Set entry code
         XR    R0,R0
         ST    R0,CVVALUEA         Address of variable value
         ST    R0,CVVALUEL         Length of variable value
         ST    R0,CVTOKEN          Token
         LA    R14,CVENTRY         Store into IKJCT441 parameter list
         LA    R15,CVNAMEA
         LA    R0,CVNAMEL
         LA    R1,CVVALUEA
         LA    R2,CVVALUEL
         LA    R3,CVTOKEN
         L     R4,CPPLECT          Address of passed ECT        #TSO172
         STM   R14,R4,CVPARMS                                   #TSO172
         OI    CVPARM7,X'80'       Set VL bit                   #TSO172
         LA    R1,CVPARMS          Point to parameter list
         L     R15,X'10'               Get address of CVT
         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table
         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441
         BALR  R14,R15             Call variable access routine
         CH    R15,=H'4'           Get return code
         BNH   GETVAROK            If not 0 or 4, error
         BAL   R14,ERROR_GETTING_VAR
         B     FLUSHIT
         SPACE 1
NOVAR    DS    0H                  No variable, try REXX arg call
         SPACE 1
*
***********************************************************************
*                                                                     *
* Invoke the IRXEXCOM routine to fetch the ARG information.           *
*                                                                     *
* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *
*                                                                     *
***********************************************************************
*
* Build the SHVBLOCK
*
* To store the argument value, we try using ARGWA, a 512-byte area
* that is already part of our workarea, to avoid unnecessary GETMAINs.
*
* If that doesn't turn out to be big enough, we'll have to GETMAIN,
* but it's best to avoid that.
*
         XC    SHVBLOCK(SHVBLEN),SHVBLOCK
         MVI   SHVCODE,SHVPRIV     Fetch private information
         LA    R1,L'ARGWA
         ST    R1,SHVBUFL          Length of 'fetch' value buffer
         LA    R1,ARGWA
         ST    R1,SHVVALA          Address of value buffer
         LA    R1,=C'ARG'          Name of thing to be fetched
         ST    R1,SHVNAMA          Address of variable name
         LA    R1,3                Length('ARG')
         ST    R1,SHVNAML          Length of variable name
         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1
         XR    R15,R15             IRXEXCOM parm 2
         LR    R0,R15              Parm 3 must be same as Parm 2
         LA    R1,SHVBLOCK         IRXEXCOM parm 4
         STM   R14,R1,IRPARMS
         OI    IRPARM4,X'80'
RETRYIRX DS    0H
*        XR    R0,R0               Don't specify an environment #TSO162
         L     R1,CPPLECT          Get passed ECT address       #TSO162
         L     R0,ECTENVBK-ECT(,R1) Get addr of REXX envir. blk #TSO162
         LA    R1,IRPARMS          Point to parameter list
         L     R15,X'10'               Get address of CVT
         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table
         L     R15,TSVTEXCO-TSVT(,R15) Get address of IRXEXCOM
         BALR  R14,R15             Call REXX arg access routine
         LTR   R15,R15             If rc zero
         BZ    OKIRX               then OK
         CH    R15,=Y(SHVTRUNC)    If value was truncated
         BE    OOPSIRX             then need more room to hold value
         B     ERROR_IRXEXCOM      Else error
OOPSIRX  DS    0H                  Not enough room to hold value
         ICM   R1,15,ARGADDR       Get address of arg buffer
         BZ    NOARGYET            If nonzero, then...
         L     R0,ARGLEN           Get length
         FREEMAIN RC,LV=(0),A=(1)
NOARGYET DS    0H
         LA    R0,1024             Increment arg len so far
         A     R0,ARGLEN
         ST    R0,ARGLEN
         ST    R0,SHVBUFL          Reset length of fetch buffer
         GETMAIN RC,LV=(0),LOC=ANY
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         ST    R1,ARGADDR
         ST    R1,SHVVALA          Reset address of value buffer
         B     RETRYIRX            Try again
OKIRX    DS    0H                  Everything OK
         MVC   CVVALUEL,SHVVALL    Set length of arg value
         MVC   CVVALUEA,SHVVALA    Set address of arg value
         SPACE 1
GETVAROK DS    0H
         EJECT
*
***********************************************************************
*                                                                     *
* Build a fake command buffer containing the value of the variable,   *
* for use by IKJPARS.  Format:                                        *
* ___________________________________________________________________ *
* |            |       |                                            | *
* | valuelen+4 | zero  |  value text                                | *
* |____________|_______|____________________________________________| *
*                                                                     *
***********************************************************************
*
         LA    R2,4                Get 4 + ...
         A     R2,CVVALUEL             length of variable value
         ST    R2,VBUFLEN          Save length
         GETMAIN RC,LV=(R2),LOC=ANY Get a fake command buffer
         LTR   R15,R15
         BNZ   GETMAIN_FAILURE
         ST    R1,VBUFADDR         Save address of fake command buffer
         SLL   R2,16               Make buffer prefix
         ST    R2,0(,R1)           Store into fake command buffer
         LA    R2,4(,R1)           Address of fake command buffer text
         L     R14,CVVALUEA        Address of variable value
         L     R15,CVVALUEL        Length of variable value
         LR    R3,R15              Length of fake command buffer text
         MVCL  R2,R14              Move variable value to fake buffer
*
***********************************************************************
*                                                                     *
* Set up to call IKJPARS.                                             *
*                                                                     *
***********************************************************************
*
         XC    ANSWER,ANSWER       Clear PDL address field
         MVC   PPLUPT,CPPLUPT      Address of UPT
         MVC   PPLECT,CPPLECT      Address of ECT
         LA    R14,ECB             Address of ECB
         L     R15,PWADDR          Address of the PCL we built
         LA    R0,ANSWER           Address of PARSE answer area
         L     R1,VBUFADDR         Address of our fake command buffer
         STM   R14,R1,PPLECB       Set rest of PPL
         ST    R9,PPLUWA           User work area = "DATD"
         ST    R9,PPLVEWA          (we don't use verify exit, but...)
         SPACE 1
         CALLTSSR EP=IKJPARS,MF=(E,PPL)
         LTR   R15,R15
         BNZ   ERROR_PARSE_FAILURE
         EJECT
*
***********************************************************************
*                                                                     *
* Now that PARSE has successfully gotten values for all parameters,   *
* go through them and retrieve their values, which will be used to    *
* set variables via IKJCT441.                                         *
*                                                                     *
***********************************************************************
*
         L     R7,ANSWER           Get address of PDL
         L     R5,PWADDR           Get address of PCL-et-al work area
         A     R5,PCLLEN           Bump past PCL part
         A     R5,QVALLEN          Bump past unquoted-string part
         LA    R5,3(,R5)           Round up to
         N     R5,=X'FFFFFFFC'      fullword boundary
         ST    R5,VUPADDR          Save address of this plist
*
* Format of each block of IKJCT441 parameter list:
*
*  +00 -> Entry code (TSVEUPDT)
*  +04 -> Address of variable name
*  +08 -> Length of variable name
*  +0C -> Address of variable value
*  +10 -> Length of variable value
*  +14 -> Token (zero, not used)
*  +18 -> ECT                                                   #TSO172
*  +1C -> Return code from IKJCT441
*  +20 -> Address of next block of this parameter list or X'80000000'
*  +24 ... not part of plist, but space to hold the address of value
*  +28 ... not part of plist, but space to hold the length of value
*  +2C ... not part of plist, but space to hold the return code
*  +30 ... not part of plist, but space to hold the address of link
*
         XR    R0,R0
         ST    R0,CVTOKEN
*        MVC   CVECT,=X'FFFFFFFF'                               #TSO172
         LA    R15,TSVEUPDT        Entry code = update variable
         ST    R15,CVENTRY         Set entry code
         L     R4,POSCOUNT         Get # of positionals
         A     R4,KEYCOUNT           + # of keywords
         BZ    NOUPDATE            If no parameters, no updating.
         L     R15,VUPADDR         Get address of the plist
BPLOOP   DS    0H
         LR    R5,R15              Point to this element of parm list
         LA    R15,CVENTRY
         ST    R15,X'00'(,R5)      Parameter 1: entry code
*                                  Set later...
*        ST       ,X'04'(,R5)      Parameter 2: address of var name
*                                  Set later...
*        ST       ,X'08'(,R5)      Parameter 3: length of var name
         LA    R15,X'24'(,R5)      Value address slot
         ST    R15,X'0C'(,R5)      Parameter 4: address of var value
         LA    R15,X'28'(,R5)      Value length slot
         ST    R15,X'10'(,R5)      Parameter 5: length of var value
         LA    R15,CVTOKEN         Dummy token
         ST    R15,X'14'(,R5)      Parameter 6: token (not used)
*        LA    R15,CVECT           Dummy ECT                    #TSO172
         L     R15,CPPLECT         Address of passed ECT        #TSO172
         ST    R15,X'18'(,R5)      Parameter 7: ECT             #TSO172
         LA    R15,X'2C'(,R5)      Return code slot
         ST    R15,X'1C'(,R5)      Parameter 8: IKJCT441 return code
         LA    R15,X'30'(,R5)      Link slot
         ST    R15,X'20'(,R5)      Parameter 9: next element in list
         LA    R15,X'34'(,R5)
         ST    R15,X'30'(,R5)      Address of next plist block
         OI    X'20'(R5),X'80'     Set VL bit
         BCT   R4,BPLOOP           Continue
         L     R0,=X'00000000'     At end,
         ST    R0,X'30'(,R5)       clear last link pointer in list
         L     R5,VUPADDR          Point to first plist block again
         EJECT
*
***********************************************************************
*                                                                     *
* Now go through positional parameters, setting things up.            *
*                                                                     *
* Format of PDE for a positional parameter (IKJIDENT):                *
*                                                                     *
* +0 (4) Pointer to the positional operand                            *
* +4 (2) Length thereof                                               *
* +6 (1) Flags                                                        *
* +7 (1) Reserved                                                     *
*                                                                     *
* Meaning of flags:  0... ....  The operand is not present.           *
*                    1... ....  The operand is present.               *
*                    .xxx xxxx  Reserved bits.                        *
*                                                                     *
***********************************************************************
*
         ICM   R8,15,POSCOUNT      Get count of positionals
         BZ    BPPPLEND            If none, skip
         L     R2,APOSD            Get address of first positional
BPPPLOOP DS    0H                  Loop to fill in IKJCT441 plist
         LA    R15,POSDADDR-POSDDATA(,R2) Get address of param name
         ST    R15,X'04'(,R5)      Parameter 2: address of var name
         LA    R15,POSDLEN-POSDDATA(,R2) Get length of param name
         ST    R15,X'08'(,R5)      Parameter 3: length of var name
         L     R15,POSDPCEA-POSDDATA(,R2) Get address of PCE
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
*
* Note: Of course it's impossible for the operand not to be present
*       under the current implementation.  But a future extension
*       might make this possible.
*
         TM    6(R1),X'80'         If operand is not present,
         BO    BPPPPRES            then...
         XR    R14,R14              say it's set to a null value
         XR    R15,R15              say it's set to a null value
         B     BPPPSET             else...
BPPPPRES DS    0H                  (operand is present)
         L     R14,0(,R1)           get address of value
         LH    R15,4(,R1)           get length of value
BPPPSET  DS    0H                  else (operand is present)
         ST    R14,X'24'(,R5)      Set address of variable value
         ST    R15,X'28'(,R5)      Set length of variable value
         L     R5,X'20'(,R5)       Go to
         L     R5,0(,R5)                 next element of param list
         LA    R2,POSDDATL(,R2)    Continue
         BCT   R8,BPPPLOOP          until no more positionals
BPPPLEND DS    0H                  End loop
         EJECT
*
***********************************************************************
*                                                                     *
* Now go through keyword parameters, setting things up.               *
*                                                                     *
* Format of PDE for a keyword parameter (IKJKEYWD):                   *
*                                                                     *
* +0 (2) Number (0 if not specified, 1 if specified)                  *
*                                                                     *
***********************************************************************
*                                                                     *
* Format of PDE for a keyword value parameter (IKJIDENT):             *
*                                                                     *
* +0 (4) Pointer to the positional operand                            *
* +4 (2) Length thereof                                               *
* +6 (1) Flags                                                        *
* +7 (1) Reserved                                                     *
*                                                                     *
* Meaning of flags:  0... ....  The operand is not present.           *
*                    1... ....  The operand is present.               *
*                    .xxx xxxx  Reserved bits.                        *
*                                                                     *
***********************************************************************
*
         ICM   R8,15,KEYCOUNT      Get count of keywords
         BZ    BPKWLEND            If none, skip
         L     R2,AKEYD            Get address of first keyword
BPKWLOOP DS    0H                  Loop to fill in IKJCT441 plist
         ST    R2,SAVER2           Save register to protect from TRT's
         LA    R15,KEYWORDA-KEYDDATA(,R2) Get address of keyword name
         ST    R15,X'04'(,R5)      Parameter 2: address of var name
         LA    R15,KEYWORDL-KEYDDATA(,R2) Get length of keyword name
         ST    R15,X'08'(,R5)      Parameter 3: length of var name
         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If keyword(value),
         BO    BPKWDVAL            then process value subfield
*
* Keyword without value is set to keyword name if specified, else null
*
         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
         CLC   0(2,R1),=X'0000'    If keyword is not specified,
         BNE   BPKWWPRS            then...
         XR    R15,R15              say it's set to a null value
         ST    R15,X'24'(,R5)       set address of variable value
         ST    R15,X'28'(,R5)       set length of variable value
         B     BPKWNEXT            else...
BPKWWPRS DS    0H                  (operand is present)
         L     R14,X'04'(,R5)       get address of variable name
         L     R15,X'08'(,R5)       get length of variable name
         ST    R14,X'0C'(,R5)      Parameter 4: address of var value
         ST    R15,X'10'(,R5)      Parameter 5: length of var value
         B     BPKWNEXT
         SPACE 1
BPKWDVAL DS    0H                  Else keyword with a value specified
*
* Keyword with value:  If keyword is present, set from value subfield
* (which must be present according to the PARS rules).  Otherwise,
* set value from default from XPROC statement, unquoting if needed.
*
         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
         CLC   0(2,R1),=X'0000'    If keyword is not specified,
         BNE   BPKWVPRS            then...
         L     R14,KEYDVALA-KEYDDATA(,R2) get address of default value
         L     R15,KEYDVALL-KEYDDATA(,R2) get length of default value
         TM    KEYFLAGS-KEYDDATA(R2),KEYFQUOT If value is quoted,
         BNO   BPKWVSET            then...
*                                   unquote it
         LA    R1,1(,R14)          Get address of quoted string + 1
         LR    R3,R15              Get length of quoted string
         SH    R3,=H'2'            minus 2 to get length between quotes
         BZ    BPKWNULL            If '', set variable to null value
         LR    R15,R1
         LR    R14,R1              Save address of string input
         ST    R14,SCANPTR
         AR    R14,R3              Save address of end of it
         ST    R14,SCANEPTR
         L     R14,QOFF            Get where to build unquoted string
         LA    R0,256              Make a constant value of 256
BPGOTQL  CR    R3,R0               If length greater than 256
         BNH   BPGOTQX             then...
         TRT   0(256,R15),STBLQUOT  scan for "'"
         BNZ   BPGOTQT              If we found it, go. Else
         MVC   0(256,R14),0(R15)    copy unquoted data to area
         AR    R14,R0               Increment output pointer by 256
         AR    R15,R0               Increment input pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    BPGOTQL              Either continue scanning
         B     BPGOTQE              or, if length zero, finished
BPGOTQX  DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,BPGQTRT           Scan for "'"
         BNZ   BPGOTQT              If found something, go
         B     BPGOTQE              else end of string
BPGOTQT  DS    0H                  Reached "'"
         CLI   1(R1),C''''         Another "'" has to follow
         BNE   0(0)                (else abend)
         LR    R3,R1               Get length we just scanned
         SR    R3,R15
         EX    R3,BPGQMVC          Move data so far (R15 -> it)
BPGQNMV  DS    0H                  (including quote, so no BCTR)
         LA    R14,1(R14,R3)       Bump past it and following quote
         LA    R15,2(,R1)          Bump to location past "''"
         L     R3,SCANEPTR
         SR    R3,R15              R3 := length remaining to scan
         BP    BPGOTQL             If something left, continue scan
BPGOTQE  DS    0H                  End of quoted string
         L     R3,SCANEPTR
         SR    R3,R15              Get length remaining to move
         BZ    BPGENMV             If zero, skip move
         EX    R3,BPGQMVC          Move data so far (R15 -> it)
BPGENMV  DS    0H                  (including quote, so no BCTR)
         LA    R14,0(R14,R3)       Bump past it
         LR    R15,R14
         S     R15,QOFF            Get length of unquoted string
         L     R1,QOFF             Get address of unquoted string
         ST    R14,QOFF            Update where to build next string
         LR    R14,R1
         B     BPKWDSET            Set address and length of string
BPKWVSET DS    0H                  else (operand is present)
         ST    R14,X'24'(,R5)      Set address of variable value
         ST    R15,X'28'(,R5)      Set length of variable value
         B     BPKWNEXT
BPKWVPRS DS    0H                  (operand is present)
         L     R15,KEYSUBOF-KEYDDATA(,R2) Get where subfield offset is
         LH    R15,0(,R15)         Get offset+1 of IKJSUBF PCE
         LA    R15,2(,R15)         Bump to associated IKJIDENT PCE
         A     R15,PWADDR          Convert to address of subfield
         LH    R1,4(,R15)          Get offset of PDE for this PCE
         AR    R1,R7               Convert to address of PDE
*
* Note: Of course it's impossible for the operand not to be present
*       under the current implementation.  But a future extension
*       might make this possible.
*
         TM    6(R1),X'80'         If operand is not present,
         BO    BPKWDPRS            then...
BPKWNULL DS    0H
         XR    R14,R14              say it's set to a null value
         XR    R15,R15              say it's set to a null value
         B     BPKWDSET            else...
BPKWDPRS DS    0H                  (operand is present)
         L     R14,0(,R1)           get address of value
         LH    R15,4(,R1)           get length of value
BPKWDSET DS    0H                  else (operand is present)
         ST    R14,X'24'(,R5)      Set address of variable value
         ST    R15,X'28'(,R5)      Set length of variable value
BPKWNEXT DS    0H                  Continue
         L     R5,X'20'(,R5)       Go to
         L     R5,0(,R5)                 next element of param list
         L     R2,SAVER2           Restore register clobbered by TRT
         LA    R2,KEYDDATL(,R2)    Continue
         BCT   R8,BPKWLOOP          until no more positionals
BPKWLEND DS    0H                  End loop
*
* Now call IKJCT441 to do all the variable updates.
*
         L     R1,VUPADDR          Point to parameter list
         L     R15,X'10'               Get address of CVT
         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table
         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441
         BALR  R14,R15             Call variable access routine
         L     R5,VUPADDR
RCLOOP   DS    0H
         LA    R5,0(,R5)           Clear VL bit if any
         LTR   R5,R5
         BZ    RCEND
         L     R15,X'2C'(,R5)      Get return code set by IKJCT441
         CH    R15,=H'4'           If return code
         BNH   RCNEXT              If not 0 or 4, error
         BAL   R14,ERROR_PUTTING_VAR
         OI    FLAGS,FLAGPUTE
RCNEXT   L     R5,X'20'(,R5)       Go to
         L     R5,0(,R5)                 next element of param list
         B     RCLOOP
RCEND    DS    0H
         TM    FLAGS,FLAGPUTE      If a variable update error,
         BO    FLUSHIT             then flush
         SPACE 1
NOUPDATE DS    0H                  Here if no call to IKJCT441 needed
         SPACE 1
         B     RETURN0             Everything fine, return code(0)
         EJECT
*
TRTPOSCT TRT   0(*-*,R3),NUMTBL    Executed: scan word for numerics
PACKIT   PACK  DOUBLE(8),0(*-*,R3) Executed: convert word to decimal
VERIFYP  TRT   0(*-*,R14),VERTBL   Executed: verify syntax of parameter
MVCWORD  MVC   0(*-*,R1),0(R14)    Executed: move parameter to wordarea
UPWORD   TR    0(*-*,R1),UPTBL     Executed: translate to uppercase
COMPWORD CLC   0(*-*,R1),0(R14)    Executed: compare parameters
MVCTOPCE MVC   0(*-*,R4),0(R1)     Executed: move parameter name to PCE
BPGQTRT  TRT   0(*-*,R15),STBLQUOT Executed: scan for "'" mark
BPGQMVC  MVC   0(*-*,R14),0(R15)   Executed: copy unquoted data to area
*
         EJECT
*
***********************************************************************
*                                                                     *
* Various error conditions.                                           *
*                                                                     *
***********************************************************************
*
ERROR_GETTING_VAR DS 0H
         ST    R14,E44114          Save return register
         ST    R15,RC441           Save IKJCT441 return code
         L     R2,CVNAMEL          Length of variable name
         L     R3,CVNAMEA          Address of variable name
         ERROR MSG_GETTING_VAR,FLUSH=NO
         B     ERROR441
         SPACE 1
ERROR_PUTTING_VAR DS 0H
         ST    R14,E44114          Save return register
         ST    R15,RC441           Save IKJCT441 return code
         L     R2,X'08'(,R5)       -> Length of variable name
         L     R2,0(,R2)           Length of variable name
         L     R3,X'04'(,R5)       -> Address of variable name
         L     R3,0(,R3)           Address of variable name
         ERROR MSG_PUTTING_VAR,FLUSH=NO
******** B     ERROR441
         SPACE 1
ERROR441 DS    0H
         XR    R2,R2               No additional information for...
         XR    R3,R3
         L     R4,RC441            Load IKJCT441 return code
         CH    R4,=H'81'           Check IKJCT441 return code
         BH    ERROR441_MISC       > 81
         BE    ERROR441_RC81       = 81
         B     *(R4)               Else branch based on return code
         B     ERROR441_MISC       04: Variable cannot be rescanned
*                                  (not treated as an error here)
         B     ERROR441_RC08       08: Variable is a CLIST BIF
         B     ERROR441_RC12       12: Variable is a CLIST label
         B     ERROR441_RC16       16: Variable is unmodifiable
         B     ERROR441_MISC       20: n/a
         B     ERROR441_RC24       24: Variable is a CLIST subprocedure
         B     ERROR441_MISC       28: n/a
         B     ERROR441_RC32       32: GETMAIN/FREEMAIN failure
         B     ERROR441_RC36       36: Variable length is invalid
         B     ERROR441_RC40       40: Not in CLIST or REXX environment
         B     ERROR441_MISC       44: invalid entry code
         B     ERROR441_MISC       48: n/a
         B     ERROR441_MISC       52: n/a
         B     ERROR441_MISC       56: n/a
         B     ERROR441_MISC       60: n/a
         B     ERROR441_MISC       64: n/a
         B     ERROR441_MISC       68: n/a
         B     ERROR441_MISC       72: n/a
         B     ERROR441_RC76       76: Variable is undefined &SYSX...
         B     ERROR441_RC80       80: Variable name invalid for REXX
ERROR441_RC08 ERROR MSG_IKJCT441_RC08,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC12 ERROR MSG_IKJCT441_RC12,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC16 ERROR MSG_IKJCT441_RC16,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC24 ERROR MSG_IKJCT441_RC24,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC32 ERROR MSG_IKJCT441_RC32,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC36 ERROR MSG_IKJCT441_RC36,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC40 ERROR MSG_IKJCT441_RC40,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC76 ERROR MSG_IKJCT441_RC76,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC80 ERROR MSG_IKJCT441_RC80,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_RC81 ERROR MSG_IKJCT441_RC81,FLUSH=NO
         L     R14,E44114
         BR    R14
ERROR441_MISC DS 0H
         CVD   R4,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         LA    R2,2                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_IKJCT441_RC,FLUSH=NO
         L     R14,E44114
         BR    R14
         SPACE 1
NOOPERANDS DS  0H                  No input variable
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_OPERANDS
         SPACE 1
NOPOSCOUNT DS  0H                  No count of positional parameters
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_POS_COUNT
         SPACE 1
BADPOSCOUNT DS 0H                  Bad count of positional parameters
         LA    R2,1(,R4)           Get length of bad data
         ERROR MSG_BAD_POS_COUNT
         SPACE 1
ERROR_NO_WANT_LP DS 0H             Left parenthesis found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_LP
         SPACE 1
ERROR_NO_WANT_RP DS 0H             Right parenthesis found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_RP
         SPACE 1
ERROR_NO_WANT_QS DS 0H             Quoted string found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_QS
         SPACE 1
ERROR_NO_WANT_SL DS 0H             Slash found, not wanted
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_NO_WANT_SL
         SPACE 1
PPMISSING DS   0H                  Positional parm not found, expected
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_TOO_FEW_PPARMS
         SPACE 1
ERROR_PARM_TOO_LONG DS 0H
         LA    R2,252              Display only up to maximum length
         LR    R3,R1               Address of offending parameter
         ERROR MSG_PARM_TOO_LONG
         SPACE 1
ERROR_PARM_INVALID DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_PARM_INVALID
         SPACE 1
ERROR_PARM_DUPLICATE DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_PARM_DUPLICATE
         SPACE 1
ERROR_OPT_TOO_LONG DS 0H
         LA    R2,L'OPTION         Display only up to maximum length
         LR    R3,R1               Address of offending parameter
         ERROR MSG_OPT_TOO_LONG
         SPACE 1
ERROR_OPT_INVALID DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_OPT_INVALID
         SPACE 1
ERROR_OPT_POS_ONLY DS 0H
         LA    R2,1(,R15)          Length of offending parameter
         LR    R3,R14              Address of offending parameter
         ERROR MSG_OPT_POS_ONLY
         SPACE 1
ERROR_ASIS_NEEDS_VAL DS 0H
         L     R3,KEYWORDA-KEYDDATA(,R2)
         L     R2,KEYWORDL-KEYDDATA(,R2)
         ERROR MSG_ASIS_NEEDS_VAL
         SPACE 1
ERROR_PP_WITH_LP DS 0H             Positional parm with left paren
         ERROR MSG_PP_WITH_LP
         SPACE 1
ERROR_FIRST_ARG DS 0H              Bad first argument
         LR    R2,R4               Length of offending parameter
         ERROR MSG_VAR_TOO_LONG
         SPACE 1
ERROR_IRXEXCOM DS 0H               IRXEXCOM failed
         C     R15,=F'-2'          Insufficient storage?
         BE    GETMAIN_FAILURE
         C     R15,=F'-1'          No valid REXX environment?
         BE    ERROR_REXX_REQUIRED
         CVD   R15,DOUBLE
         UNPK  DOUBLE(3),DOUBLE(8)
         OI    DOUBLE+2,X'F0'
         LA    R2,3                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_IRXEXCOM_FAIL
         SPACE 1
ERROR_REXX_REQUIRED DS 0H
         XR    R2,R2
         XR    R3,R3
         ERROR MSG_REXX_REQUIRED
ERROR_PARSE_FAILURE DS 0H          IKJPARS failed
         CH    R15,=H'4'
         BE    FLUSHIT
         CH    R15,=H'20'
         BE    FLUSHIT
         CH    R15,=H'32'
         BE    FLUSHIT
         CVD   R15,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         LA    R2,2                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_PARSE_FAILURE
         SPACE 1
GETMAIN_FAILURE DS 0H              Insufficient storage
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_GETMAIN_FAIL
         SPACE 1
KVERROR  DS    0H                  This should never happen
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_KV_ERROR
         SPACE 1
FLUSHIT  DS    0H                  Return in failure
         SPACE 1
         TCLEARQ INPUT             Flush terminal input
         MVC   FLUSH(LENFLUSH),MFLUSH Set up STACK list form
         XC    ECB,ECB             Clear ECB and flush the input stack
         STACK PARM=FLUSH,MF=(E,IOPL)
         LTR   R15,R15             If STACK failed,
         BZ    RETURN12            then...
         CVD   R15,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         LA    R2,2                Length of error code
         LA    R3,DOUBLE           Address of error code
         ERROR MSG_STACK_ERROR,FLUSH=NO
RETURN12 DS    0H
         LA    R2,12               Set return code to 12
         B     RETURN
         SPACE 1
RETURN0  DS    0H                  Return with code 0
         XR    R2,R2               Set return code to zero
******** B     RETURN
         SPACE 1
RETURN   DS    0H                  R2 contains return code
         SPACE 1
         ICM   R1,15,PWADDR        If there was a parse work area
         BZ    NOFREEPW            then free it
         L     R0,PWLEN
         FREEMAIN RC,LV=(0),A=(1)
NOFREEPW DS    0H
         SPACE 1
         ICM   R1,15,VBUFADDR      If there was a fake command buffer
         BZ    NOFREEVBUF          then free it
         L     R0,VBUFLEN
         FREEMAIN RC,LV=(0),A=(1)
NOFREEVBUF DS  0H
         SPACE 1
         ICM   R1,15,ARGADDR       If there was an arg buffer
         BZ    NOFREEARG           then free it
         L     R0,ARGLEN           Get length
         FREEMAIN RC,LV=(0),A=(1)
NOFREEARG DS   0H
         SPACE 1
         ICM   R1,15,AKEYD         If there was a keyword/value area
         BZ    NOFREEKEYD          then free it
         L     R0,LKEYD
         FREEMAIN RC,LV=(0),A=(1)
NOFREEKEYD DS  0H
         SPACE 1
         ICM   R1,15,APOSD         If there was a pos parm area,
         BZ    NOFREEPOSD          then free it
         L     R0,LPOSD
         FREEMAIN RC,LV=(0),A=(1)
NOFREEPOSD DS  0H
         SPACE 1
         IKJRLSA ANSWER            Free IKJPARS storage if any
         SPACE 1
         L     R0,DATDLEN          Get length of work area
         LR    R1,R13              Get address of work area
         L     R13,4(,R13)         Unchain save area
         ST    R2,16(,R13)         Store return code in save area
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* Subroutines                                                         *
***********************************************************************
         EJECT
DOOPTS   DS    0H                  Process options following "/"
         SPACE 1
         ST    R14,DOOPT14         Save return address
         TM    FLAGS,FLAGPOSD+FLAGKEYD Must be processing either a
         BZ    ERROR_NO_WANT_SL    positional or a keyword
*
* Process the option following the slash.
*
         BAL   R14,SCAN            Scan for option name
         B     DOOPTRET            None, skip
         B     OPTNAME             Unquoted name, process
         B     ERROR_NO_WANT_QS    Quoted string found
         B     ERROR_NO_WANT_LP    "(" found
         B     ERROR_NO_WANT_RP    ")" found
         B     ERROR_NO_WANT_SL    "/" found
         SPACE 1
OPTNAME  DS    0H                  Option name found
*
* Validate option name and process it.
*
         CH    R2,=Y(L'OPTION)     If too long
         BH    ERROR_OPT_TOO_LONG  then error
         MVI   OPTION,C' '         Clear option field to blanks
         MVC   OPTION+1(L'OPTION-1),OPTION
         LR    R14,R1              Address
         LR    R15,R2              Length
         BCTR  R15,0               Reduce length for execute
         LA    R1,OPTION           Point to place to move option name
         EX    R15,MVCWORD         Move option name to option area
         EX    R15,UPWORD          Translate to uppercase
*
* Time to process the options
*
         TM    FLAGS,FLAGPOSD      If currently processing positional
         BO    DOOPTP              then check positional options
         B     DOOPTK              else check keyword options
         SPACE 1
DOOPTP   DS    0H
         L     R1,LASTAREA         Point to current PP area
******** CLC   =C'OPTIONAL ',OPTION
******** BE    DOOPTP_OPTIONAL
         CLC   =C'ASIS ',OPTION
         BE    DOOPTP_ASIS
         CLC   =C'QUOTABLE ',OPTION
         BE    DOOPTP_CHAR
         B     ERROR_OPT_INVALID   All other options are bad, error
         SPACE 1
DOOPTP_OPTIONAL DS 0H
         OI    POSDFLGS-POSDDATA(R1),POSDOPT
         B     DOOPTRET
         SPACE 1
DOOPTP_ASIS     DS 0H
         OI    POSDFLGS-POSDDATA(R1),POSDASIS
         B     DOOPTRET
         SPACE 1
DOOPTP_CHAR     DS 0H
         OI    POSDFLGS-POSDDATA(R1),POSDCHAR
         B     DOOPTRET
         SPACE 1
DOOPTK   DS    0H
         L     R1,LASTAREA         Point to current KV area
         CLC   =C'ASIS ',OPTION
         BE    DOOPTK_ASIS
         CLC   =C'QUOTABLE ',OPTION
         BE    ERROR_OPT_POS_ONLY
         B     ERROR_OPT_INVALID   All other options are bad, error
         SPACE 1
DOOPTK_ASIS    DS 0H
         OI    KEYFLAGS-KEYDDATA(R1),KEYFASIS
         B     DOOPTRET
         SPACE 1
DOOPTRET DS    0H
         L     R14,DOOPT14
         BR    R14
         EJECT
SCAN     DS    0H
*
***********************************************************************
*                                                                     *
* This routine scans the command buffer for operands.  It returns the *
* address of the next operand in R1 and its length in R2 (when there  *
* are no more operands, R1 and R2 are zeroed).  The operand may be a  *
* name, a number, a parenthesis, or a quoted string. If it's a quoted *
* string, it will be returned as is, quotes and all.                  *
*                                                                     *
* Return is as follows:                                               *
*                                                                     *
* To return address + 0  ... no value found                           *
* To return address + 4  ... unquoted string found                    *
* To return address + 8  ... quoted string found                      *
* To return address + 12 ... left parenthesis found                   *
* To return address + 16 ... right parenthesis found                  *
*                                                                     *
* SCANPTR -> area to scan; SCANEPTR -> end thereof                    *
*                                                                     *
***********************************************************************
*
         L     R1,SCANPTR          Point to data to scan
         XR    R2,R2               Clear TRT register
         L     R3,SCANEPTR         Point to end of data to scan
         SR    R3,R1               Get length of data to scan
         LA    R0,256              Set up constant 256
         LTR   R3,R3               If length is zero
         BZ    SCANEND             then finished, return no value
SCANLOOP DS    0H                  Do TRT for remaining length
         CR    R3,R0               If length greater than 256
         BNH   SCANLEFF            then...
         TRT   0(256,R1),STBL0      scan for important characters
         BNZ   SCANGOT1             If we found something, process it
         AR    R1,R0                Else increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    SCANLOOP             Either continue scanning
         B     SCANEND              or exit (no value), length now zero
SCANLEFF DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,SCANTRT           Scan for important characters
         BNZ   SCANGOT1             If we found something, process it
******** B     SCANEND              If none found, exit in failure
SCANEND  DS    0H                  Reached end of data
         XR    R1,R1               Clear scanning registers
         XR    R2,R2
         BR    R14                 Return with no value
SCANGOT1 DS    0H                  R1 -> something we found
         L     R3,SCANEPTR
         SR    R3,R1               R3 := length remaining to scan
         B     *(R2)               R2 tells what kind it is
         B     GOTWORD             4:  Found nonblank
         B     GOTLP               8:  Found (
         B     GOTRP               12: Found )
         B     GOTSLASH            16: Found /
         B     GOTQUOTE            20: Found '
         SPACE 1
GOTWORD  DS    0H                  Found a nonblank (word)
*                                  R1 -> it, R3 = length to scan
*
* Scan for end-of-word
*
         LR    R15,R1              Save address of the word
GOTWORDL CR    R3,R0               If length greater than 256
         BNH   GOTWORDX            then...
         TRT   0(256,R1),STBLWORD   scan for important characters
         BNZ   GOTWORDT             If we found it, go. Else
         AR    R1,R0                Increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    GOTWORDL             Either continue scanning
         B     GOTWORDE             or go if length zero
GOTWORDX DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,GOTWTRT           Scan for important characters
         BNZ   GOTWORDT             If found something, go
         L     R1,SCANEPTR          Else end of text = end of word
         B     GOTWORDE
GOTWORDT L     R3,SCANEPTR         R3 := length remaining to scan
         SR    R3,R1               R1 -> character
         B     *(R2)               Branch depending on R2
         B     GOTWORDE            4:  Found whitespace, end of word
         B     GOTWLP              8:  Found (
         B     GOTWRP              12: Found )
         B     GOTWS               16: Found /
         SPACE 1
GOTWORDE DS    0H                  Found whitespace or end of word
         LR    R2,R1               Set length of word found
         SR    R2,R15
         ST    R1,SCANPTR          Set scan pointer for next scan
         LR    R1,R15              Set pointer to found item
         B     4(,R14)             Return to caller with unquoted word
GOTWLP   DS    0H                  Found "(" in word
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BZ    GOTWORDE            If was zero, not nested, end of word
         LA    R2,1(,R2)           Increment it
         ST    R2,PARCOUNT
         B     GOTWNEXT            Else process as constituent char
GOTWRP   DS    0H                  Found a right parenthesis ")"
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BZ    GOTWORDE            If was zero, not nested, end of word
         BCTR  R2,0                Decrement count
         ST    R2,PARCOUNT
         LTR   R2,R2
         BZ    GOTWORDE            If now zero, not nested, end of word
         B     GOTWNEXT            Else process as constituent char
GOTWS    DS    0H                  Found a slash "/"
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BNZ   GOTWNEXT            If inside (), treat as constituent
         B     GOTWORDE            Else treat as end of word
         SPACE 1
GOTWNEXT LA    R1,1(,R1)           Bump text pointer
         BCT   R3,GOTWORDL         Decrement count, scan if nonzero
         B     GOTWORDE            end of word
         SPACE 1
GOTLP    DS    0H                  Found a left parenthesis "("
*                                  R1 -> it, R3 = length to scan
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BNZ   GOTWORD             If count was nonzero, start of word
         LA    R2,1(,R2)           Increment it
         ST    R2,PARCOUNT
         LA    R2,1                Else set length to 1
         LA    R15,1(,R1)          Set pointer past it
         ST    R15,SCANPTR         Update scan pointer
         B     12(,R14)            Return single left parenthesis
         SPACE 1
GOTRP    DS    0H                  Found a right parenthesis ")"
*                                  R1 -> it, R3 = length to scan
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BZ    SCANRETP            If was zero, not nested, return ")"
         BCTR  R2,0                Decrement count
         ST    R2,PARCOUNT
         LTR   R2,R2
         BNZ   GOTWORD             If now nonzero, part of word
SCANRETP DS    0H                  Return the parenthesis
         LA    R2,1                Set length to 1
         LA    R15,1(,R1)          Set pointer past it
         ST    R15,SCANPTR         Update scan pointer
         B     16(,R14)            Return single right parenthesis
         SPACE 1
GOTQUOTE DS    0H                  Found a single quote "'"
*                                  R1 -> it, R3 = length to scan
         LR    R15,R1              Save address of the quoted string
         LA    R1,1(,R1)           Bump past initial quote
         BCT   R3,GOTQL            Decrement length to scan
         B     ERRQUOTE            If nothing left, error
GOTQL    CR    R3,R0               If length greater than 256
         BNH   GOTQX               then...
         TRT   0(256,R1),STBLQUOT   scan for "'"
         BNZ   GOTQT                If we found it, go. Else
         AR    R1,R0                Increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    GOTQL                Either continue scanning
         B     ERRQUOTE             or, if length zero, error
GOTQX    DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,GOTQTRT           Scan for "'"
         BNZ   GOTQT                If found something, go
         B     ERRQUOTE             Else error
GOTQT    DS    0H                  Reached "'"
         L     R3,SCANEPTR
         SR    R3,R1               R3 := length remaining to scan
         BNP   GOTQE               If zero, it's the ending quote
         CLI   1(R1),C''''         If not "''"
         BNE   GOTQE               then it's the ending quote
         LA    R1,2(,R1)           Else bump past "''"
         SH    R3,=H'2'            Decrement scan length
         BP    GOTQL               If something left, continue scan
         B     ERRQUOTE            Else error
GOTQE    DS    0H                  End of quoted string
         LA    R1,1(,R1)           Bump past final quote mark
         LR    R2,R1               Set length of string including "'"s
         SR    R2,R15
         ST    R1,SCANPTR          Set scan pointer for next scan
         LR    R1,R15              Set pointer to found item
         B     8(,R14)             Return quoted string to caller
         SPACE 1
GOTSLASH DS    0H                  Found a slash "/"
*                                  R1 -> it, R3 = length to scan
         CH    R3,=H'2'            If not enough room for "/*"
         BL    GOTSL               then treat as real slash
         CLI   1(R1),C'*'          If not "/*"
         BNE   GOTSL               then treat as real slash
         LA    R1,2(,R1)           Else start of comment: bump text ptr
         SH    R3,=H'2'            Decrement length to scan
         BNP   SCANEND             If nothing left, end of text
GOTCOMML CR    R3,R0               If length greater than 256
         BNH   GOTCOMMX            then...
         TRT   0(256,R1),STBLCOMM   scan for "*"
         BNZ   GOTCOMME             If we found it, go. Else
         AR    R1,R0                Increment text pointer by 256
         SR    R3,R0                Decrement length by 256
         BP    GOTCOMML             Either continue scanning
         B     SCANEND              or, if length zero, end of text
GOTCOMMX DS    0H                  Else...
         BCTR  R3,0                 Reduce length for execute
         EX    R3,GOTCTRT           Scan for "*"
         BNZ   GOTCOMME             If found something, go
         B     SCANEND              Else end of text
GOTCOMME DS    0H                   Reached an "*"
         L     R3,SCANEPTR
         SR    R3,R1               R3 := length remaining to scan
         CH    R3,=H'2'            If not enough room for "*/"
         BL    GOTCOMMC            then continue scanning for it
         CLI   1(R1),C'/'          If not "*/"
         BNE   GOTCOMMC            then continue scanning for it
         LA    R1,2(,R1)           Else bump past "*/"
         SH    R3,=H'2'            Decrement scan length
         BP    SCANLOOP            If something left, continue scan
         B     SCANEND             Else end of text
GOTCOMMC DS    0H                  "*" but no "/"
         LA    R1,1(,R1)           Bump past "*"
         BCT   R3,GOTCOMML         Decrement length, continue if nzero
         B     SCANEND             Else end of text
GOTSL    DS    0H                  Found a slash "/" without a "*"
         ICM   R2,15,PARCOUNT      Get parenthesis count
         BNZ   GOTWORD             If inside (), treat as constituent
RETSLASH DS    0H                  Else treat as single slash "/"
         LA    R2,1                Set length to 1
         LA    R15,1(,R1)          Set pointer past it
         ST    R15,SCANPTR         Update scan pointer
         B     20(,R14)            Return single slash
         SPACE 1
ERRQUOTE DS    0H                  Mismatched quotes
         XR    R2,R2               No accompanying data
         XR    R3,R3               " " "
         ERROR MSG_QUOTE_ERROR
         SPACE 1
SCANTRT  TRT   0(*-*,R1),STBL0      (Executed instruction)
GOTWTRT  TRT   0(*-*,R1),STBLWORD   (Executed instruction)
GOTCTRT  TRT   0(*-*,R1),STBLCOMM   (Executed instruction)
GOTQTRT  TRT   0(*-*,R1),STBLQUOT   (Executed instruction)
         SPACE 1
STBL0    DC    256YL1(4)           Table to scan for good stuff
         ORG   STBL0+C' '          Blank
         DC    YL1(0)              is whitespace
         ORG   STBL0+C','          Comma
         DC    YL1(0)              is whitespace
         ORG   STBL0+X'05'         Tab
         DC    YL1(0)              is whitespace
         ORG   STBL0+C'('          Left parenthesis
         DC    YL1(8)              is special
         ORG   STBL0+C')'          Right parenthesis
         DC    YL1(12)             is special
         ORG   STBL0+C'/'          Slash
         DC    YL1(16)             might be part of /*
         ORG   STBL0+C''''         Quote
         DC    YL1(20)             is special
         ORG   ,
         SPACE 1
STBLWORD DC    256YL1(0)           Table to scan for end of word
         ORG   STBLWORD+C' '       Blank
         DC    YL1(4)              is whitespace
         ORG   STBLWORD+C','       Comma
         DC    YL1(4)              is whitespace
         ORG   STBLWORD+X'05'      Tab
         DC    YL1(4)              is whitespace
         ORG   STBLWORD+C'('       Left parenthesis
         DC    YL1(8)              is special
         ORG   STBLWORD+C')'       Right parenthesis
         DC    YL1(12)             is special
         ORG   STBLWORD+C'/'       Slash
         DC    YL1(16)             might be part of /*
         ORG   ,
         SPACE 1
STBLCOMM DC    256YL1(0)           Table to scan for "*/"
         ORG   STBLCOMM+C'*'
         DC    1YL1(1)
         ORG   ,
         SPACE 1
STBLQUOT DC    256YL1(0)           Table to scan for "'"
         ORG   STBLQUOT+C''''
         DC    1YL1(1)
         ORG   ,
VERTBL   DC    256YL1(1)           Table to verify parameter syntax
         ORG   VERTBL+C'_'         Underscore is valid (?)
         DC    YL1(0)               valid?
         ORG   VERTBL+C'@'         National character is valid (?)
         DC    YL1(0)
         ORG   VERTBL+C'#'         National character is valid (?)
         DC    YL1(0)
         ORG   VERTBL+C'$'         National character is valid (?)
         DC    YL1(0)
         ORG   VERTBL+C'a'         Lower case alphabetics are valid
         DC    9YL1(0)
         ORG   VERTBL+C'j'
         DC    9YL1(0)
         ORG   VERTBL+C's'
         DC    8YL1(0)
         ORG   VERTBL+C'A'         Upper case alphabetics are valid
         DC    9YL1(0)
         ORG   VERTBL+C'J'
         DC    9YL1(0)
         ORG   VERTBL+C'S'
         DC    8YL1(0)
         ORG   VERTBL+C'0'         Numerics are valid (except 1st pos)
         DC    10YL1(0)
         ORG   ,
UPTBL    DC    256YL1(*-UPTBL)     Table to translate to uppercase
         ORG   UPTBL+C'a'
         DC    C'ABCDEFGHI'
         ORG   UPTBL+C'j'
         DC    C'JKLMNOPQR'
         ORG   UPTBL+C's'
         DC    C'STUVWXYZ'
         ORG   ,
         EJECT
PUTLINE  DS    0H
*
***********************************************************************
*                                                                     *
* This routine displays messages to the TSO user using the TSO        *
* PUTLINE service routine.  At entry R1 contains the address of the   *
* message to be displayed, and R0 contains the length of the message. *
* R3 points to additional data to be displayed, and R2 is its length. *
* If R1 is zero, the message has already been built in the workarea   *
* MSGWA.  The message is assumed to begin with a message ID unless    *
* the first character is blank, in which case the initial blank is    *
* stripped off by PUTLINE anyhow.                                     *
*                                                                     *
***********************************************************************
*
         ST    R14,PUTL14          Save return register
         LTR   R15,R0              Load length value
         BNP   PUTLRET             If zero, don't do anything
         BCTR  R15,0               Else reduce length for execute
         LTR   R1,R1               If R1 is zero,
         BZ    PUTIT               then message already set up.
         EX    R15,MVCPUT          Else move message to work area
         LTR   R2,R2               If additional data,
         BZ    PUTIT               then
         LA    R1,MSGWA+1(R15)      Point to end of message
         CH    R2,=H'256'           (Use max length of 256)
         BNH   *+8
         LA    R2,256
         BCTR  R2,0                 Reduce data length for execute
         EX    R2,MVCPUT2           Move additional data to work area
         LA    R15,1(R15,R2)        Add length of data to msg length
PUTIT    DS    0H
         LA    R15,5(,R15)         Restore length + 4 for header
         SLL   R15,16              Shift length into left half of hdr
         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr
PUTLINE_RETRY DS 0H
         XC    ECB,ECB             Clear ECB
         PUTLINE PARM=PTLIST,                                          X
               MF=(E,IOPL),                                            X
               OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15             If PUTLINE OK
         BZ    PUTLRET             then return
         CH    R15,=H'8'           Else if attention interrupt
         BE    PUTLRET             then OK
         CH    R15,=H'12'          Else if pending 2nd level message
         BE    PUTL12              then OK
PUTERROR DS    0H                  Else PUTLINE error
         CVD   R15,DOUBLE
         UNPK  DOUBLE(2),DOUBLE(8)
         OI    DOUBLE+1,X'F0'
         MVC   MSGWA+1(L'MSG_PUTLINE_FAILURE1),MSG_PUTLINE_FAILURE1
         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1(2),DOUBLE
         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1+2(L'MSG_PUTLINE_FAILURE2)X
               ,MSG_PUTLINE_FAILURE2
         TPUT  MSGWA+1,L'MSG_PUTLINE_FAILURE1+2+L'MSG_PUTLINE_FAILURE2
         LA    R1,MSGWA
         LH    R0,MSGHDR
         SH    R0,=H'4'
         TPUT  (1),(0),R           Try to display original message
PUTLRET  L     R14,PUTL14          Restore return register
         BR    R14                 Return
*
PUTL12   DS    0H                  Try putting out pending 2nd level ms
         XC    ECB,ECB             Clear ecb
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)
         B     PUTLINE_RETRY
*
MVCPUT   MVC   MSGWA(*-*),0(R1)    Executed
MVCPUT2  MVC   0(*-*,R1),0(R3)     Executed
         EJECT
MFLUSH   STACK MF=L,DELETE=ALL
LENFLUSH EQU   *-MFLUSH
*
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
*
         EJECT
         LTORG
         EJECT
***********************************************************************
* Messages                                                            *
***********************************************************************
         SPACE 1
MSG_NO_OPERANDS    DC C'XPROC001 No operands specified.'
MSG_REXX_REQUIRED  DC C'XPROC002 Not in REXX: input variable required.'
MSG_NO_POS_COUNT   DC C'XPROC003 Missing positional parameter count.'
MSG_BAD_POS_COUNT  DC C'XPROC004 Invalid positional parameter count: '
MSG_QUOTE_ERROR    DC C'XPROC005 Missing end quote.'
MSG_NO_WANT_LP     DC C'XPROC006 "(" found where not expected.'
MSG_NO_WANT_RP     DC C'XPROC007 ")" found where not expected.'
MSG_NO_WANT_QS     DC C'XPROC008 Quoted string in invalid position.'
MSG_TOO_FEW_PPARMS DC C'XPROC009 Fewer positional parms than expected.'
MSG_PP_WITH_LP     DC C'XPROC010 Value not allowed on positional: '
MSG_PARM_TOO_LONG  DC C'XPROC011 Parameter name too long (> 255): '
MSG_PARM_INVALID   DC C'XPROC012 Invalid syntax in parameter name: '
MSG_PARM_DUPLICATE DC C'XPROC013 Duplicate parameter name: '
MSG_EXTRANEOUS     DC C'XPROC014 Extraneous data ignored in value: '
MSG_VAR_TOO_LONG   DC C'XPROC015 Variable name too long (> 256): '
MSG_GETTING_VAR    DC C'XPROC016 Error accessing value of variable: '
MSG_PUTTING_VAR    DC C'XPROC017 Error storing value of variable: '
MSG_IKJCT441_RC    DC C'XPROC018 IKJCT441 return code is: '
MSG_PARSE_FAILURE  DC C'XPROC019 PARSE service routine failure, code: '
MSG_GETMAIN_FAIL   DC C'XPROC020 Not enough main storage to execute.'
MSG_IRXEXCOM_FAIL  DC C'XPROC021 IRXEXCOM failure, error code: '
MSG_STACK_ERROR    DC C'XPROC022 STACK service routine failure, code: '
MSG_NO_WANT_SL     DC C'XPROC023 "/" found where not expected.'
MSG_OPT_TOO_LONG   DC C'XPROC024 Option name too long: '
MSG_OPT_INVALID    DC C'XPROC025 Invalid option name: '
MSG_ASIS_NEEDS_VAL DC C'XPROC026 ASIS invalid with valueless keyword: '
MSG_OPT_POS_ONLY   DC C'XPROC027 Option valid only for positional: '
*
MSG_KV_ERROR       DC C'XPROC999 Internal error in keyword value scan.'
*
MSG_PUTLINE_FAILURE1 DC C'*** XPROC: PUTLINE error code '
MSG_PUTLINE_FAILURE2 DC C' trying to issue the following message:'
*
ISMSG    DC    C'*** XPROC ignoring slash after this parameter: ' dummy
         SPACE 1
         EJECT
***********************************************************************
* Constants                                                           *
***********************************************************************
         SPACE 1
KEYDINCR DC    A(100*KEYDDATL)     Initial & increment key area length
         SPACE 1
NUMTBL   DC    256YL1(1)           Table to validate numerics
         ORG   NUMTBL+C'0'
         DC    10YL1(0)
         ORG   ,
         EJECT
MSG_IKJCT441_RC08 DC C'XPROC508 Variable is a CLIST built-in function.'
MSG_IKJCT441_RC12 DC C'XPROC512 Variable is a CLIST label.'
MSG_IKJCT441_RC16 DC C'XPROC516 CLIST variable cannot be updated.'
MSG_IKJCT441_RC24 DC C'XPROC524 Variable is a CLIST subprocedure.'
MSG_IKJCT441_RC32 DC C'XPROC532 GETMAIN or FREEMAIN storage failure.'
MSG_IKJCT441_RC36 DC C'XPROC536 Variable name or value too long.'
MSG_IKJCT441_RC40 DC C'XPROC540 No valid CLIST or REXX environment.'
MSG_IKJCT441_RC76 DC C'XPROC576 Undefined &&SYSX CLIST variable.'
MSG_IKJCT441_RC80 DC C'XPROC580 Variable name invalid for REXX.'
MSG_IKJCT441_RC81 DC C'XPROC581 Internal REXX routine failure.'
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
         SPACE 1
SAVEAREA DS    18F                 OS save area
SAVE2    DS    18F                 Save area for PARSE exit routines
DOUBLE   DS    D                   Conversion work area
DATDLEN  DS    F                   Length of this work area
PUTL14   DS    F                   Return register save
E44114   DS    F                   Return register save
DOOPT14  DS    F                   Return register save
SAVER2   DS    A                   Save for TRT register
MYBASES  DS    2A                  Base regs for IKJPARS exit routines
SCANRES  DS    2A                  Used to save output from SCAN
WORDPTR  DS    A                   Address of next slot for word copy
PWADDR   DS    A                   Address of IKJPARS PCL area
PWLEN    DS    F                   Length of IKJPARS PCL area
PCLLEN   DS    F                   Actual length of the IKJPARS PCL
QOFF     DS    A                   Address of quoted-value-string area
QVALLEN  DS    F                   Length of quoted-value-string area
VUPADDR  DS    F                   Address of IKJCT441 update parm list
VUPLEN   DS    F                   Length of IKJCT441 update parm list
PDLLEN   DS    F                   Length of the IKJPARS PDL
VBUFADDR DS    A                   Address of fake command buffer
VBUFLEN  DS    A                   Length of fake command buffer
ARGADDR  DS    A                   Address of ARG buffer
ARGLEN   DS    F                   Length of ARG buffer
SCANPTR  DS    A                   Scanning pointer
SCANEPTR DS    A                   Scanning end pointer
PARCOUNT DS    F                   Parenthesis count
PVARADDR DS    A                   Address of input variable name
PVARLEN  DS    F                   Length of input variable name
POSCOUNT DS    F                   Positional parameter count
KEYCOUNT DS    F                   Keyword count
LASTAREA DS    A                   Address of last pos or key area
LASTADDR DS    A                   Address of last processed thing
LASTLEN  DS    F                   Length of last processed thing
APOSD    DS    A                   Address of positional parm area
LPOSD    DS    A                   Length of positional parm area
AKEYD    DS    A                   Address of keyword/value area
LKEYD    DS    A                   Length of keyword/value area
AKEYE    DS    A                   Address of end of keyword/value area
FIRSTKEY DS    A                   Address of first IKJKEYWD PCE
SUBTOSET DS    A                   Address of previous IKJSUBF PCE
FLAGS    DS    X                   Flags
FLAGPUTE EQU   B'10000000'         1 = error putting variable values
FLAGPOSD EQU   B'01000000'         1 = currently processing positionals
FLAGKEYD EQU   B'00100000'         1 = currently processing keywords
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
*
ECB      DS    F                   ECB for TSO routines
*
OLD      DS    0F                  PUTLINE output line descriptor
OLDF1    DS    F'1'                Number of message segments
OLDMSG   DS    A(*-*)              Address of the first message segment
*
MSGHDR   DS    F                   PUTLINE message header
MSGWA    DS    CL512               PUTLINE message work area
ARGWA    DS    CL512               ARG message work area
*
FLUSH    STACK MF=L,DELETE=ALL
*
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
*
CPPL     DS    0A
***********************************************************************
*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *
*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *
***********************************************************************
*
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
*
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
*
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
*
PPL      DS    0A
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
PPLVEWA  DS    A        PTR TO USER WORK AREA FOR VERIFY EXITS
*
ANSWER   DS    F                   ANSWER AREA FOR PARSE
         SPACE 1
CVPARMS  DS    0F                  Variable access facility parm list
CVPARM1  DS    A                   Parameter 1: entry code
CVPARM2  DS    A                   Parameter 2: address of var name
CVPARM3  DS    A                   Parameter 3: length of var name
CVPARM4  DS    A                   Parameter 4: address of var value
CVPARM5  DS    A                   Parameter 5: length of var value
CVPARM6  DS    A                   Parameter 6: token (not used)
CVPARM7  DS    A                   Parameter 7: ECT             #TSO172
*
CVENTRY  DS    A                   Entry code
CVNAMEA  DS    A                   Address of variable name
CVNAMEL  DS    A                   Length of variable name
CVVALUEA DS    A                   Address of variable value
CVVALUEL DS    A                   Length of variable value
CVTOKEN  DS    A                   Token (not used)
* CVECT  DS    A                   ECT (not used)               #TSO172
*
RC441    DS    F                   Return code from IKJCT441
         SPACE 1
         SPACE 1
IRPARMS  DS    0F                  IRXEXCOM parameter list
IRPARM1  DS    A                   Parameter 1: CL8'IRXEXCOM'
IRPARM2  DS    A                   Parameter 2: same as parameter 3
IRPARM3  DS    A                   Parameter 3: same as parameter 2
IRPARM4  DS    A                   Parameter 4: SHVBLOCK
*
***********************************************************************
*                                                                     *
* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *
*                                                                     *
***********************************************************************
*
SHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK
SHVNEXT  DS  A                        Chain pointer to next SHVBLOCK
SHVUSER  DS  F                        Used during "FETCH NEXT"
*                                      Contains length of buffer
*                                      pointed to by SHVNAMA
SHVCODES DS  0F
SHVCODE  DS  CL1                      Function code - indicates type
*                                      of variable access request
SHVRET   DS  XL1                      Return codes
         DS  H'0'                     Reserved (should be 0)
SHVBUFL  DS  F                        Length of fetch value buffer
SHVNAMA  DS  A                        Address of variable name
SHVNAML  DS  F                        Length of variable name
SHVVALA  DS  A                        Address of value buffer
SHVVALL  DS  F                        Length of value buffer
*                                      (Set on fetch)
SHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK
         SPACE 1
**********************************************************************/
*   SHARED VARIABLE REQUEST BLOCK - function codes                   */
**********************************************************************/
         SPACE 1
SHVFETCH EQU   C'F'            Copy value of shared variable
SHVSTORE EQU   C'S'            Set variable from given value
SHVDROPV EQU   C'D'            Drop variable
SHVSYFET EQU   C'f'            Symbolic name retrieve
SHVSYSET EQU   C's'            Symbolic name set
SHVSYDRO EQU   C'd'            Symbolic name drop
SHVNEXTV EQU   C'N'            Fetch "next" variable
SHVPRIV  EQU   C'P'            Fetch private information
         SPACE 1
**********************************************************************/
*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */
**********************************************************************/
        SPACE 1
SHVCLEAN EQU   X'00'           Execution was OK
SHVNEWV  EQU   X'01'           Variable did not exist
SHVLVAR  EQU   X'02'           Last variable transferred ("N")
SHVTRUNC EQU   X'04'           Truncation occurred for "Fetch"
SHVBADN  EQU   X'08'           Invalid variable name
SHVBADV  EQU   X'10'           Invalid value specified
SHVBADF  EQU   X'80'           Invalid function code (SHVCODE)
         SPACE 1
**********************************************************************/
*        R15 return codes                                            */
**********************************************************************/
         SPACE 1
SHVRCOK  EQU    0              Entire Plist chain processed
SHVRCINV EQU   -1              Invalid entry conditions
SHVRCIST EQU   -2              Insufficient storage available
         SPACE
*
PVAR     DS    CL256               Area to build input variable name
OPTION   DS    CL16                Area to build option name
         SPACE 1
SIZDATD  EQU   *-DATD              Length of fixed part of work area
         SPACE 1
WORDCOPY EQU   *                   Area to put copies of keyword names
         EJECT
POSDDATA DSECT ,                   Info on positional parameter specs
         SPACE 1
*                                  (POSCOUNT) occurrences of...
*
POSDADDR DS    A                   Address of positional parameter name
POSDLEN  DS    A                   Length of positional parameter name
POSDPCEA DS    A                   Address of PCE for this parameter
POSDPCEL DS    A                   Length of PCE for this parameter
POSDMAXL DS    A                   Maximum length for prompting message
POSDFLGS DS    X                   Flags
POSDOPT  EQU   B'10000000'          1 = parameter is optional
POSDCHAR EQU   B'01000000'          1 = value is possibly-quoted string
POSDASIS EQU   B'00100000'          1 = value is to be processed asis
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
         DS    0D                  Round to doubleword length
         SPACE 1
POSDDATL EQU   *-POSDDATA          Length of an occurrence
         EJECT
KEYDDATA DSECT ,                   Info on keyword/value specs
         SPACE 1
*                                  some # of occurrences of...
*
KEYWORDA DS    A                   Address of keyword
KEYWORDL DS    A                   Length of keyword
KEYDVALA DS    A                   Address of keyword's default value
KEYDVALL DS    A                   Length of keyword's default value
KEYDPCEA DS    A                   Address of PCE for this parameter
KEYDPCEL DS    A                   Length of PCE for this parameter
KEYDMAXL DS    A                   Maximum length for prompting message
KEYSUBOF DS    A                   Where to store subfield offset
KEYFLAGS DS    X                   Flags
KEYFDVAL EQU   B'10000000'          1 = a default value was specified
KEYFQUOT EQU   B'01000000'          1 = default value is quoted string
KEYFASIS EQU   B'00100000'          1 = value is to be processed asis
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
         DS    0D                  Round to doubleword length
         SPACE 1
KEYDDATL EQU   *-KEYDDATA          Length of an occurrence
         EJECT
***********************************************************************
* Macro expansions                                                    *
***********************************************************************
         SPACE 1
         IKJTSVT
         SPACE 1                                                #TSO162
         IKJECT ,                                               #TSO162
         SPACE 1
         CVT   DSECT=YES
         END
./ ADD NAME=XPUT     0100-07332-07332-0900-00052-00052-00000-SEB
XPUT     CSECT
*
* DCL XPUT EXTERNAL ENTRY(CHAR(*) VAR) OPTIONS(ASM INTER);
*
         SAVE  (14,12),,XPUT_&SYSDATE._&SYSTIME
         LR    12,15
         USING XPUT,12
         L     1,0(,1)             POINT TO PARM STRING
         LH    0,0(,1)             GET LENGTH OF STRING
         LA    1,2(,1)             GET ADDRESS OF STRING
         LTR   0,0                 IF LENGTH IS ZERO
         BZ    AFTTPUT             THEN DO NOTHING
         CLI   0(1),X'27'          IF FIRST CHAR IS ESCAPE CHARACTER
         BNE   TPUTEDIT            THEN
         TPUT  (1),(0),FULLSCR      DO TPUT FULLSCR WITHOUT TRANSLATING
         B     AFTTPUT             ELSE
TPUTEDIT LR    15,0                GET LENGTH OF PARM STRING
         LR    4,1                 POINT TO STRING
         LA    3,256
CHECKTR  LTR   15,15               IF LENGTH ZERO
         BZ    AFTTR               THEN PUT IT OUT
         CR    15,3                IF LENGTH GREATER THAN 256
         BNH   LASTTR              THEN
         TR    0(256,4),TABLE      TRANSLATE INVALID CHARACTERS
         AR    4,3                 BUMP STRING POINTER
         SR    15,3                DECREMENT LENGTH
         B     CHECKTR             CONTINUE
LASTTR   BCTR  15,0                REDUCE FOR EXECUTE
         EX    15,TR               TRANSLATE TO PRINTABLE
AFTTR    DS    0H                  GET LENGTH OF STRING
         TPUT  (1),(0),R            DO TPUT EDIT
AFTTPUT  L     14,12(,13)          RETURN WITH RC FROM TPUT
         LM    0,12,20(13)
         BR    14
TR       TR    0(0,4),TABLE
TABLE    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'.ABCDEFGHI......'
         DC    C'.JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         END
./ ADD NAME=XQSCAN   0100-07332-07332-0900-00704-00704-00000-SEB
         TITLE 'XQSCAN - DISPLAY ENQ DATA'
***********************************************************************
* THIS PROGRAM IS *** NOT *** REENTRANT.  TOO BAD.                    *
***********************************************************************
***********************************************************************
* INFORMATION ON THE GQSCAN MACRO INSTRUCTION MAY BE FOUND IN:        *
*      OS/VS2 SYSTEM PROGRAMMING LIBRARY: SUPERVISOR                  *
*                     GC28-1046-0                                     *
*             FIRST EDITION (DECEMBER, 1980)                          *
*                  WITH TNL GN28-4917                                 *
***********************************************************************
         TITLE 'XQSCAN - INSTREAM MACROS'
         MACRO
&LABEL   WTT   &TEXT
         LCLC  &LAPOST,&LBLA,&LBLB
&LAPOST  SETC  'L'''
&LBLA    SETC  'WTT&SYSNDX.A'
&LBLB    SETC  'WTT&SYSNDX.B'
         CNOP  0,4
&LABEL   BAL   1,&LBLB
&LBLA    DC    C&TEXT
&LBLB    DS    0H
         LA    1,0(,1)
         LA    0,&LAPOST.&LBLA
         BAL   14,PUTLINE
         MEND
         TITLE 'XQSCAN - SET UP FOR HASP MACROS'
         COPY  $HASPGBL
         $HASPEQU
         TITLE 'XQSCAN - DISPLAY ENQ DATA'
* PARM VALUE IS ONE CHARACTER AS FOLLOWS:
*    C - DISPLAY ALL CONFLICTS
*    R - DISPLAY ALL RESERVES
*    ALL - DISPLAY EVERYTHING IN THE SYSTEM
*    J=... DISPLAY FOR SPECIFIED JOBNAME
*    ANYTHING ELSE - DISPLAY FOR SPECIFIED MAJOR NAME (QNAME)
*    NULL - PROGRAM PROMPTS FOR MAJOR AND MINOR ENQ NAMES
         EJECT
XQSCAN   CSECT
         SAVE  (14,12),,XQSCAN_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XQSCAN,R12
         LA    R15,SAVEAREA
         ST    R13,4(,R15)
         ST    R15,8(,R13)
         LR    R13,R15
         USING SAVEAREA,R13
         EJECT
         L     R15,X'21C'          TCB
         L     R15,X'B4'(,R15)     JSCB
         L     R15,X'15C'(,R15)    Active JSCB
         L     R15,X'108'(,R15)    PSCB
         L     R15,X'30'(,R15)     UPT
         ST    R15,IOPLUPT
         L     R15,X'224'          ASCB
         L     R15,X'6C'(,R15)     ASXB
         L     R15,X'14'(,R15)     LWA
         L     R15,X'20'(,R15)     LWA
         ST    R15,IOPLECT
         LA    R15,ECB
         ST    R15,IOPLECB
         L     R1,0(,R1)           GET PARM VALUE
         LH    R3,0(,R1)           GET LENGTH OF PARMS
         LA    R9,2(,R1)           POINT TO BEGINNING OF PARMS
         LTR   R3,R3               IF NO PARM SPECIFIED
         BZ    NOPARMS             THEN NO PARM
PROCPRMS OI    0(R9),C' '          SHIFT TO UPPER CASE
         CLI   0(R9),C'R'          IF PARM IS 'R'
         BNE   NOTRES               AND
         CH    R3,=H'1'              PARM LENGTH IS 1
         BNE   NOTRES                 THEN
         OI    FLAGSA,FLAGRYES         DISPLAY RESERVE DATA ONLY
         B     AFTPARMS            ELSE
NOTRES   DS    0H
         CLI   0(R9),C'C'          IF PARM IS 'C'
         BNE   NOCONF               AND
         CH    R3,=H'1'              PARM LENGTH IS 1
         BNE   NOCONF                 THEN CONFLICTS ONLY WAS REQUESTED
         MVC   WAITCNT,=F'1'        SET WAITCNT = 1
         OI    FLAGSB,FLAGWAIT      INDICATE WAIT COUNT SPECIFIED
         B     AFTPARMS            ELSE
NOCONF   DS    0H
         CH    R3,=H'3'            IF PARM LENGTH = 3
         BNE   NOTALL               AND
         CLC   0(3,R9),=C'ALL'       PARM IS 'ALL'
         BE    AFTPARMS               THEN DISPLAY EVERYTHING
NOTALL   DS    0H
         CH    R3,=H'2'            IF PARM LENGTH >= 2
         BL    NOTJEQ               AND
         CLC   0(2,R9),=C'J='        PARM STARTS WITH J=
         BNE   NOTJEQ                 THEN
         SH    R3,=H'2'                GET REMAINING PARM (JOBNAME) LEN
         BNP   GETJOBN                 IF ZERO, PROMPT FOR JOBNAME
         CH    R3,=H'8'                IF JOBNAME LENGTH GT 8
         BH    JERROR                  THEN ERROR
         MVC   JOBNAME,BLANKS          ELSE CLEAR JOBNAME TO BLANKS
         BCTR  R3,0                    PREPARE TO EXECUTE...
         EX    R3,MVJOBNM              MOVE PARM INTO JOBNAME
         B     TESTJOBN                GO TO PROCESS JOBNAME
NOTJEQ   DS    0H                  ELSE ANYTHING ELSE, ASSUME QNAME
         CH    R3,=H'8'            IF QNAME LENGTH GT 8
         BH    QERROR              THEN ERROR
         MVC   MAJOR,BLANKS        ELSE CLEAR QNAME TO BLANKS
         BCTR  R3,0                PREPARE TO EXECUTE...
         EX    R3,MVQNAME          MOVE PARM INTO QNAME
         LA    R0,MAJOR            PLACE ADDRESS OF QNAME
         ST    R0,QNAME            IN PARAMETER LIST
         B     AFTPARMS            GO PROCESS QNAME BY ITSELF
         SPACE
MVJOBNM  OC    JOBNAME(0),2(R9)    MOVE PARM FIELD TO JOBNAME
MVQNAME  OC    MAJOR(0),0(R9)      MOVE PARM FIELD TO QNAME
         SPACE
NOPARMS  DS    0H                  NO PARMS SPECIFIED...
* IF NO PARMS ENTERED, PROMPT THE USER FOR VARIOUS INFO...
GETQNAME WTT   'XQSCAN: ENTER MAJOR NAME (QNAME) OR PRESS ENTER:'
         TCLEARQ INPUT             PURGE TERMINAL INPUT
         TGET  MAJOR,8             GET QNAME
         CH    R15,=H'12'          IF TOO MUCH DATA ENTERED
         BNE   MAJNOT12            THEN
QERROR   WTT   'XQSCAN: QNAME EXCEEDS 8 CHARACTERS'
         B     GETQNAME             PROMPT AGAIN
MAJNOT12 LTR   R1,R1               IF USER ENTERED NOTHING
         BZ    NORNAME             THEN GO ASK FOR JOBNAME. ELSE...
         OC    MAJOR,BLANKS         TRANSLATE TO UPPERCASE
         LA    R0,MAJOR             PLACE ADDRESS OF QNAME
         ST    R0,QNAME             IN PARAMETER LIST
NOQNAME  DS    0H
GETRNAME WTT   'XQSCAN: ENTER MINOR NAME (RNAME) OR PRESS ENTER:'
         TCLEARQ INPUT             PURGE TERMINAL INPUT
         TGET  MINOR,255           GET RNAME
         CH    R15,=H'12'          IF TOO MUCH DATA ENTERED
         BNE   MINNOT12            THEN
RERROR   WTT   'XQSCAN: RNAME EXCEEDS 255 CHARACTERS'
         B     GETRNAME             PROMPT AGAIN
MINNOT12 LTR   R1,R1               IF USER ENTERED NOTHING
         BZ    NOJOBN              THEN ASK FOR NOTHING ELSE. ELSE...
         OC    MINOR,BLANKS         TRANSLATE TO UPPERCASE
         LA    R0,MINOR             PLACE ADDRESS OF RNAME
         ST    R0,RNAME             IN PARAMETER LIST
         STC   R1,RNMLEN            PUT LENGTH OF NAME IN PARM LIST
         B     NOJOBN               CONTINUE (CAN ASK FOR NOTHING ELSE)
NORNAME  DS    0H
GETJOBN  WTT   'XQSCAN: ENTER JOBNAME OR PRESS ENTER:'
         TCLEARQ INPUT             PURGE TERMINAL INPUT
         TGET  JOBNAME,8           GET JOB NAME
         CH    R15,=H'12'          IF TOO MUCH DATA ENTERED
         BNE   GOTJOBN             THEN
JERROR   WTT   'XQSCAN: JOBNAME EXCEEDS 8 CHARACTERS'
         B     GETJOBN              PROMPT AGAIN
GOTJOBN  LTR   R1,R1               IF USER ENTERED NOTHING
         BZ    NOJOBN              THEN DO NOTHING. ELSE...
         OC    JOBNAME,BLANKS      SHIFT TO UPPER CASE
TESTJOBN DS    0H                  RETRIEVE ASID OF JOBNAME
         CLC   JOBNAME,=CL8'*MASTER*' IF MASTER SCHEDULER REQUESTED
         BNE   NOTMSTR             THEN
         LA    R0,1                 SET ASID = 01
         B     MOVEASID            ELSE
NOTMSTR  DS    0H                   NOT MASTER SCHEDULER
         L     R1,X'10'             GET ADDRESS OF CVT
         L     R1,X'22C'(,R1)       GET ADDRESS OF ASVT
         L     R15,X'204'(,R1)      GET MAX # OF ADDRESS SPACES
         BCTR  R15,0                SUBTRACT 1 TO POINT TO LAST ONE
         SLA   R15,2                MULTIPLY BY FOUR
         LA    R1,X'210'(,R1)       POINT TO FIRST ASVT ENTRY
         ALR   R15,R1               GET ADDRESS OF LAST ASVT ENTRY
         LA    R14,4
ASVTLOOP TM    0(R1),X'80'          IF ASVT ENTRY IS AVAILABLE
         BO    ASVTCONT             THEN NOT THIS ONE, CONTINUE
         L     R2,0(,R1)            ELSE GET ADDRESS OF ITS ASCB
         L     R2,X'38'(,R2)        GET ADDRESS OF ITS CSCB
         CLC   8(8,R2),JOBNAME      IF JOBNAME MATCHES
         BNE   ASVTCONT             THEN (WE FOUND IT) ...
         LH    R0,X'1E'(,R2)        GET ASID FROM CSCB
         B     MOVEASID             ELSE
ASVTCONT BXLE  R1,R14,ASVTLOOP      CONTINUE UNTIL FOUND OR NONE LEFT
*
* IF JOB NOT FOUND VIA ASVT SCAN, TRY JES CONTROL BLOCK SCAN.
*
         L     R1,X'10'            GET ADDRESS OF CVT
         USING CVTMAP,R1           ESTABLISH ADDRESSABILITY TO CVT
         L     R1,CVTJESCT         GET ADDRESS OF JES CONTROL TABLE
         USING JESCT,R1            ESTABLISH ADDRESSABILITY TO JSECT
         L     R1,JESSSCT          GET ADDRESS OF SUBSYSTEM CONTROL TBL
         USING SSCT,R1             ESTABLISH ADDRESSABILITY TO SSCT
*        L     R1,SSCTSSVT         GET ADDRESS OF SUBSYSTEM VECTOR TBL
*        USING SSVT,R1             ESTABLISH ADDRESSABILITY TO SSVT
* following due to JES2 3.1.3...
         L     R1,SSCTSUS2         Get address of JES2 HCCT
         USING HCCT,R1             ESTABLISH ADDRESSABILITY TO HCCT
         ICM   R1,15,CCTJXCLS      GET ADDRESS OF SUBSYSTEM JOB BLOCK
         BZ    JNOTFOUN            IF ZERO, JOB NOT FOUND. ELSE...
SJBLOOP  DS    0H                  CHAIN THROUGH SJB'S
         USING SJB,R1              ESTABLISH ADDRESSABILITY TO SJB
         CLC   SJBJOBNM,JOBNAME    IF JOBNAME MATCHES,
         BNE   NEXTSJB             THEN (WE FOUND IT)...
         LH    R0,SJBASID           GET ASID FROM SJB
         B     MOVEASID             AND STORE IT. ELSE...
NEXTSJB  ICM   R1,15,SJBXQCHN      GET NEXT SJB IN CHAIN
         BNZ   SJBLOOP             IF THERE IS ONE, CONTINUE. ELSE...
JNOTFOUN DS    0H
         WTT   'XQSCAN: JOBNAME NOT FOUND'
         B     GETJOBN
MOVEASID DS    0H
         ST    R0,ASID             PUT ASID INTO PARAMETER LIST
         MVC   SYSNAME,CSDL        SYSNAME REQUIRED FOR ASID
         LA    R0,SYSNAME
         ST    R0,SYSNM            PUT ADDRESS IN PARAMETER LIST
         OI    FLAGSB,FLAGSYSN     INDICATE SYSNAME SPECIFIED
NOJOBN   DS    0H
         SPACE
AFTPARMS DS    0H                  ALL PARMS HAVE BEEN HANDLED
         L     R0,INCR             GET FIRST LENGTH OF AREA
         ST    R0,AREALEN          SAVE IT
         GETMAIN R,LV=(0)          GET IT
         ST    R1,AREAPTR          SAVE ADDRESS OF AREA
         SPACE
RETRY    DS    0H
         L     R1,AREAPTR          GET ADDRESS OF CURRENT AREA
         EJECT
***********************************************************************
         SPACE
         GQSCAN MF=(E,QSPARMS)     SCAN ENQ INFO
         SPACE
***********************************************************************
         EJECT
AFTQCSAN DS    0H
         STM   R0,R1,GQREGS        SAVE RETURN PARAMETER REGISTERS
         LR    R10,R1              GET NUMBER OF RIBS RETURNED
         LTR   R2,R15              TEST RETURN CODE FROM GQSCAN
         BZ    DISPLAY             IF ZERO, GO SHOW USER
         CH    R2,=H'4'            IF RC=4 (NO DATA)
         BNE   TRY8                THEN
         WTT   'XQSCAN: FOUND NO ENQ/RESERVE DATA FOR REQUEST.'
         B     RETURN
         SPACE
TRY8     CH    R2,=H'8'            IF RC=8 (TOO MUCH DATA)
         BNE   TRY12               THEN
         L     R0,AREALEN           GET CURRENT AREA LENGTH
         L     R1,AREAPTR           GET CURRENT AREA ADDRESS
         FREEMAIN R,LV=(0),A=(1)    FREE EXISTING AREA
         L     R0,INCR              GET AREA LENGTH INCREMENT
         AL    R0,AREALEN           INCREASE THE LENGTH
         ST    R0,AREALEN           SAVE IT
         GETMAIN RC,LV=(0)          TRY TO GET IT
         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA IF ANY
         LTR   R15,R15              IF COULD NOT GET IT
         BZ    RETRY                THEN
         L     R0,AREALEN           GET LENGTH
         S     R0,INCR              GO BACK TO PREVIOUS LENGTH
         GETMAIN R,LV=(0)           GET IT (WE KNOW THAT WE CAN)
         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA
         WTT   'XQSCAN: COULD NOT GET STORAGE TO DISPLAY ALL DATA'
         B     RETRY                AND TRY AGAIN.
         SPACE
TRY12    CH    R2,=H'12'
         BNE   TRY16
         WTT   'XQSCAN: FAILED, GQSCAN ERROR CODE 12'
         B     RETURN
TRY16    CH    R2,=H'16'
         BNE   NOT16
         WTT   'XQSCAN: FAILED, GQSCAN ERROR CODE 16'
         B     RETURN
NOT16    DS    0H
         WTT   'XQSCAN: UNEXPECTED ERROR CODE = ABEND CODE'
         ABEND (R2),DUMP
         EJECT
DISPLAY  DS    0H                  OK - NOW DISPLAY INFO
         SPACE
         L     R3,AREAPTR          START OF Q INFO
         USING RIB,R3              ADDRESS THE BASIC FIXED RIB
CONTINUE DS    0H
         LH    R8,LRIBFIX          LENGTH OF FIXED RIB
         ALR   R8,R3                PLUS ADDRESS OF FIXED RIB
         USING RIBVAR,R8            GIVES VARIABLE SECTION OF RIB
* SHOULD WE DISPLAY THIS ONE?
         XR    R0,R0               CLEAR INSERT REGISTER
         IC    R0,RIBSCOPE         GET SCOPE VALUE
         SRL   R0,4
         SLL   R0,4                EXTRACT LEFT NIBBLE ONLY
         STC   R0,SCOPEBIT         STORE IT
         CLI   SCOPEBIT,RIBSYS     IF SCOPE = SYSTEM
         BNE   NOTSYS              THEN
         MVC   SCOPE,=CL7'SYSTEM'   SAY SO
         B     AFTSCOPE            ELSE
NOTSYS   CLI   SCOPEBIT,RIBSYSS    IF SCOPE = SYSTEMS
         BNE   NOTSYSS             THEN
         MVC   SCOPE,=CL7'SYSTEMS'  SAY SO
         B     AFTSCOPE            ELSE
NOTSYSS  CLI   SCOPEBIT,RIBSTEP    IF SCOPE = STEP
         BNE   NOTSTEP             THEN
         MVC   SCOPE,=CL7'STEP'     SAY SO
         B     AFTSCOPE            ELSE
NOTSTEP  CLI   SCOPEBIT,RIBGLBL    IF SCOPE = GLOBAL
         BNE   NOTGLBL             THEN
         MVC   SCOPE,=CL7'GLOBAL'   SAY SO
         B     AFTSCOPE            ELSE
NOTGLBL  CLI   SCOPEBIT,0          IF SCOPE = LOCAL
         BNE   NOTZERO             THEN
         MVC   SCOPE,=CL7'LOCAL'    SAY SO
         B     AFTSCOPE            ELSE
NOTZERO  MVC   SCOPE,=CL7'???????'  I DON'T KNOW WHAT IT IS
AFTSCOPE DS    0H
***
         AGO   .NOHMTSK            BYPASS EXTRA DISPLAYS
***
         WTT   ' '                 DISPLAY A BLANK LINE
         MVC   TPUTAREA+00(007),=C'QNAME: '
         MVC   TPUTAREA+07(008),RIBQNAME
         LA    R1,TPUTAREA
         LA    R0,7+8
         BAL   R14,PUTLINE         DISPLAY QNAME
         XR    R9,R9               CLEAR INSERT REGISTER
         ICM   R9,1,RIBRNMLN       GET LENGTH OF RNAME
         BZ    NODISMIN            IF THERE IS ONE (NONZERO), THEN
         MVC   TPUTAREA+00(007),=C'RNAME: '
         BCTR  R9,0
         EX    R9,MVCRNAME
         EX    R9,TRNAME
         LA    R1,TPUTAREA
         LA    R0,8(,R9)
         BAL   R14,PUTLINE         DISPLAY RNAME
         CH    R9,=H'7'            IF LENGTH OF RNAME BETWEEN 1 & 8
         BH    NODISMIN            AND
         EX    R9,TRTNAME           INVALID CHARACTERS PRESENT
         BZ    NODISMIN            THEN
         XC    HEXNAME(8),HEXNAME
         EX    R9,MVCNAME
         LA    R9,1(,R9)
         MVC   TPUTAREA+00(015),=C'      (HEX:  X'''
         MVC   TPUTAREA+15(007),HEXNAME
         UNPK  TPUTAREA+15(015),TPUTAREA+15(08)
         TR    TPUTAREA+15(014),XXXTBL
         MVC   TPUTAREA+29(002),=C''')'
         LA    R1,TPUTAREA
         LA    R0,31
         BAL   R14,PUTLINE         DISPLAY RNAME IN HEX
         B     NODISMIN            BRANCH AROUND EXECUTED INSTRUCTIONS
         SPACE
MVCRNAME MVC   TPUTAREA+07(000),RIBRNAME
TRNAME   TR    TPUTAREA+07(000),DISPTBL
TRTNAME  TRT   RIBRNAME(0),TRTABLE
MVCNAME  MVC   HEXNAME(0),RIBRNAME
         SPACE 2
NODISMIN DS    0H
         MVC   TPUTAREA+00(007),=C'SCOPE: '
         MVC   TPUTAREA+07(007),SCOPE
         LA    R1,TPUTAREA
         LA    R0,14
         BAL   R14,PUTLINE         DISPLAY SCOPE
***
         AGO   .NOHMTSK            DON'T DISPLAY HOW MANY TASKS OWN
***
         MVC   TPUTAREA+00(002),BLANKS
         L     R0,RIBNTO
         CVD   R0,DOUBLE
         MVC   TPUTAREA+02(012),=X'F02020202020202020202020'
         LA    R1,TPUTAREA+02+11
         EDMK  TPUTAREA+02(012),DOUBLE+2
         BNM   *+10
         BCTR  R1,0
         MVI   0(R1),C'-'
         MVC   TPUTAREA+02(012),0(R1)
         LA    R15,TPUTAREA+02+11
         SR    R15,R1
         LA    R1,TPUTAREA+02+1(R15)
         CLC   RIBNTO,=F'1'
         BNE   MORETHN1
         MVC   0(10,R1),=C' TASK OWNS'
         B     AFTTHN1
MORETHN1 MVC   0(109,R1),=C' TASKS OWN'
AFTTHN1  MVC   10(14,1),=C' THIS RESOURCE'
         LA    R0,24(,R1)
         LA    R1,TPUTAREA
         SLR   R0,R1
         BAL   R14,PUTLINE
***
.NOHMTSK ANOP  ,                   DON'T DISPLAY HOW MANY TASKS OWN
***
         EJECT
         ICM   R0,15,RIBNTWE       # OF TASK WAITING FOR EXCLUSIVE
         BZ    NOWE                IF NONE, BYPASS
         MVC   TPUTAREA+00(031),=C' TASKS WAITING FOR ACCESS=OLD: '
         CVD   R0,DOUBLE           CONVERT # OF TASKS TO DECIMAL
         LA    R1,TPUTAREA+31+11
         MVC   TPUTAREA+31(012),=X'F02020202020202020202020'
         EDMK  TPUTAREA+31(012),DOUBLE+2
         BNM   *+10
         BCTR  R1,0
         MVI   0(R1),C'-'
         MVC   TPUTAREA+31(012),0(R1)
         LA    R15,TPUTAREA+31+11
         SR    R15,R1
         LA    R0,TPUTAREA+31+1(R15)
         LA    R1,TPUTAREA
         SLR   R0,R1
         BAL   R14,PUTLINE
NOWE     DS    0H
         SPACE
         ICM   R0,15,RIBNTWS       # OF TASK WAITING FOR SHARED
         BZ    NOWS                IF NONE, BYPASS
         MVC   TPUTAREA+00(031),=C' TASKS WAITING FOR ACCESS=SHR: '
         CVD   R0,DOUBLE           CONVERT # OF TASKS TO DECIMAL
         LA    R1,TPUTAREA+31+11
         MVC   TPUTAREA+31(012),=X'F02020202020202020202020'
         EDMK  TPUTAREA+31(012),DOUBLE+2
         BNM   *+10
         BCTR  R1,0
         MVI   0(R1),C'-'
         MVC   TPUTAREA+31(012),0(R1)
         LA    R15,TPUTAREA+31+11
         SR    R15,R1
         LA    R0,TPUTAREA+31+1(R15)
         LA    R1,TPUTAREA
         SLR   R0,R1
         BAL   R14,PUTLINE
         SPACE
NOWS     DS    0H
         ICM   R7,15,RIBNRIBE      GET NUMBER OF EXTENTS RETURNED
         BZ    NOEXTS              IF NONE, BYPASS
         LR    R6,R8               BUMP PAST VARIABLE PART OF RIB
         AH    R6,RIBVLEN          BUMP PAST VARIABLE PART OF RIB
         USING RIBE,R6             RIB EXTENT
EXTLOOP  DS    0H
         SPACE 2
         TM    RIBERFLG,RIBETYPE   IF ACCESS IS EXCLUSIVE
         BO    SHARED              THEN
         MVC   TYPE,=CL3'OLD'       SAY SO
         B     AFTTYPE             ELSE
SHARED   MVC   TYPE,=CL3'SHR'       SAY SHARED
AFTTYPE  DS    0H
         TM    RIBERFLG,RIBERESV
         BO    ISRESV
         MVI   WHATISIT,C' '
         B     AFTRESV
ISRESV   MVI   WHATISIT,C'R'
AFTRESV  DS    0H
         TM    RIBESFLG,RIBESTAT   1 = OWNS IT, 0 = WAITING FOR IT
         BO    STATOWN
         MVI   STAT,C'W'
         B     AFTSTAT
STATOWN  MVI   STAT,C' '
AFTSTAT  DS    0H
         MVC   TPUTAREA+00(255),BLANKS
         MVC   TPUTAREA+00(001),STAT       WAIT OR OWN
         MVC   TPUTAREA+02(001),RIBEASID+1 ASID
         UNPK  TPUTAREA+02(003),TPUTAREA+02(02)
         TR    TPUTAREA+02(002),XXXTBL
         MVI   TPUTAREA+04,C' '
         MVC   TPUTAREA+05(007),SCOPE      STEP, SYSTEM, SYSTEMS
         MVC   TPUTAREA+13(003),TYPE       OLD OR SHR
         MVC   TPUTAREA+17(001),WHATISIT   ENQUEUE OR RESERVE
         MVC   TPUTAREA+19(008),RIBEJBNM   JOBNAME
         TR    TPUTAREA+19(008),DISPTBL
         MVC   TPUTAREA+28(008),RIBQNAME   MAJOR NAME
         TR    TPUTAREA+28(008),DISPTBL
         XR    R15,R15
         ICM   R15,1,RIBRNMLN
         BZ    NODRNAME
         BCTR  R15,0
         EX    R15,DRNAME
         EX    R15,DRTR
         B     NODRNAME
DRNAME   MVC   TPUTAREA+37(000),RIBRNAME   MINOR NAME
DRTR     TR    TPUTAREA+37(000),DISPTBL
NODRNAME DS    0H
         LA    R0,TPUTAREA+37+1(R15)
         LA    R1,TPUTAREA
         SLR   R0,R1
         BAL   R14,PUTLINE
         CLC   RIBESYSN,NONAME
         BE    NOSYS
         CLC   RIBESYSN,CSDL
         BE    NOSYS
         MVC   TPUTAREA+00(015),=C'    SYSTEM:    '
         MVC   TPUTAREA+15(008),RIBESYSN
         LA    R1,TPUTAREA
         LA    R0,23
         BAL   R14,PUTLINE
         EJECT
NOSYS    DS    0H
         AH    R6,LRIBE            ADDR(RIBE)+LENGTH(RIBE) -> NEXT RIBE
         BCT   R7,EXTLOOP          LOOP UNTIL NO MORE EXTENTS
         SPACE
NOEXTS   DS    0H
         LA    R3,0(,R6)           END OF PREV RIBE = BEGIN NEXT RIBE
         BCT   R10,CONTINUE        CONTINUE UNTIL NO MORE RIBS
         B     RETURN              AND THEN FINISH.
         EJECT
RETURN   DS    0H
         L     R13,4(,R13)
         LM    R14,R12,12(R13)
         XR    R15,R15             RETURN CODE(0)
         BR    R14
         EJECT
PUTLINE  DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* R1 = address of message text                                        *
* R0 = length of message text                                         *
*                                                                     *
***********************************************************************
         SPACE 1
         ST    R14,PUTL14          Save return address
         LR    R14,R0              Get length of message
         BCTR  R14,0               Adjust for EX
         EX    R14,MOVELINE        Move message to buffer
         LA    R14,5(,R14)         Get message length + 4
         SLL   R14,16              Shift into left half
         ST    R14,MSGBUFF         Set message buffer prefix
         XC    ECB,ECB
         PUTLINE PARM=PUTLIST,OUTPUT=(MSGBUFF,TERM,SINGLE,DATA),       X
               MF=(E,IOPL)
         LTR   R15,R15             If PUTLINE completed OK
         BZ    PUTLRET             then just return
         LA    R1,MSGBUFF+4        Else point to message
         LH    R0,MSGBUFF+0        Get length of message
         SH    R0,=H'4'            Subtract prefix length
         TPUT  (1),(0),R
PUTLRET  DS    0H
         L     R14,PUTL14          Restore return address
         BR    R14                 Return to caller
         SPACE 1
MOVELINE MVC   MSGBUFF+4(*-*),0(R1) Move PUTLINE message to buffer
PUTL14   DS    A
IOPL     DS    0A
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
ECB      DS    A
PUTLIST  PUTLINE MF=L              PUTLINE parameter list
OLD      DS    F                   PUTLINE output line descriptor
MSGBUFF  DS    F,CL256             PUTLINE message buffer
         EJECT
SAVEAREA DS    9D
DOUBLE   DS    D
* VALUES PASSED BACK FROM THE GQSCAN SERVICE
GQREGS   DS    2F
         ORG   GQREGS
GQREG0   DS    F                   REGISTER ZERO FROM GQSCAN
         ORG   GQREG0
LRIBFIX  DS    H                   LENGTH OF EACH FIXED RIB
LRIBE    DS    H                   LENGTH OF EACH RIBE
GQREG1   DS    F                   REGISTER ONE FROM GQSCAN
         ORG   GQREG1
NUMRIBS  DS    F                   NUMBER OF RIBS COPIED
TOK      DC    F'0'                TOKEN FOR GQSCAN PROCESSING (UNUSED)
SCOPEBIT DC    X'00'
SCOPE    DC    CL7' '
TYPE     DC    CL3' '
WHATISIT DC    CL1' '
STAT     DC    CL1' '
HEXNAME  DS    XL8
SYSNAME  DC    CL8' '
JOBNAME  DC    CL8' '
MAJOR    DC    CL8' '
MINOR    DC    CL256' '
BLANKS   DC    CL256' '
         SPACE
INCR     DC    F'4096'             INCREMENT FOR GETMAINS
NONAME   DC    CL8'NONAME'         DEFAULT SYSTEM NAME
CSDL     DC    CL8'CSDL'           EXPECTED SYSTEM NAME
         SPACE
TRTABLE  DC    256YL1(1)
         ORG   TRTABLE+X'40'
         DC    YL1(0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0)
         DC    YL1(0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0)
         DC    YL1(0,0,2,3,4,5,6,7,8,9,0,0,0,0,0,0)
         DC    YL1(1,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0)
         ORG   TRTABLE+X'81'
         DC    YL1(0,0,0,0,0,0,0,0,0)
         ORG   TRTABLE+X'91'
         DC    YL1(0,0,0,0,0,0,0,0,0)
         ORG   TRTABLE+X'A2'
         DC    YL1(0,0,0,0,0,0,0,0)
         ORG   TRTABLE+X'C1'
         DC    YL1(0,0,0,0,0,0,0,0,0)
         ORG   TRTABLE+X'D1'
         DC    YL1(0,0,0,0,0,0,0,0,0)
         ORG   TRTABLE+X'E2'
         DC    YL1(0,0,0,0,0,0,0,0)
         ORG   TRTABLE+X'F0'
         DC    YL1(0,0,0,0,0,0,0,0,0,0)
         ORG
TRTTBL   DC    256YL1(1)
         ORG   TRTTBL+X'81'
         DC    YL1(0,0,0,0,0,0)
         ORG   TRTTBL+C'A'
         DC    YL1(0,0,0,0,0,0)
         ORG   TRTTBL+C'0'
         DC    YL1(0,0,0,0,0,0,0,0,0,0)
         ORG
TRTBL    DC    256YL1(*-TRTBL)
         ORG   TRTBL+X'81'
         DC    X'FAFBFCFDFEFF'
         ORG   TRTBL+C'A'
         DC    X'FAFBFCFDFEFF'
         ORG
DISPTBL  DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'.ABCDEFGHI......'
         DC    C'.JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
XXXTBL   EQU   *-256
         EJECT
QSPARMS  DS    0F
         SPACE
***********************************************************************
*           PARAMETER LIST TO ISGQSCAN MAPPED AS FOLLOWS:             *
***********************************************************************
         SPACE
AREAPTR  DC    A(0)           AREAPTR    ADDR OF USER SPECIFIED AREA
AREALEN  DC    A(0)           AREALEN    SIZE OF USER SPECIFIED AREA
QNAME    DC    A(0)           QNAME      QNAME (MAJOR NAME) ADDRESS
RNAME    DC    A(0)           RNAME      RNAME (MINOR NAME) ADDRESS
SYSNM    DC    A(0)           SYSNM      SYSNAME ADDRESS
ASID     DC    A(0)           ASID       ASID VALUE
REQCNT   DC    A(0)           REQCNT     REQUEST COUNT
OWNCNT   DC    A(0)           OWNCNT     OWNER COUNT
WAITCNT  DC    A(0)           WAITCNT    WAIT COUNT
TOKEN    DC    A(TOK)         TOKEN      TOKEN ADDRESS
REQLIM   DC    A(32767)       REQLIM     REQUEST LIMIT = MAX
FLAGSA   DC    BL1'11100000'  FLAGSA     RESERVE/SCOPE FLAGS
*                            1.......    SCOPE=STEP
*                            .1......    SCOPE=SYSTEM
*                            ..1.....    SCOPE=SYSTEMS
*                            ...1....    SCOPE=LOCAL
*                            ....1...    SCOPE=GLOBAL
FLAGRNO  EQU   B'00000100'   .....1..    RESERVE=NO
FLAGRYES EQU   B'00000010'   ......1.    RESERVE=YES
*                            .......1    RESERVED
FLAGSB   DC  BL1'00000000'    FLAGSB     VARIABLE SPECIFIED FLAGS
FLAGSYSN EQU   B'10000000'   1.......    SYSNAME SPECIFIED
*                            .1......    REQCNT SPECIFIED
*                            ..1.....    OWNCNT SPECIFIED
FLAGWAIT EQU   B'00010000'   ...1....    WAITCNT SPECIFIED
FLAGTOK  EQU   B'00001000'   ....1...    TOKEN SPECIFIED
*                            .....1..    RESERVED
*                            ......1.    RESERVED
*                            .......1    RESERVED
RNMLEN   DC    YL1(0)                    RNAME LENGTH
         SPACE
         LTORG
         SPACE
TPUTAREA DS    CL280
         EJECT
         ISGRIB ,   MAP THE DATA PASSED BACK BY ISGQSCAN
 SPACE
 CSECT
 SPACE
         CVT    DSECT=YES,PREFIX=YES
 SPACE
 CSECT
 SPACE
         IEZDEB
 SPACE
 CSECT
 SPACE
         IEFJESCT
 SPACE
 CSECT
 SPACE
         IEFJSCVT
 SPACE
 CSECT
 SPACE
         $XECB
 SPACE
 CSECT
 SPACE
         $SCAT
 SPACE
 CSECT
 SPACE
         $HFAME
 SPACE
 CSECT
 SPACE
         $HCCT
 SPACE
 CSECT
 SPACE
         $SJB
 SPACE
 CSECT
 SPACE
         $TQE
         TITLE ' '                 CLEAR TITLE GENERATED BY HASP MACROS
         CSECT
         END
./ ADD NAME=XRXDEQ   0100-07332-07332-0900-00141-00141-00000-SEB
         TITLE 'XRXDEQ   - REXX dequeue LINK module'
***********************************************************************
*                                                                     *
* XRXDEQ   - REXX dequeue LINK module                                 *
*                                                                     *
* This routine is designed to allow a REXX exec to dequeue on a       *
* specified QNAME and RNAME.  It MUST be invoked as follows:          *
*                                                                     *
*   ADDRESS LINK "XRXDEQ qname,rname"                                 *
*                                                                     *
* No blanks are permitted.  LINK must be specified because the ENQ    *
* is task-related (see XRXENQ).                                       *
*                                                                     *
* Case MUST be exact.                                                 *
*                                                                     *
* On entry register 1 points to a pair of parameter addresses:        *
*                                                                     *
* Parameter 1 --> the address of the remaining text in the buffer     *
* Parameter 2 --> the length of the remaining text in the buffer      *
*                                                                     *
* See TSO/E REXX Reference, p. 25, for more information.              *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   Static base register
R13      EQU   13   Dynamic base register and save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
XRXDEQ   CSECT
         SAVE  (14,12),,XRXDEQ_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XRXDEQ,R12
         LR    R2,R1               Save input parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
         LM    R3,R4,0(R2)         Get parameters 1 and 2
         L     R3,0(,R3)           Get address of remaining text
         L     R4,0(,R4)           Get length of remaining text
         LA    R5,0(R3,R4)         Point to end of remaining text
         LTR   R15,R4              If length is zero,
         BNP   ERROR               then error
         BCTR  R15,0               Reduce length for execute
         EX    R15,FINDCOMA        Scan for comma
         BZ    ERROR               If none found, error
         LR    R6,R1               Location of comma
         SR    R6,R3               Get length of text up to comma
         BNP   ERROR               If zero, error
         CH    R6,=H'8'            If too long, error
         BH    ERROR
         LA    R7,1(,R1)           Point past comma
         SR    R5,R7               Get length of rname
         BNP   ERROR               If zero, error
         CH    R5,=H'256'          If too long, error
         BH    ERROR
* R3 = address of qname
* R6 = length of qname
* R7 = address of rname
* R5 = length of rname
         MVI   QNAME,C' '          Clear qname to blanks
         MVC   QNAME+1(L'QNAME-1),QNAME
         LR    R15,R6
         BCTR  R15,0               Reduce length for execute
         EX    R15,MVCQNAME        Move qname
         MVI   RNAME,C' '          Clear rname to blanks
         MVC   RNAME+1(L'RNAME-1),RNAME
         LR    R15,R5
         BCTR  R15,0               Reduce length for execute
         EX    R15,MVCRNAME        Move rname
         SPACE 1
         LA    R2,QNAME
         LA    R3,RNAME
         MVC   DEQLIST($DEQLEN),$DEQLIST
         DEQ   ((R2),(R3),(R5),SYSTEMS),RET=HAVE,MF=(E,DEQLIST)
         B     RETURN              Return with DEQ return code
         SPACE 1
ERROR    DS    0H                  Bad parameters
         L     R15,=F'-1'          Signal failure
         B     RETURN
         SPACE 1
***********************************************************************
* Return to calling environment - R15 contains return code            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         SPACE 1
FINDCOMA TRT   0(*-*,R3),TRTBL     Executed: scan for comma
MVCQNAME MVC   QNAME(*-*),0(R3)    Executed: move qname
MVCRNAME MVC   RNAME(*-*),0(R7)    Executed: move rname
         SPACE 1
$DEQLIST DEQ   (,,,SYSTEMS),RET=HAVE,MF=L
$DEQLEN  EQU   *-$DEQLIST
         SPACE 1
TRTBL    DC    256YL1(0)           Table to scan for comma
         ORG   TRTBL+C','
         DC    YL1(1)
         ORG   ,
         SPACE 1
         LTORG
         SPACE 1
         DROP  R12
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
         SPACE 1
SAVEAREA DS    18F
QNAME    DS    CL8
RNAME    DS    CL256
DEQLIST  DEQ   (,,,SYSTEMS),RET=HAVE,MF=L
         SPACE 2
SIZDATD  EQU   *-DATD              Length of dynamic work area
         EJECT
         END
./ ADD NAME=XRXENQ   0100-07332-07332-0900-00141-00141-00000-SEB
         TITLE 'XRXENQ   - REXX enqueue LINK module'
***********************************************************************
*                                                                     *
* XRXENQ   - REXX enqueue LINK module                                 *
*                                                                     *
* This routine is designed to allow a REXX exec to enqueue on a       *
* specified QNAME and RNAME.  It MUST be invoked as follows:          *
*                                                                     *
*   ADDRESS LINK "XRXENQ qname,rname"                                 *
*                                                                     *
* No blanks are permitted.  LINK must be specified because the ENQ    *
* will go away (due to task termination) otherwise.                   *
*                                                                     *
* Case MUST be exact.                                                 *
*                                                                     *
* On entry register 1 points to a pair of parameter addresses:        *
*                                                                     *
* Parameter 1 --> the address of the remaining text in the buffer     *
* Parameter 2 --> the length of the remaining text in the buffer      *
*                                                                     *
* See TSO/E REXX Reference, p. 25, for more information.              *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    Miscellaneous uses
R3       EQU   3    .
R4       EQU   4    .
R5       EQU   5    .
R6       EQU   6    .
R7       EQU   7    .
R8       EQU   8    .
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   Static base register
R13      EQU   13   Dynamic base register and save area pointer
R14      EQU   14
R15      EQU   15
         SPACE 1
XRXENQ   CSECT
         SAVE  (14,12),,XRXENQ_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XRXENQ,R12
         LR    R2,R1               Save input parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
         LM    R3,R4,0(R2)         Get parameters 1 and 2
         L     R3,0(,R3)           Get address of remaining text
         L     R4,0(,R4)           Get length of remaining text
         LA    R5,0(R3,R4)         Point to end of remaining text
         LTR   R15,R4              If length is zero,
         BNP   ERROR               then error
         BCTR  R15,0               Reduce length for execute
         EX    R15,FINDCOMA        Scan for comma
         BZ    ERROR               If none found, error
         LR    R6,R1               Location of comma
         SR    R6,R3               Get length of text up to comma
         BNP   ERROR               If zero, error
         CH    R6,=H'8'            If too long, error
         BH    ERROR
         LA    R7,1(,R1)           Point past comma
         SR    R5,R7               Get length of rname
         BNP   ERROR               If zero, error
         CH    R5,=H'256'          If too long, error
         BH    ERROR
* R3 = address of qname
* R6 = length of qname
* R7 = address of rname
* R5 = length of rname
         MVI   QNAME,C' '          Clear qname to blanks
         MVC   QNAME+1(L'QNAME-1),QNAME
         LR    R15,R6
         BCTR  R15,0               Reduce length for execute
         EX    R15,MVCQNAME        Move qname
         MVI   RNAME,C' '          Clear rname to blanks
         MVC   RNAME+1(L'RNAME-1),RNAME
         LR    R15,R5
         BCTR  R15,0               Reduce length for execute
         EX    R15,MVCRNAME        Move rname
         SPACE 1
         LA    R2,QNAME
         LA    R3,RNAME
         MVC   ENQLIST($ENQLEN),$ENQLIST
         ENQ   ((R2),(R3),E,(R5),SYSTEMS),RET=HAVE,MF=(E,ENQLIST)
         B     RETURN              Return with ENQ return code
         SPACE 1
ERROR    DS    0H                  Bad parameters
         L     R15,=F'-1'          Signal failure
         B     RETURN
         SPACE 1
***********************************************************************
* Return to calling environment - R15 contains return code            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         SPACE 1
FINDCOMA TRT   0(*-*,R3),TRTBL     Executed: scan for comma
MVCQNAME MVC   QNAME(*-*),0(R3)    Executed: move qname
MVCRNAME MVC   RNAME(*-*),0(R7)    Executed: move rname
         SPACE 1
$ENQLIST ENQ   (,,E,,SYSTEMS),RET=HAVE,MF=L
$ENQLEN  EQU   *-$ENQLIST
         SPACE 1
TRTBL    DC    256YL1(0)           Table to scan for comma
         ORG   TRTBL+C','
         DC    YL1(1)
         ORG   ,
         SPACE 1
         LTORG
         SPACE 1
         DROP  R12
         EJECT
***********************************************************************
* Work area                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   Dynamically acquired work area
         SPACE 1
SAVEAREA DS    18F
QNAME    DS    CL8
RNAME    DS    CL256
ENQLIST  ENQ   (,,E,,SYSTEMS),RET=HAVE,MF=L
         SPACE 2
SIZDATD  EQU   *-DATD              Length of dynamic work area
         EJECT
         END
./ ADD NAME=XRXVARS  0100-07332-07332-0900-00246-00246-00000-SEB
*
***********************************************************************
*                                                                     *
* XRXVARS - SEB1525 09/18/89                                          *
*                                                                     *
***********************************************************************
*
***********************************************************************
*
*  This routine returns the names of all current REXX variables and
*  queues them on the REXX data stack.  The names are selected based
*  on a prefix given in the parameter field.
*
*  Particularly useful if a stem (varname.) is given as the argument.
*
*  Invocation:  CALL 'wherever.load(XRXVARS)' 'variable-prefix'
*
***********************************************************************
         PRINT NOGEN
XRXVARS  CSECT
XRXVARS  AMODE 31
XRXVARS  RMODE ANY
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SAVE  (14,12),,XRXVARS_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XRXVARS,R12
         LR    R2,R1               Save parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R1,8(,R13)
         ST    R13,4(,R1)
         LR    R13,R1
         USING DATD,R13
         MVI   FLAGS,0             Random initializations
         L     R4,0(,R2)           Get address of parm string
         LH    R3,0(,R4)           R3 = length of parm
         LA    R4,2(,R4)           R4 = address of parm
         LOAD  EP=IRXSTK                Get address of IRXSTK routine
         ST    R0,@IRXSTK               Save it
         LOAD  EP=IRXEXCOM              Get address of IRXEXCOM routine
         ST    R0,@IRXEXCO              Save it
*
***********************************************************************
*                                                                     *
* Invoke the IRXEXCOM routine to retrieve all variable names.         *
*                                                                     *
* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *
*                                                                     *
***********************************************************************
*
* Build the SHVBLOCK
*
* To store the argument value, we try using ARGWA, a 512-byte area
* that is already part of our workarea, to avoid unnecessary GETMAINs.
*
* If that doesn't turn out to be big enough, we'll have to GETMAIN,
* but it's best to avoid that.
*
CONTINUE DS    0H
         XC    VARNAME(L'VARNAME),VARNAME
         XC    SHVBLOCK(SHVBLEN),SHVBLOCK
         MVI   SHVCODE,SHVNEXTV    Fetch "next" variable
         LA    R1,L'VARNAME
         ST    R1,SHVUSER          Length of name buffer
         LA    R1,VARNAME
         ST    R1,SHVNAMA          Address of name buffer
         LA    R1,1
         ST    R1,SHVBUFL          Length of dummy value buffer
         LA    R1,DUMBUF
         ST    R1,SHVVALA          Address of dummy value buffer
*                 SHVNAML will contain the length of the name returned
         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1
         XR    R15,R15             IRXEXCOM parm 2
         LR    R0,R15              Parm 3 must be same as Parm 2
         LA    R1,SHVBLOCK         IRXEXCOM parm 4
         STM   R14,R1,IRPARMS
         OI    IRPARM4,X'80'
         XR    R0,R0               Don't specify an environment block
         L     R15,@IRXEXCO        Get address of IRXEXCOM
         LA    R1,IRPARMS          Point to parameter list
         BALR  R14,R15             Call REXX arg access routine
         LTR   R15,R15             Check RC
         BM    BADEXCOM
         TM    SHVRET,SHVLVAR      If no more variables
         BO    ENDIT               then finished
*
* Compare variable prefix here...
*
         LTR   R15,R3
         BZ    QUEUEIT             If no prefix given, accept all
         BCTR  R15,0               Else reduce length for execute
         EX    R15,CLCNAME         If prefix doesn't match
         BNE   CONTINUE            then continue
QUEUEIT  DS    0H
*
* Queue line onto REXX data stack
*
         MVC   IRFUNCT,=CL8'QUEUE'
         LA    R1,VARNAME
         ST    R1,IRSTRADR
         L     R1,SHVNAML
         ST    R1,IRSTRLEN
         XR    R1,R1
         ST    R1,IRRETCD
         LA    R14,IRFUNCT
         LA    R15,IRSTRADR
         LA    R0,IRSTRLEN
         LA    R1,IRRETCD
         STM   R14,R1,IRPARMS
         OI    IRPARM4,X'80'
         XR    R0,R0               Don't specify an environment block
         LA    R1,IRPARMS          Point to parameter list
         L     R15,@IRXSTK         Get address of IRXSTK
         BALR  R14,R15             Call REXX stack access routi ne
         LTR   R15,R15             Check rc
         BNZ   BADSTK
STACKOK  DS    0H                  R15 = 0
         B     CONTINUE
         SPACE 1
ENDIT    DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in save area
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         SPACE 1
ERROR    DS    0H
         L     R15,=F'-1'          Load error code
         B     ENDIT
         SPACE 1
BADEXCOM DS    0H
         LA    R1,1111             U1111 for error in IRXEXCOM
         ABEND (1)
         SPACE 1
BADSTK   DS    0H
         LR    R1,R15              Make abend code the return code
         ABEND (1)
         SPACE 1
         EJECT
CLCNAME  CLC   0(*-*,R4),VARNAME   Executed: compare variable prefix
         EJECT
DATD     DSECT
SAVEAREA DS    18F
@IRXSTK  DS    A                   Address of REXX stack routine
@IRXEXCO DS    A                   Address of REXX access routine
FLAGS    DC    X'00'               Flags
*        EQU   B'10000000'          Reserved
*        EQU   B'01000000'          Reserved
*        EQU   B'00100000'          Reserved
*        EQU   B'00010000'          Reserved
*        EQU   B'00001000'          Reserved
*        EQU   B'00000100'          Reserved
*        EQU   B'00000010'          Reserved
*        EQU   B'00000001'          Reserved
*
VARNAME  DS    CL256               Area where variable name is returned
DUMBUF   DS    CL1                 We don't care about the value
*
IRPARMS  DS    0A                  Parameter list for IRX routines
IRPARM1  DS    A                   Address of parameter 1
IRPARM2  DS    A                   Address of parameter 2
IRPARM3  DS    A                   Address of parameter 3
IRPARM4  DS    A                   Address of parameter 4
*                                  Parameters used by IRXSTK
IRFUNCT  DS    CL8                 Parameter 1: function to perform
IRSTRADR DS    CL8                 Parameter 2: address of string
IRSTRLEN DS    CL8                 Parameter 3: length of string
IRRETCD  DS    CL8                 Parameter 4: return code
*                                  Parameters used by IRXEXCOM
*
***********************************************************************
*                                                                     *
* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *
*                                                                     *
***********************************************************************
*
SHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK
SHVNEXT  DS  A                        Chain pointer to next SHVBLOCK
SHVUSER  DS  F                        Used during "FETCH NEXT"
*                                      Contains length of buffer
*                                      pointed to by SHVNAMA
SHVCODES DS  0F
SHVCODE  DS  CL1                      Function code - indicates type
*                                      of variable access request
SHVRET   DS  XL1                      Return codes
         DS  H'0'                     Reserved (should be 0)
SHVBUFL  DS  F                        Length of fetch value buffer
SHVNAMA  DS  A                        Address of variable name
SHVNAML  DS  F                        Length of variable name
SHVVALA  DS  A                        Address of value buffer
SHVVALL  DS  F                        Length of value buffer
*                                      (Set on fetch)
SHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK
         SPACE 1
**********************************************************************/
*   SHARED VARIABLE REQUEST BLOCK - function codes                   */
**********************************************************************/
         SPACE 1
SHVFETCH EQU   C'F'            Copy value of shared variable
SHVSTORE EQU   C'S'            Set variable from given value
SHVDROPV EQU   C'D'            Drop variable
SHVSYFET EQU   C'f'            Symbolic name retrieve
SHVSYSET EQU   C's'            Symbolic name set
SHVSYDRO EQU   C'd'            Symbolic name drop
SHVNEXTV EQU   C'N'            Fetch "next" variable
SHVPRIV  EQU   C'P'            Fetch private information
         SPACE 1
**********************************************************************/
*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */
**********************************************************************/
        SPACE 1
SHVCLEAN EQU   X'00'           Execution was OK
SHVNEWV  EQU   X'01'           Variable did not exist
SHVLVAR  EQU   X'02'           Last variable transferred ("N")
SHVTRUNC EQU   X'04'           Truncation occurred for "Fetch"
SHVBADN  EQU   X'08'           Invalid variable name
SHVBADV  EQU   X'10'           Invalid value specified
SHVBADF  EQU   X'80'           Invalid function code (SHVCODE)
         SPACE 1
**********************************************************************/
*        R15 return codes                                            */
**********************************************************************/
         SPACE 1
SHVRCOK  EQU    0              Entire Plist chain processed
SHVRCINV EQU   -1              Invalid entry conditions
SHVRCIST EQU   -2              Insufficient storage available
         SPACE 1
SIZDATD  EQU   *-DATD
         END
./ ADD NAME=XTSEXEC  0100-07332-07332-0900-01723-01723-00000-SEB
         SPLEVEL SET=2
         TITLE 'XTSEXEC - RUN-TIME TSO COMMAND OR CLIST EXECUTOR'
***********************************************************************
*                                                                     *
* XTSEXEC - Run-time executor of TSO command or CLIST.                *
*                                                                     *
*          This linklist-resident routine is LINKed to from the CCF   *
*          subroutine XCLIST.  The code herein used to be part of the *
*          XCLIST routine in CCF.LINK.LOAD, but has been separated    *
*          to facilitate system-dependent enhancements, upgrades and  *
*          testing.  The XCLIST in CCF.LINK.LOAD merely issues a LINK *
*          to this routine, passing the contents of register 1 thru.  *
*                                                                     *
*          Adjustments to support various features of TSO/Extensions  *
*          are expected throughout the life of this module.           *
*                                                                     *
* The XCLIST subroutine is invoked as follows:                        *
*                                                                     *
* From PL/1:                                                          *
*                                                                     *
*    DCL XCLIST EXT ENTRY(CHAR(*) VAR) OPTIONS(ASSEMBLER RETCODE);    *
*    CALL XCLIST ('CLISTNAME CLISTOPERANDS ETC.');                    *
*                                                                     *
* From FORTRAN:                                                       *
*                                                                     *
*      INTEGER*2    ILEN                                              *
*      INTEGER*4    IRC                                               *
*      INTEGER*4    XCLIST                                            *
*      CHARACTER*2  CMDLEN                                            *
*      CHARACTER*80 CMD                                               *
*      DATA ILEN/80/                                                  *
*      EQUIVALENCE (ILEN,CMDLEN)                                      *
*      CMD = 'WHATEVER YOUR COMMAND IS'                               *
*      IRC = XCLIST(CMDLEN // CMD)                                    *
*C     ... IRC IS THE RETURN CODE FROM THE COMMAND.                   *
*                                                                     *
* Input is a PL/1 varying-length character string (you know, a        *
* halfword containing the command length followed by the command).    *
*                                                                     *
* The return code from the last command executed is returned to       *
* the calling program.                                                *
*                                                                     *
***********************************************************************
*                                                                     *
*  LINKAGE EDITOR ATTRIBUTES:  REENTRANT, REUSABLE                    *
*  AMODE:  ANY     RMODE: ANY                                         *
*  MACRO LIBRARIES REQUIRED:  DST1.AMODGEN                            *
*                                                                     *
***********************************************************************
*                                                                     *
* REGISTER USAGE:                                                     *
*                                                                     *
*   R3  -->  CPPL (COMMAND PROCESSOR PARAMETER LIST)                  *
*   R4  -->  ECT (ENVIRONMENT CONTROL TABLE)                          *
*   R5  -->  CBUF (COMMAND BUFFER)                                    *
*   R6  -->  (available)                                              *
*   R7  -->  ADDRESS OF OUR INPUT STACK                               *
*   R8  -->  STATIC BASE REGISTER FOR PUTLINE SUBROUTINE              *
*   R9  -->  SECONDARY STATIC BASE REGISTER                           *
*   R10 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 0                      *
*   R11 -->  DYNAMIC BASE REGISTER FOR SUBPOOL 1                      *
*   R12 -->  PRIMARY STATIC BASE REGISTER                             *
*   R13 -->  SAVE AREA POINTER                                        *
*                                                                     *
* NOTE: REGISTER USAGE IN EXIT ROUTINES MAY DEVIATE FROM THE ABOVE.   *
*                                                                     *
***********************************************************************
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*                                                                     *
* 05/02/89 - Born out of the ashes of XCLIST (SEB1525).               *
*            Contains code to process commands under all versions of  *
*            TSO/Extensions for MVS/XA.                               *
*                                                                     *
***********************************************************************
         SPACE 2
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
XTSEXEC  CSECT
XTSEXEC  AMODE ANY
XTSEXEC  RMODE ANY
         SAVE  (14,12),,XTSEXEC_&SYSDATE._&SYSTIME
         LR    R12,R15
         LA    R9,4095(,R12)
         LA    R9,1(,R9)
         USING XTSEXEC,R12,R9
         L     R3,0(,R1)           SAVE PARAMETER LIST ADDRESS
         XR    R11,R11             CLEAR SUBPOOL 1 STORAGE REGISTER
         LA    R0,SIZDATD0         GET LENGTH OF SUBPOOL 1 STORAGE
         GETMAIN R,LV=(0),LOC=BELOW GET SUBPOOL 1 STORAGE
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         LR    R10,R1              ADDRESS SUBPOOL 0 STORAGE
         USING DATD0,R10
         SPACE
*
* BUILD CPPL FROM SYSTEM CONTROL BLOCKS
*
         USING PSA,0
         L     R15,PSATOLD          GET TCB ADDRESS
         USING TCB,R15
         L     R15,TCBJSCB          GET JSCB ADDRESS
         USING IEZJSCB,R15
         L     R15,JSCBACT          GET ADDRESS OF ACTIVE JSCB
         L     R15,JSCBPSCB         GET ADDRESS OF PSCB
         LTR   R15,R15             IF THERE'S NO PSCB
         BNZ   PSCBOK              THEN...
         LA    R1,NTSOMSG           Issued in non-TSO environment
         WTO   MF=(E,(1))           Write to programmer
         ABEND 1500                 AND BLOW UP, NO DUMP REQUIRED
         SPACE 1
PSCBOK   DS    0H
         ST    R15,CPPLPSCB         SAVE PSCB ADDRESS
         USING PSCB,R15
         MVC   CPPLUPT,PSCBUPT      SAVE UPT ADDRESS
         L     R15,PSCBRLGB         GET ADDRESS OF RELOGON BUFFER
         USING RLGB,R15
         L     R4,RLGBECT           GET ADDRESS OF ECT
         ST    R4,CPPLECT          ADDRESS ENVIRONMENT CONTROL TABLE
         USING ECT,R4
         SPACE 2
*
* Locate the LWA (logon work area) to find the addresses of the TSO
* tables that define which TSO commands can be accessed and how.
*
         L     R15,PSAAOLD         Get ASCB address
         USING ASCB,R15
         L     R15,ASCBASXB        Get ASXB address
         USING ASXB,R15
         L     R2,ASXBLWA          Get LWA address
         USING LWA,R2
         CLC   LWAPECT(4),CPPLECT  Check that ECT addresses match
         BE    ECTSOK
         LA    R1,NECTMSG           ECT pointer mismatch
         WTO   MF=(E,(1))           Write to programmer
ECTSOK   DS    0H
         L     R15,LWATNS          Get address of IKJEFTNS
         ST    R15,D0NSADDR        (TSO commands invalid in background)
         L     R15,LWATE2          Get address of IKJEFTE2
         ST    R15,D0E2ADDR        (TSO commands that run authorized)
         L     R14,CPPLUPT
         L     R15,CPPLECT
         LA    R0,D0ECB
         STM   R14,R0,IOPLUPT      SET UP IKJPUTL PARAMETER LIST
         L     R1,CPPLPSCB
         LA    R2,DAPB2C
         STM   R14,R2,DAPLUPT      SET UP IKJDAIR PARAMETER LIST
         LA    R0,X'2C'            DAIR ENTRY CODE TO MARK NOT IN USE
         SLL   R0,16               SHIFT INTO LEFT HALF FOR DAIR CB
         STCM  R0,15,DA2CCD        AND PUT ZEROES INTO FLAG FIELD
         MVI   DA2CDDN,C' '        CLEAR DDNAME TO BLANKS
         MVC   DA2CDDN+1(7),DA2CDDN
         MVC   D0BLDL(4),=Y(1,12)  INITIALIZE BLDL LIST FOR CMDCHK
         MVC   D0ATTACH(LATTACHL),LATTACH  SET UP ATTACH LIST FORM
         MVC   PTPB(12),LPUTLINE           SET UP PUTLINE LIST FORM
         MVC   PGPB(LPUTGETL),LPUTGET      SET UP PUTGET LIST FORM
         MVC   D0ESTAE(LESTAEL),LESTAE     SET UP ESTAE LIST FORM
         MVC   D0STAX(LSTAXL),LSTAX        SET UP STAX LIST FORM
         LA    R0,1
         LA    R1,D0MSGHDR
         XR    R2,R2
         STM   R0,R2,D0MSGOLD      INITIALIZE PUTLINE WORK AREA
         LA    R1,D0PGHDR
         STM   R0,R1,D0PGOLD       INITIALIZE PUTGET MODE MSG AREA
         LA    R1,D0PGOLD
         ST    R1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK
         LA    R1,D0MSGOLD
         ST    R1,PTPBOPUT         STORE ADDR OF O.L.D. IN PARM BLOCK
         LA    R0,D0CMDECB
         LA    R1,D0ATNECB
         STM   R0,R1,D0ECBLST      INITIALIZE ECB LIST
         OI    D0ECBLST+4,X'80'
*** NOTE: R2 CONTAINS ZEROES FROM ABOVE INSTRUCTIONS.
         ST    R2,DA2CTCB          TCB ADDRESS TO MARK DSE'S NOT IN USE
         ST    R2,D0RETCD          INITIALIZE RETURN CODE TO ZERO
         MVI   D0RETURN,D0RETNO    Initialize returning status to NO
         SPACE
***********************************************************************
* Before setting up handlers, save current state so that it can be    *
* restored if things get interrupted.                                 *
***********************************************************************
         SPACE
         MVC   D0CMDS,ECTPCMD      SAVE ORIGINAL PRIMARY & SUBCOMMAND
         L     R2,ECTIOWA          GET ADDRESS OF ORIGINAL INPUT STACK
         ST    R2,D0SVIOA          SAVE INPUT STACK IN OUR WORK AREA
         LA    R0,PUTLINE          ADDRESS OF PUTLINE SUBROUTINE
         ST    R0,D0PLADDR         SAVE IT FOR EXIT ROUTINES
         SPACE
***********************************************************************
* SET UP ESTAE (ABEND) AND STAX (ATTENTION) EXIT ROUTINES.            *
* NOTE: THE DATD0 DSECT IS PASSED TO BOTH ROUTINES.  SINCE THE        *
*       ADDRESS OF DATD0 IS IN R10, THAT REGISTER IS USED AS THE      *
*       PARAMETER ADDRESS IN THE ESTAE AND STAX MACRO INSTRUCTIONS.   *
***********************************************************************
         SPACE
         LA    R14,STAEEXIT
         ESTAE (R14),PARAM=(R10),MF=(E,D0ESTAE)
         LTR   R15,R15             IF ESTAE FAILED,
         BZ    ESTAEOK             THEN
         LA    R1,=C'ESTAE'         BLOW UP
         LA    R0,5
         B     ERROR
ESTAEOK  OI    D0FLAGS,D0ESTON     ELSE INDICATE ESTAE IS ACTIVE
         LA    R14,STAXEXIT
         STAX  (R14),USADDR=(R10),REPLACE=NO,MF=(E,D0STAX)
         CH    R15,=H'4'           IF STAX FAILED,
         BNH   STAXOK              THEN
         LA    R1,=C'STAX'          BLOW UP
         LA    R0,4
         B     ERROR
STAXOK   OI    D0FLAGS,D0STXON     ELSE INDICATE STAX IS ACTIVE
         EJECT
***********************************************************************
* Determine which version of TSO/Extensions is active.                *
* Reference: TSO/Extensions Version 2 Programming Services (SC28-1875 *
*            Chapter 2. Considerations for Using TSO/E Services       *
*            Determining the Version and Release of TSO/E Installed   *
***********************************************************************
         SPACE 1
         MVI   D0TSOE,C'0'         Initialize TSO/E version to (none)
         L     R15,X'10'           Get address of CVT
         L     R15,CVTTVT-CVT(,R15) Get address of TSVT
         LTR   R15,R15             If there is none,
         BZ    TSOEV0              then don't change it
         USING TSVT,R15            Else set it...
         MVC   D0TSOE,TSVTLVER     C'1' = version 1, C'2' = version 2
         SPACE 1
TSOEV0   DS    0H
         SPACE 1
***********************************************************************
* ALLOCATE SUBPOOL 1 STORAGE FOR SCAN SERVICE ROUTINE                 *
***********************************************************************
         SPACE
         GETMAIN R,LV=SIZDATD1,SP=1,LOC=BELOW GET SUBPOOL 1 STORAGE
         LR    R11,R1              ADDRESS SUBPOOL 1 STORAGE
         USING DATD1,R11
         EJECT
***********************************************************************
* ALLOCATE SUBPOOL 1 STORAGE FOR INITIAL COMMAND BUFFER               *
***********************************************************************
         SPACE
         LA    R2,4                ADD 4 TO ...
         AH    R2,0(,R3)            LENGTH OF COMMAND STRING
         LA    R0,1                GET SUBPOOL NUMBER
         SLL   R0,24               SHIFT TO HIGH ORDER BYTE
         ALR   R0,R2               ADD IN LENGTH
         AH    R0,=Y(7+8)          ROUND TO DOUBLEWORD BOUNDARY
         N     R0,=F'-8'            SO THAT WE CAN
         LR    R14,R0                PAD IT AND SAVE IT FOR MVCL
         GETMAIN R,LV=(0),LOC=BELOW GET SUBPOOL 1 STORAGE
         LR    R5,R1               FOR INITIAL COMMAND BUFFER
         LR    R15,R14             GET LENGTH OF GETMAINED BUFFER
         SH    R15,=H'4'           MINUS 4 FOR PREFIX
         LA    R14,4(,R5)          GET ADDRESS OF OUTPUT BUFFER TEXT
         LA    R0,2(,R3)           GET ADDRESS OF INPUT COMMAND STRING
         LH    R1,0(,R3)           GET LENGTH OF INPUT COMMAND STRING
         MVCL  R14,R0              MOVE COMMAND STRING TO THE BUFFER
*                                  (INCLUDING NULL PADDING)
         SLL   R2,16               SHIFT BUFFER LENGTH INTO LEFT HALF
         ST    R2,0(,R5)           CREATE COMMAND BUFFER PREFIX
         SPACE
         L     R14,CPPLUPT
         L     R15,CPPLECT
         LA    R0,D0ECB
         LA    R1,D1CSFLG
         LA    R2,CSOA
         STM   R14,R2,CSPL         SET UP IKJSCAN PARAMETER LIST
         MVI   D1CSFLG,0           PREPARE TO SYNTAX CHECK COMMAND
         SPACE
***********************************************************************
* PREPARE TO INVOKE COMMANDS BY SAVING THE CURRENT INPUT STACK AND    *
* INITIALIZING IT TO A TERMINAL ELEMENT (A LA ISPF).                  *
***********************************************************************
         SPACE
         CLI   D0TSOE,C'2'         If TSO/E Version 2 or later,
         BNL   INITSTK2            then do it the TSO/E Version 2 way
*                                  else do it the TSO/E Version 1 way
         OI    D0FLAGS,D0STKMOD    INDICATE INPUT STACK ADDR ALTERED
         XR    R0,R0               MAKE A ZERO
         ST    R0,ECTIOWA          CLEAR INPUT STACK ADDRESS
         ST    R0,D0ECB            CLEAR ECB FOR STACK
*
* SET UP A TERMINAL ELEMENT AS THE BOTTOM ELEMENT OF NEW INPUT STACK
*
         MVC   D0STACK(STKINITL),STKINIT Set up stack macro form
         STACK PARM=D0STACK,MF=(E,IOPL)
         LTR   R15,R15             IF STACK SUCCESSFUL,
         BZ    STACKOK             THEN TERMINATE OUR PROCESSING.
         LA    R1,=C'STACK DATASET=*' ELSE BLOW UP
         LA    R0,15
         B     ERROR
         SPACE
STACKOK  DS    0H
         SPACE
***********************************************************************
* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA XCLIST FUNCTION IN THE *
* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *
* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *
* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *
* NOTE THAT WE CAN'T DO THIS "LEGALLY" BY USING THE STACK MACRO TO    *
* SET UP SYSTSPRT AS THE BOTTOM ELEMENT, SINCE THAT WOULD CAUSE IT    *
* TO BE REOPENED FOR OUTPUT AND PREVIOUS TSO OUTPUT WOULD BE LOST.    *
***********************************************************************
         SPACE
         L     R2,D0SVIOA          Get address of original input stack
         L     R7,ECTIOWA          GET ADDRESS OF OUR NEW INPUT STACK
         L     R14,4(,R7)          GET ADDRESS OF OUR BOTTOM ELEMENT
         L     R15,4(,R2)          GET ADDRESS OF THEIR BOTTOM ELEMENT
         MVC   0(4,R14),0(R15)     MOVE THEIR ELEMENT TO OUR ELEMENT
         B     AINITSTK            Else...
         SPACE 1
INITSTK2 DS    0H                  Set input stack for TSO/E Version 2
*
***********************************************************************
* Make a new input stack by issuing STACK ENVIRON=CREATE, which makes *
* a new ECT and a new IOWA.  We don't use the new ECT, but we do use  *
* the new IOWA, altering the current ECT to point to it.              *
***********************************************************************
*
         MVC   D0STACK2(STKCREAL),STKECREA Set up stack macro form
         XC    D0ECB,D0ECB         Clear ECB
         STACK PARM=D0STACK2,MF=(E,IOPL) Stack ENVIRON=CREATE
         LTR   R15,R15             If STACK failed,
         BZ    ENVCREOK            then blow up
         LA    R1,=C'STACK ENVIRON=CREATE'
         LA    R0,20
         B     ERROR
ENVCREOK DS    0H                  STACK created new ECT...
*
***********************************************************************
* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA XCLIST FUNCTION IN THE *
* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *
* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *
* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *
***********************************************************************
*
         OI    D0FLAGS,D0STKMOD    Indicate input stack addr altered
         L     R15,D0STACK2+STPBECTA-STPB Get address of new ECT
         ST    R15,D0NEWECT               Save it
         MVC   ECTIOWA(4),ECTIOWA-ECT(R15) Copy IOWA pointer to ours
*
* Put a barrier element on the stack.
*
         MVC   D0STACK2(STKBARRL),STKBARR Set up stack list form
         XC    D0ECB,D0ECB         Clear ECB
         STACK PARM=D0STACK2,MF=(E,IOPL) STACK BARRIER=*
         LTR   R15,R15             IF STACK UNSUCCESSFUL,
         BZ    BARRIERD            THEN TERMINATE OUR PROCESSING.
         LA    R1,=C'STACK BARRIER=*'
         LA    R0,15
         B     ERROR
BARRIERD DS    0H
*
* Use PUTGET SUBSTACK=YES in conjunction with the barrier.
*
         MVC   PGPB(LPUTSUBL),LPUTSUB Set up PUTGET SUBSTACK=YES form
         LA    R1,D0PGOLD
         ST    R1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK
         SPACE 1
AINITSTK DS    0H                  ECT ready with new stack
         SPACE
***********************************************************************
* THE COMMAND BUFFER PASSED TO US IS SCANNED AS A TSO COMMAND, THE    *
* FIRST OPERAND IS CHECKED TO SEE IF IT IS A VALID TSO COMMAND OR     *
* CLIST, AND IF SO, IT IS THEN INVOKED.                               *
***********************************************************************
         SPACE
         ST    R5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS
         MVC   D0OFFSET,2(R5)      SAVE POSSIBLE CLIST NAME OFFSET
         LR    R1,R5               POINT TO COMMAND BUFFER
         BAL   R14,SCAN            SCAN NEXT OPERAND IN COMMAND BUFFER
         B     GOSCAN(R15)         BRANCH BASED ON RETURN CODE
GOSCAN   B     SCAN0               RC=0 - VALID COMMAND NAME
         B     RETURN              RC=4 - NO COMMAND NAME, RETURN NIL
         B     SCAN8               RC=8 - INVALID COMMAND NAME
         LH    R15,D0SCANRC        RC=12 - SCAN ERROR
         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP
         LA    R0,4
         B     ERROR
         SPACE
SCAN8    DS    0H                  COMMAND IS SYNTACTICALLY INVALID
         LA    R1,SYNMSG
         LA    R0,L'SYNMSG
         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK
         B     RETURN
         SPACE
SCAN0    DS    0H                  COMMAND NAME IS SYNTACTICALLY OK
         BAL   R14,CKCMD           CHECK EXISTENCE OF COMMAND
         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,
         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE
         LTR   R15,R15             IF COMMAND IS NOT SUPPORTED
         BNZ   RETURN              THEN RETURN WITHOUT INVOKING IT
         BAL   R14,ATTACH          ELSE ATTACH THE COMMAND
         TM    D0FLAGS,D0SUBER     IF SEVERE ERROR OCCURRED,
         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE
         B     PROCXC              GO PROCESS ADDITIONAL STACKED CMD'S
         EJECT
RETURN   DS    0H
         SPACE
***********************************************************************
*           *** RETURN TO CALLING PROGRAM ***                         *
*         CLEAR OUR STACK, RESTORE ORIGINAL ONE,                      *
*                 FREE STORAGE AND EXIT                               *
***********************************************************************
         SPACE
         CLI   D0RETURN,D0RETYES   If we're already returning,
         BNE   NORETYES            then...
         LA    R1,RETYMSG           Attempt to return again (literally)
         WTO   MF=(E,(1))           Write to programmer
         ABEND 1501,DUMP            Abend (stack error or something)
NORETYES DS    0H
         MVI   D0RETURN,D0RETYES   Indicate we are returning
         LTR   R1,R11              IF SUBPOOL 1 STORAGE ALLOCATED,
         BZ    AFTFREE1            THEN
         FREEMAIN R,LV=SIZDATD1,A=(1),SP=1  FREE SUBPOOL 1 STORAGE
         XR    R11,R11              INDICATE SUBPOOL 1 STORAGE FREED
AFTFREE1 DS    0H
         TM    D0FLAGS,D0STKMOD    IF INPUT STACK ADDRESS WAS ALTERED,
         BZ    AFTSTKRS            THEN
         CLI   D0TSOE,C'2'         If TSO/E Version 2 or later
         BNL   FREESTK2            then unstack the new way
*                                  else unstack the old way
STKCHECK DS    0H                   CHECK CURRENT INPUT STACK
         CLC   0(4,R7),4(R7)        IF TOP ELEMENT NOT = BOTTOM ELEMENT
         BE    STKCLRD              THEN
         LA    R1,FLUSHTOP           CALL STACK TO FLUSH TOP ELEMENT
         BAL   R14,FLUSH             UNTIL
         B     STKCHECK              ALL STACK ELEMENTS ARE CLEARED.
STKCLRD  DS    0H                  WHEN STACK IS CLEARED...
*
* NOTE THAT WE DON'T PROCESS THE BOTTOM ELEMENT OF OUR STACK VIA STACK!
* IT CANNOT BE DELETED IF IT IS A TERMINAL ELEMENT, AND IF IT IS A
* DATASET ELEMENT WE DEFINITELY DON'T WANT TO CLOSE IT, SO WE JUST
* LET IT DISAPPEAR (UN)NATURALLY.
*
         B     AFTSTKRS
         SPACE 1
FREESTK2 DS    0H                  Unstack the TSO/E Version 2 way...
         MVC   D0STACK2(STKDELBL),STKDELB
         XC    D0ECB,D0ECB
         STACK PARM=D0STACK2,MF=(E,IOPL)
         LTR   R15,R15
         BZ    AFTSTKDB
         LA    R1,=C'STACK DELETE=BARRIER'
         LA    R0,20
         B     ERROR
         SPACE 1
AFTSTKDB DS    0H
*
***********************************************************************
* Clear things out by issuing STACK ENVIRON=DESTROY.  This SHOULD     *
* have the effect of deleting all the elements from the IOWA that     *
* we have been using.  Then restore the old IOWA pointer to the ECT.  *
***********************************************************************
*
         MVC   D0STACK2(STKDESTL),STKEDEST Set up stack macro form
         L     R15,D0NEWECT               Get address of new ECT
         ST    R15,D0STACK2+STPBECTA-STPB Store into stack parm list
         ST    R15,IOPLECT         Store into IOPL for STACK to see
         XC    D0ECB,D0ECB         Clear ECB
         STACK PARM=D0STACK2,MF=(E,IOPL) Stack ENVIRON=DESTROY
         LTR   R15,R15             If STACK failed,
         BZ    ENVDESOK            then blow up
*                                  (but before blowing up, patch up)
         MVC   D0BADECT,IOPLECT     Save address of bad? model ECT
         MVC   D0BADIOW,ECTIOWA     Save address of bad? IOWA
         MVC   IOPLECT,CPPLECT      Restore our ECT pointer
         MVC   ECTIOWA(4),D0SVIOA   RESTORE ORIGINAL INPUT STACK ADDR
         NI    D0FLAGS,255-D0STKMOD INDICATE INPUT STACK RESTORED
*                                  (now things are patched up...)
         LA    R1,=C'STACK ENVIRON=DESTROY'
         LA    R0,21
         B     ERROR
ENVDESOK DS    0H                  STACK back to normal, almost...
         MVC   IOPLECT,CPPLECT     Restore our ECT pointer
         SPACE 1
AFTSTKRS DS    0H                  Unstacked, one way or the other
         SPACE 1
         MVC   ECTIOWA(4),D0SVIOA   RESTORE ORIGINAL INPUT STACK ADDR
         NI    D0FLAGS,255-D0STKMOD INDICATE INPUT STACK RESTORED
         TM    D0FLAGS,D0ECTMOD    IF ECTPCMD OR ECTSCMD WAS ALTERED,
         BZ    AFTCMDRS            THEN
         MVC   ECTPCMD(16),D0CMDS   RESTORE ECTPCMD AND ECTSCMD.
AFTCMDRS DS    0H
         TM    D0FLAGS,D0STXON     IF STAX IS ACTIVE
         BNO   OFFSTAX             THEN
         STAX  ,                    CANCEL STAX
OFFSTAX  DS    0H
         TM    D0FLAGS,D0ESTON     IF ESTAE IS ACTIVE
         BNO   OFFESTAE            THEN
         ESTAE 0                    CANCEL ESTAE
OFFESTAE DS    0H
         SPACE
FINALRET DS    0H
         L     R15,D0RETCD         PICK UP RETURN CODE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        PASS BACK RETURN CODE IN R15
         ST    R15,20(,R13)        PASS BACK RETURN CODE IN R0 FOR FTN
         FREEMAIN R,LV=SIZDATD0,A=(1)  FREE SUBPOOL 0 STORAGE
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
LPUTLINE PUTLINE MF=L,OUTPUT=(*-*,TERM,SINGLE,INFOR)
LPUTGET  PUTGET  MF=L,OUTPUT=(*-*,,MODE)
LPUTGETL EQU   *-LPUTGET
LPUTSUB  PUTGET  MF=L,OUTPUT=(*-*,,MODE),SUBSTACK=YES
LPUTSUBL EQU   *-LPUTSUB
STKINIT  STACK MF=L,DATASET=*      STACK TERMINAL ELEMENT LIST FORM
STKINITL EQU   *-STKINIT           LENGTH OF STACK LIST FORM
FLUSHALL STACK MF=L,DELETE=ALL     NORMAL STACK FLUSH LIST FORM
FLUSHTOP STACK MF=L,DELETE=TOP     ATTN STACK FLUSH LIST FORM
STKECREA STACK MF=L,ENVIRON=CREATE  TSO/E Version 2 ECT builder
STKCREAL EQU   *-STKECREA          LENGTH OF STACK LIST FORM
STKEDEST STACK MF=L,ENVIRON=DESTROY TSO/E Version 2 ECT remover
STKDESTL EQU   *-STKEDEST          LENGTH OF STACK LIST FORM
STKBARR  STACK MF=L,BARRIER=*
STKBARRL EQU   *-STKBARR           LENGTH OF STACK LIST FORM
STKDELB  STACK MF=L,DELETE=BARRIER
STKDELBL EQU   *-STKDELB           LENGTH OF STACK LIST FORM
LATTACH  ATTACH SF=L,SHSPV=78,SZERO=NO
LATTACHL EQU   *-LATTACH
LESTAE   ESTAE MF=L
LESTAEL  EQU   *-LESTAE
LSTAX    STAX  MF=L,REPLACE=NO
LSTAXL   EQU   *-LSTAX
         SPACE
MODEDATA DC    Y(MODELEN,0)
MODEMSG  DC    C' XCLIST'          LEADING BLANK REQUIRED - NO MSGID
MODELEN  EQU   *-MODEDATA
         SPACE 1
         DC    C'0123456789ABCDEF'
HEXTR    EQU   *-256
         SPACE
         LTORG
         TITLE 'XTSEXEC - STACKED COMMAND PROCESSING'
PROCXC   DS    0H
         SPACE
***********************************************************************
*               STACKED COMMAND PROCESSING                            *
*                                                                     *
* FOR THIS ROUTINE, ALL COMMANDS PLACED ON THE INPUT STACK BY THE     *
* CURRENT COMMAND (E.G. A CLIST) ARE EXECUTED FROM THIS INTERFACE.    *
* THE END OF THE CLIST OR STACK ELEMENT IS DETERMINED BY REACHING     *
* THE BOTTOM LEVEL OF THE INPUT STACK.                                *
*                                                                     *
* NOTE: WHEN THE END OF A CLIST IS REACHED, THE PUTGET SERVICE        *
* ROUTINE AUTOMATICALLY GOES TO THE NEXT LOWER ELEMENT ON THE STACK   *
* TO RETRIEVE THE NEXT COMMAND.  NO NOTIFICATION IS RECEIVED BY THE   *
* CALLER OF PUTGET THAT THIS HAS HAPPENED.  TO GET AROUND THIS        *
* PROBLEM, WE ISSUE A PUTGET WITH A BAD MODE MESSAGE SO THAT THE      *
* PUTGET WILL COMPLETE SUCCESSFULLY AS LONG AS IT GETS A COMMAND FROM *
* A CLIST, BUT NOT WHEN IT TRIES TO GET A COMMAND FROM THE TERMINAL   *
* (IT WILL RETURN A CODE OF 24 IN THIS CASE).  (THIS IDEA CAME        *
* ORIGINALLY FROM ISPF MODULE ISPCAT (OR CAT).) WHEN THIS SITUATION   *
* IS DETECTED, THE RETURN CODE FROM PUTGET IS CHECKED; IF THE INPUT   *
* WAS OBTAINED FROM THE TERMINAL BUT NOT FROM THE BOTTOM LEVEL OF     *
* THE INPUT STACK, THE PROBABLE EXPLANATION IS THAT A "TERMIN"        *
* COMMAND PROCEDURE STATEMENT HAS BEEN EXECUTED, SO THE PUTGET IS     *
* REISSUED WITH A GOOD MODE MESSAGE TO PERMIT TERMIN FUNCTIONING.     *
* OTHERWISE WE KNOW THAT THE CLIST HAS COME TO AN END AND WE EXIT.    *
*                                                                     *
* THIS GIVES RISE TO A PROBLEM IN CLISTS THAT CONTAIN TERMIN          *
* STATEMENTS:  IF CONTROL IS RETURNED TO THE CLIST BY THE USER'S      *
* ENTRY OF A TERMIN STRING, AND THE CLIST ISSUES NO MORE TSO COMMANDS *
* BUT DOES SOME CLIST PROCESSING AND TERMINATES, THIS SUBROUTINE HAS  *
* NO WAY OF KNOWING THAT THE COMMAND RETRIEVED FOLLOWING THE TERMIN   *
* STATEMENT CAME FROM OUTSIDE THE CLIST UNTIL IT HAS ALREADY BEEN     *
* RETRIEVED, BY WHICH TIME IT IS TOO LATE TO DO ANYTHING ABOUT IT.    *
* THEREFORE, CLISTS SHOULD CONTAIN AT LEAST ONE COMMAND (A NULL       *
* COMMAND IS SUFFICIENT) FOLLOWING RETURN FROM A TERMIN STATEMENT.    *
* (ISPF AVOIDS THIS PROBLEM BY REFUSING TO SUPPORT TERMIN ENTIRELY.)  *
*                                                                     *
***********************************************************************
         SPACE
***********************************************************************
* RETRIEVE COMMANDS USING PUTGET, SCAN THEM AND ATTACH THE COMMANDS   *
* WHEN VALID.  NOTE THAT STACK FLUSHING MAY CAUSE THE CURRENT STACK   *
* LEVEL TO REVERT TO THE ORIGINAL LEVEL, TERMINATING OUR PROCESSING   *
* OF COMMANDS; THIS IS A NORMAL WAY OF CLIST TERMINATION UNDER TSO.   *
***********************************************************************
         SPACE
         LTR   R1,R5               GET ADDRESS OF PUTGET BUFFER
         BZ    XCGET               IF A PUTGET BUFFER EXISTS, THEN...
         LA    R0,1                 GET SUBPOOL NUMBER
         SLL   R0,24                SHIFT INTO HIGH-ORDER BYTE
         AH    R0,0(,R5)            ADD IN LENGTH OF PUTGET BUFFER
         FREEMAIN R,LV=(0),A=(1)    FREE THE PUTGET INPUT BUFFER
         XR    R5,R5                CLEAR PUTGET BUFFER POINTER
         SPACE
XCGET    DS    0H
         SPACE
         CLI   D0TSOE,C'2'         If TSO/E Version 2 or later
         BNL   PROC2               then process commands the new way
*                                  else process commands the old way
         SPACE
***********************************************************************
* AT THIS POINT WE ARE READY TO GET THE NEXT COMMAND, BUT ONLY IF A   *
* NEW ELEMENT HAS BEEN PLACED ON THE INPUT STACK, I.E. THE STACK      *
* LEVEL AT THIS POINT IS NOT THE SAME AS THE BOTTOM ELEMENT.  SUCH    *
* CAN OCCUR IF WE HAVE EXECUTED A CLIST OR IF WE HAVE INVOKED A       *
* COMMAND THAT STACKS OTHER COMMANDS.  WE KEEP PROCESSING COMMANDS    *
* UNTIL THE STACK LEVEL REACHES THE BOTTOM AGAIN.  NOTE THAT ANY      *
* ERROR ENCOUNTERED DURING A PREVIOUS PASS THROUGH THIS LOOP WILL     *
* HAVE CAUSED US TO ISSUE A STACK FLUSH, WHICH WILL RESULT IN         *
* TERMINATION OF NEW STACK ELEMENTS (AND EXIT FROM LOOP) UNLESS THE   *
* ELEMENT IS A CLIST WITH CONTROL MAIN OR CONTROL NOFLUSH ACTIVE.     *
***********************************************************************
         SPACE
         CLC   0(4,R7),4(R7)       IF TOP STK ELEMENT = BOTTOM ELEMENT
         BE    ENDCMDS             THEN END OUR PROCESSING.
         SPACE
***********************************************************************
* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *
***********************************************************************
         SPACE
         XC    D0PGHDR(4),D0PGHDR  SET UP BAD (NULL) MODE MESSAGE
         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE
         CH    R15,=H'24'          IF INVALID PARAMETERS ON PUTGET,
         BNE   PUTGETOK            THEN (TERMINAL IS CURRENT ELEMENT)..
         CLC   0(4,R7),4(R7)        IF TOP STK ELEMENT = BOTTOM ELEMENT
         BE    ENDCMDS              THEN END OUR PROCESSING.
         SPACE
***********************************************************************
* ELSE WE ASSUME A TERMIN STATEMENT WAS EXECUTED AND WE ACCEPT INPUT. *
***********************************************************************
         SPACE
         MVC   D0PGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE
         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG                OR
         CH    R15,=H'24'            INVALID PARAMETERS ON PUTGET,
         BE    BADPG                  THEN REALLY BAD PUTGET, BLOW UP.
         CLC   0(4,R7),4(R7)       ELSE IF TOP ELEMENT = BOTTOM ELEMENT
         BNE   PUTGETOK            THEN (TERMIN ENVIRONMENT NOT VALID)
         LA    R1,TERMMSG           DISPLAY MESSAGE TELLING USER THAT
         LA    R0,L'TERMMSG         THE COMMAND WAS NOT EXECUTED SINCE
         BAL   R14,PUTLINE          IT WASN'T SUPPOSED TO BE RETRIEVED
         B     ENDCMDS              AND THEN RETURN TO CALLING PGM.
         SPACE 1
PROC2    DS    0H                  Process commands the TSO/E V.2 way
         SPACE 1
***********************************************************************
* At this point we are ready to get the next command, but only if a   *
* new element has been placed on the input stack, I.E. the stack      *
* level at this point is not the barrier element.  Such can occur if  *
* we have executed a CLIST or if we have invoked a command that       *
* stacks other commands.  We keep processing commands until the stack *
* barrier element is reached.  Note that any error encountered during *
* a previous pass through this loop will have caused us to issue a    *
* stack flush, which will result in termination of new stack elements *
* (and exit from loop) unless the element is a CLIST with             *
* CONTROL MAIN or CONTROL NOFLUSH active.                             *
***********************************************************************
* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *
***********************************************************************
         SPACE
         MVC   D0PGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE
         BAL   R14,PUTGET          GET A LINE OF COMMAND INPUT
         TM    D0FLAGS,D0SUBER     IF A PUTGET ERROR OCCURRED,
         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE
         CH    R15,=H'40'          IF BARRIER HIT,
         BE    ENDCMDS             then no more command
******** B     PUTGETOK            else process command
         SPACE 1
PUTGETOK DS    0H
         CLI   D0STATUS,D0ATTN     IF ATTENTION INTERRUPT OCCURRED,
         BNE   PGNOATTN            THEN
         LA    R1,FLUSHTOP          FLUSH THE STACK (EVEN IF
         BAL   R14,FLUSH             CONTROL NOFLUSH IS ACTIVE)
         B     PROCXC               AND CONTINUE
         SPACE
PGNOATTN DS    0H                  ELSE GO AHEAD AND PROCESS THIS LINE
         ST    R5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS
         XC    D0OFFSET,D0OFFSET   SET COMMAND BUFFER OFFSET TO ZERO
         LR    R1,R5               POINT TO THE COMMAND BUFFER
         BAL   R14,SCAN            SCAN NEXT OPERAND OF THE COMMAND
         B     GOSCANX(R15)        BRANCH BASED ON RETURN CODE
GOSCANX  B     SCANX0              RC=0 - VALID COMMAND NAME
         B     PROCXC              RC=4 - NO COMMAND NAME
         B     SCANX8              RC=8 - INVALID COMMAND NAME
         LH    R15,D0SCANRC        RC=12 - SCAN ERROR
         LA    R1,=C'SCAN'          IN WHICH CASE, BLOW UP
         LA    R0,4
         B     ERROR
         SPACE
SCANX8   DS    0H                  COMMAND IS SYNTACTICALLY INVALID
         LA    R1,SYNMSG
         LA    R0,L'SYNMSG
         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK
         B     PROCXC
         SPACE
SCANX0   DS    0H                  COMMAND IS SYNTACTICALLY OK
         BAL   R14,CKCMD           CHECK VALIDITY OF COMMAND
         LTR   R15,R15             IF COMMAN IS NOT VALID,
         BNZ   PROCXC              THEN CONTINUE WITH THE NEXT ONE
         BAL   R14,ATTACH          ELSE INVOKE THE COMMAND
         TM    D0FLAGS,D0SUBER     IF SUBROUTINE ERROR,
         BO    ERROR               THEN GO TO DISPLAY MESSAGE
         B     PROCXC              ELSE GO TO GET THE NEXT COMMAND
         SPACE 2
BADPG    LA    R1,=C'PUTGET'       FATAL PUTGET ERROR
         LA    R0,6
         B     ERROR
         EJECT
ENDCMDS  DS    0H                  NO MORE COMMANDS TO PROCESS
         XR    R15,R15
         ICM   R15,7,ECTRTCD       PICK UP RETURN CODE FROM ECT
         ST    R15,D0RETCD         SAVE THE RETURN CODE
         SPACE
***********************************************************************
* AT THIS POINT, TO INSURE CORRECT COMMAND STATISTICAL RECORDING, WE  *
* DO VARIOUS STUFF FOR TSO/MON.  SINCE TSO/MON IS NOT INSTALLED AT    *
* DRAPER, I HAVE OMITTED THIS CODE, BUT MAY ADD SVC109 INTERFACE SOON.*
***********************************************************************
         SPACE
         B     RETURN              RETURN TO CALLING PROGRAM
         EJECT
ERROR    DS    0H                  DISPLAY ERROR MESSAGE AND END
         SPACE
***********************************************************************
* MISCELLANEOUS ERROR DISPLAY.                                        *
* R0 CONTAINS LENGTH OF NAME OF FUNCTION THAT FAILED                  *
* R1 CONTAINS ADDRESS OF NAME OF FUNCTION THAT FAILED                 *
* R15 CONTAINS RETURN CODE FROM FAILED FUNCTION                       *
***********************************************************************
         SPACE
         MVC   D0MSG(L'ERRMSG1),ERRMSG1  SET UP FIRST PART OF MESSAGE
         LTR   R14,R0              GET LENGTH OF FUNCTION TYPE
         BNP   AFTFUNC             IF NONE, BYPASS
         BCTR  R14,0               ELSE REDUCE LENGTH FOR EXECUTE
         EX    R14,MOVEFUNC        MOVE FUNCTION NAME TO ERROR MESSAGE
AFTFUNC  LA    R1,D0MSG+L'ERRMSG1+1(R14)  POINT TO NEXT PART OF MESSAGE
         MVC   0(L'ERRMSG2,R1),ERRMSG2    SET UP SECOND PART OF MESSAGE
         CVD   R15,D0DOUBLE               CONVERT ERROR CODE TO DISPLAY
         UNPK  L'ERRMSG2(2,R1),D0DOUBLE
         OI    L'ERRMSG2+1(R1),X'F0'
         LA    R0,L'ERRMSG1+L'ERRMSG2+3(R14)  GET LENGTH OF MSG IN R0
         XR    R1,R1               INDICATE MESSAGE ALREADY IN WORKAREA
         BAL   R14,PUTLINE         DISPLAY THE MESSAGE
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           FLUSH THE INPUT STACK
         B     RETURN              RETURN TO CALLING PROGRAM
         SPACE
ERRMSG1  DC    C'XTS00006 XCLIST/XTSEXEC FAILED, '
ERRMSG2  DC    C' ERROR CODE '
         SPACE
MOVEFUNC MVC   D0MSG+L'ERRMSG1(0),0(R1)  MOVE FUNCTION TO ERROR MESSAGE
         TITLE 'XTSEXEC - SCAN SUBROUTINE'
***********************************************************************
* THE SCAN SUBROUTINE INVOKES THE IKJSCAN TSO SERVICE ROUTINE TO      *
* DETERMINE THE NATURE OF THE NEXT OPERAND IN THE XTSEXEC COMMAND     *
* BUFFER.  ON ENTRY R1 CONTAINS THE ADDRESS OF THE COMMAND BUFFER TO  *
* BE SCANNED.  ON RETURN THE FIELD D0COMMND CONTAINS THE OPERAND,     *
* BLANK PADDED AND JUSTIFIED LEFT, UNLESS THE OPERAND IS MISSING OR   *
* SYNTACTICALLY INVALID.  R15 IS SET TO ZERO IF THE OPERAND IS A      *
* SYNTACTICALLY VALID COMMAND NAME, 4 IF IT IS MISSING, 8 IF IT IS    *
* SYNTACTICALLY INVALID, 12 IF AN ERROR RETURN CODE IS PASSED BACK    *
* FROM IKJSCAN.  IF THE OPERAND WAS PRECEDED BY A PERCENT SIGN (%),   *
* THE FLAG D0EXEC IS SET ON; OTHERWISE IT IS SET OFF.  IF THERE ARE   *
* NO FURTHER OPERANDS IN THE XTSEXEC COMMAND BUFFER FOLLOWING THE     *
* CURRENT ONE, THE ECTNOPD FLAG IN THE ECT IS SET ON.                 *
***********************************************************************
         SPACE
SCAN     DS    0H
         ST    R14,D0SCAN14        SAVE RETURN REGISTER
         MVI   D0COMMND,C' '       SET COMMAND NAME FIELD TO BLANKS
         MVC   D0COMMND+1(7),D0COMMND
         NI    D0FLAGS,255-D0EXEC  ASSUME NOT AN IMPLICIT EXEC FOR NOW
         NI    ECTSWS,255-ECTNOPD  SET ECT NO-OPERANDS BIT OFF
         ST    R1,CSPLCBUF         SET COMMAND BUFFER ADDRESS FROM PARM
         XC    D0ECB,D0ECB         CLEAR ECB
         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  CALL IKJSCAN TO SCAN BUFFER
         STH   R15,D0SCANRC        SAVE IKJSCAN RETURN CODE
         LTR   R15,R15             IF SCAN FAILED,
         BZ    SCANOK              THEN...
         LA    R15,12               INDICATE SCAN FAILURE
         B     SCANRET              AND RETURN. ELSE...
SCANOK   DS    0H                  CHECK RESULTS OF SCAN
         TM    CSOAFLG,CSOAQM+CSOABAD IF ANY SYNTAX ERROR
         BNZ   SCANBAD             THEN RETURN INDICATING BAD SYNTAX
         TM    CSOAFLG,CSOANOC     IF NO COMMAND NAME WAS FOUND,
         BNO   NOTNOC              THEN...
         OI    ECTSWS,ECTNOPD       INDICATE ECT NO OPERANDS
         LA    R15,4                RETURN INDICATING NOTHING FOUND
         B     SCANRET             ELSE...
NOTNOC   DS    0H                  (AN OPERAND EXISTS)
         LH    R1,CSOALNM          PICK UP LENGTH OF OPERAND
         LTR   R1,R1               IF LENGTH IS ZERO,
         BNP   SCANBAD             THEN...
         L     R15,CSOACNM         GET ADDRESS OF OPERAND
         BCTR  R1,0                REDUCE OPERAND LENGTH FOR EXECUTE
         EX    R1,MOVECMD          MOVE OPERAND TO COMMAND NAME AREA
         XR    R15,R15             INDICATE VALID COMMAND NAME
         TM    CSOAFLG,CSOAEXEC    IF COMMAND PRECEDED BY % SIGN,
         BZ    *+8                 THEN...
         OI    D0FLAGS,D0EXEC       INDICATE IMPLICIT EXEC
         TM    CSOAFLG,CSOAVNP     IF THERE ARE NO FURTHER OPERANDS,
         BNO   *+8                 THEN...
         OI    ECTSWS,ECTNOPD       SAY SO IN ECT
         B     SCANRET             RETURN
SCANBAD  DS    0H                  SYNTAX ERROR
         LA    R15,8               RETURN INDICATING BAD SYNTAX
******** B     SCANRET
SCANRET  L     R14,D0SCAN14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE 2
MOVECMD  MVC   D0COMMND(0),0(R15)  MOVE COMMAND NAME TO NAME AREA
         SPACE
         LTORG
         TITLE 'XTSEXEC - CKCMD SUBROUTINE'
CKCMD    DS    0H
         SPACE
         ST    R14,D0CKCM14        SAVE RETURN REGISTER
         NI    D0FLAGS,255-D0SUBER TURN OFF ERROR INDICATOR
         NI    D0FLAGS,255-D0AUTH  Also assume not APF authorized
         TM    D0FLAGS,D0EXEC      IF IMPLICIT %CLIST,
         BO    IMPLICIT            THEN PROCESS AS ONE. ELSE...
******** CLC   D0COMMND(5),=CL5'TEST '     IF COMMAND = TEST
******** BE    NGCMD                       THEN REJECT
         CLC   D0COMMND(8),=CL8'ISPEXEC '  IF COMMAND = ISPEXEC
         BE    NGCMD                       THEN REJECT
*
******** BE    PROCESS_ISPEXEC_COMMAND future enhancement...
*
         MVC   D0MODULE,D0COMMND   ELSE SET COMMAND NAME = SAME NAME
         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED
         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME
         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS
         MVC   ECTSCMD+1(7),ECTSCMD
         CLC   =C'TIME ',D0MODULE  IF COMMAND = TIME
         BNE   NOTTIME             THEN
         MVC   D0MODULE,=CL8'IKJEFT25' SET MODULE NAME = IKJEFT25
         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING
NOTTIME  CLC   =C'CALL ',D0MODULE  IF COMMAND = CALL
         BNE   NOTCALL             THEN
******** MVC   D0MODULE,=CL8'ISPCALL ' SET MODULE NAME = ISPCALL
         MVC   D0MODULE,=CL8'IKJEFG00' SET MODULE NAME = IKJEFG00
         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING
NOTCALL  CLC   =C'TEST ',D0MODULE  If command = TEST
         BNE   NOTTEST             then
         OI    D0FLAGS,D0AUTH       indicate APF authorization required
         B     TSEVENT              and process without searching.
NOTTEST  DS    0H
         SPACE
         SPACE 1
***********************************************************************
*                                                                     *
* Before searching for the command, search the table of authorized    *
* TSO commands to see if it requires APF authorization.  If it does,  *
* indicate so.  We will still have to search for it.                  *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R15,D0E2ADDR        Get address of IKJEFTE2
         LA    R1,16(,R15)         Point to first entry
E2LOOP   DS    0H                  Loop
         CLI   0(R1),C' '           until blank entry found
         BE    NOTAUTH              at which point it's not authorized
         CLC   0(8,R1),D0MODULE     but if we found the module name
         BE    NEEDAUTH             then mark it authorized
         LA    R1,8(,R1)            else bump to next entry
         B     E2LOOP               and continue.
NEEDAUTH DS    0H                  Here if module is in E2 table
         OI    D0FLAGS,D0AUTH      Indicate APF authorization required
*
* ... we should probably bypass the search - TSO service'll do it NEhow
*
NOTAUTH  DS    0H                  Here if module is not authorized
         SPACE 1
***********************************************************************
* NOTE: AT THIS POINT IT IS POSSIBLE TO INSERT SOME ALTERNATE COMMAND *
* VALIDATION CODE SUCH AS AN ACF2 COMMAND VALIDATION SVC.  HOWEVER,   *
* WE WILL EMULATE THE TMP AND ISPF COMMAND SEARCH CODE INSTEAD.       *
***********************************************************************
         SPACE
         DROP  R12,R9              (temporary base reg suppression)
         STM   R3,R9,32(R13)       SAVE REGISTERS USED BY LPA SEARCH
         LM    R0,R1,D0MODULE      LOAD COMMAND NAME INTO PARM REGS
         L     R3,16               R3 = CVT ADDRESS
         L     R15,X'160'(,R3)     R15 -> LPA DIRECTORY SEARCH ROUTINE
         BALR  R14,R15             CALL LPA DIRECTORY SEARCH
***********************************************************************
* IF THE COMMAND NAME IS FOUND IN THE LPA DIRECTORY, CONTROL RETURNS  *
* TO THE NEXT SEQUENTIAL INSTRUCTION AND R14 IS SET TO ZERO.  IF THE  *
* COMMAND NAME HAS NOT BEEN FOUND, CONTROL RETURNS TO THE INSTRUCTION *
* AT +4 PAST HERE AND R14 IS NONZERO.                                 *
***********************************************************************
         LA    R14,0               IF SUCCESSFUL, SET R14 = 0
         LM    R3,R9,32(R13)       RESTORE REGISTERS USED BY LPA SEARCH
         USING XTSEXEC,R12,R9      (restore addressability)
         LTR   R14,R14             IF COMMAND NAME WAS FOUND,
         BZ    TSEVENT             THEN GO AHEAD AND USE IT. ELSE...
         LA    R0,D0MODULE         SET EPLOC PARAMETER FOR IDENTIFY
         XR    R1,R1               SET ENTRY ADDRESS PARM FOR IDENTIFY
         IDENTIFY ENTRY=(1),EPLOC=(0) SEE IF ENTRY NAME IS AROUND
         CH    R15,=H'8'           IF RC=8, COMMAND IS IN JPA
         BE    TSEVENT             SO GO USE IT
         CH    R15,=H'20'          IF RC=20, COMMAND IS IN JPA
         BE    TSEVENT             SO GO USE IT
         BLDL  0,D0BLDL            IF NONE OF THE ABOVE, TRY BLDL
         LTR   R15,R15             SEE IF BLDL SUCCESSFUL
         BZ    TSEVENT             IF BLDL SUCCESSFUL, IT IS A COMMAND
******** BNZ   IMPLICIT            IF BLDL FAILED, IT MUST BE A CLIST
         SPACE
IMPLICIT DS    0H                  LOAD MODULE NOT FOUND, MUST BE CLIST
         MVC   D0MODULE,=CL8'EXEC' SET COMMAND NAME = "EXEC"
         NI    D0FLAGS,255-D0AUTH  Show not APF authorized after all
         LH    R15,D0OFFSET        PICK UP OFFSET OF CLIST NAME
         LTR   R15,R15             IF ZERO OFFSET, THEN IGNORE
         BNP   AFTBLNKX
         BCTR  R15,0               REDUCE FOR EXECUTE
         BCTR  R15,0               AND FOR MOVE CHARACTERS
         MVI   4(R5),C' '          SET BUFFER PRECEDING CLIST NAME
         EX    R15,MVCBLANK         TO BLANKS
AFTBLNKX XC    2(2,R5),2(R5)       SET COMMAND BUFFER OFFSET = ZERO
         OI    D0FLAGS,D0ECTMOD    INDICATE ECT HAS BEEN CHANGED
         MVC   ECTPCMD,D0MODULE    SET UP ECT COMMAND NAME
         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS
         MVC   ECTSCMD+1(7),ECTSCMD
         SPACE
TSEVENT  DS    0H                  NOW WE ARE READY TO ISSUE COMMAND
         SPACE
***********************************************************************
* ISSUE TSVENT (SYSEVENT 0) TO TELL SYSTEM ABOUT COMMAND.             *
* NOTE: SVC 109 INTERFACE IS A POSSIBILITY HERE. HOWEVER, EXISTING    *
* TSO MONITORING PRODUCTS USE THE SVC 95 INTERFACE ONLY, EVEN THOUGH  *
* THE SVC 109 INTERFACE IS PARTICULARLY SUITED FOR APPLICATIONS SUCH  *
* AS THIS ROUTINE WHICH CREATE STACKS OF NESTED COMMAND INVOCATIONS.  *
***********************************************************************
         SPACE
         L     R1,ECTPCMD
         L     R15,ECTPCMD+4
         TSEVENT PPMODE            TELL SRM ABOUT THE COMMAND
         XR    R15,R15             INDICATE COMMAND IS OK
         B     CKCMDRET            AND RETURN
         SPACE
NGCMD    DS    0H                  COMMAND NOT VALID (TEST, ETC.)
         MVC   D0MSG(L'TESTMSG1),TESTMSG1  MOVE BEGINNING OF MESSAGE
         MVC   D0MSG+L'TESTMSG1(8),D0COMMND  MOVE IN COMMAND NAME
         LA    R1,D0MSG+L'TESTMSG1 POINT TO BEGINNING OF NAME
         LA    R14,8               MAX COUNT FOR NAME LENGTH
NGLOOP   CLI   0(R1),C' '          SCAN FOR FIRST BLANK
         BE    NGBLANK              FOLLOWING COMMAND NAME
         LA    R1,1(,R1)             UNTIL
         BCT   R14,NGLOOP             LENGTH OF NAME EXHAUSTED
NGBLANK  DS    0H
         MVC   0(L'TESTMSG2,R1),TESTMSG2  MOVE END OF MESSAGE
         LA    R0,L'TESTMSG2(,R1)  END OF MESSAGE
         LA    R14,D0MSG           MINUS BEGINNING OF MESSAGE
         SLR   R0,R14              GIVES LENGTH OF MESSAGE
         XR    R1,R1               INDICATE MESSAGE ALREADY BUILT
         BAL   R14,PUTLINE         DISPLAY ERROR MESSAGE
         LA    R1,12               SET ECT RETURN CODE TO 12
         STCM  R1,7,ECTRTCD        AS IF COMMAND NOT FOUND
         LA    R1,FLUSHALL
         BAL   R14,FLUSH           AND FLUSH THE INPUT STACK
         LA    R15,8               INDICATE COMMAND INVALID
CKCMDRET L     R14,D0CKCM14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
MVCBLANK MVC   5(0,R5),4(R5)       FINISH MOVING BLANKS INTO CMD BUFFER
         SPACE
TESTMSG1 DC    C'XTS00002 XCLIST/XTSEXEC DOES NOT SUPPORT THE '
TESTMSG2 DC    C' COMMAND'
         SPACE
         LTORG
         TITLE 'XTSEXEC - ATTACH SUBROUTINE'
ATTACH   DS    0H
         SPACE
***********************************************************************
*                                                                     *
* This subroutine does one of the following:                          *
*                                                                     *
* (1) If the command requires APF authorization, invokes the TSO      *
*     Authorized Service Facility to invoke it.                       *
* (2) Otherwise, attaches the command as a subtask directly.          *
*                                                                     *
***********************************************************************
         SPACE
         ST    R14,D0ATT14         SAVE RETURN REGISTER
         SPACE
         TM    D0FLAGS,D0AUTH      If command requires authorization
         BO    ATTTSF              then go invoke TSO service facility
         SPACE
         XC    D0CMDECB,D0CMDECB   CLEAR ATTACH ECB
         XC    D0ATNECB,D0ATNECB   CLEAR ATTENTION ECB
         NI    D0FLAGS,255-D0SUBER CLEAR ERROR FLAG
         MVI   D0STATUS,D0NORMAL   CLEAR COMMAND STATUS FLAG
         NI    ECTSWS2,255-ECTNOQPR ENABLE "? PROMPT HELP"
         LA    R1,CPPL             POINT TO CPPL
         ATTACH EPLOC=D0MODULE,SF=(E,D0ATTACH),ECB=D0CMDECB,           X
               ESTAI=(STAIEXIT,DATD0) ATTACH THE COMMAND
         LTR   R15,R15             IF ATTACH FAILED,
         BZ    ATTACHOK            THEN
         LA    R1,=C'ATTACH'        BLOW UP
         LA    R0,6
         OI    D0FLAGS,D0SUBER
         B     ATTRET
ATTACHOK DS    0H
         LR    R2,R1               SAVE TCB ADDRESS
         USING TCB,R2
         WAIT  1,ECBLIST=D0ECBLST  WAIT FOR COMPLETION OR ATTENTION
         MVC   ECTRTCD,TCBCMPC     MOVE TCB COMPLETION CODE TO ECT
         MVI   ECTRCDF,0           INIT ECT CP = NOT ABENDED
         ST    R2,DA2CTCB          SAVE TCB ADDRESS FOR DAIR
         XC    D0ECB,D0ECB         CLEAR ECB
         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)  MARK DATA SETS NOT IN USE
         ST    R15,D0DAIRRC        SAVE DAIR RETURN CODE
         OI    D0FLAGS,D0DETACH    INDICATE DETACH IN PROGRESS
         LA    R1,DA2CTCB          POINT TO TCB ADDRESS
         DETACH (1),STAE=YES       DETACH THE COMMAND
         NI    D0FLAGS,255-D0DETACH INDICATE DETACH NOT IN PROGRESS
         CH    R15,=H'4'           IF DETACH FAILED,
         BNH   DETACHOK
         LA    R1,=C'DETACH'        BLOW UP
         LA    R0,6
         OI    D0FLAGS,D0SUBER
         B     ATTRET
         DROP  R2
DETACHOK DS    0H                  NOW, CHECK DAIRRC AFTER DETACH
         ICM   R15,15,D0DAIRRC     IF DAIR RETURN CODE NOT ZERO,
         BZ    DAIROK              THEN...
         LA    R1,=C'DAIR'          BLOW UP
         LA    R0,4
         OI    D0FLAGS,D0SUBER
         B     ATTRET
DAIROK   DS    0H
         SPACE
         CLI   D0STATUS,D0ATTN     IF COMMAND TERMINATED BY ATTENTION,
         BE    ATTFLUSH            THEN FLUSH THE INPUT STACK
         CLI   D0STATUS,D0ABEND    ELSE IF THE COMMAND ABENDED,
         BNE   ATTRET              THEN
ABFLUSH  OI    ECTRCDF,X'80'        INDICATE CP ABENDED IN ECT
         LA    R1,FLUSHALL          FOR ABEND, DO NORMAL STACK FLUSH
         B     FLUSHCMD             AND FLUSH THE INPUT STACK.
ATTFLUSH LA    R1,FLUSHTOP         FOR ATTN, DO EVEN IF CONTROL=NOFLUSH
FLUSHCMD BAL   R14,FLUSH           FLUSH THE INPUT STACK
ATTRET   L     R14,D0ATT14         RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
ATTTSF   DS    0H                  Here if command is APF authorized
         SPACE
         XR    R0,R0               Make a zero
         ST    R0,D0TSFRC          Initialize TSO command return code
         ST    R0,D0TSFRS          Initialize TSO command reason code
         ST    R0,D0TSFAC          Initialize TSO command abend code
         LA    R1,TSFFLAGS         Point to flags
         ST    R1,D0TSFP1          Store parameter 1
         L     R2,CPPLCBUF         Get address of command buffer
         LA    R1,4(,R2)           Point to command buffer text
         ST    R1,D0TSFP2          Store parameter 2
         LH    R1,0(,R2)           Get length of command buffer
         SH    R1,=H'4'            Adjust length to length of text
         ST    R1,D0TSFLEN         Store length
         LA    R1,D0TSFLEN         Get address of length
         ST    R1,D0TSFP3          Store parameter 3
         LA    R1,D0TSFRC          Point to where to store return code
         ST    R1,D0TSFP4          Store parameter 4
         LA    R1,D0TSFRS          Point to where to store reason code
         ST    R1,D0TSFP5          Store parameter 5
         LA    R1,D0TSFAC          Point to where to store abend code
         ST    R1,D0TSFP6          Store parameter 6
         OI    D0TSFP6,X'80'       Set VL bit
         LA    R1,D0TSFP1          Point to parameter list
         L     R15,X'10'           Get address of CVT
         L     R15,CVTTVT-CVT(,R15) Get address of TSVT
         L     R15,TSVTASF-TSVT(,R15) Get address of IKJEFTSR
         BALR  R14,R15             Call IKJEFTSR
         SPACE
* OK, now process all those godawful return codes.  Who designed this!
         SPACE
         B     TSFRC(R15)          Branch depending on return code
TSFRC    B     TSFRC0              0 = OK
         B     TSFRC4              4 = nonzero return code from command
         B     TSFRC8              8 = attention interrupt
         B     TSFRC12             12 = abend
         B     TSFRC16             16 = parm address in protected stg.
         B     TSFRC20             20 = error in parameter list
         B     TSFRC24             24 = unexpected TSO failure
         B     TSFRC28             28 = AMODE 24 but parms are AMODE 31
         SPACE
TSFRC0   EQU   ATTRET              0 = OK
TSFRC4   EQU   ATTRET              4 = nonzero return code from command
         SPACE
TSFRC8   DS    0H                  8 = attention interrupt
         SPACE
         MVC   D0MSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE
         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   D0MSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE
         LA    R0,L'ATNMSGID+8+L'ATTNMSG    GET LENGTH OF ATTENTION MSG
         XR    R1,R1               INDICATE MESSAGE SET UP
         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE
         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE
         B     ATTFLUSH            Return to flush stack for attn & ret
         SPACE
TSFRC12  DS    0H                  12 = abend
         SPACE
         MVI   D0STATUS,D0ABEND    INDICATE COMMAND ABENDED
         MVC   D0ABCODE(3),D0TSFAC+1 STORE ABEND CODE
         SPACE
***********************************************************************
* DISPLAY "ENDED DUE TO ERROR" MESSAGE                                *
***********************************************************************
         SPACE
         MVC   D0MSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE
         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   D0MSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE
         CLC   D0ABCODE,=X'000FFF'          IF CODE GREATER THAN 4095
         BNH   TSFUSRAB                     THEN MUST BE A SYSTEM ABEND
         MVC   D0MSG2(6),=C'SYSTEM'         SO SAY SO
         MVC   D0MSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         UNPK  D0SYSTEM(3),D0ABCODE(2)      PUT ABEND CODE IN HEX IN
         MVZ   D0SYSTEM(3),=X'000000'
         TR    D0SYSTEM(3),=C'0123456789ABCDEF'
         LA    R0,D0SYSL                    GET LENGTH OF MESSAGE
         B     TSFANYAB                     GO TO DISPLAY IT
TSFUSRAB MVC   D0MSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND
         MVC   D0MSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         XR    R0,R0
         ICM   R0,7,D0ABCODE                GET NUMERIC USER ABEND CODE
         CVD   R0,D0DOUBLE                  CONVERT TO DISPLAY
         UNPK  D0USER(4),D0DOUBLE
         OI    D0USER+3,X'F0'
         LA    R0,D0USERL                   GET LENGTH OF MESSAGE
TSFANYAB DS    0H
         XR    R1,R1               INDICATE MESSAGE SET UP
         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE
         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE
         B     ABFLUSH
TSFRC16  DS    0H                  16 = parm address in protected stg.
TSFRC20  DS    0H                  20 = error in parameter list
TSFRC24  DS    0H                  24 = unexpected TSO failure
TSFRC28  DS    0H                  28 = AMODE 24 but parms are AMODE 31
         ABEND (15),DUMP           Abend for now...
         SPACE
TSFFLAGS DS    0F                  First parm to IKJEFTSR (flags)
         DC    X'0000'             First 2 bytes must be zeroes
         DC    X'01'               Take a dump in case of ABEND
         DC    X'01'               Invoke as command, not as CLIST
*                                  (so stacked commands are handled
*                                   by us instead of IKJEFTSR)
         TITLE 'XTSEXEC - PUTGET SUBROUTINE'
***********************************************************************
* THIS SUBROUTINE ISSUES A PUTGET MACRO INSTRUCTION TO DISPLAY A MODE *
* MESSAGE (WHERE APPROPRIATE) AND RETRIEVE A COMMAND LINE FROM THE    *
* CURRENT SOURCE OF INPUT.  IF THE PUTGET RETURNS WITH A CODE OF 12   *
* (MEANING THAT A SECOND-LEVEL MESSAGE CHAIN IS AVAILABLE BUT THE     *
* USER IS IN A CLIST AND THE "NOPAUSE" PROFILE OPTION IS ACTIVE), IT  *
* IS RETRIED AFTER SETTING THE BIT IN THE ECT WHICH PURGES            *
* SECOND-LEVEL MESSAGES.  IF IT RETURNS WITH A CODE OF 24 (INVALID    *
* PARAMETERS), CONTROL IS RETURNED WITHOUT AN ERROR INDICATION - THIS *
* IS USED TO DETERMINE IF A CLIST HAS TERMINATED.  THIS "TRICK" WAS   *
* USED IN ISPF MODULE ISPCAT TO DETERMINE THE END OF A CLIST.         *
*                                                                     *
* UPON RETURN, R5 CONTAINS THE ADDRESS OF THE INPUT BUFFER RETURNED   *
* BY PUTGET IF THE RETURN CODE IS 0 OR 4, ELSE R5 CONTAINS ZERO.      *
*                                                                     *
***********************************************************************
         SPACE
PUTGET   DS    0H
         ST    R14,D0PG14          SAVE RETURN REGISTER
PGRETRY  DS    0H
         MVI   D0STATUS,D0NORMAL   CLEAR COMMAND STATUS FLAG
         XR    R5,R5               SET PUTGET BUFFER ADDRESS TO ZERO
         ST    R5,D0ECB            CLEAR ECB
         PUTGET PARM=PGPB,MF=(E,IOPL)  ISSUE PUTGET
         CH    R15,=H'24'          IF RETURN CODE GREATER THAN 24,
         BH    PGERROR              THEN BLOW UP
         B     PGGO(R15)           ELSE PROCESS EACH POSSIBLE R.C.
PGGO     B     PGGOTLN         0 = LINE CAME FROM TERMINAL
         B     PGGOTLN         4 = LINE CAME FROM IN-STORAGE LIST
         B     PUTGET8         8 = ATTENTION INTERRUPTION
         B     PUTGET12       12 = NO LINE DUE TO SECOND-LEVEL MESSAGE
         B     PGERROR        16 = ERROR
         B     PGERROR        20 = ERROR
         B     PGRETURN       24 = BAD MODE MESSAGE - TERMINAL INPUT
         SPACE
PUTGET8  MVI   D0STATUS,D0ATTN     RC=8: INDICATE ATTENTION INTERRUPT
         B     PGRETURN              AND RETURN
PUTGET12 TM    ECTMSGF,X'80'       RC=12: IF 2ND-LVL MSGS ALRDY PURGED,
         BO    PGERROR                    THEN UNRECOVERABLE ERROR
         OI    ECTMSGF,X'80'         ELSE PURGE 2ND-LEVEL MESSAGE CHAIN
         B     PGRETRY                AND REISSUE PUTGET
PGERROR  DS    0H                  BAD RETURN CODE?
         CH    R15,=H'40'          If RC = 40 (SUBSTACK found barrier)
         BE    PGRETURN            then return OK, caller will handle
         OI    D0FLAGS,D0SUBER     Else bad RC, unrecoverable error
         B     PGRETURN            SO JUST RETURN.
PGGOTLN  L     R5,PGPBIBUF         GET ADDRESS OF PUTGET INPUT BUFFER
PGRETURN L     R14,D0PG14          RESTORE RETURN REGISTER
         BR    R14                 RETURN
         TITLE 'XTSEXEC - PUTLINE SUBROUTINE'
***********************************************************************
* THIS ROUTINE DISPLAYS MESSAGES TO THE TSO USER USING THE TSO        *
* PUTLINE SERVICE ROUTINE.  AT ENTRY R1 CONTAINS THE ADDRESS OF THE   *
* MESSAGE TO BE DISPLAYED, AND R0 CONTAINS THE LENGTH OF THE MESSAGE. *
* IF R1 IS ZERO, THE MESSAGE HAS ALREADY BEEN BUILT IN THE WORKAREA   *
* D0MSG.  THE MESSAGE IS ASSUMED TO BEGIN WITH A MESSAGE ID UNLESS    *
* THE FIRST CHARACTER IS BLANK, IN WHICH CASE THE INITIAL BLANK IS    *
* STRIPPED OFF BY PUTLINE ANYHOW.                                     *
* NOTE THAT THIS SUBROUTINE ESTABLISHES ITS OWN BASE REGISTER.  THIS  *
* IS BECAUSE THIS SUBROUTINE IS REFERENCED BY INTERCEPT ROUTINES      *
* WHERE THE NORMAL BASE REGISTER IS UNAVAILABLE.                      *
***********************************************************************
         SPACE
PUTLINE  DS    0H
         ST    R14,D0PUTL14        SAVE RETURN REGISTER
         BALR  R8,0                SET UP LOCAL ADDRESSABILITY
         USING *,R8
         DROP  R12,R9
         LTR   R15,R0              LOAD LENGTH VALUE
         BZ    PUTLRET             IF ZERO, DON'T DO ANYTHING
         BM    PUTLCMD             If negative, displaying command buf
         BCTR  R15,0               ELSE REDUCE LENGTH FOR EXECUTE
         LTR   R1,R1               IF R1 IS ZERO,
         BZ    PUTIT               THEN MESSAGE ALREADY SET UP. ELSE...
         EX    R15,MOVEPUT         MOVE MESSAGE TO WORK AREA
         B     PUTIT               Go to it
PUTLCMD  DS    0H                  Here to display a command
         LCR   R15,R15             Make length positive again
         MVI   D0MSG,C' '          Blank to stop message ID stripping
         CH    R15,=Y(L'D0MSG-1)   To maximum length
         BNH   PUTLMC
         MVC   D0MSG+1(L'D0MSG-1),0(R1) Move most of command to W/A
         MVC   D0MSG+L'D0MSG-3(3),=CL3'...'  Ellipsis
         LA    R15,L'D0MSG-1-1+1   Add 1 for initial blank
         B     PUTIT               Go do it
PUTLMC   DS    0H                  Else
         BCTR  R15,0               Reduce length for execute
         EX    R15,MOVEPUTC        Move command to work area
         LA    R15,1(,R15)         Add 1 for initial blank
******** B     PUTIT               Go do it
PUTIT    DS    0H
         LA    R15,5(,R15)         RESTORE LENGTH + 4 FOR HEADER
         SLL   R15,16              SHIFT LENGTH INTO LEFT HALF OF HDR
         STCM  R15,15,D0MSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR
         XC    D0ECB,D0ECB         CLEAR ECB
         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE
         LTR   R15,R15             IF PUTLINE OK
         BZ    PUTLRET             THEN RETURN
         CH    R15,=H'8'           ELSE IF ATTENTION INTERRUPT
         BNE   PUTERROR            THEN
         MVI   D0STATUS,D0ATTN      INDICATE SO
         B     PUTLRET             ELSE PUTLINE ERROR
PUTERROR DS    0H
         MVC   D0MSGBUF(L'BADPUT),BADPUT  Move message to 24-bit stg
         LA    R1,D0MSGBUF
         LA    R0,L'D0MSGBUF
         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT
******** B     PUTLRET
PUTLRET  L     R14,D0PUTL14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
MOVEPUT  MVC   D0MSG(0),0(R1)      MOVE MESSAGE TO WORK AREA
MOVEPUTC MVC   D0MSG+1(0),0(R1)    MOVE COMMAND TO WORK AREA
BADPUT   DC    C'*** XTS00008: XCLIST/XTSEXEC PUTLINE FAILURE ***'
         SPACE
         LTORG
         SPACE
         USING XTSEXEC,R12,R9
         DROP  R8
         TITLE 'XTSEXEC - FLUSH SUBROUTINE'
***********************************************************************
* THIS ROUTINE DELETES ELEMENTS FROM THE INPUT STACK.  IT IS USED     *
* WHEN AN ERROR OCCURS THAT WOULD REQUIRE THAT NO MORE COMMANDS IN A  *
* CLIST BE EXECUTED.  IT ALSO CLEARS THE TERMINAL INPUT QUEUE SO THAT *
* ADDITIONAL COMMANDS "STACKED" WITH FIELD MARKS ARE NOT EXECUTED.    *
* ON ENTRY TO THIS SUBROUTINE R1 POINTS TO THE LIST FORM OF THE STACK *
* MACRO INSTRUCTION TO BE EXECUTED.  NORMALLY STACK DELETE=ALL WILL   *
* BE USED; THIS FLUSHES ALL ELEMENTS FROM THE STACK EXCEPT (1) THE    *
* BOTTOM ELEMENT, (2) ANY CLISTS WHICH HAVE CONTROL NOFLUSH OR        *
* CONTROL MAIN ACTIVE.  FOR ATTENTION-PROVOKED FLUSHES, WE USE STACK  *
* DELETE=TOP.  THIS DELETES THE TOP ELEMENT FROM THE STACK UNLESS IT  *
* IS A CLIST WITH CONTROL MAIN ACTIVE.                                *
***********************************************************************
         SPACE
FLUSH    DS    0H
         ST    R14,D0FLSH14        SAVE RETURN REGISTER
         MVC   D0STACK(STKINITL),0(R1) SET UP STACK LIST FORM
         TCLEARQ INPUT             CLEAR TERMINAL INPUT QUEUE
         XC    D0ECB,D0ECB         CLEAR ECB
         STACK PARM=D0STACK,MF=(E,IOPL)  FLUSH THE STACK
         LTR   R15,R15             IF STACK FAILED
         BZ    FLUSHRET            THEN SAY SO
         LA    R1,BADSTACK
         LA    R0,L'BADSTACK
         BAL   R14,PUTLINE
FLUSHRET LA    R14,12              SET RETURN CODE TO 12 WHEN FLUSHING
         ST    R14,D0RETCD
         L     R14,D0FLSH14        RESTORE RETURN REGISTER
         BR    R14                 RETURN
         SPACE
         LTORG
         SPACE
         DROP  R11,R12,R9
         TITLE 'XTSEXEC - STAI EXIT FOR ABENDING COMMANDS'
STAIEXIT DS    0H
         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER
         USING STAIEXIT,R12
         LA    R3,12               CHECK IF REGISTER 0 = "12"
         CR    R0,R3               IF AN SDWA IS AVAILABLE,
         BE    NOSDWA              THEN...
         LM    R10,R11,0(R1)        R10 -> WORKAREA, R11 = ABEND CODE
         B     AFTSDWA             ELSE...
NOSDWA   LR    R10,R2               R10 -> WORKAREA
         LR    R11,R1               R11 = ABEND COMPLETION CODE
         XR    R1,R1                Clear SDWA address - ain't none
AFTSDWA  DS    0H
         ST    R1,D0SDWA           Save address of SDWA
         ST    R14,D0STAI14        SAVE RETURN REGISTER
         L     R4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT
         TM    D0FLAGS,D0DETACH    IF DETACH IN PROGRESS
         BZ    NOT33E               AND
         CLM   R11,7,=X'33E000'      ABEND CODE IS S33E
         BNE   NOT33E                 THEN...
         MVC   D0MSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE
         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   D0MSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE
         LA    R0,L'ATNMSGID+8+L'ATTNMSG    GET LENGTH OF ATTENTION MSG
         B     ANYABEND                GO TO DISPLAY THE MESSAGE
NOT33E   DS    0H
         MVI   D0STATUS,D0ABEND    INDICATE COMMAND ABENDED
         STCM  R11,7,D0ABCODE      STORE ABEND CODE
         SPACE
***********************************************************************
* DISPLAY "ENDED DUE TO ERROR" MESSAGE                                *
***********************************************************************
         SPACE
         MVC   D0MSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE
         MVC   D0MSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE
         MVC   D0MSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE
         CLC   D0ABCODE,=X'000FFF'          IF CODE GREATER THAN 4095
         BNH   USRABEND                     THEN MUST BE A SYSTEM ABEND
         MVC   D0MSG2(6),=C'SYSTEM'         SO SAY SO
         MVC   D0MSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         UNPK  D0SYSTEM(3),D0ABCODE(2)      PUT ABEND CODE IN HEX IN
         MVZ   D0SYSTEM(3),=X'000000'
         TR    D0SYSTEM(3),=C'0123456789ABCDEF'
         LA    R0,D0SYSL                    GET LENGTH OF MESSAGE
         B     ANYABEND                     GO TO DISPLAY IT
USRABEND MVC   D0MSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND
         MVC   D0MSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE
         XR    R0,R0
         ICM   R0,7,D0ABCODE                GET NUMERIC USER ABEND CODE
         CVD   R0,D0DOUBLE                  CONVERT TO DISPLAY
         UNPK  D0USER(4),D0DOUBLE
         OI    D0USER+3,X'F0'
         LA    R0,D0USERL                   GET LENGTH OF MESSAGE
ANYABEND DS    0H
         XR    R1,R1               INDICATE MESSAGE SET UP
         L     R15,D0PLADDR        GET ADDRESS OF PUTLINE SUBROUTINE
         BALR  R14,R15             CALL IT TO DISPLAY THE MESSAGE
         L     R2,D0STAI14         Get return register
         LA    R15,16              Set return code in case no SDWA
         ICM   R3,15,D0SDWA        Get SDWA address
         BZR   R2                  If none, just branch back w/rc=16
         SETRP WKAREA=(R3),RC=16   Let ABEND continue without ESTAI
         BR    R2                  Return to caller
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XTSEXEC - STAE EXIT FOR INTERNAL ABEND'
STAEEXIT DS    0H
         LR    R12,R15             SAVE ENTRY ADDRESS REGISTER
         USING STAEEXIT,R12
         LA    R3,12               CHECK IF REGISTER 0 = "12"
         CR    R0,R3               IF AN SDWA IS AVAILABLE,
         BE    NOSDWAE             THEN...
         L     R10,0(,R1)           R10 -> WORKAREA
         B     AFTSDWAE            ELSE...
NOSDWAE  LR    R10,R2               R10 -> WORKAREA
AFTSDWAE DS    0H
         L     R4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT
         MVC   ECTIOWA(4),D0SVIOA  RESTORE ECT INPUT STACK ADDRESS
         MVC   ECTPCMD(16),D0CMDS  RESTORE ECT COMMAND/SUBCOMMAND NAMES
         XR    R15,R15             CONTINUE WITH ABNORMAL TERMINATION
         BR    R14                 AND RETURN
         SPACE
         LTORG
         SPACE
         DROP  R12
         TITLE 'XTSEXEC - STAX EXIT FOR ATTENTION INTERRUPT'
STAXEXIT DS    0H
         SPACE
         LR    R12,R15             SAVE ENTRY ADDRESS
         USING STAXEXIT,R12
         L     R10,8(,R1)          GET ADDRESS OF USER PARAMETER LIST
         LR    R9,R14              SAVE RETURN ADDRESS
         STATUS STOP               MAKE SUBTASK NONDISPATCHABLE
         MVI   D0STATUS,D0ATTN     INDICATE ATTENTION OCCURRED
         POST  D0ECB,0             POST SERVICE ROUTINES ECB
         POST  D0ATNECB,0          POST ECB FOR COMMAND ATTACH
         BR    R9                  RETURN TO SYSTEM
         SPACE
         LTORG
         SPACE
         DROP  R12
         EJECT
***********************************************************************
* MESSAGES                                                            *
***********************************************************************
         SPACE
NTSOMSG  WTO   MF=L,                                                   X
               ROUTCDE=11,          ISSUE WRITE TO PROGRAMMER MESSAGE  X
               'XTS00009 XCLIST/XTSEXEC ISSUED IN NON-TSO ENVIRONMENT'
NECTMSG  WTO   MF=L,                                                   X
               ROUTCDE=11,                                             X
               'XTS00010 Warning: The ECT addresses in the LWA (logon wX
               ork area) and the RLGB (relogon buffer) do not match.  XX
               CLIST is using the ECT address from the RLGB.'
RETYMSG  WTO   MF=L,                                                   X
               ROUTCDE=11,          ISSUE WRITE TO PROGRAMMER MESSAGE  X
               'XTS00011 XCLIST/XTSEXEC TERMINATION SEVERE ERROR'
         SPACE
SYNMSG   DC    C'XTS00001 INVALID COMMAND SYNTAX'
TERMMSG  DC    C'XTS00005 COMMAND INPUT IGNORED, CLIST HAS TERMINATED'
BADSTACK DC    C'XTS00007 XCLIST/XTSEXEC ERROR FLUSHING STACK'
         SPACE
ABEMSGID DC    C'XTS00003 '
ABEMSG1  DC    C' ENDED DUE TO ERROR, '
ABEMSG2  DC    C' ABEND CODE '
         SPACE
ATNMSGID DC    C'XTS00004 '
ATTNMSG  DC    C' TERMINATED BY ATTENTION INTERRUPTION'
         EJECT
         USING XTSEXEC,R12,R9
         USING DATD1,R11
         TITLE 'XTSEXEC - DATA AREAS'
DATD0    DSECT
         SPACE
D0SAVE   DS    9D                  OS SAVE AREA
D0DOUBLE DS    D                   FOR NUMERIC CONVERSIONS
D0SCAN14 DS    A                   SAVE AREA FOR SCAN SUBROUTINE
D0CKCM14 DS    A                   SAVE AREA FOR CKCMD SUBROUTINE
D0ATT14  DS    A                   SAVE AREA FOR ATTACH SUBROUTINE
D0PUTL14 DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE
D0PG14   DS    A                   SAVE AREA FOR PUTGET SUBROUTINE
D0FLSH14 DS    A                   SAVE AREA FOR FLUSH SUBROUTINE
D0STAI14 DS    A                   SAVE AREA FOR STAI EXIT ROUTINE
D0ECB    DS    F                   ECB FOR TSO SERVICE ROUTINES
D0CMDECB DS    F                   ECB FOR ATTACHED COMMANDS
D0ATNECB DS    F                   ECB FOR ATTENTION INTERRUPTIONS
D0ECBLST DS    2A                  ECB LIST
D0PLADDR DS    A                   ADDRESS OF PUTLINE SUBROUTINE
D0E2ADDR DS    A                   Address of IKJEFTE2
D0NSADDR DS    A                   Address of IKJEFTNS
D0SDWA   DS    A                   Address of SDWA
D0BADECT DS    A                   Address of possible bad model ECT
D0BADIOW DS    A                   Address of possible bad IOWA
         SPACE
CPPL     DS    0F                  COMMAND PROCESSOR PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJCPPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *
*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *
***********************************************************************
         SPACE
CPPLCBUF DS    A        PTR TO COMMAND BUFFER
CPPLUPT  DS    A        PTR TO UPT
CPPLPSCB DS    A        PTR TO PSCB
CPPLECT  DS    A        PTR TO ECT
         SPACE 2
IOPL     DS    0F                  I/O SERVICE ROUTINE PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJIOPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE 2
PTPB     DS    0F                  PUTLINE PARAMETER BLOCK
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJPTPB)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE PUTLINE PARAMETER BLOCK (PTPB) IS POINTED TO BY THE PARAM.   *
*    LIST PASSED TO PUTLINE.  IT IS USED TO RETURN PERTINENT INFO.    *
*    AS WELL AS CONTROL PUTLINE FUNCTIONS                             *
***********************************************************************
         SPACE
         DS    0F
         DS    CL4      INTERNAL PUTLINE USAGE
PTPBOPUT DS    A        ADDRESS OF OUTPUT LINE DESCRIPTOR OR DATA LINE
PTPBFLN  DS    A        PTR TO FORMATTED LINE RETURNED WHEN OUTPUT=
*                       ADDR,FORMAT) IS SPECIFIED
         SPACE
PGPB     DS    0H                  PUTGET PARAMETER BLOCK
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJPGPB)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *
*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *
*    RETURNING INFORMATION.                                           *
***********************************************************************
         SPACE
         DS    0F
         DS    CL12     INTERNAL TO GETLINE/PUTLINE
PGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE
         SPACE
DAPL     DS    0F                  DYNAMIC ALLOCATION PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJDAPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *
*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *
*    VIA REGISTER 1
***********************************************************************
         SPACE
DAPLUPT  DS    A        PTR TO UPT
DAPLECT  DS    A        PTR TO ECT
DAPLECB  DS    A        PTR TO CP'S ECB
DAPLPSCB DS    A        PTR TO PSCB
DAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK
         SPACE
DAPB2C   DS    0F                  DAIR PARAMETER LIST FOR CODE 2C
         SPACE
***********************************************************************
* COPIED FROM SYS1.MACLIB(IKJDAP2C) BECAUSE THE MACRO FORCES A DSECT  *
***********************************************************************
* THIS OPERATION CODE ALLOWS FOR RE-USE  OF TIOT ENTRIES              *
* IT IS USED BY THE TMP BEFORE DETACHING A TASK, AND BY ANY  TASK     *
* WHICH ATTACHES SUB-TASKS                                            *
***********************************************************************
         SPACE
DA2CCD   DS    CL2      DAIR ENTRY CODE
DA2CFLG  DS    H        FLAG FIELD
DA2CTCB  DS    A        TCB ADDR OF DSE ENTRIES MARKED NOT IN USE
DA2CDDN  DS    CL8        DDNAME
         SPACE
D0STACK  STACK MF=L,DELETE=ALL     USED FOR ANY STACK DELETE FUNCTION
         SPACE
D0STACK2 STACK MF=L,ENVIRON=CREATE USED FOR ANY STACK ENVIRON FUNCTION
         SPACE
D0ATTACH ATTACH SF=L
         SPACE
D0ESTAE  ESTAE MF=L
         SPACE
D0STAX   STAX  MF=L
         SPACE
D0NEWECT DS    A              Address of ECT created by ENVIRON=CREATE
D0RETCD  DS    F                   RETURN CODE FROM COMMAND
D0DAIRRC DS    F                   RETURN CODE FROM IKJDAIR
D0SVIOA  DS    F                   SAVE INPUT STACK ADDRESS
D0SCANRC DS    H                   RETURN CODE FROM IKJSCAN
D0OFFSET DS    H                   SAVED OFFSET OF POSSIBLE CLIST NAME
D0CMDS   DS    CL16                SAVED ECT COMMAND AND SUBCOMMAND
D0COMMND DS    CL8                 COMMAND NAME FROM SCAN
D0BLDL   DS    F                   BLDL LIST FOR COMMAND CHECK
D0MODULE DS    CL8                 MODULE NAME FOR COMMAND
         DS    XL4                 FILLER FOR BLDL
D0ABCODE DS    XL3                 ABEND CODE STORED BY STAI EXIT
D0FLAGS  DS    X                   FLAGS
D0EXEC   EQU   B'10000000'          1 = IMPLICIT EXEC COMMAND (%)
D0STKMOD EQU   B'01000000'          1 = ECT INPUT STACK ADDR ALTERED
D0ECTMOD EQU   B'00100000'          1 = ECT PCMD/SCMD WAS ALTERED
D0ESTON  EQU   B'00010000'          1 = ESTAE SUCCESSFUL
D0STXON  EQU   B'00001000'          1 = STAX SUCCESSFUL
D0SUBER  EQU   B'00000100'          1 = SEVERE ERROR IN SUBROUTINE
D0DETACH EQU   B'00000010'          1 = DETACH IN PROGRESS
D0AUTH   EQU   B'00000001'          1 = command requires authorization
D0RETURN DS    X                   Return status flag
D0RETNO  EQU   0                    Not returning
D0RETYES EQU   1                    Returning
D0STATUS DS    X                   COMMAND STATUS FLAG
D0NORMAL EQU   0                    COMMAND COMPLETED NORMALLY
D0ATTN   EQU   1                    ATTENTION INTERRUPT OCCURRED
D0ABEND  EQU   2                    ABNORMAL TERMINATION OCCURRED
D0TSOE   DS    X                   TSO/E version number
         SPACE
***********************************************************************
* Fields used by the TSO Authorized Service Facility                  *
***********************************************************************
         SPACE
D0TSFPLS DS    0A
D0TSFP1  DS    A                   TSO Service Facility parameter 1
D0TSFP2  DS    A                   TSO Service Facility parameter 2
D0TSFP3  DS    A                   TSO Service Facility parameter 3
D0TSFP4  DS    A                   TSO Service Facility parameter 4
D0TSFP5  DS    A                   TSO Service Facility parameter 5
D0TSFP6  DS    A                   TSO Service Facility parameter 6
D0TSFRC  DS    A                   Return code from TSO command
D0TSFRS  DS    A                   Reason code from TSO command
D0TSFAC  DS    A                   Abend code from TSO command
D0TSFLEN DS    A                   Length of command
         SPACE
***********************************************************************
* PUTGET MODE MESSAGE AREA                                            *
***********************************************************************
         SPACE
D0PGOLD  DS    A(1)                NUMBER OF MESSAGE SEGMENTS
D0PGPTR  DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT
D0PGHDR  DS    2Y                  MESSAGE HEADER
D0PGMODE DS    CL(L'MODEMSG)       MESSAGE TEXT
         SPACE
***********************************************************************
* WORKAREA FOR CONSTRUCTING PUTLINE MESSAGES                          *
* NOTE: THIS IS SET UP FOR SINGLE-LEVEL INFORMATIONAL MESSAGES ONLY.  *
***********************************************************************
         SPACE
D0MSGOLD DS    A(1)                NUMBER OF MESSAGE SEGMENTS
D0MSGPTR DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT
D0MSGHDR DS    2Y                  MESSAGE HEADER
D0MSG    DS    CL128               MESSAGE TEXT
D0MSG1   EQU   D0MSG+L'ABEMSGID    OFFSET OF "ENDED DUE TO ERROR"
D0MSG2   EQU   D0MSG1+8+L'ABEMSG1  OFFSET OF "SYSTEM" OR "USER"
D0SYSTEM EQU   D0MSG2+6+L'ABEMSG2  OFFSET OF SYSTEM ABEND CODE
D0USER   EQU   D0MSG2+4+L'ABEMSG2  OFFSET OF USER ABEND CODE
D0SYSL   EQU   D0SYSTEM+3-D0MSG    LENGTH OF SYSTEM ABEND MESSAGE
D0USERL  EQU   D0USER+4-D0MSG      LENGTH OF USER ABEND MESSAGE
         SPACE 2
D0MSGBUF DS    CL256               Area to build messages
         SPACE 2
SIZDATD0 EQU   *-DATD0
         EJECT
DATD1    DSECT
         SPACE
***********************************************************************
* ALL STORAGE USED BY IKJSCAN IS ALLOCATED IN SUBPOOL 1 BECAUSE       *
* THAT'S WHAT WE WERE TOLD TO DO BY THE GUIDE TO WRITING A TMP OR A   *
* COMMAND PROCESSOR.                                                  *
***********************************************************************
         SPACE
CSPL     DS    0D                  COMMAND SCAN PARAMETER LIST
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJCSPL)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *
*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *
***********************************************************************
         SPACE
CSPLUPT  DS    A        PTR TO  UPT
CSPLECT  DS    A        PTR TO  ECT
CSPLECB  DS    A        PTR TO  CP'S ECB
CSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED
*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF
*                       COMMAND NAME.
CSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)
CSPLCBUF DS    A        PTR TO COMMAND BUFFER
         SPACE
CSOA     DS    0H                  COMMAND SCAN OUTPUT AREA
         SPACE
***********************************************************************
* COPIED FROM 'SYS1.MACLIB(IKJCSOA)' BECAUSE THE MACRO FORCES A DSECT *
***********************************************************************
*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *
*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *
*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *
***********************************************************************
         SPACE
CSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME
CSOALNM  DS    H        LENGTH OF CMD NAME
CSOAFLG  DS    X        FLAGS
CSOAVWP  EQU   X'80'    VALID WITH PARAMETERS
CSOAVNP  EQU   X'40'    VALID NO   PARAMS
CSOAQM   EQU   X'20'    QUESTION MARK
CSOANOC  EQU   X'10'    NO COMMAND
CSOABAD  EQU   X'08'    BAD CMD NAME
CSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME
         DS    CL1      RESERVED
         SPACE
D1CSFLG  DS    F                   COMMAND SCAN FLAG WORD
         SPACE 2
SIZDATD1 EQU   *-DATD1
         SPACE 2
XTSEXEC  CSECT
         EJECT
         IKJECT
         EJECT
         IKJSTPB
         EJECT
         IKJPSCB
         EJECT
         IKJRLGB
         EJECT
         IKJEFLWA
         EJECT
         IKJTSVT
         EJECT
         PRINT NOGEN
         IHASDWA
         IEZJSCB
         IKJTCB
         IHAASCB
         IHAASXB
         IHAPSA
         CVT   DSECT=YES
         END
./ ADD NAME=XTSOVAR  0100-07332-07332-0900-00570-00570-00000-SEB
         TITLE 'XTSOVAR  - CLIST VARIABLE ACCESS FOR PL/1'
***********************************************************************
*                                                                     *
* XTSOVAR  - CLIST VARIABLE ACCESS FOR PL/1                           *
*                                                                     *
***********************************************************************
***********************************************************************
*                                                                     *
* XTSOVAR - AN INTERFACE TO THE TSO/EXTENSIONS RELEASE 2 CLIST        *
* VARIABLE ACCESS FACILITY FOR PL/1.                                  *
*                                                                     *
* PL/1 INVOCATION:                                                    *
*                                                                     *
* DCL VALUE    CHAR(256) VAR;                                         *
* DCL XTSOVAR ENTRY (CHAR(*),      /* 'R(EAD)' OR 'W(RITE)'       */  *
*                    CHAR(*) VAR,  /* THE NAME OF THE VARIABLE    */  *
*                    CHAR(*) VAR)  /* THE VALUE TO BE READ OR SET */  *
*              EXTERNAL;           /* DON'T SAY OPTIONS(ASM)!!!!! */  *
* DCL PLIRETV BUILTIN;                                                *
*                                                                     *
* /* SAMPLE CODE TO READ THE VALUE OF A VARIABLE */                   *
*                                                                     *
* CALL XTSOVAR ('R','SYSDVAL',VALUE);                                 *
* IF PLIRETV ^= 0 THEN DO;                                            *
*  PUT LIST('ERROR: RETRIEVED DATA TRUNCATED. BYTES LOST:',PLIRETV);  *
* END;                                                                *
* PUT LIST('THE VALUE OF &SYDSVAL IS:', VALUE);                       *
*                                                                     *
* /* SAMPLE CODE TO UPDATE THE VALUE OF A VARIABLE */                 *
*                                                                     *
* VALUE = 'THIS IS THE STRING TO BECOME THE VALUE OF &SYSDVAL';       *
* CALL XTSOVAR ('W','SYSDVAL',VALUE);                                 *
*                                                                     *
*  ***********    S P E C I F I C A T I O N S    ***********          *
*                                                                     *
* PROGRAM NAME:  XTSOVAR                                              *
* AUTHOR:        STEVE BACHER (SEB1525)                               *
* DATE:          06/13/85                                             *
* FUNCTION:      TO BE INVOKED FROM A PL/1 PROGRAM FOR THE PURPOSE    *
*                OF (1) RETRIEVING THE VALUE OF A CLIST VARIABLE,     *
*                OR (2) UPDATING THE VALUE OF A CLIST VARIABLE.       *
* RESTRICTION:   PROGRAM MUST BE RUN UNDER A CLIST.  IF RETRIEVING,   *
*                THE TARGET STRING MUST BE DECLARED LARGE ENOUGH TO   *
*                HOLD THE RETURN VALUE.  IF UPDATING, THE VARIABLE    *
*                MUST BE MODIFIABLE (NOT A SYSTEM VARIABLE).          *
* INPUT:         A STANDARD PL/1 PARAMETER LIST AS FOLLOWS:           *
*  PARAMETER 1:  A FIXED-LENGTH CHARACTER STRING WHOSE FIRST OR ONLY  *
*                CHARACTER IS "R" (READ, I.E. RETRIEVE A VALUE) OR    *
*                "W" (WRITE, I.E. UPDATE A VALUE).                    *
*  PARAMETER 2:  A VARYING-LENGTH CHARACTER STRING WHICH CONTAINS THE *
*                NAME OF THE CLIST VARIABLE TO BE ACCESSED (A LEADING *
*                AMPERSAND AND/OR TRAILING BLANKS ARE IGNORED).       *
*  PARAMETER 3:  A VARYING-LENGTH CHARACTER STRING USED AS FOLLOWS:   *
*                FOR "R" (READ) MODE, WILL CONTAIN THE VALUE OF THE   *
*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *
*                A DUMMY ARGUMENT SHOULD NOT BE USED IN THIS CASE.    *
*                FOR "W" (WRITE) MODE, CONTAINS THE VALUE TO BE       *
*                ASSIGNED TO THE CLIST VARIABLE.                      *
* RETURN CODES:                                                       *
*  0 - FUNCTION SUCCESSFUL.                                           *
*  GT 0 - READ MODE ONLY:  THE VALUE IN THE CLIST IS LONGER THAN      *
*        THE MAXIMUM DECLARED LENGTH OF THE THIRD PARAMETER, AND THE  *
*        VALUE HAS BEEN STORED, BUT WAS TRUNCATED.  THE RETURN CODE   *
*        IS THE NUMBER OF BYTES LOST THROUGH TRUNCATION.              *
* ABEND CODES:                                                        *
* 0C3 (PL/1 ONCODE 8093 - "ERROR" CONDITION RAISED) - ISSUED WHEN AN  *
* ERROR OTHER THAN TRUNCATION OCCURS.                                 *
*                                                                     *
* THE REASON CODE (IN PLIRETV) IS AS FOLLOWS:                         *
*                                                                     *
* 500 -  INVALID PARAMETERS PASSED TO THIS ROUTINE.                   *
* OTHER CODES ARE 500 + THE RETURN CODE FROM IKJCT441, THE CLIST      *
* VARIABLE ACCESS FACILITY, IF THAT ROUTINE FAILED.                   *
*                                                                     *
* PROCESSING:                                                         *
*  THE CLIST VARIABLE ACCESS FACILITY IS USED TO RETRIEVE OR UPDATE   *
*  THE REQUESTED CLIST VARIABLE IN THE CURRENTLY ACTIVE CLIST.        *
*  THE VALUE IS NOT CASE SHIFTED OR OTHERWISE TRANSLATED IN ANY WAY   *
*  (NORMAL CLIST PROCESSING DOES ITS OWN CHARACTER TRANSLATION).      *
*                                                                     *
*  A MESSAGE WILL BE DISPLAYED FOR A NONZERO RETURN CODE (CONTROL     *
*  NOMSG OR COMMAND OUTPUT TRAPPING WILL SUPPRESS THESE MESSAGES).    *
*                                                                     *
* DOCUMENTATION:                                                      *
* THE CLIST VARIABLE ACCESS FACILITY IS DOCUMENTED IN THE TSO         *
* GUIDE TO WRITING A TMP OR A COMMAND PROCESSOR FOR TSO/E RELEASE 2.  *
*                                                                     *
* RESTRICTIONS: THIS PROGRAM REQUIRES THE H ASSEMBLER, BECAUSE I WAS  *
* PERVERSE ENOUGH TO USE LONG SYMBOLIC NAMES.  BESIDES, ONCE YOU USE  *
* THE "CVT" MACRO YOU HAVE TO USE THE H ASSEMBLER.                    *
*                                                                     *
* ACKNOWLEDGMENTS:                                                    *
* THANKS TO LARRY JONES (LLJ4266) FOR TECHNICAL ASSISTANCE.           *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*  07/02/87 - NOW AMODE(ANY) AND RMODE(ANY).                          *
*  12/28/87 - TSO/E RELEASE 4 SUPPORT.                                *
*  05/01/89 - TSO/E VERSION 2 SUPPORT.                                *
*  08/17/89 - Support for REXX: switches to AMODE(31) to access.      *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    MISCELLANEOUS USES
R4       EQU   4    RETURN CODE FROM IKJCT441
R5       EQU   5    RESERVED FOR PL/1
R6       EQU   6    POINTER TO DOPE VECTOR FOR ARG 1
R7       EQU   7    POINTER TO DOPE VECTOR FOR ARG 2
R8       EQU   8    POINTER TO DOPE VECTOR FOR ARG 3
R9       EQU   9    ADDRESS OF VARIABLE NAME
R10      EQU   10   LENGTH OF VARIABLE NAME
R11      EQU   11   STATIC BASE REGISTER
R12      EQU   12   RESERVED FOR PL/1
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XTSOVAR  CSECT
XTSOVAR  AMODE ANY
XTSOVAR  RMODE ANY
         SAVE  (14,12),,&SYSDATE._&SYSTIME
         LR    R11,R15
         USING XTSOVAR,R11
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* VALIDITY CHECK PARAMETER LIST                                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    0(R1),X'80'         IF VL BIT SHOWS 1 PARM PASSED
         BO    WRONG_NUMBER_ARGS   THEN ERROR
         TM    4(R1),X'80'         IF VL BIT SHOWS 2 PARMS PASSED
         BO    WRONG_NUMBER_ARGS   THEN ERROR
         TM    8(R1),X'80'         IF VL BIT DOESN'T SHOW 3 PARMS
         BZ    WRONG_NUMBER_ARGS   THEN ERRROR
         SPACE 1
***********************************************************************
*                                                                     *
* PROCESS PARAMETERS PASSED FROM PL/1                                 *
*                                                                     *
***********************************************************************
         SPACE 1
         LM    R6,R8,0(R1)         GET POINTERS TO DOPE VECTORS
         CLI   6(R6),X'00'         IF ARG1 IS NOT CHAR(*) {FIXED},
         BNE   INVALID_ARG_TYPE    THEN ERROR
         CLI   6(R7),X'80'         IF ARG2 IS NOT CHAR(*) {VARYING},
         BNE   INVALID_ARG_TYPE    THEN ERROR
         CLI   6(R8),X'80'         IF ARG3 IS NOT CHAR(*) {VARYING},
         BNE   INVALID_ARG_TYPE    THEN ERROR
         SPACE 1
***********************************************************************
*                                                                     *
* THE FIRST ARGUMENT MUST BE "R" (READ) OR "W" (WRITE).               *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,0(,R6)           GET ADDRESS OF ARG1 CHAR STRING
         CLI   0(R1),C'R'          MUST BE UPPER CASE R
         BE    ENTRY_CODE_READ
         CLI   0(R1),C'R'-X'40'    OR LOWER CASE R
         BE    ENTRY_CODE_READ
         CLI   0(R1),C'W'          OR UPPER CASE W
         BE    ENTRY_CODE_WRITE
         CLI   0(R1),C'W'-X'40'    OR LOWER CASE W
         BE    ENTRY_CODE_WRITE
         B     WRONG_ENTRY_CODE    ELSE ERROR
         SPACE 1
ENTRY_CODE_READ DS 0H
         MVI   MODE,TSVERETR       INDICATE READ MODE
         B     SET_NAME_LENGTH
         SPACE 1
ENTRY_CODE_WRITE DS 0H
         MVI   MODE,TSVEUPDT       INDICATE WRITE MODE
         B     SET_NAME_LENGTH
         SPACE 2
SET_NAME_LENGTH DS 0H
         SPACE 1
***********************************************************************
*                                                                     *
* TAKE THE VARIABLE NAME LENGTH AND ADJUST IT.                        *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME STRING
         LH    R10,0(,R1)          GET CURRENT LENGTH OF STRING
         LA    R9,2(,R1)           POINT TO TEXT OF STRING
         LTR   R10,R10             BYPASS CHECK IF LENGTH IS ZERO
         BNP   NOCHECK             (BUT LET IKJCT441 FLAG IT AS ERROR)
         CLI   0(R9),C'&&'         IF USER STARTED NAME WITH AMPERSAND
         BNE   NOAMP               THEN...
         LA    R9,1(,R9)            BUMP PAST IT
         BCTR  R10,0                AND ADJUST LENGTH ACCORDINGLY.
NOAMP    DS    0H                  ANYHOW...
         LA    R15,0(R9,R10)       POINT TO END OF STRING
         BCTR  R15,0               BUMP BACK TO LAST CHARACTER
BLOOP    CLI   0(R15),C' '         SCAN OFF TRAILING BLANKS
         BNE   ENDNAME
         BCTR  R15,0
         BCT   R10,BLOOP
ENDNAME  DS    0H                  NOW R10 HAS ACTUAL LENGTH
NOCHECK  DS    0H
         SPACE 2
SETPARMS DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* SET UP PARAMETERS TO PASS TO IKJCT441                               *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R0,R0               MAKE A ZERO
         XR    R1,R1
         IC    R1,MODE             PICK UP MODE
         ST    R1,CENTRY           SET ENTRY CODE IN PARAMETER LIST
         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME
         ST    R10,CNAMEL          SET LENGTH OF VARIABLE NAME
         ST    R9,CNAMEA           SET ADDRESS OF VARIABLE NAME
         CLI   MODE,TSVERETR       IF MODE IS READ,
         BNE   NOTREAD             THEN...
         ST    R0,CVALUEA           CLEAR ADDRESS OF VARIABLE VALUE
         ST    R0,CVALUEL           CLEAR ADDRESS OF VARIABLE NAME
         B     AFTREAD             ELSE...
NOTREAD  DS    0H                   (SET TO UPDATE)
         L     R1,0(,R8)            GET POINTER TO VARIABLE VALUE
         LH    R2,0(,R1)            GET LENGTH OF VARIABLE VALUE
         ST    R2,CVALUEL           SET LENGTH OF VARIABLE VALUE
         LA    R2,2(,R1)            GET ADDRESS OF VARIABLE VALUE
         ST    R2,CVALUEA           SET ADDRESS OF VARIABLE VALUE
AFTREAD  DS    0H
         ST    R0,CTOKEN           SET TOKEN (NOT USED)
         LA    R14,CENTRY
         LA    R15,CNAMEA
         LA    R0,CNAMEL
         LA    R1,CVALUEA
         LA    R2,CVALUEL
         LA    R3,CTOKEN
         STM   R14,R3,CPARMS       SET UP PARAMETER LIST
         OI    CPARM6,X'80'        SET VL BIT
         LA    R1,CPARMS           POINT TO PARAMETER LIST
         L     R15,X'10'               GET ADDRESS OF CVT
         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE
         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441
         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE
         LTR   R4,R15              GET RETURN CODE
         BZ    OK                  IF ZERO, OK
         CH    R4,=H'76'           IF RETURN CODE IS 76
         BE    RC76                 OR
         CH    R4,=H'80'             RETURN CODE IS 80
         BE    RC80                 OR
         CH    R4,=H'81'             RETURN CODE IS 81
         BE    RC81                 OR
         CH    R4,=H'40'             RETURN CODE IS 40 OR LESS
         BH    RCOTHER                THEN
RET441   B     RET441(R4)              BRANCH DEPENDING ON RETURN CODE
         B     OK                  RC=4 IS OK
         B     RC8
         B     RC12
         B     RC16
         B     RCOTHER
         B     RC24
         B     RCOTHER
         B     RC32
         B     RC36
         B     RC40
         SPACE 1
OK       DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IF READ MODE, SEE IF WE CAN COPY THE DATA INTO CALLER'S VARIABLE.   *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   MODE,TSVERETR       IF NOT READ MODE,
         BNE   RETURN              THEN JUST RETURN. ELSE (READ MODE)..
         L     R2,0(,R8)           POINT TO CHAR(*) VAR ARG 3
         L     R9,CVALUEL          GET LENGTH OF RETURNED VALUE
         LA    R0,2(,R2)           SET ADDRESS OF WHERE TO MOVE IT
         LH    R1,4(,R8)           SET LENGTH OF WHERE TO MOVE IT
         L     R14,CVALUEA         SET ADDRESS OF WHAT TO MOVE
         LR    R15,R9              SET LENGTH OF WHAT TO MOVE
         L     R3,=A(MVCL+X'80000000')  Get address of 31-bit code
         LA    R4,AFTMVCL               Get return address
         BSM   R4,R3               Save current AMODE in R4, go to 31
MVCL     DS    0H
         MVCL  R0,R14              MOVE VALUE TO CALLER'S ARG 3
         BSM   0,R4                Return to previous AMODE
AFTMVCL  DS    0H
*
* BY HAPPY CIRCUMSTANCE, R15 NOW CONTAINS THE NUMBER OF BYTES NOT
* MOVED (I.E. TRUNCATED), WHICH IS ZERO IF IT ALL GOT MOVED.  WE
* CAN RETURN THIS AS THE RETURN CODE.
*
* SET LENGTH FIELD OF CHAR(*) VARYING ACCORDING TO HOW MUCH MOVED.
*
         SR    R9,R15              LENGTH MINUS TRUNCATION
         STH   R9,0(,R2)           GIVES LENGTH(STRING) TO BE SET
         B     RETURN              RETURN WITH CODE IN R15
         EJECT
RC8      DS    0H
         LA    R1,MSG8
         B     ERROR
         SPACE 1
RC12     DS    0H
         LA    R1,MSG12
         B     ERROR
         SPACE 1
RC16     DS    0H
         LA    R1,MSG16
         B     ERROR
         SPACE 1
RC24     DS    0H
         LA    R1,MSG24
         B     ERROR
         SPACE 1
RC32     DS    0H
         LA    R1,MSG32
         B     ERROR
         SPACE 1
RC36     DS    0H
         LA    R1,MSG36
         B     ERROR
         SPACE 1
RC40     DS    0H
         LA    R1,MSG40
         B     ERROR
         SPACE 1
RC76     DS    0H
         LA    R1,MSG76
         B     ERROR
         SPACE 1
RC80     DS    0H
         LA    R1,MSG80
         B     ERROR
         SPACE 1
RC81     DS    0H
         LA    R1,MSG81
         B     ERROR
         SPACE 1
RCOTHER  DS    0H
         MVC   OTHERMSG(MSGOTHER_LENGTH),MSGOTHER
         CVD   R4,OTHERRC
         UNPK  OTHERMSG+MSGOTHER_LENGTH(2),OTHERRC
         OI    OTHERMSG+MSGOTHER_LENGTH+1,X'F0'
         MVI   OTHERMSG+MSGOTHER_LENGTH+2,C'.'
         LA    R1,OTHERMSG
         LA    R0,MSGOTHER_LENGTH+3
         STH   R0,0(,R1)
         B     ERROR
         SPACE 1
         EJECT
ERROR    DS    0H
         SPACE 1
         USING PSA,0
         L     R15,PSATOLD           GET TCB ADDRESS
         USING TCB,R15
         L     R15,TCBJSCB           GET JSCB ADDRESS
         USING IEZJSCB,R15
         L     R15,JSCBACT           GET ADDRESS OF ACTIVE JSCB
         L     R15,JSCBPSCB          GET ADDRESS OF PSCB
         USING PSCB,R15
         MVC   IOPLUPT,PSCBUPT       SET UPT ADDRESS FOR PUTLINE
         L     R15,PSCBRLGB          GET ADDRESS OF RELOGON BUFFER
         USING RLGB,R15
         L     R8,RLGBECT            GET ADDRESS OF ECT
         ST    R8,IOPLECT            SET ECT ADDRESS FOR PUTLINE
         LA    R15,ECB
         ST    R15,IOPLECB          SET ECB ADDRESS IN IOPL
         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM
         LA    R0,1                 (REG1 ALREADY POINTS TO MSG)
         STM   R0,R1,OLD            SET UP OUTPUT LINE DESCRIPTOR
         XC    ECB,ECB              CLEAR ECB FOR PUTLINE
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15              IF PUTLINE FAILED,
         BZ    PUTLOK               THEN...
DOTPUT   DS    0H                    try to display message via TPUT
*
* Note: This will work only if the load module is loaded below the
*       line.  But since this won't get executed unless there's a
*       PUTLINE failure, which really shouldn't occur, we won't
*       worry about it.
*
         LA    R1,PUTLFAIL           DISPLAY PUTLINE FAILURE MESSAGE
         LA    R0,L'PUTLFAIL
         TPUT  (1),(0),R
         L     R1,OLD+4              GET ADDRESS OF ERROR MESSAGE
         LH    R0,0(,R1)             PICK UP LENGTH OF MESSAGE
         SH    R0,=H'5'              SUBTRACT LENGTH OF HEADER & BLANK
         LA    R1,5(,R1)             BUMP PAST HEADER & BLANK
         TPUT  (1),(0),R             AND DISPLAY VIA TPUT
PUTLOK   DS    0H
         SPACE 1
ABENDIT  DS    0H                   FORCE ONCODE8093
         SPACE 1
***********************************************************************
*                                                                     *
* R4 CONTAINS RETURN CODE FROM IKJCT441 (ZERO IF WAS NEVER CALLED)    *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R15,500(,R4)         SET REASON CODE = RC + 500
         ST    R15,68(,R12)         STORE IN PLIRETV AREA
         EX    0,*                  FORCE 0C3 ABEND
         EJECT
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* STORE RETURN CODE IN TCA+X'44'.  THIS IS NECESSARY TO ALLOW THE     *
* CALLER TO PICK UP THE RETURN CODE VIA "PLIRETV" DESPITE NOT BEING   *
* ABLE TO SPECIFY OPTIONS(RETCODE) IN THE DECLARE.                    *
*                                                                     *
***********************************************************************
         SPACE 1
         ST    R15,68(,R12)        STORE RETURN CODE IN PL/1 TCA
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* ERROR ROUTINES                                                      *
***********************************************************************
         SPACE 1
WRONG_NUMBER_ARGS DS 0H
         LA    R1,WRONG_NUMBER_ARGS_MESSAGE
         XR    R4,R4
         B     ERROR
         SPACE 1
INVALID_ARG_TYPE  DS 0H
         LA    R1,INVALID_ARG_TYPE_MESSAGE
         XR    R4,R4
         B     ERROR
         SPACE 1
WRONG_ENTRY_CODE  DS 0H
         LA    R1,WRONG_ENTRY_CODE_MESSAGE
         XR    R4,R4
         B     ERROR
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR) LIST FORM PUTLINE
LENPUTL  EQU   *-MPTLIST
         SPACE
WRONG_NUMBER_ARGS_MESSAGE WTO MF=L,                                    X
               ' XTSOVAR: WRONG NUMBER OF ARGUMENTS PASSED TO XTSOVAR.'
INVALID_ARG_TYPE_MESSAGE  WTO MF=L,                                    X
               ' XTSOVAR: INVALID ARGUMENT TYPES PASSED TO XTSOVAR.'
WRONG_ENTRY_CODE_MESSAGE  WTO MF=L,                                    X
               ' XTSOVAR: CODE PASSED TO XTSOVAR NOT "R" OR "W".'
MSG4     EQU   0               VARIABLE RETURNED, DO NOT RESCAN
MSG8     WTO   MF=L,' XTSVAR08: CLIST VARIABLE REQUIRES EVALUATION.'
MSG12    WTO   MF=L,' XTSVAR12: REQUESTED CLIST VARIABLE IS A LABEL.'
MSG16    WTO   MF=L,' XTSVAR16: CANNOT UPDATE SYSTEM CLIST VARIABLE.'
MSG24    WTO   MF=L,' XTSVAR24: REQUESTED CLIST VARIABLE IS A PROCEDUREX
                NAME.'
MSG32    WTO   MF=L,' XTSVAR32: IKJCT441 GETMAIN/FREEMAIN FAILURE.'
MSG36    WTO   MF=L,' XTSVAR36: CLIST VARIABLE NAME TOO LONG OR NULL.'
MSG40    WTO   MF=L,' XTSVAR40: NO CLIST IS CURRENTLY ACTIVE.'
MSG76    WTO   MF=L,' XTSVAR76: UNDEFINED &&SYSX CLIST VARIABLE.'
MSG80    WTO   MF=L,' XTSVAR80: VARIABLE NAME NOT VALID FOR REXX.'
MSG81    WTO   MF=L,' XTSVAR81: REXX ROUTINE DETECTED AN ERROR.'
         SPACE 1
MSGOTHER WTO   MF=L,' XTSOVAR: CLIST VARIABLE ACCESS RETURN CODE '
MSGOTHER_LENGTH EQU *-MSGOTHER
         SPACE 1
PUTLFAIL DC    C'XTSOVAR: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING IX
               SSUED VIA TPUT:'
         EJECT
         LTORG
         SPACE 3
         DROP  R11
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F                 OS SAVE AREA
OTHERRC  DS    D
         SPACE
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
OLD      DS    2F                  # OF SEGMENTS AND ADDRESS OF 1ST SEG
         SPACE
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE 2
CPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS
         SPACE 1
CPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE
CPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME
CPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME
CPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE
CPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE
CPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)
         SPACE 1
CENTRY   DC    A(0)                ENTRY CODE
CNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME
CNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME
CVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME
CVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE
CTOKEN   DC    A(0)                TOKEN (NOT USED)
         SPACE 1
MODE     DS    C                   R(EAD) OR W(RITE)
         SPACE 2
OTHERMSG DS    0A
         DS    CL(MSGOTHER_LENGTH+3)
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJECT
         SPACE 1
         IKJCPPL
         SPACE 1
         IKJTSVT
         SPACE 1
         PRINT NOGEN
         IHAPSA
         SPACE 1
         CVT   DSECT=YES
         SPACE 1
         IKJTCB
         SPACE 1
         IEZJSCB
         SPACE 1
         IKJPSCB
         SPACE 1
         IKJRLGB
         END
./ ADD NAME=XTSVAR   0100-07332-07332-0900-00600-00600-00000-SEB
         TITLE 'XTSVAR  - CLIST VARIABLE ACCESS FOR FORTRAN'
***********************************************************************
*                                                                     *
* XTSVAR  - CLIST VARIABLE ACCESS FOR FORTRAN                         *
*                                                                     *
***********************************************************************
***********************************************************************
*                                                                     *
* XTSVAR - AN INTERFACE TO THE TSO/EXTENSIONS RELEASE 2 CLIST         *
* VARIABLE ACCESS FACILITY FOR FORTRAN.                               *
*                                                                     *
* FORTRAN INVOCATION:                                                 *
*                                                                     *
*       INTEGER*4 FUNCTION XTSVAR(RW,VARNAM,VARVAL,LENGTH)            *
* C                                                                   *
*       CHARACTER RW*1,VARNAM*(*),VARVAL*(*)                          *
*       INTEGER*4 LENGTH                                              *
* C                                                                   *
* C  INPUT:                                                           *
* C    RW     - READ/WRITE FLAG, EITHER 'R' OR 'W' OR 'r' OR 'w'      *
* C    VARNAM - TSO VARIABLE NAME                                     *
* C                                                                   *
* C  OUTPUT:                                                          *
* C    VARVAL - VALUE OF TSO VARIABLE                                 *
* C    LENGTH - LENGTH OF VARVAL STRING, OR 0 IF VALUE IS <NULL>      *
* C    XTSVAR - .EQ.0 => SUCCESS                                      *
* C             .GT.0 => TRUNCATION OR OTHER ERROR AS FOR XTSOVAR     *
*                                                                     *
*                                                                     *
* C  SAMPLE CODE TO READ THE VALUE OF A VARIABLE                      *
*                                                                     *
*   RC = XTSVAR ('R','SYSDVAL',VARVAL,LENGTH)                         *
*   IF (RC.NE.0) THEN                                                 *
*    WRITE (6,100) RC                                                 *
* 100 FORMAT(' ERROR: RETRIEVED DATA TRUNCATED. BYTES LOST:',I10)     *
*   ENDIF                                                             *
*    WRITE (6,200) VARVAL                                             *
* 200 FORMAT(' THE VALUE OF &SYSDVAL IS:',A.... whatever              *
*  C FOR A LENGTH OF "LENGTH"                                         *
*                                                                     *
* C  SAMPLE CODE TO UPDATE THE VALUE OF A VARIABLE                    *
*                                                                     *
* C NOTE THAT THE "LENGTH" VARIABLE MUST BE SPECIFIED THO NOT USED    *
*                                                                     *
* VARVAL = 'THIS IS THE STRING TO BECOME THE VALUE OF &SYSDVAL'       *
* CALL XTSVAR  ('W','SYSDVAL',VARVAL, LENGTH)                         *
*                                                                     *
*  ***********    S P E C I F I C A T I O N S    ***********          *
*                                                                     *
* PROGRAM NAME:  XTSVAR                                               *
* AUTHOR:        STEVE BACHER (SEB1525)                               *
* DATE:          06/25/87                                             *
* FUNCTION:      TO BE INVOKED FROM A FORTRAN PROGRAM FOR THE PURPOSE *
*                OF (1) RETRIEVING THE VALUE OF A CLIST VARIABLE,     *
*                OR (2) UPDATING THE VALUE OF A CLIST VARIABLE.       *
* RESTRICTION:   PROGRAM MUST BE RUN UNDER A CLIST.  IF RETRIEVING,   *
*                THE TARGET STRING MUST BE DEFINED LARGE ENOUGH TO    *
*                HOLD THE RETURN VALUE.  IF UPDATING, THE VARIABLE    *
*                MUST BE MODIFIABLE (NOT A SYSTEM VARIABLE).          *
* INPUT:         A STANDARD FORTRAN PARAMETER LIST AS FOLLOWS:        *
*  PARAMETER 1:  A FIXED-LENGTH CHARACTER STRING WHOSE FIRST OR ONLY  *
*                CHARACTER IS "R" (READ, I.E. RETRIEVE A VALUE) OR    *
*                "W" (WRITE, I.E. UPDATE A VALUE).                    *
*  PARAMETER 2:  A FIXED-LENGTH CHARACTER STRING WHICH CONTAINS THE   *
*                NAME OF THE CLIST VARIABLE TO BE ACCESSED (A LEADING *
*                AMPERSAND AND/OR TRAILING BLANKS ARE IGNORED).       *
*  PARAMETER 3:  A FIXED-LENGTH CHARACTER STRING USED AS FOLLOWS:     *
*                FOR "R" (READ) MODE, WILL CONTAIN THE VALUE OF THE   *
*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *
*                A DUMMY ARGUMENT SHOULD NOT BE USED IN THIS CASE.    *
*                FOR "W" (WRITE) MODE, CONTAINS THE VALUE TO BE       *
*                ASSIGNED TO THE CLIST VARIABLE.                      *
*  PARAMETER 4:  A FULLWORD INTEGER USED AS FOLLOWS:                  *
*                FOR "R" (READ) MODE, WILL CONTAIN THE LENGTH OF THE  *
*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *
*                FOR "W" (WRITE) MODE, IS NOT USED, BUT YOU MAY NOT   *
*                SPECIFY ANYTHING OTHER THAN AN INTEGER*4 VARIABLE    *
*                FOR THIS PARAMETER.                                  *
* RETURN VALUE (INTEGER):                                             *
*  0 - FUNCTION SUCCESSFUL.                                           *
*  GT 0 - READ MODE ONLY:  THE VALUE IN THE CLIST IS LONGER THAN      *
*        THE CHARACTER STRING LENGTH OF THE THIRD PARAMETER, AND THE  *
*        VALUE HAS BEEN STORED, BUT WAS TRUNCATED.  THE RETURN VALUE  *
*        IS THE NUMBER OF BYTES LOST THROUGH TRUNCATION.              *
* ABEND CODES:                                                        *
* Unn - ISSUED WHEN AN ERROR OTHER THAN TRUNCATION OCCURS.            *
*                                                                     *
* THE USER ABEND CODE IS:                                             *
*                                                                     *
* 500 -  INVALID PARAMETERS PASSED TO THIS ROUTINE.                   *
* OTHER CODES ARE 500 + THE RETURN CODE FROM IKJCT441, THE CLIST      *
* VARIABLE ACCESS FACILITY, IF THAT ROUTINE FAILED.                   *
*                                                                     *
* PROCESSING:                                                         *
*  THE CLIST VARIABLE ACCESS FACILITY IS USED TO RETRIEVE OR UPDATE   *
*  THE REQUESTED CLIST VARIABLE IN THE CURRENTLY ACTIVE CLIST.        *
*  THE VALUE IS NOT CASE SHIFTED OR OTHERWISE TRANSLATED IN ANY WAY   *
*  (NORMAL CLIST PROCESSING DOES ITS OWN CHARACTER TRANSLATION).      *
*                                                                     *
*  A MESSAGE WILL BE DISPLAYED FOR A NONZERO RETURN CODE (CONTROL     *
*  NOMSG OR COMMAND OUTPUT TRAPPING WILL SUPPRESS THESE MESSAGES).    *
*                                                                     *
* DOCUMENTATION:                                                      *
* THE CLIST VARIABLE ACCESS FACILITY IS DOCUMENTED IN THE TSO         *
* GUIDE TO WRITING A TMP OR A COMMAND PROCESSOR FOR TSO/E RELEASE 3.  *
*                                                                     *
* RESTRICTIONS: THIS PROGRAM REQUIRES THE H ASSEMBLER, BECAUSE I WAS  *
* PERVERSE ENOUGH TO USE LONG SYMBOLIC NAMES.  BESIDES, ONCE YOU USE  *
* THE "CVT" MACRO YOU HAVE TO USE THE H ASSEMBLER.                    *
*                                                                     *
* ACKNOWLEDGMENTS:                                                    *
* THIS IS A MODIFIED VERSION OF XTSOVAR, THE EQUIVALENT ROUTINE FOR   *
* PL/1 PROGRAMS.  SEE XTSOVAR FOR FURTHER ACKNOWLEDGMENTS.            *
*                                                                     *
* CHANGE ACTIVITY:                                                    *
*  12/28/87 - SUPPORT FOR TSO/E RELEASE 4.                            *
*  05/01/89 - SUPPORT FOR TSO/E VERSION 2.                            *
*  08/17/89 - Support for REXX: switches to AMODE(31) to access.      *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    MISCELLANEOUS USES
R4       EQU   4    RETURN CODE FROM IKJCT441
R5       EQU   5    POINTER TO PARAMETER LIST
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9    ADDRESS OF VARIABLE NAME
R10      EQU   10   LENGTH OF VARIABLE NAME
R11      EQU   11   STATIC BASE REGISTER
R12      EQU   12   RESERVED FOR PL/1
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XTSVAR   CSECT
XTSVAR   AMODE ANY
XTSVAR   RMODE ANY
         SAVE  (14,12),,&SYSDATE._&SYSTIME
         LR    R11,R15
         USING XTSVAR,R11
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* VALIDITY CHECK PARAMETER LIST                                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    0(R1),X'80'         IF VL BIT SHOWS 1 PARM PASSED
         BO    WRONG_NUMBER_ARGS   THEN ERROR
         TM    4(R1),X'80'         IF VL BIT SHOWS 2 PARMS PASSED
         BO    WRONG_NUMBER_ARGS   THEN ERROR
         TM    8(R1),X'80'         IF VL BIT SHOWS 3 PARMS PASSED
         BO    WRONG_NUMBER_ARGS   THEN ERROR
         TM    12(R1),X'80'        IF VL BIT DOESN'T SHOW 4 PARMS
         BZ    WRONG_NUMBER_ARGS   THEN ERRROR
         SPACE 1
***********************************************************************
*                                                                     *
* PROCESS PARAMETERS PASSED FROM FORTRAN                              *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R5,R1               Save pointer to parameter list
         USING FP,R5               Establish addressability to parms
         SPACE 1
***********************************************************************
*                                                                     *
* THE FIRST ARGUMENT MUST BE "R" (READ) OR "W" (WRITE).               *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,FP_RW_A          GET ADDRESS OF ARG1 CHAR STRING
         CLI   0(R1),C'R'          MUST BE UPPER CASE R
         BE    ENTRY_CODE_READ
         CLI   0(R1),C'R'-X'40'    OR LOWER CASE R
         BE    ENTRY_CODE_READ
         CLI   0(R1),C'W'          OR UPPER CASE W
         BE    ENTRY_CODE_WRITE
         CLI   0(R1),C'W'-X'40'    OR LOWER CASE W
         BE    ENTRY_CODE_WRITE
         B     WRONG_ENTRY_CODE    ELSE ERROR
         SPACE 1
ENTRY_CODE_READ DS 0H
         MVI   MODE,TSVERETR       INDICATE READ MODE
         B     SET_NAME_LENGTH
         SPACE 1
ENTRY_CODE_WRITE DS 0H
         MVI   MODE,TSVEUPDT       INDICATE WRITE MODE
         B     SET_NAME_LENGTH
         SPACE 2
SET_NAME_LENGTH DS 0H
         SPACE 1
***********************************************************************
*                                                                     *
* TAKE THE VARIABLE NAME LENGTH AND ADJUST IT.                        *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R9,FP_VARNAME_A     Point to variable name string text
         L     R1,FP_VARNAME_L     Point to length of variable name
         L     R10,0(,R1)          Load length of variable name string
         LTR   R10,R10             BYPASS CHECK IF LENGTH IS ZERO
         BNP   NOCHECK             (BUT LET IKJCT441 FLAG IT AS ERROR)
         CLI   0(R9),C'&&'         IF USER STARTED NAME WITH AMPERSAND
         BNE   NOAMP               THEN...
         LA    R9,1(,R9)            BUMP PAST IT
         BCTR  R10,0                AND ADJUST LENGTH ACCORDINGLY.
NOAMP    DS    0H                  ANYHOW...
         LA    R15,0(R9,R10)       POINT TO END OF STRING
         BCTR  R15,0               BUMP BACK TO LAST CHARACTER
BLOOP    CLI   0(R15),C' '         SCAN OFF TRAILING BLANKS
         BNE   ENDNAME
         BCTR  R15,0
         BCT   R10,BLOOP
ENDNAME  DS    0H                  NOW R10 HAS ACTUAL LENGTH
NOCHECK  DS    0H
         SPACE 2
SETPARMS DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* SET UP PARAMETERS TO PASS TO IKJCT441                               *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R0,R0               MAKE A ZERO
         XR    R1,R1
         IC    R1,MODE             PICK UP MODE
         ST    R1,CENTRY           SET ENTRY CODE IN PARAMETER LIST
         ST    R10,CNAMEL          SET LENGTH OF VARIABLE NAME
         ST    R9,CNAMEA           SET ADDRESS OF VARIABLE NAME
         CLI   MODE,TSVERETR       IF MODE IS READ,
         BNE   NOTREAD             THEN...
         ST    R0,CVALUEA           CLEAR ADDRESS OF VARIABLE VALUE
         ST    R0,CVALUEL           CLEAR ADDRESS OF VARIABLE NAME
         B     AFTREAD             ELSE...
NOTREAD  DS    0H                   (SET TO UPDATE)
         L     R1,FP_VARVALUE_L     POINT TO VARIABLE VALUE LENGTH
         L     R2,0(,R1)            LOAD LENGTH OF VARIABLE VALUE
         ST    R2,CVALUEL           SET LENGTH OF VARIABLE VALUE
         L     R2,FP_VARVALUE_A     GET ADDRESS OF VARIABLE VALUE
         ST    R2,CVALUEA           SET ADDRESS OF VARIABLE VALUE
AFTREAD  DS    0H
         ST    R0,CTOKEN           SET TOKEN (NOT USED)
         LA    R14,CENTRY
         LA    R15,CNAMEA
         LA    R0,CNAMEL
         LA    R1,CVALUEA
         LA    R2,CVALUEL
         LA    R3,CTOKEN
         STM   R14,R3,CPARMS       SET UP PARAMETER LIST
         OI    CPARM6,X'80'        SET VL BIT
         LA    R1,CPARMS           POINT TO PARAMETER LIST
         L     R15,X'10'               GET ADDRESS OF CVT
         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE
         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441
         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE
         LTR   R4,R15              GET RETURN CODE
         BZ    OK                  IF ZERO, OK
         CH    R4,=H'76'           IF RETURN CODE IS 76
         BE    RC76                 OR
         CH    R4,=H'80'             RETURN CODE IS 80
         BE    RC80                 OR
         CH    R4,=H'81'             RETURN CODE IS 81
         BE    RC81                 OR
         CH    R4,=H'40'             RETURN CODE IS 40 OR LESS
         BH    RCOTHER                THEN
RET441   B     RET441(R4)              BRANCH DEPENDING ON RETURN CODE
         B     OK                  RC=4 IS OK
         B     RC8
         B     RC12
         B     RC16
         B     RCOTHER
         B     RC24
         B     RCOTHER
         B     RC32
         B     RC36
         B     RC40
         SPACE 1
OK       DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IF READ MODE, SEE IF WE CAN COPY THE DATA INTO CALLER'S VARIABLE.   *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   MODE,TSVERETR       IF NOT READ MODE,
         BNE   RETURN              THEN JUST RETURN. ELSE (READ MODE)..
         L     R9,CVALUEL          GET LENGTH OF RETURNED VALUE
         L     R0,FP_VARVALUE_A    POINT TO VALUE AREA (WHERE TO MOVE)
         L     R1,FP_VARVALUE_L    POINT TO LENGTH OF VALUE AREA
         L     R1,0(,R1)           SET LENGTH OF WHERE TO MOVE IT
         L     R14,CVALUEA         SET ADDRESS OF WHAT TO MOVE
         LR    R15,R9              SET LENGTH OF WHAT TO MOVE
         O     R15,=X'40000000'    SET FILL CHARACTER TO BLANK
         L     R3,=A(MVCL+X'80000000')  Get address of 31-bit code
         LA    R4,AFTMVCL               Get return address
         BSM   R4,R3               Save current AMODE in R4, go to 31
MVCL     DS    0H
         MVCL  R0,R14              MOVE VALUE TO CALLER'S ARG 3
         BSM   0,R4                Return to previous AMODE
AFTMVCL  DS    0H
         N     R15,=X'00FFFFFF'    CLEAR FILL CHARACTER, LEAVE LENGTH
*
* BY HAPPY CIRCUMSTANCE, R15 NOW CONTAINS THE NUMBER OF BYTES NOT
* MOVED (I.E. TRUNCATED), WHICH IS ZERO IF IT ALL GOT MOVED.  WE
* CAN RETURN THIS AS THE RETURN CODE.
*
* SET LENGTH FIELD (ARG 4) ACCORDING TO HOW MUCH MOVED.
*
         SR    R9,R15              LENGTH MINUS TRUNCATION
         L     R1,FP_LENGTH_A      GET ADDRESS OF VALUE LENGTH AREA
         ST    R9,0(,R1)           RETURN LENGTH TO THE CALLER
         B     RETURN              RETURN WITH CODE IN R15
         EJECT
RC8      DS    0H
         LA    R1,MSG8
         B     ERROR
         SPACE 1
RC12     DS    0H
         LA    R1,MSG12
         B     ERROR
         SPACE 1
RC16     DS    0H
         LA    R1,MSG16
         B     ERROR
         SPACE 1
RC24     DS    0H
         LA    R1,MSG24
         B     ERROR
         SPACE 1
RC32     DS    0H
         LA    R1,MSG32
         B     ERROR
         SPACE 1
RC36     DS    0H
         LA    R1,MSG36
         B     ERROR
         SPACE 1
RC40     DS    0H
         LA    R1,MSG40
         B     ERROR
         SPACE 1
RC76     DS    0H
         LA    R1,MSG76
         B     ERROR
         SPACE 1
RC80     DS    0H
         LA    R1,MSG80
         B     ERROR
         SPACE 1
RC81     DS    0H
         LA    R1,MSG81
         B     ERROR
         SPACE 1
RCOTHER  DS    0H
         MVC   OTHERMSG(MSGOTHER_LENGTH),MSGOTHER
         CVD   R4,OTHERRC
         UNPK  OTHERMSG+MSGOTHER_LENGTH(2),OTHERRC
         OI    OTHERMSG+MSGOTHER_LENGTH+1,X'F0'
         MVI   OTHERMSG+MSGOTHER_LENGTH+2,C'.'
         LA    R1,OTHERMSG
         LA    R0,MSGOTHER_LENGTH+3
         STH   R0,0(,R1)
         B     ERROR
         EJECT
ERROR    DS    0H
         SPACE 1
         USING PSA,0
         L     R15,PSATOLD           GET TCB ADDRESS
         USING TCB,R15
         L     R15,TCBJSCB           GET JSCB ADDRESS
         USING IEZJSCB,R15
         L     R15,JSCBACT           GET ADDRESS OF ACTIVE JSCB
         L     R15,JSCBPSCB          GET ADDRESS OF PSCB
         USING PSCB,R15
         MVC   IOPLUPT,PSCBUPT       SET UPT ADDRESS FOR PUTLINE
         L     R15,PSCBRLGB          GET ADDRESS OF RELOGON BUFFER
         USING RLGB,R15
         L     R8,RLGBECT            GET ADDRESS OF ECT
         ST    R8,IOPLECT            SET ECT ADDRESS FOR PUTLINE
         LA    R15,ECB
         ST    R15,IOPLECB          SET ECB ADDRESS IN IOPL
         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM
         LA    R0,1                 (REG1 ALREADY POINTS TO MSG)
         STM   R0,R1,OLD            SET UP OUTPUT LINE DESCRIPTOR
         XC    ECB,ECB              CLEAR ECB FOR PUTLINE
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15              IF PUTLINE FAILED,
         BZ    PUTLOK               THEN...
DOTPUT   DS    0H                    try to display message via TPUT
*
* Note: This will work only if the load module is loaded below the
*       line.  But since this won't get executed unless there's a
*       PUTLINE failure, which really shouldn't occur, we won't
*       worry about it.
*
         LA    R1,PUTLFAIL           DISPLAY PUTLINE FAILURE MESSAGE
         LA    R0,L'PUTLFAIL
         TPUT  (1),(0),R
         L     R1,OLD+4              GET ADDRESS OF ERROR MESSAGE
         LH    R0,0(,R1)             PICK UP LENGTH OF MESSAGE
         SH    R0,=H'5'              SUBTRACT LENGTH OF HEADER & BLANK
         LA    R1,5(,R1)             BUMP PAST HEADER & BLANK
         TPUT  (1),(0),R             AND DISPLAY VIA TPUT
PUTLOK   DS    0H
         SPACE 1
ABENDIT  DS    0H                   FORCE ONCODE8093
         SPACE 1
***********************************************************************
*                                                                     *
* R4 CONTAINS RETURN CODE FROM IKJCT441 (ZERO IF WAS NEVER CALLED)    *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,500(,R4)          SET REASON CODE = RC + 500
         ABEND (1),DUMP             FORCE U(N+500) ABEND
         EJECT
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* SET RETURN CODE IN REGISTER 0.  THIS IS NECESSARY TO ALLOW THE      *
* CALLER TO PICK UP THE RETURN CODE FROM A FORTRAN FUNCTION CALL.     *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,20(,R13) (SAVED R0)  SET RETURN CODE FOR FORTRAN
         ST    R15,16(,R13) (SAVED R15) SET RET CODE FOR EVERYONE ELSE
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* ERROR ROUTINES                                                      *
***********************************************************************
         SPACE 1
WRONG_NUMBER_ARGS DS 0H
         LA    R1,WRONG_NUMBER_ARGS_MESSAGE
         XR    R4,R4
         B     ERROR
         SPACE 1
INVALID_ARG_TYPE  DS 0H
         LA    R1,INVALID_ARG_TYPE_MESSAGE
         XR    R4,R4
         B     ERROR
         SPACE 1
WRONG_ENTRY_CODE  DS 0H
         LA    R1,WRONG_ENTRY_CODE_MESSAGE
         XR    R4,R4
         B     ERROR
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR) LIST FORM PUTLINE
LENPUTL  EQU   *-MPTLIST
         SPACE
WRONG_NUMBER_ARGS_MESSAGE WTO MF=L,                                    X
               ' XTSVAR: WRONG NUMBER OF ARGUMENTS PASSED TO XTSVAR.'
INVALID_ARG_TYPE_MESSAGE  WTO MF=L,                                    X
               ' XTSVAR: INVALID ARGUMENT TYPES PASSED TO XTSVAR.'
WRONG_ENTRY_CODE_MESSAGE  WTO MF=L,                                    X
               ' XTSVAR: CODE PASSED TO XTSVAR NOT "R" OR "W".'
MSG4     EQU   0               VARIABLE RETURNED, DO NOT RESCAN
MSG8     WTO   MF=L,' XTSVAR08: CLIST VARIABLE REQUIRES EVALUATION.'
MSG12    WTO   MF=L,' XTSVAR12: REQUESTED CLIST VARIABLE IS A LABEL.'
MSG16    WTO   MF=L,' XTSVAR16: CANNOT UPDATE SYSTEM CLIST VARIABLE.'
MSG24    WTO   MF=L,' XTSVAR24: REQUESTED CLIST VARIABLE IS A PROCEDUREX
                NAME.'
MSG32    WTO   MF=L,' XTSVAR32: IKJCT441 GETMAIN/FREEMAIN FAILURE.'
MSG36    WTO   MF=L,' XTSVAR36: CLIST VARIABLE NAME TOO LONG OR NULL.'
MSG40    WTO   MF=L,' XTSVAR40: NO CLIST IS CURRENTLY ACTIVE.'
MSG76    WTO   MF=L,' XTSVAR76: UNDEFINED &&SYSX CLIST VARIABLE.'
MSG80    WTO   MF=L,' XTSVAR80: VARIABLE NAME NOT VALID FOR REXX.'
MSG81    WTO   MF=L,' XTSVAR81: REXX ROUTINE DETECTED AN ERROR.'
         SPACE 1
MSGOTHER WTO   MF=L,' XTSVAR: CLIST VARIABLE ACCESS RETURN CODE '
MSGOTHER_LENGTH EQU *-MSGOTHER
         SPACE
PUTLFAIL DC    C'XTSVAR: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING ISX
               SUED VIA TPUT:'
         EJECT
         LTORG
         SPACE 3
         DROP  R11
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F                 OS SAVE AREA
OTHERRC  DS    D
         SPACE
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
OLD      DS    2F                  # OF SEGMENTS AND ADDRESS OF 1ST SEG
         SPACE
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE 2
CPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS
         SPACE 1
CPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE
CPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME
CPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME
CPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE
CPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE
CPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)
         SPACE 1
CENTRY   DC    A(0)                ENTRY CODE
CNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME
CNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME
CVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME
CVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE
CTOKEN   DC    A(0)                TOKEN (NOT USED)
         SPACE 1
MODE     DS    C                   R(EAD) OR W(RITE)
         SPACE 1
OTHERMSG DS    0A
         DS    CL(MSGOTHER_LENGTH+3)
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MAPPING OF PARAMETER LIST PASSED FROM FORTRAN                       *
***********************************************************************
         SPACE 1
FP       DSECT
         SPACE 1
FP_RW_A       DS A                 Address of R/W parameter
FP_VARNAME_A  DS A                 Address of variable name
FP_VARVALUE_A DS A                 Address of variable value
FP_LENGTH_A   DS A                 Address of variable value length
FP_RW_L       DS A                 Address of length of R/W parameter
FP_VARNAME_L  DS A                 Address of length of variable name
FP_VARVALUE_L DS A                 Address of length of variable value
FP_LENGTH_L   DS A                 Address of nothing much
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJECT
         SPACE 1
         IKJCPPL
         SPACE 1
         IKJTSVT
         SPACE 1
         PRINT NOGEN
         IHAPSA
         SPACE 1
         CVT   DSECT=YES
         SPACE 1
         IKJTCB
         SPACE 1
         IEZJSCB
         SPACE 1
         IKJPSCB
         SPACE 1
         IKJRLGB
         END
./ ADD NAME=XTSVARV  0100-07332-07332-0900-00538-00538-00000-SEB
         TITLE 'XTSVARV  - CLIST VARIABLE ACCESS FOR PL/1'
***********************************************************************
*                                                                     *
* XTSVARV  - CLIST VARIABLE ACCESS FOR PL/1                           *
*                                                                     *
***********************************************************************
***********************************************************************
*                                                                     *
* XTSVARV - AN INTERFACE TO THE TSO/EXTENSIONS RELEASE 2 CLIST        *
* VARIABLE ACCESS FACILITY FOR PL/1.                                  *
*                                                                     *
* PL/1 INVOCATION:                                                    *
*                                                                     *
* DCL VALUE    CHAR(256) VAR;                                         *
* DCL XTSVARV ENTRY (CHAR(*),      /* 'R(EAD)' OR 'W(RITE)'       */  *
*                    CHAR(*) VAR,  /* THE NAME OF THE VARIABLE    */  *
*                    CHAR(*) VAR)  /* THE VALUE TO BE READ OR SET */  *
*              EXTERNAL;           /* DON'T SAY OPTIONS(ASM)!!!!! */  *
* DCL PLIRETV BUILTIN;                                                *
*                                                                     *
* /* SAMPLE CODE TO READ THE VALUE OF A VARIABLE */                   *
*                                                                     *
* CALL XTSVARV ('R','SYSDVAL',VALUE);                                 *
* IF PLIRETV ^= 0 THEN DO;                                            *
*  PUT LIST('ERROR: RETRIEVED DATA TRUNCATED. BYTES LOST:',PLIRETV);  *
* END;                                                                *
* PUT LIST('THE VALUE OF &SYDSVAL IS:', VALUE);                       *
*                                                                     *
* /* SAMPLE CODE TO UPDATE THE VALUE OF A VARIABLE */                 *
*                                                                     *
* VALUE = 'THIS IS THE STRING TO BECOME THE VALUE OF &SYSDVAL';       *
* CALL XTSVARV ('W','SYSDVAL',VALUE);                                 *
*                                                                     *
*  ***********    S P E C I F I C A T I O N S    ***********          *
*                                                                     *
* PROGRAM NAME:  XTSVARV                                              *
*                (ALIAS "XSTDVL" ESTABLISHED FOR FORTRAN.)            *
* FUNCTION:      TO BE INVOKED FROM A PL/1 PROGRAM FOR THE PURPOSE    *
*                OF (1) RETRIEVING THE VALUE OF A CLIST VARIABLE,     *
*                OR (2) UPDATING THE VALUE OF A CLIST VARIABLE.       *
* RESTRICTION:   PROGRAM MUST BE RUN UNDER A CLIST.  IF RETRIEVING,   *
*                THE TARGET STRING MUST BE DECLARED LARGE ENOUGH TO   *
*                HOLD THE RETURN VALUE.  IF UPDATING, THE VARIABLE    *
*                MUST BE MODIFIABLE (NOT A SYSTEM VARIABLE).          *
* INPUT:         A STANDARD PL/1 PARAMETER LIST AS FOLLOWS:           *
*  PARAMETER 1:  A FIXED-LENGTH CHARACTER STRING WHOSE FIRST OR ONLY  *
*                CHARACTER IS "R" (READ, I.E. RETRIEVE A VALUE) OR    *
*                "W" (WRITE, I.E. UPDATE A VALUE).                    *
*  PARAMETER 2:  A VARYING-LENGTH CHARACTER STRING WHICH CONTAINS THE *
*                NAME OF THE CLIST VARIABLE TO BE ACCESSED (A LEADING *
*                AMPERSAND AND/OR TRAILING BLANKS ARE IGNORED).       *
*  PARAMETER 3:  A VARYING-LENGTH CHARACTER STRING USED AS FOLLOWS:   *
*                FOR "R" (READ) MODE, WILL CONTAIN THE VALUE OF THE   *
*                REQUESTED VARIABLE UPON RETURN FROM THIS SUBROUTINE. *
*                A DUMMY ARGUMENT SHOULD NOT BE USED IN THIS CASE.    *
*                FOR "W" (WRITE) MODE, CONTAINS THE VALUE TO BE       *
*                ASSIGNED TO THE CLIST VARIABLE.                      *
* RETURN CODES:                                                       *
*  0 - FUNCTION SUCCESSFUL.                                           *
*  GT 0 - READ MODE ONLY:  THE VALUE IN THE CLIST IS LONGER THAN      *
*        THE MAXIMUM DECLARED LENGTH OF THE THIRD PARAMETER, AND THE  *
*        VALUE HAS BEEN STORED, BUT WAS TRUNCATED.  THE RETURN CODE   *
*        IS THE NUMBER OF BYTES LOST THROUGH TRUNCATION.              *
* ABEND CODES:                                                        *
* 0C3 (PL/1 ONCODE 8093 - "ERROR" CONDITION RAISED) - ISSUED WHEN AN  *
* ERROR OTHER THAN TRUNCATION OCCURS.                                 *
*                                                                     *
* THE REASON CODE (IN PLIRETV) IS AS FOLLOWS:                         *
*                                                                     *
* 500 -  INVALID PARAMETERS PASSED TO THIS ROUTINE.                   *
* OTHER CODES ARE 500 + THE RETURN CODE FROM IKJCT441, THE CLIST      *
* VARIABLE ACCESS FACILITY, IF THAT ROUTINE FAILED.                   *
*                                                                     *
* PROCESSING:                                                         *
*  THE CLIST VARIABLE ACCESS FACILITY IS USED TO RETRIEVE OR UPDATE   *
*  THE REQUESTED CLIST VARIABLE IN THE CURRENTLY ACTIVE CLIST.        *
*  THE VALUE IS NOT CASE SHIFTED OR OTHERWISE TRANSLATED IN ANY WAY   *
*  (NORMAL CLIST PROCESSING DOES ITS OWN CHARACTER TRANSLATION).      *
*                                                                     *
*  A MESSAGE WILL BE DISPLAYED FOR A NONZERO RETURN CODE (CONTROL     *
*  NOMSG OR COMMAND OUTPUT TRAPPING WILL SUPPRESS THESE MESSAGES).    *
*                                                                     *
* DOCUMENTATION:                                                      *
* THE CLIST VARIABLE ACCESS FACILITY IS DOCUMENTED IN THE TSO         *
* GUIDE TO WRITING A TMP OR A COMMAND PROCESSOR FOR TSO/E RELEASE 2.  *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    MISCELLANEOUS USES
R4       EQU   4    RETURN CODE FR OM IKJCT441
R5       EQU   5    RESERVED FOR PL/1
R6       EQU   6    POINTER TO DOPE VECTOR FOR ARG 1
R7       EQU   7    POINTER TO DOPE VECTOR FOR ARG 2
R8       EQU   8    POINTER TO DOPE VECTOR FOR ARG 3
R9       EQU   9    ADDRESS OF VARIABLE NAME
R10      EQU   10   LENGTH OF VARIABLE NAME
R11      EQU   11   STATIC BASE REGISTER
R12      EQU   12   RESERVED FOR PL/1
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XTSVARV  CSECT
         SAVE  (14,12),,&SYSDATE._&SYSTIME
         LR    R11,R15
         USING XTSVARV,R11
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         LR    R1,R2               RESTORE INPUT PARAMETER ADDRESS
         EJECT
         SPACE 1
***********************************************************************
*                                                                     *
* VALIDITY CHECK PARAMETER LIST                                       *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    0(R1),X'80'         IF VL BIT SHOWS 1 PARM PASSED
         BO    WRONG_NUMBER_ARGS   THEN ERROR
         TM    4(R1),X'80'         IF VL BIT SHOWS 2 PARMS PASSED
         BO    WRONG_NUMBER_ARGS   THEN ERROR
         TM    8(R1),X'80'         IF VL BIT DOESN'T SHOW 3 PARMS
         BZ    WRONG_NUMBER_ARGS   THEN ERRROR
         SPACE 1
***********************************************************************
*                                                                     *
* PROCESS PARAMETERS PASSED FROM PL/1                                 *
*                                                                     *
***********************************************************************
         SPACE 1
         LM    R6,R8,0(R1)         GET POINTERS TO DOPE VECTORS
         CLI   6(R6),X'00'         IF ARG1 IS NOT CHAR(*) {FIXED},
         BNE   INVALID_ARG_TYPE    THEN ERROR
         CLI   6(R7),X'80'         IF ARG2 IS NOT CHAR(*) {FIXED},
         BNE   INVALID_ARG_TYPE    THEN ERROR
         CLI   6(R8),X'80'         IF ARG3 IS NOT CHAR(*) {FIXED},
         BNE   INVALID_ARG_TYPE    THEN ERROR
         SPACE 1
***********************************************************************
*                                                                     *
* THE FIRST ARGUMENT MUST BE "R" (READ) OR "W" (WRITE).               *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,0(,R6)           GET ADDRESS OF ARG1 CHAR STRING
         CLI   0(R1),C'R'          MUST BE UPPER CASE R
         BE    ENTRY_CODE_READ
         CLI   0(R1),C'R'-X'40'    OR LOWER CASE R
         BE    ENTRY_CODE_READ
         CLI   0(R1),C'W'          OR UPPER CASE W
         BE    ENTRY_CODE_WRITE
         CLI   0(R1),C'W'-X'40'    OR LOWER CASE W
         BE    ENTRY_CODE_WRITE
         B     WRONG_ENTRY_CODE    ELSE ERROR
         SPACE 1
ENTRY_CODE_READ DS 0H
         MVI   MODE,TSVERETR       INDICATE READ MODE
         B     SET_NAME_LENGTH
ENTRY_CODE_WRITE DS 0H
         MVI   MODE,TSVEUPDT       INDICATE WRITE MODE
         B     SET_NAME_LENGTH
         SPACE 2
SET_NAME_LENGTH DS 0H
         SPACE 1
***********************************************************************
*                                                                     *
* TAKE THE VARIABLE NAME LENGTH AND ADJUST IT.                        *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME STRING
         LH    R10,0(,R1)          GET CURRENT LENGTH OF STRING
         LA    R9,2(,R1)           POINT TO TEXT OF STRING
         LTR   R10,R10             BYPASS CHECK IF LENGTH IS ZERO
         BNP   NOCHECK             (BUT LET IKJCT441 FLAG IT AS ERROR)
         CLI   0(R9),C'&&'         IF USER STARTED NAME WITH AMPERSAND
         BNE   NOAMP               THEN...
         LA    R9,1(,R9)            BUMP PAST IT
         BCTR  R10,0                AND ADJUST LENGTH ACCORDINGLY.
NOAMP    DS    0H                  ANYHOW...
         LA    R15,0(R9,R10)       POINT TO END OF STRING
         BCTR  R15,0               BUMP BACK TO LAST CHARACTER
BLOOP    CLI   0(R15),C' '         SCAN OFF TRAILING BLANKS
         BNE   ENDNAME
         BCTR  R15,0
         BCT   R10,BLOOP
ENDNAME  DS    0H                  NOW R10 HAS ACTUAL LENGTH
NOCHECK  DS    0H
         SPACE 2
SETPARMS DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* SET UP PARAMETERS TO PASS TO IKJCT441                               *
*                                                                     *
***********************************************************************
         SPACE 1
         XR    R0,R0               MAKE A ZERO
         XR    R1,R1
         IC    R1,MODE             PICK UP MODE
         ST    R1,CENTRY           SET ENTRY CODE IN PARAMETER LIST
         L     R1,0(,R7)           GET POINTER TO VARIABLE NAME
         ST    R10,CNAMEL          SET LENGTH OF VARIABLE NAME
         ST    R9,CNAMEA           SET ADDRESS OF VARIABLE NAME
         CLI   MODE,TSVERETR       IF MODE IS READ,
         BNE   NOTREAD             THEN...
         ST    R0,CVALUEA           CLEAR ADDRESS OF VARIABLE VALUE
         ST    R0,CVALUEL           CLEAR ADDRESS OF VARIABLE NAME
         B     AFTREAD             ELSE...
NOTREAD  DS    0H                   (SET TO UPDATE)
         L     R1,0(,R8)            GET POINTER TO VARIABLE VALUE
         LH    R2,0(,R1)            GET LENGTH OF VARIABLE VALUE
         ST    R2,CVALUEL           SET LENGTH OF VARIABLE VALUE
         LA    R2,2(,R1)            GET ADDRESS OF VARIABLE VALUE
         ST    R2,CVALUEA           SET ADDRESS OF VARIABLE VALUE
AFTREAD  DS    0H
         ST    R0,CTOKEN           SET TOKEN (NOT USED)
         LA    R14,CENTRY
         LA    R15,CNAMEA
         LA    R0,CNAMEL
         LA    R1,CVALUEA
         LA    R2,CVALUEL
         LA    R3,CTOKEN
         STM   R14,R3,CPARMS       SET UP PARAMETER LIST
         OI    CPARM6,X'80'        SET VL BIT
         LA    R1,CPARMS           POINT TO PARAMETER LIST
         L     R15,X'10'               GET ADDRESS OF CVT
         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE
         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441
         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE
         LR    R4,R15
         B     RET441(R4)          BRANCH DEPENDING ON RETURN CODE
RET441   B     OK                  RC=0 IS OK
         B     OK                  RC=4 IS OK
         B     RC8
         B     RC12
         B     RC16
         B     RC20
         B     RC24
         B     RC28
         B     RC32
         B     RC36
         B     RC40
         B     RC44
         B     RC48
         B     RC52
         B     RC56
         B     RC60
         SPACE 1
OK       DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IF READ MODE, SEE IF WE CAN COPY THE DATA INTO CALLER'S VARIABLE.   *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   MODE,TSVERETR       IF READ MODE
         BNE   RETURN              THEN...
         L     R2,0(,R8)           POINT TO CHAR(*) VAR ARG 3
         L     R9,CVALUEL          GET LENGTH OF RETURNED VALUE
         LA    R0,2(,R2)           SET ADDRESS OF WHERE TO MOVE IT
         LH    R1,4(,R8)           SET LENGTH OF WHERE TO MOVE IT
         L     R14,CVALUEA         SET ADDRESS OF WHAT TO MOVE
         LR    R15,R9              SET LENGTH OF WHAT TO MOVE
         MVCL  R0,R14              MOVE VALUE TO CALLER'S ARG 3
*
* BY HAPPY CIRCUMSTANCE, R15 NOW CONTAINS THE NUMBER OF BYTES NOT
* MOVED (I.E. TRUNCATED), WHICH IS ZERO IF IT ALL GOT MOVED.  WE
* CAN RETURN THIS AS THE RETURN CODE.
*
* SET LENGTH FIELD OF CHAR(*) VARYING ACCORDING TO HOW MUCH MOVED.
*
         SR    R9,R15              LENGTH MINUS TRUNCATION
         STH   R9,0(,R2)           GIVES LENGTH(STRING) TO BE SET
         B     RETURN              RETURN WITH CODE IN R15
         SPACE 1
RC8      DS    0H
         LA    R1,MSG8
         B     ERROR
         SPACE 1
RC12     DS    0H
         LA    R1,MSG12
         B     ERROR
         SPACE 1
RC16     DS    0H
         LA    R1,MSG16
         B     ERROR
         SPACE 1
RC20     DS    0H
         LA    R1,MSG20
         B     ERROR
         SPACE 1
RC24     DS    0H
         LA    R1,MSG24
         B     ERROR
         SPACE 1
RC28     DS    0H
         LA    R1,MSG28
         B     ERROR
         SPACE 1
RC32     DS    0H
         LA    R1,MSG32
         B     ERROR
         SPACE 1
RC36     DS    0H
         LA    R1,MSG36
         B     ERROR
         SPACE 1
RC40     DS    0H
         LA    R1,MSG40
         B     ERROR
         SPACE 1
RC44     DS    0H
         LA    R1,MSG44
         B     ERROR
         SPACE 1
RC48     DS    0H
         LA    R1,MSG48
         B     ERROR
         SPACE 1
RC52     DS    0H
         LA    R1,MSG52
         B     ERROR
         SPACE 1
RC56     DS    0H
         LA    R1,MSG56
         B     ERROR
         SPACE 1
RC60     DS    0H
         LA    R1,MSG60
         B     ERROR
         EJECT
ERROR    DS    0H
         SPACE 1
         USING PSA,0
         L     R15,PSATOLD           GET TCB ADDRESS
         USING TCB,R15
         L     R15,TCBJSCB           GET JSCB ADDRESS
         USING IEZJSCB,R15
         L     R15,JSCBACT           GET ADDRESS OF ACTIVE JSCB
         L     R15,JSCBPSCB          GET ADDRESS OF PSCB
         USING PSCB,R15
         MVC   IOPLUPT,PSCBUPT       SET UPT ADDRESS FOR PUTLINE
         L     R15,PSCBRLGB          GET ADDRESS OF RELOGON BUFFER
         USING RLGB,R15
         L     R8,RLGBECT            GET ADDRESS OF ECT
         ST    R8,IOPLECT            SET ECT ADDRESS FOR PUTLINE
         LA    R15,ECB
         ST    R15,IOPLECB          SET ECB ADDRESS IN IOPL
         MVC   PTLIST(LENPUTL),MPTLIST SET UP PUTLINE LIST FORM
         LA    R0,1                 (REG1 ALREADY POINTS TO MSG)
         STM   R0,R1,OLD            SET UP OUTPUT LINE DESCRIPTOR
         XC    ECB,ECB              CLEAR ECB FOR PUTLINE
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15              IF PUTLINE FAILED,
         BZ    PUTLOK               THEN...
DOTPUT   LA    R1,PUTLFAIL           DISPLAY PUTLINE FAILURE MESSAGE
         LA    R0,L'PUTLFAIL
         TPUT  (1),(0),R
         L     R1,OLD+4              GET ADDRESS OF ERROR MESSAGE
         LH    R0,0(,R1)             PICK UP LENGTH OF MESSAGE
         SH    R0,=H'5'              SUBTRACT LENGTH OF HEADER & BLANK
         LA    R1,5(,R1)             BUMP PAST HEADER & BLANK
         TPUT  (1),(0),R             AND DISPLAY VIA TPUT
PUTLOK   DS    0H
         SPACE 1
ABENDIT  DS    0H                   FORCE ONCODE8093
         SPACE 1
***********************************************************************
*                                                                     *
* R4 CONTAINS RETURN CODE FROM IKJCT441 (ZERO IF WAS NEVER CALLED)    *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R15,500(,R4)         SET REASON CODE = RC + 500
         ST    R15,68(,R12)         STORE IN PLIRETV AREA
         EX    0,*                  FORCE 0C3 ABEND
         EJECT
***********************************************************************
* RETURN TO CALLING ENVIRONMENT - R15 CONTAINS RETURN CODE            *
***********************************************************************
         SPACE 1
RETURN   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* STORE RETURN CODE IN TCA+X'44'.  THIS IS NECESSARY TO ALLOW THE     *
* CALLER TO PICK UP THE RETURN CODE VIA "PLIRETV" DESPITE NOT BEING   *
* ABLE TO SPECIFY OPTIONS(RETCODE) IN THE DECLARE.                    *
*                                                                     *
***********************************************************************
         SPACE 1
         ST    R15,68(,R12)        STORE RETURN CODE IN PL/1 TCA
         SPACE 1
         LR    R1,R13
         L     R13,4(,R13)
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* ERROR ROUTINES                                                      *
***********************************************************************
         SPACE 1
WRONG_NUMBER_ARGS DS 0H
         LA    R1,WRONG_NUMBER_ARGS_MESSAGE
         XR    R4,R4
         B     ERROR
         SPACE 1
INVALID_ARG_TYPE  DS 0H
         LA    R1,INVALID_ARG_TYPE_MESSAGE
         XR    R4,R4
         B     ERROR
         SPACE 1
WRONG_ENTRY_CODE  DS 0H
         LA    R1,WRONG_ENTRY_CODE_MESSAGE
         XR    R4,R4
         B     ERROR
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR) LIST FORM PUTLINE
LENPUTL  EQU   *-MPTLIST
         SPACE
WRONG_NUMBER_ARGS_MESSAGE WTO MF=L,                                    X
               ' XTSVARV: WRONG NUMBER OF ARGUMENTS PASSED TO XTSVARV.'
INVALID_ARG_TYPE_MESSAGE  WTO MF=L,                                    X
               ' XTSVARV: INVALID ARGUMENT TYPES PASSED TO XTSVARV.'
WRONG_ENTRY_CODE_MESSAGE  WTO MF=L,                                    X
               ' XTSVARV: CODE PASSED TO XTSVARV NOT "R" OR "W".'
MSG0     WTO   MF=L,' XTSVAR00: INVALID PARAMETERS PASSED TO XTSVARV.'
MSG4     EQU   0               VARIABLE RETURNED, DO NOT RESCAN
MSG8     WTO   MF=L,' XTSVAR08: CLIST VARIABLE REQUIRES EVALUATION.'
MSG12    WTO   MF=L,' XTSVAR12: REQUESTED CLIST VARIABLE IS A LABEL.'
MSG16    WTO   MF=L,' XTSVAR16: CANNOT UPDATE SYSTEM CLIST VARIABLE.'
MSG20    WTO   MF=L,' XTSVAR20: CLIST VARIABLE ACCESS RETURN CODE 20.'
MSG24    WTO   MF=L,' XTSVAR24: CLIST VARIABLE ACCESS RETURN CODE 24.'
MSG28    WTO   MF=L,' XTSVAR28: CLIST VARIABLE ACCESS RETURN CODE 28.'
MSG32    WTO   MF=L,' XTSVAR32: IKJCT441 GETMAIN/FREEMAIN FAILURE.'
MSG36    WTO   MF=L,' XTSVAR36: CLIST VARIABLE NAME IS TOO LONG.'
MSG40    WTO   MF=L,' XTSVAR40: NO CLIST IS CURRENTLY ACTIVE.'
MSG44    WTO   MF=L,' XTSVAR44: CLIST VARIABLE ACCESS RETURN CODE 44.'
MSG48    WTO   MF=L,' XTSVAR48: CLIST VARIABLE ACCESS RETURN CODE 48.'
MSG52    WTO   MF=L,' XTSVAR52: CLIST VARIABLE ACCESS RETURN CODE 52.'
MSG56    WTO   MF=L,' XTSVAR56: CLIST VARIABLE ACCESS RETURN CODE 56.'
MSG60    WTO   MF=L,' XTSVAR60: CLIST VARIABLE ACCESS RETURN CODE 60.'
         SPACE
PUTLFAIL DC    C'XTSVARV: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING IX
               SSUED VIA TPUT:'
         EJECT
         LTORG
         SPACE 3
         DROP  R11
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F                 OS SAVE AREA
         SPACE
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
OLD      DS    2F                  # OF SEGMENTS AND ADDRESS OF 1ST SEG
         SPACE
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE 2
CPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS
         SPACE 1
CPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE
CPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME
CPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME
CPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE
CPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE
CPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)
         SPACE 1
CENTRY   DC    A(0)                ENTRY CODE
CNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME
CNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME
CVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME
CVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE
CTOKEN   DC    A(0)                TOKEN (NOT USED)
         SPACE 1
MODE     DS    C                   R(EAD) OR W(RITE)
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJECT
         SPACE 1
         IKJCPPL
         SPACE 1
         IKJTSVT
         SPACE 1
         PRINT NOGEN
         IHAPSA
         SPACE 1
         CVT   DSECT=YES
         SPACE 1
         IKJTCB
         SPACE 1
         IEZJSCB
         SPACE 1
         IKJPSCB
         SPACE 1
         IKJRLGB
         END
./ ADD NAME=XUSERS   0100-07332-07332-0900-00390-00390-00000-SEB
         TITLE 'XUSERS - TSO command to display users logged on'
*
***********************************************************************
*                                                                     *
* XUSERS - based on the USERS program by PQS1448 (Peter Stasiowski).  *
*                                                                     *
* Rewritten as a TSO command processor by SEB1525 (Steve Bacher) 7/88 *
*                                                                     *
***********************************************************************
* This TSO command takes no operands (yet).
***********************************************************************
*
***********************************************************************
* INFORMATION ON THE GQSCAN MACRO INSTRUCTION MAY BE FOUND IN:        *
*      OS/VS2 SYSTEM PROGRAMMING LIBRARY: SUPERVISOR                  *
*                     GC28-1046-0                                     *
*             FIRST EDITION (DECEMBER, 1980)                          *
*                  WITH TNL GN28-4917                                 *
***********************************************************************
         SPACE 1
XUSERS   CSECT
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2   Misc.
R3       EQU   3   Address of each basic fixed RIB
R4       EQU   4   Address of output area
R5       EQU   5   Address of end of output area
R6       EQU   6   Address of each RIB extent
R7       EQU   7   RIB extent counter
R8       EQU   8   Address of variable section of RIB
R9       EQU   9   RIB counter
R10      EQU   10  Count of user names
R11      EQU   11  Address of user name buffer
R12      EQU   12  Base register
R13      EQU   13  Save area pointer
R14      EQU   14
R15      EQU   15
         EJECT
         SAVE  (14,12),,XUSERS_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XUSERS,R12
         LR    R2,R1               Save parameter address
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R15,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
*
* Initialization
*
         USING CPPL,R2
         SPACE 1
         MVC   PTLIST(LENPUTL),MPTLIST
         MVC   PTDATA(LENPUTD),MPTDATA
         MVC   IOPLUPT,CPPLUPT
         MVC   IOPLECT,CPPLECT
         MVC   MAJOR,=CL8'SYSIKJUA'
         MVC   MINOR,BLANKS
         MVC   TPUTAREA,BLANKS
         LA    R0,ECB
         ST    R0,IOPLECB
         XR    R0,R0
         ST    R0,GQREG0
         ST    R0,GQREG1
         ST    R0,TOK
         ST    R0,AREAPTR
         ST    R0,AREALEN
         ST    R0,QNAME
         ST    R0,RNAME
         ST    R0,SYSNM
         ST    R0,ASID
         ST    R0,REQCNT
         ST    R0,OWNCNT
         ST    R0,WAITCNT
         LA    R0,TOK              Address of token
         ST    R0,TOKEN
         MVC   REQLIM,=A(32767)    Request limit = max
         MVI   FLAGSA,B'11100000'  Scope=step, system, and systems
         MVI   FLAGSB,B'00000000'  Scope=step, system, and systems
         MVI   RNMLEN,0            RNAME length
         LA    R0,MAJOR            PLACE ADDRESS OF QNAME
         ST    R0,QNAME            IN PARAMETER LIST
         L     R0,INCR             GET FIRST LENGTH OF AREA
         ST    R0,AREALEN          SAVE IT
         GETMAIN R,LV=(0)          GET IT
         ST    R1,AREAPTR          SAVE ADDRESS OF AREA
         SPACE
         L     R0,=A(UBUFLEN)      Get storage to hold enough userids
         GETMAIN R,LV=(0)
         LR    R11,R1
         ST    R11,UBUFPTR
         XR    R10,R10
         SPACE
RETRY    DS    0H
         L     R1,AREAPTR          GET ADDRESS OF CURRENT AREA
         EJECT
***********************************************************************
         SPACE
         GQSCAN MF=(E,QSPARMS)     SCAN ENQ INFO
         SPACE
***********************************************************************
         EJECT
AFTQCSAN DS    0H
         STM   R0,R1,GQREGS        SAVE RETURN PARAMETER REGISTERS
         LR    R9,R1               GET NUMBER OF RIBS RETURNED
         LTR   R2,R15              TEST RETURN CODE FROM GQSCAN
         BZ    DISPLAY             IF ZERO, GO SHOW USER
         CH    R2,=H'4'            IF RC=4 (NO DATA)
         BNE   TRY8                THEN
         LA    R1,MSG_NODATA        Say no TSO users
         BAL   R14,PUTMSG
         LA    R15,4                Set return code to 4
         B     RETURN
         SPACE
TRY8     CH    R2,=H'8'            IF RC=8 (TOO MUCH DATA)
         BNE   NOT8                THEN
         L     R0,AREALEN           GET CURRENT AREA LENGTH
         L     R1,AREAPTR           GET CURRENT AREA ADDRESS
         FREEMAIN R,LV=(0),A=(1)    FREE EXISTING AREA
         L     R0,INCR              GET AREA LENGTH INCREMENT
         AL    R0,AREALEN           INCREASE THE LENGTH
         ST    R0,AREALEN           SAVE IT
         GETMAIN RC,LV=(0)          TRY TO GET IT
         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA IF ANY
         LTR   R15,R15              IF COULD NOT GET IT
         BZ    RETRY                THEN
         L     R0,AREALEN           GET LENGTH
         S     R0,INCR              GO BACK TO PREVIOUS LENGTH
         GETMAIN R,LV=(0)           GET IT (WE KNOW THAT WE CAN)
         ST    R1,AREAPTR           SAVE ADDRESS OF GOTTEN AREA
         LA    R1,NEEDED_MORE_DATA
         BAL   R14,PUTMSG
         B     RETRY                AND TRY AGAIN.
         SPACE
NOT8     DS    0H
         LA    R1,ABENDMSG
         BAL   R14,PUTMSG
         ABEND (R2),DUMP
         EJECT
DISPLAY  DS    0H                  OK - NOW DISPLAY INFO
         SPACE
         L     R3,AREAPTR          START OF Q INFO
         USING RIB,R3              ADDRESS THE BASIC FIXED RIB
CONTINUE DS    0H
         LH    R8,LRIBFIX          LENGTH OF FIXED RIB
         ALR   R8,R3                PLUS ADDRESS OF FIXED RIB
         USING RIBVAR,R8            GIVES VARIABLE SECTION OF RIB
         ICM   R7,15,RIBNRIBE      GET NUMBER OF EXTENTS RETURNED
         BZ    NOEXTS              IF NONE, BYPASS
         LR    R6,R8               BUMP PAST VARIABLE PART OF RIB
         AH    R6,RIBVLEN          BUMP PAST VARIABLE PART OF RIB
         USING RIBE,R6             RIB EXTENT
EXTLOOP  DS    0H
         LA    R10,1(,R10)         Increment userid count
         CH    R10,=Y(512)         If more than we can handle
         BNH   OKSOFAR             then...
         LA    R1,TOOMANYUSERS
         BAL   R14,PUTMSG
         LA    R15,16
         B     RETURN
         SPACE 1
OKSOFAR  DS    0H
         MVC   0(8,R11),RIBRNAME   Add user name to user name buffer
         LA    R11,8(,R11)         Get ready for next user name
         SPACE
         AH    R6,LRIBE            ADDR(RIBE)+LENGTH(RIBE) -> NEXT RIBE
         BCT   R7,EXTLOOP          LOOP UNTIL NO MORE EXTENTS
         SPACE
NOEXTS   DS    0H
         LA    R3,0(,R6)           END OF PREV RIBE = BEGIN NEXT RIBE
         BCT   R9,CONTINUE         CONTINUE UNTIL NO MORE RIBS
         SPACE
*
***********************************************************************
*                                                                     *
* All user names stored in the user name buffer.  Now write out stuff *
*                                                                     *
***********************************************************************
*
         MVC   TPUTAREA+0(L'TSOUSERS),TSOUSERS
         CVD   R10,DOUBLE          Convert number of TSO users
         MVC   TPUTAREA+L'TSOUSERS(4),=X'40202120'
         ED    TPUTAREA+L'TSOUSERS(4),DOUBLE+6
         LA    R4,TPUTAREA+L'TSOUSERS+4
         BAL   R14,LINEOUT         Write "TSO USERS nnn"
         MVC   TPUTAREA,BLANKS
*
***********************************************************************
*                                                                     *
* Sort the userids by name.  This code taken from PQS1448 "USERS" cmd *
*                                                                     *
***********************************************************************
*
SRT      CH    R10,=H'1'           Skip sort if only one user
         BNH   PRT
SRT1     LR    R0,R10              Get number of user names - 1
         BCTR  R0,0
         XR    R15,R15             Set something-moved flag = off
         L     R1,UBUFPTR          Get address of first user name
SRT2     CLC   0(8,R1),8(R1)       If username(i) > username(i+1)
         BNH   SRT3                then...
         MVC   DOUBLE(8),0(R1)      swap usernames
         MVC   0(8,R1),8(R1)
         MVC   8(8,R1),DOUBLE
         LA    R15,1                set something-moved flag = on
SRT3     LA    R1,8(,R1)           Next username
         BCT   R0,SRT2             Loop until all usernames processed
         LTR   R15,R15             If anything was moved this round,
         BNZ   SRT1                then do another sorting loop
         SPACE 1
PRT      DS    0H                  Now ready to print sorted userids
         SPACE 1
         L     R11,UBUFPTR         Point to sorted user names
         LA    R4,TPUTAREA         Point to output area
         LA    R5,TPUTAREA+L'TPUTAREA-9 Point to end of output area
         SPACE 1
WRITEM   DS    0H
         CR    R4,R5               If at end of output line
         BNH   NOOUT               then
         BAL   R14,LINEOUT          write out the current line
NOOUT    DS    0H
         MVC   0(8,R4),0(R11)      Move userid
         MVI   8(R4),C' '          Separate user names
         LA    R4,9(,R4)           Bump line pointer
         LA    R11,8(,R11)         Bump user buffer pointer
         BCT   R10,WRITEM          Loop (#-of-users) times
         BAL   R14,LINEOUT         Then write out last line if any
         XR    R15,R15             Set return code to zero
         EJECT
RETURN   DS    0H
         L     R0,AREALEN
         L     R1,AREAPTR
         FREEMAIN R,LV=(0),A=(1)
         L     R0,=A(UBUFLEN)
         L     R1,UBUFPTR
         FREEMAIN R,LV=(0),A=(1)
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        Store return code in savearea
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
LINEOUT  DS    0H                  Write a line
         LR    R2,R14              Save return address
         LR    R0,R4               Point to end of data written so far
         LA    R1,TPUTAREA         Point to beginning of data
         SR    R0,R1               Get length of data
         BNPR  R2                  If no data to write, skip
         AH    R0,=H'4'            Set up header for PUTLINE
         SLL   R0,16
         ST    R0,TPUTHDR
         PUTLINE PARM=PTDATA,MF=(E,IOPL),                              X
               OUTPUT=(TPUTHDR,TERM,SINGLE,DATA)
         LA    R4,TPUTAREA         Place to put next user name
         LTR   R15,R15             Check return code from PUTLINE
         BZR   R2                  If OK, return
         LR    R2,R15              Else save return code
         TPUT  BADPUT,L'BADPUT     Write error message
         LA    R0,L'TPUTAREA
         LA    R1,TPUTAREA
         SLR   R0,R1
         TPUT  (1),(0),R           Write line we tried to put out
         ABEND (R2),DUMP           Abend with PUTLINE RC as user code
         EJECT
PUTMSG   DS    0H                  Display message via PUTLINE
*
*                                  R1 -> message header || text
*
         LR    R2,R14              Save return address
         LA    R0,1                Define 1 message segment
         STM   R0,R1,OLD           Set up output line descriptor
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R1,R15              If PUTLINE OK,
         BZR   R2                  then return. Else
         ABEND (1),DUMP            Abend with PUTLINE RC as user code
         EJECT
         SPACE
MPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
LENPUTL  EQU   *-MPTLIST
         SPACE
MPTDATA  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,DATA)
LENPUTD  EQU   *-MPTDATA
         SPACE
INCR     DC    F'8192'             INCREMENT FOR GETMAINS
         SPACE
         SPACE 1
BLANKS   DC    CL256' '
         EJECT
TSOUSERS DC    C'TSO USERS '
BADPUT   DC    C'XUSERS PUTLINE failure trying to write this line:'
ABENDMSG WTO   MF=L,'XUSERS002 XUSERS failed, GQSCAN error code = ABENDX
                code of following ABEND.'
TOOMANYUSERS WTO MF=L,                                                 X
               'XUSERS003 More than 512 TSO users logged on.'
MSG_NODATA WTO MF=L,'XUSERS001 No TSO users are logged on.'
NEEDED_MORE_DATA WTO MF=L,'XUSERS needed more storage to get all data.'
         EJECT
         LTORG
         SPACE
         EJECT
DATD     DSECT
         SPACE 1
SAVEAREA DS    9D
DOUBLE   DS    D
*
* VALUES PASSED BACK FROM THE GQSCAN SERVICE
*
GQREGS   DS    2F
         ORG   GQREGS
GQREG0   DS    F                   REGISTER ZERO FROM GQSCAN
         ORG   GQREG0
LRIBFIX  DS    H                   LENGTH OF EACH FIXED RIB
LRIBE    DS    H                   LENGTH OF EACH RIBE
GQREG1   DS    F                   REGISTER ONE FROM GQSCAN
         ORG   GQREG1
NUMRIBS  DS    F                   NUMBER OF RIBS COPIED
TOK      DC    F'0'                TOKEN FOR GQSCAN PROCESSING (UNUSED)
MAJOR    DC    CL8' '
MINOR    DC    CL256' '
QSPARMS  DS    0F
         SPACE
***********************************************************************
*           PARAMETER LIST TO ISGQSCAN MAPPED AS FOLLOWS:             *
***********************************************************************
         SPACE
AREAPTR  DC    A(0)           AREAPTR    ADDR OF USER SPECIFIED AREA
AREALEN  DC    A(0)           AREALEN    SIZE OF USER SPECIFIED AREA
QNAME    DC    A(0)           QNAME      QNAME (MAJOR NAME) ADDRESS
RNAME    DC    A(0)           RNAME      RNAME (MINOR NAME) ADDRESS
SYSNM    DC    A(0)           SYSNM      SYSNAME ADDRESS
ASID     DC    A(0)           ASID       ASID VALUE
REQCNT   DC    A(0)           REQCNT     REQUEST COUNT
OWNCNT   DC    A(0)           OWNCNT     OWNER COUNT
WAITCNT  DC    A(0)           WAITCNT    WAIT COUNT
TOKEN    DC    A(TOK)         TOKEN      TOKEN ADDRESS
REQLIM   DC    A(32767)       REQLIM     REQUEST LIMIT = MAX
FLAGSA   DC    BL1'11100000'  FLAGSA     RESERVE/SCOPE FLAGS
*                            1.......    SCOPE=STEP
*                            .1......    SCOPE=SYSTEM
*                            ..1.....    SCOPE=SYSTEMS
*                            ...1....    SCOPE=LOCAL
*                            ....1...    SCOPE=GLOBAL
FLAGRNO  EQU   B'00000100'   .....1..    RESERVE=NO
FLAGRYES EQU   B'00000010'   ......1.    RESERVE=YES
*                            .......1    RESERVED
FLAGSB   DC  BL1'00000000'    FLAGSB     VARIABLE SPECIFIED FLAGS
FLAGSYSN EQU   B'10000000'   1.......    SYSNAME SPECIFIED
*                            .1......    REQCNT SPECIFIED
*                            ..1.....    OWNCNT SPECIFIED
FLAGWAIT EQU   B'00010000'   ...1....    WAITCNT SPECIFIED
FLAGTOK  EQU   B'00001000'   ....1...    TOKEN SPECIFIED
*                            .....1..    RESERVED
*                            ......1.    RESERVED
*                            .......1    RESERVED
RNMLEN   DC    YL1(0)                    RNAME LENGTH
         SPACE
UBUFPTR  DC    A(0)
UBUFLEN  EQU   512*8               Room for 512 userids
         SPACE
ECB      DS    F                   ECB FOR TSO ROUTINES
OLD      DS    0F                  PUTLINE OUTPUT LINE DESCRIPTOR
OLDF1    DS    F'1'                NUMBER OF MESSAGE SEGMENTS
OLDMSG   DS    A(*-*)              ADDRESS OF THE FIRST MESSAGE SEGMENT
         SPACE 1
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
PTDATA   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,DATA)
         SPACE 1
IOPL     DS    0H
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE 1
TPUTHDR  DS    F
TPUTAREA DS    CL(8*9)
         SPACE 1
SIZDATD  EQU   *-DATD
         EJECT
         ISGRIB ,   MAP THE DATA PASSED BACK BY ISGQSCAN
         SPACE
         IKJCPPL
         SPACE
         CVT    DSECT=YES,PREFIX=YES
         SPACE
         END
./ ADD NAME=XUSING   0100-07332-07332-0900-00490-00490-00000-SEB
         TITLE 'XUSING - TSO COMMAND TO DISPLAY WHO''S USING A DEVICE'
***********************************************************************
*                                                                     *
* SYNTAX:   XUSING VOLUME(VOLSER) UNIT(UNITNUMBER) DEVICE(UNITNUMBER) *
*                                                                     *
* RETURN CODE: 0 - NOBODY IS USING THE DEVICE                         *
*              4 - SOMEBODY IS USING THE DEVICE                       *
*              8 - DEVICE NOT FOUND                                   *
*             12 - INVALID INPUT TO COMMAND                           *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    ADDRESS THE CVT
R4       EQU   4    ADDRESS THE PDL (PARSE OUTPUT)
R5       EQU   5    ADDRESS THE UCB
R6       EQU   6    .
R7       EQU   7    LINK REGISTER FOR PUTLINE
R8       EQU   8    ADDRESS OF FIRST IOQ FOR UCB
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XUSING   CSECT
         SAVE  (14,12),,XUSING_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XUSING,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
         USING CPPL,R2             ADDRESS INPUT CPPL
         XC    ANSWER,ANSWER
         MVC   IOPLUPT,CPPLUPT
         MVC   IOPLECT,CPPLECT
         MVC   PPLUPT,CPPLUPT
         MVC   PPLECT,CPPLECT
         LA    R14,ECB
         ST    R14,IOPLECB
         L     R15,=V(XFVOLPCL)
         LA    R0,ANSWER
         L     R1,CPPLCBUF
         STM   R14,R1,PPLECB
         ST    R13,PPLUWA          USER WORK AREA = "DATD"
         MVC   PTLIST(PTLISTL),SPTLIST
         LA    R14,1
         LA    R15,OUTHDR
         LA    R0,L'OUTLINE+4
         SLL   R0,16
         STM   R14,R0,OLD
         SPACE
         XC    ECB,ECB
         CALLTSSR EP=IKJPARS,MF=(E,PPL)
         LTR   R15,R15
         BNZ   RETURN12
         L     R4,ANSWER
         USING PDL,R4
         MVC   SRCHVOL,BLANKS
         MVC   SRCHCUU,BLANKS
         MVI   FLAGS,X'00'         INITIALIZE FLAGS
         TM    PDLVOL+6,X'80'      IF VOLUME SERIAL WAS SPECIFIED,
         BNO   BYPVOL              THEN...
         TM    PDLUNIT+6,X'80'      If unit name was also specified,
         BO    ERRBOTH               then error - can't specify both
         L     R14,PDLVOL+0         Get address of volume serial
         LH    R15,PDLVOL+4         Get length of volume serial
         BCTR  R15,0
         EX    R15,MVCVOL           Move volume serial to work area
         OI    FLAGS,VOLSPEC        INDICATE VOL SER SPECIFIED
         B     MOVEDONE
         SPACE 1
MVCVOL   MVC   SRCHVOL(0),0(R14)   Move volume serial to work area
         SPACE 1
BYPVOL   DS    0H                  No volume - look for unit
         TM    PDLUNIT+6,X'80'     If unit name was not specified
         BNO   ERRNONE              then error - need at least one
         L     R14,PDLUNIT+0       Get address of unit number
         MVC   SRCHCUU(3),0(R14)   Move unit number to work area
         OI    FLAGS,CUUSPEC        INDICATE UNIT NAME SPECIFIED
MOVEDONE DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Locate the UCB for this volume or unit.                             *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R3,X'10'            GET CVT ADDRESS
         USING CVTMAP,R3           SET UP ADDRESSABILITY TO CVT
         XC    WORKAREA,WORKAREA   CLEAR WORK AREA
         LA    R14,WORKAREA        GET ADDRESS OF WORK AREA
         LA    R15,DEVCLASS        GET ADDRESS OF AREA CONTAINING
         MVI   DEVCLASS,X'00'      THE DEVICE CLASS TO BE SEARCHED
         LA    R0,ADDRUCB          GET ADDRESS OF WORD WHERE SCAN
*                                  SERVICE WILL STORE THE UCB ADDRESS
         STM   R14,R0,PARMLIST
         OI    PARMUCB,X'80'       INDICATE END OF PARMLIST
         XR    R8,R8               CLEAR ENTRY COUNT
SEARCH   DS    0H
         LA    R1,PARMLIST         PUT PARMLIST ADDRESS IN REGISTER 1
         L     R15,CVTUCBSC        GET SCAN SERVICE ADDRESS
         BALR  R14,R15             GO TO SCAN SERVICE.
         LTR   R15,R15             HAS A UCB BEEN RETURNED?
         BNZ   NOMATCH             NO, AT END OF DEVICE CLASS AND
*                                  NO MATCH FOUND
         L     R5,ADDRUCB          GET UCB ADDR RETURNED BY SCAN SRVCE
         SH    R5,=Y(UCBOB-UCB)    Bump back to UCB prefix
         USING UCB,R5              SET UP ADDRESSABILITY TO UCB
         TM    FLAGS,VOLSPEC       IF VOLUME SERIAL REQUESTED,
         BZ    NOCHKVOL            THEN
         CLC   SRCHVOL,UCBVOLI      IS THIS THE VOL WE'RE LOOKING FOR?
         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.
NOCHKVOL DS    0H
         TM    FLAGS,CUUSPEC       IF UNIT NUMBER REQUESTED,
         BZ    NOCHKCUU            THEN
         CLC   SRCHCUU,UCBNAME      IS THIS THE CUU WE'RE LOOKING FOR?
         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.
NOCHKCUU DS    0H
*                                  NOTE:  THE WORK AREA MUST NOT BE
*                                         CHANGED BETWEEN CALLS TO
*                                         THE SCAN SERVICE ROUTINE
         SPACE
FOUND    DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* Now see if any jobs have this unit allocated, and who they are.     *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R8,UCBEXTPT         Get address of UCB extension
         USING UCBCMEXT,R8
         LH    R9,UCBASID          Get ASID that has this UCB allocated
         LTR   R9,R9
         BZ    NOTALLOC
         L     R15,X'10'           Get CVT address
         USING CVT,R15
         L     R10,CVTASVT         Get ASVT address
         DROP  R15
         USING ASVT,R10
         BCTR  R9,0
         SLA   R9,2                Convert ASID to ASVT index
         L     R11,ASVTENTY(R9)    Get ASCB address for this ASID
         USING ASCB,R11
         L     R6,ASCBCSCB         Get CSCB address
         USING CHAIN,R6
*
         MVI   OUTLINE,C' '
         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE
         MVC   OUTMSGID(L'MSGID),MSGID
         MVC   OUTVOL,UCBVOLI
         MVC   OUTUNIT,UCBNAME
         UNPK  OUTASID(5),UCBASID(3)
         TR    OUTASID(4),TRTBL
         MVI   OUTASID+4,C' '
         MVC   OUTNAME1,CHAIN+X'08'
         MVC   OUTNAME2,CHAIN+X'10'
         MVC   OUTNAME3,CHAIN+X'20'
         LA    R1,OUTLINE
         LA    R0,L'OUTLINE
         BAL   R7,PUTLINE          DISPLAY THIS ENTRY LINE
*
         B     RETURN0             Return, somebody has it allocated
         SPACE
NOMATCH  DS    0H
         MVC   OUTLINE(L'NOTFOUND),NOTFOUND
         TM    FLAGS,VOLSPEC       IF A VOLSER WAS REQUESTED
         BZ    WASNTVOL            THEN
         MVC   OUTLINE+(NFSTUFF-NF1)+0(7),=C'VOLUME '
         MVC   OUTLINE+(NFSTUFF-NF1)+7(6),SRCHVOL
         B     AFTWASNT
WASNTVOL DS    0H                  Else must have been a unit number
         MVC   OUTLINE+(NFSTUFF-NF1)+0(10),=C'UNIT NAME '
         MVC   OUTLINE+(NFSTUFF-NF1)+10(3),SRCHCUU
AFTWASNT DS    0H
         LA    R0,L'NOTFOUND+4
         STH   R0,OUTHDR
         BAL   R7,PUTLINE
         B     RETURN8
         EJECT
NOTALLOC DS    0H
         MVC   OUTLINE(L'NAMSG),NAMSG
         TM    FLAGS,VOLSPEC       IF A VOLSER WAS REQUESTED
         BZ    XASNTVOL            THEN
         MVC   OUTLINE+(NASTUFF-NA1)+0(7),=C'VOLUME '
         MVC   OUTLINE+(NASTUFF-NA1)+7(6),SRCHVOL
         B     AFTXASNT
XASNTVOL DS    0H                  Else must have been a unit number
         MVC   OUTLINE+(NASTUFF-NA1)+0(10),=C'UNIT NAME '
         MVC   OUTLINE+(NASTUFF-NA1)+10(3),SRCHCUU
AFTXASNT DS    0H
         LA    R0,L'NAMSG+4
         STH   R0,OUTHDR
         BAL   R7,PUTLINE
         B     RETURN4
         EJECT
ERRBOTH  DS    0H
         MVC   OUTLINE(L'BOTHMSG),BOTHMSG
         LA    R0,L'BOTHMSG+4
         STH   R0,OUTHDR
         BAL   R7,PUTLINE
         B     RETURN12
         SPACE 2
ERRNONE  DS    0H
         MVC   OUTLINE(L'NONEMSG),NONEMSG
         LA    R0,L'NONEMSG+4
         STH   R0,OUTHDR
         BAL   R7,PUTLINE
         B     RETURN12
         EJECT
RETURN4  DS    0H                  RETURN WITH CODE 4
         SPACE
         LA    R2,4                SET RETURN CODE TO FOUR
         B     RETURNP
         SPACE 2
RETURN8  DS    0H                  RETURN WITH CODE 8
         SPACE
         LA    R2,8                SET RETURN CODE TO EIGHT
         B     RETURNP
         SPACE 2
RETURN12 DS    0H                  RETURN WITH CODE 12
         SPACE
         LA    R2,12               SET RETURN CODE TO TWELVE
         B     RETURN              RETURN WITHOUT FREEING PARSE STORAGE
         SPACE 2
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
         XR    R2,R2               SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *
***********************************************************************
RETURNP  DS    0H
         SPACE
         LA    R1,ANSWER
         IKJRLSA (1)               RELEASE PARSE STORAGE
         SPACE
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *
***********************************************************************
RETURN   DS    0H
         LR    R1,R13
         L     R13,4(,R13)
         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* PUTLINE SUBROUTINE  - LINK REGISTER IS R7                           *
***********************************************************************
         SPACE
PUTLINE  DS    0H
         TR    OUTLINE(L'OUTLINE),TRANSTBL
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15
         BNZ   0(,R15)             BRANCH TO LOW CORE IF PUTLINE FAILS
         BR    R7
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE 1
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
SPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
PTLISTL  EQU   *-SPTLIST
         SPACE 1
MSGID    DC    C'XUSING01:'
NA1      DC    C'XUSING03: '
NASTUFF  DC    CL13' '
NA3      DC    C' NOT ALLOCATED'
NAMSG    EQU   NA1,*-NA1,C'C'
         SPACE
NF1      DC    C'XUSING02: '
NFSTUFF  DC    CL13' '
NF3      DC    C' NOT FOUND'
NOTFOUND EQU   NF1,*-NF1,C'C'
         SPACE
BLANKS   EQU   NFSTUFF,8,C'C'      GENERAL PURPOSE BLANKS
         SPACE
TESTTBL  DC    256YL1(*-TESTTBL)
         ORG   TESTTBL+C'*'
         DC    X'FF'
         ORG
         SPACE
MASKTBL  DC    256X'00'
         ORG   MASKTBL+C'*'
         DC    X'FF'
         ORG
         SPACE
TRANSTBL DS    0C
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/........,%_>?'
         DC    C'.........`:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    C'................'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
TRTBL    EQU   *-256
         EJECT
BOTHMSG  DC    C'XUSING05: Specify VOLUME or UNIT name, not both.'
NONEMSG  DC    C'XUSING04: Either a VOLUME or a UNIT name is required.'
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
*******************************************************************
*
*  Parse validity check exit for unitname.
*
*******************************************************************
         SPACE 1
UNITCHK  DS   0H
         SPACE 1
         STM   R14,R12,12(R13)
         LR    R12,R15
         USING UNITCHK,R12
         SPACE 1
         L     R8,0(,R1)           Get address of unit number PDE
         L     R5,0(,R8)           Get address of unit number
         LH    R6,4(,R8)           Get length of unit number
         LA    R0,3
         CR    R6,R0               Length must be equal to 3
         BNE   UNITNG
         TRT   0(3,R5),UNITTBL     Check for valid characters
         BZ    UNITOK
UNITNG   LA    R15,4               Invalid unit number
         B     UNITRET
UNITOK   XR    R15,R15             Valid unit number
UNITRET  L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14                 Return to PARSE
         SPACE 1
UNITTBL  DC    256YL1(1)           All characters invalid except...
         ORG   UNITTBL+C'0'        0-9
         DC    10YL1(0)             and
         ORG   UNITTBL+C'A'        A-F
         DC    6YL1(0)
         ORG   ,
         SPACE 1
         DROP  R12
         EJECT
***********************************************************************
* PARSE CONTROL BLOCKS CSECT                                          *
***********************************************************************
         SPACE 1
XFVOLPCL IKJPARM DSECT=PDL
         SPACE
XFVOLUME IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=SUBVOL
         SPACE
XFUNIT   IKJKEYWD
         IKJNAME 'UNIT',ALIAS='DEVICE',SUBFLD=SUBUNIT
         SPACE
SUBVOL   IKJSUBF
PDLVOL   IKJIDENT 'VOLUME SERIAL',UPPERCASE,                           X
               PROMPT='VOLUME SERIAL',                                 X
               MAXLNTH=6,FIRST=ANY,OTHER=ANY
         SPACE
SUBUNIT  IKJSUBF
PDLUNIT  IKJIDENT 'UNIT NUMBER',UPPERCASE,                             X
               PROMPT='UNIT NUMBER',VALIDCK=UNITCHK,                   X
               MAXLNTH=3,FIRST=ALPHANUM,OTHER=ALPHANUM
         SPACE
         IKJENDP
         SPACE
XUSING   CSECT
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE
PPL      DS    0A
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
         SPACE
ANSWER   DS    F                   ANSWER AREA FOR PARSE
         SPACE
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE
PARMLIST DS    3F                  PARMLIST MAPPING
         ORG   PARMLIST
PARMWA   DS    F                   ADDRESS OF 100-BYTE WORK AREA
PARMDEVT DS    F                   ADDRESS OF BYTE CONTAINING
*                                  THE DEVICE TYPE TO BE SEARCHED
PARMUCB  DS    F                   ADDRESS OF WORD TO CONTAIN THE
*                                  UCB ADDRESS
         SPACE
DEVCLASS DS    CL1                 BYTE CONTAINING DEVICE CLASS TO
*                                  TO BE SEARCHED FOR
ADDRUCB  DS    F                   WORD IN WHICH UCB SCAN WILL
*                                  PLACE THE ADDRESS OF THE UCB
         DS    0D                  ALIGN TO DOUBLE-WORD BOUNDARY.
*                                  WORK AREA FOR SCAN SERVICE MUST
*                                  BE ON A DOUBLE-WORD BOUNDARY.
WORKAREA DS    CL100               WORK AREA
SRCHVOL  DS    CL6                 VOLSER TO BE FOUND
SRCHCUU  DS    CL3                 UNIT TO BE FOUND
FLAGS    DS    X
VOLSPEC  EQU   X'80'               ON IF VOL SER SPECIFIED
CUUSPEC  EQU   X'40'               ON IF UNIT NAME SPECIFIED
ALLOCD   EQU   X'20'               ON IF UCB IS ALLOCATED BY SOMEBODY
         SPACE
OLD      DS    0A
OLD1     DC    F'1'
OLD2     DC    A(OUTHDR)
OUTHDR   DC    Y(L'OUTLINE+4,0)
OUTLINE  DS    CL79
         ORG   OUTLINE
OUTMSGID DS    CL(L'MSGID)
         DS    CL2
OUTVOL   DS    CL6
         DS    CL2
OUTUNIT  DS    CL3
         DS    CL2
OUTASID  DS    CL4
         DS    CL2
OUTNAME1 DS    CL8
         DS    CL2
OUTNAME2 DS    CL8
         DS    CL2
OUTNAME3 DS    CL8
         ORG
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJCPPL
         IEFUCBOB PREFIX=YES       UCB MAPPING MACRO
         IHAASVT                   ASCB MAPPING MACRO
         IHAASCB                   ASCB MAPPING MACRO
         IEECHAIN                  CSCB MAPPING MACRO
         CVT   DSECT=YES
         END
./ ADD NAME=XVOLUME  0100-07332-07332-0900-00573-00573-00000-SEB
         TITLE 'XVOLUME - TSO COMMAND TO DISPLAY INFO ON VOLSER'
***********************************************************************
*                                                                     *
* XVOLUME - A TSO COMMAND CREATED FROM THE TEXT OF A SAMPLE PROGRAM   *
*           FOUND IN THE XA SPL: SYSTEM MACROS AND FACILITIES MANUAL  *
*           TO DO A UCB SCAN.                                         *
*                                                                     *
* SYNTAX:   XVOLUME VOLUME(VOLSER) UNIT(UNITNAME) DEVICE(DEVTYPE)     *
* ALIAS:    XVOL                                                      *
*                                                                     *
* RETURN CODES: 0 - SUCCESSFUL COMPLETION                             *
*               4 - REQUESTED THING(S) NOT FOUND                      *
*                                                                     *
* This version of the command uses the UCBSCAN macro et al., required *
* for support of dynamic UCB's.  January 1996 SEB                     *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    ADDRESS THE CVT
R4       EQU   4    ADDRESS THE PDL (PARSE OUTPUT)
R5       EQU   5    ADDRESS THE UCB
R6       EQU   6    .
R7       EQU   7    LINK REGISTER FOR PUTLINE
R8       EQU   8    COUNT OF VOLUME ENTRIES FOUND
R9       EQU   9    .
R10      EQU   10   .
R11      EQU   11   .
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XVOLUME  CSECT
XVOLUME  AMODE 31
XVOLUME  RMODE ANY
         SAVE  (14,12),,XVOLUME_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING XVOLUME,R12
         LR    R2,R1               SAVE INPUT PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         EJECT
         USING CPPL,R2             ADDRESS INPUT CPPL
         XC    ANSWER,ANSWER
         MVC   IOPLUPT,CPPLUPT
         MVC   IOPLECT,CPPLECT
         MVC   PPLUPT,CPPLUPT
         MVC   PPLECT,CPPLECT
         LA    R14,ECB
         ST    R14,IOPLECB
         L     R15,=V(XFVOLPCL)
         LA    R0,ANSWER
         L     R1,CPPLCBUF
         STM   R14,R1,PPLECB
         ST    R13,PPLUWA          USER WORK AREA = "DATD"
         MVC   PTLIST(PTLISTL),SPTLIST
         LA    R14,1
         LA    R15,OUTHDR
         LA    R0,L'OUTLINE+4
         SLL   R0,16
         STM   R14,R0,OLD
         SPACE
         MVI   UVTATTR,10          SET LENGTH OF ATTRIBUTE AREA
         LA    R1,UVTATTR          SET ATTRIBUTE AREA ADDRESS
         ST    R1,UVTDEVT           IN UNIT TABLE
         LA    R0,UVTABLE
         LA    R1,UVFLAGS
         STM   R0,R1,UVPARMS       INITIALIZE PARMS FOR IEFEB4UV
         LOAD  EPLOC==CL8'IEFEB4UV',ERRET=NOUV GET UNIT VERIFIER MODULE
         ST    R0,@EB4UV           STORE ADDRESS OF IEFEB4UV
NOUV     DS    0H
         SPACE
         XC    ECB,ECB
         CALLTSSR EP=IKJPARS,MF=(E,PPL)
         LTR   R15,R15
         BNZ   RETURN12
         L     R4,ANSWER
         USING PDL,R4
         MVC   SRCHVOL,BLANKS
         MVC   SRCHCUU,BLANKS
         MVC   SRCHDEV,BLANKS
         MVI   FLAGS,X'00'         INITIALIZE FLAGS
         TM    PDLVOL+6,X'80'      IF VOLUME SERIAL WAS SPECIFIED,
         BNO   BYPVOL              THEN...
         L     R14,PDLVOL+0         GET ADDRESS OF VOLUME SERIAL
         LH    R15,PDLVOL+4         GET LENGTH OF VOLUME SERIAL
         BCTR  R15,0
         EX    R15,MVCVOL           MOVE VOLUME SERIAL TO WORK AREA
         MVC   VOLTEST,SRCHVOL
         TR    VOLTEST,TESTTBL      CREATE VOL SER TESTING FIELD
         MVC   VOLMASK,SRCHVOL
         TR    VOLMASK,MASKTBL      CREATE VOL SER TESTING MASK
         OI    FLAGS,VOLSPEC        INDICATE VOL SER SPECIFIED
BYPVOL   DS    0H
         TM    PDLUNIT+6,X'80'     IF UNIT OR DEVICE WAS SPECIFIED,
         BNO   BYPUNIT             THEN...
         L     R14,PDLUNIT+0        GET ADDRESS OF VOLUME SERIAL
         LH    R15,PDLUNIT+4        GET LENGTH OF VOLUME SERIAL
         BCTR  R15,0
         CH    R15,=H'2'            IF LENGTH OF UNIT IS 3,
         BNE   ISADEV               THEN
         EX    R15,MVCCUU            MOVE UNIT NUMBER TO WORK AREA
         MVC   CUUTEST,SRCHCUU
         TR    CUUTEST,TESTTBL       CREATE UNIT NAME TESTING FIELD
         MVC   CUUMASK,SRCHCUU
         TR    CUUMASK,MASKTBL       CREATE UNIT NAME TESTING MASK
         OI    FLAGS,CUUSPEC        INDICATE UNIT NAME SPECIFIED
         B     AFTDEV               ELSE
ISADEV   EX    R15,MVCDEV            MOVE DEVICE NAME TO WORK AREA
         MVC   DEVTEST,SRCHDEV
         TR    DEVTEST,TESTTBL       CREATE DEVICE TESTING FIELD
         MVC   DEVMASK,SRCHDEV
         TR    DEVMASK,MASKTBL       CREATE DEVICE TESTING MASK
         OI    FLAGS,DEVSPEC        INDICATE DEVICE TYPE SPECIFIED
AFTDEV   DS    0H
BYPUNIT  DS    0H
         L     R3,X'10'            GET CVT ADDRESS
         USING CVTMAP,R3           SET UP ADDRESSABILITY TO CVT
         XC    WORKAREA,WORKAREA   CLEAR WORK AREA
         LA    R14,WORKAREA        GET ADDRESS OF WORK AREA
         LA    R15,DEVCLASS        GET ADDRESS OF AREA CONTAINING
         MVI   DEVCLASS,X'00'      THE DEVICE CLASS TO BE SEARCHED
         LA    R0,ADDRUCB          GET ADDRESS OF WORD WHERE SCAN
*                                  SERVICE WILL STORE THE UCB ADDRESS
         STM   R14,R0,PARMLIST
         OI    PARMUCB,X'80'       INDICATE END OF PARMLIST
         XR    R8,R8               CLEAR ENTRY COUNT
SEARCH   DS    0H
         UCBSCAN COPY,WORKAREA=WORKAREA,UCBAREA=UCBAREA,               X
               DYNAMIC=YES,DEVCLASS=ALL,RANGE=ALL,                     X
               MF=(E,PUCBSCAN),PLISTVER=MAX
* ------ LA    R1,PARMLIST         PUT PARMLIST ADDRESS IN REGISTER 1
* ------ L     R15,CVTUCBSC        GET SCAN SERVICE ADDRESS
* ------ BALR  R14,R15             GO TO SCAN SERVICE.
         LTR   R15,R15             CHECK RETURN CODE
         BZ    MATCH               IF ZERO, MATCH WAS FOUND
         CH    R15,=H'4'           IF FOUR,
         BE    NOMATCH             NO MORE MATCHING UCB'S
         B     ERRORUCB            OTHERWISE SOME KIND OF ERROR
         SPACE
MATCH    DS    0H
*                                  NO MATCH FOUND
* ------ L     R5,ADDRUCB          GET UCB ADDR RETURNED BY SCAN SRVCE
         LA    R5,UCBAREA
         USING UCBOB,R5            SET UP ADDRESSABILITY TO UCB
         TM    FLAGS,VOLSPEC       IF VOLUME SERIAL REQUESTED,
         BZ    NOCHKVOL            THEN
         MVC   VOLUCBT,UCBVOLI      MOVE UCB VOLSER TO WORKAREA
         OC    VOLUCBT,VOLMASK      OR IT WITH THE MASK
         CLC   VOLUCBT,VOLTEST      IS THIS THE VOL WE'RE LOOKING FOR?
         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.
NOCHKVOL DS    0H
         TM    FLAGS,CUUSPEC       IF UNIT NUMBER REQUESTED,
         BZ    NOCHKCUU            THEN
         MVC   CUUUCBT,UCBNAME      MOVE UCB UNIT NAME TO WORKAREA
         OC    CUUUCBT,CUUMASK      OR IT WITH THE MASK
         CLC   CUUUCBT,CUUTEST      IS THIS THE CUU WE'RE LOOKING FOR?
         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.
NOCHKCUU DS    0H
*                                  NOTE:  THE WORK AREA MUST NOT BE
*                                         CHANGED BETWEEN CALLS TO
*                                         THE SCAN SERVICE ROUTINE
         SPACE
FOUND    DS    0H
         MVI   OUTLINE,C' '
         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE
         STCM  R5,15,OUTMSGID          PUT UCB ADDRESS IN MESSAGE
         UNPK  OUTMSGID(9),OUTMSGID(5)
         TR    OUTMSGID(8),TRTBL
         MVI   OUTMSGID+8,C' '
         MVC   OUTVOL,UCBVOLI
*XXX
         CLC   =CL3'UCB',UCBNAME
         BNE   MVUCBNAM
         UNPK  OUTUNIT(5),UCBCHAN(3)
         TR    OUTUNIT(4),TRTBL
         MVI   OUTUNIT+4,C' '
         B     AFTMVUCB
MVUCBNAM MVC   OUTUNIT+1(3),UCBNAME
AFTMVUCB DS    0H
         UNPK  OUTXTYPE(9),UCBTYP(5)
         TR    OUTXTYPE(8),TRTBL
         MVI   OUTP1,C'('
         MVI   OUTX1,C'X'
         MVI   OUTQ1,C''''
         MVI   OUTQ2,C''''
         MVI   OUTP2,C')'
         MVC   OUTTYPE,=CL8'        '
         TM    UCBSTAT,B'10000000'
         BZ    *+10
         MVC   OUTSTAT1(3),=CL3'ONL'
         TM    UCBSTAT,B'01000000'
         BZ    *+10
         MVC   OUTSTAT2(3),=CL3'CHG'
         TM    UCBSTAT,B'00100000'
         BZ    *+10
         MVC   OUTSTAT3(3),=CL3'RSV'
         TM    UCBSTAT,B'00010000'
         BZ    *+10
         MVC   OUTSTAT4(3),=CL3'UNL'
         TM    UCBSTAT,B'00001000'
         BZ    *+10
         MVC   OUTSTAT5(3),=CL3'ALC'
         TM    UCBSTAT,B'00000100'
         BZ    *+10
         MVC   OUTSTAT6(3),=CL3'PRS'
         TM    UCBSTAT,B'00000010'
         BZ    *+10
         MVC   OUTSTAT7(3),=CL3'SYR'
         TM    UCBSTAT,B'00000001'
         BZ    *+10
         MVC   OUTSTAT8(3),=CL3'DAD'
         L     R15,@EB4UV          GET ADDRESS OF IEFEB4UV
         LTR   R15,R15             IF IT WAS NOT SUCCESSFULLY LOADED
         BZ    DISPLAY             THEN BYPASS UNIT NAME ACCESS
         MVC   UVTDEVT,UCBTYP      SET DEVICE TYPE TO BE CONVERTED
         LA    R1,UVPARMS          GET ADDRESS OF PARMLIST FOR IEFEB4UV
         BASSM R14,R15             CALL IEFEB4UV IN ITS AMODE
         LTR   R15,R15             CHECK RETURN CODE FROM IEFEB4UV
         BZ    DEVFOUND            IF ZERO, WE GOT A UNIT NAME
         CH    R15,=H'4'           IF FOUR, NO UNIT NAME FOUND
         BE    DISPLAY             SO JUST LEAVE IT BLANK.
*                                  OTHERWISE A BAD RETURN CODE
         MVC   OUTTYPE,=CL8'(UVRC??)'
         CVD   R15,DOUBLE          CONVERT RETURN CODE TO DECIMAL
         UNPK  OUTTYPE+5(2),DOUBLE
         OI    OUTTYPE+6,X'F0'     AND PUT IT IN OUTPUT TYPE
         B     DISPLAY
DEVFOUND DS    0H
         TM    UVTATTR+1,B'00010000' IF UNIT NAME CONTAINS TP DEVICES
         BZ    NOTTP                 THEN
         MVC   OUTTYPE,=C'(TP DEV)'    INDICATE TP DEVICE IN OUTPUT
         B     DISPLAY               ELSE
NOTTP    MVC   OUTTYPE,UVTNAME         MOVE EBCDIC NAME TO OUTPUT LINE
DISPLAY  DS    0H
         TM    FLAGS,DEVSPEC       IF DEVICE TYPE REQUESTED,
         BZ    NOCHKDEV            THEN
         MVC   DEVUCBT,OUTTYPE      MOVE DEVICE NAME TO WORKAREA
         OC    DEVUCBT,DEVMASK      OR IT WITH THE MASK
         CLC   DEVUCBT,DEVTEST      IS THIS THE DEV WE'RE LOOKING FOR?
         BNE   SEARCH               NO, CONTINUE SCAN OF UCBS.
NOCHKDEV DS    0H
         LA    R8,1(,R8)           INCREMENT COUNT OF ENTRIES DISPLAYED
         LA    R1,OUTLINE
         LA    R0,L'OUTLINE
         BAL   R7,PUTLINE          DISPLAY THIS ENTRY LINE
         B     SEARCH              CONTINUE SEARCH
         SPACE
NOMATCH  DS    0H
         LTR   R8,R8               IF ENTRIES HAVE BEEN FOUND,
         BNZ   RETURN0             THEN RETURN NORMALLY. ELSE...
         MVC   OUTLINE(L'NOTFOUND),NOTFOUND
         TM    FLAGS,VOLSPEC       IF A VOLSER WAS REQUESTED
         BZ    WASNTVOL            THEN
         MVC   OUTLINE+(NFSTUFF-NF1)+0(7),=C'VOLUME '
         MVC   OUTLINE+(NFSTUFF-NF1)+7(6),SRCHVOL
         B     AFTWASNT
WASNTVOL DS    0H
         TM    FLAGS,CUUSPEC       IF A UNIT NUMBER WAS REQUESTED
         BZ    WASNTCUU            THEN
         MVC   OUTLINE+(NFSTUFF-NF1)+0(10),=C'UNIT NAME '
         MVC   OUTLINE+(NFSTUFF-NF1)+10(3),SRCHCUU
         B     AFTWASNT
WASNTCUU DS    0H
         TM    FLAGS,DEVSPEC       IF A DEVICE TYPE WAS REQUESTED
         BZ    WASNTDEV            THEN
         MVC   OUTLINE+(NFSTUFF-NF1)+0(5),=C'UNIT '
         MVC   OUTLINE+(NFSTUFF-NF1)+5(8),SRCHDEV
         B     AFTWASNT
WASNTDEV DS    0H
         MVC   OUTLINE+(NFSTUFF-NF1)+0(13),=C'UCB ENTRIES  '
AFTWASNT DS    0H
         LA    R0,L'NOTFOUND+4
         STH   R0,OUTHDR
         BAL   R7,PUTLINE
         B     RETURN4
         SPACE
ERRORUCB DS    0H
         MVC   OUTLINE(L'UBLEWIT),UBLEWIT
         LA    R0,L'UBLEWIT+4
         STH   R0,OUTHDR
         BAL   R7,PUTLINE
         B     RETURN12
         EJECT
RETURN4  DS    0H                  RETURN WITH CODE 4
         SPACE
         LA    R2,4                SET RETURN CODE TO FOUR
         B     RETURNP
         SPACE 2
RETURN12 DS    0H                  RETURN WITH CODE 12
         SPACE
         LA    R2,12               SET RETURN CODE TO TWELVE
         B     RETURN              RETURN WITHOUT FREEING PARSE STORAGE
         SPACE 2
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
         XR    R2,R2               SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT BUT FIRST RELEASE PARSE STORAGE       *
***********************************************************************
RETURNP  DS    0H
         SPACE
         L     R1,ANSWER
         IKJRLSA (1)               RELEASE PARSE STORAGE
         SPACE
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R2 CONTAINS RETURN CODE            *
***********************************************************************
RETURN   DS    0H
         DELETE EPLOC==CL8'IEFEB4UV'
         LR    R1,R13
         L     R13,4(,R13)
         ST    R2,16(,R13)         STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* PUTLINE SUBROUTINE  - LINK REGISTER IS R7                           *
***********************************************************************
         SPACE
PUTLINE  DS    0H
         TR    OUTLINE(L'OUTLINE),TRANSTBL
         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(OLD,TERM,SINGLE,INFOR)
         LTR   R15,R15
         BNZ   0(,R15)             BRANCH TO LOW CORE IF PUTLINE FAILS
         BR    R7
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE
MVCVOL   OC    SRCHVOL(0),0(R14)   MOVE VOLUME SERIAL FOLDING TO UPPER
MVCCUU   OC    SRCHCUU(0),0(R14)   MOVE UNIT NUMBER FOLDING TO UPPER
MVCDEV   OC    SRCHDEV(0),0(R14)   MOVE DEVICE NAME FOLDING TO UPPER
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE
SPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
PTLISTL  EQU   *-SPTLIST
         SPACE
UVFLAGS  DS    0X                  FLAGS FOR IEFEB4UV
         DC    B'00100001'         RETURN UNIT NAME,
*                                  CONVERT DEVICE NAME TO LOOK-UP VALUE
         DC    B'00000000'         NO OTHER OPTIONS REQUESTED
         SPACE
MSGID    DC    C'XVOL001:'
NF1      DC    C'XVOL002: '
NFSTUFF  DC    CL13' '
NF3      DC    C' NOT FOUND'
NOTFOUND EQU   NF1,*-NF1,C'C'
         SPACE
UBLEWIT  DC    C'XVOL003: UCBSCAN SERVICE FAILURE.'
         SPACE
BLANKS   EQU   NFSTUFF,8,C'C'      GENERAL PURPOSE BLANKS
         SPACE
TESTTBL  DC    256YL1(*-TESTTBL)
         ORG   TESTTBL+C'*'
         DC    X'FF'
         ORG
         SPACE
MASKTBL  DC    256X'00'
         ORG   MASKTBL+C'*'
         DC    X'FF'
         ORG
         SPACE
TRANSTBL DS    0C
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/........,%_>?'
         DC    C'.........`:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4BAD4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4BBD4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
TRTBL    EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* PARSE CONTROL BLOCKS CSECT                                          *
***********************************************************************
         SPACE 1
XFVOLPCL IKJPARM DSECT=PDL
         SPACE
XFVOLUME IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=SUBVOL
         SPACE
XFUNIT   IKJKEYWD
         IKJNAME 'UNIT',ALIAS='DEVICE',SUBFLD=SUBUNIT
         SPACE
SUBVOL   IKJSUBF
PDLVOL   IKJIDENT 'VOLUME SERIAL',                                     X
               PROMPT='VOLUME SERIAL OR VOLUME SERIAL MASK',           X
               MAXLNTH=6,FIRST=ANY,OTHER=ANY
         SPACE
SUBUNIT  IKJSUBF
PDLUNIT  IKJIDENT 'UNIT NAME',                                         X
               PROMPT='UNIT NUMBER, DEVICE TYPE, OR MASK',             X
               MAXLNTH=8,FIRST=ANY,OTHER=ANY
         SPACE
         IKJENDP
         SPACE
XVOLUME  CSECT
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
ECB      DS    F                   ECB FOR TSO SERVICE ROUTINES
@EB4UV   DC    A(0)                ADDRESS OF IEFEB4UV
IOPL     DS    0A
***********************************************************************
*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *
*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *
*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *
***********************************************************************
         SPACE
IOPLUPT  DS    A        PTR TO UPT
IOPLECT  DS    A        PTR TO ECT
IOPLECB  DS    A        PTR TO USER'S ECB
IOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK
         SPACE
PPL      DS    0A
***********************************************************************
*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *
*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *
***********************************************************************
         SPACE
PPLUPT   DS    A        PTR TO UPT
PPLECT   DS    A        PTR TO ECT
PPLECB   DS    A        PTR TO CP'S ECB
PPLPCL   DS    A        PTR TO PCL
PPLANS   DS    A        PTR TO ANS PLACE
PPLCBUF  DS    A        PTR TO CMD BUFFER
PPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)
         SPACE
ANSWER   DS    F                   ANSWER AREA FOR PARSE
         SPACE
PTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)
         SPACE
PARMLIST DS    3F                  PARMLIST MAPPING
         ORG   PARMLIST
PARMWA   DS    F                   ADDRESS OF 100-BYTE WORK AREA
PARMDEVT DS    F                   ADDRESS OF BYTE CONTAINING
*                                  THE DEVICE TYPE TO BE SEARCHED
PARMUCB  DS    F                   ADDRESS OF WORD TO CONTAIN THE
*                                  UCB ADDRESS
         SPACE
DEVCLASS DS    CL1                 BYTE CONTAINING DEVICE CLASS TO
*                                  TO BE SEARCHED FOR
ADDRUCB  DS    F                   WORD IN WHICH UCB SCAN WILL
*                                  PLACE THE ADDRESS OF THE UCB
         DS    0D                  ALIGN TO DOUBLE-WORD BOUNDARY.
*                                  WORK AREA FOR SCAN SERVICE MUST
*                                  BE ON A DOUBLE-WORD BOUNDARY.
WORKAREA DS    0F,CL100            WORK AREA
UCBAREA  DS    0F,CL48             WORK AREA
SRCHVOL  DS    CL6                 VOLSER TO BE FOUND
SRCHCUU  DS    CL3                 UNIT TO BE FOUND
SRCHDEV  DS    CL8                 DEVICE TO BE FOUND
UCBT     DS    CL8                 AREA FOR COMPARISONS
VOLUCBT  EQU   UCBT,6,C'C'
CUUUCBT  EQU   UCBT,3,C'C'
DEVUCBT  EQU   UCBT,8,C'C'
VOLTEST  DS    CL6                 VOL FOR COMPARISONS
CUUTEST  DS    CL3                 CUU FOR COMPARISONS
DEVTEST  DS    CL8                 DEV FOR COMPARISONS
VOLMASK  DS    CL6                 MASK FOR COMPARISONS
CUUMASK  DS    CL3                 MASK FOR COMPARISONS
DEVMASK  DS    CL8                 MASK FOR COMPARISONS
FLAGS    DS    X
VOLSPEC  EQU   X'80'               ON IF VOL SER SPECIFIED
CUUSPEC  EQU   X'40'               ON IF UNIT NAME SPECIFIED
DEVSPEC  EQU   X'20'               ON IF DEVICE TYPE SPECIFIED
         SPACE
         UCBSCAN MF=(L,PUCBSCAN),PLISTVER=MAX
         SPACE
UVPARMS  DS    0F                  PARAMETER LIST FOR IEFEB4UV
         SPACE
UVPARM1  DC    A(UVTABLE)          ADDRESS OF UNIT TABLE
UVPARM2  DC    A(UVFLAGS)          ADDRESS OF FLAGS
         SPACE
UVTABLE  DS    0F                  UNIT TABLE FOR IEFEB4UV
UVTNAME  DS    CL8                 UNIT NAME RETURNED BY IEFEB4UV
UVTDEVT  DS    XL4                 DEVICE TYPE TO BE CONVERTED
UVTATTRP DS    A(UVTATTR)          ZERO OR ADDRESS OF ATTRIBUTE AREA
         SPACE
UVTATTR  DC    X'0A',9X'00'        10-BYTE ATTRIBUTE AREA
         SPACE
OLD      DS    0A
OLD1     DC    F'1'
OLD2     DC    A(OUTHDR)
OUTHDR   DC    Y(L'OUTLINE+4,0)
OUTLINE  DS    CL79
         ORG   OUTLINE
OUTMSGID DS    CL8                 FORMERLY CL(L'MSGID)
         DS    CL3
OUTVOL   DS    CL6
         DS    CL2
OUTUNIT  DS    CL4
         DS    CL2
OUTTYPE  DS    CL8
         DS    CL1
OUTP1    DC    C'('
OUTX1    DC    C'X'
OUTQ1    DC    C''''
OUTXTYPE DS    CL8
OUTQ2    DC    C''''
OUTP2    DC    C')'
*
* New output fields added 05/15/87
*
         DS    CL1
OUTSTAT  EQU   *
OUTSTAT1 DS    CL3
         DS    CL1
OUTSTAT2 DS    CL3
         DS    CL1
OUTSTAT3 DS    CL3
         DS    CL1
OUTSTAT4 DS    CL3
         DS    CL1
OUTSTAT5 DS    CL3
         DS    CL1
OUTSTAT6 DS    CL3
         DS    CL1
OUTSTAT7 DS    CL3
         DS    CL1
OUTSTAT8 DS    CL3
         ORG
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         IKJCPPL
         EJECT
DSECTUCB DSECT ,
         SPACE 1
         IEFUCBOB ,                UCB MAPPING MACRO
         EJECT
         CVT   DSECT=YES
         END
./ ADD NAME=XVX      0100-07332-07332-0900-01517-01517-00000-SEB
         TITLE 'XVX - DISPLAY VIRTUAL STORAGE UNDER ISPF'
***********************************************************************
*                                                                     *
* XVX - ISPF DIALOG DRIVER TO DISPLAY VIRTUAL STORAGE                 *
*                                                                     *
* VERSION 2 - MODIFIED FOR ISPF VERSION 2                             *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2    MISCELLANEOUS USES
R3       EQU   3    MISCELLANEOUS USES
R4       EQU   4    LENGTH OF ARGUMENT FIELD
R5       EQU   5    BASE ADDRESS FIELD
R6       EQU   6    CURRENT ADDRESS FIELD
R7       EQU   7    WORK REGISTER TO BUILD DISPLAY
R8       EQU   8    WORK REGISTER TO BUILD DISPLAY
R9       EQU   9    *** AVAILABLE  ***
R10      EQU   10   DATA BUFFER ADDRESS
R11      EQU   11   STATIC BASE REGISTER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
XVX      CSECT
         SAVE  (14,12),,XVX_&SYSDATE._&SYSTIME
         LR    R12,R15
         LA    R11,2048(,R12)
         LA    R11,2048(,R11)
         USING XVX,R12,R11
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE
         LOAD  EPLOC==CL8'ISPLINK' FETCH ISPLINK MODULE
         ST    R0,@ISPLINK         SAVE ITS ADDRESS
         EJECT
***********************************************************************
* DETERMINE NUMBER OF OUTPUT LINES IN DYNAMIC AREA ON PANEL XVX       *
* THIS SHOULD BE THE NUMBER OF TERMINAL LINES MINUS 3, BUT IS         *
* ESTABLISHED BY THE PANEL DEFINITION.  THEREFORE, WE USE THE         *
* PQUERY SERVICE TO OBTAIN THE INFORMATION.                           *
***********************************************************************
         SPACE
*
* SET UP FOR VDEFINES. NOTE BOOTSTRAP VDEFINE FOR VXLINES FOR PQUERY.
*
         LA    R14,=C'VDEFINE'
         ST    R14,ISPPARM1
*
* ISPEXEC VDEFINE VXLINES FIXED(4)
*
         LA    R15,$VXLINES
         LA    R0,VXLINES
         LA    R1,=C'FIXED'
         LA    R2,$FOUR
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15             IF FIRST CALL TO ISPLINK FAILED,
         LTR   R15,R15             THEN RETURN (NOT UNDER ISPF).
         BNZ   NOISPF
*
* ISPEXEC PQUERY PANEL(XVX) AREANAME(VX) DEPTH(VXLINES)
*
         LA    R1,@PQUERY
         L     R15,@ISPLINK
         BALR  R14,R15
         CH    R15,H8              IF PQUERY FAILED,
         BNE   NOTPQ8              THEN SHOW ERROR PANEL AND QUIT
*
* ISPEXEC DISPLAY PANEL(XVXERROR)
*
         LA    R1,@ERRDISP
         L     R15,@ISPLINK
         BALR  R14,R15
         B     RETURN
NOTPQ8   DS    0H                  PQUERY SUCCESSFUL...
         L     R0,VXLINES          GET MAX NUMBER OF LINES FROM PQUERY
         STH   R0,#SHOW            SET NUMBER OF LINES TO SHOW
         STH   R0,#CURSHOW         SET NUMBER OF LINES TO SHOW
         MVI   #OLDSHOW,X'80'      FORCE NO PREVIOUS SHOW VALUE
         MVC   PANEL,$XVX          SET UP PANEL NAME
         LR    R2,R0               SAVE # OF LINES
         MH    R0,=H'80'           MULTIPLY # OF LINES BY WIDTH
         ST    R0,VXLEN            SET DYNAMIC SCREEN AREA SIZE
         SLA   R2,4                MULTIPLY BY 16 FOR MAX DATA LENGTH
         LA    R2,1(,R2)           ADD 1 FOR PADDING FOR UNPACKS
         ST    R2,BUFLEN           GIVING LENGTH OF DATA BUFFER
         LR    R0,R2               PUT IT BACK IN REGISTER 0
         GETMAIN R,LV=(0)          GET STORAGE FOR THE DATA BUFFER
         ST    R1,BUFADDR          SAVE ADDRESS OF THE DATA BUFFER
*
* DETERMINE MAXIMUM NUMBER OF LINES THAT CAN BE DISPLAYED
*
         L     R0,VXLINES          GET NUMBER OF LINES
         CH    R0,=H'40'           IF NUMBER OF LINES EXCEEDS 40
         BNH   INIT                THEN
         LA    R1,@ERRDISP          DISPLAY ERROR PANEL
         L     R15,@ISPLINK         (CAN'T PROCESS THAT MANY LINES)
         BALR  R14,R15
         B     RETURN               AND QUIT.
         EJECT
***********************************************************************
* INITIALIZE VARIABLES                                                *
***********************************************************************
         SPACE
INIT     DS    0H
         SPACE
         MVC   MSGID,$XVX          INITIALIZE MESSAGE ID
         MVI   ZCMD,C'0'           INITIALIZE COMMAND = "0"
         MVI   ZCMD+1,C' '
         MVC   ZCMD+2(L'ZCMD-2),ZCMD+1
         MVC   ZVERB,BLANKS
         XR    R5,R5               INITIAL BASE ADDRESS = ZERO
         XR    R6,R6               INITIAL CURRENT ADDRESS = ZERO
         ST    R6,ZSCROLLN         INITIAL SCROLL AMOUNT = ZERO
         STM   R5,R6,SYMFIRST      CLEAR SYMBOL CHAIN POINTERS
         ST    R5,STACKPTR         CLEAR BACKTRACKING STACK
         NI    BOOLEANS,255-BINMODE INITIALIZE MODE FLAG
         MVC   SCRSHIFT,INITSLA    INITIALIZE LINES->BYTES SHIFT INSTR
         EJECT
*
* ISPEXEC VDEFINE ZCMD CHAR(LENGTH(ZCMD))
*
         LA    R15,=C'ZCMD '
         LA    R0,ZCMD
         LA    R1,=C'CHAR'
         LA    R2,=A(L'ZCMD)
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDEFINE ZVERB CHAR(LENGTH(ZVERB))
*
         LA    R15,$ZVERB
         LA    R0,ZVERB
         LA    R1,=C'CHAR'
         LA    R2,$EIGHT           LENGTH OF ZVERB
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDEFINE ZSCROLLA CHAR(4)
*
         LA    R15,$ZSCRLLA
         LA    R0,ZSCROLLA
         LA    R1,=C'CHAR'
         LA    R2,$FOUR
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDEFINE ZSCROLLN FIXED(4)
*
         LA    R15,$ZSCRLLN
         LA    R0,ZSCROLLN
         LA    R1,=C'FIXED'
         LA    R2,$FOUR
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDEFINE VXLVLIN FIXED(4)
*
         LA    R15,=C'VXLVLIN '
         LA    R0,VXLVLIN
         LA    R1,=C'FIXED'
         LA    R2,$FOUR
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDEFINE VADDR HEX(4)
*
         LA    R15,=C'VADDR '
         LA    R0,VADDR
         LA    R1,=C'HEX'
         LA    R2,$FOUR
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDEFINE VLABEL CHAR(8)
*
         LA    R15,=C'VLABEL '
         LA    R0,VLABEL
         LA    R1,=C'CHAR'
         LA    R2,$EIGHT           LENGTH OF VLABEL
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC VDEFINE VX CHAR(VXLEN)
*
         LA    R15,$VX
         LA    R0,VX
         LA    R1,=C'CHAR'
         LA    R2,VXLEN
         STM   R15,R2,ISPPARM2
         OI    ISPPARM5,X'80'
         LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
*
* ISPEXEC CONTROL DISPLAY REFRESH
*
         LA    R1,@REFRESH
         L     R15,@ISPLINK
         BALR  R14,R15
         EJECT
***********************************************************************
* SET UP ESPIE ENVIRONMENT TO CATCH PROTECTION EXCEPTIONS.            *
* SPIE WON'T WORK BECAUSE AMODE WILL BE 31 WHEN PROGRAM CHECKS OCCUR. *
***********************************************************************
         SPACE
SETSPIE  ESPIE SET,SPIEEXIT,(4,5)  TRAP 0C4'S AND 0C5'S
         ST    R1,PREVSPIE         SAVE PREVIOUS PIE ADDRESS
         EJECT
LOOP     DS    0H                  MAIN PROCESSING LOOP
         SPACE
***********************************************************************
* INITIALIZE FLAGS AND DEFAULT SCROLLING NUMBER OF BYTES              *
***********************************************************************
         SPACE
         NI    BOOLEANS,255-BADADDR-DOPUSH-DOUPDATE-RETRY  INIT FLAGS
         STM   R5,R6,SAVEADRS      SET SAVED BASE & CURRENT ADDRESSES
         MVI   MSGNO,0             CLEAR MESSAGE ID
         SPACE
***********************************************************************
* EXTRACT ARGUMENT FROM ZCMD FIELD                                    *
***********************************************************************
         SPACE
         MVI   ARGUMENT,C' '
         MVC   ARGUMENT+1(L'ARGUMENT-1),ARGUMENT
         LA    R0,ZCMD
         LR    R1,R0
         LA    R14,1
         LA    R15,ZCMD+L'ZCMD-1
ZCMDLOOP DS    0H
         CLI   0(R1),C' '
         BE    ZCMDEND
         BXLE  R1,R14,ZCMDLOOP
ZCMDEND  DS    0H
         SR    R1,R0
         LTR   R4,R1               SET ARGUMENT LENGTH
         BNP   NOARG
         BCTR  R1,0
         EX    R1,MVCARG           MOVE FIRST WORD OF ZCMD TO ARGUMENT
NOARG    DS    0H
         CLC   ZVERB,BLANKS        IF ZVERB IS NULL
         BNE   CMDSRCH             THEN
         MVC   ZVERB,CLOCATE        INIT SET ZVERB = 'LOCATE'
         LTR   R4,R4                IF ARGUMENT LENGTH = ZERO
         BZ    RETSUCC              THEN PROCESS AS NULL COMMAND
         LTR   R1,R1                IF ARGUMENT LENGTH = ONE
         BNP   CMDSRCH              OR
         CLI   ARGUMENT,C'.'        ARGUMENT DOES NOT START W/PERIOD
         BE    DEFLABEL             OR
         CLI   ARGUMENT,C'!'        ARGUMENT DOES NOT START WITH "!"
         BNE   CMDSRCH              THEN GO TO PROCESS LOCATE COMMAND
         SPACE
DEFLABEL DS    0H                  ELSE ARGUMENT STARTS WITH PERIOD
*
* ARG STARTS WITH PERIOD, IS A LABEL DEFINITION
* EXTRACT NAME OF LABEL AND ADD IT TO IMMEDIATE-SYMBOL CHAIN
*
         CH    R4,=H'9'            IF LENGTH OF LABEL GREATER THAN 8
         BH    DEFLBLNG            THEN LABEL IS NO GOOD
         MVC   VLABEL,BLANKS       SET UP TEST LABEL IN UPPER CASE
         OC    VLABEL,ARGUMENT+1
         TRT   VLABEL,NAMETBL      VERIFY VALID CHARS
         BNZ   DEFLBLNG
         TM    VLABEL,X'F0'        LABEL CANNOT START WITH NUMERIC
         BNO   DEFLBLOK
DEFLBLNG MVI   MSGNO,15            IF BAD LABEL, SAY SO
         B     RETFAIL
DEFLBLOK DS    0H
         ST    R6,VADDR            SET ADDRESS FOR MESSAGES
         MVI   MSGNO,17            SAY LABEL REASSIGNED, BUT...
         LM    R15,R0,VLABEL       PUT SYMBOL ARGUMENT NAME IN REGS
         BAL   R14,GETISYM         GET IMMEDIATE SYMBOL
         LTR   R14,R1              IF ONE WAS FOUND (SET R14=0 IF NOT)
         BZ    DSSETNEW            THEN...
         CLI   ARGUMENT,C'!'        IF REASSIGN REQUESTED
         BE    DSSETSYM             THEN DO REASSIGN
         MVI   MSGNO,24             ELSE SAY LABEL ALREADY EXISTS
         B     RETFAIL              AND FLAG AS ERROR.
DSSETNEW MVI   MSGNO,16            ELSE SAY LABEL ASSIGNED AS NEW
         LA    R0,SYMLEN           GET LENGTH OF A SYMBOL ENTRY
         GETMAIN R,LV=(0)          GET STORAGE FOR ONE
         USING SYM,R1
*** ASSUME R14 = 0
         ST    R14,SYMNEXT         CLEAR CHAIN POINTER
         ICM   R15,15,SYMLAST      GET ADDRESS OF LAST SYMBOL
         BZ    DSNOLAST            IF THERE IS ONE,
         ST    R1,SYMNEXT-SYM(,R15) THEN CHAIN THIS OFF IT
         B     DSAFTLST            ELSE
DSNOLAST ST    R1,SYMFIRST          CHAIN THIS OFF HEADER
DSAFTLST ST    R1,SYMLAST          SET NEW LAST-ENTRY POINTER
DSSETSYM DS    0H                  LABEL NAME ALREADY EXISTS
         MVC   SYMNAME,VLABEL      ELSE SET NAME
         ST    R6,SYMADDR          SET ADDRESS=CURRENT ADDRESS
         B     RETSUCC
         DROP  R1
CMDSRCH  DS    0H
*
* SEARCH THE TABLE OF COMMANDS FOR THE COMMAND VERB
*
         LA    R1,CMDTABLE
         LA    R14,12
         LA    R15,CMDEND-12
CMDLOOP  CLC   0(8,R1),ZVERB
         BE    CMDFOUND
         BXLE  R1,R14,CMDLOOP
*                                  ELSE COMMAND NOT FOUND...
         MVI   MSGNO,03             SAY INVALID COMMAND
         B     RETFAIL
         SPACE
CMDFOUND DS    0H
         L     R15,8(,R1)          GET ADDRESS OF COMMAND PROCESSOR
         BR    R15                 PROCESS THE COMMAND
         SPACE
RETFAIL  DS    0H                  RETURN ADDRESS IF FAILURE
         LM    R5,R6,SAVEADRS      RESTORE SAVED BASE & CURRENT ADDR'S
         B     DISPLAY             AND GO REDISPLAY SAME SCREEN
         SPACE
RETPUSH  DS    0H
         OI    BOOLEANS,DOPUSH     INDICATE STACK ELEMENT TO BE PUSHED
         B     RETSUCC             PROCESS NORMALLY
         SPACE
RETUPDT  DS    0H
         OI    BOOLEANS,DOUPDATE   INDICATE STACK ELEMENT TO BE UPDATED
******** B     RETSUCC             PROCESS NORMALLY
         EJECT
RETSUCC  DS    0H                  COMMAND SUCCESSFUL
         SPACE
***********************************************************************
* PROCESS BASE ADDRESS IN R5 AND PROCESS CURRENT ADDRESS IN R6        *
***********************************************************************
         SPACE
         LR    R0,R6               CURRENT ADDRESS MINUS BASE ADDRESS
         SR    R0,R5               GIVES CURRENT OFFSET
         LPR   R0,R0               GET ABSOLUTE VALUE OF OFFSET
         SRA   R0,24               IF IT IS TOO LARGE (GT FFFFFF),
         BZ    *+6                 THEN...
         LR    R5,R6                RESET BASE SO THAT OFFSET = ZERO
         SPACE
***********************************************************************
* PREPARE FOR DATA MOVEMENT FROM VIRTUAL STORAGE TO BUFFER AREA.      *
* SET UP CODE TO MOVE DATA USING CURRENT SHOW VALUE                   *
***********************************************************************
         SPACE
         NI    BOOLEANS,255-RETRY  INITIALIZE RETRY FLAG
         LH    R0,#SHOW            GET # OF LINES TO SHOW
         CH    R0,#OLDSHOW         IF SAME AS PREVIOUS # OF LINES
         BE    DONTGEN             THEN BYPASS CODE GENERATION. ELSE
         STH   R0,#OLDSHOW         RESET PREVIOUS SHOW VALUE
GETDATA  DS    0H                  (RETRY POINT FOR DATA ACCESS)
*
* AT THIS POINT R0 CONTAINS THE # OF LINES TO DISPLAY.
*
         STH   R0,#CURSHOW         SET # OF LINES CURRENTLY SHOWN
         LA    R1,MVCAREA          INITIALIZE POINTER TO CODE AREA
         LH    R14,MVCBIN+2        INITIALIZE MVC ADDRESS 1
         LH    R15,MVCBIN+4        INITIALIZE MVC ADDRESS 2
GENMLOOP DS    0H                  GENERATE MVC INSTRUCTIONS IN AREA
         MVI   0(R1),X'D2'         BUILD MVC OP CODE
         STCM  R14,3,2(R1)         SET UP DESTINATION ADDRESS
         STCM  R15,3,4(R1)         SET UP SOURCE ADDRESS
         CH    R0,=H'16'           DO IN GROUPS OF 16 LINES
         BNH   GENMREST            UNTIL 16 LINES OR LESS ARE LEFT
         MVI   1(R1),X'FF'         BUILD LENGTH OPERAND = 256 BYTES
         LA    R1,6(,R1)           BUMP CODE POINTER
         LA    R14,256(,R14)       INCREMENT ADDRESS 1
         LA    R15,256(,R15)       INCREMENT ADDRESS 2
         SH    R0,=H'16'           DECREMENT LENGTH REMAINING TO MOVE
         B     GENMLOOP            AND CONTINUE LOOP
GENMREST DS    0H                  NOW HANDLE REMAINING LENGTH
         SLA   R0,4                # OF LINES * 16 = # OF BYTES TO MOVE
         BCTR  R0,0                REDUCE BY 1 FOR MVC LENGTH
         STC   R0,1(,R1)           BUILD LENGTH OPERAND
         MVC   6(2,R1),BR14        BUILD "BR 14" OP CODE TO FINISH
DONTGEN  DS    0H                  END OF CODE GENERATION
         SPACE
***********************************************************************
* NOW WE CAN ACTUALLY MOVE DATA FROM REQUESTED AREA TO OUR BUFFER     *
***********************************************************************
         SPACE
         L     R10,BUFADDR         SET ADDRESSABILITY TO BUFFER
         OI    BOOLEANS,PROT       SET PROTECTION FLAG FOR ESPIE
         NI    BOOLEANS,255-ABENDED    INITIALIZE PGM CHECK FLAG
         LA    R0,MOVEFAIL
         ST    R0,ERRET            SET RETURN ADDRESS (AMODE 24)
         L     R15,=A(MOVE31+X'80000000')
         BSM   0,R15               SWITCH TO AMODE 31
MOVE31   DS    0H
         TM    BOOLEANS,BINMODE    IF BINARY MODE IS ACTIVE
         BO    MOVEBIN             THEN DO SMALLER MOVE. ELSE...
*
* IF 0C4 OCCURS, ESPIE EXIT WILL CAUSE CONTROL TO GO TO "MOVEFAIL".
*
* NOTE: MOVES MUST BE DONE IN 256-BYTE GROUPS TO INSURE MAXIMUM
* CONSISTENCY OF DISPLAYED STORAGE.  USING MVCL WOULD NOT GUARANTEE
* THIS SINCE IT IS INTERRUPTIBLE.
*
         BAL   R14,MVCAREA         CALL GENERATED CODE TO MOVE DATA
         B     MOVEDOK
         SPACE
MOVEBIN  DS    0H
         LH    R14,#CURSHOW        GET # OF LINES TO SHOW CURRENTLY
         SLA   R14,2               MULTIPLY BY 4 TO GET # OF BYTES
         BCTR  R14,0               REDUCE FOR EXECUTE
         EX    R14,MVCBIN          MOVE DATA FROM STORAGE TO BUFFER
         B     MOVEDOK
*
* END ESPIE-PROTECTED CODE
*
MOVEFAIL DS    0H                  0C4 OCCURRED DURING DATA MOVE...
         SPACE
*
* NOTE THAT THE ESPIE EXIT SETS THIS RETURN POINT AS AMODE 24
*
         SPACE
***********************************************************************
* IF A PROTECTION EXCEPTION OCCURRED TRYING TO ACCESS THE REQUESTED   *
* VIRTUAL STORAGE AREA, IT MAY BE BECAUSE WE WERE TRYING TO ACCESS A  *
* BLOCK OF DATA THAT SPANNED 2 SEGMENTS THE SECOND OF WHICH WAS       *
* INACCESSIBLE.  IF THIS IS THE CASE WE WISH TO RETRY THE ACCESS AND  *
* ONLY DISPLAY THE FIRST SEGMENT.  SINCE WE MUST DISPLAY DATA IN      *
* 16-BYTE LINES, THIS CAN WORK ONLY IF THE REQUESTED ADDRESS          *
* REFERENCES AT LEAST 16 BYTES OF ACCESSIBLE STORAGE.                 *
* NOTE THAT THE TEST WAS CHANGED FROM 4K TO 2K TO PREPARE FOR NEW     *
* STORAGE PROTECTION FEATURES OF MVS/SP2.                             *
***********************************************************************
         SPACE
         TM    BOOLEANS,RETRY      IF THIS WAS 2ND ATTEMPT,
         BO    MOVERROR            THEN DATA CANNOT BE ACCESSED
         LR    R0,R6               ELSE GET CURRENT ADDRESS
         N     R0,=X'FFFFF800'     CONVERT TO 2K-SEGMENT ADDRESS
         AH    R0,=H'2048'         GET ADDRESS OF NEXT 2K SEGMENT
         SLR   R0,R6               GET LENGTH OF DATA IN THIS SEGMENT
         TM    BOOLEANS,BINMODE    IF IN BINARY MODE,
         BZ    RXSHIFT             THEN...
         SRA   R0,2                 DIVIDE BY 4 TO GET # OF LINES
         B     RTSHIFT             ELSE...
RXSHIFT  SRA   R0,4                 DIVIDE BY 16 TO GET # OF LINES
RTSHIFT  BZ    MOVERROR            IF 0, CANNOT RETRY, ERROR
         CH    R0,#CURSHOW         WE CAN RETRY ONLY IF # OF LINES IS
         BNL   MOVERROR             LESS THAN # WE TRIED TO ACCESS.
         MVI   #OLDSHOW,X'80'      FORCE REGENERATION OF CODE NEXT TIME
         OI    BOOLEANS,RETRY      INDICATE ANOTHER ATTEMPT
         B     GETDATA             AND GO TO TRY IT AGAIN.
         SPACE
MOVERROR DS    0H                  ACCESS TO DATA FAILED...
         NI    BOOLEANS,255-RETRY  TURN OFF RETRY INDICATOR
         MVI   MSGNO,07            SAY STORAGE NOT ACCESSIBLE
         B     RETFAIL             AND GO TO RESHOW CURRENT DISPLAY
MOVEDOK  DS    0H                  DATA MOVEMENT WAS OK
         SPACE
         LA    R15,MOVE24
         BSM   0,R15               SWITCH TO AMODE 24
MOVE24   DS    0H
         NI    BOOLEANS,255-PROT   TURN OFF PROTECTION TRAP
         TM    BOOLEANS,DOPUSH     IF WE'RE SUPPOSED TO PUSH,
         BZ    AFTPUSH             THEN
PUSH     DS    0H                   PUSH ADDRESS ONTO BACKTRACK STACK
*
* THIS ROUTINE PUSHES THE CURRENT BASE AND ADDRESS ONTO THE
* BACKTRACKING STACK.
*
         L     R1,STACKPTR         GET CURRENT STACK POINTER
         LA    R1,8(,R1)           INCREMENT BY 1 ENTRY
         CH    R1,=H'128'          IF THIS EXCEEDS SIZE OF STACK
         BH    STKOVFLO            THEN PROCESS STACK OVERFLOW
         ST    R1,STACKPTR         ELSE STORE NEW STACK POINTER
         LA    R1,BKSTACK-8(R1)    ADDRESS NEW CURRENT STACK ELEMENT
         STM   R5,R6,0(R1)         STORE CURRENT BASE & ADDR IN STACK
         B     AFTPUSH             ELSE...
STKOVFLO DS    0H
         MVC   BKSTACK(8*15),BKSTACK+8 SHIFT ENTRIES 2 THRU 16 OVER
         STM   R5,R6,BKSTACK+8*15  STORE CURRENT BASE & ADDR IN STACK
AFTPUSH  DS    0H
         SPACE
         TM    BOOLEANS,DOUPDATE   IF WE'RE SUPPOSED TO UPDATE,
         BZ    AFTUPDT             THEN
UPDATE   DS    0H                   UPDATE ADDRESS ON BACKTRACK STACK
*
* THIS ROUTINE INSERTS THE CURRENT BASE AND ADDRESS INTO THE
* CURRENT STACK ENTRY, REPLACING THE PREVIOUS CONTENTS.
*
         ICM   R1,15,STACKPTR      GET CURRENT STACK POINTER
         BZ    AFTUPDT             IF STACK IS NOT EMPTY, THEN...
         LA    R1,BKSTACK-8(R1)     POINT TO CURRENT STACK ENTRY
         STM   R5,R6,0(R1)          STORE CURRENT BASE & ADDR IN STACK
AFTUPDT  DS    0H
         SPACE
* CLEAR THE OUTPUT AREA TO BLANKS
         SPACE
         LA    R0,VX               SET OUTPUT ADDRESS
         LA    R1,VXEND-VX         SET OUTPUT LENGTH
         XR    R14,R14             CLEAR INPUT POINTER
         LA    R15,X'40'           SET UP SOURCE PADDING CHARACTER
         SLL   R15,24              SET UP SOURCE MVCL REGISTER LENGTH
         MVCL  R0,R14              CLEAR OUTPUT AREA TO BLANKS
*
* FOR EACH 16 BYTES OF BUFFER STORAGE, CONSTRUCT AN OUTPUT LINE
* (INPUT POINTER IS R10)
*
         TM    BOOLEANS,BINMODE    IF BINARY MODE IS ACTIVE
         BZ    SETXINCR            THEN
         LA    R1,4                 SET BUMPING INCREMENT TO 4
         B     SETAINCR            ELSE
SETXINCR LA    R1,16                SET BUMPING INCREMENT TO 16
SETAINCR DS    0H
         LA    R2,VX               SET INITIAL OUTPUT POINTER
         LR    R7,R6               SET CURRENT ADDRESS - BASE ADDRESS
         SR    R7,R5                = INITIAL OFFSET FROM BASE
         LR    R8,R6               SET INITIAL ADDRESS VALUE
         LH    R15,#CURSHOW        GET NUMBER OF LINES TO FORMAT
OUTLOOP  DS    0H
         LA    R14,C'+'            USE A PLUS SIGN UNLESS
         LTR   R7,R7
         BNM   *+8                 CURRENT LINE OFFSET IS NEGATIVE,
         LA    R14,C'-'            IN WHICH CASE USE A MINUS SIGN
         LPR   R0,R7               GET ABSOLUTE VALUE OF OFFSET
         ST    R0,DOUBLE           CONVERT RELATIVE OFFSET TO HEX
         UNPK  LOCOFF(9),DOUBLE(5)  DISPLAY IN LOCATION OFFSET FIELD
         TR    LOCOFF(8),HEXTBL
         LA    R3,LOCOFF-1         SCAN FOR LEADING ZEROES IN OFFSET
         LA    R0,7
EDITLOOP CLI   1(R3),C'0'
         BNE   EDITEND
         MVI   1(R3),C' '          REPLACING THEM WITH BLANKS
         LA    R3,1(,R3)
         BCT   R0,EDITLOOP
EDITEND  DS    0H
         STC   R14,0(,R3)          STORE SIGN INTO OFFSET DISPLAY
         MVI   0(R2),C' '          CLEAR OUTPUT LINE TO BLANKS
         MVC   1(79-1,R2),0(R2)
         MVC   0(8,R2),LOCOFF      MOVE OFFSET DISPLAY TO OUTPUT LINE
         MVI   8(R2),C' '
         ST    R8,DOUBLE           GET ADDRESS TO CONVERT TO HEX DSPL
         UNPK  10(9,R2),DOUBLE+0(5)
         TR    10(8,R2),HEXTBL
         MVI   18(R2),X'02'        MOVE ATTR CHAR FOR DATA FIELDS
         TM    BOOLEANS,BINMODE    IF BINARY MODE IS ACTIVE
         BO    UNBIN               THEN GO TO DO BINARY DECONVERSION
         UNPK  20(9,R2),0(5,R10)   ELSE DISPLAY HEX DATA
         TR    20(8,R2),HEXTBL
         MVI   28(R2),C' '
         UNPK  29(9,R2),4(5,R10)
         TR    29(8,R2),HEXTBL
         MVI   37(R2),C' '
         UNPK  38(9,R2),8(5,R10)
         TR    38(8,R2),HEXTBL
         MVI   46(R2),C' '
         UNPK  47(9,R2),12(5,R10)
         TR    47(8,R2),HEXTBL
         MVI   55(R2),C' '
         MVI   56(R2),X'01'        MOVE ATTR CHAR FOR ADDRESS FIELDS
         MVI   57(R2),C'*'
         MVC   58(16,R2),0(R10)
         TR    58(16,R2),TRANSTBL
         MVI   74(R2),C'*'
         B     UNDONE              ELSE
UNBIN    DS    0H                  BINARY DATA TO BE DISPLAYED
         MVC   20(1,R2),0(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA
         MVC   20+1(8,R2),20(R2)   PROPAGATE THROUGH OUTPUT SECTION
         NC    20(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS
         TR    20(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES
         MVI   20+4(R2),C' '       BLANK OUT THE MIDDLE PART
         MVC   30(1,R2),1(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA
         MVC   30+1(8,R2),30(R2)   PROPAGATE THROUGH OUTPUT SECTION
         NC    30(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS
         TR    30(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES
         MVI   30+4(R2),C' '       BLANK OUT THE MIDDLE PART
         MVC   40(1,R2),2(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA
         MVC   40+1(8,R2),40(R2)   PROPAGATE THROUGH OUTPUT SECTION
         NC    40(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS
         TR    40(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES
         MVI   40+4(R2),C' '       BLANK OUT THE MIDDLE PART
         MVC   50(1,R2),3(R10)     MOVE A BYTE TO OUTPUT BUFFER AREA
         MVC   50+1(8,R2),50(R2)   PROPAGATE THROUGH OUTPUT SECTION
         NC    50(9,R2),=X'804020100008040201' KEEP ONLY RELEVANT BITS
         TR    50(9,R2),BINTBL     TRANSLATE TO PRINTABLE ZEROES & ONES
         MVI   50+4(R2),C' '       BLANK OUT THE MIDDLE PART
         MVI   60(R2),X'01'        MOVE ATTR CHAR FOR DATA FIELDS
         UNPK  61(3,R2),0(2,R10)   MOVE HEX BYTE IN
         TR    61(2,R2),HEXTBL
         MVI   61+2(R2),C' '
         UNPK  64(3,R2),1(2,R10)   MOVE HEX BYTE IN
         TR    64(2,R2),HEXTBL
         MVI   64+2(R2),C' '
         UNPK  67(3,R2),2(2,R10)   MOVE HEX BYTE IN
         TR    67(2,R2),HEXTBL
         MVI   67+2(R2),C' '
         UNPK  70(3,R2),3(2,R10)   MOVE HEX BYTE IN
         TR    70(2,R2),HEXTBL
         MVI   70+2(R2),C' '
         MVI   74(R2),C'*'
         MVC   75(4,R2),0(R10)
         TR    75(4,R2),TRANSTBL
         MVI   79(R2),C'*'
UNDONE   DS    0H                  OK - OUTPUT LINE COMPLETE
         ALR   R7,R1               BUMP CURRENT OFFSET
         ALR   R8,R1               BUMP CURRENT ADDRESS
         LA    R2,80(,R2)          BUMP OUTPUT POINTER
         ALR   R10,R1              BUMP INPUT POINTER
         BCT   R15,OUTLOOP         REPEAT FOR ALL OUTPUT LINES
         SPACE
         MVI   ZCMD,C' '           SET ZCMD TO BLANKS
         MVC   ZCMD+1(L'ZCMD-1),ZCMD
         BCTR  R8,0                GET ADDRESS OF LAST BYTE MOVED
         LTR   R8,R8               IF ADDRESS PAST 7FFFFFFF,
         BNM   DISPLAY             THEN
         MVI   MSGNO,08             SAY WRAPAROUND OCCURRED
******** B     DISPLAY
         EJECT
DISPLAY  DS    0H
         SPACE
***********************************************************************
* ISPEXEC DISPLAY PANEL(PANEL) MSG(MSGID)                             *
***********************************************************************
         SPACE
         LA    R14,$DISPLAY
         LA    R15,PANEL
         LA    R0,MSGID
         STM   R14,R0,ISPPARMS
         XR    R15,R15             CLEAR INSERT REG
         ICM   R15,1,MSGNO         GET MESSAGE NUMBER
         BNZ   DISPMSG             IF ZERO, THEN...
         OI    ISPPARM2,X'80'       SET # OF PARMS TO 2 TO IGNORE MSGID
         B     DISPPNL             ELSE...
DISPMSG  CVD   R15,DOUBLE
         UNPK  MSGID+3(3),DOUBLE+6(2) CONVERT TO CHARACTER 999
         OI    MSGID+5,X'F0'        TO CREATE MESSAGE ID NUMBER
         OI    ISPPARM3,X'80'       SET # OF PARMS TO 3
DISPPNL  LA    R1,ISPPARMS
         L     R15,@ISPLINK
         BALR  R14,R15
         LTR   R15,R15             IF RETURN CODE IS NONZERO
         BNZ   RETURN0             THEN EXIT FUNCTION
         MVC   PANEL,BLANKS        CLEAR PANEL NAME FOR EFFICIENCY
         MVI   MSGNO,0             CLEAR MESSAGE ID FIELD
         SPACE
***********************************************************************
* ISPEXEC VGET (ZVERB ZSCROLLA ZSCROLLN) SHARED                       *
***********************************************************************
         SPACE
         LA    R1,@VGET
         L     R15,@ISPLINK
         BALR  R14,R15
         SPACE
         B     LOOP                LOOP UNTIL NONZERO RC FROM DISPLAY
         SPACE 2
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE
***********************************************************************
* RESTORE ESPIE ENVIRONMENT                                           *
***********************************************************************
         SPACE
         L     R1,PREVSPIE         RESTORE PREVIOUS PIE ADDRESS
         ESPIE RESET,(1)           RESTORE CALLER'S ESPIE
         SPACE 2
RETURN   DS    0H
         SPACE
         L     R2,SYMFIRST         FREE ALL SYMBOL TABLE STORAGE
FREELOOP LTR   R1,R2
         BZ    FREED
         L     R2,SYMNEXT-SYM(,R2)
         LA    R0,SYMLEN
         FREEMAIN R,LV=(0),A=(1)
         B     FREELOOP
FREED    DS    0H
         SPACE
*
* ISPEXEC VRESET
*
         LA    R1,@VRESET
         L     R15,@ISPLINK
         BALR  R14,R15
         SPACE
         LM    R0,R1,BUFLA         FREE THE DATA BUFFER
         FREEMAIN R,LV=(0),A=(1)
         SPACE
NOISPF   DS    0H
         SPACE
         DELETE EPLOC==CL8'ISPLINK' RELEASE ISPLINK MODULE
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         XR    R15,R15             SET RETURN CODE TO ZERO
BR14     BR    R14
         EJECT
CMDTABLE DS    0H
         SPACE
CLOCATE  DC    CL8'LOCATE  ',AL4(LOCATE)
CRESET   DC    CL8'RESET   ',AL4(RESET)
CUP      DC    CL8'UP      ',AL4(UP)
CDOWN    DC    CL8'DOWN    ',AL4(DOWN)
CLEFT    DC    CL8'XVXLEFT ',AL4(XVXLEFT)
CRIGHT   DC    CL8'XVXRIGHT',AL4(XVXRIGHT)
CLOAD    DC    CL8'LOAD    ',AL4(LOAD)
CDELETE  DC    CL8'DELETE  ',AL4(DELETE)
CLABELS  DC    CL8'LABELS  ',AL4(LABELS)
CBASE    DC    CL8'BASE    ',AL4(BASE)
CSHOW    DC    CL8'SHOW    ',AL4(SHOW)
CDROP    DC    CL8'DROP    ',AL4(DROP)
CBACK    DC    CL8'BACK    ',AL4(BACK)
CCLEAR   DC    CL8'CLEAR   ',AL4(CLEAR)
CBINARY  DC    CL8'BINARY  ',AL4(BINARY)
         SPACE
CMDEND   EQU   *
         EJECT
RESET    DS    0H                  PROCESS RESET COMMAND
         SPACE
         LTR   R4,R4                IF ARGUMENT IS NULL
         BNZ   SETORIG              THEN
         LR    R5,R6                 RESET BASE SO THAT OFFSET = ZERO
         B     RETUPDT               RETURN TO MODIFY STACK. ELSE...
SETORIG  XR    R3,R3                SET SIGN INDICATOR
         CLI   ARGUMENT,C'+'        IF THERE IS A SIGN PRECEDING IT
         BE    RESUPSGN             THEN
         CLI   ARGUMENT,C'-'
         BNE   AFTUPSGN
         BCTR  R3,0                  SET SIGN INDICATOR
RESUPSGN DS    0H                    IF A SIGN...
         BCTR  R4,0                   REDUCE ARGUMENT LENGTH BY 1
         MVC   ARGUMENT(L'ARGUMENT-1),ARGUMENT+1 SHIFT ARG LEFT 1
AFTUPSGN BAL   R14,HEXIN           CONVERT ARGUMENT FROM HEX TO BINARY
         TM    BOOLEANS,BADADDR    IF CONVERSION FAILED,
         BZ    RESARGOK            THEN
         MVI   MSGNO,01             SAY INVALID HEX VALUE
         B     RETFAIL              AND RETURN.
RESARGOK DS    0H
         LTR   R3,R3               IF SIGN WAS MINUS
         BZ    *+6                 THEN
         LCR   R1,R1                SET NEW OFFSET NEGATIVE
         LR    R5,R6               CURRENT ADDRESS MINUS NEW OFFSET
         SR    R5,R1               GIVES NEW BASE ADDRESS
         B     RETUPDT             RETURN TO MODIFY STACK
         EJECT
UP       DS    0H                  PROCESS UP COMMAND
DOWN     DS    0H                    AND DOWN COMMAND
         SPACE
         LTR   R4,R4               IF THERE'S AN ARGUMENT
         BZ    UPDOWNOK            THEN (NOT ACCEPTED AS SCROLL AMOUNT)
         MVI   MSGNO,09             SAY INVALID SCROLL AMOUNT
         B     RETFAIL              AND RETURN.
UPDOWNOK DS    0H                  ELSE PROCESS SCROLL REQUEST
         SPACE
*
* IF THE SHOW COMMAND WAS USED TO PRODUCE A SHORT DISPLAY, WE WILL
* HAVE TO ADJUST THE SCROLL AMOUNT.  THIS DOES NOT APPLY TO A
* DISPLAY SHORTENED TEMPORARILY BY STORAGE PROTECTION.
*
         CLI   ZSCROLLA,C'M'       IF SCROLL AMOUNT = MAX
         BNE   SCRNOTM              THEN
         MVI   MSGNO,25              SAY MAX IS INVALID
         B     RETFAIL                AND RETURN.
SCRNOTM  DS    0H                  ELSE
         L     R1,ZSCROLLN         GET SCROLL AMOUNT
         LH    R0,#SHOW            GET CURRENT AMOUNT TO SHOW
         CLI   ZSCROLLA,C'P'       IF SCROLL AMOUNT = PAGE
         BNE   SCRNOTP              AND
SCRPAGE  CR    R1,R0                 AMOUNT EXCEEDS SHOW AMOUNT
         BNH   SCROK                  THEN
         LR    R1,R0                   USE SHOW AMOUNT
         B     SCROK
SCRNOTP  DS    0H                  ELSE
         CLI   ZSCROLLA,C'C'       IF SCROLL AMOUNT = CURSOR
         BNE   SCRNOTC             THEN
*
* FOR CURSOR SCROLLING, THE SCROLL AMOUNT RETURNED BY ISPF IS:
* THE RELATIVE ROW NUMBER IF "DOWN" IS THE SCROLLING DIRECTION.
* THE DISTANCE OF THE ROW FROM THE BOTTOM IF "UP" IS THE DIRECTION.
* IN THE CASE OF "UP", WE HAVE TO FIGURE OUT WHAT THE DISTANCE OF
* THE CURRENT ROW IS FROM THE LAST ROW SHOWN.
*
         CLI   ZVERB,C'D'           IF COMMAND = DOWN
         BE    SCRPAGE               THEN ANALYZE SAME AS PAGE
         L     R14,VXLVLIN           ELSE GET LAST VISIBLE LINE
         LR    R15,R14               LVLINE MINUS SCROLL AMOUNT
         SR    R15,R1                GIVES RELATIVE ROW NUMBER
         LR    R1,R0                 PROVISIONALLY SCROLL LIKE PAGE
         CR    R15,R0                IF AMOUNT WITHIN SHOW AMOUNT
         BH    SCROK                  THEN SET SCROLL AMOUNT =
         CR    R1,R14
         BNH   *+6
         LR    R1,R14
         SR    R1,R15                  MIN(SHOW,LVLINE) - ROW NUM
         B     SCROK
SCRNOTC  DS    0H                  ELSE
         CLI   ZSCROLLA,C'D'       IF SCROLL AMOUNT = DATA
         BNE   SCRNOTD              AND
         BCTR  R0,0
         CR    R1,R0                 AMOUNT EXCEEDS SHOW AMOUNT - 1
         BNH   SCROK                  THEN
         LR    R1,R0                   USE SHOW AMOUNT - 1
         B     SCROK
SCRNOTD  DS    0H                  ELSE
         CLI   ZSCROLLA,C'H'       IF SCROLL AMOUNT = HALF
         BNE   SCRNOTH              AND
         LH    R0,#SHOW
         SRA   R0,1
         CR    R1,R0                 AMOUNT EXCEEDS SHOW AMOUNT / 2
         BNH   SCROK                  THEN
         LR    R1,R0                   USE SHOW AMOUNT / 2
******** B     SCROK
SCRNOTH  DS    0H                  ELSE
SCROK    DS    0H                  SCROLL AMOUNT IS IN R1
         EX    0,SCRSHIFT          MULTIPLY BY 4|16 TO GET # OF BYTES
         CLI   ZVERB,C'U'          IF COMMAND IS UP
         BNE   *+6                 THEN
         LCR   R1,R1                MAKE SCROLL BYTES NEG (TO SUBTRACT)
         AR    R6,R1               ADD SCROLL BYTES TO CURRENT ADDRESS
         B     RETUPDT             RETURN TO MODIFY STACK
         EJECT
XVXLEFT  DS    0H                  PROCESS LEFT COMMAND
XVXRIGHT DS    0H                     AND RIGHT COMMAND
         SPACE
         LA    R1,1                INIT AMOUNT = 1
         LTR   R4,R4               BUT IF ARGUMENT NOT NULL
         BZ    LROK                THEN
         BAL   R14,HEXIN            EXTRACT HEX VALUE OF ARGUMENT
         TM    BOOLEANS,BADADDR     IF CONVERSION UNSUCCESSFUL
         BO    LRERR                OR
         LR    R0,R1                MORE THAN 6 HEX CHARACTERS
         SRA   R0,24                 ARE SIGNIFICANT
         BZ    LROK                 THEN
LRERR    MVI   MSGNO,02              SAY INVALID HEX OFFSET
         B     RETFAIL               RETURN IN ERROR. ELSE...
LROK     CLI   ZVERB+3,C'L'        IF COMMAND = (XVX)LEFT
         BNE   *+6                 THEN
         LCR   R1,R1                MAKE SCROLL BYTES NEG (TO SUBTRACT)
         AR    R6,R1               ADD SCROLL BYTES TO CURRENT ADDRESS
         B     RETUPDT             RETURN TO MODIFY STACK
         EJECT
LOAD     DS    0H                  PROCESS LOAD COMMAND
         SPACE
         LTR   R15,R4               IF ARGUMENT LENGTH 0
         BNP   LDLENERR             OR
         CH    R15,H8                 ARGUMENT LENGTH GREATER THAN 8
         BNH   LDLENOK              THEN
LDLENERR MVI   MSGNO,10              SAY INVALID OPERAND
         B     RETFAIL             AND RETURN IN ERROR. ELSE...
LDLENOK  DS    0H                  OK TO LOAD MODULE
         MVC   LOADNAME,BLANKS
         BCTR  R15,0
         EX    R15,MVCLOAD         SET UP LOAD MODULE NAME
         LOAD  EPLOC=LOADNAME,ERRET=LOADERR
         LR    R6,R0               SET NEW ADDRESS = LOAD ENTRY POINT
         N     R6,=X'7FFFFFFF'     CLEAR HIGH-ORDER BIT
         LR    R5,R6               SET BASE ADDRESS = NEW CURRENT
         MVI   MSGNO,12            TELL USER IT HAS BEEN DONE
         B     RETPUSH             RETURN TO PUSH NEW VALUE ON STACK
LOADERR  MVI   MSGNO,11            IF LOAD FAILED, SAY SO
         B     RETFAIL             AND RETURN IN ERROR
         EJECT
DELETE   DS    0H                  PROCESS DELETE COMMAND
         SPACE
         LTR   R15,R4               IF ARGUMENT LENGTH 0
         BNP   DELENERR             OR
         CH    R15,H8                 ARGUMENT LENGTH GREATER THAN 8
         BNH   DELENOK              THEN
DELENERR MVI   MSGNO,10              SAY INVALID OPERAND
         B     RETFAIL               AND RETURN IN ERROR
DELENOK  DS    0H                  ELSE OK
         MVC   LOADNAME,BLANKS
         BCTR  R15,0
         EX    R15,MVCLOAD         SET UP LOAD MODULE NAME
         DELETE EPLOC=LOADNAME
         LTR   R15,R15
         BNZ   DELETERR
         MVI   MSGNO,13             TELL USER IT HAS BEEN DONE
         B     RETSUCC              AND RETURN
DELETERR DS    0H
         MVI   MSGNO,14              SAY DELETE FAILED
         B     RETFAIL               AND RETURN IN ERROR
         EJECT
LABELS   DS    0H                  PROCESS LABELS COMMAND
         SPACE
         XR    R3,R3               INITIALIZE LABEL COUNT
         ICM   R2,15,SYMFIRST      GET FIRST SYMBOL
LABELTST BZ    LABELEND            IF NO MORE, EXIT
         USING SYM,R2
         LTR   R3,R3               IF THIS IS THE FIRST TO DISPLAY
         BNZ   LABELDIS            THEN
*
* ISPEXEC CONTROL DISPLAY LINE START(4)
*
         LA    R1,@LINE4
         L     R15,@ISPLINK
         BALR  R14,R15
LABELDIS DS    0H
         LA    R3,1(,R3)           ELSE INCREMENT LABEL COUNT
         MVC   OUTNAME(8),SYMNAME
         MVI   OUTNAME+8,C' '
         MVC   HEXWORK(4),SYMADDR
         UNPK  OUTADDR(9),HEXWORK(5)
         TR    OUTADDR(8),HEXTBL
         MVI   OUTADDR+8,C' '
         LA    R1,OUTAREA
         LA    R0,L'OUTAREA
         TPUT  (1),(0),R           DISPLAY LABEL INFORMATION
LABELNXT ICM   R2,15,SYMNEXT       ELSE GET NEXT SYMBOL IN CHAIN
         B     LABELTST            AND CHECK IT
         DROP  R2
LABELEND MVI   ZCMD,C' '           CLEAR AREA TO BLANK
         MVC   ZCMD+1(L'ZCMD-1),ZCMD
         LTR   R3,R3               IF LABELS WERE FOUND
         BNP   LABELMSG            THEN REFRESH THE DISPLAY
*
* ISPEXEC CONTROL DISPLAY REFRESH
*
         LA    R1,@REFRESH
         L     R15,@ISPLINK
         BALR  R14,R15
         B     RETSUCC             ELSE
LABELMSG MVI   MSGNO,18             SAY NO LABELS DEFINED
         B     RETSUCC             RETURN TO CALLER
         EJECT
LOCATE   DS    0H                  PROCESS LOCATE COMMAND (OR ADDRESS)
         SPACE
*** ASSUME R4 IS NONZERO
         SPACE
         LA    R1,ARGUMENT-1(R4)   POINT TO LAST CHARACTER OF ARGUMENT
         XR    R15,R15             CLEAR INDIRECTION COUNT
         ST    R15,INDIRECT        STORE INDIRECTION COUNT
PCLOOP   CLI   0(R1),C'?'          FOR EVERY QUESTION MARK
         BE    GOTINDXX             OR
         CLI   0(R1),C'%'            PERCENT SIGN
         BNE   NOPCENTS               AT END OF ARG, DO:
GOTINDXX LA    R15,1(,R15)         INCREMENT INDIRECTION COUNT
         BCTR  R1,0                BUMP BACK
         ST    R15,INDIRECT        STORE INDIRECTION COUNT
         BCT   R4,PCLOOP           REDUCE LENGTH AND CONTINUE
         B     PROCPCNT            IF ?-%'S ONLY, DO ONLY INDIRECTION
         SPACE
NOPCENTS DS    0H                  ELSE...
         BAL   R14,GETADDR         RESOLVE ADDRESS
         TM    BOOLEANS,BADADDR    IF ERROR OCCURRED,
         BO    RETFAIL             THEN RETURN, DO NOTHING. ELSE
         LR    R6,R1               SET NEW CURRENT ADDRESS
         TM    BOOLEANS,KEEPBASE   IF BASE IS TO BE ALTERED
         BO    PROCPCNT            THEN
         LR    R5,R6                SET NEW BASE FROM NEW CURRENT ADDR
         SPACE
PROCPCNT DS    0H                  NOW PROCESS INDIRECTION REQUESTS
         ICM   R15,15,INDIRECT     GET INDIRECTION COUNT
         BZ    RETPUSH             IF NO INDIRECTION, PUSH AND RETURN
         LA    R1,ARGUMENT(R4)     POINT TO FIRST INDIRECTION SYMBOL
         LA    R0,BADIND           SET UP ERROR ROUTINE IF 0C4 OCCURS
         ST    R0,ERRET             WHILE ACCESSING DATA
         L     R14,=A(STARTIND+X'80000000')
         BSM   0,R14               SWITCH TO AMODE 31
STARTIND OI    BOOLEANS,PROT       INTERCEPT PROTECTION VIOLATIONS
*
* IF 0C4 OCCURS, ESPIE EXIT WILL CAUSE CONTROL TO GO TO "BADIND".
*
INDLOOP  L     R6,0(,R6)           GET VALUE AT SPECIFIED ADDRESS
         CLI   0(R1),C'%'          IF 24-BIT INDIRECT ADDRESSING
         BNE   INDCONT              REQUESTED ("%" SIGNS), THEN...
         N     R6,=X'00FFFFFF'       CLEAR HIGH-ORDER BYTE OF ADDRESS
INDCONT  LA    R1,1(,R1)           BUMP TO NEXT INDIRECTION SYMBOL
         BCT   R15,INDLOOP         CONTINUE UNTIL NO MORE % SIGNS
*
* END ESPIE-PROTECTED CODE
*
         NI    BOOLEANS,255-PROT   TURN OFF PROTECTION TRAP
         LA    R14,ENDIND          SWITCH TO AMODE 24
         BSM   0,R14
ENDIND   DS    0H
         N     R6,=X'7FFFFFFF'     CLEAR HIGH-ORDER BIT
         LR    R5,R6               SET BASE ADDRESS = CURRENT ADDRESS
         B     RETPUSH             RETURN TO PUSH GOOD ADDR ON STACK
         SPACE
BADIND   DS    0H                  0C4 OCCURRED DURING INDIRECTION
*
* NOTE THAT THE ESPIE EXIT SETS THIS RETURN POINT AS AMODE 24
*
         MVI   MSGNO,19            SAY ERROR OCCURRED
         B     RETFAIL             RETURN WITH BAD ADDRESS
         EJECT
BASE     DS    0H                  PROCESS BASE COMMAND
         SPACE
         LR    R1,R6               SET RESULT TO CURRENT ADDRESS
         LTR   R4,R4               IF ARGUMENT LENGTH IS ZERO
         BZ    RETBASE             THEN RETURN WITH THAT BASE. ELSE...
         BAL   R14,GETADDR         RESOLVE ADDRESS
         TM    BOOLEANS,BADADDR    IF ERROR OCCURRED,
         BO    RETFAIL             THEN RETURN, DO NOTHING. ELSE...
RETBASE  LR    R5,R1               SET NEW BASE = RESULT
         B     RETUPDT             RETURN TO MODIFY STACK
         EJECT
SHOW     DS    0H                  PROCESS SHOW COMMAND
         SPACE
         LTR   R4,R4               IF ARGUMENT LENGTH IS ZERO
         BNZ   SHOWVFY             THEN (USE DEFAULT VALUE)...
         L     R1,VXLINES           USE DEFAULT VALUE
         B     SHOWSET             RETURN WITH GOOD ADDRESS
SHOWVFY  DS    0H                  CONVERT TO NUMERIC IN R1
         CH    R4,=H'2'            IF LENGTH OF ARGUMENT GREATER THAN 2
         BH    SHOWERR             THEN ERROR - INVALID SHOW AMOUNT
         LR    R15,R4              ELSE...
         BCTR  R15,0                USING LENGTH OF ARGUMENT
         EX    R15,VERIFY           CHECK ALL NUMERICS IN ARGUMENT
         BNZ   SHOWERR              IF ARGUMENT NOT NUMERIC, ERROR
         EX    R15,SHOPACK         USING LENGTH COMPUTED PREVIOUSLY,
         CVB   R1,DOUBLE           PUT SHOW AMOUNT IN R1
         LTR   R1,R1               IF VALUE LESS THAN 1
         BNP   SHOWERR             THEN ERROR
         C     R1,VXLINES          ELSE IF VALUE EXCEEDS MAX ALLOWABLE
         BH    SHOWERR             THEN ERROR
SHOWSET  STH   R1,#SHOW            ELSE SAVE NEW SHOW VALUE
         B     RETSUCC
SHOWERR  MVI   MSGNO,20            SAY ERROR OCCURRED
         B     RETFAIL             RETURN IN FAILURE
         EJECT
DROP     DS    0H                  PROCESS DROP COMMAND
         SPACE
         LTR   R15,R4               IF ARGUMENT LENGTH 0
         BNP   DROPERR              OR
         CH    R15,H8                 ARGUMENT LENGTH GREATER THAN 8
         BNH   DROPOK               THEN
DROPERR  MVI   MSGNO,15              SAY INVALID LABEL
         B     RETFAIL               RETURN IN FAILURE
DROPOK   DS    0H                  ELSE OK
         MVC   LOADNAME,BLANKS
         BCTR  R15,0
         EX    R15,MVCLOAD         SET UP LABEL NAME
         LA    R2,SYMFIRST         INIT PREVIOUS-ENTRY POINTER
         USING SYM,R1
DROPLOOP ICM   R1,15,SYMNEXT-SYM(R2) GET ADDR OF SYMBOL TABLE ENTRY
         BZ    DROPNF              IF NONE LEFT, SYMBOL NOT FOUND
         CLC   LOADNAME,SYMNAME    IF THIS IS A MATCH
         BE    DROPIT              THEN DROP IT
         LR    R2,R1               ELSE SAVE ADDRESS OF JUST-PROCESSED
         B     DROPLOOP            AND GO TO NEXT ENTRY.
DROPNF   DS    0H                  IF NOT FOUND...
         MVI   MSGNO,21            SAY LABEL NOT FOUND
         B     RETFAIL             AND RETURN WITH BAD ADDRESS
DROPIT   DS    0H                  LABEL FOUND...
         MVC   SYMNEXT-SYM(4,R2),SYMNEXT  CHAIN CURRENT NEXT TO PREV'S
         CL    R1,SYMLAST          IF THIS IS LAST IN CHAIN,
         BNE   *+8                 THEN
         ST    R2,SYMLAST           SET NEW LAST-IN-CHAIN POINTER
         ICM   R0,15,SYMFIRST      IF THE FIRST IS ZERO (IE NONE LEFT)
         BNZ   *+8                 THEN
         ST    R0,SYMLAST           SET LAST TO ZERO TOO
         LA    R0,SYMLEN           GET LENGTH OF AN ENTRY
         FREEMAIN R,LV=(0),A=(1)   FREE THE DROPPED ENTRY
         B     RETSUCC             RETURN.
         DROP  R1
         EJECT
BACK     DS    0H                  PROCESS BACK COMMAND
         SPACE
         ICM   R1,15,STACKPTR      GET CURRENT STACK POINTER
         BZ    NOBACK              IF ZERO, THEN CANNOT BACKTRACK
         SH    R1,H8               DECREMENT STACK POINTER
         BZ    NOBACK              IF ZERO, THEN CANNOT BACKTRACK
         ST    R1,STACKPTR         ELSE POP ENTRY FROM THE STACK
         LA    R14,BKSTACK-8(R1)   RESTORE BASE AND ADDRESS
         LM    R5,R6,0(R14)         FROM STACK
         B     RETSUCC              AND RETURN.
NOBACK   MVI   MSGNO,22            ERROR - SAY YOU CAN'T BACKTRACK
         B     RETFAIL             AND RETURN IN ERROR.
         EJECT
CLEAR    DS    0H                  PROCESS CLEAR COMMAND
         SPACE
         XC    STACKPTR,STACKPTR   SET STACK POINTER TO ZERO
         B     RETPUSH             RETURN TO PUSH CURR ADDR ON STACK
         EJECT
BINARY   DS    0H                  PROCESS BINARY COMMAND
         SPACE
         LTR   R4,R4               IF ARGUMENT LENGTH IS ZERO
         BZ    BINON               THEN SET BINARY MODE ON.
         CH    R4,=H'2'            IF ARGUMENT LENGTH IS 2
         BNE   BINTRY3              AND
         CLC   ARGUMENT(2),=C'ON'    VALUE IS "ON"
         BE    BINON                  THEN SET BINARY MODE ON
BINTRY3  CH    R4,=H'3'            ELSE IF ARGUMENT LENGTH IS 3
         BNE   BINERR               AND
         CLC   ARGUMENT(3),=C'OFF'   VALUE IS "OFF"
         BE    BINOFF                 THEN SET BINARY MODE OFF
BINERR   MVI   MSGNO,23            ELSE SAY INVALID PARAMETER
         B     RETFAIL             AND RETURN IN ERROR.
BINON    DS    0H                  BINARY ON REQUESTED
         OI    BOOLEANS,BINMODE    SET BINARY MODE FLAG ON
         MVI   SCRSHIFT+3,2        SET SHIFT INSTRUCTION TO MULT BY 4
         B     RETSUCC             AND RETURN.
BINOFF   DS    0H                  BINARY OFF REQUESTED
         NI    BOOLEANS,255-BINMODE SET BINARY MODE FLAG OFF
         MVI   SCRSHIFT+3,4        SET SHIFT INSTRUCTION TO MULT BY 16
         B     RETSUCC             AND RETURN.
         EJECT
***********************************************************************
* ESPIE EXIT ROUTINE.                                                 *
* THIS RECEIVES CONTROL IN AMODE 24, IN WHICH ESPIE MACRO WAS ISSUED. *
***********************************************************************
         SPACE
SPIEEXIT DS    0H
         USING *,R15
         TM    BOOLEANS,PROT       IF PROTECTION EXCEPTION WAS EXPECTED
         BZ    REALABND            THEN
         NI    BOOLEANS,255-PROT    TURN OFF PROTECTION FLAG
         OI    BOOLEANS,ABENDED     INDICATE INVALID ADDRESS
         L     R0,ERRET             SET CONTINUATION ADDRESS & AMODE
         ST    R0,76(,R1)           UPDATE OPSW IN EPIE W.NEW ADDRESS
         BR    R14                  RETURN TO SYSTEM
REALABND DS    0H                  ELSE REAL ABEND
         LR    R2,R1               SAVE PIE ADDRESS IN R2 4 DEBUG
         LA    R1,ABENDMSG
         LA    R0,L'ABENDMSG
         TPUT  (1),(0),R
         ABEND X'0C4',DUMP         ABEND - NOTE PIE IN REG 2
ABENDMSG DC    C'XVX: SYSTEM ABEND...REG2->EPIE, 2R%+4C = PSW ADDR'
         DROP  R15
         EJECT
***********************************************************************
* SUBROUTINES                                                         *
***********************************************************************
         SPACE
GETADDR  DS    0H                  SUBROUTINE TO RESOLVE ADDRESS
*
* THIS ROUTINE RESOLVES THE ADDRESS REFERENCED BY THE VALUE OF THE
* FIELD "ARGUMENT".  THE LENGTH OF "ARGUMENT" IS CONTAINED IN R4
* (THIS WILL HAVE BEEN ADJUSTED FOR EXTRA CHARACTERS LIKE PERCENT
* SIGNS THAT ARE VALID ONLY FOR CERTAIN COMMANDS).
* ON RETURN R1 = VALUE OF ADDRESS (LIKE R6).
*
         ST    R14,GETAD14         SAVE RETURN REGISTER
         NI    BOOLEANS,255-KEEPBASE INITIALIZE BASE-ALTERATION FLAG
         XR    R3,R3               SET SIGN INDICATOR
         CLI   ARGUMENT,C'+'       IF ARGUMENT STARTS WITH A PLUS SIGN
         BE    GASIGN              THEN PROCESS OFFSET LOCATE
         CLI   ARGUMENT,C'-'       IF ARGUMENT STARTS WITH MINUS SIGN
         BNE   GASTD               THEN
         BCTR  R3,0                 SET SIGN INDICATOR NEGATIVE
GASIGN   DS    0H                  OFFSET LOCATE...
         OI    BOOLEANS,KEEPBASE   INDICATE BASE IS TO BE UNCHANGED
         BCTR  R4,0                SUBTRACT 1 FROM LENGTH OF ARGUMENT
         MVC   ARGUMENT(L'ARGUMENT-1),ARGUMENT+1 AND SHIFT ARG LEFT
         BAL   R14,HEXIN           CONVERT HEX ARGUMENT TO BINARY
         TM    BOOLEANS,BADADDR    IF INVALID HEX
         BO    GETRET              THEN ERROR
         LTR   R3,R3               IF SIGN WAS MINUS
         BZ    *+6                 THEN
         LCR   R1,R1                TAKE NEGATIVE VALUE
         ALR   R1,R5               SET RESULT = BASE ADDRESS + VALUE
         B     GETRET              AND RETURN TO CALLER.
         SPACE
GASTD    DS    0H                  STANDARD ADDRESS LOCATE
         LA    R1,ARGUMENT-1(R4)   POINT TO LAST CHARACTER OF ARGUMENT
         CLI   0(R1),C'.'          IF LAST CHAR IS A PERIOD
         BNE   NOTPD               THEN
         BCTR  R4,0                REDUCE ARGUMENT LENGTH BY 1
         B     ISADDR              AND ALWAYS PROCESS AS AN ADDRESS
NOTPD    DS    0H                  ELSE VALUE DOES NOT END IN PERIOD
*
* MAY BE A LABEL...SEE IF IT IS A SYMBOL FROM THE TABLE
*
         LR    R15,R4              USING LENGTH OF ARGUMENT,
         BCTR  R15,0
         EX    R15,TRTARG          VERIFY VALID CHARACTERS
         BNZ   ISADDR              IF BAD CHARS, TREAT AS ADDRESS
         TM    ARGUMENT,X'F0'      IF BEGINS WITH NUMERIC,
         BO    ISADDR              THEN TREAT AS ADDRESS. ELSE...
         MVC   VLABEL,BLANKS       CLEAR LABEL AREA TO BLANKS
         EX    R15,MVCLABEL        MOVE ARGUMENT TO LABEL
         LM    R15,R0,VLABEL       PICK UP VALUE AND USE IT AS A LABEL
         BAL   R14,GETISYM         SEARCH FOR SYMBOL IN TABLE
         LTR   R1,R1               IF NOT FOUND,
         BZ    ISADDR               THEN ASSUME ADDRESS, PROCESS THUS
         USING SYM,R1
         L     R1,SYMADDR          ELSE USE ADDRESS FROM THE TABLE
         DROP  R1
         B     GETRET              AND PROCESS AS GOOD ADDRESS
ISADDR   DS    0H
         BAL   R14,HEXIN           EXTRACT HEX VALUE FROM ARGUMENT
         TM    BOOLEANS,BADADDR    IF ERROR DETECTED,
         BO    GETRET               THEN JUST RETURN.
         N     R1,=X'7FFFFFFF'     ZERO THE HIGH-ORDER BIT
GETRET   DS    0H
         L     R14,GETAD14         RESTORE RETURN ADDRESS
         BR    R14                 RETURN TO CALLER
         EJECT
HEXIN    DS    0H
*
* THIS SUBROUTINE RETURNS A BINARY VALUE IN R1 BASED ON "ARGUMENT".
* REMEMBER, R4 CONTAINS THE LENGTH OF "ARGUMENT" TO BE CONVERTED.
* NOTE: R2 IS ALTERED.
*
* A VALUE ENDING IN "N" IS ASSUMED TO BE A DECIMAL VALUE.
* OTHERWISE IT IS ASSUMED TO BE A HEX VALUE.
*
         LTR   R15,R4              USING LENGTH OF ARGUMENT
         BNZ   HEXINNT0            IF LENGTH IS ZERO
         MVI   MSGNO,03             THEN SAY INVALID COMMAND
         B     HEXERROR
HEXINNT0 DS    0H
         LA    R1,ARGUMENT-1(R15)  POINT TO LAST CHAR OF ARGUMENT
         CLI   0(R1),C'N'          IF VALUE ENDS IN "N",
         BNE   HEXNOTN             THEN
         BCTR  R15,0               SUBTRACT 1 FROM LENGTH OF ARG
         LTR   R15,R15             IF REMAINING LENGTH IS ZERO
         BNP   HEXINVCH            THEN FLAG AS ERROR
         BCTR  R15,0               USING LENGTH OF ARGUMENT
         EX    R15,VERIFY          CHECK ALL NUMERICS IN ARGUMENT
         BNZ   HEXINVCH            IF ARGUMENT NOT NUMERIC, INVALID
         CH    R15,=H'9'           IF TOO LONG TO BE A FIXED(31) BIN
         BH    HEX2LONG            THEN VALUE TOO LONG
         BL    HEXNLOK             IF LENGTH = 10 THEN
         CLC   ARGUMENT(10),=C'2147483647'
         BH    HEX2LONG            THEN VALUE TOO LONG
HEXNLOK  DS    0H                  ELSE VALID NUMERIC VALUE
         EX    R15,SHOPACK         PACK INTO "DOUBLE"
         CVB   R1,DOUBLE           RETURN WITH DECIMAL AMOUNT IN R1
         BR    R14                 RETURN TO CALLER
         SPACE
HEXNOTN  DS    0H
         CH    R15,H8               USING LENGTH OF ARGUMENT
         BNH   HEXINNT8            IF LENGTH IS GREATER THAN 8
HEX2LONG MVI   MSGNO,05             THEN SAY ADDRESS TOO LONG
         B     HEXERROR
HEXINNT8 DS    0H
         BCTR  R15,0
         EX    R15,XVERIFY          CHECK HEX CHARS IN ARGUMENT
         BZ    HEXINOK              IF ARGUMENT NOT HEX
HEXINVCH MVI   MSGNO,06              THEN SAY BAD ADDRESS
******** B     HEXERROR
HEXERROR DS    0H                  IF ERROR OCCURRED...
         OI    BOOLEANS,BADADDR    INDICATE ADDRESS IS BAD
         BR    R14                 AND RETURN TO CALLER
HEXINOK  DS    0H                  ELSE AMOUNT IS OK
         MVC   HEXWORK(8),BLANKS
         EX    R15,HEXMVC          MOVE TO WORKAREA
         EX    R15,HEXTR           TRANSLATE
         LA    R15,1(,R15)         ADD 1 FOR PACKING
         EX    R15,HEXPACK         AND PACK
         ICM   R1,15,DOUBLE+3      RETURN WITH HEX AMOUNT IN R1
         BR    R14                 RETURN TO CALLER
         SPACE
XVERIFY  TRT   ARGUMENT(0),XVERTBL VERIFY HEX CHARS IN ARGUMENT
HEXMVC   OC    HEXWORK(0),ARGUMENT MOVE TO WORK AREA
HEXTR    TR    HEXWORK(0),HEXINTBL TRANSLATE IN PREPARATION FOR HEXIN
HEXPACK  PACK  DOUBLE,HEXWORK(0)   PACK ARGUMENT FOR CONVERSION
         EJECT
GETISYM  DS    0H
*
* THIS SUBROUTINE RETURNS THE ADDRESS OF AN IMMEDIATE SYMBOL ENTRY.
* ON ENTRY REGS 15 AND 0 CONTAIN THE SYMBOL NAME.
* ON RETURN R1 CONTAINS THE ADDRESS OF THE ENTRY, OR ZERO IF NONE.
*
         ICM   R1,15,SYMFIRST      GET FIRST SYMBOL
GETITEST BZR   R14                 IF NONE, RETURN WITH NONE
         USING SYM,R1
         CL    R15,SYMNAME         COMPARE FIRST 4 CHARS
         BNE   GETINEXT            IF NOT EQUAL, GET NEXT ENTRY
         CL    R0,SYMNAME+4        COMPARE THE REST
         BER   R14                 IF EQUAL, RETURN, GOT IT
GETINEXT ICM   R1,15,SYMNEXT       ELSE GET NEXT SYMBOL IN CHAIN
         B     GETITEST            AND CHECK IT
         DROP  R1
         EJECT
***********************************************************************
* EXECUTED INSTRUCTIONS                                               *
***********************************************************************
         SPACE
MVCARG   OC    ARGUMENT(0),ZCMD    EXTRACT ARGUMENT FROM ZCMD FIELD
MVCLOAD  OC    LOADNAME(0),ARGUMENT MOVE ARGUMENT TO LOAD NAME
MVCLABEL OC    VLABEL(0),ARGUMENT  MOVE ARGUMENT TO LABEL NAME
MVCBIN   MVC   0(0,R10),0(R6)      MOVE DATA FROM STORAGE TO BUFFER
TRTARG   TRT   ARGUMENT(0),NAMETBL VERIFY VALID CHARACTERS
VERIFY   TRT   ARGUMENT(0),VERTBL  VERIFY NUMERICS IN ARGUMENT
SHOPACK  PACK  DOUBLE,ARGUMENT(0)  PACK ARGUMENT FOR CONVERSION
         SPACE 2
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 1
$XVX     DC    CL8'XVX'            APPLICATION ID PREFIX
         ORG   $XVX+3              DON'T WASTE ANY PRECIOUS BYTES
BLANKS   DC    CL8' '              GENERAL PURPOSE BLANKS
         SPACE 1
@ERRDISP DS    0A                  PARAMETERS FOR ISPLINK DISPLAY
         DC    A($DISPLAY)
         DC    X'80'
         DC    AL3($XVXERR)
         SPACE 1
@REFRESH DS    0A                  PARAMETERS FOR ISPLINK CONTROL
         DC    A($CONTROL)
         DC    A($DISPLAY)
         DC    X'80'
         DC    AL3($REFRESH)
         SPACE 1
@LINE4   DS    0A                  PARAMETERS FOR ISPLINK CONTROL
         DC    A($CONTROL)
         DC    A($DISPLAY)
         DC    A($LINE)
         DC    X'80'
         DC    AL3($FOUR)
         SPACE 1
@VGET    DS    0A                  PARAMETERS FOR ISPLINK VGET
         DC    A($VGET)
         DC    A($GETVARS)
         DC    X'80'
         DC    AL3($SHARED)
         SPACE 1
@VRESET  DS    0A                  PARAMETERS FOR ISPLINK VRESET
         DC    X'80'
         DC    AL3($VRESET)
         SPACE 1
@PQUERY  DS    0A                  PARAMETERS FOR ISPLINK PQUERY
         DC    A($PQUERY)          1. SERVICE NAME
         DC    A($XVX)             2. PANEL NAME
         DC    A($VX)              3. AREA NAME
         DC    A(BLANKS)           4. AREATYPE OMITTED
         DC    A(BLANKS)           5. WIDTH OMITTED
         DC    X'80'               6. DEPTH INTO VXLINES
         DC    AL3($VXLINES)       7. ALL OTHER PARAMETERS OMITTED
         SPACE 1
         LTORG
         SPACE 1
$FOUR    DC    F'4'
$EIGHT   DC    F'8'
H8       EQU   $EIGHT+2,2,C'H'
$DISPLAY DC    C'DISPLAY '
$REFRESH DC    C'REFRESH '
$CONTROL DC    C'CONTROL'
$LINE    DC    C'LINE '
$VGET    DC    C'VGET'
$GETVARS DC    C'('
$ZVERB   DC    C'ZVERB '
$ZSCRLLA DC    C'ZSCROLLA '
$ZSCRLLN DC    C'ZSCROLLN '
         DC    C')'
$SHARED  DC    C'SHARED'
$VRESET  DC    C'VRESET'
$PQUERY  DC    C'PQUERY'
$VX      DC    C'VX '
$VXLINES DC    C'VXLINES '
$XVXERR  DC    C'XVXERROR'
         SPACE 1
INITSLA  SLA   R1,4                INITIAL SHIFT FOR LINES TO BYTES
         SPACE 1
TRANSTBL DS    0C
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/........,%_>?'
         DC    C'.........`:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4BA1A2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    C'................'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
VERTBL   DC    256X'01'
         ORG   VERTBL+C'0'
         DC    10X'00'
         ORG
         SPACE
XVERTBL  DC    256X'01'
         ORG   XVERTBL+X'81'
         DC    6X'00'
         ORG   XVERTBL+C'A'
         DC    6X'00'
         ORG   XVERTBL+C'0'
         DC    10X'00'
         ORG
         SPACE
HEXINTBL DC    256YL1(*-HEXINTBL)
         ORG   HEXINTBL+X'81'
         DC    X'FAFBFCFDFEFF'
         ORG   HEXINTBL+C'A'
         DC    X'FAFBFCFDFEFF'
         ORG
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         SPACE
NAMETBL  DC    256X'01'            TABLE TO VERIFY NAMES
         ORG   NAMETBL+C' '
         DC    X'00'
         ORG   NAMETBL+C'@'
         DC    X'00'
         ORG   NAMETBL+C'#'
         DC    X'00'
         ORG   NAMETBL+C'$'
         DC    X'00'
         ORG   NAMETBL+C'A'
         DC    9X'00'
         ORG   NAMETBL+C'J'
         DC    9X'00'
         ORG   NAMETBL+C'S'
         DC    8X'00'
         ORG   NAMETBL+C'0'
         DC    10X'00'
         ORG
BINTBL   DC    C'0',128C'1'        TABLE TO TRANSLATE TO BINARY DISPLAY
         SPACE 2
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D
PANEL    DS    CL8                 PANEL NAME
MSGID    DS    CL8                 MESSAGE ID
ZVERB    DS    CL8                 COMMAND VERB FIELD
LOADNAME DS    CL8                 LOAD MODULE NAME FOR LOADS
VLABEL   DS    CL8                 LABEL NAME FOR PROCESSING
VADDR    DS    A                   ADDRESS FOR MESSAGES
PREVSPIE DS    A                   ADDRESS OF PREVIOUS ESPIE ELEMENT
ERRET    DS    A                   RETURN ADDRESS FOR ESPIE PROCESSING
GETAD14  DS    A                   SAVE AREA FOR SUBROUTINE
@ISPLINK DS    A                   ADDRESS OF ISPLINK
ISPPARMS DS    0A                  PARAMETERS FOR ISPLINK
ISPPARM1 DS    A
ISPPARM2 DS    A
ISPPARM3 DS    A
ISPPARM4 DS    A
ISPPARM5 DS    A
ISPPARM6 DS    A
ZSCROLLA DS    CL4                 SCROLL AMOUNT CHARACTER VALUE
ZSCROLLN DS    F                   SCROLL AMOUNT NUMERIC VALUE
SAVEADRS DS    2F                  SAVED BASE ADDRESS & CURRENT ADDRESS
SYMFIRST DS    A                   ADDRESS OF IMMEDIATE-SYMBOL CHAIN
SYMLAST  DS    A                   ADDRESS OF LAST IMMEDIATE SYMBOL
INDIRECT DS    F                   INDIRECT ADDRESSING COUNT
BUFLA    DS    2A                  LENGTH AND ADDRESS OF DATA BUFFER
         ORG   BUFLA
BUFLEN   DS    F                   LENGTH OF DATA BUFFER
BUFADDR  DS    A                   ADDRESS OF DATA BUFFER
STACKPTR DS    A                   POINTER INTO BACKTRACKING STACK
BKSTACK  DS    16D                 BACKTRACKING STACK FOR BACK COMMAND
SCRSHIFT SLA   0,0                 INSTR TO CONVERT LINES TO BYTES
MVCAREA  DS    13H                 AREA TO BUILD CODE TO MOVE DATA
MSGNO    DS    X                   NUMERIC MESSAGE ID
ARGUMENT DS    CL72                TEXT OF ARGUMENT
ZCMD     DS    CL72                COMMAND INPUT FIELD
         ORG   ZCMD                OVERLAY THIS AREA FOR...
OUTAREA  DS    0CL18               OUTPUT AREA FOR LABEL DISPLAY
OUTNAME  DS    CL8
         DS    C
OUTADDR  DS    CL8
         DS    C
         ORG
VXLEN    DS    F                   SIZE OF DYNAMIC SCREEN AREA
VXLINES  DS    F                   NUMBER OF PANEL OUTPUT LINES
VXLVLIN  DS    F                   LAST VISIBLE LINE FROM PANEL
#SHOW    DS    H                   NUMBER OF OUTPUT LINES TO SHOW
#OLDSHOW DS    H                   PREVIOUS VALUE TO SHOW
#CURSHOW DS    H                   NUMBER OF LINES CURRENTLY SHOWN
VXNAME   DS    CL6                 VARIABLE NAMES FOR VDEFINES
HEXWORK  DS    CL9                 WORK AREA FOR HEXIN
LOCOFF   DS    CL9                 OFFSET OF LOCATION
BOOLEANS DS    X                   BITS
PROT     EQU   B'10000000'         1 = PROTECTION EXCEPTION EXPECTED
BADADDR  EQU   B'01000000'         1 = BAD ADDRESS SPECIFIED
ABENDED  EQU   B'00100000'         1 = ESPIE TRAPPED PROGRAM CHECK
KEEPBASE EQU   B'00010000'         1 = LOCATE CMD NOT TO ALTER BASE
DOPUSH   EQU   B'00001000'         1 = PUSH A BACKTRACK STACK ADDRESS
DOUPDATE EQU   B'00000100'         1 = UPDATE CURRENT BACKTRACK ADDRESS
RETRY    EQU   B'00000010'         1 = RETRY AFTER PROTECTION EXCEPTION
BINMODE  EQU   B'00000001'         1 = BINARY MODE ACTIVE
VX       DS    40CL80              AREA TO BUILD OUTPUT SCREEN DATA
VXEND    EQU   *
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         EJECT
SYM      DSECT ,                   MAP THE SYMBOL CHAIN ENTRIES
SYMNEXT  DS    A                   ADDRESS OF NEXT ELEMENT IN CHAIN
SYMNAME  DS    CL8                 SYMBOL NAME
SYMADDR  DS    A                   ADDRESS OF SYMBOL
SYMLEN   EQU   *-SYM               LENGTH OF A SYMBOL ENTRY
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 1
         END
./ ADD NAME=XWRITENR 0100-07332-07332-0900-00197-00197-00000-SEB
         TITLE 'XWRITENR copyright notice'
***********************************************************************
*                                                                     *
*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *
*                                                                     *
*   This program is provided on an "as is" basis.  It may be freely   *
*   distributed as long as it is not offered for commercial sale,     *
*   and as long as this copyright notice is included.                 *
*                                                                     *
***********************************************************************
         TITLE 'XWRITENR - REXX external function to simulate WRITENR'
XWRITENR CSECT
XWRITENR AMODE ANY
XWRITENR RMODE ANY
         SPACE
***********************************************************************
*
* Syntax:  call XWRITENR "anything at all"
*
***********************************************************************
*                                                                *
* Input:       (R1) = address of IRXEFPL parameter list:         *
*                                                                *
*              Offset:                                           *
*               00 = Reserved                                    *
*               04 = Reserved                                    *
*               08 = Reserved                                    *
*               0C = Reserved                                    *
*               10 = Address of the parsed argument list         *
*               14 = Address of the address of the EVALBLOCK     *
*                                                                *
******************************************************************
*                                                                *
* Output:      R15 = return code from PUTLINE                    *
*                                                                *
******************************************************************
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
         SAVE  (14,12),,XWRITENR_&SYSDATE._&SYSTIME
         BALR  R12,0
         USING *,R12
         SPACE
         L     R2,16(,R1)          R2 = address of parsed argument list
         L     R6,20(,R1)          R6 = address of address of EVALBLOCK
         L     R6,0(,R6)           R6 = address of EVALBLOCK
         L     R4,4(,R2)           R4 = length of message
         L     R5,0(,R2)           R5 = address of text of message
         C     R5,=X'FFFFFFFF'     If number of arguments not 1
         BE    ERROR               then error
         L     R0,8(,R2)
         C     R0,=X'FFFFFFFF'     If number of arguments not 1
         BNE   ERROR               then error
         LTR   R15,R4              If message length is zero
         BZ    RETURN              then return code(zero)
         LA    R0,DYSIZE           Get size of dynamic area w/o message
         AR    R0,R4               Add length of message
         GETMAIN R,LV=(0)          Get dynamic storage area
         SPACE
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DYNAM,R13
         SPACE
LENOK    DS    0H
         CH    R4,=H'256'          If message is 256 chars or less
         BH    MOVELONG            then...
         LR    R14,R4
         BCTR  R14,0                decrement length for move
         EX    R14,MOVEMSG          Move message to buffer
         B     MSGMOVED            else...
MOVELONG DS    0H
         LA    R0,PUTBUF+4         Address of message destination
         LR    R1,R4               Length of message destination
         LR    R14,R5              Address of message source
         LR    R15,R4              Length of message source
         MVCL  R0,R14              Move message to buffer
MSGMOVED DS    0H
         LA    R14,4(,R4)         Add length of header
         SLL   R14,16             Shift: 1st HWD = hdr, 2nd = no 2ndary
         ST    R14,PUTBUF         Put in first 2 halfwords in header
         SPACE
         LA    R1,IOPLSP           Set up IOPL
         USING IOPL,R1
         SPACE
         USING PSA,0
         L     R8,PSATOLD           GET TCB ADDRESS
         USING TCB,R8
         L     R8,TCBJSCB           GET JSCB ADDRESS
         USING IEZJSCB,R8
         L     R8,JSCBACT           GET ADDRESS OF ACTIVE JSCB
         L     R8,JSCBPSCB          GET ADDRESS OF PSCB
         USING PSCB,R8
         MVC   IOPLUPT,PSCBUPT      PUT UPT ADDRESS IN IOPL
         L     R8,PSCBRLGB          GET ADDR OF RELOGON BUFFER
         USING RLGB,R8
         MVC   IOPLECT,RLGBECT      PUT ADDRESS OF ECT IN IOPL
         SPACE
         SR    R0,R0
         ST    R0,ECB              Zero out ECB
         ST    R0,IOPLIOPB         Zero out IOPL parm block address
         LA    R0,ECB
         ST    R0,IOPLECB          Finish up IOPL
         MVC   PUTBLK(LPUTBLK),PUTMAST     Build PUTLINE MF=L
         DROP  R1
         EJECT
         PUTLINE PARM=PUTBLK,OUTPUT=(PUTBUF,TERM,SINGLE,DATA),         +
               TERMPUT=(ASIS),                                         +
               MF=(E,(1))
         EJECT
ENDIT    LR    R3,R15              Save return code
         LA    R0,2
         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length
         CVD   R3,DOUBLE           Return code
         UNPK  16(2,R6),DOUBLE     Generate 2 digits
         OI    17(R6),X'F0'
         CLI   16(R6),C'0'         If first digit is 0
         BNE   NOTZ                then
         MVC   16(1,R6),17(R6)      make it a 1-digit number
         MVI   17(R6),C' '
         LA    R0,1                 set length to 1
         ST    R0,8(,R6)            set EVLEN (in EVALBLOCK) to length
NOTZ     DS    0H
         LA    R0,DYSIZE           Get length of storage w/o message
         AR    R0,R4               Add length of message
         LA    R1,DYNAM            Get address of storage
         L     R13,4(0,R13)
         FREEMAIN R,LV=(0),A=(1)
RETURN   DS    0H
         RETURN (14,12),T,RC=0
         SPACE 2
ERROR    DS    0H                  Here if wrong # of arguments
         LA    R0,2
         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length
         MVC   16(2,R6),=C'-2'     Return value
         B     RETURN
         SPACE 2
MOVEMSG  MVC   PUTBUF+4(0),0(R5)
         EJECT
PUTMAST  PUTLINE MF=L
         EJECT
DYNAM    DSECT
         SPACE
SAVEAREA DS    9D
DOUBLE   DS    D          Work area for conversions
         SPACE
PUTBLK   PUTLINE MF=L
LPUTBLK  EQU   *-PUTBLK
         SPACE
IOPLSP   DS    4F        INPUT OUTPUT PARAMETER BLOCK
ECB      DS    F
         SPACE
PUTBUF   DS    F          MESSAGE HEADER
         SPACE
*                                  (Actual message buffer variable)
         SPACE
DYSIZE   EQU   *-DYNAM             Length of dynamic area w/o msg buf
         EJECT
*
*  STORAGE DEFINITIONS:
*
         SPACE
         IKJIOPL
         SPACE
         IKJCPPL
         SPACE
         IKJUPT
         SPACE
         IKJECT
         SPACE
         IKJPSCB
         EJECT ,
         IHAPSA
         EJECT ,
         IKJTCB
         EJECT ,
         IEZJSCB
         EJECT ,
         IKJRLGB
         EJECT
         SPACE 5
         END
./ ADD NAME=YITADDR  0100-07332-07332-0900-00250-00250-00000-SEB
         TITLE 'YITADDR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BASSM R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'YITADDR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *
* REALLY A TCB ADDRESS AFTER ALL), RETURNS THE HEX ADDRESS AS A       *
* CLIST VARIABLE.                                                     *
*                                                                     *
***********************************************************************
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
YITADDR  CSECT
         SAVE  (14,12),,YITADDR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING YITADDR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         MVI   YITHEX,C' '
         MVC   YITHEX+1(L'YITHEX-1),YITHEX
*
* SET YITHEX = THE VALUE
*
         ST    R0,DOUBLE
         UNPK  YITHEX(9),DOUBLE(5)
         TR    YITHEX(8),HEXTBL
         SPACE 1
YITSET   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *
* VALUE AS A CLIST VARIABLE.                                          *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R14,CENTRY
         LA    R15,CNAMEA
         LA    R0,CNAMEL
         LA    R1,CVALUEA
         LA    R2,CVALUEL
         LA    R3,CTOKEN
         STM   R14,R3,CPARM1
         L     R1,ADPLCPPL
         USING CPPL,R1
         L     R1,CPPLECT
         DROP  R1
         ST    R1,CPARM7
         OI    CPARM7,X'80'
         LA    R0,TSVEUPDT
         ST    R0,CENTRY
         XR    R0,0
         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME
         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME
         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE
         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE
*
* SET YITHEX
*
         LA    R14,=C'YITHEX'
         LA    R15,6
         LA    R0,YITHEX
         LA    R1,L'YITHEX
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* RETURN TO CALLER
*
         B     RETURN0
         SPACE 2
CALL441  DS    0H
         LA    R1,CPARM1           POINT TO PARAMETER LIST
         L     R15,X'10'               GET ADDRESS OF CVT
         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE
         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441
         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE
         LTR   R15,R15             IF RETURN CODE IS ZERO
         BZR   R2                  THEN EVERYTHING IS OK
         MVC   LINE(L'ERR441),ERR441
         CVD   R15,DOUBLE
         UNPK  LINE+L'ERR441(2),DOUBLE
         OI    LINE+L'ERR441+1,X'F0'
         BAL   R14,OUTPUT
         BR    R2
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BASSM R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERR441   DC    C'YITADDR: CLIST VARIABLE ACCESS FACILITY ERROR '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION
OUTSAVE  DS    A
         SPACE 1
CPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS
         SPACE 1
CPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE
CPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME
CPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME
CPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE
CPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE
CPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)
CPARM7   DS    A                   POINTER TO IPCS'S ECT
         SPACE 1
CENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE
CNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME
CNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME
CVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME
CVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE
CTOKEN   DC    A(0)                TOKEN (NOT USED)
         SPACE 1
YITHEX   DS    CL8                 VALUE OF CLIST VARIABLE
         DS    CL4                 PADDING
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         EJECT
         IKJTCB
         EJECT
         IKJTSVT
         EJECT
         IKJCPPL
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=YITSAV   0100-07332-07332-0900-00432-00432-00000-SEB
         TITLE 'YITSAV - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   ('&LENGTH' EQ '(0)').GOTLEN
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'YITSAV - IPCS TCB EXIT TO DISPLAY SAVE AREA TRACE'
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3    DUMP STORAGE ACCESS REGISTER
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    ADDRESS OF PREVIOUS SAVE AREA (COMPARE WITH HSA)
R8       EQU   8    TRUE ADDRESS OF CURRENT SAVE AREA
R9       EQU   9    ADDRESS OF DATA WHERE SAVEAREA'S R15 POINTS
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
YITSAV   CSECT
         SAVE  (14,12),,YITSAV_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING YITSAV,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ADDRESS OF ABDPL
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
PROCESS  DS    0H
         SPACE 1
         LOAD  EP=XIPSWHR          LOAD ADDRESS SEARCH ROUTINE
         ST    R0,WHRADDR
         SPACE 1
         XR    R7,R7               INITIALIZE HSA POINTER
         ICM   R3,15,ADPLTCB       ADDRESS OF FIRST SAVE AREA
         BNZ   LOOP                IF NONE, THEN...
         MVC   LINE(L'NOSAMSG),NOSAMSG SAY SO
         BAL   R14,OUTPUT
         B     RETURN0
         SPACE 1
LOOP     DS    0H
         LTR   R3,R3               UNTIL NO MORE
         BZ    ENDLOOP
         MVC   LINE(L'SAMSG),SAMSG "SAVE AREA AT "
         LR    R8,R3               TRUE ADDRESS OF THIS SAVE AREA
         ST    R8,OPWORK           DISPLAY IT
         UNPK  LINESAA+0(9),OPWORK(5)
         TR    LINESAA+0(8),HEXTBL
         MVI   LINESAA+8,C'.'
         GSTOR R3,72,ERRET=SANA    GET SAVE AREA FROM DUMP
         MVC   COPYSA(72),0(R3)    COPY INTO OUR WORK AREA
CONTLOOP DS    0H
         SPACE
         MVC   LINEL1(4),=C'WD1='
         UNPK  LINEN1(9),SAWD1(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'HSA='
         UNPK  LINEN2(9),SAHSA(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'LSA='
         UNPK  LINEN3(9),SALSA(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         BAL   R14,OUTPUT
         C     R7,SAHSA            CHECK HSA POINTER
         BE    HSAOK               IF IT DOESN'T MATCH, THEN...
         MVC   LINEL1(L'IBCMSG),IBCMSG
         BAL   R14,OUTPUT          NOTE INVALID BACK CHAIN
HSAOK    DS    0H
         LR    R7,R8               SET PREVIOUS-SAVE-AREA ADDRESS
         MVC   LINEL1(4),=C'R14='
         UNPK  LINEN1(9),SAR14(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR14
         BAL   R14,FINDMOD         RESOLVE RETURN ADDRESS
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R15='
         UNPK  LINEN1(9),SAR15(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         L     R0,SAR15
         BAL   R14,FINDMOD         RESOLVE ENTRY ADDRESS
         SPACE 1
         L     R9,FMWHERE          ADDRESS THAT HAS BEEN RESOLVED
         LTR   R9,R9               IF ZERO, IGNORE IT
         BZ    NOEP
         GSTOR R9,8,ERRET=NOEP     TRY TO GET ENTRY POINT DATA
         ICM   R0,15,0(R9)         GET ENTRY POINT INSTRUCTION
         N     R0,=X'FFFFF000'     AND OUT THE DISPLACEMENT
         CL    R0,=X'47F0F000'     IF IT IS NOT A BRANCH-AROUND
         BNE   NOEP                THEN NO EP DATA
         XR    R2,R2               CLEAR INSERT REG
         IC    R2,4(,R9)           GET LENGTH OF IDENTIFIER
         LTR   R2,R2               IF ZERO
         BZ    NOEP                THEN NO EP DATA
         CH    R2,=Y(EPLENGTH)     SET MAXIMUM LENGTH THAT WE CAN SHOW
         BNH   SETMAX
         LA    R2,EPLENGTH
SETMAX   DS    0H
         LA    R9,4
         A     R9,FMWHERE          POINT TO IDENTIFIER STUFF
         LA    R0,1+3(,R2)         SET LENGTH+1 AND PREPARE TO...
         N     R0,=X'FFFFFFFC'     ....ROUND UP TO FULLWORD BOUNDARY
         GSTOR R9,(0),ERRET=NOEP   GET DATA FOR THE LENGTH NEEDED
         MVC   LINEEP1(6),=CL6'AT EP '
         BCTR  R2,0                REDUCE LENGTH FOR EXECUTE
         EX    R2,EPMVC            TRANSLATE EP DATA
NOEP     DS    0H
         SPACE 1
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R0 ='
         UNPK  LINEN1(9),SAR00(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         BAL   R14,OUTPUT
         MVC   LINEL1(4),=C'R1 ='
         UNPK  LINEN1(9),SAR01(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R2 ='
         UNPK  LINEN2(9),SAR02(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R3 ='
         UNPK  LINEN3(9),SAR03(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R4 ='
         UNPK  LINEN4(9),SAR04(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R5 ='
         UNPK  LINEN1(9),SAR05(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R6 ='
         UNPK  LINEN2(9),SAR06(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R7 ='
         UNPK  LINEN3(9),SAR07(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R8 ='
         UNPK  LINEN4(9),SAR08(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         MVC   LINEL1(4),=C'R9 ='
         UNPK  LINEN1(9),SAR09(5)
         TR    LINEN1(8),HEXTBL
         MVI   LINEB1,C' '
         MVC   LINEL2(4),=C'R10='
         UNPK  LINEN2(9),SAR10(5)
         TR    LINEN2(8),HEXTBL
         MVI   LINEB2,C' '
         MVC   LINEL3(4),=C'R11='
         UNPK  LINEN3(9),SAR11(5)
         TR    LINEN3(8),HEXTBL
         MVI   LINEB3,C' '
         MVC   LINEL4(4),=C'R12='
         UNPK  LINEN4(9),SAR12(5)
         TR    LINEN4(8),HEXTBL
         MVI   LINEB4,C' '
         BAL   R14,OUTPUT
         SPACE
         BAL   R14,OUTPUT          JUST A BLANK LINE
         SPACE
         L     R3,SALSA            GET ADDRESS OF NEXT SAVE AREA
         B     LOOP                CONTINUE LOOPING
         SPACE 1
SANA     DS    0H                  SAVE AREA NOT AVAILABLE FROM DUMP
         SPACE 1
         MVC   LINE+L'SAMSG+08+2(L'SANAMSG),SANAMSG
         BAL   R14,OUTPUT
         B     ERROUT
         SPACE 1
ENDLOOP  DS    0H
         B     RETURN0
         SPACE 2
EPMVC    MVC   LINEEP2(0),1(R9)    EXECUTED
         EJECT
STORERR  DS    0H                  ERROR ACCESSING STORAGE
         MVC   LINE(L'ERRMSG),ERRMSG
******** B     ERROUT
         SPACE 1
ERROUT   DS    0H
         BAL   R14,OUTPUT
         B     RETURN0
         EJECT
FINDMOD  DS    0H                  SUBROUTINE TO FIND/PRINT MODULE NAME
*                                  R0 CONTAINS ADDRESS TO SEARCH ON
         ST    R0,FMWHERE          STORE ADDRESS TO BE RESOLVED
         LTR   R0,R0               IF ADDRESS IS ZEROES,
         BZR   R14                 THEN PRINT NOTHING, NOT AN EP
         ST    R14,FMSAVE
         NI    FMWHERE,B'01111111' TURN OFF HIGH-ORDER BIT FOR ADDRESS
FMDOIT   DS    0H
         XR    R0,R0
         ST    R0,ADPLCOM1
         L     R0,FMWHERE
         LR    R1,R4
         L     R15,WHRADDR
         BASSM R14,R15
         CLI   ADPLFMT1,C' '
         BE    FMNF
         MVC   LINEMOD(16),ADPLCOM1
         B     FMRET
FMNF     DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* IF ADDRESS UNKNOWN, MAYBE THE HIGH-ORDER BYTE IS CONFUSING THE      *
* ADDRESS SEARCH ROUTINE.  SO WE SET IT TO ZEROES AND TRY AGAIN.      *
*                                                                     *
***********************************************************************
         SPACE 1
         CLI   FMWHERE,X'00'       IF IT'S ALREADY A 24-BIT ADDRESS
         BE    FMFAIL              THEN DON'T TRY AGAIN
         MVI   FMWHERE,X'00'       ELSE CHANGE IT TO A 24-BIT ADDRESS
         B     FMDOIT               TRY AGAIN WITH 0 IN H.O.BYTE
FMFAIL   DS    0H                  ELSE GIVE UP
         MVC   LINEMOD(16),=CL16'(UNKNOWN)       '
         XC    FMWHERE,FMWHERE
FMRET    DS    0H
         L     R14,FMSAVE
         BR    R14
         EJECT
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         LTR   R15,R15             IF LINE NOT PRINTED
         BNZ   RETURN0             THEN...
NORETYET DS    0H
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         DELETE EP=XIPSWHR
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERRMSG   DC    C'ERROR - STORAGE UNAVAILABLE'
NOSAMSG  DC    C'SAVEA AREA POINTER IS ZERO'
IBCMSG   DC    C'*** INVALID BACK CHAIN ***'
SANAMSG  DC    C'STORAGE UNAVAILABLE'
SAMSG    DC    C'SAVE AREA AT '
         SPACE
VALTBL   DC    256YL1(1)
         ORG   VALTBL+X'81'
         DC    6YL1(0)             LOWER CASE ABCDEF
         ORG   VALTBL+C'A'
         DC    6YL1(0)             UPPER CASE ABCDEF
         ORG   VALTBL+C'0'
         DC    10YL1(0)            0123456789
         ORG
         SPACE
FTBL     DC    256YL1(*-FTBL)
         ORG   FTBL+X'81'
         DC    X'FAFBFCFDFEFF'     LOWER CASE ABCDEF
         ORG   FTBL+C'A'
         DC    X'FAFBFCFDFEFF'     UPPER CASE ABCDEF
         ORG
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
OUTSAVE  DS    A                   SAVE AREA FOR OUTPUT SUBROUTINE
FMSAVE   DS    A                   SAVE AREA FOR FINDMOD SUBROUTINE
FMWHERE  DS    A                   ADDRESS PASSED TO FINDMOD SUBROUTINE
WHRADDR  DS    A                   ADDRESS OF XIPSWHR, SEARCH ROUTINE
         DS    XL1                 PADDING FOR CONVERSION
OPWORK   DS    0F,CL9              WORK AREA FOR OPERAND CONVERSION
COPYSA   DS    18F                 WORK AREA FOR SAVE AREA
         ORG   COPYSA
SAWD1    DS    F                   00 = FIRST WORD
SAHSA    DS    F                   04 = HSA
SALSA    DS    F                   08 = LSA
SAR14    DS    F                   0C = REG14
SAR15    DS    F                   10 = REG15
SAR00    DS    F                   14 = REG0
SAR01    DS    F                   18 = REG1
SAR02    DS    F                   1C = REG2
SAR03    DS    F                   20 = REG3
SAR04    DS    F                   24 = REG4
SAR05    DS    F                   28 = REG5
SAR06    DS    F                   2C = REG6
SAR07    DS    F                   30 = REG7
SAR08    DS    F                   34 = REG8
SAR09    DS    F                   38 = REG9
SAR10    DS    F                   3C = REG10
SAR11    DS    F                   40 = REG11
SAR12    DS    F                   44 = REG12
         ORG
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         ORG   LINE
         DS    CL(L'SAMSG)         "SAVE AREA AT "
LINESAA  DS    CL8                 ADDRESS OF SAVE AREA
         DS    CL2                 "  "
LINEL1   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN1   DS    CL8                 "NNNNNNNN"
LINEB1   DS    CL1                 " "
LINEL2   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN2   DS    CL8                 "NNNNNNNN"
LINEB2   DS    CL1                 " "
LINEL3   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN3   DS    CL8                 "NNNNNNNN"
LINEB3   DS    CL1                 " "
LINEL4   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN4   DS    CL8                 "NNNNNNNN"
LINEB4   DS    CL1                 " "
LINEL5   DS    CL4                 "XXX="
         DS    CL1                 " "
LINEN5   DS    CL8                 "NNNNNNNN"
LINEB5   DS    CL1                 " "
         ORG   LINEL2
         DS    CL1
LINEMOD  DS    CL16                "WHERE" DATA
         DS    CL1
LINEEP1  DS    CL6                 "AT EP "
LINEEP2  DS    CL(EPLENGTH)
         SPACE 1
EPLENGTH EQU   78-(LINEEP2-LINE)
         ORG
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IKJTCB
         EJECT
         BLSABDPL
         SPACE 2
         END
./ ADD NAME=YITWHR   0100-07332-07332-0900-00299-00299-00000-SEB
         TITLE 'YITWHR - MACROS'
         MACRO
&SYM     GSTOR &REG,&LENGTH,&ERRET=STORERR
&SYM     LR    R1,R4                   GET ADDRESS OF ABDPL
         AIF   (&LENGTH LT 4096).LAR0
         LH    R0,=H'&LENGTH'          GET REQUESTED LENGTH
         AGO   .GOTLEN
.LAR0    LA    R0,&LENGTH              GET REQUESTED LENGTH
.GOTLEN  STH   R0,ADPLDLEN             STORE INTO PARAMETER LIST
         LR    R0,&REG                 SET REQUESTED ADDRESS TO ACCESS
         L     R15,ADPLMEMA            GET ADDRESS OF STORAGE ACCESSOR
         BALR  R14,R15                 CALL IT
         LTR   R15,R15                 IF RETURN CODE NONZERO
         BNZ   &ERRET                  THEN ERROR ACCESSING STORAGE
         LR    &REG,R0                 ELSE LOAD ADDRESS BACK INTO REG
         MEND
         TITLE 'YITWHR - IPCS TCB EXIT TO TELL WHERE AN ADDRESS IS'
         SPACE 1
***********************************************************************
*                                                                     *
* THIS IS AN IPCS TCB EXIT THAT, GIVEN AN ADDRESS (WHICH IS NOT       *
* REALLY A TCB ADDRESS AFTER ALL), REPORTS ON WHAT LOAD MODULE THE    *
* ADDRESS LIVES IN AS WELL AS THE OFFSET.  UNLIKE THE XITWHR EXIT,    *
* HOWEVER, THIS ROUTINE DOES NOT DISPLAY THE INFO, BUT RETURNS THE    *
* VALUES AS CLIST VARIABLES (JEEZ, I HOPE THIS WORKS).                *
*                                                                     *
***********************************************************************
         SPACE 1
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4    ADDRESS OF ABDPL PARAMETER LIST
R5       EQU   5    ADDRESS OF OPERAND
R6       EQU   6    LENGTH OF OPERAND
R7       EQU   7    POINTER TO CDE
R8       EQU   8    USED IN NUCMAP SCANNING
R9       EQU   9    USED IN NUCMAP SCANNING
R10      EQU   10   POINTER TO PARAMETER LIST EXTENSION
R11      EQU   11   POINTER TO OUTPUT BUFFER
R12      EQU   12   STATIC BASE REGISTER
R13      EQU   13   DYNAMIC BASE REGISTER AND SAVE AREA POINTER
R14      EQU   14
R15      EQU   15
         SPACE 1
YITWHR   CSECT
         SAVE  (14,12),,YITWHR_&SYSDATE._&SYSTIME
         LR    R12,R15
         USING YITWHR,R12
******** LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         LA    R0,SIZDATD
         GETMAIN R,LV=(0)
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATD,R13
         SPACE 1
         XR    R1,R1               INDICATE ABDPL GET
         L     R15,=V(XABDGET)     CALL XABDGET TO GET ABDPL
         BALR  R14,R15
         LR    R4,R1               SAVE ABDPL PARAMETER ADDRESS
         USING ABDPL,R4
         L     R11,ADPLBUF            ESTABLISH ADDRESSABILITY TO
         USING LINE,R11                OUTPUT BUFFER
         L     R10,ADPLEXT            ESTABLISH ADDRESSABILITY TO
         USING ADPLEXTN,R10            PARAMETER LIST EXTENSION
         EJECT
* THE PARAMETER ADDRESS IS PASSED AS THE TCB ADDRESS VIA TCBEXIT.
* OF COURSE, IT ISN'T REALLY A TCB ADDRESS, BUT THIS GUARANTEES
* THE CORRECT ASID, ETC.
         SPACE 1
         XR    R0,R0
         ST    R0,ADPLCOM1         Clear communication word
         L     R0,ADPLTCB          GET BINARY ADDRESS VALUE
         LR    R1,R4               GET ADDRESS OF ABDPL
         SPACE 1
         LINK  EP=XIPSWHR          CALL ADDRESS SEARCH SUBROUTINE
         SPACE 1
         MVI   YITPLACE,C' '
         MVC   YITPLACE+1(L'YITPLACE-1),YITPLACE
         MVI   YITNAME,C' '
         MVC   YITNAME+1(L'YITNAME-1),YITNAME
         MVI   YITLOC,C' '
         MVC   YITLOC+1(L'YITLOC-1),YITLOC
*
* SET YITPLACE = THE AREA WHERE IT WAS FOUND: JPA/PLPA/MLPA/NUC/ERR
*
         MVC   YITPLACE(4),ADPLFMT1
         CLI   YITPLACE,C' '
         BE    YITERROR
         CLI   YITPLACE,C'E'
         BE    YITERRNP
         B     YITOK
YITERROR DS    0H                  ERROR - MODULE NOT FOUND
         MVC   YITPLACE(11),=C'UNAVAILABLE'
YITERRNP DS    0H                  STORAGE ERROR - RETAIN YITPLACE
         MVC   YITNAME(11),=C'UNAVAILABLE'
         MVC   YITLOC(11),=C'UNAVAILABLE'
         B     YITSET
YITOK    DS    0H
*
* SET YITNAME = THE NAME OF THE LOAD MODULE
*
         MVC   YITNAME(8),ADPLCOM1
*
* SET YITLOC = THE OFFSET OF THE ADDRESS WITHIN THE LOAD MODULE
*
         L     R0,ADPLFMT2
         CVD   R0,DOUBLE
         UNPK  YITLOC(10),DOUBLE
         OI    YITLOC+9,X'F0'
         SPACE 1
YITSET   DS    0H
         SPACE 1
***********************************************************************
*                                                                     *
* OK, NOW INVOKE THE CLIST VARIABLE ACCESS FACILITY TO SET THE        *
* THREE VALUES AS CLIST VARIABLES.                                    *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R14,CENTRY
         LA    R15,CNAMEA
         LA    R0,CNAMEL
         LA    R1,CVALUEA
         LA    R2,CVALUEL
         LA    R3,CTOKEN
         STM   R14,R3,CPARM1
         OI    CPARM6,X'80'
         LA    R0,TSVEUPDT
         ST    R0,CENTRY
         XR    R0,0
         ST    R0,CNAMEA           ADDRESS OF VARIABLE NAME
         ST    R0,CNAMEL           LENGTH OF VARIABLE NAME
         ST    R0,CVALUEA          ADDRESS OF VARIABLE VALUE
         ST    R0,CVALUEL          LENGTH OF VARIABLE VALUE
*
* SET YITPLACE
*
         LA    R14,=C'YITPLACE'
         LA    R15,8
         LA    R0,YITPLACE
         LA    R1,L'YITPLACE
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* SET YITNAME
*
         LA    R14,=C'YITNAME'
         LA    R15,7
         LA    R0,YITNAME
         LA    R1,L'YITNAME
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* SET YITLOC
*
         LA    R14,=C'YITLOC'
         LA    R15,6
         LA    R0,YITLOC
         LA    R1,L'YITLOC
         STM   R14,R1,CNAMEA
         BAL   R2,CALL441
*
* RETURN TO CALLER
*
         B     RETURN0
         SPACE 2
CALL441  DS    0H
         LA    R1,CPARM1           POINT TO PARAMETER LIST
         L     R15,X'10'               GET ADDRESS OF CVT
         L     R15,CVTTVT-CVT(,R15)    GET ADDRESS OF TSO VECTOR TABLE
         L     R15,TSVTVACC-TSVT(,R15) GET ADDRESS OF IKJCT441
         BALR  R14,R15             CALL CLIST VARIABLE ACCESS ROUTINE
         LTR   R15,R15             IF RETURN CODE IS ZERO
         BZR   R2                  THEN EVERYTHING IS OK
         MVC   LINE(L'ERR441),ERR441
         CVD   R15,DOUBLE
         UNPK  LINE+L'ERR441(2),DOUBLE
         OI    LINE+L'ERR441+1,X'F0'
         BAL   R14,OUTPUT
         BR    R2
         SPACE 2
OUTPUT   DS    0H
         ST    R14,OUTSAVE
         TR    LINE(L'LINE),TRTBL  TRANSLATE OUT UNPRINTABLE CHARS
         LR    R1,R4               PASS ABDPL TO PRINT SERVICE ROUTINE
         L     R15,ADPLPRNT        GET ADDRESS OF PRINT SERVICE
         BALR  R14,R15             CALL IT
         L     R11,ADPLBUF         POINT TO NEW OUTPUT BUFFER
         L     R14,OUTSAVE
         BR    R14                 RETURN
         EJECT
RETURN0  DS    0H                  RETURN WITH CODE 0
         SPACE 1
         LR    R1,R4               INDICATE ABDPL FREE
         L     R15,=V(XABDGET)     CALL XABDGET TO FREE ABDPL
         BALR  R14,R15
         SPACE 1
         XR    R15,R15             SET RETURN CODE TO ZERO
         SPACE 2
***********************************************************************
* RETURN TO CALLING ENVIRONMENT -  R15 CONTAINS RETURN CODE           *
***********************************************************************
RETURN   DS    0H
         SPACE
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)        STORE RETURN CODE IN SAVE AREA
         LA    R0,SIZDATD
         FREEMAIN R,LV=(0),A=(1)
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
***********************************************************************
* DECLARATIVES                                                        *
***********************************************************************
         SPACE 2
ERR441   DC    C'YITWHR: CLIST VARIABLE ACCESS FACILITY ERROR '
         SPACE
TRTBL    DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C'................'
         DC    C' ..........<(+|'
         DC    C'&&.........!$*);^'
         DC    C'-/.........,%_>?'
         DC    C'..........:#@''="'
         DC    X'4B8182838485868788894B4B4B4B4B4B'
         DC    X'4B9192939495969798994B4B4B4B4B4B'
         DC    X'4B4BA2A3A4A5A6A7A8A94B4B4B4B4B4B'
         DC    X'4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B4B'
         DC    C'{ABCDEFGHI......'
         DC    C'}JKLMNOPQR......'
         DC    C'\.STUVWXYZ......'
         DC    C'0123456789......'
         SPACE
         DC    C'0123456789ABCDEF'
HEXTBL   EQU   *-256
         EJECT
         LTORG
         SPACE 3
         DROP  R12
         EJECT
***********************************************************************
* WORK AREA                                                           *
***********************************************************************
         SPACE 1
DATD     DSECT ,                   DYNAMICALLY ACQUIRED WORK AREA
         SPACE 1
SAVEAREA DS    18F
DOUBLE   DS    D                   WORK AREA FOR NUMERIC CONVERSION
OUTSAVE  DS    A
         SPACE 1
CPARMS   DS    0A                  PARMS FOR CLIST VARIABLE ACCESS
         SPACE 1
CPARM1   DC    A(CENTRY)           POINTER TO ENTRY CODE
CPARM2   DC    A(CNAMEA)           POINTER TO ADDRESS OF VARIABLE NAME
CPARM3   DC    A(CNAMEL)           POINTER TO LENGTH OF VARIABLE NAME
CPARM4   DC    A(CVALUEA)          POINTER TO ADDRESS OF VARIABLE VALUE
CPARM5   DC    A(CVALUEL)          POINTER TO LENGTH OF VARIABLE VALUE
CPARM6   DC    A(CTOKEN)           POINTER TO TOKEN (NOT USED)
         SPACE 1
CENTRY   DC    A(TSVEUPDT)         ENTRY CODE FOR VARIABLE UPDATE
CNAMEA   DC    A(0)                ADDRESS OF VARIABLE NAME
CNAMEL   DC    A(0)                LENGTH OF VARIABLE NAME
CVALUEA  DC    A(0)                ADDRESS OF VARIABLE NAME
CVALUEL  DC    A(0)                LENGTH OF VARIABLE VALUE
CTOKEN   DC    A(0)                TOKEN (NOT USED)
         SPACE 1
YITPLACE DS    CL11                VALUE OF CLIST VARIABLE
YITNAME  DS    CL11                VALUE OF CLIST VARIABLE
YITLOC   DS    CL11                VALUE OF CLIST VARIABLE
         SPACE 2
SIZDATD  EQU   *-DATD              LENGTH OF DYNAMIC WORK AREA
         SPACE 3
LINE     DSECT ,                   MAP THE OUTPUT BUFFER
         DS    CL133               WORD AREA FOR OUTPUT LINES
         EJECT
***********************************************************************
* MACRO EXPANSIONS                                                    *
***********************************************************************
         SPACE 2
         IHACDE
         EJECT
         IHAXTLST
         EJECT
         IHALPDE
         EJECT
         IKJTCB
         EJECT
         IKJTSVT
         EJECT
         CVT   DSECT=YES
         EJECT
         BLSABDPL
         SPACE 2
         END
