
                            REstructured

                              eXtended

                              eXecutor



                          (June 14, 2002)




Agenda


1- Introduction -------------------------- 3
2- ROEs ---------------------------------- 4
3- History ------------------------------- 5
4- Summary ------------------------------- 6
5- Pros and Cons ------------------------- 7
6- Books --------------------------------- 9
7- Platforms ---------------------------- 12
8- Online Help -------------------------- 13
9- Datasets ----------------------------- 14
    A- Class Datasets ------------------- 15
10- Execution --------------------------- 16
11- Syntax ------------------------------ 17
    A- Instructions --------------------- 20
    B- Variables ------------------------ 21
12- PARSE ---- -------------------------- 23
13- Control Structures ------------------ 26
    A- IF THEN [ELSE] ------------------- 27
    B- SELECT --------------------------- 30
    C- DO Loop -------------------------- 31
    D- SIGNAL --------------------------- 34
14- Passing Variables ------------------- 35
15- External Data Queue ----------------- 36
16- EXECIO ------------------------------ 39
17- Procedures -------------------------- 42
    A- Built-in Functions --------------- 46
    B- DATE() --------------------------- 49
18- Null Variables ---------------------- 51
19- ADDRESS ----------------------------- 52
20- Debugging --------------------------- 54
    A- TRACE ---------------------------- 56
    B- TRACE Output --------------------- 57
    C- TRACE Tips ----------------------- 58
21- Batch  ------------------------------ 59
    A- IKJEFT01 ------------------------- 60
    B- IRXJCL --------------------------- 62
22- RACF -------------------------------- 63




Introduction


1) Name?

2) Have you programmed in any other language before?

3) Have you used REXX?  CLIST?  ISPF?

4) What is your expectation of the class?

5)  Is there a specific item you want to learn about REXX?





ROE's


1) Start/End time?

2) Breaks

    " Every hour and half?

    " Lunchtime?

    " Designate someone as time keeper

3) Questions

4) Assignments and Exams

5) Please turn beepers and cell phones on vibrate

6) If you have to step out or miss a class please get with me
   before/after class and I'll bring you up to speed on the
   subject material you missed-



History


" Created 29 March 1979 by Mike Cowlishaw, working for IBM's
  System Assurance Laboratory near Winchester (England)-

" Started off as a personal project and initially called REX
  because the name sounded cool-

" Initially, REX was used internally within IBM, and only later
  launched as a product-

" The new IBM internal electronic Network, VNET, had a major part
  in the development of REX-

" In 1982, the name gained an X to avoid any confusion with other
  products- REXX stands for REstructured eXtended eXecutor-

" In 1983, REXX was included in the 3rd release of IBM's Virtual
  Machine /System Product- Before VM/CMS used EXEC and EXEC-2-

" In 1985, REXX was available for PC-DOS, created by Mainsfield
  Software Group-

" In 1987, IBM announced that REXX was to be the Procedure
  Language for its Systems Application Architecture (SAA)-

" In 1988, REXX was available with TSO/E V2-1 (MVS/XA)-

" In 1989, research began on a REXX compiler at IBM's Haifa
  Scientific Center in Israel- Later, IBM's Vienna Software
  Laboratory in Austria developed the 1st commercial REXX compiler-

" In 1990, REXX was available in OS/2 V2-1 and OS/400 R3

" In 1991, started work on ANSI X3J18 standards for REXX-




Summary


" REXX is a modern, structured, high-level programming language

" Procedure Language

" Interpretive Language

" 24 Keywords

" REXX looks like PL1, without data typing-

" Numbers, including both integer and real are just special cases
  of strings- Only when values are actually used are any
  conversions made-

" Storage is only used when variables are used-

" REXX does no I/O- REXX relies on other systems (ISPF/TSO) to
  accomplish displaying of panels and read/writing to files-




PROs


" Has only 1 data type, the character string, so no declarations
  are needed-

" REXX arithmetic is defined as decimal arithmetic, with
  precision selected by the programmer rather than by the hardware-

" REXX places no inherent limits on size of strings-

" REXX is a small language, making it easy to learn-

" REXX has no reserved words-

" REXX is very system-independent- This gives it the advantage of
  portability and wide application-




 CONs


" Performance- For example REXX's decimal arithmetic will be
  slower than binary arithmetic-

" Its dynamic nature means that, even with advanced compilers,
  programs in REXX are usually slower-

" REXX's Data type, the string, is not well supported by other
  languages, so there may be a cost in data conversion-




Books


REXX/Advanced Techniques for Programmers, J- Ranade IBM Series
Author:      Peter C- Kiesel
Publisher:   Mcgraw Hill
ISBN:        0-07-034600-3
Cost:        $75-00
Rating:        ***********

Programming in REXX, J- Ranade IBM Series
Author:      Charles Daney
Publisher:   Mcgraw Hill
ISBN:        0-07-015305-1
Cost:        $75-00
Rating:        ***********

REXX in the TSO Environment
Author: Gabriel F- Gargiulo
Publisher: QED information Sciences, Inc-
ISBN:  0-89435-354-3
Cost:  $75-00
Rating:  ***********

Practical Usage of TSO REXX
Author: Anthony S- Rudd
Email:       ARUDD@COMPUSERVE-COM
Publisher:   Springer
ISBN:        1852332611
Cost:       $79-95
Rating:      ********

Practical Usage of MVS REXX
Author:     Anthony S- Rudd
Email:       ARUDD@COMPUSERVE-COM
Publisher:   Springer
ISBN:        3-540-19952-7
Cost:       $79-95
Rating:      ********

The REXX Handbook, J- Ranade IBM Series
Authors:     Gabriel Goldberg/Philip H- Smith III
Publisher:   Mcgraw Hill
ISBN:       0-07-023682-8
Cost:        $75-00
Rating:      *****

The REXX Language, A Practical Approach to Programming
Author:      M-F- Cowlishaw
Publisher:   Prentice Hall PTR
ISBN:        0-13-780651-5
Cost:        $30-00
Rating:      *****

OS/2 REXX From Bark to Byte, IBM Red Book
Author:      IBM
Publisher:   IBM
ISBN:        GG24-4199-00
Cost:        $30-00
Rating:      *****

Teach Yourself REXX in 21 days
Authors:     Schindler & Schindler
Publisher:   Sams Publishing
ISBN:        0-672-30529-1
Cost:        $29-99
Rating:      **

Writing OS/2 REXX programs
Author:      Ronny Richardson
Publisher:   McGraw Hill
ISBN:        0-07-052372-X
Cost:        $30-00
Rating:      **

Down to Earth REXX
Author: William F- Schindler
Publisher: Perfect Niche Software
ISBN:  0967759005
Cost:  $29-95
Rating:  ?

MVS and ISPF Update
Xephon
1301 West Highway 407, Suite 201-405
Lewisville, TX 75067
(940) 455-7050



Book Look
Web:   www-booklook-com
Phone:  (845) 986-1981

Used and Out of Print Books
Web:    www-addall-com

Used Book Search
Web:  www-usedbooksearch-com

Compare 30 Online Book Stores
Web:  www-AllBookStore-com

Search Dozens of Book Stores
Web:  www-bestbookbuys-com



IBM REXX
www-4-ibm-com/software/ad/rexx/

REXX Links
 www-rexx-com/complang-html
www2-hursley-ibm-com/rexx/

REXX - Handling Dates
www2-hursley-ibm-com/rexx/datec-htm
www-1-ibm-com/servers/eserver/zseries/solutions/s390da/articles/rexxdate-html

REXX Edit Macros
www-geocities-com/davemcritchie/rexx/home-htm

REXX - MVS Freeware
www-planetmvs-com/freeware/fwrexx-html



Platforms


1- Supported Under

    " VM     - Virtual Machine
    " MVS    - Multiple Virtual Storage
    " VSE    - Disk Operating System/Virtual Storage Extension
    " PCs    - Personal Computer/Disk Operating System/OS2/Windows
    " OS/400 - AS/400 Operating System
    " VAX    - DEC's Operating System
    " UNIX
    " TANDEM


2- IBM
    Phone:  800-237-5511
    Email: IBMLINK  WWW2-IBMLINK-IBM-COM
     OS/390 Books WWW-1-IBM-COM/SERVERS/S390/OS390/BKSERV/
     Red Books  WWW-REDBOOKS-IBM-COM/


3- Open Software Technologies, Inc-
    1230 Douglas Avenue, Suite 300
    Longwood, Florida  32779
    Phone:    (407) 788-7173
    FAX:    (407) 788-8494
    Email:    support@mail-open-softech-com
    Web:    http://www-open-softech-com


4- Relational Architecture International
    33 Newark Street
    Hoboken, NJ  07030
    Phone: (800) 201-0771
    Email: Sales@relarc-com
    Web: www-relarc-com


Both Open Software Technologies and Relational Architecture
International provide significant enhancements to REXX, including
access to DB2 and VSAM-




Online Help


1- MVS/QuickRef

A- QW <REXX cmd>

B- QW
" Select "C - Request Reference Information by Category"
" Select "PROGLANG - Programming Languages"
" Select "IBM - OS/390 REXX SYNTAX - V2R9"


2- Book Manager

A- =V-BKM
" Select "IKJOSE30 - OS/390 V2R10-0 TSO/E"
    or "IKJ2BI02 - TSO/E V2R5"
" Select "IKJ3A330 - OS/390 V2R10-0 TSO/E REXX Reference" or
    "IKJ3C310 - OS/390 V2R9-0 TSO/E REXX User's Guide"



Datasets


1- Displaying datasets concatenated to TSO/ISPF

" LISTA <ddname>
" TSO  ISRDDN
" TSO  ISRFIND
" TSO LISTALC STATUS


2- DD Cards

" SYSEXEC  - REXX only
" SYSPROC  - CLIST and REXX


3- Search Order:

" SYSUEXEC  - ALTLIB
" SYSEXEC
" SYSUPROC - ALTLIB
" SYSPROC
" ISPLLIB
" STEPLIB


4- Items of Interest

" SYSEXEC can only contain REXXs
" SYSPROC can contain CLIST and REXXs
" Each concatenated data set must have the same record format
  (RECFM) and logical record length (LRECL)-
" Largest record length is 255 for both SYSEXEC and SYSPROC DSNs-
  The last 8 characters of the input records are ignored-
" Make sure to remove sequence numbers in columns 73-80 when
  copying or moving REXX's from a dataset with LRECL=80 over to a
  dataset with LRECL=255-
" If after allocating a SYSEXEC, you still receive "COMMAND NOT
  FOUND" type in
   "TSO EXECUTIL SEARCHDD (YES)"
" REXX's can be located in sequential or PDS datasets- PDS's are
  normally used-




Class Datasets


1- TSO Logon Proc

   ó SCP  or  IKJACCNT

2- Rename your old REXX Class Datasets

   ó TSO REXXRNAM

3- Create your new REXX Class datasets

   ó TSO  REXXALOC

4- Copy members to your new REXX Class datasets

   ó TSO  REXXCOPY

5- TSO Logon Proc

   ó REXXCLS

6- Or use SCP/IKJACCNT and LIBDEF datasets

   A- Dynamically Allocate Datasets

      ó TSO  REXXCLSA

B- De-Allocate Datasets

   ó TSO  REXXCLSD




Execution


1- Several ways to execute a REXX program

A- Foreground

" TSO  <rexx pgm> <parms>
" TSO %<rexx pgm> <parms>
" TSO EX 'dsname(member)'
" TSO EXEC 'dsname(member)'
" ISPF =6
ó <rexx pgm>  <parms>
ó %<rexx pgm> <parms>
ó EX 'dsname' <parms>
ó EXEC 'dsname(member)'

B- Background

" PGM=IKJEFT01
" PGM=IRXJCL


Syntax


1- Readable and easy to use

" Mixed Case
" Free Formatting
" Punctuation only to avoid ambiguity
" No data type or variable definitions or declarations
" Interpretive makes debugging easier- If a program error is
  encountered the line of code will be displayed-


2- Basic Components of REXX

Clauses/Statements   Each program line usually contains at least
                     one statement- REXX deals with one clause at a
                     time-
Tokens               Each clause can be divided into tokens separated by
                     blanks- (ex- /*, ADDRESS, etc-)
Expressions          Tokens may form expressions in a clause- (ex- IF
                     ABC = 10 THEN)

Instructions         One or more clauses containing REXX keywords which
                     perform a task- (ex- IF, DO, END, etc--)
Assignments          Clauses defining variables to given clauses (ex-
                     ABC=24)
Separators           Semicolon, ";" ",", can separate clauses on a line-
                     Comma continues a line-


3- Five varieties of clauses

Null Clauses         Blank Lines ignored by interpreter-
Labels               Defined by a token and followed by a colon ":"
                     They indicate the start of a subprogram or a
                     branch point (reachable by REXX CALL or
                     SIGNAL)
Assignments          variable=value
Instructions         Keyword action (ex- IF xyz THEN)
Commands             Clauses possibly containing an
                     expression that is passed to an external
                     environment such as TSO or ISPF-



4- Five most common tokens

Tokens are defined as every item delimited by blanks inside a
clause-

Comments      Any text between an opening /* and a closing */
Strings       Any text delimited by single or double quotes
Symbols       Any combination of characters (A-Z, 0-9, etc-)
Numbers       Any valid number-
Operators     The characters +, -, /, *, etc---


5- Arithmetic Operators

+   Add
-   Subtract
*   Multiply
/   Divide
%   Integer divide
       Divide and return the integer part of the result-
//   Remainder
        Divide and return the remainder-
**   Power
        Raise a number to a whole number power-


6- Items of Interest

" By default, REXX allows for 9 significant digits- To change the
  default use "NUMERIC DIGITS ##"
" When a computation exceeds a user-defined maximum precision it
  does not generate an error message, as other languages, when an
  overflow occurs- Instead it discards the least significant digits
  of a result in order to stay within the specified degree of
  precision-
" The only limitation on mathematic precision is the amount of
  memory that is available to your system-
" A variable that was never given a value is taken as a literal,
  but converted to upper case-
" Place all literals in single or double quotes; else REXX will
  treat it as an un-initialized variable-
" "Not" putting quotes around literals can be quite costly, in
  terms of performance, because the REXX interpreter has to execute
  the un-initialized variable code-
" One or more blanks between variables or literal strings becomes
  one blank-
" Maximum length of a literal or variable is 250 characters- This
  is because the ISPF editor can only handle up to 250 characters-


7- Items of Interest (cont-)

" If the comma (,) is the last character of a line the REXX
  interpreter will treat it as the continuation character-
" The semi-colon (;) is the End-Of-Clause and will not be treated
  as a NULL leg (NOP)-
" Do not use the semi-colon (;) after each REXX statement, it's
  not needed-
" Placing all variables and keywords in upper case will save some
  cycles, because the REXX interpreter translates everything to
  upper case except what is in quotes and comments-
" Below statements will display 0- REXX does a logical evaluation
  of the comparison, not an assignment-
  ó SAY A=B
  ó A=B=C=10;  SAY A


8- Examples

SAY1  SAY, display text on screen
SAY2  SAY/PULL, display text and retrieve information

ARG1  Retrieve Arguments (Upper)
ARG2  Retrieve Arguments (Upper/Lower)



Instructions


ADDRESS      Set current command environment
ARG          Get argument
CALL         Invoke routine (exception handler)
DO           Start of DO-block
DROP         Free variable
EXIT         Exit
IF - THEN - [ELSE]    Conditional processing
INTERPRET    Process run-time statement
ITERATE      Iterate DO-loop
LEAVE        Leave DO-loop
NOP          No-instruction
NUMERIC      Set numeric options
OPTIONS      Set language processor options
PARSE        Parse data
PROCEDURE    Define start of procedure
PULL         Retrieve element from stack
PUSH         Place element at end of the stack
QUEUE        Place element at start of the stack
RETURN       Return from routine
SAY          Display
SELECT       Define start of SELECT-block
SIGNAL       Exception handler processing
TRACE        Set debugging option
UPPER        Transform to uppercase


Variables


1- Items of interest

  " No need to declare variables ahead of time-
  " Allocates storage only when used-
  " Use quotes, double or single, when assigning text-
  " Variable name can be upper and lower case
  " Variable name can be up to 250 characters long-
  " Un-initialized variable is equal to its name in upper case-
  " Very few Reserved Words-


2- Two types of variables

  A- Simple
    " Sequence of characters, no periods

  B- Compound
    " Two or more simple names connected by periods
    " <stem>-<subscripts>
    Where  <stem>
    ó Any sequence of characters
    <subscripts or tail>
    ó Number or characters-
    ó Provides for "Associative Indexing", ex- AGE-FRED


3- Items of Interest

  " A variable name can "not" start with a number- If that were
  allowed, it would be possible to redefine a number
      ó 3 = 4
  " The variable name cannot contain any arithmetic characters-
  " All data items in REXX are referred to with a symbolic name-
    REXX has no other way, such as pointers, to access data- This
    makes REXX very safe to use, since it is impossible to
    reference memory that has not been allocated-
  " A REXX program will never crash simply because it refers to
    an un-initialized variable (as in other languages)- The REXX
    program may malfunction and give incorrect results-
  " Reasons other languages require data declaration is to
    specify the type, amount of data, and the name- Since REXX
    stores everything as characters, there is no need for this-


4- Items of Interest (cont-)

  " Storage is only allocated for the array elements actually
    being used-
  " Array subscripts need not be numeric- This permits
    associative indexing-
  " Each separate REXX program maintains its variables
    independently of every other REXX program-


5- Examples

       VARIABL1  - Assign/display "Simple" character variables
       VARIABL2  - Assign/display "Simple" numeric variables
       VARIABL3  - Display un-initialized "Simple" variables
       VARIABL4  - Assign/display values to REXX Commands
       ARRAY1    - Initialize a "Compound" Variable
       ARRAY2    - "Compound" Variable using whole numbers
       ARRAY3    - "Compound" Variable using multi-dimensional
       ARRAY4    - "Compound" Variable using associative array
       ARRAY5    - Display un-initialized "Compound" variable
       DROP1     - Delete a "Simple" variable
       DROP2     - Delete a "Compound" variable

PARSE



1- Syntax

PARSE  <UPPER>  <source>  <template>

    <UPPER> is optional- If used will translate all text to upper
                         case-

    <source> is required can be any of the following:
                  ARG
                  PULL
                  VALUE <expression> WITH
                  VAR <variable>
    <template> is optional


2- Items of interest

  " Used to take strings apart-  It is word oriented-
  " Extremely powerful, but least used-
  " Faster in execution speed since the whole operation can be
    done internally, without the need to constantly issue function
    calls-
  " Prevents text from being converted to all UPPER case, if
    UPPER is not specified- When using ARG and PULL without PARSE
    the text will always be translated to UPPER case-
  " "PULL" is equal to "PARSE UPPER PULL"
  " "ARG" is equal to "PARSE UPPER ARG"
  " The words are placed in the variables in the same order that
    they are entered-
  " Space is a delimiter, not the comma-
  " REXX places the extra words in the last variable-
  " Use the period to ignore a word or extra words-
  " All templates are changed when executing PARSE-
  " If there are fewer words than there are variables in the
    template, all remaining variables are set to the null string, a
    string length of 0-
  " If there are more words then there are variables, the last
    variable will get whatever is left or the original data, which
    could include both leading and trailing blanks- The last
    variable on a template is treated differently from the other
    variables-
  " Most common mistake is extra blanks in the variable that is
    the last one in the template- This can be remedied by using a
    period as a DUMMY variable-


3- Items Interest (cont-)

  " What if a literal pattern is not found in scanning a string?
    ó The answer is that this is not considered an error condition,
      and you cannot test directly for it- PARSE simply assigns the
      null string to all variables named after the literal string
      that was not found-
  " "PARSE VALUE 0 WITH 1 VAR1 1 VAR2 1 VAR3" is used frequently
    to initialize variables to the same value-
  " "PARSE EXTERNAL" is the same as "PARSE UPPER PULL", but it
    doesn't look at the external stack-
  " Information from "PARSE ARG", "PARSE SOURCE" and "PARSE
    VERSION" are static within a given routine, that is, the same
    information will be retrieved each time these options are used-
  " "PARSE VALUE" using a literal or function must use the
    sub-keyword "WITH"-
  ó PARSE VALUE TIME() WITH HH ":" MM ":" SS
  ó PASRE VALUE "HELLO DOLLY" WITH VAR1 VAR2
  " Column delaminating- The number on the left is the start
    column, the number of the right minus 1, is the end column-
      ó  XYZ = "ABCDEFGHIGHKL"
  ó PARSE VAR XYZ 1 VAR1 5 VAR2 9 VAR3 13
  " VAR1 = "ABCD"
  " VAR2 = "EFGH"
  " VER3 = "IJKL"
  ó PARSE VAR XYZ 1 VAR1 5 7 VAR2 9 11 VAR3 13
  " VAR1 = "ABCD"
  " VAR2 = "GH"
  " VAR3 = "KL"
  " Literal Characters placed in the template:
    ó If it finds the character, it will put all the data that is
      before the character into the variables that are before the
      literal character- Then it will place all the data that is
      after the literal character into the variables after literal-
    ó What is unique about this is that the "before", or left side
      has nothing to do with the "after", or right side- One side
      does not influence the other- It is as if there were two
      separate PARSE commands-
    ó If the data does not contain the literal character the
      variables to the right are set to "NULL"-


4- Examples

    PARSE1   - PARSE VAR TEXT using positional patterns
    PARSE2   - PARSE VAR TEXT ignoring string patterns
    PARSE3   - PARSE VALUE initializing variables
    PARSE4   - PARSE VALUE using positional patterns
    PARSE5   - PARSE VALUE using separator cards
    PARSE6   - PARSE VALUE used to initialize variables
    PARSE7   - PARSE VALUE used to initialize variables

Control Structures

    " IF THEN ELSE

    " SELECT WHEN END

    " DO END

    " SIGNAL

    " NOP

IF THEN


1- Syntax

        IF  <expression>  THEN
         <statement>
        ELSE
         <statement>

       IF  <expression>  THEN DO
        <statements>
           END
        ELSE DO
        <statements>
        END


2- Commands

        NOP   - No Operation


3- Items of interest

  " Unlimited number of nested IF THENs
  " THEN and ELSE are reserved word in an IF clause-
  " There is no specific keywords, such as ENDIF, required to end
    an IF statement-
  " Indentation is used for clarity-  REXX could care less-
  " Cannot use English words (AND, NOT, NE- etc-)
  " <>, \, ~ means not equal-
  " Upper and lower case are significant in REXX comparisons-
  " One of the convenient characteristics of the equality operator,
    "=", when comparing strings is that leading and trailing blanks
    are ignored- Blanks in the middle of string are NOT ignored-
  " If leading blanks are important use "= =", exact equality-
  " Examples of strictly equal:
    ó 'Apples' == '  Apples   ' -- Not Equal
    ó -01 == 000-0100 ------ Not Equal
  " A Null clause is not an instruction, so putting an extra
    semicolon (or label) after the THEN or ELSE is not equivalent to
    putting a dummy instruction- The NOP instruction is provided for
    this purpose-

4- Items of Interest (cont-)

  " True is a 1 and False is 0- There may be times you want to
    make use of the 1 and 0 in your program
    ó ANSWER = 45 = 46
    ó SAY ANSWER --- ZERO will be displayed
  " "ABC" = "ABC"- REXX interprets this as a comparison- Result
    is 1- 1 is not a keyword of REXX, so it passes it to the
    external command environment (TSO)- TSO will reject it as an
    "INVALID COMMAND"-
  " NUMERIC FUZZ 1
    ó Says "out of the nine significant digits, ignore one low
      order digit"-
    ó There must be nine digits to take effect-
    ó NUMERIC DIGITS 5
  NUMERIC FUZZ 1
  IF 12361 = 12362 ------ Is Equal


5- Examples

    IFTHEN1  - IF THEN with DO END
    IFTHEN2  - Nested IF THEN
    IFTHEN3 - True Comparisons




Comparitives


1- Normal Comparative

=              Equal (numerically or when padded)
~=, \=         Not equal (inverse of =)
>              Greater than
<              Less than
><, <>         Greater than or less than (Same as Not Equal)
>=, ~<, \>     Greater than or equal to, not less than
>=, ~<- \>     Less than or equal to, not greater than


2- Strict Comparative Operators

==             Strictly equal (identical)
~==, \==       Strictly not equal (inverse of ==)
>>             Strictly greater than
<<             Strictly less than
>>=, ~<<, \<<  Strictly greater than or equal to, strictly not
               less than
<<=, ~>>, \>>  Strictly less than or equal to, strictly not greater than


3- Logical (Boolean)

&             And
|             OR
&&            Exclusive or returns 1 if either (but Not both)
              is true
Prefix ~, \   Logical Not m Negates, 1 becomes 0 and vise versa


4- Hex Representation

~   5F
|   4F



SELECT


1- Syntax

SELECT
    WHEN  <expression>  THEN
             statement
    WHEN  <expression>  THEN
              statement
    OTHERWISE
END


2- Items of Interest

  " No limit on number of WHEN cases-
  " Just like IF statement, but with no ELSE
  " SELECT is REXX's implementation of the structured programming
    construct "CASE"-
  " REXX and ISPF have identical commands "SELECT" but do different
    things- The ISPF SELECT invokes a panel or program-
  " SELECT statements can be nested-
  " Only one WHEN can be executed
  " OTHERWISE is optional-
    ó But note, if none of the WHEN cases are selected, and no
      OTHERWISE statement has been coded, an error will be generated-
    ó OTHERWISE can be empty - A NOP instruction is not required-
    ó If OTHEWISE has several statements to execute you do not need
      to enclose it with a DO--END pair-


3- Examples

SELECT1  - Select statement with NO OTHERWISE statement
SELECT2  - Select statement with an OTHERWISE statement



DO Loops


    1- Seven Types of DO Loops

    A- Simple Repetitive Loop
              DO ##
                     <statements>
              END

    B- Compound Repetitive Loop
              DO  J  =  1  to  10  by  1
                     <statements>
              END

    C- "DO FOREVER" using the "LEAVE" Command
              DO  FOREVER
                     IF  <expression>  THEN
                          LEAVE
                     <statements>
              END

    D- "DO UNTIL" (EVAULATED AT THE BOTTOM)
              DO  UNTIL  <expression>
                     <statements>
              END

    E- "DO WHILE" (EVAULATED AT THE TOP)
              DO  WHILE  <expression>
                     <statements>
              END

    F- Repetitive loop with WHILE condition
    DO I  = 1 TO 10 WHILE X = 1
           <statements>
    END

    G- Repetitive loop with UNTIL condition
    DO I  = 1 TO 10 UNTIL X = 1
           <statements>
    END



2- Commands

 LEAVE - Exit the active loop, except when control variable name
         is specified (ex- LEAVE J)
 ITERATE - Skip the rest of the body of the active loop, except
         when a controlled variable name is specified (ex- ITERATE K)-


3- Items of Interest

  " The interpretation of the "TO" variable is accomplished at the
    1st execution of the statement- You can modify this variable
    inside the loop without affecting the iterations of the loop-
  " LEAVE and ITERATE must be in an active repetitive loop- An
    error will occur if used outside a repetitive loop-
  " LEAVE and ITERATE statement will only work with repetitive
    DO-Loops, NOT a simple DO-END structure-
  " LEAVE and ITERATE only affect the inner most loop, except when
    a control variable is used-
  " When executing a "DO UNTIL" loop the instructions within the
    loop are always executed once- It's as if the comparison is
    actually accomplished at the END statement-
  " The WHILE and UNTIL instruction is compared every iteration-
    These loops may be somewhat slower due to this-
  " Below is an incorrect use of using a control variable name on
    ITERATE and LEAVE statement-
        DO WHILE A>5
        IF A = 3 THEN
        ITERATE A
        SAY A
           END
    You can correct this by removing the "A" from ITERATE or code it
    as follows:
        DO I=1 WHILE A>5
        IF A=3 THEN
        ITERATE
        SAY A
        END
  " Most common mistakes using loops are:
  ó Using SIGNAL to branch back into a loop after SIGNALing out of it-
  ó Changing the values  of the variables on the DO statement-
  ó Using ITERATE instead of LEAVE
  ó Using DO WHILE, instead of DO UNTIL
  ó Not providing an EXIT form a DO FOREVER



4- Examples

DOEND1   - Simple Repetitive DO Loop
DOEND2   - Simple Repetitive DO Loop
DOEND3   - Controlled Repetitive DO Loop
DOEND4   - Controlled Repetitive DO Loop using ITERATE with a
           control variable to exit the inner most loop-
DOEND5   - Modifying the "TO" variable inside the loop
DOEND6   - Using the same Iteration variable within 2 loops
DOFOR    - "DO FOREVER" using the "LEAVE" command
DOUNTIL1 - "DO UNTIL"
DOUNTIL2 - Controlled Repetitive DO loop with UNTIL condition
DOWHILE1 - "DO WHILE"
DOWHILE2 - Controlled Repetitive DO loop with WHILE condition


SIGNAL

1- Syntax

SIGNAL  <label>
SIGNAL  VALUE  <expression>
SIGNAL  ON|OFF  <event>  NAME  <label>

2- Three uses

  " Transfer control immediately to the label specified (GOTO)
  " Transfer control after interpreting the expression containing
    the label- This allows for more flexibility-
  " Enable/disable handling of exception conditions-

3- Items of Interest

  " Terminates active IF, SELECT, DO instructions-
  " You cannot transfer control from one place to another within
    a DO or SELECT instruction- Error will occur-
  " If the label occurs twice in the program, only the 1st
    occurrence is used-


4- Examples

SIGNAL1 - GOTO
SIGNAL2 - GOTO with 2 identical labels in the program
SIGNAL3 - SIGNAL using VALUE
SIGNAL4 - Error Handling - Un-initialized variable
SIGNAL5  - Error Handling - Invalid or command not found
SIGNAL6 - Error Handling - Un-initialized variable



Passing Variables


1- Four ways to pass Variables/Information to another REXX program

  A- Arguments

    " TSO  <rexx pgm>  <parms>
    " CALL <rexx pgm> <parm1, parm2>
    " <rexx pgm>(parm1,parm2)

  B- External Data Queue

    " PUSH/QUEUE/PULL

  C- Files

    " EXECIO

  D- ISPF Variable Pool

    " VGET/VPUT



External Data Stack

1- Commands

QUEUE  <rec>  - Inserts   records (First In, First Out)
PUSH  <rec>   - Inserts   records (Last  In, First Out)
PULL  <rec>   - Retrieves records
QUEUED()      - No- of  records in the stack

MAKEBUF       - Create a new buffer on the data stack
DROPBUF <##>  - Delete a buffer on the data stack
QBUF          - Query how many buffers are active on the data stack
QELEM         - Query how many elements are on the data stack

NEWSTACK      - Create a new data stack
DELSTACK      - Delete most recently created data stack
QSTACK        - Query the number of data stacks that are in use-


2- Items of interest

  " External Data Stack is a feature of REXX, not TSO- Other
    programming languages can access it by calling IRXSTK, the data
    stack processing routine-
  " Commonly used to:
      ó Pass variables/records to another REXX
      ó Temporarily place records
      ó Read/write records from a file
  " Can only access one stack at a time, the current one-
  " Each element/record can be 1 to 16 megabytes in size
  " If the data stack is empty, PULL reads from the Terminal
    (foreground) or SYSTSIN (background)- For batch if SYSTSIN is
    empty it will return a null string-
  " The TSO stack is a two-part stack; it consists of the terminal
    input buffer, not the output buffer, and the program stack- The
    program stack is sometimes called the program data buffer-
  " "PARSE EXTERNAL" will take information directly from the
    terminal buffer and not from the program stack-
  " A line may be NULL or it may have one word or several- Each
    PUSH and QUEUE stacks a line, each PULL retrieves a line-
  " Two FIFO commands are QUEUE and EXECIO-

3- Items of Interest (cont)

  " Two instructions that take data out of the stack are PULL and
    EXECIO- Also, TSO commands can take items out of the stack-
  " If you DO NOT PULL all of the records off the stack before
    EXITing, REXX will automatically PULL them off upon EXITing and
    execute them as REXX or TSO commands, sometimes causing
    "COMMAND NOT FOUND"-
  " NEWSTACK creates a new data stack and basically hides or
    isolates the current data stack- Elements on the previous data
    stack cannot be accessed until a DELSTACK command is issued to
    delete the new data stack and any elements remaining in it-
  " After an exec issues the NEWSTACK command, any element that
    is placed on the data stack with a PUSH or QUEUE instruction is
    placed on the new data stack- If an exec calls a routine
    (function or subroutine) after the NEWSTACK command is issued,
    that routine also uses the new data stack and cannot access
    elements on the previous data stack, unless it issues a
    DELSTACK command- If you issue a NEWSTACK command, you must
    issue a corresponding DELSTACK command to delete the data stack
    that NEWSTACK created-
  " MAKEBUF, DROPBUF, QBUF, and QELEM start with stack no 0-
    Where NEWSTACK, DELSTACK, QSTACK all start with stack no 1-
  " Only MAKEBUF, DROPBUF, QBUF, and QSTACK place the stack
    number in RC-
  " Another way to display the number of external data stacks in
    existence is:
      When using NEWSTACK/DELSTACK
      QSTACK
      SAY  "There are" RC "Stacks
      When using MAKEBUF or DROPBUF
      QBUF
      SAY  "There are " RC "Stacks"
  " Order of the PULL
      ó Program Stack
      ó Terminal Input Buffer
      ó Terminal


4- MAKEBUF

  " Return code displays buffer number created-

5- DROPBUF <##>

Null  - Drops current Data Stack buffer-
##    - Removes specified buffer and all buffers above it-
0     - Clears all records in buffer 0

Return Code
         0    - Successful
         1    - Invalid number was specified
         2    - Buffer does not exist

6- NEWSTACK

  " Return code displays 0, not the stack no-

7- DELSTACK

" Only deletes most recently created stack- If a new stack was
  not created, DELSTACK removes all records from the original
  stack-
" Return code always displays 0, not the stack no-


8- Examples

STACK1   - Demonstrate using PUSH and PULL (LIFO)
STACK2   - Demonstrate using QUEUE and PULL (FIFO)
STACK3   - Demonstrate using Data Stack with a procedure
STACK4   - Demonstrate using MAKEBUF/DROPBUF
STACK5   - Demonstrate using NEWSTACK/DELSTACK
STACK6   - Demonstrate using external data queue with TSO command
           OPER



EXECIO

1- Description

  " Read or Write Sequential files or a PDS(mbr), placing the
    records on the data stack or in an array-

2- Syntax

      EXECIO  <no>  <open file>  <DDname>  (<parms>

      <no>
        ##  - Number of records to read/write
        *   - Read/write "ALL" records
        0   - process no records-  Used to open/close a file-

      <open file>
        DISKR   - Open file for INPUT
        DISKW  - Open file for Output
        DISKRU - Open file for Update

  " Usually READ a record and then use DISKW to update the record-
  " Can use DISKR or DISKRU to fetch next records

        <DDname>
  " DD card used to read the file

      <parms>
        FINIS       - Closes the file
        OPEN        - Open file
        STEM <var>-  - Insert records into an array

3- Return Codes

      2   - End of File
      4   - Empty file
      20  - Severe Error

4- Items of Interest

  " EXECIO is actually a TSO command, not REXX-
  " The EXECIO only supports fixed and variable length records-
  " In general a file should be closed and unallocated when it is
    no longer needed- This has two advantages:
      ó Frees main-storage
      ó Allows others to use the file
  " When possible read in the entire file- Also, take advantage of
    the STEM option-
  " Right hand parenthesis is optional-
  " If you do NOT read in the entire file, say you read in 1 record
    in at a time, you'll need to examine RC after each read-
  " EXECIO must be in quotes, especially when using "*"- If not in
    quotes REXX will treat the "*" as an arithmetic operation-
  " If the file is read into a stem variable, the stem-0 variable
    will contain the number of records read-
  " Because the amount of storage used for compound variables can
    be extensive a DROP should be made for such variables when they
    are no longer required- For example, if the EXECIO command has
    been used to read the complete contents of a dataset into a stem
    variable-
  " Use NEWSTACK and DELSTACK when writing to the External Data
    Queue- Queued() tells us how many records are stacked-
  " A DISKW operation that writes zero records and closes (FINIS
    option) the file will delete all the data records from the file:
      ó "EXECIO 0 DISKW <ddname> (FINIS"
  " Records can be placed at either the head (LIFO operand) or the
    tail (FIFO operand) of the stack- The default is LIFO-
      ó "EXECIO * DISKR <ddname> (FIFO"
  " When using DISKW with "*" from the external data queue the last
    line must be null- If it doesn't find one, the keyboard will
    unlock and whatever you type in at the keyboard will be written,
    until you enter a null line (just ENTER)- To prevent this from
    happening code the following:
      ó "EXECIO "QUEUED()" DISKW DD1 (FINIS"
  " When writing records to a file the information that extends
    beyond the largest record length is truncated- When information
    is shorter than the record length the line is padded with blanks
    to attain the original record length-
  " When * is specified as the number of lines to write, the EXECIO
    command stops writing information to the data set when it finds a
    null line or an un-initialized compound variable- It DOES NOT use
    the value in subscript 0 (ex- REC-0)-

5- Items of Interest

  " You may skip records when reading a file, but only if you go
    forward within the file-
  " File positioning can be accomplished in two ways:
      ó Specify the SKIP operand, which will skip the specified
        number of records- Below example skips the first two records:
  " "EXECIO 2 DISKR <ddname> (SKIP"
  " "EXECIO * DISKR <ddname>"
      ó The starting record no can be specified- Below examples
        skips the first two records:
  " "EXECIO * DISKR <ddname> 3"


6- Examples

      TSOFILE1  - Read 1 record at a time using the Data Stack
      TSOFILE2  - Read "All" records placing them on Data Stack
      TSOFILE3  - Writing "ALL" records from the Data Stack
      TSOFILE4  - Read/Write to a file using an Array



Procedures


1- Two types of Procedures

  A- Subroutines
  " Pass variables and receive a return code
  " CALL XYZ <var1>, <var2>

  B- Functions
  " Pass variables and return a result-
  " X = SUBSTR()


2- Location of Procedures

  A- Internal
  " LABEL
  " PROCEDURE
  " RETURN/RESULT

  B- Built-in
  " 66+ standard REXX functions, ex- WORD()

  C- External
  " Located outside of REXX program-
  " Could be written in a different language-
  " Program name, no LABEL, limited to 8 characters-
  " EXIT/RC
  " RETURN/RESULT


3- Search Order

  A- Internal
  B- Built-in
  C- External


4- Arguments

  A- By Reference
    " Variable name, subroutine can modify variable

  B- By Value
    " Only values of variables are passed- Subroutine is NOT able
      to modify the actual variable-

5- Scope of Variables

  A- Global

  B- Local

6- Procedure Statement

  " PROCEDURE <EXPOSE> <variables>
  " Optional
  " Must be the first instruction executed after the CALL or
    function invocation - that is, it must be the first instruction
    following the label-
  " Protects variables from being used/accessed-
  " EXPOSE allows only specific variables to be accessed-


7- Items of Interest

  " Used mainly to break down a large program into more
    manageable sections and prevent duplication of code-
  " A function must return a value, while a subroutine usually
    does not-
  " A subroutine may RETURN a numeric or alpha value- That value
    is placed in a special variable, RESULT, after the CALL- EXIT
    should only be used to return a number, which is stored in the
    RC variable-
  " If the procedure was invoked by CALL ABC() and no expression
    was provided on RETURN, then RESULT is dropped and becomes
    undefined-
  " Placing quotes around the CALLs to external or REXX built-in
    routines will cause the interpreter to NOT look in the file for
    a label that matches the referenced routine-
  " You can override built-in REXX functions by coding an
    internal procedure with the same name in your REXX program-

8- Items of Interest (Cont-)

  " A label can be up to 249 characters followed by a colon-
  " A label can start with a numeric character, or just be a
    number, unlike a variable- Numeric labels are allowed ' 4: or
    8:
  " If there are duplicate labels within a program, only the
    first is ever used- The second occurrence of a label is not an
    error, but will never be executed-
  " As REXX encounters labels it stores the label and address in
    the "Look-Aside" Buffer- On sub-sequent searches for labels, it
    will use the "Look-Aside" buffer-
  " A maximum of 20 parameters can be passed to a function or
    subroutine-
  " In REXX arguments are always passed by value- This means that
    arguments are evaluated when the procedure is called and only
    the resulting value is available to the procedure-
  " The ARG statement functions like the ARG in the main program,
    but you may want to use commas in the function/subroutine to
    separate the different items of data- It is recommended to
    follow this standard- If you use commas in the call, then use
    them in the ARG-
  " In subroutine the PARSE ARG should have as many commas as the
    corresponding CALL instruction or function reference-
  " The ARG or PARSE ARG statement need not occur at the
    beginning of the subroutine- It can be anywhere within the
    subroutine- And it can be used several times to parse the
    arguments in different ways-
  " There is no way to detect omitted arguments with PARSE ARG-
    Variables corresponding to omitted arguments are simply
    assigned NULL strings-
  " When coding functions always pass information to a procedure
    through an ARG statement and give back an answer with RETURN-
  " Use ARG() to determine the number of arguments passed to a
    procedure- Also, to obtain the 1st argument you can use ARG(1)-
    Just remember the ARG function depends on using the comma as a
    delimiter between arguments-
  " Procedures can overlap, that is, one procedure could "flow
    into" another without the label of the second procedure being
    invoked by a CALL or function reference- This provides for
    alternate entry points into a procedure-
  " Avoid sharing variables with the main part of the program- By
    doing this you can use the function internally or externally
    with little or no changes needed-
  " Variable lists can be used in the PROCEDURE command (ex-
    PROCEDURE EXPOSE (VARLIST), where VARLIST = "V1 V2 V3")
  " The names listed in an EXPOSE list are exposed in order from
    left to right- When you expose a single element in an array,
    you must explicitly specify it (ARRAY-2) or pass the tail
    variable ahead of the array element (PROCEDURE J ARRAY-J)-
  " When the "PROCEDURE" instruction is encountered, REXX will
    start a new variable (symbol) table by saving the pointer to
    the contents to the caller's table and restoring the caller's
    table upon return-
  " External Procedures have no PROCEDURE statement and label-

9- Items of Interest (Cont-)

  " An internal function/subroutine inherits the settings from
    the main program ' ADDRESS, NUMERIC DIGITS/FUZZ, TRACE, etc-
    However, only changes made in the internal procedure to these
    settings affects only the internal procedure- REXX restores
    them at the RETURN, so the main program will see the settings
    just as it left them-
  " The variable "RESULT" will be set to an un-initialized state
    (DROPed) if the called routine does not return any values-
  " If you want to know the line number of the statement that
    called the function/subroutine, examine the special variable
    SIGL-
  " Quotes around a function means that it is a built-in or
    external function, not an internal user-written function-
  " Note that there may NOT be a space between the name of the
    function and the left parenthesis following it-
  " When two or more elements of the data are passed to the
    function, they are separated by commas, NOT spaces-
  " Some functions have defaults and need nothing in parenthesis
    ' TIME()
  " All REXX built-in functions may be "CALLed" like subroutines
    too- When this is done, the answer is placed in the special
    variable "RESULT"-
  " INTERPET and VALUE() are used to execute REXX and host
    commands that are built dynamically-


10- Examples

PROCFUN1   - Internal Function, passing variables
PROCFUN2   - Internal Function, displaying RESULT

PROCSUB1   - Subroutine using global variables
PROCSUB2   - Subroutine using global variables and passing argument-
PROCSUB3   - Subroutine using local variables
PROCSUB4   - Subroutine using local variables and passing argument
PROCSUB5   - Subroutine using local variables, but exposing some
             variables
PROCSUB6   - Subroutine using local variables, passing arguments
             with commas
PROCSUB7   - Subroutine using local variables, selecting only
             certain arguments-
PROCSUB8   - Subroutine using local variables, selecting only
             certain arguments-
PROCSUB9   - Subroutine using local variables, exposing an array-
PROCSUBA/B - External subroutine, passing variables using ISPF
PROCSUBC   - Subroutine using variable list
PROCSUBD/E - Subroutine with quotes around the name



Built-in Functions


1- Function Definitions

ABBREV     Test whether string is an abbreviation
ABS        Return absolute value
ADDRESS    Return name of current environment
ARG        Return argument
BITAND     Logical AND
BITOR      Logical OR
BITXOR     Logical Exclusive-OR
B2X        Convert binary data to hexadecimal
CENTRE     Centralize Data (CENTER)
COMPARE    Compare
CONDITION  Return Condition
COPIES     Replicate data
C2D        Convert character data to decimal
C2X        Convert character data to hexadecimal
DATATYPE   Determine data type
DATE       Return current date
DELSTR     Delete substring
DELWORD    Delete one or more words
DIGITS     Return the NUMERIC DIGITS setting
D2C        Convert decimal data to character
D2X        Convert decimal data to hexadecimal
ERRORTEXT  Return message text
FIND       Search for word (non-SAA)
FORM       Determine NUMERIC FUZZ
INDEX      Search for substring (non-SAA)
INSERT     Insert substring
JUSTIFY    Justify string of words (non-SAA)
LASTPOS    Determine last position of phrase
LEFT       Left-align string
LENGTH     Determine length of string
LINESIZE   Return the maximum width of a terminal line (non-SAA)
MAX        Determine the maximum of a series of numeric values
MIN        Determine the minimum of a series of numeric values
OVERLAY    Overlay part of a string with a phrase
POS        Search for substring
QUEUED     Determine the number of entries in the queue


RANDOM     Generate a pseudo-random number
REVERSE    Reverse the sequence of data
RIGHT      Right-align string
SIGN       Determine numeric sign
SOURCELINE Return "program line"
SPACE      Insert fill-character between words
STRIP      Remove padding-characters at the start or end of a string
SUBSTR     Extract substring
SUBWORD    Extract series of words from word-string
SYMBOL     Determine the status of a symbol
TIME       Return the current time-of-day
TRACE      Return and set the current trace mode
TRANSLATE  Translate
TRUNC      Truncate numeric value
USERID     Return Userid (non-SAA)
VALUE      Return and set the contents of a symbol
VERIFY     Test whether only characters in phrase are present in string
WORD       Fetch word
WORDINDEX  Determine the position of a word in a string of words
WORDLENGTH Determine word length
WORDPOS    Determine word-number of a word in word-string
WORDS      Determine number of words in word-string
RANGE      Define a range of hexadecimal to binary
X2B        Convert hexadecimal to binary
X2C        Convert hexadecimal to character
X2D        Convert hexadecimal to decimal



2- Examples

CENTER    - COPY and CENTER to display text

DATATYPE  - DATATYPE and WORD to display text

FORMAT1   - FORMAT, CENTER and COPY
FORMAT2   - FORMAT with NUMERIC DIGITS
FORMAT3   - FORMAT using numeric

POS1      - POS, forward search of text
POS2      - POS, backward search of text

SUBSTR    - SUBSTR, selected text by position

TRANSLT1  - TRANSLATE lower case to upper case
TRANSLT2  - TRANSLATE upper case to lower case
TRANSLT3  - TRANSLATE phone number to characters

WORD1     - WORDS, display no of words in a variable
WORD2     - WORDINEX, display the nth word in a variable
WORD3     - WORDPOS, find a word in a variable
WORD4     - WORDLENGTH, how large is a particular word

PDSATTR   - LISTDSI, display PDS/Seq file attributes

DATE()



1- Syntax

DATE(output-format, input-date, input-date-format)


2- Date Formats

Base The number of complete days (that is, not including the
current day) since and including the base date, 1 January 0001,
in the format: dddddd (no leading zeros or blanks)-

The expression DATE('B')//7 returns a number in the range 0-6
that corresponds to the current day of the week, where 0 is
Monday and 6 is Sunday-

The base date of 1 January 0001 is determined by extending the
current Gregorian calendar backward (365 days each year, with an
extra day every year that is divisible by 4 except century years
that are not divisible by 400)- It does not take into account any
errors in the calendar system that created the Gregorian calendar
originally-

Century The number of days, including the current day, since and
including January 1 of the last year that is a multiple of 100 in
the form: ddddd (no leading zeros)- Example: A call to DATE(C) on
March 13 1992 returns 33675, the number of days from 1 January
1900 to 13 March 1992- Similarly, a call to DATE(C) on 2 January
2000 returns 2, the number of days from 1 January 2000 to 2
January 2000-

Will not accept an input date-  Only valid for today's date-

Days The number of days, including the current day, so far in
this year in the format: ddd (no leading zeros or blanks)-

European Date in the format: dd/mm/yy

Julian Date in the format: yyddd-

Will not except an input date-  Only valid for today's date-


Month Full English name of the current month, for example, August-

Will not except an input date-  Only valid for today's date-

Normal Date in the format: dd mon yyyy- This is the default- If
the active language has an abbreviated form of the month name,
then it is used (for example, Jan, Feb, and so on)- If Normal is
specified (or allowed to default) for date_format2, the
input_date must have the month (mon) specified in the English
abbreviated form of the month name-

Ordered Date in the format: yy/mm/dd (suitable for sorting, and
so forth)-

Standard Date in the format: yyyymmdd (suitable for sorting, and
so forth)-

USA  Date in the format: mm/dd/yy-

Weekday The English name for the day of the week, in mixed case,
for example, Tuesday-

Will not except an input date-  Only valid for today's date-



3- Items of Interest

  " The first call to DATE or TIME in one clause causes a time
    stamp to be made that is then used for all calls to these
    functions in that clause- Therefore, multiple calls to any of the
    DATE or TIME functions or both in a single expression or clause
    are guaranteed to be consistent with each other-

  " Input dates given in 2-digit year formats (i-e- European,
    Julian, Ordered, USA) are interpreted as being within a 100 year
    window as calculated by:

  (current_year - 50) = low end of window
  (current_year + 49) = high end of window


4- Examples

DATE01
DATE02
DATE03



Null Variables

1- ARG() Syntax

ARG()
ARG(##, E | O )

Where ## is the argument number
            E  - does argument Exist
            O  - is argument Omitted

  This will return a value of zero for false or one for true-

  The ARG() function is dependent on a comma, as the delimiter,
  between arguments-


2- LENGTH() Syntax

LENGTH(<variable/text>)


3- Different Ways to Check

IF (VAR1 = "") THEN
     SAY "NULL VARAIBLE"

IF (LENGTH(VAR1) > 0) THEN
     SAY "NULL VARIABLE"

IF (ARG(1,E) = 0) THEN
     SAY "NULL VARIABLE"

IF (ARG(1,O)) THEN
     SAY "NULL VARIABLE"

ADDRESS "ISPEXEC VGET(Z)"
IF (VAR1 = Z) THEN
     SAY "NULL VARIABLE"


ADDRESS



1- Syntax

ADDRESS <environment>
ADDRESS VALUE <variable>
ADDRESS <environment> <command>
<environment> <command>

ADDRESS()


2- Environments

TSO
ISPEXEC
ISREDIT
MVS
CONSOLE


3- Statements

      "ISPEXEC VGET(var1 var2)"
      "ISPEXEC "SELECT PGM(abc)"
      "TSO ALLOCATE FI(ddname) DA('dsname') SHR"

      ADDRESS TSO "ALLOCATE FI(ddname) DA('dsname') SHR"
      ADDRESS ISPEXEC "SELECT PGM(abc) PARM(parms)"
      ADDRESS TSO "FREE FI(ddname)"

      ADDRESS ISPEXEC
       "VGET (var1 var2)"
       "SELECT PGM(abc)"
      ADDRESS TSO
       "ALLOCATE FI(ddname) DA('dsname') SHR"
       "FREE FI(ddname)"

      ENVIRON = "TSO"
      ADDRESS VALUE ENVIRON
       "ALLOCATE FI(ddname) DA('dsname') SHR"


4- Items of interest

  " The default environment is TSO-
  " If the named environment doesn't exist, the action of the
    instruction is undefined-
  " It is a good idea to enclose all non-variable parts of the
    command in quotation marks, because a word in the text:
    ó May have been previously used as a variable in the program
    ó May be a REXX keyword (ex- SELECT, PUSH, DROP, etc-)
    ó Or one day the REXX language may introduce a new keyword-
  " You DO NOT need to place quotes around the environment name-
    REXX treats the word immediately after the ADDRESS command as a
    reserved word- REXX will not translate it as a variable-
  " Using the ADDRESS instruction without specifying an environment
    or supplying an expression informs REXX to switch back to the
    last subcommand environment used- In other words, using ADDRESS
    as a complete statement will switch between the currently active
    environment and the previously active environment-
  " If REXX sees quotes or apostrophes around the 1st word in the
    sentence, and the instruction is NOT an assignment, REXX will
    pass the command to the external environment- An unknown REXX
    command that is not in quotes will still be passed to the
    external environment, but this action will be less efficient than
    using quotes around the command-
  " Return codes are passed back in a variable called RC-
  " Return Codes
    ó RC = 0 --- Worked
    ó RC = -3 ---- Command Not Found
    ó RC = -## -- System Abend Code (negative numbers)
    ó RC = + ## --- User Abend Code (positive numbers)
  To convert system abend codes to there original form use
  C2X(ABS(RC))
  " You can ask TSO if an environment is available with the below
    TSO command:
    ó SUBCOM environment
  A RC=0 means the environment is available-


5- Examples

BROWSE - Browse a member
EDIT   - Edit a member


Debugging

1- Three modes of Tracing

A- Passive Tracing

  " TRACE <char>


B- Interactive Tracing

  " TRACE  ?<char>

  " Items of Interest

    ó REXX will pause after executing most statements, except:
      o Clauses consisting of END, THEN, ELSE, OTHERWISE, RETURN,
        EXIT, SIGNAL, and CALL-
      o Clauses that raise a condition for which there is an
        enabled condition handler or that cause a SYNTAX error-
    ó User is then prompted for input-  The input can be
        Null Line       Execute next instruction
        Equal Sign (=)  Re-execute previous line
        REXX statement  Ex- A=2, B=0, C=A+B, SIGNAL <label>, EXIT,
                        TRACE O, SAY ABC, etc--
        TRACE ?         Turn off interactive tracing-
        TRACE ##        Specify a positive number- Tracing
                        will display and proceed for that
                        number of clauses without pausing-
        TRACE -##       Specify a negative number- Tracing
                        will NOT display and proceed for that that
                        number of clauses without pausing-
    ó If you need to examine a large number of variables you
      might even provide special subroutines in your program to
      display the data- These routines can be invoked from a trace
      prompt with a CALL instruction-
    ó To display source lines execute:
        DO J = <from line no> TO <to line no>; SOURCELINE(J);END

C- Command Inhibition

  " TRACE !<char Syntax >  or TRACE !?<char>

  " Items of interest

  ó Inhibits host command execution- For example the TRACE !R
    causes commands to be traced but not processed-
  ó As each command is bypassed, the REXX special variable RC is
    set to zero-
  ó You can use this action for debugging potentially destructive
    programs-
  ó When in interactive debugging mode any commands entered
    manually will be processed-
  ó While in interactive debugging mode (TRACE !?R) you can
    switch off command inhibition, by issuing a TRACE !- Repeated
    use of the !  prefix, therefore, switches you alternately in or
    out of command inhibition mode-


  2- Items of Interest

  " Prefix options (? or R) can be specified in any order-
  " When tracing in REXX, the numbers being displayed are the
    edit line numbers-
  " Can have several TRACE statements in a REXX program- There is
    no limit-
  " Trace actions are automatically saved across subroutine and
    function calls-
  " If available at the time of execution, comments associated
    with a traced clause are included in the trace, as are comments
    in a null clause, if you specify TRACE A, R, I, or S-
  " When a loop is being traced, the DO clause itself is traced
    on every iteration of the loop-
  " You can retrieve the trace actions currently in effect by
    using the TRACE built-in function, TRACE()-
  " When entering a REXX command in interactive mode, the
    statement must be complete (ie- DO--END, IF -- THEN-- ELSE)
  " To display lines of code while in interactive mode:
      ó DO I=1 TO 5; SAY SOURCELINE(I); END
  " When executing a host command in interactive mode- The host
    command will "NOT" place its return code in the special
    variable RC- Only host commands in the REXX program will place
    a return code in RC-
  " "TRCE !R" ' There is a drawback to this, there may be times
    that a non-zero value is expected-


TRACE

1- TRACE  <parm>

All           Traces (that is, displays) all clauses before execution-

Commands      Traces all commands before execution- If
              the command results in an error or failure, then
              tracing also displays the return code from the
              command-

Error         Traces any command resulting in an error
              or failure after execution, there with the
              return code from the command-

Failure       Traces any command resulting in a
              failure after execution, together with the
              return code from the command- This is the same
              as the Normal option-

Intermediates Traces all clauses before execution-
              Also traces intermediate results during evaluation
              of expressions and substituted names-

Labels        Traces only labels passed during execution-
              This is especially useful with debug mode,
              when the language processor pauses after each
              label- It also helps the user to note all
              internal subroutine calls and transfers of
              control because of the SIGNAL instruction-

Normal        Traces any command resulting in a
              negative return code after execution, together
              with the return code from the command- This is
              the default setting-

Off           Traces nothing and resets the special prefix
              options (described later) to OFF- Please consider
              the Note given with the description of the MSG
              function on topic 4-4-3-

Results       Traces all clauses before execution-
              Displays final results (contrast with
              Intermediates, preceding) of evaluating an
              expression- Also displays values assigned during
              PULL, ARG, and PARSE instructions- This setting is
              recommended for general debugging-

Scan          Traces all remaining clauses in the data
              without them being processed- Basic checking
              (for missing ENDs and so forth) is carried
              out, and the trace is formatted as usual- This
              is valid only if the

              TRACE S clause itself is not nested in any
              other instruction (including INTERPRET or
              interactive debug) or in an internal routine-



TRACE  OUTPUT

1- How to read the TRACE OUTPUT

  A- A line number precedes the first clause traced on any line- If
     the line number is greater than 99999, the language processor
     truncates it on the left, and the ?  prefix indicates the
     truncation- For example, the line number 100354 appears as
     ?00354- All lines displayed during tracing have a three-character
     prefix to identify the type of data being traced- These can be:

*-*  Identifies the source of a single clause, that is, the data
     actually in the program-

+++  Identifies a trace message- This may be the nonzero return
     code from a command, the prompt message when interactive debug is
     entered, an indication of a syntax error when in interactive
     debug, or the trace back clauses after a syntax error in the
     program-

>>>  Identifies the result of an expression (for TRACE R) or the
     value assigned to a variable during parsing, or the value
     returned from a subroutine call-

>->  Identifies the value "assigned" to a placeholder during parsing

  B- The following prefixes are used only if TRACE Intermediates
     is in effect:

>C>  The data traced is the name of a compound variable, traced
     after substitution and before use, provided that the name had
     the value of a variable substituted into it-

>F>  The data traced is the result of a function call-

>L>  The data traced is a literal (string, un-initialized
     variable, or constant symbol)-

>O>  The data traced is the result of an operation on two terms-

>P>  The data traced is the result of a prefix operation-

>V>  The data traced is the contents of a variable-



TRACE TIPS

1- Receive an argument to turn trace on

ARG VAR1 VAR2 -
IF (VAR1 = "TRACE") THEN
 INTERPRET VAR1 VAR2


2- Subroutines to assist when using Interactive Trace Mode

    A- Place the below subroutines at the bottom of your REXX- When
       you are in interactive trace mode just type in "CALL
       DISPVARS" or "CALL DISPSRC 5 10"

DISPVARS:
  SAY "COUNTER = "COUNTER
  SAY "FIRSTIME = "FIRSTIME
  SAY "COLNO     =" COLNO
RETURN

DISPSRC:
  ARG BEGLINE ENDLINE -
  IF (BEGLINE = "") THEN DO
   BEGLINE = 1
   ENDLINE = 20
  END
  DO I = BEGLINE to ENDLINE
   SAY SUBSTR(SOURCELINE(I),1,79)
  END
RETURN



Batch

1- PGM=IKJEFT01

A- Invoking a REXX Program
" PARM=<rexx pgm>
" PARM='ISPSTART CMD(rexx pgm)'
" SYSTSIN DD card
              ISPSTART CMD(********) BDBCS

B- Can use TSO and ISPF Commands


2- PGM=IRXJCL

1- Return Code

2- Cannot use ISPF or TSO Commands


3- Items of Interest

  " Background processing does not interfere with a person's use of
    the terminal-
  " You can run time-consuming and low priority execs in the
    background, or execs that do not require terminal interaction-
  " When an exec runs in the TSO/E background or MVS batch, it has
    the same use of the data stack as an exec that runs in the TSO/E
    foreground- The PULL instruction, however, works differently when
    the data stack is empty- In the TSO/E foreground, PULL goes to
    the terminal for input- In the TSO/E background and MVS batch,
    PULL goes to the input stream as defined by ddname SYSTSIN- When
    SYSTSIN has no data, the PULL instruction returns a null- If the
    input stream has no data and the PULL instruction is in a loop,
    the exec can result in an infinite loop-
  " When submitting a TSO/E background task it assumes your RACF
    attributes-
  " To set the Return Code:
  ADDRESS ISPEXEC
  ZISPFRC = 8
  "VPUT (ZISPFRC)"


IKJEFT01


1- Generic IKJEFT01

//BATCHTSO EXEC PGM=IKJEFT01,PARM='REXXPGM REXXPARM',
//             REGION=4M,DYNAMNBR=50
//SYSEXEC  DD  DISP=SHR,DSN=<DSNAME WHERE  REXX RESIDES>
//SYSTSPRT DD  SYSOUT=*
//SYSTSIN  DD  DUMMY


2- IKJEFT01 using TSO Logon Procs

//TSOPROC JCLLIB ORDER=('sign-on-proclib')
//$ISDUSR     EXEC SCP,PARM-$ISDUSR=''
//$ISDUSR-SYSTSPRT DD SYSOUT=*
//$ISDUSR-ISPLOG DD DSN=&&ISPLOG,
//             DISP=(NEW,DELETE,DELETE),
//             UNIT=VIO,SPACE=(CYL,(2,5,1),RLSE)
//$ISDUSR-ISPLIST DD DSN=&&ISPLIST,
//             DISP=(NEW,DELETE,DELETE),
//             UNIT=VIO,SPACE=(CYL,(2,5,1),RLSE)
//$ISDUSR-ISPPROF DD DSN=&&ISPPROF,
//             DISP=(NEW,DELETE,DELETE),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120),
//             UNIT=VIO,SPACE=(CYL,(5,5,25),RLSE)
//$ISDUSR-SYSTSIN DD *
     ISPSTART CMD(********) BDBCS


3- Items of Interest

  " In both examples if you want to receive an MVS Return Code,
    execute the REXX Program as a parameter to IKJEFT01, instead of
    using SYSTSIN-
  " Example no- 2 is the preferred method of executing a REXX
    because it will have access to all ISPF datasets and it is
    easier to maintain- The System Programmers will maintain the
    TSO sign-on procs-
  " In Example no 2 we allocate a temporary ISPLOG, ISPLIST and
    ISPPROF to prevent error messages from being displayed in our
    SYSTSPRT-
  " The REXX program can be located in either the SYSPROC or
    SYSEXEC DD card-

IRXJCL


Reason you would want to use IRXJCL is it will always give you an
MVS return code and does not need to allocate a lot of datasets-
The negative part of using IRXJCL, is that your REXX must not
call any ISPF routines (bummer!)


This information is in book manager-  Below is how I found it:

1- Invoked Book Manager
2- Select "IKJ2BI02    TSO/E V2R5"
3- Search for "IRXJCL"
4- Select "IKJ2C307 TSO/E V2R5 REXX/MVS User's Guide"


Below is what it said:

2-6-3-2 Using IRXJCL to run an EXEC in MVS Batch

To run a REXX EXEC in MVS batch, you must specify program IRXJCL
in the JCL EXEC statement- SYSEXEC is the default load DD-
Running an EXEC in MVS batch is similar in many ways to running
an EXEC in the TSO/E background, however, there are significant
differences- One major difference is that the EXEC running in MVS
batch cannot use TSO/E services, such as TSO/E commands and most
of the TSO/E external functions- Additional similarities and
differences appear in "summary of TSO/E background and MVS batch"
in topic 2-6-4-

The following series of examples show how an MVS batch job named
userida invokes a REXX EXEC in a PDS member named
"userid-myREXX-EXEC(JCLTEST)"-

The member name, JCLTEST, is specified as the first word after
the PARM parameter of the EXEC statement- Two arguments, test and
IRXJCL, follow the member name- Output from the EXEC goes to an
output data set named "userid-IRXJCL-output", which is specified
in the SYSTSPRT DD statement-

The SYSTSIN DD statement supplies the EXEC with three lines of
data in the input stream- This EXEC also uses EXECIO to write a
1-line timestamp to the end of the sequential data set
"userid-trace-output", which is allocated in the OUTDD statement-

//userida   JOB  'account,dept,bldg','programmer  name',
//               CLASS=J,MSGCLASS=X,MSGLEVEL=(1,1)
//*
//MVSBATCH   EXEC  PGM=IRXJCL,
//                       PARM='jcltest test IRXJCL'
//*                                   |         ||                   |
//*   name of  EXEC       <----> |                  |
//*   argument                            <----------->
//OUTDD       DD   DISP=SHR,DSN=userid-trace-output
//SYSTSPRT  DD   DISP=SHR,DSN=userid-IRXJCL-output
//SYSEXEC    DD   DISP=SHR,DSN=userid-myREXX-EXEC
//SYSTSIN     DD     *
  first  line  of  data
  second  line  of  data
  third  line  of  data
/*
//


1- Items of interest

" The default environment is MVS-


RACF



1- RACF the following

" The datasets where the REXX, ISPF Panels, Skeletons, Tables,
  and Messages reside-
" The TSO sign-on proc-
" Data files-
" Password File-


2- RACF Commands

    A- List all sign-on procs

        TSO  SR  CLASS(TSOPROC)

    B- List RACF attributes for a single TSO Sign-on

        TSO  RL  TSOPROC <proc-name> ALL

    C- List RACF attributes for a dataset

        TSO  LD  DATASET('dsname')  ALL

    D- List RACF attributes for a userid

        TSO  LU  <userid>

    Note:  The Userid that executes these commands must have the
           Auditor Bit turned ON-


3- Encrypt the Password

" Buy or create software that will encrypt the password-

