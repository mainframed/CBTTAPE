/* REXX */
/**********************************************************************/
/* this routine gets system information - version 1.1                 */
/**********************************************************************/
/*------------------ initialize global variables ---------------------*/
trace 0
arg optn
address tso                                    /* set mode            */
numeric digits 30                              /* set decimal size    */
cvt = c2d(storage(10,4))                       /* point to cvt        */
ecvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */
sysn = mvsvar('SYSNAME')                       /* get sysname         */
red   = '01'x                                  /* set colour          */
blue  = '02'x                                  /* attributes fo the   */
green = '03'x                                  /* dynamic display     */
white = '04'x                                  /* area                */
turq  = '05'x                                  /*                     */
pink  = '06'x                                  /*                     */
yellow = '07'x                                 /*                     */
/*--------------------- select an option -----------------------------*/
if optn <> '' then                             /* no string passed    */
  do
    select
      when optn = 'SYS' | optn = 1 then call system
      when optn = 'STR' | optn = 2 then call storeuse
      when optn = 'MAP' | optn = 3 then call storemap
      when optn = 'VER' | optn = 4 then call softver
      when optn = 'LPA' | optn = 5 then call lpalist
      when optn = 'LNK' | optn = 6 then call lnklist
      when optn = 'APF' | optn = 7 then call apflist
      when optn = 'ASL' | optn = 8 then call asllist
      otherwise call mainmenu                  /* display main menu   */
    end
  end
else
  do forever
    call mainmenu                              /* display main menu   */
    select
      when optn = 1 then call system
      when optn = 2 then call storeuse
      when optn = 3 then call storemap
      when optn = 4 then call softver
      when optn = 5 then call lpalist
      when optn = 6 then call lnklist
      when optn = 7 then call apflist
      when optn = 8 then call asllist
      otherwise exit                           /* end of the program  */
    end
  end

exit                                           /* end of the program  */
/*--------------------- display primary panel ------------------------*/
mainmenu:
address ispexec
title = ' System Information on 'sysn          /* set display title   */

"addpop row(2) column(12)"                     /* start window        */
"display panel(checkmnu)"                      /* display results     */
"rempop"                                       /* stop window         */

return
/****************************** Option 1 ******************************/
/*------------------ calculate and display system info ---------------*/
/**********************************************************************/
system:
address tso                                    /* set mode            */
sort = 'N'                                     /* don't allow sorting */
title = ' System Information '                 /* set display title   */
call get_cpu_info
call get_ipl_time
call get_ipl_info
call get_iodf_dsn
call get_sysres
call get_unit_addr
call get_volser
call get_real_storage
address ispexec                                /* set mode            */
"addpop row(2) column(2)"                      /* start window        */

do until rc > 0
  "display panel(checkstm)"                    /* display results     */
end

"rempop"                                       /* stop window         */
address tso                                    /* set mode            */

return
/*---------------- get IPL time --------------------------------------*/
get_ipl_time:
cvtsmca = c2d(storage(d2x(cvt+196),4))         /* point to cvtsmca    */
ipltime = c2d(storage(d2x(cvtsmca+336),4))     /* point to smcaitme   */
/* ------- convert time from hundreds of seconds to hh:mm:ss -------- */
ipltime = ipltime%100                          /* remove 100's        */
iplhrs = ipltime%3600                          /* calculate hours     */
iplhrs = right(iplhrs,2,'0')                   /* add leading zero    */
ipltime = ipltime//3600                        /* calculate minutes   */
iplmin = ipltime%60                            /* decimal convertion  */
iplmin = right(iplmin,2,'0')                   /* add leading zero    */
iplsec = ipltime//60                           /* calculate seconds   */
iplsec = right(iplsec,2,'0')                   /* add leading zero    */
ipltime= iplhrs':'iplmin':'iplsec              /* build string        */
/* ------- convert julian days to day of the week ------------------- */
ipldate = c2x(storage(d2x(cvtsmca+340),4))     /* point to smcaidte   */
parse var ipldate . 3 yy 5 ddd 8 .             /* strip out year, day */
juldate = yy||ddd                              /* build julain date   */
ipldate = date(,''juldate'','j')               /* Get the date        */
iplday  = date(w,''juldate'','j')              /* Get the day         */

return
/*---------------- get IPL info --------------------------------------*/
get_ipl_info:
ihaipa = c2d(storage(d2x(ecvt+392),4))         /* point to ecvtipa    */
ipll = storage(d2x(ihaipa+16),8)               /* ipl load parameters */
hcdu = storage(d2x(ihaipa+16),4)               /* hcd unit address    */
hcdm = storage(d2x(ihaipa+20),2)               /* hcd load member     */
lpar = storage(d2x(ihaipa+32),8)               /* lpar name           */
ipld = strip(storage(d2x(ihaipa+48),44))       /* ipl parm DSN        */
iplu = storage(d2x(ihaipa+92),4)               /* ipl load parm addr. */
hcds = storage(d2x(ihaipa+96),2)               /* iodf suffix         */
hcdq = storage(d2x(ihaipa+99),8)               /* hcd hi-level qual.  */
syssf = strip(storage(d2x(ihaipa+160),2))      /* ieasysxx suffixes   */
mvol = storage(d2x(ihaipa+224),6)              /* mcat volser         */
mcat = storage(d2x(ihaipa+234),44)             /* master catalog name */
symsf = strip(storage(d2x(ihaipa+288),63))     /* ieasymxx suffixes   */
pdsn = strip(storage(d2x(ihaipa+416),44))      /* parmlib dsn         */
pvol = storage(d2x(ihaipa+461),6)              /* parmlib volser      */
ipln = ipld'(LOAD'hcdm')'                      /* build iplparm dsn   */

return
/*---------------- get IODF DSN --------------------------------------*/
get_iodf_dsn:
cvtixavl = c2d(storage(d2x(cvt+124),4))        /* point to cvtixavl   */
iociovtp = c2d(storage(d2x(cvtixavl+208),4))   /* point to iociovtp   */
hcdn   = strip(storage(d2x(iociovtp+288),15))  /* point to iodf name  */
cda      = c2d(storage(d2x(iociovtp+24),4))    /* point to cda        */
hcdn     = strip(storage(d2x(cda+32),15))      /* point to iodf name  */
configid = storage(d2x(cda+92),8)              /* point to config     */
edt      = storage(d2x(cda+104),2)             /* point to edt        */

return
/*--------------------- get the sysres volser ------------------------*/
get_sysres:
ucb    = c2d(storage(d2x(cvt+48),4))           /* point to cvtsmca    */
sysres = storage(d2x(ucb+28),6)                /* sysres volume       */
sysrs2 = mvsvar('symdef','sysr2')              /* get second sysres   */

if sysrs2 = '' then sysrs2 = '-none-'          /* no second sysres    */

return
/*---------------- get the unit address ------------------------------*/
get_unit_addr:
saddr = getucb(sysres)                         /* sysres device no.   */

if sysrs2 ¬= '-none-' then saddr2 = getucb(sysrs2) /* no second sysres*/

paddr = getucb(pvol)                           /* parmlib device no.  */
maddr = getucb(mvol)                           /* mcat   device no.   */

return
/*----------------------- get the volser -----------------------------*/
get_volser:
iplv = getvol(iplu)                            /* iplparm volser      */
hcdv = getvol(hcdu)                            /* iodf volser         */

return
/*---------------- get numbers of cpu's ------------------------------*/
get_cpu_info:
cvtscpin = c2d(storage(d2x(cvt+832),4))        /* point to cvtscpin   */
cpuno = c2d(storage(d2x(cvtscpin+16),2))       /*  get no. of cpu's   */
/*---------------- get cpu info --------------------------------------*/
cvthid = c2d(storage(d2x(cvt+1068),4))         /* point to cvthid     */
cputype = strip(storage(d2x(cvthid+28),4))     /* get cpu type        */
cpumod = strip(storage(d2x(cvthid+32),3))      /* get cpu model       */
cpu = cputype'-'cpumod
/*---------------- set up cpu display fields -------------------------*/
x = syscpus('cpuid.')

do cntr = 1 to cpuid.0                         /* pack cpu id. into   */
  temp_var_name = 'cpu'||cntr                  /* display string      */
  interpret temp_var_name '= substr(cpuid.cntr,3,6)'
end

return
/*---------------- get storage values --------------------------------*/
get_real_storage:
cvtrlstg = c2d(storage(d2x(cvt+856),4))        /* point to cvtrlstg   */
realm  = cvtrlstg/1024                         /* convert to MB.      */
cvtrcep = c2d(storage(d2x(cvt+1168),4))        /* point to cvtrcep    */
xpand  = c2d(storage(d2x(cvtrcep+160),4))      /* no. expanded stor.  */
xpand  = xpand*4/1024                          /* convert to MB.      */

return
/*--------------------- get device number from UCB -------------------*/
getucb: procedure expose vol dnum
arg vol                                        /* get volume name     */
dnum = '0000'                                  /* initilaize device   */
address LINKPGM "GETUADDR vol dnum"            /* call program        */
return dnum
/*--------------------- get volser from UCB --------------------------*/
getvol: procedure expose vol dnum
arg dnum                                       /* get device address  */
vol= 'XXXXXX'                                  /* initilaize volser   */
address LINKPGM "GETUADDR vol dnum"            /* call program        */
return vol
/****************************** Option 2 ******************************/
/*------------------ calculate and display storage useage ------------*/
/**********************************************************************/
storeuse:
address tso                                    /* set mode            */
sort = 'N'                                     /* don't allow sorting */
title = ' Storage Usage '                      /* set display title   */
call set_default
call get_storage_use
call get_slots
address ispexec                                /* set mode            */
"addpop row(2) column(2)"                      /* start window        */

do until rc > 0
  "display panel(checkstr)"                    /* display results     */
end

"rempop"                                       /* stop window         */
address tso                                    /* set mode            */

return
/*---------------- get available 'slots' -----------------------------*/
get_slots:
cvtasvt = c2d(storage(d2x(cvt+556),4))         /* point to cvtasvt    */
sltf = c2d(storage(d2x(cvtasvt+480),4))        /* # slots free        */
slti = c2d(storage(d2x(cvtasvt+484),4))        /* # slots initial     */
sltn = c2d(storage(d2x(cvtasvt+488),4))        /* # slots not reusable*/
maxo = c2d(storage(d2x(cvtasvt+500),4))        /* # slots orginally   */
maxu = c2d(storage(d2x(cvtasvt+516),4))        /* # slots available   */

return
/****************************** Option 3 ******************************/
/*------------------ calculate and display storage map ---------------*/
/**********************************************************************/
storemap:
address tso                                    /* set mode            */
sort = 'N'                                     /* don't allow sorting */
title = ' Storage Map '                        /* set display title   */
call set_default
call get_storage_use
call get_storage_map
address ispexec                                /* set mode            */
"addpop row(2) column(10)"                     /* start window        */

do until rc > 0
  "display panel(checkmap)"                    /* display results     */
end

"rempop"                                       /* stop window         */
address tso                                    /* set mode            */

return
/*---------------- get storage allocation ----------------------------*/
get_storage_map:
cvtgda = c2d(storage(d2x(cvt+560),4))          /* point to cvtgda     */
csas  = strip(c2x(storage(d2x(cvtgda+108),4)),'l',0) /* start of csa  */
csa   = strip(c2x(storage(d2x(cvtgda+112),4)),'l',0) /* csa size      */
csak  = x2d(csa)/1024                                /* convert to K. */
csae  = d2x(x2d(csa)+x2d(csas)-1)                    /* end of csa    */
ecsas = strip(c2x(storage(d2x(cvtgda+124),4)),'l',0) /* start of ecsa */
ecsa  = strip(c2x(storage(d2x(cvtgda+128),4)),'l',0) /* ex. csa size  */
ecsak = x2d(ecsa)/1024                               /* convert to K. */
ecsae = d2x(x2d(ecsa)+x2d(ecsas)-1)                  /* end of ecsa   */
sqas  = strip(c2x(storage(d2x(cvtgda+144),4)),'l',0) /* start of sqa  */
sqa   = strip(c2x(storage(d2x(cvtgda+148),4)),'l',0) /* sqa size *    */
sqak  = x2d(sqa)/1024                                /* convert to K. */
sqae  = d2x(x2d(sqa)+x2d(sqas)-1)                    /* end of sqa    */
esqas = strip(c2x(storage(d2x(cvtgda+152),4)),'l',0) /* start of esqa */
esqa  = strip(c2x(storage(d2x(cvtgda+156),4)),'l',0) /* ex. esqa size */
esqak = x2d(esqa)/1024                               /* convert to K. */
esqae = d2x(x2d(esqa)+x2d(esqas)-1)                  /* end of esqa   */
priv  = strip(c2x(storage(d2x(cvtgda+164),4)),'l',0) /* priv.  size   */
privk = x2d(priv)/1024                               /* convert to K. */
prive = d2x(20480+((privk-20)*1024)-1)               /* end of priv.  */
eprvs = strip(c2x(storage(d2x(cvtgda+168),4)),'l',0) /* start of eprv.*/
eprv  = strip(c2x(storage(d2x(cvtgda+172),4)),'l',0) /* epriv. size   */
eprvk = x2d(eprv)/1024                               /* convert to K. */
eprve = d2x(x2d(eprv)+x2d(eprvs)-1)                  /* end of epriv. */
gblr  = strip(c2x(storage(d2x(cvtgda+196),4)),'l',0) /* size v=r gbl. */
gblrk = x2d(gblr)/1024                               /* convert to K. */
gblre = d2x(20480+x2d(gblr)-1)                       /* end of global */
cvtsmext = c2d(storage(d2x(cvt+1196),4))           /* pnt to cvtsmext */
mlpas  = strip(c2x(storage(d2x(cvtsmext+8),4)),'l',0) /*start of mlpa */

if mlpas <> 0 then                             /* mlpa in use         */
  do
    mlpae = strip(c2x(storage(d2x(cvtsmext+12),4)),'l',0)
    mlpak = (x2d(mlpae)-x2d(mlpas)+1)/1024     /* calc and convert    */
  end
else                                           /* no mlpa             */
  do
    mplas = '  n/a   '
    mlpae = '  n/a   '
    mlpak = 0
  end

flpas = strip(c2x(storage(d2x(cvtsmext+16),4)),'l',0) /*start of flpa */

if flpas <> 0 then                             /* flpa in use         */
  do
    flpae = strip(c2x(storage(d2x(cvtsmext+20),4)),'l',0)
    flpak = (x2d(flpae)-x2d(flpas)+1)/1024     /* calc and convert    */
  end
else                                           /* no flpa             */
  do
    fplas = '  n/a   '
    flpae = '  n/a   '
    flpak = 0
  end

plpas = strip(c2x(storage(d2x(cvtsmext+24),4)),'l',0) /*start of plpa */
plpae = strip(c2x(storage(d2x(cvtsmext+28),4)),'l',0) /* end of plpa  */
plpak = (x2d(plpae)-x2d(plpas)+1)/1024               /* calc and conv */
nucws = strip(c2x(storage(d2x(cvtsmext+32),4)),'l',0) /* start of r/w */
nucwe = strip(c2x(storage(d2x(cvtsmext+36),4)),'l',0) /* end of r/w   */
nucwk = (x2d(nucwe)-x2d(nucws)+1)/1024               /* calc and conv */
nucwk = format(nucwk,,0)                             /* tidy up size  */
nucos = strip(c2x(storage(d2x(cvtsmext+40),4)),'l',0) /*start of flpa */
nucok = (x2d('ffffff')-x2d(nucos)+1)/1024            /* calc and conv */
enucoe = strip(c2x(storage(d2x(cvtsmext+44),4)),'l',0) /* end of r/o  */
enucok = X2d(enucoe)-X2d('1000000')+1                /* calc and conv */
enucok = Format(enucok/1024,,0)                      /* tidy up size  */
enucws = strip(c2x(storage(d2x(cvtsmext+48),4)),'l',0) /* str e-r/w   */
enucwe = strip(c2x(storage(d2x(cvtsmext+52),4)),'l',0) /* end e-r/w   */
enucwk = (x2d(enucwe)-x2d(enucws)+1)/1024            /* calc and conv */
enucwk = format(enucwk,,0)                           /* tidy up size  */
eplpas = strip(c2x(storage(d2x(cvtsmext+56),4)),'l',0) /*str of eplpa */
eplpae = strip(c2x(storage(d2x(cvtsmext+60),4)),'l',0) /*end of eplpa */
eplpak = (x2d(eplpae)-x2d(eplpas)+1)/1024            /* calc and conv */
eflpas = strip(c2x(storage(d2x(cvtsmext+64),4)),'l',0) /*str of eflpa */

if eflpas <> 0 then                            /* ext. flpa in use    */
  do
    eflpae = strip(c2x(storage(d2x(cvtsmext+68),4)),'l',0)
    eflpak = (x2d(eflpae)-x2d(eflpas)+1)/1024  /* calc and convert    */
  end
else                                           /* no ext. flpa        */
  do
    efplas = '  n/a   '
    eflpae = '  n/a   '
    eflpak = 0
  end

emlpas = strip(c2x(storage(d2x(cvtsmext+72),4)),'l',0) /* str emlpa   */

if emlpas <> 0 then                            /* ext. mlpa in use    */
  do
    emlpae = strip(c2x(storage(d2x(cvtsmext+76),4)),'l',0)
    emlpak = (x2d(emlpae)-x2d(emlpas)+1)/1024  /* calc and convert    */
  end
else                                           /* no ext. mlpa        */
  do
    emplas = '  n/a   '
    emlpae = '  n/a   '
    emlpak = 0
  end

return
/****************************** Option 4 ******************************/
/*------------------ calculate and display software version ----------*/
/**********************************************************************/
softver:
address tso                                    /* set mode            */
sort = 'N'                                     /* don't allow sorting */
title = ' Version Information '                /* set display title   */

call get_sysvar
call get_vtam
call get_dfa
call get_ispf
address ispexec                                /* set mode            */
"addpop row(2) column(6)"                      /* start window        */

do until rc > 0
  "display panel(checkver)"                    /* display results     */
end

"rempop"                                       /* stop window         */
address tso                                    /* set mode            */

return
/*--------------------- get system variable information --------------*/
get_sysvar:
osysd = mvsvar('sysopsys')                     /* get OS level        */
osys1 = substr(osysd,1,6)                      /* format              */
osys2 = substr(osysd,8,8)
osysv = osys1' 'osys2
fmid = substr(osysd,17,7)                      /* get FMID level      */
jesd = sysvar('sysjes')                        /* format              */
jesv = substr(jesd,9,8)
dfpv = substr(mvsvar('sysdfp'),4,8)
hsm  = sysvar('syshsm')                        /* get HSM level       */
hsml = right(substr(hsm,1,1),2,0)              /* format              */
hsmr = substr(hsm,2,2)
hsmm = right(substr(hsm,4,1),2,0)
hsmv = hsml'.'hsmr'.'hsmm
racf = sysvar('syslracf')                      /* get RACF level      */
racfl = right(substr(racf,1,1),2,0)            /* format              */
racfr = substr(racf,2,2)
racfm = right(substr(racf,4,1),2,0)
racfv = racfl'.'racfr'.'racfm
tso  = sysvar('systsoe')                       /* get TSO level       */
tsol = right(substr(tso,1,1),2,0)              /* format              */
tsor = substr(racf,2,2)
tsom = right(substr(tso,4,1),2,0)
tsov = tsol'.'tsor'.'tsom
smfid = mvsvar('syssmfid')                     /* get SMFID           */
splx = mvsvar('sysplex')                       /* get Sysplex Id.     */
mvs = mvsvar('sysmvs')                         /* get MVS level       */

return
/*---------------- get the vtam version and release ------------------*/
get_vtam:
atcvt = c2d(storage(408,4))                    /* point to atcvt      */
vtamr = storage(d2x(atcvt+2),1)                /* get vtam version    */
vtaml = storage(d2x(atcvt+3),1)                /* get vtam release    */
vtamv = vtamr'.'vtaml                          /* build display       */

return
/*---------------- get dfa version------------------------------------*/
get_dfa:
cvtdfa  = c2d(storage(d2x(cvt+1216),4))        /* get cvtdfa address  */
dfaprod = c2x(storage(d2x(cvtdfa+16),1))       /* product type        */
dfaver  = c2x(storage(d2x(cvtdfa+17),1))       /* version             */
dfarlse = c2x(storage(d2x(cvtdfa+18),1))       /* release             */
dfamod  = c2x(storage(d2x(cvtdfa+19),1))       /* modification        */

if dfamod = '' then dfamod = 0                 /* add modification    */

dfsms = dfaver'.'dfarlse'.'dfamod              /* build display       */

return
/*----------------------- get the ispf level -------------------------*/
get_ispf:
address ispexec                                /* set mode            */
vget ZENVIR                                    /* get ispf version    */
ispfv = substr(ZENVIR,6,3)                     /* build display       */
drop ZENVIR                                    /* drop ispf variable  */
address tso                                    /* reset mode          */

return
/****************************** Option 5 ******************************/
/*--------------------- get lpa list ---------------------------------*/
/**********************************************************************/
lpalist:
address tso                                    /* set mode            */
sort = 'N'                                     /* don't allow sorting */
cur_line = 1                                   /* first row           */
csrpos  = 1                                    /* first character     */
poppos  = 10                                   /* start pos. for pop  */
scrn_wdth = 45                                 /* set screen width    */
panel_name = checklpa                          /* set panel name      */
cvtsmext = c2d(storage(d2x(cvt+1196),4))       /* point to cvtsmext   */
cvteplps = c2d(storage(d2x(cvtsmext+56),4))    /* point to cvteplps   */
maxlines = c2d(storage(d2x(cvteplps+4),4))     /* number of entries   */
lpatntry = cvteplps+9                          /* point to first dsn  */

do inc = 1 for maxlines
  lpadsn = storage(d2x(lpatntry),44)           /* get the lpa dsn     */
  lpatntry = lpatntry+45                       /* increment the pntr  */
  line.inc = green||lpadsn                     /* build display str.  */
end

title = maxlines' LPA Datasets '               /* set display title   */
call display_list                              /* display results     */

return
/****************************** Option 6 ******************************/
/*--------------------- get link list --------------------------------*/
/**********************************************************************/
lnklist:
address tso                                    /* set mode            */
sort = 'N'                                     /* don't allow sorting */
cur_line = 1                                   /* first row           */
csrpos  = 1                                    /* first character     */
poppos  = 6                                    /* start pos. for pop  */
scrn_wdth = 56                                 /* set screen width    */
panel_name = checklnk                          /* set panel name      */
ascb = c2d(storage(224,4))                     /* point to ascb       */
assb = c2d(storage(d2x(ascb+336),4))           /* point to assb       */
dlcb = c2d(storage(d2x(assb+236),4))           /* point to dlcb       */
lnkname = strip(storage(d2x(dlcb+36),16),t)    /* lnklst set name     */
cvtllta = c2d(storage(d2x(dlcb+16),4))         /* point to cvtllta    */
lltx = c2d(storage(d2x(dlcb+20),4))            /* point to lltx       */
maxlines = c2d(storage(d2x(cvtllta+4),4))      /* number of entry     */
lltapftb = cvtllta + 8 + (maxlines * 45)       /* first entry         */
lnkoff = 8                                     /* offset for dsn      */
voloff = 8                                     /* offset for vol      */
apfoff = 0                                     /* offset for apf      */

do inc = 1 to maxlines
  len = c2d(storage(d2x(cvtllta+lnkoff),1))    /* length of entry     */
  lnkdsn = storage(d2x(cvtllta+lnkoff+1),len)  /* get the dsn         */
  lnkvol = storage(d2x(lltx+voloff),6)         /* get the volser      */
  apflag = storage(d2x(lltapftb+apfoff),1)     /* check apf flag      */
  if bitand(apflag,'80'x) = '80'x then dsnapf = 'Y' /* apf flag on    */
  else dsnapf = ' '                            /* apf flag off        */
  lnkoff = lnkoff + 45                         /* incr. lnkoff        */
  voloff = voloff + 8                          /* incr. voloff        */
  apfoff = apfoff + 1                          /* incr. apfoff        */
  line.inc = green||left(lnkdsn,45)||blue||left(lnkvol||' ',
             ||red||dsnapf,9)
end

title = maxlines' LinkList Datasets in 'lnkname
call display_list                              /* display results     */

return
/****************************** Option 7 ******************************/
/*--------------------- get apf list ---------------------------------*/
/**********************************************************************/
apflist:
address tso                                    /* set mode            */
sort = 'N'                                     /* don't allow sorting */
cur_line = 1                                   /* first row           */
csrpos  = 1                                    /* first character     */
poppos  = 8                                    /* start pos. for pop  */
scrn_wdth = 53                                 /* set screen width    */
panel_name = checkapf                          /* set panel name      */

cvtauthl = c2d(storage(d2x(cvt+484),4))        /* point to cvtauthl   */

if cvtauthl <> c2d('7ffff001'x) then           /* dynamic list ?      */
  do
    maxlines = c2d(storage(d2x(cvtauthl),2))   /* £ apf in table      */
    apfoff   = 2                               /* first in apf tbl    */
    do inc = 1 to maxlines
       len = c2d(storage(d2x(cvtauthl+apfoff),1))  /* length of entry */
       apfvol = storage(d2x(cvtauthl+apfoff+1),6)  /* apf volser      */
       apfdsn = storage(d2x(cvtauthl+apfoff+1+6),len-6) /* apf dsn    */
       apfoff = apfoff+len+1                   /* set apf offset      */
       line.inc = green||left(apfdsn,45)||blue||apfvol
    end
  end
else
  do
    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */
    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */
    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */
    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */
    apf. = ''
    inc = 0
    do forever
      apfdsn = storage(d2x(apht+24),44)        /* apf dataset name    */
      if substr(apfdsn,1,1) ¬= '00'x then      /* 00 = deleted        */
        do
          apfesms = storage(d2x(apht+4),1)     /* sms flag            */
          if  bitand(apfesms,'80'x)  = '80'x then apfvol = '*SMS* '
          else apfvol = storage(d2x(apht+68),6)   /* apf volser       */
          line.inc =green||left(apfdsn,45)||blue||apfvol
          inc = inc + 1
        end
      if apht = last then leave
      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */
    end
    maxlines = inc - 1
  end                                          /* set maximum lines   */

title = maxlines' APF Datasets '               /* set display title   */
call display_list                              /* display results     */

return
/****************************** Option 8 ******************************/
/*--------------------- get address space list -----------------------*/
/**********************************************************************/
asllist:
address tso                                    /* set mode            */
sort = 'Y'                                     /* allow sorting       */
cur_line = 1                                   /* first row           */
csrpos  = 1                                    /* first character     */
poppos  = 3                                    /* start pos. for pop  */
display_again = 'Y'                            /* display once        */
scrn_wdth = 64                                 /* set screen width    */
panel_name = checkasl                          /* set panel name      */
sfld = 2                                       /* sort on first field */
sfld = 2                                       /* sort on first field */
slen = 8                                       /* length of field     */
sorder = 'A'                                   /* sort type           */
vfld = 'ALL'                                   /* view selection flag */
vdis = 'All'                                   /* view selection flag */
cvtasvt = c2d(storage(d2x(cvt+556),4))         /* point to cvtasvt    */
asvtmaxu = c2d(storage(d2x(cvtasvt+516),4))    /* £ slots available   */

do until display_again = 'N'                  /* until PF3 is pressed */
  inc = 1                                      /* at least once       */
  acnt = 0                                     /*                     */
  bcnt = 0                                     /*                     */
  btcnt = 0                                    /* initialize          */
  icnt = 0                                     /* counters            */
  ocnt = 0                                     /* for all active      */
  scnt = 0                                     /* address spaces      */
  stcnt = 0                                    /*                     */
  sycnt = 0                                    /*                     */
  tcnt = 0                                     /*                     */
  ucnt = 0                                     /*                     */
  inc = 1                                      /* at least once       */
/*---------------- get the cpu percentage ----------------------------*/
  srmt = c2d(storage((d2x(cvt+604)),4))        /* point to smrt       */
  cct = c2d(storage((d2x(srmt+4)),4))          /* point to cvtecvt    */
  cpp = format(c2d(storage(d2x(cct+102),2)),3)||'%' /* format display */
/*---------------- loop through non-vacant asvt slots ----------------*/
  do cntr = 0 to asvtmaxu                     /* check all ASVT slots */
    offset = cntr * 4                          /* increment offset    */
    in_use_flag = storage(d2x(cvtasvt+528+offset),1)  /* get flag     */
    if bitand(in_use_flag,'80'x) = '80'x then iterate   /* in use?    */
    ascb = c2d(storage(d2x(cvtasvt+528+offset),4)) /* get ascb addr.  */
    if ascb = '0' then iterate                     /* valid address?  */
    if storage(d2x(ascb),4) <> 'ASCB' then iterate   /* eye catcher?  */
    call get_ascb
  end
  maxlines = inc - 1                           /* set maximum lines   */
  mcnt = maxlines                              /* set total ASIDs     */
  call quicksort 1,maxlines                    /* sort the displays   */
  title = ' Address Space List - 'vdis         /* set display title   */
  call display_list                            /* display results     */
end

return
/*------------- get address space infomation -------------------------*/
get_ascb:
asid = red||right(c2d(storage(d2x(ascb+36),2)),3)  /* get ASID        */
dpri = blue||right(c2x(storage(d2x(ascb+43),1)),3) /* dispatch prior. */
cscb = c2d(storage(d2x(ascb+56),4))            /* address of CSCB     */
ascbejst = c2d(storage(d2x(ascb+64),8))        /* job step cpu time   */
/*--------------- convert CPU time to hh:mm.ss -----------------------*/
cputime = ascbejst/4096/1000000                /* convert to minutes  */
cpuhrs = cputime%60                            /* convert to hours    */
cpuhrs = right(cpuhrs,3,' ')||':'              /* pad, add separator  */
cpumin = (cputime//60)*60%60                   /* get seconds         */
cpumin = right(cpumin,2,'0')||'.'              /* pad, add separator  */
cpusec = cputime//1                            /* get seconds         */
cpusec = substr(cpusec,3,2,'0')                /* pad                 */
cpu = white||cpuhrs||cpumin||cpusec            /* build string        */
/*--------------- get the assb info and build output line ------------*/
assb = c2d(storage(d2x(ascb+336),4))           /* address of ASSB     */
assbvsc = c2d(storage(d2x(assb+32),4))         /* VIO Aux pages used  */
vio = turq||right(assbvsc,8)                   /* vio count           */
assbnvsc = c2d(storage(d2x(assb+36),4))        /* non-VIO Aux pages   */
nonvio = blue||right(assbnvsc,8)               /* non-vio count       */
/*------------- set the job name and display colour ------------------*/
ascbjbns = c2d(storage(d2x(ascb+176),4))       /* address of jobname  */

if ascbjbns = 0 then call starting_asid        /* Starting asid       */
else
  do
    jname = storage(d2x(ascbjbns),8)           /* get jobname         */
    if cscb = 0 then call master_asid          /* Master asid?        */
    else
      do
        chtrkid = c2d(storage(d2x(cscb+28),1)) /* display identifier  */
        select
          when chtrkid = 1 then call tso_asid  /* TSO asid?           */
          when chtrkid = 2 then call stc_asid  /* STC asid?           */
          when chtrkid = 3 then call init_asid /* Initiator asid?     */
          when chtrkid = 4 then call system_asid /* System asid       */
          otherwise call unknown_asid          /* Unknown asid        */
        end
      end
  end

oucb = c2d(storage(d2x(ascb+144),4))           /* address of OUCB     */
oucbsfl = storage(d2x(oucb+17),1)              /* swapout flag        */
oucbsrc = c2d(storage(d2x(oucb+41),1))         /* get swap code       */
/*----------------- convert numeric to swap code ---------------------*/
select
  when oucbsrc = 1 then swap = blue||'TO'
  when oucbsrc = 2 then swap = green||'TI'
  when oucbsrc = 3 then swap = pink||'LW'
  when oucbsrc = 4 then swap = turq||'XS'
  when oucbsrc = 5 then swap = blue||'RS'
  when oucbsrc = 6 then swap = pink||'DW'
  when oucbsrc = 7 then swap = green||'RQ'
  when oucbsrc = 8 then swap = turq||'NQ'
  when oucbsrc = 9 then swap = blue||'EX'
  when oucbsrc = 10 then swap = pink||'US'
  when oucbsrc = 11 then swap = gteen||'TS'
  when oucbsrc = 12 then swap = turq||'IC'
  when oucbsrc = 13 then swap = blue||'IP'
  when oucbsrc = 14 then swap = pink||'MR'
  when oucbsrc = 15 then swap = green||'AW'
  when oucbsrc = 16 then swap = turq||'OI'
  when oucbsrc = 17 then swap = blue||'OO'
  otherwise if bitand(oucbsfl,'80'x) = '80'x then swap = green||'NS'
            else swap = yellow||'IN'
end

ouxb = c2d(storage(d2x(ascb+148),4))           /* address of ouxb     */
ouxbiosm = c2d(storage(d2x(ouxb+152),4))       /* exception count     */
excp = pink||right(strip(ouxbiosm),9)          /* get exception count */
rsme = c2d(storage(d2x(ascb+364),4))           /* address of rsme     */
rstor = green||format(c2d(storage(d2x(rsme+44),4)),5) /* format rstor */

if vfld = 'ALL' then call build_output
else
  if type = vfld then call build_output
  else nop

return
/*----------------------- build the output line ----------------------*/
build_output:
line.inc = jname||asid||dpri||swap||cpu||rstor||vio||nonvio||excp
inc = inc + 1                                  /* increment counter   */

return
/*----------------------- Init ASID ----------------------------------*/
init_asid:
select
  when jname = 'ASCHINT' then                  /* Initiator?          */
    do
      jname = white||jname                     /* set colour          */
      type = 'ASC'                             /* set type            */
      acnt = acnt + 1                          /* increment counter   */
    end
  when jname = 'BPXAS' then                    /* OMVS asid?          */
    do
      ascbjbni = c2d(storage(d2x(ascb+172),4)) /* iname address       */
      if ascbjbni = 0 then                     /* blank iname field   */
        do
          jname = pink||jname                  /* set colour          */
          type = 'BPX'                         /* set type            */
          bcnt = bcnt + 1                      /* increment counter   */
        end
      else
        do
          jname = pink||storage(d2x(ascbjbni),8) /* use iname         */
          type = 'OMV'                         /* set type            */
          ocnt = ocnt + 1                      /* increment counter   */
        end
    end
  when jname = 'INIT' then                     /* Initiator?          */
    do
      ascbjbni = c2d(storage(d2x(ascb+172),4)) /* iname address       */
      if ascbjbni = 0 then                     /* blank iname field   */
        do
          jname = white||jname                 /* set colour          */
          type = 'INI'                         /* set type            */
          icnt = icnt + 1                      /* increment counter   */
        end
      else
        do
          jname = yellow||storage(d2x(ascbjbni),8) /* use iname       */
          type = 'BAT'                         /* set type            */
          btcnt = btcnt + 1                    /* increment counter   */
        end
    end
  otherwise call unknown_asid                  /* what's left         */
end

return
/*----------------------- Master ASID --------------------------------*/
master_asid:
jname = white||jname                           /* set colour          */
type = 'SYS'                                   /* set type            */
sycnt = sycnt + 1                              /* increment counter   */

return
/*----------------------- Starting ASID ------------------------------*/
starting_asid:
jname = yellow||'Starting'                     /* set colour          */
type = 'UKN'                                   /* set type            */
stcnt = stcnt + 1                              /* increment counter   */

return
/*----------------------- STC ASID -----------------------------------*/
stc_asid:
jname = turq||jname                            /* set colour          */
type = 'STC'                                   /* set type            */
scnt = scnt + 1                                /* increment counter   */

return
/*----------------------- System ASID --------------------------------*/
system_asid:
jname = blue||jname                            /* set colour          */
type = 'SYS'                                   /* set type            */
sycnt = sycnt + 1                              /* increment counter   */

return
/*----------------------- TSO ASID -----------------------------------*/
tso_asid:
jname = green||jname                           /* set colour          */
type = 'TSO'                                   /* set type            */
tcnt = tcnt + 1                                /* increment counter   */

return
/*----------------------- Unknown ASID -------------------------------*/
unknown_asid:
jname = red||'Unknown '                        /* set colour          */
type = 'UKN'                                   /* set type            */
ucnt = ucnt + 1                                /* increment counter   */

return
/*----------------------- sort the output lines ----------------------*/
quicksort: procedure expose line. sorder sfld slen
arg first,last                                 /* point to cvtgda     */
ptr1 = first                                   /* point to cvtgda     */
ptr2 = last                                    /* point to cvtgda     */
mid_point = (first + last) % 2                 /* point to cvtgda     */
keep = substr(line.mid_point,sfld,slen)        /* point to cvtgda     */

do until ptr1 > ptr2                           /* point to cvtgda     */
  if sorder = 'A' then                         /* ascending sort      */
    do
      do while substr(line.ptr1,sfld,slen) << keep /* less than ?     */
        ptr1 = ptr1 + 1                        /* increment counter   */
      end
      do while substr(line.ptr2,sfld,slen) >> keep /* more than ?     */
        ptr2 = ptr2 - 1                        /* decrement counter   */
      end
    end
  else                                         /* decending sort      */
    do
      do while substr(line.ptr1,sfld,slen) >> keep /* more than ?     */
        ptr1 = ptr1 + 1                        /* increment counter   */
      end
      do while substr(line.ptr2,sfld,slen) << keep /* less than ?     */
        ptr2 = ptr2 - 1                        /* decrement counter   */
      end
    end
      if ptr1 <= ptr2 then                     /* point to cvtgda     */
        do
          temp_var = line.ptr1                 /* swap the two fields */
          line.ptr1 = line.ptr2                /* using the temporary */
          line.ptr2 = temp_var                 /* field               */
          ptr1 = ptr1 + 1                      /* increment counter   */
          ptr2 = ptr2 - 1                      /* decrement counter   */
        end
    end

if first < ptr2 then call quicksort first,ptr2 /* move down top       */
if ptr1 < last then call quicksort ptr1,last   /* move up bottom      */

return
/**********************************************************************/
/********************** common sub-routines ***************************/
/**********************************************************************/
/*---------------- default values ------------------------------------*/
set_default:
psas = 0                                       /* start of psa        */
psae = FFF                                     /* end of psa          */
psak = 4                                       /* size of psa         */
syss = 1000                                    /* start of system     */
syse = 4FFF                                    /* end of system       */
sysk = 16                                      /* size of system      */
privs = 5000                                   /* start of private    */
gblrs = 5000                                   /* start of real priv. */
nucoe = FFFFFF                                 /* end of R/O nuc.     */
enucos = 1000000                               /* start of ext. nuc.  */

return
/*---------------- get storage use details ---------------------------*/
get_storage_use:
megabyte = 1024*1000
cvtgda = c2d(storage(d2x(cvt+560),4))          /* point to cvtgda     */
csa   = c2d(storage(d2x(cvtgda+112),4))        /* csa region size     */
csaf  = format((csa/megabyte),,2)              /* convert to Megs.    */
ecsa  = c2d(storage(d2x(cvtgda+128),4))        /* ex. csa size        */
ecsaf = format((ecsa/megabyte),,2)             /* convert to Megs.    */
sqa   = c2d(storage(d2x(cvtgda+148),4))        /* sqa region size     */
sqaf  = format((sqa/megabyte),,2)              /* convert to Megs.    */
esqa  = c2d(storage(d2x(cvtgda+156),4))        /* ex. sqa size        */
esqaf = format((esqa/megabyte),,2)             /* convert to Megs.    */
priv  = c2d(storage(d2x(cvtgda+164),4))        /* private region size */
privf = format((priv/megabyte),,2)             /* convert to Megs.    */
eprv  = c2d(storage(d2x(cvtgda+172),4))        /* ex. private size    */
eprvf = format((eprv/megabyte),,2)             /* convert to Megs.    */
csau  = c2d(storage(d2x(cvtgda+432),4))        /* csa used            */
csauf = format((csau/csa*100),,1)'%'           /* convert to Percent  */
ecsau = c2d(storage(d2x(cvtgda+436),4))        /* ecsa used           */
ecsauf = format((ecsau/ecsa*100),,1)'%'        /* convert to Percent  */
sqau  = c2d(storage(d2x(cvtgda+440),4))        /* sqa used            */
sqauf = format((sqau/sqa*100),,1)'%'           /* convert to Percent  */
esqau = c2d(storage(d2x(cvtgda+444),4))        /* esqa used           */
esqauf = format((esqau/esqa*100),,1)'%'        /* convert to Percent  */
csao  = c2d(storage(d2x(cvtgda+448),4))        /* csa overflow        */
csaof = format((csao/megabyte),,2)             /* convert to Megs.    */
ecsao = c2d(storage(d2x(cvtgda+452),4))        /* ecsa overflow       */
ecsaof = format((ecsao/megabyte),,2)           /* convert to Megs.    */

return
/*--------------------- display list in pop-up window ----------------*/
display_list:
srchfor = ''                                   /* null string         */
dyndata = ''                                   /* initialize display  */

do inc = 1 to maxlines                         /* for each line       */
  dyndata = dyndata||line.inc                  /* build output line   */
end

dyndata = dyndata||blue||centre(white||'BOTTOM'||blue,scrn_wdth-1,'*')

address ispexec                                /* set mode            */
"vget zpf05 profile"                           /* get PF5 key         */
zpf05_old = zpf05                              /* save old key        */
zpf05 = 'AGAIN'                                /* set PF5 key         */
"vput zpf05 profile"                           /* store PF5 key       */
cursor = 'cursor()'                            /* set initial value   */
"addpop row(2) column("poppos")"               /* set window          */

do until disprc > 0
  display_again = 'N'
  dynarea = substr(dyndata,1+(cur_line-1)*scrn_wdth) /* set display   */
  "display panel("panel_name")" cursor         /* display result      */
  disprc = rc
  "vget (zverb,zscrolla,zscrolln)"             /* get ispf values     */
  select
    when zverb = 'UP' then
      do
        if zscrolla = 'MAX' then cur_line = 1  /* move to top         */
        else cur_line = max(1,cur_line-zscrolln) /* up x lines        */
      end
    when zverb = 'DOWN' then
      do
        if zscrolla = 'MAX' then cur_line = maxlines  /* move to bot. */
        else cur_line = min(maxlines,cur_line+zscrolln) /*down x lines*/
      end
    when zcmd = 'AGAIN' & srchfor <> '' then   /* PF5 pressed         */
      do
        from_here = start_pos                  /* get search string   */
        start_pos = pos(srchfor,dyndata,from_here+1) /* search again  */
        if start_pos <> 0 then call get_position /* if found, display */
        else call not_found                    /* reset cursor        */
      end
    when substr(zcmd,1,1) = 'F' then           /* find a string?      */
      do
        parse var zcmd . srchfor               /* get search string   */
        start_pos = pos(srchfor,dyndata)       /* search for string   */
        if start_pos <> 0 then call get_position /* if found, display */
        else call not_found                    /* reset cursor        */
      end
    when substr(zcmd,1,1) = 'L' & sort = 'Y' then
      do
        "addpop row(2) column(18)"             /* start window        */
        "display panel(checkact)"              /* display results     */
        "rempop"                               /* stop window         */
      end
    when substr(zcmd,1,1) = 'S' & sort = 'Y' then
      do
        "addpop column(10)"                    /* Set up sort window  */
        "display panel(checksrt)"              /* Display window      */
        "rempop"                               /* remove window       */
        display_again = 'Y'                    /* Display again       */
        cur_line = 1                           /* set to top          */
        leave                                  /* exit loop           */
      end
    when substr(zcmd,1,1) = 'V' & sort = 'Y' then
      do
        "addpop column(10)"                    /* Set up sort window  */
        "display panel(checkvie)"              /* Display window      */
        "rempop"                               /* remove window       */
        display_again = 'Y'                    /* display again       */
        cur_line = 1                           /* set to top          */
        leave                                  /* exit loop           */
      end
    when disprc = 0 & sort = 'Y' then          /* enter pressed       */
      do
        display_again = 'Y'                    /* display again       */
        leave                                  /* exit loop           */
      end
    otherwise
  end
end

"rempop"                                       /* close window        */
zpf05 = zpf05_old                              /* reset pf key        */
"vput zpf05 profile"                           /* store PF5 key       */
address tso                                    /* set mode            */

return
/*------------------ calculate line position in dynamic area ---------*/
get_position:
cur_line = start_pos%scrn_wdth+1               /* get row position    */
csrpos = start_pos//scrn_wdth                  /* get column position */
cursor = 'cursor(dynarea)'                     /* set cursor field    */

return
/*------------------ calculate line position in dynamic area ---------*/
not_found:
cur_line = 1                                   /* set row position    */
csrpos  = 1                                    /* set column position */
cursor = 'cursor()'                            /* set cursor field    */

return
