SYSINT   TITLE     'SYSTEM INTERFACE ROUTINE'
SYSINT   CSECT     ,
*
R0       EQU       0
R1       EQU       1
R2       EQU       2
R3       EQU       3
R4       EQU       4
R5       EQU       5
R6       EQU       6
R7       EQU       7
R8       EQU       8
R9       EQU       9
R10      EQU       10
R11      EQU       11
R12      EQU       12
R13      EQU       13
R14      EQU       14
R15      EQU       15
*
*        SYSTEM INTERFACE CONTROL AREA DESCRIPTION
*
SICA     DSECT     ,                   SYSTEM INTERFACE CONTROL AREA
SICAID   DS        1F                  SICA ID FIELD
BKWDPTR  DS        1F                  POINTER TO PREVIOUS SAVEAREA
FWRDPTR  DS        1F                  POINTER TO NEXT SAVE AREA
SAVEAREA DS        15F                 REMAINDER OF OS SAVEAREA
USERQORG DS        1F                  ORIGIN OF USER QUEUE
SYSINTAD DS        1F                  ADDRESS OF SYSINT ROUTINE
IOCBQORG DS        1F                  POINTER TO START OF IOCB QUEUE
TRACEPTR DS        1F                  ADDRESS OF TRACE
TRSETA   DS        1F                  ADDRESS OF SETAREA ROUTINE
SYSCORE  DS        1F                  CORE TO BE LEFT FOR SYSTEM
SICACEND DS        0F                  END OF COMMON PART OF SICA
SICAPICA DS        2F                  SICA PICA FOR SPIE
IOCODE   EQU       SICAPICA+6          RETURN CODE
SPIEEXIT DS        4F                  SPACE FOR SPIE EXIT ROUTINE
SPIEROUT DS        1F                  ADDRESS OF USER'S SPIE ROUTINE
SPIER2   DS        1F                  SAVED VALUE OF USER'S R2
SICAPIE  DS        14F                 SPACE TO SAVE PIE AND OPEN REGS
TIMREXIT DS        3F                  SPACE FOR STIMER EXIT ROUTINE
TIMRROUT DS        1F                  SPACE FOR USER'S STIMER EXIT
STIMERR2 DS        1F                  SPACE FOR USER'S R2 VALUE
SICAPARM DS        4F                  WORK AREA
PICASAVE DS        1F                  VALUE OF PICA POINTER ON ENTRY
SICAEND  DS        0D                  END OF SICA
*
SICAPREF EQU       72                  LENGTH OF SICA PREFIX SECTION
*
*        IO CONTROL BLOCK DESCRIPTION
*
IOCB     DSECT     ,                   IO CONTROL BLOCK
USERAREA DS        256D                SPACE FOR USER-DEFINED PREFIX
IODEF    DS        0F                  IO DEFINITION SECTION
FILETYPE DS        1C                  FILE TYPE(ONE OF FOLLOWING)
F$QSAM   EQU       1                   QSAM WITH NO ERROR RETURN CODES
F$BSAM   EQU       2                   BSAM WITH NO ERROR RETURN CODES
F$BPAM   EQU       3                   BPAM WITH NO ERROR RETURN CODES
F$QSAMR  EQU       4                   QSAM WITH ERROR RETURN CODES
F$BSAMR  EQU       5                   BSAM LOAD MODE(RELATIVE RECORD)
F$BSAMK  EQU       6                   BSAM LOAD MODE(KEYED RECORD)
F$BDAMR  EQU       7                   BDAM RELATIVE RECORD
F$BDAMK  EQU       8                   BDAM KEYED RECORD
USERLNTH DS        1C                  LENGTH OF USER AREA IN DBLWORDS
OPTIONS  DS        2C                  OPTIONS USED
DDNAME   DS        2F                  FILE NAME
RECFM    DS        1C                  RECFM
RECMERGE DS        1C                  MASK TO MERGE RECFM BITS
KEYLEN   DS        1C                  KEY LENGTH
BUFNO    DS        1C                  NUMBER OF BUFFERS
LRECL    DS        1H                  LRECL OR DEFAULT LRECL
MAXLRECL DS        1H                  MAXIMUM LRECL
BLKSI    DS        1H                  BLKSI(>0) OR DEFAULT BLKSI(<0)
RKP      DS        1H                  OFFSET OF KEY IN RECORD
TRACKLIM EQU       RKP                 NUMBER OF TRACKS
         DS        1F                  RESERVED FOR FUTURE USE
IODEFEND DS        0F                  END OF IODEF
MAXRECNO DS        1F                  MAXIMUM RECORD NUMBER FOR BDAM
IOCBLINK DS        1F                  LINK TO NEXT IOCB(AFTER OPEN)
IOCBUSER DS        1F                  USER FIELD(NOT USED BY SYSINT)
IOCBSYS  DS        1F                  POINTER TO SYSTEM DEPENDENT DATA
IOCBCEND DS        0F                  END OF COMMON PART OF IOCB
         DS        2F                  RESERVED
IOCBDCB  DS        26F                 FILE DCB
DCBBFTEK EQU       IOCBDCB+32
DCBBLKSI EQU       IOCBDCB+62
DCBBUFCB EQU       IOCBDCB+20
DCBBUFNO EQU       IOCBDCB+20
DCBCIND  EQU       IOCBDCB+60
DCBDEBAD EQU       IOCBDCB+44
DCBDEVT  EQU       IOCBDCB+17
DCBDSORG EQU       IOCBDCB+26
DCBDVTBL EQU       IOCBDCB+12
DCBEODAD EQU       IOCBDCB+32
DCBFDAD  EQU       IOCBDCB+05
DCBIOBA  EQU       IOCBDCB+68
DCBKEYLE EQU       IOCBDCB+16
DCBLRECL EQU       IOCBDCB+82
DCBMACR  EQU       IOCBDCB+50
DCBNOTE  EQU       IOCBDCB+84
DCBOFLGS EQU       IOCBDCB+48
DCBOPTCD EQU       IOCBDCB+52
DCBRECFM EQU       IOCBDCB+36
DCBREL   EQU       IOCBDCB+17          NUMBER OF TRACKS OR BLOCKS(BDAM)
DCBRELAD EQU       IOCBDCB+00
DCBROUT  EQU       IOCBDCB+48          ADDR OF GET,PUT,READ,WRITE
IOCBDECB DS        0F                  DECB
DECBECB  DS        1F
DECBTYPE DS        1H
DECBLNTH DS        1H
DECBDCBA DS        1F                  POINTER TO DCB
DECBAREA DS        1F                  POINTER TO RECORD
DECBIOBA DS        1F                  POINTER TO IOB
DECKYADR DS        1F                  POINTER TO KEY
DECRECPT DS        1F                  POINTER TO BLOCK REFERENCE
DECNXADR DS        1F
IOCBSICA DS        1F                  POINTER TO SICA
CHECKSAV DS        1F
VLIND    DS        1H                  4 FOR RECFM=V, 0 OTHERWISE
OPENCODE DS        1C                  OPEN CODE
FLAGS    DS        1C                  INTERNAL FLAGS
REREADSW EQU       X'80'               UNLIKE CONCATENATION REREAD FLAG
UNITFULL EQU       X'40'               VOLUME FULL FLAG
SECALLOC EQU       X'20'               SECONDARY ALLOCATION FLAG
IOCBEND  DS        0D
*
FILECHAR DSECT     ,
FIMACRF  DS        1H                  FILE MACRF
FIDSORG  DS        1C                  FILE DSORG
FIFLAGS  DS        1C                  FILE FLAGS
*
*        FOLLOWING IS A LIST OF SYMBOLIC EQUATES FOR FIELDS IN
*        VARIOUS OPERATING SYSTEM CONTROL BLOCKS
*
CVTPTR   EQU       16                  POINTER TO OS'S COMMUNICATION
*                                      VECTOR TABLE(CVT)
CVTTCBP  EQU       0                   PTR IN CVT TO TASK SWITCH CELL
CVTCMS   EQU       7                   BYTE IN CVT WHICH IS 255 FOR CMS
CVTDCB   EQU       116                 BYTE IN CVT FOR SYSTEM TYPE
TCBPTR   EQU       4                   PTR IN TSC TO CURRENT TCB
TCBTIOT  EQU       12                  PTR IN TCB TO TASK I/O TABLE
*
*        CONTROL BLOCK VALUES FROM CMS
*
FCBFIRST EQU       X'5C0'              PTR IN NUCON TO FIRST FCB
FCBLINK  EQU       0                   PTR IN FCB TO NEXT FCB
FCBDDNAM EQU       8                   DDNAME IN FCB
*
SYSINT   CSECT
         USING     SICA,R13
         USING     SYSINT,R15
SYSINT$  B         SYSMAIN             000 - RESERVED
         B         SYSINIT             004 - SYSINT INITIALIZATION
         B         SYSTERM             008 - SYSINT TERMINATION
         B         SYSGMAIN            012 - GETMAIN
         B         SYSFMAIN            016 - FREEMAIN
         B         SYSRMAIN            020 - CORE CLEANUP
         B         SYSTEST             024 - LOOKUP DDNAME
         B         SYSMOVE             028 - MOVE BLOCK OF MEMORY
         B         SYSOPEN             032 - OPEN FILE
         B         SYSCLOSE            036 - CLOSE FILE
         B         SYSREAD             040 - READ FILE
         B         SYSWRITE            044 - WRITE FILE
         B         SYSGET              048 - GET FILE
         B         SYSPUT              052 - PUT FILE
         B         SYSNOTE             056 - NOTE FILE
         B         SYSPOINT            060 - POINT FILE
         B         SYSFIND             064 - FIND FILE
         B         SYSSTOW             068 - STOW FILE
         B         SYSSPIE             072 - SET PROGRAM INTERRUPT EXIT
         B         SYSTIME             076 - GET TIME AND DATE
         B         SYSSTIME            080 - SET TIMER INTERVAL
         B         SYSTTIME            084 - TEST TIMER INTERVAL
         B         SYSLOAD             088 - LOAD A LOAD MODULE
         B         SYSDELT             092 - DELETE A LOAD MODULE
         B         SYSWTO              096 - WRITE MESSAGE TO OPERATOR
         B         SYSWTOR             100 - WRITE OPERATOR WITH REPLY
         B         SYSABEND            104 - ABEND PROGRAM
         B         SYSWTP              108 - WRITE TO PROGRAM LOG
         B         GMENTRY             112 - INTERNAL ENTRY FOR SYSINT$
*
         ENTRY     SYSINT$
         ENTRY     SYSINIT
         ENTRY     SYSTERM
         ENTRY     SYSGMAIN
         ENTRY     SYSFMAIN
         ENTRY     SYSRMAIN
         ENTRY     SYSTEST
         ENTRY     SYSMOVE
         ENTRY     SYSOPEN
         ENTRY     SYSCLOSE
         ENTRY     SYSREAD
         ENTRY     SYSWRITE
         ENTRY     SYSGET
         ENTRY     SYSPUT
         ENTRY     SYSNOTE
         ENTRY     SYSPOINT
         ENTRY     SYSFIND
         ENTRY     SYSSTOW
         ENTRY     SYSSPIE
         ENTRY     SYSTIME
         ENTRY     SYSSTIME
         ENTRY     SYSTTIME
         ENTRY     SYSLOAD
         ENTRY     SYSDELT
         ENTRY     SYSWTO
         ENTRY     SYSWTOR
         ENTRY     SYSABEND
         ENTRY     SYSWTP
         DROP      R15
*
SYSMAIN  B         0(,R14)
*
*        SYSTEM INTERFACE INITIALIZATION ROUTINE
*        THIS ROUTINE WILL CREATE A SYSTEM INTERFACE CONTROL AREA AND
*        CHAIN IT ONTO THE SAVEAREA QUEUE SO THAT THE BACKWARD POINTER
*        OF THE SICA POINTS TO THE SAVEAREA THAT WAS IN R13 WHEN THE
*        ROUTINE WAS ENTERED. IF A SICA IS ALREADY ON THE BACKWARD
*        SAVEAREA CHAIN QUEUE THEN IT'S ADDRESS IS RETURNED IN R1.
*
         USING     SYSINT,R15
SYSINIT  LR        R1,R13              SAVE USER'S SAVEAREA POINTER
         L         R2,SYSIDENT-SYSINT(,R15)  GET SICA ID
INGSICA  C         R2,SICAID-SICA(,R1)  IS THIS THE SICA
         BNE       INITNEXT            IF NOT THEN CONTINUE UP QUEUE
         LA        R1,SICAPREF(,R1)    ADD ON PREFIX LENGTH
         BR        R14                 AND RETURN TO CALLER
INITNEXT L         R1,BKWDPTR-SICA(,R1)  OTHERWISE CONTINUE UP QUEUE
         LTR       R1,R1               IS THIS THE END OF THE QUEUE
         BNZ       INGSICA             IF NOT THEN CONTINUE
         LA        R0,SICAEND-SICA+SICAPREF GET LENGTH OF SICA & PREFIX
         LNR       R1,R0               SET R1 NEGATIVE FOR GETMAIN
         SVC       10                  ISSUE GETMAIN SVC
         BALR      R15,0               RESET BASE REGISTER
         USING     *,R15               AND RESET USING
         XC        0(256,R1),0(R1)     CLEAR FIRST 256 BYTES OF SICA
         XC        256(SICAEND-SICA+SICAPREF-256,R1),256(R1) CLEAR REST
         ST        R13,BKWDPTR-SICA(,R1) SET USER'S SAVEAREA AS BKWDPTR
         ST        R1,FWRDPTR-SICA(,R13) SET USER'S FWRDPTR AS SICA
         ST        R2,SICAID-SICA(,R1)  FOR FUTURE IDENTIFICATION
         LR        R2,R13              SAVE OLD SAVEAREA ADDRESS
         LR        R13,R1              SICA PREFIX BECOMES NEW SAVEAREA
         MVC       SAVEAREA-SICA(60,R13),SAVEAREA-SICA(R2) MOVE SAVEAR
         LA        R0,TERMROUT         GET ADDRESS OF TERMINATE ROUTINE
         ST        R0,SAVEAREA-SICA(,R13)  SAVE IN SAVEAREA R14 SLOT
         ST        R13,BKWDPTR+SICAPREF  SICA BKWDPTR=A(SICA PREFIX)
         L         R0,ASYSINT          GET SYSINT ADDRESS
         ST        R0,SYSINTAD+SICAPREF  SAVE IN SICA
         MVI       SYSCORE+2+SICAPREF,X'10'  SET SYSTEM CORE TO 4K
         L         R1,CVTPTR(,R0)      GET CVT POINTER
         TM        CVTDCB(R1),X'02'    IS THIS A VS SYSTEM
         BZ        *+8                 IF NOT THEN GO AROUND
         MVI       SYSCORE+2+SICAPREF,X'30'  SET SYSTEM CORE TO 12K
         MVC       SPIEEXIT+SICAPREF(SPIECOD1-SPIECODE),SPIECODE
         LA        R0,SPIEEXIT+SICAPREF  LOAD ADDRESS OF SPIE ROUTINE
         ST        R0,SICAPICA+SICAPREF STORE EXIT ROUTINE ADDR IN PICA
         LA        R1,SICAPICA+SICAPREF  LOAD PARM REG FOR SPIE SVC
         SVC       14                  ISSUE SPIE SVC
         BALR      R15,0               RESET BASE REGISTER
         USING     *,R15               AND RESET USING
         ST        R1,PICASAVE+SICAPREF  SAVE CALLER'S PICA POINTER
         SPM       R13                 SET PROGRAM MASK OFF
         LA        R0,INITBR14         GET ADDRESS OF BR R14 INST
         LR        R1,R0               GET ANOTHER ADDRESS OF BR R14
         STM       R0,R1,TRACEPTR+SICAPREF  SAVE IN TRACE ADDRESSES
         L         R1,0(,R2)           GET FIRST WORD OF CALLER'S SAVE
         SR        R2,R1               CALCULATE DIFFERENCE
         CL        R2,=F'64'           IS DIFFERENCE >=0 & <64
         BNL       INITRET             IF NOT THEN RETURN
         CLC       0(8,R1),=CL8'SUPRTRAC'  IS CALLER SUPRTRAC
         BNE       INITRET             IF NOT THEN RETURN
         MVC       TRACEPTR+SICAPREF(8),8(R1) MOVE OVER TRACE ADDRESSES
INITRET  LA        R1,SICAPREF(,R13)   SET SICA PROPER FOR PROGRAM
INITBR14 BR        R14                 AND RETURN TO CALLER
SPIECODE L         R2,SPIER2-SPIEEXIT(,R15)  GET R2 SAVED VALUE
         MVC       SICAPIE-SPIEEXIT(32,R15),0(R1)  SAVE PIE VALUE
         L         R15,SPIEROUT-SPIEEXIT(,R15)  GET ADDR OF SPIE ROUT
         BR        R15                 AND GO TO IT
SPIECOD1 DC        0H'0'
ASYSINT  DC        A(SYSINT)
         DROP      R15
*
TERMROUT L         R14,BKWDPTR-SICA(,R13)  GET PTR TO PREVIOUS SAVEAREA
         STM       R0,R2,SAVEAREA+8-SICA(R14)  SAVE R0-R2
         LR        R2,R15              SAVE R15 IN R2
         L         R1,PICASAVE+SICAPREF  GET SAVED PICA POINTER
         SVC       14                  ISSUE SPIE SVC TO RESTORE PICA
         LR        R1,R13              MOVE SICA PREFIX POINTER TO R1
         LA        R0,SICAEND-SICA+SICAPREF GET LENGTH OF SICA & PREFIX
         LR        R13,R14             RESTORE PREVIOUS SAVEAREA PTR
         SVC       10                  ISSUE FREEMAIN SVC
         LR        R15,R2              RESTORE R15
         LM        R0,R2,SAVEAREA+8-SICA(R13)  RESTORE R0-R2
         L         R14,SAVEAREA-SICA(,R13)  GET CALLER'S R14
         BR        R14                 AND RETURN TO CALLER
*
*        SYSTEM INTERFACE TERMINATION ROUTINE
*        IF R13 CONTAINS THE ADDRESS OF THE SICA, THEN IT IS FREED
*        AND R13 IS REPLACED BY THE SICA BKWDPTR FIELD.
*
SYSTERM  CLC       SICAID-SICA(4,R13),SYSIDENT-SYSINT(R15) SICA ?
         BCR       7,R14               IF NOT THEN RETURN
         L         R1,PICASAVE+SICAPREF  GET SAVED PICA POINTER
         SVC       14                  ISSUE SPIE SVC TO RESTORE PICA
         LR        R1,R13              MOVE SICA PREFIX ADDRESS INTO R1
         L         R13,BKWDPTR-SICA(,R13)  GET PREVIOUS SAVEAREA PTR
         LA        R0,SICAEND-SICA+SICAPREF GET LENGTH OF SICA & PREFIX
         SVC       10                  ISSUE FREEMAIN SVC
         BR        R14                 AND RETURN TO CALLER
*
*        GETMAIN ROUTINE
*        INPUT  R0=MIN,R1=MAX
*        OUTPUT R0=LENGTH,R1=ADDRESS
*        REQUEST IS CONDITIONAL IF NEXT INST IS CONDITIONAL BRANCH
*        CC=0 FOR SUCCESSFULL, CC=1 FOR NOT SUCCESSFULL
*
GMPARM   EQU       SAVEAREA+4
GMMINMAX EQU       GMPARM+12           (MIN CORE,MAX CORE)
GMRESULT EQU       GMMINMAX+8          (ADDR OF CORE,LNTH OF CORE)
GMSAVR13 EQU       GMRESULT+8          SAVEAREA FOR SAVEAREA POINTER
         USING     SYSINT,R15
GETMAIN  LR        R0,R1               COPY R1 INTO R0
         LR        R15,R11             FOR INTERNAL CALLERS
SYSGMAIN SLL       R1,8                LEAVE BOTTOM BYTE 0
         SLDL      R0,8                LEAVE BOTTOM 2 BYTES 0
         LA        R14,0(,R14)         CLEAR UPPER BYTE OF R14
         SLL       R15,8               MOVE R15 OVER 1 BYTE
         SRDL      R14,8               MOVE R14 & R15 RIGHT 1 BYTE
         OR        R1,R14              SAVE LOW 2 BYTES OF R14 IN R1
         LR        R14,R13             SAVE CURRENT SAVEAREA POINTER
         B         GMGSICA1
GMGSICA  L         R13,BKWDPTR         GO BACK UP THE SAVEAREA QUEUE
GMGSICA1 CLC       SICAID(4),SYSIDENT  IS THIS THE SICA PREFIX
         BNE       GMGSICA             IF NOT THEN CONTINUE UP QUEUE
GMENTRY  LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER
         ST        R14,GMSAVR13        SAVE PREVIOUS SAVEAREA PTR
         LR        R14,R1              RESTORE R14
         SLDL      R14,8               RECOVER LOW BYTE OF R14
         SRL       R15,8               RECOVER R15
         SRDL      R0,8                SHIFT R0 & R1 RIGHT BY 1 BYTE
         SRL       R1,8                RECOVER R1 VALUE
         STM       R0,R1,GMMINMAX      SET UP MIN-MAX VALUES
         LA        R0,GMMINMAX         SET UP ADDRESS OF MIN-MAX CELL
         LA        R1,GMRESULT         SET UP ADDRESS OF RESULT CELL
         STM       R0,R1,GMPARM        SET UP PARMATER LIST FOR GETMAIN
         MVI       GMPARM+9,0          SET UP SUBPOOL ID
         MVI       GMPARM+8,X'C0'      SET UP FLAGS FOR UNCONDITIONAL
         CLI       0(R14),X'47'        IS THE NEXT INSTRUCTION A BRANCH
         BNE       GMUNCON             IF NOT THEN LEAVE AS UNCON
         TM        1(R14),X'F0'        IS IT A CONDITIONAL BRANCH
         BNM       GMUNCON             IF NOT THEN LEAVE AS UNCON
         MVI       GMPARM+8,X'E0'      SET UP FLAGS FOR CONDITIONAL
GMUNCON  LA        R1,GMPARM           SET UP R1 FOR GETMAIN
         SVC       4                   ISSUE GETMAIN SVC
         OR        R15,R15             SET CC=0 FOR OK - CC=1 FOR NOT
         L         R1,GMRESULT         GET ADDRESS OF CORE
         L         R0,GMRESULT+4       GET LENGTH OF CORE
         L         R13,GMSAVR13        RESTORE SAVEAREA POINTER
         BR        R14                 RETURN TO CALLER
         DROP      R15
*
*        FREEMAIN ONE CONTIGUOUS AREA
*        INPUT R1=ADDRESS OF AREA TO FREEMAIN
*              R0=LENGTH OF AREA
*
         USING     SYSINT,R15
FREEMAIN LR        R15,R11             FOR INTERNAL CALLERS
SYSFMAIN AH        R0,=H'7'            ROUND LENGTH TO DOUBLE WORD
         N         R0,=F'-8'
         SVC       10                  ISSUE FREEMAIN SVC
         BR        R14                 AND RETURN TO CALLER
         DROP      R15
*
*        RELEASE/CLEANUP
*        INPUT R1=ADDRESS OF AREA TO FREEMAIN/CLEANUP
*              R0=LENGTH OF AREA
*        ROUTINE MUST FREEMAIN ALL ALLOCATED CORE AREAS WITHIN THE
*        AREA BETWEEN R1 AND R1+R0
*        REGISTER USAGE
*        R2=START OF AREA TO FREE
*        R3=END OF AREA TO FREE+1
*        R4=CURRENT FQE POINTER
*        R5=CURRENT LOW-BOUND OF AREA(DQE) TO FREE
*        R6=CURRENT HIGH-BOUND OF AREA(DQE) TO FREE
*        R10=CURRENT DQE POINTER
*        R1=START OF CURRENT ALLOCATED AREA
*        R0=END OF CURRENT ALLOCATED AREA
*        METHOD IS TO SEARCH DOWN ALL FQE'S FOR THE REGION,FIND ALL
*        ALLOCATED AREAS, AND FREE ANY PART WHICH OVERLAPS AREA TO FREE
*
         USING     SYSINT,R11
RMSYSID  EQU       SAVEAREA+00
SYSRMAIN STM       R2,R14,SAVEAREA+4
         LR        R11,R15
         LR        R2,R1               GET START OF AREA ADDRESS
         LR        R3,R1               GET START OF AREA ADDRESS
         AR        R3,R0               CALCULATE END OF AREA ADDRESS
         L         R4,CVTPTR(,R0)      GET CVT POINTER
         CLI       CVTCMS(R4),255      IS THIS CMS
         BE        RMRETURN            IF SO THEN RETURN
         MVC       RMSYSID(1),CVTDCB(R4)  SAVE SYSTEM TYPE BYTE
         L         R4,CVTTCBP(,R4)     GET TASK SWITCH CELL POINTER
         L         R4,TCBPTR(,R4)      GET ADDRESS OF CURRENT TASK
         TM        RMSYSID,X'20'       IS THIS MFT
         BNO       RMNOJST             IF NOT THEN USE CURRENT TASK
         L         R1,44(,R4)          GET POINTER TO JOB STEP TASK
         LTR       R1,R1               IF THERE ONE
         BZ        RMNOJST             IF NOT THEN USE CURRENT
         LR        R4,R1               USE JOB STEP TASK
RMNOJST  L         R10,24(,R4)         GET POINTER TO MSS CELL
         TM        RMSYSID,X'10'       IS THIS MVT
         BO        RMSPQSYS            IF SO THEN GO FIND SPQE
         L         R1,4(,R10)          GET START OF REGION ADDRESS
         LTR       R1,R1               IS IT ALLOCATED ?
         BNZ       *+8                 IF SO THEN SKIP NEXT
         LA        R10,12(,R10)        MUST BE MFT WITH REGION IN LCS
         L         R5,4(,R10)          LOW-BOUND=START OF REGION ADDR
         L         R6,8(,R10)          HIGH-BOUND=END OF REGION ADDR
         L         R4,0(,R10)          GET ADDRESS OF FIRST FQE
         SR        R10,R10             INDICATE LAST DQE
         B         RMSTART             PROCEED DOWN FQE CHAIN
RMSPQELP L         R10,0(,R10)         ADVANCE TO NEXT SPQE
RMSPQSYS TM        RMSYSID,X'13'       IS THIS VS2.2 ?
         BNO       RMSPQE1
         CLI       10(R10),0           IS THIS SUBPOOL ZERO
         BNE       RMSPQELP            IF NOT THEN CONTINUE
         TM        8(R10),X'80'        IS SUBPOOL SHARED
         B         RMSPQTST            GO TO COMMON TEST
RMSPQE1  CLI       4(R10),0            IS THIS SUBPOOL ZERO
         BNE       RMSPQELP            IF NOT THEN CONTINUE SEARCH
         TM        0(R10),X'80'        IS SUBPOOL SHARED
RMSPQTST BNO       *+8                 IF NOT THEN HAVE SPQE
         L         R10,4(,R10)         OTHERWISE GET PRIMARY SPQE
         L         R10,4(,R10)         GET POINTER TO FIRST DQE
RMDQELP  L         R6,8(,R10)          GET START OF DQE'S AREA
         LA        R5,0(,R6)           LOW-BOUND=START OF DQE'S AREA
         A         R6,12(,R10)         HIGH-BOUND=END OF DQE'S AREA
         L         R4,0(,R10)          GET POINTER TO FIRST FQE
         L         R10,4(,R10)         ADVANCE TO NEXT DQE
         CR        R5,R3               IF LOW-BOUND<END OF AREA TO FREE
         BL        RMSTART               THEN START DOWN FQE CHAIN
         B         RMNXTDQE            OTHERWISE SKIP TO NEXT DQE
RMFQELP  LR        R1,R5               ALLOC-AREA-START=LOW-BOUND
         SR        R6,R6               ZERO CURRENT HIGH-BOUND
         N         R4,=X'00FFFFFF'     IF THIS THE END OF THE FQE CHAIN
         BZ        RMFQEEND            IS SO THEN SKIP NEXT
         TM        RMSYSID,X'02'       IS THIS A VS SYSTEM
         BZ        RMFQEOS             IF NOT USE ROUT FOR OS
         TM        RMSYSID,X'10'       IS THIS VS2
         BO        RMFQEVS2            IF SO THEN GO PROCESS
RMFQEVS1 L         R6,4(,R4)           HIGH-BOUND=START OF FQE AREA
         LR        R1,R6               COPY START OF FQE AREA
         A         R1,8(,R4)           ALLOC-AREA-START=END OF FQE AREA
         B         RMFQECOM            GO TO COMMON ROUTINE
RMFQEVS2 L         R1,8(,R4)           ALLOC-AREA-START=END OF FQE AREA
         LR        R6,R1               COPY END OF FQE AREA
         S         R6,4(,R4)           HIGH BOUND=START OF FQE AREA
         B         RMFQECOM            GO TO COMMON ROUTINE
RMFQEOS  LR        R6,R4               HIGH BOUND=START OF FQE AREA
         LR        R1,R6               COPY START OF FQE AREA
         A         R1,4(,R4)           ALLOC-AREA-START=END OF FQE AREA
RMFQECOM L         R4,0(,R4)           ADVANCE TO NEXT FQE
RMFQEEND LA        R1,0(,R1)           CLEAR ANY FLAGS
         CR        R1,R2               R1=MAXIMUM OF ALLOC-AREA-START
         BNL       *+6                 AND
         LR        R1,R2               START OF AREA TO FREE
         CR        R0,R3               R0=MINIMUM OF ALLOC-AREA-END
         BNH       *+6                 AND
         LR        R0,R3               END OF AREA TO FREE
         SR        R0,R1               CALCULATE LENGTH OF AREA TO FREE
         BNP       *+6                 IF NOT POSITIVE SKIP THE SVC
         SVC       10                  OTHERWISE ISSUE THE FREEMAIN SVC
RMSTART  LA        R0,0(,R6)           ALLOC-AREA-END=HIGH-BOUND
         CR        R0,R2               IF ALLOC-AREA-END > START OF
         BH        RMFQELP               AREA TO FREE THEN LOOP
RMNXTDQE N         R10,=X'00FFFFFF'    ARE THERE ANY MORE DQE'S
         BNZ       RMDQELP             IF SO THEN CONTINUE
RMRETURN LM        R2,R14,SAVEAREA+4   RESTORE CALLER'S REGISTERS
         BR        R14                 AND RETURN
         DROP      R11
*
*        TEST ROUTINE
*        INPUT  R1=ADDR(DDNAME)
*        OUTPUT R1=FILE POSITION INDICATOR
*        CC=0 IF FILE EXISTS, CC=1 IF FILE DOES NOT EXIST
*
         USING     SYSINT,R15
SYSTEST  STM       R2,R4,SAVEAREA      SAVE REGISTERS
         L         R2,CVTPTR(,R0)      GET CVT POINTER
         CLI       CVTCMS(R2),255      IS THIS CMS
         BE        TESTCMS             IF SO THEN GO PROCESS
         L         R2,CVTTCBP(,R2)     GET TASK SWITCH CELL POINTER
         L         R2,TCBPTR(,R2)      GET ADDRESS OF CURRENT TASK
         L         R2,TCBTIOT(,R2)     GET ADDRESS OF TIOT
         LCR       R4,R2               SAVE COMPLEMENT FOR LATER
         SR        R3,R3               CLEAR WORK REGISTER
TESTLOOP AR        R2,R3               ADVANCE TO NEXT ENTRY
         CLC       28(8,R2),0(R1)      COMPARE FOR FILE
         BE        TESTRET             IF FOUND THEN STOP AND RETURN
         IC        R3,24(,R2)          GET LENGTH OF CURRENT ENTRY
         LTR       R3,R3               ARE WE AT END
         BNZ       TESTLOOP            IF NOT THEN CONTINUE
TESTRET1 OR        R13,R13             SET CC=1 FOR NOT FOUND
TESTRET  LA        R1,4(R2,R4)         SET FILE POSITION INDICATOR
         LM        R2,R4,SAVEAREA      RESTORE REGISTERS
         BR        R14                 AND RETURN
TESTCMS  L         R3,FCBFIRST(,R0)    GET START OF FILEDEF QUEUE
         LCR       R4,R2               SAVE FOR LATER
TESTCMS1 LA        R2,4(,R2)           BUMP RELATIVE POSITION POINTER
         N         R3,=X'00FFFFFF'     IS THIS THE END OF THE QUEUE
         BZ        TESTRET1            IF SO THEN RETURN 1 FOR NOT FND
         CLC       FCBDDNAM(8,R3),0(R1)  COMPARE FOR DDNAME
         BE        TESTRET             IF FOUND THEN STOP AND RETURN 0
         L         R3,FCBLINK(,R3)     ADVANCE TO NEXT ENTRY
         B         TESTCMS1            AND CONTINUE LOOP
         DROP      R15
*
*        OPEN ROUTINE
*        INPUT  R2=ADDR(IODEF SECTION OF IOCB)
*               R1=OPEN CODE
*        OUTPUT R2=ADDR(SYSTEM IOCB)
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSOPEN  LA        R2,0(,R2)           CLEAR UPPER BYTE OF R2
         SLL       R1,24               GET OPEN CODE
         OR        R2,R1               SAVE OPEN CODE
         LR        R1,R13
         L         R0,SYSIDENT-SYSINT(,R15)  GET SICA ID
OPGSICA  L         R13,BKWDPTR         GO BACK UP SAVEAREA QUEUE
         C         R0,SICAID           IS THIS THE SICA
         BNE       OPGSICA-SYSINT(,R15) IF NOT THEN CONTINUE UP QUEUE
         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER
         STM       R2,R15,SICAPIE      SAVE REGISTERS IN PIE
         ST        R1,SICAPIE+(R13-R2)*4  SAVE R13
         LR        R11,R15             LOAD BASE REGISTER
         MVI       IOCODE+1,0
         SR        R10,R10             CLEAR R10 FOR LENGTH
         IC        R10,USERLNTH-IODEF(,R2)  GET LENGTH OF USER AREA
         SLA       R10,3               CONVERT TO BYTES FROM DWORDS
         LA        R0,IOCBEND-IODEF(,R10)   GET LENGTH OF IOCB
         LCR       R1,R0               SET R1 NEGATIVE FOR GETMAIN
         SVC       10                  GETMAIN SPACE FOR IOCB
         AR        R10,R1              SET IOCB POINTER TO ADDR(IODEF)
         SH        R10,=AL2(IODEF-IOCB)  REMOVE LENGTH OF PREFIX
         XC        0(IOCBEND-IODEF,R1),0(R1)  ZERO USER'S AREA
         XC        IODEF(IOCBEND-IODEF),IODEF  CLEAR IOCB
         MVC       IODEF(IODEFEND-IODEF),0(R2)  MOVE IN INITIAL INFO
         SR        R9,R9               CLEAR R9
         IC        R9,FILETYPE         GET FILETYPE
         SLL       R9,2                GET INDEX INTO FILECHAR TABLE
         LA        R9,OPFILDEF(R9)     GET FILECHAR ENTRY
         USING     FILECHAR,R9         SET UP USING FOR DSECT
         MVC       OPENCODE(1),SICAPIE  GET OPEN CODE FROM TOP OF R2
         MVC       DCBDSORG(1),FIDSORG  SET FILE DSORG
         LA        R0,READEOF          SET EODAD FIELD
         LA        R1,OPEXLST          SET ADDRESS OF EXLST
         LM        R2,R3,DDNAME        SET DDNAME
         LH        R4,FIMACRF          INSERT MACRF
         SR        R5,R5               CHECK ROUTINE
         LA        R6,IOERROR          SYNAD
         CLI       FIDSORG,X'20'       IS THIS A BDAM FILE
         BNE       *+8                 IF NOT THEN GO AROUND
         LA        R6,OPBR14           OTHERWISE SET SYNAD TO BR R14
         STM       R0,R6,DCBEODAD      STORE IN DCB
         MVI       DCBOFLGS,X'0A'      SET DCBOFLGS
         TM        DCBMACR,X'40'       IS THIS QSAM
         BZ        *+8                 IF NOT THEN SKIP NEXT INST
         MVI       DCBBUFCB+3,1        INDICATE OPEN TO GET BUFFERS
         TM        OPENCODE,X'0F'      TEST OPEN CODE
         BNZ       *+8                 IS IT OPEN FOR INPUT
         MVI       DCBMACR+1,0         CLEAR OUTPUT FLAGS IF SO
         BNO       *+8                 IS IT OPEN FOR OUTPUT
         NI        DCBMACR,1           CLEAR INPUT FLAGS IF SO
         CLI       BUFNO,128           IS THE BUFNO SPECIFIED
         BNL       *+10                IF NOT THEN GO AROUND
         MVC       DCBBUFNO(1),BUFNO   MOVE NUMBER OF BUFFERS TO DCB
         MVC       IOCBLINK(4),IOCBQORG  ADD IOCB TO QUEUE
         ST        R10,IOCBQORG
         ST        R13,IOCBSICA        STORE SICA ADDRESS IN IOCB
         OI        FLAGS,REREADSW      INDICATE OPEN EXIT TO EXLST RTN
         LA        R0,IOCBDCB          GET ADDRESS OF DCB
         ST        R0,DECBDCBA         AND STORE IT IN DECB
         ST        R0,SICAPARM         AND IN PARM LIST FOR OPEN
         ST        R0,IOCBSYS          STORE SYSTEM DEPENDENT POINTER
         MVI       DECBTYPE,X'80'      INDICATE LENGTH TO COME FROM DCB
         MVI       DCBBFTEK,X'42'      SET BFTEK
OPENSVC  MVC       SICAPARM(1),OPENCODE  MOVE IN OPEN CODE
         OI        SICAPARM,X'80'      INDICATE END OF OPEN PARM LIST
         LA        R1,SICAPARM         SET PARM REG FOR OPEN
         SVC       19                  ISSUE OPEN SVC
         TM        DCBOFLGS,X'10'      DID DCB OPEN
         BZ        OPENERR6            IF NOT THEN GIVE RETURN CODE 6
*        CLI       DCBDSORG,X'20'      IS THIS A BDAM FILE
*        BE        *+8                 IF SO THEN SKIP NEXT
         NI        DCBCIND+1,255-X'08' STOP EOV FROM FREEING BUFFERS
         CLI       FILETYPE,F$BDAMR    IS IT BDAM RELATIVE RECORD
         BNE       *+10                IF NOT THEN SKIP NEXT
         MVC       MAXRECNO+1(3),DCBREL GET NUMBER OF TRACKS OR BLOCKS
         MVC       CHECKSAV(4),DCBROUT+4  SAVE CHECK/SYNC ROUTINE ADDR
         L         R4,CVTPTR(,R0)      GET CVT POINTER
         CLI       CVTCMS(R4),255      IS THIS CMS
         BE        OPBLKOK             IF SO THEN SKIP NEXT
         UNPK      SAVEAREA(3),DCBDEVT(2)  SEPARATE UPPER PARM OF DEVT
         CLI       SAVEAREA,X'F2'      IS THE DEVICE DIRECT-ACCESS
         BNE       OPBLKOK             IF NOT THEN SKIP THE NEXT CODE
         L         R4,DCBDVTBL         GET PTR TO DEVICE TABLE ENTRY
         LH        R0,4(,R4)           GET MAXIMUM BLKSIZE
         CH        R0,=H'13165'        IS THIS A 3330
         BNE       *+8                 IF NOT THEN GO AROUND
         LH        R0,=H'13030'        GET CORRECT MAXIMUM BLKSIZE
         CH        R0,BLKSI            COMPARE WITH BLKSIZE
         BNL       OPBLKOK             IF MAX>=BLKSI THEN OK
         OI        DCBCIND+1,X'10'     SET PERMANENT ERROR
         STH       R0,DCBBLKSI         STORE MAXIMUM BLKSIZE
         MVI       IOCODE+1,5          SET OPEN RETURN CODE
OPBLKOK  EQU       *
OPRETURN LR        R2,R10              SET SYSTEM IOCB ADDRESS IN R2
         LH        R15,IOCODE          SET R15 TO RETURN CODE
         LM        R3,R14,SICAPIE+4    RESTORE REGISTERS
OPBR14   BR        R14                 AND RETURN TO CALLER
OPENERR6 MVI       IOCODE+1,6          SET OPEN RETURN CODE TO 6
         CLI       FILETYPE,F$QSAMR    IS THIS A RETURN CODE FILE
         BNL       OPRETURN            IF SO THEN GIVE RETURN CODE 6
         LM        R2,R3,DDNAME        LOAD DDNAME INTO REGS
         L         R1,OPABCODE         SET ABEND CODE TO U0013
         SVC       13                  ISSUE ABEND SVC
OPABCODE DC        0F'0',X'8000',AL2(13)
OPFILDEF EQU       *-4
         DC        X'48504000'         F$QSAM
         DC        X'24244000'         F$BSAM
         DC        X'24240200'         F$BPAM
         DC        X'48504000'         F$QSAMR
         DC        X'20284000'         F$BSAMR
         DC        X'20284000'         F$BSAMK
         DC        X'29282000'         F$BDAMR
         DC        X'31322000'         F$BDAMK
OPEXLST  DC        0F'0',X'05',AL3(EXITROUT)
         DC        0F'0',X'88',AL3(EXITB37)
EXITROUT XI        FLAGS-IOCBDCB(R1),REREADSW  REVERSE REREADSW
         TM        FLAGS-IOCBDCB(R1),REREADSW  IS EXIT FROM OPEN
         BZ        EXITOPEN            IF SO THEN CONTINUE
         LA        R0,IOCBDCB-IOCB     GET OFFSET OF DCB IN IOCB
         SR        R1,R0               GET IOCB ADDRESS
         MVC       DCBBUFNO-IOCB(1,R1),BUFNO-IOCB(R1)  RECOVER BUFNO
         BR        R14                 AND RETURN TO EOV
EXITOPEN MVC       DCBKEYLE(1),KEYLEN  SET KEY LENGTH FROM IOCB
         L         R2,CVTPTR(,R0)      GET CVT POINTER
         CLI       CVTCMS(R2),255      IS THIS CMS
         BE        EXITCMS             IF SO THEN SKIP NEXT
         L         R2,DCBDEBAD         GET POINTER TO OPEN WORK AREA
         CLC       257(3,R2),=F'0'     IS THERE A SECONDARY ALLOCATION
         BZ        *+8                 IF NOT THEN SKIP NEXT CODE
         OI        FLAGS,SECALLOC      SET SECONDARY ALLOCATION FLAG
EXITCMS  EQU       *
         MVC       SICAPARM+4(1),DCBRECFM  SAVE FILE RECFM
         TM        DCBRECFM,X'C0'      IS DCBRECFM TYPE DEFINED
         BZ        EXRECFMD            IF NOT THEN USE DEFAULT RECFM
         MVC       SICAPARM+5(1),DCBRECFM  MOVE DCBRECFM TO TEMP
         XC        SICAPARM+5(1),RECFM     EXCLUSIVE OR WITH RECFM
         OC        SICAPARM+5(1),RECMERGE  TURN MERGABLE BITS ON
         XC        SICAPARM+5(1),RECMERGE  TURN MERGABLE BITS OFF
         BZ        EXRECFM             IF ZERO THEN DCBRECFM IS OK
EXRECFMD MVC       DCBRECFM(1),RECFM   OTHERWISE USE DEFAULT
EXRECFM  MVC       RECFM(1),DCBRECFM   MERGE RECFM BACK INTO IOCB
         TM        RECFM,X'80'         IS RECFM=V
         BO        *+8                 IF NOT THEN GO AROUND
         MVI       VLIND+1,4           SET LENGTH OF RCW TO 4
         CLI       FILETYPE,F$QSAMR    IS THIS A RETURN CODE FILE
         BNL       EXITRETC            IF SO THEN GO TO PROPER CODE
         LH        R6,VLIND            PUT RCW LENGTH IN R6
         LH        R4,LRECL            GET IOCB LRECL
         LPR       R4,R4               MAKE LRECL POSITIVE
         LH        R7,MAXLRECL         GET MAXIMUM LRECL
         LTR       R7,R7               IS MAXLRECL SPECIFIED
         BZ        EXLRECL             IF NOT THEN LRECL IS FORCED
         LH        R5,DCBLRECL         PICK UP DCB LRECL FIELD
         SR        R5,R6               SUBTRACT POSSIBLE RCW
         BNP       EXLRECL             IF NO DCBLRECL THEN USE DEFAULT
         LR        R4,R5               OTHERWISE USE DCBLRECL
         CR        R4,R7               COMPARE WITH MAXIMUM
         BNH       EXLRECL             IF NOT HIGH THEN IS OK
         LR        R4,R7               OTHERWISE USE MAXIMUM
EXLRECL  STH       R4,LRECL            SAVE FINAL LRECL IN IOCB
         AR        R4,R6               ADD IN POSSIBLE RCW
         STH       R4,DCBLRECL         SAVE IN DCB LRECL FIELD
         LH        R7,BLKSI            GET IOCB BLKSI
         LCR       R5,R7               COMPLEMENT AND TEST
         BM        EXBLKSI             IF IOCB BLKSI>0 THEN IS FORCED
         LH        R7,DCBBLKSI         PICK UP DCB BLKSI FIELD
         LTR       R7,R7               IF BLKSI SPECIFIED ON DD, USE IT
         BNZ       EXBLKSI
         LTR       R7,R5               OTHERWISE USE DEFAULT
         BNZ       EXBLKSI             IF DEFAULTÂ¬=0 THEN GO AND USE
         LR        R7,R4               SET BLKSIZE=LRECL
         AR        R7,R6               ADD IN BCW
EXBLKSI  TM        DCBRECFM,X'40'      IS RECFM=F
         BO        EXBLKSI1            IF NOT THEN GO AROUND
         DR        R6,R4               DIVIDE BLKSIZE BY LRECL
         MR        R6,R4               ROUND TO NEAREST MULTIPLE
         LTR       R7,R7               IS BLKSI=0
         BNZ       EXBLKSI1            IF NOT THEN CONTINUE
         LR        R7,R4               SET BLKSI=LRECL
EXBLKSI1 STH       R7,DCBBLKSI         STORE BLKSIZE IN DCB
         STH       R7,BLKSI            STORE BLKSIZE IN IOCB
         CLI       DCBBUFNO,0          HAS BUFNO BEEN SPECIFIED
         BNE       EXBUFNO             IF SO THEN SKIP NEXT
         XI        BUFNO,X'80'         REVERSE UPPER BIT OF BUFNO
         CLC       DCBBLKSI(1),BUFNO   IS (BLKSI/256)>=CRITICAL BLKSI
         BL        EXBUFNO             IF NOT THEN LEAVE BUFNO AS IS
         MVI       DCBBUFNO,1          CHANGE BUFNO TO 1
EXBUFNO  MVC       BUFNO(1),DCBBUFNO   SAVE BUFNO FOR EOV
         BR        R14                 AND RETURN TO OPEN
EXITRETC LR        R8,R14              SAVE RETURN ADDRESS
         TM        OPENCODE,X'0F'      IS FILE OPEN FOR OUTPUT
         BO        EXRRECFM            IF SO THEN RECFM IS OK
         TM        SICAPARM+4,X'C0'    IS FILE RECFM DEFINED
         BNZ       EXRECHEK            IF SO THEN CHECK IF COMPATIBLE
         L         R2,CVTPTR(,R0)      GET CVT POINTER
         CLI       CVTCMS(R2),255      IS THIS CMS
         BE        EXRRECFM            IF SO THEN ACCEPT RECFM AS IS
         B         EXITERR1            OTHERWISE GIVE ERROR 1
EXRECHEK TM        DCBRECFM,X'C0'      IS RECFM=U
         BO        EXRRECFM            IF SO THEN OK
         XC        SICAPARM+4(1),DCBRECFM
         TM        SICAPARM+4,X'C0'    ARE RECFMS COMPATIBLE
         BNZ       EXITERR2            IF NOT THEN GIVE ERROR 2
EXRRECFM LH        R1,BLKSI            GET FILE BLKSIZE
         LTR       R0,R1               IS BLKSIZE>0
         BP        EXRBLKSI            THEN IT IS FORCED
         LH        R1,DCBBLKSI         GET MERGED IN BLKSIZE
         LTR       R1,R1               HAS BLKSIZE BEEN SPECIFIED
         BP        EXRBLKSI            AND IF ZERO THEN GIVE ERROR 1
         LPR       R1,R0               CHECK IF ANY DEFAULT BLKSIZE
         BZ        EXITERR1            AND IF ZERO THEN GIVE ERROR 1
EXRBLKSI STH       R1,DCBBLKSI         STORE IN DCB BLKSIZE
         STH       R1,BLKSI            AND IN BLKSI
         CLI       FILETYPE,F$QSAMR    IS THIS RETURN CODE QSAM
         BNE       EXNQSAMR            IF NOT THEN SKIP NEXT
         LH        R2,LRECL            GET FILE LRECL
         LTR       R2,R2               IS IT ZERO
         BNZ       EXLRECOK            IF NOT THEN SKIP NEXT
         LH        R2,DCBLRECL         GET MERGED IN LRECL
         SH        R2,VLIND            REMOVE RCW LENGTH
         BNP       EXITERR1            AND IF ZERO THEN GIVE ERROR 1
EXLRECOK STH       R2,LRECL            STORE IN FILE LRECL
         AH        R2,VLIND            ADD IN RCW LENGTH
         STH       R2,DCBLRECL         AND IN DCB LRECL
         SR        R0,R0               CLEAR R0 FOR DIVIDE
         DR        R0,R2               DIVIDE BLKSIZE BY LRECL
         TM        DCBRECFM,X'40'      IS RECFM=F
         BO        EXITNOTF            IF NOT THEN GO AROUND
         LTR       R0,R0               IS REMAINDER ZERO
         BNZ       EXITERR4            IF NOT THEN GIVE ERROR 4
EXITNOTF SR        R1,R1               CLEAR R1
         IC        R1,DCBBUFNO         GET BUFNO
         LTR       R1,R1               IS IT ZERO
         BNZ       *+8                 IF NOT THEN SKIP NEXT
         LA        R1,2                SET TO 2
         MH        R1,BLKSI            MULTIPLY BY BLKSIZE
         LA        R1,256(,R1)         ADD IN EXTRA
         BAL       R14,GETMAIN         CALL GETMAIN
         BNZ       EXITERR3            IF NOT ENOUGH GIVE ERROR 3
         SVC       10                  FREE THE MEMORY
EXNQSAMR NI        DCBOPTCD,255-1      CLEAR RELATIVE MODE FLAG
         CLI       FILETYPE,F$BDAMR    IS THIS BDAM RELATIVE RECORD
         BNE       *+8                 IF NOT THEN SKIP NEXT
         MVI       DCBOPTCD,1          INSERT OPTCD
         BR        R8                  AND RETURN
EXITERR4 XI        IOCODE+1,7          SET IOCODE TO 4
EXITERR3 XI        IOCODE+1,1          SET IOCODE TO 3
EXITERR2 XI        IOCODE+1,3          SET IOCODE TO 2
EXITERR1 XI        IOCODE+1,1          SET IOCODE TO 1
         MVI       DCBRECFM,X'C0'      SET RECFM=U
         LA        R1,16               SET BLKSI & LRECL TO 16
         STH       R1,DCBLRECL         SET LRECL=16
         STH       R1,DCBBLKSI         SET BLKSI=16
         BR        R8                  RETURN TO OPEN
         DROP      R9
         USING     EXITB37,R15
EXITB37  SH        R1,=AL2(IOCBDCB-IOCB)
         LA        R15,2               EOV CODE FOR ABEND
         CLI       FILETYPE-IOCB(R1),F$QSAMR  RETURN CODE TYPE ?
         BCR       4,R14               IF NOT THEN ABEND
         BCTR      R15,0               EOV CODE FOR TAKE SYNAD EXIT
         L         R1,IOCBSICA-IOCB(,R1)  GET SICA POINTER
         MVI       IOCODE+1-SICA(R1),2 SET IO RETURN CODE
         BR        R14                 AND RETURN TO EOV
         DROP      R15
*
*        CLOSE ROUTINE
*        INPUT  R2=ADDR(SYSTEM IOCB)
*               R1=CLOSE CODE
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSCLOSE LTR       R2,R2               IS THIS A NULL FILE
         BCR       8,R14               IF SO THEN RETURN
         STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         LA        R15,IOCBDCB         GET DCB ADDRESS
         ST        R15,SICAPARM        SAVE IN CLOSE PARM LIST
         STC       R1,SICAPARM         STORE CLOSE CODE
         OI        SICAPARM,X'80'      INDICATE END OF CLOSE PARM LIST
         LA        R1,SICAPARM         SET PARM REG FOR CLOSE
         SVC       20                  ISSUE CLOSE SVC
*        FREEPOOL  IOCBDCB             FREE BUFFER POOL
         L         R15,DCBBUFCB        GET BUFCB POINTER
         N         R15,=X'00FFFFFF'    IS THERE A BUFFER POOL
         BZ        CLOSE1              IF NOT THEN GO AROUND
         SR        R14,R14             CLEAR R14
         IC        R14,5(,R15)         GET NUMBER OF BUFFERS
         MH        R14,6(,R15)         MULTIPLY BY BUFFER LENGTH
         LA        R0,8(,R14)          GET LENGTH INCLUDING BUFCB
         LA        R1,0(,R15)          SET ADDRESS FOR FREEMAIN
         SVC       10                  ISSUE FREEMAIN SVC
CLOSE1   LA        R1,IOCBQORG         GET ADDR OF START OF IOCB QUEUE
         SH        R1,=AL2(IOCBLINK-IOCB)  MAKE LOOK LIKE DUMMY IOCB
CLOSLOOP LR        R2,R1               SAVE PREVIOUS POINTER
         L         R1,IOCBLINK-IOCB(,R1)  ADVANCE TO NEXT IOCB
         CR        R1,R10              IS THIS THE IOCB
         BNE       CLOSLOOP            IF NOT THEN CONTINUE DOWN QUEUE
         MVC       IOCBLINK-IOCB(4,R2),IOCBLINK-IOCB(R1)  DELINK IOCB
         SR        R1,R1               CLEAR R1
         IC        R1,USERLNTH         GET LENGTH OF USER AREA
         SLA       R1,3                CONVERT TO BYTES FROM DWORDS
         LA        R0,IOCBEND-IODEF(,R1)  GET LENGTH OF IOCB
         LA        R1,IOCBEND          GET END OF IOCB
         SR        R1,R0               GET START OF IOCB
         SVC       10                  ISSUE FREEMAIN SVC
         B         IORET               AND RETURN
*
*        GET ROUTINE
*        INPUT  R1=ADDR OF TO AREA(MOVE MODE), OR R1=0(LOCATE MODE)
*               R0=LENGTH OF TO AREA(MOVE MODE)
*               R2=ADDR OF IOCB
*        OUTPUT R1=ADDR OF RECORD(RCW NOT INCLUDED FOR RECFM=V)
*               R0=LENGTH OF RECORD(RCW LENGTH NOT INCLUDED FOR V)
*        CC=0 FOR OK, CC=1 FOR EOF,
*        CC=3 FOR IO ERROR.
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSGET   STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
REGET    NI        FLAGS,255-REREADSW  TURN OFF REREAD SWITCH
*        GET       IOCBDCB
         LA        R1,IOCBDCB          GET DCB ADDRESS FOR GET
         L         R15,DCBROUT         LOAD GET ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
         TM        FLAGS,REREADSW      IS REREAD REQUIRED
         BO        REGET               IF SO THEN DO IT
         LH        R0,LRECL            LOAD LRECL IN CASE RECFM=F
         TM        RECFM,X'40'         IS THIS RECFM F
         BZ        GETCOM              IF SO THEN GO TO COMMON ROUTINE
         TM        RECFM,X'C0'         IS IT RECFM U
         BO        GETU                IF SO THEN GO PROCESS
         MVC       SAVEAREA(2),0(R1)   ALIGN RCW
         LH        R0,SAVEAREA         AND PUT IN R0
         SH        R0,VLIND            SUBTRACT LENGTH OF RCW
         LA        R1,4(,R1)           AND SKIP OVER RCW
         B         GETCOM              GO TO COMMON ROUTINE
GETU     L         R4,DCBIOBA          GET POINTER TO IOB PREFIX
         LH        R0,BLKSI            GET SIZE OF READ
         SH        R0,22(,R4)          SUBTRACT RESIDUAL COUNT
GETCOM   LTR       R2,R2               IS RECORD TO BE MOVED
         BZ        IORET0              IF NOT THEN RETURN ADDR AND LNTH
         BAL       R14,MOVE            MOVE RECORD INTO AREA
IORET0   CR        R0,R0               SET CC=0
IORET    LH        R15,IOCODE          LOAD RETURN CODE
RETURN   LR        R13,R12             RESTORE CALLER'S R13
         LM        R2,R14,SAVEAREA     RESTORE CALLER'S REGISTERS
         BR        R14                 AND RETURN
READEOF  DC        0H'0'               SET CC=3 FOR END-OF-FILE
IORET1   OR        R13,R13             SET CC=1
         B         IORET               AND RETURN
IOERROR  MVC       DCBROUT+4(4),CHECKSAV  RESTORE CHECK ROUTINE ADDRESS
IORET3   TM        *+1,1               SET CC=3
         B         IORET               AND RETURN
IOINIT   LR        R11,R15
         LA        R10,0(,R2)          MOVE IOCB ADDR AND CLEAR FLAGS
         LR        R12,R13             SAVE R13
         L         R13,IOCBSICA        LOAD SICA POINTER
         LPR       R3,R0               SAVE LENGTH
         LR        R2,R1               SAVE AREA ADDRESS
         STM       R10,R12,SICAPIE     SAVE REGS FOR LATER
         MVI       IOCODE+1,0          INITIALIZE RETURN CODE
         BR        R14
         DROP      R11
*
*        PUT ROUTINE
*        INPUT  R1=ADDR OF RECORD(RCW NOT INCLUDED FOR RECFM=V)
*               R0=LENGTH OF RECORD(RCW LENGTH NOT INCLUDED FOR V)
*               R2=ADDR OF IOCB
*        OUTPUT R1=ADDR OF AREA FOR NEXT RECORD(LOCATE MODE)
*        CC=0 FOR OK
*        CC=3 AND R15=0 FOR IO ERROR
*        CC=3 AND R15=1 FOR DATA SET IS FULL
*        CC=3 AND R15=2 FOR DISK VOLUME IS FULL
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSPUT   STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         SH        R2,VLIND            SUBTRACT POSSIBLE RCW
*        PUT       IOCBDCB,(1)
         LR        R0,R2               MOVE AREA ADDRESS INTO R0
         LA        R1,IOCBDCB          GET DCB ADDRESS FOR PUT
         L         R15,DCBROUT         GET PUT ROUTINE ADDRESS
         TM        OPENCODE,X'0F'      IS FILE OPEN FOR IO
         BM        PUTX                IF SO THEN GO TO PUTX
         MVC       SICAPARM(4),0(R2)   SAVE POSSIBLE RCW
         TM        RECFM,X'80'         IS RECFM=V
         BO        PUTNOTV             IF NOT THEN GO AROUND
         AH        R3,VLIND            ADD ON RCW LENGTH
         STH       R3,SAVEAREA         SAVE IN ALIGNED AREA
         MVC       0(2,R2),SAVEAREA    AND MOVE IN RCW
         XC        2(2,R2),2(R2)       AND MOVE IN ZERO
PUTNOTV  LH        R4,DCBLRECL         SAVE LRECL FIELD
         TM        RECFM,X'C0'         IS RECFM=U
         BNO       *+8                 IF NOT THEN SKIP NEXT
         STH       R3,DCBLRECL         SET LRECL
         CLI       FILETYPE,F$QSAM     IS THIS QSAM
         BE        *+10                IF SO THEN SKIP CHECK
         MVC       DCBROUT+5(3),=AL3(CHECK)  MOVE IN CHECK ROUTINE
         BALR      R14,R15             AND CALL PUT ROUTINE
         MVC       DCBROUT+4(4),CHECKSAV  RESTORE CHECK ROUTINE ADDRESS
         MVC       0(4,R2),SICAPARM    RESTORE POSSIBLE RCW
         STH       R4,DCBLRECL         RESTORE LRECL
         B         IORET0              AND RETURN
PUTX     BAL       R14,4(,R15)         CALL PUTX ROUTINE
         B         IORET0              AND RETURN
CHECK    STM       R9,R12,SICAPIE+12   SAVE REGISTERS
         LM        R10,R12,SICAPIE     RESTORE REGISTERS
         TM        DCBCIND,X'20'       IS EXTENT FULL
         BZ        CHECKRET            IF NOT THEN RETURN
         CLI       DCBFDAD,15          ARE THERE 16 EXTENTS
         BNL       CHECKERR            IF NOT THEN ERROR
         TM        FLAGS,SECALLOC      IS THERE A SECONDARY ALLOCATION
         BO        CHECKRET            IF SO THEN CONTINUE
CHECKERR L         R9,DCBIOBA          GET IOB ADDRESS
         NI        20(R9),X'FE'        TURN OFF CSW UNIT EXCEPTION BIT
         NI        DCBCIND,255-X'20'   TURN OFF FULL BIT
         OI        DCBCIND+1,X'10'     INDICATE PERMANENT IO ERROR
         MVI       IOCODE+1,1          SET CODE FOR CALLER
         B         IORET3              AND RETURN WITH IO ERROR
CHECKRET L         R15,CHECKSAV        GET REAL CHECK ROUTINE ADDRESS
         LM        R9,R12,SICAPIE+12   RESTORE REGISTERS
         BR        R15                 AND GO TO IT
         DROP      R11
*
*        READ ROUTINE
*        INPUT  R1=ADDR OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)
*               R0=LENGTH OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)
*                  +N READ N BYTES
*                  +1 READ BLKSIZE BYTES
*                   0 READ BLKSIZE BYTES
*                  -1 READ BLKSIZE BYTES
*                  -N READ N BYTES
*               R2=ADDR OF IOCB
*               R3=RELATIVE RECORD NUMBER FOR RELATIVE FILES
*                  A(TRACKNO,KEY ADDR) FOR DIRECT
*        OUTPUT R1=ADDR(RECORD)
*               R0=LENGTH(RECORD)
*        CC=0 FOR OK, CC=1 FOR EOF,
*        CC=3 FOR IO ERROR.
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSREAD  STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         MVI       DECBECB,X'7F'       INITIALIZE ECB
         LH        R4,DCBBLKSI         SAVE BLKSIZE
         CL        R3,=F'1'            HAS LENGTH BEEN SPECIFIED
         BH        *+6                 IF SO THEN USE IT
         LR        R3,R4               OTHERWISE USE BLKSIZE
         STH       R3,DCBBLKSI         STORE LENGTH TO READ
         CLI       FILETYPE,F$BDAMR    IS THIS A BDAM FILE
         BNL       READBDAM            IF SO THEN GO TO BDAM CODE
         ST        R2,DECBAREA         STORE AREA ADDRESS IN DECB
         MVI       DECBTYPE+1,X'80'    INDICATE READ
REREAD   NI        FLAGS,255-REREADSW  TURN OFF REREAD SWITCH
*        READ      IOCBDECB
         LA        R1,IOCBDECB         GET DCB ADDRESS FOR READ
         L         R15,DCBROUT         LOAD READ ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
*        CHECK     IOCBDECB
         LA        R1,IOCBDECB         LOAD DECB ADDRESS
         L         R15,DCBROUT+4       LOAD CHECK ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
         TM        FLAGS,REREADSW      IS REREAD REQUIRED
         BO        REREAD              IF SO THEN DO IT
         L         R3,DECBIOBA         LOAD IOB POINTER
         LH        R0,DCBBLKSI         GET READ LENGTH
         SH        R0,14(,R3)          SUBTRACT RESIDUAL COUNT
         STH       R4,DCBBLKSI         RESTORE BLKSIZE
         B         IORET0              AND RETURN
READBDAM LA        R15,X'0148'         INITIALIZE FOR RELATIVE RECORD
         L         R6,SAVEAREA+4-SICA(,R12)  GET KEY PARM FROM SAVED R3
READREL  LA        R7,DECKYADR+1       SET ADDRESS TO POINT TO NUMBER
         BE        BDAMIO              IF RELATIVE THEN GO DO IO
         LA        R15,X'004C'         SET TYPE FOR TRACKNO AND KEY
READKEY  LA        R7,2(,R6)           GET POINTER TO TRACK NUMBER
         L         R6,4(,R6)           GET POINTER TO KEY
BDAMIO   STH       R15,DECBTYPE        SAVE TYPE
         STM       R6,R7,DECKYADR      STORE KEY POINTER AND TRACK PTR
         ST        R2,DECBAREA         STORE AREA ADDRESS IN DECB
*        READ      IOCBDECB
         LA        R1,IOCBDECB         GET DCB ADDRESS FOR READ
         L         R15,DCBROUT         LOAD READ ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
*        CHECK     IOCBDECB
         LA        R1,IOCBDECB         LOAD DECB ADDRESS
         L         R15,DCBROUT+4       LOAD CHECK ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
         L         R3,DECBIOBA         GET IOB POINTER
         LH        R0,DCBBLKSI         GET BLKSIZE
         SH        R0,14(,R3)          SUBTRACT RESIDUAL COUNT
         STH       R4,DCBBLKSI         RESTORE BLKSIZE
         TM        DECBECB+1,X'80'     WAS RECORD NOT FOUND
         BO        IORET1              IF NOT FOUND THEN RETURN 1
         TM        DECBECB+1,X'10'     WAS IT AN INVALID REQUEST
         BZ        IORET0              IF VALID THEN RETURN 0
         TM        DECBECB+2,X'11'     IF KEY BEGINS X'FF' OR NOT IN
         BNZ       IORET1              DATA SET THEN RETURN 1
         B         IORET0              OTHERWISE RETURN 0
         DROP      R11
*
*        WRITE ROUTINE
*        INPUT  R1=ADDR OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)
*               R0=LENGTH OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)
*                  +N WRITE N BYTES
*                  +1 WRITE BLKSIZE BYTES
*                   0 WRITE DUMMY RECORD FOR F$BSAMK RECFM=F
*                     WRITE CAPACITY RECORD FOR F$BSAMK RECFM=V OR U
*                     WRITE BLKSIZE BYTES FOR ALL OTHER FILES
*                  -1 REWRITE BLKSIZE BYTES
*                  -N REWRITE N BYTES
*               R2=ADDR OF IOCB
*               R3=RELATIVE RECORD NUMBER FOR RELATIVE FILES
*                  A(TRACKNO,KEY ADDR) FOR DIRECT
*        OUTPUT
*        CC=0 FOR OK(FOR F$BSAMR OR F$BSAMK R15 SET AS FOR BSAM LOAD)
*        CC=1 FOR EOF OR RECORD NOT FOUND(BDAM)
*        CC=3 AND R15=0 FOR IO ERROR
*        CC=3 AND R15=1 FOR DATA SET FULL
*        CC=3 AND R15=2 FOR DISK PACK FULL
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSWRITE STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         MVI       DECBECB,X'7F'       INITIALIZE ECB
         LH        R4,DCBBLKSI         SAVE BLKSIZE
         CL        R3,=F'1'            HAS LENGTH BEEN SPECIFIED
         BH        *+6                 IF SO THEN USE IT
         LR        R3,R4               OTHERWISE USE BLKSIZE
         STH       R3,DCBBLKSI         STORE LENGTH TO WRITE
         TM        RECFM,X'80'         IS RECFM=V
         BO        WRITNOTV            IF NOT THEN GO AROUND
         SR        R15,R15             CLEAR R15
         CLI       DCBDSORG,X'20'      IS THIS BDAM
         BE        *+8                 IF SO THEN SKIP NEXT
         IC        R15,KEYLEN          GET KEY LENGTH
         AR        R15,R2              GET POINTER TO BCW
         XC        SAVEAREA+2(2),SAVEAREA+2  INITIALIZE TO ZERO
         STH       R3,SAVEAREA         SAVE IN ALIGNED AREA
         MVC       0(4,R15),SAVEAREA   MOVE IN BCW
         TM        RECFM,X'10'         ARE RECORDS BLOCKED
         BO        WRITNOTV            IF SO THEN NO RCW
         SH        R3,VLIND            GET LENGTH OF RECORD
         STH       R3,SAVEAREA         SAVE IN ALIGNED AREA
         MVC       4(4,R15),SAVEAREA   MOVE RCW INTO BUFFER
WRITNOTV CLI       FILETYPE,F$BDAMR    IS THIS A BDAM FILE
         BNL       WRITBDAM            IF SO THEN GO TO BDAM CODE
         ST        R2,DECBAREA         STORE AREA ADDRESS IN DECB
         MVI       DECBTYPE+1,X'20'    INITIALIZE TO WRITE RECORD(SF)
         CLI       FILETYPE,F$BSAMR    IS THIS A BSAM LOAD MODE FILE
         BNL       WRITLOAD            IF SO THEN GO TO BSAM LOAD CODE
*        WRITE     IOCBDECB
         LA        R1,IOCBDECB         GET DCB ADDRESS FOR WRITE
         L         R15,DCBROUT         LOAD WRITE ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
*        CHECK     IOCBDECB
         LA        R1,IOCBDECB         LOAD DECB ADDRESS FOR CHECK
         L         R15,DCBROUT+4       LOAD CHECK ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
         STH       R4,DCBBLKSI         RESTORE BLKSIZE
         B         IORET0              AND RETURN
WRITLOAD BE        WRITREC             IF NOT KEYED THEN GO WRITE(SF)
         LTR       R0,R0               IS THIS A RECORD WRITE
         BP        WRITREC             IF SO THEN GO WRITE RECORD(SF)
         MVI       DECBTYPE+1,X'04'    SET FOR CAPACITY RECORD(SZ)
         TM        RECFM,X'40'         IS THIS RECFM=F
         BNZ       WRITREC             IF NOT THEN GO WRITE CAPACITY
         MVI       DECBTYPE+1,X'10'    CHANGE TO WRITE DUMMY RECORD(SD)
*        WRITE     IOCBDECB
WRITREC  LA        R1,IOCBDECB         LOAD DECB ADDRESS FOR WRITE
         L         R15,DCBROUT         LOAD WRITE ROUTINE ADDRESS
         BALR      R14,R15             AND CALL IT
         LR        R2,R15              SAVE RETURN CODE IN R2
*        CHECK     IOCBDECB
         LA        R1,IOCBDECB         LOAD DECB ADDRESS FOR CHECK
         BAL       R14,CHECK           CALL CHECK ROUTINE
         STH       R4,DCBBLKSI         RESTORE BLKSIZE
         STC       R2,IOCODE+1         SAVE RETURN CODE
         B         IORET0              AND RETURN
WRITBDAM LA        R15,X'0140'         INITIALIZE FOR RELATIVE RECORD
         L         R6,SAVEAREA+4-SICA(,R12)  GET KEY PARM FROM SAVED R3
         BE        READREL             IF RELATIVE THEN GO DO WRITE
         LA        R15,X'0042'         CHANGE TO ADD TYPE
         LTR       R0,R0               IS THIS A REWRITE
         BNM       READKEY             IF NOT THEN GO DO WRITE
         LA        R15,X'0044'         CHANGE TO REWRITE TYPE
         B         READKEY             GO DO WRITE
         DROP      R11
*
*        NOTE ROUTINE
*        INPUT  R2=ADDR OF IOCB
*        OUTPUT R1=NOTE CONTROL INFORMATION SUITABLE FOR POINT
*                  FOR DISK CTTTRR00 WHERE C=CONCATNO,
*                           TTT=RELATIVE TRACK AND RR=RECORDNO
*                  FOR TAPE BLOCK NUMBER IN BINARY
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSNOTE  STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         LA        R1,IOCBDCB          SET DCB ADDRESS FOR NOTE
         L         R15,DCBNOTE         GET NOTE/POINT ROUTINE ADDRESS
         BALR      R14,R15             AND CALL NOTE ROUTINE
         IC        R0,DCBRELAD+3       GET CONCATENATION NUMBER IF DISK
         SLL       R0,28               SHIFT INTO UPPER HBYTE OF WORD
         OR        R1,R0               INSERT CONCATNO INTO ADDRESS
         B         IORET0              AND RETURN
         DROP      R11
*
*        POINT ROUTINE
*        INPUT  R2=ADDR OF IOCB
*               R1=NOTE CONTROL INFORMATION
*               R0=0 FOR CURRENT RECORD
*                  1 FOR NEXT RECORD
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSPOINT STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         AR        R1,R0               ADD IN NEXT RECORD INDICATOR
         SR        R0,R0               CLEAR R0
         SLDL      R0,4                MOVE CONCATNO IF DISK INTO R0
         SRL       R1,4                FIX UP REMAINDER OF NOTE INFO
         ST        R1,DECBAREA         SAVE INFO IN STORAGE
         STC       R0,DCBRELAD+3       SAVE POSSIBLE CONCATNO IN DCB
         LA        R1,IOCBDCB          SET DCB ADDRESS FOR POINT
         LA        R0,DECBAREA         SET PARM REG FOR POINT
         L         R15,DCBNOTE         GET NOTE/POINT ROUTINE ADDRESS
         BAL       R14,4(,R15)         AND CALL POINT ROUTINE
         B         IORET0              AND RETURN
         DROP      R11
*
*        FIND ROUTINE
*        INPUT  R2=ADDR OF IOCB
*               R1=ADDR OF NAME OF MEMBER TO FIND
*        OUTPUT
*        CC=0 FOR FOUND, CC=1 FOR NOT FOUND, CC=2 FOR IO ERROR
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSFIND  STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         LR        R0,R1               SET PARM REG FOR FIND
         LA        R1,IOCBDCB          SET DCB ADDRESS FOR FIND
         LCR       R1,R1               INDICATE D TYPE FIND
         SVC       18                  ISSUE FIND SVC
         CH        R15,=H'8'           IS THERE AN IO ERROR
         BE        IORET2              IF SO THEN RETURN 2
         OR        R15,R15             SET CC=0 FOR FOUND,CC=1 FOR NOT
         B         IORET               AND RETURN
         DROP      R11
*
*        STOW ROUTINE
*        INPUT  R2=ADDR OF IOCB
*               R1=ADDR OF NAME OF MEMBER TO STOW
*        OUTPUT
*        CC=0 MEMBER REPLACED, CC=1 MEMBER ADDED
*        CC=2 MEMBER NOT ADDED OR REPLACED(FULL OR IO ERROR)
*
         USING     SYSINT,R11
         USING     IOCB,R10
SYSSTOW  STM       R2,R15,SAVEAREA     SAVE REGISTERS
         BAL       R14,IOINIT-SYSINT(,R15)
         MVC       SICAPARM(8),0(R1)   MOVE OVER NAME
         XC        SICAPARM+8(4),SICAPARM+8  ZERO TTR AND BITS
         LA        R0,SICAPARM         LOAD ADDR OF STOW PARM
         LA        R1,IOCBDCB          LOAD DCB ADDRESS
         LCR       R1,R1               INDICATE TYPE R
         SVC       21                  ISSUE STOW SVC
         LTR       R15,R15             TEST RETURN CODE
         BZ        IORET0              IF OK THEN RETURN 0
         CH        R15,=H'8'           IS THE RETURN CODE 8
         BE        IORET1              IF SO THEN RETURN 1
IORET2   LTR       R13,R13             SET CC=2
         B         IORET               AND RETURN
         DROP      R11
         DROP      R10
*
*        MOVE ROUTINE
*        INPUT  R1=FROM-ADDRESS, R0=FROM-LENGTH
*               R2=TO-ADDRESS, R3=TO-LENGTH
*        IF FROM-RECORD IS LONGER THEN IT IS TRUNCATED
*        IF FROM-RECORD IS SHORTER THEN TO-RECORD IS PADDED WITH BLANKS
*
         USING     SYSINT,R15
MOVE     LR        R15,R11             FOR INTERNAL ENTRY
SYSMOVE  STM       R0,R5,SAVEAREA      SAVE CALLER'S REGISTERS
         LR        R4,R3               COPY TO-LENGTH
         CR        R4,R0               IS RECORD TO BE PADDED
         BNH       MOVEMAIN            IF NOT THEN COPY MAIN PART
         LR        R4,R0               R4=MIN(TO-LENGTH,FROM-LENGTH)
         LA        R5,0(R2,R4)         GET ADDR OF PART TO PAD
         MVI       0(R5),C' '          INSERT FIRST BLANK
         LA        R0,2(,R4)           CALCULATE FROM-LENGTH+2
         SR        R3,R0               CALCULATE LENGTH OF VAR MVC
         BM        MOVEMAIN            IF NEG THEN SKIP EX OF MVC
         EX        R3,BLANKMVC         MVC  1(*-*,R5),0(R5)
MOVEMAIN SH        R4,=H'257'          -1 FOR EX AND -256 FOR LAST
         BM        MOVELAST            IF <0 THEN GO DO EX
MOVELOOP MVC       0(256,R2),0(R1)     OTHERWISE MOVE 256 BYTES
         LA        R2,256(,R2)         BUMP TO-ADDRESS
         LA        R1,256(,R1)         BUMP FROM-ADDRESS
         SH        R4,=H'256'          SUBTRACT 256 FROM COUNT
         BNM       MOVELOOP            IF NOT NEG THEN LOOP
MOVELAST EX        R4,MOVEMVC          MVC  0(*-*,R2),0(R1)
         LM        R0,R5,SAVEAREA      RESTORE REGISTERS
         BR        R14                 AND RETURN TO CALLER
MOVEMVC  MVC       0(*-*,R2),0(R1)     MOVE MAIN PART OF DATA
BLANKMVC MVC       1(*-*,R5),0(R5)     PROPAGATE BLANK DOWN RECORD
         DROP      R15
*
*        SPIE ROUTINE
*        INPUT  R0=PROGRAM CHECK MASK
*               R1=ADDR OF SPIE EXIT ROUTINE
*               R2=VALUE TO BE PRESERVED FOR EXIT
*
         USING     SYSINT,R11
SYSSPIE  STM       R2,R14,SAVEAREA     SAVE REGISTERS
         LR        R11,R15             GET BASE REGISTER
         LR        R12,R13             SAVE USER'S R13
         L         R10,SYSIDENT-SYSINT(,R15)  GET SICA ID
SPGSICA  L         R13,BKWDPTR         GET BKWDPTR
         C         R10,SICAID          COMPARE WITH SICA ID
         BNE       SPGSICA             LOOP UNTIL FOUND
         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER
         ST        R1,SPIEROUT         SAVE ADDRESS OF EXIT ROUTINE
         STH       R0,SICAPICA+4       STORE MASK IN PICA
         ST        R2,SPIER2           SAVE R2 VALUE FOR EXIT ROUTINE
         LA        R1,SICAPICA         LOAD PARM REG FOR SPIE SVC
         SVC       14                  ISSUE SPIE SVC
         SPM       R13                 SET PROGRAM MASK OFF
         B         RETURN              AND RETURN
         DROP      R11
*
*        TIME ROUTINE
*        OUTPUT R0=TIME OF DAY IN TIMER UNITS
*               R1=DATE IN FORM 00 YY DD DF
*
SYSTIME  SR        R1,R1               INDICATE TIMER UNITS
         SVC       11                  ISSUE TIME SVC
         BR        R14                 AND RETURN
*
*        STIMER ROUTINE
*        INPUT  R0=VALUE OF INTERVAL
*               R1=ADDR OF EXIT ROUTINE(UPPER BYTE>0 FOR REAL TIMING)
*               R2=VALUE TO BE PRESERVED FOR EXIT ROUTINE
*
         USING     SYSINT,R11
SYSSTIME STM       R2,R14,SAVEAREA     SAVE REGISTERS
         LR        R11,R15             GET BASE REGISTER
         LR        R12,R13             SAVE USER'S R13
         L         R10,SYSIDENT-SYSINT(,R15)  GET SICA ID
STGSICA  L         R13,BKWDPTR         GET BKWDPTR
         C         R10,SICAID          COMPARE WITH SICA ID
         BNE       STGSICA             LOOP UNTIL FOUND
         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER
         MVC       TIMREXIT(10),TIMRCODE  INIT TIMER EXIT CODE
         ST        R0,SICAPARM         STORE INTERVAL IN CORE
         ST        R2,STIMERR2         SAVE EXIT VALUE OF R2
         LA        R2,0(,R1)           CLEAR UPPER BYTE OF ADDRESS
         ST        R2,TIMRROUT         SAVE TIMER EXIT ROUTINE ADDRESS
         LA        R0,TIMREXIT         LOAD EXIT ROUTINE ADDRESS
         CR        R1,R2               IS UPPER BYTE OF R1=0
         BE        *+8                 IF SO THEN IS TASK INTERVAL
         O         R0,=X'03000000'     SET CODE FOR REAL INTERVAL
         LA        R1,SICAPARM         LOAD ADDR OF INTERVAL WORD
         SVC       47                  ISSUE STIMER SVC
         B         RETURN              AND RETURN
TIMRCODE L         R2,STIMERR2-TIMREXIT(,R15)  LOAD R2 VALUE
         L         R15,TIMRROUT-TIMREXIT(,R15)  GET EXIT ROUTINE ADDR
         BR        R15                 AND GO TO IT
         DROP      R11
*
*        TTIMER ROUTINE
*        INPUT  R1=0 FOR CONTINUATION OF INTERVAL
*                  1 FOR CANCELATION OF INTERVAL
*                  2 FOR JOB STEP TIME REMAINING
*        OUTPUT R0=REMAINDER OF STIMER INTERVAL IN TIMER UNITS
*
         USING     SYSINT,R15
SYSTTIME C         R1,=F'2'            IS THIS JOB STEP INTERVAL
         BE        JOBSTEP             IF SO THEN GO PROCESS
         SVC       46                  ISSUE TTIMER SVC
         BR        R14                 AND RETURN
JOBSTEP  STM       R2,R14,SAVEAREA     SAVE REGISTERS
         LR        R11,R15             LOAD BASE REGISTER
         DROP      R15
         USING     SYSINT,R11
         L         R2,CVTPTR(,R0)      GET CVT POINTER
         L         R0,=X'7FFFFFFF'     LOAD MAXIMUM TIME
         CLI       CVTDCB(R2),X'10'    IS THIS MVT
         BNE       JSTRET              IF NOT THEN RETURN MAXIMUM
         L         R3,0(,R2)           GET TASK SWITCH CELL POINTER
         L         R3,4(,R3)           GET CURRENT TASK ADDRESS
         L         R3,124(,R3)         JOB STEP TCB ADDRESS
         L         R3,132(,R3)         INITIATOR TCB ADDRESS
         L         R3,120(,R3)         INITIATOR TQE ADDRESS
         L         R2,88(,R2)          POINTER TO SHPC
GETTIME  L         R4,12(,R3)          GET TOX
         L         R5,80               GET TIMER VALUE
         L         R6,0(,R2)           GET SHPC
         C         R4,12(,R3)          CHECK FOR NO INTERRUPT
         BNE       GETTIME             IF CHANGED MUST DO AGAIN
         SRA       R5,1                (TIMER/2)
         SR        R5,R6               (TIMER/2)-SHPC
         AR        R5,R4               (TIMER/2)-SHPC+TOX
         LR        R0,R5               SET VALUE IN RETURN REGISTER
JSTRET   LM        R2,R14,SAVEAREA     RESTORE CALLER'S REGISTERS
         BR        R14
*
*        LOAD ROUTINE
*        INPUT  R1=ADDRESS OF NAME OF MODULE TO LOAD
*               R2=ADDRESS OF IOCB TO LOAD ON(0 FOR STEPLIB ETC)
*        OUTPUT R1=ENTRY POINT OF MODULE
*               R0=LOAD POINT OF MODULE
*        CC=0 FOR LOADED, CC=1 FOR NOT ENOUGH CORE, CC=2 FOR NOT FOUND
*
         USING     SYSINT,R11
SYSLOAD  STM       R2,R14,SAVEAREA     SAVE REGISTERS
         LR        R11,R15             SAVE BASE REGISTER
         LR        R12,R13             SAVE USER'S R13
         L         R10,SYSIDENT        GET SICA ID
LOGSICA  L         R13,BKWDPTR         GET BKWDPTR
         C         R10,SICAID          COMPARE WITH SICA ID
         BNE       LOGSICA             LOOP UNTIL FOUND
         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER
         L         R15,CVTPTR(,R0)     GET CVT POINTER
         CLI       CVTCMS(R15),255     IS THIS CMS
         BE        LOADCMS             IF SO THEN GO PROCESS
         MVC       SICAPIE(4),=X'00010030'
         MVC       SICAPIE+4(8),0(R1)  MOVE IN NAME
         LTR       R2,R2               IS THERE A IOCB
         BZ        *+8                 IF NOT THEN CONTINUE
         LA        R2,IOCBDCB-IOCB(,R2)  OTHERWISE GET DCB ADDRESS
         LR        R1,R2               PUT DCB ADDRESS OR 0 IN R1
         LA        R0,SICAPIE          LOAD PARM ADDRESS FOR BLDL
         SVC       18                  ISSUE BLDL SVC
         LTR       R15,R15             TEST RETURN CODE FROM BLDL
         BP        RETURN              IF NAME NOT FOUND THEN RETURN 2
         L         R1,SICAPIE+28       GET LENGTH FROM PARM LIST
         SRL       R1,8                GET LENGTH IN LOW PART
         BAL       R14,GETMAIN         CALL GETMAIN ROUTINE
         BNZ       RETURN              IF NO CORE THEN RETURN 1
         BAL       R14,FREEMAIN        FREE CORE
         LR        R1,R2               LOAD DCB ADDRESS FOR LOAD
         LA        R0,SICAPIE+4        LOAD ADDRESS OF DE ENTRY
         LCR       R0,R0               COMPLEMENT TO INDICATE DE-TYPE
         SVC       8                   ISSUE LOAD SVC
         LR        R1,R0               SAVE ENTRY POINT ADDRESS IN R1
         MVI       SICAPIE+32,0        ZERO UPPER BYTE OF ENTRY OFFSET
         S         R0,SICAPIE+32       GET LOAD POINT OF MODULE
         CR        R0,R0               SET CC=0
         B         RETURN              AND RETURN
LOADCMS  LR        R0,R1               PUT NAME ADDRESS IN R0
         SR        R1,R1               INDICATE NO DCB
         SVC       8                   ISSUE LOAD SVC
         LR        R1,R0               PUT ENTRY POINT IN R1
         B         IORET0              RETURN 0
         DROP      R11
*
*        DELETE ROUTINE
*        INPUT  R1=ADDRESS OF NAME OF MODULE TO DELETE
*        OUTPUT CC=0 FOR DELETED, CC=1 FOR NAME NOT FOUND
*
SYSDELT  LR        R0,R1               COPY ADDRESS OF NAME FOR SVC
         SVC       9                   ISSUE DELETE SVC
         OR        R15,R15             SET CONDITION CODE
         BR        R14                 AND RETURN TO CALLER
*
*
*        WTO, WTOR AND WTP ROUTINE
*        INPUT  R1=ADDRESS OF TEXT TO WRITE
*               R0=LENGTH OF TEXT TO WRITE
*               R2=ADDRESS OF INPUT AREA FOR WTOR
*               R3=LENGTH OF INPUT AREA FOR WTOR
*
         USING     SYSINT,R15
SYSWTP   O         R1,=X'80000000'     SET WTP FLAG
         DROP      R15                 DROP R15
         USING     SYSINT,R11
SYSWTO   SR        R2,R2               CLEAR R2 TO INDICATE WTO
SYSWTOR  STM       R14,R12,SAVEAREA    SAVE REGISTERS
         LR        R11,R15             LOAD BASE REGISTER
         LR        R4,R1               SAVE ADDRESS OF STRING TO WRITE
         LR        R5,R0               SAVE LENGTH OF STRING TO WRITE
         LA        R0,144              GET LENGTH OF WORKAREA
         LNR       R1,R0               SET R1 NEGATIVE FOR GETMAIN
         SVC       10                  ISSUE GETMAIN SVC
         LR        R6,R1               SAVE ADDRESS OF WORKAREA
         ST        R2,0(,R6)           SAVE REPLY ADDRESS AREA
         STC       R3,0(,R6)           SAVE REPLY ADDRESS LENGTH
         EX        R5,WTORMVC          MVC 12(*-*,R6),0(R4)
         LA        R0,4(,R5)
         SLL       R0,16
         ST        R0,8(,R6)           SAVE IN WTOR PARM LIST
         MVI       10(R1),X'80'        TURN ON MCS FLAG
         AR        R5,R1               DESCRIPTOR/ROUTING FLAGS
         MVC       8(4,R5),=X'02004020'     DESC=7,ROUTCDE=(2,11)
         LTR       R4,R4               IS THIS A WTP
         BNM       *+8                 IF NOT THEN BRANCH AROUND
         NI        10(R5),255-X'40'    TURN MAIN CONSOLE FLAG OFF
         LA        R0,140(,R6)         GET ADDRESS OF WTOR ECB
         ST        R0,4(,R6)           SAVE IN WTOR PARM LIST
         MVI       140(R6),0           INITIALIZE ECB
         LTR       R2,R2               IS THIS WTOR
         BNZ       WTORCODE            IF SO THEN GO TO WTOR CODE
         LA        R1,8(,R6)           SKIP OVER TO PROPER PARM FOR WTO
         SVC       35                  ISSUE WTO SVC
         B         WTOCOMN             AND BRANCH TO COMMON CODE
WTORCODE SVC       35                  ISSUE WTOR SVC
         LA        R1,140(,R6)         SET UP ECB ADDRESS FOR WAIT SVC
         LA        R0,1                SET UP WAIT COUNT FOR WAIT SVC
         SVC       1                   AND WAIT FOR REPLY
WTOCOMN  LR        R1,R6               GET WORKAREA ADDRESS
         LA        R0,144              GET WORKAREA LENGTH
         SVC       10                  ISSUE FREEMAIN SVC
         LM        R14,R12,SAVEAREA    RESTORE USER'S REGISTERS
         BR        R14                 AND RETURN TO USER
WTORMVC  MVC       12(*-*,R6),0(R4)    MVC TO MOVE STUFF TO WRITE
         DROP      R11
*
*        ABEND ROUTINE
*        INPUT  R1=ABEND PARM REGISTER
*
SYSABEND SVC       13                  ISSUE ABEND SVC
*
SYSIDENT DC        0F'0',C'SICA'
         USING     SYSINT,R11
SYSPATCH DC        8S(*)               PATCH AREA FOR SYSINT
         DROP      R11
         DC        0D'0'
         LTORG
         DC        0D'0'
         END
