1
-
-
-
-
0                                     GPSAM
                     General Purpose Subsystem Access Method
-                         Version 1 Modification Level 0
0                                 Nov. 29, 1982
-
0                                 Howard Gilbert
                               Yale Computer Center
                                 175 Whitney Ave.
                            P.O. Box 2112 Yale Station
                               New Haven, Ct 06520
                         Bitnet address: GILBERT @ YALEVM
-
-
-
0                    (c) Copyright 1982 Yale Computer Center
0                    Yale retains all commercial rights to
                     the programs described herein. A
                     perpetual license is hereby granted to
                     any individual, company, or organization
                     to use them for any purpose on their own
                     machine and to distribute the programs
                     to other users provided that no more
                     than a nominal service charge is made
                     for the distribution. Explicit
                     permission of Yale is required to sell
                     any product which incorporates any part
                     of these programs or the accompanying
                     documentation.
1
-
                                  1.  HIGHLIGHTS
+                                 1.  HIGHLIGHTS
0             GPSAM lets you write your own "access method" and make it
           look like a sequential dataset to any application program or
           utility. It can be used to provide DBMS, VTAM, TSO
           fullscreen, BTAM, or specialized device support.
0             ® Simple:  Installs on any MVS system. No IBM code is
+               ______
                modified.  Takes only a few minutes to run linkedit
                steps and build procedures.
0             ® Small:  700 bytes in LPA. 160 bytes in private address
+               _____
                space.
0             ® Safe:  Only one instruction executes in key 0 and
+               ____
                modifies a general system control block. Another 18
                instructions operate in a system key and only 4 of them
                change storage, storing values in job related control
                blocks in the private area. Even the most conservative
                installation can desk check the single authorized CSECT
                several times over in an hour.
0             ® Universal:  While a system programmer must install the
+               _________
                package in authorized libraries, any application
                programmer can write his own "access method" in
                assembler and use it from his own programs. The user
                specifies the module name on his DD card or in the TSO
                allocation of the ddname.  These user modules run in
                problem state and can come from any library.  Control
                is given to the routine from the OPEN, CLOSE, GET, PUT,
                READ, or WRITE statements.
0             ® Secure:  MVS Integrity is maintained. If an authorized
+               ______
                program opens a GPSAM file, the "access method" module
                is limited to those explicitly permitted by an
                installation supplied name table and the module must
                come from an APF library.
0          GPSAM is distributed in source and object form. It is
           written in structured assembler language using the HAL£
           macro system.  There are no prerequisites for any IBM or
           non-IBM program products.
-
-          ××××××××××××××××××××
-          £ HAL provides IF, ELSEIF, ELSE, DO UNTIL, DO WHILE, BLOCK,
             and LEAVE statements with logical expressions. It is is
             distributed with GPSAM and other Yale packages. A separate
             document describes its use and syntax.
0                                     - 1 -
1
-
                                 2.  HOW IT WORKS
+                                2.  HOW IT WORKS
0             GPSAM makes use of the subsystem dataset facility which
+                                    _________ _______
           is a standard part of MVS. The best known subsystems are
           JES2 and JES3, and many programmers assume that a subsystem
           must involve communication with a running system task. In
           fact, the Subsystem Interface is more properly a set of
           general system exits identified by control blocks rather
           than linkedited into system modules.
0             For example, to use GPSAM the system programmer adds the
           name "GPSM" to the subsystem name table (a LINKLIB module in
           SP 1.1 or member of PARMLIB in SP 1.3).  At IPL time the
           system builds a 36 byte control block called a SSCVT and
           stores the name "GPSM" in it.  The subsystem is the control
+                                         ___ _________ __ ___ _______
           block.  There is no stared task, job, address space, or
+          _____
           subtask associated with the name GPSM.
0             It is necessary to run the GPSAM program after IPL.  This
           authorized program fills in the SSCVT control block with a
           pointer to exit routines which should get control when a
           GPSM dataset is allocated, opened, or closed.  These exits
           load the user supplied access method module.
0             Many application programmers assume that since the
           standard IBM access methods are part of the operating system
           they operate like SVC routines.  In fact, BSAM and QSAM
           operate as subroutines to the application program. The
           supervisor state part of the I/O process is handled by the
           separate EXCP SVC service.  An access method has no special
           attributes and need not be a system program at all.
0             GPSAM is not simply a single additional access method; it
           is instead a way to write your own access methods. On the DD
           card you specify a load module.  The load module is the
+                                           ___ ____ ______ __ ___
           dataset.
+          _______
0             On the EXEC card the programmer specifies a module name
           and parameter.
0             //stepname EXEC PGM=module,PARM='parameter'
0          GPSAM allows the programmer to supply other module names and
           parameter strings on the DD cards.
0             //ddname DD SUBSYS=(GPSM,module,'parameter')
0          When the main program opens this file name, the system calls
           one of the GPSM exit routines. The exit finds the module
           name from the DD card and issues a LOAD macro to bring it
           into storage. It then calls the entry point of the module as
           a problem state exit of OPEN (something like the DCB OPEN
           exit which is described in the standard Data Managment
-                                     - 2 -
1
-
           manuals). The user routine must prepare to service program
           input and output requests.  It is important to realize that
           there is no real data associated with this SUBSYS ddname. In
           many cases the user's entry point will open some other type
           of dataset or other ddname to actually get access to the
           data. The only absolute requirement for the entry point is
           that it pass back the address of another subroutine which
           will service the READ and WRITE or GET and PUT requests.
           The main entry point of the module is reenterd to close the
           dataset.
-
                                3.  POSSIBLE USES
+                               3.  POSSIBLE USES
0             The access method module is simply a dynamic subroutine
           of the main program.  If you write the jobstep program
           yourself in assembler language, and always get data from the
           same source, then you do not need GPSAM and can achieve the
           same function with the LOAD and LINK macros.
0             GPSAM becomes useful if the program is a package which
           you cannot modify, or is written in a high level language
           which has limited linkage conventions, or if the program was
           written to handle normal datasets and would be expensive to
           convert for a single special job. After all, the whole
           purpose of an access method is to free the program from
           internal dependency on any specific device type. But while
           QSAM and BSAM are fine for disk, tape, and unit record
           devices, they do not support more exotic kinds of data
           structures or device types.
0             One of the most important advantages of the Database
           Management concept is that it frees the application program
           from dependence on the form or location of the data. A DBMS
           does this for big online datasets, but it has a big setup
           cost and is not useful for smaller casual files or for tape
           datasets.  One of the simplest uses of GPSAM is to simply
           reformat records to match the actual contents of a datset to
           the format the program expects to see.  Suppose that changes
           in tax laws, zip code size, audit requirements, or a merger
           force changes in the format of archived tape files.  It is
           possible to recopy all existing data, but this is expensive
           and time consuming. Besides, there are lots of programs
           which depend on the old format. Alternately, two small
           assembler language programs could be written for GPSAM:
0             //INPUT DD SUBSYS=(GPSM,OLDFORM,REALTAPE)
              //REALTAPE DD definition of new format tape
0          The OLDFORM module would read a record from the REALTAPE
           ddname and reorganize the data to simulate the old format.
           Old programs will continue to work and need not be converted
-                                     - 3 -
1
-
           until new function is desired.  A matching NEWFORM module
           could take the old format tape and expand it to the new
           format with default or dummy values inserted into the new
           fields. This allows new programs to be run on the old tapes.
0             While some examples of GPSAM access method modules are
           supplied with the package, much of the program development
           will be contributed by the user community. The following
           examples show how GPSAM could be used. It is a wish list and
           not a list of supplied funcitons:
0             ® SUBSYS=(GPSM,LOWCASE) - In TSO, when the terminal is
                allocated for input using DA(*), the data typed in is
                folded into upper case. If this is not desired, a GPSAM
                module could do the TGET directly and pass the data
                unmolested.  This is only one example of a large number
                of potential terminal support routines to do things
                which the standard IBM DA(*) support does not provide.
                Examples include: fullscreen output to 3270s, support
                of ASA carriage control characters when the terminal is
                a hardcopy device, support of control characters for
                graphics devices, file transfer to minicomputers
                through the communications line, blank compression
                where the terminal has tab stops, insertion of padding
                characters when the terminal requires them, etc.
0             ® SUBSYS=(GPSM,SERIES1,ddname) - The IBM Series/1
                mincomputer supports many different hardware interfaces
                (GPIB, local area network, high speed parallel) and can
                itself be channel attached as a simulated 3270 control
                unit. Data acquired from lab equipment, point of sale,
                factory floor, network, or ID card scanning devices
                could be directly read or spooled to disk and
                transferred later through a BTAM interface routine
                connected through GPSAM.  The "ddname" supplied as the
                third parameter would be the name on a related:
                    //ddname DD UNIT=cuu
                card which defines the Series/1 data transfer address.
0             ® SUBSYS=(GPSM,DACU,ddname) - The new IBM DACU hardware
                product is similar to the previous example, except that
                it provides an interface to a DEC UNIBUS.  The
                interface routine would use the IBM GAM access method
                to provide the real I/O support to the device.
0             ® SUBSYS=(GPSM,DBMSI,'query') - The I/O could be sent to
                a Database Management System for resolution. The
                parameter string could contain a query, and the
                application program could then read records which are
                the result of the query. Alternately, the program could
                write the query to one file and then read the responses
                from another file.
-
                                      - 4 -
1
-
              ® SUBSYS=(GPSM,VTAMI,'netaddr,filename') - A dataset can
                be retrieved from a programmable node or other host in
                an ACF VTAM network. The interface program would open
                an ACB and establish a session with a service routine
                at the remote location. The supplied "filename" would
                be passed to locate the desired data in the remote
                library structure. The data could then be read as a
                sequential dataset by the local application program.
0             ® SUBSYS=(GPSM,NJEPACK,ddname) - An output dataset is to
                be sent through JES NJE services to a remote location.
                The "ddname" represents a SYSOUT=B card with routing
                information to the desired target. The problem is that
                the program producing the data does not want to produce
                cards but assumes some other F, V, or U record format.
                Records must be packed/blocked in card image compatible
                with the IBM network interchange format for
                transmission.
-
                            4.  HISTORICAL PERSPECTIVE
+                           4.  HISTORICAL PERSPECTIVE
0             Subsystem datasets were originally designed for use by
           JES.  From Releases 2.0 to 3.7 the only subsystem datasets
           were SYSIN and SYSOUT.  In the middle of Release 3.7,
           Selectable Unit 29 generalized the subsystem dataset concept
           with the SUBSYS keyword support.  Not many people took
           notice of SU 29, however, because its nominal function was
           to support the Vector Processor Subsystem for the 3838 array
           processor and few customers purchased this device.
0             It is well known that the product development is a small
           part of IBM's overall software costs.  There are major
           additional costs in testing, support, and education. The
           product must be tested and supported in any environment the
           customer may choose to use it.  When the product has a
           rather technical function, is mostly required to support
           other IBM products, and does not have a clear market demand,
           IBM avoids the extra cost by declaring the program to be an
           internal interface. While the interface may be documented in
           some manuals, it is not given full field support and need be
           tested only to ensure that it provides the functions
           required by the other specific IBM products.
0             The IBM market experts understand the requirements of
           industrial, financial, and government customers. But there
           come moments when an idea is "right" for reasons which a
           programmer understands instinctively but which are difficult
           to explain to salesmen.  The main advantage of the SUBSYS
           interface is that it is "slick".  There is nothing it does
           which cannot be done some other way. It makes some things
           easier to accomplish and to document. It may not be quite as
-                                     - 5 -
1
-
           general as the UNIX "pipe" concept or the device driver
           architecture in some minicomputer systems, but it is still
           awfully clever.  When the people in White Plains ask the
           question "What will they pay for it" or "How many machines
           will it sell," there is no easy way to put a dollar figure
           on a sense of technical aesthetics.
0             There is more opportunity for small useful products to
           come from IBM as IUPs and FDPs. Some, like GPSAM, will be
           written by customers and distributed through SHARE. If
           potential users simply don't look at anything but the fully
           supported products, then they shut themselves off from a
           whole class of useful tools.
-
                         5.  SUBSYSTEM DATASET INTERFACE
+                        5.  SUBSYSTEM DATASET INTERFACE
0             For each SUBSYS file, exits are taken to the subsystem
           when the JCL is parsed, then at allocation, open, close, and
           deallocation time. GPSAM is only interested in open and
           close and ignores the other calls.
0             The application program opens a DCB to talk to the file,
           but the OPEN SVC constructs an ACB and passes it to the
           subsystem.  When the application program issues the standard
           BSAM or QSAM I/O requests (GET, PUT, READ, WRITE, NOTE,
           POINT, CHECK) the IBM Sequential Access Method Subsystem
           Interface (SAMSI) modules convert these macros requests into
           VSAM-like requests with an RPL and an ACB. This produces
           some good news and some bad news.  The good news is that you
           do not have to worry about the difference between QSAM or
           BSAM because the IBM code delivers a common interface to
           your program.  The bad news is that the interface looks like
           an Entry Sequenced VSAM Dataset (ESDS) and this is a less
           familiar interface to most programmers.
0             Actually, the interface to the user "access method"
           routine is fairly simple. On entry to the routine:
0              R0   Contains a request code.
               R1   Points to the Request Parameter List (RPL).
               R13  Points to a save area.
               R14  Is the return address.
               R15  Is the entry address.
0          There are a lot of codes which can exist in R0 if you wanted
           to support them, but the only required codes are 0 (GET) and
           1 (PUT).  You can treat the rest as No-Ops or logical
           errors.  Within the RPL,
-
-                                     - 6 -
1
-
              Offset  Name      Function
              0C      RPLFDBWD  Return code from I/O request.
              20      RPLAREA   Points to user buffer.
              30      RPLRLEN   Has or gets the length of the data in
           the buffer.
              34      RPLBUFL   Has the full size of the user buffer.
0          and any use of other fields is optional.  For a PUT request,
           you must dispose of RPLRLEN bytes of data in the buffer
           RPLAREA points to. For a GET request you fill the buffer
           with no more than RPLBUFL bytes of data and put the actual
           length in RPLRLEN.  In both cases, the first byte of
           RPLFDBWD gets a summary I/O status code with one of three
           values:
0             Value   Name      Meaning
              0       RPLNOERR  Normal end to request
              8       RPLLOGER  Logical error (including end of file)
             12       RPLPHYER  Physical error
0          The third byte of RPLFDBWD, which can be accessed under the
           label of RPLERRCD, is assigned a more detailed reason code.
           Since the interface is based on pseudo-VSAM, the error codes
           are taken from Figures 6 and 7 in the VSAM Programmer's
+                                                ____ ____________
           Guide.  These error codes are given symbolic names by the
+          _____
           IDARMRCD macro.  The most likely error values are:
0             Value   Name      Meaning
                4     RPLEODER  End of file
               2C     RPLINBUF  Input buffer too small
               44     RPLINACC  GET to output or PUT to input dataset
               6C     RPLINLEN  RPLRECL is invalid (0, too small, too
           big)
0             All of the fields documented here would be part of any
           possible interface. Imbedding the information in a VSAM
           structure doesn't really add to the work.  There is one
           delicate issue, and GPSAM makes it easy. If you want to
           signal an abnormal condition (end of file, logical, or
           physical error) then any appropriate exit routine which the
           ACB points to should be called. The full required exit
           processing logic is supplied by entry point GPSMEXIT in the
           supplied GPSMSUBS module which can be linkedited with your
           access method module. You simply set the correct feedback
           code, then branch to that entry point to decide if an exit
           should be called.
-
-
-
                                      - 7 -
1
-
                          6.  CONCERNING DCB PARAMETERS
+                         6.  CONCERNING DCB PARAMETERS
0             Unlike JES files, there is no default DCB information for
           a GPSM dataset. Therefore, if the program does not provide
           such defaults, so RECFM, LRECL, and BLKSIZE must be given
           when the file is defined. Since a subsystem processes
           unblocked records, and since it does only synchronous I/O,
           the RECFM should be F, V, or U but should not be B (blocked)
           or S (spanned).  BUFNO should be 1, since a larger value for
           BUFNO can cause FORTRAN to read-ahead, issuing a GET for the
           next record before processing the previous one.
0             In batch the DCB information can be provided on the DD
           card in the usual manner:
0             //ddname DD SUBSYS=(GPSM,module,'parameter'),
              // DCB=(RECFM=U,BLKSIZE=80,BUFNO=1)
0          In TSO the GPSMDD command accepts RECFM and LRECL keywords:
0             GPSMDD ddname module 'parameter' RECFM(U) LRECL(80)
0          GPSMDD calculates the BLKSIZE based on LRECL and defaults
           BUFNO to 1.
-
                                 7.  INSTALLATION
+                                7.  INSTALLATION
0             The first step in installation is to define the name
           "GPSM" as a subsystem, since this will not take effect until
           the next IPL. Consult the correct level of the IBM manual
           System Programming Library: Job Management for information
+          ______ ___________ _______  ___ __________
           on the definition of a new subsystem. Up to MVS SP1.1 it is
           necessary to use AMASPZAP to place an entry in the IEFJSSNT
           module in SYS1.LINKLIB. After SP 1.3 it is possible to
           change the IEFJSSxx member of SYS1.PARMLIB.
0             There are some supplied examples of GPSM access method
           routines, but the GPSAM system proper consists of only four
           modules:
0          Name      Library  Attrib     Function
           GPSAM     LPA      RENT,AC=1  Subsystem code itself
           GPSMOPEN  LNKLST   RENT       Handles the open and close
           GPSMSUBS  SYSLIB              Subroutine for access method module
           GPSMDD    CMDLIB              TSO command to allocate GPSM dataset
0          The distributed material consists of a documentation file
           (you are reading it) and the source. The user must assemble
           the source routines and link the object decks into the
           appropriate libraries.
-
                                      - 8 -
1
-
              The distributed source is a sequential dataset which can
           be used as input to the IEBUPDTE utility to generate a
           partitioned dataset:
0             //GPSM EXEC PGM=IEBUPDTE,PARM=NEW
              //SYSPRINT DD DUMMY
              //SYSUT2 DD DSN=????.GPSAM.ASM,DISP=(,CATLG),UNIT= ...
              //SYSIN DD ... (describe input tape)
0          If GPSAM was received by itself the source is the second
           file on the tape (this document is the first file). If GPSAM
           is being distributed on a mods tape, then follow the
           instructions of the mods tape authors in unloading the file.
0             The source PDS also contains macros which are required
           for assembly.  When assembling any of the GPSAM routines,
           the SYSLIB should be defined as:
0             //SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
              //       DD DSN=SYS1.AMODGEN,DISP=SHR
              //       DD DSN=????.GPSAM.ASM,DISP=SHR
0             No linkedit job stream is supplied with the package, but
           the following example can be followed as a model.  Please
           read carefully the discussion which follows it to understand
           the attributes of each module which is being created.
-
-
-
-
-
-
-
-
-
-                                     - 9 -
1
-
           //GPSMLINK JOB
           //**************************************************************/
           //*    SAMPLE JOB TO INSTALL GPSAM ROUTINES                    */
           //*    YOU CHANGE THE DATASET NAMES TO MATCH LOCAL REQUIREMENTS*/
           //*    ASSUMES A "LKED" PROC IN PROCLIB                        */
           //**************************************************************/
           //GPSAM EXEC LKED,PARM='RENT,REUS,AC=1'
           //**************************************************************/
           //*    LINK THE GPSAM MODULE INTO LPALIB                       */
           //*    NOT MUCH CHOICE HERE, THE MODULE MUST GO IN THE LINK    */
           //*      PACK, ALTHOUGH FOR TEST PURPOSES IT CAN BE MLPA'ED    */
           //*      INTO THE SYSTEM.                                      */
           //**************************************************************/
           //SYSLMOD DD DSN=SYS1.LPALIB,DISP=SHR
           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR
            INCLUDE GPSAM(GPSAM)
            ALIAS GPSAMEND
            NAME GPSAM
           //GPSMOPEN EXEC LKED,PARM='RENT,REUS'
           //**************************************************************/
           //*    LINK THE GPSMOPEN MODULE INTO THE LINKLIST              */
           //*    FOR TEST PURPOSES, THIS MODULE CAN COME FROM A STEPLIB  */
           //*      PROVIDED THAT THE LIBRARY IS IN THE APF LIST.         */
           //**************************************************************/
           //SYSLMOD DD DSN=????.LINKLIB,DISP=SHR
           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR
            INCLUDE GPSAM(GPSMOPEN)
            NAME GPSMOPEN
           //GPSMDD   EXEC LKED
           //**************************************************************/
           //*    LINK THE GPSMDD MODULE INTO A TSO COMMAND LIBRARY       */
           //*    NOTE THAT IT IS NOT REENTRANT AND CANNOT GO IN LPALIB   */
           //*      ANY MEMBER OF THE LINKLIST WILL DO.                   */
           //**************************************************************/
           //SYSLMOD DD DSN=????.CMDLIB,DISP=SHR
           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR
            INCLUDE GPSAM(GPSMDD)
            NAME GPSMDD
           //GPSMDD   EXEC LKED
           //**************************************************************/
           //*    LINK A SAMPLE ACCESS METHOD ROUTINE INTO SOME           */
           //*      USER LIBRARY. THIS ROUTINE PERMITS LOWERCASE INPUT    */
           //*      FROM A TERMINAL. THIS STEP IS OPTIONAL IF YOU DON'T   */
           //*      NEED THIS ROUTINE. IT IS JUST A SAMPLE OF GPSM USE.   */
           //**************************************************************/
           //SYSLMOD DD DSN=????.LINKLIB,DISP=SHR
           //GPSAM DD DSN=GPSAM.OBJ,DISP=SHR
            INCLUDE GPSAM(LOWCASAM)
            INCLUDE GPSAM(GPSMSUBS)
            NAME LOWCASAM
-
-                                     - 10 -
1
-
              GPSAM is the only authorized module in the package.  It
           contains all the subsystem exit routines and the SSVT
           control block.  The GPSAM main entry point initializes the
           subsystem. The module has a optional alternate entry point
           GPSAMEND which can be defined by an ALIAS card and run to
           deactivate the subsystem. There should never be any real
           need to use GPSAMEND unless you are modifying the GPSAM
           program itself.
0             The GPSAM OPEN exit issues a LOAD macro for the entry
           point name GPSMOPEN and uses the SYNCH macro to pass control
           to it as a problem state exit.  The substantive part of OPEN
           and CLOSE processing is done by this module.  While GPSMOPEN
           could be in LPALIB, it is usually kept in one of the
           libraries of the LNKLST concatenation instead.  This makes
           it easier to modify if you want to test new versions.
           Alternate versions of GPSMOPEN can also be supplied in a
           STEPLIB if the library is APF authorized.  While GPSMOPEN
           runs in problem state, it has certain integrity checking
           functions to perform and can only be modified by system
           programmers.  For this reason, GPSAM is careful to restrict
           the loading of GPSMOPEN from only an APF library.
0             GPSMSUBS is intended to contain subroutines which will be
           helpful to the user supplied access method modules.
           Currently the only such subroutine is GPSMEXIT which
           provides the common error analysis and exit list processing
           logic.  It can be kept in object form or linked into a local
           subroutine library and used later to build the access method
           module.  It is itself reentrant and should be given the REEN
           attribute in case the rest of the access method module is
           also reentrant.
0             GPSMDD is a TSO command which can be used to allocate a
           GPSM dataset. It is not reentrant and thus cannot go in
           LPALIB.  It should be placed somewhere in the LNKLST
           concatenation so it can be conveniently accessed by TSO
           users.
0             It is also important to provide a procedure which can be
           used to initialize GPSAM. A suggestion is to add a member to
           PROCLIB:
0             ./ ADD NAME=GPSAM
              //GPSAM EXEC PGM=GPSAM
0          Once the system goes into production, some provision should
           be made to issue the "S GPSAM" command at IPL.
-
-
0                                     - 11 -
1
-
                               8.  SYSTEM INTEGRITY
+                              8.  SYSTEM INTEGRITY
0             The thing about GPSAM is that it allows the user through
           JCL to specify the loading of an arbitrary module while any
           other program is running. No problem exists if the program
           opening the dataset is unauthorized, but in the authorized
           case some care must be given to preserve MVS integrity.
0             The security checks are built into the GPSMOPEN module.
           This module is itself loaded by the GPSAM exits while they
           are in supervisor state, so the normal operating system LOAD
           macro processing will ensure that GPSMOPEN can only come
           from an APF library and is therefore itself valid.
0             GPSMOPEN checks to see if the current jobstep is APF
           authorized.  If so, then the access method module must come
           from an APF library (LOAD will take care of this check
           automatically). But in addition, the access method module
           name must be in a table of specially approved access method
           routines assembled into GPSMOPEN itself. This extra check is
           added because any module in any APF library could otherwise
+                        ___
           be loaded through GPSAM into an authorized but unexpected
           environment. With thousands of modules to choose from, some
           routine could probably be found which would misinterpret the
           parameters passed by GPSMOPEN and cause trouble to the
           system.
0             One problem which could not be solved by simple
           limitations is the use of a GPSM dataset by a program which
           is in supervisor state or system key when it opens the file
           but which is not APF authorized and has a problem state TCB
           protect key. The only likely such situation is a dataset
           opened by an SVC routine running under an unauthorized task.
           The LOAD macro will limit the source of the module to an APF
           library if the program doing the LOAD is 1) APF authorized,
           2) supervisor state, or 3) system key. GPSMOPEN never meets
           tests 2 and 3, and if the jobstep is not APF then LOAD will
           let the access method module come from anywhere. We cannot
           pass back an arbitrary module entry point to a routine which
           is itself in supervisor state and may be expected to branch
           to this unknown module. This problem could not be solved by
           table lookup, so GPSAM enforces a flat prohibition on its
           use by any program which is supervisor or system key but not
           also APF.
-
-
-
-                                     - 12 -
1
-
                           9.  PROGRAMMING RESTRICTIONS
+                          9.  PROGRAMMING RESTRICTIONS
0             The GPSMOPEN program and the main entry point of the user
           access method module run as exits of the OPEN SVC. The
           system is holding an ENQ on one of the control blocks for
           this dataset under the major name SYSZTIOT and this ENQ is
           in conflict with any attempt to dynamically allocate any
           dataset through SVC 99. This does not prevent other files
           from being opened, it just prevents new allocations. Thus
           files needed by your program at OPEN time, including all
           catalogs accessed thorugh LOCATE, must already be allocated
           before the OPEN occurs.
-
                       10.  WRITING AN ACCESS METHOD MODULE
+                      10.  WRITING AN ACCESS METHOD MODULE
0             The elements of a user written access method module are
           illustrated by examples from the distributed LOWCASAM
           routine.  It turns file input requests from a program into
           terminal input requests though the TGET macro, but without
           the translation of lower case to upper case associated with
           normal DA(*) input datasets.
0             The main entry point of the access method routine is
           called by GPSMOPEN using standard subroutine linkage. On
           entry, R1 points to a parameter block/work area:
0          AMPARM   DSECT
           GPSMMPRM DS    A                  POINTER TO MODULE PARM
           GPSMSSOB DS    A                  POINT TO OPEN SSOB
           GPSMAMEP DS    A                  RETURN ACB AM ENTRY POINT
           GPSMSAVA DS    A                  WORD TO SAVE FOR CLOSE
           GPSMDDN  DS    CL8                DDNAME
                    DS    16A                WORK AREA
0          GPSMMPRM is the address of the parameter field from file
           allocation (either the third SUBSYS parameter in batch or
           the third positional parameter on the GPSMDD TSO command).
           This pointer is 0 if no parameter exists. The format of the
           parameter is a one byte length field followed by the
+                         ___ ____
           character string. Quotes used to delimit the parameter will
           have been removed.
0             The GPSMSSOB field points to the Subsystem Options Block
           created by OPEN to process this request. It is mapped by the
           statement:
0                   IEFJSSOB DA
0          And its format can be found in the MVS Debugging Handbook.
           There are three useful fields in this block:
-
                                      - 13 -
1
-
             SSOBFUNC  which contains the request code
                       (SSOBOPEN for OPEN, SSOBCLOS for CLOSE).
             SSDAJFCB  which points to the JFCB for the dataset.
             SSDADEBP  which points to the DEB. The DEBDCBAD field in
           turn
                       points to a protected copy of the ACB.
-             GPSMDDN has the ddname for the dataset being opened. This
           seems to be the most useful item which is not in the control
           blocks passed direcly through the SSOB. Other control blocks
           for the dataset (like the DSAB and the SIOT) can be found
           using algorithms which can be copied from GPSMOPEN source.
0             GPSMAMEP must be filled in with the entry point which
           handles I/O macro requests (GET, PUT, etc.). This is the
           only function which the main entry point of the access
           method routine must perform.
0          LOWCASAM CSECT
                    USING *,R15
                    SAVE  (14,12),,*
                    LR    R10,R15
                    USING LOWCASAM,R10
                    DROP  R15
                    LR    R2,R1
                    USING AMPARM,R2
                    L     R6,GPSMSSOB        GET SSOB POINTER
                    USING SSOB,R6            NOW CHAIN DOWN TO ACB
           OPENCLOS    IF    (SSOBFUNC+1,EQ,SSOBOPEN,CLI),THEN
           *              ******************************************************
           *              * FUNCTION IS OPEN.                                  *
           *              ******************************************************
                          LA    R1,PUTGET          PLACE PUT/GET ENTRY POINT
                          ST    R1,GPSMAMEP        IN PARAMETER BLOCK
                          MVC   BADIODD,GPSMDDN    SAVE DDNAME FOR MESSAGES
                       ELSE  ,
           *              ******************************************************
           *              * THE FUNCTION IS CLOSE                              *
           *              ******************************************************
           *              (NOTHING DONE AT CLOSE TIME)
                       BEND  OPENCLOS
                    SPACE 5
           RET      L     R13,4(R13)         BACK TO SAVE1
                    RETURN (14,12),RC=0
                    DROP  ,
-             In the previous code, the entry point for normal I/O is
           called PUTGET.  The SAM access method branches to this entry
           point using the PUT or GET macros with the RPL= keyword
           (VSAM syntax). The expansion of these macros generates the
           following statements:
-                                     - 14 -
1
-
                    L     R1,RPL
                    LA    R0,function
                    L     R15,24(R1)         POINT TO ACB
                    L     R15,8(R1)          POINT TO MY ENTRY POINT
                    BALR  R14,R15
0          The function code in r0 is 0 for a GET and 1 for a PUT.
           These are the only functions which you are known to have to
           support, though JES has support for NOTE, POINT, CHECK, and
           ENDREQ and so these codes might be considered for
           comprehensive support. The LOWCASAM module supports the GET
           file I/O request by issuing a TGET terminal I/O request,
           checks for "/*" to signal end of file, and rejects output
           requests with a friendly but firm message.
0          PUTGET      BLOCK ,
                       SAVE  (14,12)
                       BALR  R12,0
                       USING *,R12
                          IF    (R0,EQ,0),THEN     IF ITS A GET
                             LR    R2,R1              SAVE RPL ADDRESS
                             USING IFGRPL,R2
                             L     R1,RPLAREA         PICK UP BUFFER
                             LR    R3,R1
                             L     R0,RPLBUFL         GET BUFFER LENGTH
                             TGET  (1),(0),EDIT       READ DATA
                             ST    R1,RPLRLEN
                                IF    (R1,GE,2),AND,     LOOK FOR "/*"
                                         (0(2,R3),EQ,SLSHSTAR,CLC)
                                   MVC   RPLFDBK,EOFCODE
                                ELSE  ,
                                   XC    RPLFDBK,RPLFDBK
                                BEND  ,
                          ELSE  ,
                             TPUT  BADIO,LBADIO
                             MVC   RPLFDBK,ERRCODE
                          BEND  ,
                       LR    R1,R2
                       L     R15,=V(GPSMEXIT)
                       BR    R15
                       BEND  PUTGET
-             Note that the exit from the routine is through the
           GPSMEXIT subroutine. It analyzes the error return code and
           passes control to the appropriate ACB exit routine if one
           exists.
0             While it is possible for an access method routine to get
           more complicated, the extra code would be required by the
           function which it performs and not the GPSAM linkage or
           conventions.
-
                                      - 15 -
1
-
                      11.  PROGRAM DEVELOPMENT AND DEBUGGING
+                     11.  PROGRAM DEVELOPMENT AND DEBUGGING
0             Since the user supplied access method module is an
           unauthorized subroutine of your program, you can debug it
           using the standard facilities of TSO TEST. Your task is the
           same as in the development of any application program. The
           author of GPSAM, however, has no pratical hints on the use
           of TEST because he used the the much more powerful locally
           developed debugging program Debugging Controller (DBC)¥.
           DBC operates as the ESTAE exit of the program being debugged
           or as the ESTAI of the attaching task.  TEST is intended to
           handle simple user applications, but DBC was designed for
           more complicated system programming tasks. It has a more
           comprehensive view of the operating system and can map
           external names and, if the module is linked with the TEST
           option, internal labels of any routine in the system
           (including mapping nucleus CSECTS or LPA modules). It has a
           more sophisticated understanding of MVS task structure and
           provides more information on TCB and RB attributes. It not
           only disassembles and labels instructions in the program,
           but can read DSECT definitions from the symbols of a load
           module and can format all system and user control blocks.
           It also can single step through a program or let
           instructions execute up to the next branch.
0             No special preparation is required to use DBC on the
           access method (GET/PUT) part of the modules.  On the other
           hand, the part that runs at OPEN time runs under the OPEN
           ESTAE exit and use of DBC in this environment requires the
           establishment of a local overriding ESTAE environment. This
           step is built into each supplied module, but is disabled by
           default. To use it, the high order bit of the storage
           location FLAGWORD should be set to 1.
0             If the access method module is linkedited with the TEST
           and REUS attributes, it can be preloaded by the debugger and
           breakpoints can be established before the main program even
           begins execution. When the module goes into a production
           library, however, it should not be marked reusable unless it
           is also reentrant.
0             Since the parts of GPSAM which run during OPEN cannot use
           dynamic allocation, all module to be mapped must be
           preloaded and mapped before the OPEN process begins.  While
           it is not necessary for ordinary users to run authorized
           when using GPSAM, the authors have found that debugginf of
           the OPEN code in an APF authorized state is easier, since
           ××××××××××××××××××××
-          ¥ DBC is distributed as a Yale program product at a
             relatively low cost through a third party.  For
             information on DBC, contact Computer Systems Research at
             203-678-1212.
0                                     - 16 -
1
-
           DBC can use system subpools for communication between tasks
           and request block levels. Thus a typical session to debug
           changes in GPSMOPEN would start out as follows (human input
           in lower case, program response in upper case):
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
                                      - 17 -
1
-
            apf dbccall iebgener
            DBC830I DBC V4.3 ENTERED PRIVILEGED UNDER RB#3 FROM TCB#5
            DBC831I THE ERROR LEVEL AND RETRY LEVEL ENVIRONMENTS ARE
           THE SAME
            DBC841I DEAD MSG 454 *** TO START PROGRAM EXECUTION, TYPE
           GO ***
            DBC
            load gpsmopen; map gpsmopen gilbert.gpsam.load; set q
           gpsmopen
            NAME      TCB#  RB#  LOCATION  COUNT  ATTRIBUTES
            IEBGENER  5     1    DBCCALL   2      3D02, RENT, REUS,
           MINOR, NOXTL
            GPSMOPEN  5          JPA KEY0  1      3122, RENT, REUS
            IEBGENER  5          JPA       1      0322
            MAPPING GPSMOPEN FROM GILBERT.GPSAM.LOAD
            MAPPING GPSMOPEN.GPSMOPEN
            DEFAULT MODULE NAME IS GPSMOPEN
            DEFAULT  CSECT NAME IS GPSMOPEN
            DBC
            zap .flagword=80
            DBC
            go
            DATA SET UTILITY - GENERATE
            /*
            DBC830I DBC V4.3 ENTERED PRIVILEGED UNDER RB#6 FROM TCB#5
            DBC831I THE ERROR LEVEL AND RETRY LEVEL ENVIRONMENTS ARE
           THE SAME
            DBC841I DEAD MSG 1
            DBC
            dmap .ssob;dm .ifgacb;dm .gpsmparm
            MAPPING SSOB FROM GILBERT.GPSAM.LOAD(GPSMOPEN)
            MAPPING IFGACB FROM GILBERT.GPSAM.LOAD(GPSMOPEN)
            MAPPING GPSMPARM FROM GILBERT.GPSAM.LOAD(GPSMOPEN)
            DBC
            format
            0B85C2  ---  GPSMOPEN.GPSMOPEN+00006A
            0B85C2                   EN1@1    EQU   *
            0B85C2  5830 2010        EL1@1    L     R3,10(,R2)
            0B85C6  5840 300C                 L     R4,C(,R3)
            0B85CA  5850 4018                 L     R5,18(,R4)
            0B85CE  5830 3008                 L     R3,8(,R3)
            DBC
            list rbs
            RB#  TYPE   CREATED BY   NAME          CURRENT EXECUTION
           LOCATION
            1    PRB    ATTACH       IEBGENER      IEBGENER.X#1+0001F2
            2    SVRB   SVC  19      OPEN          IFG019RA+0009FA
            3    PRB    SYNCH                      IEBGENER.X#1+00039A
            4    SVRB   SVC  19      OPEN          IGG0199G+0000C4
            5    SVRB   SVC  22      OPEN-J        COMMON+18E896
            6    PRB    SYNCH                      GPSMOPEN+000064
            7    SVRB   #DIE TRAP    ABEND-0C1     IGC0001C.X#1+001F58
            8    PRB    SYNCH                      DBC+00E58E (RETRY
           LEVEL)
0                                     - 18 -
1
-
           and so on setting breakpoints, single stepping through code,
           and displaying formatted system control blocks. The entire
           GPSAM package was written by one person in one week using
           DBC; without the debugging package it might never have been
           written.
-
                            12.  FUTURES AND RESEARCH
+                           12.  FUTURES AND RESEARCH
0             This first version of GPSAM demonstrates 1) that the
           thing is workable, 2) that there is very little code
           involved, and 3) that it can be turned over to "end users"
           with full system integrity. It gives everyone a thing to
           play with, and does so little that it can do nothing wrong.
           That is not the same thing, however, as providing all the
           desirable function.
0             One of the things I feel bad about is that there is no
           subsystem specific default DCB information. JES does that at
           allocation time, but in this system it must be done at OPEN
           time and I am not sure if that is too late and what must be
           done to carry it off. This is a topic for research.
0             The application program can open an ACB to talk to the
           subsystem directly. This would allow simulation of all forms
           of RPL requests (keyed VSAM, RBA VSAM, VTAM, etc.).  One
           question which is not clear is how much of the ACB must be
           filled in to carry this off. PLIX will ABEND with an OC4 if
           you open a file which claims to be VSAM to a SUBSYS dataset.
           It is clear that VSAM is looking in the ACB for other
           pointers (to the AMB?) but there is no clear documentation
           on the fields which must be faked in order to allow the OPEN
           to be accepted. This is also a research project.
-
-
-
-
-
-
-
                                      - 19 -
1
-
                                 HAL (Version 2)
0                     Structured Macros for 370 and Series/1
0                              Yale Computer Center
-
-             The Handy Assembler Language (HAL) macros provide support
           for structured programming techniques in IBM assembler
           language coding. There are other macro systems for this
           purpose, but HAL has some advantages:
0             ® HAL is a single maclib member included at the beginning
                of an assembly with the COPY statement and therefore
                looks to the assembler as "inline" macros. Thus the HAL
                macros avoid any name conflicts with other MACLIB
                members with the same names.
0             ® HAL is not copyrighted or proprietary in any way. You
                can therefore use it to write your own programs and can
                freely distribute it to anyone. Most other structured
                macro systems are tied to some kind of program product.
0             ® HAL is available in two versions, one for IBM
                370/303x/4300 computers and one for the GSD Series/1
                minicomputer.  Furthermore, it is probably possible to
                extend HAL to any other computer system with a standard
                IBM-like assembler.
0             Note that we are not going to claim among its advantages
           that HAL is the "best" structured programming macro system
           which can be developed. That is a subjective judgement which
           simply is not worth arguing over. HAL works. We have found
           it to be very valuable in our own coding projects.  People
           who are more interested in programming languages than in
           programming itself will probably not like HAL.  People who
           understand the requirements of serious software production
           may prefer this usable simple little system over more
           technically virtuous but less practically usable macro and
           preprocessor alternatives.
0             There are three objectives of HAL. First, it makes
           complicated software easier to program. Secondly, it reduces
           the probability of certain kinds of logical errors by
           encouraging more careful program design and by providing
           programming structures which more closely resemble the
           origninal design constructs. Finally, a program written in
           HAL is easier to read than one written in unstructured
           assembly, making subsequent maintenance easier and more
           reliable.
-                                     - 1 -
1
-
              The reader is assumed to be familiar with assembler
           language and with the common higher level language
           structures "IF-THEN-ELSE", "DO WHILE", "LEAVE blockname",
           and so on. The syntax of the various HAL statements will be
           comprehensively documented below, but most programmers will
           have little difficulty in following some simple examples
           first which will provide a better view into the HAL concepts
           and the programming structures which can be built using the
           macros.
0             There have been experiments in several places with the
           use of assembler source indentation to represent the block
+                           ______
           structure of certain programs. The results appear favorable
           to simple numeric computations or string handling and
           lexical routines, but are quite unsatisfactory when applied
           to system programming with extensive use of operating system
           macro calls, much larger program modules, and more extensive
           commenting requirements. HAL was originally designed to be
           fairly readable without any indentation at all. Subsequently
           we built a small formatting program to take the HAL source
           in its 80 column card image file and expand it across a 132
           column printer page with proper indentation and pagination.
           There are two versions of this formatting program. The 370
           version is itself written in 370 HAL. The Series/1 version
           is written in the EDX native language.  We have found that
           the best technique of program development is to use the
           HALFMT listing output to highlight and summarize overall
           program structure while using the assembler listing to get
           offset information in DSECTS and executable code for
           interactive debugging and to get symbol usage
           crossreferences.
0             A program written in HAL is divided up into blocks. Each
           block begins with one of the HAL structure macros and ends
           with the common block end macro BEND.
0             The BLOCK block:
                    name      BLOCK ,
                              ...
                              BEND  name
0             The simple IF block:
                    Ýname¨    IF    (logical test),THEN
                              ...
                              BEND  Ýname¨
0             The IF-ELSE block:
                    Ýname¨    IF    (logical test),THEN
                              Ýtrue code¨
                              ELSE  ,
                              Ýfalse code¨
                              BEND  Ýname¨
-
                                      - 2 -
1
-
              The unconditional DO loop:
                    name      DO    INF
                              ...
                              LEAVE name,IF,(logical expression)
                              ...
                              BEND  name
0             The conditional DO loop:
                    name      DO    UNTIL|WHILE,(logical expression)
                              ...
                              BEND  name
0             The multiple choice ("case" or "select"):
                    name      IF    (logical expression),THEN
                              Ýcase 1 code¨
                              ELSEIF (logical expression),THEN
                              Ýcase 2 code¨
                              ....
                              ELSE  ,
                              Ýall other cases¨
                              BEND  name
-             The DO macro introduces a looping program structure. The
           statements in the block will be executed repeatedly, subject
           to an exit condition.  In a DO WHILE block a logical
           expression is evaluated before the first and all subsequent
           executions of the block and exit is made when the condition
           evaluates FALSE. In a DO UNTIL block, the logical expression
           is evaluated after the execution of the block, and exit is
           made when the condition evaluates as TRUE.  In a DO
           INFinite, the user must supply his own exit condition either
           with a LEAVE or EXIT statement (see below) or by the native
           exceptional condition handling of the operating system (such
           as the EODAD option for end-of-file processing on the 370).
0             An IF block contains a THEN clause and optionally an ELSE
           clause. Subject to a test established in the IF macro, the
           THEN clause may be executed or control may pass instead to
           the ELSE clause (or the end of the block if no ELSE clause
           exists).  The simple IF statement can be generalized to
           three or more mutually exclusive alternatives with
           additional ELSEIF clauses between the original IF and the
           ELSE macro. The logical expressions on the IF and on each
           ELSEIF will be evaluated in turn, and the first test which
           evaluates "true" will cause the following clause to be
           executed following which control will be transferred to the
           BEND location. If a final ELSE is present, the last clause
           will always be executed if all previous tests have failed.
           If no ELSE is provided, no clause will be executed if all
           tests fail.
-
0                                     - 3 -
1
-
              A BLOCK macro introduces a simple non-iterative,
           unconditional block.  It is a similar to the "DO;" of PL/I.
           The existence of the BLOCK does not effect any other macros
           or scope-of-names and does not produce any executable
           statements. It can help, however, to organize the program
           and to clarify the relationships of groups of statements.
           One use of the BLOCK statement is simply to provide
           appropriate indentation in the output listing of the HALFMT
           program. Whenever a particuar range of statements jointly
           perform a specific function, enclosing them in a BLOCK (and
           putting a block comment at the front of the BLOCK to state
           their purpose, assumptions, inputs, and outputs) can be a
           very effective program commentary tool.  The BLOCK can also
           be named in a LEAVE statement, providing a structured
           programming tool to avoid GOTO.  Finally, the BLOCK
           structure provides a method of reflecting in HAL program
           structures which derive from other hardware or operating
           system conventions which are not otherwise supported
           expicitly in HAL. For example, a loop governed by a
           branch-on-count or BXLE instruction, an asynchronous exit,
           or an internal procedure can be enclosed in a HAL block.
0                             BAL   R14,MYSUB
                              ...
                    MYSUB     BLOCK ,
                              Ýsubroutine¨
                              BR    R14
                              BEND  MYSUB
-             A block is given a label from the name field of the
           BLOCK, DO, or IF macro which begins it. Block labels are
           optional on innermost blocks.  It is good practice to label
           anything except a very short IF or DO group.
0             There is a LEAVE macro which allows one to transfer
           control out of an enclosing block. LEAVE will usually branch
           to the statement following the BEND, so used in a THEN or
           ELSE clause, it will terminate the entire IF block.  There
           are special considerations for LEAVE when one is in a BLOCK
           with an "epilog".  An epilog is a section of code at the end
           of a BLOCK block which performs some required cleanup or
           termination function.  One indicates that an epilog exists
           by coding "BLOCK EPILOG=YES" and one signifies the start of
           the epilog with an EPILOG macro.
0             The concept of EPILOG is not part of any common higher
           level languages, yet we have found that it represents one of
           the most valuable contributions of HAL to proper structuring
           of system programs. Often a program will acquire a resource
           or modify the system in some manner which requires a
           corresponding cleanup action later in the program. In MVS
           some examples of common services and their cleanup include
-                                     - 4 -
1
-
           OPEN-CLOSE, ENQ-DEQ, GETMAIN-FREEMAIN, and balanced uses of
           SETLOCK, SETFRR, ESTAE, and MODESET.  On the Series/1, an
           epilog may be appropriate to balance EN and DIS, match IOPK
           or SEAKR instructions, balance push and pop requests,
           balance temporary register reassignments with IR, or simply
           to hold the LMB on a return.  EPILOG provides a program
           structure which explicitly reflects the altered internal
           environment of the block and the unfinished business which
           must be transacted before exit.
0             A LEAVE statement for a block with an epilog transfers
           control to the statement following the EPILOG macro.  One
           cannot LEAVE an outer block from within any BLOCK with an
           epilog.
0          PROCESS  BLOCK
                    ....
           SPECIAL  BLOCK EPILOG=YES
                    ....
                    LEAVE PROCESS   ***
                    ....
                    EPILOG SPECIAL
                    ....
                    BEND  SPECIAL
                    BEND  PROCESS
0          The LEAVE statement marked above is illegal because any
           attempt to leave block PROCESS at that point would bypass
           the cleanup in the epilog for inner block SPECIAL.
0             The DO and IF macros make use of logical expressions to
           decide if the loop is to iterate again or which clause is to
           be executed.  All logical expressions have a common syntax
           which represents a compromise between assembler macro
           language and common higher level language concepts. The
           normal simple logical expression consists of an operand,
           relation, and second operand, optionally followed by a
           machine instruction which will set the condition code:
           "(op1,rel,op3)" or "(op1,rel,op3,inst)".
0                   (R0,LE,4)
                    (PGMNAME,EQ,MYPROG,CLC)
                    (BITFLGS,ON,BIT8)
0          The relation "rel" is used to form a branch or jump
           condition.  There are arithmetic and bit test relations.
           Each relation has a positive form (GT) and a negative form
           (NGT) formed by prefixing the positive relation with the
           letter "N".  The permissible positive relations are:
0             Arithmetic relations for both systems
                 EQ, NE, GT, LT, GE, LE
              Arithmetic 370 relations
                 H, L, P, N, Z
0                                     - 5 -
1
-
              Arithmetic Series/1 relations
                 LLT, LGT, LLE, LGE
              Bit relations on both systems
                 ON, OFF, MIX
              Bit relations on 370
                 O, Z, M
0          If the user supplies an explicit condition code setting
           instruction as the fourth positional parameter of the
           logical expression sublist, then the macro expands this
           logical test to:
0                   370                           Series/1
0                    inst   op1,op3               inst  op3,op1
                     Bxx    yyyy                  Jxx   yyyy
0          where xx is a condition calculated by the relation, and yyyy
           is the label of a statement block determined by context.
           Note that the order of the two operands is reversed
           following the normal Series/1 conventions. The programmer
           codes the logical expressions the same way for either system
           and the macro system generates the correct form.
0                   (R4,LT,XYZDATA)
0          In a register storage or register literal operation the
           register should come first.  The condition test is
           calculated so that the relation reads correctly left to
           right no matter how the operands are actually ordered.
           Therefore, the above expression evaluates true if the
           contents of R4 are less than the contents of the word at
           storage location XYZDATA.
0             Assembler macros cannot determine the data types of their
           arguments, so if the instruction is not explicitly given, an
           assumption must be made about the operands and the
           appropriate instruction to use.  The default instructions
           are determined by examining the relation and the third
           operand. For arithmetic relations the default operation is:
0             OP3        Series/1            370
0             0          CWI  0,op1          LTR  op1,op1
              number     CWI  op3,op1        CH   op1,=H'op3'
              symbol     CW   op3,op1        C    op1,op3
0          For logical relations ON, OFF, and MIX, the Series/1 default
           is TWI and the 370 default is the TM instruction.
0             It is possible for the condition code to be set by an
           arithmetic instruction, but the use of arithmetic
           instructions in a logical expression is difficult to follow.
-                                     - 6 -
1
-
           Instead, the user should use the degenerate form of the
           logical expression which only provide the relation.  If you
           wish to add a value to a register, then execute some code
           only if the result is positive, you could do it with a
           tricky use of the macro system:
0                             IF    (R4,NP,XYZDATA,A),THEN
0          Instead, it is better to use the more direct form:
0                             A     R4,XYZDATA
                              IF    NP,THEN
0          which is much easier to read.
0             Simple relations can be strung together by the logical
           relations AND and OR. Evaluation of logical expressions
           occurs from left to right. If the next conjuction is OR and
           the previous expression was true, a branch is generated to
           the "true" block. If the next conjunction is AND and the
           previous relation evaluated as false, a branch is generated
           to the "false" block. Otherwise, evaluation continues.
0                             IF    (R0,EQ,0),OR,(OP,EQ,ENDER,CLC)
                              DO    WHILE,(XYZFLG,OFF,ENDFLG),AND,
                                    (XYZDATA,GT,MINDATA),AND,
                                    (XYZDATA,LT,MAXDATA)
-             Some note should be made of the statement labels generate
           by HAL. Every block expands to a STart, ELse, and ENd label.
           Except for an IF block with an ELSE macro, the EL and EN
           labels occur together. The first number in the label
           indicates a level of block nesting.  The second number
           (following "@") is a unique block counter for that nesting
           level.
-
-
-
-
-
-
0                                     - 7 -
1
-
                               Macro Syntax Summary
0          Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |    blabel    |  BLOCK    EPILOG=YES                      |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             The BLOCK macro begins a block of statements. The block
           ends with the next balancing BEND statement. The primary
           purpose of a BLOCK is to provide a target for the LEAVE
           macro. The EPILOG option inhibits one from accidentally
           LEAVEing the block without executing necessary cleanup
           operations.  The block label "blabel" is syntactically
           optional, but an unlabelled BLOCK cannot have inner IF or DO
           blocks and is therefore hardly worth defining.
-
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |              |  BEND     Ýblabel¨                        |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             The BEND statement ends a BLOCK, DO, or IF block of
           statements. The BEND statement never has a label. The
           "blabel" operand must match the block label on the macro
           which began the block.
-
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |    Ýlabel¨   |  EPILOG    blabel                         |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             This macro begins the epilog section of a BLOCK
           EPILOG=YES group of statements. It is illegal in any other
           kind of block.  The epilog section extends to the BEND which
           ends the complete block.
-
-
0                                     - 8 -
1
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |    Ýlabel¨   |  LEAVE     blabelÝ,IF, exp¨               |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             This macro can be used to exit from a BLOCK, IF, ELSE, or
           DO block of statements. It usually transfers control to the
           statement after the BEND which ends the block. In the case
           of a BLOCK EPILOG=YES where the EPILOG macro has not been
           encountered, LEAVE branches to the statement after the
           EPILOG macro.  The "blabel" can name an outer block in which
           the current statement is nested, but the LEAVE macro will
           not permit the bypassing an EPILOG.  If the "IF" clause
           appears trailed by logical expressions, the transfer out of
           block will be conditioned by these tests.  On the Series/1,
           enclosing the block label in parentheses is an indication
           that the end of the block is too far away to use the "J"
           instructions and a "B" transfer is required.
-
-
-
-
-
-
-
-
-
-
-
-
                                      - 9 -
1
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |    Ýlabel¨   |  EXIT     Ýslabel¨Ý,IF, exp¨              |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             One of the important things about structured programming
           is that it does not have any GOTO statements. Well, here is
           a GOTO statement in disguise. There are certain programming
           constructs which cannot be naturally handled by a sparse
           control structure such as that which HAL affords, so EXIT
           was added to fill in the gaps. Used properly, EXIT appears
           in two complimentary forms: one which defines a special
           condition handling block and one which conditionally
           transfers control to it. Consider the following "search"
           block construct:
-              SEARCH    BLOCK ,
               SCAN      DO    WHILE,(not end-of-chain)
                         prepare for test
                         EXIT  FOUND,IF,(entry is good)
                         prepare for next entry
                         BEND  SCAN
                         search failure code
               FOUND     EXIT
                         search success code
                         BEND  SEARCH
-             The first EXIT macro is the "verb" form (exit is used as
           a verb because it has an object, the positional parameter
           FOUND).  It is a disguised GOTO and transfers control
           conditionally to the label FOUND. The HAL macros do no
           checking on this label, so it can be any valid or invalid
           symbol. However, if you want to use EXIT in a kosher way,
           you generate the label with the "noun" form of the EXIT
           macro.  An example of the noun form is given in the second
           EXIT, which has no operands.  This form should be used only
           if the current nesting level is a BLOCK statement. The EXIT
           units should usually be gathered together at the end of the
           BLOCK just before the BEND, or before the EPILOG if the
           block has an EPILOG. Each EXIT expands to two statements: an
           unconditional jump to the BEND and a entry label statement.
           The only way to get into the EXIT clause is to use the verb
           form of EXIT to transfer control to this label.
-
-
-
                                      - 10 -
1
-
               B1        BLOCK EPILOG=YES
                         (block processing code)
                         (contains LEAVE B1,
                          EXIT E1, and EXIT E2 stmts)
               E1        EXIT  ,
               E2        EXIT  ,
                         EPILOG ,
                         BEND  B1
0             Note that the code in an EXIT block still transfers
           control to the EPILOG. The EXIT is in addition to the EPILOG
           and does not replace it.  On the Series/1, the first
           positional parameter "slabel" can be enclosed in parentheses
           if the transfer is too far away to use the "J" instructions
           and a "B" should be used instead. This include the noun form
           where
                name   EXIT   ()
           is used to introduce an exit unit where the end of the block
           is still far away.
-
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |    Ýblabel¨  |  IF      exp Ý,THEN¨                      |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             This macro begins an IF block. The logical expression is
           evaluated. If it proves false, control is transferred to the
           first ELSEIF or ELSE macro in the block if one exists,
           otherwise control is passed to the statement after the BEND
           which closes the block.  An optional "THEN" can be added
           after the logical expressions for appearences; it will be
           ignored.
0             There are three basic IF constructs. The simple IF-BEND
           has only one clause block. The IF-ELSE-BEND has two clauses,
           one if the expression evaluates true, the other if it is
           false.  The IF-ELSEIF-ELSEIF-...-ELSE-BEND clause has
           multiple logical tests. First the IF test is evaluated. If
           true, the code following IF is executed. Otherwise, control
           passes to the first ELSEIF and its test is evaluated. If it
           is true, the code following it is executed, otherwise
           control passes to the second ELSEIF and so on.  the ELSE, if
           present, will always be executed when all the tests fail.
-
-
                                      - 11 -
1
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |    Ýblabel¨  |  ELSEIF  exp Ý,THEN¨                      |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             This macro begins an ELSEIF clause of the IF block.  If
           the expression evaluates true, this clause will be executed.
           Otherwise, control passes to the next ELSEIF, or to the
           ELSE, or the the BEND, whichever comes next.
-
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |              |  ELSE                                     |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             This macro begins the "else" section of an IF block. It
           is optional in an IF block and illegal in any other context.
           The ELSE macro cannot have a label since it is part of the
           containing IF block and should not be branched to directly.
-
-
           Ð××××××××××××××××××××××××××××××××××××××××××××××××××××××××××¯
           |                                                          |
           |              |       INF                                 |
           |    Ýblabel¨  |  DO   WHILE  ,exp                         |
           |              |       UNTIL  ,exp                         |
           |                                                          |
           ¿××××××××××××××××××××××××××××××××××××××××××××××××××××××××××]
0             This macro produces a loop. If the INF option is chosen,
           the loop will be unconditional and must be terminated by
           executing a LEAVE statement. If the WHILE option is chosen,
           the expression is evaluated at the beginning of the first
           and each subsequent iteration of the loop and the loop is
           exited when the expression evaluates false. If the UNTIL
           option is chosen, the expression is evaluated before the
           second and each subsequent iteration of the loop, and exit
           occurs when the epression evaluates true.
-
-
                                      - 12 -
1
-
                                    HAL Logic
0             Since HAL is intended to be COPY'd into the beginning of
           an assembly program, it is designed to be relatively
           compact.  There is little additional commentary, so the
           program logic is described here.
0             All of the global variable symbols and internal macro
           names begin with the prefix "YCC" to avoid naming conflicts.
           The current block nesting level is maintained in the global
           symbol &YCCLVL. This is used to index into five global
           variable symbol arrays:
0             ® &YCCTYPE is an array of numeric block type codes. The
                type definitions are:
                         0 EPILOG
                         1 BLOCK
                         2 DO UNTIL
                         3 DO WHILE
                         4 IF or ELSEIF
                         5 other (ELSE or conditional LEAVE test)
0             ® &YCCBLK# is an numeric array indexed by nesting level
                containing the current block number within this level.
                One member of the array is incremented by 1 when a new
                block is generated. The ST and TS labels are generated
                with a suffix of &YCCLVL.@&YCCBLK#(&YCCLVL).
0             ® &YCCEN# is a numeric array identifying the current BEND
                label. Its elements are equal to &YCCBLK# for every
                program structure except an ELSEIF where &YCCEN# holds
                the block number of the original IF.
0             ® &YCCBLKN contains the name of the block at each nesting
                level.
0             ® &YCCEPLG is a logical variable indicating for a BLOCK
                block if an EPILOG is expected.
0             Since several macros begin a new block, there is an inner
           macro YCCPUSH which pushes down the stack, adding 1 to
           &YCCLVL and incrementing &YCCBLK#(&YCCLVL). All blocks end
           in a BEND, so the pop logic is processed there.
0             The logical expression evaluation and instruction
           generation is performed by inner macro YCCTEST. This macro
           knows what are the appropriate labels to use if the test
           comes from an IF, DO UNTIL, DO WHILE, or ELSEIF macro based
           on the current setting of &YCCTYPE(&YCCLVL).  However, when
           the request is coming from a conditional LEAVE or EXIT
           macro, it is necessary for the caller to provide the exit
           label in the global symbol &YCCGO.
-
                                      - 13 -
